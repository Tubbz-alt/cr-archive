<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LinearScan.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_CodeStubs.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_FrameMap.hpp&quot;
  30 #include &quot;c1/c1_IR.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_LinearScan.hpp&quot;
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;code/vmreg.inline.hpp&quot;
  35 #include &quot;runtime/timerTrace.hpp&quot;
  36 #include &quot;utilities/bitMap.inline.hpp&quot;
  37 
  38 #ifndef PRODUCT
  39 
  40   static LinearScanStatistic _stat_before_alloc;
  41   static LinearScanStatistic _stat_after_asign;
  42   static LinearScanStatistic _stat_final;
  43 
  44   static LinearScanTimers _total_timer;
  45 
  46   // helper macro for short definition of timer
  47   #define TIME_LINEAR_SCAN(timer_name)  TraceTime _block_timer(&quot;&quot;, _total_timer.timer(LinearScanTimers::timer_name), TimeLinearScan || TimeEachLinearScan, Verbose);
  48 
  49   // helper macro for short definition of trace-output inside code
  50   #define TRACE_LINEAR_SCAN(level, code)       \
  51     if (TraceLinearScanLevel &gt;= level) {       \
  52       code;                                    \
  53     }
  54 
  55 #else
  56 
  57   #define TIME_LINEAR_SCAN(timer_name)
  58   #define TRACE_LINEAR_SCAN(level, code)
  59 
  60 #endif
  61 
  62 // Map BasicType to spill size in 32-bit words, matching VMReg&#39;s notion of words
  63 #ifdef _LP64
  64 static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 0, 2,  1, 2, 1, -1};
  65 #else
  66 static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, 1, -1, 1, 1, -1};
  67 #endif
  68 
  69 
  70 // Implementation of LinearScan
  71 
  72 LinearScan::LinearScan(IR* ir, LIRGenerator* gen, FrameMap* frame_map)
  73  : _compilation(ir-&gt;compilation())
  74  , _ir(ir)
  75  , _gen(gen)
  76  , _frame_map(frame_map)
  77  , _cached_blocks(*ir-&gt;linear_scan_order())
  78  , _num_virtual_regs(gen-&gt;max_virtual_register_number())
  79  , _has_fpu_registers(false)
  80  , _num_calls(-1)
  81  , _max_spills(0)
  82  , _unused_spill_slot(-1)
  83  , _intervals(0)   // initialized later with correct length
  84  , _new_intervals_from_allocation(NULL)
  85  , _sorted_intervals(NULL)
  86  , _needs_full_resort(false)
  87  , _lir_ops(0)     // initialized later with correct length
  88  , _block_of_op(0) // initialized later with correct length
  89  , _has_info(0)
  90  , _has_call(0)
  91  , _interval_in_loop(0)  // initialized later with correct length
  92  , _scope_value_cache(0) // initialized later with correct length
<a name="1" id="anc1"></a><span class="line-modified">  93 #ifdef X86</span>
  94  , _fpu_stack_allocator(NULL)
  95 #endif
  96 {
  97   assert(this-&gt;ir() != NULL,          &quot;check if valid&quot;);
  98   assert(this-&gt;compilation() != NULL, &quot;check if valid&quot;);
  99   assert(this-&gt;gen() != NULL,         &quot;check if valid&quot;);
 100   assert(this-&gt;frame_map() != NULL,   &quot;check if valid&quot;);
 101 }
 102 
 103 
 104 // ********** functions for converting LIR-Operands to register numbers
 105 //
 106 // Emulate a flat register file comprising physical integer registers,
 107 // physical floating-point registers and virtual registers, in that order.
 108 // Virtual registers already have appropriate numbers, since V0 is
 109 // the number of physical registers.
 110 // Returns -1 for hi word if opr is a single word operand.
 111 //
 112 // Note: the inverse operation (calculating an operand for register numbers)
 113 //       is done in calc_operand_for_interval()
 114 
 115 int LinearScan::reg_num(LIR_Opr opr) {
 116   assert(opr-&gt;is_register(), &quot;should not call this otherwise&quot;);
 117 
 118   if (opr-&gt;is_virtual_register()) {
 119     assert(opr-&gt;vreg_number() &gt;= nof_regs, &quot;found a virtual register with a fixed-register number&quot;);
 120     return opr-&gt;vreg_number();
 121   } else if (opr-&gt;is_single_cpu()) {
 122     return opr-&gt;cpu_regnr();
 123   } else if (opr-&gt;is_double_cpu()) {
 124     return opr-&gt;cpu_regnrLo();
 125 #ifdef X86
 126   } else if (opr-&gt;is_single_xmm()) {
 127     return opr-&gt;fpu_regnr() + pd_first_xmm_reg;
 128   } else if (opr-&gt;is_double_xmm()) {
 129     return opr-&gt;fpu_regnrLo() + pd_first_xmm_reg;
 130 #endif
 131   } else if (opr-&gt;is_single_fpu()) {
 132     return opr-&gt;fpu_regnr() + pd_first_fpu_reg;
 133   } else if (opr-&gt;is_double_fpu()) {
 134     return opr-&gt;fpu_regnrLo() + pd_first_fpu_reg;
 135   } else {
 136     ShouldNotReachHere();
 137     return -1;
 138   }
 139 }
 140 
 141 int LinearScan::reg_numHi(LIR_Opr opr) {
 142   assert(opr-&gt;is_register(), &quot;should not call this otherwise&quot;);
 143 
 144   if (opr-&gt;is_virtual_register()) {
 145     return -1;
 146   } else if (opr-&gt;is_single_cpu()) {
 147     return -1;
 148   } else if (opr-&gt;is_double_cpu()) {
 149     return opr-&gt;cpu_regnrHi();
 150 #ifdef X86
 151   } else if (opr-&gt;is_single_xmm()) {
 152     return -1;
 153   } else if (opr-&gt;is_double_xmm()) {
 154     return -1;
 155 #endif
 156   } else if (opr-&gt;is_single_fpu()) {
 157     return -1;
 158   } else if (opr-&gt;is_double_fpu()) {
 159     return opr-&gt;fpu_regnrHi() + pd_first_fpu_reg;
 160   } else {
 161     ShouldNotReachHere();
 162     return -1;
 163   }
 164 }
 165 
 166 
 167 // ********** functions for classification of intervals
 168 
 169 bool LinearScan::is_precolored_interval(const Interval* i) {
 170   return i-&gt;reg_num() &lt; LinearScan::nof_regs;
 171 }
 172 
 173 bool LinearScan::is_virtual_interval(const Interval* i) {
 174   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base;
 175 }
 176 
 177 bool LinearScan::is_precolored_cpu_interval(const Interval* i) {
 178   return i-&gt;reg_num() &lt; LinearScan::nof_cpu_regs;
 179 }
 180 
 181 bool LinearScan::is_virtual_cpu_interval(const Interval* i) {
 182 #if defined(__SOFTFP__) || defined(E500V2)
 183   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base;
 184 #else
 185   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; (i-&gt;type() != T_FLOAT &amp;&amp; i-&gt;type() != T_DOUBLE);
 186 #endif // __SOFTFP__ or E500V2
 187 }
 188 
 189 bool LinearScan::is_precolored_fpu_interval(const Interval* i) {
 190   return i-&gt;reg_num() &gt;= LinearScan::nof_cpu_regs &amp;&amp; i-&gt;reg_num() &lt; LinearScan::nof_regs;
 191 }
 192 
 193 bool LinearScan::is_virtual_fpu_interval(const Interval* i) {
 194 #if defined(__SOFTFP__) || defined(E500V2)
 195   return false;
 196 #else
 197   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; (i-&gt;type() == T_FLOAT || i-&gt;type() == T_DOUBLE);
 198 #endif // __SOFTFP__ or E500V2
 199 }
 200 
 201 bool LinearScan::is_in_fpu_register(const Interval* i) {
 202   // fixed intervals not needed for FPU stack allocation
 203   return i-&gt;reg_num() &gt;= nof_regs &amp;&amp; pd_first_fpu_reg &lt;= i-&gt;assigned_reg() &amp;&amp; i-&gt;assigned_reg() &lt;= pd_last_fpu_reg;
 204 }
 205 
 206 bool LinearScan::is_oop_interval(const Interval* i) {
 207   // fixed intervals never contain oops
 208   return i-&gt;reg_num() &gt;= nof_regs &amp;&amp; i-&gt;type() == T_OBJECT;
 209 }
 210 
 211 
 212 // ********** General helper functions
 213 
 214 // compute next unused stack index that can be used for spilling
 215 int LinearScan::allocate_spill_slot(bool double_word) {
 216   int spill_slot;
 217   if (double_word) {
 218     if ((_max_spills &amp; 1) == 1) {
 219       // alignment of double-word values
 220       // the hole because of the alignment is filled with the next single-word value
 221       assert(_unused_spill_slot == -1, &quot;wasting a spill slot&quot;);
 222       _unused_spill_slot = _max_spills;
 223       _max_spills++;
 224     }
 225     spill_slot = _max_spills;
 226     _max_spills += 2;
 227 
 228   } else if (_unused_spill_slot != -1) {
 229     // re-use hole that was the result of a previous double-word alignment
 230     spill_slot = _unused_spill_slot;
 231     _unused_spill_slot = -1;
 232 
 233   } else {
 234     spill_slot = _max_spills;
 235     _max_spills++;
 236   }
 237 
 238   int result = spill_slot + LinearScan::nof_regs + frame_map()-&gt;argcount();
 239 
 240   // the class OopMapValue uses only 11 bits for storing the name of the
 241   // oop location. So a stack slot bigger than 2^11 leads to an overflow
 242   // that is not reported in product builds. Prevent this by checking the
 243   // spill slot here (altough this value and the later used location name
 244   // are slightly different)
 245   if (result &gt; 2000) {
 246     bailout(&quot;too many stack slots used&quot;);
 247   }
 248 
 249   return result;
 250 }
 251 
 252 void LinearScan::assign_spill_slot(Interval* it) {
 253   // assign the canonical spill slot of the parent (if a part of the interval
 254   // is already spilled) or allocate a new spill slot
 255   if (it-&gt;canonical_spill_slot() &gt;= 0) {
 256     it-&gt;assign_reg(it-&gt;canonical_spill_slot());
 257   } else {
 258     int spill = allocate_spill_slot(type2spill_size[it-&gt;type()] == 2);
 259     it-&gt;set_canonical_spill_slot(spill);
 260     it-&gt;assign_reg(spill);
 261   }
 262 }
 263 
 264 void LinearScan::propagate_spill_slots() {
 265   if (!frame_map()-&gt;finalize_frame(max_spills())) {
 266     bailout(&quot;frame too large&quot;);
 267   }
 268 }
 269 
 270 // create a new interval with a predefined reg_num
 271 // (only used for parent intervals that are created during the building phase)
 272 Interval* LinearScan::create_interval(int reg_num) {
 273   assert(_intervals.at(reg_num) == NULL, &quot;overwriting exisiting interval&quot;);
 274 
 275   Interval* interval = new Interval(reg_num);
 276   _intervals.at_put(reg_num, interval);
 277 
 278   // assign register number for precolored intervals
 279   if (reg_num &lt; LIR_OprDesc::vreg_base) {
 280     interval-&gt;assign_reg(reg_num);
 281   }
 282   return interval;
 283 }
 284 
 285 // assign a new reg_num to the interval and append it to the list of intervals
 286 // (only used for child intervals that are created during register allocation)
 287 void LinearScan::append_interval(Interval* it) {
 288   it-&gt;set_reg_num(_intervals.length());
 289   _intervals.append(it);
 290   IntervalList* new_intervals = _new_intervals_from_allocation;
 291   if (new_intervals == NULL) {
 292     new_intervals = _new_intervals_from_allocation = new IntervalList();
 293   }
 294   new_intervals-&gt;append(it);
 295 }
 296 
 297 // copy the vreg-flags if an interval is split
 298 void LinearScan::copy_register_flags(Interval* from, Interval* to) {
 299   if (gen()-&gt;is_vreg_flag_set(from-&gt;reg_num(), LIRGenerator::byte_reg)) {
 300     gen()-&gt;set_vreg_flag(to-&gt;reg_num(), LIRGenerator::byte_reg);
 301   }
 302   if (gen()-&gt;is_vreg_flag_set(from-&gt;reg_num(), LIRGenerator::callee_saved)) {
 303     gen()-&gt;set_vreg_flag(to-&gt;reg_num(), LIRGenerator::callee_saved);
 304   }
 305 
 306   // Note: do not copy the must_start_in_memory flag because it is not necessary for child
 307   //       intervals (only the very beginning of the interval must be in memory)
 308 }
 309 
 310 
 311 // ********** spill move optimization
 312 // eliminate moves from register to stack if stack slot is known to be correct
 313 
 314 // called during building of intervals
 315 void LinearScan::change_spill_definition_pos(Interval* interval, int def_pos) {
 316   assert(interval-&gt;is_split_parent(), &quot;can only be called for split parents&quot;);
 317 
 318   switch (interval-&gt;spill_state()) {
 319     case noDefinitionFound:
 320       assert(interval-&gt;spill_definition_pos() == -1, &quot;must no be set before&quot;);
 321       interval-&gt;set_spill_definition_pos(def_pos);
 322       interval-&gt;set_spill_state(oneDefinitionFound);
 323       break;
 324 
 325     case oneDefinitionFound:
 326       assert(def_pos &lt;= interval-&gt;spill_definition_pos(), &quot;positions are processed in reverse order when intervals are created&quot;);
 327       if (def_pos &lt; interval-&gt;spill_definition_pos() - 2) {
 328         // second definition found, so no spill optimization possible for this interval
 329         interval-&gt;set_spill_state(noOptimization);
 330       } else {
 331         // two consecutive definitions (because of two-operand LIR form)
 332         assert(block_of_op_with_id(def_pos) == block_of_op_with_id(interval-&gt;spill_definition_pos()), &quot;block must be equal&quot;);
 333       }
 334       break;
 335 
 336     case noOptimization:
 337       // nothing to do
 338       break;
 339 
 340     default:
 341       assert(false, &quot;other states not allowed at this time&quot;);
 342   }
 343 }
 344 
 345 // called during register allocation
 346 void LinearScan::change_spill_state(Interval* interval, int spill_pos) {
 347   switch (interval-&gt;spill_state()) {
 348     case oneDefinitionFound: {
 349       int def_loop_depth = block_of_op_with_id(interval-&gt;spill_definition_pos())-&gt;loop_depth();
 350       int spill_loop_depth = block_of_op_with_id(spill_pos)-&gt;loop_depth();
 351 
 352       if (def_loop_depth &lt; spill_loop_depth) {
 353         // the loop depth of the spilling position is higher then the loop depth
 354         // at the definition of the interval -&gt; move write to memory out of loop
 355         // by storing at definitin of the interval
 356         interval-&gt;set_spill_state(storeAtDefinition);
 357       } else {
 358         // the interval is currently spilled only once, so for now there is no
 359         // reason to store the interval at the definition
 360         interval-&gt;set_spill_state(oneMoveInserted);
 361       }
 362       break;
 363     }
 364 
 365     case oneMoveInserted: {
 366       // the interval is spilled more then once, so it is better to store it to
 367       // memory at the definition
 368       interval-&gt;set_spill_state(storeAtDefinition);
 369       break;
 370     }
 371 
 372     case storeAtDefinition:
 373     case startInMemory:
 374     case noOptimization:
 375     case noDefinitionFound:
 376       // nothing to do
 377       break;
 378 
 379     default:
 380       assert(false, &quot;other states not allowed at this time&quot;);
 381   }
 382 }
 383 
 384 
 385 bool LinearScan::must_store_at_definition(const Interval* i) {
 386   return i-&gt;is_split_parent() &amp;&amp; i-&gt;spill_state() == storeAtDefinition;
 387 }
 388 
 389 // called once before asignment of register numbers
 390 void LinearScan::eliminate_spill_moves() {
 391   TIME_LINEAR_SCAN(timer_eliminate_spill_moves);
 392   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;***** Eliminating unnecessary spill moves&quot;));
 393 
 394   // collect all intervals that must be stored after their definion.
 395   // the list is sorted by Interval::spill_definition_pos
 396   Interval* interval;
 397   Interval* temp_list;
 398   create_unhandled_lists(&amp;interval, &amp;temp_list, must_store_at_definition, NULL);
 399 
 400 #ifdef ASSERT
 401   Interval* prev = NULL;
 402   Interval* temp = interval;
 403   while (temp != Interval::end()) {
 404     assert(temp-&gt;spill_definition_pos() &gt; 0, &quot;invalid spill definition pos&quot;);
 405     if (prev != NULL) {
 406       assert(temp-&gt;from() &gt;= prev-&gt;from(), &quot;intervals not sorted&quot;);
 407       assert(temp-&gt;spill_definition_pos() &gt;= prev-&gt;spill_definition_pos(), &quot;when intervals are sorted by from, then they must also be sorted by spill_definition_pos&quot;);
 408     }
 409 
 410     assert(temp-&gt;canonical_spill_slot() &gt;= LinearScan::nof_regs, &quot;interval has no spill slot assigned&quot;);
 411     assert(temp-&gt;spill_definition_pos() &gt;= temp-&gt;from(), &quot;invalid order&quot;);
 412     assert(temp-&gt;spill_definition_pos() &lt;= temp-&gt;from() + 2, &quot;only intervals defined once at their start-pos can be optimized&quot;);
 413 
 414     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;interval %d (from %d to %d) must be stored at %d&quot;, temp-&gt;reg_num(), temp-&gt;from(), temp-&gt;to(), temp-&gt;spill_definition_pos()));
 415 
 416     temp = temp-&gt;next();
 417   }
 418 #endif
 419 
 420   LIR_InsertionBuffer insertion_buffer;
 421   int num_blocks = block_count();
 422   for (int i = 0; i &lt; num_blocks; i++) {
 423     BlockBegin* block = block_at(i);
 424     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 425     int         num_inst = instructions-&gt;length();
 426     bool        has_new = false;
 427 
 428     // iterate all instructions of the block. skip the first because it is always a label
 429     for (int j = 1; j &lt; num_inst; j++) {
 430       LIR_Op* op = instructions-&gt;at(j);
 431       int op_id = op-&gt;id();
 432 
 433       if (op_id == -1) {
 434         // remove move from register to stack if the stack slot is guaranteed to be correct.
 435         // only moves that have been inserted by LinearScan can be removed.
 436         assert(op-&gt;code() == lir_move, &quot;only moves can have a op_id of -1&quot;);
 437         assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
 438         assert(op-&gt;as_Op1()-&gt;result_opr()-&gt;is_virtual(), &quot;LinearScan inserts only moves to virtual registers&quot;);
 439 
 440         LIR_Op1* op1 = (LIR_Op1*)op;
 441         Interval* interval = interval_at(op1-&gt;result_opr()-&gt;vreg_number());
 442 
 443         if (interval-&gt;assigned_reg() &gt;= LinearScan::nof_regs &amp;&amp; interval-&gt;always_in_memory()) {
 444           // move target is a stack slot that is always correct, so eliminate instruction
 445           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;eliminating move from interval %d to %d&quot;, op1-&gt;in_opr()-&gt;vreg_number(), op1-&gt;result_opr()-&gt;vreg_number()));
 446           instructions-&gt;at_put(j, NULL); // NULL-instructions are deleted by assign_reg_num
 447         }
 448 
 449       } else {
 450         // insert move from register to stack just after the beginning of the interval
 451         assert(interval == Interval::end() || interval-&gt;spill_definition_pos() &gt;= op_id, &quot;invalid order&quot;);
 452         assert(interval == Interval::end() || (interval-&gt;is_split_parent() &amp;&amp; interval-&gt;spill_state() == storeAtDefinition), &quot;invalid interval&quot;);
 453 
 454         while (interval != Interval::end() &amp;&amp; interval-&gt;spill_definition_pos() == op_id) {
 455           if (!has_new) {
 456             // prepare insertion buffer (appended when all instructions of the block are processed)
 457             insertion_buffer.init(block-&gt;lir());
 458             has_new = true;
 459           }
 460 
 461           LIR_Opr from_opr = operand_for_interval(interval);
 462           LIR_Opr to_opr = canonical_spill_opr(interval);
 463           assert(from_opr-&gt;is_fixed_cpu() || from_opr-&gt;is_fixed_fpu(), &quot;from operand must be a register&quot;);
 464           assert(to_opr-&gt;is_stack(), &quot;to operand must be a stack slot&quot;);
 465 
 466           insertion_buffer.move(j, from_opr, to_opr);
 467           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting move after definition of interval %d to stack slot %d at op_id %d&quot;, interval-&gt;reg_num(), interval-&gt;canonical_spill_slot() - LinearScan::nof_regs, op_id));
 468 
 469           interval = interval-&gt;next();
 470         }
 471       }
 472     } // end of instruction iteration
 473 
 474     if (has_new) {
 475       block-&gt;lir()-&gt;append(&amp;insertion_buffer);
 476     }
 477   } // end of block iteration
 478 
 479   assert(interval == Interval::end(), &quot;missed an interval&quot;);
 480 }
 481 
 482 
 483 // ********** Phase 1: number all instructions in all blocks
 484 // Compute depth-first and linear scan block orders, and number LIR_Op nodes for linear scan.
 485 
 486 void LinearScan::number_instructions() {
 487   {
 488     // dummy-timer to measure the cost of the timer itself
 489     // (this time is then subtracted from all other timers to get the real value)
 490     TIME_LINEAR_SCAN(timer_do_nothing);
 491   }
 492   TIME_LINEAR_SCAN(timer_number_instructions);
 493 
 494   // Assign IDs to LIR nodes and build a mapping, lir_ops, from ID to LIR_Op node.
 495   int num_blocks = block_count();
 496   int num_instructions = 0;
 497   int i;
 498   for (i = 0; i &lt; num_blocks; i++) {
 499     num_instructions += block_at(i)-&gt;lir()-&gt;instructions_list()-&gt;length();
 500   }
 501 
 502   // initialize with correct length
 503   _lir_ops = LIR_OpArray(num_instructions, num_instructions, NULL);
 504   _block_of_op = BlockBeginArray(num_instructions, num_instructions, NULL);
 505 
 506   int op_id = 0;
 507   int idx = 0;
 508 
 509   for (i = 0; i &lt; num_blocks; i++) {
 510     BlockBegin* block = block_at(i);
 511     block-&gt;set_first_lir_instruction_id(op_id);
 512     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 513 
 514     int num_inst = instructions-&gt;length();
 515     for (int j = 0; j &lt; num_inst; j++) {
 516       LIR_Op* op = instructions-&gt;at(j);
 517       op-&gt;set_id(op_id);
 518 
 519       _lir_ops.at_put(idx, op);
 520       _block_of_op.at_put(idx, block);
 521       assert(lir_op_with_id(op_id) == op, &quot;must match&quot;);
 522 
 523       idx++;
 524       op_id += 2; // numbering of lir_ops by two
 525     }
 526     block-&gt;set_last_lir_instruction_id(op_id - 2);
 527   }
 528   assert(idx == num_instructions, &quot;must match&quot;);
 529   assert(idx * 2 == op_id, &quot;must match&quot;);
 530 
 531   _has_call.initialize(num_instructions);
 532   _has_info.initialize(num_instructions);
 533 }
 534 
 535 
 536 // ********** Phase 2: compute local live sets separately for each block
 537 // (sets live_gen and live_kill for each block)
 538 
 539 void LinearScan::set_live_gen_kill(Value value, LIR_Op* op, BitMap&amp; live_gen, BitMap&amp; live_kill) {
 540   LIR_Opr opr = value-&gt;operand();
 541   Constant* con = value-&gt;as_Constant();
 542 
 543   // check some asumptions about debug information
 544   assert(!value-&gt;type()-&gt;is_illegal(), &quot;if this local is used by the interpreter it shouldn&#39;t be of indeterminate type&quot;);
 545   assert(con == NULL || opr-&gt;is_virtual() || opr-&gt;is_constant() || opr-&gt;is_illegal(), &quot;asumption: Constant instructions have only constant operands&quot;);
 546   assert(con != NULL || opr-&gt;is_virtual(), &quot;asumption: non-Constant instructions have only virtual operands&quot;);
 547 
 548   if ((con == NULL || con-&gt;is_pinned()) &amp;&amp; opr-&gt;is_register()) {
 549     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 550     int reg = opr-&gt;vreg_number();
 551     if (!live_kill.at(reg)) {
 552       live_gen.set_bit(reg);
 553       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;  Setting live_gen for value %c%d, LIR op_id %d, register number %d&quot;, value-&gt;type()-&gt;tchar(), value-&gt;id(), op-&gt;id(), reg));
 554     }
 555   }
 556 }
 557 
 558 
 559 void LinearScan::compute_local_live_sets() {
 560   TIME_LINEAR_SCAN(timer_compute_local_live_sets);
 561 
 562   int  num_blocks = block_count();
 563   int  live_size = live_set_size();
 564   bool local_has_fpu_registers = false;
 565   int  local_num_calls = 0;
 566   LIR_OpVisitState visitor;
 567 
 568   BitMap2D local_interval_in_loop = BitMap2D(_num_virtual_regs, num_loops());
 569 
 570   // iterate all blocks
 571   for (int i = 0; i &lt; num_blocks; i++) {
 572     BlockBegin* block = block_at(i);
 573 
 574     ResourceBitMap live_gen(live_size);
 575     ResourceBitMap live_kill(live_size);
 576 
 577     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 578       // Phi functions at the begin of an exception handler are
 579       // implicitly defined (= killed) at the beginning of the block.
 580       for_each_phi_fun(block, phi,
 581         if (!phi-&gt;is_illegal()) { live_kill.set_bit(phi-&gt;operand()-&gt;vreg_number()); }
 582       );
 583     }
 584 
 585     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 586     int num_inst = instructions-&gt;length();
 587 
 588     // iterate all instructions of the block. skip the first because it is always a label
 589     assert(visitor.no_operands(instructions-&gt;at(0)), &quot;first operation must always be a label&quot;);
 590     for (int j = 1; j &lt; num_inst; j++) {
 591       LIR_Op* op = instructions-&gt;at(j);
 592 
 593       // visit operation to collect all operands
 594       visitor.visit(op);
 595 
 596       if (visitor.has_call()) {
 597         _has_call.set_bit(op-&gt;id() &gt;&gt; 1);
 598         local_num_calls++;
 599       }
 600       if (visitor.info_count() &gt; 0) {
 601         _has_info.set_bit(op-&gt;id() &gt;&gt; 1);
 602       }
 603 
 604       // iterate input operands of instruction
 605       int k, n, reg;
 606       n = visitor.opr_count(LIR_OpVisitState::inputMode);
 607       for (k = 0; k &lt; n; k++) {
 608         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
 609         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 610 
 611         if (opr-&gt;is_virtual_register()) {
 612           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 613           reg = opr-&gt;vreg_number();
 614           if (!live_kill.at(reg)) {
 615             live_gen.set_bit(reg);
 616             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;  Setting live_gen for register %d at instruction %d&quot;, reg, op-&gt;id()));
 617           }
 618           if (block-&gt;loop_index() &gt;= 0) {
 619             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 620           }
 621           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 622         }
 623 
 624 #ifdef ASSERT
 625         // fixed intervals are never live at block boundaries, so
 626         // they need not be processed in live sets.
 627         // this is checked by these assertions to be sure about it.
 628         // the entry block may have incoming values in registers, which is ok.
 629         if (!opr-&gt;is_virtual_register() &amp;&amp; block != ir()-&gt;start()) {
 630           reg = reg_num(opr);
 631           if (is_processed_reg_num(reg)) {
 632             assert(live_kill.at(reg), &quot;using fixed register that is not defined in this block&quot;);
 633           }
 634           reg = reg_numHi(opr);
 635           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 636             assert(live_kill.at(reg), &quot;using fixed register that is not defined in this block&quot;);
 637           }
 638         }
 639 #endif
 640       }
 641 
 642       // Add uses of live locals from interpreter&#39;s point of view for proper debug information generation
 643       n = visitor.info_count();
 644       for (k = 0; k &lt; n; k++) {
 645         CodeEmitInfo* info = visitor.info_at(k);
 646         ValueStack* stack = info-&gt;stack();
 647         for_each_state_value(stack, value,
 648           set_live_gen_kill(value, op, live_gen, live_kill)
 649         );
 650       }
 651 
 652       // iterate temp operands of instruction
 653       n = visitor.opr_count(LIR_OpVisitState::tempMode);
 654       for (k = 0; k &lt; n; k++) {
 655         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
 656         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 657 
 658         if (opr-&gt;is_virtual_register()) {
 659           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 660           reg = opr-&gt;vreg_number();
 661           live_kill.set_bit(reg);
 662           if (block-&gt;loop_index() &gt;= 0) {
 663             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 664           }
 665           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 666         }
 667 
 668 #ifdef ASSERT
 669         // fixed intervals are never live at block boundaries, so
 670         // they need not be processed in live sets
 671         // process them only in debug mode so that this can be checked
 672         if (!opr-&gt;is_virtual_register()) {
 673           reg = reg_num(opr);
 674           if (is_processed_reg_num(reg)) {
 675             live_kill.set_bit(reg_num(opr));
 676           }
 677           reg = reg_numHi(opr);
 678           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 679             live_kill.set_bit(reg);
 680           }
 681         }
 682 #endif
 683       }
 684 
 685       // iterate output operands of instruction
 686       n = visitor.opr_count(LIR_OpVisitState::outputMode);
 687       for (k = 0; k &lt; n; k++) {
 688         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
 689         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 690 
 691         if (opr-&gt;is_virtual_register()) {
 692           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 693           reg = opr-&gt;vreg_number();
 694           live_kill.set_bit(reg);
 695           if (block-&gt;loop_index() &gt;= 0) {
 696             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 697           }
 698           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 699         }
 700 
 701 #ifdef ASSERT
 702         // fixed intervals are never live at block boundaries, so
 703         // they need not be processed in live sets
 704         // process them only in debug mode so that this can be checked
 705         if (!opr-&gt;is_virtual_register()) {
 706           reg = reg_num(opr);
 707           if (is_processed_reg_num(reg)) {
 708             live_kill.set_bit(reg_num(opr));
 709           }
 710           reg = reg_numHi(opr);
 711           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 712             live_kill.set_bit(reg);
 713           }
 714         }
 715 #endif
 716       }
 717     } // end of instruction iteration
 718 
 719     block-&gt;set_live_gen (live_gen);
 720     block-&gt;set_live_kill(live_kill);
 721     block-&gt;set_live_in  (ResourceBitMap(live_size));
 722     block-&gt;set_live_out (ResourceBitMap(live_size));
 723 
 724     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;live_gen  B%d &quot;, block-&gt;block_id()); print_bitmap(block-&gt;live_gen()));
 725     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;live_kill B%d &quot;, block-&gt;block_id()); print_bitmap(block-&gt;live_kill()));
 726   } // end of block iteration
 727 
 728   // propagate local calculated information into LinearScan object
 729   _has_fpu_registers = local_has_fpu_registers;
 730   compilation()-&gt;set_has_fpu_code(local_has_fpu_registers);
 731 
 732   _num_calls = local_num_calls;
 733   _interval_in_loop = local_interval_in_loop;
 734 }
 735 
 736 
 737 // ********** Phase 3: perform a backward dataflow analysis to compute global live sets
 738 // (sets live_in and live_out for each block)
 739 
 740 void LinearScan::compute_global_live_sets() {
 741   TIME_LINEAR_SCAN(timer_compute_global_live_sets);
 742 
 743   int  num_blocks = block_count();
 744   bool change_occurred;
 745   bool change_occurred_in_block;
 746   int  iteration_count = 0;
 747   ResourceBitMap live_out(live_set_size()); // scratch set for calculations
 748 
 749   // Perform a backward dataflow analysis to compute live_out and live_in for each block.
 750   // The loop is executed until a fixpoint is reached (no changes in an iteration)
 751   // Exception handlers must be processed because not all live values are
 752   // present in the state array, e.g. because of global value numbering
 753   do {
 754     change_occurred = false;
 755 
 756     // iterate all blocks in reverse order
 757     for (int i = num_blocks - 1; i &gt;= 0; i--) {
 758       BlockBegin* block = block_at(i);
 759 
 760       change_occurred_in_block = false;
 761 
 762       // live_out(block) is the union of live_in(sux), for successors sux of block
 763       int n = block-&gt;number_of_sux();
 764       int e = block-&gt;number_of_exception_handlers();
 765       if (n + e &gt; 0) {
 766         // block has successors
 767         if (n &gt; 0) {
 768           live_out.set_from(block-&gt;sux_at(0)-&gt;live_in());
 769           for (int j = 1; j &lt; n; j++) {
 770             live_out.set_union(block-&gt;sux_at(j)-&gt;live_in());
 771           }
 772         } else {
 773           live_out.clear();
 774         }
 775         for (int j = 0; j &lt; e; j++) {
 776           live_out.set_union(block-&gt;exception_handler_at(j)-&gt;live_in());
 777         }
 778 
 779         if (!block-&gt;live_out().is_same(live_out)) {
 780           // A change occurred.  Swap the old and new live out sets to avoid copying.
 781           ResourceBitMap temp = block-&gt;live_out();
 782           block-&gt;set_live_out(live_out);
 783           live_out = temp;
 784 
 785           change_occurred = true;
 786           change_occurred_in_block = true;
 787         }
 788       }
 789 
 790       if (iteration_count == 0 || change_occurred_in_block) {
 791         // live_in(block) is the union of live_gen(block) with (live_out(block) &amp; !live_kill(block))
 792         // note: live_in has to be computed only in first iteration or if live_out has changed!
 793         ResourceBitMap live_in = block-&gt;live_in();
 794         live_in.set_from(block-&gt;live_out());
 795         live_in.set_difference(block-&gt;live_kill());
 796         live_in.set_union(block-&gt;live_gen());
 797       }
 798 
 799 #ifndef PRODUCT
 800       if (TraceLinearScanLevel &gt;= 4) {
 801         char c = &#39; &#39;;
 802         if (iteration_count == 0 || change_occurred_in_block) {
 803           c = &#39;*&#39;;
 804         }
 805         tty-&gt;print(&quot;(%d) live_in%c  B%d &quot;, iteration_count, c, block-&gt;block_id()); print_bitmap(block-&gt;live_in());
 806         tty-&gt;print(&quot;(%d) live_out%c B%d &quot;, iteration_count, c, block-&gt;block_id()); print_bitmap(block-&gt;live_out());
 807       }
 808 #endif
 809     }
 810     iteration_count++;
 811 
 812     if (change_occurred &amp;&amp; iteration_count &gt; 50) {
 813       BAILOUT(&quot;too many iterations in compute_global_live_sets&quot;);
 814     }
 815   } while (change_occurred);
 816 
 817 
 818 #ifdef ASSERT
 819   // check that fixed intervals are not live at block boundaries
 820   // (live set must be empty at fixed intervals)
 821   for (int i = 0; i &lt; num_blocks; i++) {
 822     BlockBegin* block = block_at(i);
 823     for (int j = 0; j &lt; LIR_OprDesc::vreg_base; j++) {
 824       assert(block-&gt;live_in().at(j)  == false, &quot;live_in  set of fixed register must be empty&quot;);
 825       assert(block-&gt;live_out().at(j) == false, &quot;live_out set of fixed register must be empty&quot;);
 826       assert(block-&gt;live_gen().at(j) == false, &quot;live_gen set of fixed register must be empty&quot;);
 827     }
 828   }
 829 #endif
 830 
 831   // check that the live_in set of the first block is empty
 832   ResourceBitMap live_in_args(ir()-&gt;start()-&gt;live_in().size());
 833   if (!ir()-&gt;start()-&gt;live_in().is_same(live_in_args)) {
 834 #ifdef ASSERT
 835     tty-&gt;print_cr(&quot;Error: live_in set of first block must be empty (when this fails, virtual registers are used before they are defined)&quot;);
 836     tty-&gt;print_cr(&quot;affected registers:&quot;);
 837     print_bitmap(ir()-&gt;start()-&gt;live_in());
 838 
 839     // print some additional information to simplify debugging
 840     for (unsigned int i = 0; i &lt; ir()-&gt;start()-&gt;live_in().size(); i++) {
 841       if (ir()-&gt;start()-&gt;live_in().at(i)) {
 842         Instruction* instr = gen()-&gt;instruction_for_vreg(i);
 843         tty-&gt;print_cr(&quot;* vreg %d (HIR instruction %c%d)&quot;, i, instr == NULL ? &#39; &#39; : instr-&gt;type()-&gt;tchar(), instr == NULL ? 0 : instr-&gt;id());
 844 
 845         for (int j = 0; j &lt; num_blocks; j++) {
 846           BlockBegin* block = block_at(j);
 847           if (block-&gt;live_gen().at(i)) {
 848             tty-&gt;print_cr(&quot;  used in block B%d&quot;, block-&gt;block_id());
 849           }
 850           if (block-&gt;live_kill().at(i)) {
 851             tty-&gt;print_cr(&quot;  defined in block B%d&quot;, block-&gt;block_id());
 852           }
 853         }
 854       }
 855     }
 856 
 857 #endif
 858     // when this fails, virtual registers are used before they are defined.
 859     assert(false, &quot;live_in set of first block must be empty&quot;);
 860     // bailout of if this occurs in product mode.
 861     bailout(&quot;live_in set of first block not empty&quot;);
 862   }
 863 }
 864 
 865 
 866 // ********** Phase 4: build intervals
 867 // (fills the list _intervals)
 868 
 869 void LinearScan::add_use(Value value, int from, int to, IntervalUseKind use_kind) {
 870   assert(!value-&gt;type()-&gt;is_illegal(), &quot;if this value is used by the interpreter it shouldn&#39;t be of indeterminate type&quot;);
 871   LIR_Opr opr = value-&gt;operand();
 872   Constant* con = value-&gt;as_Constant();
 873 
 874   if ((con == NULL || con-&gt;is_pinned()) &amp;&amp; opr-&gt;is_register()) {
 875     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 876     add_use(opr, from, to, use_kind);
 877   }
 878 }
 879 
 880 
 881 void LinearScan::add_def(LIR_Opr opr, int def_pos, IntervalUseKind use_kind) {
 882   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; def &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; def_pos %d (%d)&quot;, def_pos, use_kind));
 883   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 884 
 885   if (opr-&gt;is_virtual_register()) {
 886     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 887     add_def(opr-&gt;vreg_number(), def_pos, use_kind, opr-&gt;type_register());
 888 
 889   } else {
 890     int reg = reg_num(opr);
 891     if (is_processed_reg_num(reg)) {
 892       add_def(reg, def_pos, use_kind, opr-&gt;type_register());
 893     }
 894     reg = reg_numHi(opr);
 895     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 896       add_def(reg, def_pos, use_kind, opr-&gt;type_register());
 897     }
 898   }
 899 }
 900 
 901 void LinearScan::add_use(LIR_Opr opr, int from, int to, IntervalUseKind use_kind) {
 902   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; use &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; from %d to %d (%d)&quot;, from, to, use_kind));
 903   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 904 
 905   if (opr-&gt;is_virtual_register()) {
 906     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 907     add_use(opr-&gt;vreg_number(), from, to, use_kind, opr-&gt;type_register());
 908 
 909   } else {
 910     int reg = reg_num(opr);
 911     if (is_processed_reg_num(reg)) {
 912       add_use(reg, from, to, use_kind, opr-&gt;type_register());
 913     }
 914     reg = reg_numHi(opr);
 915     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 916       add_use(reg, from, to, use_kind, opr-&gt;type_register());
 917     }
 918   }
 919 }
 920 
 921 void LinearScan::add_temp(LIR_Opr opr, int temp_pos, IntervalUseKind use_kind) {
 922   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; temp &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; temp_pos %d (%d)&quot;, temp_pos, use_kind));
 923   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 924 
 925   if (opr-&gt;is_virtual_register()) {
 926     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 927     add_temp(opr-&gt;vreg_number(), temp_pos, use_kind, opr-&gt;type_register());
 928 
 929   } else {
 930     int reg = reg_num(opr);
 931     if (is_processed_reg_num(reg)) {
 932       add_temp(reg, temp_pos, use_kind, opr-&gt;type_register());
 933     }
 934     reg = reg_numHi(opr);
 935     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 936       add_temp(reg, temp_pos, use_kind, opr-&gt;type_register());
 937     }
 938   }
 939 }
 940 
 941 
 942 void LinearScan::add_def(int reg_num, int def_pos, IntervalUseKind use_kind, BasicType type) {
 943   Interval* interval = interval_at(reg_num);
 944   if (interval != NULL) {
 945     assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
 946 
 947     if (type != T_ILLEGAL) {
 948       interval-&gt;set_type(type);
 949     }
 950 
 951     Range* r = interval-&gt;first();
 952     if (r-&gt;from() &lt;= def_pos) {
 953       // Update the starting point (when a range is first created for a use, its
 954       // start is the beginning of the current block until a def is encountered.)
 955       r-&gt;set_from(def_pos);
 956       interval-&gt;add_use_pos(def_pos, use_kind);
 957 
 958     } else {
 959       // Dead value - make vacuous interval
 960       // also add use_kind for dead intervals
 961       interval-&gt;add_range(def_pos, def_pos + 1);
 962       interval-&gt;add_use_pos(def_pos, use_kind);
 963       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;Warning: def of reg %d at %d occurs without use&quot;, reg_num, def_pos));
 964     }
 965 
 966   } else {
 967     // Dead value - make vacuous interval
 968     // also add use_kind for dead intervals
 969     interval = create_interval(reg_num);
 970     if (type != T_ILLEGAL) {
 971       interval-&gt;set_type(type);
 972     }
 973 
 974     interval-&gt;add_range(def_pos, def_pos + 1);
 975     interval-&gt;add_use_pos(def_pos, use_kind);
 976     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;Warning: dead value %d at %d in live intervals&quot;, reg_num, def_pos));
 977   }
 978 
 979   change_spill_definition_pos(interval, def_pos);
 980   if (use_kind == noUse &amp;&amp; interval-&gt;spill_state() &lt;= startInMemory) {
 981         // detection of method-parameters and roundfp-results
 982         // TODO: move this directly to position where use-kind is computed
 983     interval-&gt;set_spill_state(startInMemory);
 984   }
 985 }
 986 
 987 void LinearScan::add_use(int reg_num, int from, int to, IntervalUseKind use_kind, BasicType type) {
 988   Interval* interval = interval_at(reg_num);
 989   if (interval == NULL) {
 990     interval = create_interval(reg_num);
 991   }
 992   assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
 993 
 994   if (type != T_ILLEGAL) {
 995     interval-&gt;set_type(type);
 996   }
 997 
 998   interval-&gt;add_range(from, to);
 999   interval-&gt;add_use_pos(to, use_kind);
1000 }
1001 
1002 void LinearScan::add_temp(int reg_num, int temp_pos, IntervalUseKind use_kind, BasicType type) {
1003   Interval* interval = interval_at(reg_num);
1004   if (interval == NULL) {
1005     interval = create_interval(reg_num);
1006   }
1007   assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
1008 
1009   if (type != T_ILLEGAL) {
1010     interval-&gt;set_type(type);
1011   }
1012 
1013   interval-&gt;add_range(temp_pos, temp_pos + 1);
1014   interval-&gt;add_use_pos(temp_pos, use_kind);
1015 }
1016 
1017 
1018 // the results of this functions are used for optimizing spilling and reloading
1019 // if the functions return shouldHaveRegister and the interval is spilled,
1020 // it is not reloaded to a register.
1021 IntervalUseKind LinearScan::use_kind_of_output_operand(LIR_Op* op, LIR_Opr opr) {
1022   if (op-&gt;code() == lir_move) {
1023     assert(op-&gt;as_Op1() != NULL, &quot;lir_move must be LIR_Op1&quot;);
1024     LIR_Op1* move = (LIR_Op1*)op;
1025     LIR_Opr res = move-&gt;result_opr();
1026     bool result_in_memory = res-&gt;is_virtual() &amp;&amp; gen()-&gt;is_vreg_flag_set(res-&gt;vreg_number(), LIRGenerator::must_start_in_memory);
1027 
1028     if (result_in_memory) {
1029       // Begin of an interval with must_start_in_memory set.
1030       // This interval will always get a stack slot first, so return noUse.
1031       return noUse;
1032 
1033     } else if (move-&gt;in_opr()-&gt;is_stack()) {
1034       // method argument (condition must be equal to handle_method_arguments)
1035       return noUse;
1036 
1037     } else if (move-&gt;in_opr()-&gt;is_register() &amp;&amp; move-&gt;result_opr()-&gt;is_register()) {
1038       // Move from register to register
1039       if (block_of_op_with_id(op-&gt;id())-&gt;is_set(BlockBegin::osr_entry_flag)) {
1040         // special handling of phi-function moves inside osr-entry blocks
1041         // input operand must have a register instead of output operand (leads to better register allocation)
1042         return shouldHaveRegister;
1043       }
1044     }
1045   }
1046 
1047   if (opr-&gt;is_virtual() &amp;&amp;
1048       gen()-&gt;is_vreg_flag_set(opr-&gt;vreg_number(), LIRGenerator::must_start_in_memory)) {
1049     // result is a stack-slot, so prevent immediate reloading
1050     return noUse;
1051   }
1052 
1053   // all other operands require a register
1054   return mustHaveRegister;
1055 }
1056 
1057 IntervalUseKind LinearScan::use_kind_of_input_operand(LIR_Op* op, LIR_Opr opr) {
1058   if (op-&gt;code() == lir_move) {
1059     assert(op-&gt;as_Op1() != NULL, &quot;lir_move must be LIR_Op1&quot;);
1060     LIR_Op1* move = (LIR_Op1*)op;
1061     LIR_Opr res = move-&gt;result_opr();
1062     bool result_in_memory = res-&gt;is_virtual() &amp;&amp; gen()-&gt;is_vreg_flag_set(res-&gt;vreg_number(), LIRGenerator::must_start_in_memory);
1063 
1064     if (result_in_memory) {
1065       // Move to an interval with must_start_in_memory set.
1066       // To avoid moves from stack to stack (not allowed) force the input operand to a register
1067       return mustHaveRegister;
1068 
1069     } else if (move-&gt;in_opr()-&gt;is_register() &amp;&amp; move-&gt;result_opr()-&gt;is_register()) {
1070       // Move from register to register
1071       if (block_of_op_with_id(op-&gt;id())-&gt;is_set(BlockBegin::osr_entry_flag)) {
1072         // special handling of phi-function moves inside osr-entry blocks
1073         // input operand must have a register instead of output operand (leads to better register allocation)
1074         return mustHaveRegister;
1075       }
1076 
1077       // The input operand is not forced to a register (moves from stack to register are allowed),
1078       // but it is faster if the input operand is in a register
1079       return shouldHaveRegister;
1080     }
1081   }
1082 
1083 
1084 #if defined(X86) || defined(S390)
1085   if (op-&gt;code() == lir_cmove) {
1086     // conditional moves can handle stack operands
1087     assert(op-&gt;result_opr()-&gt;is_register(), &quot;result must always be in a register&quot;);
1088     return shouldHaveRegister;
1089   }
1090 
1091   // optimizations for second input operand of arithmehtic operations on Intel
1092   // this operand is allowed to be on the stack in some cases
1093   BasicType opr_type = opr-&gt;type_register();
1094   if (opr_type == T_FLOAT || opr_type == T_DOUBLE) {
1095     if ((UseSSE == 1 &amp;&amp; opr_type == T_FLOAT) || UseSSE &gt;= 2 S390_ONLY(|| true)) {
1096       // SSE float instruction (T_DOUBLE only supported with SSE2)
1097       switch (op-&gt;code()) {
1098         case lir_cmp:
1099         case lir_add:
1100         case lir_sub:
1101         case lir_mul:
1102         case lir_div:
1103         {
1104           assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1105           LIR_Op2* op2 = (LIR_Op2*)op;
1106           if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1107             assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1108             return shouldHaveRegister;
1109           }
1110         }
1111         default:
1112           break;
1113       }
1114     } else {
1115       // FPU stack float instruction
1116       switch (op-&gt;code()) {
1117         case lir_add:
1118         case lir_sub:
1119         case lir_mul:
1120         case lir_div:
1121         {
1122           assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1123           LIR_Op2* op2 = (LIR_Op2*)op;
1124           if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1125             assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1126             return shouldHaveRegister;
1127           }
1128         }
1129         default:
1130           break;
1131       }
1132     }
1133     // We want to sometimes use logical operations on pointers, in particular in GC barriers.
1134     // Since 64bit logical operations do not current support operands on stack, we have to make sure
1135     // T_OBJECT doesn&#39;t get spilled along with T_LONG.
1136   } else if (opr_type != T_LONG LP64_ONLY(&amp;&amp; opr_type != T_OBJECT)) {
1137     // integer instruction (note: long operands must always be in register)
1138     switch (op-&gt;code()) {
1139       case lir_cmp:
1140       case lir_add:
1141       case lir_sub:
1142       case lir_logic_and:
1143       case lir_logic_or:
1144       case lir_logic_xor:
1145       {
1146         assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1147         LIR_Op2* op2 = (LIR_Op2*)op;
1148         if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1149           assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1150           return shouldHaveRegister;
1151         }
1152       }
1153       default:
1154         break;
1155     }
1156   }
1157 #endif // X86 S390
1158 
1159   // all other operands require a register
1160   return mustHaveRegister;
1161 }
1162 
1163 
1164 void LinearScan::handle_method_arguments(LIR_Op* op) {
1165   // special handling for method arguments (moves from stack to virtual register):
1166   // the interval gets no register assigned, but the stack slot.
1167   // it is split before the first use by the register allocator.
1168 
1169   if (op-&gt;code() == lir_move) {
1170     assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
1171     LIR_Op1* move = (LIR_Op1*)op;
1172 
1173     if (move-&gt;in_opr()-&gt;is_stack()) {
1174 #ifdef ASSERT
1175       int arg_size = compilation()-&gt;method()-&gt;arg_size();
1176       LIR_Opr o = move-&gt;in_opr();
1177       if (o-&gt;is_single_stack()) {
1178         assert(o-&gt;single_stack_ix() &gt;= 0 &amp;&amp; o-&gt;single_stack_ix() &lt; arg_size, &quot;out of range&quot;);
1179       } else if (o-&gt;is_double_stack()) {
1180         assert(o-&gt;double_stack_ix() &gt;= 0 &amp;&amp; o-&gt;double_stack_ix() &lt; arg_size, &quot;out of range&quot;);
1181       } else {
1182         ShouldNotReachHere();
1183       }
1184 
1185       assert(move-&gt;id() &gt; 0, &quot;invalid id&quot;);
1186       assert(block_of_op_with_id(move-&gt;id())-&gt;number_of_preds() == 0, &quot;move from stack must be in first block&quot;);
1187       assert(move-&gt;result_opr()-&gt;is_virtual(), &quot;result of move must be a virtual register&quot;);
1188 
1189       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;found move from stack slot %d to vreg %d&quot;, o-&gt;is_single_stack() ? o-&gt;single_stack_ix() : o-&gt;double_stack_ix(), reg_num(move-&gt;result_opr())));
1190 #endif
1191 
1192       Interval* interval = interval_at(reg_num(move-&gt;result_opr()));
1193 
1194       int stack_slot = LinearScan::nof_regs + (move-&gt;in_opr()-&gt;is_single_stack() ? move-&gt;in_opr()-&gt;single_stack_ix() : move-&gt;in_opr()-&gt;double_stack_ix());
1195       interval-&gt;set_canonical_spill_slot(stack_slot);
1196       interval-&gt;assign_reg(stack_slot);
1197     }
1198   }
1199 }
1200 
1201 void LinearScan::handle_doubleword_moves(LIR_Op* op) {
1202   // special handling for doubleword move from memory to register:
1203   // in this case the registers of the input address and the result
1204   // registers must not overlap -&gt; add a temp range for the input registers
1205   if (op-&gt;code() == lir_move) {
1206     assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
1207     LIR_Op1* move = (LIR_Op1*)op;
1208 
1209     if (move-&gt;result_opr()-&gt;is_double_cpu() &amp;&amp; move-&gt;in_opr()-&gt;is_pointer()) {
1210       LIR_Address* address = move-&gt;in_opr()-&gt;as_address_ptr();
1211       if (address != NULL) {
1212         if (address-&gt;base()-&gt;is_valid()) {
1213           add_temp(address-&gt;base(), op-&gt;id(), noUse);
1214         }
1215         if (address-&gt;index()-&gt;is_valid()) {
1216           add_temp(address-&gt;index(), op-&gt;id(), noUse);
1217         }
1218       }
1219     }
1220   }
1221 }
1222 
1223 void LinearScan::add_register_hints(LIR_Op* op) {
1224   switch (op-&gt;code()) {
1225     case lir_move:      // fall through
1226     case lir_convert: {
1227       assert(op-&gt;as_Op1() != NULL, &quot;lir_move, lir_convert must be LIR_Op1&quot;);
1228       LIR_Op1* move = (LIR_Op1*)op;
1229 
1230       LIR_Opr move_from = move-&gt;in_opr();
1231       LIR_Opr move_to = move-&gt;result_opr();
1232 
1233       if (move_to-&gt;is_register() &amp;&amp; move_from-&gt;is_register()) {
1234         Interval* from = interval_at(reg_num(move_from));
1235         Interval* to = interval_at(reg_num(move_to));
1236         if (from != NULL &amp;&amp; to != NULL) {
1237           to-&gt;set_register_hint(from);
1238           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation at op_id %d: added hint from interval %d to %d&quot;, move-&gt;id(), from-&gt;reg_num(), to-&gt;reg_num()));
1239         }
1240       }
1241       break;
1242     }
1243     case lir_cmove: {
1244       assert(op-&gt;as_Op2() != NULL, &quot;lir_cmove must be LIR_Op2&quot;);
1245       LIR_Op2* cmove = (LIR_Op2*)op;
1246 
1247       LIR_Opr move_from = cmove-&gt;in_opr1();
1248       LIR_Opr move_to = cmove-&gt;result_opr();
1249 
1250       if (move_to-&gt;is_register() &amp;&amp; move_from-&gt;is_register()) {
1251         Interval* from = interval_at(reg_num(move_from));
1252         Interval* to = interval_at(reg_num(move_to));
1253         if (from != NULL &amp;&amp; to != NULL) {
1254           to-&gt;set_register_hint(from);
1255           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation at op_id %d: added hint from interval %d to %d&quot;, cmove-&gt;id(), from-&gt;reg_num(), to-&gt;reg_num()));
1256         }
1257       }
1258       break;
1259     }
1260     default:
1261       break;
1262   }
1263 }
1264 
1265 
1266 void LinearScan::build_intervals() {
1267   TIME_LINEAR_SCAN(timer_build_intervals);
1268 
1269   // initialize interval list with expected number of intervals
1270   // (32 is added to have some space for split children without having to resize the list)
1271   _intervals = IntervalList(num_virtual_regs() + 32);
1272   // initialize all slots that are used by build_intervals
1273   _intervals.at_put_grow(num_virtual_regs() - 1, NULL, NULL);
1274 
1275   // create a list with all caller-save registers (cpu, fpu, xmm)
1276   // when an instruction is a call, a temp range is created for all these registers
1277   int num_caller_save_registers = 0;
1278   int caller_save_registers[LinearScan::nof_regs];
1279 
1280   int i;
1281   for (i = 0; i &lt; FrameMap::nof_caller_save_cpu_regs(); i++) {
1282     LIR_Opr opr = FrameMap::caller_save_cpu_reg_at(i);
1283     assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1284     assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1285     caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1286   }
1287 
1288   // temp ranges for fpu registers are only created when the method has
1289   // virtual fpu operands. Otherwise no allocation for fpu registers is
1290   // performed and so the temp ranges would be useless
1291   if (has_fpu_registers()) {
1292 #ifdef X86
1293     if (UseSSE &lt; 2) {
1294 #endif
1295       for (i = 0; i &lt; FrameMap::nof_caller_save_fpu_regs; i++) {
1296         LIR_Opr opr = FrameMap::caller_save_fpu_reg_at(i);
1297         assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1298         assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1299         caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1300       }
1301 #ifdef X86
1302     }
1303     if (UseSSE &gt; 0) {
1304       int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();
1305       for (i = 0; i &lt; num_caller_save_xmm_regs; i ++) {
1306         LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(i);
1307         assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1308         assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1309         caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1310       }
1311     }
1312 #endif
1313   }
1314   assert(num_caller_save_registers &lt;= LinearScan::nof_regs, &quot;out of bounds&quot;);
1315 
1316 
1317   LIR_OpVisitState visitor;
1318 
1319   // iterate all blocks in reverse order
1320   for (i = block_count() - 1; i &gt;= 0; i--) {
1321     BlockBegin* block = block_at(i);
1322     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
1323     int         block_from =   block-&gt;first_lir_instruction_id();
1324     int         block_to =     block-&gt;last_lir_instruction_id();
1325 
1326     assert(block_from == instructions-&gt;at(0)-&gt;id(), &quot;must be&quot;);
1327     assert(block_to   == instructions-&gt;at(instructions-&gt;length() - 1)-&gt;id(), &quot;must be&quot;);
1328 
1329     // Update intervals for registers live at the end of this block;
1330     ResourceBitMap live = block-&gt;live_out();
1331     int size = (int)live.size();
1332     for (int number = (int)live.get_next_one_offset(0, size); number &lt; size; number = (int)live.get_next_one_offset(number + 1, size)) {
1333       assert(live.at(number), &quot;should not stop here otherwise&quot;);
1334       assert(number &gt;= LIR_OprDesc::vreg_base, &quot;fixed intervals must not be live on block bounds&quot;);
1335       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;live in %d to %d&quot;, number, block_to + 2));
1336 
1337       add_use(number, block_from, block_to + 2, noUse, T_ILLEGAL);
1338 
1339       // add special use positions for loop-end blocks when the
1340       // interval is used anywhere inside this loop.  It&#39;s possible
1341       // that the block was part of a non-natural loop, so it might
1342       // have an invalid loop index.
1343       if (block-&gt;is_set(BlockBegin::linear_scan_loop_end_flag) &amp;&amp;
1344           block-&gt;loop_index() != -1 &amp;&amp;
1345           is_interval_in_loop(number, block-&gt;loop_index())) {
1346         interval_at(number)-&gt;add_use_pos(block_to + 1, loopEndMarker);
1347       }
1348     }
1349 
1350     // iterate all instructions of the block in reverse order.
1351     // skip the first instruction because it is always a label
1352     // definitions of intervals are processed before uses
1353     assert(visitor.no_operands(instructions-&gt;at(0)), &quot;first operation must always be a label&quot;);
1354     for (int j = instructions-&gt;length() - 1; j &gt;= 1; j--) {
1355       LIR_Op* op = instructions-&gt;at(j);
1356       int op_id = op-&gt;id();
1357 
1358       // visit operation to collect all operands
1359       visitor.visit(op);
1360 
1361       // add a temp range for each register if operation destroys caller-save registers
1362       if (visitor.has_call()) {
1363         for (int k = 0; k &lt; num_caller_save_registers; k++) {
1364           add_temp(caller_save_registers[k], op_id, noUse, T_ILLEGAL);
1365         }
1366         TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation destroys all caller-save registers&quot;));
1367       }
1368 
1369       // Add any platform dependent temps
1370       pd_add_temps(op);
1371 
1372       // visit definitions (output and temp operands)
1373       int k, n;
1374       n = visitor.opr_count(LIR_OpVisitState::outputMode);
1375       for (k = 0; k &lt; n; k++) {
1376         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
1377         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1378         add_def(opr, op_id, use_kind_of_output_operand(op, opr));
1379       }
1380 
1381       n = visitor.opr_count(LIR_OpVisitState::tempMode);
1382       for (k = 0; k &lt; n; k++) {
1383         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
1384         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1385         add_temp(opr, op_id, mustHaveRegister);
1386       }
1387 
1388       // visit uses (input operands)
1389       n = visitor.opr_count(LIR_OpVisitState::inputMode);
1390       for (k = 0; k &lt; n; k++) {
1391         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
1392         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1393         add_use(opr, block_from, op_id, use_kind_of_input_operand(op, opr));
1394       }
1395 
1396       // Add uses of live locals from interpreter&#39;s point of view for proper
1397       // debug information generation
1398       // Treat these operands as temp values (if the life range is extended
1399       // to a call site, the value would be in a register at the call otherwise)
1400       n = visitor.info_count();
1401       for (k = 0; k &lt; n; k++) {
1402         CodeEmitInfo* info = visitor.info_at(k);
1403         ValueStack* stack = info-&gt;stack();
1404         for_each_state_value(stack, value,
1405           add_use(value, block_from, op_id + 1, noUse);
1406         );
1407       }
1408 
1409       // special steps for some instructions (especially moves)
1410       handle_method_arguments(op);
1411       handle_doubleword_moves(op);
1412       add_register_hints(op);
1413 
1414     } // end of instruction iteration
1415   } // end of block iteration
1416 
1417 
1418   // add the range [0, 1[ to all fixed intervals
1419   // -&gt; the register allocator need not handle unhandled fixed intervals
1420   for (int n = 0; n &lt; LinearScan::nof_regs; n++) {
1421     Interval* interval = interval_at(n);
1422     if (interval != NULL) {
1423       interval-&gt;add_range(0, 1);
1424     }
1425   }
1426 }
1427 
1428 
1429 // ********** Phase 5: actual register allocation
1430 
1431 int LinearScan::interval_cmp(Interval** a, Interval** b) {
1432   if (*a != NULL) {
1433     if (*b != NULL) {
1434       return (*a)-&gt;from() - (*b)-&gt;from();
1435     } else {
1436       return -1;
1437     }
1438   } else {
1439     if (*b != NULL) {
1440       return 1;
1441     } else {
1442       return 0;
1443     }
1444   }
1445 }
1446 
1447 #ifndef PRODUCT
1448 int interval_cmp(Interval* const&amp; l, Interval* const&amp; r) {
1449   return l-&gt;from() - r-&gt;from();
1450 }
1451 
1452 bool find_interval(Interval* interval, IntervalArray* intervals) {
1453   bool found;
1454   int idx = intervals-&gt;find_sorted&lt;Interval*, interval_cmp&gt;(interval, found);
1455 
1456   if (!found) {
1457     return false;
1458   }
1459 
1460   int from = interval-&gt;from();
1461 
1462   // The index we&#39;ve found using binary search is pointing to an interval
1463   // that is defined in the same place as the interval we were looking for.
1464   // So now we have to look around that index and find exact interval.
1465   for (int i = idx; i &gt;= 0; i--) {
1466     if (intervals-&gt;at(i) == interval) {
1467       return true;
1468     }
1469     if (intervals-&gt;at(i)-&gt;from() != from) {
1470       break;
1471     }
1472   }
1473 
1474   for (int i = idx + 1; i &lt; intervals-&gt;length(); i++) {
1475     if (intervals-&gt;at(i) == interval) {
1476       return true;
1477     }
1478     if (intervals-&gt;at(i)-&gt;from() != from) {
1479       break;
1480     }
1481   }
1482 
1483   return false;
1484 }
1485 
1486 bool LinearScan::is_sorted(IntervalArray* intervals) {
1487   int from = -1;
1488   int null_count = 0;
1489 
1490   for (int i = 0; i &lt; intervals-&gt;length(); i++) {
1491     Interval* it = intervals-&gt;at(i);
1492     if (it != NULL) {
1493       assert(from &lt;= it-&gt;from(), &quot;Intervals are unordered&quot;);
1494       from = it-&gt;from();
1495     } else {
1496       null_count++;
1497     }
1498   }
1499 
1500   assert(null_count == 0, &quot;Sorted intervals should not contain nulls&quot;);
1501 
1502   null_count = 0;
1503 
1504   for (int i = 0; i &lt; interval_count(); i++) {
1505     Interval* interval = interval_at(i);
1506     if (interval != NULL) {
1507       assert(find_interval(interval, intervals), &quot;Lists do not contain same intervals&quot;);
1508     } else {
1509       null_count++;
1510     }
1511   }
1512 
1513   assert(interval_count() - null_count == intervals-&gt;length(),
1514       &quot;Sorted list should contain the same amount of non-NULL intervals as unsorted list&quot;);
1515 
1516   return true;
1517 }
1518 #endif
1519 
1520 void LinearScan::add_to_list(Interval** first, Interval** prev, Interval* interval) {
1521   if (*prev != NULL) {
1522     (*prev)-&gt;set_next(interval);
1523   } else {
1524     *first = interval;
1525   }
1526   *prev = interval;
1527 }
1528 
1529 void LinearScan::create_unhandled_lists(Interval** list1, Interval** list2, bool (is_list1)(const Interval* i), bool (is_list2)(const Interval* i)) {
1530   assert(is_sorted(_sorted_intervals), &quot;interval list is not sorted&quot;);
1531 
1532   *list1 = *list2 = Interval::end();
1533 
1534   Interval* list1_prev = NULL;
1535   Interval* list2_prev = NULL;
1536   Interval* v;
1537 
1538   const int n = _sorted_intervals-&gt;length();
1539   for (int i = 0; i &lt; n; i++) {
1540     v = _sorted_intervals-&gt;at(i);
1541     if (v == NULL) continue;
1542 
1543     if (is_list1(v)) {
1544       add_to_list(list1, &amp;list1_prev, v);
1545     } else if (is_list2 == NULL || is_list2(v)) {
1546       add_to_list(list2, &amp;list2_prev, v);
1547     }
1548   }
1549 
1550   if (list1_prev != NULL) list1_prev-&gt;set_next(Interval::end());
1551   if (list2_prev != NULL) list2_prev-&gt;set_next(Interval::end());
1552 
1553   assert(list1_prev == NULL || list1_prev-&gt;next() == Interval::end(), &quot;linear list ends not with sentinel&quot;);
1554   assert(list2_prev == NULL || list2_prev-&gt;next() == Interval::end(), &quot;linear list ends not with sentinel&quot;);
1555 }
1556 
1557 
1558 void LinearScan::sort_intervals_before_allocation() {
1559   TIME_LINEAR_SCAN(timer_sort_intervals_before);
1560 
1561   if (_needs_full_resort) {
1562     // There is no known reason why this should occur but just in case...
1563     assert(false, &quot;should never occur&quot;);
1564     // Re-sort existing interval list because an Interval::from() has changed
1565     _sorted_intervals-&gt;sort(interval_cmp);
1566     _needs_full_resort = false;
1567   }
1568 
1569   IntervalList* unsorted_list = &amp;_intervals;
1570   int unsorted_len = unsorted_list-&gt;length();
1571   int sorted_len = 0;
1572   int unsorted_idx;
1573   int sorted_idx = 0;
1574   int sorted_from_max = -1;
1575 
1576   // calc number of items for sorted list (sorted list must not contain NULL values)
1577   for (unsorted_idx = 0; unsorted_idx &lt; unsorted_len; unsorted_idx++) {
1578     if (unsorted_list-&gt;at(unsorted_idx) != NULL) {
1579       sorted_len++;
1580     }
1581   }
1582   IntervalArray* sorted_list = new IntervalArray(sorted_len, sorted_len, NULL);
1583 
1584   // special sorting algorithm: the original interval-list is almost sorted,
1585   // only some intervals are swapped. So this is much faster than a complete QuickSort
1586   for (unsorted_idx = 0; unsorted_idx &lt; unsorted_len; unsorted_idx++) {
1587     Interval* cur_interval = unsorted_list-&gt;at(unsorted_idx);
1588 
1589     if (cur_interval != NULL) {
1590       int cur_from = cur_interval-&gt;from();
1591 
1592       if (sorted_from_max &lt;= cur_from) {
1593         sorted_list-&gt;at_put(sorted_idx++, cur_interval);
1594         sorted_from_max = cur_interval-&gt;from();
1595       } else {
1596         // the asumption that the intervals are already sorted failed,
1597         // so this interval must be sorted in manually
1598         int j;
1599         for (j = sorted_idx - 1; j &gt;= 0 &amp;&amp; cur_from &lt; sorted_list-&gt;at(j)-&gt;from(); j--) {
1600           sorted_list-&gt;at_put(j + 1, sorted_list-&gt;at(j));
1601         }
1602         sorted_list-&gt;at_put(j + 1, cur_interval);
1603         sorted_idx++;
1604       }
1605     }
1606   }
1607   _sorted_intervals = sorted_list;
1608   assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1609 }
1610 
1611 void LinearScan::sort_intervals_after_allocation() {
1612   TIME_LINEAR_SCAN(timer_sort_intervals_after);
1613 
1614   if (_needs_full_resort) {
1615     // Re-sort existing interval list because an Interval::from() has changed
1616     _sorted_intervals-&gt;sort(interval_cmp);
1617     _needs_full_resort = false;
1618   }
1619 
1620   IntervalArray* old_list = _sorted_intervals;
1621   IntervalList* new_list = _new_intervals_from_allocation;
1622   int old_len = old_list-&gt;length();
1623   int new_len = new_list == NULL ? 0 : new_list-&gt;length();
1624 
1625   if (new_len == 0) {
1626     // no intervals have been added during allocation, so sorted list is already up to date
1627     assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1628     return;
1629   }
1630 
1631   // conventional sort-algorithm for new intervals
1632   new_list-&gt;sort(interval_cmp);
1633 
1634   // merge old and new list (both already sorted) into one combined list
1635   int combined_list_len = old_len + new_len;
1636   IntervalArray* combined_list = new IntervalArray(combined_list_len, combined_list_len, NULL);
1637   int old_idx = 0;
1638   int new_idx = 0;
1639 
1640   while (old_idx + new_idx &lt; old_len + new_len) {
1641     if (new_idx &gt;= new_len || (old_idx &lt; old_len &amp;&amp; old_list-&gt;at(old_idx)-&gt;from() &lt;= new_list-&gt;at(new_idx)-&gt;from())) {
1642       combined_list-&gt;at_put(old_idx + new_idx, old_list-&gt;at(old_idx));
1643       old_idx++;
1644     } else {
1645       combined_list-&gt;at_put(old_idx + new_idx, new_list-&gt;at(new_idx));
1646       new_idx++;
1647     }
1648   }
1649 
1650   _sorted_intervals = combined_list;
1651   assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1652 }
1653 
1654 
1655 void LinearScan::allocate_registers() {
1656   TIME_LINEAR_SCAN(timer_allocate_registers);
1657 
1658   Interval* precolored_cpu_intervals, *not_precolored_cpu_intervals;
1659   Interval* precolored_fpu_intervals, *not_precolored_fpu_intervals;
1660 
1661   // allocate cpu registers
1662   create_unhandled_lists(&amp;precolored_cpu_intervals, &amp;not_precolored_cpu_intervals,
1663                          is_precolored_cpu_interval, is_virtual_cpu_interval);
1664 
1665   // allocate fpu registers
1666   create_unhandled_lists(&amp;precolored_fpu_intervals, &amp;not_precolored_fpu_intervals,
1667                          is_precolored_fpu_interval, is_virtual_fpu_interval);
1668 
1669   // the fpu interval allocation cannot be moved down below with the fpu section as
1670   // the cpu_lsw.walk() changes interval positions.
1671 
1672   LinearScanWalker cpu_lsw(this, precolored_cpu_intervals, not_precolored_cpu_intervals);
1673   cpu_lsw.walk();
1674   cpu_lsw.finish_allocation();
1675 
1676   if (has_fpu_registers()) {
1677     LinearScanWalker fpu_lsw(this, precolored_fpu_intervals, not_precolored_fpu_intervals);
1678     fpu_lsw.walk();
1679     fpu_lsw.finish_allocation();
1680   }
1681 }
1682 
1683 
1684 // ********** Phase 6: resolve data flow
1685 // (insert moves at edges between blocks if intervals have been split)
1686 
1687 // wrapper for Interval::split_child_at_op_id that performs a bailout in product mode
1688 // instead of returning NULL
1689 Interval* LinearScan::split_child_at_op_id(Interval* interval, int op_id, LIR_OpVisitState::OprMode mode) {
1690   Interval* result = interval-&gt;split_child_at_op_id(op_id, mode);
1691   if (result != NULL) {
1692     return result;
1693   }
1694 
1695   assert(false, &quot;must find an interval, but do a clean bailout in product mode&quot;);
1696   result = new Interval(LIR_OprDesc::vreg_base);
1697   result-&gt;assign_reg(0);
1698   result-&gt;set_type(T_INT);
1699   BAILOUT_(&quot;LinearScan: interval is NULL&quot;, result);
1700 }
1701 
1702 
1703 Interval* LinearScan::interval_at_block_begin(BlockBegin* block, int reg_num) {
1704   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1705   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1706 
1707   return split_child_at_op_id(interval_at(reg_num), block-&gt;first_lir_instruction_id(), LIR_OpVisitState::outputMode);
1708 }
1709 
1710 Interval* LinearScan::interval_at_block_end(BlockBegin* block, int reg_num) {
1711   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1712   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1713 
1714   return split_child_at_op_id(interval_at(reg_num), block-&gt;last_lir_instruction_id() + 1, LIR_OpVisitState::outputMode);
1715 }
1716 
1717 Interval* LinearScan::interval_at_op_id(int reg_num, int op_id) {
1718   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1719   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1720 
1721   return split_child_at_op_id(interval_at(reg_num), op_id, LIR_OpVisitState::inputMode);
1722 }
1723 
1724 
1725 void LinearScan::resolve_collect_mappings(BlockBegin* from_block, BlockBegin* to_block, MoveResolver &amp;move_resolver) {
1726   DEBUG_ONLY(move_resolver.check_empty());
1727 
1728   const int size = live_set_size();
1729   const ResourceBitMap live_at_edge = to_block-&gt;live_in();
1730 
1731   // visit all registers where the live_at_edge bit is set
1732   for (int r = (int)live_at_edge.get_next_one_offset(0, size); r &lt; size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
1733     assert(r &lt; num_virtual_regs(), &quot;live information set for not exisiting interval&quot;);
1734     assert(from_block-&gt;live_out().at(r) &amp;&amp; to_block-&gt;live_in().at(r), &quot;interval not live at this edge&quot;);
1735 
1736     Interval* from_interval = interval_at_block_end(from_block, r);
1737     Interval* to_interval = interval_at_block_begin(to_block, r);
1738 
1739     if (from_interval != to_interval &amp;&amp; (from_interval-&gt;assigned_reg() != to_interval-&gt;assigned_reg() || from_interval-&gt;assigned_regHi() != to_interval-&gt;assigned_regHi())) {
1740       // need to insert move instruction
1741       move_resolver.add_mapping(from_interval, to_interval);
1742     }
1743   }
1744 }
1745 
1746 
1747 void LinearScan::resolve_find_insert_pos(BlockBegin* from_block, BlockBegin* to_block, MoveResolver &amp;move_resolver) {
1748   if (from_block-&gt;number_of_sux() &lt;= 1) {
1749     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting moves at end of from_block B%d&quot;, from_block-&gt;block_id()));
1750 
1751     LIR_OpList* instructions = from_block-&gt;lir()-&gt;instructions_list();
1752     LIR_OpBranch* branch = instructions-&gt;last()-&gt;as_OpBranch();
1753     if (branch != NULL) {
1754       // insert moves before branch
1755       assert(branch-&gt;cond() == lir_cond_always, &quot;block does not end with an unconditional jump&quot;);
1756       move_resolver.set_insert_position(from_block-&gt;lir(), instructions-&gt;length() - 2);
1757     } else {
1758       move_resolver.set_insert_position(from_block-&gt;lir(), instructions-&gt;length() - 1);
1759     }
1760 
1761   } else {
1762     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting moves at beginning of to_block B%d&quot;, to_block-&gt;block_id()));
1763 #ifdef ASSERT
1764     assert(from_block-&gt;lir()-&gt;instructions_list()-&gt;at(0)-&gt;as_OpLabel() != NULL, &quot;block does not start with a label&quot;);
1765 
1766     // because the number of predecessor edges matches the number of
1767     // successor edges, blocks which are reached by switch statements
1768     // may have be more than one predecessor but it will be guaranteed
1769     // that all predecessors will be the same.
1770     for (int i = 0; i &lt; to_block-&gt;number_of_preds(); i++) {
1771       assert(from_block == to_block-&gt;pred_at(i), &quot;all critical edges must be broken&quot;);
1772     }
1773 #endif
1774 
1775     move_resolver.set_insert_position(to_block-&gt;lir(), 0);
1776   }
1777 }
1778 
1779 
1780 // insert necessary moves (spilling or reloading) at edges between blocks if interval has been split
1781 void LinearScan::resolve_data_flow() {
1782   TIME_LINEAR_SCAN(timer_resolve_data_flow);
1783 
1784   int num_blocks = block_count();
1785   MoveResolver move_resolver(this);
1786   ResourceBitMap block_completed(num_blocks);
1787   ResourceBitMap already_resolved(num_blocks);
1788 
1789   int i;
1790   for (i = 0; i &lt; num_blocks; i++) {
1791     BlockBegin* block = block_at(i);
1792 
1793     // check if block has only one predecessor and only one successor
1794     if (block-&gt;number_of_preds() == 1 &amp;&amp; block-&gt;number_of_sux() == 1 &amp;&amp; block-&gt;number_of_exception_handlers() == 0) {
1795       LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
1796       assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;block must start with label&quot;);
1797       assert(instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successors must end with branch&quot;);
1798       assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block with successor must end with unconditional branch&quot;);
1799 
1800       // check if block is empty (only label and branch)
1801       if (instructions-&gt;length() == 2) {
1802         BlockBegin* pred = block-&gt;pred_at(0);
1803         BlockBegin* sux = block-&gt;sux_at(0);
1804 
1805         // prevent optimization of two consecutive blocks
1806         if (!block_completed.at(pred-&gt;linear_scan_number()) &amp;&amp; !block_completed.at(sux-&gt;linear_scan_number())) {
1807           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;**** optimizing empty block B%d (pred: B%d, sux: B%d)&quot;, block-&gt;block_id(), pred-&gt;block_id(), sux-&gt;block_id()));
1808           block_completed.set_bit(block-&gt;linear_scan_number());
1809 
1810           // directly resolve between pred and sux (without looking at the empty block between)
1811           resolve_collect_mappings(pred, sux, move_resolver);
1812           if (move_resolver.has_mappings()) {
1813             move_resolver.set_insert_position(block-&gt;lir(), 0);
1814             move_resolver.resolve_and_append_moves();
1815           }
1816         }
1817       }
1818     }
1819   }
1820 
1821 
1822   for (i = 0; i &lt; num_blocks; i++) {
1823     if (!block_completed.at(i)) {
1824       BlockBegin* from_block = block_at(i);
1825       already_resolved.set_from(block_completed);
1826 
1827       int num_sux = from_block-&gt;number_of_sux();
1828       for (int s = 0; s &lt; num_sux; s++) {
1829         BlockBegin* to_block = from_block-&gt;sux_at(s);
1830 
1831         // check for duplicate edges between the same blocks (can happen with switch blocks)
1832         if (!already_resolved.at(to_block-&gt;linear_scan_number())) {
1833           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;**** processing edge between B%d and B%d&quot;, from_block-&gt;block_id(), to_block-&gt;block_id()));
1834           already_resolved.set_bit(to_block-&gt;linear_scan_number());
1835 
1836           // collect all intervals that have been split between from_block and to_block
1837           resolve_collect_mappings(from_block, to_block, move_resolver);
1838           if (move_resolver.has_mappings()) {
1839             resolve_find_insert_pos(from_block, to_block, move_resolver);
1840             move_resolver.resolve_and_append_moves();
1841           }
1842         }
1843       }
1844     }
1845   }
1846 }
1847 
1848 
1849 void LinearScan::resolve_exception_entry(BlockBegin* block, int reg_num, MoveResolver &amp;move_resolver) {
1850   if (interval_at(reg_num) == NULL) {
1851     // if a phi function is never used, no interval is created -&gt; ignore this
1852     return;
1853   }
1854 
1855   Interval* interval = interval_at_block_begin(block, reg_num);
1856   int reg = interval-&gt;assigned_reg();
1857   int regHi = interval-&gt;assigned_regHi();
1858 
1859   if ((reg &lt; nof_regs &amp;&amp; interval-&gt;always_in_memory()) ||
1860       (use_fpu_stack_allocation() &amp;&amp; reg &gt;= pd_first_fpu_reg &amp;&amp; reg &lt;= pd_last_fpu_reg)) {
1861     // the interval is split to get a short range that is located on the stack
1862     // in the following two cases:
1863     // * the interval started in memory (e.g. method parameter), but is currently in a register
1864     //   this is an optimization for exception handling that reduces the number of moves that
1865     //   are necessary for resolving the states when an exception uses this exception handler
1866     // * the interval would be on the fpu stack at the begin of the exception handler
1867     //   this is not allowed because of the complicated fpu stack handling on Intel
1868 
1869     // range that will be spilled to memory
1870     int from_op_id = block-&gt;first_lir_instruction_id();
1871     int to_op_id = from_op_id + 1;  // short live range of length 1
1872     assert(interval-&gt;from() &lt;= from_op_id &amp;&amp; interval-&gt;to() &gt;= to_op_id,
1873            &quot;no split allowed between exception entry and first instruction&quot;);
1874 
1875     if (interval-&gt;from() != from_op_id) {
1876       // the part before from_op_id is unchanged
1877       interval = interval-&gt;split(from_op_id);
1878       interval-&gt;assign_reg(reg, regHi);
1879       append_interval(interval);
1880     } else {
1881       _needs_full_resort = true;
1882     }
1883     assert(interval-&gt;from() == from_op_id, &quot;must be true now&quot;);
1884 
1885     Interval* spilled_part = interval;
1886     if (interval-&gt;to() != to_op_id) {
1887       // the part after to_op_id is unchanged
1888       spilled_part = interval-&gt;split_from_start(to_op_id);
1889       append_interval(spilled_part);
1890       move_resolver.add_mapping(spilled_part, interval);
1891     }
1892     assign_spill_slot(spilled_part);
1893 
1894     assert(spilled_part-&gt;from() == from_op_id &amp;&amp; spilled_part-&gt;to() == to_op_id, &quot;just checking&quot;);
1895   }
1896 }
1897 
1898 void LinearScan::resolve_exception_entry(BlockBegin* block, MoveResolver &amp;move_resolver) {
1899   assert(block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;should not call otherwise&quot;);
1900   DEBUG_ONLY(move_resolver.check_empty());
1901 
1902   // visit all registers where the live_in bit is set
1903   int size = live_set_size();
1904   for (int r = (int)block-&gt;live_in().get_next_one_offset(0, size); r &lt; size; r = (int)block-&gt;live_in().get_next_one_offset(r + 1, size)) {
1905     resolve_exception_entry(block, r, move_resolver);
1906   }
1907 
1908   // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
1909   for_each_phi_fun(block, phi,
1910     if (!phi-&gt;is_illegal()) { resolve_exception_entry(block, phi-&gt;operand()-&gt;vreg_number(), move_resolver); }
1911   );
1912 
1913   if (move_resolver.has_mappings()) {
1914     // insert moves after first instruction
1915     move_resolver.set_insert_position(block-&gt;lir(), 0);
1916     move_resolver.resolve_and_append_moves();
1917   }
1918 }
1919 
1920 
1921 void LinearScan::resolve_exception_edge(XHandler* handler, int throwing_op_id, int reg_num, Phi* phi, MoveResolver &amp;move_resolver) {
1922   if (interval_at(reg_num) == NULL) {
1923     // if a phi function is never used, no interval is created -&gt; ignore this
1924     return;
1925   }
1926 
1927   // the computation of to_interval is equal to resolve_collect_mappings,
1928   // but from_interval is more complicated because of phi functions
1929   BlockBegin* to_block = handler-&gt;entry_block();
1930   Interval* to_interval = interval_at_block_begin(to_block, reg_num);
1931 
1932   if (phi != NULL) {
1933     // phi function of the exception entry block
1934     // no moves are created for this phi function in the LIR_Generator, so the
1935     // interval at the throwing instruction must be searched using the operands
1936     // of the phi function
1937     Value from_value = phi-&gt;operand_at(handler-&gt;phi_operand());
1938 
1939     // with phi functions it can happen that the same from_value is used in
1940     // multiple mappings, so notify move-resolver that this is allowed
1941     move_resolver.set_multiple_reads_allowed();
1942 
1943     Constant* con = from_value-&gt;as_Constant();
1944     if (con != NULL &amp;&amp; !con-&gt;is_pinned()) {
1945       // unpinned constants may have no register, so add mapping from constant to interval
1946       move_resolver.add_mapping(LIR_OprFact::value_type(con-&gt;type()), to_interval);
1947     } else {
1948       // search split child at the throwing op_id
1949       Interval* from_interval = interval_at_op_id(from_value-&gt;operand()-&gt;vreg_number(), throwing_op_id);
1950       move_resolver.add_mapping(from_interval, to_interval);
1951     }
1952 
1953   } else {
1954     // no phi function, so use reg_num also for from_interval
1955     // search split child at the throwing op_id
1956     Interval* from_interval = interval_at_op_id(reg_num, throwing_op_id);
1957     if (from_interval != to_interval) {
1958       // optimization to reduce number of moves: when to_interval is on stack and
1959       // the stack slot is known to be always correct, then no move is necessary
1960       if (!from_interval-&gt;always_in_memory() || from_interval-&gt;canonical_spill_slot() != to_interval-&gt;assigned_reg()) {
1961         move_resolver.add_mapping(from_interval, to_interval);
1962       }
1963     }
1964   }
1965 }
1966 
1967 void LinearScan::resolve_exception_edge(XHandler* handler, int throwing_op_id, MoveResolver &amp;move_resolver) {
1968   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;resolving exception handler B%d: throwing_op_id=%d&quot;, handler-&gt;entry_block()-&gt;block_id(), throwing_op_id));
1969 
1970   DEBUG_ONLY(move_resolver.check_empty());
1971   assert(handler-&gt;lir_op_id() == -1, &quot;already processed this xhandler&quot;);
1972   DEBUG_ONLY(handler-&gt;set_lir_op_id(throwing_op_id));
1973   assert(handler-&gt;entry_code() == NULL, &quot;code already present&quot;);
1974 
1975   // visit all registers where the live_in bit is set
1976   BlockBegin* block = handler-&gt;entry_block();
1977   int size = live_set_size();
1978   for (int r = (int)block-&gt;live_in().get_next_one_offset(0, size); r &lt; size; r = (int)block-&gt;live_in().get_next_one_offset(r + 1, size)) {
1979     resolve_exception_edge(handler, throwing_op_id, r, NULL, move_resolver);
1980   }
1981 
1982   // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
1983   for_each_phi_fun(block, phi,
1984     if (!phi-&gt;is_illegal()) { resolve_exception_edge(handler, throwing_op_id, phi-&gt;operand()-&gt;vreg_number(), phi, move_resolver); }
1985   );
1986 
1987   if (move_resolver.has_mappings()) {
1988     LIR_List* entry_code = new LIR_List(compilation());
1989     move_resolver.set_insert_position(entry_code, 0);
1990     move_resolver.resolve_and_append_moves();
1991 
1992     entry_code-&gt;jump(handler-&gt;entry_block());
1993     handler-&gt;set_entry_code(entry_code);
1994   }
1995 }
1996 
1997 
1998 void LinearScan::resolve_exception_handlers() {
1999   MoveResolver move_resolver(this);
2000   LIR_OpVisitState visitor;
2001   int num_blocks = block_count();
2002 
2003   int i;
2004   for (i = 0; i &lt; num_blocks; i++) {
2005     BlockBegin* block = block_at(i);
2006     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
2007       resolve_exception_entry(block, move_resolver);
2008     }
2009   }
2010 
2011   for (i = 0; i &lt; num_blocks; i++) {
2012     BlockBegin* block = block_at(i);
2013     LIR_List* ops = block-&gt;lir();
2014     int num_ops = ops-&gt;length();
2015 
2016     // iterate all instructions of the block. skip the first because it is always a label
2017     assert(visitor.no_operands(ops-&gt;at(0)), &quot;first operation must always be a label&quot;);
2018     for (int j = 1; j &lt; num_ops; j++) {
2019       LIR_Op* op = ops-&gt;at(j);
2020       int op_id = op-&gt;id();
2021 
2022       if (op_id != -1 &amp;&amp; has_info(op_id)) {
2023         // visit operation to collect all operands
2024         visitor.visit(op);
2025         assert(visitor.info_count() &gt; 0, &quot;should not visit otherwise&quot;);
2026 
2027         XHandlers* xhandlers = visitor.all_xhandler();
2028         int n = xhandlers-&gt;length();
2029         for (int k = 0; k &lt; n; k++) {
2030           resolve_exception_edge(xhandlers-&gt;handler_at(k), op_id, move_resolver);
2031         }
2032 
2033 #ifdef ASSERT
2034       } else {
2035         visitor.visit(op);
2036         assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
2037 #endif
2038       }
2039     }
2040   }
2041 }
2042 
2043 
2044 // ********** Phase 7: assign register numbers back to LIR
2045 // (includes computation of debug information and oop maps)
2046 
2047 VMReg LinearScan::vm_reg_for_interval(Interval* interval) {
2048   VMReg reg = interval-&gt;cached_vm_reg();
2049   if (!reg-&gt;is_valid() ) {
2050     reg = vm_reg_for_operand(operand_for_interval(interval));
2051     interval-&gt;set_cached_vm_reg(reg);
2052   }
2053   assert(reg == vm_reg_for_operand(operand_for_interval(interval)), &quot;wrong cached value&quot;);
2054   return reg;
2055 }
2056 
2057 VMReg LinearScan::vm_reg_for_operand(LIR_Opr opr) {
2058   assert(opr-&gt;is_oop(), &quot;currently only implemented for oop operands&quot;);
2059   return frame_map()-&gt;regname(opr);
2060 }
2061 
2062 
2063 LIR_Opr LinearScan::operand_for_interval(Interval* interval) {
2064   LIR_Opr opr = interval-&gt;cached_opr();
2065   if (opr-&gt;is_illegal()) {
2066     opr = calc_operand_for_interval(interval);
2067     interval-&gt;set_cached_opr(opr);
2068   }
2069 
2070   assert(opr == calc_operand_for_interval(interval), &quot;wrong cached value&quot;);
2071   return opr;
2072 }
2073 
2074 LIR_Opr LinearScan::calc_operand_for_interval(const Interval* interval) {
2075   int assigned_reg = interval-&gt;assigned_reg();
2076   BasicType type = interval-&gt;type();
2077 
2078   if (assigned_reg &gt;= nof_regs) {
2079     // stack slot
2080     assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2081     return LIR_OprFact::stack(assigned_reg - nof_regs, type);
2082 
2083   } else {
2084     // register
2085     switch (type) {
2086       case T_OBJECT: {
2087         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2088         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2089         return LIR_OprFact::single_cpu_oop(assigned_reg);
2090       }
2091 
2092       case T_ADDRESS: {
2093         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2094         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2095         return LIR_OprFact::single_cpu_address(assigned_reg);
2096       }
2097 
2098       case T_METADATA: {
2099         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2100         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2101         return LIR_OprFact::single_cpu_metadata(assigned_reg);
2102       }
2103 
2104 #ifdef __SOFTFP__
2105       case T_FLOAT:  // fall through
2106 #endif // __SOFTFP__
2107       case T_INT: {
2108         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2109         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2110         return LIR_OprFact::single_cpu(assigned_reg);
2111       }
2112 
2113 #ifdef __SOFTFP__
2114       case T_DOUBLE:  // fall through
2115 #endif // __SOFTFP__
2116       case T_LONG: {
2117         int assigned_regHi = interval-&gt;assigned_regHi();
2118         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2119         assert(num_physical_regs(T_LONG) == 1 ||
2120                (assigned_regHi &gt;= pd_first_cpu_reg &amp;&amp; assigned_regHi &lt;= pd_last_cpu_reg), &quot;no cpu register&quot;);
2121 
2122         assert(assigned_reg != assigned_regHi, &quot;invalid allocation&quot;);
2123         assert(num_physical_regs(T_LONG) == 1 || assigned_reg &lt; assigned_regHi,
2124                &quot;register numbers must be sorted (ensure that e.g. a move from eax,ebx to ebx,eax can not occur)&quot;);
2125         assert((assigned_regHi != any_reg) ^ (num_physical_regs(T_LONG) == 1), &quot;must be match&quot;);
2126         if (requires_adjacent_regs(T_LONG)) {
2127           assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == assigned_regHi, &quot;must be sequential and even&quot;);
2128         }
2129 
2130 #ifdef _LP64
2131         return LIR_OprFact::double_cpu(assigned_reg, assigned_reg);
2132 #else
2133 #if defined(SPARC) || defined(PPC32)
2134         return LIR_OprFact::double_cpu(assigned_regHi, assigned_reg);
2135 #else
2136         return LIR_OprFact::double_cpu(assigned_reg, assigned_regHi);
2137 #endif // SPARC
2138 #endif // LP64
2139       }
2140 
2141 #ifndef __SOFTFP__
2142       case T_FLOAT: {
2143 #ifdef X86
2144         if (UseSSE &gt;= 1) {
2145           int last_xmm_reg = pd_last_xmm_reg;
2146 #ifdef _LP64
2147           if (UseAVX &lt; 3) {
2148             last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
2149           }
2150 #endif
2151           assert(assigned_reg &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg &lt;= last_xmm_reg, &quot;no xmm register&quot;);
2152           assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2153           return LIR_OprFact::single_xmm(assigned_reg - pd_first_xmm_reg);
2154         }
2155 #endif
2156 
2157         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2158         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2159         return LIR_OprFact::single_fpu(assigned_reg - pd_first_fpu_reg);
2160       }
2161 
2162       case T_DOUBLE: {
2163 #ifdef X86
2164         if (UseSSE &gt;= 2) {
2165           int last_xmm_reg = pd_last_xmm_reg;
2166 #ifdef _LP64
2167           if (UseAVX &lt; 3) {
2168             last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
2169           }
2170 #endif
2171           assert(assigned_reg &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg &lt;= last_xmm_reg, &quot;no xmm register&quot;);
2172           assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register (double xmm values are stored in one register)&quot;);
2173           return LIR_OprFact::double_xmm(assigned_reg - pd_first_xmm_reg);
2174         }
2175 #endif
2176 
2177 #ifdef SPARC
2178         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2179         assert(interval-&gt;assigned_regHi() &gt;= pd_first_fpu_reg &amp;&amp; interval-&gt;assigned_regHi() &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2180         assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == interval-&gt;assigned_regHi(), &quot;must be sequential and even&quot;);
2181         LIR_Opr result = LIR_OprFact::double_fpu(interval-&gt;assigned_regHi() - pd_first_fpu_reg, assigned_reg - pd_first_fpu_reg);
2182 #elif defined(ARM32)
2183         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2184         assert(interval-&gt;assigned_regHi() &gt;= pd_first_fpu_reg &amp;&amp; interval-&gt;assigned_regHi() &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2185         assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == interval-&gt;assigned_regHi(), &quot;must be sequential and even&quot;);
2186         LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg, interval-&gt;assigned_regHi() - pd_first_fpu_reg);
2187 #else
2188         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2189         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register (double fpu values are stored in one register on Intel)&quot;);
2190         LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg);
2191 #endif
2192         return result;
2193       }
2194 #endif // __SOFTFP__
2195 
2196       default: {
2197         ShouldNotReachHere();
2198         return LIR_OprFact::illegalOpr;
2199       }
2200     }
2201   }
2202 }
2203 
2204 LIR_Opr LinearScan::canonical_spill_opr(Interval* interval) {
2205   assert(interval-&gt;canonical_spill_slot() &gt;= nof_regs, &quot;canonical spill slot not set&quot;);
2206   return LIR_OprFact::stack(interval-&gt;canonical_spill_slot() - nof_regs, interval-&gt;type());
2207 }
2208 
2209 LIR_Opr LinearScan::color_lir_opr(LIR_Opr opr, int op_id, LIR_OpVisitState::OprMode mode) {
2210   assert(opr-&gt;is_virtual(), &quot;should not call this otherwise&quot;);
2211 
2212   Interval* interval = interval_at(opr-&gt;vreg_number());
2213   assert(interval != NULL, &quot;interval must exist&quot;);
2214 
2215   if (op_id != -1) {
2216 #ifdef ASSERT
2217     BlockBegin* block = block_of_op_with_id(op_id);
2218     if (block-&gt;number_of_sux() &lt;= 1 &amp;&amp; op_id == block-&gt;last_lir_instruction_id()) {
2219       // check if spill moves could have been appended at the end of this block, but
2220       // before the branch instruction. So the split child information for this branch would
2221       // be incorrect.
2222       LIR_OpBranch* branch = block-&gt;lir()-&gt;instructions_list()-&gt;last()-&gt;as_OpBranch();
2223       if (branch != NULL) {
2224         if (block-&gt;live_out().at(opr-&gt;vreg_number())) {
2225           assert(branch-&gt;cond() == lir_cond_always, &quot;block does not end with an unconditional jump&quot;);
2226           assert(false, &quot;can&#39;t get split child for the last branch of a block because the information would be incorrect (moves are inserted before the branch in resolve_data_flow)&quot;);
2227         }
2228       }
2229     }
2230 #endif
2231 
2232     // operands are not changed when an interval is split during allocation,
2233     // so search the right interval here
2234     interval = split_child_at_op_id(interval, op_id, mode);
2235   }
2236 
2237   LIR_Opr res = operand_for_interval(interval);
2238 
2239 #ifdef X86
2240   // new semantic for is_last_use: not only set on definite end of interval,
2241   // but also before hole
2242   // This may still miss some cases (e.g. for dead values), but it is not necessary that the
2243   // last use information is completely correct
2244   // information is only needed for fpu stack allocation
2245   if (res-&gt;is_fpu_register()) {
2246     if (opr-&gt;is_last_use() || op_id == interval-&gt;to() || (op_id != -1 &amp;&amp; interval-&gt;has_hole_between(op_id, op_id + 1))) {
2247       assert(op_id == -1 || !is_block_begin(op_id), &quot;holes at begin of block may also result from control flow&quot;);
2248       res = res-&gt;make_last_use();
2249     }
2250   }
2251 #endif
2252 
2253   assert(!gen()-&gt;is_vreg_flag_set(opr-&gt;vreg_number(), LIRGenerator::callee_saved) || !FrameMap::is_caller_save_register(res), &quot;bad allocation&quot;);
2254 
2255   return res;
2256 }
2257 
2258 
2259 #ifdef ASSERT
2260 // some methods used to check correctness of debug information
2261 
2262 void assert_no_register_values(GrowableArray&lt;ScopeValue*&gt;* values) {
2263   if (values == NULL) {
2264     return;
2265   }
2266 
2267   for (int i = 0; i &lt; values-&gt;length(); i++) {
2268     ScopeValue* value = values-&gt;at(i);
2269 
2270     if (value-&gt;is_location()) {
2271       Location location = ((LocationValue*)value)-&gt;location();
2272       assert(location.where() == Location::on_stack, &quot;value is in register&quot;);
2273     }
2274   }
2275 }
2276 
2277 void assert_no_register_values(GrowableArray&lt;MonitorValue*&gt;* values) {
2278   if (values == NULL) {
2279     return;
2280   }
2281 
2282   for (int i = 0; i &lt; values-&gt;length(); i++) {
2283     MonitorValue* value = values-&gt;at(i);
2284 
2285     if (value-&gt;owner()-&gt;is_location()) {
2286       Location location = ((LocationValue*)value-&gt;owner())-&gt;location();
2287       assert(location.where() == Location::on_stack, &quot;owner is in register&quot;);
2288     }
2289     assert(value-&gt;basic_lock().where() == Location::on_stack, &quot;basic_lock is in register&quot;);
2290   }
2291 }
2292 
2293 void assert_equal(Location l1, Location l2) {
2294   assert(l1.where() == l2.where() &amp;&amp; l1.type() == l2.type() &amp;&amp; l1.offset() == l2.offset(), &quot;&quot;);
2295 }
2296 
2297 void assert_equal(ScopeValue* v1, ScopeValue* v2) {
2298   if (v1-&gt;is_location()) {
2299     assert(v2-&gt;is_location(), &quot;&quot;);
2300     assert_equal(((LocationValue*)v1)-&gt;location(), ((LocationValue*)v2)-&gt;location());
2301   } else if (v1-&gt;is_constant_int()) {
2302     assert(v2-&gt;is_constant_int(), &quot;&quot;);
2303     assert(((ConstantIntValue*)v1)-&gt;value() == ((ConstantIntValue*)v2)-&gt;value(), &quot;&quot;);
2304   } else if (v1-&gt;is_constant_double()) {
2305     assert(v2-&gt;is_constant_double(), &quot;&quot;);
2306     assert(((ConstantDoubleValue*)v1)-&gt;value() == ((ConstantDoubleValue*)v2)-&gt;value(), &quot;&quot;);
2307   } else if (v1-&gt;is_constant_long()) {
2308     assert(v2-&gt;is_constant_long(), &quot;&quot;);
2309     assert(((ConstantLongValue*)v1)-&gt;value() == ((ConstantLongValue*)v2)-&gt;value(), &quot;&quot;);
2310   } else if (v1-&gt;is_constant_oop()) {
2311     assert(v2-&gt;is_constant_oop(), &quot;&quot;);
2312     assert(((ConstantOopWriteValue*)v1)-&gt;value() == ((ConstantOopWriteValue*)v2)-&gt;value(), &quot;&quot;);
2313   } else {
2314     ShouldNotReachHere();
2315   }
2316 }
2317 
2318 void assert_equal(MonitorValue* m1, MonitorValue* m2) {
2319   assert_equal(m1-&gt;owner(), m2-&gt;owner());
2320   assert_equal(m1-&gt;basic_lock(), m2-&gt;basic_lock());
2321 }
2322 
2323 void assert_equal(IRScopeDebugInfo* d1, IRScopeDebugInfo* d2) {
2324   assert(d1-&gt;scope() == d2-&gt;scope(), &quot;not equal&quot;);
2325   assert(d1-&gt;bci() == d2-&gt;bci(), &quot;not equal&quot;);
2326 
2327   if (d1-&gt;locals() != NULL) {
2328     assert(d1-&gt;locals() != NULL &amp;&amp; d2-&gt;locals() != NULL, &quot;not equal&quot;);
2329     assert(d1-&gt;locals()-&gt;length() == d2-&gt;locals()-&gt;length(), &quot;not equal&quot;);
2330     for (int i = 0; i &lt; d1-&gt;locals()-&gt;length(); i++) {
2331       assert_equal(d1-&gt;locals()-&gt;at(i), d2-&gt;locals()-&gt;at(i));
2332     }
2333   } else {
2334     assert(d1-&gt;locals() == NULL &amp;&amp; d2-&gt;locals() == NULL, &quot;not equal&quot;);
2335   }
2336 
2337   if (d1-&gt;expressions() != NULL) {
2338     assert(d1-&gt;expressions() != NULL &amp;&amp; d2-&gt;expressions() != NULL, &quot;not equal&quot;);
2339     assert(d1-&gt;expressions()-&gt;length() == d2-&gt;expressions()-&gt;length(), &quot;not equal&quot;);
2340     for (int i = 0; i &lt; d1-&gt;expressions()-&gt;length(); i++) {
2341       assert_equal(d1-&gt;expressions()-&gt;at(i), d2-&gt;expressions()-&gt;at(i));
2342     }
2343   } else {
2344     assert(d1-&gt;expressions() == NULL &amp;&amp; d2-&gt;expressions() == NULL, &quot;not equal&quot;);
2345   }
2346 
2347   if (d1-&gt;monitors() != NULL) {
2348     assert(d1-&gt;monitors() != NULL &amp;&amp; d2-&gt;monitors() != NULL, &quot;not equal&quot;);
2349     assert(d1-&gt;monitors()-&gt;length() == d2-&gt;monitors()-&gt;length(), &quot;not equal&quot;);
2350     for (int i = 0; i &lt; d1-&gt;monitors()-&gt;length(); i++) {
2351       assert_equal(d1-&gt;monitors()-&gt;at(i), d2-&gt;monitors()-&gt;at(i));
2352     }
2353   } else {
2354     assert(d1-&gt;monitors() == NULL &amp;&amp; d2-&gt;monitors() == NULL, &quot;not equal&quot;);
2355   }
2356 
2357   if (d1-&gt;caller() != NULL) {
2358     assert(d1-&gt;caller() != NULL &amp;&amp; d2-&gt;caller() != NULL, &quot;not equal&quot;);
2359     assert_equal(d1-&gt;caller(), d2-&gt;caller());
2360   } else {
2361     assert(d1-&gt;caller() == NULL &amp;&amp; d2-&gt;caller() == NULL, &quot;not equal&quot;);
2362   }
2363 }
2364 
2365 void check_stack_depth(CodeEmitInfo* info, int stack_end) {
2366   if (info-&gt;stack()-&gt;bci() != SynchronizationEntryBCI &amp;&amp; !info-&gt;scope()-&gt;method()-&gt;is_native()) {
2367     Bytecodes::Code code = info-&gt;scope()-&gt;method()-&gt;java_code_at_bci(info-&gt;stack()-&gt;bci());
2368     switch (code) {
2369       case Bytecodes::_ifnull    : // fall through
2370       case Bytecodes::_ifnonnull : // fall through
2371       case Bytecodes::_ifeq      : // fall through
2372       case Bytecodes::_ifne      : // fall through
2373       case Bytecodes::_iflt      : // fall through
2374       case Bytecodes::_ifge      : // fall through
2375       case Bytecodes::_ifgt      : // fall through
2376       case Bytecodes::_ifle      : // fall through
2377       case Bytecodes::_if_icmpeq : // fall through
2378       case Bytecodes::_if_icmpne : // fall through
2379       case Bytecodes::_if_icmplt : // fall through
2380       case Bytecodes::_if_icmpge : // fall through
2381       case Bytecodes::_if_icmpgt : // fall through
2382       case Bytecodes::_if_icmple : // fall through
2383       case Bytecodes::_if_acmpeq : // fall through
2384       case Bytecodes::_if_acmpne :
2385         assert(stack_end &gt;= -Bytecodes::depth(code), &quot;must have non-empty expression stack at if bytecode&quot;);
2386         break;
2387       default:
2388         break;
2389     }
2390   }
2391 }
2392 
2393 #endif // ASSERT
2394 
2395 
2396 IntervalWalker* LinearScan::init_compute_oop_maps() {
2397   // setup lists of potential oops for walking
2398   Interval* oop_intervals;
2399   Interval* non_oop_intervals;
2400 
2401   create_unhandled_lists(&amp;oop_intervals, &amp;non_oop_intervals, is_oop_interval, NULL);
2402 
2403   // intervals that have no oops inside need not to be processed
2404   // to ensure a walking until the last instruction id, add a dummy interval
2405   // with a high operation id
2406   non_oop_intervals = new Interval(any_reg);
2407   non_oop_intervals-&gt;add_range(max_jint - 2, max_jint - 1);
2408 
2409   return new IntervalWalker(this, oop_intervals, non_oop_intervals);
2410 }
2411 
2412 
2413 OopMap* LinearScan::compute_oop_map(IntervalWalker* iw, LIR_Op* op, CodeEmitInfo* info, bool is_call_site) {
2414   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;creating oop map at op_id %d&quot;, op-&gt;id()));
2415 
2416   // walk before the current operation -&gt; intervals that start at
2417   // the operation (= output operands of the operation) are not
2418   // included in the oop map
2419   iw-&gt;walk_before(op-&gt;id());
2420 
2421   int frame_size = frame_map()-&gt;framesize();
2422   int arg_count = frame_map()-&gt;oop_map_arg_count();
2423   OopMap* map = new OopMap(frame_size, arg_count);
2424 
2425   // Iterate through active intervals
2426   for (Interval* interval = iw-&gt;active_first(fixedKind); interval != Interval::end(); interval = interval-&gt;next()) {
2427     int assigned_reg = interval-&gt;assigned_reg();
2428 
2429     assert(interval-&gt;current_from() &lt;= op-&gt;id() &amp;&amp; op-&gt;id() &lt;= interval-&gt;current_to(), &quot;interval should not be active otherwise&quot;);
2430     assert(interval-&gt;assigned_regHi() == any_reg, &quot;oop must be single word&quot;);
2431     assert(interval-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base, &quot;fixed interval found&quot;);
2432 
2433     // Check if this range covers the instruction. Intervals that
2434     // start or end at the current operation are not included in the
2435     // oop map, except in the case of patching moves.  For patching
2436     // moves, any intervals which end at this instruction are included
2437     // in the oop map since we may safepoint while doing the patch
2438     // before we&#39;ve consumed the inputs.
2439     if (op-&gt;is_patching() || op-&gt;id() &lt; interval-&gt;current_to()) {
2440 
2441       // caller-save registers must not be included into oop-maps at calls
2442       assert(!is_call_site || assigned_reg &gt;= nof_regs || !is_caller_save(assigned_reg), &quot;interval is in a caller-save register at a call -&gt; register will be overwritten&quot;);
2443 
2444       VMReg name = vm_reg_for_interval(interval);
2445       set_oop(map, name);
2446 
2447       // Spill optimization: when the stack value is guaranteed to be always correct,
2448       // then it must be added to the oop map even if the interval is currently in a register
2449       if (interval-&gt;always_in_memory() &amp;&amp;
2450           op-&gt;id() &gt; interval-&gt;spill_definition_pos() &amp;&amp;
2451           interval-&gt;assigned_reg() != interval-&gt;canonical_spill_slot()) {
2452         assert(interval-&gt;spill_definition_pos() &gt; 0, &quot;position not set correctly&quot;);
2453         assert(interval-&gt;canonical_spill_slot() &gt;= LinearScan::nof_regs, &quot;no spill slot assigned&quot;);
2454         assert(interval-&gt;assigned_reg() &lt; LinearScan::nof_regs, &quot;interval is on stack, so stack slot is registered twice&quot;);
2455 
2456         set_oop(map, frame_map()-&gt;slot_regname(interval-&gt;canonical_spill_slot() - LinearScan::nof_regs));
2457       }
2458     }
2459   }
2460 
2461   // add oops from lock stack
2462   assert(info-&gt;stack() != NULL, &quot;CodeEmitInfo must always have a stack&quot;);
2463   int locks_count = info-&gt;stack()-&gt;total_locks_size();
2464   for (int i = 0; i &lt; locks_count; i++) {
2465     set_oop(map, frame_map()-&gt;monitor_object_regname(i));
2466   }
2467 
2468   return map;
2469 }
2470 
2471 
2472 void LinearScan::compute_oop_map(IntervalWalker* iw, const LIR_OpVisitState &amp;visitor, LIR_Op* op) {
2473   assert(visitor.info_count() &gt; 0, &quot;no oop map needed&quot;);
2474 
2475   // compute oop_map only for first CodeEmitInfo
2476   // because it is (in most cases) equal for all other infos of the same operation
2477   CodeEmitInfo* first_info = visitor.info_at(0);
2478   OopMap* first_oop_map = compute_oop_map(iw, op, first_info, visitor.has_call());
2479 
2480   for (int i = 0; i &lt; visitor.info_count(); i++) {
2481     CodeEmitInfo* info = visitor.info_at(i);
2482     OopMap* oop_map = first_oop_map;
2483 
2484     // compute worst case interpreter size in case of a deoptimization
2485     _compilation-&gt;update_interpreter_frame_size(info-&gt;interpreter_frame_size());
2486 
2487     if (info-&gt;stack()-&gt;locks_size() != first_info-&gt;stack()-&gt;locks_size()) {
2488       // this info has a different number of locks then the precomputed oop map
2489       // (possible for lock and unlock instructions) -&gt; compute oop map with
2490       // correct lock information
2491       oop_map = compute_oop_map(iw, op, info, visitor.has_call());
2492     }
2493 
2494     if (info-&gt;_oop_map == NULL) {
2495       info-&gt;_oop_map = oop_map;
2496     } else {
2497       // a CodeEmitInfo can not be shared between different LIR-instructions
2498       // because interval splitting can occur anywhere between two instructions
2499       // and so the oop maps must be different
2500       // -&gt; check if the already set oop_map is exactly the one calculated for this operation
2501       assert(info-&gt;_oop_map == oop_map, &quot;same CodeEmitInfo used for multiple LIR instructions&quot;);
2502     }
2503   }
2504 }
2505 
2506 
2507 // frequently used constants
2508 // Allocate them with new so they are never destroyed (otherwise, a
2509 // forced exit could destroy these objects while they are still in
2510 // use).
2511 ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantOopWriteValue(NULL);
2512 ConstantIntValue*      LinearScan::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(-1);
2513 ConstantIntValue*      LinearScan::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue((jint)0);
2514 ConstantIntValue*      LinearScan::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(1);
2515 ConstantIntValue*      LinearScan::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(2);
2516 LocationValue*         _illegal_value = new (ResourceObj::C_HEAP, mtCompiler) LocationValue(Location());
2517 
2518 void LinearScan::init_compute_debug_info() {
2519   // cache for frequently used scope values
2520   // (cpu registers and stack slots)
2521   int cache_size = (LinearScan::nof_cpu_regs + frame_map()-&gt;argcount() + max_spills()) * 2;
2522   _scope_value_cache = ScopeValueArray(cache_size, cache_size, NULL);
2523 }
2524 
2525 MonitorValue* LinearScan::location_for_monitor_index(int monitor_index) {
2526   Location loc;
2527   if (!frame_map()-&gt;location_for_monitor_object(monitor_index, &amp;loc)) {
2528     bailout(&quot;too large frame&quot;);
2529   }
2530   ScopeValue* object_scope_value = new LocationValue(loc);
2531 
2532   if (!frame_map()-&gt;location_for_monitor_lock(monitor_index, &amp;loc)) {
2533     bailout(&quot;too large frame&quot;);
2534   }
2535   return new MonitorValue(object_scope_value, loc);
2536 }
2537 
2538 LocationValue* LinearScan::location_for_name(int name, Location::Type loc_type) {
2539   Location loc;
2540   if (!frame_map()-&gt;locations_for_slot(name, loc_type, &amp;loc)) {
2541     bailout(&quot;too large frame&quot;);
2542   }
2543   return new LocationValue(loc);
2544 }
2545 
2546 
2547 int LinearScan::append_scope_value_for_constant(LIR_Opr opr, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2548   assert(opr-&gt;is_constant(), &quot;should not be called otherwise&quot;);
2549 
2550   LIR_Const* c = opr-&gt;as_constant_ptr();
2551   BasicType t = c-&gt;type();
2552   switch (t) {
2553     case T_OBJECT: {
2554       jobject value = c-&gt;as_jobject();
2555       if (value == NULL) {
2556         scope_values-&gt;append(_oop_null_scope_value);
2557       } else {
2558         scope_values-&gt;append(new ConstantOopWriteValue(c-&gt;as_jobject()));
2559       }
2560       return 1;
2561     }
2562 
2563     case T_INT: // fall through
2564     case T_FLOAT: {
2565       int value = c-&gt;as_jint_bits();
2566       switch (value) {
2567         case -1: scope_values-&gt;append(_int_m1_scope_value); break;
2568         case 0:  scope_values-&gt;append(_int_0_scope_value); break;
2569         case 1:  scope_values-&gt;append(_int_1_scope_value); break;
2570         case 2:  scope_values-&gt;append(_int_2_scope_value); break;
2571         default: scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_bits())); break;
2572       }
2573       return 1;
2574     }
2575 
2576     case T_LONG: // fall through
2577     case T_DOUBLE: {
2578 #ifdef _LP64
2579       scope_values-&gt;append(_int_0_scope_value);
2580       scope_values-&gt;append(new ConstantLongValue(c-&gt;as_jlong_bits()));
2581 #else
2582       if (hi_word_offset_in_bytes &gt; lo_word_offset_in_bytes) {
2583         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_hi_bits()));
2584         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_lo_bits()));
2585       } else {
2586         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_lo_bits()));
2587         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_hi_bits()));
2588       }
2589 #endif
2590       return 2;
2591     }
2592 
2593     case T_ADDRESS: {
2594 #ifdef _LP64
2595       scope_values-&gt;append(new ConstantLongValue(c-&gt;as_jint()));
2596 #else
2597       scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint()));
2598 #endif
2599       return 1;
2600     }
2601 
2602     default:
2603       ShouldNotReachHere();
2604       return -1;
2605   }
2606 }
2607 
2608 int LinearScan::append_scope_value_for_operand(LIR_Opr opr, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2609   if (opr-&gt;is_single_stack()) {
2610     int stack_idx = opr-&gt;single_stack_ix();
2611     bool is_oop = opr-&gt;is_oop_register();
2612     int cache_idx = (stack_idx + LinearScan::nof_cpu_regs) * 2 + (is_oop ? 1 : 0);
2613 
2614     ScopeValue* sv = _scope_value_cache.at(cache_idx);
2615     if (sv == NULL) {
2616       Location::Type loc_type = is_oop ? Location::oop : Location::normal;
2617       sv = location_for_name(stack_idx, loc_type);
2618       _scope_value_cache.at_put(cache_idx, sv);
2619     }
2620 
2621     // check if cached value is correct
2622     DEBUG_ONLY(assert_equal(sv, location_for_name(stack_idx, is_oop ? Location::oop : Location::normal)));
2623 
2624     scope_values-&gt;append(sv);
2625     return 1;
2626 
2627   } else if (opr-&gt;is_single_cpu()) {
2628     bool is_oop = opr-&gt;is_oop_register();
2629     int cache_idx = opr-&gt;cpu_regnr() * 2 + (is_oop ? 1 : 0);
2630     Location::Type int_loc_type = NOT_LP64(Location::normal) LP64_ONLY(Location::int_in_long);
2631 
2632     ScopeValue* sv = _scope_value_cache.at(cache_idx);
2633     if (sv == NULL) {
2634       Location::Type loc_type = is_oop ? Location::oop : int_loc_type;
2635       VMReg rname = frame_map()-&gt;regname(opr);
2636       sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2637       _scope_value_cache.at_put(cache_idx, sv);
2638     }
2639 
2640     // check if cached value is correct
2641     DEBUG_ONLY(assert_equal(sv, new LocationValue(Location::new_reg_loc(is_oop ? Location::oop : int_loc_type, frame_map()-&gt;regname(opr)))));
2642 
2643     scope_values-&gt;append(sv);
2644     return 1;
2645 
2646 #ifdef X86
2647   } else if (opr-&gt;is_single_xmm()) {
2648     VMReg rname = opr-&gt;as_xmm_float_reg()-&gt;as_VMReg();
2649     LocationValue* sv = new LocationValue(Location::new_reg_loc(Location::normal, rname));
2650 
2651     scope_values-&gt;append(sv);
2652     return 1;
2653 #endif
2654 
2655   } else if (opr-&gt;is_single_fpu()) {
<a name="2" id="anc2"></a><span class="line-modified">2656 #ifdef X86</span>
2657     // the exact location of fpu stack values is only known
2658     // during fpu stack allocation, so the stack allocator object
2659     // must be present
2660     assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2661     assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2662     opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
<a name="3" id="anc3"></a>

2663 #endif
2664 
2665     Location::Type loc_type = float_saved_as_double ? Location::float_in_dbl : Location::normal;
2666     VMReg rname = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnr());
2667 #ifndef __SOFTFP__
2668 #ifndef VM_LITTLE_ENDIAN
2669     // On S390 a (single precision) float value occupies only the high
2670     // word of the full double register. So when the double register is
2671     // stored to memory (e.g. by the RegisterSaver), then the float value
2672     // is found at offset 0. I.e. the code below is not needed on S390.
2673 #ifndef S390
2674     if (! float_saved_as_double) {
2675       // On big endian system, we may have an issue if float registers use only
2676       // the low half of the (same) double registers.
2677       // Both the float and the double could have the same regnr but would correspond
2678       // to two different addresses once saved.
2679 
2680       // get next safely (no assertion checks)
2681       VMReg next = VMRegImpl::as_VMReg(1+rname-&gt;value());
2682       if (next-&gt;is_reg() &amp;&amp;
2683           (next-&gt;as_FloatRegister() == rname-&gt;as_FloatRegister())) {
2684         // the back-end does use the same numbering for the double and the float
2685         rname = next; // VMReg for the low bits, e.g. the real VMReg for the float
2686       }
2687     }
2688 #endif // !S390
2689 #endif
2690 #endif
2691     LocationValue* sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2692 
2693     scope_values-&gt;append(sv);
2694     return 1;
2695 
2696   } else {
2697     // double-size operands
2698 
2699     ScopeValue* first;
2700     ScopeValue* second;
2701 
2702     if (opr-&gt;is_double_stack()) {
2703 #ifdef _LP64
2704       Location loc1;
2705       Location::Type loc_type = opr-&gt;type() == T_LONG ? Location::lng : Location::dbl;
2706       if (!frame_map()-&gt;locations_for_slot(opr-&gt;double_stack_ix(), loc_type, &amp;loc1, NULL)) {
2707         bailout(&quot;too large frame&quot;);
2708       }
2709       // Does this reverse on x86 vs. sparc?
2710       first =  new LocationValue(loc1);
2711       second = _int_0_scope_value;
2712 #else
2713       Location loc1, loc2;
2714       if (!frame_map()-&gt;locations_for_slot(opr-&gt;double_stack_ix(), Location::normal, &amp;loc1, &amp;loc2)) {
2715         bailout(&quot;too large frame&quot;);
2716       }
2717       first =  new LocationValue(loc1);
2718       second = new LocationValue(loc2);
2719 #endif // _LP64
2720 
2721     } else if (opr-&gt;is_double_cpu()) {
2722 #ifdef _LP64
2723       VMReg rname_first = opr-&gt;as_register_lo()-&gt;as_VMReg();
2724       first = new LocationValue(Location::new_reg_loc(Location::lng, rname_first));
2725       second = _int_0_scope_value;
2726 #else
2727       VMReg rname_first = opr-&gt;as_register_lo()-&gt;as_VMReg();
2728       VMReg rname_second = opr-&gt;as_register_hi()-&gt;as_VMReg();
2729 
2730       if (hi_word_offset_in_bytes &lt; lo_word_offset_in_bytes) {
2731         // lo/hi and swapped relative to first and second, so swap them
2732         VMReg tmp = rname_first;
2733         rname_first = rname_second;
2734         rname_second = tmp;
2735       }
2736 
2737       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2738       second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2739 #endif //_LP64
2740 
2741 
2742 #ifdef X86
2743     } else if (opr-&gt;is_double_xmm()) {
2744       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation&quot;);
2745       VMReg rname_first  = opr-&gt;as_xmm_double_reg()-&gt;as_VMReg();
2746 #  ifdef _LP64
2747       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2748       second = _int_0_scope_value;
2749 #  else
2750       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2751       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2752       if (true) {
2753         VMReg rname_second = rname_first-&gt;next();
2754         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2755       }
2756 #  endif
2757 #endif
2758 
2759     } else if (opr-&gt;is_double_fpu()) {
2760       // On SPARC, fpu_regnrLo/fpu_regnrHi represents the two halves of
2761       // the double as float registers in the native ordering. On X86,
2762       // fpu_regnrLo is a FPU stack slot whose VMReg represents
2763       // the low-order word of the double and fpu_regnrLo + 1 is the
2764       // name for the other half.  *first and *second must represent the
2765       // least and most significant words, respectively.
2766 
<a name="4" id="anc4"></a><span class="line-modified">2767 #ifdef X86</span>
2768       // the exact location of fpu stack values is only known
2769       // during fpu stack allocation, so the stack allocator object
2770       // must be present
2771       assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2772       assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2773       opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2774 
2775       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2776 #endif
<a name="5" id="anc5"></a>


2777 #ifdef SPARC
2778       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi() + 1, &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2779 #endif
2780 #ifdef ARM32
2781       assert(opr-&gt;fpu_regnrHi() == opr-&gt;fpu_regnrLo() + 1, &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2782 #endif
2783 #ifdef PPC32
2784       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2785 #endif
2786 
2787 #ifdef VM_LITTLE_ENDIAN
2788       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrLo());
2789 #else
2790       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrHi());
2791 #endif
2792 
2793 #ifdef _LP64
2794       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2795       second = _int_0_scope_value;
2796 #else
2797       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2798       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2799       if (true) {
2800         VMReg rname_second = rname_first-&gt;next();
2801         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2802       }
2803 #endif
2804 
2805     } else {
2806       ShouldNotReachHere();
2807       first = NULL;
2808       second = NULL;
2809     }
2810 
2811     assert(first != NULL &amp;&amp; second != NULL, &quot;must be set&quot;);
2812     // The convention the interpreter uses is that the second local
2813     // holds the first raw word of the native double representation.
2814     // This is actually reasonable, since locals and stack arrays
2815     // grow downwards in all implementations.
2816     // (If, on some machine, the interpreter&#39;s Java locals or stack
2817     // were to grow upwards, the embedded doubles would be word-swapped.)
2818     scope_values-&gt;append(second);
2819     scope_values-&gt;append(first);
2820     return 2;
2821   }
2822 }
2823 
2824 
2825 int LinearScan::append_scope_value(int op_id, Value value, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2826   if (value != NULL) {
2827     LIR_Opr opr = value-&gt;operand();
2828     Constant* con = value-&gt;as_Constant();
2829 
2830     assert(con == NULL || opr-&gt;is_virtual() || opr-&gt;is_constant() || opr-&gt;is_illegal(), &quot;asumption: Constant instructions have only constant operands (or illegal if constant is optimized away)&quot;);
2831     assert(con != NULL || opr-&gt;is_virtual(), &quot;asumption: non-Constant instructions have only virtual operands&quot;);
2832 
2833     if (con != NULL &amp;&amp; !con-&gt;is_pinned() &amp;&amp; !opr-&gt;is_constant()) {
2834       // Unpinned constants may have a virtual operand for a part of the lifetime
2835       // or may be illegal when it was optimized away,
2836       // so always use a constant operand
2837       opr = LIR_OprFact::value_type(con-&gt;type());
2838     }
2839     assert(opr-&gt;is_virtual() || opr-&gt;is_constant(), &quot;other cases not allowed here&quot;);
2840 
2841     if (opr-&gt;is_virtual()) {
2842       LIR_OpVisitState::OprMode mode = LIR_OpVisitState::inputMode;
2843 
2844       BlockBegin* block = block_of_op_with_id(op_id);
2845       if (block-&gt;number_of_sux() == 1 &amp;&amp; op_id == block-&gt;last_lir_instruction_id()) {
2846         // generating debug information for the last instruction of a block.
2847         // if this instruction is a branch, spill moves are inserted before this branch
2848         // and so the wrong operand would be returned (spill moves at block boundaries are not
2849         // considered in the live ranges of intervals)
2850         // Solution: use the first op_id of the branch target block instead.
2851         if (block-&gt;lir()-&gt;instructions_list()-&gt;last()-&gt;as_OpBranch() != NULL) {
2852           if (block-&gt;live_out().at(opr-&gt;vreg_number())) {
2853             op_id = block-&gt;sux_at(0)-&gt;first_lir_instruction_id();
2854             mode = LIR_OpVisitState::outputMode;
2855           }
2856         }
2857       }
2858 
2859       // Get current location of operand
2860       // The operand must be live because debug information is considered when building the intervals
2861       // if the interval is not live, color_lir_opr will cause an assertion failure
2862       opr = color_lir_opr(opr, op_id, mode);
2863       assert(!has_call(op_id) || opr-&gt;is_stack() || !is_caller_save(reg_num(opr)), &quot;can not have caller-save register operands at calls&quot;);
2864 
2865       // Append to ScopeValue array
2866       return append_scope_value_for_operand(opr, scope_values);
2867 
2868     } else {
2869       assert(value-&gt;as_Constant() != NULL, &quot;all other instructions have only virtual operands&quot;);
2870       assert(opr-&gt;is_constant(), &quot;operand must be constant&quot;);
2871 
2872       return append_scope_value_for_constant(opr, scope_values);
2873     }
2874   } else {
2875     // append a dummy value because real value not needed
2876     scope_values-&gt;append(_illegal_value);
2877     return 1;
2878   }
2879 }
2880 
2881 
2882 IRScopeDebugInfo* LinearScan::compute_debug_info_for_scope(int op_id, IRScope* cur_scope, ValueStack* cur_state, ValueStack* innermost_state) {
2883   IRScopeDebugInfo* caller_debug_info = NULL;
2884 
2885   ValueStack* caller_state = cur_state-&gt;caller_state();
2886   if (caller_state != NULL) {
2887     // process recursively to compute outermost scope first
2888     caller_debug_info = compute_debug_info_for_scope(op_id, cur_scope-&gt;caller(), caller_state, innermost_state);
2889   }
2890 
2891   // initialize these to null.
2892   // If we don&#39;t need deopt info or there are no locals, expressions or monitors,
2893   // then these get recorded as no information and avoids the allocation of 0 length arrays.
2894   GrowableArray&lt;ScopeValue*&gt;*   locals      = NULL;
2895   GrowableArray&lt;ScopeValue*&gt;*   expressions = NULL;
2896   GrowableArray&lt;MonitorValue*&gt;* monitors    = NULL;
2897 
2898   // describe local variable values
2899   int nof_locals = cur_state-&gt;locals_size();
2900   if (nof_locals &gt; 0) {
2901     locals = new GrowableArray&lt;ScopeValue*&gt;(nof_locals);
2902 
2903     int pos = 0;
2904     while (pos &lt; nof_locals) {
2905       assert(pos &lt; cur_state-&gt;locals_size(), &quot;why not?&quot;);
2906 
2907       Value local = cur_state-&gt;local_at(pos);
2908       pos += append_scope_value(op_id, local, locals);
2909 
2910       assert(locals-&gt;length() == pos, &quot;must match&quot;);
2911     }
2912     assert(locals-&gt;length() == cur_scope-&gt;method()-&gt;max_locals(), &quot;wrong number of locals&quot;);
2913     assert(locals-&gt;length() == cur_state-&gt;locals_size(), &quot;wrong number of locals&quot;);
2914   } else if (cur_scope-&gt;method()-&gt;max_locals() &gt; 0) {
2915     assert(cur_state-&gt;kind() == ValueStack::EmptyExceptionState, &quot;should be&quot;);
2916     nof_locals = cur_scope-&gt;method()-&gt;max_locals();
2917     locals = new GrowableArray&lt;ScopeValue*&gt;(nof_locals);
2918     for(int i = 0; i &lt; nof_locals; i++) {
2919       locals-&gt;append(_illegal_value);
2920     }
2921   }
2922 
2923   // describe expression stack
2924   int nof_stack = cur_state-&gt;stack_size();
2925   if (nof_stack &gt; 0) {
2926     expressions = new GrowableArray&lt;ScopeValue*&gt;(nof_stack);
2927 
2928     int pos = 0;
2929     while (pos &lt; nof_stack) {
2930       Value expression = cur_state-&gt;stack_at_inc(pos);
2931       append_scope_value(op_id, expression, expressions);
2932 
2933       assert(expressions-&gt;length() == pos, &quot;must match&quot;);
2934     }
2935     assert(expressions-&gt;length() == cur_state-&gt;stack_size(), &quot;wrong number of stack entries&quot;);
2936   }
2937 
2938   // describe monitors
2939   int nof_locks = cur_state-&gt;locks_size();
2940   if (nof_locks &gt; 0) {
2941     int lock_offset = cur_state-&gt;caller_state() != NULL ? cur_state-&gt;caller_state()-&gt;total_locks_size() : 0;
2942     monitors = new GrowableArray&lt;MonitorValue*&gt;(nof_locks);
2943     for (int i = 0; i &lt; nof_locks; i++) {
2944       monitors-&gt;append(location_for_monitor_index(lock_offset + i));
2945     }
2946   }
2947 
2948   return new IRScopeDebugInfo(cur_scope, cur_state-&gt;bci(), locals, expressions, monitors, caller_debug_info);
2949 }
2950 
2951 
2952 void LinearScan::compute_debug_info(CodeEmitInfo* info, int op_id) {
2953   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;creating debug information at op_id %d&quot;, op_id));
2954 
2955   IRScope* innermost_scope = info-&gt;scope();
2956   ValueStack* innermost_state = info-&gt;stack();
2957 
2958   assert(innermost_scope != NULL &amp;&amp; innermost_state != NULL, &quot;why is it missing?&quot;);
2959 
2960   DEBUG_ONLY(check_stack_depth(info, innermost_state-&gt;stack_size()));
2961 
2962   if (info-&gt;_scope_debug_info == NULL) {
2963     // compute debug information
2964     info-&gt;_scope_debug_info = compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state);
2965   } else {
2966     // debug information already set. Check that it is correct from the current point of view
2967     DEBUG_ONLY(assert_equal(info-&gt;_scope_debug_info, compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state)));
2968   }
2969 }
2970 
2971 
2972 void LinearScan::assign_reg_num(LIR_OpList* instructions, IntervalWalker* iw) {
2973   LIR_OpVisitState visitor;
2974   int num_inst = instructions-&gt;length();
2975   bool has_dead = false;
2976 
2977   for (int j = 0; j &lt; num_inst; j++) {
2978     LIR_Op* op = instructions-&gt;at(j);
2979     if (op == NULL) {  // this can happen when spill-moves are removed in eliminate_spill_moves
2980       has_dead = true;
2981       continue;
2982     }
2983     int op_id = op-&gt;id();
2984 
2985     // visit instruction to get list of operands
2986     visitor.visit(op);
2987 
2988     // iterate all modes of the visitor and process all virtual operands
2989     for_each_visitor_mode(mode) {
2990       int n = visitor.opr_count(mode);
2991       for (int k = 0; k &lt; n; k++) {
2992         LIR_Opr opr = visitor.opr_at(mode, k);
2993         if (opr-&gt;is_virtual_register()) {
2994           visitor.set_opr_at(mode, k, color_lir_opr(opr, op_id, mode));
2995         }
2996       }
2997     }
2998 
2999     if (visitor.info_count() &gt; 0) {
3000       // exception handling
3001       if (compilation()-&gt;has_exception_handlers()) {
3002         XHandlers* xhandlers = visitor.all_xhandler();
3003         int n = xhandlers-&gt;length();
3004         for (int k = 0; k &lt; n; k++) {
3005           XHandler* handler = xhandlers-&gt;handler_at(k);
3006           if (handler-&gt;entry_code() != NULL) {
3007             assign_reg_num(handler-&gt;entry_code()-&gt;instructions_list(), NULL);
3008           }
3009         }
3010       } else {
3011         assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
3012       }
3013 
3014       // compute oop map
3015       assert(iw != NULL, &quot;needed for compute_oop_map&quot;);
3016       compute_oop_map(iw, visitor, op);
3017 
3018       // compute debug information
3019       if (!use_fpu_stack_allocation()) {
3020         // compute debug information if fpu stack allocation is not needed.
3021         // when fpu stack allocation is needed, the debug information can not
3022         // be computed here because the exact location of fpu operands is not known
3023         // -&gt; debug information is created inside the fpu stack allocator
3024         int n = visitor.info_count();
3025         for (int k = 0; k &lt; n; k++) {
3026           compute_debug_info(visitor.info_at(k), op_id);
3027         }
3028       }
3029     }
3030 
3031 #ifdef ASSERT
3032     // make sure we haven&#39;t made the op invalid.
3033     op-&gt;verify();
3034 #endif
3035 
3036     // remove useless moves
3037     if (op-&gt;code() == lir_move) {
3038       assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
3039       LIR_Op1* move = (LIR_Op1*)op;
3040       LIR_Opr src = move-&gt;in_opr();
3041       LIR_Opr dst = move-&gt;result_opr();
3042       if (dst == src ||
3043           (!dst-&gt;is_pointer() &amp;&amp; !src-&gt;is_pointer() &amp;&amp;
3044            src-&gt;is_same_register(dst))) {
3045         instructions-&gt;at_put(j, NULL);
3046         has_dead = true;
3047       }
3048     }
3049   }
3050 
3051   if (has_dead) {
3052     // iterate all instructions of the block and remove all null-values.
3053     int insert_point = 0;
3054     for (int j = 0; j &lt; num_inst; j++) {
3055       LIR_Op* op = instructions-&gt;at(j);
3056       if (op != NULL) {
3057         if (insert_point != j) {
3058           instructions-&gt;at_put(insert_point, op);
3059         }
3060         insert_point++;
3061       }
3062     }
3063     instructions-&gt;trunc_to(insert_point);
3064   }
3065 }
3066 
3067 void LinearScan::assign_reg_num() {
3068   TIME_LINEAR_SCAN(timer_assign_reg_num);
3069 
3070   init_compute_debug_info();
3071   IntervalWalker* iw = init_compute_oop_maps();
3072 
3073   int num_blocks = block_count();
3074   for (int i = 0; i &lt; num_blocks; i++) {
3075     BlockBegin* block = block_at(i);
3076     assign_reg_num(block-&gt;lir()-&gt;instructions_list(), iw);
3077   }
3078 }
3079 
3080 
3081 void LinearScan::do_linear_scan() {
3082   NOT_PRODUCT(_total_timer.begin_method());
3083 
3084   number_instructions();
3085 
3086   NOT_PRODUCT(print_lir(1, &quot;Before Register Allocation&quot;));
3087 
3088   compute_local_live_sets();
3089   compute_global_live_sets();
3090   CHECK_BAILOUT();
3091 
3092   build_intervals();
3093   CHECK_BAILOUT();
3094   sort_intervals_before_allocation();
3095 
3096   NOT_PRODUCT(print_intervals(&quot;Before Register Allocation&quot;));
3097   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_before_alloc));
3098 
3099   allocate_registers();
3100   CHECK_BAILOUT();
3101 
3102   resolve_data_flow();
3103   if (compilation()-&gt;has_exception_handlers()) {
3104     resolve_exception_handlers();
3105   }
3106   // fill in number of spill slots into frame_map
3107   propagate_spill_slots();
3108   CHECK_BAILOUT();
3109 
3110   NOT_PRODUCT(print_intervals(&quot;After Register Allocation&quot;));
3111   NOT_PRODUCT(print_lir(2, &quot;LIR after register allocation:&quot;));
3112 
3113   sort_intervals_after_allocation();
3114 
3115   DEBUG_ONLY(verify());
3116 
3117   eliminate_spill_moves();
3118   assign_reg_num();
3119   CHECK_BAILOUT();
3120 
3121   NOT_PRODUCT(print_lir(2, &quot;LIR after assignment of register numbers:&quot;));
3122   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_after_asign));
3123 
3124   { TIME_LINEAR_SCAN(timer_allocate_fpu_stack);
3125 
3126     if (use_fpu_stack_allocation()) {
3127       allocate_fpu_stack(); // Only has effect on Intel
3128       NOT_PRODUCT(print_lir(2, &quot;LIR after FPU stack allocation:&quot;));
3129     }
3130   }
3131 
3132   { TIME_LINEAR_SCAN(timer_optimize_lir);
3133 
3134     EdgeMoveOptimizer::optimize(ir()-&gt;code());
3135     ControlFlowOptimizer::optimize(ir()-&gt;code());
3136     // check that cfg is still correct after optimizations
3137     ir()-&gt;verify();
3138   }
3139 
3140   NOT_PRODUCT(print_lir(1, &quot;Before Code Generation&quot;, false));
3141   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_final));
3142   NOT_PRODUCT(_total_timer.end_method(this));
3143 }
3144 
3145 
3146 // ********** Printing functions
3147 
3148 #ifndef PRODUCT
3149 
3150 void LinearScan::print_timers(double total) {
3151   _total_timer.print(total);
3152 }
3153 
3154 void LinearScan::print_statistics() {
3155   _stat_before_alloc.print(&quot;before allocation&quot;);
3156   _stat_after_asign.print(&quot;after assignment of register&quot;);
3157   _stat_final.print(&quot;after optimization&quot;);
3158 }
3159 
3160 void LinearScan::print_bitmap(BitMap&amp; b) {
3161   for (unsigned int i = 0; i &lt; b.size(); i++) {
3162     if (b.at(i)) tty-&gt;print(&quot;%d &quot;, i);
3163   }
3164   tty-&gt;cr();
3165 }
3166 
3167 void LinearScan::print_intervals(const char* label) {
3168   if (TraceLinearScanLevel &gt;= 1) {
3169     int i;
3170     tty-&gt;cr();
3171     tty-&gt;print_cr(&quot;%s&quot;, label);
3172 
3173     for (i = 0; i &lt; interval_count(); i++) {
3174       Interval* interval = interval_at(i);
3175       if (interval != NULL) {
3176         interval-&gt;print();
3177       }
3178     }
3179 
3180     tty-&gt;cr();
3181     tty-&gt;print_cr(&quot;--- Basic Blocks ---&quot;);
3182     for (i = 0; i &lt; block_count(); i++) {
3183       BlockBegin* block = block_at(i);
3184       tty-&gt;print(&quot;B%d [%d, %d, %d, %d] &quot;, block-&gt;block_id(), block-&gt;first_lir_instruction_id(), block-&gt;last_lir_instruction_id(), block-&gt;loop_index(), block-&gt;loop_depth());
3185     }
3186     tty-&gt;cr();
3187     tty-&gt;cr();
3188   }
3189 
3190   if (PrintCFGToFile) {
3191     CFGPrinter::print_intervals(&amp;_intervals, label);
3192   }
3193 }
3194 
3195 void LinearScan::print_lir(int level, const char* label, bool hir_valid) {
3196   if (TraceLinearScanLevel &gt;= level) {
3197     tty-&gt;cr();
3198     tty-&gt;print_cr(&quot;%s&quot;, label);
3199     print_LIR(ir()-&gt;linear_scan_order());
3200     tty-&gt;cr();
3201   }
3202 
3203   if (level == 1 &amp;&amp; PrintCFGToFile) {
3204     CFGPrinter::print_cfg(ir()-&gt;linear_scan_order(), label, hir_valid, true);
3205   }
3206 }
3207 
3208 #endif //PRODUCT
3209 
3210 
3211 // ********** verification functions for allocation
3212 // (check that all intervals have a correct register and that no registers are overwritten)
3213 #ifdef ASSERT
3214 
3215 void LinearScan::verify() {
3216   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying intervals ******************************************&quot;));
3217   verify_intervals();
3218 
3219   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying that no oops are in fixed intervals ****************&quot;));
3220   verify_no_oops_in_fixed_intervals();
3221 
3222   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying that unpinned constants are not alive across block boundaries&quot;));
3223   verify_constants();
3224 
3225   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying register allocation ********************************&quot;));
3226   verify_registers();
3227 
3228   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* no errors found **********************************************&quot;));
3229 }
3230 
3231 void LinearScan::verify_intervals() {
3232   int len = interval_count();
3233   bool has_error = false;
3234 
3235   for (int i = 0; i &lt; len; i++) {
3236     Interval* i1 = interval_at(i);
3237     if (i1 == NULL) continue;
3238 
3239     i1-&gt;check_split_children();
3240 
3241     if (i1-&gt;reg_num() != i) {
3242       tty-&gt;print_cr(&quot;Interval %d is on position %d in list&quot;, i1-&gt;reg_num(), i); i1-&gt;print(); tty-&gt;cr();
3243       has_error = true;
3244     }
3245 
3246     if (i1-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; i1-&gt;type() == T_ILLEGAL) {
3247       tty-&gt;print_cr(&quot;Interval %d has no type assigned&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3248       has_error = true;
3249     }
3250 
3251     if (i1-&gt;assigned_reg() == any_reg) {
3252       tty-&gt;print_cr(&quot;Interval %d has no register assigned&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3253       has_error = true;
3254     }
3255 
3256     if (i1-&gt;assigned_reg() == i1-&gt;assigned_regHi()) {
3257       tty-&gt;print_cr(&quot;Interval %d: low and high register equal&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3258       has_error = true;
3259     }
3260 
3261     if (!is_processed_reg_num(i1-&gt;assigned_reg())) {
3262       tty-&gt;print_cr(&quot;Can not have an Interval for an ignored register&quot;); i1-&gt;print(); tty-&gt;cr();
3263       has_error = true;
3264     }
3265 
3266     // special intervals that are created in MoveResolver
3267     // -&gt; ignore them because the range information has no meaning there
3268     if (i1-&gt;from() == 1 &amp;&amp; i1-&gt;to() == 2) continue;
3269 
3270     if (i1-&gt;first() == Range::end()) {
3271       tty-&gt;print_cr(&quot;Interval %d has no Range&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3272       has_error = true;
3273     }
3274 
3275     for (Range* r = i1-&gt;first(); r != Range::end(); r = r-&gt;next()) {
3276       if (r-&gt;from() &gt;= r-&gt;to()) {
3277         tty-&gt;print_cr(&quot;Interval %d has zero length range&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3278         has_error = true;
3279       }
3280     }
3281 
3282     for (int j = i + 1; j &lt; len; j++) {
3283       Interval* i2 = interval_at(j);
3284       if (i2 == NULL || (i2-&gt;from() == 1 &amp;&amp; i2-&gt;to() == 2)) continue;
3285 
3286       int r1 = i1-&gt;assigned_reg();
3287       int r1Hi = i1-&gt;assigned_regHi();
3288       int r2 = i2-&gt;assigned_reg();
3289       int r2Hi = i2-&gt;assigned_regHi();
3290       if ((r1 == r2 || r1 == r2Hi || (r1Hi != any_reg &amp;&amp; (r1Hi == r2 || r1Hi == r2Hi))) &amp;&amp; i1-&gt;intersects(i2)) {
3291         tty-&gt;print_cr(&quot;Intervals %d and %d overlap and have the same register assigned&quot;, i1-&gt;reg_num(), i2-&gt;reg_num());
3292         i1-&gt;print(); tty-&gt;cr();
3293         i2-&gt;print(); tty-&gt;cr();
3294         has_error = true;
3295       }
3296     }
3297   }
3298 
3299   assert(has_error == false, &quot;register allocation invalid&quot;);
3300 }
3301 
3302 
3303 void LinearScan::verify_no_oops_in_fixed_intervals() {
3304   Interval* fixed_intervals;
3305   Interval* other_intervals;
3306   create_unhandled_lists(&amp;fixed_intervals, &amp;other_intervals, is_precolored_cpu_interval, NULL);
3307 
3308   // to ensure a walking until the last instruction id, add a dummy interval
3309   // with a high operation id
3310   other_intervals = new Interval(any_reg);
3311   other_intervals-&gt;add_range(max_jint - 2, max_jint - 1);
3312   IntervalWalker* iw = new IntervalWalker(this, fixed_intervals, other_intervals);
3313 
3314   LIR_OpVisitState visitor;
3315   for (int i = 0; i &lt; block_count(); i++) {
3316     BlockBegin* block = block_at(i);
3317 
3318     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
3319 
3320     for (int j = 0; j &lt; instructions-&gt;length(); j++) {
3321       LIR_Op* op = instructions-&gt;at(j);
3322       int op_id = op-&gt;id();
3323 
3324       visitor.visit(op);
3325 
3326       if (visitor.info_count() &gt; 0) {
3327         iw-&gt;walk_before(op-&gt;id());
3328         bool check_live = true;
3329         if (op-&gt;code() == lir_move) {
3330           LIR_Op1* move = (LIR_Op1*)op;
3331           check_live = (move-&gt;patch_code() == lir_patch_none);
3332         }
3333         LIR_OpBranch* branch = op-&gt;as_OpBranch();
3334         if (branch != NULL &amp;&amp; branch-&gt;stub() != NULL &amp;&amp; branch-&gt;stub()-&gt;is_exception_throw_stub()) {
3335           // Don&#39;t bother checking the stub in this case since the
3336           // exception stub will never return to normal control flow.
3337           check_live = false;
3338         }
3339 
3340         // Make sure none of the fixed registers is live across an
3341         // oopmap since we can&#39;t handle that correctly.
3342         if (check_live) {
3343           for (Interval* interval = iw-&gt;active_first(fixedKind);
3344                interval != Interval::end();
3345                interval = interval-&gt;next()) {
3346             if (interval-&gt;current_to() &gt; op-&gt;id() + 1) {
3347               // This interval is live out of this op so make sure
3348               // that this interval represents some value that&#39;s
3349               // referenced by this op either as an input or output.
3350               bool ok = false;
3351               for_each_visitor_mode(mode) {
3352                 int n = visitor.opr_count(mode);
3353                 for (int k = 0; k &lt; n; k++) {
3354                   LIR_Opr opr = visitor.opr_at(mode, k);
3355                   if (opr-&gt;is_fixed_cpu()) {
3356                     if (interval_at(reg_num(opr)) == interval) {
3357                       ok = true;
3358                       break;
3359                     }
3360                     int hi = reg_numHi(opr);
3361                     if (hi != -1 &amp;&amp; interval_at(hi) == interval) {
3362                       ok = true;
3363                       break;
3364                     }
3365                   }
3366                 }
3367               }
3368               assert(ok, &quot;fixed intervals should never be live across an oopmap point&quot;);
3369             }
3370           }
3371         }
3372       }
3373 
3374       // oop-maps at calls do not contain registers, so check is not needed
3375       if (!visitor.has_call()) {
3376 
3377         for_each_visitor_mode(mode) {
3378           int n = visitor.opr_count(mode);
3379           for (int k = 0; k &lt; n; k++) {
3380             LIR_Opr opr = visitor.opr_at(mode, k);
3381 
3382             if (opr-&gt;is_fixed_cpu() &amp;&amp; opr-&gt;is_oop()) {
3383               // operand is a non-virtual cpu register and contains an oop
3384               TRACE_LINEAR_SCAN(4, op-&gt;print_on(tty); tty-&gt;print(&quot;checking operand &quot;); opr-&gt;print(); tty-&gt;cr());
3385 
3386               Interval* interval = interval_at(reg_num(opr));
3387               assert(interval != NULL, &quot;no interval&quot;);
3388 
3389               if (mode == LIR_OpVisitState::inputMode) {
3390                 if (interval-&gt;to() &gt;= op_id + 1) {
3391                   assert(interval-&gt;to() &lt; op_id + 2 ||
3392                          interval-&gt;has_hole_between(op_id, op_id + 2),
3393                          &quot;oop input operand live after instruction&quot;);
3394                 }
3395               } else if (mode == LIR_OpVisitState::outputMode) {
3396                 if (interval-&gt;from() &lt;= op_id - 1) {
3397                   assert(interval-&gt;has_hole_between(op_id - 1, op_id),
3398                          &quot;oop input operand live after instruction&quot;);
3399                 }
3400               }
3401             }
3402           }
3403         }
3404       }
3405     }
3406   }
3407 }
3408 
3409 
3410 void LinearScan::verify_constants() {
3411   int num_regs = num_virtual_regs();
3412   int size = live_set_size();
3413   int num_blocks = block_count();
3414 
3415   for (int i = 0; i &lt; num_blocks; i++) {
3416     BlockBegin* block = block_at(i);
3417     ResourceBitMap live_at_edge = block-&gt;live_in();
3418 
3419     // visit all registers where the live_at_edge bit is set
3420     for (int r = (int)live_at_edge.get_next_one_offset(0, size); r &lt; size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
3421       TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;checking interval %d of block B%d&quot;, r, block-&gt;block_id()));
3422 
3423       Value value = gen()-&gt;instruction_for_vreg(r);
3424 
3425       assert(value != NULL, &quot;all intervals live across block boundaries must have Value&quot;);
3426       assert(value-&gt;operand()-&gt;is_register() &amp;&amp; value-&gt;operand()-&gt;is_virtual(), &quot;value must have virtual operand&quot;);
3427       assert(value-&gt;operand()-&gt;vreg_number() == r, &quot;register number must match&quot;);
3428       // TKR assert(value-&gt;as_Constant() == NULL || value-&gt;is_pinned(), &quot;only pinned constants can be alive accross block boundaries&quot;);
3429     }
3430   }
3431 }
3432 
3433 
3434 class RegisterVerifier: public StackObj {
3435  private:
3436   LinearScan*   _allocator;
3437   BlockList     _work_list;      // all blocks that must be processed
3438   IntervalsList _saved_states;   // saved information of previous check
3439 
3440   // simplified access to methods of LinearScan
3441   Compilation*  compilation() const              { return _allocator-&gt;compilation(); }
3442   Interval*     interval_at(int reg_num) const   { return _allocator-&gt;interval_at(reg_num); }
3443   int           reg_num(LIR_Opr opr) const       { return _allocator-&gt;reg_num(opr); }
3444 
3445   // currently, only registers are processed
3446   int           state_size()                     { return LinearScan::nof_regs; }
3447 
3448   // accessors
3449   IntervalList* state_for_block(BlockBegin* block) { return _saved_states.at(block-&gt;block_id()); }
3450   void          set_state_for_block(BlockBegin* block, IntervalList* saved_state) { _saved_states.at_put(block-&gt;block_id(), saved_state); }
3451   void          add_to_work_list(BlockBegin* block) { if (!_work_list.contains(block)) _work_list.append(block); }
3452 
3453   // helper functions
3454   IntervalList* copy(IntervalList* input_state);
3455   void          state_put(IntervalList* input_state, int reg, Interval* interval);
3456   bool          check_state(IntervalList* input_state, int reg, Interval* interval);
3457 
3458   void process_block(BlockBegin* block);
3459   void process_xhandler(XHandler* xhandler, IntervalList* input_state);
3460   void process_successor(BlockBegin* block, IntervalList* input_state);
3461   void process_operations(LIR_List* ops, IntervalList* input_state);
3462 
3463  public:
3464   RegisterVerifier(LinearScan* allocator)
3465     : _allocator(allocator)
3466     , _work_list(16)
3467     , _saved_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL)
3468   { }
3469 
3470   void verify(BlockBegin* start);
3471 };
3472 
3473 
3474 // entry function from LinearScan that starts the verification
3475 void LinearScan::verify_registers() {
3476   RegisterVerifier verifier(this);
3477   verifier.verify(block_at(0));
3478 }
3479 
3480 
3481 void RegisterVerifier::verify(BlockBegin* start) {
3482   // setup input registers (method arguments) for first block
3483   int input_state_len = state_size();
3484   IntervalList* input_state = new IntervalList(input_state_len, input_state_len, NULL);
3485   CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
3486   for (int n = 0; n &lt; args-&gt;length(); n++) {
3487     LIR_Opr opr = args-&gt;at(n);
3488     if (opr-&gt;is_register()) {
3489       Interval* interval = interval_at(reg_num(opr));
3490 
3491       if (interval-&gt;assigned_reg() &lt; state_size()) {
3492         input_state-&gt;at_put(interval-&gt;assigned_reg(), interval);
3493       }
3494       if (interval-&gt;assigned_regHi() != LinearScan::any_reg &amp;&amp; interval-&gt;assigned_regHi() &lt; state_size()) {
3495         input_state-&gt;at_put(interval-&gt;assigned_regHi(), interval);
3496       }
3497     }
3498   }
3499 
3500   set_state_for_block(start, input_state);
3501   add_to_work_list(start);
3502 
3503   // main loop for verification
3504   do {
3505     BlockBegin* block = _work_list.at(0);
3506     _work_list.remove_at(0);
3507 
3508     process_block(block);
3509   } while (!_work_list.is_empty());
3510 }
3511 
3512 void RegisterVerifier::process_block(BlockBegin* block) {
3513   TRACE_LINEAR_SCAN(2, tty-&gt;cr(); tty-&gt;print_cr(&quot;process_block B%d&quot;, block-&gt;block_id()));
3514 
3515   // must copy state because it is modified
3516   IntervalList* input_state = copy(state_for_block(block));
3517 
3518   if (TraceLinearScanLevel &gt;= 4) {
3519     tty-&gt;print_cr(&quot;Input-State of intervals:&quot;);
3520     tty-&gt;print(&quot;    &quot;);
3521     for (int i = 0; i &lt; state_size(); i++) {
3522       if (input_state-&gt;at(i) != NULL) {
3523         tty-&gt;print(&quot; %4d&quot;, input_state-&gt;at(i)-&gt;reg_num());
3524       } else {
3525         tty-&gt;print(&quot;   __&quot;);
3526       }
3527     }
3528     tty-&gt;cr();
3529     tty-&gt;cr();
3530   }
3531 
3532   // process all operations of the block
3533   process_operations(block-&gt;lir(), input_state);
3534 
3535   // iterate all successors
3536   for (int i = 0; i &lt; block-&gt;number_of_sux(); i++) {
3537     process_successor(block-&gt;sux_at(i), input_state);
3538   }
3539 }
3540 
3541 void RegisterVerifier::process_xhandler(XHandler* xhandler, IntervalList* input_state) {
3542   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_xhandler B%d&quot;, xhandler-&gt;entry_block()-&gt;block_id()));
3543 
3544   // must copy state because it is modified
3545   input_state = copy(input_state);
3546 
3547   if (xhandler-&gt;entry_code() != NULL) {
3548     process_operations(xhandler-&gt;entry_code(), input_state);
3549   }
3550   process_successor(xhandler-&gt;entry_block(), input_state);
3551 }
3552 
3553 void RegisterVerifier::process_successor(BlockBegin* block, IntervalList* input_state) {
3554   IntervalList* saved_state = state_for_block(block);
3555 
3556   if (saved_state != NULL) {
3557     // this block was already processed before.
3558     // check if new input_state is consistent with saved_state
3559 
3560     bool saved_state_correct = true;
3561     for (int i = 0; i &lt; state_size(); i++) {
3562       if (input_state-&gt;at(i) != saved_state-&gt;at(i)) {
3563         // current input_state and previous saved_state assume a different
3564         // interval in this register -&gt; assume that this register is invalid
3565         if (saved_state-&gt;at(i) != NULL) {
3566           // invalidate old calculation only if it assumed that
3567           // register was valid. when the register was already invalid,
3568           // then the old calculation was correct.
3569           saved_state_correct = false;
3570           saved_state-&gt;at_put(i, NULL);
3571 
3572           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;process_successor B%d: invalidating slot %d&quot;, block-&gt;block_id(), i));
3573         }
3574       }
3575     }
3576 
3577     if (saved_state_correct) {
3578       // already processed block with correct input_state
3579       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: previous visit already correct&quot;, block-&gt;block_id()));
3580     } else {
3581       // must re-visit this block
3582       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: must re-visit because input state changed&quot;, block-&gt;block_id()));
3583       add_to_work_list(block);
3584     }
3585 
3586   } else {
3587     // block was not processed before, so set initial input_state
3588     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: initial visit&quot;, block-&gt;block_id()));
3589 
3590     set_state_for_block(block, copy(input_state));
3591     add_to_work_list(block);
3592   }
3593 }
3594 
3595 
3596 IntervalList* RegisterVerifier::copy(IntervalList* input_state) {
3597   IntervalList* copy_state = new IntervalList(input_state-&gt;length());
3598   copy_state-&gt;appendAll(input_state);
3599   return copy_state;
3600 }
3601 
3602 void RegisterVerifier::state_put(IntervalList* input_state, int reg, Interval* interval) {
3603   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; state_size()) {
3604     if (interval != NULL) {
3605       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;        reg[%d] = %d&quot;, reg, interval-&gt;reg_num()));
3606     } else if (input_state-&gt;at(reg) != NULL) {
3607       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;        reg[%d] = NULL&quot;, reg));
3608     }
3609 
3610     input_state-&gt;at_put(reg, interval);
3611   }
3612 }
3613 
3614 bool RegisterVerifier::check_state(IntervalList* input_state, int reg, Interval* interval) {
3615   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; state_size()) {
3616     if (input_state-&gt;at(reg) != interval) {
3617       tty-&gt;print_cr(&quot;!! Error in register allocation: register %d does not contain interval %d&quot;, reg, interval-&gt;reg_num());
3618       return true;
3619     }
3620   }
3621   return false;
3622 }
3623 
3624 void RegisterVerifier::process_operations(LIR_List* ops, IntervalList* input_state) {
3625   // visit all instructions of the block
3626   LIR_OpVisitState visitor;
3627   bool has_error = false;
3628 
3629   for (int i = 0; i &lt; ops-&gt;length(); i++) {
3630     LIR_Op* op = ops-&gt;at(i);
3631     visitor.visit(op);
3632 
3633     TRACE_LINEAR_SCAN(4, op-&gt;print_on(tty));
3634 
3635     // check if input operands are correct
3636     int j;
3637     int n = visitor.opr_count(LIR_OpVisitState::inputMode);
3638     for (j = 0; j &lt; n; j++) {
3639       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, j);
3640       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3641         Interval* interval = interval_at(reg_num(opr));
3642         if (op-&gt;id() != -1) {
3643           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::inputMode);
3644         }
3645 
3646         has_error |= check_state(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3647         has_error |= check_state(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3648 
3649         // When an operand is marked with is_last_use, then the fpu stack allocator
3650         // removes the register from the fpu stack -&gt; the register contains no value
3651         if (opr-&gt;is_last_use()) {
3652           state_put(input_state, interval-&gt;assigned_reg(),   NULL);
3653           state_put(input_state, interval-&gt;assigned_regHi(), NULL);
3654         }
3655       }
3656     }
3657 
3658     // invalidate all caller save registers at calls
3659     if (visitor.has_call()) {
3660       for (j = 0; j &lt; FrameMap::nof_caller_save_cpu_regs(); j++) {
3661         state_put(input_state, reg_num(FrameMap::caller_save_cpu_reg_at(j)), NULL);
3662       }
3663       for (j = 0; j &lt; FrameMap::nof_caller_save_fpu_regs; j++) {
3664         state_put(input_state, reg_num(FrameMap::caller_save_fpu_reg_at(j)), NULL);
3665       }
3666 
3667 #ifdef X86
3668       int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();
3669       for (j = 0; j &lt; num_caller_save_xmm_regs; j++) {
3670         state_put(input_state, reg_num(FrameMap::caller_save_xmm_reg_at(j)), NULL);
3671       }
3672 #endif
3673     }
3674 
3675     // process xhandler before output and temp operands
3676     XHandlers* xhandlers = visitor.all_xhandler();
3677     n = xhandlers-&gt;length();
3678     for (int k = 0; k &lt; n; k++) {
3679       process_xhandler(xhandlers-&gt;handler_at(k), input_state);
3680     }
3681 
3682     // set temp operands (some operations use temp operands also as output operands, so can&#39;t set them NULL)
3683     n = visitor.opr_count(LIR_OpVisitState::tempMode);
3684     for (j = 0; j &lt; n; j++) {
3685       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, j);
3686       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3687         Interval* interval = interval_at(reg_num(opr));
3688         if (op-&gt;id() != -1) {
3689           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::tempMode);
3690         }
3691 
3692         state_put(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3693         state_put(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3694       }
3695     }
3696 
3697     // set output operands
3698     n = visitor.opr_count(LIR_OpVisitState::outputMode);
3699     for (j = 0; j &lt; n; j++) {
3700       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, j);
3701       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3702         Interval* interval = interval_at(reg_num(opr));
3703         if (op-&gt;id() != -1) {
3704           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::outputMode);
3705         }
3706 
3707         state_put(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3708         state_put(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3709       }
3710     }
3711   }
3712   assert(has_error == false, &quot;Error in register allocation&quot;);
3713 }
3714 
3715 #endif // ASSERT
3716 
3717 
3718 
3719 // **** Implementation of MoveResolver ******************************
3720 
3721 MoveResolver::MoveResolver(LinearScan* allocator) :
3722   _allocator(allocator),
3723   _insert_list(NULL),
3724   _insert_idx(-1),
3725   _insertion_buffer(),
3726   _mapping_from(8),
3727   _mapping_from_opr(8),
3728   _mapping_to(8),
3729   _multiple_reads_allowed(false)
3730 {
3731   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
3732     _register_blocked[i] = 0;
3733   }
3734   DEBUG_ONLY(check_empty());
3735 }
3736 
3737 
3738 #ifdef ASSERT
3739 
3740 void MoveResolver::check_empty() {
3741   assert(_mapping_from.length() == 0 &amp;&amp; _mapping_from_opr.length() == 0 &amp;&amp; _mapping_to.length() == 0, &quot;list must be empty before and after processing&quot;);
3742   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
3743     assert(register_blocked(i) == 0, &quot;register map must be empty before and after processing&quot;);
3744   }
3745   assert(_multiple_reads_allowed == false, &quot;must have default value&quot;);
3746 }
3747 
3748 void MoveResolver::verify_before_resolve() {
3749   assert(_mapping_from.length() == _mapping_from_opr.length(), &quot;length must be equal&quot;);
3750   assert(_mapping_from.length() == _mapping_to.length(), &quot;length must be equal&quot;);
3751   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;insert position not set&quot;);
3752 
3753   int i, j;
3754   if (!_multiple_reads_allowed) {
3755     for (i = 0; i &lt; _mapping_from.length(); i++) {
3756       for (j = i + 1; j &lt; _mapping_from.length(); j++) {
3757         assert(_mapping_from.at(i) == NULL || _mapping_from.at(i) != _mapping_from.at(j), &quot;cannot read from same interval twice&quot;);
3758       }
3759     }
3760   }
3761 
3762   for (i = 0; i &lt; _mapping_to.length(); i++) {
3763     for (j = i + 1; j &lt; _mapping_to.length(); j++) {
3764       assert(_mapping_to.at(i) != _mapping_to.at(j), &quot;cannot write to same interval twice&quot;);
3765     }
3766   }
3767 
3768 
3769   ResourceBitMap used_regs(LinearScan::nof_regs + allocator()-&gt;frame_map()-&gt;argcount() + allocator()-&gt;max_spills());
3770   if (!_multiple_reads_allowed) {
3771     for (i = 0; i &lt; _mapping_from.length(); i++) {
3772       Interval* it = _mapping_from.at(i);
3773       if (it != NULL) {
3774         assert(!used_regs.at(it-&gt;assigned_reg()), &quot;cannot read from same register twice&quot;);
3775         used_regs.set_bit(it-&gt;assigned_reg());
3776 
3777         if (it-&gt;assigned_regHi() != LinearScan::any_reg) {
3778           assert(!used_regs.at(it-&gt;assigned_regHi()), &quot;cannot read from same register twice&quot;);
3779           used_regs.set_bit(it-&gt;assigned_regHi());
3780         }
3781       }
3782     }
3783   }
3784 
3785   used_regs.clear();
3786   for (i = 0; i &lt; _mapping_to.length(); i++) {
3787     Interval* it = _mapping_to.at(i);
3788     assert(!used_regs.at(it-&gt;assigned_reg()), &quot;cannot write to same register twice&quot;);
3789     used_regs.set_bit(it-&gt;assigned_reg());
3790 
3791     if (it-&gt;assigned_regHi() != LinearScan::any_reg) {
3792       assert(!used_regs.at(it-&gt;assigned_regHi()), &quot;cannot write to same register twice&quot;);
3793       used_regs.set_bit(it-&gt;assigned_regHi());
3794     }
3795   }
3796 
3797   used_regs.clear();
3798   for (i = 0; i &lt; _mapping_from.length(); i++) {
3799     Interval* it = _mapping_from.at(i);
3800     if (it != NULL &amp;&amp; it-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
3801       used_regs.set_bit(it-&gt;assigned_reg());
3802     }
3803   }
3804   for (i = 0; i &lt; _mapping_to.length(); i++) {
3805     Interval* it = _mapping_to.at(i);
3806     assert(!used_regs.at(it-&gt;assigned_reg()) || it-&gt;assigned_reg() == _mapping_from.at(i)-&gt;assigned_reg(), &quot;stack slots used in _mapping_from must be disjoint to _mapping_to&quot;);
3807   }
3808 }
3809 
3810 #endif // ASSERT
3811 
3812 
3813 // mark assigned_reg and assigned_regHi of the interval as blocked
3814 void MoveResolver::block_registers(Interval* it) {
3815   int reg = it-&gt;assigned_reg();
3816   if (reg &lt; LinearScan::nof_regs) {
3817     assert(_multiple_reads_allowed || register_blocked(reg) == 0, &quot;register already marked as used&quot;);
3818     set_register_blocked(reg, 1);
3819   }
3820   reg = it-&gt;assigned_regHi();
3821   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3822     assert(_multiple_reads_allowed || register_blocked(reg) == 0, &quot;register already marked as used&quot;);
3823     set_register_blocked(reg, 1);
3824   }
3825 }
3826 
3827 // mark assigned_reg and assigned_regHi of the interval as unblocked
3828 void MoveResolver::unblock_registers(Interval* it) {
3829   int reg = it-&gt;assigned_reg();
3830   if (reg &lt; LinearScan::nof_regs) {
3831     assert(register_blocked(reg) &gt; 0, &quot;register already marked as unused&quot;);
3832     set_register_blocked(reg, -1);
3833   }
3834   reg = it-&gt;assigned_regHi();
3835   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3836     assert(register_blocked(reg) &gt; 0, &quot;register already marked as unused&quot;);
3837     set_register_blocked(reg, -1);
3838   }
3839 }
3840 
3841 // check if assigned_reg and assigned_regHi of the to-interval are not blocked (or only blocked by from)
3842 bool MoveResolver::save_to_process_move(Interval* from, Interval* to) {
3843   int from_reg = -1;
3844   int from_regHi = -1;
3845   if (from != NULL) {
3846     from_reg = from-&gt;assigned_reg();
3847     from_regHi = from-&gt;assigned_regHi();
3848   }
3849 
3850   int reg = to-&gt;assigned_reg();
3851   if (reg &lt; LinearScan::nof_regs) {
3852     if (register_blocked(reg) &gt; 1 || (register_blocked(reg) == 1 &amp;&amp; reg != from_reg &amp;&amp; reg != from_regHi)) {
3853       return false;
3854     }
3855   }
3856   reg = to-&gt;assigned_regHi();
3857   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3858     if (register_blocked(reg) &gt; 1 || (register_blocked(reg) == 1 &amp;&amp; reg != from_reg &amp;&amp; reg != from_regHi)) {
3859       return false;
3860     }
3861   }
3862 
3863   return true;
3864 }
3865 
3866 
3867 void MoveResolver::create_insertion_buffer(LIR_List* list) {
3868   assert(!_insertion_buffer.initialized(), &quot;overwriting existing buffer&quot;);
3869   _insertion_buffer.init(list);
3870 }
3871 
3872 void MoveResolver::append_insertion_buffer() {
3873   if (_insertion_buffer.initialized()) {
3874     _insertion_buffer.lir_list()-&gt;append(&amp;_insertion_buffer);
3875   }
3876   assert(!_insertion_buffer.initialized(), &quot;must be uninitialized now&quot;);
3877 
3878   _insert_list = NULL;
3879   _insert_idx = -1;
3880 }
3881 
3882 void MoveResolver::insert_move(Interval* from_interval, Interval* to_interval) {
3883   assert(from_interval-&gt;reg_num() != to_interval-&gt;reg_num(), &quot;from and to interval equal&quot;);
3884   assert(from_interval-&gt;type() == to_interval-&gt;type(), &quot;move between different types&quot;);
3885   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;must setup insert position first&quot;);
3886   assert(_insertion_buffer.lir_list() == _insert_list, &quot;wrong insertion buffer&quot;);
3887 
3888   LIR_Opr from_opr = LIR_OprFact::virtual_register(from_interval-&gt;reg_num(), from_interval-&gt;type());
3889   LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval-&gt;reg_num(), to_interval-&gt;type());
3890 
3891   if (!_multiple_reads_allowed) {
3892     // the last_use flag is an optimization for FPU stack allocation. When the same
3893     // input interval is used in more than one move, then it is too difficult to determine
3894     // if this move is really the last use.
3895     from_opr = from_opr-&gt;make_last_use();
3896   }
3897   _insertion_buffer.move(_insert_idx, from_opr, to_opr);
3898 
3899   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: inserted move from register %d (%d, %d) to %d (%d, %d)&quot;, from_interval-&gt;reg_num(), from_interval-&gt;assigned_reg(), from_interval-&gt;assigned_regHi(), to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
3900 }
3901 
3902 void MoveResolver::insert_move(LIR_Opr from_opr, Interval* to_interval) {
3903   assert(from_opr-&gt;type() == to_interval-&gt;type(), &quot;move between different types&quot;);
3904   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;must setup insert position first&quot;);
3905   assert(_insertion_buffer.lir_list() == _insert_list, &quot;wrong insertion buffer&quot;);
3906 
3907   LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval-&gt;reg_num(), to_interval-&gt;type());
3908   _insertion_buffer.move(_insert_idx, from_opr, to_opr);
3909 
3910   TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;MoveResolver: inserted move from constant &quot;); from_opr-&gt;print(); tty-&gt;print_cr(&quot;  to %d (%d, %d)&quot;, to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
3911 }
3912 
3913 
3914 void MoveResolver::resolve_mappings() {
3915   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: resolving mappings for Block B%d, index %d&quot;, _insert_list-&gt;block() != NULL ? _insert_list-&gt;block()-&gt;block_id() : -1, _insert_idx));
3916   DEBUG_ONLY(verify_before_resolve());
3917 
3918   // Block all registers that are used as input operands of a move.
3919   // When a register is blocked, no move to this register is emitted.
3920   // This is necessary for detecting cycles in moves.
3921   int i;
3922   for (i = _mapping_from.length() - 1; i &gt;= 0; i--) {
3923     Interval* from_interval = _mapping_from.at(i);
3924     if (from_interval != NULL) {
3925       block_registers(from_interval);
3926     }
3927   }
3928 
3929   int spill_candidate = -1;
3930   while (_mapping_from.length() &gt; 0) {
3931     bool processed_interval = false;
3932 
3933     for (i = _mapping_from.length() - 1; i &gt;= 0; i--) {
3934       Interval* from_interval = _mapping_from.at(i);
3935       Interval* to_interval = _mapping_to.at(i);
3936 
3937       if (save_to_process_move(from_interval, to_interval)) {
3938         // this inverval can be processed because target is free
3939         if (from_interval != NULL) {
3940           insert_move(from_interval, to_interval);
3941           unblock_registers(from_interval);
3942         } else {
3943           insert_move(_mapping_from_opr.at(i), to_interval);
3944         }
3945         _mapping_from.remove_at(i);
3946         _mapping_from_opr.remove_at(i);
3947         _mapping_to.remove_at(i);
3948 
3949         processed_interval = true;
3950       } else if (from_interval != NULL &amp;&amp; from_interval-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
3951         // this interval cannot be processed now because target is not free
3952         // it starts in a register, so it is a possible candidate for spilling
3953         spill_candidate = i;
3954       }
3955     }
3956 
3957     if (!processed_interval) {
3958       // no move could be processed because there is a cycle in the move list
3959       // (e.g. r1 -&gt; r2, r2 -&gt; r1), so one interval must be spilled to memory
3960       guarantee(spill_candidate != -1, &quot;no interval in register for spilling found&quot;);
3961 
3962       // create a new spill interval and assign a stack slot to it
3963       Interval* from_interval = _mapping_from.at(spill_candidate);
3964       Interval* spill_interval = new Interval(-1);
3965       spill_interval-&gt;set_type(from_interval-&gt;type());
3966 
3967       // add a dummy range because real position is difficult to calculate
3968       // Note: this range is a special case when the integrity of the allocation is checked
3969       spill_interval-&gt;add_range(1, 2);
3970 
3971       //       do not allocate a new spill slot for temporary interval, but
3972       //       use spill slot assigned to from_interval. Otherwise moves from
3973       //       one stack slot to another can happen (not allowed by LIR_Assembler
3974       int spill_slot = from_interval-&gt;canonical_spill_slot();
3975       if (spill_slot &lt; 0) {
3976         spill_slot = allocator()-&gt;allocate_spill_slot(type2spill_size[spill_interval-&gt;type()] == 2);
3977         from_interval-&gt;set_canonical_spill_slot(spill_slot);
3978       }
3979       spill_interval-&gt;assign_reg(spill_slot);
3980       allocator()-&gt;append_interval(spill_interval);
3981 
3982       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;created new Interval %d for spilling&quot;, spill_interval-&gt;reg_num()));
3983 
3984       // insert a move from register to stack and update the mapping
3985       insert_move(from_interval, spill_interval);
3986       _mapping_from.at_put(spill_candidate, spill_interval);
3987       unblock_registers(from_interval);
3988     }
3989   }
3990 
3991   // reset to default value
3992   _multiple_reads_allowed = false;
3993 
3994   // check that all intervals have been processed
3995   DEBUG_ONLY(check_empty());
3996 }
3997 
3998 
3999 void MoveResolver::set_insert_position(LIR_List* insert_list, int insert_idx) {
4000   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: setting insert position to Block B%d, index %d&quot;, insert_list-&gt;block() != NULL ? insert_list-&gt;block()-&gt;block_id() : -1, insert_idx));
4001   assert(_insert_list == NULL &amp;&amp; _insert_idx == -1, &quot;use move_insert_position instead of set_insert_position when data already set&quot;);
4002 
4003   create_insertion_buffer(insert_list);
4004   _insert_list = insert_list;
4005   _insert_idx = insert_idx;
4006 }
4007 
4008 void MoveResolver::move_insert_position(LIR_List* insert_list, int insert_idx) {
4009   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: moving insert position to Block B%d, index %d&quot;, insert_list-&gt;block() != NULL ? insert_list-&gt;block()-&gt;block_id() : -1, insert_idx));
4010 
4011   if (_insert_list != NULL &amp;&amp; (insert_list != _insert_list || insert_idx != _insert_idx)) {
4012     // insert position changed -&gt; resolve current mappings
4013     resolve_mappings();
4014   }
4015 
4016   if (insert_list != _insert_list) {
4017     // block changed -&gt; append insertion_buffer because it is
4018     // bound to a specific block and create a new insertion_buffer
4019     append_insertion_buffer();
4020     create_insertion_buffer(insert_list);
4021   }
4022 
4023   _insert_list = insert_list;
4024   _insert_idx = insert_idx;
4025 }
4026 
4027 void MoveResolver::add_mapping(Interval* from_interval, Interval* to_interval) {
4028   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: adding mapping from %d (%d, %d) to %d (%d, %d)&quot;, from_interval-&gt;reg_num(), from_interval-&gt;assigned_reg(), from_interval-&gt;assigned_regHi(), to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
4029 
4030   _mapping_from.append(from_interval);
4031   _mapping_from_opr.append(LIR_OprFact::illegalOpr);
4032   _mapping_to.append(to_interval);
4033 }
4034 
4035 
4036 void MoveResolver::add_mapping(LIR_Opr from_opr, Interval* to_interval) {
4037   TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;MoveResolver: adding mapping from &quot;); from_opr-&gt;print(); tty-&gt;print_cr(&quot; to %d (%d, %d)&quot;, to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
4038   assert(from_opr-&gt;is_constant(), &quot;only for constants&quot;);
4039 
4040   _mapping_from.append(NULL);
4041   _mapping_from_opr.append(from_opr);
4042   _mapping_to.append(to_interval);
4043 }
4044 
4045 void MoveResolver::resolve_and_append_moves() {
4046   if (has_mappings()) {
4047     resolve_mappings();
4048   }
4049   append_insertion_buffer();
4050 }
4051 
4052 
4053 
4054 // **** Implementation of Range *************************************
4055 
4056 Range::Range(int from, int to, Range* next) :
4057   _from(from),
4058   _to(to),
4059   _next(next)
4060 {
4061 }
4062 
4063 // initialize sentinel
4064 Range* Range::_end = NULL;
4065 void Range::initialize(Arena* arena) {
4066   _end = new (arena) Range(max_jint, max_jint, NULL);
4067 }
4068 
4069 int Range::intersects_at(Range* r2) const {
4070   const Range* r1 = this;
4071 
4072   assert(r1 != NULL &amp;&amp; r2 != NULL, &quot;null ranges not allowed&quot;);
4073   assert(r1 != _end &amp;&amp; r2 != _end, &quot;empty ranges not allowed&quot;);
4074 
4075   do {
4076     if (r1-&gt;from() &lt; r2-&gt;from()) {
4077       if (r1-&gt;to() &lt;= r2-&gt;from()) {
4078         r1 = r1-&gt;next(); if (r1 == _end) return -1;
4079       } else {
4080         return r2-&gt;from();
4081       }
4082     } else if (r2-&gt;from() &lt; r1-&gt;from()) {
4083       if (r2-&gt;to() &lt;= r1-&gt;from()) {
4084         r2 = r2-&gt;next(); if (r2 == _end) return -1;
4085       } else {
4086         return r1-&gt;from();
4087       }
4088     } else { // r1-&gt;from() == r2-&gt;from()
4089       if (r1-&gt;from() == r1-&gt;to()) {
4090         r1 = r1-&gt;next(); if (r1 == _end) return -1;
4091       } else if (r2-&gt;from() == r2-&gt;to()) {
4092         r2 = r2-&gt;next(); if (r2 == _end) return -1;
4093       } else {
4094         return r1-&gt;from();
4095       }
4096     }
4097   } while (true);
4098 }
4099 
4100 #ifndef PRODUCT
4101 void Range::print(outputStream* out) const {
4102   out-&gt;print(&quot;[%d, %d[ &quot;, _from, _to);
4103 }
4104 #endif
4105 
4106 
4107 
4108 // **** Implementation of Interval **********************************
4109 
4110 // initialize sentinel
4111 Interval* Interval::_end = NULL;
4112 void Interval::initialize(Arena* arena) {
4113   Range::initialize(arena);
4114   _end = new (arena) Interval(-1);
4115 }
4116 
4117 Interval::Interval(int reg_num) :
4118   _reg_num(reg_num),
4119   _type(T_ILLEGAL),
4120   _first(Range::end()),
4121   _use_pos_and_kinds(12),
4122   _current(Range::end()),
4123   _next(_end),
4124   _state(invalidState),
4125   _assigned_reg(LinearScan::any_reg),
4126   _assigned_regHi(LinearScan::any_reg),
4127   _cached_to(-1),
4128   _cached_opr(LIR_OprFact::illegalOpr),
4129   _cached_vm_reg(VMRegImpl::Bad()),
4130   _split_children(NULL),
4131   _canonical_spill_slot(-1),
4132   _insert_move_when_activated(false),
4133   _spill_state(noDefinitionFound),
4134   _spill_definition_pos(-1),
4135   _register_hint(NULL)
4136 {
4137   _split_parent = this;
4138   _current_split_child = this;
4139 }
4140 
4141 int Interval::calc_to() {
4142   assert(_first != Range::end(), &quot;interval has no range&quot;);
4143 
4144   Range* r = _first;
4145   while (r-&gt;next() != Range::end()) {
4146     r = r-&gt;next();
4147   }
4148   return r-&gt;to();
4149 }
4150 
4151 
4152 #ifdef ASSERT
4153 // consistency check of split-children
4154 void Interval::check_split_children() {
4155   if (_split_children != NULL &amp;&amp; _split_children-&gt;length() &gt; 0) {
4156     assert(is_split_parent(), &quot;only split parents can have children&quot;);
4157 
4158     for (int i = 0; i &lt; _split_children-&gt;length(); i++) {
4159       Interval* i1 = _split_children-&gt;at(i);
4160 
4161       assert(i1-&gt;split_parent() == this, &quot;not a split child of this interval&quot;);
4162       assert(i1-&gt;type() == type(), &quot;must be equal for all split children&quot;);
4163       assert(i1-&gt;canonical_spill_slot() == canonical_spill_slot(), &quot;must be equal for all split children&quot;);
4164 
4165       for (int j = i + 1; j &lt; _split_children-&gt;length(); j++) {
4166         Interval* i2 = _split_children-&gt;at(j);
4167 
4168         assert(i1-&gt;reg_num() != i2-&gt;reg_num(), &quot;same register number&quot;);
4169 
4170         if (i1-&gt;from() &lt; i2-&gt;from()) {
4171           assert(i1-&gt;to() &lt;= i2-&gt;from() &amp;&amp; i1-&gt;to() &lt; i2-&gt;to(), &quot;intervals overlapping&quot;);
4172         } else {
4173           assert(i2-&gt;from() &lt; i1-&gt;from(), &quot;intervals start at same op_id&quot;);
4174           assert(i2-&gt;to() &lt;= i1-&gt;from() &amp;&amp; i2-&gt;to() &lt; i1-&gt;to(), &quot;intervals overlapping&quot;);
4175         }
4176       }
4177     }
4178   }
4179 }
4180 #endif // ASSERT
4181 
4182 Interval* Interval::register_hint(bool search_split_child) const {
4183   if (!search_split_child) {
4184     return _register_hint;
4185   }
4186 
4187   if (_register_hint != NULL) {
4188     assert(_register_hint-&gt;is_split_parent(), &quot;ony split parents are valid hint registers&quot;);
4189 
4190     if (_register_hint-&gt;assigned_reg() &gt;= 0 &amp;&amp; _register_hint-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
4191       return _register_hint;
4192 
4193     } else if (_register_hint-&gt;_split_children != NULL &amp;&amp; _register_hint-&gt;_split_children-&gt;length() &gt; 0) {
4194       // search the first split child that has a register assigned
4195       int len = _register_hint-&gt;_split_children-&gt;length();
4196       for (int i = 0; i &lt; len; i++) {
4197         Interval* cur = _register_hint-&gt;_split_children-&gt;at(i);
4198 
4199         if (cur-&gt;assigned_reg() &gt;= 0 &amp;&amp; cur-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
4200           return cur;
4201         }
4202       }
4203     }
4204   }
4205 
4206   // no hint interval found that has a register assigned
4207   return NULL;
4208 }
4209 
4210 
4211 Interval* Interval::split_child_at_op_id(int op_id, LIR_OpVisitState::OprMode mode) {
4212   assert(is_split_parent(), &quot;can only be called for split parents&quot;);
4213   assert(op_id &gt;= 0, &quot;invalid op_id (method can not be called for spill moves)&quot;);
4214 
4215   Interval* result;
4216   if (_split_children == NULL || _split_children-&gt;length() == 0) {
4217     result = this;
4218   } else {
4219     result = NULL;
4220     int len = _split_children-&gt;length();
4221 
4222     // in outputMode, the end of the interval (op_id == cur-&gt;to()) is not valid
4223     int to_offset = (mode == LIR_OpVisitState::outputMode ? 0 : 1);
4224 
4225     int i;
4226     for (i = 0; i &lt; len; i++) {
4227       Interval* cur = _split_children-&gt;at(i);
4228       if (cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; cur-&gt;to() + to_offset) {
4229         if (i &gt; 0) {
4230           // exchange current split child to start of list (faster access for next call)
4231           _split_children-&gt;at_put(i, _split_children-&gt;at(0));
4232           _split_children-&gt;at_put(0, cur);
4233         }
4234 
4235         // interval found
4236         result = cur;
4237         break;
4238       }
4239     }
4240 
4241 #ifdef ASSERT
4242     for (i = 0; i &lt; len; i++) {
4243       Interval* tmp = _split_children-&gt;at(i);
4244       if (tmp != result &amp;&amp; tmp-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; tmp-&gt;to() + to_offset) {
4245         tty-&gt;print_cr(&quot;two valid result intervals found for op_id %d: %d and %d&quot;, op_id, result-&gt;reg_num(), tmp-&gt;reg_num());
4246         result-&gt;print();
4247         tmp-&gt;print();
4248         assert(false, &quot;two valid result intervals found&quot;);
4249       }
4250     }
4251 #endif
4252   }
4253 
4254   assert(result != NULL, &quot;no matching interval found&quot;);
4255   assert(result-&gt;covers(op_id, mode), &quot;op_id not covered by interval&quot;);
4256 
4257   return result;
4258 }
4259 
4260 
4261 // returns the last split child that ends before the given op_id
4262 Interval* Interval::split_child_before_op_id(int op_id) {
4263   assert(op_id &gt;= 0, &quot;invalid op_id&quot;);
4264 
4265   Interval* parent = split_parent();
4266   Interval* result = NULL;
4267 
4268   assert(parent-&gt;_split_children != NULL, &quot;no split children available&quot;);
4269   int len = parent-&gt;_split_children-&gt;length();
4270   assert(len &gt; 0, &quot;no split children available&quot;);
4271 
4272   for (int i = len - 1; i &gt;= 0; i--) {
4273     Interval* cur = parent-&gt;_split_children-&gt;at(i);
4274     if (cur-&gt;to() &lt;= op_id &amp;&amp; (result == NULL || result-&gt;to() &lt; cur-&gt;to())) {
4275       result = cur;
4276     }
4277   }
4278 
4279   assert(result != NULL, &quot;no split child found&quot;);
4280   return result;
4281 }
4282 
4283 
4284 // Note: use positions are sorted descending -&gt; first use has highest index
4285 int Interval::first_usage(IntervalUseKind min_use_kind) const {
4286   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4287 
4288   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4289     if (_use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4290       return _use_pos_and_kinds.at(i);
4291     }
4292   }
4293   return max_jint;
4294 }
4295 
4296 int Interval::next_usage(IntervalUseKind min_use_kind, int from) const {
4297   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4298 
4299   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4300     if (_use_pos_and_kinds.at(i) &gt;= from &amp;&amp; _use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4301       return _use_pos_and_kinds.at(i);
4302     }
4303   }
4304   return max_jint;
4305 }
4306 
4307 int Interval::next_usage_exact(IntervalUseKind exact_use_kind, int from) const {
4308   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4309 
4310   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4311     if (_use_pos_and_kinds.at(i) &gt;= from &amp;&amp; _use_pos_and_kinds.at(i + 1) == exact_use_kind) {
4312       return _use_pos_and_kinds.at(i);
4313     }
4314   }
4315   return max_jint;
4316 }
4317 
4318 int Interval::previous_usage(IntervalUseKind min_use_kind, int from) const {
4319   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4320 
4321   int prev = 0;
4322   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4323     if (_use_pos_and_kinds.at(i) &gt; from) {
4324       return prev;
4325     }
4326     if (_use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4327       prev = _use_pos_and_kinds.at(i);
4328     }
4329   }
4330   return prev;
4331 }
4332 
4333 void Interval::add_use_pos(int pos, IntervalUseKind use_kind) {
4334   assert(covers(pos, LIR_OpVisitState::inputMode), &quot;use position not covered by live range&quot;);
4335 
4336   // do not add use positions for precolored intervals because
4337   // they are never used
4338   if (use_kind != noUse &amp;&amp; reg_num() &gt;= LIR_OprDesc::vreg_base) {
4339 #ifdef ASSERT
4340     assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must be&quot;);
4341     for (int i = 0; i &lt; _use_pos_and_kinds.length(); i += 2) {
4342       assert(pos &lt;= _use_pos_and_kinds.at(i), &quot;already added a use-position with lower position&quot;);
4343       assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4344       if (i &gt; 0) {
4345         assert(_use_pos_and_kinds.at(i) &lt; _use_pos_and_kinds.at(i - 2), &quot;not sorted descending&quot;);
4346       }
4347     }
4348 #endif
4349 
4350     // Note: add_use is called in descending order, so list gets sorted
4351     //       automatically by just appending new use positions
4352     int len = _use_pos_and_kinds.length();
4353     if (len == 0 || _use_pos_and_kinds.at(len - 2) &gt; pos) {
4354       _use_pos_and_kinds.append(pos);
4355       _use_pos_and_kinds.append(use_kind);
4356     } else if (_use_pos_and_kinds.at(len - 1) &lt; use_kind) {
4357       assert(_use_pos_and_kinds.at(len - 2) == pos, &quot;list not sorted correctly&quot;);
4358       _use_pos_and_kinds.at_put(len - 1, use_kind);
4359     }
4360   }
4361 }
4362 
4363 void Interval::add_range(int from, int to) {
4364   assert(from &lt; to, &quot;invalid range&quot;);
4365   assert(first() == Range::end() || to &lt; first()-&gt;next()-&gt;from(), &quot;not inserting at begin of interval&quot;);
4366   assert(from &lt;= first()-&gt;to(), &quot;not inserting at begin of interval&quot;);
4367 
4368   if (first()-&gt;from() &lt;= to) {
4369     // join intersecting ranges
4370     first()-&gt;set_from(MIN2(from, first()-&gt;from()));
4371     first()-&gt;set_to  (MAX2(to,   first()-&gt;to()));
4372   } else {
4373     // insert new range
4374     _first = new Range(from, to, first());
4375   }
4376 }
4377 
4378 Interval* Interval::new_split_child() {
4379   // allocate new interval
4380   Interval* result = new Interval(-1);
4381   result-&gt;set_type(type());
4382 
4383   Interval* parent = split_parent();
4384   result-&gt;_split_parent = parent;
4385   result-&gt;set_register_hint(parent);
4386 
4387   // insert new interval in children-list of parent
4388   if (parent-&gt;_split_children == NULL) {
4389     assert(is_split_parent(), &quot;list must be initialized at first split&quot;);
4390 
4391     parent-&gt;_split_children = new IntervalList(4);
4392     parent-&gt;_split_children-&gt;append(this);
4393   }
4394   parent-&gt;_split_children-&gt;append(result);
4395 
4396   return result;
4397 }
4398 
4399 // split this interval at the specified position and return
4400 // the remainder as a new interval.
4401 //
4402 // when an interval is split, a bi-directional link is established between the original interval
4403 // (the split parent) and the intervals that are split off this interval (the split children)
4404 // When a split child is split again, the new created interval is also a direct child
4405 // of the original parent (there is no tree of split children stored, but a flat list)
4406 // All split children are spilled to the same stack slot (stored in _canonical_spill_slot)
4407 //
4408 // Note: The new interval has no valid reg_num
4409 Interval* Interval::split(int split_pos) {
4410   assert(LinearScan::is_virtual_interval(this), &quot;cannot split fixed intervals&quot;);
4411 
4412   // allocate new interval
4413   Interval* result = new_split_child();
4414 
4415   // split the ranges
4416   Range* prev = NULL;
4417   Range* cur = _first;
4418   while (cur != Range::end() &amp;&amp; cur-&gt;to() &lt;= split_pos) {
4419     prev = cur;
4420     cur = cur-&gt;next();
4421   }
4422   assert(cur != Range::end(), &quot;split interval after end of last range&quot;);
4423 
4424   if (cur-&gt;from() &lt; split_pos) {
4425     result-&gt;_first = new Range(split_pos, cur-&gt;to(), cur-&gt;next());
4426     cur-&gt;set_to(split_pos);
4427     cur-&gt;set_next(Range::end());
4428 
4429   } else {
4430     assert(prev != NULL, &quot;split before start of first range&quot;);
4431     result-&gt;_first = cur;
4432     prev-&gt;set_next(Range::end());
4433   }
4434   result-&gt;_current = result-&gt;_first;
4435   _cached_to = -1; // clear cached value
4436 
4437   // split list of use positions
4438   int total_len = _use_pos_and_kinds.length();
4439   int start_idx = total_len - 2;
4440   while (start_idx &gt;= 0 &amp;&amp; _use_pos_and_kinds.at(start_idx) &lt; split_pos) {
4441     start_idx -= 2;
4442   }
4443 
4444   intStack new_use_pos_and_kinds(total_len - start_idx);
4445   int i;
4446   for (i = start_idx + 2; i &lt; total_len; i++) {
4447     new_use_pos_and_kinds.append(_use_pos_and_kinds.at(i));
4448   }
4449 
4450   _use_pos_and_kinds.trunc_to(start_idx + 2);
4451   result-&gt;_use_pos_and_kinds = _use_pos_and_kinds;
4452   _use_pos_and_kinds = new_use_pos_and_kinds;
4453 
4454 #ifdef ASSERT
4455   assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must have use kind for each use pos&quot;);
4456   assert(result-&gt;_use_pos_and_kinds.length() % 2 == 0, &quot;must have use kind for each use pos&quot;);
4457   assert(_use_pos_and_kinds.length() + result-&gt;_use_pos_and_kinds.length() == total_len, &quot;missed some entries&quot;);
4458 
4459   for (i = 0; i &lt; _use_pos_and_kinds.length(); i += 2) {
4460     assert(_use_pos_and_kinds.at(i) &lt; split_pos, &quot;must be&quot;);
4461     assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4462   }
4463   for (i = 0; i &lt; result-&gt;_use_pos_and_kinds.length(); i += 2) {
4464     assert(result-&gt;_use_pos_and_kinds.at(i) &gt;= split_pos, &quot;must be&quot;);
4465     assert(result-&gt;_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; result-&gt;_use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4466   }
4467 #endif
4468 
4469   return result;
4470 }
4471 
4472 // split this interval at the specified position and return
4473 // the head as a new interval (the original interval is the tail)
4474 //
4475 // Currently, only the first range can be split, and the new interval
4476 // must not have split positions
4477 Interval* Interval::split_from_start(int split_pos) {
4478   assert(LinearScan::is_virtual_interval(this), &quot;cannot split fixed intervals&quot;);
4479   assert(split_pos &gt; from() &amp;&amp; split_pos &lt; to(), &quot;can only split inside interval&quot;);
4480   assert(split_pos &gt; _first-&gt;from() &amp;&amp; split_pos &lt;= _first-&gt;to(), &quot;can only split inside first range&quot;);
4481   assert(first_usage(noUse) &gt; split_pos, &quot;can not split when use positions are present&quot;);
4482 
4483   // allocate new interval
4484   Interval* result = new_split_child();
4485 
4486   // the new created interval has only one range (checked by assertion above),
4487   // so the splitting of the ranges is very simple
4488   result-&gt;add_range(_first-&gt;from(), split_pos);
4489 
4490   if (split_pos == _first-&gt;to()) {
4491     assert(_first-&gt;next() != Range::end(), &quot;must not be at end&quot;);
4492     _first = _first-&gt;next();
4493   } else {
4494     _first-&gt;set_from(split_pos);
4495   }
4496 
4497   return result;
4498 }
4499 
4500 
4501 // returns true if the op_id is inside the interval
4502 bool Interval::covers(int op_id, LIR_OpVisitState::OprMode mode) const {
4503   Range* cur  = _first;
4504 
4505   while (cur != Range::end() &amp;&amp; cur-&gt;to() &lt; op_id) {
4506     cur = cur-&gt;next();
4507   }
4508   if (cur != Range::end()) {
4509     assert(cur-&gt;to() != cur-&gt;next()-&gt;from(), &quot;ranges not separated&quot;);
4510 
4511     if (mode == LIR_OpVisitState::outputMode) {
4512       return cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; cur-&gt;to();
4513     } else {
4514       return cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt;= cur-&gt;to();
4515     }
4516   }
4517   return false;
4518 }
4519 
4520 // returns true if the interval has any hole between hole_from and hole_to
4521 // (even if the hole has only the length 1)
4522 bool Interval::has_hole_between(int hole_from, int hole_to) {
4523   assert(hole_from &lt; hole_to, &quot;check&quot;);
4524   assert(from() &lt;= hole_from &amp;&amp; hole_to &lt;= to(), &quot;index out of interval&quot;);
4525 
4526   Range* cur  = _first;
4527   while (cur != Range::end()) {
4528     assert(cur-&gt;to() &lt; cur-&gt;next()-&gt;from(), &quot;no space between ranges&quot;);
4529 
4530     // hole-range starts before this range -&gt; hole
4531     if (hole_from &lt; cur-&gt;from()) {
4532       return true;
4533 
4534     // hole-range completely inside this range -&gt; no hole
4535     } else if (hole_to &lt;= cur-&gt;to()) {
4536       return false;
4537 
4538     // overlapping of hole-range with this range -&gt; hole
4539     } else if (hole_from &lt;= cur-&gt;to()) {
4540       return true;
4541     }
4542 
4543     cur = cur-&gt;next();
4544   }
4545 
4546   return false;
4547 }
4548 
4549 
4550 #ifndef PRODUCT
4551 void Interval::print(outputStream* out) const {
4552   const char* SpillState2Name[] = { &quot;no definition&quot;, &quot;no spill store&quot;, &quot;one spill store&quot;, &quot;store at definition&quot;, &quot;start in memory&quot;, &quot;no optimization&quot; };
4553   const char* UseKind2Name[] = { &quot;N&quot;, &quot;L&quot;, &quot;S&quot;, &quot;M&quot; };
4554 
4555   const char* type_name;
4556   LIR_Opr opr = LIR_OprFact::illegal();
4557   if (reg_num() &lt; LIR_OprDesc::vreg_base) {
4558     type_name = &quot;fixed&quot;;
4559     // need a temporary operand for fixed intervals because type() cannot be called
4560 #ifdef X86
4561     int last_xmm_reg = pd_last_xmm_reg;
4562 #ifdef _LP64
4563     if (UseAVX &lt; 3) {
4564       last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
4565     }
4566 #endif
4567 #endif
4568     if (assigned_reg() &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg() &lt;= pd_last_cpu_reg) {
4569       opr = LIR_OprFact::single_cpu(assigned_reg());
4570     } else if (assigned_reg() &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg() &lt;= pd_last_fpu_reg) {
4571       opr = LIR_OprFact::single_fpu(assigned_reg() - pd_first_fpu_reg);
4572 #ifdef X86
4573     } else if (assigned_reg() &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg() &lt;= last_xmm_reg) {
4574       opr = LIR_OprFact::single_xmm(assigned_reg() - pd_first_xmm_reg);
4575 #endif
4576     } else {
4577       ShouldNotReachHere();
4578     }
4579   } else {
4580     type_name = type2name(type());
4581     if (assigned_reg() != -1 &amp;&amp;
4582         (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {
4583       opr = LinearScan::calc_operand_for_interval(this);
4584     }
4585   }
4586 
4587   out-&gt;print(&quot;%d %s &quot;, reg_num(), type_name);
4588   if (opr-&gt;is_valid()) {
4589     out-&gt;print(&quot;\&quot;&quot;);
4590     opr-&gt;print(out);
4591     out-&gt;print(&quot;\&quot; &quot;);
4592   }
4593   out-&gt;print(&quot;%d %d &quot;, split_parent()-&gt;reg_num(), (register_hint(false) != NULL ? register_hint(false)-&gt;reg_num() : -1));
4594 
4595   // print ranges
4596   Range* cur = _first;
4597   while (cur != Range::end()) {
4598     cur-&gt;print(out);
4599     cur = cur-&gt;next();
4600     assert(cur != NULL, &quot;range list not closed with range sentinel&quot;);
4601   }
4602 
4603   // print use positions
4604   int prev = 0;
4605   assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must be&quot;);
4606   for (int i =_use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4607     assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4608     assert(prev &lt; _use_pos_and_kinds.at(i), &quot;use positions not sorted&quot;);
4609 
4610     out-&gt;print(&quot;%d %s &quot;, _use_pos_and_kinds.at(i), UseKind2Name[_use_pos_and_kinds.at(i + 1)]);
4611     prev = _use_pos_and_kinds.at(i);
4612   }
4613 
4614   out-&gt;print(&quot; \&quot;%s\&quot;&quot;, SpillState2Name[spill_state()]);
4615   out-&gt;cr();
4616 }
4617 #endif
4618 
4619 
4620 
4621 // **** Implementation of IntervalWalker ****************************
4622 
4623 IntervalWalker::IntervalWalker(LinearScan* allocator, Interval* unhandled_fixed_first, Interval* unhandled_any_first)
4624  : _compilation(allocator-&gt;compilation())
4625  , _allocator(allocator)
4626 {
4627   _unhandled_first[fixedKind] = unhandled_fixed_first;
4628   _unhandled_first[anyKind]   = unhandled_any_first;
4629   _active_first[fixedKind]    = Interval::end();
4630   _inactive_first[fixedKind]  = Interval::end();
4631   _active_first[anyKind]      = Interval::end();
4632   _inactive_first[anyKind]    = Interval::end();
4633   _current_position = -1;
4634   _current = NULL;
4635   next_interval();
4636 }
4637 
4638 
4639 // append interval in order of current range from()
4640 void IntervalWalker::append_sorted(Interval** list, Interval* interval) {
4641   Interval* prev = NULL;
4642   Interval* cur  = *list;
4643   while (cur-&gt;current_from() &lt; interval-&gt;current_from()) {
4644     prev = cur; cur = cur-&gt;next();
4645   }
4646   if (prev == NULL) {
4647     *list = interval;
4648   } else {
4649     prev-&gt;set_next(interval);
4650   }
4651   interval-&gt;set_next(cur);
4652 }
4653 
4654 void IntervalWalker::append_to_unhandled(Interval** list, Interval* interval) {
4655   assert(interval-&gt;from() &gt;= current()-&gt;current_from(), &quot;cannot append new interval before current walk position&quot;);
4656 
4657   Interval* prev = NULL;
4658   Interval* cur  = *list;
4659   while (cur-&gt;from() &lt; interval-&gt;from() || (cur-&gt;from() == interval-&gt;from() &amp;&amp; cur-&gt;first_usage(noUse) &lt; interval-&gt;first_usage(noUse))) {
4660     prev = cur; cur = cur-&gt;next();
4661   }
4662   if (prev == NULL) {
4663     *list = interval;
4664   } else {
4665     prev-&gt;set_next(interval);
4666   }
4667   interval-&gt;set_next(cur);
4668 }
4669 
4670 
4671 inline bool IntervalWalker::remove_from_list(Interval** list, Interval* i) {
4672   while (*list != Interval::end() &amp;&amp; *list != i) {
4673     list = (*list)-&gt;next_addr();
4674   }
4675   if (*list != Interval::end()) {
4676     assert(*list == i, &quot;check&quot;);
4677     *list = (*list)-&gt;next();
4678     return true;
4679   } else {
4680     return false;
4681   }
4682 }
4683 
4684 void IntervalWalker::remove_from_list(Interval* i) {
4685   bool deleted;
4686 
4687   if (i-&gt;state() == activeState) {
4688     deleted = remove_from_list(active_first_addr(anyKind), i);
4689   } else {
4690     assert(i-&gt;state() == inactiveState, &quot;invalid state&quot;);
4691     deleted = remove_from_list(inactive_first_addr(anyKind), i);
4692   }
4693 
4694   assert(deleted, &quot;interval has not been found in list&quot;);
4695 }
4696 
4697 
4698 void IntervalWalker::walk_to(IntervalState state, int from) {
4699   assert (state == activeState || state == inactiveState, &quot;wrong state&quot;);
4700   for_each_interval_kind(kind) {
4701     Interval** prev = state == activeState ? active_first_addr(kind) : inactive_first_addr(kind);
4702     Interval* next   = *prev;
4703     while (next-&gt;current_from() &lt;= from) {
4704       Interval* cur = next;
4705       next = cur-&gt;next();
4706 
4707       bool range_has_changed = false;
4708       while (cur-&gt;current_to() &lt;= from) {
4709         cur-&gt;next_range();
4710         range_has_changed = true;
4711       }
4712 
4713       // also handle move from inactive list to active list
4714       range_has_changed = range_has_changed || (state == inactiveState &amp;&amp; cur-&gt;current_from() &lt;= from);
4715 
4716       if (range_has_changed) {
4717         // remove cur from list
4718         *prev = next;
4719         if (cur-&gt;current_at_end()) {
4720           // move to handled state (not maintained as a list)
4721           cur-&gt;set_state(handledState);
4722           interval_moved(cur, kind, state, handledState);
4723         } else if (cur-&gt;current_from() &lt;= from){
4724           // sort into active list
4725           append_sorted(active_first_addr(kind), cur);
4726           cur-&gt;set_state(activeState);
4727           if (*prev == cur) {
4728             assert(state == activeState, &quot;check&quot;);
4729             prev = cur-&gt;next_addr();
4730           }
4731           interval_moved(cur, kind, state, activeState);
4732         } else {
4733           // sort into inactive list
4734           append_sorted(inactive_first_addr(kind), cur);
4735           cur-&gt;set_state(inactiveState);
4736           if (*prev == cur) {
4737             assert(state == inactiveState, &quot;check&quot;);
4738             prev = cur-&gt;next_addr();
4739           }
4740           interval_moved(cur, kind, state, inactiveState);
4741         }
4742       } else {
4743         prev = cur-&gt;next_addr();
4744         continue;
4745       }
4746     }
4747   }
4748 }
4749 
4750 
4751 void IntervalWalker::next_interval() {
4752   IntervalKind kind;
4753   Interval* any   = _unhandled_first[anyKind];
4754   Interval* fixed = _unhandled_first[fixedKind];
4755 
4756   if (any != Interval::end()) {
4757     // intervals may start at same position -&gt; prefer fixed interval
4758     kind = fixed != Interval::end() &amp;&amp; fixed-&gt;from() &lt;= any-&gt;from() ? fixedKind : anyKind;
4759 
4760     assert (kind == fixedKind &amp;&amp; fixed-&gt;from() &lt;= any-&gt;from() ||
4761             kind == anyKind   &amp;&amp; any-&gt;from() &lt;= fixed-&gt;from(), &quot;wrong interval!!!&quot;);
4762     assert(any == Interval::end() || fixed == Interval::end() || any-&gt;from() != fixed-&gt;from() || kind == fixedKind, &quot;if fixed and any-Interval start at same position, fixed must be processed first&quot;);
4763 
4764   } else if (fixed != Interval::end()) {
4765     kind = fixedKind;
4766   } else {
4767     _current = NULL; return;
4768   }
4769   _current_kind = kind;
4770   _current = _unhandled_first[kind];
4771   _unhandled_first[kind] = _current-&gt;next();
4772   _current-&gt;set_next(Interval::end());
4773   _current-&gt;rewind_range();
4774 }
4775 
4776 
4777 void IntervalWalker::walk_to(int lir_op_id) {
4778   assert(_current_position &lt;= lir_op_id, &quot;can not walk backwards&quot;);
4779   while (current() != NULL) {
4780     bool is_active = current()-&gt;from() &lt;= lir_op_id;
4781     int id = is_active ? current()-&gt;from() : lir_op_id;
4782 
4783     TRACE_LINEAR_SCAN(2, if (_current_position &lt; id) { tty-&gt;cr(); tty-&gt;print_cr(&quot;walk_to(%d) **************************************************************&quot;, id); })
4784 
4785     // set _current_position prior to call of walk_to
4786     _current_position = id;
4787 
4788     // call walk_to even if _current_position == id
4789     walk_to(activeState, id);
4790     walk_to(inactiveState, id);
4791 
4792     if (is_active) {
4793       current()-&gt;set_state(activeState);
4794       if (activate_current()) {
4795         append_sorted(active_first_addr(current_kind()), current());
4796         interval_moved(current(), current_kind(), unhandledState, activeState);
4797       }
4798 
4799       next_interval();
4800     } else {
4801       return;
4802     }
4803   }
4804 }
4805 
4806 void IntervalWalker::interval_moved(Interval* interval, IntervalKind kind, IntervalState from, IntervalState to) {
4807 #ifndef PRODUCT
4808   if (TraceLinearScanLevel &gt;= 4) {
4809     #define print_state(state) \
4810     switch(state) {\
4811       case unhandledState: tty-&gt;print(&quot;unhandled&quot;); break;\
4812       case activeState: tty-&gt;print(&quot;active&quot;); break;\
4813       case inactiveState: tty-&gt;print(&quot;inactive&quot;); break;\
4814       case handledState: tty-&gt;print(&quot;handled&quot;); break;\
4815       default: ShouldNotReachHere(); \
4816     }
4817 
4818     print_state(from); tty-&gt;print(&quot; to &quot;); print_state(to);
4819     tty-&gt;fill_to(23);
4820     interval-&gt;print();
4821 
4822     #undef print_state
4823   }
4824 #endif
4825 }
4826 
4827 
4828 
4829 // **** Implementation of LinearScanWalker **************************
4830 
4831 LinearScanWalker::LinearScanWalker(LinearScan* allocator, Interval* unhandled_fixed_first, Interval* unhandled_any_first)
4832   : IntervalWalker(allocator, unhandled_fixed_first, unhandled_any_first)
4833   , _move_resolver(allocator)
4834 {
4835   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
4836     _spill_intervals[i] = new IntervalList(2);
4837   }
4838 }
4839 
4840 
4841 inline void LinearScanWalker::init_use_lists(bool only_process_use_pos) {
4842   for (int i = _first_reg; i &lt;= _last_reg; i++) {
4843     _use_pos[i] = max_jint;
4844 
4845     if (!only_process_use_pos) {
4846       _block_pos[i] = max_jint;
4847       _spill_intervals[i]-&gt;clear();
4848     }
4849   }
4850 }
4851 
4852 inline void LinearScanWalker::exclude_from_use(int reg) {
4853   assert(reg &lt; LinearScan::nof_regs, &quot;interval must have a register assigned (stack slots not allowed)&quot;);
4854   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4855     _use_pos[reg] = 0;
4856   }
4857 }
4858 inline void LinearScanWalker::exclude_from_use(Interval* i) {
4859   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4860 
4861   exclude_from_use(i-&gt;assigned_reg());
4862   exclude_from_use(i-&gt;assigned_regHi());
4863 }
4864 
4865 inline void LinearScanWalker::set_use_pos(int reg, Interval* i, int use_pos, bool only_process_use_pos) {
4866   assert(use_pos != 0, &quot;must use exclude_from_use to set use_pos to 0&quot;);
4867 
4868   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4869     if (_use_pos[reg] &gt; use_pos) {
4870       _use_pos[reg] = use_pos;
4871     }
4872     if (!only_process_use_pos) {
4873       _spill_intervals[reg]-&gt;append(i);
4874     }
4875   }
4876 }
4877 inline void LinearScanWalker::set_use_pos(Interval* i, int use_pos, bool only_process_use_pos) {
4878   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4879   if (use_pos != -1) {
4880     set_use_pos(i-&gt;assigned_reg(), i, use_pos, only_process_use_pos);
4881     set_use_pos(i-&gt;assigned_regHi(), i, use_pos, only_process_use_pos);
4882   }
4883 }
4884 
4885 inline void LinearScanWalker::set_block_pos(int reg, Interval* i, int block_pos) {
4886   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4887     if (_block_pos[reg] &gt; block_pos) {
4888       _block_pos[reg] = block_pos;
4889     }
4890     if (_use_pos[reg] &gt; block_pos) {
4891       _use_pos[reg] = block_pos;
4892     }
4893   }
4894 }
4895 inline void LinearScanWalker::set_block_pos(Interval* i, int block_pos) {
4896   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4897   if (block_pos != -1) {
4898     set_block_pos(i-&gt;assigned_reg(), i, block_pos);
4899     set_block_pos(i-&gt;assigned_regHi(), i, block_pos);
4900   }
4901 }
4902 
4903 
4904 void LinearScanWalker::free_exclude_active_fixed() {
4905   Interval* list = active_first(fixedKind);
4906   while (list != Interval::end()) {
4907     assert(list-&gt;assigned_reg() &lt; LinearScan::nof_regs, &quot;active interval must have a register assigned&quot;);
4908     exclude_from_use(list);
4909     list = list-&gt;next();
4910   }
4911 }
4912 
4913 void LinearScanWalker::free_exclude_active_any() {
4914   Interval* list = active_first(anyKind);
4915   while (list != Interval::end()) {
4916     exclude_from_use(list);
4917     list = list-&gt;next();
4918   }
4919 }
4920 
4921 void LinearScanWalker::free_collect_inactive_fixed(Interval* cur) {
4922   Interval* list = inactive_first(fixedKind);
4923   while (list != Interval::end()) {
4924     if (cur-&gt;to() &lt;= list-&gt;current_from()) {
4925       assert(list-&gt;current_intersects_at(cur) == -1, &quot;must not intersect&quot;);
4926       set_use_pos(list, list-&gt;current_from(), true);
4927     } else {
4928       set_use_pos(list, list-&gt;current_intersects_at(cur), true);
4929     }
4930     list = list-&gt;next();
4931   }
4932 }
4933 
4934 void LinearScanWalker::free_collect_inactive_any(Interval* cur) {
4935   Interval* list = inactive_first(anyKind);
4936   while (list != Interval::end()) {
4937     set_use_pos(list, list-&gt;current_intersects_at(cur), true);
4938     list = list-&gt;next();
4939   }
4940 }
4941 
4942 void LinearScanWalker::spill_exclude_active_fixed() {
4943   Interval* list = active_first(fixedKind);
4944   while (list != Interval::end()) {
4945     exclude_from_use(list);
4946     list = list-&gt;next();
4947   }
4948 }
4949 
4950 void LinearScanWalker::spill_block_inactive_fixed(Interval* cur) {
4951   Interval* list = inactive_first(fixedKind);
4952   while (list != Interval::end()) {
4953     if (cur-&gt;to() &gt; list-&gt;current_from()) {
4954       set_block_pos(list, list-&gt;current_intersects_at(cur));
4955     } else {
4956       assert(list-&gt;current_intersects_at(cur) == -1, &quot;invalid optimization: intervals intersect&quot;);
4957     }
4958 
4959     list = list-&gt;next();
4960   }
4961 }
4962 
4963 void LinearScanWalker::spill_collect_active_any() {
4964   Interval* list = active_first(anyKind);
4965   while (list != Interval::end()) {
4966     set_use_pos(list, MIN2(list-&gt;next_usage(loopEndMarker, _current_position), list-&gt;to()), false);
4967     list = list-&gt;next();
4968   }
4969 }
4970 
4971 void LinearScanWalker::spill_collect_inactive_any(Interval* cur) {
4972   Interval* list = inactive_first(anyKind);
4973   while (list != Interval::end()) {
4974     if (list-&gt;current_intersects(cur)) {
4975       set_use_pos(list, MIN2(list-&gt;next_usage(loopEndMarker, _current_position), list-&gt;to()), false);
4976     }
4977     list = list-&gt;next();
4978   }
4979 }
4980 
4981 
4982 void LinearScanWalker::insert_move(int op_id, Interval* src_it, Interval* dst_it) {
4983   // output all moves here. When source and target are equal, the move is
4984   // optimized away later in assign_reg_nums
4985 
4986   op_id = (op_id + 1) &amp; ~1;
4987   BlockBegin* op_block = allocator()-&gt;block_of_op_with_id(op_id);
4988   assert(op_id &gt; 0 &amp;&amp; allocator()-&gt;block_of_op_with_id(op_id - 2) == op_block, &quot;cannot insert move at block boundary&quot;);
4989 
4990   // calculate index of instruction inside instruction list of current block
4991   // the minimal index (for a block with no spill moves) can be calculated because the
4992   // numbering of instructions is known.
4993   // When the block already contains spill moves, the index must be increased until the
4994   // correct index is reached.
4995   LIR_OpList* list = op_block-&gt;lir()-&gt;instructions_list();
4996   int index = (op_id - list-&gt;at(0)-&gt;id()) / 2;
4997   assert(list-&gt;at(index)-&gt;id() &lt;= op_id, &quot;error in calculation&quot;);
4998 
4999   while (list-&gt;at(index)-&gt;id() != op_id) {
5000     index++;
5001     assert(0 &lt;= index &amp;&amp; index &lt; list-&gt;length(), &quot;index out of bounds&quot;);
5002   }
5003   assert(1 &lt;= index &amp;&amp; index &lt; list-&gt;length(), &quot;index out of bounds&quot;);
5004   assert(list-&gt;at(index)-&gt;id() == op_id, &quot;error in calculation&quot;);
5005 
5006   // insert new instruction before instruction at position index
5007   _move_resolver.move_insert_position(op_block-&gt;lir(), index - 1);
5008   _move_resolver.add_mapping(src_it, dst_it);
5009 }
5010 
5011 
5012 int LinearScanWalker::find_optimal_split_pos(BlockBegin* min_block, BlockBegin* max_block, int max_split_pos) {
5013   int from_block_nr = min_block-&gt;linear_scan_number();
5014   int to_block_nr = max_block-&gt;linear_scan_number();
5015 
5016   assert(0 &lt;= from_block_nr &amp;&amp; from_block_nr &lt; block_count(), &quot;out of range&quot;);
5017   assert(0 &lt;= to_block_nr &amp;&amp; to_block_nr &lt; block_count(), &quot;out of range&quot;);
5018   assert(from_block_nr &lt; to_block_nr, &quot;must cross block boundary&quot;);
5019 
5020   // Try to split at end of max_block. If this would be after
5021   // max_split_pos, then use the begin of max_block
5022   int optimal_split_pos = max_block-&gt;last_lir_instruction_id() + 2;
5023   if (optimal_split_pos &gt; max_split_pos) {
5024     optimal_split_pos = max_block-&gt;first_lir_instruction_id();
5025   }
5026 
5027   int min_loop_depth = max_block-&gt;loop_depth();
5028   for (int i = to_block_nr - 1; i &gt;= from_block_nr; i--) {
5029     BlockBegin* cur = block_at(i);
5030 
5031     if (cur-&gt;loop_depth() &lt; min_loop_depth) {
5032       // block with lower loop-depth found -&gt; split at the end of this block
5033       min_loop_depth = cur-&gt;loop_depth();
5034       optimal_split_pos = cur-&gt;last_lir_instruction_id() + 2;
5035     }
5036   }
5037   assert(optimal_split_pos &gt; allocator()-&gt;max_lir_op_id() || allocator()-&gt;is_block_begin(optimal_split_pos), &quot;algorithm must move split pos to block boundary&quot;);
5038 
5039   return optimal_split_pos;
5040 }
5041 
5042 
5043 int LinearScanWalker::find_optimal_split_pos(Interval* it, int min_split_pos, int max_split_pos, bool do_loop_optimization) {
5044   int optimal_split_pos = -1;
5045   if (min_split_pos == max_split_pos) {
5046     // trivial case, no optimization of split position possible
5047     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      min-pos and max-pos are equal, no optimization possible&quot;));
5048     optimal_split_pos = min_split_pos;
5049 
5050   } else {
5051     assert(min_split_pos &lt; max_split_pos, &quot;must be true then&quot;);
5052     assert(min_split_pos &gt; 0, &quot;cannot access min_split_pos - 1 otherwise&quot;);
5053 
5054     // reason for using min_split_pos - 1: when the minimal split pos is exactly at the
5055     // beginning of a block, then min_split_pos is also a possible split position.
5056     // Use the block before as min_block, because then min_block-&gt;last_lir_instruction_id() + 2 == min_split_pos
5057     BlockBegin* min_block = allocator()-&gt;block_of_op_with_id(min_split_pos - 1);
5058 
5059     // reason for using max_split_pos - 1: otherwise there would be an assertion failure
5060     // when an interval ends at the end of the last block of the method
5061     // (in this case, max_split_pos == allocator()-&gt;max_lir_op_id() + 2, and there is no
5062     // block at this op_id)
5063     BlockBegin* max_block = allocator()-&gt;block_of_op_with_id(max_split_pos - 1);
5064 
5065     assert(min_block-&gt;linear_scan_number() &lt;= max_block-&gt;linear_scan_number(), &quot;invalid order&quot;);
5066     if (min_block == max_block) {
5067       // split position cannot be moved to block boundary, so split as late as possible
5068       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      cannot move split pos to block boundary because min_pos and max_pos are in same block&quot;));
5069       optimal_split_pos = max_split_pos;
5070 
5071     } else if (it-&gt;has_hole_between(max_split_pos - 1, max_split_pos) &amp;&amp; !allocator()-&gt;is_block_begin(max_split_pos)) {
5072       // Do not move split position if the interval has a hole before max_split_pos.
5073       // Intervals resulting from Phi-Functions have more than one definition (marked
5074       // as mustHaveRegister) with a hole before each definition. When the register is needed
5075       // for the second definition, an earlier reloading is unnecessary.
5076       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval has hole just before max_split_pos, so splitting at max_split_pos&quot;));
5077       optimal_split_pos = max_split_pos;
5078 
5079     } else {
5080       // seach optimal block boundary between min_split_pos and max_split_pos
5081       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      moving split pos to optimal block boundary between block B%d and B%d&quot;, min_block-&gt;block_id(), max_block-&gt;block_id()));
5082 
5083       if (do_loop_optimization) {
5084         // Loop optimization: if a loop-end marker is found between min- and max-position,
5085         // then split before this loop
5086         int loop_end_pos = it-&gt;next_usage_exact(loopEndMarker, min_block-&gt;last_lir_instruction_id() + 2);
5087         TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization: loop end found at pos %d&quot;, loop_end_pos));
5088 
5089         assert(loop_end_pos &gt; min_split_pos, &quot;invalid order&quot;);
5090         if (loop_end_pos &lt; max_split_pos) {
5091           // loop-end marker found between min- and max-position
5092           // if it is not the end marker for the same loop as the min-position, then move
5093           // the max-position to this loop block.
5094           // Desired result: uses tagged as shouldHaveRegister inside a loop cause a reloading
5095           // of the interval (normally, only mustHaveRegister causes a reloading)
5096           BlockBegin* loop_block = allocator()-&gt;block_of_op_with_id(loop_end_pos);
5097 
5098           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval is used in loop that ends in block B%d, so trying to move max_block back from B%d to B%d&quot;, loop_block-&gt;block_id(), max_block-&gt;block_id(), loop_block-&gt;block_id()));
5099           assert(loop_block != min_block, &quot;loop_block and min_block must be different because block boundary is needed between&quot;);
5100 
5101           optimal_split_pos = find_optimal_split_pos(min_block, loop_block, loop_block-&gt;last_lir_instruction_id() + 2);
5102           if (optimal_split_pos == loop_block-&gt;last_lir_instruction_id() + 2) {
5103             optimal_split_pos = -1;
5104             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization not necessary&quot;));
5105           } else {
5106             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization successful&quot;));
5107           }
5108         }
5109       }
5110 
5111       if (optimal_split_pos == -1) {
5112         // not calculated by loop optimization
5113         optimal_split_pos = find_optimal_split_pos(min_block, max_block, max_split_pos);
5114       }
5115     }
5116   }
5117   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      optimal split position: %d&quot;, optimal_split_pos));
5118 
5119   return optimal_split_pos;
5120 }
5121 
5122 
5123 /*
5124   split an interval at the optimal position between min_split_pos and
5125   max_split_pos in two parts:
5126   1) the left part has already a location assigned
5127   2) the right part is sorted into to the unhandled-list
5128 */
5129 void LinearScanWalker::split_before_usage(Interval* it, int min_split_pos, int max_split_pos) {
5130   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;----- splitting interval: &quot;); it-&gt;print());
5131   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      between %d and %d&quot;, min_split_pos, max_split_pos));
5132 
5133   assert(it-&gt;from() &lt; min_split_pos,         &quot;cannot split at start of interval&quot;);
5134   assert(current_position() &lt; min_split_pos, &quot;cannot split before current position&quot;);
5135   assert(min_split_pos &lt;= max_split_pos,     &quot;invalid order&quot;);
5136   assert(max_split_pos &lt;= it-&gt;to(),          &quot;cannot split after end of interval&quot;);
5137 
5138   int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, true);
5139 
5140   assert(min_split_pos &lt;= optimal_split_pos &amp;&amp; optimal_split_pos &lt;= max_split_pos, &quot;out of range&quot;);
5141   assert(optimal_split_pos &lt;= it-&gt;to(),  &quot;cannot split after end of interval&quot;);
5142   assert(optimal_split_pos &gt; it-&gt;from(), &quot;cannot split at start of interval&quot;);
5143 
5144   if (optimal_split_pos == it-&gt;to() &amp;&amp; it-&gt;next_usage(mustHaveRegister, min_split_pos) == max_jint) {
5145     // the split position would be just before the end of the interval
5146     // -&gt; no split at all necessary
5147     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      no split necessary because optimal split position is at end of interval&quot;));
5148     return;
5149   }
5150 
5151   // must calculate this before the actual split is performed and before split position is moved to odd op_id
5152   bool move_necessary = !allocator()-&gt;is_block_begin(optimal_split_pos) &amp;&amp; !it-&gt;has_hole_between(optimal_split_pos - 1, optimal_split_pos);
5153 
5154   if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5155     // move position before actual instruction (odd op_id)
5156     optimal_split_pos = (optimal_split_pos - 1) | 1;
5157   }
5158 
5159   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      splitting at position %d&quot;, optimal_split_pos));
5160   assert(allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 1), &quot;split pos must be odd when not on block boundary&quot;);
5161   assert(!allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), &quot;split pos must be even on block boundary&quot;);
5162 
5163   Interval* split_part = it-&gt;split(optimal_split_pos);
5164 
5165   allocator()-&gt;append_interval(split_part);
5166   allocator()-&gt;copy_register_flags(it, split_part);
5167   split_part-&gt;set_insert_move_when_activated(move_necessary);
5168   append_to_unhandled(unhandled_first_addr(anyKind), split_part);
5169 
5170   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      split interval in two parts (insert_move_when_activated: %d)&quot;, move_necessary));
5171   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); it-&gt;print());
5172   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); split_part-&gt;print());
5173 }
5174 
5175 /*
5176   split an interval at the optimal position between min_split_pos and
5177   max_split_pos in two parts:
5178   1) the left part has already a location assigned
5179   2) the right part is always on the stack and therefore ignored in further processing
5180 */
5181 void LinearScanWalker::split_for_spilling(Interval* it) {
5182   // calculate allowed range of splitting position
5183   int max_split_pos = current_position();
5184   int min_split_pos = MAX2(it-&gt;previous_usage(shouldHaveRegister, max_split_pos) + 1, it-&gt;from());
5185 
5186   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;----- splitting and spilling interval: &quot;); it-&gt;print());
5187   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      between %d and %d&quot;, min_split_pos, max_split_pos));
5188 
5189   assert(it-&gt;state() == activeState,     &quot;why spill interval that is not active?&quot;);
5190   assert(it-&gt;from() &lt;= min_split_pos,    &quot;cannot split before start of interval&quot;);
5191   assert(min_split_pos &lt;= max_split_pos, &quot;invalid order&quot;);
5192   assert(max_split_pos &lt; it-&gt;to(),       &quot;cannot split at end end of interval&quot;);
5193   assert(current_position() &lt; it-&gt;to(),  &quot;interval must not end before current position&quot;);
5194 
5195   if (min_split_pos == it-&gt;from()) {
5196     // the whole interval is never used, so spill it entirely to memory
5197     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      spilling entire interval because split pos is at beginning of interval&quot;));
5198     assert(it-&gt;first_usage(shouldHaveRegister) &gt; current_position(), &quot;interval must not have use position before current_position&quot;);
5199 
5200     allocator()-&gt;assign_spill_slot(it);
5201     allocator()-&gt;change_spill_state(it, min_split_pos);
5202 
5203     // Also kick parent intervals out of register to memory when they have no use
5204     // position. This avoids short interval in register surrounded by intervals in
5205     // memory -&gt; avoid useless moves from memory to register and back
5206     Interval* parent = it;
5207     while (parent != NULL &amp;&amp; parent-&gt;is_split_child()) {
5208       parent = parent-&gt;split_child_before_op_id(parent-&gt;from());
5209 
5210       if (parent-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
5211         if (parent-&gt;first_usage(shouldHaveRegister) == max_jint) {
5212           // parent is never used, so kick it out of its assigned register
5213           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      kicking out interval %d out of its register because it is never used&quot;, parent-&gt;reg_num()));
5214           allocator()-&gt;assign_spill_slot(parent);
5215         } else {
5216           // do not go further back because the register is actually used by the interval
5217           parent = NULL;
5218         }
5219       }
5220     }
5221 
5222   } else {
5223     // search optimal split pos, split interval and spill only the right hand part
5224     int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, false);
5225 
5226     assert(min_split_pos &lt;= optimal_split_pos &amp;&amp; optimal_split_pos &lt;= max_split_pos, &quot;out of range&quot;);
5227     assert(optimal_split_pos &lt; it-&gt;to(), &quot;cannot split at end of interval&quot;);
5228     assert(optimal_split_pos &gt;= it-&gt;from(), &quot;cannot split before start of interval&quot;);
5229 
5230     if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5231       // move position before actual instruction (odd op_id)
5232       optimal_split_pos = (optimal_split_pos - 1) | 1;
5233     }
5234 
5235     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      splitting at position %d&quot;, optimal_split_pos));
5236     assert(allocator()-&gt;is_block_begin(optimal_split_pos)  || (optimal_split_pos % 2 == 1), &quot;split pos must be odd when not on block boundary&quot;);
5237     assert(!allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), &quot;split pos must be even on block boundary&quot;);
5238 
5239     Interval* spilled_part = it-&gt;split(optimal_split_pos);
5240     allocator()-&gt;append_interval(spilled_part);
5241     allocator()-&gt;assign_spill_slot(spilled_part);
5242     allocator()-&gt;change_spill_state(spilled_part, optimal_split_pos);
5243 
5244     if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5245       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      inserting move from interval %d to %d&quot;, it-&gt;reg_num(), spilled_part-&gt;reg_num()));
5246       insert_move(optimal_split_pos, it, spilled_part);
5247     }
5248 
5249     // the current_split_child is needed later when moves are inserted for reloading
5250     assert(spilled_part-&gt;current_split_child() == it, &quot;overwriting wrong current_split_child&quot;);
5251     spilled_part-&gt;make_current_split_child();
5252 
5253     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      split interval in two parts&quot;));
5254     TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); it-&gt;print());
5255     TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); spilled_part-&gt;print());
5256   }
5257 }
5258 
5259 
5260 void LinearScanWalker::split_stack_interval(Interval* it) {
5261   int min_split_pos = current_position() + 1;
5262   int max_split_pos = MIN2(it-&gt;first_usage(shouldHaveRegister), it-&gt;to());
5263 
5264   split_before_usage(it, min_split_pos, max_split_pos);
5265 }
5266 
5267 void LinearScanWalker::split_when_partial_register_available(Interval* it, int register_available_until) {
5268   int min_split_pos = MAX2(it-&gt;previous_usage(shouldHaveRegister, register_available_until), it-&gt;from() + 1);
5269   int max_split_pos = register_available_until;
5270 
5271   split_before_usage(it, min_split_pos, max_split_pos);
5272 }
5273 
5274 void LinearScanWalker::split_and_spill_interval(Interval* it) {
5275   assert(it-&gt;state() == activeState || it-&gt;state() == inactiveState, &quot;other states not allowed&quot;);
5276 
5277   int current_pos = current_position();
5278   if (it-&gt;state() == inactiveState) {
5279     // the interval is currently inactive, so no spill slot is needed for now.
5280     // when the split part is activated, the interval has a new chance to get a register,
5281     // so in the best case no stack slot is necessary
5282     assert(it-&gt;has_hole_between(current_pos - 1, current_pos + 1), &quot;interval can not be inactive otherwise&quot;);
5283     split_before_usage(it, current_pos + 1, current_pos + 1);
5284 
5285   } else {
5286     // search the position where the interval must have a register and split
5287     // at the optimal position before.
5288     // The new created part is added to the unhandled list and will get a register
5289     // when it is activated
5290     int min_split_pos = current_pos + 1;
5291     int max_split_pos = MIN2(it-&gt;next_usage(mustHaveRegister, min_split_pos), it-&gt;to());
5292 
5293     split_before_usage(it, min_split_pos, max_split_pos);
5294 
5295     assert(it-&gt;next_usage(mustHaveRegister, current_pos) == max_jint, &quot;the remaining part is spilled to stack and therefore has no register&quot;);
5296     split_for_spilling(it);
5297   }
5298 }
5299 
5300 
5301 int LinearScanWalker::find_free_reg(int reg_needed_until, int interval_to, int hint_reg, int ignore_reg, bool* need_split) {
5302   int min_full_reg = any_reg;
5303   int max_partial_reg = any_reg;
5304 
5305   for (int i = _first_reg; i &lt;= _last_reg; i++) {
5306     if (i == ignore_reg) {
5307       // this register must be ignored
5308 
5309     } else if (_use_pos[i] &gt;= interval_to) {
5310       // this register is free for the full interval
5311       if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] &lt; _use_pos[min_full_reg] &amp;&amp; min_full_reg != hint_reg)) {
5312         min_full_reg = i;
5313       }
5314     } else if (_use_pos[i] &gt; reg_needed_until) {
5315       // this register is at least free until reg_needed_until
5316       if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] &gt; _use_pos[max_partial_reg] &amp;&amp; max_partial_reg != hint_reg)) {
5317         max_partial_reg = i;
5318       }
5319     }
5320   }
5321 
5322   if (min_full_reg != any_reg) {
5323     return min_full_reg;
5324   } else if (max_partial_reg != any_reg) {
5325     *need_split = true;
5326     return max_partial_reg;
5327   } else {
5328     return any_reg;
5329   }
5330 }
5331 
5332 int LinearScanWalker::find_free_double_reg(int reg_needed_until, int interval_to, int hint_reg, bool* need_split) {
5333   assert((_last_reg - _first_reg + 1) % 2 == 0, &quot;adjust algorithm&quot;);
5334 
5335   int min_full_reg = any_reg;
5336   int max_partial_reg = any_reg;
5337 
5338   for (int i = _first_reg; i &lt; _last_reg; i+=2) {
5339     if (_use_pos[i] &gt;= interval_to &amp;&amp; _use_pos[i + 1] &gt;= interval_to) {
5340       // this register is free for the full interval
5341       if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] &lt; _use_pos[min_full_reg] &amp;&amp; min_full_reg != hint_reg)) {
5342         min_full_reg = i;
5343       }
5344     } else if (_use_pos[i] &gt; reg_needed_until &amp;&amp; _use_pos[i + 1] &gt; reg_needed_until) {
5345       // this register is at least free until reg_needed_until
5346       if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] &gt; _use_pos[max_partial_reg] &amp;&amp; max_partial_reg != hint_reg)) {
5347         max_partial_reg = i;
5348       }
5349     }
5350   }
5351 
5352   if (min_full_reg != any_reg) {
5353     return min_full_reg;
5354   } else if (max_partial_reg != any_reg) {
5355     *need_split = true;
5356     return max_partial_reg;
5357   } else {
5358     return any_reg;
5359   }
5360 }
5361 
5362 
5363 bool LinearScanWalker::alloc_free_reg(Interval* cur) {
5364   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot;trying to find free register for &quot;); cur-&gt;print());
5365 
5366   init_use_lists(true);
5367   free_exclude_active_fixed();
5368   free_exclude_active_any();
5369   free_collect_inactive_fixed(cur);
5370   free_collect_inactive_any(cur);
5371   assert(unhandled_first(fixedKind) == Interval::end(), &quot;must not have unhandled fixed intervals because all fixed intervals have a use at position 0&quot;);
5372 
5373   // _use_pos contains the start of the next interval that has this register assigned
5374   // (either as a fixed register or a normal allocated register in the past)
5375   // only intervals overlapping with cur are processed, non-overlapping invervals can be ignored safely
5376   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      state of registers:&quot;));
5377   TRACE_LINEAR_SCAN(4, for (int i = _first_reg; i &lt;= _last_reg; i++) tty-&gt;print_cr(&quot;      reg %d: use_pos: %d&quot;, i, _use_pos[i]));
5378 
5379   int hint_reg, hint_regHi;
5380   Interval* register_hint = cur-&gt;register_hint();
5381   if (register_hint != NULL) {
5382     hint_reg = register_hint-&gt;assigned_reg();
5383     hint_regHi = register_hint-&gt;assigned_regHi();
5384 
5385     if (allocator()-&gt;is_precolored_cpu_interval(register_hint)) {
5386       assert(hint_reg != any_reg &amp;&amp; hint_regHi == any_reg, &quot;must be for fixed intervals&quot;);
5387       hint_regHi = hint_reg + 1;  // connect e.g. eax-edx
5388     }
5389     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;      hint registers %d, %d from interval &quot;, hint_reg, hint_regHi); register_hint-&gt;print());
5390 
5391   } else {
5392     hint_reg = any_reg;
5393     hint_regHi = any_reg;
5394   }
5395   assert(hint_reg == any_reg || hint_reg != hint_regHi, &quot;hint reg and regHi equal&quot;);
5396   assert(cur-&gt;assigned_reg() == any_reg &amp;&amp; cur-&gt;assigned_regHi() == any_reg, &quot;register already assigned to interval&quot;);
5397 
5398   // the register must be free at least until this position
5399   int reg_needed_until = cur-&gt;from() + 1;
5400   int interval_to = cur-&gt;to();
5401 
5402   bool need_split = false;
5403   int split_pos;
5404   int reg;
5405   int regHi = any_reg;
5406 
5407   if (_adjacent_regs) {
5408     reg = find_free_double_reg(reg_needed_until, interval_to, hint_reg, &amp;need_split);
5409     regHi = reg + 1;
5410     if (reg == any_reg) {
5411       return false;
5412     }
5413     split_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
5414 
5415   } else {
5416     reg = find_free_reg(reg_needed_until, interval_to, hint_reg, any_reg, &amp;need_split);
5417     if (reg == any_reg) {
5418       return false;
5419     }
5420     split_pos = _use_pos[reg];
5421 
5422     if (_num_phys_regs == 2) {
5423       regHi = find_free_reg(reg_needed_until, interval_to, hint_regHi, reg, &amp;need_split);
5424 
5425       if (_use_pos[reg] &lt; interval_to &amp;&amp; regHi == any_reg) {
5426         // do not split interval if only one register can be assigned until the split pos
5427         // (when one register is found for the whole interval, split&amp;spill is only
5428         // performed for the hi register)
5429         return false;
5430 
5431       } else if (regHi != any_reg) {
5432         split_pos = MIN2(split_pos, _use_pos[regHi]);
5433 
5434         // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
5435         if (reg &gt; regHi) {
5436           int temp = reg;
5437           reg = regHi;
5438           regHi = temp;
5439         }
5440       }
5441     }
5442   }
5443 
5444   cur-&gt;assign_reg(reg, regHi);
5445   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;selected register %d, %d&quot;, reg, regHi));
5446 
5447   assert(split_pos &gt; 0, &quot;invalid split_pos&quot;);
5448   if (need_split) {
5449     // register not available for full interval, so split it
5450     split_when_partial_register_available(cur, split_pos);
5451   }
5452 
5453   // only return true if interval is completely assigned
5454   return _num_phys_regs == 1 || regHi != any_reg;
5455 }
5456 
5457 
5458 int LinearScanWalker::find_locked_reg(int reg_needed_until, int interval_to, int ignore_reg, bool* need_split) {
5459   int max_reg = any_reg;
5460 
5461   for (int i = _first_reg; i &lt;= _last_reg; i++) {
5462     if (i == ignore_reg) {
5463       // this register must be ignored
5464 
5465     } else if (_use_pos[i] &gt; reg_needed_until) {
5466       if (max_reg == any_reg || _use_pos[i] &gt; _use_pos[max_reg]) {
5467         max_reg = i;
5468       }
5469     }
5470   }
5471 
5472   if (max_reg != any_reg &amp;&amp; _block_pos[max_reg] &lt;= interval_to) {
5473     *need_split = true;
5474   }
5475 
5476   return max_reg;
5477 }
5478 
5479 int LinearScanWalker::find_locked_double_reg(int reg_needed_until, int interval_to, bool* need_split) {
5480   assert((_last_reg - _first_reg + 1) % 2 == 0, &quot;adjust algorithm&quot;);
5481 
5482   int max_reg = any_reg;
5483 
5484   for (int i = _first_reg; i &lt; _last_reg; i+=2) {
5485     if (_use_pos[i] &gt; reg_needed_until &amp;&amp; _use_pos[i + 1] &gt; reg_needed_until) {
5486       if (max_reg == any_reg || _use_pos[i] &gt; _use_pos[max_reg]) {
5487         max_reg = i;
5488       }
5489     }
5490   }
5491 
5492   if (max_reg != any_reg &amp;&amp;
5493       (_block_pos[max_reg] &lt;= interval_to || _block_pos[max_reg + 1] &lt;= interval_to)) {
5494     *need_split = true;
5495   }
5496 
5497   return max_reg;
5498 }
5499 
5500 void LinearScanWalker::split_and_spill_intersecting_intervals(int reg, int regHi) {
5501   assert(reg != any_reg, &quot;no register assigned&quot;);
5502 
5503   for (int i = 0; i &lt; _spill_intervals[reg]-&gt;length(); i++) {
5504     Interval* it = _spill_intervals[reg]-&gt;at(i);
5505     remove_from_list(it);
5506     split_and_spill_interval(it);
5507   }
5508 
5509   if (regHi != any_reg) {
5510     IntervalList* processed = _spill_intervals[reg];
5511     for (int i = 0; i &lt; _spill_intervals[regHi]-&gt;length(); i++) {
5512       Interval* it = _spill_intervals[regHi]-&gt;at(i);
5513       if (processed-&gt;find(it) == -1) {
5514         remove_from_list(it);
5515         split_and_spill_interval(it);
5516       }
5517     }
5518   }
5519 }
5520 
5521 
5522 // Split an Interval and spill it to memory so that cur can be placed in a register
5523 void LinearScanWalker::alloc_locked_reg(Interval* cur) {
5524   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot;need to split and spill to get register for &quot;); cur-&gt;print());
5525 
5526   // collect current usage of registers
5527   init_use_lists(false);
5528   spill_exclude_active_fixed();
5529   assert(unhandled_first(fixedKind) == Interval::end(), &quot;must not have unhandled fixed intervals because all fixed intervals have a use at position 0&quot;);
5530   spill_block_inactive_fixed(cur);
5531   spill_collect_active_any();
5532   spill_collect_inactive_any(cur);
5533 
5534 #ifndef PRODUCT
5535   if (TraceLinearScanLevel &gt;= 4) {
5536     tty-&gt;print_cr(&quot;      state of registers:&quot;);
5537     for (int i = _first_reg; i &lt;= _last_reg; i++) {
5538       tty-&gt;print(&quot;      reg %d: use_pos: %d, block_pos: %d, intervals: &quot;, i, _use_pos[i], _block_pos[i]);
5539       for (int j = 0; j &lt; _spill_intervals[i]-&gt;length(); j++) {
5540         tty-&gt;print(&quot;%d &quot;, _spill_intervals[i]-&gt;at(j)-&gt;reg_num());
5541       }
5542       tty-&gt;cr();
5543     }
5544   }
5545 #endif
5546 
5547   // the register must be free at least until this position
5548   int reg_needed_until = MIN2(cur-&gt;first_usage(mustHaveRegister), cur-&gt;from() + 1);
5549   int interval_to = cur-&gt;to();
5550   assert (reg_needed_until &gt; 0 &amp;&amp; reg_needed_until &lt; max_jint, &quot;interval has no use&quot;);
5551 
5552   int split_pos = 0;
5553   int use_pos = 0;
5554   bool need_split = false;
5555   int reg, regHi;
5556 
5557   if (_adjacent_regs) {
5558     reg = find_locked_double_reg(reg_needed_until, interval_to, &amp;need_split);
5559     regHi = reg + 1;
5560 
5561     if (reg != any_reg) {
5562       use_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
5563       split_pos = MIN2(_block_pos[reg], _block_pos[regHi]);
5564     }
5565   } else {
5566     reg = find_locked_reg(reg_needed_until, interval_to, cur-&gt;assigned_reg(), &amp;need_split);
5567     regHi = any_reg;
5568 
5569     if (reg != any_reg) {
5570       use_pos = _use_pos[reg];
5571       split_pos = _block_pos[reg];
5572 
5573       if (_num_phys_regs == 2) {
5574         if (cur-&gt;assigned_reg() != any_reg) {
5575           regHi = reg;
5576           reg = cur-&gt;assigned_reg();
5577         } else {
5578           regHi = find_locked_reg(reg_needed_until, interval_to, reg, &amp;need_split);
5579           if (regHi != any_reg) {
5580             use_pos = MIN2(use_pos, _use_pos[regHi]);
5581             split_pos = MIN2(split_pos, _block_pos[regHi]);
5582           }
5583         }
5584 
5585         if (regHi != any_reg &amp;&amp; reg &gt; regHi) {
5586           // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
5587           int temp = reg;
5588           reg = regHi;
5589           regHi = temp;
5590         }
5591       }
5592     }
5593   }
5594 
5595   if (reg == any_reg || (_num_phys_regs == 2 &amp;&amp; regHi == any_reg) || use_pos &lt;= cur-&gt;first_usage(mustHaveRegister)) {
5596     // the first use of cur is later than the spilling position -&gt; spill cur
5597     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;able to spill current interval. first_usage(register): %d, use_pos: %d&quot;, cur-&gt;first_usage(mustHaveRegister), use_pos));
5598 
5599     if (cur-&gt;first_usage(mustHaveRegister) &lt;= cur-&gt;from() + 1) {
5600       assert(false, &quot;cannot spill interval that is used in first instruction (possible reason: no register found)&quot;);
5601       // assign a reasonable register and do a bailout in product mode to avoid errors
5602       allocator()-&gt;assign_spill_slot(cur);
5603       BAILOUT(&quot;LinearScan: no register found&quot;);
5604     }
5605 
5606     split_and_spill_interval(cur);
5607   } else {
5608     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;decided to use register %d, %d&quot;, reg, regHi));
5609     assert(reg != any_reg &amp;&amp; (_num_phys_regs == 1 || regHi != any_reg), &quot;no register found&quot;);
5610     assert(split_pos &gt; 0, &quot;invalid split_pos&quot;);
5611     assert(need_split == false || split_pos &gt; cur-&gt;from(), &quot;splitting interval at from&quot;);
5612 
5613     cur-&gt;assign_reg(reg, regHi);
5614     if (need_split) {
5615       // register not available for full interval, so split it
5616       split_when_partial_register_available(cur, split_pos);
5617     }
5618 
5619     // perform splitting and spilling for all affected intervalls
5620     split_and_spill_intersecting_intervals(reg, regHi);
5621   }
5622 }
5623 
5624 bool LinearScanWalker::no_allocation_possible(Interval* cur) {
5625 #ifdef X86
5626   // fast calculation of intervals that can never get a register because the
5627   // the next instruction is a call that blocks all registers
5628   // Note: this does not work if callee-saved registers are available (e.g. on Sparc)
5629 
5630   // check if this interval is the result of a split operation
5631   // (an interval got a register until this position)
5632   int pos = cur-&gt;from();
5633   if ((pos &amp; 1) == 1) {
5634     // the current instruction is a call that blocks all registers
5635     if (pos &lt; allocator()-&gt;max_lir_op_id() &amp;&amp; allocator()-&gt;has_call(pos + 1)) {
5636       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      free register cannot be available because all registers blocked by following call&quot;));
5637 
5638       // safety check that there is really no register available
5639       assert(alloc_free_reg(cur) == false, &quot;found a register for this interval&quot;);
5640       return true;
5641     }
5642 
5643   }
5644 #endif
5645   return false;
5646 }
5647 
5648 void LinearScanWalker::init_vars_for_alloc(Interval* cur) {
5649   BasicType type = cur-&gt;type();
5650   _num_phys_regs = LinearScan::num_physical_regs(type);
5651   _adjacent_regs = LinearScan::requires_adjacent_regs(type);
5652 
5653   if (pd_init_regs_for_alloc(cur)) {
5654     // the appropriate register range was selected.
5655   } else if (type == T_FLOAT || type == T_DOUBLE) {
5656     _first_reg = pd_first_fpu_reg;
5657     _last_reg = pd_last_fpu_reg;
5658   } else {
5659     _first_reg = pd_first_cpu_reg;
5660     _last_reg = FrameMap::last_cpu_reg();
5661   }
5662 
5663   assert(0 &lt;= _first_reg &amp;&amp; _first_reg &lt; LinearScan::nof_regs, &quot;out of range&quot;);
5664   assert(0 &lt;= _last_reg &amp;&amp; _last_reg &lt; LinearScan::nof_regs, &quot;out of range&quot;);
5665 }
5666 
5667 
5668 bool LinearScanWalker::is_move(LIR_Op* op, Interval* from, Interval* to) {
5669   if (op-&gt;code() != lir_move) {
5670     return false;
5671   }
5672   assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5673 
5674   LIR_Opr in = ((LIR_Op1*)op)-&gt;in_opr();
5675   LIR_Opr res = ((LIR_Op1*)op)-&gt;result_opr();
5676   return in-&gt;is_virtual() &amp;&amp; res-&gt;is_virtual() &amp;&amp; in-&gt;vreg_number() == from-&gt;reg_num() &amp;&amp; res-&gt;vreg_number() == to-&gt;reg_num();
5677 }
5678 
5679 // optimization (especially for phi functions of nested loops):
5680 // assign same spill slot to non-intersecting intervals
5681 void LinearScanWalker::combine_spilled_intervals(Interval* cur) {
5682   if (cur-&gt;is_split_child()) {
5683     // optimization is only suitable for split parents
5684     return;
5685   }
5686 
5687   Interval* register_hint = cur-&gt;register_hint(false);
5688   if (register_hint == NULL) {
5689     // cur is not the target of a move, otherwise register_hint would be set
5690     return;
5691   }
5692   assert(register_hint-&gt;is_split_parent(), &quot;register hint must be split parent&quot;);
5693 
5694   if (cur-&gt;spill_state() != noOptimization || register_hint-&gt;spill_state() != noOptimization) {
5695     // combining the stack slots for intervals where spill move optimization is applied
5696     // is not benefitial and would cause problems
5697     return;
5698   }
5699 
5700   int begin_pos = cur-&gt;from();
5701   int end_pos = cur-&gt;to();
5702   if (end_pos &gt; allocator()-&gt;max_lir_op_id() || (begin_pos &amp; 1) != 0 || (end_pos &amp; 1) != 0) {
5703     // safety check that lir_op_with_id is allowed
5704     return;
5705   }
5706 
5707   if (!is_move(allocator()-&gt;lir_op_with_id(begin_pos), register_hint, cur) || !is_move(allocator()-&gt;lir_op_with_id(end_pos), cur, register_hint)) {
5708     // cur and register_hint are not connected with two moves
5709     return;
5710   }
5711 
5712   Interval* begin_hint = register_hint-&gt;split_child_at_op_id(begin_pos, LIR_OpVisitState::inputMode);
5713   Interval* end_hint = register_hint-&gt;split_child_at_op_id(end_pos, LIR_OpVisitState::outputMode);
5714   if (begin_hint == end_hint || begin_hint-&gt;to() != begin_pos || end_hint-&gt;from() != end_pos) {
5715     // register_hint must be split, otherwise the re-writing of use positions does not work
5716     return;
5717   }
5718 
5719   assert(begin_hint-&gt;assigned_reg() != any_reg, &quot;must have register assigned&quot;);
5720   assert(end_hint-&gt;assigned_reg() == any_reg, &quot;must not have register assigned&quot;);
5721   assert(cur-&gt;first_usage(mustHaveRegister) == begin_pos, &quot;must have use position at begin of interval because of move&quot;);
5722   assert(end_hint-&gt;first_usage(mustHaveRegister) == end_pos, &quot;must have use position at begin of interval because of move&quot;);
5723 
5724   if (begin_hint-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
5725     // register_hint is not spilled at begin_pos, so it would not be benefitial to immediately spill cur
5726     return;
5727   }
5728   assert(register_hint-&gt;canonical_spill_slot() != -1, &quot;must be set when part of interval was spilled&quot;);
5729 
5730   // modify intervals such that cur gets the same stack slot as register_hint
5731   // delete use positions to prevent the intervals to get a register at beginning
5732   cur-&gt;set_canonical_spill_slot(register_hint-&gt;canonical_spill_slot());
5733   cur-&gt;remove_first_use_pos();
5734   end_hint-&gt;remove_first_use_pos();
5735 }
5736 
5737 
5738 // allocate a physical register or memory location to an interval
5739 bool LinearScanWalker::activate_current() {
5740   Interval* cur = current();
5741   bool result = true;
5742 
5743   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;+++++ activating interval &quot;); cur-&gt;print());
5744   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      split_parent: %d, insert_move_when_activated: %d&quot;, cur-&gt;split_parent()-&gt;reg_num(), cur-&gt;insert_move_when_activated()));
5745 
5746   if (cur-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
5747     // activating an interval that has a stack slot assigned -&gt; split it at first use position
5748     // used for method parameters
5749     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval has spill slot assigned (method parameter) -&gt; split it before first use&quot;));
5750 
5751     split_stack_interval(cur);
5752     result = false;
5753 
5754   } else if (allocator()-&gt;gen()-&gt;is_vreg_flag_set(cur-&gt;reg_num(), LIRGenerator::must_start_in_memory)) {
5755     // activating an interval that must start in a stack slot, but may get a register later
5756     // used for lir_roundfp: rounding is done by store to stack and reload later
5757     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval must start in stack slot -&gt; split it before first use&quot;));
5758     assert(cur-&gt;assigned_reg() == any_reg &amp;&amp; cur-&gt;assigned_regHi() == any_reg, &quot;register already assigned&quot;);
5759 
5760     allocator()-&gt;assign_spill_slot(cur);
5761     split_stack_interval(cur);
5762     result = false;
5763 
5764   } else if (cur-&gt;assigned_reg() == any_reg) {
5765     // interval has not assigned register -&gt; normal allocation
5766     // (this is the normal case for most intervals)
5767     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      normal allocation of register&quot;));
5768 
5769     // assign same spill slot to non-intersecting intervals
5770     combine_spilled_intervals(cur);
5771 
5772     init_vars_for_alloc(cur);
5773     if (no_allocation_possible(cur) || !alloc_free_reg(cur)) {
5774       // no empty register available.
5775       // split and spill another interval so that this interval gets a register
5776       alloc_locked_reg(cur);
5777     }
5778 
5779     // spilled intervals need not be move to active-list
5780     if (cur-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
5781       result = false;
5782     }
5783   }
5784 
5785   // load spilled values that become active from stack slot to register
5786   if (cur-&gt;insert_move_when_activated()) {
5787     assert(cur-&gt;is_split_child(), &quot;must be&quot;);
5788     assert(cur-&gt;current_split_child() != NULL, &quot;must be&quot;);
5789     assert(cur-&gt;current_split_child()-&gt;reg_num() != cur-&gt;reg_num(), &quot;cannot insert move between same interval&quot;);
5790     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;Inserting move from interval %d to %d because insert_move_when_activated is set&quot;, cur-&gt;current_split_child()-&gt;reg_num(), cur-&gt;reg_num()));
5791 
5792     insert_move(cur-&gt;from(), cur-&gt;current_split_child(), cur);
5793   }
5794   cur-&gt;make_current_split_child();
5795 
5796   return result; // true = interval is moved to active list
5797 }
5798 
5799 
5800 // Implementation of EdgeMoveOptimizer
5801 
5802 EdgeMoveOptimizer::EdgeMoveOptimizer() :
5803   _edge_instructions(4),
5804   _edge_instructions_idx(4)
5805 {
5806 }
5807 
5808 void EdgeMoveOptimizer::optimize(BlockList* code) {
5809   EdgeMoveOptimizer optimizer = EdgeMoveOptimizer();
5810 
5811   // ignore the first block in the list (index 0 is not processed)
5812   for (int i = code-&gt;length() - 1; i &gt;= 1; i--) {
5813     BlockBegin* block = code-&gt;at(i);
5814 
5815     if (block-&gt;number_of_preds() &gt; 1 &amp;&amp; !block-&gt;is_set(BlockBegin::exception_entry_flag)) {
5816       optimizer.optimize_moves_at_block_end(block);
5817     }
5818     if (block-&gt;number_of_sux() == 2) {
5819       optimizer.optimize_moves_at_block_begin(block);
5820     }
5821   }
5822 }
5823 
5824 
5825 // clear all internal data structures
5826 void EdgeMoveOptimizer::init_instructions() {
5827   _edge_instructions.clear();
5828   _edge_instructions_idx.clear();
5829 }
5830 
5831 // append a lir-instruction-list and the index of the current operation in to the list
5832 void EdgeMoveOptimizer::append_instructions(LIR_OpList* instructions, int instructions_idx) {
5833   _edge_instructions.append(instructions);
5834   _edge_instructions_idx.append(instructions_idx);
5835 }
5836 
5837 // return the current operation of the given edge (predecessor or successor)
5838 LIR_Op* EdgeMoveOptimizer::instruction_at(int edge) {
5839   LIR_OpList* instructions = _edge_instructions.at(edge);
5840   int idx = _edge_instructions_idx.at(edge);
5841 
5842   if (idx &lt; instructions-&gt;length()) {
5843     return instructions-&gt;at(idx);
5844   } else {
5845     return NULL;
5846   }
5847 }
5848 
5849 // removes the current operation of the given edge (predecessor or successor)
5850 void EdgeMoveOptimizer::remove_cur_instruction(int edge, bool decrement_index) {
5851   LIR_OpList* instructions = _edge_instructions.at(edge);
5852   int idx = _edge_instructions_idx.at(edge);
5853   instructions-&gt;remove_at(idx);
5854 
5855   if (decrement_index) {
5856     _edge_instructions_idx.at_put(edge, idx - 1);
5857   }
5858 }
5859 
5860 
5861 bool EdgeMoveOptimizer::operations_different(LIR_Op* op1, LIR_Op* op2) {
5862   if (op1 == NULL || op2 == NULL) {
5863     // at least one block is already empty -&gt; no optimization possible
5864     return true;
5865   }
5866 
5867   if (op1-&gt;code() == lir_move &amp;&amp; op2-&gt;code() == lir_move) {
5868     assert(op1-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5869     assert(op2-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5870     LIR_Op1* move1 = (LIR_Op1*)op1;
5871     LIR_Op1* move2 = (LIR_Op1*)op2;
5872     if (move1-&gt;info() == move2-&gt;info() &amp;&amp; move1-&gt;in_opr() == move2-&gt;in_opr() &amp;&amp; move1-&gt;result_opr() == move2-&gt;result_opr()) {
5873       // these moves are exactly equal and can be optimized
5874       return false;
5875     }
5876 
5877   } else if (op1-&gt;code() == lir_fxch &amp;&amp; op2-&gt;code() == lir_fxch) {
5878     assert(op1-&gt;as_Op1() != NULL, &quot;fxch must be LIR_Op1&quot;);
5879     assert(op2-&gt;as_Op1() != NULL, &quot;fxch must be LIR_Op1&quot;);
5880     LIR_Op1* fxch1 = (LIR_Op1*)op1;
5881     LIR_Op1* fxch2 = (LIR_Op1*)op2;
5882     if (fxch1-&gt;in_opr()-&gt;as_jint() == fxch2-&gt;in_opr()-&gt;as_jint()) {
5883       // equal FPU stack operations can be optimized
5884       return false;
5885     }
5886 
5887   } else if (op1-&gt;code() == lir_fpop_raw &amp;&amp; op2-&gt;code() == lir_fpop_raw) {
5888     // equal FPU stack operations can be optimized
5889     return false;
5890   }
5891 
5892   // no optimization possible
5893   return true;
5894 }
5895 
5896 void EdgeMoveOptimizer::optimize_moves_at_block_end(BlockBegin* block) {
5897   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;optimizing moves at end of block B%d&quot;, block-&gt;block_id()));
5898 
5899   if (block-&gt;is_predecessor(block)) {
5900     // currently we can&#39;t handle this correctly.
5901     return;
5902   }
5903 
5904   init_instructions();
5905   int num_preds = block-&gt;number_of_preds();
5906   assert(num_preds &gt; 1, &quot;do not call otherwise&quot;);
5907   assert(!block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;exception handlers not allowed&quot;);
5908 
5909   // setup a list with the lir-instructions of all predecessors
5910   int i;
5911   for (i = 0; i &lt; num_preds; i++) {
5912     BlockBegin* pred = block-&gt;pred_at(i);
5913     LIR_OpList* pred_instructions = pred-&gt;lir()-&gt;instructions_list();
5914 
5915     if (pred-&gt;number_of_sux() != 1) {
5916       // this can happen with switch-statements where multiple edges are between
5917       // the same blocks.
5918       return;
5919     }
5920 
5921     assert(pred-&gt;number_of_sux() == 1, &quot;can handle only one successor&quot;);
5922     assert(pred-&gt;sux_at(0) == block, &quot;invalid control flow&quot;);
5923     assert(pred_instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successor must end with branch&quot;);
5924     assert(pred_instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
5925     assert(pred_instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block must end with unconditional branch&quot;);
5926 
5927     if (pred_instructions-&gt;last()-&gt;info() != NULL) {
5928       // can not optimize instructions when debug info is needed
5929       return;
5930     }
5931 
5932     // ignore the unconditional branch at the end of the block
5933     append_instructions(pred_instructions, pred_instructions-&gt;length() - 2);
5934   }
5935 
5936 
5937   // process lir-instructions while all predecessors end with the same instruction
5938   while (true) {
5939     LIR_Op* op = instruction_at(0);
5940     for (i = 1; i &lt; num_preds; i++) {
5941       if (operations_different(op, instruction_at(i))) {
5942         // these instructions are different and cannot be optimized -&gt;
5943         // no further optimization possible
5944         return;
5945       }
5946     }
5947 
5948     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;found instruction that is equal in all %d predecessors: &quot;, num_preds); op-&gt;print());
5949 
5950     // insert the instruction at the beginning of the current block
5951     block-&gt;lir()-&gt;insert_before(1, op);
5952 
5953     // delete the instruction at the end of all predecessors
5954     for (i = 0; i &lt; num_preds; i++) {
5955       remove_cur_instruction(i, true);
5956     }
5957   }
5958 }
5959 
5960 
5961 void EdgeMoveOptimizer::optimize_moves_at_block_begin(BlockBegin* block) {
5962   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;optimization moves at begin of block B%d&quot;, block-&gt;block_id()));
5963 
5964   init_instructions();
5965   int num_sux = block-&gt;number_of_sux();
5966 
5967   LIR_OpList* cur_instructions = block-&gt;lir()-&gt;instructions_list();
5968 
5969   assert(num_sux == 2, &quot;method should not be called otherwise&quot;);
5970   assert(cur_instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successor must end with branch&quot;);
5971   assert(cur_instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
5972   assert(cur_instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block must end with unconditional branch&quot;);
5973 
5974   if (cur_instructions-&gt;last()-&gt;info() != NULL) {
5975     // can no optimize instructions when debug info is needed
5976     return;
5977   }
5978 
5979   LIR_Op* branch = cur_instructions-&gt;at(cur_instructions-&gt;length() - 2);
5980   if (branch-&gt;info() != NULL || (branch-&gt;code() != lir_branch &amp;&amp; branch-&gt;code() != lir_cond_float_branch)) {
5981     // not a valid case for optimization
5982     // currently, only blocks that end with two branches (conditional branch followed
5983     // by unconditional branch) are optimized
5984     return;
5985   }
5986 
5987   // now it is guaranteed that the block ends with two branch instructions.
5988   // the instructions are inserted at the end of the block before these two branches
5989   int insert_idx = cur_instructions-&gt;length() - 2;
5990 
5991   int i;
5992 #ifdef ASSERT
5993   for (i = insert_idx - 1; i &gt;= 0; i--) {
5994     LIR_Op* op = cur_instructions-&gt;at(i);
5995     if ((op-&gt;code() == lir_branch || op-&gt;code() == lir_cond_float_branch) &amp;&amp; ((LIR_OpBranch*)op)-&gt;block() != NULL) {
5996       assert(false, &quot;block with two successors can have only two branch instructions&quot;);
5997     }
5998   }
5999 #endif
6000 
6001   // setup a list with the lir-instructions of all successors
6002   for (i = 0; i &lt; num_sux; i++) {
6003     BlockBegin* sux = block-&gt;sux_at(i);
6004     LIR_OpList* sux_instructions = sux-&gt;lir()-&gt;instructions_list();
6005 
6006     assert(sux_instructions-&gt;at(0)-&gt;code() == lir_label, &quot;block must start with label&quot;);
6007 
6008     if (sux-&gt;number_of_preds() != 1) {
6009       // this can happen with switch-statements where multiple edges are between
6010       // the same blocks.
6011       return;
6012     }
6013     assert(sux-&gt;pred_at(0) == block, &quot;invalid control flow&quot;);
6014     assert(!sux-&gt;is_set(BlockBegin::exception_entry_flag), &quot;exception handlers not allowed&quot;);
6015 
6016     // ignore the label at the beginning of the block
6017     append_instructions(sux_instructions, 1);
6018   }
6019 
6020   // process lir-instructions while all successors begin with the same instruction
6021   while (true) {
6022     LIR_Op* op = instruction_at(0);
6023     for (i = 1; i &lt; num_sux; i++) {
6024       if (operations_different(op, instruction_at(i))) {
6025         // these instructions are different and cannot be optimized -&gt;
6026         // no further optimization possible
6027         return;
6028       }
6029     }
6030 
6031     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;----- found instruction that is equal in all %d successors: &quot;, num_sux); op-&gt;print());
6032 
6033     // insert instruction at end of current block
6034     block-&gt;lir()-&gt;insert_before(insert_idx, op);
6035     insert_idx++;
6036 
6037     // delete the instructions at the beginning of all successors
6038     for (i = 0; i &lt; num_sux; i++) {
6039       remove_cur_instruction(i, false);
6040     }
6041   }
6042 }
6043 
6044 
6045 // Implementation of ControlFlowOptimizer
6046 
6047 ControlFlowOptimizer::ControlFlowOptimizer() :
6048   _original_preds(4)
6049 {
6050 }
6051 
6052 void ControlFlowOptimizer::optimize(BlockList* code) {
6053   ControlFlowOptimizer optimizer = ControlFlowOptimizer();
6054 
6055   // push the OSR entry block to the end so that we&#39;re not jumping over it.
6056   BlockBegin* osr_entry = code-&gt;at(0)-&gt;end()-&gt;as_Base()-&gt;osr_entry();
6057   if (osr_entry) {
6058     int index = osr_entry-&gt;linear_scan_number();
6059     assert(code-&gt;at(index) == osr_entry, &quot;wrong index&quot;);
6060     code-&gt;remove_at(index);
6061     code-&gt;append(osr_entry);
6062   }
6063 
6064   optimizer.reorder_short_loops(code);
6065   optimizer.delete_empty_blocks(code);
6066   optimizer.delete_unnecessary_jumps(code);
6067   optimizer.delete_jumps_to_return(code);
6068 }
6069 
6070 void ControlFlowOptimizer::reorder_short_loop(BlockList* code, BlockBegin* header_block, int header_idx) {
6071   int i = header_idx + 1;
6072   int max_end = MIN2(header_idx + ShortLoopSize, code-&gt;length());
6073   while (i &lt; max_end &amp;&amp; code-&gt;at(i)-&gt;loop_depth() &gt;= header_block-&gt;loop_depth()) {
6074     i++;
6075   }
6076 
6077   if (i == code-&gt;length() || code-&gt;at(i)-&gt;loop_depth() &lt; header_block-&gt;loop_depth()) {
6078     int end_idx = i - 1;
6079     BlockBegin* end_block = code-&gt;at(end_idx);
6080 
6081     if (end_block-&gt;number_of_sux() == 1 &amp;&amp; end_block-&gt;sux_at(0) == header_block) {
6082       // short loop from header_idx to end_idx found -&gt; reorder blocks such that
6083       // the header_block is the last block instead of the first block of the loop
6084       TRACE_LINEAR_SCAN(1, tty-&gt;print_cr(&quot;Reordering short loop: length %d, header B%d, end B%d&quot;,
6085                                          end_idx - header_idx + 1,
6086                                          header_block-&gt;block_id(), end_block-&gt;block_id()));
6087 
6088       for (int j = header_idx; j &lt; end_idx; j++) {
6089         code-&gt;at_put(j, code-&gt;at(j + 1));
6090       }
6091       code-&gt;at_put(end_idx, header_block);
6092 
6093       // correct the flags so that any loop alignment occurs in the right place.
6094       assert(code-&gt;at(end_idx)-&gt;is_set(BlockBegin::backward_branch_target_flag), &quot;must be backward branch target&quot;);
6095       code-&gt;at(end_idx)-&gt;clear(BlockBegin::backward_branch_target_flag);
6096       code-&gt;at(header_idx)-&gt;set(BlockBegin::backward_branch_target_flag);
6097     }
6098   }
6099 }
6100 
6101 void ControlFlowOptimizer::reorder_short_loops(BlockList* code) {
6102   for (int i = code-&gt;length() - 1; i &gt;= 0; i--) {
6103     BlockBegin* block = code-&gt;at(i);
6104 
6105     if (block-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) {
6106       reorder_short_loop(code, block, i);
6107     }
6108   }
6109 
6110   DEBUG_ONLY(verify(code));
6111 }
6112 
6113 // only blocks with exactly one successor can be deleted. Such blocks
6114 // must always end with an unconditional branch to this successor
6115 bool ControlFlowOptimizer::can_delete_block(BlockBegin* block) {
6116   if (block-&gt;number_of_sux() != 1 || block-&gt;number_of_exception_handlers() != 0 || block-&gt;is_entry_block()) {
6117     return false;
6118   }
6119 
6120   LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6121 
6122   assert(instructions-&gt;length() &gt;= 2, &quot;block must have label and branch&quot;);
6123   assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6124   assert(instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;last instrcution must always be a branch&quot;);
6125   assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;branch must be unconditional&quot;);
6126   assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;block() == block-&gt;sux_at(0), &quot;branch target must be the successor&quot;);
6127 
6128   // block must have exactly one successor
6129 
6130   if (instructions-&gt;length() == 2 &amp;&amp; instructions-&gt;last()-&gt;info() == NULL) {
6131     return true;
6132   }
6133   return false;
6134 }
6135 
6136 // substitute branch targets in all branch-instructions of this blocks
6137 void ControlFlowOptimizer::substitute_branch_target(BlockBegin* block, BlockBegin* target_from, BlockBegin* target_to) {
6138   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Deleting empty block: substituting from B%d to B%d inside B%d&quot;, target_from-&gt;block_id(), target_to-&gt;block_id(), block-&gt;block_id()));
6139 
6140   LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6141 
6142   assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6143   for (int i = instructions-&gt;length() - 1; i &gt;= 1; i--) {
6144     LIR_Op* op = instructions-&gt;at(i);
6145 
6146     if (op-&gt;code() == lir_branch || op-&gt;code() == lir_cond_float_branch) {
6147       assert(op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6148       LIR_OpBranch* branch = (LIR_OpBranch*)op;
6149 
6150       if (branch-&gt;block() == target_from) {
6151         branch-&gt;change_block(target_to);
6152       }
6153       if (branch-&gt;ublock() == target_from) {
6154         branch-&gt;change_ublock(target_to);
6155       }
6156     }
6157   }
6158 }
6159 
6160 void ControlFlowOptimizer::delete_empty_blocks(BlockList* code) {
6161   int old_pos = 0;
6162   int new_pos = 0;
6163   int num_blocks = code-&gt;length();
6164 
6165   while (old_pos &lt; num_blocks) {
6166     BlockBegin* block = code-&gt;at(old_pos);
6167 
6168     if (can_delete_block(block)) {
6169       BlockBegin* new_target = block-&gt;sux_at(0);
6170 
6171       // propagate backward branch target flag for correct code alignment
6172       if (block-&gt;is_set(BlockBegin::backward_branch_target_flag)) {
6173         new_target-&gt;set(BlockBegin::backward_branch_target_flag);
6174       }
6175 
6176       // collect a list with all predecessors that contains each predecessor only once
6177       // the predecessors of cur are changed during the substitution, so a copy of the
6178       // predecessor list is necessary
6179       int j;
6180       _original_preds.clear();
6181       for (j = block-&gt;number_of_preds() - 1; j &gt;= 0; j--) {
6182         BlockBegin* pred = block-&gt;pred_at(j);
6183         if (_original_preds.find(pred) == -1) {
6184           _original_preds.append(pred);
6185         }
6186       }
6187 
6188       for (j = _original_preds.length() - 1; j &gt;= 0; j--) {
6189         BlockBegin* pred = _original_preds.at(j);
6190         substitute_branch_target(pred, block, new_target);
6191         pred-&gt;substitute_sux(block, new_target);
6192       }
6193     } else {
6194       // adjust position of this block in the block list if blocks before
6195       // have been deleted
6196       if (new_pos != old_pos) {
6197         code-&gt;at_put(new_pos, code-&gt;at(old_pos));
6198       }
6199       new_pos++;
6200     }
6201     old_pos++;
6202   }
6203   code-&gt;trunc_to(new_pos);
6204 
6205   DEBUG_ONLY(verify(code));
6206 }
6207 
6208 void ControlFlowOptimizer::delete_unnecessary_jumps(BlockList* code) {
6209   // skip the last block because there a branch is always necessary
6210   for (int i = code-&gt;length() - 2; i &gt;= 0; i--) {
6211     BlockBegin* block = code-&gt;at(i);
6212     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6213 
6214     LIR_Op* last_op = instructions-&gt;last();
6215     if (last_op-&gt;code() == lir_branch) {
6216       assert(last_op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6217       LIR_OpBranch* last_branch = (LIR_OpBranch*)last_op;
6218 
6219       assert(last_branch-&gt;block() != NULL, &quot;last branch must always have a block as target&quot;);
6220       assert(last_branch-&gt;label() == last_branch-&gt;block()-&gt;label(), &quot;must be equal&quot;);
6221 
6222       if (last_branch-&gt;info() == NULL) {
6223         if (last_branch-&gt;block() == code-&gt;at(i + 1)) {
6224 
6225           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Deleting unconditional branch at end of block B%d&quot;, block-&gt;block_id()));
6226 
6227           // delete last branch instruction
6228           instructions-&gt;trunc_to(instructions-&gt;length() - 1);
6229 
6230         } else {
6231           LIR_Op* prev_op = instructions-&gt;at(instructions-&gt;length() - 2);
6232           if (prev_op-&gt;code() == lir_branch || prev_op-&gt;code() == lir_cond_float_branch) {
6233             assert(prev_op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6234             LIR_OpBranch* prev_branch = (LIR_OpBranch*)prev_op;
6235 
6236             if (prev_branch-&gt;stub() == NULL) {
6237 
6238               LIR_Op2* prev_cmp = NULL;
6239               // There might be a cmove inserted for profiling which depends on the same
6240               // compare. If we change the condition of the respective compare, we have
6241               // to take care of this cmove as well.
6242               LIR_Op2* prev_cmove = NULL;
6243 
6244               for(int j = instructions-&gt;length() - 3; j &gt;= 0 &amp;&amp; prev_cmp == NULL; j--) {
6245                 prev_op = instructions-&gt;at(j);
6246                 // check for the cmove
6247                 if (prev_op-&gt;code() == lir_cmove) {
6248                   assert(prev_op-&gt;as_Op2() != NULL, &quot;cmove must be of type LIR_Op2&quot;);
6249                   prev_cmove = (LIR_Op2*)prev_op;
6250                   assert(prev_branch-&gt;cond() == prev_cmove-&gt;condition(), &quot;should be the same&quot;);
6251                 }
6252                 if (prev_op-&gt;code() == lir_cmp) {
6253                   assert(prev_op-&gt;as_Op2() != NULL, &quot;branch must be of type LIR_Op2&quot;);
6254                   prev_cmp = (LIR_Op2*)prev_op;
6255                   assert(prev_branch-&gt;cond() == prev_cmp-&gt;condition(), &quot;should be the same&quot;);
6256                 }
6257               }
6258               // Guarantee because it is dereferenced below.
6259               guarantee(prev_cmp != NULL, &quot;should have found comp instruction for branch&quot;);
6260               if (prev_branch-&gt;block() == code-&gt;at(i + 1) &amp;&amp; prev_branch-&gt;info() == NULL) {
6261 
6262                 TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Negating conditional branch and deleting unconditional branch at end of block B%d&quot;, block-&gt;block_id()));
6263 
6264                 // eliminate a conditional branch to the immediate successor
6265                 prev_branch-&gt;change_block(last_branch-&gt;block());
6266                 prev_branch-&gt;negate_cond();
6267                 prev_cmp-&gt;set_condition(prev_branch-&gt;cond());
6268                 instructions-&gt;trunc_to(instructions-&gt;length() - 1);
6269                 // if we do change the condition, we have to change the cmove as well
6270                 if (prev_cmove != NULL) {
6271                   prev_cmove-&gt;set_condition(prev_branch-&gt;cond());
6272                   LIR_Opr t = prev_cmove-&gt;in_opr1();
6273                   prev_cmove-&gt;set_in_opr1(prev_cmove-&gt;in_opr2());
6274                   prev_cmove-&gt;set_in_opr2(t);
6275                 }
6276               }
6277             }
6278           }
6279         }
6280       }
6281     }
6282   }
6283 
6284   DEBUG_ONLY(verify(code));
6285 }
6286 
6287 void ControlFlowOptimizer::delete_jumps_to_return(BlockList* code) {
6288 #ifdef ASSERT
6289   ResourceBitMap return_converted(BlockBegin::number_of_blocks());
6290 #endif
6291 
6292   for (int i = code-&gt;length() - 1; i &gt;= 0; i--) {
6293     BlockBegin* block = code-&gt;at(i);
6294     LIR_OpList* cur_instructions = block-&gt;lir()-&gt;instructions_list();
6295     LIR_Op*     cur_last_op = cur_instructions-&gt;last();
6296 
6297     assert(cur_instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6298     if (cur_instructions-&gt;length() == 2 &amp;&amp; cur_last_op-&gt;code() == lir_return) {
6299       // the block contains only a label and a return
6300       // if a predecessor ends with an unconditional jump to this block, then the jump
6301       // can be replaced with a return instruction
6302       //
6303       // Note: the original block with only a return statement cannot be deleted completely
6304       //       because the predecessors might have other (conditional) jumps to this block
6305       //       -&gt; this may lead to unnecesary return instructions in the final code
6306 
6307       assert(cur_last_op-&gt;info() == NULL, &quot;return instructions do not have debug information&quot;);
6308       assert(block-&gt;number_of_sux() == 0 ||
6309              (return_converted.at(block-&gt;block_id()) &amp;&amp; block-&gt;number_of_sux() == 1),
6310              &quot;blocks that end with return must not have successors&quot;);
6311 
6312       assert(cur_last_op-&gt;as_Op1() != NULL, &quot;return must be LIR_Op1&quot;);
6313       LIR_Opr return_opr = ((LIR_Op1*)cur_last_op)-&gt;in_opr();
6314 
6315       for (int j = block-&gt;number_of_preds() - 1; j &gt;= 0; j--) {
6316         BlockBegin* pred = block-&gt;pred_at(j);
6317         LIR_OpList* pred_instructions = pred-&gt;lir()-&gt;instructions_list();
6318         LIR_Op*     pred_last_op = pred_instructions-&gt;last();
6319 
6320         if (pred_last_op-&gt;code() == lir_branch) {
6321           assert(pred_last_op-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
6322           LIR_OpBranch* pred_last_branch = (LIR_OpBranch*)pred_last_op;
6323 
6324           if (pred_last_branch-&gt;block() == block &amp;&amp; pred_last_branch-&gt;cond() == lir_cond_always &amp;&amp; pred_last_branch-&gt;info() == NULL) {
6325             // replace the jump to a return with a direct return
6326             // Note: currently the edge between the blocks is not deleted
6327             pred_instructions-&gt;at_put(pred_instructions-&gt;length() - 1, new LIR_Op1(lir_return, return_opr));
6328 #ifdef ASSERT
6329             return_converted.set_bit(pred-&gt;block_id());
6330 #endif
6331           }
6332         }
6333       }
6334     }
6335   }
6336 }
6337 
6338 
6339 #ifdef ASSERT
6340 void ControlFlowOptimizer::verify(BlockList* code) {
6341   for (int i = 0; i &lt; code-&gt;length(); i++) {
6342     BlockBegin* block = code-&gt;at(i);
6343     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6344 
6345     int j;
6346     for (j = 0; j &lt; instructions-&gt;length(); j++) {
6347       LIR_OpBranch* op_branch = instructions-&gt;at(j)-&gt;as_OpBranch();
6348 
6349       if (op_branch != NULL) {
6350         assert(op_branch-&gt;block() == NULL || code-&gt;find(op_branch-&gt;block()) != -1, &quot;branch target not valid&quot;);
6351         assert(op_branch-&gt;ublock() == NULL || code-&gt;find(op_branch-&gt;ublock()) != -1, &quot;branch target not valid&quot;);
6352       }
6353     }
6354 
6355     for (j = 0; j &lt; block-&gt;number_of_sux() - 1; j++) {
6356       BlockBegin* sux = block-&gt;sux_at(j);
6357       assert(code-&gt;find(sux) != -1, &quot;successor not valid&quot;);
6358     }
6359 
6360     for (j = 0; j &lt; block-&gt;number_of_preds() - 1; j++) {
6361       BlockBegin* pred = block-&gt;pred_at(j);
6362       assert(code-&gt;find(pred) != -1, &quot;successor not valid&quot;);
6363     }
6364   }
6365 }
6366 #endif
6367 
6368 
6369 #ifndef PRODUCT
6370 
6371 // Implementation of LinearStatistic
6372 
6373 const char* LinearScanStatistic::counter_name(int counter_idx) {
6374   switch (counter_idx) {
6375     case counter_method:          return &quot;compiled methods&quot;;
6376     case counter_fpu_method:      return &quot;methods using fpu&quot;;
6377     case counter_loop_method:     return &quot;methods with loops&quot;;
6378     case counter_exception_method:return &quot;methods with xhandler&quot;;
6379 
6380     case counter_loop:            return &quot;loops&quot;;
6381     case counter_block:           return &quot;blocks&quot;;
6382     case counter_loop_block:      return &quot;blocks inside loop&quot;;
6383     case counter_exception_block: return &quot;exception handler entries&quot;;
6384     case counter_interval:        return &quot;intervals&quot;;
6385     case counter_fixed_interval:  return &quot;fixed intervals&quot;;
6386     case counter_range:           return &quot;ranges&quot;;
6387     case counter_fixed_range:     return &quot;fixed ranges&quot;;
6388     case counter_use_pos:         return &quot;use positions&quot;;
6389     case counter_fixed_use_pos:   return &quot;fixed use positions&quot;;
6390     case counter_spill_slots:     return &quot;spill slots&quot;;
6391 
6392     // counter for classes of lir instructions
6393     case counter_instruction:     return &quot;total instructions&quot;;
6394     case counter_label:           return &quot;labels&quot;;
6395     case counter_entry:           return &quot;method entries&quot;;
6396     case counter_return:          return &quot;method returns&quot;;
6397     case counter_call:            return &quot;method calls&quot;;
6398     case counter_move:            return &quot;moves&quot;;
6399     case counter_cmp:             return &quot;compare&quot;;
6400     case counter_cond_branch:     return &quot;conditional branches&quot;;
6401     case counter_uncond_branch:   return &quot;unconditional branches&quot;;
6402     case counter_stub_branch:     return &quot;branches to stub&quot;;
6403     case counter_alu:             return &quot;artithmetic + logic&quot;;
6404     case counter_alloc:           return &quot;allocations&quot;;
6405     case counter_sync:            return &quot;synchronisation&quot;;
6406     case counter_throw:           return &quot;throw&quot;;
6407     case counter_unwind:          return &quot;unwind&quot;;
6408     case counter_typecheck:       return &quot;type+null-checks&quot;;
6409     case counter_fpu_stack:       return &quot;fpu-stack&quot;;
6410     case counter_misc_inst:       return &quot;other instructions&quot;;
6411     case counter_other_inst:      return &quot;misc. instructions&quot;;
6412 
6413     // counter for different types of moves
6414     case counter_move_total:      return &quot;total moves&quot;;
6415     case counter_move_reg_reg:    return &quot;register-&gt;register&quot;;
6416     case counter_move_reg_stack:  return &quot;register-&gt;stack&quot;;
6417     case counter_move_stack_reg:  return &quot;stack-&gt;register&quot;;
6418     case counter_move_stack_stack:return &quot;stack-&gt;stack&quot;;
6419     case counter_move_reg_mem:    return &quot;register-&gt;memory&quot;;
6420     case counter_move_mem_reg:    return &quot;memory-&gt;register&quot;;
6421     case counter_move_const_any:  return &quot;constant-&gt;any&quot;;
6422 
6423     case blank_line_1:            return &quot;&quot;;
6424     case blank_line_2:            return &quot;&quot;;
6425 
6426     default: ShouldNotReachHere(); return &quot;&quot;;
6427   }
6428 }
6429 
6430 LinearScanStatistic::Counter LinearScanStatistic::base_counter(int counter_idx) {
6431   if (counter_idx == counter_fpu_method || counter_idx == counter_loop_method || counter_idx == counter_exception_method) {
6432     return counter_method;
6433   } else if (counter_idx == counter_loop_block || counter_idx == counter_exception_block) {
6434     return counter_block;
6435   } else if (counter_idx &gt;= counter_instruction &amp;&amp; counter_idx &lt;= counter_other_inst) {
6436     return counter_instruction;
6437   } else if (counter_idx &gt;= counter_move_total &amp;&amp; counter_idx &lt;= counter_move_const_any) {
6438     return counter_move_total;
6439   }
6440   return invalid_counter;
6441 }
6442 
6443 LinearScanStatistic::LinearScanStatistic() {
6444   for (int i = 0; i &lt; number_of_counters; i++) {
6445     _counters_sum[i] = 0;
6446     _counters_max[i] = -1;
6447   }
6448 
6449 }
6450 
6451 // add the method-local numbers to the total sum
6452 void LinearScanStatistic::sum_up(LinearScanStatistic &amp;method_statistic) {
6453   for (int i = 0; i &lt; number_of_counters; i++) {
6454     _counters_sum[i] += method_statistic._counters_sum[i];
6455     _counters_max[i] = MAX2(_counters_max[i], method_statistic._counters_sum[i]);
6456   }
6457 }
6458 
6459 void LinearScanStatistic::print(const char* title) {
6460   if (CountLinearScan || TraceLinearScanLevel &gt; 0) {
6461     tty-&gt;cr();
6462     tty-&gt;print_cr(&quot;***** LinearScan statistic - %s *****&quot;, title);
6463 
6464     for (int i = 0; i &lt; number_of_counters; i++) {
6465       if (_counters_sum[i] &gt; 0 || _counters_max[i] &gt;= 0) {
6466         tty-&gt;print(&quot;%25s: %8d&quot;, counter_name(i), _counters_sum[i]);
6467 
6468         LinearScanStatistic::Counter cntr = base_counter(i);
6469         if (cntr != invalid_counter) {
6470           tty-&gt;print(&quot;  (%5.1f%%) &quot;, _counters_sum[i] * 100.0 / _counters_sum[cntr]);
6471         } else {
6472           tty-&gt;print(&quot;           &quot;);
6473         }
6474 
6475         if (_counters_max[i] &gt;= 0) {
6476           tty-&gt;print(&quot;%8d&quot;, _counters_max[i]);
6477         }
6478       }
6479       tty-&gt;cr();
6480     }
6481   }
6482 }
6483 
6484 void LinearScanStatistic::collect(LinearScan* allocator) {
6485   inc_counter(counter_method);
6486   if (allocator-&gt;has_fpu_registers()) {
6487     inc_counter(counter_fpu_method);
6488   }
6489   if (allocator-&gt;num_loops() &gt; 0) {
6490     inc_counter(counter_loop_method);
6491   }
6492   inc_counter(counter_loop, allocator-&gt;num_loops());
6493   inc_counter(counter_spill_slots, allocator-&gt;max_spills());
6494 
6495   int i;
6496   for (i = 0; i &lt; allocator-&gt;interval_count(); i++) {
6497     Interval* cur = allocator-&gt;interval_at(i);
6498 
6499     if (cur != NULL) {
6500       inc_counter(counter_interval);
6501       inc_counter(counter_use_pos, cur-&gt;num_use_positions());
6502       if (LinearScan::is_precolored_interval(cur)) {
6503         inc_counter(counter_fixed_interval);
6504         inc_counter(counter_fixed_use_pos, cur-&gt;num_use_positions());
6505       }
6506 
6507       Range* range = cur-&gt;first();
6508       while (range != Range::end()) {
6509         inc_counter(counter_range);
6510         if (LinearScan::is_precolored_interval(cur)) {
6511           inc_counter(counter_fixed_range);
6512         }
6513         range = range-&gt;next();
6514       }
6515     }
6516   }
6517 
6518   bool has_xhandlers = false;
6519   // Note: only count blocks that are in code-emit order
6520   for (i = 0; i &lt; allocator-&gt;ir()-&gt;code()-&gt;length(); i++) {
6521     BlockBegin* cur = allocator-&gt;ir()-&gt;code()-&gt;at(i);
6522 
6523     inc_counter(counter_block);
6524     if (cur-&gt;loop_depth() &gt; 0) {
6525       inc_counter(counter_loop_block);
6526     }
6527     if (cur-&gt;is_set(BlockBegin::exception_entry_flag)) {
6528       inc_counter(counter_exception_block);
6529       has_xhandlers = true;
6530     }
6531 
6532     LIR_OpList* instructions = cur-&gt;lir()-&gt;instructions_list();
6533     for (int j = 0; j &lt; instructions-&gt;length(); j++) {
6534       LIR_Op* op = instructions-&gt;at(j);
6535 
6536       inc_counter(counter_instruction);
6537 
6538       switch (op-&gt;code()) {
6539         case lir_label:           inc_counter(counter_label); break;
6540         case lir_std_entry:
6541         case lir_osr_entry:       inc_counter(counter_entry); break;
6542         case lir_return:          inc_counter(counter_return); break;
6543 
6544         case lir_rtcall:
6545         case lir_static_call:
6546         case lir_optvirtual_call:
6547         case lir_virtual_call:    inc_counter(counter_call); break;
6548 
6549         case lir_move: {
6550           inc_counter(counter_move);
6551           inc_counter(counter_move_total);
6552 
6553           LIR_Opr in = op-&gt;as_Op1()-&gt;in_opr();
6554           LIR_Opr res = op-&gt;as_Op1()-&gt;result_opr();
6555           if (in-&gt;is_register()) {
6556             if (res-&gt;is_register()) {
6557               inc_counter(counter_move_reg_reg);
6558             } else if (res-&gt;is_stack()) {
6559               inc_counter(counter_move_reg_stack);
6560             } else if (res-&gt;is_address()) {
6561               inc_counter(counter_move_reg_mem);
6562             } else {
6563               ShouldNotReachHere();
6564             }
6565           } else if (in-&gt;is_stack()) {
6566             if (res-&gt;is_register()) {
6567               inc_counter(counter_move_stack_reg);
6568             } else {
6569               inc_counter(counter_move_stack_stack);
6570             }
6571           } else if (in-&gt;is_address()) {
6572             assert(res-&gt;is_register(), &quot;must be&quot;);
6573             inc_counter(counter_move_mem_reg);
6574           } else if (in-&gt;is_constant()) {
6575             inc_counter(counter_move_const_any);
6576           } else {
6577             ShouldNotReachHere();
6578           }
6579           break;
6580         }
6581 
6582         case lir_cmp:             inc_counter(counter_cmp); break;
6583 
6584         case lir_branch:
6585         case lir_cond_float_branch: {
6586           LIR_OpBranch* branch = op-&gt;as_OpBranch();
6587           if (branch-&gt;block() == NULL) {
6588             inc_counter(counter_stub_branch);
6589           } else if (branch-&gt;cond() == lir_cond_always) {
6590             inc_counter(counter_uncond_branch);
6591           } else {
6592             inc_counter(counter_cond_branch);
6593           }
6594           break;
6595         }
6596 
6597         case lir_neg:
6598         case lir_add:
6599         case lir_sub:
6600         case lir_mul:
6601         case lir_mul_strictfp:
6602         case lir_div:
6603         case lir_div_strictfp:
6604         case lir_rem:
6605         case lir_sqrt:
6606         case lir_abs:
6607         case lir_log10:
6608         case lir_logic_and:
6609         case lir_logic_or:
6610         case lir_logic_xor:
6611         case lir_shl:
6612         case lir_shr:
6613         case lir_ushr:            inc_counter(counter_alu); break;
6614 
6615         case lir_alloc_object:
6616         case lir_alloc_array:     inc_counter(counter_alloc); break;
6617 
6618         case lir_monaddr:
6619         case lir_lock:
6620         case lir_unlock:          inc_counter(counter_sync); break;
6621 
6622         case lir_throw:           inc_counter(counter_throw); break;
6623 
6624         case lir_unwind:          inc_counter(counter_unwind); break;
6625 
6626         case lir_null_check:
6627         case lir_leal:
6628         case lir_instanceof:
6629         case lir_checkcast:
6630         case lir_store_check:     inc_counter(counter_typecheck); break;
6631 
6632         case lir_fpop_raw:
6633         case lir_fxch:
6634         case lir_fld:             inc_counter(counter_fpu_stack); break;
6635 
6636         case lir_nop:
6637         case lir_push:
6638         case lir_pop:
6639         case lir_convert:
6640         case lir_roundfp:
6641         case lir_cmove:           inc_counter(counter_misc_inst); break;
6642 
6643         default:                  inc_counter(counter_other_inst); break;
6644       }
6645     }
6646   }
6647 
6648   if (has_xhandlers) {
6649     inc_counter(counter_exception_method);
6650   }
6651 }
6652 
6653 void LinearScanStatistic::compute(LinearScan* allocator, LinearScanStatistic &amp;global_statistic) {
6654   if (CountLinearScan || TraceLinearScanLevel &gt; 0) {
6655 
6656     LinearScanStatistic local_statistic = LinearScanStatistic();
6657 
6658     local_statistic.collect(allocator);
6659     global_statistic.sum_up(local_statistic);
6660 
6661     if (TraceLinearScanLevel &gt; 2) {
6662       local_statistic.print(&quot;current local statistic&quot;);
6663     }
6664   }
6665 }
6666 
6667 
6668 // Implementation of LinearTimers
6669 
6670 LinearScanTimers::LinearScanTimers() {
6671   for (int i = 0; i &lt; number_of_timers; i++) {
6672     timer(i)-&gt;reset();
6673   }
6674 }
6675 
6676 const char* LinearScanTimers::timer_name(int idx) {
6677   switch (idx) {
6678     case timer_do_nothing:               return &quot;Nothing (Time Check)&quot;;
6679     case timer_number_instructions:      return &quot;Number Instructions&quot;;
6680     case timer_compute_local_live_sets:  return &quot;Local Live Sets&quot;;
6681     case timer_compute_global_live_sets: return &quot;Global Live Sets&quot;;
6682     case timer_build_intervals:          return &quot;Build Intervals&quot;;
6683     case timer_sort_intervals_before:    return &quot;Sort Intervals Before&quot;;
6684     case timer_allocate_registers:       return &quot;Allocate Registers&quot;;
6685     case timer_resolve_data_flow:        return &quot;Resolve Data Flow&quot;;
6686     case timer_sort_intervals_after:     return &quot;Sort Intervals After&quot;;
6687     case timer_eliminate_spill_moves:    return &quot;Spill optimization&quot;;
6688     case timer_assign_reg_num:           return &quot;Assign Reg Num&quot;;
6689     case timer_allocate_fpu_stack:       return &quot;Allocate FPU Stack&quot;;
6690     case timer_optimize_lir:             return &quot;Optimize LIR&quot;;
6691     default: ShouldNotReachHere();       return &quot;&quot;;
6692   }
6693 }
6694 
6695 void LinearScanTimers::begin_method() {
6696   if (TimeEachLinearScan) {
6697     // reset all timers to measure only current method
6698     for (int i = 0; i &lt; number_of_timers; i++) {
6699       timer(i)-&gt;reset();
6700     }
6701   }
6702 }
6703 
6704 void LinearScanTimers::end_method(LinearScan* allocator) {
6705   if (TimeEachLinearScan) {
6706 
6707     double c = timer(timer_do_nothing)-&gt;seconds();
6708     double total = 0;
6709     for (int i = 1; i &lt; number_of_timers; i++) {
6710       total += timer(i)-&gt;seconds() - c;
6711     }
6712 
6713     if (total &gt;= 0.0005) {
6714       // print all information in one line for automatic processing
6715       tty-&gt;print(&quot;@&quot;); allocator-&gt;compilation()-&gt;method()-&gt;print_name();
6716 
6717       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;compilation()-&gt;method()-&gt;code_size());
6718       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;block_at(allocator-&gt;block_count() - 1)-&gt;last_lir_instruction_id() / 2);
6719       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;block_count());
6720       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;num_virtual_regs());
6721       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;interval_count());
6722       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;_num_calls);
6723       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;num_loops());
6724 
6725       tty-&gt;print(&quot;@ %6.6f &quot;, total);
6726       for (int i = 1; i &lt; number_of_timers; i++) {
6727         tty-&gt;print(&quot;@ %4.1f &quot;, ((timer(i)-&gt;seconds() - c) / total) * 100);
6728       }
6729       tty-&gt;cr();
6730     }
6731   }
6732 }
6733 
6734 void LinearScanTimers::print(double total_time) {
6735   if (TimeLinearScan) {
6736     // correction value: sum of dummy-timer that only measures the time that
6737     // is necesary to start and stop itself
6738     double c = timer(timer_do_nothing)-&gt;seconds();
6739 
6740     for (int i = 0; i &lt; number_of_timers; i++) {
6741       double t = timer(i)-&gt;seconds();
6742       tty-&gt;print_cr(&quot;    %25s: %6.3f s (%4.1f%%)  corrected: %6.3f s (%4.1f%%)&quot;, timer_name(i), t, (t / total_time) * 100.0, t - c, (t - c) / (total_time - 2 * number_of_timers * c) * 100);
6743     }
6744   }
6745 }
6746 
6747 #endif // #ifndef PRODUCT
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/c1/c1_CodeStubs.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Canonicalizer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Compilation.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_CodeStubs.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 121,10 ***</span>
<span class="line-new-header">--- 121,11 ---</span>
    static float float_zero;
    static double double_zero;
   public:
    ConversionStub(Bytecodes::Code bytecode, LIR_Opr input, LIR_Opr result)
      : _bytecode(bytecode), _input(input), _result(result) {
<span class="line-added">+     NOT_IA32( ShouldNotReachHere(); ) // used only on x86-32</span>
    }
  
    Bytecodes::Code bytecode() { return _bytecode; }
    LIR_Opr         input()    { return _input; }
    LIR_Opr         result()   { return _result; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,20 ***</span>
      masm-&gt;bind(_patch_site_continuation);
      _bytes_to_copy = masm-&gt;pc() - pc_start();
      if (_id == PatchingStub::access_field_id) {
        // embed a fixed offset to handle long patches which need to be offset by a word.
        // the patching code will just add the field offset field to this offset so
<span class="line-modified">!       // that we can refernce either the high or low word of a double word field.</span>
        int field_offset = 0;
        switch (patch_code) {
        case lir_patch_low:         field_offset = lo_word_offset_in_bytes; break;
        case lir_patch_high:        field_offset = hi_word_offset_in_bytes; break;
        case lir_patch_normal:      field_offset = 0;                       break;
        default: ShouldNotReachHere();
        }
        NativeMovRegMem* n_move = nativeMovRegMem_at(pc_start());
        n_move-&gt;set_offset(field_offset);
      } else if (_id == load_klass_id || _id == load_mirror_id || _id == load_appendix_id) {
        assert(_obj != noreg, &quot;must have register object for load_klass/load_mirror&quot;);
  #ifdef ASSERT
        // verify that we&#39;re pointing at a NativeMovConstReg
        nativeMovConstReg_at(pc_start());
<span class="line-new-header">--- 408,22 ---</span>
      masm-&gt;bind(_patch_site_continuation);
      _bytes_to_copy = masm-&gt;pc() - pc_start();
      if (_id == PatchingStub::access_field_id) {
        // embed a fixed offset to handle long patches which need to be offset by a word.
        // the patching code will just add the field offset field to this offset so
<span class="line-modified">!       // that we can reference either the high or low word of a double word field.</span>
        int field_offset = 0;
        switch (patch_code) {
        case lir_patch_low:         field_offset = lo_word_offset_in_bytes; break;
        case lir_patch_high:        field_offset = hi_word_offset_in_bytes; break;
        case lir_patch_normal:      field_offset = 0;                       break;
        default: ShouldNotReachHere();
        }
        NativeMovRegMem* n_move = nativeMovRegMem_at(pc_start());
        n_move-&gt;set_offset(field_offset);
<span class="line-added">+       // Copy will never get executed, so only copy the part which is required for patching.</span>
<span class="line-added">+       _bytes_to_copy = MAX2(n_move-&gt;num_bytes_to_end_of_patch(), (int)NativeGeneralJump::instruction_size);</span>
      } else if (_id == load_klass_id || _id == load_mirror_id || _id == load_appendix_id) {
        assert(_obj != noreg, &quot;must have register object for load_klass/load_mirror&quot;);
  #ifdef ASSERT
        // verify that we&#39;re pointing at a NativeMovConstReg
        nativeMovConstReg_at(pc_start());
</pre>
<center><a href="c1_Canonicalizer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Compilation.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
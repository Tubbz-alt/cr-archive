<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/events.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_EVENTS_HPP
 26 #define SHARE_UTILITIES_EVENTS_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/mutexLocker.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 #include &quot;utilities/formatBuffer.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 32 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
<span class="line-added"> 33 #include &quot;utilities/ostream.hpp&quot;</span>
 34 #include &quot;utilities/vmError.hpp&quot;
 35 
 36 // Events and EventMark provide interfaces to log events taking place in the vm.
 37 // This facility is extremly useful for post-mortem debugging. The eventlog
 38 // often provides crucial information about events leading up to the crash.
 39 //
 40 // Abstractly the logs can record whatever they way but normally they
 41 // would record at least a timestamp and the current Thread, along
 42 // with whatever data they need in a ring buffer.  Commonly fixed
 43 // length text messages are recorded for simplicity but other
 44 // strategies could be used.  Several logs are provided by default but
 45 // new instances can be created as needed.
 46 
 47 // The base event log dumping class that is registered for dumping at
 48 // crash time.  This is a very generic interface that is mainly here
 49 // for completeness.  Normally the templated EventLogBase would be
 50 // subclassed to provide different log types.
 51 class EventLog : public CHeapObj&lt;mtInternal&gt; {
 52   friend class Events;
 53 
 54  private:
 55   EventLog* _next;
 56 
 57   EventLog* next() const { return _next; }
 58 
 59  public:
 60   // Automatically registers the log so that it will be printed during
 61   // crashes.
 62   EventLog();
 63 
<a name="2" id="anc2"></a><span class="line-modified"> 64   // Print log to output stream.</span>
<span class="line-added"> 65   virtual void print_log_on(outputStream* out, int max = -1) = 0;</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67   // Returns true if s matches either the log name or the log handle.</span>
<span class="line-added"> 68   virtual bool matches_name_or_handle(const char* s) const = 0;</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70   // Print log names (for help output of VM.events).</span>
<span class="line-added"> 71   virtual void print_names(outputStream* out) const = 0;</span>
<span class="line-added"> 72 </span>
 73 };
 74 
 75 
 76 // A templated subclass of EventLog that provides basic ring buffer
 77 // functionality.  Most event loggers should subclass this, possibly
 78 // providing a more featureful log function if the existing copy
 79 // semantics aren&#39;t appropriate.  The name is used as the label of the
 80 // log when it is dumped during a crash.
 81 template &lt;class T&gt; class EventLogBase : public EventLog {
 82   template &lt;class X&gt; class EventRecord : public CHeapObj&lt;mtInternal&gt; {
 83    public:
 84     double  timestamp;
 85     Thread* thread;
 86     X       data;
 87   };
 88 
 89  protected:
 90   Mutex           _mutex;
<a name="3" id="anc3"></a><span class="line-added"> 91   // Name is printed out as a header.</span>
 92   const char*     _name;
<a name="4" id="anc4"></a><span class="line-added"> 93   // Handle is a short specifier used to select this particular event log</span>
<span class="line-added"> 94   // for printing (see VM.events command).</span>
<span class="line-added"> 95   const char*     _handle;</span>
 96   int             _length;
 97   int             _index;
 98   int             _count;
 99   EventRecord&lt;T&gt;* _records;
100 
101  public:
<a name="5" id="anc5"></a><span class="line-modified">102   EventLogBase&lt;T&gt;(const char* name, const char* handle, int length = LogEventsBufferEntries):</span>
<span class="line-modified">103     _mutex(Mutex::event, name, true, Mutex::_safepoint_check_never),</span>
104     _name(name),
<a name="6" id="anc6"></a><span class="line-added">105     _handle(handle),</span>
106     _length(length),
107     _index(0),
108     _count(0) {
109     _records = new EventRecord&lt;T&gt;[length];
110   }
111 
112   double fetch_timestamp() {
113     return os::elapsedTime();
114   }
115 
116   // move the ring buffer to next open slot and return the index of
117   // the slot to use for the current message.  Should only be called
118   // while mutex is held.
119   int compute_log_index() {
120     int index = _index;
121     if (_count &lt; _length) _count++;
122     _index++;
123     if (_index &gt;= _length) _index = 0;
124     return index;
125   }
126 
127   bool should_log() {
128     // Don&#39;t bother adding new entries when we&#39;re crashing.  This also
129     // avoids mutating the ring buffer when printing the log.
130     return !VMError::fatal_error_in_progress();
131   }
132 
133   // Print the contents of the log
<a name="7" id="anc7"></a><span class="line-modified">134   void print_log_on(outputStream* out, int max = -1);</span>
<span class="line-added">135 </span>
<span class="line-added">136   // Returns true if s matches either the log name or the log handle.</span>
<span class="line-added">137   bool matches_name_or_handle(const char* s) const;</span>
<span class="line-added">138 </span>
<span class="line-added">139   // Print log names (for help output of VM.events).</span>
<span class="line-added">140   void print_names(outputStream* out) const;</span>
141 
142  private:
<a name="8" id="anc8"></a><span class="line-modified">143   void print_log_impl(outputStream* out, int max = -1);</span>
144 
145   // Print a single element.  A templated implementation might need to
146   // be declared by subclasses.
147   void print(outputStream* out, T&amp; e);
148 
149   void print(outputStream* out, EventRecord&lt;T&gt;&amp; e) {
150     out-&gt;print(&quot;Event: %.3f &quot;, e.timestamp);
151     if (e.thread != NULL) {
152       out-&gt;print(&quot;Thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(e.thread));
153     }
154     print(out, e.data);
155   }
156 };
157 
158 // A simple wrapper class for fixed size text messages.
159 template &lt;size_t bufsz&gt;
160 class FormatStringLogMessage : public FormatBuffer&lt;bufsz&gt; {
<a name="9" id="anc9"></a>




161 };
162 typedef FormatStringLogMessage&lt;256&gt; StringLogMessage;
163 typedef FormatStringLogMessage&lt;512&gt; ExtendedStringLogMessage;
164 
165 // A simple ring buffer of fixed size text messages.
166 template &lt;size_t bufsz&gt;
167 class FormatStringEventLog : public EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt; {
168  public:
<a name="10" id="anc10"></a><span class="line-modified">169   FormatStringEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)</span>
<span class="line-added">170    : EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt;(name, short_name, count) {}</span>
171 
172   void logv(Thread* thread, const char* format, va_list ap) ATTRIBUTE_PRINTF(3, 0) {
173     if (!this-&gt;should_log()) return;
174 
175     double timestamp = this-&gt;fetch_timestamp();
<a name="11" id="anc11"></a><span class="line-modified">176     MutexLocker ml(&amp;this-&gt;_mutex, Mutex::_no_safepoint_check_flag);</span>
177     int index = this-&gt;compute_log_index();
178     this-&gt;_records[index].thread = thread;
179     this-&gt;_records[index].timestamp = timestamp;
180     this-&gt;_records[index].data.printv(format, ap);
181   }
182 
183   void log(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(3, 4) {
184     va_list ap;
185     va_start(ap, format);
186     this-&gt;logv(thread, format, ap);
187     va_end(ap);
188   }
189 };
190 typedef FormatStringEventLog&lt;256&gt; StringEventLog;
191 typedef FormatStringEventLog&lt;512&gt; ExtendedStringEventLog;
192 
193 class InstanceKlass;
194 
195 // Event log for class unloading events to materialize the class name in place in the log stream.
196 class UnloadingEventLog : public EventLogBase&lt;StringLogMessage&gt; {
197  public:
<a name="12" id="anc12"></a><span class="line-modified">198   UnloadingEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)</span>
<span class="line-added">199    : EventLogBase&lt;StringLogMessage&gt;(name, short_name, count) {}</span>
200 
201   void log(Thread* thread, InstanceKlass* ik);
202 };
203 
204 // Event log for exceptions
205 class ExceptionsEventLog : public ExtendedStringEventLog {
206  public:
<a name="13" id="anc13"></a><span class="line-modified">207   ExceptionsEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)</span>
<span class="line-added">208    : ExtendedStringEventLog(name, short_name, count) {}</span>
209 
210   void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
211 };
212 
213 
214 class Events : AllStatic {
215   friend class EventLog;
216 
217  private:
218   static EventLog* _logs;
219 
220   // A log for generic messages that aren&#39;t well categorized.
221   static StringEventLog* _messages;
222 
223   // A log for internal exception related messages, like internal
224   // throws and implicit exceptions.
225   static ExceptionsEventLog* _exceptions;
226 
227   // Deoptization related messages
228   static StringEventLog* _deopt_messages;
229 
230   // Redefinition related messages
231   static StringEventLog* _redefinitions;
232 
233   // Class unloading events
234   static UnloadingEventLog* _class_unloading;
235  public:
<a name="14" id="anc14"></a><span class="line-modified">236 </span>
<span class="line-added">237   // Print all event logs; limit number of events per event log to be printed with max</span>
<span class="line-added">238   // (max == -1 prints all events).</span>
<span class="line-added">239   static void print_all(outputStream* out, int max = -1);</span>
<span class="line-added">240 </span>
<span class="line-added">241   // Print a single event log specified by name or handle.</span>
<span class="line-added">242   static void print_one(outputStream* out, const char* log_name, int max = -1);</span>
243 
244   // Dump all events to the tty
245   static void print();
246 
247   // Logs a generic message with timestamp and format as printf.
248   static void log(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
249 
250   // Log exception related message
251   static void log_exception(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
252   static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
253 
254   static void log_redefinition(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
255 
256   static void log_class_unloading(Thread* thread, InstanceKlass* ik);
257 
258   static void log_deopt_message(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
259 
260   // Register default loggers
261   static void init();
262 };
263 
264 inline void Events::log(Thread* thread, const char* format, ...) {
<a name="15" id="anc15"></a><span class="line-modified">265   if (LogEvents &amp;&amp; _messages != NULL) {</span>
266     va_list ap;
267     va_start(ap, format);
268     _messages-&gt;logv(thread, format, ap);
269     va_end(ap);
270   }
271 }
272 
273 inline void Events::log_exception(Thread* thread, const char* format, ...) {
<a name="16" id="anc16"></a><span class="line-modified">274   if (LogEvents &amp;&amp; _exceptions != NULL) {</span>
275     va_list ap;
276     va_start(ap, format);
277     _exceptions-&gt;logv(thread, format, ap);
278     va_end(ap);
279   }
280 }
281 
282 inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {
<a name="17" id="anc17"></a><span class="line-modified">283   if (LogEvents &amp;&amp; _exceptions != NULL) {</span>
284     _exceptions-&gt;log(thread, h_exception, message, file, line);
285   }
286 }
287 
288 inline void Events::log_redefinition(Thread* thread, const char* format, ...) {
<a name="18" id="anc18"></a><span class="line-modified">289   if (LogEvents &amp;&amp; _redefinitions != NULL) {</span>
290     va_list ap;
291     va_start(ap, format);
292     _redefinitions-&gt;logv(thread, format, ap);
293     va_end(ap);
294   }
295 }
296 
297 inline void Events::log_class_unloading(Thread* thread, InstanceKlass* ik) {
<a name="19" id="anc19"></a><span class="line-modified">298   if (LogEvents &amp;&amp; _class_unloading != NULL) {</span>
299     _class_unloading-&gt;log(thread, ik);
300   }
301 }
302 
303 inline void Events::log_deopt_message(Thread* thread, const char* format, ...) {
<a name="20" id="anc20"></a><span class="line-modified">304   if (LogEvents &amp;&amp; _deopt_messages != NULL) {</span>
305     va_list ap;
306     va_start(ap, format);
307     _deopt_messages-&gt;logv(thread, format, ap);
308     va_end(ap);
309   }
310 }
311 
<a name="21" id="anc21"></a>
312 template &lt;class T&gt;
<a name="22" id="anc22"></a><span class="line-modified">313 inline void EventLogBase&lt;T&gt;::print_log_on(outputStream* out, int max) {</span>
314   if (Thread::current_or_null() == NULL) {
315     // Not yet attached? Don&#39;t try to use locking
<a name="23" id="anc23"></a><span class="line-modified">316     print_log_impl(out, max);</span>
317   } else {
<a name="24" id="anc24"></a><span class="line-modified">318     MutexLocker ml(&amp;_mutex, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">319     print_log_impl(out, max);</span>
320   }
321 }
322 
<a name="25" id="anc25"></a><span class="line-added">323 template &lt;class T&gt;</span>
<span class="line-added">324 inline bool EventLogBase&lt;T&gt;::matches_name_or_handle(const char* s) const {</span>
<span class="line-added">325   return ::strcasecmp(s, _name) == 0 ||</span>
<span class="line-added">326          ::strcasecmp(s, _handle) == 0;</span>
<span class="line-added">327 }</span>
<span class="line-added">328 </span>
<span class="line-added">329 template &lt;class T&gt;</span>
<span class="line-added">330 inline void EventLogBase&lt;T&gt;::print_names(outputStream* out) const {</span>
<span class="line-added">331   out-&gt;print(&quot;\&quot;%s\&quot; : %s&quot;, _handle, _name);</span>
<span class="line-added">332 }</span>
<span class="line-added">333 </span>
334 // Dump the ring buffer entries that current have entries.
335 template &lt;class T&gt;
<a name="26" id="anc26"></a><span class="line-modified">336 inline void EventLogBase&lt;T&gt;::print_log_impl(outputStream* out, int max) {</span>
337   out-&gt;print_cr(&quot;%s (%d events):&quot;, _name, _count);
338   if (_count == 0) {
339     out-&gt;print_cr(&quot;No events&quot;);
340     out-&gt;cr();
341     return;
342   }
343 
<a name="27" id="anc27"></a><span class="line-added">344   int printed = 0;</span>
345   if (_count &lt; _length) {
346     for (int i = 0; i &lt; _count; i++) {
<a name="28" id="anc28"></a><span class="line-added">347       if (max &gt; 0 &amp;&amp; printed == max) {</span>
<span class="line-added">348         break;</span>
<span class="line-added">349       }</span>
350       print(out, _records[i]);
<a name="29" id="anc29"></a><span class="line-added">351       printed ++;</span>
352     }
353   } else {
354     for (int i = _index; i &lt; _length; i++) {
<a name="30" id="anc30"></a><span class="line-added">355       if (max &gt; 0 &amp;&amp; printed == max) {</span>
<span class="line-added">356         break;</span>
<span class="line-added">357       }</span>
358       print(out, _records[i]);
<a name="31" id="anc31"></a><span class="line-added">359       printed ++;</span>
360     }
361     for (int i = 0; i &lt; _index; i++) {
<a name="32" id="anc32"></a><span class="line-added">362       if (max &gt; 0 &amp;&amp; printed == max) {</span>
<span class="line-added">363         break;</span>
<span class="line-added">364       }</span>
365       print(out, _records[i]);
<a name="33" id="anc33"></a><span class="line-added">366       printed ++;</span>
367     }
368   }
<a name="34" id="anc34"></a><span class="line-added">369 </span>
<span class="line-added">370   if (printed == max) {</span>
<span class="line-added">371     out-&gt;print_cr(&quot;...(skipped)&quot;);</span>
<span class="line-added">372   }</span>
<span class="line-added">373 </span>
374   out-&gt;cr();
375 }
376 
377 // Implement a printing routine for the StringLogMessage
378 template &lt;&gt;
379 inline void EventLogBase&lt;StringLogMessage&gt;::print(outputStream* out, StringLogMessage&amp; lm) {
380   out-&gt;print_raw(lm);
381   out-&gt;cr();
382 }
383 
384 // Implement a printing routine for the ExtendedStringLogMessage
385 template &lt;&gt;
386 inline void EventLogBase&lt;ExtendedStringLogMessage&gt;::print(outputStream* out, ExtendedStringLogMessage&amp; lm) {
387   out-&gt;print_raw(lm);
388   out-&gt;cr();
389 }
390 
391 // Place markers for the beginning and end up of a set of events.
392 // These end up in the default log.
393 class EventMark : public StackObj {
394   StringLogMessage _buffer;
395 
396  public:
397   // log a begin event, format as printf
398   EventMark(const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
399   // log an end event
400   ~EventMark();
401 };
402 
403 #endif // SHARE_UTILITIES_EVENTS_HPP
<a name="35" id="anc35"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="35" type="hidden" />
</body>
</html>
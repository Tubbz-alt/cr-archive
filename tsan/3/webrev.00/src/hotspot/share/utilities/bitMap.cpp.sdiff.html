<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/bitMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="align.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bitMap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/bitMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;utilities/bitMap.inline.hpp&quot;
 30 #include &quot;utilities/copy.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;

 32 
 33 STATIC_ASSERT(sizeof(BitMap::bm_word_t) == BytesPerWord); // &quot;Implementation assumption.&quot;
 34 
 35 typedef BitMap::bm_word_t bm_word_t;
 36 typedef BitMap::idx_t     idx_t;
 37 
 38 class ResourceBitMapAllocator : StackObj {
 39  public:
 40   bm_word_t* allocate(idx_t size_in_words) const {
 41     return NEW_RESOURCE_ARRAY(bm_word_t, size_in_words);
 42   }
 43   void free(bm_word_t* map, idx_t size_in_words) const {
 44     // Don&#39;t free resource allocated arrays.
 45   }
 46 };
 47 
 48 class CHeapBitMapAllocator : StackObj {
 49   MEMFLAGS _flags;
 50 
 51  public:
</pre>
<hr />
<pre>
 94   if (old_map != NULL) {
 95     allocator.free(old_map, old_size_in_words);
 96   }
 97 
 98   return map;
 99 }
100 
101 template &lt;class Allocator&gt;
102 bm_word_t* BitMap::allocate(const Allocator&amp; allocator, idx_t size_in_bits, bool clear) {
103   // Reuse reallocate to ensure that the new memory is cleared.
104   return reallocate(allocator, NULL, 0, size_in_bits, clear);
105 }
106 
107 template &lt;class Allocator&gt;
108 void BitMap::free(const Allocator&amp; allocator, bm_word_t* map, idx_t  size_in_bits) {
109   bm_word_t* ret = reallocate(allocator, map, size_in_bits, 0);
110   assert(ret == NULL, &quot;Reallocate shouldn&#39;t have allocated&quot;);
111 }
112 
113 template &lt;class Allocator&gt;
<span class="line-modified">114 void BitMap::resize(const Allocator&amp; allocator, idx_t new_size_in_bits) {</span>
<span class="line-modified">115   bm_word_t* new_map = reallocate(allocator, map(), size(), new_size_in_bits);</span>
116 
117   update(new_map, new_size_in_bits);
118 }
119 
120 template &lt;class Allocator&gt;
<span class="line-modified">121 void BitMap::initialize(const Allocator&amp; allocator, idx_t size_in_bits) {</span>
122   assert(map() == NULL, &quot;precondition&quot;);
123   assert(size() == 0,   &quot;precondition&quot;);
124 
<span class="line-modified">125   resize(allocator, size_in_bits);</span>
126 }
127 
128 template &lt;class Allocator&gt;
<span class="line-modified">129 void BitMap::reinitialize(const Allocator&amp; allocator, idx_t new_size_in_bits) {</span>
<span class="line-modified">130   // Remove previous bits.</span>
<span class="line-modified">131   resize(allocator, 0);</span>
132 
<span class="line-modified">133   initialize(allocator, new_size_in_bits);</span>
134 }
135 
<span class="line-modified">136 ResourceBitMap::ResourceBitMap(idx_t size_in_bits)</span>
<span class="line-modified">137     : BitMap(allocate(ResourceBitMapAllocator(), size_in_bits), size_in_bits) {</span>
138 }
139 
140 void ResourceBitMap::resize(idx_t new_size_in_bits) {
<span class="line-modified">141   BitMap::resize(ResourceBitMapAllocator(), new_size_in_bits);</span>
142 }
143 
144 void ResourceBitMap::initialize(idx_t size_in_bits) {
<span class="line-modified">145   BitMap::initialize(ResourceBitMapAllocator(), size_in_bits);</span>
146 }
147 
148 void ResourceBitMap::reinitialize(idx_t size_in_bits) {
<span class="line-modified">149   BitMap::reinitialize(ResourceBitMapAllocator(), size_in_bits);</span>
150 }
151 
152 ArenaBitMap::ArenaBitMap(Arena* arena, idx_t size_in_bits)
153     : BitMap(allocate(ArenaBitMapAllocator(arena), size_in_bits), size_in_bits) {
154 }
155 
156 CHeapBitMap::CHeapBitMap(idx_t size_in_bits, MEMFLAGS flags, bool clear)
157     : BitMap(allocate(CHeapBitMapAllocator(flags), size_in_bits, clear), size_in_bits), _flags(flags) {
158 }
159 
160 CHeapBitMap::~CHeapBitMap() {
161   free(CHeapBitMapAllocator(_flags), map(), size());
162 }
163 
<span class="line-modified">164 void CHeapBitMap::resize(idx_t new_size_in_bits) {</span>
<span class="line-modified">165   BitMap::resize(CHeapBitMapAllocator(_flags), new_size_in_bits);</span>
166 }
167 
<span class="line-modified">168 void CHeapBitMap::initialize(idx_t size_in_bits) {</span>
<span class="line-modified">169   BitMap::initialize(CHeapBitMapAllocator(_flags), size_in_bits);</span>
170 }
171 
<span class="line-modified">172 void CHeapBitMap::reinitialize(idx_t size_in_bits) {</span>
<span class="line-modified">173   BitMap::reinitialize(CHeapBitMapAllocator(_flags), size_in_bits);</span>
174 }
175 
176 #ifdef ASSERT
<span class="line-modified">177 void BitMap::verify_index(idx_t index) const {</span>
<span class="line-modified">178   assert(index &lt; _size, &quot;BitMap index out of bounds&quot;);</span>

179 }
180 
<span class="line-modified">181 void BitMap::verify_range(idx_t beg_index, idx_t end_index) const {</span>
<span class="line-modified">182   assert(beg_index &lt;= end_index, &quot;BitMap range error&quot;);</span>
<span class="line-modified">183   // Note that [0,0) and [size,size) are both valid ranges.</span>
<span class="line-modified">184   if (end_index != _size) verify_index(end_index);</span>












185 }
186 #endif // #ifdef ASSERT
187 
188 void BitMap::pretouch() {
189   os::pretouch_memory(word_addr(0), word_addr(size()));
190 }
191 
192 void BitMap::set_range_within_word(idx_t beg, idx_t end) {
193   // With a valid range (beg &lt;= end), this test ensures that end != 0, as
194   // required by inverted_bit_mask_for_range.  Also avoids an unnecessary write.
195   if (beg != end) {
196     bm_word_t mask = inverted_bit_mask_for_range(beg, end);
197     *word_addr(beg) |= ~mask;
198   }
199 }
200 
201 void BitMap::clear_range_within_word(idx_t beg, idx_t end) {
202   // With a valid range (beg &lt;= end), this test ensures that end != 0, as
203   // required by inverted_bit_mask_for_range.  Also avoids an unnecessary write.
204   if (beg != end) {
205     bm_word_t mask = inverted_bit_mask_for_range(beg, end);
206     *word_addr(beg) &amp;= mask;
207   }
208 }
209 
210 void BitMap::par_put_range_within_word(idx_t beg, idx_t end, bool value) {
211   assert(value == 0 || value == 1, &quot;0 for clear, 1 for set&quot;);
212   // With a valid range (beg &lt;= end), this test ensures that end != 0, as
213   // required by inverted_bit_mask_for_range.  Also avoids an unnecessary write.
214   if (beg != end) {
215     bm_word_t* pw = word_addr(beg);
216     bm_word_t  w  = *pw;
217     bm_word_t  mr = inverted_bit_mask_for_range(beg, end);
218     bm_word_t  nw = value ? (w | ~mr) : (w &amp; mr);
219     while (true) {
<span class="line-modified">220       bm_word_t res = Atomic::cmpxchg(nw, pw, w);</span>
221       if (res == w) break;
222       w  = res;
223       nw = value ? (w | ~mr) : (w &amp; mr);
224     }
225   }
226 }
227 
228 void BitMap::set_range(idx_t beg, idx_t end) {
229   verify_range(beg, end);
230 
<span class="line-modified">231   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="line-modified">232   idx_t end_full_word = word_index(end);</span>
233 
234   if (beg_full_word &lt; end_full_word) {
235     // The range includes at least one full word.
236     set_range_within_word(beg, bit_index(beg_full_word));
237     set_range_of_words(beg_full_word, end_full_word);
238     set_range_within_word(bit_index(end_full_word), end);
239   } else {
240     // The range spans at most 2 partial words.
241     idx_t boundary = MIN2(bit_index(beg_full_word), end);
242     set_range_within_word(beg, boundary);
243     set_range_within_word(boundary, end);
244   }
245 }
246 
247 void BitMap::clear_range(idx_t beg, idx_t end) {
248   verify_range(beg, end);
249 
<span class="line-modified">250   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="line-modified">251   idx_t end_full_word = word_index(end);</span>
252 
253   if (beg_full_word &lt; end_full_word) {
254     // The range includes at least one full word.
255     clear_range_within_word(beg, bit_index(beg_full_word));
256     clear_range_of_words(beg_full_word, end_full_word);
257     clear_range_within_word(bit_index(end_full_word), end);
258   } else {
259     // The range spans at most 2 partial words.
260     idx_t boundary = MIN2(bit_index(beg_full_word), end);
261     clear_range_within_word(beg, boundary);
262     clear_range_within_word(boundary, end);
263   }
264 }
265 
266 bool BitMap::is_small_range_of_words(idx_t beg_full_word, idx_t end_full_word) {
267   // There is little point to call large version on small ranges.
<span class="line-modified">268   // Need to check carefully, keeping potential idx_t underflow in mind.</span>


269   // The threshold should be at least one word.
270   STATIC_ASSERT(small_range_words &gt;= 1);
<span class="line-modified">271   return (beg_full_word + small_range_words &gt;= end_full_word);</span>
272 }
273 
274 void BitMap::set_large_range(idx_t beg, idx_t end) {
275   verify_range(beg, end);
276 
<span class="line-modified">277   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="line-modified">278   idx_t end_full_word = word_index(end);</span>
279 
280   if (is_small_range_of_words(beg_full_word, end_full_word)) {
281     set_range(beg, end);
282     return;
283   }
284 
285   // The range includes at least one full word.
286   set_range_within_word(beg, bit_index(beg_full_word));
287   set_large_range_of_words(beg_full_word, end_full_word);
288   set_range_within_word(bit_index(end_full_word), end);
289 }
290 
291 void BitMap::clear_large_range(idx_t beg, idx_t end) {
292   verify_range(beg, end);
293 
<span class="line-modified">294   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="line-modified">295   idx_t end_full_word = word_index(end);</span>
296 
297   if (is_small_range_of_words(beg_full_word, end_full_word)) {
298     clear_range(beg, end);
299     return;
300   }
301 
302   // The range includes at least one full word.
303   clear_range_within_word(beg, bit_index(beg_full_word));
304   clear_large_range_of_words(beg_full_word, end_full_word);
305   clear_range_within_word(bit_index(end_full_word), end);
306 }
307 
308 void BitMap::at_put(idx_t offset, bool value) {
309   if (value) {
310     set_bit(offset);
311   } else {
312     clear_bit(offset);
313   }
314 }
315 
</pre>
<hr />
<pre>
326 // make such a strong assertion here, based on
327 // assuming such constrained use (which though true
328 // today, could change in the future to service some
329 // funky parallel algorithm), we encourage callers
330 // to do such verification, as and when appropriate.
331 bool BitMap::par_at_put(idx_t bit, bool value) {
332   return value ? par_set_bit(bit) : par_clear_bit(bit);
333 }
334 
335 void BitMap::at_put_range(idx_t start_offset, idx_t end_offset, bool value) {
336   if (value) {
337     set_range(start_offset, end_offset);
338   } else {
339     clear_range(start_offset, end_offset);
340   }
341 }
342 
343 void BitMap::par_at_put_range(idx_t beg, idx_t end, bool value) {
344   verify_range(beg, end);
345 
<span class="line-modified">346   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="line-modified">347   idx_t end_full_word = word_index(end);</span>
348 
349   if (beg_full_word &lt; end_full_word) {
350     // The range includes at least one full word.
351     par_put_range_within_word(beg, bit_index(beg_full_word), value);
352     if (value) {
353       set_range_of_words(beg_full_word, end_full_word);
354     } else {
355       clear_range_of_words(beg_full_word, end_full_word);
356     }
357     par_put_range_within_word(bit_index(end_full_word), end, value);
358   } else {
359     // The range spans at most 2 partial words.
360     idx_t boundary = MIN2(bit_index(beg_full_word), end);
361     par_put_range_within_word(beg, boundary, value);
362     par_put_range_within_word(boundary, end, value);
363   }
364 
365 }
366 
367 void BitMap::at_put_large_range(idx_t beg, idx_t end, bool value) {
368   if (value) {
369     set_large_range(beg, end);
370   } else {
371     clear_large_range(beg, end);
372   }
373 }
374 
375 void BitMap::par_at_put_large_range(idx_t beg, idx_t end, bool value) {
376   verify_range(beg, end);
377 
<span class="line-modified">378   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="line-modified">379   idx_t end_full_word = word_index(end);</span>
380 
381   if (is_small_range_of_words(beg_full_word, end_full_word)) {
382     par_at_put_range(beg, end, value);
383     return;
384   }
385 
386   // The range includes at least one full word.
387   par_put_range_within_word(beg, bit_index(beg_full_word), value);
388   if (value) {
389     set_large_range_of_words(beg_full_word, end_full_word);
390   } else {
391     clear_large_range_of_words(beg_full_word, end_full_word);
392   }
393   par_put_range_within_word(bit_index(end_full_word), end, value);
394 }
395 
396 inline bm_word_t tail_mask(idx_t tail_bits) {
397   assert(tail_bits != 0, &quot;precondition&quot;); // Works, but shouldn&#39;t be called.
398   assert(tail_bits &lt; (idx_t)BitsPerWord, &quot;precondition&quot;);
399   return (bm_word_t(1) &lt;&lt; tail_bits) - 1;
</pre>
<hr />
<pre>
403 inline bm_word_t tail_of_map(bm_word_t value, idx_t tail_bits) {
404   return value &amp; tail_mask(tail_bits);
405 }
406 
407 // Compute the new last word of a map with a non-aligned length.
408 // new_value has the new trailing bits of the map in the low tail_bits.
409 // old_value is the last word of the map, including bits beyond the end.
410 // Returns old_value with the low tail_bits replaced by the corresponding
411 // bits in new_value.
412 inline bm_word_t merge_tail_of_map(bm_word_t new_value,
413                                    bm_word_t old_value,
414                                    idx_t tail_bits) {
415   bm_word_t mask = tail_mask(tail_bits);
416   return (new_value &amp; mask) | (old_value &amp; ~mask);
417 }
418 
419 bool BitMap::contains(const BitMap&amp; other) const {
420   assert(size() == other.size(), &quot;must have same size&quot;);
421   const bm_word_t* dest_map = map();
422   const bm_word_t* other_map = other.map();
<span class="line-modified">423   idx_t limit = word_index(size());</span>
424   for (idx_t index = 0; index &lt; limit; ++index) {
425     // false if other bitmap has bits set which are clear in this bitmap.
426     if ((~dest_map[index] &amp; other_map[index]) != 0) return false;
427   }
428   idx_t rest = bit_in_word(size());
429   // true unless there is a partial-word tail in which the other
430   // bitmap has bits set which are clear in this bitmap.
431   return (rest == 0) || tail_of_map(~dest_map[limit] &amp; other_map[limit], rest) == 0;
432 }
433 
434 bool BitMap::intersects(const BitMap&amp; other) const {
435   assert(size() == other.size(), &quot;must have same size&quot;);
436   const bm_word_t* dest_map = map();
437   const bm_word_t* other_map = other.map();
<span class="line-modified">438   idx_t limit = word_index(size());</span>
439   for (idx_t index = 0; index &lt; limit; ++index) {
440     if ((dest_map[index] &amp; other_map[index]) != 0) return true;
441   }
442   idx_t rest = bit_in_word(size());
443   // false unless there is a partial-word tail with non-empty intersection.
444   return (rest &gt; 0) &amp;&amp; tail_of_map(dest_map[limit] &amp; other_map[limit], rest) != 0;
445 }
446 
447 void BitMap::set_union(const BitMap&amp; other) {
448   assert(size() == other.size(), &quot;must have same size&quot;);
449   bm_word_t* dest_map = map();
450   const bm_word_t* other_map = other.map();
<span class="line-modified">451   idx_t limit = word_index(size());</span>
452   for (idx_t index = 0; index &lt; limit; ++index) {
453     dest_map[index] |= other_map[index];
454   }
455   idx_t rest = bit_in_word(size());
456   if (rest &gt; 0) {
457     bm_word_t orig = dest_map[limit];
458     dest_map[limit] = merge_tail_of_map(orig | other_map[limit], orig, rest);
459   }
460 }
461 
462 void BitMap::set_difference(const BitMap&amp; other) {
463   assert(size() == other.size(), &quot;must have same size&quot;);
464   bm_word_t* dest_map = map();
465   const bm_word_t* other_map = other.map();
<span class="line-modified">466   idx_t limit = word_index(size());</span>
467   for (idx_t index = 0; index &lt; limit; ++index) {
468     dest_map[index] &amp;= ~other_map[index];
469   }
470   idx_t rest = bit_in_word(size());
471   if (rest &gt; 0) {
472     bm_word_t orig = dest_map[limit];
473     dest_map[limit] = merge_tail_of_map(orig &amp; ~other_map[limit], orig, rest);
474   }
475 }
476 
477 void BitMap::set_intersection(const BitMap&amp; other) {
478   assert(size() == other.size(), &quot;must have same size&quot;);
479   bm_word_t* dest_map = map();
480   const bm_word_t* other_map = other.map();
<span class="line-modified">481   idx_t limit = word_index(size());</span>
482   for (idx_t index = 0; index &lt; limit; ++index) {
483     dest_map[index] &amp;= other_map[index];
484   }
485   idx_t rest = bit_in_word(size());
486   if (rest &gt; 0) {
487     bm_word_t orig = dest_map[limit];
488     dest_map[limit] = merge_tail_of_map(orig &amp; other_map[limit], orig, rest);
489   }
490 }
491 
492 bool BitMap::set_union_with_result(const BitMap&amp; other) {
493   assert(size() == other.size(), &quot;must have same size&quot;);
494   bool changed = false;
495   bm_word_t* dest_map = map();
496   const bm_word_t* other_map = other.map();
<span class="line-modified">497   idx_t limit = word_index(size());</span>
498   for (idx_t index = 0; index &lt; limit; ++index) {
499     bm_word_t orig = dest_map[index];
500     bm_word_t temp = orig | other_map[index];
501     changed = changed || (temp != orig);
502     dest_map[index] = temp;
503   }
504   idx_t rest = bit_in_word(size());
505   if (rest &gt; 0) {
506     bm_word_t orig = dest_map[limit];
507     bm_word_t temp = merge_tail_of_map(orig | other_map[limit], orig, rest);
508     changed = changed || (temp != orig);
509     dest_map[limit] = temp;
510   }
511   return changed;
512 }
513 
514 bool BitMap::set_difference_with_result(const BitMap&amp; other) {
515   assert(size() == other.size(), &quot;must have same size&quot;);
516   bool changed = false;
517   bm_word_t* dest_map = map();
518   const bm_word_t* other_map = other.map();
<span class="line-modified">519   idx_t limit = word_index(size());</span>
520   for (idx_t index = 0; index &lt; limit; ++index) {
521     bm_word_t orig = dest_map[index];
522     bm_word_t temp = orig &amp; ~other_map[index];
523     changed = changed || (temp != orig);
524     dest_map[index] = temp;
525   }
526   idx_t rest = bit_in_word(size());
527   if (rest &gt; 0) {
528     bm_word_t orig = dest_map[limit];
529     bm_word_t temp = merge_tail_of_map(orig &amp; ~other_map[limit], orig, rest);
530     changed = changed || (temp != orig);
531     dest_map[limit] = temp;
532   }
533   return changed;
534 }
535 
536 bool BitMap::set_intersection_with_result(const BitMap&amp; other) {
537   assert(size() == other.size(), &quot;must have same size&quot;);
538   bool changed = false;
539   bm_word_t* dest_map = map();
540   const bm_word_t* other_map = other.map();
<span class="line-modified">541   idx_t limit = word_index(size());</span>
542   for (idx_t index = 0; index &lt; limit; ++index) {
543     bm_word_t orig = dest_map[index];
544     bm_word_t temp = orig &amp; other_map[index];
545     changed = changed || (temp != orig);
546     dest_map[index] = temp;
547   }
548   idx_t rest = bit_in_word(size());
549   if (rest &gt; 0) {
550     bm_word_t orig = dest_map[limit];
551     bm_word_t temp = merge_tail_of_map(orig &amp; other_map[limit], orig, rest);
552     changed = changed || (temp != orig);
553     dest_map[limit] = temp;
554   }
555   return changed;
556 }
557 
558 void BitMap::set_from(const BitMap&amp; other) {
559   assert(size() == other.size(), &quot;must have same size&quot;);
560   bm_word_t* dest_map = map();
561   const bm_word_t* other_map = other.map();
<span class="line-modified">562   idx_t copy_words = word_index(size());</span>
563   Copy::disjoint_words((HeapWord*)other_map, (HeapWord*)dest_map, copy_words);
564   idx_t rest = bit_in_word(size());
565   if (rest &gt; 0) {
566     dest_map[copy_words] = merge_tail_of_map(other_map[copy_words],
567                                              dest_map[copy_words],
568                                              rest);
569   }
570 }
571 
572 bool BitMap::is_same(const BitMap&amp; other) const {
573   assert(size() == other.size(), &quot;must have same size&quot;);
574   const bm_word_t* dest_map = map();
575   const bm_word_t* other_map = other.map();
<span class="line-modified">576   idx_t limit = word_index(size());</span>
577   for (idx_t index = 0; index &lt; limit; ++index) {
578     if (dest_map[index] != other_map[index]) return false;
579   }
580   idx_t rest = bit_in_word(size());
581   return (rest == 0) || (tail_of_map(dest_map[limit] ^ other_map[limit], rest) == 0);
582 }
583 
584 bool BitMap::is_full() const {
585   const bm_word_t* words = map();
<span class="line-modified">586   idx_t limit = word_index(size());</span>
587   for (idx_t index = 0; index &lt; limit; ++index) {
588     if (~words[index] != 0) return false;
589   }
590   idx_t rest = bit_in_word(size());
591   return (rest == 0) || (tail_of_map(~words[limit], rest) == 0);
592 }
593 
594 bool BitMap::is_empty() const {
595   const bm_word_t* words = map();
<span class="line-modified">596   idx_t limit = word_index(size());</span>
597   for (idx_t index = 0; index &lt; limit; ++index) {
598     if (words[index] != 0) return false;
599   }
600   idx_t rest = bit_in_word(size());
601   return (rest == 0) || (tail_of_map(words[limit], rest) == 0);
602 }
603 
604 void BitMap::clear_large() {
605   clear_large_range_of_words(0, size_in_words());
606 }
607 
608 // Note that if the closure itself modifies the bitmap
609 // then modifications in and to the left of the _bit_ being
610 // currently sampled will not be seen. Note also that the
611 // interval [leftOffset, rightOffset) is right open.
612 bool BitMap::iterate(BitMapClosure* blk, idx_t leftOffset, idx_t rightOffset) {
613   verify_range(leftOffset, rightOffset);
614 
<span class="line-modified">615   idx_t startIndex = word_index(leftOffset);</span>
<span class="line-modified">616   idx_t endIndex   = MIN2(word_index(rightOffset) + 1, size_in_words());</span>
617   for (idx_t index = startIndex, offset = leftOffset;
618        offset &lt; rightOffset &amp;&amp; index &lt; endIndex;
619        offset = (++index) &lt;&lt; LogBitsPerWord) {
620     idx_t rest = map(index) &gt;&gt; (offset &amp; (BitsPerWord - 1));
621     for (; offset &lt; rightOffset &amp;&amp; rest != 0; offset++) {
622       if (rest &amp; 1) {
623         if (!blk-&gt;do_bit(offset)) return false;
624         //  resample at each closure application
625         // (see, for instance, CMS bug 4525989)
626         rest = map(index) &gt;&gt; (offset &amp; (BitsPerWord -1));
627       }
628       rest = rest &gt;&gt; 1;
629     }
630   }
631   return true;
632 }
633 
<span class="line-removed">634 const BitMap::idx_t* BitMap::_pop_count_table = NULL;</span>
<span class="line-removed">635 </span>
<span class="line-removed">636 void BitMap::init_pop_count_table() {</span>
<span class="line-removed">637   if (_pop_count_table == NULL) {</span>
<span class="line-removed">638     BitMap::idx_t *table = NEW_C_HEAP_ARRAY(idx_t, 256, mtInternal);</span>
<span class="line-removed">639     for (uint i = 0; i &lt; 256; i++) {</span>
<span class="line-removed">640       table[i] = num_set_bits(i);</span>
<span class="line-removed">641     }</span>
<span class="line-removed">642 </span>
<span class="line-removed">643     if (!Atomic::replace_if_null(table, &amp;_pop_count_table)) {</span>
<span class="line-removed">644       guarantee(_pop_count_table != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">645       FREE_C_HEAP_ARRAY(idx_t, table);</span>
<span class="line-removed">646     }</span>
<span class="line-removed">647   }</span>
<span class="line-removed">648 }</span>
<span class="line-removed">649 </span>
<span class="line-removed">650 BitMap::idx_t BitMap::num_set_bits(bm_word_t w) {</span>
<span class="line-removed">651   idx_t bits = 0;</span>
<span class="line-removed">652 </span>
<span class="line-removed">653   while (w != 0) {</span>
<span class="line-removed">654     while ((w &amp; 1) == 0) {</span>
<span class="line-removed">655       w &gt;&gt;= 1;</span>
<span class="line-removed">656     }</span>
<span class="line-removed">657     bits++;</span>
<span class="line-removed">658     w &gt;&gt;= 1;</span>
<span class="line-removed">659   }</span>
<span class="line-removed">660   return bits;</span>
<span class="line-removed">661 }</span>
<span class="line-removed">662 </span>
<span class="line-removed">663 BitMap::idx_t BitMap::num_set_bits_from_table(unsigned char c) {</span>
<span class="line-removed">664   assert(_pop_count_table != NULL, &quot;precondition&quot;);</span>
<span class="line-removed">665   return _pop_count_table[c];</span>
<span class="line-removed">666 }</span>
<span class="line-removed">667 </span>
668 BitMap::idx_t BitMap::count_one_bits() const {
<span class="line-removed">669   init_pop_count_table(); // If necessary.</span>
670   idx_t sum = 0;
<span class="line-removed">671   typedef unsigned char uchar;</span>
672   for (idx_t i = 0; i &lt; size_in_words(); i++) {
673     bm_word_t w = map()[i];
<span class="line-modified">674     for (size_t j = 0; j &lt; sizeof(bm_word_t); j++) {</span>
<span class="line-removed">675       sum += num_set_bits_from_table(uchar(w &amp; 255));</span>
<span class="line-removed">676       w &gt;&gt;= 8;</span>
<span class="line-removed">677     }</span>
678   }
679   return sum;
680 }
681 
682 void BitMap::print_on_error(outputStream* st, const char* prefix) const {
683   st-&gt;print_cr(&quot;%s[&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
684       prefix, p2i(map()), p2i((char*)map() + (size() &gt;&gt; LogBitsPerByte)));
685 }
686 
687 void BitMap::write_to(bm_word_t* buffer, size_t buffer_size_in_bytes) const {
688   assert(buffer_size_in_bytes == size_in_bytes(), &quot;must be&quot;);
689   memcpy(buffer, _map, size_in_bytes());
690 }
691 
692 #ifndef PRODUCT
693 
694 void BitMap::print_on(outputStream* st) const {
695   tty-&gt;print(&quot;Bitmap(&quot; SIZE_FORMAT &quot;):&quot;, size());
696   for (idx_t index = 0; index &lt; size(); index++) {
697     tty-&gt;print(&quot;%c&quot;, at(index) ? &#39;1&#39; : &#39;0&#39;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;utilities/bitMap.inline.hpp&quot;
 30 #include &quot;utilities/copy.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
<span class="line-added"> 32 #include &quot;utilities/population_count.hpp&quot;</span>
 33 
 34 STATIC_ASSERT(sizeof(BitMap::bm_word_t) == BytesPerWord); // &quot;Implementation assumption.&quot;
 35 
 36 typedef BitMap::bm_word_t bm_word_t;
 37 typedef BitMap::idx_t     idx_t;
 38 
 39 class ResourceBitMapAllocator : StackObj {
 40  public:
 41   bm_word_t* allocate(idx_t size_in_words) const {
 42     return NEW_RESOURCE_ARRAY(bm_word_t, size_in_words);
 43   }
 44   void free(bm_word_t* map, idx_t size_in_words) const {
 45     // Don&#39;t free resource allocated arrays.
 46   }
 47 };
 48 
 49 class CHeapBitMapAllocator : StackObj {
 50   MEMFLAGS _flags;
 51 
 52  public:
</pre>
<hr />
<pre>
 95   if (old_map != NULL) {
 96     allocator.free(old_map, old_size_in_words);
 97   }
 98 
 99   return map;
100 }
101 
102 template &lt;class Allocator&gt;
103 bm_word_t* BitMap::allocate(const Allocator&amp; allocator, idx_t size_in_bits, bool clear) {
104   // Reuse reallocate to ensure that the new memory is cleared.
105   return reallocate(allocator, NULL, 0, size_in_bits, clear);
106 }
107 
108 template &lt;class Allocator&gt;
109 void BitMap::free(const Allocator&amp; allocator, bm_word_t* map, idx_t  size_in_bits) {
110   bm_word_t* ret = reallocate(allocator, map, size_in_bits, 0);
111   assert(ret == NULL, &quot;Reallocate shouldn&#39;t have allocated&quot;);
112 }
113 
114 template &lt;class Allocator&gt;
<span class="line-modified">115 void BitMap::resize(const Allocator&amp; allocator, idx_t new_size_in_bits, bool clear) {</span>
<span class="line-modified">116   bm_word_t* new_map = reallocate(allocator, map(), size(), new_size_in_bits, clear);</span>
117 
118   update(new_map, new_size_in_bits);
119 }
120 
121 template &lt;class Allocator&gt;
<span class="line-modified">122 void BitMap::initialize(const Allocator&amp; allocator, idx_t size_in_bits, bool clear) {</span>
123   assert(map() == NULL, &quot;precondition&quot;);
124   assert(size() == 0,   &quot;precondition&quot;);
125 
<span class="line-modified">126   resize(allocator, size_in_bits, clear);</span>
127 }
128 
129 template &lt;class Allocator&gt;
<span class="line-modified">130 void BitMap::reinitialize(const Allocator&amp; allocator, idx_t new_size_in_bits, bool clear) {</span>
<span class="line-modified">131   // Remove previous bits - no need to clear</span>
<span class="line-modified">132   resize(allocator, 0, false /* clear */);</span>
133 
<span class="line-modified">134   initialize(allocator, new_size_in_bits, clear);</span>
135 }
136 
<span class="line-modified">137 ResourceBitMap::ResourceBitMap(idx_t size_in_bits, bool clear)</span>
<span class="line-modified">138     : BitMap(allocate(ResourceBitMapAllocator(), size_in_bits, clear), size_in_bits) {</span>
139 }
140 
141 void ResourceBitMap::resize(idx_t new_size_in_bits) {
<span class="line-modified">142   BitMap::resize(ResourceBitMapAllocator(), new_size_in_bits, true /* clear */);</span>
143 }
144 
145 void ResourceBitMap::initialize(idx_t size_in_bits) {
<span class="line-modified">146   BitMap::initialize(ResourceBitMapAllocator(), size_in_bits, true /* clear */);</span>
147 }
148 
149 void ResourceBitMap::reinitialize(idx_t size_in_bits) {
<span class="line-modified">150   BitMap::reinitialize(ResourceBitMapAllocator(), size_in_bits, true /* clear */);</span>
151 }
152 
153 ArenaBitMap::ArenaBitMap(Arena* arena, idx_t size_in_bits)
154     : BitMap(allocate(ArenaBitMapAllocator(arena), size_in_bits), size_in_bits) {
155 }
156 
157 CHeapBitMap::CHeapBitMap(idx_t size_in_bits, MEMFLAGS flags, bool clear)
158     : BitMap(allocate(CHeapBitMapAllocator(flags), size_in_bits, clear), size_in_bits), _flags(flags) {
159 }
160 
161 CHeapBitMap::~CHeapBitMap() {
162   free(CHeapBitMapAllocator(_flags), map(), size());
163 }
164 
<span class="line-modified">165 void CHeapBitMap::resize(idx_t new_size_in_bits, bool clear) {</span>
<span class="line-modified">166   BitMap::resize(CHeapBitMapAllocator(_flags), new_size_in_bits, clear);</span>
167 }
168 
<span class="line-modified">169 void CHeapBitMap::initialize(idx_t size_in_bits, bool clear) {</span>
<span class="line-modified">170   BitMap::initialize(CHeapBitMapAllocator(_flags), size_in_bits, clear);</span>
171 }
172 
<span class="line-modified">173 void CHeapBitMap::reinitialize(idx_t size_in_bits, bool clear) {</span>
<span class="line-modified">174   BitMap::reinitialize(CHeapBitMapAllocator(_flags), size_in_bits, clear);</span>
175 }
176 
177 #ifdef ASSERT
<span class="line-modified">178 void BitMap::verify_size(idx_t size_in_bits) {</span>
<span class="line-modified">179   assert(size_in_bits &lt;= max_size_in_bits(),</span>
<span class="line-added">180          &quot;out of bounds: &quot; SIZE_FORMAT, size_in_bits);</span>
181 }
182 
<span class="line-modified">183 void BitMap::verify_index(idx_t bit) const {</span>
<span class="line-modified">184   assert(bit &lt; _size,</span>
<span class="line-modified">185          &quot;BitMap index out of bounds: &quot; SIZE_FORMAT &quot; &gt;= &quot; SIZE_FORMAT,</span>
<span class="line-modified">186          bit, _size);</span>
<span class="line-added">187 }</span>
<span class="line-added">188 </span>
<span class="line-added">189 void BitMap::verify_limit(idx_t bit) const {</span>
<span class="line-added">190   assert(bit &lt;= _size,</span>
<span class="line-added">191          &quot;BitMap limit out of bounds: &quot; SIZE_FORMAT &quot; &gt; &quot; SIZE_FORMAT,</span>
<span class="line-added">192          bit, _size);</span>
<span class="line-added">193 }</span>
<span class="line-added">194 </span>
<span class="line-added">195 void BitMap::verify_range(idx_t beg, idx_t end) const {</span>
<span class="line-added">196   assert(beg &lt;= end,</span>
<span class="line-added">197          &quot;BitMap range error: &quot; SIZE_FORMAT &quot; &gt; &quot; SIZE_FORMAT, beg, end);</span>
<span class="line-added">198   verify_limit(end);</span>
199 }
200 #endif // #ifdef ASSERT
201 
202 void BitMap::pretouch() {
203   os::pretouch_memory(word_addr(0), word_addr(size()));
204 }
205 
206 void BitMap::set_range_within_word(idx_t beg, idx_t end) {
207   // With a valid range (beg &lt;= end), this test ensures that end != 0, as
208   // required by inverted_bit_mask_for_range.  Also avoids an unnecessary write.
209   if (beg != end) {
210     bm_word_t mask = inverted_bit_mask_for_range(beg, end);
211     *word_addr(beg) |= ~mask;
212   }
213 }
214 
215 void BitMap::clear_range_within_word(idx_t beg, idx_t end) {
216   // With a valid range (beg &lt;= end), this test ensures that end != 0, as
217   // required by inverted_bit_mask_for_range.  Also avoids an unnecessary write.
218   if (beg != end) {
219     bm_word_t mask = inverted_bit_mask_for_range(beg, end);
220     *word_addr(beg) &amp;= mask;
221   }
222 }
223 
224 void BitMap::par_put_range_within_word(idx_t beg, idx_t end, bool value) {
225   assert(value == 0 || value == 1, &quot;0 for clear, 1 for set&quot;);
226   // With a valid range (beg &lt;= end), this test ensures that end != 0, as
227   // required by inverted_bit_mask_for_range.  Also avoids an unnecessary write.
228   if (beg != end) {
229     bm_word_t* pw = word_addr(beg);
230     bm_word_t  w  = *pw;
231     bm_word_t  mr = inverted_bit_mask_for_range(beg, end);
232     bm_word_t  nw = value ? (w | ~mr) : (w &amp; mr);
233     while (true) {
<span class="line-modified">234       bm_word_t res = Atomic::cmpxchg(pw, w, nw);</span>
235       if (res == w) break;
236       w  = res;
237       nw = value ? (w | ~mr) : (w &amp; mr);
238     }
239   }
240 }
241 
242 void BitMap::set_range(idx_t beg, idx_t end) {
243   verify_range(beg, end);
244 
<span class="line-modified">245   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="line-modified">246   idx_t end_full_word = to_words_align_down(end);</span>
247 
248   if (beg_full_word &lt; end_full_word) {
249     // The range includes at least one full word.
250     set_range_within_word(beg, bit_index(beg_full_word));
251     set_range_of_words(beg_full_word, end_full_word);
252     set_range_within_word(bit_index(end_full_word), end);
253   } else {
254     // The range spans at most 2 partial words.
255     idx_t boundary = MIN2(bit_index(beg_full_word), end);
256     set_range_within_word(beg, boundary);
257     set_range_within_word(boundary, end);
258   }
259 }
260 
261 void BitMap::clear_range(idx_t beg, idx_t end) {
262   verify_range(beg, end);
263 
<span class="line-modified">264   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="line-modified">265   idx_t end_full_word = to_words_align_down(end);</span>
266 
267   if (beg_full_word &lt; end_full_word) {
268     // The range includes at least one full word.
269     clear_range_within_word(beg, bit_index(beg_full_word));
270     clear_range_of_words(beg_full_word, end_full_word);
271     clear_range_within_word(bit_index(end_full_word), end);
272   } else {
273     // The range spans at most 2 partial words.
274     idx_t boundary = MIN2(bit_index(beg_full_word), end);
275     clear_range_within_word(beg, boundary);
276     clear_range_within_word(boundary, end);
277   }
278 }
279 
280 bool BitMap::is_small_range_of_words(idx_t beg_full_word, idx_t end_full_word) {
281   // There is little point to call large version on small ranges.
<span class="line-modified">282   // Need to check carefully, keeping potential idx_t over/underflow in mind,</span>
<span class="line-added">283   // because beg_full_word &gt; end_full_word can occur when beg and end are in</span>
<span class="line-added">284   // the same word.</span>
285   // The threshold should be at least one word.
286   STATIC_ASSERT(small_range_words &gt;= 1);
<span class="line-modified">287   return beg_full_word + small_range_words &gt;= end_full_word;</span>
288 }
289 
290 void BitMap::set_large_range(idx_t beg, idx_t end) {
291   verify_range(beg, end);
292 
<span class="line-modified">293   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="line-modified">294   idx_t end_full_word = to_words_align_down(end);</span>
295 
296   if (is_small_range_of_words(beg_full_word, end_full_word)) {
297     set_range(beg, end);
298     return;
299   }
300 
301   // The range includes at least one full word.
302   set_range_within_word(beg, bit_index(beg_full_word));
303   set_large_range_of_words(beg_full_word, end_full_word);
304   set_range_within_word(bit_index(end_full_word), end);
305 }
306 
307 void BitMap::clear_large_range(idx_t beg, idx_t end) {
308   verify_range(beg, end);
309 
<span class="line-modified">310   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="line-modified">311   idx_t end_full_word = to_words_align_down(end);</span>
312 
313   if (is_small_range_of_words(beg_full_word, end_full_word)) {
314     clear_range(beg, end);
315     return;
316   }
317 
318   // The range includes at least one full word.
319   clear_range_within_word(beg, bit_index(beg_full_word));
320   clear_large_range_of_words(beg_full_word, end_full_word);
321   clear_range_within_word(bit_index(end_full_word), end);
322 }
323 
324 void BitMap::at_put(idx_t offset, bool value) {
325   if (value) {
326     set_bit(offset);
327   } else {
328     clear_bit(offset);
329   }
330 }
331 
</pre>
<hr />
<pre>
342 // make such a strong assertion here, based on
343 // assuming such constrained use (which though true
344 // today, could change in the future to service some
345 // funky parallel algorithm), we encourage callers
346 // to do such verification, as and when appropriate.
347 bool BitMap::par_at_put(idx_t bit, bool value) {
348   return value ? par_set_bit(bit) : par_clear_bit(bit);
349 }
350 
351 void BitMap::at_put_range(idx_t start_offset, idx_t end_offset, bool value) {
352   if (value) {
353     set_range(start_offset, end_offset);
354   } else {
355     clear_range(start_offset, end_offset);
356   }
357 }
358 
359 void BitMap::par_at_put_range(idx_t beg, idx_t end, bool value) {
360   verify_range(beg, end);
361 
<span class="line-modified">362   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="line-modified">363   idx_t end_full_word = to_words_align_down(end);</span>
364 
365   if (beg_full_word &lt; end_full_word) {
366     // The range includes at least one full word.
367     par_put_range_within_word(beg, bit_index(beg_full_word), value);
368     if (value) {
369       set_range_of_words(beg_full_word, end_full_word);
370     } else {
371       clear_range_of_words(beg_full_word, end_full_word);
372     }
373     par_put_range_within_word(bit_index(end_full_word), end, value);
374   } else {
375     // The range spans at most 2 partial words.
376     idx_t boundary = MIN2(bit_index(beg_full_word), end);
377     par_put_range_within_word(beg, boundary, value);
378     par_put_range_within_word(boundary, end, value);
379   }
380 
381 }
382 
383 void BitMap::at_put_large_range(idx_t beg, idx_t end, bool value) {
384   if (value) {
385     set_large_range(beg, end);
386   } else {
387     clear_large_range(beg, end);
388   }
389 }
390 
391 void BitMap::par_at_put_large_range(idx_t beg, idx_t end, bool value) {
392   verify_range(beg, end);
393 
<span class="line-modified">394   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="line-modified">395   idx_t end_full_word = to_words_align_down(end);</span>
396 
397   if (is_small_range_of_words(beg_full_word, end_full_word)) {
398     par_at_put_range(beg, end, value);
399     return;
400   }
401 
402   // The range includes at least one full word.
403   par_put_range_within_word(beg, bit_index(beg_full_word), value);
404   if (value) {
405     set_large_range_of_words(beg_full_word, end_full_word);
406   } else {
407     clear_large_range_of_words(beg_full_word, end_full_word);
408   }
409   par_put_range_within_word(bit_index(end_full_word), end, value);
410 }
411 
412 inline bm_word_t tail_mask(idx_t tail_bits) {
413   assert(tail_bits != 0, &quot;precondition&quot;); // Works, but shouldn&#39;t be called.
414   assert(tail_bits &lt; (idx_t)BitsPerWord, &quot;precondition&quot;);
415   return (bm_word_t(1) &lt;&lt; tail_bits) - 1;
</pre>
<hr />
<pre>
419 inline bm_word_t tail_of_map(bm_word_t value, idx_t tail_bits) {
420   return value &amp; tail_mask(tail_bits);
421 }
422 
423 // Compute the new last word of a map with a non-aligned length.
424 // new_value has the new trailing bits of the map in the low tail_bits.
425 // old_value is the last word of the map, including bits beyond the end.
426 // Returns old_value with the low tail_bits replaced by the corresponding
427 // bits in new_value.
428 inline bm_word_t merge_tail_of_map(bm_word_t new_value,
429                                    bm_word_t old_value,
430                                    idx_t tail_bits) {
431   bm_word_t mask = tail_mask(tail_bits);
432   return (new_value &amp; mask) | (old_value &amp; ~mask);
433 }
434 
435 bool BitMap::contains(const BitMap&amp; other) const {
436   assert(size() == other.size(), &quot;must have same size&quot;);
437   const bm_word_t* dest_map = map();
438   const bm_word_t* other_map = other.map();
<span class="line-modified">439   idx_t limit = to_words_align_down(size());</span>
440   for (idx_t index = 0; index &lt; limit; ++index) {
441     // false if other bitmap has bits set which are clear in this bitmap.
442     if ((~dest_map[index] &amp; other_map[index]) != 0) return false;
443   }
444   idx_t rest = bit_in_word(size());
445   // true unless there is a partial-word tail in which the other
446   // bitmap has bits set which are clear in this bitmap.
447   return (rest == 0) || tail_of_map(~dest_map[limit] &amp; other_map[limit], rest) == 0;
448 }
449 
450 bool BitMap::intersects(const BitMap&amp; other) const {
451   assert(size() == other.size(), &quot;must have same size&quot;);
452   const bm_word_t* dest_map = map();
453   const bm_word_t* other_map = other.map();
<span class="line-modified">454   idx_t limit = to_words_align_down(size());</span>
455   for (idx_t index = 0; index &lt; limit; ++index) {
456     if ((dest_map[index] &amp; other_map[index]) != 0) return true;
457   }
458   idx_t rest = bit_in_word(size());
459   // false unless there is a partial-word tail with non-empty intersection.
460   return (rest &gt; 0) &amp;&amp; tail_of_map(dest_map[limit] &amp; other_map[limit], rest) != 0;
461 }
462 
463 void BitMap::set_union(const BitMap&amp; other) {
464   assert(size() == other.size(), &quot;must have same size&quot;);
465   bm_word_t* dest_map = map();
466   const bm_word_t* other_map = other.map();
<span class="line-modified">467   idx_t limit = to_words_align_down(size());</span>
468   for (idx_t index = 0; index &lt; limit; ++index) {
469     dest_map[index] |= other_map[index];
470   }
471   idx_t rest = bit_in_word(size());
472   if (rest &gt; 0) {
473     bm_word_t orig = dest_map[limit];
474     dest_map[limit] = merge_tail_of_map(orig | other_map[limit], orig, rest);
475   }
476 }
477 
478 void BitMap::set_difference(const BitMap&amp; other) {
479   assert(size() == other.size(), &quot;must have same size&quot;);
480   bm_word_t* dest_map = map();
481   const bm_word_t* other_map = other.map();
<span class="line-modified">482   idx_t limit = to_words_align_down(size());</span>
483   for (idx_t index = 0; index &lt; limit; ++index) {
484     dest_map[index] &amp;= ~other_map[index];
485   }
486   idx_t rest = bit_in_word(size());
487   if (rest &gt; 0) {
488     bm_word_t orig = dest_map[limit];
489     dest_map[limit] = merge_tail_of_map(orig &amp; ~other_map[limit], orig, rest);
490   }
491 }
492 
493 void BitMap::set_intersection(const BitMap&amp; other) {
494   assert(size() == other.size(), &quot;must have same size&quot;);
495   bm_word_t* dest_map = map();
496   const bm_word_t* other_map = other.map();
<span class="line-modified">497   idx_t limit = to_words_align_down(size());</span>
498   for (idx_t index = 0; index &lt; limit; ++index) {
499     dest_map[index] &amp;= other_map[index];
500   }
501   idx_t rest = bit_in_word(size());
502   if (rest &gt; 0) {
503     bm_word_t orig = dest_map[limit];
504     dest_map[limit] = merge_tail_of_map(orig &amp; other_map[limit], orig, rest);
505   }
506 }
507 
508 bool BitMap::set_union_with_result(const BitMap&amp; other) {
509   assert(size() == other.size(), &quot;must have same size&quot;);
510   bool changed = false;
511   bm_word_t* dest_map = map();
512   const bm_word_t* other_map = other.map();
<span class="line-modified">513   idx_t limit = to_words_align_down(size());</span>
514   for (idx_t index = 0; index &lt; limit; ++index) {
515     bm_word_t orig = dest_map[index];
516     bm_word_t temp = orig | other_map[index];
517     changed = changed || (temp != orig);
518     dest_map[index] = temp;
519   }
520   idx_t rest = bit_in_word(size());
521   if (rest &gt; 0) {
522     bm_word_t orig = dest_map[limit];
523     bm_word_t temp = merge_tail_of_map(orig | other_map[limit], orig, rest);
524     changed = changed || (temp != orig);
525     dest_map[limit] = temp;
526   }
527   return changed;
528 }
529 
530 bool BitMap::set_difference_with_result(const BitMap&amp; other) {
531   assert(size() == other.size(), &quot;must have same size&quot;);
532   bool changed = false;
533   bm_word_t* dest_map = map();
534   const bm_word_t* other_map = other.map();
<span class="line-modified">535   idx_t limit = to_words_align_down(size());</span>
536   for (idx_t index = 0; index &lt; limit; ++index) {
537     bm_word_t orig = dest_map[index];
538     bm_word_t temp = orig &amp; ~other_map[index];
539     changed = changed || (temp != orig);
540     dest_map[index] = temp;
541   }
542   idx_t rest = bit_in_word(size());
543   if (rest &gt; 0) {
544     bm_word_t orig = dest_map[limit];
545     bm_word_t temp = merge_tail_of_map(orig &amp; ~other_map[limit], orig, rest);
546     changed = changed || (temp != orig);
547     dest_map[limit] = temp;
548   }
549   return changed;
550 }
551 
552 bool BitMap::set_intersection_with_result(const BitMap&amp; other) {
553   assert(size() == other.size(), &quot;must have same size&quot;);
554   bool changed = false;
555   bm_word_t* dest_map = map();
556   const bm_word_t* other_map = other.map();
<span class="line-modified">557   idx_t limit = to_words_align_down(size());</span>
558   for (idx_t index = 0; index &lt; limit; ++index) {
559     bm_word_t orig = dest_map[index];
560     bm_word_t temp = orig &amp; other_map[index];
561     changed = changed || (temp != orig);
562     dest_map[index] = temp;
563   }
564   idx_t rest = bit_in_word(size());
565   if (rest &gt; 0) {
566     bm_word_t orig = dest_map[limit];
567     bm_word_t temp = merge_tail_of_map(orig &amp; other_map[limit], orig, rest);
568     changed = changed || (temp != orig);
569     dest_map[limit] = temp;
570   }
571   return changed;
572 }
573 
574 void BitMap::set_from(const BitMap&amp; other) {
575   assert(size() == other.size(), &quot;must have same size&quot;);
576   bm_word_t* dest_map = map();
577   const bm_word_t* other_map = other.map();
<span class="line-modified">578   idx_t copy_words = to_words_align_down(size());</span>
579   Copy::disjoint_words((HeapWord*)other_map, (HeapWord*)dest_map, copy_words);
580   idx_t rest = bit_in_word(size());
581   if (rest &gt; 0) {
582     dest_map[copy_words] = merge_tail_of_map(other_map[copy_words],
583                                              dest_map[copy_words],
584                                              rest);
585   }
586 }
587 
588 bool BitMap::is_same(const BitMap&amp; other) const {
589   assert(size() == other.size(), &quot;must have same size&quot;);
590   const bm_word_t* dest_map = map();
591   const bm_word_t* other_map = other.map();
<span class="line-modified">592   idx_t limit = to_words_align_down(size());</span>
593   for (idx_t index = 0; index &lt; limit; ++index) {
594     if (dest_map[index] != other_map[index]) return false;
595   }
596   idx_t rest = bit_in_word(size());
597   return (rest == 0) || (tail_of_map(dest_map[limit] ^ other_map[limit], rest) == 0);
598 }
599 
600 bool BitMap::is_full() const {
601   const bm_word_t* words = map();
<span class="line-modified">602   idx_t limit = to_words_align_down(size());</span>
603   for (idx_t index = 0; index &lt; limit; ++index) {
604     if (~words[index] != 0) return false;
605   }
606   idx_t rest = bit_in_word(size());
607   return (rest == 0) || (tail_of_map(~words[limit], rest) == 0);
608 }
609 
610 bool BitMap::is_empty() const {
611   const bm_word_t* words = map();
<span class="line-modified">612   idx_t limit = to_words_align_down(size());</span>
613   for (idx_t index = 0; index &lt; limit; ++index) {
614     if (words[index] != 0) return false;
615   }
616   idx_t rest = bit_in_word(size());
617   return (rest == 0) || (tail_of_map(words[limit], rest) == 0);
618 }
619 
620 void BitMap::clear_large() {
621   clear_large_range_of_words(0, size_in_words());
622 }
623 
624 // Note that if the closure itself modifies the bitmap
625 // then modifications in and to the left of the _bit_ being
626 // currently sampled will not be seen. Note also that the
627 // interval [leftOffset, rightOffset) is right open.
628 bool BitMap::iterate(BitMapClosure* blk, idx_t leftOffset, idx_t rightOffset) {
629   verify_range(leftOffset, rightOffset);
630 
<span class="line-modified">631   idx_t startIndex = to_words_align_down(leftOffset);</span>
<span class="line-modified">632   idx_t endIndex   = to_words_align_up(rightOffset);</span>
633   for (idx_t index = startIndex, offset = leftOffset;
634        offset &lt; rightOffset &amp;&amp; index &lt; endIndex;
635        offset = (++index) &lt;&lt; LogBitsPerWord) {
636     idx_t rest = map(index) &gt;&gt; (offset &amp; (BitsPerWord - 1));
637     for (; offset &lt; rightOffset &amp;&amp; rest != 0; offset++) {
638       if (rest &amp; 1) {
639         if (!blk-&gt;do_bit(offset)) return false;
640         //  resample at each closure application
641         // (see, for instance, CMS bug 4525989)
642         rest = map(index) &gt;&gt; (offset &amp; (BitsPerWord -1));
643       }
644       rest = rest &gt;&gt; 1;
645     }
646   }
647   return true;
648 }
649 


































650 BitMap::idx_t BitMap::count_one_bits() const {

651   idx_t sum = 0;

652   for (idx_t i = 0; i &lt; size_in_words(); i++) {
653     bm_word_t w = map()[i];
<span class="line-modified">654     sum += population_count(w);</span>



655   }
656   return sum;
657 }
658 
659 void BitMap::print_on_error(outputStream* st, const char* prefix) const {
660   st-&gt;print_cr(&quot;%s[&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
661       prefix, p2i(map()), p2i((char*)map() + (size() &gt;&gt; LogBitsPerByte)));
662 }
663 
664 void BitMap::write_to(bm_word_t* buffer, size_t buffer_size_in_bytes) const {
665   assert(buffer_size_in_bytes == size_in_bytes(), &quot;must be&quot;);
666   memcpy(buffer, _map, size_in_bytes());
667 }
668 
669 #ifndef PRODUCT
670 
671 void BitMap::print_on(outputStream* st) const {
672   tty-&gt;print(&quot;Bitmap(&quot; SIZE_FORMAT &quot;):&quot;, size());
673   for (idx_t index = 0; index &lt; size(); index++) {
674     tty-&gt;print(&quot;%c&quot;, at(index) ? &#39;1&#39; : &#39;0&#39;);
</pre>
</td>
</tr>
</table>
<center><a href="align.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bitMap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
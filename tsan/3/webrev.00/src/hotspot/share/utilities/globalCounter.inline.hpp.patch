diff a/src/hotspot/share/utilities/globalCounter.inline.hpp b/src/hotspot/share/utilities/globalCounter.inline.hpp
--- a/src/hotspot/share/utilities/globalCounter.inline.hpp
+++ b/src/hotspot/share/utilities/globalCounter.inline.hpp
@@ -24,11 +24,10 @@
 
 #ifndef SHARE_UTILITIES_GLOBALCOUNTER_INLINE_HPP
 #define SHARE_UTILITIES_GLOBALCOUNTER_INLINE_HPP
 
 #include "runtime/atomic.hpp"
-#include "runtime/orderAccess.hpp"
 #include "runtime/thread.inline.hpp"
 #include "utilities/globalCounter.hpp"
 
 inline GlobalCounter::CSContext
 GlobalCounter::critical_section_begin(Thread *thread) {
@@ -38,21 +37,21 @@
   // Otherwise, set the counter to the current version + active bit.
   uintx new_cnt = old_cnt;
   if ((new_cnt & COUNTER_ACTIVE) == 0) {
     new_cnt = Atomic::load(&_global_counter._counter) | COUNTER_ACTIVE;
   }
-  OrderAccess::release_store_fence(thread->get_rcu_counter(), new_cnt);
+  Atomic::release_store_fence(thread->get_rcu_counter(), new_cnt);
   return static_cast<CSContext>(old_cnt);
 }
 
 inline void
 GlobalCounter::critical_section_end(Thread *thread, CSContext context) {
   assert(thread == Thread::current(), "must be current thread");
   assert((*thread->get_rcu_counter() & COUNTER_ACTIVE) == COUNTER_ACTIVE, "must be in critical section");
   // Restore the counter value from before the associated begin.
-  OrderAccess::release_store(thread->get_rcu_counter(),
-                             static_cast<uintx>(context));
+  Atomic::release_store(thread->get_rcu_counter(),
+                        static_cast<uintx>(context));
 }
 
 class GlobalCounter::CriticalSection {
  private:
   Thread* _thread;

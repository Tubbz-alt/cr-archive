<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/ostream.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ostream.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="population_count.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/ostream.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 #ifndef SHARE_UTILITIES_OSTREAM_HPP
 26 #define SHARE_UTILITIES_OSTREAM_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/timer.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 
 32 DEBUG_ONLY(class ResourceMark;)
 33 
 34 // Output streams for printing
 35 //
 36 // Printing guidelines:
 37 // Where possible, please use tty-&gt;print() and tty-&gt;print_cr().
 38 // For product mode VM warnings use warning() which internally uses tty.
 39 // In places where tty is not initialized yet or too much overhead,
 40 // we may use jio_printf:
 41 //     jio_fprintf(defaultStream::output_stream(), &quot;Message&quot;);
 42 // This allows for redirection via -XX:+DisplayVMOutputToStdout and
 43 // -XX:+DisplayVMOutputToStderr
 44 class outputStream : public ResourceObj {



 45  protected:
 46    int _indentation; // current indentation
 47    int _width;       // width of the page
 48    int _position;    // position on the current line
 49    int _newlines;    // number of &#39;\n&#39; output so far
 50    julong _precount; // number of chars output, less _position
 51    TimeStamp _stamp; // for time stamps
 52    char* _scratch;   // internal scratch buffer for printf
 53    size_t _scratch_len; // size of internal scratch buffer
 54 
 55    void update_position(const char* s, size_t len);
 56    static const char* do_vsnprintf(char* buffer, size_t buflen,
 57                                    const char* format, va_list ap,
 58                                    bool add_cr,
 59                                    size_t&amp; result_len)  ATTRIBUTE_PRINTF(3, 0);
 60 
 61    // calls do_vsnprintf and writes output to stream; uses an on-stack buffer.
 62    void do_vsnprintf_and_write_with_automatic_buffer(const char* format, va_list ap, bool add_cr) ATTRIBUTE_PRINTF(2, 0);
 63    // calls do_vsnprintf and writes output to stream; uses the user-provided buffer;
 64    void do_vsnprintf_and_write_with_scratch_buffer(const char* format, va_list ap, bool add_cr) ATTRIBUTE_PRINTF(2, 0);
</pre>
<hr />
<pre>
169   ttyLocker()  { _holder = hold_tty(); }
170   ~ttyLocker() { release_tty(_holder); }
171 };
172 
173 // Release the tty lock if it&#39;s held and reacquire it if it was
174 // locked.  Used to avoid lock ordering problems.
175 class ttyUnlocker: StackObj {
176  private:
177   bool _was_locked;
178  public:
179   ttyUnlocker()  {
180     _was_locked = ttyLocker::release_tty_if_locked();
181   }
182   ~ttyUnlocker() {
183     if (_was_locked) {
184       ttyLocker::hold_tty();
185     }
186   }
187 };
188 
<span class="line-modified">189 // for writing to strings; buffer will expand automatically</span>

190 class stringStream : public outputStream {
191  protected:
192   char*  buffer;
193   size_t buffer_pos;
194   size_t buffer_length;
195   bool   buffer_fixed;
<span class="line-modified">196   DEBUG_ONLY(ResourceMark* rm;)</span>



197  public:


198   stringStream(size_t initial_bufsize = 256);


199   stringStream(char* fixed_buffer, size_t fixed_buffer_size);
200   ~stringStream();
201   virtual void write(const char* c, size_t len);
<span class="line-modified">202   size_t      size() { return buffer_pos; }</span>
<span class="line-modified">203   const char* base() { return buffer; }</span>
<span class="line-modified">204   void  reset() { buffer_pos = 0; _precount = 0; _position = 0; }</span>
<span class="line-modified">205   char* as_string();</span>


206 };
207 
208 class fileStream : public outputStream {
209  protected:
210   FILE* _file;
211   bool  _need_close;
212  public:
213   fileStream() { _file = NULL; _need_close = false; }
214   fileStream(const char* file_name);
215   fileStream(const char* file_name, const char* opentype);
216   fileStream(FILE* file, bool need_close = false) { _file = file; _need_close = need_close; }
217   ~fileStream();
218   bool is_open() const { return _file != NULL; }
219   virtual void write(const char* c, size_t len);
220   size_t read(void *data, size_t size, size_t count) { return ::fread(data, size, count, _file); }
221   char* readln(char *data, int count);
222   int eof() { return feof(_file); }
223   long fileSize();
224   void rewind() { ::rewind(_file); }
225   void flush();
</pre>
<hr />
<pre>
240   void set_fd(int fd) { _fd = fd; }
241   int fd() const { return _fd; }
242   virtual void write(const char* c, size_t len);
243   void flush() {};
244 };
245 
246 void ostream_init();
247 void ostream_init_log();
248 void ostream_exit();
249 void ostream_abort();
250 
251 // In the non-fixed buffer case an underlying buffer will be created and
252 // managed in C heap. Not MT-safe.
253 class bufferedStream : public outputStream {
254  protected:
255   char*  buffer;
256   size_t buffer_pos;
257   size_t buffer_max;
258   size_t buffer_length;
259   bool   buffer_fixed;

260  public:
261   bufferedStream(size_t initial_bufsize = 256, size_t bufmax = 1024*1024*10);
262   bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax = 1024*1024*10);
263   ~bufferedStream();
264   virtual void write(const char* c, size_t len);
265   size_t      size() { return buffer_pos; }
266   const char* base() { return buffer; }
267   void  reset() { buffer_pos = 0; _precount = 0; _position = 0; }
268   char* as_string();
269 };
270 
271 #define O_BUFLEN 2000   // max size of output of individual print() methods
272 
273 #ifndef PRODUCT
274 
275 class networkStream : public bufferedStream {
276 
277   private:
278     int _socket;
279 
</pre>
</td>
<td>
<hr />
<pre>
 25 #ifndef SHARE_UTILITIES_OSTREAM_HPP
 26 #define SHARE_UTILITIES_OSTREAM_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/timer.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 
 32 DEBUG_ONLY(class ResourceMark;)
 33 
 34 // Output streams for printing
 35 //
 36 // Printing guidelines:
 37 // Where possible, please use tty-&gt;print() and tty-&gt;print_cr().
 38 // For product mode VM warnings use warning() which internally uses tty.
 39 // In places where tty is not initialized yet or too much overhead,
 40 // we may use jio_printf:
 41 //     jio_fprintf(defaultStream::output_stream(), &quot;Message&quot;);
 42 // This allows for redirection via -XX:+DisplayVMOutputToStdout and
 43 // -XX:+DisplayVMOutputToStderr
 44 class outputStream : public ResourceObj {
<span class="line-added"> 45  private:</span>
<span class="line-added"> 46    NONCOPYABLE(outputStream);</span>
<span class="line-added"> 47 </span>
 48  protected:
 49    int _indentation; // current indentation
 50    int _width;       // width of the page
 51    int _position;    // position on the current line
 52    int _newlines;    // number of &#39;\n&#39; output so far
 53    julong _precount; // number of chars output, less _position
 54    TimeStamp _stamp; // for time stamps
 55    char* _scratch;   // internal scratch buffer for printf
 56    size_t _scratch_len; // size of internal scratch buffer
 57 
 58    void update_position(const char* s, size_t len);
 59    static const char* do_vsnprintf(char* buffer, size_t buflen,
 60                                    const char* format, va_list ap,
 61                                    bool add_cr,
 62                                    size_t&amp; result_len)  ATTRIBUTE_PRINTF(3, 0);
 63 
 64    // calls do_vsnprintf and writes output to stream; uses an on-stack buffer.
 65    void do_vsnprintf_and_write_with_automatic_buffer(const char* format, va_list ap, bool add_cr) ATTRIBUTE_PRINTF(2, 0);
 66    // calls do_vsnprintf and writes output to stream; uses the user-provided buffer;
 67    void do_vsnprintf_and_write_with_scratch_buffer(const char* format, va_list ap, bool add_cr) ATTRIBUTE_PRINTF(2, 0);
</pre>
<hr />
<pre>
172   ttyLocker()  { _holder = hold_tty(); }
173   ~ttyLocker() { release_tty(_holder); }
174 };
175 
176 // Release the tty lock if it&#39;s held and reacquire it if it was
177 // locked.  Used to avoid lock ordering problems.
178 class ttyUnlocker: StackObj {
179  private:
180   bool _was_locked;
181  public:
182   ttyUnlocker()  {
183     _was_locked = ttyLocker::release_tty_if_locked();
184   }
185   ~ttyUnlocker() {
186     if (_was_locked) {
187       ttyLocker::hold_tty();
188     }
189   }
190 };
191 
<span class="line-modified">192 // for writing to strings; buffer will expand automatically.</span>
<span class="line-added">193 // Buffer will always be zero-terminated.</span>
194 class stringStream : public outputStream {
195  protected:
196   char*  buffer;
197   size_t buffer_pos;
198   size_t buffer_length;
199   bool   buffer_fixed;
<span class="line-modified">200 </span>
<span class="line-added">201   // zero terminate at buffer_pos.</span>
<span class="line-added">202   void zero_terminate();</span>
<span class="line-added">203 </span>
204  public:
<span class="line-added">205   // Create a stringStream using an internal buffer of initially initial_bufsize size;</span>
<span class="line-added">206   // will be enlarged on demand. There is no maximum cap.</span>
207   stringStream(size_t initial_bufsize = 256);
<span class="line-added">208   // Creates a stringStream using a caller-provided buffer. Will truncate silently if</span>
<span class="line-added">209   // it overflows.</span>
210   stringStream(char* fixed_buffer, size_t fixed_buffer_size);
211   ~stringStream();
212   virtual void write(const char* c, size_t len);
<span class="line-modified">213   // Return number of characters written into buffer, excluding terminating zero and</span>
<span class="line-modified">214   // subject to truncation in static buffer mode.</span>
<span class="line-modified">215   size_t      size() const { return buffer_pos; }</span>
<span class="line-modified">216   const char* base() const { return buffer; }</span>
<span class="line-added">217   void  reset();</span>
<span class="line-added">218   char* as_string() const;</span>
219 };
220 
221 class fileStream : public outputStream {
222  protected:
223   FILE* _file;
224   bool  _need_close;
225  public:
226   fileStream() { _file = NULL; _need_close = false; }
227   fileStream(const char* file_name);
228   fileStream(const char* file_name, const char* opentype);
229   fileStream(FILE* file, bool need_close = false) { _file = file; _need_close = need_close; }
230   ~fileStream();
231   bool is_open() const { return _file != NULL; }
232   virtual void write(const char* c, size_t len);
233   size_t read(void *data, size_t size, size_t count) { return ::fread(data, size, count, _file); }
234   char* readln(char *data, int count);
235   int eof() { return feof(_file); }
236   long fileSize();
237   void rewind() { ::rewind(_file); }
238   void flush();
</pre>
<hr />
<pre>
253   void set_fd(int fd) { _fd = fd; }
254   int fd() const { return _fd; }
255   virtual void write(const char* c, size_t len);
256   void flush() {};
257 };
258 
259 void ostream_init();
260 void ostream_init_log();
261 void ostream_exit();
262 void ostream_abort();
263 
264 // In the non-fixed buffer case an underlying buffer will be created and
265 // managed in C heap. Not MT-safe.
266 class bufferedStream : public outputStream {
267  protected:
268   char*  buffer;
269   size_t buffer_pos;
270   size_t buffer_max;
271   size_t buffer_length;
272   bool   buffer_fixed;
<span class="line-added">273   bool   truncated;</span>
274  public:
275   bufferedStream(size_t initial_bufsize = 256, size_t bufmax = 1024*1024*10);
276   bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax = 1024*1024*10);
277   ~bufferedStream();
278   virtual void write(const char* c, size_t len);
279   size_t      size() { return buffer_pos; }
280   const char* base() { return buffer; }
281   void  reset() { buffer_pos = 0; _precount = 0; _position = 0; }
282   char* as_string();
283 };
284 
285 #define O_BUFLEN 2000   // max size of output of individual print() methods
286 
287 #ifndef PRODUCT
288 
289 class networkStream : public bufferedStream {
290 
291   private:
292     int _socket;
293 
</pre>
</td>
</tr>
</table>
<center><a href="ostream.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="population_count.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
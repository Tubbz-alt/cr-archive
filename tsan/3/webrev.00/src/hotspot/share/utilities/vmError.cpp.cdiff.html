<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/vmError.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ticks.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmError.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/vmError.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,12 ---</span>
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;gc/shared/gcConfig.hpp&quot;
  #include &quot;logging/logConfiguration.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/compressedOops.hpp&quot;</span>
  #include &quot;prims/whitebox.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,13 ***</span>
    return buf;
  }
  
  static void print_bug_submit_message(outputStream *out, Thread *thread) {
    if (out == NULL) return;
<span class="line-modified">!   out-&gt;print_raw_cr(&quot;# If you would like to submit a bug report, please visit:&quot;);</span>
<span class="line-modified">!   out-&gt;print_raw   (&quot;#   &quot;);</span>
<span class="line-modified">!   out-&gt;print_raw_cr(Arguments::java_vendor_url_bug());</span>
    // If the crash is in native code, encourage user to submit a bug to the
    // provider of that code.
    if (thread &amp;&amp; thread-&gt;is_Java_thread() &amp;&amp;
        !thread-&gt;is_hidden_from_external_view()) {
      JavaThread* jt = (JavaThread*)thread;
<span class="line-new-header">--- 126,18 ---</span>
    return buf;
  }
  
  static void print_bug_submit_message(outputStream *out, Thread *thread) {
    if (out == NULL) return;
<span class="line-modified">!   const char *url = Arguments::java_vendor_url_bug();</span>
<span class="line-modified">!   if (url == NULL || *url == &#39;\0&#39;)</span>
<span class="line-modified">!     url = JDK_Version::runtime_vendor_vm_bug_url();</span>
<span class="line-added">+   if (url != NULL &amp;&amp; *url != &#39;\0&#39;) {</span>
<span class="line-added">+     out-&gt;print_raw_cr(&quot;# If you would like to submit a bug report, please visit:&quot;);</span>
<span class="line-added">+     out-&gt;print_raw   (&quot;#   &quot;);</span>
<span class="line-added">+     out-&gt;print_raw_cr(url);</span>
<span class="line-added">+   }</span>
    // If the crash is in native code, encourage user to submit a bug to the
    // provider of that code.
    if (thread &amp;&amp; thread-&gt;is_Java_thread() &amp;&amp;
        !thread-&gt;is_hidden_from_external_view()) {
      JavaThread* jt = (JavaThread*)thread;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 289,18 ***</span>
    st-&gt;print_cr(&quot;#   Decrease Java heap size (-Xmx/-Xms)&quot;);
    st-&gt;print_cr(&quot;#   Decrease number of Java threads&quot;);
    st-&gt;print_cr(&quot;#   Decrease Java thread stack sizes (-Xss)&quot;);
    st-&gt;print_cr(&quot;#   Set larger code cache with -XX:ReservedCodeCacheSize=&quot;);
    if (UseCompressedOops) {
<span class="line-modified">!     switch (Universe::narrow_oop_mode()) {</span>
<span class="line-modified">!       case Universe::UnscaledNarrowOop:</span>
          st-&gt;print_cr(&quot;#   JVM is running with Unscaled Compressed Oops mode in which the Java heap is&quot;);
          st-&gt;print_cr(&quot;#     placed in the first 4GB address space. The Java Heap base address is the&quot;);
          st-&gt;print_cr(&quot;#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress&quot;);
          st-&gt;print_cr(&quot;#     to set the Java Heap base and to place the Java Heap above 4GB virtual address.&quot;);
          break;
<span class="line-modified">!       case Universe::ZeroBasedNarrowOop:</span>
          st-&gt;print_cr(&quot;#   JVM is running with Zero Based Compressed Oops mode in which the Java heap is&quot;);
          st-&gt;print_cr(&quot;#     placed in the first 32GB address space. The Java Heap base address is the&quot;);
          st-&gt;print_cr(&quot;#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress&quot;);
          st-&gt;print_cr(&quot;#     to set the Java Heap base and to place the Java Heap above 32GB virtual address.&quot;);
          break;
<span class="line-new-header">--- 296,18 ---</span>
    st-&gt;print_cr(&quot;#   Decrease Java heap size (-Xmx/-Xms)&quot;);
    st-&gt;print_cr(&quot;#   Decrease number of Java threads&quot;);
    st-&gt;print_cr(&quot;#   Decrease Java thread stack sizes (-Xss)&quot;);
    st-&gt;print_cr(&quot;#   Set larger code cache with -XX:ReservedCodeCacheSize=&quot;);
    if (UseCompressedOops) {
<span class="line-modified">!     switch (CompressedOops::mode()) {</span>
<span class="line-modified">!       case CompressedOops::UnscaledNarrowOop:</span>
          st-&gt;print_cr(&quot;#   JVM is running with Unscaled Compressed Oops mode in which the Java heap is&quot;);
          st-&gt;print_cr(&quot;#     placed in the first 4GB address space. The Java Heap base address is the&quot;);
          st-&gt;print_cr(&quot;#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress&quot;);
          st-&gt;print_cr(&quot;#     to set the Java Heap base and to place the Java Heap above 4GB virtual address.&quot;);
          break;
<span class="line-modified">!       case CompressedOops::ZeroBasedNarrowOop:</span>
          st-&gt;print_cr(&quot;#   JVM is running with Zero Based Compressed Oops mode in which the Java heap is&quot;);
          st-&gt;print_cr(&quot;#     placed in the first 32GB address space. The Java Heap base address is the&quot;);
          st-&gt;print_cr(&quot;#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress&quot;);
          st-&gt;print_cr(&quot;#     to set the Java Heap base and to place the Java Heap above 32GB virtual address.&quot;);
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 317,19 ***</span>
     JDK_Version::current().to_string(buf, buflen);
     const char* runtime_name = JDK_Version::runtime_name() != NULL ?
                                  JDK_Version::runtime_name() : &quot;&quot;;
     const char* runtime_version = JDK_Version::runtime_version() != NULL ?
                                     JDK_Version::runtime_version() : &quot;&quot;;
     const char* jdk_debug_level = VM_Version::printable_jdk_debug_level() != NULL ?
                                     VM_Version::printable_jdk_debug_level() : &quot;&quot;;
  
<span class="line-modified">!    st-&gt;print_cr(&quot;# JRE version: %s (%s) (%sbuild %s)&quot;, runtime_name, buf,</span>
<span class="line-modified">!                  jdk_debug_level, runtime_version);</span>
  
     // This is the long version with some default settings added
<span class="line-modified">!    st-&gt;print_cr(&quot;# Java VM: %s (%s%s, %s%s%s%s%s, %s, %s)&quot;,</span>
                   VM_Version::vm_name(),
                   jdk_debug_level,
                   VM_Version::vm_release(),
                   VM_Version::vm_info_string(),
                   TieredCompilation ? &quot;, tiered&quot; : &quot;&quot;,
  #if INCLUDE_JVMCI
<span class="line-new-header">--- 324,23 ---</span>
     JDK_Version::current().to_string(buf, buflen);
     const char* runtime_name = JDK_Version::runtime_name() != NULL ?
                                  JDK_Version::runtime_name() : &quot;&quot;;
     const char* runtime_version = JDK_Version::runtime_version() != NULL ?
                                     JDK_Version::runtime_version() : &quot;&quot;;
<span class="line-added">+    const char* vendor_version = JDK_Version::runtime_vendor_version() != NULL ?</span>
<span class="line-added">+                                   JDK_Version::runtime_vendor_version() : &quot;&quot;;</span>
     const char* jdk_debug_level = VM_Version::printable_jdk_debug_level() != NULL ?
                                     VM_Version::printable_jdk_debug_level() : &quot;&quot;;
  
<span class="line-modified">!    st-&gt;print_cr(&quot;# JRE version: %s%s%s (%s) (%sbuild %s)&quot;, runtime_name,</span>
<span class="line-modified">!                 (*vendor_version != &#39;\0&#39;) ? &quot; &quot; : &quot;&quot;, vendor_version,</span>
<span class="line-added">+                 buf, jdk_debug_level, runtime_version);</span>
  
     // This is the long version with some default settings added
<span class="line-modified">!    st-&gt;print_cr(&quot;# Java VM: %s%s%s (%s%s, %s%s%s%s%s, %s, %s)&quot;,</span>
                   VM_Version::vm_name(),
<span class="line-added">+                 (*vendor_version != &#39;\0&#39;) ? &quot; &quot; : &quot;&quot;, vendor_version,</span>
                   jdk_debug_level,
                   VM_Version::vm_release(),
                   VM_Version::vm_info_string(),
                   TieredCompilation ? &quot;, tiered&quot; : &quot;&quot;,
  #if INCLUDE_JVMCI
</pre>
<hr />
<pre>
<span class="line-old-header">*** 386,32 ***</span>
  // Factor to translate the timestamp to seconds.
  #define TIMESTAMP_TO_SECONDS_FACTOR (1000 * 1000 * 1000)
  
  void VMError::record_reporting_start_time() {
    const jlong now = get_current_timestamp();
<span class="line-modified">!   Atomic::store(now, &amp;_reporting_start_time);</span>
  }
  
  jlong VMError::get_reporting_start_time() {
    return Atomic::load(&amp;_reporting_start_time);
  }
  
  void VMError::record_step_start_time() {
    const jlong now = get_current_timestamp();
<span class="line-modified">!   Atomic::store(now, &amp;_step_start_time);</span>
  }
  
  jlong VMError::get_step_start_time() {
    return Atomic::load(&amp;_step_start_time);
  }
  
  void VMError::report(outputStream* st, bool _verbose) {
  
  # define BEGIN if (_current_step == 0) { _current_step = __LINE__;
  # define STEP(s) } if (_current_step &lt; __LINE__) { _current_step = __LINE__; _current_step_info = s; \
    record_step_start_time(); _step_did_timeout = false;
<span class="line-modified">! # define END }</span>
  
    // don&#39;t allocate large buffer on stack
    static char buf[O_BUFLEN];
  
    BEGIN
<span class="line-new-header">--- 397,36 ---</span>
  // Factor to translate the timestamp to seconds.
  #define TIMESTAMP_TO_SECONDS_FACTOR (1000 * 1000 * 1000)
  
  void VMError::record_reporting_start_time() {
    const jlong now = get_current_timestamp();
<span class="line-modified">!   Atomic::store(&amp;_reporting_start_time, now);</span>
  }
  
  jlong VMError::get_reporting_start_time() {
    return Atomic::load(&amp;_reporting_start_time);
  }
  
  void VMError::record_step_start_time() {
    const jlong now = get_current_timestamp();
<span class="line-modified">!   Atomic::store(&amp;_step_start_time, now);</span>
  }
  
  jlong VMError::get_step_start_time() {
    return Atomic::load(&amp;_step_start_time);
  }
  
<span class="line-added">+ void VMError::clear_step_start_time() {</span>
<span class="line-added">+   return Atomic::store(&amp;_step_start_time, (jlong)0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void VMError::report(outputStream* st, bool _verbose) {
  
  # define BEGIN if (_current_step == 0) { _current_step = __LINE__;
  # define STEP(s) } if (_current_step &lt; __LINE__) { _current_step = __LINE__; _current_step_info = s; \
    record_step_start_time(); _step_did_timeout = false;
<span class="line-modified">! # define END clear_step_start_time(); }</span>
  
    // don&#39;t allocate large buffer on stack
    static char buf[O_BUFLEN];
  
    BEGIN
</pre>
<hr />
<pre>
<span class="line-old-header">*** 447,10 ***</span>
<span class="line-new-header">--- 462,19 ---</span>
  
    // TestUnresponsiveErrorHandler: We want to test both step timeouts and global timeout.
    // Step to global timeout ratio is 4:1, so in order to be absolutely sure we hit the
    // global timeout, let&#39;s execute the timeout step five times.
    // See corresponding test in test/runtime/ErrorHandling/TimeoutInErrorHandlingTest.java
<span class="line-added">+   STEP(&quot;setup for test unresponsive error reporting step&quot;)</span>
<span class="line-added">+     if (_verbose &amp;&amp; TestUnresponsiveErrorHandler) {</span>
<span class="line-added">+       // We record reporting_start_time for this test here because we</span>
<span class="line-added">+       // care about the time spent executing TIMEOUT_TEST_STEP and not</span>
<span class="line-added">+       // about the time it took us to get here.</span>
<span class="line-added">+       tty-&gt;print_cr(&quot;Recording reporting_start_time for TestUnresponsiveErrorHandler.&quot;);</span>
<span class="line-added">+       record_reporting_start_time();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
    #define TIMEOUT_TEST_STEP STEP(&quot;test unresponsive error reporting step&quot;) \
      if (_verbose &amp;&amp; TestUnresponsiveErrorHandler) { os::infinite_sleep(); }
    TIMEOUT_TEST_STEP
    TIMEOUT_TEST_STEP
    TIMEOUT_TEST_STEP
</pre>
<hr />
<pre>
<span class="line-old-header">*** 880,11 ***</span>
       }
  
    STEP(&quot;printing compressed oops mode&quot;)
  
       if (_verbose &amp;&amp; UseCompressedOops) {
<span class="line-modified">!        Universe::print_compressed_oops_mode(st);</span>
         if (UseCompressedClassPointers) {
           Metaspace::print_compressed_class_space(st);
         }
         st-&gt;cr();
       }
<span class="line-new-header">--- 904,11 ---</span>
       }
  
    STEP(&quot;printing compressed oops mode&quot;)
  
       if (_verbose &amp;&amp; UseCompressedOops) {
<span class="line-modified">!        CompressedOops::print_mode(st);</span>
         if (UseCompressedClassPointers) {
           Metaspace::print_compressed_class_space(st);
         }
         st-&gt;cr();
       }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1081,11 ***</span>
    }
  
    // STEP(&quot;printing compressed oops mode&quot;)
  
    if (UseCompressedOops) {
<span class="line-modified">!     Universe::print_compressed_oops_mode(st);</span>
      if (UseCompressedClassPointers) {
        Metaspace::print_compressed_class_space(st);
      }
      st-&gt;cr();
    }
<span class="line-new-header">--- 1105,11 ---</span>
    }
  
    // STEP(&quot;printing compressed oops mode&quot;)
  
    if (UseCompressedOops) {
<span class="line-modified">!     CompressedOops::print_mode(st);</span>
      if (UseCompressedClassPointers) {
        Metaspace::print_compressed_class_space(st);
      }
      st-&gt;cr();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1188,33 ***</span>
    // STEP(&quot;printing end marker&quot;)
  
    st-&gt;print_cr(&quot;END.&quot;);
  }
  
<span class="line-modified">! volatile intptr_t VMError::first_error_tid = -1;</span>
  
  /** Expand a pattern into a buffer starting at pos and open a file using constructed path */
<span class="line-modified">! static int expand_and_open(const char* pattern, char* buf, size_t buflen, size_t pos) {</span>
    int fd = -1;
    if (Arguments::copy_expand_pid(pattern, strlen(pattern), &amp;buf[pos], buflen - pos)) {
<span class="line-modified">!     // the O_EXCL flag will cause the open to fail if the file exists</span>
<span class="line-removed">-     fd = open(buf, O_RDWR | O_CREAT | O_EXCL, 0666);</span>
    }
    return fd;
  }
  
  /**
   * Construct file name for a log file and return it&#39;s file descriptor.
   * Name and location depends on pattern, default_pattern params and access
   * permissions.
   */
<span class="line-modified">! static int prepare_log_file(const char* pattern, const char* default_pattern, char* buf, size_t buflen) {</span>
    int fd = -1;
  
    // If possible, use specified pattern to construct log file name
    if (pattern != NULL) {
<span class="line-modified">!     fd = expand_and_open(pattern, buf, buflen, 0);</span>
    }
  
    // Either user didn&#39;t specify, or the user&#39;s location failed,
    // so use the default name in the current directory
    if (fd == -1) {
<span class="line-new-header">--- 1212,38 ---</span>
    // STEP(&quot;printing end marker&quot;)
  
    st-&gt;print_cr(&quot;END.&quot;);
  }
  
<span class="line-modified">! volatile intptr_t VMError::_first_error_tid = -1;</span>
  
  /** Expand a pattern into a buffer starting at pos and open a file using constructed path */
<span class="line-modified">! static int expand_and_open(const char* pattern, bool overwrite_existing, char* buf, size_t buflen, size_t pos) {</span>
    int fd = -1;
<span class="line-added">+   int mode = O_RDWR | O_CREAT;</span>
<span class="line-added">+   if (overwrite_existing) {</span>
<span class="line-added">+     mode |= O_TRUNC;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     mode |= O_EXCL;</span>
<span class="line-added">+   }</span>
    if (Arguments::copy_expand_pid(pattern, strlen(pattern), &amp;buf[pos], buflen - pos)) {
<span class="line-modified">!     fd = open(buf, mode, 0666);</span>
    }
    return fd;
  }
  
  /**
   * Construct file name for a log file and return it&#39;s file descriptor.
   * Name and location depends on pattern, default_pattern params and access
   * permissions.
   */
<span class="line-modified">! static int prepare_log_file(const char* pattern, const char* default_pattern, bool overwrite_existing, char* buf, size_t buflen) {</span>
    int fd = -1;
  
    // If possible, use specified pattern to construct log file name
    if (pattern != NULL) {
<span class="line-modified">!     fd = expand_and_open(pattern, overwrite_existing, buf, buflen, 0);</span>
    }
  
    // Either user didn&#39;t specify, or the user&#39;s location failed,
    // so use the default name in the current directory
    if (fd == -1) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1222,22 ***</span>
      if (cwd != NULL) {
        size_t pos = strlen(cwd);
        int fsep_len = jio_snprintf(&amp;buf[pos], buflen-pos, &quot;%s&quot;, os::file_separator());
        pos += fsep_len;
        if (fsep_len &gt; 0) {
<span class="line-modified">!         fd = expand_and_open(default_pattern, buf, buflen, pos);</span>
        }
      }
    }
  
     // try temp directory if it exists.
     if (fd == -1) {
       const char* tmpdir = os::get_temp_directory();
       if (tmpdir != NULL &amp;&amp; strlen(tmpdir) &gt; 0) {
         int pos = jio_snprintf(buf, buflen, &quot;%s%s&quot;, tmpdir, os::file_separator());
         if (pos &gt; 0) {
<span class="line-modified">!          fd = expand_and_open(default_pattern, buf, buflen, pos);</span>
         }
       }
     }
  
    return fd;
<span class="line-new-header">--- 1251,22 ---</span>
      if (cwd != NULL) {
        size_t pos = strlen(cwd);
        int fsep_len = jio_snprintf(&amp;buf[pos], buflen-pos, &quot;%s&quot;, os::file_separator());
        pos += fsep_len;
        if (fsep_len &gt; 0) {
<span class="line-modified">!         fd = expand_and_open(default_pattern, overwrite_existing, buf, buflen, pos);</span>
        }
      }
    }
  
     // try temp directory if it exists.
     if (fd == -1) {
       const char* tmpdir = os::get_temp_directory();
       if (tmpdir != NULL &amp;&amp; strlen(tmpdir) &gt; 0) {
         int pos = jio_snprintf(buf, buflen, &quot;%s%s&quot;, tmpdir, os::file_separator());
         if (pos &gt; 0) {
<span class="line-modified">!          fd = expand_and_open(default_pattern, overwrite_existing, buf, buflen, pos);</span>
         }
       }
     }
  
    return fd;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1305,10 ***</span>
<span class="line-new-header">--- 1334,16 ---</span>
    static const int fd_out = 1; // stdout
  
    // File descriptor to the error log file.
    static int fd_log = -1;
  
<span class="line-added">+ #ifdef CAN_SHOW_REGISTERS_ON_ASSERT</span>
<span class="line-added">+   // Disarm assertion poison page, since from this point on we do not need this mechanism anymore and it may</span>
<span class="line-added">+   // cause problems in error handling during native OOM, see JDK-8227275.</span>
<span class="line-added">+   disarm_assert_poison();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
    // Use local fdStream objects only. Do not use global instances whose initialization
    // relies on dynamic initialization (see JDK-8214975). Do not rely on these instances
    // to carry over into recursions or invocations from other threads.
    fdStream out(fd_out);
    out.set_scratch_buffer(buffer, sizeof(buffer));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1327,12 ***</span>
  
    if (SuppressFatalErrorMessage) {
        os::abort(CreateCoredumpOnCrash);
    }
    intptr_t mytid = os::current_thread_id();
<span class="line-modified">!   if (first_error_tid == -1 &amp;&amp;</span>
<span class="line-modified">!       Atomic::cmpxchg(mytid, &amp;first_error_tid, (intptr_t)-1) == -1) {</span>
  
      // Initialize time stamps to use the same base.
      out.time_stamp().update_to(1);
      log.time_stamp().update_to(1);
  
<span class="line-new-header">--- 1362,12 ---</span>
  
    if (SuppressFatalErrorMessage) {
        os::abort(CreateCoredumpOnCrash);
    }
    intptr_t mytid = os::current_thread_id();
<span class="line-modified">!   if (_first_error_tid == -1 &amp;&amp;</span>
<span class="line-modified">!       Atomic::cmpxchg(&amp;_first_error_tid, (intptr_t)-1, mytid) == -1) {</span>
  
      // Initialize time stamps to use the same base.
      out.time_stamp().update_to(1);
      log.time_stamp().update_to(1);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1349,11 ***</span>
  
      // first time
      _error_reported = true;
  
      reporting_started();
<span class="line-modified">!     record_reporting_start_time();</span>
  
      if (ShowMessageBoxOnError || PauseAtExit) {
        show_message_box(buffer, sizeof(buffer));
  
        // User has asked JVM to abort. Reset ShowMessageBoxOnError so the
<span class="line-new-header">--- 1384,18 ---</span>
  
      // first time
      _error_reported = true;
  
      reporting_started();
<span class="line-modified">!     if (!TestUnresponsiveErrorHandler) {</span>
<span class="line-added">+       // Record reporting_start_time unless we&#39;re running the</span>
<span class="line-added">+       // TestUnresponsiveErrorHandler test. For that test we record</span>
<span class="line-added">+       // reporting_start_time at the beginning of the test.</span>
<span class="line-added">+       record_reporting_start_time();</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       out.print_raw_cr(&quot;Delaying recording reporting_start_time for TestUnresponsiveErrorHandler.&quot;);</span>
<span class="line-added">+     }</span>
  
      if (ShowMessageBoxOnError || PauseAtExit) {
        show_message_box(buffer, sizeof(buffer));
  
        // User has asked JVM to abort. Reset ShowMessageBoxOnError so the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1381,11 ***</span>
      // to be reported.
      if (UseOSErrorReporting &amp;&amp; log_done) return;
  
      // This is not the first error, see if it happened in a different thread
      // or in the same thread during error reporting.
<span class="line-modified">!     if (first_error_tid != mytid) {</span>
        char msgbuf[64];
        jio_snprintf(msgbuf, sizeof(msgbuf),
                     &quot;[thread &quot; INTX_FORMAT &quot; also had an error]&quot;,
                     mytid);
        out.print_raw_cr(msgbuf);
<span class="line-new-header">--- 1423,11 ---</span>
      // to be reported.
      if (UseOSErrorReporting &amp;&amp; log_done) return;
  
      // This is not the first error, see if it happened in a different thread
      // or in the same thread during error reporting.
<span class="line-modified">!     if (_first_error_tid != mytid) {</span>
        char msgbuf[64];
        jio_snprintf(msgbuf, sizeof(msgbuf),
                     &quot;[thread &quot; INTX_FORMAT &quot; also had an error]&quot;,
                     mytid);
        out.print_raw_cr(msgbuf);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1443,56 ***</span>
          st-&gt;cr();
        }
      }
    }
  
<span class="line-modified">!   // print to screen</span>
    if (!out_done) {
<span class="line-modified">!     report(&amp;out, false);</span>
  
      out_done = true;
  
      _current_step = 0;
      _current_step_info = &quot;&quot;;
    }
  
    // print to error log file
    if (!log_done) {
      // see if log file is already open
      if (!log.is_open()) {
        // open log file
<span class="line-modified">!       fd_log = prepare_log_file(ErrorFile, &quot;hs_err_pid%p.log&quot;, buffer, sizeof(buffer));</span>
<span class="line-modified">!       if (fd_log != -1) {</span>
<span class="line-modified">!         out.print_raw(&quot;# An error report file with more information is saved as:\n# &quot;);</span>
<span class="line-modified">!         out.print_raw_cr(buffer);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         log.set_fd(fd_log);</span>
        } else {
<span class="line-modified">!         out.print_raw_cr(&quot;# Can not save log file, dump to screen..&quot;);</span>
<span class="line-modified">!         log.set_fd(fd_out);</span>
        }
      }
  
      report(&amp;log, true);
      log_done = true;
      _current_step = 0;
      _current_step_info = &quot;&quot;;
  
<span class="line-modified">!     if (fd_log != -1) {</span>
        close(fd_log);
        fd_log = -1;
      }
  
      log.set_fd(-1);
    }
  
    static bool skip_replay = ReplayCompiles; // Do not overwrite file during replay
    if (DumpReplayDataOnError &amp;&amp; _thread &amp;&amp; _thread-&gt;is_Compiler_thread() &amp;&amp; !skip_replay) {
      skip_replay = true;
      ciEnv* env = ciEnv::current();
      if (env != NULL) {
<span class="line-modified">!       int fd = prepare_log_file(ReplayDataFile, &quot;replay_pid%p.log&quot;, buffer, sizeof(buffer));</span>
        if (fd != -1) {
          FILE* replay_data_file = os::open(fd, &quot;w&quot;);
          if (replay_data_file != NULL) {
            fileStream replay_data_stream(replay_data_file, /*need_close=*/true);
            env-&gt;dump_replay_data_unsafe(&amp;replay_data_stream);
<span class="line-new-header">--- 1485,73 ---</span>
          st-&gt;cr();
        }
      }
    }
  
<span class="line-modified">!   // Part 1: print an abbreviated version (the &#39;#&#39; section) to stdout.</span>
    if (!out_done) {
<span class="line-modified">!     // Suppress this output if we plan to print Part 2 to stdout too.</span>
<span class="line-added">+     // No need to have the &quot;#&quot; section twice.</span>
<span class="line-added">+     if (!(ErrorFileToStdout &amp;&amp; out.fd() == 1)) {</span>
<span class="line-added">+       report(&amp;out, false);</span>
<span class="line-added">+     }</span>
  
      out_done = true;
  
      _current_step = 0;
      _current_step_info = &quot;&quot;;
    }
  
<span class="line-added">+   // Part 2: print a full error log file (optionally to stdout or stderr).</span>
    // print to error log file
    if (!log_done) {
      // see if log file is already open
      if (!log.is_open()) {
        // open log file
<span class="line-modified">!       if (ErrorFileToStdout) {</span>
<span class="line-modified">!         fd_log = 1;</span>
<span class="line-modified">!       } else if (ErrorFileToStderr) {</span>
<span class="line-modified">!         fd_log = 2;</span>
        } else {
<span class="line-modified">!         fd_log = prepare_log_file(ErrorFile, &quot;hs_err_pid%p.log&quot;, true,</span>
<span class="line-modified">!                  buffer, sizeof(buffer));</span>
<span class="line-added">+         if (fd_log != -1) {</span>
<span class="line-added">+           out.print_raw(&quot;# An error report file with more information is saved as:\n# &quot;);</span>
<span class="line-added">+           out.print_raw_cr(buffer);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           out.print_raw_cr(&quot;# Can not save log file, dump to screen..&quot;);</span>
<span class="line-added">+           fd_log = 1;</span>
<span class="line-added">+         }</span>
        }
<span class="line-added">+       log.set_fd(fd_log);</span>
      }
  
      report(&amp;log, true);
      log_done = true;
      _current_step = 0;
      _current_step_info = &quot;&quot;;
  
<span class="line-modified">!     if (fd_log &gt; 3) {</span>
        close(fd_log);
        fd_log = -1;
      }
  
      log.set_fd(-1);
    }
  
<span class="line-added">+   if (PrintNMTStatistics) {</span>
<span class="line-added">+     fdStream fds(fd_out);</span>
<span class="line-added">+     MemTracker::final_report(&amp;fds);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    static bool skip_replay = ReplayCompiles; // Do not overwrite file during replay
    if (DumpReplayDataOnError &amp;&amp; _thread &amp;&amp; _thread-&gt;is_Compiler_thread() &amp;&amp; !skip_replay) {
      skip_replay = true;
      ciEnv* env = ciEnv::current();
      if (env != NULL) {
<span class="line-modified">!       const bool overwrite = false; // We do not overwrite an existing replay file.</span>
<span class="line-added">+       int fd = prepare_log_file(ReplayDataFile, &quot;replay_pid%p.log&quot;, overwrite, buffer, sizeof(buffer));</span>
        if (fd != -1) {
          FILE* replay_data_file = os::open(fd, &quot;w&quot;);
          if (replay_data_file != NULL) {
            fileStream replay_data_stream(replay_data_file, /*need_close=*/true);
            env-&gt;dump_replay_data_unsafe(&amp;replay_data_stream);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1644,11 ***</span>
    const jlong reporting_start_time_l = get_reporting_start_time();
    const jlong now = get_current_timestamp();
    // Timestamp is stored in nanos.
    if (reporting_start_time_l &gt; 0) {
      const jlong end = reporting_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR;
<span class="line-modified">!     if (end &lt;= now) {</span>
        _reporting_did_timeout = true;
        interrupt_reporting_thread();
        return true; // global timeout
      }
    }
<span class="line-new-header">--- 1703,13 ---</span>
    const jlong reporting_start_time_l = get_reporting_start_time();
    const jlong now = get_current_timestamp();
    // Timestamp is stored in nanos.
    if (reporting_start_time_l &gt; 0) {
      const jlong end = reporting_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR;
<span class="line-modified">!     if (end &lt;= now &amp;&amp; !_reporting_did_timeout) {</span>
<span class="line-added">+       // We hit ErrorLogTimeout and we haven&#39;t interrupted the reporting</span>
<span class="line-added">+       // thread yet.</span>
        _reporting_did_timeout = true;
        interrupt_reporting_thread();
        return true; // global timeout
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1657,11 ***</span>
    if (step_start_time_l &gt; 0) {
      // A step times out after a quarter of the total timeout. Steps are mostly fast unless they
      // hang for some reason, so this simple rule allows for three hanging step and still
      // hopefully leaves time enough for the rest of the steps to finish.
      const jlong end = step_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR / 4;
<span class="line-modified">!     if (end &lt;= now) {</span>
        _step_did_timeout = true;
        interrupt_reporting_thread();
        return false; // (Not a global timeout)
      }
    }
<span class="line-new-header">--- 1718,13 ---</span>
    if (step_start_time_l &gt; 0) {
      // A step times out after a quarter of the total timeout. Steps are mostly fast unless they
      // hang for some reason, so this simple rule allows for three hanging step and still
      // hopefully leaves time enough for the rest of the steps to finish.
      const jlong end = step_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR / 4;
<span class="line-modified">!     if (end &lt;= now &amp;&amp; !_step_did_timeout) {</span>
<span class="line-added">+       // The step timed out and we haven&#39;t interrupted the reporting</span>
<span class="line-added">+       // thread yet.</span>
        _step_did_timeout = true;
        interrupt_reporting_thread();
        return false; // (Not a global timeout)
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1723,24 ***</span>
    const size_t      num = (size_t)os::vm_page_size();
  
    const char* const eol = os::line_separator();
    const char* const msg = &quot;this message should be truncated during formatting&quot;;
    char * const dataPtr = NULL;  // bad data pointer
<span class="line-modified">!   const void (*funcPtr)(void) = (const void(*)()) 0xF;  // bad function pointer</span>
  
    // Keep this in sync with test/hotspot/jtreg/runtime/ErrorHandling/ErrorHandler.java
    // which tests cases 1 thru 13.
    // Case 14 is tested by test/hotspot/jtreg/runtime/ErrorHandling/SafeFetchInErrorHandlingTest.java.
    // Case 15 is tested by test/hotspot/jtreg/runtime/ErrorHandling/SecondaryErrorTest.java.
    // Case 16 is tested by test/hotspot/jtreg/runtime/ErrorHandling/ThreadsListHandleInErrorHandlingTest.java.
    // Case 17 is tested by test/hotspot/jtreg/runtime/ErrorHandling/NestedThreadsListHandleInErrorHandlingTest.java.
  
<span class="line-modified">!   // We grab Threads_lock to keep ThreadsSMRSupport::print_info_on()</span>
    // from racing with Threads::add() or Threads::remove() as we
    // generate the hs_err_pid file. This makes our ErrorHandling tests
    // more stable.
<span class="line-modified">!   MutexLockerEx ml(Threads_lock-&gt;owned_by_self() ? NULL : Threads_lock, Mutex::_no_safepoint_check_flag);</span>
  
    switch (how) {
      case  1: vmassert(str == NULL, &quot;expected null&quot;); break;
      case  2: vmassert(num == 1023 &amp;&amp; *str == &#39;X&#39;,
                        &quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
<span class="line-new-header">--- 1786,36 ---</span>
    const size_t      num = (size_t)os::vm_page_size();
  
    const char* const eol = os::line_separator();
    const char* const msg = &quot;this message should be truncated during formatting&quot;;
    char * const dataPtr = NULL;  // bad data pointer
<span class="line-modified">!   const void (*funcPtr)(void);  // bad function pointer</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if defined(PPC64) &amp;&amp; !defined(ABI_ELFv2)</span>
<span class="line-added">+   struct FunctionDescriptor functionDescriptor;</span>
<span class="line-added">+ </span>
<span class="line-added">+   functionDescriptor.set_entry((address) 0xF);</span>
<span class="line-added">+   funcPtr = (const void(*)()) &amp;functionDescriptor;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+   funcPtr = (const void(*)()) 0xF;</span>
<span class="line-added">+ #endif</span>
  
    // Keep this in sync with test/hotspot/jtreg/runtime/ErrorHandling/ErrorHandler.java
    // which tests cases 1 thru 13.
    // Case 14 is tested by test/hotspot/jtreg/runtime/ErrorHandling/SafeFetchInErrorHandlingTest.java.
    // Case 15 is tested by test/hotspot/jtreg/runtime/ErrorHandling/SecondaryErrorTest.java.
    // Case 16 is tested by test/hotspot/jtreg/runtime/ErrorHandling/ThreadsListHandleInErrorHandlingTest.java.
    // Case 17 is tested by test/hotspot/jtreg/runtime/ErrorHandling/NestedThreadsListHandleInErrorHandlingTest.java.
  
<span class="line-modified">!   // We try to grab Threads_lock to keep ThreadsSMRSupport::print_info_on()</span>
    // from racing with Threads::add() or Threads::remove() as we
    // generate the hs_err_pid file. This makes our ErrorHandling tests
    // more stable.
<span class="line-modified">!   if (!Threads_lock-&gt;owned_by_self()) {</span>
<span class="line-added">+     Threads_lock-&gt;try_lock();</span>
<span class="line-added">+     // The VM is going to die so no need to unlock Thread_lock.</span>
<span class="line-added">+   }</span>
  
    switch (how) {
      case  1: vmassert(str == NULL, &quot;expected null&quot;); break;
      case  2: vmassert(num == 1023 &amp;&amp; *str == &#39;X&#39;,
                        &quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1783,6 ***</span>
    }
    tty-&gt;print_cr(&quot;VMError::controlled_crash: survived intentional crash. Did you suppress the assert?&quot;);
    ShouldNotReachHere();
  }
  #endif // !PRODUCT
<span class="line-removed">- </span>
<span class="line-new-header">--- 1858,5 ---</span>
</pre>
<center><a href="ticks.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmError.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
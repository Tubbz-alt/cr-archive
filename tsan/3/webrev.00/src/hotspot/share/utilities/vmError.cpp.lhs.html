<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/vmError.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/gcConfig.hpp&quot;
  31 #include &quot;logging/logConfiguration.hpp&quot;
  32 #include &quot;jfr/jfrEvents.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
<a name="1" id="anc1"></a>

  34 #include &quot;prims/whitebox.hpp&quot;
  35 #include &quot;runtime/arguments.hpp&quot;
  36 #include &quot;runtime/atomic.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/init.hpp&quot;
  39 #include &quot;runtime/os.hpp&quot;
  40 #include &quot;runtime/thread.inline.hpp&quot;
  41 #include &quot;runtime/threadSMR.hpp&quot;
  42 #include &quot;runtime/vmThread.hpp&quot;
  43 #include &quot;runtime/vmOperations.hpp&quot;
  44 #include &quot;runtime/vm_version.hpp&quot;
  45 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  46 #include &quot;services/memTracker.hpp&quot;
  47 #include &quot;utilities/debug.hpp&quot;
  48 #include &quot;utilities/decoder.hpp&quot;
  49 #include &quot;utilities/defaultStream.hpp&quot;
  50 #include &quot;utilities/events.hpp&quot;
  51 #include &quot;utilities/vmError.hpp&quot;
  52 #include &quot;utilities/macros.hpp&quot;
  53 #if INCLUDE_JFR
  54 #include &quot;jfr/jfr.hpp&quot;
  55 #endif
  56 
  57 #ifndef PRODUCT
  58 #include &lt;signal.h&gt;
  59 #endif // PRODUCT
  60 
  61 bool VMError::_error_reported = false;
  62 
  63 // call this when the VM is dying--it might loosen some asserts
  64 bool VMError::is_error_reported() { return _error_reported; }
  65 
  66 // returns an address which is guaranteed to generate a SIGSEGV on read,
  67 // for test purposes, which is not NULL and contains bits in every word
  68 void* VMError::get_segfault_address() {
  69   return (void*)
  70 #ifdef _LP64
  71     0xABC0000000000ABCULL;
  72 #else
  73     0x00000ABC;
  74 #endif
  75 }
  76 
  77 // List of environment variables that should be reported in error log file.
  78 const char *env_list[] = {
  79   // All platforms
  80   &quot;JAVA_HOME&quot;, &quot;JRE_HOME&quot;, &quot;JAVA_TOOL_OPTIONS&quot;, &quot;_JAVA_OPTIONS&quot;, &quot;CLASSPATH&quot;,
  81   &quot;JAVA_COMPILER&quot;, &quot;PATH&quot;, &quot;USERNAME&quot;,
  82 
  83   // Env variables that are defined on Solaris/Linux/BSD
  84   &quot;LD_LIBRARY_PATH&quot;, &quot;LD_PRELOAD&quot;, &quot;SHELL&quot;, &quot;DISPLAY&quot;,
  85   &quot;HOSTTYPE&quot;, &quot;OSTYPE&quot;, &quot;ARCH&quot;, &quot;MACHTYPE&quot;,
  86 
  87   // defined on AIX
  88   &quot;LIBPATH&quot;, &quot;LDR_PRELOAD&quot;, &quot;LDR_PRELOAD64&quot;,
  89 
  90   // defined on Linux
  91   &quot;LD_ASSUME_KERNEL&quot;, &quot;_JAVA_SR_SIGNUM&quot;,
  92 
  93   // defined on Darwin
  94   &quot;DYLD_LIBRARY_PATH&quot;, &quot;DYLD_FALLBACK_LIBRARY_PATH&quot;,
  95   &quot;DYLD_FRAMEWORK_PATH&quot;, &quot;DYLD_FALLBACK_FRAMEWORK_PATH&quot;,
  96   &quot;DYLD_INSERT_LIBRARIES&quot;,
  97 
  98   // defined on Windows
  99   &quot;OS&quot;, &quot;PROCESSOR_IDENTIFIER&quot;, &quot;_ALT_JAVA_HOME_DIR&quot;,
 100 
 101   (const char *)0
 102 };
 103 
 104 // A simple parser for -XX:OnError, usage:
 105 //  ptr = OnError;
 106 //  while ((cmd = next_OnError_command(buffer, sizeof(buffer), &amp;ptr) != NULL)
 107 //     ... ...
 108 static char* next_OnError_command(char* buf, int buflen, const char** ptr) {
 109   if (ptr == NULL || *ptr == NULL) return NULL;
 110 
 111   const char* cmd = *ptr;
 112 
 113   // skip leading blanks or &#39;;&#39;
 114   while (*cmd == &#39; &#39; || *cmd == &#39;;&#39;) cmd++;
 115 
 116   if (*cmd == &#39;\0&#39;) return NULL;
 117 
 118   const char * cmdend = cmd;
 119   while (*cmdend != &#39;\0&#39; &amp;&amp; *cmdend != &#39;;&#39;) cmdend++;
 120 
 121   Arguments::copy_expand_pid(cmd, cmdend - cmd, buf, buflen);
 122 
 123   *ptr = (*cmdend == &#39;\0&#39; ? cmdend : cmdend + 1);
 124   return buf;
 125 }
 126 
 127 static void print_bug_submit_message(outputStream *out, Thread *thread) {
 128   if (out == NULL) return;
<a name="2" id="anc2"></a><span class="line-modified"> 129   out-&gt;print_raw_cr(&quot;# If you would like to submit a bug report, please visit:&quot;);</span>
<span class="line-modified"> 130   out-&gt;print_raw   (&quot;#   &quot;);</span>
<span class="line-modified"> 131   out-&gt;print_raw_cr(Arguments::java_vendor_url_bug());</span>





 132   // If the crash is in native code, encourage user to submit a bug to the
 133   // provider of that code.
 134   if (thread &amp;&amp; thread-&gt;is_Java_thread() &amp;&amp;
 135       !thread-&gt;is_hidden_from_external_view()) {
 136     JavaThread* jt = (JavaThread*)thread;
 137     if (jt-&gt;thread_state() == _thread_in_native) {
 138       out-&gt;print_cr(&quot;# The crash happened outside the Java Virtual Machine in native code.\n# See problematic frame for where to report the bug.&quot;);
 139     }
 140   }
 141   out-&gt;print_raw_cr(&quot;#&quot;);
 142 }
 143 
 144 bool VMError::coredump_status;
 145 char VMError::coredump_message[O_BUFLEN];
 146 
 147 void VMError::record_coredump_status(const char* message, bool status) {
 148   coredump_status = status;
 149   strncpy(coredump_message, message, sizeof(coredump_message));
 150   coredump_message[sizeof(coredump_message)-1] = 0;
 151 }
 152 
 153 // Return a string to describe the error
 154 char* VMError::error_string(char* buf, int buflen) {
 155   char signame_buf[64];
 156   const char *signame = os::exception_name(_id, signame_buf, sizeof(signame_buf));
 157 
 158   if (signame) {
 159     jio_snprintf(buf, buflen,
 160                  &quot;%s (0x%x) at pc=&quot; PTR_FORMAT &quot;, pid=%d, tid=&quot; UINTX_FORMAT,
 161                  signame, _id, _pc,
 162                  os::current_process_id(), os::current_thread_id());
 163   } else if (_filename != NULL &amp;&amp; _lineno &gt; 0) {
 164     // skip directory names
 165     char separator = os::file_separator()[0];
 166     const char *p = strrchr(_filename, separator);
 167     int n = jio_snprintf(buf, buflen,
 168                          &quot;Internal Error at %s:%d, pid=%d, tid=&quot; UINTX_FORMAT,
 169                          p ? p + 1 : _filename, _lineno,
 170                          os::current_process_id(), os::current_thread_id());
 171     if (n &gt;= 0 &amp;&amp; n &lt; buflen &amp;&amp; _message) {
 172       if (strlen(_detail_msg) &gt; 0) {
 173         jio_snprintf(buf + n, buflen - n, &quot;%s%s: %s&quot;,
 174         os::line_separator(), _message, _detail_msg);
 175       } else {
 176         jio_snprintf(buf + n, buflen - n, &quot;%sError: %s&quot;,
 177                      os::line_separator(), _message);
 178       }
 179     }
 180   } else {
 181     jio_snprintf(buf, buflen,
 182                  &quot;Internal Error (0x%x), pid=%d, tid=&quot; UINTX_FORMAT,
 183                  _id, os::current_process_id(), os::current_thread_id());
 184   }
 185 
 186   return buf;
 187 }
 188 
 189 void VMError::print_stack_trace(outputStream* st, JavaThread* jt,
 190                                 char* buf, int buflen, bool verbose) {
 191 #ifdef ZERO
 192   if (jt-&gt;zero_stack()-&gt;sp() &amp;&amp; jt-&gt;top_zero_frame()) {
 193     // StackFrameStream uses the frame anchor, which may not have
 194     // been set up.  This can be done at any time in Zero, however,
 195     // so if it hasn&#39;t been set up then we just set it up now and
 196     // clear it again when we&#39;re done.
 197     bool has_last_Java_frame = jt-&gt;has_last_Java_frame();
 198     if (!has_last_Java_frame)
 199       jt-&gt;set_last_Java_frame();
 200     st-&gt;print(&quot;Java frames:&quot;);
 201     st-&gt;cr();
 202 
 203     // Print the frames
 204     StackFrameStream sfs(jt);
 205     for(int i = 0; !sfs.is_done(); sfs.next(), i++) {
 206       sfs.current()-&gt;zero_print_on_error(i, st, buf, buflen);
 207       st-&gt;cr();
 208     }
 209 
 210     // Reset the frame anchor if necessary
 211     if (!has_last_Java_frame)
 212       jt-&gt;reset_last_Java_frame();
 213   }
 214 #else
 215   if (jt-&gt;has_last_Java_frame()) {
 216     st-&gt;print_cr(&quot;Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)&quot;);
 217     for(StackFrameStream sfs(jt); !sfs.is_done(); sfs.next()) {
 218       sfs.current()-&gt;print_on_error(st, buf, buflen, verbose);
 219       st-&gt;cr();
 220     }
 221   }
 222 #endif // ZERO
 223 }
 224 
 225 void VMError::print_native_stack(outputStream* st, frame fr, Thread* t, char* buf, int buf_size) {
 226 
 227   // see if it&#39;s a valid frame
 228   if (fr.pc()) {
 229     st-&gt;print_cr(&quot;Native frames: (J=compiled Java code, A=aot compiled Java code, j=interpreted, Vv=VM code, C=native code)&quot;);
 230 
 231     int count = 0;
 232     while (count++ &lt; StackPrintLimit) {
 233       fr.print_on_error(st, buf, buf_size);
 234       if (fr.pc()) { // print source file and line, if available
 235         char buf[128];
 236         int line_no;
 237         if (Decoder::get_source_info(fr.pc(), buf, sizeof(buf), &amp;line_no)) {
 238           st-&gt;print(&quot;  (%s:%d)&quot;, buf, line_no);
 239         }
 240       }
 241       st-&gt;cr();
 242       // Compiled code may use EBP register on x86 so it looks like
 243       // non-walkable C frame. Use frame.sender() for java frames.
 244       if (t &amp;&amp; t-&gt;is_Java_thread()) {
 245         // Catch very first native frame by using stack address.
 246         // For JavaThread stack_base and stack_size should be set.
 247         if (!t-&gt;on_local_stack((address)(fr.real_fp() + 1))) {
 248           break;
 249         }
 250         if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {
 251           RegisterMap map((JavaThread*)t, false); // No update
 252           fr = fr.sender(&amp;map);
 253         } else {
 254           // is_first_C_frame() does only simple checks for frame pointer,
 255           // it will pass if java compiled code has a pointer in EBP.
 256           if (os::is_first_C_frame(&amp;fr)) break;
 257           fr = os::get_sender_for_C_frame(&amp;fr);
 258         }
 259       } else {
 260         if (os::is_first_C_frame(&amp;fr)) break;
 261         fr = os::get_sender_for_C_frame(&amp;fr);
 262       }
 263     }
 264 
 265     if (count &gt; StackPrintLimit) {
 266       st-&gt;print_cr(&quot;...&lt;more frames&gt;...&quot;);
 267     }
 268 
 269     st-&gt;cr();
 270   }
 271 }
 272 
 273 static void print_oom_reasons(outputStream* st) {
 274   st-&gt;print_cr(&quot;# Possible reasons:&quot;);
 275   st-&gt;print_cr(&quot;#   The system is out of physical RAM or swap space&quot;);
 276   if (UseCompressedOops) {
 277     st-&gt;print_cr(&quot;#   The process is running with CompressedOops enabled, and the Java Heap may be blocking the growth of the native heap&quot;);
 278   }
 279   if (LogBytesPerWord == 2) {
 280     st-&gt;print_cr(&quot;#   In 32 bit mode, the process size limit was hit&quot;);
 281   }
 282   st-&gt;print_cr(&quot;# Possible solutions:&quot;);
 283   st-&gt;print_cr(&quot;#   Reduce memory load on the system&quot;);
 284   st-&gt;print_cr(&quot;#   Increase physical memory or swap space&quot;);
 285   st-&gt;print_cr(&quot;#   Check if swap backing store is full&quot;);
 286   if (LogBytesPerWord == 2) {
 287     st-&gt;print_cr(&quot;#   Use 64 bit Java on a 64 bit OS&quot;);
 288   }
 289   st-&gt;print_cr(&quot;#   Decrease Java heap size (-Xmx/-Xms)&quot;);
 290   st-&gt;print_cr(&quot;#   Decrease number of Java threads&quot;);
 291   st-&gt;print_cr(&quot;#   Decrease Java thread stack sizes (-Xss)&quot;);
 292   st-&gt;print_cr(&quot;#   Set larger code cache with -XX:ReservedCodeCacheSize=&quot;);
 293   if (UseCompressedOops) {
<a name="3" id="anc3"></a><span class="line-modified"> 294     switch (Universe::narrow_oop_mode()) {</span>
<span class="line-modified"> 295       case Universe::UnscaledNarrowOop:</span>
 296         st-&gt;print_cr(&quot;#   JVM is running with Unscaled Compressed Oops mode in which the Java heap is&quot;);
 297         st-&gt;print_cr(&quot;#     placed in the first 4GB address space. The Java Heap base address is the&quot;);
 298         st-&gt;print_cr(&quot;#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress&quot;);
 299         st-&gt;print_cr(&quot;#     to set the Java Heap base and to place the Java Heap above 4GB virtual address.&quot;);
 300         break;
<a name="4" id="anc4"></a><span class="line-modified"> 301       case Universe::ZeroBasedNarrowOop:</span>
 302         st-&gt;print_cr(&quot;#   JVM is running with Zero Based Compressed Oops mode in which the Java heap is&quot;);
 303         st-&gt;print_cr(&quot;#     placed in the first 32GB address space. The Java Heap base address is the&quot;);
 304         st-&gt;print_cr(&quot;#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress&quot;);
 305         st-&gt;print_cr(&quot;#     to set the Java Heap base and to place the Java Heap above 32GB virtual address.&quot;);
 306         break;
 307       default:
 308         break;
 309     }
 310   }
 311   st-&gt;print_cr(&quot;# This output file may be truncated or incomplete.&quot;);
 312 }
 313 
 314 static void report_vm_version(outputStream* st, char* buf, int buflen) {
 315    // VM version
 316    st-&gt;print_cr(&quot;#&quot;);
 317    JDK_Version::current().to_string(buf, buflen);
 318    const char* runtime_name = JDK_Version::runtime_name() != NULL ?
 319                                 JDK_Version::runtime_name() : &quot;&quot;;
 320    const char* runtime_version = JDK_Version::runtime_version() != NULL ?
 321                                    JDK_Version::runtime_version() : &quot;&quot;;
<a name="5" id="anc5"></a>

 322    const char* jdk_debug_level = VM_Version::printable_jdk_debug_level() != NULL ?
 323                                    VM_Version::printable_jdk_debug_level() : &quot;&quot;;
 324 
<a name="6" id="anc6"></a><span class="line-modified"> 325    st-&gt;print_cr(&quot;# JRE version: %s (%s) (%sbuild %s)&quot;, runtime_name, buf,</span>
<span class="line-modified"> 326                  jdk_debug_level, runtime_version);</span>

 327 
 328    // This is the long version with some default settings added
<a name="7" id="anc7"></a><span class="line-modified"> 329    st-&gt;print_cr(&quot;# Java VM: %s (%s%s, %s%s%s%s%s, %s, %s)&quot;,</span>
 330                  VM_Version::vm_name(),
<a name="8" id="anc8"></a>
 331                  jdk_debug_level,
 332                  VM_Version::vm_release(),
 333                  VM_Version::vm_info_string(),
 334                  TieredCompilation ? &quot;, tiered&quot; : &quot;&quot;,
 335 #if INCLUDE_JVMCI
 336                  EnableJVMCI ? &quot;, jvmci&quot; : &quot;&quot;,
 337                  UseJVMCICompiler ? &quot;, jvmci compiler&quot; : &quot;&quot;,
 338 #else
 339                  &quot;&quot;, &quot;&quot;,
 340 #endif
 341                  UseCompressedOops ? &quot;, compressed oops&quot; : &quot;&quot;,
 342                  GCConfig::hs_err_name(),
 343                  VM_Version::vm_platform_string()
 344                );
 345 }
 346 
 347 // This is the main function to report a fatal error. Only one thread can
 348 // call this function, so we don&#39;t need to worry about MT-safety. But it&#39;s
 349 // possible that the error handler itself may crash or die on an internal
 350 // error, for example, when the stack/heap is badly damaged. We must be
 351 // able to handle recursive errors that happen inside error handler.
 352 //
 353 // Error reporting is done in several steps. If a crash or internal error
 354 // occurred when reporting an error, the nested signal/exception handler
 355 // can skip steps that are already (or partially) done. Error reporting will
 356 // continue from the next step. This allows us to retrieve and print
 357 // information that may be unsafe to get after a fatal error. If it happens,
 358 // you may find nested report_and_die() frames when you look at the stack
 359 // in a debugger.
 360 //
 361 // In general, a hang in error handler is much worse than a crash or internal
 362 // error, as it&#39;s harder to recover from a hang. Deadlock can happen if we
 363 // try to grab a lock that is already owned by current thread, or if the
 364 // owner is blocked forever (e.g. in os::infinite_sleep()). If possible, the
 365 // error handler and all the functions it called should avoid grabbing any
 366 // lock. An important thing to notice is that memory allocation needs a lock.
 367 //
 368 // We should avoid using large stack allocated buffers. Many errors happen
 369 // when stack space is already low. Making things even worse is that there
 370 // could be nested report_and_die() calls on stack (see above). Only one
 371 // thread can report error, so large buffers are statically allocated in data
 372 // segment.
 373 
 374 int          VMError::_current_step;
 375 const char*  VMError::_current_step_info;
 376 
 377 volatile jlong VMError::_reporting_start_time = -1;
 378 volatile bool VMError::_reporting_did_timeout = false;
 379 volatile jlong VMError::_step_start_time = -1;
 380 volatile bool VMError::_step_did_timeout = false;
 381 
 382 // Helper, return current timestamp for timeout handling.
 383 jlong VMError::get_current_timestamp() {
 384   return os::javaTimeNanos();
 385 }
 386 // Factor to translate the timestamp to seconds.
 387 #define TIMESTAMP_TO_SECONDS_FACTOR (1000 * 1000 * 1000)
 388 
 389 void VMError::record_reporting_start_time() {
 390   const jlong now = get_current_timestamp();
<a name="9" id="anc9"></a><span class="line-modified"> 391   Atomic::store(now, &amp;_reporting_start_time);</span>
 392 }
 393 
 394 jlong VMError::get_reporting_start_time() {
 395   return Atomic::load(&amp;_reporting_start_time);
 396 }
 397 
 398 void VMError::record_step_start_time() {
 399   const jlong now = get_current_timestamp();
<a name="10" id="anc10"></a><span class="line-modified"> 400   Atomic::store(now, &amp;_step_start_time);</span>
 401 }
 402 
 403 jlong VMError::get_step_start_time() {
 404   return Atomic::load(&amp;_step_start_time);
 405 }
 406 
<a name="11" id="anc11"></a>



 407 void VMError::report(outputStream* st, bool _verbose) {
 408 
 409 # define BEGIN if (_current_step == 0) { _current_step = __LINE__;
 410 # define STEP(s) } if (_current_step &lt; __LINE__) { _current_step = __LINE__; _current_step_info = s; \
 411   record_step_start_time(); _step_did_timeout = false;
<a name="12" id="anc12"></a><span class="line-modified"> 412 # define END }</span>
 413 
 414   // don&#39;t allocate large buffer on stack
 415   static char buf[O_BUFLEN];
 416 
 417   BEGIN
 418 
 419   STEP(&quot;printing fatal error message&quot;)
 420 
 421     st-&gt;print_cr(&quot;#&quot;);
 422     if (should_report_bug(_id)) {
 423       st-&gt;print_cr(&quot;# A fatal error has been detected by the Java Runtime Environment:&quot;);
 424     } else {
 425       st-&gt;print_cr(&quot;# There is insufficient memory for the Java &quot;
 426                    &quot;Runtime Environment to continue.&quot;);
 427     }
 428 
 429 #ifndef PRODUCT
 430   // Error handler self tests
 431 
 432   // test secondary error handling. Test it twice, to test that resetting
 433   // error handler after a secondary crash works.
 434   STEP(&quot;test secondary crash 1&quot;)
 435     if (_verbose &amp;&amp; TestCrashInErrorHandler != 0) {
 436       st-&gt;print_cr(&quot;Will crash now (TestCrashInErrorHandler=&quot; UINTX_FORMAT &quot;)...&quot;,
 437         TestCrashInErrorHandler);
 438       controlled_crash(TestCrashInErrorHandler);
 439     }
 440 
 441   STEP(&quot;test secondary crash 2&quot;)
 442     if (_verbose &amp;&amp; TestCrashInErrorHandler != 0) {
 443       st-&gt;print_cr(&quot;Will crash now (TestCrashInErrorHandler=&quot; UINTX_FORMAT &quot;)...&quot;,
 444         TestCrashInErrorHandler);
 445       controlled_crash(TestCrashInErrorHandler);
 446     }
 447 
 448   // TestUnresponsiveErrorHandler: We want to test both step timeouts and global timeout.
 449   // Step to global timeout ratio is 4:1, so in order to be absolutely sure we hit the
 450   // global timeout, let&#39;s execute the timeout step five times.
 451   // See corresponding test in test/runtime/ErrorHandling/TimeoutInErrorHandlingTest.java
<a name="13" id="anc13"></a>








 452   #define TIMEOUT_TEST_STEP STEP(&quot;test unresponsive error reporting step&quot;) \
 453     if (_verbose &amp;&amp; TestUnresponsiveErrorHandler) { os::infinite_sleep(); }
 454   TIMEOUT_TEST_STEP
 455   TIMEOUT_TEST_STEP
 456   TIMEOUT_TEST_STEP
 457   TIMEOUT_TEST_STEP
 458   TIMEOUT_TEST_STEP
 459 
 460   STEP(&quot;test safefetch in error handler&quot;)
 461     // test whether it is safe to use SafeFetch32 in Crash Handler. Test twice
 462     // to test that resetting the signal handler works correctly.
 463     if (_verbose &amp;&amp; TestSafeFetchInErrorHandler) {
 464       st-&gt;print_cr(&quot;Will test SafeFetch...&quot;);
 465       if (CanUseSafeFetch32()) {
 466         int* const invalid_pointer = (int*) get_segfault_address();
 467         const int x = 0x76543210;
 468         int i1 = SafeFetch32(invalid_pointer, x);
 469         int i2 = SafeFetch32(invalid_pointer, x);
 470         if (i1 == x &amp;&amp; i2 == x) {
 471           st-&gt;print_cr(&quot;SafeFetch OK.&quot;); // Correctly deflected and returned default pattern
 472         } else {
 473           st-&gt;print_cr(&quot;??&quot;);
 474         }
 475       } else {
 476         st-&gt;print_cr(&quot;not possible; skipped.&quot;);
 477       }
 478     }
 479 #endif // PRODUCT
 480 
 481   STEP(&quot;printing type of error&quot;)
 482 
 483      switch(static_cast&lt;unsigned int&gt;(_id)) {
 484        case OOM_MALLOC_ERROR:
 485        case OOM_MMAP_ERROR:
 486          if (_size) {
 487            st-&gt;print(&quot;# Native memory allocation &quot;);
 488            st-&gt;print((_id == (int)OOM_MALLOC_ERROR) ? &quot;(malloc) failed to allocate &quot; :
 489                                                  &quot;(mmap) failed to map &quot;);
 490            jio_snprintf(buf, sizeof(buf), SIZE_FORMAT, _size);
 491            st-&gt;print(&quot;%s&quot;, buf);
 492            st-&gt;print(&quot; bytes&quot;);
 493            if (strlen(_detail_msg) &gt; 0) {
 494              st-&gt;print(&quot; for &quot;);
 495              st-&gt;print(&quot;%s&quot;, _detail_msg);
 496            }
 497            st-&gt;cr();
 498          } else {
 499            if (strlen(_detail_msg) &gt; 0) {
 500              st-&gt;print(&quot;# &quot;);
 501              st-&gt;print_cr(&quot;%s&quot;, _detail_msg);
 502            }
 503          }
 504          // In error file give some solutions
 505          if (_verbose) {
 506            print_oom_reasons(st);
 507          } else {
 508            return;  // that&#39;s enough for the screen
 509          }
 510          break;
 511        case INTERNAL_ERROR:
 512        default:
 513          break;
 514      }
 515 
 516   STEP(&quot;printing exception/signal name&quot;)
 517 
 518      st-&gt;print_cr(&quot;#&quot;);
 519      st-&gt;print(&quot;#  &quot;);
 520      // Is it an OS exception/signal?
 521      if (os::exception_name(_id, buf, sizeof(buf))) {
 522        st-&gt;print(&quot;%s&quot;, buf);
 523        st-&gt;print(&quot; (0x%x)&quot;, _id);                // signal number
 524        st-&gt;print(&quot; at pc=&quot; PTR_FORMAT, p2i(_pc));
 525        if (_siginfo != NULL &amp;&amp; os::signal_sent_by_kill(_siginfo)) {
 526          st-&gt;print(&quot; (sent by kill)&quot;);
 527        }
 528      } else {
 529        if (should_report_bug(_id)) {
 530          st-&gt;print(&quot;Internal Error&quot;);
 531        } else {
 532          st-&gt;print(&quot;Out of Memory Error&quot;);
 533        }
 534        if (_filename != NULL &amp;&amp; _lineno &gt; 0) {
 535 #ifdef PRODUCT
 536          // In product mode chop off pathname?
 537          char separator = os::file_separator()[0];
 538          const char *p = strrchr(_filename, separator);
 539          const char *file = p ? p+1 : _filename;
 540 #else
 541          const char *file = _filename;
 542 #endif
 543          st-&gt;print(&quot; (%s:%d)&quot;, file, _lineno);
 544        } else {
 545          st-&gt;print(&quot; (0x%x)&quot;, _id);
 546        }
 547      }
 548 
 549   STEP(&quot;printing current thread and pid&quot;)
 550 
 551      // process id, thread id
 552      st-&gt;print(&quot;, pid=%d&quot;, os::current_process_id());
 553      st-&gt;print(&quot;, tid=&quot; UINTX_FORMAT, os::current_thread_id());
 554      st-&gt;cr();
 555 
 556   STEP(&quot;printing error message&quot;)
 557 
 558      if (should_report_bug(_id)) {  // already printed the message.
 559        // error message
 560        if (strlen(_detail_msg) &gt; 0) {
 561          st-&gt;print_cr(&quot;#  %s: %s&quot;, _message ? _message : &quot;Error&quot;, _detail_msg);
 562        } else if (_message) {
 563          st-&gt;print_cr(&quot;#  Error: %s&quot;, _message);
 564        }
 565      }
 566 
 567   STEP(&quot;printing Java version string&quot;)
 568 
 569      report_vm_version(st, buf, sizeof(buf));
 570 
 571   STEP(&quot;printing problematic frame&quot;)
 572 
 573      // Print current frame if we have a context (i.e. it&#39;s a crash)
 574      if (_context) {
 575        st-&gt;print_cr(&quot;# Problematic frame:&quot;);
 576        st-&gt;print(&quot;# &quot;);
 577        frame fr = os::fetch_frame_from_context(_context);
 578        fr.print_on_error(st, buf, sizeof(buf));
 579        st-&gt;cr();
 580        st-&gt;print_cr(&quot;#&quot;);
 581      }
 582 
 583   STEP(&quot;printing core file information&quot;)
 584     st-&gt;print(&quot;# &quot;);
 585     if (CreateCoredumpOnCrash) {
 586       if (coredump_status) {
 587         st-&gt;print(&quot;Core dump will be written. Default location: %s&quot;, coredump_message);
 588       } else {
 589         st-&gt;print(&quot;No core dump will be written. %s&quot;, coredump_message);
 590       }
 591     } else {
 592       st-&gt;print(&quot;CreateCoredumpOnCrash turned off, no core file dumped&quot;);
 593     }
 594     st-&gt;cr();
 595     st-&gt;print_cr(&quot;#&quot;);
 596 
 597   STEP(&quot;printing bug submit message&quot;)
 598 
 599      if (should_report_bug(_id) &amp;&amp; _verbose) {
 600        print_bug_submit_message(st, _thread);
 601      }
 602 
 603   STEP(&quot;printing summary&quot;)
 604 
 605      if (_verbose) {
 606        st-&gt;cr();
 607        st-&gt;print_cr(&quot;---------------  S U M M A R Y ------------&quot;);
 608        st-&gt;cr();
 609      }
 610 
 611   STEP(&quot;printing VM option summary&quot;)
 612 
 613      if (_verbose) {
 614        // VM options
 615        Arguments::print_summary_on(st);
 616        st-&gt;cr();
 617      }
 618 
 619   STEP(&quot;printing summary machine and OS info&quot;)
 620 
 621      if (_verbose) {
 622        os::print_summary_info(st, buf, sizeof(buf));
 623      }
 624 
 625 
 626   STEP(&quot;printing date and time&quot;)
 627 
 628      if (_verbose) {
 629        os::print_date_and_time(st, buf, sizeof(buf));
 630      }
 631 
 632   STEP(&quot;printing thread&quot;)
 633 
 634      if (_verbose) {
 635        st-&gt;cr();
 636        st-&gt;print_cr(&quot;---------------  T H R E A D  ---------------&quot;);
 637        st-&gt;cr();
 638      }
 639 
 640   STEP(&quot;printing current thread&quot;)
 641 
 642      // current thread
 643      if (_verbose) {
 644        if (_thread) {
 645          st-&gt;print(&quot;Current thread (&quot; PTR_FORMAT &quot;):  &quot;, p2i(_thread));
 646          _thread-&gt;print_on_error(st, buf, sizeof(buf));
 647          st-&gt;cr();
 648        } else {
 649          st-&gt;print_cr(&quot;Current thread is native thread&quot;);
 650        }
 651        st-&gt;cr();
 652      }
 653 
 654   STEP(&quot;printing current compile task&quot;)
 655 
 656      if (_verbose &amp;&amp; _thread &amp;&amp; _thread-&gt;is_Compiler_thread()) {
 657         CompilerThread* t = (CompilerThread*)_thread;
 658         if (t-&gt;task()) {
 659            st-&gt;cr();
 660            st-&gt;print_cr(&quot;Current CompileTask:&quot;);
 661            t-&gt;task()-&gt;print_line_on_error(st, buf, sizeof(buf));
 662            st-&gt;cr();
 663         }
 664      }
 665 
 666 
 667   STEP(&quot;printing stack bounds&quot;)
 668 
 669      if (_verbose) {
 670        st-&gt;print(&quot;Stack: &quot;);
 671 
 672        address stack_top;
 673        size_t stack_size;
 674 
 675        if (_thread) {
 676           stack_top = _thread-&gt;stack_base();
 677           stack_size = _thread-&gt;stack_size();
 678        } else {
 679           stack_top = os::current_stack_base();
 680           stack_size = os::current_stack_size();
 681        }
 682 
 683        address stack_bottom = stack_top - stack_size;
 684        st-&gt;print(&quot;[&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;]&quot;, p2i(stack_bottom), p2i(stack_top));
 685 
 686        frame fr = _context ? os::fetch_frame_from_context(_context)
 687                            : os::current_frame();
 688 
 689        if (fr.sp()) {
 690          st-&gt;print(&quot;,  sp=&quot; PTR_FORMAT, p2i(fr.sp()));
 691          size_t free_stack_size = pointer_delta(fr.sp(), stack_bottom, 1024);
 692          st-&gt;print(&quot;,  free space=&quot; SIZE_FORMAT &quot;k&quot;, free_stack_size);
 693        }
 694 
 695        st-&gt;cr();
 696      }
 697 
 698   STEP(&quot;printing native stack&quot;)
 699 
 700    if (_verbose) {
 701      if (os::platform_print_native_stack(st, _context, buf, sizeof(buf))) {
 702        // We have printed the native stack in platform-specific code
 703        // Windows/x64 needs special handling.
 704      } else {
 705        frame fr = _context ? os::fetch_frame_from_context(_context)
 706                            : os::current_frame();
 707 
 708        print_native_stack(st, fr, _thread, buf, sizeof(buf));
 709      }
 710    }
 711 
 712   STEP(&quot;printing Java stack&quot;)
 713 
 714      if (_verbose &amp;&amp; _thread &amp;&amp; _thread-&gt;is_Java_thread()) {
 715        print_stack_trace(st, (JavaThread*)_thread, buf, sizeof(buf));
 716      }
 717 
 718   STEP(&quot;printing target Java thread stack&quot;)
 719 
 720      // printing Java thread stack trace if it is involved in GC crash
 721      if (_verbose &amp;&amp; _thread &amp;&amp; (_thread-&gt;is_Named_thread())) {
 722        JavaThread*  jt = ((NamedThread *)_thread)-&gt;processed_thread();
 723        if (jt != NULL) {
 724          st-&gt;print_cr(&quot;JavaThread &quot; PTR_FORMAT &quot; (nid = %d) was being processed&quot;, p2i(jt), jt-&gt;osthread()-&gt;thread_id());
 725          print_stack_trace(st, jt, buf, sizeof(buf), true);
 726        }
 727      }
 728 
 729   STEP(&quot;printing siginfo&quot;)
 730 
 731      // signal no, signal code, address that caused the fault
 732      if (_verbose &amp;&amp; _siginfo) {
 733        st-&gt;cr();
 734        os::print_siginfo(st, _siginfo);
 735        st-&gt;cr();
 736      }
 737 
 738   STEP(&quot;CDS archive access warning&quot;)
 739 
 740      // Print an explicit hint if we crashed on access to the CDS archive.
 741      if (_verbose &amp;&amp; _siginfo) {
 742        check_failing_cds_access(st, _siginfo);
 743        st-&gt;cr();
 744      }
 745 
 746   STEP(&quot;printing register info&quot;)
 747 
 748      // decode register contents if possible
 749      if (_verbose &amp;&amp; _context &amp;&amp; Universe::is_fully_initialized()) {
 750        os::print_register_info(st, _context);
 751        st-&gt;cr();
 752      }
 753 
 754   STEP(&quot;printing registers, top of stack, instructions near pc&quot;)
 755 
 756      // registers, top of stack, instructions near pc
 757      if (_verbose &amp;&amp; _context) {
 758        os::print_context(st, _context);
 759        st-&gt;cr();
 760      }
 761 
 762   STEP(&quot;inspecting top of stack&quot;)
 763 
 764      // decode stack contents if possible
 765      if (_verbose &amp;&amp; _context &amp;&amp; Universe::is_fully_initialized()) {
 766        frame fr = os::fetch_frame_from_context(_context);
 767        const int slots = 8;
 768        const intptr_t *start = fr.sp();
 769        const intptr_t *end = start + slots;
 770        if (is_aligned(start, sizeof(intptr_t)) &amp;&amp; os::is_readable_range(start, end)) {
 771          st-&gt;print_cr(&quot;Stack slot to memory mapping:&quot;);
 772          for (int i = 0; i &lt; slots; ++i) {
 773            st-&gt;print(&quot;stack at sp + %d slots: &quot;, i);
 774            os::print_location(st, *(start + i));
 775          }
 776        }
 777        st-&gt;cr();
 778      }
 779 
 780   STEP(&quot;printing code blob if possible&quot;)
 781 
 782      if (_verbose &amp;&amp; _context) {
 783        CodeBlob* cb = CodeCache::find_blob(_pc);
 784        if (cb != NULL) {
 785          if (Interpreter::contains(_pc)) {
 786            // The interpreter CodeBlob is very large so try to print the codelet instead.
 787            InterpreterCodelet* codelet = Interpreter::codelet_containing(_pc);
 788            if (codelet != NULL) {
 789              codelet-&gt;print_on(st);
 790              Disassembler::decode(codelet-&gt;code_begin(), codelet-&gt;code_end(), st);
 791            }
 792          } else {
 793            StubCodeDesc* desc = StubCodeDesc::desc_for(_pc);
 794            if (desc != NULL) {
 795              desc-&gt;print_on(st);
 796              Disassembler::decode(desc-&gt;begin(), desc-&gt;end(), st);
 797            } else if (_thread != NULL) {
 798              // Disassembling nmethod will incur resource memory allocation,
 799              // only do so when thread is valid.
 800              ResourceMark rm(_thread);
 801              Disassembler::decode(cb, st);
 802              st-&gt;cr();
 803            }
 804          }
 805        }
 806      }
 807 
 808   STEP(&quot;printing VM operation&quot;)
 809 
 810      if (_verbose &amp;&amp; _thread &amp;&amp; _thread-&gt;is_VM_thread()) {
 811         VMThread* t = (VMThread*)_thread;
 812         VM_Operation* op = t-&gt;vm_operation();
 813         if (op) {
 814           op-&gt;print_on_error(st);
 815           st-&gt;cr();
 816           st-&gt;cr();
 817         }
 818      }
 819 
 820   STEP(&quot;printing process&quot;)
 821 
 822      if (_verbose) {
 823        st-&gt;cr();
 824        st-&gt;print_cr(&quot;---------------  P R O C E S S  ---------------&quot;);
 825        st-&gt;cr();
 826      }
 827 
 828 #ifndef _WIN32
 829   STEP(&quot;printing user info&quot;)
 830 
 831      if (ExtensiveErrorReports &amp;&amp; _verbose) {
 832        os::Posix::print_user_info(st);
 833      }
 834 #endif
 835 
 836   STEP(&quot;printing all threads&quot;)
 837 
 838      // all threads
 839      if (_verbose &amp;&amp; _thread) {
 840        Threads::print_on_error(st, _thread, buf, sizeof(buf));
 841        st-&gt;cr();
 842      }
 843 
 844   STEP(&quot;printing VM state&quot;)
 845 
 846      if (_verbose) {
 847        // Safepoint state
 848        st-&gt;print(&quot;VM state:&quot;);
 849 
 850        if (SafepointSynchronize::is_synchronizing()) st-&gt;print(&quot;synchronizing&quot;);
 851        else if (SafepointSynchronize::is_at_safepoint()) st-&gt;print(&quot;at safepoint&quot;);
 852        else st-&gt;print(&quot;not at safepoint&quot;);
 853 
 854        // Also see if error occurred during initialization or shutdown
 855        if (!Universe::is_fully_initialized()) {
 856          st-&gt;print(&quot; (not fully initialized)&quot;);
 857        } else if (VM_Exit::vm_exited()) {
 858          st-&gt;print(&quot; (shutting down)&quot;);
 859        } else {
 860          st-&gt;print(&quot; (normal execution)&quot;);
 861        }
 862        st-&gt;cr();
 863        st-&gt;cr();
 864      }
 865 
 866   STEP(&quot;printing owned locks on error&quot;)
 867 
 868      // mutexes/monitors that currently have an owner
 869      if (_verbose) {
 870        print_owned_locks_on_error(st);
 871        st-&gt;cr();
 872      }
 873 
 874   STEP(&quot;printing number of OutOfMemoryError and StackOverflow exceptions&quot;)
 875 
 876      if (_verbose &amp;&amp; Exceptions::has_exception_counts()) {
 877        st-&gt;print_cr(&quot;OutOfMemory and StackOverflow Exception counts:&quot;);
 878        Exceptions::print_exception_counts_on_error(st);
 879        st-&gt;cr();
 880      }
 881 
 882   STEP(&quot;printing compressed oops mode&quot;)
 883 
 884      if (_verbose &amp;&amp; UseCompressedOops) {
<a name="14" id="anc14"></a><span class="line-modified"> 885        Universe::print_compressed_oops_mode(st);</span>
 886        if (UseCompressedClassPointers) {
 887          Metaspace::print_compressed_class_space(st);
 888        }
 889        st-&gt;cr();
 890      }
 891 
 892   STEP(&quot;printing heap information&quot;)
 893 
 894      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 895        Universe::heap()-&gt;print_on_error(st);
 896        st-&gt;cr();
 897        st-&gt;print_cr(&quot;Polling page: &quot; INTPTR_FORMAT, p2i(os::get_polling_page()));
 898        st-&gt;cr();
 899      }
 900 
 901   STEP(&quot;printing metaspace information&quot;)
 902 
 903      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 904        st-&gt;print_cr(&quot;Metaspace:&quot;);
 905        MetaspaceUtils::print_basic_report(st, 0);
 906      }
 907 
 908   STEP(&quot;printing code cache information&quot;)
 909 
 910      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 911        // print code cache information before vm abort
 912        CodeCache::print_summary(st);
 913        st-&gt;cr();
 914      }
 915 
 916   STEP(&quot;printing ring buffers&quot;)
 917 
 918      if (_verbose) {
 919        Events::print_all(st);
 920        st-&gt;cr();
 921      }
 922 
 923   STEP(&quot;printing dynamic libraries&quot;)
 924 
 925      if (_verbose) {
 926        // dynamic libraries, or memory map
 927        os::print_dll_info(st);
 928        st-&gt;cr();
 929      }
 930 
 931   STEP(&quot;printing native decoder state&quot;)
 932 
 933      if (_verbose) {
 934        Decoder::print_state_on(st);
 935        st-&gt;cr();
 936      }
 937 
 938   STEP(&quot;printing VM options&quot;)
 939 
 940      if (_verbose) {
 941        // VM options
 942        Arguments::print_on(st);
 943        st-&gt;cr();
 944      }
 945 
 946   STEP(&quot;printing flags&quot;)
 947 
 948     if (_verbose) {
 949       JVMFlag::printFlags(
 950         st,
 951         true, // with comments
 952         false, // no ranges
 953         true); // skip defaults
 954       st-&gt;cr();
 955     }
 956 
 957   STEP(&quot;printing warning if internal testing API used&quot;)
 958 
 959      if (WhiteBox::used()) {
 960        st-&gt;print_cr(&quot;Unsupported internal testing APIs have been used.&quot;);
 961        st-&gt;cr();
 962      }
 963 
 964   STEP(&quot;printing log configuration&quot;)
 965     if (_verbose){
 966       st-&gt;print_cr(&quot;Logging:&quot;);
 967       LogConfiguration::describe_current_configuration(st);
 968       st-&gt;cr();
 969     }
 970 
 971   STEP(&quot;printing all environment variables&quot;)
 972 
 973      if (_verbose) {
 974        os::print_environment_variables(st, env_list);
 975        st-&gt;cr();
 976      }
 977 
 978   STEP(&quot;printing signal handlers&quot;)
 979 
 980      if (_verbose) {
 981        os::print_signal_handlers(st, buf, sizeof(buf));
 982        st-&gt;cr();
 983      }
 984 
 985   STEP(&quot;Native Memory Tracking&quot;)
 986      if (_verbose) {
 987        MemTracker::error_report(st);
 988      }
 989 
 990   STEP(&quot;printing system&quot;)
 991 
 992      if (_verbose) {
 993        st-&gt;cr();
 994        st-&gt;print_cr(&quot;---------------  S Y S T E M  ---------------&quot;);
 995        st-&gt;cr();
 996      }
 997 
 998   STEP(&quot;printing OS information&quot;)
 999 
1000      if (_verbose) {
1001        os::print_os_info(st);
1002        st-&gt;cr();
1003      }
1004 
1005   STEP(&quot;printing CPU info&quot;)
1006      if (_verbose) {
1007        os::print_cpu_info(st, buf, sizeof(buf));
1008        st-&gt;cr();
1009      }
1010 
1011   STEP(&quot;printing memory info&quot;)
1012 
1013      if (_verbose) {
1014        os::print_memory_info(st);
1015        st-&gt;cr();
1016      }
1017 
1018   STEP(&quot;printing internal vm info&quot;)
1019 
1020      if (_verbose) {
1021        st-&gt;print_cr(&quot;vm_info: %s&quot;, VM_Version::internal_vm_info_string());
1022        st-&gt;cr();
1023      }
1024 
1025   // print a defined marker to show that error handling finished correctly.
1026   STEP(&quot;printing end marker&quot;)
1027 
1028      if (_verbose) {
1029        st-&gt;print_cr(&quot;END.&quot;);
1030      }
1031 
1032   END
1033 
1034 # undef BEGIN
1035 # undef STEP
1036 # undef END
1037 }
1038 
1039 // Report for the vm_info_cmd. This prints out the information above omitting
1040 // crash and thread specific information.  If output is added above, it should be added
1041 // here also, if it is safe to call during a running process.
1042 void VMError::print_vm_info(outputStream* st) {
1043 
1044   char buf[O_BUFLEN];
1045   report_vm_version(st, buf, sizeof(buf));
1046 
1047   // STEP(&quot;printing summary&quot;)
1048 
1049   st-&gt;cr();
1050   st-&gt;print_cr(&quot;---------------  S U M M A R Y ------------&quot;);
1051   st-&gt;cr();
1052 
1053   // STEP(&quot;printing VM option summary&quot;)
1054 
1055   // VM options
1056   Arguments::print_summary_on(st);
1057   st-&gt;cr();
1058 
1059   // STEP(&quot;printing summary machine and OS info&quot;)
1060 
1061   os::print_summary_info(st, buf, sizeof(buf));
1062 
1063   // STEP(&quot;printing date and time&quot;)
1064 
1065   os::print_date_and_time(st, buf, sizeof(buf));
1066 
1067   // Skip: STEP(&quot;printing thread&quot;)
1068 
1069   // STEP(&quot;printing process&quot;)
1070 
1071   st-&gt;cr();
1072   st-&gt;print_cr(&quot;---------------  P R O C E S S  ---------------&quot;);
1073   st-&gt;cr();
1074 
1075   // STEP(&quot;printing number of OutOfMemoryError and StackOverflow exceptions&quot;)
1076 
1077   if (Exceptions::has_exception_counts()) {
1078     st-&gt;print_cr(&quot;OutOfMemory and StackOverflow Exception counts:&quot;);
1079     Exceptions::print_exception_counts_on_error(st);
1080     st-&gt;cr();
1081   }
1082 
1083   // STEP(&quot;printing compressed oops mode&quot;)
1084 
1085   if (UseCompressedOops) {
<a name="15" id="anc15"></a><span class="line-modified">1086     Universe::print_compressed_oops_mode(st);</span>
1087     if (UseCompressedClassPointers) {
1088       Metaspace::print_compressed_class_space(st);
1089     }
1090     st-&gt;cr();
1091   }
1092 
1093   // STEP(&quot;printing heap information&quot;)
1094 
1095   if (Universe::is_fully_initialized()) {
1096     MutexLocker hl(Heap_lock);
1097     Universe::heap()-&gt;print_on_error(st);
1098     st-&gt;cr();
1099     st-&gt;print_cr(&quot;Polling page: &quot; INTPTR_FORMAT, p2i(os::get_polling_page()));
1100     st-&gt;cr();
1101   }
1102 
1103   // STEP(&quot;printing metaspace information&quot;)
1104 
1105   if (Universe::is_fully_initialized()) {
1106     st-&gt;print_cr(&quot;Metaspace:&quot;);
1107     MetaspaceUtils::print_basic_report(st, 0);
1108   }
1109 
1110   // STEP(&quot;printing code cache information&quot;)
1111 
1112   if (Universe::is_fully_initialized()) {
1113     // print code cache information before vm abort
1114     CodeCache::print_summary(st);
1115     st-&gt;cr();
1116   }
1117 
1118   // STEP(&quot;printing ring buffers&quot;)
1119 
1120   Events::print_all(st);
1121   st-&gt;cr();
1122 
1123   // STEP(&quot;printing dynamic libraries&quot;)
1124 
1125   // dynamic libraries, or memory map
1126   os::print_dll_info(st);
1127   st-&gt;cr();
1128 
1129   // STEP(&quot;printing VM options&quot;)
1130 
1131   // VM options
1132   Arguments::print_on(st);
1133   st-&gt;cr();
1134 
1135   // STEP(&quot;printing warning if internal testing API used&quot;)
1136 
1137   if (WhiteBox::used()) {
1138     st-&gt;print_cr(&quot;Unsupported internal testing APIs have been used.&quot;);
1139     st-&gt;cr();
1140   }
1141 
1142   // STEP(&quot;printing log configuration&quot;)
1143   st-&gt;print_cr(&quot;Logging:&quot;);
1144   LogConfiguration::describe(st);
1145   st-&gt;cr();
1146 
1147   // STEP(&quot;printing all environment variables&quot;)
1148 
1149   os::print_environment_variables(st, env_list);
1150   st-&gt;cr();
1151 
1152   // STEP(&quot;printing signal handlers&quot;)
1153 
1154   os::print_signal_handlers(st, buf, sizeof(buf));
1155   st-&gt;cr();
1156 
1157   // STEP(&quot;Native Memory Tracking&quot;)
1158 
1159   MemTracker::error_report(st);
1160 
1161   // STEP(&quot;printing system&quot;)
1162 
1163   st-&gt;cr();
1164   st-&gt;print_cr(&quot;---------------  S Y S T E M  ---------------&quot;);
1165   st-&gt;cr();
1166 
1167   // STEP(&quot;printing OS information&quot;)
1168 
1169   os::print_os_info(st);
1170   st-&gt;cr();
1171 
1172   // STEP(&quot;printing CPU info&quot;)
1173 
1174   os::print_cpu_info(st, buf, sizeof(buf));
1175   st-&gt;cr();
1176 
1177   // STEP(&quot;printing memory info&quot;)
1178 
1179   os::print_memory_info(st);
1180   st-&gt;cr();
1181 
1182   // STEP(&quot;printing internal vm info&quot;)
1183 
1184   st-&gt;print_cr(&quot;vm_info: %s&quot;, VM_Version::internal_vm_info_string());
1185   st-&gt;cr();
1186 
1187   // print a defined marker to show that error handling finished correctly.
1188   // STEP(&quot;printing end marker&quot;)
1189 
1190   st-&gt;print_cr(&quot;END.&quot;);
1191 }
1192 
<a name="16" id="anc16"></a><span class="line-modified">1193 volatile intptr_t VMError::first_error_tid = -1;</span>
1194 
1195 /** Expand a pattern into a buffer starting at pos and open a file using constructed path */
<a name="17" id="anc17"></a><span class="line-modified">1196 static int expand_and_open(const char* pattern, char* buf, size_t buflen, size_t pos) {</span>
1197   int fd = -1;
<a name="18" id="anc18"></a>





1198   if (Arguments::copy_expand_pid(pattern, strlen(pattern), &amp;buf[pos], buflen - pos)) {
<a name="19" id="anc19"></a><span class="line-modified">1199     // the O_EXCL flag will cause the open to fail if the file exists</span>
<span class="line-removed">1200     fd = open(buf, O_RDWR | O_CREAT | O_EXCL, 0666);</span>
1201   }
1202   return fd;
1203 }
1204 
1205 /**
1206  * Construct file name for a log file and return it&#39;s file descriptor.
1207  * Name and location depends on pattern, default_pattern params and access
1208  * permissions.
1209  */
<a name="20" id="anc20"></a><span class="line-modified">1210 static int prepare_log_file(const char* pattern, const char* default_pattern, char* buf, size_t buflen) {</span>
1211   int fd = -1;
1212 
1213   // If possible, use specified pattern to construct log file name
1214   if (pattern != NULL) {
<a name="21" id="anc21"></a><span class="line-modified">1215     fd = expand_and_open(pattern, buf, buflen, 0);</span>
1216   }
1217 
1218   // Either user didn&#39;t specify, or the user&#39;s location failed,
1219   // so use the default name in the current directory
1220   if (fd == -1) {
1221     const char* cwd = os::get_current_directory(buf, buflen);
1222     if (cwd != NULL) {
1223       size_t pos = strlen(cwd);
1224       int fsep_len = jio_snprintf(&amp;buf[pos], buflen-pos, &quot;%s&quot;, os::file_separator());
1225       pos += fsep_len;
1226       if (fsep_len &gt; 0) {
<a name="22" id="anc22"></a><span class="line-modified">1227         fd = expand_and_open(default_pattern, buf, buflen, pos);</span>
1228       }
1229     }
1230   }
1231 
1232    // try temp directory if it exists.
1233    if (fd == -1) {
1234      const char* tmpdir = os::get_temp_directory();
1235      if (tmpdir != NULL &amp;&amp; strlen(tmpdir) &gt; 0) {
1236        int pos = jio_snprintf(buf, buflen, &quot;%s%s&quot;, tmpdir, os::file_separator());
1237        if (pos &gt; 0) {
<a name="23" id="anc23"></a><span class="line-modified">1238          fd = expand_and_open(default_pattern, buf, buflen, pos);</span>
1239        }
1240      }
1241    }
1242 
1243   return fd;
1244 }
1245 
1246 int         VMError::_id;
1247 const char* VMError::_message;
1248 char        VMError::_detail_msg[1024];
1249 Thread*     VMError::_thread;
1250 address     VMError::_pc;
1251 void*       VMError::_siginfo;
1252 void*       VMError::_context;
1253 const char* VMError::_filename;
1254 int         VMError::_lineno;
1255 size_t      VMError::_size;
1256 
1257 void VMError::report_and_die(Thread* thread, unsigned int sig, address pc, void* siginfo,
1258                              void* context, const char* detail_fmt, ...)
1259 {
1260   va_list detail_args;
1261   va_start(detail_args, detail_fmt);
1262   report_and_die(sig, NULL, detail_fmt, detail_args, thread, pc, siginfo, context, NULL, 0, 0);
1263   va_end(detail_args);
1264 }
1265 
1266 void VMError::report_and_die(Thread* thread, unsigned int sig, address pc, void* siginfo, void* context)
1267 {
1268   report_and_die(thread, sig, pc, siginfo, context, &quot;%s&quot;, &quot;&quot;);
1269 }
1270 
1271 void VMError::report_and_die(const char* message, const char* detail_fmt, ...)
1272 {
1273   va_list detail_args;
1274   va_start(detail_args, detail_fmt);
1275   report_and_die(INTERNAL_ERROR, message, detail_fmt, detail_args, NULL, NULL, NULL, NULL, NULL, 0, 0);
1276   va_end(detail_args);
1277 }
1278 
1279 void VMError::report_and_die(const char* message)
1280 {
1281   report_and_die(message, &quot;%s&quot;, &quot;&quot;);
1282 }
1283 
1284 void VMError::report_and_die(Thread* thread, void* context, const char* filename, int lineno, const char* message,
1285                              const char* detail_fmt, va_list detail_args)
1286 {
1287   report_and_die(INTERNAL_ERROR, message, detail_fmt, detail_args, thread, NULL, NULL, context, filename, lineno, 0);
1288 }
1289 
1290 void VMError::report_and_die(Thread* thread, const char* filename, int lineno, size_t size,
1291                              VMErrorType vm_err_type, const char* detail_fmt, va_list detail_args) {
1292   report_and_die(vm_err_type, NULL, detail_fmt, detail_args, thread, NULL, NULL, NULL, filename, lineno, size);
1293 }
1294 
1295 void VMError::report_and_die(int id, const char* message, const char* detail_fmt, va_list detail_args,
1296                              Thread* thread, address pc, void* siginfo, void* context, const char* filename,
1297                              int lineno, size_t size)
1298 {
1299   // A single scratch buffer to be used from here on.
1300   // Do not rely on it being preserved across function calls.
1301   static char buffer[O_BUFLEN];
1302 
1303   // File descriptor to tty to print an error summary to.
1304   // Hard wired to stdout; see JDK-8215004 (compatibility concerns).
1305   static const int fd_out = 1; // stdout
1306 
1307   // File descriptor to the error log file.
1308   static int fd_log = -1;
1309 
<a name="24" id="anc24"></a>





1310   // Use local fdStream objects only. Do not use global instances whose initialization
1311   // relies on dynamic initialization (see JDK-8214975). Do not rely on these instances
1312   // to carry over into recursions or invocations from other threads.
1313   fdStream out(fd_out);
1314   out.set_scratch_buffer(buffer, sizeof(buffer));
1315 
1316   // Depending on the re-entrance depth at this point, fd_log may be -1 or point to an open hs-err file.
1317   fdStream log(fd_log);
1318   log.set_scratch_buffer(buffer, sizeof(buffer));
1319 
1320   // How many errors occurred in error handler when reporting first_error.
1321   static int recursive_error_count;
1322 
1323   // We will first print a brief message to standard out (verbose = false),
1324   // then save detailed information in log file (verbose = true).
1325   static bool out_done = false;         // done printing to standard out
1326   static bool log_done = false;         // done saving error log
1327 
1328   if (SuppressFatalErrorMessage) {
1329       os::abort(CreateCoredumpOnCrash);
1330   }
1331   intptr_t mytid = os::current_thread_id();
<a name="25" id="anc25"></a><span class="line-modified">1332   if (first_error_tid == -1 &amp;&amp;</span>
<span class="line-modified">1333       Atomic::cmpxchg(mytid, &amp;first_error_tid, (intptr_t)-1) == -1) {</span>
1334 
1335     // Initialize time stamps to use the same base.
1336     out.time_stamp().update_to(1);
1337     log.time_stamp().update_to(1);
1338 
1339     _id = id;
1340     _message = message;
1341     _thread = thread;
1342     _pc = pc;
1343     _siginfo = siginfo;
1344     _context = context;
1345     _filename = filename;
1346     _lineno = lineno;
1347     _size = size;
1348     jio_vsnprintf(_detail_msg, sizeof(_detail_msg), detail_fmt, detail_args);
1349 
1350     // first time
1351     _error_reported = true;
1352 
1353     reporting_started();
<a name="26" id="anc26"></a><span class="line-modified">1354     record_reporting_start_time();</span>







1355 
1356     if (ShowMessageBoxOnError || PauseAtExit) {
1357       show_message_box(buffer, sizeof(buffer));
1358 
1359       // User has asked JVM to abort. Reset ShowMessageBoxOnError so the
1360       // WatcherThread can kill JVM if the error handler hangs.
1361       ShowMessageBoxOnError = false;
1362     }
1363 
1364     os::check_dump_limit(buffer, sizeof(buffer));
1365 
1366     // reset signal handlers or exception filter; make sure recursive crashes
1367     // are handled properly.
1368     reset_signal_handlers();
1369 
1370     EventShutdown e;
1371     if (e.should_commit()) {
1372       e.set_reason(&quot;VM Error&quot;);
1373       e.commit();
1374     }
1375 
1376     JFR_ONLY(Jfr::on_vm_shutdown(true);)
1377 
1378   } else {
1379     // If UseOsErrorReporting we call this for each level of the call stack
1380     // while searching for the exception handler.  Only the first level needs
1381     // to be reported.
1382     if (UseOSErrorReporting &amp;&amp; log_done) return;
1383 
1384     // This is not the first error, see if it happened in a different thread
1385     // or in the same thread during error reporting.
<a name="27" id="anc27"></a><span class="line-modified">1386     if (first_error_tid != mytid) {</span>
1387       char msgbuf[64];
1388       jio_snprintf(msgbuf, sizeof(msgbuf),
1389                    &quot;[thread &quot; INTX_FORMAT &quot; also had an error]&quot;,
1390                    mytid);
1391       out.print_raw_cr(msgbuf);
1392 
1393       // error reporting is not MT-safe, block current thread
1394       os::infinite_sleep();
1395 
1396     } else {
1397       if (recursive_error_count++ &gt; 30) {
1398         out.print_raw_cr(&quot;[Too many errors, abort]&quot;);
1399         os::die();
1400       }
1401 
1402       outputStream* const st = log.is_open() ? &amp;log : &amp;out;
1403       st-&gt;cr();
1404 
1405       // Timeout handling.
1406       if (_step_did_timeout) {
1407         // The current step had a timeout. Lets continue reporting with the next step.
1408         st-&gt;print_raw(&quot;[timeout occurred during error reporting in step \&quot;&quot;);
1409         st-&gt;print_raw(_current_step_info);
1410         st-&gt;print_cr(&quot;\&quot;] after &quot; INT64_FORMAT &quot; s.&quot;,
1411                      (int64_t)
1412                      ((get_current_timestamp() - _step_start_time) / TIMESTAMP_TO_SECONDS_FACTOR));
1413       } else if (_reporting_did_timeout) {
1414         // We hit ErrorLogTimeout. Reporting will stop altogether. Let&#39;s wrap things
1415         // up, the process is about to be stopped by the WatcherThread.
1416         st-&gt;print_cr(&quot;------ Timeout during error reporting after &quot; INT64_FORMAT &quot; s. ------&quot;,
1417                      (int64_t)
1418                      ((get_current_timestamp() - _reporting_start_time) / TIMESTAMP_TO_SECONDS_FACTOR));
1419         st-&gt;flush();
1420         // Watcherthread is about to call os::die. Lets just wait.
1421         os::infinite_sleep();
1422       } else {
1423         // Crash or assert during error reporting. Lets continue reporting with the next step.
1424         stringStream ss(buffer, sizeof(buffer));
1425         // Note: this string does get parsed by a number of jtreg tests,
1426         // see hotspot/jtreg/runtime/ErrorHandling.
1427         ss.print(&quot;[error occurred during error reporting (%s), id 0x%x&quot;,
1428                    _current_step_info, id);
1429         char signal_name[64];
1430         if (os::exception_name(id, signal_name, sizeof(signal_name))) {
1431           ss.print(&quot;, %s (0x%x) at pc=&quot; PTR_FORMAT, signal_name, id, p2i(pc));
1432         } else {
1433           if (should_report_bug(id)) {
1434             ss.print(&quot;, Internal Error (%s:%d)&quot;,
1435               filename == NULL ? &quot;??&quot; : filename, lineno);
1436           } else {
1437             ss.print(&quot;, Out of Memory Error (%s:%d)&quot;,
1438               filename == NULL ? &quot;??&quot; : filename, lineno);
1439           }
1440         }
1441         ss.print(&quot;]&quot;);
1442         st-&gt;print_raw_cr(buffer);
1443         st-&gt;cr();
1444       }
1445     }
1446   }
1447 
<a name="28" id="anc28"></a><span class="line-modified">1448   // print to screen</span>
1449   if (!out_done) {
<a name="29" id="anc29"></a><span class="line-modified">1450     report(&amp;out, false);</span>




1451 
1452     out_done = true;
1453 
1454     _current_step = 0;
1455     _current_step_info = &quot;&quot;;
1456   }
1457 
<a name="30" id="anc30"></a>
1458   // print to error log file
1459   if (!log_done) {
1460     // see if log file is already open
1461     if (!log.is_open()) {
1462       // open log file
<a name="31" id="anc31"></a><span class="line-modified">1463       fd_log = prepare_log_file(ErrorFile, &quot;hs_err_pid%p.log&quot;, buffer, sizeof(buffer));</span>
<span class="line-modified">1464       if (fd_log != -1) {</span>
<span class="line-modified">1465         out.print_raw(&quot;# An error report file with more information is saved as:\n# &quot;);</span>
<span class="line-modified">1466         out.print_raw_cr(buffer);</span>
<span class="line-removed">1467 </span>
<span class="line-removed">1468         log.set_fd(fd_log);</span>
1469       } else {
<a name="32" id="anc32"></a><span class="line-modified">1470         out.print_raw_cr(&quot;# Can not save log file, dump to screen..&quot;);</span>
<span class="line-modified">1471         log.set_fd(fd_out);</span>







1472       }
<a name="33" id="anc33"></a>
1473     }
1474 
1475     report(&amp;log, true);
1476     log_done = true;
1477     _current_step = 0;
1478     _current_step_info = &quot;&quot;;
1479 
<a name="34" id="anc34"></a><span class="line-modified">1480     if (fd_log != -1) {</span>
1481       close(fd_log);
1482       fd_log = -1;
1483     }
1484 
1485     log.set_fd(-1);
1486   }
1487 
<a name="35" id="anc35"></a>




1488   static bool skip_replay = ReplayCompiles; // Do not overwrite file during replay
1489   if (DumpReplayDataOnError &amp;&amp; _thread &amp;&amp; _thread-&gt;is_Compiler_thread() &amp;&amp; !skip_replay) {
1490     skip_replay = true;
1491     ciEnv* env = ciEnv::current();
1492     if (env != NULL) {
<a name="36" id="anc36"></a><span class="line-modified">1493       int fd = prepare_log_file(ReplayDataFile, &quot;replay_pid%p.log&quot;, buffer, sizeof(buffer));</span>

1494       if (fd != -1) {
1495         FILE* replay_data_file = os::open(fd, &quot;w&quot;);
1496         if (replay_data_file != NULL) {
1497           fileStream replay_data_stream(replay_data_file, /*need_close=*/true);
1498           env-&gt;dump_replay_data_unsafe(&amp;replay_data_stream);
1499           out.print_raw(&quot;#\n# Compiler replay data is saved as:\n# &quot;);
1500           out.print_raw_cr(buffer);
1501         } else {
1502           int e = errno;
1503           out.print_raw(&quot;#\n# Can&#39;t open file to dump replay data. Error: &quot;);
1504           out.print_raw_cr(os::strerror(e));
1505         }
1506       }
1507     }
1508   }
1509 
1510   static bool skip_bug_url = !should_report_bug(_id);
1511   if (!skip_bug_url) {
1512     skip_bug_url = true;
1513 
1514     out.print_raw_cr(&quot;#&quot;);
1515     print_bug_submit_message(&amp;out, _thread);
1516   }
1517 
1518   static bool skip_OnError = false;
1519   if (!skip_OnError &amp;&amp; OnError &amp;&amp; OnError[0]) {
1520     skip_OnError = true;
1521 
1522     // Flush output and finish logs before running OnError commands.
1523     ostream_abort();
1524 
1525     out.print_raw_cr(&quot;#&quot;);
1526     out.print_raw   (&quot;# -XX:OnError=\&quot;&quot;);
1527     out.print_raw   (OnError);
1528     out.print_raw_cr(&quot;\&quot;&quot;);
1529 
1530     char* cmd;
1531     const char* ptr = OnError;
1532     while ((cmd = next_OnError_command(buffer, sizeof(buffer), &amp;ptr)) != NULL){
1533       out.print_raw   (&quot;#   Executing &quot;);
1534 #if defined(LINUX) || defined(_ALLBSD_SOURCE)
1535       out.print_raw   (&quot;/bin/sh -c &quot;);
1536 #elif defined(SOLARIS)
1537       out.print_raw   (&quot;/usr/bin/sh -c &quot;);
1538 #elif defined(_WINDOWS)
1539       out.print_raw   (&quot;cmd /C &quot;);
1540 #endif
1541       out.print_raw   (&quot;\&quot;&quot;);
1542       out.print_raw   (cmd);
1543       out.print_raw_cr(&quot;\&quot; ...&quot;);
1544 
1545       if (os::fork_and_exec(cmd) &lt; 0) {
1546         out.print_cr(&quot;os::fork_and_exec failed: %s (%s=%d)&quot;,
1547                      os::strerror(errno), os::errno_name(errno), errno);
1548       }
1549     }
1550 
1551     // done with OnError
1552     OnError = NULL;
1553   }
1554 
1555   if (!UseOSErrorReporting) {
1556     // os::abort() will call abort hooks, try it first.
1557     static bool skip_os_abort = false;
1558     if (!skip_os_abort) {
1559       skip_os_abort = true;
1560       bool dump_core = should_report_bug(_id);
1561       os::abort(dump_core &amp;&amp; CreateCoredumpOnCrash, _siginfo, _context);
1562     }
1563 
1564     // if os::abort() doesn&#39;t abort, try os::die();
1565     os::die();
1566   }
1567 }
1568 
1569 /*
1570  * OnOutOfMemoryError scripts/commands executed while VM is a safepoint - this
1571  * ensures utilities such as jmap can observe the process is a consistent state.
1572  */
1573 class VM_ReportJavaOutOfMemory : public VM_Operation {
1574  private:
1575   const char* _message;
1576  public:
1577   VM_ReportJavaOutOfMemory(const char* message) { _message = message; }
1578   VMOp_Type type() const                        { return VMOp_ReportJavaOutOfMemory; }
1579   void doit();
1580 };
1581 
1582 void VM_ReportJavaOutOfMemory::doit() {
1583   // Don&#39;t allocate large buffer on stack
1584   static char buffer[O_BUFLEN];
1585 
1586   tty-&gt;print_cr(&quot;#&quot;);
1587   tty-&gt;print_cr(&quot;# java.lang.OutOfMemoryError: %s&quot;, _message);
1588   tty-&gt;print_cr(&quot;# -XX:OnOutOfMemoryError=\&quot;%s\&quot;&quot;, OnOutOfMemoryError);
1589 
1590   // make heap parsability
1591   Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
1592 
1593   char* cmd;
1594   const char* ptr = OnOutOfMemoryError;
1595   while ((cmd = next_OnError_command(buffer, sizeof(buffer), &amp;ptr)) != NULL){
1596     tty-&gt;print(&quot;#   Executing &quot;);
1597 #if defined(LINUX)
1598     tty-&gt;print  (&quot;/bin/sh -c &quot;);
1599 #elif defined(SOLARIS)
1600     tty-&gt;print  (&quot;/usr/bin/sh -c &quot;);
1601 #endif
1602     tty-&gt;print_cr(&quot;\&quot;%s\&quot;...&quot;, cmd);
1603 
1604     if (os::fork_and_exec(cmd, true) &lt; 0) {
1605       tty-&gt;print_cr(&quot;os::fork_and_exec failed: %s (%s=%d)&quot;,
1606                      os::strerror(errno), os::errno_name(errno), errno);
1607     }
1608   }
1609 }
1610 
1611 void VMError::report_java_out_of_memory(const char* message) {
1612   if (OnOutOfMemoryError &amp;&amp; OnOutOfMemoryError[0]) {
1613     MutexLocker ml(Heap_lock);
1614     VM_ReportJavaOutOfMemory op(message);
1615     VMThread::execute(&amp;op);
1616   }
1617 }
1618 
1619 void VMError::show_message_box(char *buf, int buflen) {
1620   bool yes;
1621   do {
1622     error_string(buf, buflen);
1623     yes = os::start_debugging(buf,buflen);
1624   } while (yes);
1625 }
1626 
1627 // Timeout handling: check if a timeout happened (either a single step did
1628 // timeout or the whole of error reporting hit ErrorLogTimeout). Interrupt
1629 // the reporting thread if that is the case.
1630 bool VMError::check_timeout() {
1631 
1632   if (ErrorLogTimeout == 0) {
1633     return false;
1634   }
1635 
1636   // Do not check for timeouts if we still have a message box to show to the
1637   // user or if there are OnError handlers to be run.
1638   if (ShowMessageBoxOnError
1639       || (OnError != NULL &amp;&amp; OnError[0] != &#39;\0&#39;)
1640       || Arguments::abort_hook() != NULL) {
1641     return false;
1642   }
1643 
1644   const jlong reporting_start_time_l = get_reporting_start_time();
1645   const jlong now = get_current_timestamp();
1646   // Timestamp is stored in nanos.
1647   if (reporting_start_time_l &gt; 0) {
1648     const jlong end = reporting_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR;
<a name="37" id="anc37"></a><span class="line-modified">1649     if (end &lt;= now) {</span>


1650       _reporting_did_timeout = true;
1651       interrupt_reporting_thread();
1652       return true; // global timeout
1653     }
1654   }
1655 
1656   const jlong step_start_time_l = get_step_start_time();
1657   if (step_start_time_l &gt; 0) {
1658     // A step times out after a quarter of the total timeout. Steps are mostly fast unless they
1659     // hang for some reason, so this simple rule allows for three hanging step and still
1660     // hopefully leaves time enough for the rest of the steps to finish.
1661     const jlong end = step_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR / 4;
<a name="38" id="anc38"></a><span class="line-modified">1662     if (end &lt;= now) {</span>


1663       _step_did_timeout = true;
1664       interrupt_reporting_thread();
1665       return false; // (Not a global timeout)
1666     }
1667   }
1668 
1669   return false;
1670 
1671 }
1672 
1673 #ifndef PRODUCT
1674 #if defined(__SUNPRO_CC) &amp;&amp; __SUNPRO_CC &gt;= 0x5140
1675 #pragma error_messages(off, SEC_NULL_PTR_DEREF)
1676 #endif
1677 typedef void (*voidfun_t)();
1678 // Crash with an authentic sigfpe
1679 static void crash_with_sigfpe() {
1680   // generate a native synchronous SIGFPE where possible;
1681   // if that did not cause a signal (e.g. on ppc), just
1682   // raise the signal.
1683   volatile int x = 0;
1684   volatile int y = 1/x;
1685 #ifndef _WIN32
1686   // OSX implements raise(sig) incorrectly so we need to
1687   // explicitly target the current thread
1688   pthread_kill(pthread_self(), SIGFPE);
1689 #endif
1690 } // end: crash_with_sigfpe
1691 
1692 // crash with sigsegv at non-null address.
1693 static void crash_with_segfault() {
1694 
1695   char* const crash_addr = (char*) VMError::get_segfault_address();
1696   *crash_addr = &#39;X&#39;;
1697 
1698 } // end: crash_with_segfault
1699 
1700 void VMError::test_error_handler() {
1701   controlled_crash(ErrorHandlerTest);
1702 }
1703 
1704 // crash in a controlled way:
1705 // how can be one of:
1706 // 1,2 - asserts
1707 // 3,4 - guarantee
1708 // 5-7 - fatal
1709 // 8 - vm_exit_out_of_memory
1710 // 9 - ShouldNotCallThis
1711 // 10 - ShouldNotReachHere
1712 // 11 - Unimplemented
1713 // 12,13 - (not guaranteed) crashes
1714 // 14 - SIGSEGV
1715 // 15 - SIGFPE
1716 void VMError::controlled_crash(int how) {
1717   if (how == 0) return;
1718 
1719   // If asserts are disabled, use the corresponding guarantee instead.
1720   NOT_DEBUG(if (how &lt;= 2) how += 2);
1721 
1722   const char* const str = &quot;hello&quot;;
1723   const size_t      num = (size_t)os::vm_page_size();
1724 
1725   const char* const eol = os::line_separator();
1726   const char* const msg = &quot;this message should be truncated during formatting&quot;;
1727   char * const dataPtr = NULL;  // bad data pointer
<a name="39" id="anc39"></a><span class="line-modified">1728   const void (*funcPtr)(void) = (const void(*)()) 0xF;  // bad function pointer</span>









1729 
1730   // Keep this in sync with test/hotspot/jtreg/runtime/ErrorHandling/ErrorHandler.java
1731   // which tests cases 1 thru 13.
1732   // Case 14 is tested by test/hotspot/jtreg/runtime/ErrorHandling/SafeFetchInErrorHandlingTest.java.
1733   // Case 15 is tested by test/hotspot/jtreg/runtime/ErrorHandling/SecondaryErrorTest.java.
1734   // Case 16 is tested by test/hotspot/jtreg/runtime/ErrorHandling/ThreadsListHandleInErrorHandlingTest.java.
1735   // Case 17 is tested by test/hotspot/jtreg/runtime/ErrorHandling/NestedThreadsListHandleInErrorHandlingTest.java.
1736 
<a name="40" id="anc40"></a><span class="line-modified">1737   // We grab Threads_lock to keep ThreadsSMRSupport::print_info_on()</span>
1738   // from racing with Threads::add() or Threads::remove() as we
1739   // generate the hs_err_pid file. This makes our ErrorHandling tests
1740   // more stable.
<a name="41" id="anc41"></a><span class="line-modified">1741   MutexLockerEx ml(Threads_lock-&gt;owned_by_self() ? NULL : Threads_lock, Mutex::_no_safepoint_check_flag);</span>



1742 
1743   switch (how) {
1744     case  1: vmassert(str == NULL, &quot;expected null&quot;); break;
1745     case  2: vmassert(num == 1023 &amp;&amp; *str == &#39;X&#39;,
1746                       &quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
1747     case  3: guarantee(str == NULL, &quot;expected null&quot;); break;
1748     case  4: guarantee(num == 1023 &amp;&amp; *str == &#39;X&#39;,
1749                        &quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
1750     case  5: fatal(&quot;expected null&quot;); break;
1751     case  6: fatal(&quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
1752     case  7: fatal(&quot;%s%s#    %s%s#    %s%s#    %s%s#    %s%s#    &quot;
1753                    &quot;%s%s#    %s%s#    %s%s#    %s%s#    %s%s#    &quot;
1754                    &quot;%s%s#    %s%s#    %s%s#    %s%s#    %s&quot;,
1755                    msg, eol, msg, eol, msg, eol, msg, eol, msg, eol,
1756                    msg, eol, msg, eol, msg, eol, msg, eol, msg, eol,
1757                    msg, eol, msg, eol, msg, eol, msg, eol, msg); break;
1758     case  8: vm_exit_out_of_memory(num, OOM_MALLOC_ERROR, &quot;ChunkPool::allocate&quot;); break;
1759     case  9: ShouldNotCallThis(); break;
1760     case 10: ShouldNotReachHere(); break;
1761     case 11: Unimplemented(); break;
1762     // There&#39;s no guarantee the bad data pointer will crash us
1763     // so &quot;break&quot; out to the ShouldNotReachHere().
1764     case 12: *dataPtr = &#39;\0&#39;; break;
1765     // There&#39;s no guarantee the bad function pointer will crash us
1766     // so &quot;break&quot; out to the ShouldNotReachHere().
1767     case 13: (*funcPtr)(); break;
1768     case 14: crash_with_segfault(); break;
1769     case 15: crash_with_sigfpe(); break;
1770     case 16: {
1771       ThreadsListHandle tlh;
1772       fatal(&quot;Force crash with an active ThreadsListHandle.&quot;);
1773     }
1774     case 17: {
1775       ThreadsListHandle tlh;
1776       {
1777         ThreadsListHandle tlh2;
1778         fatal(&quot;Force crash with a nested ThreadsListHandle.&quot;);
1779       }
1780     }
1781 
1782     default: tty-&gt;print_cr(&quot;ERROR: %d: unexpected test_num value.&quot;, how);
1783   }
1784   tty-&gt;print_cr(&quot;VMError::controlled_crash: survived intentional crash. Did you suppress the assert?&quot;);
1785   ShouldNotReachHere();
1786 }
1787 #endif // !PRODUCT
<a name="42" id="anc42"></a><span class="line-removed">1788 </span>
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>
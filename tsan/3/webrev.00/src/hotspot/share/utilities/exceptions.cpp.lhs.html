<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/exceptions.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;compiler/compileBroker.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;logging/logStream.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
<a name="1" id="anc1"></a>
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/init.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;runtime/javaCalls.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;runtime/thread.inline.hpp&quot;
 39 #include &quot;runtime/threadCritical.hpp&quot;
 40 #include &quot;runtime/atomic.hpp&quot;
 41 #include &quot;utilities/events.hpp&quot;
 42 #include &quot;utilities/exceptions.hpp&quot;
 43 
 44 // Implementation of ThreadShadow
 45 void check_ThreadShadow() {
 46   const ByteSize offset1 = byte_offset_of(ThreadShadow, _pending_exception);
 47   const ByteSize offset2 = Thread::pending_exception_offset();
 48   if (offset1 != offset2) fatal(&quot;ThreadShadow::_pending_exception is not positioned correctly&quot;);
 49 }
 50 
 51 
 52 void ThreadShadow::set_pending_exception(oop exception, const char* file, int line) {
 53   assert(exception != NULL &amp;&amp; oopDesc::is_oop(exception), &quot;invalid exception oop&quot;);
 54   _pending_exception = exception;
 55   _exception_file    = file;
 56   _exception_line    = line;
 57 }
 58 
 59 void ThreadShadow::clear_pending_exception() {
 60   LogTarget(Debug, exceptions) lt;
 61   if (_pending_exception != NULL &amp;&amp; lt.is_enabled()) {
 62     ResourceMark rm;
 63     LogStream ls(lt);
 64     ls.print(&quot;Thread::clear_pending_exception: cleared exception:&quot;);
 65     _pending_exception-&gt;print_on(&amp;ls);
 66   }
 67   _pending_exception = NULL;
 68   _exception_file    = NULL;
 69   _exception_line    = 0;
 70 }
 71 // Implementation of Exceptions
 72 
 73 bool Exceptions::special_exception(Thread* thread, const char* file, int line, Handle h_exception) {
 74   // bootstrapping check
 75   if (!Universe::is_fully_initialized()) {
 76    vm_exit_during_initialization(h_exception);
 77    ShouldNotReachHere();
 78   }
 79 
 80 #ifdef ASSERT
 81   // Check for trying to throw stack overflow before initialization is complete
 82   // to prevent infinite recursion trying to initialize stack overflow without
 83   // adequate stack space.
 84   // This can happen with stress testing a large value of StackShadowPages
 85   if (h_exception()-&gt;klass() == SystemDictionary::StackOverflowError_klass()) {
 86     InstanceKlass* ik = InstanceKlass::cast(h_exception-&gt;klass());
 87     assert(ik-&gt;is_initialized(),
 88            &quot;need to increase java_thread_min_stack_allowed calculation&quot;);
 89   }
 90 #endif // ASSERT
 91 
 92   if (thread-&gt;is_VM_thread()
 93       || !thread-&gt;can_call_java()) {
 94     // We do not care what kind of exception we get for the vm-thread or a thread which
 95     // is compiling.  We just install a dummy exception object
 96     thread-&gt;set_pending_exception(Universe::vm_exception(), file, line);
 97     return true;
 98   }
 99 
100   return false;
101 }
102 
103 bool Exceptions::special_exception(Thread* thread, const char* file, int line, Symbol* h_name, const char* message) {
104   // bootstrapping check
105   if (!Universe::is_fully_initialized()) {
106     if (h_name == NULL) {
107       // atleast an informative message.
108       vm_exit_during_initialization(&quot;Exception&quot;, message);
109     } else {
110       vm_exit_during_initialization(h_name, message);
111     }
112     ShouldNotReachHere();
113   }
114 
115   if (thread-&gt;is_VM_thread()
116       || !thread-&gt;can_call_java()) {
117     // We do not care what kind of exception we get for the vm-thread or a thread which
118     // is compiling.  We just install a dummy exception object
119     thread-&gt;set_pending_exception(Universe::vm_exception(), file, line);
120     return true;
121   }
122   return false;
123 }
124 
125 // This method should only be called from generated code,
126 // therefore the exception oop should be in the oopmap.
127 void Exceptions::_throw_oop(Thread* thread, const char* file, int line, oop exception) {
128   assert(exception != NULL, &quot;exception should not be NULL&quot;);
129   Handle h_exception(thread, exception);
130   _throw(thread, file, line, h_exception);
131 }
132 
133 void Exceptions::_throw(Thread* thread, const char* file, int line, Handle h_exception, const char* message) {
134   ResourceMark rm(thread);
135   assert(h_exception() != NULL, &quot;exception should not be NULL&quot;);
136 
137   // tracing (do this up front - so it works during boot strapping)
138   // Note, the print_value_string() argument is not called unless logging is enabled!
139   log_info(exceptions)(&quot;Exception &lt;%s%s%s&gt; (&quot; INTPTR_FORMAT &quot;) \n&quot;
140                        &quot;thrown [%s, line %d]\nfor thread &quot; INTPTR_FORMAT,
141                        h_exception-&gt;print_value_string(),
142                        message ? &quot;: &quot; : &quot;&quot;, message ? message : &quot;&quot;,
143                        p2i(h_exception()), file, line, p2i(thread));
144 
145   // for AbortVMOnException flag
146   Exceptions::debug_check_abort(h_exception, message);
147 
148   // Check for special boot-strapping/vm-thread handling
149   if (special_exception(thread, file, line, h_exception)) {
150     return;
151   }
152 
153   if (h_exception-&gt;is_a(SystemDictionary::OutOfMemoryError_klass())) {
154     count_out_of_memory_exceptions(h_exception);
155   }
156 
157   if (h_exception-&gt;is_a(SystemDictionary::LinkageError_klass())) {
158     Atomic::inc(&amp;_linkage_errors);
159   }
160 
161   assert(h_exception-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;exception is not a subclass of java/lang/Throwable&quot;);
162 
163   // set the pending exception
164   thread-&gt;set_pending_exception(h_exception(), file, line);
165 
166   // vm log
167   Events::log_exception(thread, h_exception, message, file, line);
168 }
169 
170 
171 void Exceptions::_throw_msg(Thread* thread, const char* file, int line, Symbol* name, const char* message,
172                             Handle h_loader, Handle h_protection_domain) {
173   // Check for special boot-strapping/vm-thread handling
174   if (special_exception(thread, file, line, name, message)) return;
175   // Create and throw exception
176   Handle h_cause(thread, NULL);
177   Handle h_exception = new_exception(thread, name, message, h_cause, h_loader, h_protection_domain);
178   _throw(thread, file, line, h_exception, message);
179 }
180 
181 void Exceptions::_throw_msg_cause(Thread* thread, const char* file, int line, Symbol* name, const char* message, Handle h_cause,
182                                   Handle h_loader, Handle h_protection_domain) {
183   // Check for special boot-strapping/vm-thread handling
184   if (special_exception(thread, file, line, name, message)) return;
185   // Create and throw exception and init cause
186   Handle h_exception = new_exception(thread, name, message, h_cause, h_loader, h_protection_domain);
187   _throw(thread, file, line, h_exception, message);
188 }
189 
190 void Exceptions::_throw_cause(Thread* thread, const char* file, int line, Symbol* name, Handle h_cause,
191                               Handle h_loader, Handle h_protection_domain) {
192   // Check for special boot-strapping/vm-thread handling
193   if (special_exception(thread, file, line, h_cause)) return;
194   // Create and throw exception
195   Handle h_exception = new_exception(thread, name, h_cause, h_loader, h_protection_domain);
196   _throw(thread, file, line, h_exception, NULL);
197 }
198 
199 void Exceptions::_throw_args(Thread* thread, const char* file, int line, Symbol* name, Symbol* signature, JavaCallArguments *args) {
200   // Check for special boot-strapping/vm-thread handling
201   if (special_exception(thread, file, line, name, NULL)) return;
202   // Create and throw exception
203   Handle h_loader(thread, NULL);
204   Handle h_prot(thread, NULL);
205   Handle exception = new_exception(thread, name, signature, args, h_loader, h_prot);
206   _throw(thread, file, line, exception);
207 }
208 
209 
210 // Methods for default parameters.
211 // NOTE: These must be here (and not in the header file) because of include circularities.
212 void Exceptions::_throw_msg_cause(Thread* thread, const char* file, int line, Symbol* name, const char* message, Handle h_cause) {
213   _throw_msg_cause(thread, file, line, name, message, h_cause, Handle(thread, NULL), Handle(thread, NULL));
214 }
215 void Exceptions::_throw_msg(Thread* thread, const char* file, int line, Symbol* name, const char* message) {
216   _throw_msg(thread, file, line, name, message, Handle(thread, NULL), Handle(thread, NULL));
217 }
218 void Exceptions::_throw_cause(Thread* thread, const char* file, int line, Symbol* name, Handle h_cause) {
219   _throw_cause(thread, file, line, name, h_cause, Handle(thread, NULL), Handle(thread, NULL));
220 }
221 
222 
223 void Exceptions::throw_stack_overflow_exception(Thread* THREAD, const char* file, int line, const methodHandle&amp; method) {
224   Handle exception;
225   if (!THREAD-&gt;has_pending_exception()) {
226     InstanceKlass* k = SystemDictionary::StackOverflowError_klass();
227     oop e = k-&gt;allocate_instance(CHECK);
228     exception = Handle(THREAD, e);  // fill_in_stack trace does gc
229     assert(k-&gt;is_initialized(), &quot;need to increase java_thread_min_stack_allowed calculation&quot;);
230     if (StackTraceInThrowable) {
<a name="2" id="anc2"></a><span class="line-modified">231       java_lang_Throwable::fill_in_stack_trace(exception, method());</span>
232     }
233     // Increment counter for hs_err file reporting
234     Atomic::inc(&amp;Exceptions::_stack_overflow_errors);
235   } else {
236     // if prior exception, throw that one instead
237     exception = Handle(THREAD, THREAD-&gt;pending_exception());
238   }
239   _throw(THREAD, file, line, exception);
240 }
241 
242 void Exceptions::fthrow(Thread* thread, const char* file, int line, Symbol* h_name, const char* format, ...) {
243   const int max_msg_size = 1024;
244   va_list ap;
245   va_start(ap, format);
246   char msg[max_msg_size];
247   os::vsnprintf(msg, max_msg_size, format, ap);
248   va_end(ap);
249   _throw_msg(thread, file, line, h_name, msg);
250 }
251 
252 
253 // Creates an exception oop, calls the &lt;init&gt; method with the given signature.
254 // and returns a Handle
255 Handle Exceptions::new_exception(Thread *thread, Symbol* name,
256                                  Symbol* signature, JavaCallArguments *args,
257                                  Handle h_loader, Handle h_protection_domain) {
258   assert(Universe::is_fully_initialized(),
259     &quot;cannot be called during initialization&quot;);
260   assert(thread-&gt;is_Java_thread(), &quot;can only be called by a Java thread&quot;);
261   assert(!thread-&gt;has_pending_exception(), &quot;already has exception&quot;);
262 
263   Handle h_exception;
264 
265   // Resolve exception klass, and check for pending exception below.
266   Klass* klass = SystemDictionary::resolve_or_fail(name, h_loader, h_protection_domain, true, thread);
267 
268   if (!thread-&gt;has_pending_exception()) {
269     assert(klass != NULL, &quot;klass must exist&quot;);
270     h_exception = JavaCalls::construct_new_instance(InstanceKlass::cast(klass),
271                                 signature,
272                                 args,
273                                 thread);
274   }
275 
276   // Check if another exception was thrown in the process, if so rethrow that one
277   if (thread-&gt;has_pending_exception()) {
278     h_exception = Handle(thread, thread-&gt;pending_exception());
279     thread-&gt;clear_pending_exception();
280   }
281   return h_exception;
282 }
283 
284 // Creates an exception oop, calls the &lt;init&gt; method with the given signature.
285 // and returns a Handle
286 // Initializes the cause if cause non-null
287 Handle Exceptions::new_exception(Thread *thread, Symbol* name,
288                                  Symbol* signature, JavaCallArguments *args,
289                                  Handle h_cause,
290                                  Handle h_loader, Handle h_protection_domain) {
291   Handle h_exception = new_exception(thread, name, signature, args, h_loader, h_protection_domain);
292 
293   // Future: object initializer should take a cause argument
294   if (h_cause.not_null()) {
295     assert(h_cause-&gt;is_a(SystemDictionary::Throwable_klass()),
296         &quot;exception cause is not a subclass of java/lang/Throwable&quot;);
297     JavaValue result1(T_OBJECT);
298     JavaCallArguments args1;
299     args1.set_receiver(h_exception);
300     args1.push_oop(h_cause);
301     JavaCalls::call_virtual(&amp;result1, h_exception-&gt;klass(),
302                                       vmSymbols::initCause_name(),
303                                       vmSymbols::throwable_throwable_signature(),
304                                       &amp;args1,
305                                       thread);
306   }
307 
308   // Check if another exception was thrown in the process, if so rethrow that one
309   if (thread-&gt;has_pending_exception()) {
310     h_exception = Handle(thread, thread-&gt;pending_exception());
311     thread-&gt;clear_pending_exception();
312   }
313   return h_exception;
314 }
315 
316 // Convenience method. Calls either the &lt;init&gt;() or &lt;init&gt;(Throwable) method when
317 // creating a new exception
318 Handle Exceptions::new_exception(Thread* thread, Symbol* name,
319                                  Handle h_cause,
320                                  Handle h_loader, Handle h_protection_domain,
321                                  ExceptionMsgToUtf8Mode to_utf8_safe) {
322   JavaCallArguments args;
323   Symbol* signature = NULL;
324   if (h_cause.is_null()) {
325     signature = vmSymbols::void_method_signature();
326   } else {
327     signature = vmSymbols::throwable_void_signature();
328     args.push_oop(h_cause);
329   }
330   return new_exception(thread, name, signature, &amp;args, h_loader, h_protection_domain);
331 }
332 
333 // Convenience method. Calls either the &lt;init&gt;() or &lt;init&gt;(String) method when
334 // creating a new exception
335 Handle Exceptions::new_exception(Thread* thread, Symbol* name,
336                                  const char* message, Handle h_cause,
337                                  Handle h_loader, Handle h_protection_domain,
338                                  ExceptionMsgToUtf8Mode to_utf8_safe) {
339   JavaCallArguments args;
340   Symbol* signature = NULL;
341   if (message == NULL) {
342     signature = vmSymbols::void_method_signature();
343   } else {
344     // We want to allocate storage, but we can&#39;t do that if there&#39;s
345     // a pending exception, so we preserve any pending exception
346     // around the allocation.
347     // If we get an exception from the allocation, prefer that to
348     // the exception we are trying to build, or the pending exception.
349     // This is sort of like what PRESERVE_EXCEPTION_MARK does, except
350     // for the preferencing and the early returns.
351     Handle incoming_exception(thread, NULL);
352     if (thread-&gt;has_pending_exception()) {
353       incoming_exception = Handle(thread, thread-&gt;pending_exception());
354       thread-&gt;clear_pending_exception();
355     }
356     Handle msg;
357     if (to_utf8_safe == safe_to_utf8) {
358       // Make a java UTF8 string.
359       msg = java_lang_String::create_from_str(message, thread);
360     } else {
361       // Make a java string keeping the encoding scheme of the original string.
362       msg = java_lang_String::create_from_platform_dependent_str(message, thread);
363     }
364     if (thread-&gt;has_pending_exception()) {
365       Handle exception(thread, thread-&gt;pending_exception());
366       thread-&gt;clear_pending_exception();
367       return exception;
368     }
369     if (incoming_exception.not_null()) {
370       return incoming_exception;
371     }
372     args.push_oop(msg);
373     signature = vmSymbols::string_void_signature();
374   }
375   return new_exception(thread, name, signature, &amp;args, h_cause, h_loader, h_protection_domain);
376 }
377 
378 // Another convenience method that creates handles for null class loaders and
379 // protection domains and null causes.
380 // If the last parameter &#39;to_utf8_mode&#39; is safe_to_utf8,
381 // it means we can safely ignore the encoding scheme of the message string and
382 // convert it directly to a java UTF8 string. Otherwise, we need to take the
383 // encoding scheme of the string into account. One thing we should do at some
384 // point is to push this flag down to class java_lang_String since other
385 // classes may need similar functionalities.
386 Handle Exceptions::new_exception(Thread* thread, Symbol* name,
387                                  const char* message,
388                                  ExceptionMsgToUtf8Mode to_utf8_safe) {
389 
390   Handle       h_loader(thread, NULL);
391   Handle       h_prot(thread, NULL);
392   Handle       h_cause(thread, NULL);
393   return Exceptions::new_exception(thread, name, message, h_cause, h_loader,
394                                    h_prot, to_utf8_safe);
395 }
396 
397 // invokedynamic uses wrap_dynamic_exception for:
398 //    - bootstrap method resolution
399 //    - post call to MethodHandleNatives::linkCallSite
400 // dynamically computed constant uses wrap_dynamic_exception for:
401 //    - bootstrap method resolution
402 //    - post call to MethodHandleNatives::linkDynamicConstant
403 void Exceptions::wrap_dynamic_exception(Thread* THREAD) {
404   if (THREAD-&gt;has_pending_exception()) {
405     oop exception = THREAD-&gt;pending_exception();
406     // See the &quot;Linking Exceptions&quot; section for the invokedynamic instruction
407     // in JVMS 6.5.
408     if (exception-&gt;is_a(SystemDictionary::Error_klass())) {
409       // Pass through an Error, including BootstrapMethodError, any other form
410       // of linkage error, or say ThreadDeath/OutOfMemoryError
411       if (TraceMethodHandles) {
412         tty-&gt;print_cr(&quot;bootstrap method invocation wraps BSME around &quot; INTPTR_FORMAT, p2i((void *)exception));
413         exception-&gt;print();
414       }
415       return;
416     }
417 
418     // Otherwise wrap the exception in a BootstrapMethodError
419     if (TraceMethodHandles) {
420       tty-&gt;print_cr(&quot;[constant/invoke]dynamic throws BSME for &quot; INTPTR_FORMAT, p2i((void *)exception));
421       exception-&gt;print();
422     }
423     Handle nested_exception(THREAD, exception);
424     THREAD-&gt;clear_pending_exception();
425     THROW_CAUSE(vmSymbols::java_lang_BootstrapMethodError(), nested_exception)
426   }
427 }
428 
429 // Exception counting for hs_err file
430 volatile int Exceptions::_stack_overflow_errors = 0;
431 volatile int Exceptions::_linkage_errors = 0;
432 volatile int Exceptions::_out_of_memory_error_java_heap_errors = 0;
433 volatile int Exceptions::_out_of_memory_error_metaspace_errors = 0;
434 volatile int Exceptions::_out_of_memory_error_class_metaspace_errors = 0;
435 
436 void Exceptions::count_out_of_memory_exceptions(Handle exception) {
<a name="3" id="anc3"></a><span class="line-modified">437   if (oopDesc::equals(exception(), Universe::out_of_memory_error_metaspace())) {</span>
438      Atomic::inc(&amp;_out_of_memory_error_metaspace_errors);
<a name="4" id="anc4"></a><span class="line-modified">439   } else if (oopDesc::equals(exception(), Universe::out_of_memory_error_class_metaspace())) {</span>
440      Atomic::inc(&amp;_out_of_memory_error_class_metaspace_errors);
441   } else {
442      // everything else reported as java heap OOM
443      Atomic::inc(&amp;_out_of_memory_error_java_heap_errors);
444   }
445 }
446 
447 void print_oom_count(outputStream* st, const char *err, int count) {
448   if (count &gt; 0) {
449     st-&gt;print_cr(&quot;OutOfMemoryError %s=%d&quot;, err, count);
450   }
451 }
452 
453 bool Exceptions::has_exception_counts() {
454   return (_stack_overflow_errors + _out_of_memory_error_java_heap_errors +
455          _out_of_memory_error_metaspace_errors + _out_of_memory_error_class_metaspace_errors) &gt; 0;
456 }
457 
458 void Exceptions::print_exception_counts_on_error(outputStream* st) {
459   print_oom_count(st, &quot;java_heap_errors&quot;, _out_of_memory_error_java_heap_errors);
460   print_oom_count(st, &quot;metaspace_errors&quot;, _out_of_memory_error_metaspace_errors);
461   print_oom_count(st, &quot;class_metaspace_errors&quot;, _out_of_memory_error_class_metaspace_errors);
462   if (_stack_overflow_errors &gt; 0) {
463     st-&gt;print_cr(&quot;StackOverflowErrors=%d&quot;, _stack_overflow_errors);
464   }
465   if (_linkage_errors &gt; 0) {
466     st-&gt;print_cr(&quot;LinkageErrors=%d&quot;, _linkage_errors);
467   }
468 }
469 
470 // Implementation of ExceptionMark
471 
472 ExceptionMark::ExceptionMark(Thread*&amp; thread) {
473   thread     = Thread::current();
474   _thread    = thread;
475   if (_thread-&gt;has_pending_exception()) {
476     oop exception = _thread-&gt;pending_exception();
477     _thread-&gt;clear_pending_exception(); // Needed to avoid infinite recursion
478     exception-&gt;print();
479     fatal(&quot;ExceptionMark constructor expects no pending exceptions&quot;);
480   }
481 }
482 
483 
484 ExceptionMark::~ExceptionMark() {
485   if (_thread-&gt;has_pending_exception()) {
486     Handle exception(_thread, _thread-&gt;pending_exception());
487     _thread-&gt;clear_pending_exception(); // Needed to avoid infinite recursion
488     if (is_init_completed()) {
489       exception-&gt;print();
490       fatal(&quot;ExceptionMark destructor expects no pending exceptions&quot;);
491     } else {
492       vm_exit_during_initialization(exception);
493     }
494   }
495 }
496 
497 // ----------------------------------------------------------------------------------------
498 
499 // caller frees value_string if necessary
500 void Exceptions::debug_check_abort(const char *value_string, const char* message) {
501   if (AbortVMOnException != NULL &amp;&amp; value_string != NULL &amp;&amp;
502       strstr(value_string, AbortVMOnException)) {
503     if (AbortVMOnExceptionMessage == NULL || (message != NULL &amp;&amp;
504         strstr(message, AbortVMOnExceptionMessage))) {
505       fatal(&quot;Saw %s, aborting&quot;, value_string);
506     }
507   }
508 }
509 
510 void Exceptions::debug_check_abort(Handle exception, const char* message) {
511   if (AbortVMOnException != NULL) {
512     debug_check_abort_helper(exception, message);
513   }
514 }
515 
516 void Exceptions::debug_check_abort_helper(Handle exception, const char* message) {
517   ResourceMark rm;
518   if (message == NULL &amp;&amp; exception-&gt;is_a(SystemDictionary::Throwable_klass())) {
519     oop msg = java_lang_Throwable::message(exception());
520     if (msg != NULL) {
521       message = java_lang_String::as_utf8_string(msg);
522     }
523   }
524   debug_check_abort(exception()-&gt;klass()-&gt;external_name(), message);
525 }
526 
527 // for logging exceptions
<a name="5" id="anc5"></a><span class="line-modified">528 void Exceptions::log_exception(Handle exception, stringStream tempst) {</span>
529   ResourceMark rm;
<a name="6" id="anc6"></a><span class="line-modified">530   Symbol* message = java_lang_Throwable::detail_message(exception());</span>
<span class="line-modified">531   if (message != NULL) {</span>
532     log_info(exceptions)(&quot;Exception &lt;%s: %s&gt;\n thrown in %s&quot;,
533                          exception-&gt;print_value_string(),
<a name="7" id="anc7"></a><span class="line-modified">534                          message-&gt;as_C_string(),</span>
<span class="line-modified">535                          tempst.as_string());</span>
536   } else {
537     log_info(exceptions)(&quot;Exception &lt;%s&gt;\n thrown in %s&quot;,
538                          exception-&gt;print_value_string(),
<a name="8" id="anc8"></a><span class="line-modified">539                          tempst.as_string());</span>
540   }
541 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
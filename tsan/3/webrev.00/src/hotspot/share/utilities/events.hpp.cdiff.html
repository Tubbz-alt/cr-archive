<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/events.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="events.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="exceptions.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/events.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,12 ---</span>
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/formatBuffer.hpp&quot;
<span class="line-added">+ #include &quot;utilities/globalDefinitions.hpp&quot;</span>
<span class="line-added">+ #include &quot;utilities/ostream.hpp&quot;</span>
  #include &quot;utilities/vmError.hpp&quot;
  
  // Events and EventMark provide interfaces to log events taking place in the vm.
  // This facility is extremly useful for post-mortem debugging. The eventlog
  // often provides crucial information about events leading up to the crash.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,11 ***</span>
   public:
    // Automatically registers the log so that it will be printed during
    // crashes.
    EventLog();
  
<span class="line-modified">!   virtual void print_log_on(outputStream* out) = 0;</span>
  };
  
  
  // A templated subclass of EventLog that provides basic ring buffer
  // functionality.  Most event loggers should subclass this, possibly
<span class="line-new-header">--- 59,19 ---</span>
   public:
    // Automatically registers the log so that it will be printed during
    // crashes.
    EventLog();
  
<span class="line-modified">!   // Print log to output stream.</span>
<span class="line-added">+   virtual void print_log_on(outputStream* out, int max = -1) = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Returns true if s matches either the log name or the log handle.</span>
<span class="line-added">+   virtual bool matches_name_or_handle(const char* s) const = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Print log names (for help output of VM.events).</span>
<span class="line-added">+   virtual void print_names(outputStream* out) const = 0;</span>
<span class="line-added">+ </span>
  };
  
  
  // A templated subclass of EventLog that provides basic ring buffer
  // functionality.  Most event loggers should subclass this, possibly
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,20 ***</span>
      X       data;
    };
  
   protected:
    Mutex           _mutex;
    const char*     _name;
    int             _length;
    int             _index;
    int             _count;
    EventRecord&lt;T&gt;* _records;
  
   public:
<span class="line-modified">!   EventLogBase&lt;T&gt;(const char* name, int length = LogEventsBufferEntries):</span>
<span class="line-modified">!     _mutex(Mutex::event, name, false, Monitor::_safepoint_check_never),</span>
      _name(name),
      _length(length),
      _index(0),
      _count(0) {
      _records = new EventRecord&lt;T&gt;[length];
    }
<span class="line-new-header">--- 86,25 ---</span>
      X       data;
    };
  
   protected:
    Mutex           _mutex;
<span class="line-added">+   // Name is printed out as a header.</span>
    const char*     _name;
<span class="line-added">+   // Handle is a short specifier used to select this particular event log</span>
<span class="line-added">+   // for printing (see VM.events command).</span>
<span class="line-added">+   const char*     _handle;</span>
    int             _length;
    int             _index;
    int             _count;
    EventRecord&lt;T&gt;* _records;
  
   public:
<span class="line-modified">!   EventLogBase&lt;T&gt;(const char* name, const char* handle, int length = LogEventsBufferEntries):</span>
<span class="line-modified">!     _mutex(Mutex::event, name, true, Mutex::_safepoint_check_never),</span>
      _name(name),
<span class="line-added">+     _handle(handle),</span>
      _length(length),
      _index(0),
      _count(0) {
      _records = new EventRecord&lt;T&gt;[length];
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 114,14 ***</span>
      // avoids mutating the ring buffer when printing the log.
      return !VMError::fatal_error_in_progress();
    }
  
    // Print the contents of the log
<span class="line-modified">!   void print_log_on(outputStream* out);</span>
  
   private:
<span class="line-modified">!   void print_log_impl(outputStream* out);</span>
  
    // Print a single element.  A templated implementation might need to
    // be declared by subclasses.
    void print(outputStream* out, T&amp; e);
  
<span class="line-new-header">--- 129,20 ---</span>
      // avoids mutating the ring buffer when printing the log.
      return !VMError::fatal_error_in_progress();
    }
  
    // Print the contents of the log
<span class="line-modified">!   void print_log_on(outputStream* out, int max = -1);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Returns true if s matches either the log name or the log handle.</span>
<span class="line-added">+   bool matches_name_or_handle(const char* s) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Print log names (for help output of VM.events).</span>
<span class="line-added">+   void print_names(outputStream* out) const;</span>
  
   private:
<span class="line-modified">!   void print_log_impl(outputStream* out, int max = -1);</span>
  
    // Print a single element.  A templated implementation might need to
    // be declared by subclasses.
    void print(outputStream* out, T&amp; e);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,30 ***</span>
  };
  
  // A simple wrapper class for fixed size text messages.
  template &lt;size_t bufsz&gt;
  class FormatStringLogMessage : public FormatBuffer&lt;bufsz&gt; {
<span class="line-removed">-  public:</span>
<span class="line-removed">-   // Wrap this buffer in a stringStream.</span>
<span class="line-removed">-   stringStream stream() {</span>
<span class="line-removed">-     return stringStream(this-&gt;_buf, this-&gt;size());</span>
<span class="line-removed">-   }</span>
  };
  typedef FormatStringLogMessage&lt;256&gt; StringLogMessage;
  typedef FormatStringLogMessage&lt;512&gt; ExtendedStringLogMessage;
  
  // A simple ring buffer of fixed size text messages.
  template &lt;size_t bufsz&gt;
  class FormatStringEventLog : public EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt; {
   public:
<span class="line-modified">!   FormatStringEventLog(const char* name, int count = LogEventsBufferEntries) : EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt;(name, count) {}</span>
  
    void logv(Thread* thread, const char* format, va_list ap) ATTRIBUTE_PRINTF(3, 0) {
      if (!this-&gt;should_log()) return;
  
      double timestamp = this-&gt;fetch_timestamp();
<span class="line-modified">!     MutexLockerEx ml(&amp;this-&gt;_mutex, Mutex::_no_safepoint_check_flag);</span>
      int index = this-&gt;compute_log_index();
      this-&gt;_records[index].thread = thread;
      this-&gt;_records[index].timestamp = timestamp;
      this-&gt;_records[index].data.printv(format, ap);
    }
<span class="line-new-header">--- 156,26 ---</span>
  };
  
  // A simple wrapper class for fixed size text messages.
  template &lt;size_t bufsz&gt;
  class FormatStringLogMessage : public FormatBuffer&lt;bufsz&gt; {
  };
  typedef FormatStringLogMessage&lt;256&gt; StringLogMessage;
  typedef FormatStringLogMessage&lt;512&gt; ExtendedStringLogMessage;
  
  // A simple ring buffer of fixed size text messages.
  template &lt;size_t bufsz&gt;
  class FormatStringEventLog : public EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt; {
   public:
<span class="line-modified">!   FormatStringEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)</span>
<span class="line-added">+    : EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt;(name, short_name, count) {}</span>
  
    void logv(Thread* thread, const char* format, va_list ap) ATTRIBUTE_PRINTF(3, 0) {
      if (!this-&gt;should_log()) return;
  
      double timestamp = this-&gt;fetch_timestamp();
<span class="line-modified">!     MutexLocker ml(&amp;this-&gt;_mutex, Mutex::_no_safepoint_check_flag);</span>
      int index = this-&gt;compute_log_index();
      this-&gt;_records[index].thread = thread;
      this-&gt;_records[index].timestamp = timestamp;
      this-&gt;_records[index].data.printv(format, ap);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,19 ***</span>
  class InstanceKlass;
  
  // Event log for class unloading events to materialize the class name in place in the log stream.
  class UnloadingEventLog : public EventLogBase&lt;StringLogMessage&gt; {
   public:
<span class="line-modified">!   UnloadingEventLog(const char* name, int count = LogEventsBufferEntries) : EventLogBase&lt;StringLogMessage&gt;(name, count) {}</span>
  
    void log(Thread* thread, InstanceKlass* ik);
  };
  
  // Event log for exceptions
  class ExceptionsEventLog : public ExtendedStringEventLog {
   public:
<span class="line-modified">!   ExceptionsEventLog(const char* name, int count = LogEventsBufferEntries) : ExtendedStringEventLog(name, count) {}</span>
  
    void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
  };
  
  
<span class="line-new-header">--- 193,21 ---</span>
  class InstanceKlass;
  
  // Event log for class unloading events to materialize the class name in place in the log stream.
  class UnloadingEventLog : public EventLogBase&lt;StringLogMessage&gt; {
   public:
<span class="line-modified">!   UnloadingEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)</span>
<span class="line-added">+    : EventLogBase&lt;StringLogMessage&gt;(name, short_name, count) {}</span>
  
    void log(Thread* thread, InstanceKlass* ik);
  };
  
  // Event log for exceptions
  class ExceptionsEventLog : public ExtendedStringEventLog {
   public:
<span class="line-modified">!   ExceptionsEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)</span>
<span class="line-added">+    : ExtendedStringEventLog(name, short_name, count) {}</span>
  
    void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
  };
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,11 ***</span>
    static StringEventLog* _redefinitions;
  
    // Class unloading events
    static UnloadingEventLog* _class_unloading;
   public:
<span class="line-modified">!   static void print_all(outputStream* out);</span>
  
    // Dump all events to the tty
    static void print();
  
    // Logs a generic message with timestamp and format as printf.
<span class="line-new-header">--- 231,17 ---</span>
    static StringEventLog* _redefinitions;
  
    // Class unloading events
    static UnloadingEventLog* _class_unloading;
   public:
<span class="line-modified">! </span>
<span class="line-added">+   // Print all event logs; limit number of events per event log to be printed with max</span>
<span class="line-added">+   // (max == -1 prints all events).</span>
<span class="line-added">+   static void print_all(outputStream* out, int max = -1);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Print a single event log specified by name or handle.</span>
<span class="line-added">+   static void print_one(outputStream* out, const char* log_name, int max = -1);</span>
  
    // Dump all events to the tty
    static void print();
  
    // Logs a generic message with timestamp and format as printf.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,91 ***</span>
    // Register default loggers
    static void init();
  };
  
  inline void Events::log(Thread* thread, const char* format, ...) {
<span class="line-modified">!   if (LogEvents) {</span>
      va_list ap;
      va_start(ap, format);
      _messages-&gt;logv(thread, format, ap);
      va_end(ap);
    }
  }
  
  inline void Events::log_exception(Thread* thread, const char* format, ...) {
<span class="line-modified">!   if (LogEvents) {</span>
      va_list ap;
      va_start(ap, format);
      _exceptions-&gt;logv(thread, format, ap);
      va_end(ap);
    }
  }
  
  inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {
<span class="line-modified">!   if (LogEvents) {</span>
      _exceptions-&gt;log(thread, h_exception, message, file, line);
    }
  }
  
  inline void Events::log_redefinition(Thread* thread, const char* format, ...) {
<span class="line-modified">!   if (LogEvents) {</span>
      va_list ap;
      va_start(ap, format);
      _redefinitions-&gt;logv(thread, format, ap);
      va_end(ap);
    }
  }
  
  inline void Events::log_class_unloading(Thread* thread, InstanceKlass* ik) {
<span class="line-modified">!   if (LogEvents) {</span>
      _class_unloading-&gt;log(thread, ik);
    }
  }
  
  inline void Events::log_deopt_message(Thread* thread, const char* format, ...) {
<span class="line-modified">!   if (LogEvents) {</span>
      va_list ap;
      va_start(ap, format);
      _deopt_messages-&gt;logv(thread, format, ap);
      va_end(ap);
    }
  }
  
<span class="line-removed">- </span>
  template &lt;class T&gt;
<span class="line-modified">! inline void EventLogBase&lt;T&gt;::print_log_on(outputStream* out) {</span>
    if (Thread::current_or_null() == NULL) {
      // Not yet attached? Don&#39;t try to use locking
<span class="line-modified">!     print_log_impl(out);</span>
    } else {
<span class="line-modified">!     MutexLockerEx ml(&amp;_mutex, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!     print_log_impl(out);</span>
    }
  }
  
  // Dump the ring buffer entries that current have entries.
  template &lt;class T&gt;
<span class="line-modified">! inline void EventLogBase&lt;T&gt;::print_log_impl(outputStream* out) {</span>
    out-&gt;print_cr(&quot;%s (%d events):&quot;, _name, _count);
    if (_count == 0) {
      out-&gt;print_cr(&quot;No events&quot;);
      out-&gt;cr();
      return;
    }
  
    if (_count &lt; _length) {
      for (int i = 0; i &lt; _count; i++) {
        print(out, _records[i]);
      }
    } else {
      for (int i = _index; i &lt; _length; i++) {
        print(out, _records[i]);
      }
      for (int i = 0; i &lt; _index; i++) {
        print(out, _records[i]);
      }
    }
    out-&gt;cr();
  }
  
  // Implement a printing routine for the StringLogMessage
  template &lt;&gt;
<span class="line-new-header">--- 260,119 ---</span>
    // Register default loggers
    static void init();
  };
  
  inline void Events::log(Thread* thread, const char* format, ...) {
<span class="line-modified">!   if (LogEvents &amp;&amp; _messages != NULL) {</span>
      va_list ap;
      va_start(ap, format);
      _messages-&gt;logv(thread, format, ap);
      va_end(ap);
    }
  }
  
  inline void Events::log_exception(Thread* thread, const char* format, ...) {
<span class="line-modified">!   if (LogEvents &amp;&amp; _exceptions != NULL) {</span>
      va_list ap;
      va_start(ap, format);
      _exceptions-&gt;logv(thread, format, ap);
      va_end(ap);
    }
  }
  
  inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {
<span class="line-modified">!   if (LogEvents &amp;&amp; _exceptions != NULL) {</span>
      _exceptions-&gt;log(thread, h_exception, message, file, line);
    }
  }
  
  inline void Events::log_redefinition(Thread* thread, const char* format, ...) {
<span class="line-modified">!   if (LogEvents &amp;&amp; _redefinitions != NULL) {</span>
      va_list ap;
      va_start(ap, format);
      _redefinitions-&gt;logv(thread, format, ap);
      va_end(ap);
    }
  }
  
  inline void Events::log_class_unloading(Thread* thread, InstanceKlass* ik) {
<span class="line-modified">!   if (LogEvents &amp;&amp; _class_unloading != NULL) {</span>
      _class_unloading-&gt;log(thread, ik);
    }
  }
  
  inline void Events::log_deopt_message(Thread* thread, const char* format, ...) {
<span class="line-modified">!   if (LogEvents &amp;&amp; _deopt_messages != NULL) {</span>
      va_list ap;
      va_start(ap, format);
      _deopt_messages-&gt;logv(thread, format, ap);
      va_end(ap);
    }
  }
  
  template &lt;class T&gt;
<span class="line-modified">! inline void EventLogBase&lt;T&gt;::print_log_on(outputStream* out, int max) {</span>
    if (Thread::current_or_null() == NULL) {
      // Not yet attached? Don&#39;t try to use locking
<span class="line-modified">!     print_log_impl(out, max);</span>
    } else {
<span class="line-modified">!     MutexLocker ml(&amp;_mutex, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!     print_log_impl(out, max);</span>
    }
  }
  
<span class="line-added">+ template &lt;class T&gt;</span>
<span class="line-added">+ inline bool EventLogBase&lt;T&gt;::matches_name_or_handle(const char* s) const {</span>
<span class="line-added">+   return ::strcasecmp(s, _name) == 0 ||</span>
<span class="line-added">+          ::strcasecmp(s, _handle) == 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;class T&gt;</span>
<span class="line-added">+ inline void EventLogBase&lt;T&gt;::print_names(outputStream* out) const {</span>
<span class="line-added">+   out-&gt;print(&quot;\&quot;%s\&quot; : %s&quot;, _handle, _name);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Dump the ring buffer entries that current have entries.
  template &lt;class T&gt;
<span class="line-modified">! inline void EventLogBase&lt;T&gt;::print_log_impl(outputStream* out, int max) {</span>
    out-&gt;print_cr(&quot;%s (%d events):&quot;, _name, _count);
    if (_count == 0) {
      out-&gt;print_cr(&quot;No events&quot;);
      out-&gt;cr();
      return;
    }
  
<span class="line-added">+   int printed = 0;</span>
    if (_count &lt; _length) {
      for (int i = 0; i &lt; _count; i++) {
<span class="line-added">+       if (max &gt; 0 &amp;&amp; printed == max) {</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
        print(out, _records[i]);
<span class="line-added">+       printed ++;</span>
      }
    } else {
      for (int i = _index; i &lt; _length; i++) {
<span class="line-added">+       if (max &gt; 0 &amp;&amp; printed == max) {</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
        print(out, _records[i]);
<span class="line-added">+       printed ++;</span>
      }
      for (int i = 0; i &lt; _index; i++) {
<span class="line-added">+       if (max &gt; 0 &amp;&amp; printed == max) {</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
        print(out, _records[i]);
<span class="line-added">+       printed ++;</span>
      }
    }
<span class="line-added">+ </span>
<span class="line-added">+   if (printed == max) {</span>
<span class="line-added">+     out-&gt;print_cr(&quot;...(skipped)&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    out-&gt;cr();
  }
  
  // Implement a printing routine for the StringLogMessage
  template &lt;&gt;
</pre>
<center><a href="events.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="exceptions.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/utilities/lockFreeStack.hpp b/src/hotspot/share/utilities/lockFreeStack.hpp
--- a/src/hotspot/share/utilities/lockFreeStack.hpp
+++ b/src/hotspot/share/utilities/lockFreeStack.hpp
@@ -25,11 +25,11 @@
 #ifndef SHARE_UTILITIES_LOCKFREESTACK_HPP
 #define SHARE_UTILITIES_LOCKFREESTACK_HPP
 
 #include "runtime/atomic.hpp"
 #include "utilities/debug.hpp"
-#include "utilities/macros.hpp"
+#include "utilities/globalDefinitions.hpp"
 
 // The LockFreeStack class template provides a lock-free LIFO. The objects
 // in the sequence are intrusively linked via a member in the objects.  As
 // a result, there is no allocation involved in adding objects to the stack
 // or removing them from the stack.
@@ -63,17 +63,15 @@
     T* cur = top();
     T* old;
     do {
       old = cur;
       set_next(*last, cur);
-      cur = Atomic::cmpxchg(first, &_top, cur);
+      cur = Atomic::cmpxchg(&_top, cur, first);
     } while (old != cur);
   }
 
-  // Noncopyable.
-  LockFreeStack(const LockFreeStack&);
-  LockFreeStack& operator=(const LockFreeStack&);
+  NONCOPYABLE(LockFreeStack);
 
 public:
   LockFreeStack() : _top(NULL) {}
   ~LockFreeStack() { assert(empty(), "stack not empty"); }
 
@@ -89,11 +87,11 @@
       T* new_top = NULL;
       if (result != NULL) {
         new_top = next(*result);
       }
       // CAS even on empty pop, for consistent membar bahavior.
-      result = Atomic::cmpxchg(new_top, &_top, result);
+      result = Atomic::cmpxchg(&_top, result, new_top);
     } while (result != old);
     if (result != NULL) {
       set_next(*result, NULL);
     }
     return result;
@@ -101,11 +99,11 @@
 
   // Atomically exchange the list of elements with NULL, returning the old
   // list of elements.  Acts as a full memory barrier.
   // postcondition: empty()
   T* pop_all() {
-    return Atomic::xchg((T*)NULL, &_top);
+    return Atomic::xchg(&_top, (T*)NULL);
   }
 
   // Atomically adds value to the top of this stack.  Acts as a full
   // memory barrier.
   void push(T& value) {
@@ -168,10 +166,10 @@
   // Set the entry following value to new_next in the list used by the
   // specialized LockFreeStack class.  Not thread-safe; in particular,
   // if value is in an instance of this specialization of LockFreeStack,
   // there must be no concurrent push or pop operations on that stack.
   static void set_next(T& value, T* new_next) {
-    Atomic::store(new_next, next_ptr(value));
+    Atomic::store(next_ptr(value), new_next);
   }
 };
 
 #endif // SHARE_UTILITIES_LOCKFREESTACK_HPP

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/bitMap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_BITMAP_HPP
 26 #define SHARE_UTILITIES_BITMAP_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 29 #include &quot;utilities/align.hpp&quot;</span>

 30 
 31 // Forward decl;
 32 class BitMapClosure;
 33 
 34 // Operations for bitmaps represented as arrays of unsigned integers.
<a name="2" id="anc2"></a><span class="line-modified"> 35 // Bit offsets are numbered from 0 to size-1.</span>
 36 
 37 // The &quot;abstract&quot; base BitMap class.
 38 //
 39 // The constructor and destructor are protected to prevent
 40 // creation of BitMap instances outside of the BitMap class.
 41 //
 42 // The BitMap class doesn&#39;t use virtual calls on purpose,
 43 // this ensures that we don&#39;t get a vtable unnecessarily.
 44 //
 45 // The allocation of the backing storage for the BitMap are handled by
 46 // the subclasses. BitMap doesn&#39;t allocate or delete backing storage.
 47 class BitMap {
 48   friend class BitMap2D;
 49 
 50  public:
 51   typedef size_t idx_t;         // Type used for bit and word indices.
<a name="3" id="anc3"></a><span class="line-modified"> 52   typedef uintptr_t bm_word_t;  // Element type of array that represents</span>
<span class="line-modified"> 53                                 // the bitmap.</span>


 54 
 55   // Hints for range sizes.
 56   typedef enum {
 57     unknown_range, small_range, large_range
 58   } RangeSizeHint;
 59 
 60  private:
 61   bm_word_t* _map;     // First word in bitmap
 62   idx_t      _size;    // Size of bitmap (in bits)
 63 
<a name="4" id="anc4"></a>




























 64   // Helper for get_next_{zero,one}_bit variants.
 65   // - flip designates whether searching for 1s or 0s.  Must be one of
 66   //   find_{zeros,ones}_flip.
 67   // - aligned_right is true if r_index is a priori on a bm_word_t boundary.
 68   template&lt;bm_word_t flip, bool aligned_right&gt;
 69   inline idx_t get_next_bit_impl(idx_t l_index, idx_t r_index) const;
 70 
 71   // Values for get_next_bit_impl flip parameter.
 72   static const bm_word_t find_ones_flip = 0;
 73   static const bm_word_t find_zeros_flip = ~(bm_word_t)0;
 74 
 75   // Threshold for performing small range operation, even when large range
 76   // operation was requested. Measured in words.
 77   static const size_t small_range_words = 32;
 78 
<a name="5" id="anc5"></a>

 79  protected:
 80   // Return the position of bit within the word that contains it (e.g., if
 81   // bitmap words are 32 bits, return a number 0 &lt;= n &lt;= 31).
 82   static idx_t bit_in_word(idx_t bit) { return bit &amp; (BitsPerWord - 1); }
 83 
 84   // Return a mask that will select the specified bit, when applied to the word
 85   // containing the bit.
 86   static bm_word_t bit_mask(idx_t bit) { return (bm_word_t)1 &lt;&lt; bit_in_word(bit); }
 87 
<a name="6" id="anc6"></a><span class="line-removed"> 88   // Return the index of the word containing the specified bit.</span>
<span class="line-removed"> 89   static idx_t word_index(idx_t bit)  { return bit &gt;&gt; LogBitsPerWord; }</span>
<span class="line-removed"> 90 </span>
 91   // Return the bit number of the first bit in the specified word.
 92   static idx_t bit_index(idx_t word)  { return word &lt;&lt; LogBitsPerWord; }
 93 
 94   // Return the array of bitmap words, or a specific word from it.
 95   bm_word_t* map()                 { return _map; }
 96   const bm_word_t* map() const     { return _map; }
 97   bm_word_t  map(idx_t word) const { return _map[word]; }
 98 
 99   // Return a pointer to the word containing the specified bit.
<a name="7" id="anc7"></a><span class="line-modified">100   bm_word_t* word_addr(idx_t bit)             { return map() + word_index(bit); }</span>
<span class="line-modified">101   const bm_word_t* word_addr(idx_t bit) const { return map() + word_index(bit); }</span>




102 
103   // Set a word to a specified value or to all ones; clear a word.
104   void set_word  (idx_t word, bm_word_t val) { _map[word] = val; }
105   void set_word  (idx_t word)            { set_word(word, ~(bm_word_t)0); }
106   void clear_word(idx_t word)            { _map[word] = 0; }
107 
<a name="8" id="anc8"></a>

108   // Utilities for ranges of bits.  Ranges are half-open [beg, end).
109 
110   // Ranges within a single word.
111   bm_word_t inverted_bit_mask_for_range(idx_t beg, idx_t end) const;
112   void  set_range_within_word      (idx_t beg, idx_t end);
113   void  clear_range_within_word    (idx_t beg, idx_t end);
114   void  par_put_range_within_word  (idx_t beg, idx_t end, bool value);
115 
116   // Ranges spanning entire words.
117   void      set_range_of_words         (idx_t beg, idx_t end);
118   void      clear_range_of_words       (idx_t beg, idx_t end);
119   void      set_large_range_of_words   (idx_t beg, idx_t end);
120   void      clear_large_range_of_words (idx_t beg, idx_t end);
121 
122   static void clear_range_of_words(bm_word_t* map, idx_t beg, idx_t end);
123 
<a name="9" id="anc9"></a><span class="line-removed">124   static bool is_small_range_of_words(idx_t beg_full_word, idx_t end_full_word);</span>
<span class="line-removed">125 </span>
<span class="line-removed">126   // The index of the first full word in a range.</span>
<span class="line-removed">127   idx_t word_index_round_up(idx_t bit) const;</span>
<span class="line-removed">128 </span>
129   // Verification.
<a name="10" id="anc10"></a><span class="line-removed">130   void verify_index(idx_t index) const NOT_DEBUG_RETURN;</span>
<span class="line-removed">131   void verify_range(idx_t beg_index, idx_t end_index) const NOT_DEBUG_RETURN;</span>
132 
<a name="11" id="anc11"></a><span class="line-modified">133   // Statistics.</span>
<span class="line-modified">134   static const idx_t* _pop_count_table;</span>
<span class="line-modified">135   static void init_pop_count_table();</span>
<span class="line-modified">136   static idx_t num_set_bits(bm_word_t w);</span>
<span class="line-modified">137   static idx_t num_set_bits_from_table(unsigned char c);</span>



138 
139   // Allocation Helpers.
140 
141   // Allocates and clears the bitmap memory.
142   template &lt;class Allocator&gt;
143   static bm_word_t* allocate(const Allocator&amp;, idx_t size_in_bits, bool clear = true);
144 
145   // Reallocates and clears the new bitmap memory.
146   template &lt;class Allocator&gt;
147   static bm_word_t* reallocate(const Allocator&amp;, bm_word_t* map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear = true);
148 
149   // Free the bitmap memory.
150   template &lt;class Allocator&gt;
151   static void free(const Allocator&amp;, bm_word_t* map, idx_t size_in_bits);
152 
153   // Protected functions, that are used by BitMap sub-classes that support them.
154 
155   // Resize the backing bitmap memory.
156   //
157   // Old bits are transfered to the new memory
158   // and the extended memory is cleared.
159   template &lt;class Allocator&gt;
<a name="12" id="anc12"></a><span class="line-modified">160   void resize(const Allocator&amp; allocator, idx_t new_size_in_bits);</span>
161 
162   // Set up and clear the bitmap memory.
163   //
164   // Precondition: The bitmap was default constructed and has
165   // not yet had memory allocated via resize or (re)initialize.
166   template &lt;class Allocator&gt;
<a name="13" id="anc13"></a><span class="line-modified">167   void initialize(const Allocator&amp; allocator, idx_t size_in_bits);</span>
168 
169   // Set up and clear the bitmap memory.
170   //
171   // Can be called on previously initialized bitmaps.
172   template &lt;class Allocator&gt;
<a name="14" id="anc14"></a><span class="line-modified">173   void reinitialize(const Allocator&amp; allocator, idx_t new_size_in_bits);</span>
174 
175   // Set the map and size.
176   void update(bm_word_t* map, idx_t size) {
177     _map = map;
178     _size = size;
179   }
180 
181   // Protected constructor and destructor.
<a name="15" id="anc15"></a><span class="line-modified">182   BitMap(bm_word_t* map, idx_t size_in_bits) : _map(map), _size(size_in_bits) {}</span>


183   ~BitMap() {}
184 
185  public:
186   // Pretouch the entire range of memory this BitMap covers.
187   void pretouch();
188 
189   // Accessing
190   static idx_t calc_size_in_words(size_t size_in_bits) {
<a name="16" id="anc16"></a><span class="line-modified">191     return word_index(size_in_bits + BitsPerWord - 1);</span>
<span class="line-modified">192   }</span>
<span class="line-removed">193 </span>
<span class="line-removed">194   static idx_t calc_size_in_bytes(size_t size_in_bits) {</span>
<span class="line-removed">195     return calc_size_in_words(size_in_bits) * BytesPerWord;</span>
196   }
197 
198   idx_t size() const          { return _size; }
199   idx_t size_in_words() const { return calc_size_in_words(size()); }
<a name="17" id="anc17"></a><span class="line-modified">200   idx_t size_in_bytes() const { return calc_size_in_bytes(size()); }</span>
201 
202   bool at(idx_t index) const {
203     verify_index(index);
204     return (*word_addr(index) &amp; bit_mask(index)) != 0;
205   }
206 
<a name="18" id="anc18"></a><span class="line-modified">207   // Align bit index up or down to the next bitmap word boundary, or check</span>
<span class="line-modified">208   // alignment.</span>
<span class="line-removed">209   static idx_t word_align_up(idx_t bit) {</span>
<span class="line-removed">210     return align_up(bit, BitsPerWord);</span>
<span class="line-removed">211   }</span>
<span class="line-removed">212   static idx_t word_align_down(idx_t bit) {</span>
<span class="line-removed">213     return align_down(bit, BitsPerWord);</span>
<span class="line-removed">214   }</span>
<span class="line-removed">215   static bool is_word_aligned(idx_t bit) {</span>
<span class="line-removed">216     return word_align_up(bit) == bit;</span>
<span class="line-removed">217   }</span>
218 
219   // Set or clear the specified bit.
220   inline void set_bit(idx_t bit);
221   inline void clear_bit(idx_t bit);
222 
<a name="19" id="anc19"></a><span class="line-modified">223   // Atomically set or clear the specified bit.</span>
<span class="line-modified">224   inline bool par_set_bit(idx_t bit);</span>
<span class="line-modified">225   inline bool par_clear_bit(idx_t bit);</span>





226 
<a name="20" id="anc20"></a><span class="line-modified">227   // Put the given value at the given offset. The parallel version</span>
228   // will CAS the value into the bitmap and is quite a bit slower.
229   // The parallel version also returns a value indicating if the
230   // calling thread was the one that changed the value of the bit.
231   void at_put(idx_t index, bool value);
232   bool par_at_put(idx_t index, bool value);
233 
234   // Update a range of bits.  Ranges are half-open [beg, end).
235   void set_range   (idx_t beg, idx_t end);
236   void clear_range (idx_t beg, idx_t end);
237   void set_large_range   (idx_t beg, idx_t end);
238   void clear_large_range (idx_t beg, idx_t end);
239   void at_put_range(idx_t beg, idx_t end, bool value);
240   void par_at_put_range(idx_t beg, idx_t end, bool value);
241   void at_put_large_range(idx_t beg, idx_t end, bool value);
242   void par_at_put_large_range(idx_t beg, idx_t end, bool value);
243 
244   // Update a range of bits, using a hint about the size.  Currently only
245   // inlines the predominant case of a 1-bit range.  Works best when hint is a
246   // compile-time constant.
247   void set_range(idx_t beg, idx_t end, RangeSizeHint hint);
248   void clear_range(idx_t beg, idx_t end, RangeSizeHint hint);
249   void par_set_range(idx_t beg, idx_t end, RangeSizeHint hint);
250   void par_clear_range  (idx_t beg, idx_t end, RangeSizeHint hint);
251 
252   // Clearing
253   void clear_large();
254   inline void clear();
255 
256   // Iteration support.  Returns &quot;true&quot; if the iteration completed, false
257   // if the iteration terminated early (because the closure &quot;blk&quot; returned
258   // false).
259   bool iterate(BitMapClosure* blk, idx_t leftIndex, idx_t rightIndex);
260   bool iterate(BitMapClosure* blk) {
261     // call the version that takes an interval
262     return iterate(blk, 0, size());
263   }
264 
265   // Looking for 1&#39;s and 0&#39;s at indices equal to or greater than &quot;l_index&quot;,
266   // stopping if none has been found before &quot;r_index&quot;, and returning
267   // &quot;r_index&quot; (which must be at most &quot;size&quot;) in that case.
268   idx_t get_next_one_offset (idx_t l_index, idx_t r_index) const;
269   idx_t get_next_zero_offset(idx_t l_index, idx_t r_index) const;
270 
271   idx_t get_next_one_offset(idx_t offset) const {
272     return get_next_one_offset(offset, size());
273   }
274   idx_t get_next_zero_offset(idx_t offset) const {
275     return get_next_zero_offset(offset, size());
276   }
277 
278   // Like &quot;get_next_one_offset&quot;, except requires that &quot;r_index&quot; is
279   // aligned to bitsizeof(bm_word_t).
280   idx_t get_next_one_offset_aligned_right(idx_t l_index, idx_t r_index) const;
281 
282   // Returns the number of bits set in the bitmap.
283   idx_t count_one_bits() const;
284 
285   // Set operations.
286   void set_union(const BitMap&amp; bits);
287   void set_difference(const BitMap&amp; bits);
288   void set_intersection(const BitMap&amp; bits);
289   // Returns true iff &quot;this&quot; is a superset of &quot;bits&quot;.
290   bool contains(const BitMap&amp; bits) const;
291   // Returns true iff &quot;this and &quot;bits&quot; have a non-empty intersection.
292   bool intersects(const BitMap&amp; bits) const;
293 
294   // Returns result of whether this map changed
295   // during the operation
296   bool set_union_with_result(const BitMap&amp; bits);
297   bool set_difference_with_result(const BitMap&amp; bits);
298   bool set_intersection_with_result(const BitMap&amp; bits);
299 
300   void set_from(const BitMap&amp; bits);
301 
302   bool is_same(const BitMap&amp; bits) const;
303 
304   // Test if all bits are set or cleared
305   bool is_full() const;
306   bool is_empty() const;
307 
308   void write_to(bm_word_t* buffer, size_t buffer_size_in_bytes) const;
309   void print_on_error(outputStream* st, const char* prefix) const;
310 
311 #ifndef PRODUCT
312  public:
313   // Printing
314   void print_on(outputStream* st) const;
315 #endif
316 };
317 
318 // A concrete implementation of the the &quot;abstract&quot; BitMap class.
319 //
320 // The BitMapView is used when the backing storage is managed externally.
321 class BitMapView : public BitMap {
322  public:
323   BitMapView() : BitMap(NULL, 0) {}
324   BitMapView(bm_word_t* map, idx_t size_in_bits) : BitMap(map, size_in_bits) {}
325 };
326 
327 // A BitMap with storage in a ResourceArea.
328 class ResourceBitMap : public BitMap {
329 
330  public:
331   ResourceBitMap() : BitMap(NULL, 0) {}
<a name="21" id="anc21"></a><span class="line-modified">332   // Clears the bitmap memory.</span>
<span class="line-modified">333   ResourceBitMap(idx_t size_in_bits);</span>
334 
335   // Resize the backing bitmap memory.
336   //
337   // Old bits are transfered to the new memory
338   // and the extended memory is cleared.
339   void resize(idx_t new_size_in_bits);
340 
341   // Set up and clear the bitmap memory.
342   //
343   // Precondition: The bitmap was default constructed and has
344   // not yet had memory allocated via resize or initialize.
345   void initialize(idx_t size_in_bits);
346 
347   // Set up and clear the bitmap memory.
348   //
349   // Can be called on previously initialized bitmaps.
350   void reinitialize(idx_t size_in_bits);
351 };
352 
353 // A BitMap with storage in a specific Arena.
354 class ArenaBitMap : public BitMap {
355  public:
356   // Clears the bitmap memory.
357   ArenaBitMap(Arena* arena, idx_t size_in_bits);
358 
359  private:
<a name="22" id="anc22"></a><span class="line-modified">360   // Don&#39;t allow copy or assignment.</span>
<span class="line-removed">361   ArenaBitMap(const ArenaBitMap&amp;);</span>
<span class="line-removed">362   ArenaBitMap&amp; operator=(const ArenaBitMap&amp;);</span>
363 };
364 
365 // A BitMap with storage in the CHeap.
366 class CHeapBitMap : public BitMap {
367 
368  private:
369   // Don&#39;t allow copy or assignment, to prevent the
370   // allocated memory from leaking out to other instances.
<a name="23" id="anc23"></a><span class="line-modified">371   CHeapBitMap(const CHeapBitMap&amp;);</span>
<span class="line-removed">372   CHeapBitMap&amp; operator=(const CHeapBitMap&amp;);</span>
373 
374   // NMT memory type
375   MEMFLAGS _flags;
376 
377  public:
378   CHeapBitMap(MEMFLAGS flags = mtInternal) : BitMap(NULL, 0), _flags(flags) {}
379   // Clears the bitmap memory.
380   CHeapBitMap(idx_t size_in_bits, MEMFLAGS flags = mtInternal, bool clear = true);
381   ~CHeapBitMap();
382 
383   // Resize the backing bitmap memory.
384   //
385   // Old bits are transfered to the new memory
<a name="24" id="anc24"></a><span class="line-modified">386   // and the extended memory is cleared.</span>
<span class="line-modified">387   void resize(idx_t new_size_in_bits);</span>
388 
<a name="25" id="anc25"></a><span class="line-modified">389   // Set up and clear the bitmap memory.</span>
390   //
391   // Precondition: The bitmap was default constructed and has
392   // not yet had memory allocated via resize or initialize.
<a name="26" id="anc26"></a><span class="line-modified">393   void initialize(idx_t size_in_bits);</span>
394 
<a name="27" id="anc27"></a><span class="line-modified">395   // Set up and clear the bitmap memory.</span>
396   //
397   // Can be called on previously initialized bitmaps.
<a name="28" id="anc28"></a><span class="line-modified">398   void reinitialize(idx_t size_in_bits);</span>
399 };
400 
401 // Convenience class wrapping BitMap which provides multiple bits per slot.
402 class BitMap2D {
403  public:
404   typedef BitMap::idx_t idx_t;          // Type used for bit and word indices.
405   typedef BitMap::bm_word_t bm_word_t;  // Element type of array that
406                                         // represents the bitmap.
407  private:
408   ResourceBitMap _map;
409   idx_t          _bits_per_slot;
410 
411   idx_t bit_index(idx_t slot_index, idx_t bit_within_slot_index) const {
412     return slot_index * _bits_per_slot + bit_within_slot_index;
413   }
414 
415   void verify_bit_within_slot_index(idx_t index) const {
416     assert(index &lt; _bits_per_slot, &quot;bit_within_slot index out of bounds&quot;);
417   }
418 
419  public:
420   // Construction. bits_per_slot must be greater than 0.
421   BitMap2D(idx_t bits_per_slot) :
422       _map(), _bits_per_slot(bits_per_slot) {}
423 
424   // Allocates necessary data structure in resource area. bits_per_slot must be greater than 0.
425   BitMap2D(idx_t size_in_slots, idx_t bits_per_slot) :
426       _map(size_in_slots * bits_per_slot), _bits_per_slot(bits_per_slot) {}
427 
428   idx_t size_in_bits() {
429     return _map.size();
430   }
431 
432   bool is_valid_index(idx_t slot_index, idx_t bit_within_slot_index);
433   bool at(idx_t slot_index, idx_t bit_within_slot_index) const;
434   void set_bit(idx_t slot_index, idx_t bit_within_slot_index);
435   void clear_bit(idx_t slot_index, idx_t bit_within_slot_index);
436   void at_put(idx_t slot_index, idx_t bit_within_slot_index, bool value);
437   void at_put_grow(idx_t slot_index, idx_t bit_within_slot_index, bool value);
438 };
439 
440 // Closure for iterating over BitMaps
441 
442 class BitMapClosure {
443  public:
444   // Callback when bit in map is set.  Should normally return &quot;true&quot;;
445   // return of false indicates that the bitmap iteration should terminate.
<a name="29" id="anc29"></a><span class="line-modified">446   virtual bool do_bit(BitMap::idx_t offset) = 0;</span>
447 };
448 
449 #endif // SHARE_UTILITIES_BITMAP_HPP
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
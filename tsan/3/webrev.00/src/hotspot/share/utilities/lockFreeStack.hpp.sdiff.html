<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/lockFreeStack.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="hashtable.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macros.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/lockFreeStack.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_LOCKFREESTACK_HPP
 26 #define SHARE_UTILITIES_LOCKFREESTACK_HPP
 27 
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;utilities/debug.hpp&quot;
<span class="line-modified"> 30 #include &quot;utilities/macros.hpp&quot;</span>
 31 
 32 // The LockFreeStack class template provides a lock-free LIFO. The objects
 33 // in the sequence are intrusively linked via a member in the objects.  As
 34 // a result, there is no allocation involved in adding objects to the stack
 35 // or removing them from the stack.
 36 //
 37 // To be used in a LockFreeStack of objects of type T, an object of
 38 // type T must have a list entry member of type T* volatile, with an
 39 // non-member accessor function returning a pointer to that member.  A
 40 // LockFreeStack is associated with the class of its elements and an
 41 // entry member from that class.
 42 //
 43 // An object can be in multiple stacks at the same time, so long as
 44 // each stack uses a different entry member. That is, the class of the
 45 // object must have multiple LockFreeStack entry members, one for each
 46 // stack in which the object may simultaneously be an element.
 47 //
 48 // LockFreeStacks support polymorphic elements.  Because the objects
 49 // in a stack are externally managed, rather than being embedded
 50 // values in the stack, the actual type of such objects may be more
 51 // specific than the stack&#39;s element type.
 52 //
 53 // \tparam T is the class of the elements in the stack.
 54 //
 55 // \tparam next_ptr is a function pointer.  Applying this function to
 56 // an object of type T must return a pointer to the list entry member
 57 // of the object associated with the LockFreeStack type.
 58 template&lt;typename T, T* volatile* (*next_ptr)(T&amp;)&gt;
 59 class LockFreeStack {
 60   T* volatile _top;
 61 
 62   void prepend_impl(T* first, T* last) {
 63     T* cur = top();
 64     T* old;
 65     do {
 66       old = cur;
 67       set_next(*last, cur);
<span class="line-modified"> 68       cur = Atomic::cmpxchg(first, &amp;_top, cur);</span>
 69     } while (old != cur);
 70   }
 71 
<span class="line-modified"> 72   // Noncopyable.</span>
<span class="line-removed"> 73   LockFreeStack(const LockFreeStack&amp;);</span>
<span class="line-removed"> 74   LockFreeStack&amp; operator=(const LockFreeStack&amp;);</span>
 75 
 76 public:
 77   LockFreeStack() : _top(NULL) {}
 78   ~LockFreeStack() { assert(empty(), &quot;stack not empty&quot;); }
 79 
 80   // Atomically removes the top object from this stack and returns a
 81   // pointer to that object, or NULL if this stack is empty. Acts as a
 82   // full memory barrier. Subject to ABA behavior; callers must ensure
 83   // usage is safe.
 84   T* pop() {
 85     T* result = top();
 86     T* old;
 87     do {
 88       old = result;
 89       T* new_top = NULL;
 90       if (result != NULL) {
 91         new_top = next(*result);
 92       }
 93       // CAS even on empty pop, for consistent membar bahavior.
<span class="line-modified"> 94       result = Atomic::cmpxchg(new_top, &amp;_top, result);</span>
 95     } while (result != old);
 96     if (result != NULL) {
 97       set_next(*result, NULL);
 98     }
 99     return result;
100   }
101 
102   // Atomically exchange the list of elements with NULL, returning the old
103   // list of elements.  Acts as a full memory barrier.
104   // postcondition: empty()
105   T* pop_all() {
<span class="line-modified">106     return Atomic::xchg((T*)NULL, &amp;_top);</span>
107   }
108 
109   // Atomically adds value to the top of this stack.  Acts as a full
110   // memory barrier.
111   void push(T&amp; value) {
112     assert(next(value) == NULL, &quot;precondition&quot;);
113     prepend_impl(&amp;value, &amp;value);
114   }
115 
116   // Atomically adds the list of objects (designated by first and
117   // last) before the objects already in this stack, in the same order
118   // as in the list. Acts as a full memory barrier.
119   // precondition: next(last) == NULL.
120   // postcondition: top() == &amp;first, next(last) == old top().
121   void prepend(T&amp; first, T&amp; last) {
122     assert(next(last) == NULL, &quot;precondition&quot;);
123 #ifdef ASSERT
124     for (T* p = &amp;first; p != &amp;last; p = next(*p)) {
125       assert(p != NULL, &quot;invalid prepend list&quot;);
126     }
</pre>
<hr />
<pre>
153   // pops while the length is being determined.
154   size_t length() const {
155     size_t result = 0;
156     for (const T* current = top(); current != NULL; current = next(*current)) {
157       ++result;
158     }
159     return result;
160   }
161 
162   // Return the entry following value in the list used by the
163   // specialized LockFreeStack class.
164   static T* next(const T&amp; value) {
165     return Atomic::load(next_ptr(const_cast&lt;T&amp;&gt;(value)));
166   }
167 
168   // Set the entry following value to new_next in the list used by the
169   // specialized LockFreeStack class.  Not thread-safe; in particular,
170   // if value is in an instance of this specialization of LockFreeStack,
171   // there must be no concurrent push or pop operations on that stack.
172   static void set_next(T&amp; value, T* new_next) {
<span class="line-modified">173     Atomic::store(new_next, next_ptr(value));</span>
174   }
175 };
176 
177 #endif // SHARE_UTILITIES_LOCKFREESTACK_HPP
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_LOCKFREESTACK_HPP
 26 #define SHARE_UTILITIES_LOCKFREESTACK_HPP
 27 
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;utilities/debug.hpp&quot;
<span class="line-modified"> 30 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 31 
 32 // The LockFreeStack class template provides a lock-free LIFO. The objects
 33 // in the sequence are intrusively linked via a member in the objects.  As
 34 // a result, there is no allocation involved in adding objects to the stack
 35 // or removing them from the stack.
 36 //
 37 // To be used in a LockFreeStack of objects of type T, an object of
 38 // type T must have a list entry member of type T* volatile, with an
 39 // non-member accessor function returning a pointer to that member.  A
 40 // LockFreeStack is associated with the class of its elements and an
 41 // entry member from that class.
 42 //
 43 // An object can be in multiple stacks at the same time, so long as
 44 // each stack uses a different entry member. That is, the class of the
 45 // object must have multiple LockFreeStack entry members, one for each
 46 // stack in which the object may simultaneously be an element.
 47 //
 48 // LockFreeStacks support polymorphic elements.  Because the objects
 49 // in a stack are externally managed, rather than being embedded
 50 // values in the stack, the actual type of such objects may be more
 51 // specific than the stack&#39;s element type.
 52 //
 53 // \tparam T is the class of the elements in the stack.
 54 //
 55 // \tparam next_ptr is a function pointer.  Applying this function to
 56 // an object of type T must return a pointer to the list entry member
 57 // of the object associated with the LockFreeStack type.
 58 template&lt;typename T, T* volatile* (*next_ptr)(T&amp;)&gt;
 59 class LockFreeStack {
 60   T* volatile _top;
 61 
 62   void prepend_impl(T* first, T* last) {
 63     T* cur = top();
 64     T* old;
 65     do {
 66       old = cur;
 67       set_next(*last, cur);
<span class="line-modified"> 68       cur = Atomic::cmpxchg(&amp;_top, cur, first);</span>
 69     } while (old != cur);
 70   }
 71 
<span class="line-modified"> 72   NONCOPYABLE(LockFreeStack);</span>


 73 
 74 public:
 75   LockFreeStack() : _top(NULL) {}
 76   ~LockFreeStack() { assert(empty(), &quot;stack not empty&quot;); }
 77 
 78   // Atomically removes the top object from this stack and returns a
 79   // pointer to that object, or NULL if this stack is empty. Acts as a
 80   // full memory barrier. Subject to ABA behavior; callers must ensure
 81   // usage is safe.
 82   T* pop() {
 83     T* result = top();
 84     T* old;
 85     do {
 86       old = result;
 87       T* new_top = NULL;
 88       if (result != NULL) {
 89         new_top = next(*result);
 90       }
 91       // CAS even on empty pop, for consistent membar bahavior.
<span class="line-modified"> 92       result = Atomic::cmpxchg(&amp;_top, result, new_top);</span>
 93     } while (result != old);
 94     if (result != NULL) {
 95       set_next(*result, NULL);
 96     }
 97     return result;
 98   }
 99 
100   // Atomically exchange the list of elements with NULL, returning the old
101   // list of elements.  Acts as a full memory barrier.
102   // postcondition: empty()
103   T* pop_all() {
<span class="line-modified">104     return Atomic::xchg(&amp;_top, (T*)NULL);</span>
105   }
106 
107   // Atomically adds value to the top of this stack.  Acts as a full
108   // memory barrier.
109   void push(T&amp; value) {
110     assert(next(value) == NULL, &quot;precondition&quot;);
111     prepend_impl(&amp;value, &amp;value);
112   }
113 
114   // Atomically adds the list of objects (designated by first and
115   // last) before the objects already in this stack, in the same order
116   // as in the list. Acts as a full memory barrier.
117   // precondition: next(last) == NULL.
118   // postcondition: top() == &amp;first, next(last) == old top().
119   void prepend(T&amp; first, T&amp; last) {
120     assert(next(last) == NULL, &quot;precondition&quot;);
121 #ifdef ASSERT
122     for (T* p = &amp;first; p != &amp;last; p = next(*p)) {
123       assert(p != NULL, &quot;invalid prepend list&quot;);
124     }
</pre>
<hr />
<pre>
151   // pops while the length is being determined.
152   size_t length() const {
153     size_t result = 0;
154     for (const T* current = top(); current != NULL; current = next(*current)) {
155       ++result;
156     }
157     return result;
158   }
159 
160   // Return the entry following value in the list used by the
161   // specialized LockFreeStack class.
162   static T* next(const T&amp; value) {
163     return Atomic::load(next_ptr(const_cast&lt;T&amp;&gt;(value)));
164   }
165 
166   // Set the entry following value to new_next in the list used by the
167   // specialized LockFreeStack class.  Not thread-safe; in particular,
168   // if value is in an instance of this specialization of LockFreeStack,
169   // there must be no concurrent push or pop operations on that stack.
170   static void set_next(T&amp; value, T* new_next) {
<span class="line-modified">171     Atomic::store(next_ptr(value), new_next);</span>
172   }
173 };
174 
175 #endif // SHARE_UTILITIES_LOCKFREESTACK_HPP
</pre>
</td>
</tr>
</table>
<center><a href="hashtable.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macros.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
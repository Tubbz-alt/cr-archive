<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/exceptions.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="exceptions.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globalCounter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/exceptions.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
169                               ExceptionMsgToUtf8Mode to_utf8_safe = safe_to_utf8);
170 
171   static void throw_stack_overflow_exception(Thread* thread, const char* file, int line, const methodHandle&amp; method);
172 
173   static void wrap_dynamic_exception(Thread* thread);
174 
175   // Exception counting for error files of interesting exceptions that may have
176   // caused a problem for the jvm
177   static volatile int _stack_overflow_errors;
178 
179   static bool has_exception_counts();
180   static void count_out_of_memory_exceptions(Handle exception);
181   static void print_exception_counts_on_error(outputStream* st);
182 
183   // for AbortVMOnException flag
184   static void debug_check_abort(Handle exception, const char* message = NULL);
185   static void debug_check_abort_helper(Handle exception, const char* message = NULL);
186   static void debug_check_abort(const char *value_string, const char* message = NULL);
187 
188   // for logging exceptions
<span class="line-modified">189   static void log_exception(Handle exception, stringStream tempst);</span>
190 };
191 
192 
193 // The THREAD &amp; TRAPS macros facilitate the declaration of functions that throw exceptions.
194 // Convention: Use the TRAPS macro as the last argument of such a function; e.g.:
195 //
196 // int this_function_may_trap(int x, float y, TRAPS)
197 
198 #define THREAD __the_thread__
199 #define TRAPS  Thread* THREAD
200 
201 
202 // The CHECK... macros should be used to pass along a THREAD reference and to check for pending
203 // exceptions. In special situations it is necessary to handle pending exceptions explicitly,
204 // in these cases the PENDING_EXCEPTION helper macros should be used.
205 //
206 // Macro naming conventions: Macros that end with _ require a result value to be returned. They
207 // are for functions with non-void result type. The result value is usually ignored because of
208 // the exception and is only needed for syntactic correctness. The _0 ending is a shortcut for
209 // _(0) since this is a frequent case. Example:
</pre>
<hr />
<pre>
220 
221 #define CHECK                                    THREAD); if (HAS_PENDING_EXCEPTION) return       ; (void)(0
222 #define CHECK_(result)                           THREAD); if (HAS_PENDING_EXCEPTION) return result; (void)(0
223 #define CHECK_0                                  CHECK_(0)
224 #define CHECK_NH                                 CHECK_(Handle())
225 #define CHECK_NULL                               CHECK_(NULL)
226 #define CHECK_false                              CHECK_(false)
227 #define CHECK_JNI_ERR                            CHECK_(JNI_ERR)
228 
229 #define CHECK_AND_CLEAR                         THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_EXCEPTION; return;        } (void)(0
230 #define CHECK_AND_CLEAR_(result)                THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_EXCEPTION; return result; } (void)(0
231 #define CHECK_AND_CLEAR_0                       CHECK_AND_CLEAR_(0)
232 #define CHECK_AND_CLEAR_NH                      CHECK_AND_CLEAR_(Handle())
233 #define CHECK_AND_CLEAR_NULL                    CHECK_AND_CLEAR_(NULL)
234 #define CHECK_AND_CLEAR_false                   CHECK_AND_CLEAR_(false)
235 
236 // The THROW... macros should be used to throw an exception. They require a THREAD variable to be
237 // visible within the scope containing the THROW. Usually this is achieved by declaring the function
238 // with a TRAPS argument.
239 
<span class="line-removed">240 #ifdef THIS_FILE</span>
<span class="line-removed">241 #define THREAD_AND_LOCATION                      THREAD, THIS_FILE, __LINE__</span>
<span class="line-removed">242 #else</span>
243 #define THREAD_AND_LOCATION                      THREAD, __FILE__, __LINE__
<span class="line-removed">244 #endif</span>
245 
246 #define THROW_OOP(e)                                \
247   { Exceptions::_throw_oop(THREAD_AND_LOCATION, e);                             return;  }
248 
249 #define THROW_HANDLE(e)                                \
250   { Exceptions::_throw(THREAD_AND_LOCATION, e);                             return;  }
251 
252 #define THROW(name)                                 \
253   { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, NULL); return;  }
254 
255 #define THROW_MSG(name, message)                    \
256   { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message); return;  }
257 
258 #define THROW_CAUSE(name, cause)   \
259   { Exceptions::_throw_cause(THREAD_AND_LOCATION, name, cause); return; }
260 
261 #define THROW_MSG_LOADER(name, message, loader, protection_domain) \
262   { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message, loader, protection_domain); return;  }
263 
264 #define THROW_ARG(name, signature, args) \
</pre>
</td>
<td>
<hr />
<pre>
169                               ExceptionMsgToUtf8Mode to_utf8_safe = safe_to_utf8);
170 
171   static void throw_stack_overflow_exception(Thread* thread, const char* file, int line, const methodHandle&amp; method);
172 
173   static void wrap_dynamic_exception(Thread* thread);
174 
175   // Exception counting for error files of interesting exceptions that may have
176   // caused a problem for the jvm
177   static volatile int _stack_overflow_errors;
178 
179   static bool has_exception_counts();
180   static void count_out_of_memory_exceptions(Handle exception);
181   static void print_exception_counts_on_error(outputStream* st);
182 
183   // for AbortVMOnException flag
184   static void debug_check_abort(Handle exception, const char* message = NULL);
185   static void debug_check_abort_helper(Handle exception, const char* message = NULL);
186   static void debug_check_abort(const char *value_string, const char* message = NULL);
187 
188   // for logging exceptions
<span class="line-modified">189   static void log_exception(Handle exception, const char* message);</span>
190 };
191 
192 
193 // The THREAD &amp; TRAPS macros facilitate the declaration of functions that throw exceptions.
194 // Convention: Use the TRAPS macro as the last argument of such a function; e.g.:
195 //
196 // int this_function_may_trap(int x, float y, TRAPS)
197 
198 #define THREAD __the_thread__
199 #define TRAPS  Thread* THREAD
200 
201 
202 // The CHECK... macros should be used to pass along a THREAD reference and to check for pending
203 // exceptions. In special situations it is necessary to handle pending exceptions explicitly,
204 // in these cases the PENDING_EXCEPTION helper macros should be used.
205 //
206 // Macro naming conventions: Macros that end with _ require a result value to be returned. They
207 // are for functions with non-void result type. The result value is usually ignored because of
208 // the exception and is only needed for syntactic correctness. The _0 ending is a shortcut for
209 // _(0) since this is a frequent case. Example:
</pre>
<hr />
<pre>
220 
221 #define CHECK                                    THREAD); if (HAS_PENDING_EXCEPTION) return       ; (void)(0
222 #define CHECK_(result)                           THREAD); if (HAS_PENDING_EXCEPTION) return result; (void)(0
223 #define CHECK_0                                  CHECK_(0)
224 #define CHECK_NH                                 CHECK_(Handle())
225 #define CHECK_NULL                               CHECK_(NULL)
226 #define CHECK_false                              CHECK_(false)
227 #define CHECK_JNI_ERR                            CHECK_(JNI_ERR)
228 
229 #define CHECK_AND_CLEAR                         THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_EXCEPTION; return;        } (void)(0
230 #define CHECK_AND_CLEAR_(result)                THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_EXCEPTION; return result; } (void)(0
231 #define CHECK_AND_CLEAR_0                       CHECK_AND_CLEAR_(0)
232 #define CHECK_AND_CLEAR_NH                      CHECK_AND_CLEAR_(Handle())
233 #define CHECK_AND_CLEAR_NULL                    CHECK_AND_CLEAR_(NULL)
234 #define CHECK_AND_CLEAR_false                   CHECK_AND_CLEAR_(false)
235 
236 // The THROW... macros should be used to throw an exception. They require a THREAD variable to be
237 // visible within the scope containing the THROW. Usually this is achieved by declaring the function
238 // with a TRAPS argument.
239 



240 #define THREAD_AND_LOCATION                      THREAD, __FILE__, __LINE__

241 
242 #define THROW_OOP(e)                                \
243   { Exceptions::_throw_oop(THREAD_AND_LOCATION, e);                             return;  }
244 
245 #define THROW_HANDLE(e)                                \
246   { Exceptions::_throw(THREAD_AND_LOCATION, e);                             return;  }
247 
248 #define THROW(name)                                 \
249   { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, NULL); return;  }
250 
251 #define THROW_MSG(name, message)                    \
252   { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message); return;  }
253 
254 #define THROW_CAUSE(name, cause)   \
255   { Exceptions::_throw_cause(THREAD_AND_LOCATION, name, cause); return; }
256 
257 #define THROW_MSG_LOADER(name, message, loader, protection_domain) \
258   { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, message, loader, protection_domain); return;  }
259 
260 #define THROW_ARG(name, signature, args) \
</pre>
</td>
</tr>
</table>
<center><a href="exceptions.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globalCounter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/utilities/xmlstream.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/nmethod.hpp&quot;
 27 #include &quot;memory/allocation.hpp&quot;
 28 #include &quot;memory/allocation.inline.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;oops/methodData.hpp&quot;
 31 #include &quot;oops/method.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;runtime/deoptimization.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/vmThread.hpp&quot;
 36 #include &quot;utilities/vmError.hpp&quot;
 37 #include &quot;utilities/xmlstream.hpp&quot;
 38 
 39 // Do not assert this condition if there&#39;s already another error reported.
 40 #define assert_if_no_error(cond, msg) \
 41   vmassert((cond) || VMError::is_error_reported(), msg)
 42 
 43 void xmlStream::initialize(outputStream* out) {
 44   _out = out;
 45   _last_flush = 0;
 46   _markup_state = BODY;
 47   _text_init._outer_xmlStream = this;
 48   _text = &amp;_text_init;
 49 
 50 #ifdef ASSERT
 51   _element_depth = 0;
 52   int   init_len = 100;
 53   char* init_buf = NEW_C_HEAP_ARRAY(char, init_len, mtInternal);
 54   _element_close_stack_low  = init_buf;
 55   _element_close_stack_high = init_buf + init_len;
 56   _element_close_stack_ptr  = init_buf + init_len - 1;
 57   _element_close_stack_ptr[0] = &#39;\0&#39;;
 58 #endif
 59 
 60   // Make sure each log uses the same base for time stamps.
 61   if (is_open()) {
 62     _out-&gt;time_stamp().update_to(1);
 63   }
 64 }
 65 
 66 #ifdef ASSERT
 67 xmlStream::~xmlStream() {
 68   FREE_C_HEAP_ARRAY(char, _element_close_stack_low);
 69 }
 70 #endif
 71 
 72 // Pass the given chars directly to _out.
 73 void xmlStream::write(const char* s, size_t len) {
 74   if (!is_open())  return;
 75 
 76   out()-&gt;write(s, len);
 77   update_position(s, len);
 78 }
 79 
 80 
 81 // Pass the given chars directly to _out, except that
 82 // we watch for special &quot;&lt;&amp;&gt;&quot; chars.
 83 // This is suitable for either attribute text or for body text.
 84 // We don&#39;t fool with &quot;&lt;![CDATA[&quot; quotes, just single-character entities.
 85 // This makes it easier for dumb tools to parse the output.
 86 void xmlStream::write_text(const char* s, size_t len) {
 87   if (!is_open())  return;
 88 
 89   size_t written = 0;
 90   // All normally printed material goes inside XML quotes.
 91   // This leaves the output free to include markup also.
 92   // Scan the string looking for inadvertant &quot;&lt;&amp;&gt;&quot; chars
 93   for (size_t i = 0; i &lt; len; i++) {
 94     char ch = s[i];
 95     // Escape special chars.
 96     const char* esc = NULL;
 97     switch (ch) {
 98       // These are important only in attrs, but we do them always:
 99     case &#39;\&#39;&#39;: esc = &quot;&amp;apos;&quot;; break;
100     case &#39;&quot;&#39;:  esc = &quot;&amp;quot;&quot;; break;
101     case &#39;&lt;&#39;:  esc = &quot;&amp;lt;&quot;;   break;
102     case &#39;&amp;&#39;:  esc = &quot;&amp;amp;&quot;;  break;
103       // This is a freebie.
104     case &#39;&gt;&#39;:  esc = &quot;&amp;gt;&quot;;   break;
105     }
106     if (esc != NULL) {
107       if (written &lt; i) {
108         out()-&gt;write(&amp;s[written], i - written);
109         written = i;
110       }
111       out()-&gt;print_raw(esc);
112       written++;
113     }
114   }
115 
116   // Print the clean remainder.  Usually, it is all of s.
117   if (written &lt; len) {
118     out()-&gt;write(&amp;s[written], len - written);
119   }
120 }
121 
122 // ------------------------------------------------------------------
123 // Outputs XML text, with special characters quoted.
124 void xmlStream::text(const char* format, ...) {
125   va_list ap;
126   va_start(ap, format);
127   va_text(format, ap);
128   va_end(ap);
129 }
130 
131 #define BUFLEN 2*K   /* max size of output of individual print methods */
132 
133 // ------------------------------------------------------------------
134 void xmlStream::va_tag(bool push, const char* format, va_list ap) {
135   assert_if_no_error(!inside_attrs(), &quot;cannot print tag inside attrs&quot;);
136   char buffer[BUFLEN];
137   size_t len;
138   const char* kind = do_vsnprintf(buffer, BUFLEN, format, ap, false, len);
139   see_tag(kind, push);
140   print_raw(&quot;&lt;&quot;);
141   write(kind, len);
142   _markup_state = (push ? HEAD : ELEM);
143 }
144 
145 #ifdef ASSERT
146 /// Debugging goo to make sure element tags nest properly.
147 
148 // ------------------------------------------------------------------
149 void xmlStream::see_tag(const char* tag, bool push) {
150   assert_if_no_error(!inside_attrs(), &quot;cannot start new element inside attrs&quot;);
151   if (!push)  return;
152 
153   // tag goes up until either null or space:
154   const char* tag_end = strchr(tag, &#39; &#39;);
155   size_t tag_len = (tag_end == NULL) ? strlen(tag) : tag_end - tag;
156   assert(tag_len &gt; 0, &quot;tag must not be empty&quot;);
157   // push the tag onto the stack, pulling down the pointer
158   char* old_ptr  = _element_close_stack_ptr;
159   char* old_low  = _element_close_stack_low;
160   char* push_ptr = old_ptr - (tag_len+1);
161   if (push_ptr &lt; old_low) {
162     int old_len = _element_close_stack_high - old_ptr;
163     int new_len = old_len * 2;
164     if (new_len &lt; 100)  new_len = 100;
165     char* new_low  = NEW_C_HEAP_ARRAY(char, new_len, mtInternal);
166     char* new_high = new_low + new_len;
167     char* new_ptr  = new_high - old_len;
168     memcpy(new_ptr, old_ptr, old_len);
169     _element_close_stack_high = new_high;
170     _element_close_stack_low  = new_low;
171     _element_close_stack_ptr  = new_ptr;
172     FREE_C_HEAP_ARRAY(char, old_low);
173     push_ptr = new_ptr - (tag_len+1);
174   }
175   assert(push_ptr &gt;= _element_close_stack_low, &quot;in range&quot;);
176   memcpy(push_ptr, tag, tag_len);
177   push_ptr[tag_len] = 0;
178   _element_close_stack_ptr = push_ptr;
179   _element_depth += 1;
180 }
181 
182 // ------------------------------------------------------------------
183 void xmlStream::pop_tag(const char* tag) {
184   assert_if_no_error(!inside_attrs(), &quot;cannot close element inside attrs&quot;);
185   assert(_element_depth &gt; 0, &quot;must be in an element to close&quot;);
186   assert(*tag != 0, &quot;tag must not be empty&quot;);
187   char* cur_tag = _element_close_stack_ptr;
188   bool  bad_tag = false;
189   while (*cur_tag != 0 &amp;&amp; strcmp(cur_tag, tag) != 0) {
190     this-&gt;print_cr(&quot;&lt;/%s&gt; &lt;!-- missing closing tag --&gt;&quot;, cur_tag);
191     _element_close_stack_ptr = (cur_tag += strlen(cur_tag) + 1);
192     _element_depth -= 1;
193     bad_tag = true;
194   }
195   if (*cur_tag == 0) {
196     bad_tag = true;
197   } else {
198     // Pop the stack, by skipping over the tag and its null.
199     _element_close_stack_ptr = cur_tag + strlen(cur_tag) + 1;
200     _element_depth -= 1;
201   }
202   if (bad_tag &amp;&amp; !VMThread::should_terminate() &amp;&amp; !VM_Exit::vm_exited() &amp;&amp;
203       !VMError::is_error_reported())
204   {
205     assert(false, &quot;bad tag in log&quot;);
206   }
207 }
208 #endif
209 
210 
211 // ------------------------------------------------------------------
212 // First word in formatted string is element kind, and any subsequent
213 // words must be XML attributes.  Outputs &quot;&lt;kind .../&gt;&quot;.
214 void xmlStream::elem(const char* format, ...) {
215   va_list ap;
216   va_start(ap, format);
217   va_elem(format, ap);
218   va_end(ap);
219 }
220 
221 // ------------------------------------------------------------------
222 void xmlStream::va_elem(const char* format, va_list ap) {
223   va_begin_elem(format, ap);
224   end_elem();
225 }
226 
227 
228 // ------------------------------------------------------------------
229 // First word in formatted string is element kind, and any subsequent
230 // words must be XML attributes.  Outputs &quot;&lt;kind ...&quot;, not including &quot;/&gt;&quot;.
231 void xmlStream::begin_elem(const char* format, ...) {
232   va_list ap;
233   va_start(ap, format);
234   va_tag(false, format, ap);
235   va_end(ap);
236 }
237 
238 // ------------------------------------------------------------------
239 void xmlStream::va_begin_elem(const char* format, va_list ap) {
240   va_tag(false, format, ap);
241 }
242 
243 // ------------------------------------------------------------------
244 // Outputs &quot;/&gt;&quot;.
245 void xmlStream::end_elem() {
246   assert(_markup_state == ELEM, &quot;misplaced end_elem&quot;);
247   print_raw(&quot;/&gt;\n&quot;);
248   _markup_state = BODY;
249 }
250 
251 // ------------------------------------------------------------------
252 // Outputs formatted text, followed by &quot;/&gt;&quot;.
253 void xmlStream::end_elem(const char* format, ...) {
254   va_list ap;
255   va_start(ap, format);
256   out()-&gt;vprint(format, ap);
257   va_end(ap);
258   end_elem();
259 }
260 
261 
262 // ------------------------------------------------------------------
263 // First word in formatted string is element kind, and any subsequent
264 // words must be XML attributes.  Outputs &quot;&lt;kind ...&gt;&quot;.
265 void xmlStream::head(const char* format, ...) {
266   va_list ap;
267   va_start(ap, format);
268   va_head(format, ap);
269   va_end(ap);
270 }
271 
272 // ------------------------------------------------------------------
273 void xmlStream::va_head(const char* format, va_list ap) {
274   va_begin_head(format, ap);
275   end_head();
276 }
277 
278 // ------------------------------------------------------------------
279 // First word in formatted string is element kind, and any subsequent
280 // words must be XML attributes.  Outputs &quot;&lt;kind ...&quot;, not including &quot;&gt;&quot;.
281 void xmlStream::begin_head(const char* format, ...) {
282   va_list ap;
283   va_start(ap, format);
284   va_tag(true, format, ap);
285   va_end(ap);
286 }
287 
288 // ------------------------------------------------------------------
289 void xmlStream::va_begin_head(const char* format, va_list ap) {
290   va_tag(true, format, ap);
291 }
292 
293 // ------------------------------------------------------------------
294 // Outputs &quot;&gt;&quot;.
295 void xmlStream::end_head() {
296   assert(_markup_state == HEAD, &quot;misplaced end_head&quot;);
297   print_raw(&quot;&gt;\n&quot;);
298   _markup_state = BODY;
299 }
300 
301 
302 // ------------------------------------------------------------------
303 // Outputs formatted text, followed by &quot;&gt;&quot;.
304 void xmlStream::end_head(const char* format, ...) {
305   va_list ap;
306   va_start(ap, format);
307   out()-&gt;vprint(format, ap);
308   va_end(ap);
309   end_head();
310 }
311 
312 
313 // ------------------------------------------------------------------
314 // Outputs &quot;&lt;/kind&gt;&quot;.
315 void xmlStream::tail(const char* kind) {
316   pop_tag(kind);
317   print_raw(&quot;&lt;/&quot;);
318   print_raw(kind);
319   print_raw(&quot;&gt;\n&quot;);
320 }
321 
322 // ------------------------------------------------------------------
323 // Outputs &quot;&lt;kind_done ... stamp=&#39;D.DD&#39;/&gt; &lt;/kind&gt;&quot;.
324 void xmlStream::done(const char* format, ...) {
325   va_list ap;
326   va_start(ap, format);
327   va_done(format, ap);
328   va_end(ap);
329 }
330 
331 // ------------------------------------------------------------------
332 // Outputs &quot;&lt;kind_done stamp=&#39;D.DD&#39;/&gt; &lt;/kind&gt;&quot;.
333 // Because done_raw() doesn&#39;t need to format strings, it&#39;s simpler than
334 // done(), and can be called safely by fatal error handler.
335 void xmlStream::done_raw(const char* kind) {
336   print_raw(&quot;&lt;&quot;);
337   print_raw(kind);
338   print_raw(&quot;_done stamp=&#39;&quot;);
339   out()-&gt;stamp();
340   print_raw_cr(&quot;&#39;/&gt;&quot;);
341   print_raw(&quot;&lt;/&quot;);
342   print_raw(kind);
343   print_raw_cr(&quot;&gt;&quot;);
344 }
345 
346 // If you remove the PRAGMA, this fails to compile with clang-503.0.40.
347 PRAGMA_DIAG_PUSH
348 PRAGMA_FORMAT_NONLITERAL_IGNORED
349 // ------------------------------------------------------------------
350 void xmlStream::va_done(const char* format, va_list ap) {
351   char buffer[200];
352   size_t format_len = strlen(format);
353   guarantee(format_len + 10 &lt; sizeof(buffer), &quot;bigger format buffer&quot;);
354   const char* kind = format;
355   const char* kind_end = strchr(kind, &#39; &#39;);
356   size_t kind_len;
357   if (kind_end != NULL) {
358     kind_len = kind_end - kind;
359     int n = os::snprintf(buffer, sizeof(buffer), &quot;%.*s_done&quot;, (int)kind_len, kind);
360     assert((size_t)n &lt; sizeof(buffer), &quot;Unexpected number of characters in string&quot;);
361   } else {
362     kind_len = format_len;
363     int n = os::snprintf(buffer, sizeof(buffer), &quot;%s_done%s&quot;, kind, kind + kind_len);
364     assert((size_t)n &lt; sizeof(buffer), &quot;Unexpected number of characters in string&quot;);
365   }
366   // Output the trailing event with the timestamp.
367   va_begin_elem(buffer, ap);
368   stamp();
369   end_elem();
370   // Output the tail-tag of the enclosing element.
371   buffer[kind_len] = 0;
372   tail(buffer);
373 }
374 PRAGMA_DIAG_POP
375 
376 // Output a timestamp attribute.
377 void xmlStream::stamp() {
378   assert_if_no_error(inside_attrs(), &quot;stamp must be an attribute&quot;);
379   print_raw(&quot; stamp=&#39;&quot;);
380   out()-&gt;stamp();
381   print_raw(&quot;&#39;&quot;);
382 }
383 
384 
385 // ------------------------------------------------------------------
386 // Output a method attribute, in the form &quot; method=&#39;pkg/cls name sig&#39;&quot;.
387 // This is used only when there is no ciMethod available.
388 void xmlStream::method(Method* method) {
389   assert_if_no_error(inside_attrs(), &quot;printing attributes&quot;);
390   if (method == NULL)  return;
391   print_raw(&quot; method=&#39;&quot;);
392   method_text(method);
393   print(&quot;&#39; bytes=&#39;%d&#39;&quot;, method-&gt;code_size());
394   print(&quot; count=&#39;%d&#39;&quot;, method-&gt;invocation_count());
395   int bec = method-&gt;backedge_count();
396   if (bec != 0)  print(&quot; backedge_count=&#39;%d&#39;&quot;, bec);
397   print(&quot; iicount=&#39;%d&#39;&quot;, method-&gt;interpreter_invocation_count());
398   int throwouts = method-&gt;interpreter_throwout_count();
399   if (throwouts != 0)  print(&quot; throwouts=&#39;%d&#39;&quot;, throwouts);
400   MethodData* mdo = method-&gt;method_data();
401   if (mdo != NULL) {
402     uint cnt;
403     cnt = mdo-&gt;decompile_count();
404     if (cnt != 0)  print(&quot; decompiles=&#39;%d&#39;&quot;, cnt);
405     for (uint reason = 0; reason &lt; mdo-&gt;trap_reason_limit(); reason++) {
406       cnt = mdo-&gt;trap_count(reason);
407       if (cnt != 0)  print(&quot; %s_traps=&#39;%d&#39;&quot;, Deoptimization::trap_reason_name(reason), cnt);
408     }
409     cnt = mdo-&gt;overflow_trap_count();
410     if (cnt != 0)  print(&quot; overflow_traps=&#39;%d&#39;&quot;, cnt);
411     cnt = mdo-&gt;overflow_recompile_count();
412     if (cnt != 0)  print(&quot; overflow_recompiles=&#39;%d&#39;&quot;, cnt);
413   }
414 }
415 
416 void xmlStream::method_text(Method* method) {
417   ResourceMark rm;
418   assert_if_no_error(inside_attrs(), &quot;printing attributes&quot;);
419   if (method == NULL)  return;
420   text()-&gt;print(&quot;%s&quot;, method-&gt;method_holder()-&gt;external_name());
421   print_raw(&quot; &quot;);  // &quot; &quot; is easier for tools to parse than &quot;::&quot;
422   method-&gt;name()-&gt;print_symbol_on(text());
423   print_raw(&quot; &quot;);  // separator
424   method-&gt;signature()-&gt;print_symbol_on(text());
425 }
426 
427 
428 // ------------------------------------------------------------------
429 // Output a klass attribute, in the form &quot; klass=&#39;pkg/cls&#39;&quot;.
430 // This is used only when there is no ciKlass available.
431 void xmlStream::klass(Klass* klass) {
432   assert_if_no_error(inside_attrs(), &quot;printing attributes&quot;);
433   if (klass == NULL) return;
434   print_raw(&quot; klass=&#39;&quot;);
435   klass_text(klass);
436   print_raw(&quot;&#39;&quot;);
437 }
438 
439 void xmlStream::klass_text(Klass* klass) {
440   assert_if_no_error(inside_attrs(), &quot;printing attributes&quot;);
441   if (klass == NULL) return;
442   //klass-&gt;print_short_name(log-&gt;out());
443   klass-&gt;name()-&gt;print_symbol_on(out());
444 }
445 
446 void xmlStream::name(const Symbol* name) {
447   assert_if_no_error(inside_attrs(), &quot;printing attributes&quot;);
448   if (name == NULL)  return;
449   print_raw(&quot; name=&#39;&quot;);
450   name_text(name);
451   print_raw(&quot;&#39;&quot;);
452 }
453 
454 void xmlStream::name_text(const Symbol* name) {
455   assert_if_no_error(inside_attrs(), &quot;printing attributes&quot;);
456   if (name == NULL)  return;
457   //name-&gt;print_short_name(text());
458   name-&gt;print_symbol_on(text());
459 }
460 
461 void xmlStream::object(const char* attr, Handle x) {
462   assert_if_no_error(inside_attrs(), &quot;printing attributes&quot;);
463   if (x == NULL)  return;
464   print_raw(&quot; &quot;);
465   print_raw(attr);
466   print_raw(&quot;=&#39;&quot;);
467   object_text(x);
468   print_raw(&quot;&#39;&quot;);
469 }
470 
471 void xmlStream::object_text(Handle x) {
472   assert_if_no_error(inside_attrs(), &quot;printing attributes&quot;);
473   if (x == NULL)  return;
474   x-&gt;print_value_on(text());
475 }
476 
477 
478 void xmlStream::object(const char* attr, Metadata* x) {
479   assert_if_no_error(inside_attrs(), &quot;printing attributes&quot;);
480   if (x == NULL)  return;
481   print_raw(&quot; &quot;);
482   print_raw(attr);
483   print_raw(&quot;=&#39;&quot;);
484   object_text(x);
485   print_raw(&quot;&#39;&quot;);
486 }
487 
488 void xmlStream::object_text(Metadata* x) {
489   assert_if_no_error(inside_attrs(), &quot;printing attributes&quot;);
490   if (x == NULL)  return;
491   //x-&gt;print_value_on(text());
492   if (x-&gt;is_method())
493     method_text((Method*)x);
494   else if (x-&gt;is_klass())
495     klass_text((Klass*)x);
496   else
497     ShouldNotReachHere(); // Add impl if this is reached.
498 }
499 
500 
501 void xmlStream::flush() {
502   out()-&gt;flush();
503   _last_flush = count();
504 }
505 
506 void xmlTextStream::flush() {
507   if (_outer_xmlStream == NULL)  return;
508   _outer_xmlStream-&gt;flush();
509 }
510 
511 void xmlTextStream::write(const char* str, size_t len) {
512   if (_outer_xmlStream == NULL)  return;
513   _outer_xmlStream-&gt;write_text(str, len);
514   update_position(str, len);
515 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/utilities/ostream.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;oops/oop.inline.hpp&quot;
  30 #include &quot;runtime/arguments.hpp&quot;
  31 #include &quot;runtime/os.inline.hpp&quot;
  32 #include &quot;runtime/vm_version.hpp&quot;
  33 #include &quot;utilities/defaultStream.hpp&quot;
  34 #include &quot;utilities/macros.hpp&quot;
  35 #include &quot;utilities/ostream.hpp&quot;
  36 #include &quot;utilities/vmError.hpp&quot;
  37 #include &quot;utilities/xmlstream.hpp&quot;
  38 
  39 // Declarations of jvm methods
  40 extern &quot;C&quot; void jio_print(const char* s, size_t len);
  41 extern &quot;C&quot; int jio_printf(const char *fmt, ...);
  42 
  43 outputStream::outputStream(int width) {
  44   _width       = width;
  45   _position    = 0;
  46   _newlines    = 0;
  47   _precount    = 0;
  48   _indentation = 0;
  49   _scratch     = NULL;
  50   _scratch_len = 0;
  51 }
  52 
  53 outputStream::outputStream(int width, bool has_time_stamps) {
  54   _width       = width;
  55   _position    = 0;
  56   _newlines    = 0;
  57   _precount    = 0;
  58   _indentation = 0;
  59   _scratch     = NULL;
  60   _scratch_len = 0;
  61   if (has_time_stamps)  _stamp.update();
  62 }
  63 
  64 void outputStream::update_position(const char* s, size_t len) {
  65   for (size_t i = 0; i &lt; len; i++) {
  66     char ch = s[i];
  67     if (ch == &#39;\n&#39;) {
  68       _newlines += 1;
  69       _precount += _position + 1;
  70       _position = 0;
  71     } else if (ch == &#39;\t&#39;) {
  72       int tw = 8 - (_position &amp; 7);
  73       _position += tw;
  74       _precount -= tw-1;  // invariant:  _precount + _position == total count
  75     } else {
  76       _position += 1;
  77     }
  78   }
  79 }
  80 
  81 // Execute a vsprintf, using the given buffer if necessary.
  82 // Return a pointer to the formatted string.
  83 const char* outputStream::do_vsnprintf(char* buffer, size_t buflen,
  84                                        const char* format, va_list ap,
  85                                        bool add_cr,
  86                                        size_t&amp; result_len) {
  87   assert(buflen &gt;= 2, &quot;buffer too small&quot;);
  88 
  89   const char* result;
  90   if (add_cr)  buflen--;
  91   if (!strchr(format, &#39;%&#39;)) {
  92     // constant format string
  93     result = format;
  94     result_len = strlen(result);
  95     if (add_cr &amp;&amp; result_len &gt;= buflen)  result_len = buflen-1;  // truncate
  96   } else if (format[0] == &#39;%&#39; &amp;&amp; format[1] == &#39;s&#39; &amp;&amp; format[2] == &#39;\0&#39;) {
  97     // trivial copy-through format string
  98     result = va_arg(ap, const char*);
  99     result_len = strlen(result);
 100     if (add_cr &amp;&amp; result_len &gt;= buflen)  result_len = buflen-1;  // truncate
 101   } else {
 102     int written = os::vsnprintf(buffer, buflen, format, ap);
 103     assert(written &gt;= 0, &quot;vsnprintf encoding error&quot;);
 104     result = buffer;
 105     if ((size_t)written &lt; buflen) {
 106       result_len = written;
 107     } else {
 108       DEBUG_ONLY(warning(&quot;increase O_BUFLEN in ostream.hpp -- output truncated&quot;);)
 109       result_len = buflen - 1;
 110     }
 111   }
 112   if (add_cr) {
 113     if (result != buffer) {
 114       memcpy(buffer, result, result_len);
 115       result = buffer;
 116     }
 117     buffer[result_len++] = &#39;\n&#39;;
 118     buffer[result_len] = 0;
 119   }
 120   return result;
 121 }
 122 
 123 void outputStream::do_vsnprintf_and_write_with_automatic_buffer(const char* format, va_list ap, bool add_cr) {
 124   char buffer[O_BUFLEN];
 125   size_t len;
 126   const char* str = do_vsnprintf(buffer, sizeof(buffer), format, ap, add_cr, len);
 127   write(str, len);
 128 }
 129 
 130 void outputStream::do_vsnprintf_and_write_with_scratch_buffer(const char* format, va_list ap, bool add_cr) {
 131   size_t len;
 132   const char* str = do_vsnprintf(_scratch, _scratch_len, format, ap, add_cr, len);
 133   write(str, len);
 134 }
 135 
 136 void outputStream::do_vsnprintf_and_write(const char* format, va_list ap, bool add_cr) {
 137   if (_scratch) {
 138     do_vsnprintf_and_write_with_scratch_buffer(format, ap, add_cr);
 139   } else {
 140     do_vsnprintf_and_write_with_automatic_buffer(format, ap, add_cr);
 141   }
 142 }
 143 
 144 void outputStream::print(const char* format, ...) {
 145   va_list ap;
 146   va_start(ap, format);
 147   do_vsnprintf_and_write(format, ap, false);
 148   va_end(ap);
 149 }
 150 
 151 void outputStream::print_cr(const char* format, ...) {
 152   va_list ap;
 153   va_start(ap, format);
 154   do_vsnprintf_and_write(format, ap, true);
 155   va_end(ap);
 156 }
 157 
 158 void outputStream::vprint(const char *format, va_list argptr) {
 159   do_vsnprintf_and_write(format, argptr, false);
 160 }
 161 
 162 void outputStream::vprint_cr(const char* format, va_list argptr) {
 163   do_vsnprintf_and_write(format, argptr, true);
 164 }
 165 
 166 void outputStream::fill_to(int col) {
 167   int need_fill = col - position();
 168   sp(need_fill);
 169 }
 170 
 171 void outputStream::move_to(int col, int slop, int min_space) {
 172   if (position() &gt;= col + slop)
 173     cr();
 174   int need_fill = col - position();
 175   if (need_fill &lt; min_space)
 176     need_fill = min_space;
 177   sp(need_fill);
 178 }
 179 
 180 void outputStream::put(char ch) {
 181   assert(ch != 0, &quot;please fix call site&quot;);
 182   char buf[] = { ch, &#39;\0&#39; };
 183   write(buf, 1);
 184 }
 185 
 186 #define SP_USE_TABS false
 187 
 188 void outputStream::sp(int count) {
 189   if (count &lt; 0)  return;
 190   if (SP_USE_TABS &amp;&amp; count &gt;= 8) {
 191     int target = position() + count;
 192     while (count &gt;= 8) {
 193       this-&gt;write(&quot;\t&quot;, 1);
 194       count -= 8;
 195     }
 196     count = target - position();
 197   }
 198   while (count &gt; 0) {
 199     int nw = (count &gt; 8) ? 8 : count;
 200     this-&gt;write(&quot;        &quot;, nw);
 201     count -= nw;
 202   }
 203 }
 204 
 205 void outputStream::cr() {
 206   this-&gt;write(&quot;\n&quot;, 1);
 207 }
 208 
 209 void outputStream::cr_indent() {
 210   cr(); indent();
 211 }
 212 
 213 void outputStream::stamp() {
 214   if (! _stamp.is_updated()) {
 215     _stamp.update(); // start at 0 on first call to stamp()
 216   }
 217 
 218   // outputStream::stamp() may get called by ostream_abort(), use snprintf
 219   // to avoid allocating large stack buffer in print().
 220   char buf[40];
 221   jio_snprintf(buf, sizeof(buf), &quot;%.3f&quot;, _stamp.seconds());
 222   print_raw(buf);
 223 }
 224 
 225 void outputStream::stamp(bool guard,
 226                          const char* prefix,
 227                          const char* suffix) {
 228   if (!guard) {
 229     return;
 230   }
 231   print_raw(prefix);
 232   stamp();
 233   print_raw(suffix);
 234 }
 235 
 236 void outputStream::date_stamp(bool guard,
 237                               const char* prefix,
 238                               const char* suffix) {
 239   if (!guard) {
 240     return;
 241   }
 242   print_raw(prefix);
 243   static const char error_time[] = &quot;yyyy-mm-ddThh:mm:ss.mmm+zzzz&quot;;
 244   static const int buffer_length = 32;
 245   char buffer[buffer_length];
 246   const char* iso8601_result = os::iso8601_time(buffer, buffer_length);
 247   if (iso8601_result != NULL) {
 248     print_raw(buffer);
 249   } else {
 250     print_raw(error_time);
 251   }
 252   print_raw(suffix);
 253   return;
 254 }
 255 
 256 outputStream&amp; outputStream::indent() {
 257   while (_position &lt; _indentation) sp();
 258   return *this;
 259 }
 260 
 261 void outputStream::print_jlong(jlong value) {
 262   print(JLONG_FORMAT, value);
 263 }
 264 
 265 void outputStream::print_julong(julong value) {
 266   print(JULONG_FORMAT, value);
 267 }
 268 
 269 /**
 270  * This prints out hex data in a &#39;windbg&#39; or &#39;xxd&#39; form, where each line is:
 271  *   &lt;hex-address&gt;: 8 * &lt;hex-halfword&gt; &lt;ascii translation (optional)&gt;
 272  * example:
 273  * 0000000: 7f44 4f46 0102 0102 0000 0000 0000 0000  .DOF............
 274  * 0000010: 0000 0000 0000 0040 0000 0020 0000 0005  .......@... ....
 275  * 0000020: 0000 0000 0000 0040 0000 0000 0000 015d  .......@.......]
 276  * ...
 277  *
 278  * indent is applied to each line.  Ends with a CR.
 279  */
 280 void outputStream::print_data(void* data, size_t len, bool with_ascii) {
 281   size_t limit = (len + 16) / 16 * 16;
 282   for (size_t i = 0; i &lt; limit; ++i) {
 283     if (i % 16 == 0) {
 284       indent().print(INTPTR_FORMAT_W(07) &quot;:&quot;, i);
 285     }
 286     if (i % 2 == 0) {
 287       print(&quot; &quot;);
 288     }
 289     if (i &lt; len) {
 290       print(&quot;%02x&quot;, ((unsigned char*)data)[i]);
 291     } else {
 292       print(&quot;  &quot;);
 293     }
 294     if ((i + 1) % 16 == 0) {
 295       if (with_ascii) {
 296         print(&quot;  &quot;);
 297         for (size_t j = 0; j &lt; 16; ++j) {
 298           size_t idx = i + j - 15;
 299           if (idx &lt; len) {
 300             char c = ((char*)data)[idx];
 301             print(&quot;%c&quot;, c &gt;= 32 &amp;&amp; c &lt;= 126 ? c : &#39;.&#39;);
 302           }
 303         }
 304       }
 305       cr();
 306     }
 307   }
 308 }
 309 
 310 stringStream::stringStream(size_t initial_size) : outputStream() {
 311   buffer_length = initial_size;
 312   buffer        = NEW_RESOURCE_ARRAY(char, buffer_length);
 313   buffer_pos    = 0;
 314   buffer_fixed  = false;
 315   DEBUG_ONLY(rm = Thread::current()-&gt;current_resource_mark();)
 316 }
 317 
 318 // useful for output to fixed chunks of memory, such as performance counters
 319 stringStream::stringStream(char* fixed_buffer, size_t fixed_buffer_size) : outputStream() {
 320   buffer_length = fixed_buffer_size;
 321   buffer        = fixed_buffer;
 322   buffer_pos    = 0;
 323   buffer_fixed  = true;
 324 }
 325 
 326 void stringStream::write(const char* s, size_t len) {
 327   size_t write_len = len;               // number of non-null bytes to write
 328   size_t end = buffer_pos + len + 1;    // position after write and final &#39;\0&#39;
 329   if (end &gt; buffer_length) {
 330     if (buffer_fixed) {
 331       // if buffer cannot resize, silently truncate
 332       end = buffer_length;
 333       write_len = end - buffer_pos - 1; // leave room for the final &#39;\0&#39;
 334     } else {
 335       // For small overruns, double the buffer.  For larger ones,
 336       // increase to the requested size.
 337       if (end &lt; buffer_length * 2) {
 338         end = buffer_length * 2;
 339       }
 340       char* oldbuf = buffer;
 341       assert(rm == NULL || Thread::current()-&gt;current_resource_mark() == rm,
 342              &quot;StringStream is re-allocated with a different ResourceMark. Current: &quot;
 343              PTR_FORMAT &quot; original: &quot; PTR_FORMAT,
 344              p2i(Thread::current()-&gt;current_resource_mark()), p2i(rm));
 345       buffer = NEW_RESOURCE_ARRAY(char, end);
 346       if (buffer_pos &gt; 0) {
 347         memcpy(buffer, oldbuf, buffer_pos);
 348       }
 349       buffer_length = end;
 350     }
 351   }
 352   // invariant: buffer is always null-terminated
 353   guarantee(buffer_pos + write_len + 1 &lt;= buffer_length, &quot;stringStream oob&quot;);
 354   if (write_len &gt; 0) {
 355     buffer[buffer_pos + write_len] = 0;
 356     memcpy(buffer + buffer_pos, s, write_len);
 357     buffer_pos += write_len;
 358   }
 359 
 360   // Note that the following does not depend on write_len.
 361   // This means that position and count get updated
 362   // even when overflow occurs.
 363   update_position(s, len);
 364 }
 365 
 366 char* stringStream::as_string() {
 367   char* copy = NEW_RESOURCE_ARRAY(char, buffer_pos + 1);
 368   strncpy(copy, buffer, buffer_pos);
 369   copy[buffer_pos] = 0;  // terminating null
 370   return copy;
 371 }
 372 
 373 stringStream::~stringStream() {}
 374 
 375 xmlStream*   xtty;
 376 outputStream* tty;
 377 CDS_ONLY(fileStream* classlist_file;) // Only dump the classes that can be stored into the CDS archive
 378 extern Mutex* tty_lock;
 379 
 380 #define EXTRACHARLEN   32
 381 #define CURRENTAPPX    &quot;.current&quot;
 382 // convert YYYY-MM-DD HH:MM:SS to YYYY-MM-DD_HH-MM-SS
 383 char* get_datetime_string(char *buf, size_t len) {
 384   os::local_time_string(buf, len);
 385   int i = (int)strlen(buf);
 386   while (--i &gt;= 0) {
 387     if (buf[i] == &#39; &#39;) buf[i] = &#39;_&#39;;
 388     else if (buf[i] == &#39;:&#39;) buf[i] = &#39;-&#39;;
 389   }
 390   return buf;
 391 }
 392 
 393 static const char* make_log_name_internal(const char* log_name, const char* force_directory,
 394                                                 int pid, const char* tms) {
 395   const char* basename = log_name;
 396   char file_sep = os::file_separator()[0];
 397   const char* cp;
 398   char  pid_text[32];
 399 
 400   for (cp = log_name; *cp != &#39;\0&#39;; cp++) {
 401     if (*cp == &#39;/&#39; || *cp == file_sep) {
 402       basename = cp + 1;
 403     }
 404   }
 405   const char* nametail = log_name;
 406   // Compute buffer length
 407   size_t buffer_length;
 408   if (force_directory != NULL) {
 409     buffer_length = strlen(force_directory) + strlen(os::file_separator()) +
 410                     strlen(basename) + 1;
 411   } else {
 412     buffer_length = strlen(log_name) + 1;
 413   }
 414 
 415   const char* pts = strstr(basename, &quot;%p&quot;);
 416   int pid_pos = (pts == NULL) ? -1 : (pts - nametail);
 417 
 418   if (pid_pos &gt;= 0) {
 419     jio_snprintf(pid_text, sizeof(pid_text), &quot;pid%u&quot;, pid);
 420     buffer_length += strlen(pid_text);
 421   }
 422 
 423   pts = strstr(basename, &quot;%t&quot;);
 424   int tms_pos = (pts == NULL) ? -1 : (pts - nametail);
 425   if (tms_pos &gt;= 0) {
 426     buffer_length += strlen(tms);
 427   }
 428 
 429   // File name is too long.
 430   if (buffer_length &gt; JVM_MAXPATHLEN) {
 431     return NULL;
 432   }
 433 
 434   // Create big enough buffer.
 435   char *buf = NEW_C_HEAP_ARRAY(char, buffer_length, mtInternal);
 436 
 437   strcpy(buf, &quot;&quot;);
 438   if (force_directory != NULL) {
 439     strcat(buf, force_directory);
 440     strcat(buf, os::file_separator());
 441     nametail = basename;       // completely skip directory prefix
 442   }
 443 
 444   // who is first, %p or %t?
 445   int first = -1, second = -1;
 446   const char *p1st = NULL;
 447   const char *p2nd = NULL;
 448 
 449   if (pid_pos &gt;= 0 &amp;&amp; tms_pos &gt;= 0) {
 450     // contains both %p and %t
 451     if (pid_pos &lt; tms_pos) {
 452       // case foo%pbar%tmonkey.log
 453       first  = pid_pos;
 454       p1st   = pid_text;
 455       second = tms_pos;
 456       p2nd   = tms;
 457     } else {
 458       // case foo%tbar%pmonkey.log
 459       first  = tms_pos;
 460       p1st   = tms;
 461       second = pid_pos;
 462       p2nd   = pid_text;
 463     }
 464   } else if (pid_pos &gt;= 0) {
 465     // contains %p only
 466     first  = pid_pos;
 467     p1st   = pid_text;
 468   } else if (tms_pos &gt;= 0) {
 469     // contains %t only
 470     first  = tms_pos;
 471     p1st   = tms;
 472   }
 473 
 474   int buf_pos = (int)strlen(buf);
 475   const char* tail = nametail;
 476 
 477   if (first &gt;= 0) {
 478     tail = nametail + first + 2;
 479     strncpy(&amp;buf[buf_pos], nametail, first);
 480     strcpy(&amp;buf[buf_pos + first], p1st);
 481     buf_pos = (int)strlen(buf);
 482     if (second &gt;= 0) {
 483       strncpy(&amp;buf[buf_pos], tail, second - first - 2);
 484       strcpy(&amp;buf[buf_pos + second - first - 2], p2nd);
 485       tail = nametail + second + 2;
 486     }
 487   }
 488   strcat(buf, tail);      // append rest of name, or all of name
 489   return buf;
 490 }
 491 
 492 // log_name comes from -XX:LogFile=log_name or
 493 // -XX:DumpLoadedClassList=&lt;file_name&gt;
 494 // in log_name, %p =&gt; pid1234 and
 495 //              %t =&gt; YYYY-MM-DD_HH-MM-SS
 496 static const char* make_log_name(const char* log_name, const char* force_directory) {
 497   char timestr[32];
 498   get_datetime_string(timestr, sizeof(timestr));
 499   return make_log_name_internal(log_name, force_directory, os::current_process_id(),
 500                                 timestr);
 501 }
 502 
 503 fileStream::fileStream(const char* file_name) {
 504   _file = fopen(file_name, &quot;w&quot;);
 505   if (_file != NULL) {
 506     _need_close = true;
 507   } else {
 508     warning(&quot;Cannot open file %s due to %s\n&quot;, file_name, os::strerror(errno));
 509     _need_close = false;
 510   }
 511 }
 512 
 513 fileStream::fileStream(const char* file_name, const char* opentype) {
 514   _file = fopen(file_name, opentype);
 515   if (_file != NULL) {
 516     _need_close = true;
 517   } else {
 518     warning(&quot;Cannot open file %s due to %s\n&quot;, file_name, os::strerror(errno));
 519     _need_close = false;
 520   }
 521 }
 522 
 523 void fileStream::write(const char* s, size_t len) {
 524   if (_file != NULL)  {
 525     // Make an unused local variable to avoid warning from gcc 4.x compiler.
 526     size_t count = fwrite(s, 1, len, _file);
 527   }
 528   update_position(s, len);
 529 }
 530 
 531 long fileStream::fileSize() {
 532   long size = -1;
 533   if (_file != NULL) {
 534     long pos = ::ftell(_file);
 535     if (pos &lt; 0) return pos;
 536     if (::fseek(_file, 0, SEEK_END) == 0) {
 537       size = ::ftell(_file);
 538     }
 539     ::fseek(_file, pos, SEEK_SET);
 540   }
 541   return size;
 542 }
 543 
 544 char* fileStream::readln(char *data, int count ) {
 545   char * ret = ::fgets(data, count, _file);
 546   //Get rid of annoying \n char
 547   data[::strlen(data)-1] = &#39;\0&#39;;
 548   return ret;
 549 }
 550 
 551 fileStream::~fileStream() {
 552   if (_file != NULL) {
 553     if (_need_close) fclose(_file);
 554     _file      = NULL;
 555   }
 556 }
 557 
 558 void fileStream::flush() {
 559   fflush(_file);
 560 }
 561 
 562 void fdStream::write(const char* s, size_t len) {
 563   if (_fd != -1) {
 564     // Make an unused local variable to avoid warning from gcc 4.x compiler.
 565     size_t count = ::write(_fd, s, (int)len);
 566   }
 567   update_position(s, len);
 568 }
 569 
 570 defaultStream* defaultStream::instance = NULL;
 571 int defaultStream::_output_fd = 1;
 572 int defaultStream::_error_fd  = 2;
 573 FILE* defaultStream::_output_stream = stdout;
 574 FILE* defaultStream::_error_stream  = stderr;
 575 
 576 #define LOG_MAJOR_VERSION 160
 577 #define LOG_MINOR_VERSION 1
 578 
 579 void defaultStream::init() {
 580   _inited = true;
 581   if (LogVMOutput || LogCompilation) {
 582     init_log();
 583   }
 584 }
 585 
 586 bool defaultStream::has_log_file() {
 587   // lazily create log file (at startup, LogVMOutput is false even
 588   // if +LogVMOutput is used, because the flags haven&#39;t been parsed yet)
 589   // For safer printing during fatal error handling, do not init logfile
 590   // if a VM error has been reported.
 591   if (!_inited &amp;&amp; !VMError::is_error_reported())  init();
 592   return _log_file != NULL;
 593 }
 594 
 595 fileStream* defaultStream::open_file(const char* log_name) {
 596   const char* try_name = make_log_name(log_name, NULL);
 597   if (try_name == NULL) {
 598     warning(&quot;Cannot open file %s: file name is too long.\n&quot;, log_name);
 599     return NULL;
 600   }
 601 
 602   fileStream* file = new(ResourceObj::C_HEAP, mtInternal) fileStream(try_name);
 603   FREE_C_HEAP_ARRAY(char, try_name);
 604   if (file-&gt;is_open()) {
 605     return file;
 606   }
 607 
 608   // Try again to open the file in the temp directory.
 609   delete file;
 610   // Note: This feature is for maintainer use only.  No need for L10N.
 611   jio_printf(&quot;Warning:  Cannot open log file: %s\n&quot;, log_name);
 612   try_name = make_log_name(log_name, os::get_temp_directory());
 613   if (try_name == NULL) {
 614     warning(&quot;Cannot open file %s: file name is too long for directory %s.\n&quot;, log_name, os::get_temp_directory());
 615     return NULL;
 616   }
 617 
 618   jio_printf(&quot;Warning:  Forcing option -XX:LogFile=%s\n&quot;, try_name);
 619 
 620   file = new(ResourceObj::C_HEAP, mtInternal) fileStream(try_name);
 621   FREE_C_HEAP_ARRAY(char, try_name);
 622   if (file-&gt;is_open()) {
 623     return file;
 624   }
 625 
 626   delete file;
 627   return NULL;
 628 }
 629 
 630 void defaultStream::init_log() {
 631   // %%% Need a MutexLocker?
 632   const char* log_name = LogFile != NULL ? LogFile : &quot;hotspot_%p.log&quot;;
 633   fileStream* file = open_file(log_name);
 634 
 635   if (file != NULL) {
 636     _log_file = file;
 637     _outer_xmlStream = new(ResourceObj::C_HEAP, mtInternal) xmlStream(file);
 638     start_log();
 639   } else {
 640     // and leave xtty as NULL
 641     LogVMOutput = false;
 642     DisplayVMOutput = true;
 643     LogCompilation = false;
 644   }
 645 }
 646 
 647 void defaultStream::start_log() {
 648   xmlStream*xs = _outer_xmlStream;
 649     if (this == tty)  xtty = xs;
 650     // Write XML header.
 651     xs-&gt;print_cr(&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;&quot;);
 652     // (For now, don&#39;t bother to issue a DTD for this private format.)
 653     jlong time_ms = os::javaTimeMillis() - tty-&gt;time_stamp().milliseconds();
 654     // %%% Should be: jlong time_ms = os::start_time_milliseconds(), if
 655     // we ever get round to introduce that method on the os class
 656     xs-&gt;head(&quot;hotspot_log version=&#39;%d %d&#39;&quot;
 657              &quot; process=&#39;%d&#39; time_ms=&#39;&quot; INT64_FORMAT &quot;&#39;&quot;,
 658              LOG_MAJOR_VERSION, LOG_MINOR_VERSION,
 659              os::current_process_id(), (int64_t)time_ms);
 660     // Write VM version header immediately.
 661     xs-&gt;head(&quot;vm_version&quot;);
 662     xs-&gt;head(&quot;name&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::vm_name()); xs-&gt;cr();
 663     xs-&gt;tail(&quot;name&quot;);
 664     xs-&gt;head(&quot;release&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::vm_release()); xs-&gt;cr();
 665     xs-&gt;tail(&quot;release&quot;);
 666     xs-&gt;head(&quot;info&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::internal_vm_info_string()); xs-&gt;cr();
 667     xs-&gt;tail(&quot;info&quot;);
 668     xs-&gt;tail(&quot;vm_version&quot;);
 669     // Record information about the command-line invocation.
 670     xs-&gt;head(&quot;vm_arguments&quot;);  // Cf. Arguments::print_on()
 671     if (Arguments::num_jvm_flags() &gt; 0) {
 672       xs-&gt;head(&quot;flags&quot;);
 673       Arguments::print_jvm_flags_on(xs-&gt;text());
 674       xs-&gt;tail(&quot;flags&quot;);
 675     }
 676     if (Arguments::num_jvm_args() &gt; 0) {
 677       xs-&gt;head(&quot;args&quot;);
 678       Arguments::print_jvm_args_on(xs-&gt;text());
 679       xs-&gt;tail(&quot;args&quot;);
 680     }
 681     if (Arguments::java_command() != NULL) {
 682       xs-&gt;head(&quot;command&quot;); xs-&gt;text()-&gt;print_cr(&quot;%s&quot;, Arguments::java_command());
 683       xs-&gt;tail(&quot;command&quot;);
 684     }
 685     if (Arguments::sun_java_launcher() != NULL) {
 686       xs-&gt;head(&quot;launcher&quot;); xs-&gt;text()-&gt;print_cr(&quot;%s&quot;, Arguments::sun_java_launcher());
 687       xs-&gt;tail(&quot;launcher&quot;);
 688     }
 689     if (Arguments::system_properties() !=  NULL) {
 690       xs-&gt;head(&quot;properties&quot;);
 691       // Print it as a java-style property list.
 692       // System properties don&#39;t generally contain newlines, so don&#39;t bother with unparsing.
 693       outputStream *text = xs-&gt;text();
 694       for (SystemProperty* p = Arguments::system_properties(); p != NULL; p = p-&gt;next()) {
 695         assert(p-&gt;key() != NULL, &quot;p-&gt;key() is NULL&quot;);
 696         if (p-&gt;is_readable()) {
 697           // Print in two stages to avoid problems with long
 698           // keys/values.
 699           text-&gt;print_raw(p-&gt;key());
 700           text-&gt;put(&#39;=&#39;);
 701           assert(p-&gt;value() != NULL, &quot;p-&gt;value() is NULL&quot;);
 702           text-&gt;print_raw_cr(p-&gt;value());
 703         }
 704       }
 705       xs-&gt;tail(&quot;properties&quot;);
 706     }
 707     xs-&gt;tail(&quot;vm_arguments&quot;);
 708     // tty output per se is grouped under the &lt;tty&gt;...&lt;/tty&gt; element.
 709     xs-&gt;head(&quot;tty&quot;);
 710     // All further non-markup text gets copied to the tty:
 711     xs-&gt;_text = this;  // requires friend declaration!
 712 }
 713 
 714 // finish_log() is called during normal VM shutdown. finish_log_on_error() is
 715 // called by ostream_abort() after a fatal error.
 716 //
 717 void defaultStream::finish_log() {
 718   xmlStream* xs = _outer_xmlStream;
 719   xs-&gt;done(&quot;tty&quot;);
 720 
 721   // Other log forks are appended here, at the End of Time:
 722   CompileLog::finish_log(xs-&gt;out());  // write compile logging, if any, now
 723 
 724   xs-&gt;done(&quot;hotspot_log&quot;);
 725   xs-&gt;flush();
 726 
 727   fileStream* file = _log_file;
 728   _log_file = NULL;
 729 
 730   delete _outer_xmlStream;
 731   _outer_xmlStream = NULL;
 732 
 733   file-&gt;flush();
 734   delete file;
 735 }
 736 
 737 void defaultStream::finish_log_on_error(char *buf, int buflen) {
 738   xmlStream* xs = _outer_xmlStream;
 739 
 740   if (xs &amp;&amp; xs-&gt;out()) {
 741 
 742     xs-&gt;done_raw(&quot;tty&quot;);
 743 
 744     // Other log forks are appended here, at the End of Time:
 745     CompileLog::finish_log_on_error(xs-&gt;out(), buf, buflen);  // write compile logging, if any, now
 746 
 747     xs-&gt;done_raw(&quot;hotspot_log&quot;);
 748     xs-&gt;flush();
 749 
 750     fileStream* file = _log_file;
 751     _log_file = NULL;
 752     _outer_xmlStream = NULL;
 753 
 754     if (file) {
 755       file-&gt;flush();
 756 
 757       // Can&#39;t delete or close the file because delete and fclose aren&#39;t
 758       // async-safe. We are about to die, so leave it to the kernel.
 759       // delete file;
 760     }
 761   }
 762 }
 763 
 764 intx defaultStream::hold(intx writer_id) {
 765   bool has_log = has_log_file();  // check before locking
 766   if (// impossible, but who knows?
 767       writer_id == NO_WRITER ||
 768 
 769       // bootstrap problem
 770       tty_lock == NULL ||
 771 
 772       // can&#39;t grab a lock if current Thread isn&#39;t set
 773       Thread::current_or_null() == NULL ||
 774 
 775       // developer hook
 776       !SerializeVMOutput ||
 777 
 778       // VM already unhealthy
 779       VMError::is_error_reported() ||
 780 
 781       // safepoint == global lock (for VM only)
 782       (SafepointSynchronize::is_synchronizing() &amp;&amp;
 783        Thread::current()-&gt;is_VM_thread())
 784       ) {
 785     // do not attempt to lock unless we know the thread and the VM is healthy
 786     return NO_WRITER;
 787   }
 788   if (_writer == writer_id) {
 789     // already held, no need to re-grab the lock
 790     return NO_WRITER;
 791   }
 792   tty_lock-&gt;lock_without_safepoint_check();
 793   // got the lock
 794   if (writer_id != _last_writer) {
 795     if (has_log) {
 796       _log_file-&gt;bol();
 797       // output a hint where this output is coming from:
 798       _log_file-&gt;print_cr(&quot;&lt;writer thread=&#39;&quot; UINTX_FORMAT &quot;&#39;/&gt;&quot;, writer_id);
 799     }
 800     _last_writer = writer_id;
 801   }
 802   _writer = writer_id;
 803   return writer_id;
 804 }
 805 
 806 void defaultStream::release(intx holder) {
 807   if (holder == NO_WRITER) {
 808     // nothing to release:  either a recursive lock, or we scribbled (too bad)
 809     return;
 810   }
 811   if (_writer != holder) {
 812     return;  // already unlocked, perhaps via break_tty_lock_for_safepoint
 813   }
 814   _writer = NO_WRITER;
 815   tty_lock-&gt;unlock();
 816 }
 817 
 818 void defaultStream::write(const char* s, size_t len) {
 819   intx thread_id = os::current_thread_id();
 820   intx holder = hold(thread_id);
 821 
 822   if (DisplayVMOutput &amp;&amp;
 823       (_outer_xmlStream == NULL || !_outer_xmlStream-&gt;inside_attrs())) {
 824     // print to output stream. It can be redirected by a vfprintf hook
 825     jio_print(s, len);
 826   }
 827 
 828   // print to log file
 829   if (has_log_file()) {
 830     int nl0 = _newlines;
 831     xmlTextStream::write(s, len);
 832     // flush the log file too, if there were any newlines
 833     if (nl0 != _newlines){
 834       flush();
 835     }
 836   } else {
 837     update_position(s, len);
 838   }
 839 
 840   release(holder);
 841 }
 842 
 843 intx ttyLocker::hold_tty() {
 844   if (defaultStream::instance == NULL)  return defaultStream::NO_WRITER;
 845   intx thread_id = os::current_thread_id();
 846   return defaultStream::instance-&gt;hold(thread_id);
 847 }
 848 
 849 void ttyLocker::release_tty(intx holder) {
 850   if (holder == defaultStream::NO_WRITER)  return;
 851   defaultStream::instance-&gt;release(holder);
 852 }
 853 
 854 bool ttyLocker::release_tty_if_locked() {
 855   intx thread_id = os::current_thread_id();
 856   if (defaultStream::instance-&gt;writer() == thread_id) {
 857     // release the lock and return true so callers know if was
 858     // previously held.
 859     release_tty(thread_id);
 860     return true;
 861   }
 862   return false;
 863 }
 864 
 865 void ttyLocker::break_tty_lock_for_safepoint(intx holder) {
 866   if (defaultStream::instance != NULL &amp;&amp;
 867       defaultStream::instance-&gt;writer() == holder) {
 868     if (xtty != NULL) {
 869       xtty-&gt;print_cr(&quot;&lt;!-- safepoint while printing --&gt;&quot;);
 870     }
 871     defaultStream::instance-&gt;release(holder);
 872   }
 873   // (else there was no lock to break)
 874 }
 875 
 876 void ostream_init() {
 877   if (defaultStream::instance == NULL) {
 878     defaultStream::instance = new(ResourceObj::C_HEAP, mtInternal) defaultStream();
 879     tty = defaultStream::instance;
 880 
 881     // We want to ensure that time stamps in GC logs consider time 0
 882     // the time when the JVM is initialized, not the first time we ask
 883     // for a time stamp. So, here, we explicitly update the time stamp
 884     // of tty.
 885     tty-&gt;time_stamp().update_to(1);
 886   }
 887 }
 888 
 889 void ostream_init_log() {
 890   // Note : this must be called AFTER ostream_init()
 891 
 892 #if INCLUDE_CDS
 893   // For -XX:DumpLoadedClassList=&lt;file&gt; option
 894   if (DumpLoadedClassList != NULL) {
 895     const char* list_name = make_log_name(DumpLoadedClassList, NULL);
 896     classlist_file = new(ResourceObj::C_HEAP, mtInternal)
 897                          fileStream(list_name);
 898     FREE_C_HEAP_ARRAY(char, list_name);
 899   }
 900 #endif
 901 
 902   // If we haven&#39;t lazily initialized the logfile yet, do it now,
 903   // to avoid the possibility of lazy initialization during a VM
 904   // crash, which can affect the stability of the fatal error handler.
 905   defaultStream::instance-&gt;has_log_file();
 906 }
 907 
 908 // ostream_exit() is called during normal VM exit to finish log files, flush
 909 // output and free resource.
 910 void ostream_exit() {
 911   static bool ostream_exit_called = false;
 912   if (ostream_exit_called)  return;
 913   ostream_exit_called = true;
 914 #if INCLUDE_CDS
 915   if (classlist_file != NULL) {
 916     delete classlist_file;
 917   }
 918 #endif
 919   if (tty != defaultStream::instance) {
 920     delete tty;
 921   }
 922   if (defaultStream::instance != NULL) {
 923     delete defaultStream::instance;
 924   }
 925   tty = NULL;
 926   xtty = NULL;
 927   defaultStream::instance = NULL;
 928 }
 929 
 930 // ostream_abort() is called by os::abort() when VM is about to die.
 931 void ostream_abort() {
 932   // Here we can&#39;t delete tty, just flush its output
 933   if (tty) tty-&gt;flush();
 934 
 935   if (defaultStream::instance != NULL) {
 936     static char buf[4096];
 937     defaultStream::instance-&gt;finish_log_on_error(buf, sizeof(buf));
 938   }
 939 }
 940 
 941 bufferedStream::bufferedStream(size_t initial_size, size_t bufmax) : outputStream() {
 942   buffer_length = initial_size;
 943   buffer        = NEW_C_HEAP_ARRAY(char, buffer_length, mtInternal);
 944   buffer_pos    = 0;
 945   buffer_fixed  = false;
 946   buffer_max    = bufmax;
 947 }
 948 
 949 bufferedStream::bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax) : outputStream() {
 950   buffer_length = fixed_buffer_size;
 951   buffer        = fixed_buffer;
 952   buffer_pos    = 0;
 953   buffer_fixed  = true;
 954   buffer_max    = bufmax;
 955 }
 956 
 957 void bufferedStream::write(const char* s, size_t len) {
 958 
 959   if(buffer_pos + len &gt; buffer_max) {
 960     flush();
 961   }
 962 
 963   size_t end = buffer_pos + len;
 964   if (end &gt;= buffer_length) {
 965     if (buffer_fixed) {
 966       // if buffer cannot resize, silently truncate
 967       len = buffer_length - buffer_pos - 1;
 968     } else {
 969       // For small overruns, double the buffer.  For larger ones,
 970       // increase to the requested size.
 971       if (end &lt; buffer_length * 2) {
 972         end = buffer_length * 2;
 973       }
 974       buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);
 975       buffer_length = end;
 976     }
 977   }
 978   memcpy(buffer + buffer_pos, s, len);
 979   buffer_pos += len;
 980   update_position(s, len);
 981 }
 982 
 983 char* bufferedStream::as_string() {
 984   char* copy = NEW_RESOURCE_ARRAY(char, buffer_pos+1);
 985   strncpy(copy, buffer, buffer_pos);
 986   copy[buffer_pos] = 0;  // terminating null
 987   return copy;
 988 }
 989 
 990 bufferedStream::~bufferedStream() {
 991   if (!buffer_fixed) {
 992     FREE_C_HEAP_ARRAY(char, buffer);
 993   }
 994 }
 995 
 996 #ifndef PRODUCT
 997 
 998 #if defined(SOLARIS) || defined(LINUX) || defined(AIX) || defined(_ALLBSD_SOURCE)
 999 #include &lt;sys/types.h&gt;
1000 #include &lt;sys/socket.h&gt;
1001 #include &lt;netinet/in.h&gt;
1002 #include &lt;arpa/inet.h&gt;
1003 #elif defined(_WINDOWS)
1004 #include &lt;winsock2.h&gt;
1005 #endif
1006 
1007 // Network access
1008 networkStream::networkStream() : bufferedStream(1024*10, 1024*10) {
1009 
1010   _socket = -1;
1011 
1012   int result = os::socket(AF_INET, SOCK_STREAM, 0);
1013   if (result &lt;= 0) {
1014     assert(false, &quot;Socket could not be created!&quot;);
1015   } else {
1016     _socket = result;
1017   }
1018 }
1019 
1020 int networkStream::read(char *buf, size_t len) {
1021   return os::recv(_socket, buf, (int)len, 0);
1022 }
1023 
1024 void networkStream::flush() {
1025   if (size() != 0) {
1026     int result = os::raw_send(_socket, (char *)base(), size(), 0);
1027     assert(result != -1, &quot;connection error&quot;);
1028     assert(result == (int)size(), &quot;didn&#39;t send enough data&quot;);
1029   }
1030   reset();
1031 }
1032 
1033 networkStream::~networkStream() {
1034   close();
1035 }
1036 
1037 void networkStream::close() {
1038   if (_socket != -1) {
1039     flush();
1040     os::socket_close(_socket);
1041     _socket = -1;
1042   }
1043 }
1044 
1045 bool networkStream::connect(const char *ip, short port) {
1046 
1047   struct sockaddr_in server;
1048   server.sin_family = AF_INET;
1049   server.sin_port = htons(port);
1050 
1051   server.sin_addr.s_addr = inet_addr(ip);
1052   if (server.sin_addr.s_addr == (uint32_t)-1) {
1053     struct hostent* host = os::get_host_by_name((char*)ip);
1054     if (host != NULL) {
1055       memcpy(&amp;server.sin_addr, host-&gt;h_addr_list[0], host-&gt;h_length);
1056     } else {
1057       return false;
1058     }
1059   }
1060 
1061 
1062   int result = os::connect(_socket, (struct sockaddr*)&amp;server, sizeof(struct sockaddr_in));
1063   return (result &gt;= 0);
1064 }
1065 
1066 #endif
    </pre>
  </body>
</html>
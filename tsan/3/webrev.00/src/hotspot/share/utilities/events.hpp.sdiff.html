<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/events.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="events.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="exceptions.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/events.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_EVENTS_HPP
 26 #define SHARE_UTILITIES_EVENTS_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/mutexLocker.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 #include &quot;utilities/formatBuffer.hpp&quot;


 32 #include &quot;utilities/vmError.hpp&quot;
 33 
 34 // Events and EventMark provide interfaces to log events taking place in the vm.
 35 // This facility is extremly useful for post-mortem debugging. The eventlog
 36 // often provides crucial information about events leading up to the crash.
 37 //
 38 // Abstractly the logs can record whatever they way but normally they
 39 // would record at least a timestamp and the current Thread, along
 40 // with whatever data they need in a ring buffer.  Commonly fixed
 41 // length text messages are recorded for simplicity but other
 42 // strategies could be used.  Several logs are provided by default but
 43 // new instances can be created as needed.
 44 
 45 // The base event log dumping class that is registered for dumping at
 46 // crash time.  This is a very generic interface that is mainly here
 47 // for completeness.  Normally the templated EventLogBase would be
 48 // subclassed to provide different log types.
 49 class EventLog : public CHeapObj&lt;mtInternal&gt; {
 50   friend class Events;
 51 
 52  private:
 53   EventLog* _next;
 54 
 55   EventLog* next() const { return _next; }
 56 
 57  public:
 58   // Automatically registers the log so that it will be printed during
 59   // crashes.
 60   EventLog();
 61 
<span class="line-modified"> 62   virtual void print_log_on(outputStream* out) = 0;</span>








 63 };
 64 
 65 
 66 // A templated subclass of EventLog that provides basic ring buffer
 67 // functionality.  Most event loggers should subclass this, possibly
 68 // providing a more featureful log function if the existing copy
 69 // semantics aren&#39;t appropriate.  The name is used as the label of the
 70 // log when it is dumped during a crash.
 71 template &lt;class T&gt; class EventLogBase : public EventLog {
 72   template &lt;class X&gt; class EventRecord : public CHeapObj&lt;mtInternal&gt; {
 73    public:
 74     double  timestamp;
 75     Thread* thread;
 76     X       data;
 77   };
 78 
 79  protected:
 80   Mutex           _mutex;

 81   const char*     _name;



 82   int             _length;
 83   int             _index;
 84   int             _count;
 85   EventRecord&lt;T&gt;* _records;
 86 
 87  public:
<span class="line-modified"> 88   EventLogBase&lt;T&gt;(const char* name, int length = LogEventsBufferEntries):</span>
<span class="line-modified"> 89     _mutex(Mutex::event, name, false, Monitor::_safepoint_check_never),</span>
 90     _name(name),

 91     _length(length),
 92     _index(0),
 93     _count(0) {
 94     _records = new EventRecord&lt;T&gt;[length];
 95   }
 96 
 97   double fetch_timestamp() {
 98     return os::elapsedTime();
 99   }
100 
101   // move the ring buffer to next open slot and return the index of
102   // the slot to use for the current message.  Should only be called
103   // while mutex is held.
104   int compute_log_index() {
105     int index = _index;
106     if (_count &lt; _length) _count++;
107     _index++;
108     if (_index &gt;= _length) _index = 0;
109     return index;
110   }
111 
112   bool should_log() {
113     // Don&#39;t bother adding new entries when we&#39;re crashing.  This also
114     // avoids mutating the ring buffer when printing the log.
115     return !VMError::fatal_error_in_progress();
116   }
117 
118   // Print the contents of the log
<span class="line-modified">119   void print_log_on(outputStream* out);</span>






120 
121  private:
<span class="line-modified">122   void print_log_impl(outputStream* out);</span>
123 
124   // Print a single element.  A templated implementation might need to
125   // be declared by subclasses.
126   void print(outputStream* out, T&amp; e);
127 
128   void print(outputStream* out, EventRecord&lt;T&gt;&amp; e) {
129     out-&gt;print(&quot;Event: %.3f &quot;, e.timestamp);
130     if (e.thread != NULL) {
131       out-&gt;print(&quot;Thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(e.thread));
132     }
133     print(out, e.data);
134   }
135 };
136 
137 // A simple wrapper class for fixed size text messages.
138 template &lt;size_t bufsz&gt;
139 class FormatStringLogMessage : public FormatBuffer&lt;bufsz&gt; {
<span class="line-removed">140  public:</span>
<span class="line-removed">141   // Wrap this buffer in a stringStream.</span>
<span class="line-removed">142   stringStream stream() {</span>
<span class="line-removed">143     return stringStream(this-&gt;_buf, this-&gt;size());</span>
<span class="line-removed">144   }</span>
145 };
146 typedef FormatStringLogMessage&lt;256&gt; StringLogMessage;
147 typedef FormatStringLogMessage&lt;512&gt; ExtendedStringLogMessage;
148 
149 // A simple ring buffer of fixed size text messages.
150 template &lt;size_t bufsz&gt;
151 class FormatStringEventLog : public EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt; {
152  public:
<span class="line-modified">153   FormatStringEventLog(const char* name, int count = LogEventsBufferEntries) : EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt;(name, count) {}</span>

154 
155   void logv(Thread* thread, const char* format, va_list ap) ATTRIBUTE_PRINTF(3, 0) {
156     if (!this-&gt;should_log()) return;
157 
158     double timestamp = this-&gt;fetch_timestamp();
<span class="line-modified">159     MutexLockerEx ml(&amp;this-&gt;_mutex, Mutex::_no_safepoint_check_flag);</span>
160     int index = this-&gt;compute_log_index();
161     this-&gt;_records[index].thread = thread;
162     this-&gt;_records[index].timestamp = timestamp;
163     this-&gt;_records[index].data.printv(format, ap);
164   }
165 
166   void log(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(3, 4) {
167     va_list ap;
168     va_start(ap, format);
169     this-&gt;logv(thread, format, ap);
170     va_end(ap);
171   }
172 };
173 typedef FormatStringEventLog&lt;256&gt; StringEventLog;
174 typedef FormatStringEventLog&lt;512&gt; ExtendedStringEventLog;
175 
176 class InstanceKlass;
177 
178 // Event log for class unloading events to materialize the class name in place in the log stream.
179 class UnloadingEventLog : public EventLogBase&lt;StringLogMessage&gt; {
180  public:
<span class="line-modified">181   UnloadingEventLog(const char* name, int count = LogEventsBufferEntries) : EventLogBase&lt;StringLogMessage&gt;(name, count) {}</span>

182 
183   void log(Thread* thread, InstanceKlass* ik);
184 };
185 
186 // Event log for exceptions
187 class ExceptionsEventLog : public ExtendedStringEventLog {
188  public:
<span class="line-modified">189   ExceptionsEventLog(const char* name, int count = LogEventsBufferEntries) : ExtendedStringEventLog(name, count) {}</span>

190 
191   void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
192 };
193 
194 
195 class Events : AllStatic {
196   friend class EventLog;
197 
198  private:
199   static EventLog* _logs;
200 
201   // A log for generic messages that aren&#39;t well categorized.
202   static StringEventLog* _messages;
203 
204   // A log for internal exception related messages, like internal
205   // throws and implicit exceptions.
206   static ExceptionsEventLog* _exceptions;
207 
208   // Deoptization related messages
209   static StringEventLog* _deopt_messages;
210 
211   // Redefinition related messages
212   static StringEventLog* _redefinitions;
213 
214   // Class unloading events
215   static UnloadingEventLog* _class_unloading;
216  public:
<span class="line-modified">217   static void print_all(outputStream* out);</span>






218 
219   // Dump all events to the tty
220   static void print();
221 
222   // Logs a generic message with timestamp and format as printf.
223   static void log(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
224 
225   // Log exception related message
226   static void log_exception(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
227   static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
228 
229   static void log_redefinition(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
230 
231   static void log_class_unloading(Thread* thread, InstanceKlass* ik);
232 
233   static void log_deopt_message(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
234 
235   // Register default loggers
236   static void init();
237 };
238 
239 inline void Events::log(Thread* thread, const char* format, ...) {
<span class="line-modified">240   if (LogEvents) {</span>
241     va_list ap;
242     va_start(ap, format);
243     _messages-&gt;logv(thread, format, ap);
244     va_end(ap);
245   }
246 }
247 
248 inline void Events::log_exception(Thread* thread, const char* format, ...) {
<span class="line-modified">249   if (LogEvents) {</span>
250     va_list ap;
251     va_start(ap, format);
252     _exceptions-&gt;logv(thread, format, ap);
253     va_end(ap);
254   }
255 }
256 
257 inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {
<span class="line-modified">258   if (LogEvents) {</span>
259     _exceptions-&gt;log(thread, h_exception, message, file, line);
260   }
261 }
262 
263 inline void Events::log_redefinition(Thread* thread, const char* format, ...) {
<span class="line-modified">264   if (LogEvents) {</span>
265     va_list ap;
266     va_start(ap, format);
267     _redefinitions-&gt;logv(thread, format, ap);
268     va_end(ap);
269   }
270 }
271 
272 inline void Events::log_class_unloading(Thread* thread, InstanceKlass* ik) {
<span class="line-modified">273   if (LogEvents) {</span>
274     _class_unloading-&gt;log(thread, ik);
275   }
276 }
277 
278 inline void Events::log_deopt_message(Thread* thread, const char* format, ...) {
<span class="line-modified">279   if (LogEvents) {</span>
280     va_list ap;
281     va_start(ap, format);
282     _deopt_messages-&gt;logv(thread, format, ap);
283     va_end(ap);
284   }
285 }
286 
<span class="line-removed">287 </span>
288 template &lt;class T&gt;
<span class="line-modified">289 inline void EventLogBase&lt;T&gt;::print_log_on(outputStream* out) {</span>
290   if (Thread::current_or_null() == NULL) {
291     // Not yet attached? Don&#39;t try to use locking
<span class="line-modified">292     print_log_impl(out);</span>
293   } else {
<span class="line-modified">294     MutexLockerEx ml(&amp;_mutex, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">295     print_log_impl(out);</span>
296   }
297 }
298 











299 // Dump the ring buffer entries that current have entries.
300 template &lt;class T&gt;
<span class="line-modified">301 inline void EventLogBase&lt;T&gt;::print_log_impl(outputStream* out) {</span>
302   out-&gt;print_cr(&quot;%s (%d events):&quot;, _name, _count);
303   if (_count == 0) {
304     out-&gt;print_cr(&quot;No events&quot;);
305     out-&gt;cr();
306     return;
307   }
308 

309   if (_count &lt; _length) {
310     for (int i = 0; i &lt; _count; i++) {



311       print(out, _records[i]);

312     }
313   } else {
314     for (int i = _index; i &lt; _length; i++) {



315       print(out, _records[i]);

316     }
317     for (int i = 0; i &lt; _index; i++) {



318       print(out, _records[i]);

319     }
320   }





321   out-&gt;cr();
322 }
323 
324 // Implement a printing routine for the StringLogMessage
325 template &lt;&gt;
326 inline void EventLogBase&lt;StringLogMessage&gt;::print(outputStream* out, StringLogMessage&amp; lm) {
327   out-&gt;print_raw(lm);
328   out-&gt;cr();
329 }
330 
331 // Implement a printing routine for the ExtendedStringLogMessage
332 template &lt;&gt;
333 inline void EventLogBase&lt;ExtendedStringLogMessage&gt;::print(outputStream* out, ExtendedStringLogMessage&amp; lm) {
334   out-&gt;print_raw(lm);
335   out-&gt;cr();
336 }
337 
338 // Place markers for the beginning and end up of a set of events.
339 // These end up in the default log.
340 class EventMark : public StackObj {
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_EVENTS_HPP
 26 #define SHARE_UTILITIES_EVENTS_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/mutexLocker.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 #include &quot;utilities/formatBuffer.hpp&quot;
<span class="line-added"> 32 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
<span class="line-added"> 33 #include &quot;utilities/ostream.hpp&quot;</span>
 34 #include &quot;utilities/vmError.hpp&quot;
 35 
 36 // Events and EventMark provide interfaces to log events taking place in the vm.
 37 // This facility is extremly useful for post-mortem debugging. The eventlog
 38 // often provides crucial information about events leading up to the crash.
 39 //
 40 // Abstractly the logs can record whatever they way but normally they
 41 // would record at least a timestamp and the current Thread, along
 42 // with whatever data they need in a ring buffer.  Commonly fixed
 43 // length text messages are recorded for simplicity but other
 44 // strategies could be used.  Several logs are provided by default but
 45 // new instances can be created as needed.
 46 
 47 // The base event log dumping class that is registered for dumping at
 48 // crash time.  This is a very generic interface that is mainly here
 49 // for completeness.  Normally the templated EventLogBase would be
 50 // subclassed to provide different log types.
 51 class EventLog : public CHeapObj&lt;mtInternal&gt; {
 52   friend class Events;
 53 
 54  private:
 55   EventLog* _next;
 56 
 57   EventLog* next() const { return _next; }
 58 
 59  public:
 60   // Automatically registers the log so that it will be printed during
 61   // crashes.
 62   EventLog();
 63 
<span class="line-modified"> 64   // Print log to output stream.</span>
<span class="line-added"> 65   virtual void print_log_on(outputStream* out, int max = -1) = 0;</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67   // Returns true if s matches either the log name or the log handle.</span>
<span class="line-added"> 68   virtual bool matches_name_or_handle(const char* s) const = 0;</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70   // Print log names (for help output of VM.events).</span>
<span class="line-added"> 71   virtual void print_names(outputStream* out) const = 0;</span>
<span class="line-added"> 72 </span>
 73 };
 74 
 75 
 76 // A templated subclass of EventLog that provides basic ring buffer
 77 // functionality.  Most event loggers should subclass this, possibly
 78 // providing a more featureful log function if the existing copy
 79 // semantics aren&#39;t appropriate.  The name is used as the label of the
 80 // log when it is dumped during a crash.
 81 template &lt;class T&gt; class EventLogBase : public EventLog {
 82   template &lt;class X&gt; class EventRecord : public CHeapObj&lt;mtInternal&gt; {
 83    public:
 84     double  timestamp;
 85     Thread* thread;
 86     X       data;
 87   };
 88 
 89  protected:
 90   Mutex           _mutex;
<span class="line-added"> 91   // Name is printed out as a header.</span>
 92   const char*     _name;
<span class="line-added"> 93   // Handle is a short specifier used to select this particular event log</span>
<span class="line-added"> 94   // for printing (see VM.events command).</span>
<span class="line-added"> 95   const char*     _handle;</span>
 96   int             _length;
 97   int             _index;
 98   int             _count;
 99   EventRecord&lt;T&gt;* _records;
100 
101  public:
<span class="line-modified">102   EventLogBase&lt;T&gt;(const char* name, const char* handle, int length = LogEventsBufferEntries):</span>
<span class="line-modified">103     _mutex(Mutex::event, name, true, Mutex::_safepoint_check_never),</span>
104     _name(name),
<span class="line-added">105     _handle(handle),</span>
106     _length(length),
107     _index(0),
108     _count(0) {
109     _records = new EventRecord&lt;T&gt;[length];
110   }
111 
112   double fetch_timestamp() {
113     return os::elapsedTime();
114   }
115 
116   // move the ring buffer to next open slot and return the index of
117   // the slot to use for the current message.  Should only be called
118   // while mutex is held.
119   int compute_log_index() {
120     int index = _index;
121     if (_count &lt; _length) _count++;
122     _index++;
123     if (_index &gt;= _length) _index = 0;
124     return index;
125   }
126 
127   bool should_log() {
128     // Don&#39;t bother adding new entries when we&#39;re crashing.  This also
129     // avoids mutating the ring buffer when printing the log.
130     return !VMError::fatal_error_in_progress();
131   }
132 
133   // Print the contents of the log
<span class="line-modified">134   void print_log_on(outputStream* out, int max = -1);</span>
<span class="line-added">135 </span>
<span class="line-added">136   // Returns true if s matches either the log name or the log handle.</span>
<span class="line-added">137   bool matches_name_or_handle(const char* s) const;</span>
<span class="line-added">138 </span>
<span class="line-added">139   // Print log names (for help output of VM.events).</span>
<span class="line-added">140   void print_names(outputStream* out) const;</span>
141 
142  private:
<span class="line-modified">143   void print_log_impl(outputStream* out, int max = -1);</span>
144 
145   // Print a single element.  A templated implementation might need to
146   // be declared by subclasses.
147   void print(outputStream* out, T&amp; e);
148 
149   void print(outputStream* out, EventRecord&lt;T&gt;&amp; e) {
150     out-&gt;print(&quot;Event: %.3f &quot;, e.timestamp);
151     if (e.thread != NULL) {
152       out-&gt;print(&quot;Thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(e.thread));
153     }
154     print(out, e.data);
155   }
156 };
157 
158 // A simple wrapper class for fixed size text messages.
159 template &lt;size_t bufsz&gt;
160 class FormatStringLogMessage : public FormatBuffer&lt;bufsz&gt; {





161 };
162 typedef FormatStringLogMessage&lt;256&gt; StringLogMessage;
163 typedef FormatStringLogMessage&lt;512&gt; ExtendedStringLogMessage;
164 
165 // A simple ring buffer of fixed size text messages.
166 template &lt;size_t bufsz&gt;
167 class FormatStringEventLog : public EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt; {
168  public:
<span class="line-modified">169   FormatStringEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)</span>
<span class="line-added">170    : EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt;(name, short_name, count) {}</span>
171 
172   void logv(Thread* thread, const char* format, va_list ap) ATTRIBUTE_PRINTF(3, 0) {
173     if (!this-&gt;should_log()) return;
174 
175     double timestamp = this-&gt;fetch_timestamp();
<span class="line-modified">176     MutexLocker ml(&amp;this-&gt;_mutex, Mutex::_no_safepoint_check_flag);</span>
177     int index = this-&gt;compute_log_index();
178     this-&gt;_records[index].thread = thread;
179     this-&gt;_records[index].timestamp = timestamp;
180     this-&gt;_records[index].data.printv(format, ap);
181   }
182 
183   void log(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(3, 4) {
184     va_list ap;
185     va_start(ap, format);
186     this-&gt;logv(thread, format, ap);
187     va_end(ap);
188   }
189 };
190 typedef FormatStringEventLog&lt;256&gt; StringEventLog;
191 typedef FormatStringEventLog&lt;512&gt; ExtendedStringEventLog;
192 
193 class InstanceKlass;
194 
195 // Event log for class unloading events to materialize the class name in place in the log stream.
196 class UnloadingEventLog : public EventLogBase&lt;StringLogMessage&gt; {
197  public:
<span class="line-modified">198   UnloadingEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)</span>
<span class="line-added">199    : EventLogBase&lt;StringLogMessage&gt;(name, short_name, count) {}</span>
200 
201   void log(Thread* thread, InstanceKlass* ik);
202 };
203 
204 // Event log for exceptions
205 class ExceptionsEventLog : public ExtendedStringEventLog {
206  public:
<span class="line-modified">207   ExceptionsEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)</span>
<span class="line-added">208    : ExtendedStringEventLog(name, short_name, count) {}</span>
209 
210   void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
211 };
212 
213 
214 class Events : AllStatic {
215   friend class EventLog;
216 
217  private:
218   static EventLog* _logs;
219 
220   // A log for generic messages that aren&#39;t well categorized.
221   static StringEventLog* _messages;
222 
223   // A log for internal exception related messages, like internal
224   // throws and implicit exceptions.
225   static ExceptionsEventLog* _exceptions;
226 
227   // Deoptization related messages
228   static StringEventLog* _deopt_messages;
229 
230   // Redefinition related messages
231   static StringEventLog* _redefinitions;
232 
233   // Class unloading events
234   static UnloadingEventLog* _class_unloading;
235  public:
<span class="line-modified">236 </span>
<span class="line-added">237   // Print all event logs; limit number of events per event log to be printed with max</span>
<span class="line-added">238   // (max == -1 prints all events).</span>
<span class="line-added">239   static void print_all(outputStream* out, int max = -1);</span>
<span class="line-added">240 </span>
<span class="line-added">241   // Print a single event log specified by name or handle.</span>
<span class="line-added">242   static void print_one(outputStream* out, const char* log_name, int max = -1);</span>
243 
244   // Dump all events to the tty
245   static void print();
246 
247   // Logs a generic message with timestamp and format as printf.
248   static void log(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
249 
250   // Log exception related message
251   static void log_exception(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
252   static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
253 
254   static void log_redefinition(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
255 
256   static void log_class_unloading(Thread* thread, InstanceKlass* ik);
257 
258   static void log_deopt_message(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
259 
260   // Register default loggers
261   static void init();
262 };
263 
264 inline void Events::log(Thread* thread, const char* format, ...) {
<span class="line-modified">265   if (LogEvents &amp;&amp; _messages != NULL) {</span>
266     va_list ap;
267     va_start(ap, format);
268     _messages-&gt;logv(thread, format, ap);
269     va_end(ap);
270   }
271 }
272 
273 inline void Events::log_exception(Thread* thread, const char* format, ...) {
<span class="line-modified">274   if (LogEvents &amp;&amp; _exceptions != NULL) {</span>
275     va_list ap;
276     va_start(ap, format);
277     _exceptions-&gt;logv(thread, format, ap);
278     va_end(ap);
279   }
280 }
281 
282 inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {
<span class="line-modified">283   if (LogEvents &amp;&amp; _exceptions != NULL) {</span>
284     _exceptions-&gt;log(thread, h_exception, message, file, line);
285   }
286 }
287 
288 inline void Events::log_redefinition(Thread* thread, const char* format, ...) {
<span class="line-modified">289   if (LogEvents &amp;&amp; _redefinitions != NULL) {</span>
290     va_list ap;
291     va_start(ap, format);
292     _redefinitions-&gt;logv(thread, format, ap);
293     va_end(ap);
294   }
295 }
296 
297 inline void Events::log_class_unloading(Thread* thread, InstanceKlass* ik) {
<span class="line-modified">298   if (LogEvents &amp;&amp; _class_unloading != NULL) {</span>
299     _class_unloading-&gt;log(thread, ik);
300   }
301 }
302 
303 inline void Events::log_deopt_message(Thread* thread, const char* format, ...) {
<span class="line-modified">304   if (LogEvents &amp;&amp; _deopt_messages != NULL) {</span>
305     va_list ap;
306     va_start(ap, format);
307     _deopt_messages-&gt;logv(thread, format, ap);
308     va_end(ap);
309   }
310 }
311 

312 template &lt;class T&gt;
<span class="line-modified">313 inline void EventLogBase&lt;T&gt;::print_log_on(outputStream* out, int max) {</span>
314   if (Thread::current_or_null() == NULL) {
315     // Not yet attached? Don&#39;t try to use locking
<span class="line-modified">316     print_log_impl(out, max);</span>
317   } else {
<span class="line-modified">318     MutexLocker ml(&amp;_mutex, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">319     print_log_impl(out, max);</span>
320   }
321 }
322 
<span class="line-added">323 template &lt;class T&gt;</span>
<span class="line-added">324 inline bool EventLogBase&lt;T&gt;::matches_name_or_handle(const char* s) const {</span>
<span class="line-added">325   return ::strcasecmp(s, _name) == 0 ||</span>
<span class="line-added">326          ::strcasecmp(s, _handle) == 0;</span>
<span class="line-added">327 }</span>
<span class="line-added">328 </span>
<span class="line-added">329 template &lt;class T&gt;</span>
<span class="line-added">330 inline void EventLogBase&lt;T&gt;::print_names(outputStream* out) const {</span>
<span class="line-added">331   out-&gt;print(&quot;\&quot;%s\&quot; : %s&quot;, _handle, _name);</span>
<span class="line-added">332 }</span>
<span class="line-added">333 </span>
334 // Dump the ring buffer entries that current have entries.
335 template &lt;class T&gt;
<span class="line-modified">336 inline void EventLogBase&lt;T&gt;::print_log_impl(outputStream* out, int max) {</span>
337   out-&gt;print_cr(&quot;%s (%d events):&quot;, _name, _count);
338   if (_count == 0) {
339     out-&gt;print_cr(&quot;No events&quot;);
340     out-&gt;cr();
341     return;
342   }
343 
<span class="line-added">344   int printed = 0;</span>
345   if (_count &lt; _length) {
346     for (int i = 0; i &lt; _count; i++) {
<span class="line-added">347       if (max &gt; 0 &amp;&amp; printed == max) {</span>
<span class="line-added">348         break;</span>
<span class="line-added">349       }</span>
350       print(out, _records[i]);
<span class="line-added">351       printed ++;</span>
352     }
353   } else {
354     for (int i = _index; i &lt; _length; i++) {
<span class="line-added">355       if (max &gt; 0 &amp;&amp; printed == max) {</span>
<span class="line-added">356         break;</span>
<span class="line-added">357       }</span>
358       print(out, _records[i]);
<span class="line-added">359       printed ++;</span>
360     }
361     for (int i = 0; i &lt; _index; i++) {
<span class="line-added">362       if (max &gt; 0 &amp;&amp; printed == max) {</span>
<span class="line-added">363         break;</span>
<span class="line-added">364       }</span>
365       print(out, _records[i]);
<span class="line-added">366       printed ++;</span>
367     }
368   }
<span class="line-added">369 </span>
<span class="line-added">370   if (printed == max) {</span>
<span class="line-added">371     out-&gt;print_cr(&quot;...(skipped)&quot;);</span>
<span class="line-added">372   }</span>
<span class="line-added">373 </span>
374   out-&gt;cr();
375 }
376 
377 // Implement a printing routine for the StringLogMessage
378 template &lt;&gt;
379 inline void EventLogBase&lt;StringLogMessage&gt;::print(outputStream* out, StringLogMessage&amp; lm) {
380   out-&gt;print_raw(lm);
381   out-&gt;cr();
382 }
383 
384 // Implement a printing routine for the ExtendedStringLogMessage
385 template &lt;&gt;
386 inline void EventLogBase&lt;ExtendedStringLogMessage&gt;::print(outputStream* out, ExtendedStringLogMessage&amp; lm) {
387   out-&gt;print_raw(lm);
388   out-&gt;cr();
389 }
390 
391 // Place markers for the beginning and end up of a set of events.
392 // These end up in the default log.
393 class EventMark : public StackObj {
</pre>
</td>
</tr>
</table>
<center><a href="events.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="exceptions.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/vmError.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ticks.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmError.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/vmError.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/gcConfig.hpp&quot;
  31 #include &quot;logging/logConfiguration.hpp&quot;
  32 #include &quot;jfr/jfrEvents.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;


  34 #include &quot;prims/whitebox.hpp&quot;
  35 #include &quot;runtime/arguments.hpp&quot;
  36 #include &quot;runtime/atomic.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/init.hpp&quot;
  39 #include &quot;runtime/os.hpp&quot;
  40 #include &quot;runtime/thread.inline.hpp&quot;
  41 #include &quot;runtime/threadSMR.hpp&quot;
  42 #include &quot;runtime/vmThread.hpp&quot;
  43 #include &quot;runtime/vmOperations.hpp&quot;
  44 #include &quot;runtime/vm_version.hpp&quot;
  45 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  46 #include &quot;services/memTracker.hpp&quot;
  47 #include &quot;utilities/debug.hpp&quot;
  48 #include &quot;utilities/decoder.hpp&quot;
  49 #include &quot;utilities/defaultStream.hpp&quot;
  50 #include &quot;utilities/events.hpp&quot;
  51 #include &quot;utilities/vmError.hpp&quot;
  52 #include &quot;utilities/macros.hpp&quot;
  53 #if INCLUDE_JFR
</pre>
<hr />
<pre>
 109   if (ptr == NULL || *ptr == NULL) return NULL;
 110 
 111   const char* cmd = *ptr;
 112 
 113   // skip leading blanks or &#39;;&#39;
 114   while (*cmd == &#39; &#39; || *cmd == &#39;;&#39;) cmd++;
 115 
 116   if (*cmd == &#39;\0&#39;) return NULL;
 117 
 118   const char * cmdend = cmd;
 119   while (*cmdend != &#39;\0&#39; &amp;&amp; *cmdend != &#39;;&#39;) cmdend++;
 120 
 121   Arguments::copy_expand_pid(cmd, cmdend - cmd, buf, buflen);
 122 
 123   *ptr = (*cmdend == &#39;\0&#39; ? cmdend : cmdend + 1);
 124   return buf;
 125 }
 126 
 127 static void print_bug_submit_message(outputStream *out, Thread *thread) {
 128   if (out == NULL) return;
<span class="line-modified"> 129   out-&gt;print_raw_cr(&quot;# If you would like to submit a bug report, please visit:&quot;);</span>
<span class="line-modified"> 130   out-&gt;print_raw   (&quot;#   &quot;);</span>
<span class="line-modified"> 131   out-&gt;print_raw_cr(Arguments::java_vendor_url_bug());</span>





 132   // If the crash is in native code, encourage user to submit a bug to the
 133   // provider of that code.
 134   if (thread &amp;&amp; thread-&gt;is_Java_thread() &amp;&amp;
 135       !thread-&gt;is_hidden_from_external_view()) {
 136     JavaThread* jt = (JavaThread*)thread;
 137     if (jt-&gt;thread_state() == _thread_in_native) {
 138       out-&gt;print_cr(&quot;# The crash happened outside the Java Virtual Machine in native code.\n# See problematic frame for where to report the bug.&quot;);
 139     }
 140   }
 141   out-&gt;print_raw_cr(&quot;#&quot;);
 142 }
 143 
 144 bool VMError::coredump_status;
 145 char VMError::coredump_message[O_BUFLEN];
 146 
 147 void VMError::record_coredump_status(const char* message, bool status) {
 148   coredump_status = status;
 149   strncpy(coredump_message, message, sizeof(coredump_message));
 150   coredump_message[sizeof(coredump_message)-1] = 0;
 151 }
</pre>
<hr />
<pre>
 274   st-&gt;print_cr(&quot;# Possible reasons:&quot;);
 275   st-&gt;print_cr(&quot;#   The system is out of physical RAM or swap space&quot;);
 276   if (UseCompressedOops) {
 277     st-&gt;print_cr(&quot;#   The process is running with CompressedOops enabled, and the Java Heap may be blocking the growth of the native heap&quot;);
 278   }
 279   if (LogBytesPerWord == 2) {
 280     st-&gt;print_cr(&quot;#   In 32 bit mode, the process size limit was hit&quot;);
 281   }
 282   st-&gt;print_cr(&quot;# Possible solutions:&quot;);
 283   st-&gt;print_cr(&quot;#   Reduce memory load on the system&quot;);
 284   st-&gt;print_cr(&quot;#   Increase physical memory or swap space&quot;);
 285   st-&gt;print_cr(&quot;#   Check if swap backing store is full&quot;);
 286   if (LogBytesPerWord == 2) {
 287     st-&gt;print_cr(&quot;#   Use 64 bit Java on a 64 bit OS&quot;);
 288   }
 289   st-&gt;print_cr(&quot;#   Decrease Java heap size (-Xmx/-Xms)&quot;);
 290   st-&gt;print_cr(&quot;#   Decrease number of Java threads&quot;);
 291   st-&gt;print_cr(&quot;#   Decrease Java thread stack sizes (-Xss)&quot;);
 292   st-&gt;print_cr(&quot;#   Set larger code cache with -XX:ReservedCodeCacheSize=&quot;);
 293   if (UseCompressedOops) {
<span class="line-modified"> 294     switch (Universe::narrow_oop_mode()) {</span>
<span class="line-modified"> 295       case Universe::UnscaledNarrowOop:</span>
 296         st-&gt;print_cr(&quot;#   JVM is running with Unscaled Compressed Oops mode in which the Java heap is&quot;);
 297         st-&gt;print_cr(&quot;#     placed in the first 4GB address space. The Java Heap base address is the&quot;);
 298         st-&gt;print_cr(&quot;#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress&quot;);
 299         st-&gt;print_cr(&quot;#     to set the Java Heap base and to place the Java Heap above 4GB virtual address.&quot;);
 300         break;
<span class="line-modified"> 301       case Universe::ZeroBasedNarrowOop:</span>
 302         st-&gt;print_cr(&quot;#   JVM is running with Zero Based Compressed Oops mode in which the Java heap is&quot;);
 303         st-&gt;print_cr(&quot;#     placed in the first 32GB address space. The Java Heap base address is the&quot;);
 304         st-&gt;print_cr(&quot;#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress&quot;);
 305         st-&gt;print_cr(&quot;#     to set the Java Heap base and to place the Java Heap above 32GB virtual address.&quot;);
 306         break;
 307       default:
 308         break;
 309     }
 310   }
 311   st-&gt;print_cr(&quot;# This output file may be truncated or incomplete.&quot;);
 312 }
 313 
 314 static void report_vm_version(outputStream* st, char* buf, int buflen) {
 315    // VM version
 316    st-&gt;print_cr(&quot;#&quot;);
 317    JDK_Version::current().to_string(buf, buflen);
 318    const char* runtime_name = JDK_Version::runtime_name() != NULL ?
 319                                 JDK_Version::runtime_name() : &quot;&quot;;
 320    const char* runtime_version = JDK_Version::runtime_version() != NULL ?
 321                                    JDK_Version::runtime_version() : &quot;&quot;;


 322    const char* jdk_debug_level = VM_Version::printable_jdk_debug_level() != NULL ?
 323                                    VM_Version::printable_jdk_debug_level() : &quot;&quot;;
 324 
<span class="line-modified"> 325    st-&gt;print_cr(&quot;# JRE version: %s (%s) (%sbuild %s)&quot;, runtime_name, buf,</span>
<span class="line-modified"> 326                  jdk_debug_level, runtime_version);</span>

 327 
 328    // This is the long version with some default settings added
<span class="line-modified"> 329    st-&gt;print_cr(&quot;# Java VM: %s (%s%s, %s%s%s%s%s, %s, %s)&quot;,</span>
 330                  VM_Version::vm_name(),

 331                  jdk_debug_level,
 332                  VM_Version::vm_release(),
 333                  VM_Version::vm_info_string(),
 334                  TieredCompilation ? &quot;, tiered&quot; : &quot;&quot;,
 335 #if INCLUDE_JVMCI
 336                  EnableJVMCI ? &quot;, jvmci&quot; : &quot;&quot;,
 337                  UseJVMCICompiler ? &quot;, jvmci compiler&quot; : &quot;&quot;,
 338 #else
 339                  &quot;&quot;, &quot;&quot;,
 340 #endif
 341                  UseCompressedOops ? &quot;, compressed oops&quot; : &quot;&quot;,
 342                  GCConfig::hs_err_name(),
 343                  VM_Version::vm_platform_string()
 344                );
 345 }
 346 
 347 // This is the main function to report a fatal error. Only one thread can
 348 // call this function, so we don&#39;t need to worry about MT-safety. But it&#39;s
 349 // possible that the error handler itself may crash or die on an internal
 350 // error, for example, when the stack/heap is badly damaged. We must be
</pre>
<hr />
<pre>
 371 // thread can report error, so large buffers are statically allocated in data
 372 // segment.
 373 
 374 int          VMError::_current_step;
 375 const char*  VMError::_current_step_info;
 376 
 377 volatile jlong VMError::_reporting_start_time = -1;
 378 volatile bool VMError::_reporting_did_timeout = false;
 379 volatile jlong VMError::_step_start_time = -1;
 380 volatile bool VMError::_step_did_timeout = false;
 381 
 382 // Helper, return current timestamp for timeout handling.
 383 jlong VMError::get_current_timestamp() {
 384   return os::javaTimeNanos();
 385 }
 386 // Factor to translate the timestamp to seconds.
 387 #define TIMESTAMP_TO_SECONDS_FACTOR (1000 * 1000 * 1000)
 388 
 389 void VMError::record_reporting_start_time() {
 390   const jlong now = get_current_timestamp();
<span class="line-modified"> 391   Atomic::store(now, &amp;_reporting_start_time);</span>
 392 }
 393 
 394 jlong VMError::get_reporting_start_time() {
 395   return Atomic::load(&amp;_reporting_start_time);
 396 }
 397 
 398 void VMError::record_step_start_time() {
 399   const jlong now = get_current_timestamp();
<span class="line-modified"> 400   Atomic::store(now, &amp;_step_start_time);</span>
 401 }
 402 
 403 jlong VMError::get_step_start_time() {
 404   return Atomic::load(&amp;_step_start_time);
 405 }
 406 




 407 void VMError::report(outputStream* st, bool _verbose) {
 408 
 409 # define BEGIN if (_current_step == 0) { _current_step = __LINE__;
 410 # define STEP(s) } if (_current_step &lt; __LINE__) { _current_step = __LINE__; _current_step_info = s; \
 411   record_step_start_time(); _step_did_timeout = false;
<span class="line-modified"> 412 # define END }</span>
 413 
 414   // don&#39;t allocate large buffer on stack
 415   static char buf[O_BUFLEN];
 416 
 417   BEGIN
 418 
 419   STEP(&quot;printing fatal error message&quot;)
 420 
 421     st-&gt;print_cr(&quot;#&quot;);
 422     if (should_report_bug(_id)) {
 423       st-&gt;print_cr(&quot;# A fatal error has been detected by the Java Runtime Environment:&quot;);
 424     } else {
 425       st-&gt;print_cr(&quot;# There is insufficient memory for the Java &quot;
 426                    &quot;Runtime Environment to continue.&quot;);
 427     }
 428 
 429 #ifndef PRODUCT
 430   // Error handler self tests
 431 
 432   // test secondary error handling. Test it twice, to test that resetting
 433   // error handler after a secondary crash works.
 434   STEP(&quot;test secondary crash 1&quot;)
 435     if (_verbose &amp;&amp; TestCrashInErrorHandler != 0) {
 436       st-&gt;print_cr(&quot;Will crash now (TestCrashInErrorHandler=&quot; UINTX_FORMAT &quot;)...&quot;,
 437         TestCrashInErrorHandler);
 438       controlled_crash(TestCrashInErrorHandler);
 439     }
 440 
 441   STEP(&quot;test secondary crash 2&quot;)
 442     if (_verbose &amp;&amp; TestCrashInErrorHandler != 0) {
 443       st-&gt;print_cr(&quot;Will crash now (TestCrashInErrorHandler=&quot; UINTX_FORMAT &quot;)...&quot;,
 444         TestCrashInErrorHandler);
 445       controlled_crash(TestCrashInErrorHandler);
 446     }
 447 
 448   // TestUnresponsiveErrorHandler: We want to test both step timeouts and global timeout.
 449   // Step to global timeout ratio is 4:1, so in order to be absolutely sure we hit the
 450   // global timeout, let&#39;s execute the timeout step five times.
 451   // See corresponding test in test/runtime/ErrorHandling/TimeoutInErrorHandlingTest.java









 452   #define TIMEOUT_TEST_STEP STEP(&quot;test unresponsive error reporting step&quot;) \
 453     if (_verbose &amp;&amp; TestUnresponsiveErrorHandler) { os::infinite_sleep(); }
 454   TIMEOUT_TEST_STEP
 455   TIMEOUT_TEST_STEP
 456   TIMEOUT_TEST_STEP
 457   TIMEOUT_TEST_STEP
 458   TIMEOUT_TEST_STEP
 459 
 460   STEP(&quot;test safefetch in error handler&quot;)
 461     // test whether it is safe to use SafeFetch32 in Crash Handler. Test twice
 462     // to test that resetting the signal handler works correctly.
 463     if (_verbose &amp;&amp; TestSafeFetchInErrorHandler) {
 464       st-&gt;print_cr(&quot;Will test SafeFetch...&quot;);
 465       if (CanUseSafeFetch32()) {
 466         int* const invalid_pointer = (int*) get_segfault_address();
 467         const int x = 0x76543210;
 468         int i1 = SafeFetch32(invalid_pointer, x);
 469         int i2 = SafeFetch32(invalid_pointer, x);
 470         if (i1 == x &amp;&amp; i2 == x) {
 471           st-&gt;print_cr(&quot;SafeFetch OK.&quot;); // Correctly deflected and returned default pattern
</pre>
<hr />
<pre>
 865 
 866   STEP(&quot;printing owned locks on error&quot;)
 867 
 868      // mutexes/monitors that currently have an owner
 869      if (_verbose) {
 870        print_owned_locks_on_error(st);
 871        st-&gt;cr();
 872      }
 873 
 874   STEP(&quot;printing number of OutOfMemoryError and StackOverflow exceptions&quot;)
 875 
 876      if (_verbose &amp;&amp; Exceptions::has_exception_counts()) {
 877        st-&gt;print_cr(&quot;OutOfMemory and StackOverflow Exception counts:&quot;);
 878        Exceptions::print_exception_counts_on_error(st);
 879        st-&gt;cr();
 880      }
 881 
 882   STEP(&quot;printing compressed oops mode&quot;)
 883 
 884      if (_verbose &amp;&amp; UseCompressedOops) {
<span class="line-modified"> 885        Universe::print_compressed_oops_mode(st);</span>
 886        if (UseCompressedClassPointers) {
 887          Metaspace::print_compressed_class_space(st);
 888        }
 889        st-&gt;cr();
 890      }
 891 
 892   STEP(&quot;printing heap information&quot;)
 893 
 894      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 895        Universe::heap()-&gt;print_on_error(st);
 896        st-&gt;cr();
 897        st-&gt;print_cr(&quot;Polling page: &quot; INTPTR_FORMAT, p2i(os::get_polling_page()));
 898        st-&gt;cr();
 899      }
 900 
 901   STEP(&quot;printing metaspace information&quot;)
 902 
 903      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 904        st-&gt;print_cr(&quot;Metaspace:&quot;);
 905        MetaspaceUtils::print_basic_report(st, 0);
</pre>
<hr />
<pre>
1066 
1067   // Skip: STEP(&quot;printing thread&quot;)
1068 
1069   // STEP(&quot;printing process&quot;)
1070 
1071   st-&gt;cr();
1072   st-&gt;print_cr(&quot;---------------  P R O C E S S  ---------------&quot;);
1073   st-&gt;cr();
1074 
1075   // STEP(&quot;printing number of OutOfMemoryError and StackOverflow exceptions&quot;)
1076 
1077   if (Exceptions::has_exception_counts()) {
1078     st-&gt;print_cr(&quot;OutOfMemory and StackOverflow Exception counts:&quot;);
1079     Exceptions::print_exception_counts_on_error(st);
1080     st-&gt;cr();
1081   }
1082 
1083   // STEP(&quot;printing compressed oops mode&quot;)
1084 
1085   if (UseCompressedOops) {
<span class="line-modified">1086     Universe::print_compressed_oops_mode(st);</span>
1087     if (UseCompressedClassPointers) {
1088       Metaspace::print_compressed_class_space(st);
1089     }
1090     st-&gt;cr();
1091   }
1092 
1093   // STEP(&quot;printing heap information&quot;)
1094 
1095   if (Universe::is_fully_initialized()) {
1096     MutexLocker hl(Heap_lock);
1097     Universe::heap()-&gt;print_on_error(st);
1098     st-&gt;cr();
1099     st-&gt;print_cr(&quot;Polling page: &quot; INTPTR_FORMAT, p2i(os::get_polling_page()));
1100     st-&gt;cr();
1101   }
1102 
1103   // STEP(&quot;printing metaspace information&quot;)
1104 
1105   if (Universe::is_fully_initialized()) {
1106     st-&gt;print_cr(&quot;Metaspace:&quot;);
</pre>
<hr />
<pre>
1173 
1174   os::print_cpu_info(st, buf, sizeof(buf));
1175   st-&gt;cr();
1176 
1177   // STEP(&quot;printing memory info&quot;)
1178 
1179   os::print_memory_info(st);
1180   st-&gt;cr();
1181 
1182   // STEP(&quot;printing internal vm info&quot;)
1183 
1184   st-&gt;print_cr(&quot;vm_info: %s&quot;, VM_Version::internal_vm_info_string());
1185   st-&gt;cr();
1186 
1187   // print a defined marker to show that error handling finished correctly.
1188   // STEP(&quot;printing end marker&quot;)
1189 
1190   st-&gt;print_cr(&quot;END.&quot;);
1191 }
1192 
<span class="line-modified">1193 volatile intptr_t VMError::first_error_tid = -1;</span>
1194 
1195 /** Expand a pattern into a buffer starting at pos and open a file using constructed path */
<span class="line-modified">1196 static int expand_and_open(const char* pattern, char* buf, size_t buflen, size_t pos) {</span>
1197   int fd = -1;






1198   if (Arguments::copy_expand_pid(pattern, strlen(pattern), &amp;buf[pos], buflen - pos)) {
<span class="line-modified">1199     // the O_EXCL flag will cause the open to fail if the file exists</span>
<span class="line-removed">1200     fd = open(buf, O_RDWR | O_CREAT | O_EXCL, 0666);</span>
1201   }
1202   return fd;
1203 }
1204 
1205 /**
1206  * Construct file name for a log file and return it&#39;s file descriptor.
1207  * Name and location depends on pattern, default_pattern params and access
1208  * permissions.
1209  */
<span class="line-modified">1210 static int prepare_log_file(const char* pattern, const char* default_pattern, char* buf, size_t buflen) {</span>
1211   int fd = -1;
1212 
1213   // If possible, use specified pattern to construct log file name
1214   if (pattern != NULL) {
<span class="line-modified">1215     fd = expand_and_open(pattern, buf, buflen, 0);</span>
1216   }
1217 
1218   // Either user didn&#39;t specify, or the user&#39;s location failed,
1219   // so use the default name in the current directory
1220   if (fd == -1) {
1221     const char* cwd = os::get_current_directory(buf, buflen);
1222     if (cwd != NULL) {
1223       size_t pos = strlen(cwd);
1224       int fsep_len = jio_snprintf(&amp;buf[pos], buflen-pos, &quot;%s&quot;, os::file_separator());
1225       pos += fsep_len;
1226       if (fsep_len &gt; 0) {
<span class="line-modified">1227         fd = expand_and_open(default_pattern, buf, buflen, pos);</span>
1228       }
1229     }
1230   }
1231 
1232    // try temp directory if it exists.
1233    if (fd == -1) {
1234      const char* tmpdir = os::get_temp_directory();
1235      if (tmpdir != NULL &amp;&amp; strlen(tmpdir) &gt; 0) {
1236        int pos = jio_snprintf(buf, buflen, &quot;%s%s&quot;, tmpdir, os::file_separator());
1237        if (pos &gt; 0) {
<span class="line-modified">1238          fd = expand_and_open(default_pattern, buf, buflen, pos);</span>
1239        }
1240      }
1241    }
1242 
1243   return fd;
1244 }
1245 
1246 int         VMError::_id;
1247 const char* VMError::_message;
1248 char        VMError::_detail_msg[1024];
1249 Thread*     VMError::_thread;
1250 address     VMError::_pc;
1251 void*       VMError::_siginfo;
1252 void*       VMError::_context;
1253 const char* VMError::_filename;
1254 int         VMError::_lineno;
1255 size_t      VMError::_size;
1256 
1257 void VMError::report_and_die(Thread* thread, unsigned int sig, address pc, void* siginfo,
1258                              void* context, const char* detail_fmt, ...)
</pre>
<hr />
<pre>
1290 void VMError::report_and_die(Thread* thread, const char* filename, int lineno, size_t size,
1291                              VMErrorType vm_err_type, const char* detail_fmt, va_list detail_args) {
1292   report_and_die(vm_err_type, NULL, detail_fmt, detail_args, thread, NULL, NULL, NULL, filename, lineno, size);
1293 }
1294 
1295 void VMError::report_and_die(int id, const char* message, const char* detail_fmt, va_list detail_args,
1296                              Thread* thread, address pc, void* siginfo, void* context, const char* filename,
1297                              int lineno, size_t size)
1298 {
1299   // A single scratch buffer to be used from here on.
1300   // Do not rely on it being preserved across function calls.
1301   static char buffer[O_BUFLEN];
1302 
1303   // File descriptor to tty to print an error summary to.
1304   // Hard wired to stdout; see JDK-8215004 (compatibility concerns).
1305   static const int fd_out = 1; // stdout
1306 
1307   // File descriptor to the error log file.
1308   static int fd_log = -1;
1309 






1310   // Use local fdStream objects only. Do not use global instances whose initialization
1311   // relies on dynamic initialization (see JDK-8214975). Do not rely on these instances
1312   // to carry over into recursions or invocations from other threads.
1313   fdStream out(fd_out);
1314   out.set_scratch_buffer(buffer, sizeof(buffer));
1315 
1316   // Depending on the re-entrance depth at this point, fd_log may be -1 or point to an open hs-err file.
1317   fdStream log(fd_log);
1318   log.set_scratch_buffer(buffer, sizeof(buffer));
1319 
1320   // How many errors occurred in error handler when reporting first_error.
1321   static int recursive_error_count;
1322 
1323   // We will first print a brief message to standard out (verbose = false),
1324   // then save detailed information in log file (verbose = true).
1325   static bool out_done = false;         // done printing to standard out
1326   static bool log_done = false;         // done saving error log
1327 
1328   if (SuppressFatalErrorMessage) {
1329       os::abort(CreateCoredumpOnCrash);
1330   }
1331   intptr_t mytid = os::current_thread_id();
<span class="line-modified">1332   if (first_error_tid == -1 &amp;&amp;</span>
<span class="line-modified">1333       Atomic::cmpxchg(mytid, &amp;first_error_tid, (intptr_t)-1) == -1) {</span>
1334 
1335     // Initialize time stamps to use the same base.
1336     out.time_stamp().update_to(1);
1337     log.time_stamp().update_to(1);
1338 
1339     _id = id;
1340     _message = message;
1341     _thread = thread;
1342     _pc = pc;
1343     _siginfo = siginfo;
1344     _context = context;
1345     _filename = filename;
1346     _lineno = lineno;
1347     _size = size;
1348     jio_vsnprintf(_detail_msg, sizeof(_detail_msg), detail_fmt, detail_args);
1349 
1350     // first time
1351     _error_reported = true;
1352 
1353     reporting_started();
<span class="line-modified">1354     record_reporting_start_time();</span>







1355 
1356     if (ShowMessageBoxOnError || PauseAtExit) {
1357       show_message_box(buffer, sizeof(buffer));
1358 
1359       // User has asked JVM to abort. Reset ShowMessageBoxOnError so the
1360       // WatcherThread can kill JVM if the error handler hangs.
1361       ShowMessageBoxOnError = false;
1362     }
1363 
1364     os::check_dump_limit(buffer, sizeof(buffer));
1365 
1366     // reset signal handlers or exception filter; make sure recursive crashes
1367     // are handled properly.
1368     reset_signal_handlers();
1369 
1370     EventShutdown e;
1371     if (e.should_commit()) {
1372       e.set_reason(&quot;VM Error&quot;);
1373       e.commit();
1374     }
1375 
1376     JFR_ONLY(Jfr::on_vm_shutdown(true);)
1377 
1378   } else {
1379     // If UseOsErrorReporting we call this for each level of the call stack
1380     // while searching for the exception handler.  Only the first level needs
1381     // to be reported.
1382     if (UseOSErrorReporting &amp;&amp; log_done) return;
1383 
1384     // This is not the first error, see if it happened in a different thread
1385     // or in the same thread during error reporting.
<span class="line-modified">1386     if (first_error_tid != mytid) {</span>
1387       char msgbuf[64];
1388       jio_snprintf(msgbuf, sizeof(msgbuf),
1389                    &quot;[thread &quot; INTX_FORMAT &quot; also had an error]&quot;,
1390                    mytid);
1391       out.print_raw_cr(msgbuf);
1392 
1393       // error reporting is not MT-safe, block current thread
1394       os::infinite_sleep();
1395 
1396     } else {
1397       if (recursive_error_count++ &gt; 30) {
1398         out.print_raw_cr(&quot;[Too many errors, abort]&quot;);
1399         os::die();
1400       }
1401 
1402       outputStream* const st = log.is_open() ? &amp;log : &amp;out;
1403       st-&gt;cr();
1404 
1405       // Timeout handling.
1406       if (_step_did_timeout) {
</pre>
<hr />
<pre>
1428                    _current_step_info, id);
1429         char signal_name[64];
1430         if (os::exception_name(id, signal_name, sizeof(signal_name))) {
1431           ss.print(&quot;, %s (0x%x) at pc=&quot; PTR_FORMAT, signal_name, id, p2i(pc));
1432         } else {
1433           if (should_report_bug(id)) {
1434             ss.print(&quot;, Internal Error (%s:%d)&quot;,
1435               filename == NULL ? &quot;??&quot; : filename, lineno);
1436           } else {
1437             ss.print(&quot;, Out of Memory Error (%s:%d)&quot;,
1438               filename == NULL ? &quot;??&quot; : filename, lineno);
1439           }
1440         }
1441         ss.print(&quot;]&quot;);
1442         st-&gt;print_raw_cr(buffer);
1443         st-&gt;cr();
1444       }
1445     }
1446   }
1447 
<span class="line-modified">1448   // print to screen</span>
1449   if (!out_done) {
<span class="line-modified">1450     report(&amp;out, false);</span>




1451 
1452     out_done = true;
1453 
1454     _current_step = 0;
1455     _current_step_info = &quot;&quot;;
1456   }
1457 

1458   // print to error log file
1459   if (!log_done) {
1460     // see if log file is already open
1461     if (!log.is_open()) {
1462       // open log file
<span class="line-modified">1463       fd_log = prepare_log_file(ErrorFile, &quot;hs_err_pid%p.log&quot;, buffer, sizeof(buffer));</span>
<span class="line-modified">1464       if (fd_log != -1) {</span>
<span class="line-modified">1465         out.print_raw(&quot;# An error report file with more information is saved as:\n# &quot;);</span>
<span class="line-modified">1466         out.print_raw_cr(buffer);</span>
<span class="line-removed">1467 </span>
<span class="line-removed">1468         log.set_fd(fd_log);</span>
1469       } else {
<span class="line-modified">1470         out.print_raw_cr(&quot;# Can not save log file, dump to screen..&quot;);</span>
<span class="line-modified">1471         log.set_fd(fd_out);</span>







1472       }

1473     }
1474 
1475     report(&amp;log, true);
1476     log_done = true;
1477     _current_step = 0;
1478     _current_step_info = &quot;&quot;;
1479 
<span class="line-modified">1480     if (fd_log != -1) {</span>
1481       close(fd_log);
1482       fd_log = -1;
1483     }
1484 
1485     log.set_fd(-1);
1486   }
1487 





1488   static bool skip_replay = ReplayCompiles; // Do not overwrite file during replay
1489   if (DumpReplayDataOnError &amp;&amp; _thread &amp;&amp; _thread-&gt;is_Compiler_thread() &amp;&amp; !skip_replay) {
1490     skip_replay = true;
1491     ciEnv* env = ciEnv::current();
1492     if (env != NULL) {
<span class="line-modified">1493       int fd = prepare_log_file(ReplayDataFile, &quot;replay_pid%p.log&quot;, buffer, sizeof(buffer));</span>

1494       if (fd != -1) {
1495         FILE* replay_data_file = os::open(fd, &quot;w&quot;);
1496         if (replay_data_file != NULL) {
1497           fileStream replay_data_stream(replay_data_file, /*need_close=*/true);
1498           env-&gt;dump_replay_data_unsafe(&amp;replay_data_stream);
1499           out.print_raw(&quot;#\n# Compiler replay data is saved as:\n# &quot;);
1500           out.print_raw_cr(buffer);
1501         } else {
1502           int e = errno;
1503           out.print_raw(&quot;#\n# Can&#39;t open file to dump replay data. Error: &quot;);
1504           out.print_raw_cr(os::strerror(e));
1505         }
1506       }
1507     }
1508   }
1509 
1510   static bool skip_bug_url = !should_report_bug(_id);
1511   if (!skip_bug_url) {
1512     skip_bug_url = true;
1513 
</pre>
<hr />
<pre>
1629 // the reporting thread if that is the case.
1630 bool VMError::check_timeout() {
1631 
1632   if (ErrorLogTimeout == 0) {
1633     return false;
1634   }
1635 
1636   // Do not check for timeouts if we still have a message box to show to the
1637   // user or if there are OnError handlers to be run.
1638   if (ShowMessageBoxOnError
1639       || (OnError != NULL &amp;&amp; OnError[0] != &#39;\0&#39;)
1640       || Arguments::abort_hook() != NULL) {
1641     return false;
1642   }
1643 
1644   const jlong reporting_start_time_l = get_reporting_start_time();
1645   const jlong now = get_current_timestamp();
1646   // Timestamp is stored in nanos.
1647   if (reporting_start_time_l &gt; 0) {
1648     const jlong end = reporting_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR;
<span class="line-modified">1649     if (end &lt;= now) {</span>


1650       _reporting_did_timeout = true;
1651       interrupt_reporting_thread();
1652       return true; // global timeout
1653     }
1654   }
1655 
1656   const jlong step_start_time_l = get_step_start_time();
1657   if (step_start_time_l &gt; 0) {
1658     // A step times out after a quarter of the total timeout. Steps are mostly fast unless they
1659     // hang for some reason, so this simple rule allows for three hanging step and still
1660     // hopefully leaves time enough for the rest of the steps to finish.
1661     const jlong end = step_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR / 4;
<span class="line-modified">1662     if (end &lt;= now) {</span>


1663       _step_did_timeout = true;
1664       interrupt_reporting_thread();
1665       return false; // (Not a global timeout)
1666     }
1667   }
1668 
1669   return false;
1670 
1671 }
1672 
1673 #ifndef PRODUCT
1674 #if defined(__SUNPRO_CC) &amp;&amp; __SUNPRO_CC &gt;= 0x5140
1675 #pragma error_messages(off, SEC_NULL_PTR_DEREF)
1676 #endif
1677 typedef void (*voidfun_t)();
1678 // Crash with an authentic sigfpe
1679 static void crash_with_sigfpe() {
1680   // generate a native synchronous SIGFPE where possible;
1681   // if that did not cause a signal (e.g. on ppc), just
1682   // raise the signal.
</pre>
<hr />
<pre>
1708 // 5-7 - fatal
1709 // 8 - vm_exit_out_of_memory
1710 // 9 - ShouldNotCallThis
1711 // 10 - ShouldNotReachHere
1712 // 11 - Unimplemented
1713 // 12,13 - (not guaranteed) crashes
1714 // 14 - SIGSEGV
1715 // 15 - SIGFPE
1716 void VMError::controlled_crash(int how) {
1717   if (how == 0) return;
1718 
1719   // If asserts are disabled, use the corresponding guarantee instead.
1720   NOT_DEBUG(if (how &lt;= 2) how += 2);
1721 
1722   const char* const str = &quot;hello&quot;;
1723   const size_t      num = (size_t)os::vm_page_size();
1724 
1725   const char* const eol = os::line_separator();
1726   const char* const msg = &quot;this message should be truncated during formatting&quot;;
1727   char * const dataPtr = NULL;  // bad data pointer
<span class="line-modified">1728   const void (*funcPtr)(void) = (const void(*)()) 0xF;  // bad function pointer</span>









1729 
1730   // Keep this in sync with test/hotspot/jtreg/runtime/ErrorHandling/ErrorHandler.java
1731   // which tests cases 1 thru 13.
1732   // Case 14 is tested by test/hotspot/jtreg/runtime/ErrorHandling/SafeFetchInErrorHandlingTest.java.
1733   // Case 15 is tested by test/hotspot/jtreg/runtime/ErrorHandling/SecondaryErrorTest.java.
1734   // Case 16 is tested by test/hotspot/jtreg/runtime/ErrorHandling/ThreadsListHandleInErrorHandlingTest.java.
1735   // Case 17 is tested by test/hotspot/jtreg/runtime/ErrorHandling/NestedThreadsListHandleInErrorHandlingTest.java.
1736 
<span class="line-modified">1737   // We grab Threads_lock to keep ThreadsSMRSupport::print_info_on()</span>
1738   // from racing with Threads::add() or Threads::remove() as we
1739   // generate the hs_err_pid file. This makes our ErrorHandling tests
1740   // more stable.
<span class="line-modified">1741   MutexLockerEx ml(Threads_lock-&gt;owned_by_self() ? NULL : Threads_lock, Mutex::_no_safepoint_check_flag);</span>



1742 
1743   switch (how) {
1744     case  1: vmassert(str == NULL, &quot;expected null&quot;); break;
1745     case  2: vmassert(num == 1023 &amp;&amp; *str == &#39;X&#39;,
1746                       &quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
1747     case  3: guarantee(str == NULL, &quot;expected null&quot;); break;
1748     case  4: guarantee(num == 1023 &amp;&amp; *str == &#39;X&#39;,
1749                        &quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
1750     case  5: fatal(&quot;expected null&quot;); break;
1751     case  6: fatal(&quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
1752     case  7: fatal(&quot;%s%s#    %s%s#    %s%s#    %s%s#    %s%s#    &quot;
1753                    &quot;%s%s#    %s%s#    %s%s#    %s%s#    %s%s#    &quot;
1754                    &quot;%s%s#    %s%s#    %s%s#    %s%s#    %s&quot;,
1755                    msg, eol, msg, eol, msg, eol, msg, eol, msg, eol,
1756                    msg, eol, msg, eol, msg, eol, msg, eol, msg, eol,
1757                    msg, eol, msg, eol, msg, eol, msg, eol, msg); break;
1758     case  8: vm_exit_out_of_memory(num, OOM_MALLOC_ERROR, &quot;ChunkPool::allocate&quot;); break;
1759     case  9: ShouldNotCallThis(); break;
1760     case 10: ShouldNotReachHere(); break;
1761     case 11: Unimplemented(); break;
</pre>
<hr />
<pre>
1768     case 14: crash_with_segfault(); break;
1769     case 15: crash_with_sigfpe(); break;
1770     case 16: {
1771       ThreadsListHandle tlh;
1772       fatal(&quot;Force crash with an active ThreadsListHandle.&quot;);
1773     }
1774     case 17: {
1775       ThreadsListHandle tlh;
1776       {
1777         ThreadsListHandle tlh2;
1778         fatal(&quot;Force crash with a nested ThreadsListHandle.&quot;);
1779       }
1780     }
1781 
1782     default: tty-&gt;print_cr(&quot;ERROR: %d: unexpected test_num value.&quot;, how);
1783   }
1784   tty-&gt;print_cr(&quot;VMError::controlled_crash: survived intentional crash. Did you suppress the assert?&quot;);
1785   ShouldNotReachHere();
1786 }
1787 #endif // !PRODUCT
<span class="line-removed">1788 </span>
</pre>
</td>
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;compiler/compileBroker.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/gcConfig.hpp&quot;
  31 #include &quot;logging/logConfiguration.hpp&quot;
  32 #include &quot;jfr/jfrEvents.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  34 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">  35 #include &quot;oops/compressedOops.hpp&quot;</span>
  36 #include &quot;prims/whitebox.hpp&quot;
  37 #include &quot;runtime/arguments.hpp&quot;
  38 #include &quot;runtime/atomic.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/init.hpp&quot;
  41 #include &quot;runtime/os.hpp&quot;
  42 #include &quot;runtime/thread.inline.hpp&quot;
  43 #include &quot;runtime/threadSMR.hpp&quot;
  44 #include &quot;runtime/vmThread.hpp&quot;
  45 #include &quot;runtime/vmOperations.hpp&quot;
  46 #include &quot;runtime/vm_version.hpp&quot;
  47 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  48 #include &quot;services/memTracker.hpp&quot;
  49 #include &quot;utilities/debug.hpp&quot;
  50 #include &quot;utilities/decoder.hpp&quot;
  51 #include &quot;utilities/defaultStream.hpp&quot;
  52 #include &quot;utilities/events.hpp&quot;
  53 #include &quot;utilities/vmError.hpp&quot;
  54 #include &quot;utilities/macros.hpp&quot;
  55 #if INCLUDE_JFR
</pre>
<hr />
<pre>
 111   if (ptr == NULL || *ptr == NULL) return NULL;
 112 
 113   const char* cmd = *ptr;
 114 
 115   // skip leading blanks or &#39;;&#39;
 116   while (*cmd == &#39; &#39; || *cmd == &#39;;&#39;) cmd++;
 117 
 118   if (*cmd == &#39;\0&#39;) return NULL;
 119 
 120   const char * cmdend = cmd;
 121   while (*cmdend != &#39;\0&#39; &amp;&amp; *cmdend != &#39;;&#39;) cmdend++;
 122 
 123   Arguments::copy_expand_pid(cmd, cmdend - cmd, buf, buflen);
 124 
 125   *ptr = (*cmdend == &#39;\0&#39; ? cmdend : cmdend + 1);
 126   return buf;
 127 }
 128 
 129 static void print_bug_submit_message(outputStream *out, Thread *thread) {
 130   if (out == NULL) return;
<span class="line-modified"> 131   const char *url = Arguments::java_vendor_url_bug();</span>
<span class="line-modified"> 132   if (url == NULL || *url == &#39;\0&#39;)</span>
<span class="line-modified"> 133     url = JDK_Version::runtime_vendor_vm_bug_url();</span>
<span class="line-added"> 134   if (url != NULL &amp;&amp; *url != &#39;\0&#39;) {</span>
<span class="line-added"> 135     out-&gt;print_raw_cr(&quot;# If you would like to submit a bug report, please visit:&quot;);</span>
<span class="line-added"> 136     out-&gt;print_raw   (&quot;#   &quot;);</span>
<span class="line-added"> 137     out-&gt;print_raw_cr(url);</span>
<span class="line-added"> 138   }</span>
 139   // If the crash is in native code, encourage user to submit a bug to the
 140   // provider of that code.
 141   if (thread &amp;&amp; thread-&gt;is_Java_thread() &amp;&amp;
 142       !thread-&gt;is_hidden_from_external_view()) {
 143     JavaThread* jt = (JavaThread*)thread;
 144     if (jt-&gt;thread_state() == _thread_in_native) {
 145       out-&gt;print_cr(&quot;# The crash happened outside the Java Virtual Machine in native code.\n# See problematic frame for where to report the bug.&quot;);
 146     }
 147   }
 148   out-&gt;print_raw_cr(&quot;#&quot;);
 149 }
 150 
 151 bool VMError::coredump_status;
 152 char VMError::coredump_message[O_BUFLEN];
 153 
 154 void VMError::record_coredump_status(const char* message, bool status) {
 155   coredump_status = status;
 156   strncpy(coredump_message, message, sizeof(coredump_message));
 157   coredump_message[sizeof(coredump_message)-1] = 0;
 158 }
</pre>
<hr />
<pre>
 281   st-&gt;print_cr(&quot;# Possible reasons:&quot;);
 282   st-&gt;print_cr(&quot;#   The system is out of physical RAM or swap space&quot;);
 283   if (UseCompressedOops) {
 284     st-&gt;print_cr(&quot;#   The process is running with CompressedOops enabled, and the Java Heap may be blocking the growth of the native heap&quot;);
 285   }
 286   if (LogBytesPerWord == 2) {
 287     st-&gt;print_cr(&quot;#   In 32 bit mode, the process size limit was hit&quot;);
 288   }
 289   st-&gt;print_cr(&quot;# Possible solutions:&quot;);
 290   st-&gt;print_cr(&quot;#   Reduce memory load on the system&quot;);
 291   st-&gt;print_cr(&quot;#   Increase physical memory or swap space&quot;);
 292   st-&gt;print_cr(&quot;#   Check if swap backing store is full&quot;);
 293   if (LogBytesPerWord == 2) {
 294     st-&gt;print_cr(&quot;#   Use 64 bit Java on a 64 bit OS&quot;);
 295   }
 296   st-&gt;print_cr(&quot;#   Decrease Java heap size (-Xmx/-Xms)&quot;);
 297   st-&gt;print_cr(&quot;#   Decrease number of Java threads&quot;);
 298   st-&gt;print_cr(&quot;#   Decrease Java thread stack sizes (-Xss)&quot;);
 299   st-&gt;print_cr(&quot;#   Set larger code cache with -XX:ReservedCodeCacheSize=&quot;);
 300   if (UseCompressedOops) {
<span class="line-modified"> 301     switch (CompressedOops::mode()) {</span>
<span class="line-modified"> 302       case CompressedOops::UnscaledNarrowOop:</span>
 303         st-&gt;print_cr(&quot;#   JVM is running with Unscaled Compressed Oops mode in which the Java heap is&quot;);
 304         st-&gt;print_cr(&quot;#     placed in the first 4GB address space. The Java Heap base address is the&quot;);
 305         st-&gt;print_cr(&quot;#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress&quot;);
 306         st-&gt;print_cr(&quot;#     to set the Java Heap base and to place the Java Heap above 4GB virtual address.&quot;);
 307         break;
<span class="line-modified"> 308       case CompressedOops::ZeroBasedNarrowOop:</span>
 309         st-&gt;print_cr(&quot;#   JVM is running with Zero Based Compressed Oops mode in which the Java heap is&quot;);
 310         st-&gt;print_cr(&quot;#     placed in the first 32GB address space. The Java Heap base address is the&quot;);
 311         st-&gt;print_cr(&quot;#     maximum limit for the native heap growth. Please use -XX:HeapBaseMinAddress&quot;);
 312         st-&gt;print_cr(&quot;#     to set the Java Heap base and to place the Java Heap above 32GB virtual address.&quot;);
 313         break;
 314       default:
 315         break;
 316     }
 317   }
 318   st-&gt;print_cr(&quot;# This output file may be truncated or incomplete.&quot;);
 319 }
 320 
 321 static void report_vm_version(outputStream* st, char* buf, int buflen) {
 322    // VM version
 323    st-&gt;print_cr(&quot;#&quot;);
 324    JDK_Version::current().to_string(buf, buflen);
 325    const char* runtime_name = JDK_Version::runtime_name() != NULL ?
 326                                 JDK_Version::runtime_name() : &quot;&quot;;
 327    const char* runtime_version = JDK_Version::runtime_version() != NULL ?
 328                                    JDK_Version::runtime_version() : &quot;&quot;;
<span class="line-added"> 329    const char* vendor_version = JDK_Version::runtime_vendor_version() != NULL ?</span>
<span class="line-added"> 330                                   JDK_Version::runtime_vendor_version() : &quot;&quot;;</span>
 331    const char* jdk_debug_level = VM_Version::printable_jdk_debug_level() != NULL ?
 332                                    VM_Version::printable_jdk_debug_level() : &quot;&quot;;
 333 
<span class="line-modified"> 334    st-&gt;print_cr(&quot;# JRE version: %s%s%s (%s) (%sbuild %s)&quot;, runtime_name,</span>
<span class="line-modified"> 335                 (*vendor_version != &#39;\0&#39;) ? &quot; &quot; : &quot;&quot;, vendor_version,</span>
<span class="line-added"> 336                 buf, jdk_debug_level, runtime_version);</span>
 337 
 338    // This is the long version with some default settings added
<span class="line-modified"> 339    st-&gt;print_cr(&quot;# Java VM: %s%s%s (%s%s, %s%s%s%s%s, %s, %s)&quot;,</span>
 340                  VM_Version::vm_name(),
<span class="line-added"> 341                 (*vendor_version != &#39;\0&#39;) ? &quot; &quot; : &quot;&quot;, vendor_version,</span>
 342                  jdk_debug_level,
 343                  VM_Version::vm_release(),
 344                  VM_Version::vm_info_string(),
 345                  TieredCompilation ? &quot;, tiered&quot; : &quot;&quot;,
 346 #if INCLUDE_JVMCI
 347                  EnableJVMCI ? &quot;, jvmci&quot; : &quot;&quot;,
 348                  UseJVMCICompiler ? &quot;, jvmci compiler&quot; : &quot;&quot;,
 349 #else
 350                  &quot;&quot;, &quot;&quot;,
 351 #endif
 352                  UseCompressedOops ? &quot;, compressed oops&quot; : &quot;&quot;,
 353                  GCConfig::hs_err_name(),
 354                  VM_Version::vm_platform_string()
 355                );
 356 }
 357 
 358 // This is the main function to report a fatal error. Only one thread can
 359 // call this function, so we don&#39;t need to worry about MT-safety. But it&#39;s
 360 // possible that the error handler itself may crash or die on an internal
 361 // error, for example, when the stack/heap is badly damaged. We must be
</pre>
<hr />
<pre>
 382 // thread can report error, so large buffers are statically allocated in data
 383 // segment.
 384 
 385 int          VMError::_current_step;
 386 const char*  VMError::_current_step_info;
 387 
 388 volatile jlong VMError::_reporting_start_time = -1;
 389 volatile bool VMError::_reporting_did_timeout = false;
 390 volatile jlong VMError::_step_start_time = -1;
 391 volatile bool VMError::_step_did_timeout = false;
 392 
 393 // Helper, return current timestamp for timeout handling.
 394 jlong VMError::get_current_timestamp() {
 395   return os::javaTimeNanos();
 396 }
 397 // Factor to translate the timestamp to seconds.
 398 #define TIMESTAMP_TO_SECONDS_FACTOR (1000 * 1000 * 1000)
 399 
 400 void VMError::record_reporting_start_time() {
 401   const jlong now = get_current_timestamp();
<span class="line-modified"> 402   Atomic::store(&amp;_reporting_start_time, now);</span>
 403 }
 404 
 405 jlong VMError::get_reporting_start_time() {
 406   return Atomic::load(&amp;_reporting_start_time);
 407 }
 408 
 409 void VMError::record_step_start_time() {
 410   const jlong now = get_current_timestamp();
<span class="line-modified"> 411   Atomic::store(&amp;_step_start_time, now);</span>
 412 }
 413 
 414 jlong VMError::get_step_start_time() {
 415   return Atomic::load(&amp;_step_start_time);
 416 }
 417 
<span class="line-added"> 418 void VMError::clear_step_start_time() {</span>
<span class="line-added"> 419   return Atomic::store(&amp;_step_start_time, (jlong)0);</span>
<span class="line-added"> 420 }</span>
<span class="line-added"> 421 </span>
 422 void VMError::report(outputStream* st, bool _verbose) {
 423 
 424 # define BEGIN if (_current_step == 0) { _current_step = __LINE__;
 425 # define STEP(s) } if (_current_step &lt; __LINE__) { _current_step = __LINE__; _current_step_info = s; \
 426   record_step_start_time(); _step_did_timeout = false;
<span class="line-modified"> 427 # define END clear_step_start_time(); }</span>
 428 
 429   // don&#39;t allocate large buffer on stack
 430   static char buf[O_BUFLEN];
 431 
 432   BEGIN
 433 
 434   STEP(&quot;printing fatal error message&quot;)
 435 
 436     st-&gt;print_cr(&quot;#&quot;);
 437     if (should_report_bug(_id)) {
 438       st-&gt;print_cr(&quot;# A fatal error has been detected by the Java Runtime Environment:&quot;);
 439     } else {
 440       st-&gt;print_cr(&quot;# There is insufficient memory for the Java &quot;
 441                    &quot;Runtime Environment to continue.&quot;);
 442     }
 443 
 444 #ifndef PRODUCT
 445   // Error handler self tests
 446 
 447   // test secondary error handling. Test it twice, to test that resetting
 448   // error handler after a secondary crash works.
 449   STEP(&quot;test secondary crash 1&quot;)
 450     if (_verbose &amp;&amp; TestCrashInErrorHandler != 0) {
 451       st-&gt;print_cr(&quot;Will crash now (TestCrashInErrorHandler=&quot; UINTX_FORMAT &quot;)...&quot;,
 452         TestCrashInErrorHandler);
 453       controlled_crash(TestCrashInErrorHandler);
 454     }
 455 
 456   STEP(&quot;test secondary crash 2&quot;)
 457     if (_verbose &amp;&amp; TestCrashInErrorHandler != 0) {
 458       st-&gt;print_cr(&quot;Will crash now (TestCrashInErrorHandler=&quot; UINTX_FORMAT &quot;)...&quot;,
 459         TestCrashInErrorHandler);
 460       controlled_crash(TestCrashInErrorHandler);
 461     }
 462 
 463   // TestUnresponsiveErrorHandler: We want to test both step timeouts and global timeout.
 464   // Step to global timeout ratio is 4:1, so in order to be absolutely sure we hit the
 465   // global timeout, let&#39;s execute the timeout step five times.
 466   // See corresponding test in test/runtime/ErrorHandling/TimeoutInErrorHandlingTest.java
<span class="line-added"> 467   STEP(&quot;setup for test unresponsive error reporting step&quot;)</span>
<span class="line-added"> 468     if (_verbose &amp;&amp; TestUnresponsiveErrorHandler) {</span>
<span class="line-added"> 469       // We record reporting_start_time for this test here because we</span>
<span class="line-added"> 470       // care about the time spent executing TIMEOUT_TEST_STEP and not</span>
<span class="line-added"> 471       // about the time it took us to get here.</span>
<span class="line-added"> 472       tty-&gt;print_cr(&quot;Recording reporting_start_time for TestUnresponsiveErrorHandler.&quot;);</span>
<span class="line-added"> 473       record_reporting_start_time();</span>
<span class="line-added"> 474     }</span>
<span class="line-added"> 475 </span>
 476   #define TIMEOUT_TEST_STEP STEP(&quot;test unresponsive error reporting step&quot;) \
 477     if (_verbose &amp;&amp; TestUnresponsiveErrorHandler) { os::infinite_sleep(); }
 478   TIMEOUT_TEST_STEP
 479   TIMEOUT_TEST_STEP
 480   TIMEOUT_TEST_STEP
 481   TIMEOUT_TEST_STEP
 482   TIMEOUT_TEST_STEP
 483 
 484   STEP(&quot;test safefetch in error handler&quot;)
 485     // test whether it is safe to use SafeFetch32 in Crash Handler. Test twice
 486     // to test that resetting the signal handler works correctly.
 487     if (_verbose &amp;&amp; TestSafeFetchInErrorHandler) {
 488       st-&gt;print_cr(&quot;Will test SafeFetch...&quot;);
 489       if (CanUseSafeFetch32()) {
 490         int* const invalid_pointer = (int*) get_segfault_address();
 491         const int x = 0x76543210;
 492         int i1 = SafeFetch32(invalid_pointer, x);
 493         int i2 = SafeFetch32(invalid_pointer, x);
 494         if (i1 == x &amp;&amp; i2 == x) {
 495           st-&gt;print_cr(&quot;SafeFetch OK.&quot;); // Correctly deflected and returned default pattern
</pre>
<hr />
<pre>
 889 
 890   STEP(&quot;printing owned locks on error&quot;)
 891 
 892      // mutexes/monitors that currently have an owner
 893      if (_verbose) {
 894        print_owned_locks_on_error(st);
 895        st-&gt;cr();
 896      }
 897 
 898   STEP(&quot;printing number of OutOfMemoryError and StackOverflow exceptions&quot;)
 899 
 900      if (_verbose &amp;&amp; Exceptions::has_exception_counts()) {
 901        st-&gt;print_cr(&quot;OutOfMemory and StackOverflow Exception counts:&quot;);
 902        Exceptions::print_exception_counts_on_error(st);
 903        st-&gt;cr();
 904      }
 905 
 906   STEP(&quot;printing compressed oops mode&quot;)
 907 
 908      if (_verbose &amp;&amp; UseCompressedOops) {
<span class="line-modified"> 909        CompressedOops::print_mode(st);</span>
 910        if (UseCompressedClassPointers) {
 911          Metaspace::print_compressed_class_space(st);
 912        }
 913        st-&gt;cr();
 914      }
 915 
 916   STEP(&quot;printing heap information&quot;)
 917 
 918      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 919        Universe::heap()-&gt;print_on_error(st);
 920        st-&gt;cr();
 921        st-&gt;print_cr(&quot;Polling page: &quot; INTPTR_FORMAT, p2i(os::get_polling_page()));
 922        st-&gt;cr();
 923      }
 924 
 925   STEP(&quot;printing metaspace information&quot;)
 926 
 927      if (_verbose &amp;&amp; Universe::is_fully_initialized()) {
 928        st-&gt;print_cr(&quot;Metaspace:&quot;);
 929        MetaspaceUtils::print_basic_report(st, 0);
</pre>
<hr />
<pre>
1090 
1091   // Skip: STEP(&quot;printing thread&quot;)
1092 
1093   // STEP(&quot;printing process&quot;)
1094 
1095   st-&gt;cr();
1096   st-&gt;print_cr(&quot;---------------  P R O C E S S  ---------------&quot;);
1097   st-&gt;cr();
1098 
1099   // STEP(&quot;printing number of OutOfMemoryError and StackOverflow exceptions&quot;)
1100 
1101   if (Exceptions::has_exception_counts()) {
1102     st-&gt;print_cr(&quot;OutOfMemory and StackOverflow Exception counts:&quot;);
1103     Exceptions::print_exception_counts_on_error(st);
1104     st-&gt;cr();
1105   }
1106 
1107   // STEP(&quot;printing compressed oops mode&quot;)
1108 
1109   if (UseCompressedOops) {
<span class="line-modified">1110     CompressedOops::print_mode(st);</span>
1111     if (UseCompressedClassPointers) {
1112       Metaspace::print_compressed_class_space(st);
1113     }
1114     st-&gt;cr();
1115   }
1116 
1117   // STEP(&quot;printing heap information&quot;)
1118 
1119   if (Universe::is_fully_initialized()) {
1120     MutexLocker hl(Heap_lock);
1121     Universe::heap()-&gt;print_on_error(st);
1122     st-&gt;cr();
1123     st-&gt;print_cr(&quot;Polling page: &quot; INTPTR_FORMAT, p2i(os::get_polling_page()));
1124     st-&gt;cr();
1125   }
1126 
1127   // STEP(&quot;printing metaspace information&quot;)
1128 
1129   if (Universe::is_fully_initialized()) {
1130     st-&gt;print_cr(&quot;Metaspace:&quot;);
</pre>
<hr />
<pre>
1197 
1198   os::print_cpu_info(st, buf, sizeof(buf));
1199   st-&gt;cr();
1200 
1201   // STEP(&quot;printing memory info&quot;)
1202 
1203   os::print_memory_info(st);
1204   st-&gt;cr();
1205 
1206   // STEP(&quot;printing internal vm info&quot;)
1207 
1208   st-&gt;print_cr(&quot;vm_info: %s&quot;, VM_Version::internal_vm_info_string());
1209   st-&gt;cr();
1210 
1211   // print a defined marker to show that error handling finished correctly.
1212   // STEP(&quot;printing end marker&quot;)
1213 
1214   st-&gt;print_cr(&quot;END.&quot;);
1215 }
1216 
<span class="line-modified">1217 volatile intptr_t VMError::_first_error_tid = -1;</span>
1218 
1219 /** Expand a pattern into a buffer starting at pos and open a file using constructed path */
<span class="line-modified">1220 static int expand_and_open(const char* pattern, bool overwrite_existing, char* buf, size_t buflen, size_t pos) {</span>
1221   int fd = -1;
<span class="line-added">1222   int mode = O_RDWR | O_CREAT;</span>
<span class="line-added">1223   if (overwrite_existing) {</span>
<span class="line-added">1224     mode |= O_TRUNC;</span>
<span class="line-added">1225   } else {</span>
<span class="line-added">1226     mode |= O_EXCL;</span>
<span class="line-added">1227   }</span>
1228   if (Arguments::copy_expand_pid(pattern, strlen(pattern), &amp;buf[pos], buflen - pos)) {
<span class="line-modified">1229     fd = open(buf, mode, 0666);</span>

1230   }
1231   return fd;
1232 }
1233 
1234 /**
1235  * Construct file name for a log file and return it&#39;s file descriptor.
1236  * Name and location depends on pattern, default_pattern params and access
1237  * permissions.
1238  */
<span class="line-modified">1239 static int prepare_log_file(const char* pattern, const char* default_pattern, bool overwrite_existing, char* buf, size_t buflen) {</span>
1240   int fd = -1;
1241 
1242   // If possible, use specified pattern to construct log file name
1243   if (pattern != NULL) {
<span class="line-modified">1244     fd = expand_and_open(pattern, overwrite_existing, buf, buflen, 0);</span>
1245   }
1246 
1247   // Either user didn&#39;t specify, or the user&#39;s location failed,
1248   // so use the default name in the current directory
1249   if (fd == -1) {
1250     const char* cwd = os::get_current_directory(buf, buflen);
1251     if (cwd != NULL) {
1252       size_t pos = strlen(cwd);
1253       int fsep_len = jio_snprintf(&amp;buf[pos], buflen-pos, &quot;%s&quot;, os::file_separator());
1254       pos += fsep_len;
1255       if (fsep_len &gt; 0) {
<span class="line-modified">1256         fd = expand_and_open(default_pattern, overwrite_existing, buf, buflen, pos);</span>
1257       }
1258     }
1259   }
1260 
1261    // try temp directory if it exists.
1262    if (fd == -1) {
1263      const char* tmpdir = os::get_temp_directory();
1264      if (tmpdir != NULL &amp;&amp; strlen(tmpdir) &gt; 0) {
1265        int pos = jio_snprintf(buf, buflen, &quot;%s%s&quot;, tmpdir, os::file_separator());
1266        if (pos &gt; 0) {
<span class="line-modified">1267          fd = expand_and_open(default_pattern, overwrite_existing, buf, buflen, pos);</span>
1268        }
1269      }
1270    }
1271 
1272   return fd;
1273 }
1274 
1275 int         VMError::_id;
1276 const char* VMError::_message;
1277 char        VMError::_detail_msg[1024];
1278 Thread*     VMError::_thread;
1279 address     VMError::_pc;
1280 void*       VMError::_siginfo;
1281 void*       VMError::_context;
1282 const char* VMError::_filename;
1283 int         VMError::_lineno;
1284 size_t      VMError::_size;
1285 
1286 void VMError::report_and_die(Thread* thread, unsigned int sig, address pc, void* siginfo,
1287                              void* context, const char* detail_fmt, ...)
</pre>
<hr />
<pre>
1319 void VMError::report_and_die(Thread* thread, const char* filename, int lineno, size_t size,
1320                              VMErrorType vm_err_type, const char* detail_fmt, va_list detail_args) {
1321   report_and_die(vm_err_type, NULL, detail_fmt, detail_args, thread, NULL, NULL, NULL, filename, lineno, size);
1322 }
1323 
1324 void VMError::report_and_die(int id, const char* message, const char* detail_fmt, va_list detail_args,
1325                              Thread* thread, address pc, void* siginfo, void* context, const char* filename,
1326                              int lineno, size_t size)
1327 {
1328   // A single scratch buffer to be used from here on.
1329   // Do not rely on it being preserved across function calls.
1330   static char buffer[O_BUFLEN];
1331 
1332   // File descriptor to tty to print an error summary to.
1333   // Hard wired to stdout; see JDK-8215004 (compatibility concerns).
1334   static const int fd_out = 1; // stdout
1335 
1336   // File descriptor to the error log file.
1337   static int fd_log = -1;
1338 
<span class="line-added">1339 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT</span>
<span class="line-added">1340   // Disarm assertion poison page, since from this point on we do not need this mechanism anymore and it may</span>
<span class="line-added">1341   // cause problems in error handling during native OOM, see JDK-8227275.</span>
<span class="line-added">1342   disarm_assert_poison();</span>
<span class="line-added">1343 #endif</span>
<span class="line-added">1344 </span>
1345   // Use local fdStream objects only. Do not use global instances whose initialization
1346   // relies on dynamic initialization (see JDK-8214975). Do not rely on these instances
1347   // to carry over into recursions or invocations from other threads.
1348   fdStream out(fd_out);
1349   out.set_scratch_buffer(buffer, sizeof(buffer));
1350 
1351   // Depending on the re-entrance depth at this point, fd_log may be -1 or point to an open hs-err file.
1352   fdStream log(fd_log);
1353   log.set_scratch_buffer(buffer, sizeof(buffer));
1354 
1355   // How many errors occurred in error handler when reporting first_error.
1356   static int recursive_error_count;
1357 
1358   // We will first print a brief message to standard out (verbose = false),
1359   // then save detailed information in log file (verbose = true).
1360   static bool out_done = false;         // done printing to standard out
1361   static bool log_done = false;         // done saving error log
1362 
1363   if (SuppressFatalErrorMessage) {
1364       os::abort(CreateCoredumpOnCrash);
1365   }
1366   intptr_t mytid = os::current_thread_id();
<span class="line-modified">1367   if (_first_error_tid == -1 &amp;&amp;</span>
<span class="line-modified">1368       Atomic::cmpxchg(&amp;_first_error_tid, (intptr_t)-1, mytid) == -1) {</span>
1369 
1370     // Initialize time stamps to use the same base.
1371     out.time_stamp().update_to(1);
1372     log.time_stamp().update_to(1);
1373 
1374     _id = id;
1375     _message = message;
1376     _thread = thread;
1377     _pc = pc;
1378     _siginfo = siginfo;
1379     _context = context;
1380     _filename = filename;
1381     _lineno = lineno;
1382     _size = size;
1383     jio_vsnprintf(_detail_msg, sizeof(_detail_msg), detail_fmt, detail_args);
1384 
1385     // first time
1386     _error_reported = true;
1387 
1388     reporting_started();
<span class="line-modified">1389     if (!TestUnresponsiveErrorHandler) {</span>
<span class="line-added">1390       // Record reporting_start_time unless we&#39;re running the</span>
<span class="line-added">1391       // TestUnresponsiveErrorHandler test. For that test we record</span>
<span class="line-added">1392       // reporting_start_time at the beginning of the test.</span>
<span class="line-added">1393       record_reporting_start_time();</span>
<span class="line-added">1394     } else {</span>
<span class="line-added">1395       out.print_raw_cr(&quot;Delaying recording reporting_start_time for TestUnresponsiveErrorHandler.&quot;);</span>
<span class="line-added">1396     }</span>
1397 
1398     if (ShowMessageBoxOnError || PauseAtExit) {
1399       show_message_box(buffer, sizeof(buffer));
1400 
1401       // User has asked JVM to abort. Reset ShowMessageBoxOnError so the
1402       // WatcherThread can kill JVM if the error handler hangs.
1403       ShowMessageBoxOnError = false;
1404     }
1405 
1406     os::check_dump_limit(buffer, sizeof(buffer));
1407 
1408     // reset signal handlers or exception filter; make sure recursive crashes
1409     // are handled properly.
1410     reset_signal_handlers();
1411 
1412     EventShutdown e;
1413     if (e.should_commit()) {
1414       e.set_reason(&quot;VM Error&quot;);
1415       e.commit();
1416     }
1417 
1418     JFR_ONLY(Jfr::on_vm_shutdown(true);)
1419 
1420   } else {
1421     // If UseOsErrorReporting we call this for each level of the call stack
1422     // while searching for the exception handler.  Only the first level needs
1423     // to be reported.
1424     if (UseOSErrorReporting &amp;&amp; log_done) return;
1425 
1426     // This is not the first error, see if it happened in a different thread
1427     // or in the same thread during error reporting.
<span class="line-modified">1428     if (_first_error_tid != mytid) {</span>
1429       char msgbuf[64];
1430       jio_snprintf(msgbuf, sizeof(msgbuf),
1431                    &quot;[thread &quot; INTX_FORMAT &quot; also had an error]&quot;,
1432                    mytid);
1433       out.print_raw_cr(msgbuf);
1434 
1435       // error reporting is not MT-safe, block current thread
1436       os::infinite_sleep();
1437 
1438     } else {
1439       if (recursive_error_count++ &gt; 30) {
1440         out.print_raw_cr(&quot;[Too many errors, abort]&quot;);
1441         os::die();
1442       }
1443 
1444       outputStream* const st = log.is_open() ? &amp;log : &amp;out;
1445       st-&gt;cr();
1446 
1447       // Timeout handling.
1448       if (_step_did_timeout) {
</pre>
<hr />
<pre>
1470                    _current_step_info, id);
1471         char signal_name[64];
1472         if (os::exception_name(id, signal_name, sizeof(signal_name))) {
1473           ss.print(&quot;, %s (0x%x) at pc=&quot; PTR_FORMAT, signal_name, id, p2i(pc));
1474         } else {
1475           if (should_report_bug(id)) {
1476             ss.print(&quot;, Internal Error (%s:%d)&quot;,
1477               filename == NULL ? &quot;??&quot; : filename, lineno);
1478           } else {
1479             ss.print(&quot;, Out of Memory Error (%s:%d)&quot;,
1480               filename == NULL ? &quot;??&quot; : filename, lineno);
1481           }
1482         }
1483         ss.print(&quot;]&quot;);
1484         st-&gt;print_raw_cr(buffer);
1485         st-&gt;cr();
1486       }
1487     }
1488   }
1489 
<span class="line-modified">1490   // Part 1: print an abbreviated version (the &#39;#&#39; section) to stdout.</span>
1491   if (!out_done) {
<span class="line-modified">1492     // Suppress this output if we plan to print Part 2 to stdout too.</span>
<span class="line-added">1493     // No need to have the &quot;#&quot; section twice.</span>
<span class="line-added">1494     if (!(ErrorFileToStdout &amp;&amp; out.fd() == 1)) {</span>
<span class="line-added">1495       report(&amp;out, false);</span>
<span class="line-added">1496     }</span>
1497 
1498     out_done = true;
1499 
1500     _current_step = 0;
1501     _current_step_info = &quot;&quot;;
1502   }
1503 
<span class="line-added">1504   // Part 2: print a full error log file (optionally to stdout or stderr).</span>
1505   // print to error log file
1506   if (!log_done) {
1507     // see if log file is already open
1508     if (!log.is_open()) {
1509       // open log file
<span class="line-modified">1510       if (ErrorFileToStdout) {</span>
<span class="line-modified">1511         fd_log = 1;</span>
<span class="line-modified">1512       } else if (ErrorFileToStderr) {</span>
<span class="line-modified">1513         fd_log = 2;</span>


1514       } else {
<span class="line-modified">1515         fd_log = prepare_log_file(ErrorFile, &quot;hs_err_pid%p.log&quot;, true,</span>
<span class="line-modified">1516                  buffer, sizeof(buffer));</span>
<span class="line-added">1517         if (fd_log != -1) {</span>
<span class="line-added">1518           out.print_raw(&quot;# An error report file with more information is saved as:\n# &quot;);</span>
<span class="line-added">1519           out.print_raw_cr(buffer);</span>
<span class="line-added">1520         } else {</span>
<span class="line-added">1521           out.print_raw_cr(&quot;# Can not save log file, dump to screen..&quot;);</span>
<span class="line-added">1522           fd_log = 1;</span>
<span class="line-added">1523         }</span>
1524       }
<span class="line-added">1525       log.set_fd(fd_log);</span>
1526     }
1527 
1528     report(&amp;log, true);
1529     log_done = true;
1530     _current_step = 0;
1531     _current_step_info = &quot;&quot;;
1532 
<span class="line-modified">1533     if (fd_log &gt; 3) {</span>
1534       close(fd_log);
1535       fd_log = -1;
1536     }
1537 
1538     log.set_fd(-1);
1539   }
1540 
<span class="line-added">1541   if (PrintNMTStatistics) {</span>
<span class="line-added">1542     fdStream fds(fd_out);</span>
<span class="line-added">1543     MemTracker::final_report(&amp;fds);</span>
<span class="line-added">1544   }</span>
<span class="line-added">1545 </span>
1546   static bool skip_replay = ReplayCompiles; // Do not overwrite file during replay
1547   if (DumpReplayDataOnError &amp;&amp; _thread &amp;&amp; _thread-&gt;is_Compiler_thread() &amp;&amp; !skip_replay) {
1548     skip_replay = true;
1549     ciEnv* env = ciEnv::current();
1550     if (env != NULL) {
<span class="line-modified">1551       const bool overwrite = false; // We do not overwrite an existing replay file.</span>
<span class="line-added">1552       int fd = prepare_log_file(ReplayDataFile, &quot;replay_pid%p.log&quot;, overwrite, buffer, sizeof(buffer));</span>
1553       if (fd != -1) {
1554         FILE* replay_data_file = os::open(fd, &quot;w&quot;);
1555         if (replay_data_file != NULL) {
1556           fileStream replay_data_stream(replay_data_file, /*need_close=*/true);
1557           env-&gt;dump_replay_data_unsafe(&amp;replay_data_stream);
1558           out.print_raw(&quot;#\n# Compiler replay data is saved as:\n# &quot;);
1559           out.print_raw_cr(buffer);
1560         } else {
1561           int e = errno;
1562           out.print_raw(&quot;#\n# Can&#39;t open file to dump replay data. Error: &quot;);
1563           out.print_raw_cr(os::strerror(e));
1564         }
1565       }
1566     }
1567   }
1568 
1569   static bool skip_bug_url = !should_report_bug(_id);
1570   if (!skip_bug_url) {
1571     skip_bug_url = true;
1572 
</pre>
<hr />
<pre>
1688 // the reporting thread if that is the case.
1689 bool VMError::check_timeout() {
1690 
1691   if (ErrorLogTimeout == 0) {
1692     return false;
1693   }
1694 
1695   // Do not check for timeouts if we still have a message box to show to the
1696   // user or if there are OnError handlers to be run.
1697   if (ShowMessageBoxOnError
1698       || (OnError != NULL &amp;&amp; OnError[0] != &#39;\0&#39;)
1699       || Arguments::abort_hook() != NULL) {
1700     return false;
1701   }
1702 
1703   const jlong reporting_start_time_l = get_reporting_start_time();
1704   const jlong now = get_current_timestamp();
1705   // Timestamp is stored in nanos.
1706   if (reporting_start_time_l &gt; 0) {
1707     const jlong end = reporting_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR;
<span class="line-modified">1708     if (end &lt;= now &amp;&amp; !_reporting_did_timeout) {</span>
<span class="line-added">1709       // We hit ErrorLogTimeout and we haven&#39;t interrupted the reporting</span>
<span class="line-added">1710       // thread yet.</span>
1711       _reporting_did_timeout = true;
1712       interrupt_reporting_thread();
1713       return true; // global timeout
1714     }
1715   }
1716 
1717   const jlong step_start_time_l = get_step_start_time();
1718   if (step_start_time_l &gt; 0) {
1719     // A step times out after a quarter of the total timeout. Steps are mostly fast unless they
1720     // hang for some reason, so this simple rule allows for three hanging step and still
1721     // hopefully leaves time enough for the rest of the steps to finish.
1722     const jlong end = step_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR / 4;
<span class="line-modified">1723     if (end &lt;= now &amp;&amp; !_step_did_timeout) {</span>
<span class="line-added">1724       // The step timed out and we haven&#39;t interrupted the reporting</span>
<span class="line-added">1725       // thread yet.</span>
1726       _step_did_timeout = true;
1727       interrupt_reporting_thread();
1728       return false; // (Not a global timeout)
1729     }
1730   }
1731 
1732   return false;
1733 
1734 }
1735 
1736 #ifndef PRODUCT
1737 #if defined(__SUNPRO_CC) &amp;&amp; __SUNPRO_CC &gt;= 0x5140
1738 #pragma error_messages(off, SEC_NULL_PTR_DEREF)
1739 #endif
1740 typedef void (*voidfun_t)();
1741 // Crash with an authentic sigfpe
1742 static void crash_with_sigfpe() {
1743   // generate a native synchronous SIGFPE where possible;
1744   // if that did not cause a signal (e.g. on ppc), just
1745   // raise the signal.
</pre>
<hr />
<pre>
1771 // 5-7 - fatal
1772 // 8 - vm_exit_out_of_memory
1773 // 9 - ShouldNotCallThis
1774 // 10 - ShouldNotReachHere
1775 // 11 - Unimplemented
1776 // 12,13 - (not guaranteed) crashes
1777 // 14 - SIGSEGV
1778 // 15 - SIGFPE
1779 void VMError::controlled_crash(int how) {
1780   if (how == 0) return;
1781 
1782   // If asserts are disabled, use the corresponding guarantee instead.
1783   NOT_DEBUG(if (how &lt;= 2) how += 2);
1784 
1785   const char* const str = &quot;hello&quot;;
1786   const size_t      num = (size_t)os::vm_page_size();
1787 
1788   const char* const eol = os::line_separator();
1789   const char* const msg = &quot;this message should be truncated during formatting&quot;;
1790   char * const dataPtr = NULL;  // bad data pointer
<span class="line-modified">1791   const void (*funcPtr)(void);  // bad function pointer</span>
<span class="line-added">1792 </span>
<span class="line-added">1793 #if defined(PPC64) &amp;&amp; !defined(ABI_ELFv2)</span>
<span class="line-added">1794   struct FunctionDescriptor functionDescriptor;</span>
<span class="line-added">1795 </span>
<span class="line-added">1796   functionDescriptor.set_entry((address) 0xF);</span>
<span class="line-added">1797   funcPtr = (const void(*)()) &amp;functionDescriptor;</span>
<span class="line-added">1798 #else</span>
<span class="line-added">1799   funcPtr = (const void(*)()) 0xF;</span>
<span class="line-added">1800 #endif</span>
1801 
1802   // Keep this in sync with test/hotspot/jtreg/runtime/ErrorHandling/ErrorHandler.java
1803   // which tests cases 1 thru 13.
1804   // Case 14 is tested by test/hotspot/jtreg/runtime/ErrorHandling/SafeFetchInErrorHandlingTest.java.
1805   // Case 15 is tested by test/hotspot/jtreg/runtime/ErrorHandling/SecondaryErrorTest.java.
1806   // Case 16 is tested by test/hotspot/jtreg/runtime/ErrorHandling/ThreadsListHandleInErrorHandlingTest.java.
1807   // Case 17 is tested by test/hotspot/jtreg/runtime/ErrorHandling/NestedThreadsListHandleInErrorHandlingTest.java.
1808 
<span class="line-modified">1809   // We try to grab Threads_lock to keep ThreadsSMRSupport::print_info_on()</span>
1810   // from racing with Threads::add() or Threads::remove() as we
1811   // generate the hs_err_pid file. This makes our ErrorHandling tests
1812   // more stable.
<span class="line-modified">1813   if (!Threads_lock-&gt;owned_by_self()) {</span>
<span class="line-added">1814     Threads_lock-&gt;try_lock();</span>
<span class="line-added">1815     // The VM is going to die so no need to unlock Thread_lock.</span>
<span class="line-added">1816   }</span>
1817 
1818   switch (how) {
1819     case  1: vmassert(str == NULL, &quot;expected null&quot;); break;
1820     case  2: vmassert(num == 1023 &amp;&amp; *str == &#39;X&#39;,
1821                       &quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
1822     case  3: guarantee(str == NULL, &quot;expected null&quot;); break;
1823     case  4: guarantee(num == 1023 &amp;&amp; *str == &#39;X&#39;,
1824                        &quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
1825     case  5: fatal(&quot;expected null&quot;); break;
1826     case  6: fatal(&quot;num=&quot; SIZE_FORMAT &quot; str=\&quot;%s\&quot;&quot;, num, str); break;
1827     case  7: fatal(&quot;%s%s#    %s%s#    %s%s#    %s%s#    %s%s#    &quot;
1828                    &quot;%s%s#    %s%s#    %s%s#    %s%s#    %s%s#    &quot;
1829                    &quot;%s%s#    %s%s#    %s%s#    %s%s#    %s&quot;,
1830                    msg, eol, msg, eol, msg, eol, msg, eol, msg, eol,
1831                    msg, eol, msg, eol, msg, eol, msg, eol, msg, eol,
1832                    msg, eol, msg, eol, msg, eol, msg, eol, msg); break;
1833     case  8: vm_exit_out_of_memory(num, OOM_MALLOC_ERROR, &quot;ChunkPool::allocate&quot;); break;
1834     case  9: ShouldNotCallThis(); break;
1835     case 10: ShouldNotReachHere(); break;
1836     case 11: Unimplemented(); break;
</pre>
<hr />
<pre>
1843     case 14: crash_with_segfault(); break;
1844     case 15: crash_with_sigfpe(); break;
1845     case 16: {
1846       ThreadsListHandle tlh;
1847       fatal(&quot;Force crash with an active ThreadsListHandle.&quot;);
1848     }
1849     case 17: {
1850       ThreadsListHandle tlh;
1851       {
1852         ThreadsListHandle tlh2;
1853         fatal(&quot;Force crash with a nested ThreadsListHandle.&quot;);
1854       }
1855     }
1856 
1857     default: tty-&gt;print_cr(&quot;ERROR: %d: unexpected test_num value.&quot;, how);
1858   }
1859   tty-&gt;print_cr(&quot;VMError::controlled_crash: survived intentional crash. Did you suppress the assert?&quot;);
1860   ShouldNotReachHere();
1861 }
1862 #endif // !PRODUCT

</pre>
</td>
</tr>
</table>
<center><a href="ticks.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmError.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/utilities/debug.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="count_leading_zeros.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debug.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/debug.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -321,11 +321,11 @@</span>
  
    // A number of threads may attempt to report OutOfMemoryError at around the
    // same time. To avoid dumping the heap or executing the data collection
    // commands multiple times we just do it once when the first threads reports
    // the error.
<span class="udiff-line-modified-removed">-   if (Atomic::cmpxchg(1, &amp;out_of_memory_reported, 0) == 0) {</span>
<span class="udiff-line-modified-added">+   if (Atomic::cmpxchg(&amp;out_of_memory_reported, 0, 1) == 0) {</span>
      // create heap dump before OnOutOfMemoryError commands are executed
      if (HeapDumpOnOutOfMemoryError) {
        tty-&gt;print_cr(&quot;java.lang.OutOfMemoryError: %s&quot;, message);
        HeapDumper::dump_heap_from_oome();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -640,10 +640,11 @@</span>
    tty-&gt;print_cr(&quot;  findm(intptr_t pc) - finds Method*&quot;);
    tty-&gt;print_cr(&quot;  find(intptr_t x)   - finds &amp; prints nmethod/stub/bytecode/oop based on pointer into it&quot;);
    tty-&gt;print_cr(&quot;  pns(void* sp, void* fp, void* pc)  - print native (i.e. mixed) stack trace. E.g.&quot;);
    tty-&gt;print_cr(&quot;                   pns($sp, $rbp, $pc) on Linux/amd64 and Solaris/amd64 or&quot;);
    tty-&gt;print_cr(&quot;                   pns($sp, $ebp, $pc) on Linux/x86 or&quot;);
<span class="udiff-line-added">+   tty-&gt;print_cr(&quot;                   pns($sp, $fp, $pc)  on Linux/AArch64 or&quot;);</span>
    tty-&gt;print_cr(&quot;                   pns($sp, 0, $pc)    on Linux/ppc64 or&quot;);
    tty-&gt;print_cr(&quot;                   pns($sp, $s8, $pc)  on Linux/mips or&quot;);
    tty-&gt;print_cr(&quot;                   pns($sp + 0x7ff, 0, $pc) on Solaris/SPARC&quot;);
    tty-&gt;print_cr(&quot;                 - in gdb do &#39;set overload-resolution off&#39; before calling pns()&quot;);
    tty-&gt;print_cr(&quot;                 - in dbx do &#39;frame 1&#39; before calling pns()&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -732,10 +733,14 @@</span>
        g_assert_poison = page;
      }
    }
  }
  
<span class="udiff-line-added">+ void disarm_assert_poison() {</span>
<span class="udiff-line-added">+   g_assert_poison = &amp;g_dummy;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  static void store_context(const void* context) {
    memcpy(&amp;g_stored_assertion_context, context, sizeof(ucontext_t));
  #if defined(__linux) &amp;&amp; defined(PPC64)
    // on Linux ppc64, ucontext_t contains pointers into itself which have to be patched up
    //  after copying the context (see comment in sys/ucontext.h):
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -744,20 +749,26 @@</span>
  }
  
  bool handle_assert_poison_fault(const void* ucVoid, const void* faulting_address) {
    if (faulting_address == g_assert_poison) {
      // Disarm poison page.
<span class="udiff-line-modified-removed">-     os::protect_memory((char*)g_assert_poison, os::vm_page_size(), os::MEM_PROT_RWX);</span>
<span class="udiff-line-modified-added">+     if (os::protect_memory((char*)g_assert_poison, os::vm_page_size(), os::MEM_PROT_RWX) == false) {</span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+       fprintf(stderr, &quot;Assertion poison page cannot be unprotected - mprotect failed with %d (%s)&quot;,</span>
<span class="udiff-line-added">+               errno, os::strerror(errno));</span>
<span class="udiff-line-added">+       fflush(stderr);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+       return false; // unprotecting memory may fail in OOM situations, as surprising as this sounds.</span>
<span class="udiff-line-added">+     }</span>
      // Store Context away.
      if (ucVoid) {
        const intx my_tid = os::current_thread_id();
<span class="udiff-line-modified-removed">-       if (Atomic::cmpxchg(my_tid, &amp;g_asserting_thread, (intx)0) == 0) {</span>
<span class="udiff-line-modified-added">+       if (Atomic::cmpxchg(&amp;g_asserting_thread, (intx)0, my_tid) == 0) {</span>
          store_context(ucVoid);
          g_assertion_context = &amp;g_stored_assertion_context;
        }
      }
      return true;
    }
    return false;
  }
  #endif // CAN_SHOW_REGISTERS_ON_ASSERT
<span class="udiff-line-removed">- </span>
</pre>
<center><a href="count_leading_zeros.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debug.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/utilities/events.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.inline.hpp&quot;
 27 #include &quot;oops/instanceKlass.hpp&quot;
 28 #include &quot;runtime/mutexLocker.hpp&quot;
 29 #include &quot;runtime/os.inline.hpp&quot;
 30 #include &quot;runtime/osThread.hpp&quot;
 31 #include &quot;runtime/thread.inline.hpp&quot;
 32 #include &quot;runtime/threadCritical.hpp&quot;
 33 #include &quot;runtime/timer.hpp&quot;
 34 #include &quot;utilities/events.hpp&quot;
 35 
 36 
 37 EventLog* Events::_logs = NULL;
 38 StringEventLog* Events::_messages = NULL;
 39 ExceptionsEventLog* Events::_exceptions = NULL;
 40 StringEventLog* Events::_redefinitions = NULL;
 41 UnloadingEventLog* Events::_class_unloading = NULL;
 42 StringEventLog* Events::_deopt_messages = NULL;
 43 
 44 EventLog::EventLog() {
 45   // This normally done during bootstrap when we&#39;re only single
 46   // threaded but use a ThreadCritical to ensure inclusion in case
 47   // some are created slightly late.
 48   ThreadCritical tc;
 49   _next = Events::_logs;
 50   Events::_logs = this;
 51 }
 52 
 53 // For each registered event logger, print out the current contents of
 54 // the buffer.
 55 void Events::print_all(outputStream* out, int max) {
 56   EventLog* log = _logs;
 57   while (log != NULL) {
 58     log-&gt;print_log_on(out, max);
 59     log = log-&gt;next();
 60   }
 61 }
 62 
 63 // Print a single event log specified by name.
 64 void Events::print_one(outputStream* out, const char* log_name, int max) {
 65   EventLog* log = _logs;
 66   int num_printed = 0;
 67   while (log != NULL) {
 68     if (log-&gt;matches_name_or_handle(log_name)) {
 69       log-&gt;print_log_on(out, max);
 70       num_printed ++;
 71     }
 72     log = log-&gt;next();
 73   }
 74   // Write a short error note if no name matched.
 75   if (num_printed == 0) {
 76     out-&gt;print_cr(&quot;The name \&quot;%s\&quot; did not match any known event log. &quot;
 77                   &quot;Valid event log names are:&quot;, log_name);
 78     EventLog* log = _logs;
 79     while (log != NULL) {
 80       log-&gt;print_names(out);
 81       out-&gt;cr();
 82       log = log-&gt;next();
 83     }
 84   }
 85 }
 86 
 87 
 88 void Events::print() {
 89   print_all(tty);
 90 }
 91 
 92 void Events::init() {
 93   if (LogEvents) {
 94     _messages = new StringEventLog(&quot;Events&quot;, &quot;events&quot;);
 95     _exceptions = new ExceptionsEventLog(&quot;Internal exceptions&quot;, &quot;exc&quot;);
 96     _redefinitions = new StringEventLog(&quot;Classes redefined&quot;, &quot;redef&quot;);
 97     _class_unloading = new UnloadingEventLog(&quot;Classes unloaded&quot;, &quot;unload&quot;);
 98     _deopt_messages = new StringEventLog(&quot;Deoptimization events&quot;, &quot;deopt&quot;);
 99   }
100 }
101 
102 void eventlog_init() {
103   Events::init();
104 }
105 
106 ///////////////////////////////////////////////////////////////////////////
107 // EventMark
108 
109 EventMark::EventMark(const char* format, ...) {
110   if (LogEvents) {
111     va_list ap;
112     va_start(ap, format);
113     // Save a copy of begin message and log it.
114     _buffer.printv(format, ap);
115     Events::log(NULL, &quot;%s&quot;, _buffer.buffer());
116     va_end(ap);
117   }
118 }
119 
120 EventMark::~EventMark() {
121   if (LogEvents) {
122     // Append &quot; done&quot; to the begin message and log it
123     _buffer.append(&quot; done&quot;);
124     Events::log(NULL, &quot;%s&quot;, _buffer.buffer());
125   }
126 }
127 
128 void UnloadingEventLog::log(Thread* thread, InstanceKlass* ik) {
129   if (!should_log()) return;
130 
131   double timestamp = fetch_timestamp();
132   // Unloading events are single threaded.
133   int index = compute_log_index();
134   _records[index].thread = thread;
135   _records[index].timestamp = timestamp;
136   stringStream st(_records[index].data.buffer(),
137                   _records[index].data.size());
138   st.print(&quot;Unloading class &quot; INTPTR_FORMAT &quot; &quot;, p2i(ik));
139   ik-&gt;name()-&gt;print_value_on(&amp;st);
140 }
141 
142 void ExceptionsEventLog::log(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {
143   if (!should_log()) return;
144 
145   double timestamp = fetch_timestamp();
146   MutexLocker ml(&amp;_mutex, Mutex::_no_safepoint_check_flag);
147   int index = compute_log_index();
148   _records[index].thread = thread;
149   _records[index].timestamp = timestamp;
150   stringStream st(_records[index].data.buffer(),
151                   _records[index].data.size());
152   st.print(&quot;Exception &lt;&quot;);
153   h_exception-&gt;print_value_on(&amp;st);
154   st.print(&quot;%s%s&gt; (&quot; INTPTR_FORMAT &quot;) \n&quot;
155            &quot;thrown [%s, line %d]&quot;,
156            message ? &quot;: &quot; : &quot;&quot;, message ? message : &quot;&quot;,
157            p2i(h_exception()), file, line);
158 }
    </pre>
  </body>
</html>
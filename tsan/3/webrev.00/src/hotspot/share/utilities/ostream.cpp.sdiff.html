<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/ostream.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macros.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ostream.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/ostream.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  82 // Return a pointer to the formatted string.
  83 const char* outputStream::do_vsnprintf(char* buffer, size_t buflen,
  84                                        const char* format, va_list ap,
  85                                        bool add_cr,
  86                                        size_t&amp; result_len) {
  87   assert(buflen &gt;= 2, &quot;buffer too small&quot;);
  88 
  89   const char* result;
  90   if (add_cr)  buflen--;
  91   if (!strchr(format, &#39;%&#39;)) {
  92     // constant format string
  93     result = format;
  94     result_len = strlen(result);
  95     if (add_cr &amp;&amp; result_len &gt;= buflen)  result_len = buflen-1;  // truncate
  96   } else if (format[0] == &#39;%&#39; &amp;&amp; format[1] == &#39;s&#39; &amp;&amp; format[2] == &#39;\0&#39;) {
  97     // trivial copy-through format string
  98     result = va_arg(ap, const char*);
  99     result_len = strlen(result);
 100     if (add_cr &amp;&amp; result_len &gt;= buflen)  result_len = buflen-1;  // truncate
 101   } else {
<span class="line-modified"> 102     int written = os::vsnprintf(buffer, buflen, format, ap);</span>
<span class="line-modified"> 103     assert(written &gt;= 0, &quot;vsnprintf encoding error&quot;);</span>
 104     result = buffer;
<span class="line-modified"> 105     if ((size_t)written &lt; buflen) {</span>
<span class="line-modified"> 106       result_len = written;</span>
 107     } else {
<span class="line-modified"> 108       DEBUG_ONLY(warning(&quot;increase O_BUFLEN in ostream.hpp -- output truncated&quot;);)</span>

 109       result_len = buflen - 1;
 110     }
 111   }
 112   if (add_cr) {
 113     if (result != buffer) {
 114       memcpy(buffer, result, result_len);
 115       result = buffer;
 116     }
 117     buffer[result_len++] = &#39;\n&#39;;
 118     buffer[result_len] = 0;
 119   }
 120   return result;
 121 }
 122 
 123 void outputStream::do_vsnprintf_and_write_with_automatic_buffer(const char* format, va_list ap, bool add_cr) {
 124   char buffer[O_BUFLEN];
 125   size_t len;
 126   const char* str = do_vsnprintf(buffer, sizeof(buffer), format, ap, add_cr, len);
 127   write(str, len);
 128 }
</pre>
<hr />
<pre>
 292       print(&quot;  &quot;);
 293     }
 294     if ((i + 1) % 16 == 0) {
 295       if (with_ascii) {
 296         print(&quot;  &quot;);
 297         for (size_t j = 0; j &lt; 16; ++j) {
 298           size_t idx = i + j - 15;
 299           if (idx &lt; len) {
 300             char c = ((char*)data)[idx];
 301             print(&quot;%c&quot;, c &gt;= 32 &amp;&amp; c &lt;= 126 ? c : &#39;.&#39;);
 302           }
 303         }
 304       }
 305       cr();
 306     }
 307   }
 308 }
 309 
 310 stringStream::stringStream(size_t initial_size) : outputStream() {
 311   buffer_length = initial_size;
<span class="line-modified"> 312   buffer        = NEW_RESOURCE_ARRAY(char, buffer_length);</span>
 313   buffer_pos    = 0;
 314   buffer_fixed  = false;
<span class="line-modified"> 315   DEBUG_ONLY(rm = Thread::current()-&gt;current_resource_mark();)</span>
 316 }
 317 
 318 // useful for output to fixed chunks of memory, such as performance counters
 319 stringStream::stringStream(char* fixed_buffer, size_t fixed_buffer_size) : outputStream() {
 320   buffer_length = fixed_buffer_size;
 321   buffer        = fixed_buffer;
 322   buffer_pos    = 0;
 323   buffer_fixed  = true;

 324 }
 325 
 326 void stringStream::write(const char* s, size_t len) {
 327   size_t write_len = len;               // number of non-null bytes to write
 328   size_t end = buffer_pos + len + 1;    // position after write and final &#39;\0&#39;
 329   if (end &gt; buffer_length) {
 330     if (buffer_fixed) {
 331       // if buffer cannot resize, silently truncate
 332       end = buffer_length;
 333       write_len = end - buffer_pos - 1; // leave room for the final &#39;\0&#39;
 334     } else {
 335       // For small overruns, double the buffer.  For larger ones,
 336       // increase to the requested size.
 337       if (end &lt; buffer_length * 2) {
 338         end = buffer_length * 2;
 339       }
<span class="line-modified"> 340       char* oldbuf = buffer;</span>
<span class="line-removed"> 341       assert(rm == NULL || Thread::current()-&gt;current_resource_mark() == rm,</span>
<span class="line-removed"> 342              &quot;StringStream is re-allocated with a different ResourceMark. Current: &quot;</span>
<span class="line-removed"> 343              PTR_FORMAT &quot; original: &quot; PTR_FORMAT,</span>
<span class="line-removed"> 344              p2i(Thread::current()-&gt;current_resource_mark()), p2i(rm));</span>
<span class="line-removed"> 345       buffer = NEW_RESOURCE_ARRAY(char, end);</span>
<span class="line-removed"> 346       if (buffer_pos &gt; 0) {</span>
<span class="line-removed"> 347         memcpy(buffer, oldbuf, buffer_pos);</span>
<span class="line-removed"> 348       }</span>
 349       buffer_length = end;
 350     }
 351   }
 352   // invariant: buffer is always null-terminated
 353   guarantee(buffer_pos + write_len + 1 &lt;= buffer_length, &quot;stringStream oob&quot;);
 354   if (write_len &gt; 0) {
<span class="line-removed"> 355     buffer[buffer_pos + write_len] = 0;</span>
 356     memcpy(buffer + buffer_pos, s, write_len);
 357     buffer_pos += write_len;

 358   }
 359 
 360   // Note that the following does not depend on write_len.
 361   // This means that position and count get updated
 362   // even when overflow occurs.
 363   update_position(s, len);
 364 }
 365 
<span class="line-modified"> 366 char* stringStream::as_string() {</span>











 367   char* copy = NEW_RESOURCE_ARRAY(char, buffer_pos + 1);
 368   strncpy(copy, buffer, buffer_pos);
 369   copy[buffer_pos] = 0;  // terminating null
 370   return copy;
 371 }
 372 
<span class="line-modified"> 373 stringStream::~stringStream() {}</span>




 374 
 375 xmlStream*   xtty;
 376 outputStream* tty;
 377 CDS_ONLY(fileStream* classlist_file;) // Only dump the classes that can be stored into the CDS archive
 378 extern Mutex* tty_lock;
 379 
 380 #define EXTRACHARLEN   32
 381 #define CURRENTAPPX    &quot;.current&quot;
 382 // convert YYYY-MM-DD HH:MM:SS to YYYY-MM-DD_HH-MM-SS
 383 char* get_datetime_string(char *buf, size_t len) {
 384   os::local_time_string(buf, len);
 385   int i = (int)strlen(buf);
 386   while (--i &gt;= 0) {
 387     if (buf[i] == &#39; &#39;) buf[i] = &#39;_&#39;;
 388     else if (buf[i] == &#39;:&#39;) buf[i] = &#39;-&#39;;
 389   }
 390   return buf;
 391 }
 392 
 393 static const char* make_log_name_internal(const char* log_name, const char* force_directory,
</pre>
<hr />
<pre>
 505   if (_file != NULL) {
 506     _need_close = true;
 507   } else {
 508     warning(&quot;Cannot open file %s due to %s\n&quot;, file_name, os::strerror(errno));
 509     _need_close = false;
 510   }
 511 }
 512 
 513 fileStream::fileStream(const char* file_name, const char* opentype) {
 514   _file = fopen(file_name, opentype);
 515   if (_file != NULL) {
 516     _need_close = true;
 517   } else {
 518     warning(&quot;Cannot open file %s due to %s\n&quot;, file_name, os::strerror(errno));
 519     _need_close = false;
 520   }
 521 }
 522 
 523 void fileStream::write(const char* s, size_t len) {
 524   if (_file != NULL)  {
<span class="line-modified"> 525     // Make an unused local variable to avoid warning from gcc 4.x compiler.</span>
 526     size_t count = fwrite(s, 1, len, _file);
 527   }
 528   update_position(s, len);
 529 }
 530 
 531 long fileStream::fileSize() {
 532   long size = -1;
 533   if (_file != NULL) {
 534     long pos = ::ftell(_file);
 535     if (pos &lt; 0) return pos;
 536     if (::fseek(_file, 0, SEEK_END) == 0) {
 537       size = ::ftell(_file);
 538     }
 539     ::fseek(_file, pos, SEEK_SET);
 540   }
 541   return size;
 542 }
 543 
 544 char* fileStream::readln(char *data, int count ) {
 545   char * ret = ::fgets(data, count, _file);
 546   //Get rid of annoying \n char
 547   data[::strlen(data)-1] = &#39;\0&#39;;
 548   return ret;
 549 }
 550 
 551 fileStream::~fileStream() {
 552   if (_file != NULL) {
 553     if (_need_close) fclose(_file);
 554     _file      = NULL;
 555   }
 556 }
 557 
 558 void fileStream::flush() {
 559   fflush(_file);
 560 }
 561 
 562 void fdStream::write(const char* s, size_t len) {
 563   if (_fd != -1) {
<span class="line-modified"> 564     // Make an unused local variable to avoid warning from gcc 4.x compiler.</span>
 565     size_t count = ::write(_fd, s, (int)len);
 566   }
 567   update_position(s, len);
 568 }
 569 
 570 defaultStream* defaultStream::instance = NULL;
 571 int defaultStream::_output_fd = 1;
 572 int defaultStream::_error_fd  = 2;
 573 FILE* defaultStream::_output_stream = stdout;
 574 FILE* defaultStream::_error_stream  = stderr;
 575 
 576 #define LOG_MAJOR_VERSION 160
 577 #define LOG_MINOR_VERSION 1
 578 
 579 void defaultStream::init() {
 580   _inited = true;
 581   if (LogVMOutput || LogCompilation) {
 582     init_log();
 583   }
 584 }
</pre>
<hr />
<pre>
 633   fileStream* file = open_file(log_name);
 634 
 635   if (file != NULL) {
 636     _log_file = file;
 637     _outer_xmlStream = new(ResourceObj::C_HEAP, mtInternal) xmlStream(file);
 638     start_log();
 639   } else {
 640     // and leave xtty as NULL
 641     LogVMOutput = false;
 642     DisplayVMOutput = true;
 643     LogCompilation = false;
 644   }
 645 }
 646 
 647 void defaultStream::start_log() {
 648   xmlStream*xs = _outer_xmlStream;
 649     if (this == tty)  xtty = xs;
 650     // Write XML header.
 651     xs-&gt;print_cr(&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;&quot;);
 652     // (For now, don&#39;t bother to issue a DTD for this private format.)



 653     jlong time_ms = os::javaTimeMillis() - tty-&gt;time_stamp().milliseconds();
<span class="line-removed"> 654     // %%% Should be: jlong time_ms = os::start_time_milliseconds(), if</span>
<span class="line-removed"> 655     // we ever get round to introduce that method on the os class</span>
 656     xs-&gt;head(&quot;hotspot_log version=&#39;%d %d&#39;&quot;
 657              &quot; process=&#39;%d&#39; time_ms=&#39;&quot; INT64_FORMAT &quot;&#39;&quot;,
 658              LOG_MAJOR_VERSION, LOG_MINOR_VERSION,
 659              os::current_process_id(), (int64_t)time_ms);
 660     // Write VM version header immediately.
 661     xs-&gt;head(&quot;vm_version&quot;);
 662     xs-&gt;head(&quot;name&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::vm_name()); xs-&gt;cr();
 663     xs-&gt;tail(&quot;name&quot;);
 664     xs-&gt;head(&quot;release&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::vm_release()); xs-&gt;cr();
 665     xs-&gt;tail(&quot;release&quot;);
 666     xs-&gt;head(&quot;info&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::internal_vm_info_string()); xs-&gt;cr();
 667     xs-&gt;tail(&quot;info&quot;);
 668     xs-&gt;tail(&quot;vm_version&quot;);
 669     // Record information about the command-line invocation.
 670     xs-&gt;head(&quot;vm_arguments&quot;);  // Cf. Arguments::print_on()
 671     if (Arguments::num_jvm_flags() &gt; 0) {
 672       xs-&gt;head(&quot;flags&quot;);
 673       Arguments::print_jvm_flags_on(xs-&gt;text());
 674       xs-&gt;tail(&quot;flags&quot;);
 675     }
</pre>
<hr />
<pre>
 927   defaultStream::instance = NULL;
 928 }
 929 
 930 // ostream_abort() is called by os::abort() when VM is about to die.
 931 void ostream_abort() {
 932   // Here we can&#39;t delete tty, just flush its output
 933   if (tty) tty-&gt;flush();
 934 
 935   if (defaultStream::instance != NULL) {
 936     static char buf[4096];
 937     defaultStream::instance-&gt;finish_log_on_error(buf, sizeof(buf));
 938   }
 939 }
 940 
 941 bufferedStream::bufferedStream(size_t initial_size, size_t bufmax) : outputStream() {
 942   buffer_length = initial_size;
 943   buffer        = NEW_C_HEAP_ARRAY(char, buffer_length, mtInternal);
 944   buffer_pos    = 0;
 945   buffer_fixed  = false;
 946   buffer_max    = bufmax;

 947 }
 948 
 949 bufferedStream::bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax) : outputStream() {
 950   buffer_length = fixed_buffer_size;
 951   buffer        = fixed_buffer;
 952   buffer_pos    = 0;
 953   buffer_fixed  = true;
 954   buffer_max    = bufmax;

 955 }
 956 
 957 void bufferedStream::write(const char* s, size_t len) {
 958 




 959   if(buffer_pos + len &gt; buffer_max) {
<span class="line-modified"> 960     flush();</span>
 961   }
 962 
 963   size_t end = buffer_pos + len;
 964   if (end &gt;= buffer_length) {
 965     if (buffer_fixed) {
 966       // if buffer cannot resize, silently truncate
 967       len = buffer_length - buffer_pos - 1;

 968     } else {
 969       // For small overruns, double the buffer.  For larger ones,
 970       // increase to the requested size.
 971       if (end &lt; buffer_length * 2) {
 972         end = buffer_length * 2;
 973       }
<span class="line-modified"> 974       buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);</span>
<span class="line-modified"> 975       buffer_length = end;</span>




















 976     }
 977   }
<span class="line-modified"> 978   memcpy(buffer + buffer_pos, s, len);</span>
<span class="line-modified"> 979   buffer_pos += len;</span>
<span class="line-modified"> 980   update_position(s, len);</span>


 981 }
 982 
 983 char* bufferedStream::as_string() {
 984   char* copy = NEW_RESOURCE_ARRAY(char, buffer_pos+1);
 985   strncpy(copy, buffer, buffer_pos);
 986   copy[buffer_pos] = 0;  // terminating null
 987   return copy;
 988 }
 989 
 990 bufferedStream::~bufferedStream() {
 991   if (!buffer_fixed) {
 992     FREE_C_HEAP_ARRAY(char, buffer);
 993   }
 994 }
 995 
 996 #ifndef PRODUCT
 997 
 998 #if defined(SOLARIS) || defined(LINUX) || defined(AIX) || defined(_ALLBSD_SOURCE)
 999 #include &lt;sys/types.h&gt;
1000 #include &lt;sys/socket.h&gt;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  82 // Return a pointer to the formatted string.
  83 const char* outputStream::do_vsnprintf(char* buffer, size_t buflen,
  84                                        const char* format, va_list ap,
  85                                        bool add_cr,
  86                                        size_t&amp; result_len) {
  87   assert(buflen &gt;= 2, &quot;buffer too small&quot;);
  88 
  89   const char* result;
  90   if (add_cr)  buflen--;
  91   if (!strchr(format, &#39;%&#39;)) {
  92     // constant format string
  93     result = format;
  94     result_len = strlen(result);
  95     if (add_cr &amp;&amp; result_len &gt;= buflen)  result_len = buflen-1;  // truncate
  96   } else if (format[0] == &#39;%&#39; &amp;&amp; format[1] == &#39;s&#39; &amp;&amp; format[2] == &#39;\0&#39;) {
  97     // trivial copy-through format string
  98     result = va_arg(ap, const char*);
  99     result_len = strlen(result);
 100     if (add_cr &amp;&amp; result_len &gt;= buflen)  result_len = buflen-1;  // truncate
 101   } else {
<span class="line-modified"> 102     int required_len = os::vsnprintf(buffer, buflen, format, ap);</span>
<span class="line-modified"> 103     assert(required_len &gt;= 0, &quot;vsnprintf encoding error&quot;);</span>
 104     result = buffer;
<span class="line-modified"> 105     if ((size_t)required_len &lt; buflen) {</span>
<span class="line-modified"> 106       result_len = required_len;</span>
 107     } else {
<span class="line-modified"> 108       DEBUG_ONLY(warning(&quot;outputStream::do_vsnprintf output truncated -- buffer length is %d bytes but %d bytes are needed.&quot;,</span>
<span class="line-added"> 109                          add_cr ? (int)buflen + 1 : (int)buflen, add_cr ? required_len + 2 : required_len + 1);)</span>
 110       result_len = buflen - 1;
 111     }
 112   }
 113   if (add_cr) {
 114     if (result != buffer) {
 115       memcpy(buffer, result, result_len);
 116       result = buffer;
 117     }
 118     buffer[result_len++] = &#39;\n&#39;;
 119     buffer[result_len] = 0;
 120   }
 121   return result;
 122 }
 123 
 124 void outputStream::do_vsnprintf_and_write_with_automatic_buffer(const char* format, va_list ap, bool add_cr) {
 125   char buffer[O_BUFLEN];
 126   size_t len;
 127   const char* str = do_vsnprintf(buffer, sizeof(buffer), format, ap, add_cr, len);
 128   write(str, len);
 129 }
</pre>
<hr />
<pre>
 293       print(&quot;  &quot;);
 294     }
 295     if ((i + 1) % 16 == 0) {
 296       if (with_ascii) {
 297         print(&quot;  &quot;);
 298         for (size_t j = 0; j &lt; 16; ++j) {
 299           size_t idx = i + j - 15;
 300           if (idx &lt; len) {
 301             char c = ((char*)data)[idx];
 302             print(&quot;%c&quot;, c &gt;= 32 &amp;&amp; c &lt;= 126 ? c : &#39;.&#39;);
 303           }
 304         }
 305       }
 306       cr();
 307     }
 308   }
 309 }
 310 
 311 stringStream::stringStream(size_t initial_size) : outputStream() {
 312   buffer_length = initial_size;
<span class="line-modified"> 313   buffer        = NEW_C_HEAP_ARRAY(char, buffer_length, mtInternal);</span>
 314   buffer_pos    = 0;
 315   buffer_fixed  = false;
<span class="line-modified"> 316   zero_terminate();</span>
 317 }
 318 
 319 // useful for output to fixed chunks of memory, such as performance counters
 320 stringStream::stringStream(char* fixed_buffer, size_t fixed_buffer_size) : outputStream() {
 321   buffer_length = fixed_buffer_size;
 322   buffer        = fixed_buffer;
 323   buffer_pos    = 0;
 324   buffer_fixed  = true;
<span class="line-added"> 325   zero_terminate();</span>
 326 }
 327 
 328 void stringStream::write(const char* s, size_t len) {
 329   size_t write_len = len;               // number of non-null bytes to write
 330   size_t end = buffer_pos + len + 1;    // position after write and final &#39;\0&#39;
 331   if (end &gt; buffer_length) {
 332     if (buffer_fixed) {
 333       // if buffer cannot resize, silently truncate
 334       end = buffer_length;
 335       write_len = end - buffer_pos - 1; // leave room for the final &#39;\0&#39;
 336     } else {
 337       // For small overruns, double the buffer.  For larger ones,
 338       // increase to the requested size.
 339       if (end &lt; buffer_length * 2) {
 340         end = buffer_length * 2;
 341       }
<span class="line-modified"> 342       buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);</span>








 343       buffer_length = end;
 344     }
 345   }
 346   // invariant: buffer is always null-terminated
 347   guarantee(buffer_pos + write_len + 1 &lt;= buffer_length, &quot;stringStream oob&quot;);
 348   if (write_len &gt; 0) {

 349     memcpy(buffer + buffer_pos, s, write_len);
 350     buffer_pos += write_len;
<span class="line-added"> 351     zero_terminate();</span>
 352   }
 353 
 354   // Note that the following does not depend on write_len.
 355   // This means that position and count get updated
 356   // even when overflow occurs.
 357   update_position(s, len);
 358 }
 359 
<span class="line-modified"> 360 void stringStream::zero_terminate() {</span>
<span class="line-added"> 361   assert(buffer != NULL &amp;&amp;</span>
<span class="line-added"> 362          buffer_pos &lt; buffer_length, &quot;sanity&quot;);</span>
<span class="line-added"> 363   buffer[buffer_pos] = &#39;\0&#39;;</span>
<span class="line-added"> 364 }</span>
<span class="line-added"> 365 </span>
<span class="line-added"> 366 void stringStream::reset() {</span>
<span class="line-added"> 367   buffer_pos = 0; _precount = 0; _position = 0;</span>
<span class="line-added"> 368   zero_terminate();</span>
<span class="line-added"> 369 }</span>
<span class="line-added"> 370 </span>
<span class="line-added"> 371 char* stringStream::as_string() const {</span>
 372   char* copy = NEW_RESOURCE_ARRAY(char, buffer_pos + 1);
 373   strncpy(copy, buffer, buffer_pos);
 374   copy[buffer_pos] = 0;  // terminating null
 375   return copy;
 376 }
 377 
<span class="line-modified"> 378 stringStream::~stringStream() {</span>
<span class="line-added"> 379   if (buffer_fixed == false &amp;&amp; buffer != NULL) {</span>
<span class="line-added"> 380     FREE_C_HEAP_ARRAY(char, buffer);</span>
<span class="line-added"> 381   }</span>
<span class="line-added"> 382 }</span>
 383 
 384 xmlStream*   xtty;
 385 outputStream* tty;
 386 CDS_ONLY(fileStream* classlist_file;) // Only dump the classes that can be stored into the CDS archive
 387 extern Mutex* tty_lock;
 388 
 389 #define EXTRACHARLEN   32
 390 #define CURRENTAPPX    &quot;.current&quot;
 391 // convert YYYY-MM-DD HH:MM:SS to YYYY-MM-DD_HH-MM-SS
 392 char* get_datetime_string(char *buf, size_t len) {
 393   os::local_time_string(buf, len);
 394   int i = (int)strlen(buf);
 395   while (--i &gt;= 0) {
 396     if (buf[i] == &#39; &#39;) buf[i] = &#39;_&#39;;
 397     else if (buf[i] == &#39;:&#39;) buf[i] = &#39;-&#39;;
 398   }
 399   return buf;
 400 }
 401 
 402 static const char* make_log_name_internal(const char* log_name, const char* force_directory,
</pre>
<hr />
<pre>
 514   if (_file != NULL) {
 515     _need_close = true;
 516   } else {
 517     warning(&quot;Cannot open file %s due to %s\n&quot;, file_name, os::strerror(errno));
 518     _need_close = false;
 519   }
 520 }
 521 
 522 fileStream::fileStream(const char* file_name, const char* opentype) {
 523   _file = fopen(file_name, opentype);
 524   if (_file != NULL) {
 525     _need_close = true;
 526   } else {
 527     warning(&quot;Cannot open file %s due to %s\n&quot;, file_name, os::strerror(errno));
 528     _need_close = false;
 529   }
 530 }
 531 
 532 void fileStream::write(const char* s, size_t len) {
 533   if (_file != NULL)  {
<span class="line-modified"> 534     // Make an unused local variable to avoid warning from gcc compiler.</span>
 535     size_t count = fwrite(s, 1, len, _file);
 536   }
 537   update_position(s, len);
 538 }
 539 
 540 long fileStream::fileSize() {
 541   long size = -1;
 542   if (_file != NULL) {
 543     long pos = ::ftell(_file);
 544     if (pos &lt; 0) return pos;
 545     if (::fseek(_file, 0, SEEK_END) == 0) {
 546       size = ::ftell(_file);
 547     }
 548     ::fseek(_file, pos, SEEK_SET);
 549   }
 550   return size;
 551 }
 552 
 553 char* fileStream::readln(char *data, int count ) {
 554   char * ret = ::fgets(data, count, _file);
 555   //Get rid of annoying \n char
 556   data[::strlen(data)-1] = &#39;\0&#39;;
 557   return ret;
 558 }
 559 
 560 fileStream::~fileStream() {
 561   if (_file != NULL) {
 562     if (_need_close) fclose(_file);
 563     _file      = NULL;
 564   }
 565 }
 566 
 567 void fileStream::flush() {
 568   fflush(_file);
 569 }
 570 
 571 void fdStream::write(const char* s, size_t len) {
 572   if (_fd != -1) {
<span class="line-modified"> 573     // Make an unused local variable to avoid warning from gcc compiler.</span>
 574     size_t count = ::write(_fd, s, (int)len);
 575   }
 576   update_position(s, len);
 577 }
 578 
 579 defaultStream* defaultStream::instance = NULL;
 580 int defaultStream::_output_fd = 1;
 581 int defaultStream::_error_fd  = 2;
 582 FILE* defaultStream::_output_stream = stdout;
 583 FILE* defaultStream::_error_stream  = stderr;
 584 
 585 #define LOG_MAJOR_VERSION 160
 586 #define LOG_MINOR_VERSION 1
 587 
 588 void defaultStream::init() {
 589   _inited = true;
 590   if (LogVMOutput || LogCompilation) {
 591     init_log();
 592   }
 593 }
</pre>
<hr />
<pre>
 642   fileStream* file = open_file(log_name);
 643 
 644   if (file != NULL) {
 645     _log_file = file;
 646     _outer_xmlStream = new(ResourceObj::C_HEAP, mtInternal) xmlStream(file);
 647     start_log();
 648   } else {
 649     // and leave xtty as NULL
 650     LogVMOutput = false;
 651     DisplayVMOutput = true;
 652     LogCompilation = false;
 653   }
 654 }
 655 
 656 void defaultStream::start_log() {
 657   xmlStream*xs = _outer_xmlStream;
 658     if (this == tty)  xtty = xs;
 659     // Write XML header.
 660     xs-&gt;print_cr(&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;&quot;);
 661     // (For now, don&#39;t bother to issue a DTD for this private format.)
<span class="line-added"> 662 </span>
<span class="line-added"> 663     // Calculate the start time of the log as ms since the epoch: this is</span>
<span class="line-added"> 664     // the current time in ms minus the uptime in ms.</span>
 665     jlong time_ms = os::javaTimeMillis() - tty-&gt;time_stamp().milliseconds();


 666     xs-&gt;head(&quot;hotspot_log version=&#39;%d %d&#39;&quot;
 667              &quot; process=&#39;%d&#39; time_ms=&#39;&quot; INT64_FORMAT &quot;&#39;&quot;,
 668              LOG_MAJOR_VERSION, LOG_MINOR_VERSION,
 669              os::current_process_id(), (int64_t)time_ms);
 670     // Write VM version header immediately.
 671     xs-&gt;head(&quot;vm_version&quot;);
 672     xs-&gt;head(&quot;name&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::vm_name()); xs-&gt;cr();
 673     xs-&gt;tail(&quot;name&quot;);
 674     xs-&gt;head(&quot;release&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::vm_release()); xs-&gt;cr();
 675     xs-&gt;tail(&quot;release&quot;);
 676     xs-&gt;head(&quot;info&quot;); xs-&gt;text(&quot;%s&quot;, VM_Version::internal_vm_info_string()); xs-&gt;cr();
 677     xs-&gt;tail(&quot;info&quot;);
 678     xs-&gt;tail(&quot;vm_version&quot;);
 679     // Record information about the command-line invocation.
 680     xs-&gt;head(&quot;vm_arguments&quot;);  // Cf. Arguments::print_on()
 681     if (Arguments::num_jvm_flags() &gt; 0) {
 682       xs-&gt;head(&quot;flags&quot;);
 683       Arguments::print_jvm_flags_on(xs-&gt;text());
 684       xs-&gt;tail(&quot;flags&quot;);
 685     }
</pre>
<hr />
<pre>
 937   defaultStream::instance = NULL;
 938 }
 939 
 940 // ostream_abort() is called by os::abort() when VM is about to die.
 941 void ostream_abort() {
 942   // Here we can&#39;t delete tty, just flush its output
 943   if (tty) tty-&gt;flush();
 944 
 945   if (defaultStream::instance != NULL) {
 946     static char buf[4096];
 947     defaultStream::instance-&gt;finish_log_on_error(buf, sizeof(buf));
 948   }
 949 }
 950 
 951 bufferedStream::bufferedStream(size_t initial_size, size_t bufmax) : outputStream() {
 952   buffer_length = initial_size;
 953   buffer        = NEW_C_HEAP_ARRAY(char, buffer_length, mtInternal);
 954   buffer_pos    = 0;
 955   buffer_fixed  = false;
 956   buffer_max    = bufmax;
<span class="line-added"> 957   truncated     = false;</span>
 958 }
 959 
 960 bufferedStream::bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax) : outputStream() {
 961   buffer_length = fixed_buffer_size;
 962   buffer        = fixed_buffer;
 963   buffer_pos    = 0;
 964   buffer_fixed  = true;
 965   buffer_max    = bufmax;
<span class="line-added"> 966   truncated     = false;</span>
 967 }
 968 
 969 void bufferedStream::write(const char* s, size_t len) {
 970 
<span class="line-added"> 971   if (truncated) {</span>
<span class="line-added"> 972     return;</span>
<span class="line-added"> 973   }</span>
<span class="line-added"> 974 </span>
 975   if(buffer_pos + len &gt; buffer_max) {
<span class="line-modified"> 976     flush(); // Note: may be a noop.</span>
 977   }
 978 
 979   size_t end = buffer_pos + len;
 980   if (end &gt;= buffer_length) {
 981     if (buffer_fixed) {
 982       // if buffer cannot resize, silently truncate
 983       len = buffer_length - buffer_pos - 1;
<span class="line-added"> 984       truncated = true;</span>
 985     } else {
 986       // For small overruns, double the buffer.  For larger ones,
 987       // increase to the requested size.
 988       if (end &lt; buffer_length * 2) {
 989         end = buffer_length * 2;
 990       }
<span class="line-modified"> 991       // Impose a cap beyond which the buffer cannot grow - a size which</span>
<span class="line-modified"> 992       // in all probability indicates a real error, e.g. faulty printing</span>
<span class="line-added"> 993       // code looping, while not affecting cases of just-very-large-but-its-normal</span>
<span class="line-added"> 994       // output.</span>
<span class="line-added"> 995       const size_t reasonable_cap = MAX2(100 * M, buffer_max * 2);</span>
<span class="line-added"> 996       if (end &gt; reasonable_cap) {</span>
<span class="line-added"> 997         // In debug VM, assert right away.</span>
<span class="line-added"> 998         assert(false, &quot;Exceeded max buffer size for this string.&quot;);</span>
<span class="line-added"> 999         // Release VM: silently truncate. We do this since these kind of errors</span>
<span class="line-added">1000         // are both difficult to predict with testing (depending on logging content)</span>
<span class="line-added">1001         // and usually not serious enough to kill a production VM for it.</span>
<span class="line-added">1002         end = reasonable_cap;</span>
<span class="line-added">1003         size_t remaining = end - buffer_pos;</span>
<span class="line-added">1004         if (len &gt;= remaining) {</span>
<span class="line-added">1005           len = remaining - 1;</span>
<span class="line-added">1006           truncated = true;</span>
<span class="line-added">1007         }</span>
<span class="line-added">1008       }</span>
<span class="line-added">1009       if (buffer_length &lt; end) {</span>
<span class="line-added">1010         buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);</span>
<span class="line-added">1011         buffer_length = end;</span>
<span class="line-added">1012       }</span>
1013     }
1014   }
<span class="line-modified">1015   if (len &gt; 0) {</span>
<span class="line-modified">1016     memcpy(buffer + buffer_pos, s, len);</span>
<span class="line-modified">1017     buffer_pos += len;</span>
<span class="line-added">1018     update_position(s, len);</span>
<span class="line-added">1019   }</span>
1020 }
1021 
1022 char* bufferedStream::as_string() {
1023   char* copy = NEW_RESOURCE_ARRAY(char, buffer_pos+1);
1024   strncpy(copy, buffer, buffer_pos);
1025   copy[buffer_pos] = 0;  // terminating null
1026   return copy;
1027 }
1028 
1029 bufferedStream::~bufferedStream() {
1030   if (!buffer_fixed) {
1031     FREE_C_HEAP_ARRAY(char, buffer);
1032   }
1033 }
1034 
1035 #ifndef PRODUCT
1036 
1037 #if defined(SOLARIS) || defined(LINUX) || defined(AIX) || defined(_ALLBSD_SOURCE)
1038 #include &lt;sys/types.h&gt;
1039 #include &lt;sys/socket.h&gt;
</pre>
</td>
</tr>
</table>
<center><a href="macros.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ostream.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
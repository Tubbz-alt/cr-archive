<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/lockFreeStack.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="hashtable.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macros.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/lockFreeStack.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,11 ***</span>
  #ifndef SHARE_UTILITIES_LOCKFREESTACK_HPP
  #define SHARE_UTILITIES_LOCKFREESTACK_HPP
  
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
<span class="line-modified">! #include &quot;utilities/macros.hpp&quot;</span>
  
  // The LockFreeStack class template provides a lock-free LIFO. The objects
  // in the sequence are intrusively linked via a member in the objects.  As
  // a result, there is no allocation involved in adding objects to the stack
  // or removing them from the stack.
<span class="line-new-header">--- 25,11 ---</span>
  #ifndef SHARE_UTILITIES_LOCKFREESTACK_HPP
  #define SHARE_UTILITIES_LOCKFREESTACK_HPP
  
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
<span class="line-modified">! #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  
  // The LockFreeStack class template provides a lock-free LIFO. The objects
  // in the sequence are intrusively linked via a member in the objects.  As
  // a result, there is no allocation involved in adding objects to the stack
  // or removing them from the stack.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,17 ***</span>
      T* cur = top();
      T* old;
      do {
        old = cur;
        set_next(*last, cur);
<span class="line-modified">!       cur = Atomic::cmpxchg(first, &amp;_top, cur);</span>
      } while (old != cur);
    }
  
<span class="line-modified">!   // Noncopyable.</span>
<span class="line-removed">-   LockFreeStack(const LockFreeStack&amp;);</span>
<span class="line-removed">-   LockFreeStack&amp; operator=(const LockFreeStack&amp;);</span>
  
  public:
    LockFreeStack() : _top(NULL) {}
    ~LockFreeStack() { assert(empty(), &quot;stack not empty&quot;); }
  
<span class="line-new-header">--- 63,15 ---</span>
      T* cur = top();
      T* old;
      do {
        old = cur;
        set_next(*last, cur);
<span class="line-modified">!       cur = Atomic::cmpxchg(&amp;_top, cur, first);</span>
      } while (old != cur);
    }
  
<span class="line-modified">!   NONCOPYABLE(LockFreeStack);</span>
  
  public:
    LockFreeStack() : _top(NULL) {}
    ~LockFreeStack() { assert(empty(), &quot;stack not empty&quot;); }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,11 ***</span>
        T* new_top = NULL;
        if (result != NULL) {
          new_top = next(*result);
        }
        // CAS even on empty pop, for consistent membar bahavior.
<span class="line-modified">!       result = Atomic::cmpxchg(new_top, &amp;_top, result);</span>
      } while (result != old);
      if (result != NULL) {
        set_next(*result, NULL);
      }
      return result;
<span class="line-new-header">--- 87,11 ---</span>
        T* new_top = NULL;
        if (result != NULL) {
          new_top = next(*result);
        }
        // CAS even on empty pop, for consistent membar bahavior.
<span class="line-modified">!       result = Atomic::cmpxchg(&amp;_top, result, new_top);</span>
      } while (result != old);
      if (result != NULL) {
        set_next(*result, NULL);
      }
      return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,11 ***</span>
  
    // Atomically exchange the list of elements with NULL, returning the old
    // list of elements.  Acts as a full memory barrier.
    // postcondition: empty()
    T* pop_all() {
<span class="line-modified">!     return Atomic::xchg((T*)NULL, &amp;_top);</span>
    }
  
    // Atomically adds value to the top of this stack.  Acts as a full
    // memory barrier.
    void push(T&amp; value) {
<span class="line-new-header">--- 99,11 ---</span>
  
    // Atomically exchange the list of elements with NULL, returning the old
    // list of elements.  Acts as a full memory barrier.
    // postcondition: empty()
    T* pop_all() {
<span class="line-modified">!     return Atomic::xchg(&amp;_top, (T*)NULL);</span>
    }
  
    // Atomically adds value to the top of this stack.  Acts as a full
    // memory barrier.
    void push(T&amp; value) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,10 ***</span>
    // Set the entry following value to new_next in the list used by the
    // specialized LockFreeStack class.  Not thread-safe; in particular,
    // if value is in an instance of this specialization of LockFreeStack,
    // there must be no concurrent push or pop operations on that stack.
    static void set_next(T&amp; value, T* new_next) {
<span class="line-modified">!     Atomic::store(new_next, next_ptr(value));</span>
    }
  };
  
  #endif // SHARE_UTILITIES_LOCKFREESTACK_HPP
<span class="line-new-header">--- 166,10 ---</span>
    // Set the entry following value to new_next in the list used by the
    // specialized LockFreeStack class.  Not thread-safe; in particular,
    // if value is in an instance of this specialization of LockFreeStack,
    // there must be no concurrent push or pop operations on that stack.
    static void set_next(T&amp; value, T* new_next) {
<span class="line-modified">!     Atomic::store(next_ptr(value), new_next);</span>
    }
  };
  
  #endif // SHARE_UTILITIES_LOCKFREESTACK_HPP
</pre>
<center><a href="hashtable.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macros.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
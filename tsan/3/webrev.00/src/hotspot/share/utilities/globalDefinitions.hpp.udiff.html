<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/utilities/globalDefinitions.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globalDefinitions.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globalDefinitions_gcc.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/globalDefinitions.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27,10 +27,13 @@</span>
  
  #include &quot;utilities/compilerWarnings.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
<span class="udiff-line-added">+ // Get constants like JVM_T_CHAR and JVM_SIGNATURE_INT, before pulling in &lt;jvm.h&gt;.</span>
<span class="udiff-line-added">+ #include &quot;classfile_constants.h&quot;</span>
<span class="udiff-line-added">+ </span>
  #include COMPILER_HEADER(utilities/globalDefinitions)
  
  // Defaults for macros that might be defined per compiler.
  #ifndef NOINLINE
  #define NOINLINE
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -41,13 +44,46 @@</span>
  
  #ifndef ATTRIBUTE_ALIGNED
  #define ATTRIBUTE_ALIGNED(x)
  #endif
  
<span class="udiff-line-added">+ // These are #defines to selectively turn on/off the Print(Opto)Assembly</span>
<span class="udiff-line-added">+ // capabilities. Choices should be led by a tradeoff between</span>
<span class="udiff-line-added">+ // code size and improved supportability.</span>
<span class="udiff-line-added">+ // if PRINT_ASSEMBLY then PRINT_ABSTRACT_ASSEMBLY must be true as well</span>
<span class="udiff-line-added">+ // to have a fallback in case hsdis is not available.</span>
<span class="udiff-line-added">+ #if defined(PRODUCT)</span>
<span class="udiff-line-added">+   #define SUPPORT_ABSTRACT_ASSEMBLY</span>
<span class="udiff-line-added">+   #define SUPPORT_ASSEMBLY</span>
<span class="udiff-line-added">+   #undef  SUPPORT_OPTO_ASSEMBLY      // Can&#39;t activate. In PRODUCT, many dump methods are missing.</span>
<span class="udiff-line-added">+   #undef  SUPPORT_DATA_STRUCTS       // Of limited use. In PRODUCT, many print methods are empty.</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   #define SUPPORT_ABSTRACT_ASSEMBLY</span>
<span class="udiff-line-added">+   #define SUPPORT_ASSEMBLY</span>
<span class="udiff-line-added">+   #define SUPPORT_OPTO_ASSEMBLY</span>
<span class="udiff-line-added">+   #define SUPPORT_DATA_STRUCTS</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #if defined(SUPPORT_ASSEMBLY) &amp;&amp; !defined(SUPPORT_ABSTRACT_ASSEMBLY)</span>
<span class="udiff-line-added">+   #define SUPPORT_ABSTRACT_ASSEMBLY</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  // This file holds all globally used constants &amp; types, class (forward)
  // declarations and a few frequently used utility functions.
  
<span class="udiff-line-added">+ // Declare the named class to be noncopyable.  This macro must be used in</span>
<span class="udiff-line-added">+ // a private part of the class&#39;s definition, followed by a semi-colon.</span>
<span class="udiff-line-added">+ // Doing so provides private declarations for the class&#39;s copy constructor</span>
<span class="udiff-line-added">+ // and assignment operator.  Because these operations are private, most</span>
<span class="udiff-line-added">+ // potential callers will fail to compile because they are inaccessible.</span>
<span class="udiff-line-added">+ // The operations intentionally lack a definition, to provoke link-time</span>
<span class="udiff-line-added">+ // failures for calls from contexts where they are accessible, e.g. from</span>
<span class="udiff-line-added">+ // within the class or from a friend of the class.</span>
<span class="udiff-line-added">+ // Note: The lack of definitions is still not completely bullet-proof, as</span>
<span class="udiff-line-added">+ // an apparent call might be optimized away by copy elision.</span>
<span class="udiff-line-added">+ // For C++11 the declarations should be changed to deleted definitions.</span>
<span class="udiff-line-added">+ #define NONCOPYABLE(C) C(C const&amp;); C&amp; operator=(C const&amp;) /* next token must be ; */</span>
<span class="udiff-line-added">+ </span>
  //----------------------------------------------------------------------------------------------------
  // Printf-style formatters for fixed- and variable-width types as pointers and
  // integers.  These are derived from the definitions in inttypes.h.  If the platform
  // doesn&#39;t provide appropriate definitions, they should be provided in
  // the compiler-specific definitions file (e.g., globalDefinitions_gcc.hpp)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -75,10 +111,13 @@</span>
  
  // Format jlong, if necessary
  #ifndef JLONG_FORMAT
  #define JLONG_FORMAT           INT64_FORMAT
  #endif
<span class="udiff-line-added">+ #ifndef JLONG_FORMAT_W</span>
<span class="udiff-line-added">+ #define JLONG_FORMAT_W(width)  INT64_FORMAT_W(width)</span>
<span class="udiff-line-added">+ #endif</span>
  #ifndef JULONG_FORMAT
  #define JULONG_FORMAT          UINT64_FORMAT
  #endif
  #ifndef JULONG_FORMAT_X
  #define JULONG_FORMAT_X        UINT64_FORMAT_X
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -213,14 +252,26 @@</span>
  // example from seconds to milliseconds and microseconds
  
  const int MILLIUNITS    = 1000;         // milli units per base unit
  const int MICROUNITS    = 1000000;      // micro units per base unit
  const int NANOUNITS     = 1000000000;   // nano units per base unit
<span class="udiff-line-added">+ const int NANOUNITS_PER_MILLIUNIT = NANOUNITS / MILLIUNITS;</span>
  
  const jlong NANOSECS_PER_SEC      = CONST64(1000000000);
  const jint  NANOSECS_PER_MILLISEC = 1000000;
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Unit conversion functions</span>
<span class="udiff-line-added">+ // The caller is responsible for considering overlow.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline int64_t nanos_to_millis(int64_t nanos) {</span>
<span class="udiff-line-added">+   return nanos / NANOUNITS_PER_MILLIUNIT;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ inline int64_t millis_to_nanos(int64_t millis) {</span>
<span class="udiff-line-added">+   return millis * NANOUNITS_PER_MILLIUNIT;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Proper units routines try to maintain at least three significant digits.
  // In worst case, it would print five significant digits with lower prefix.
  // G is close to MAX_SIZE on 32-bit platforms, so its product can easily overflow,
  // and therefore we need to be careful.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -283,10 +334,17 @@</span>
      return s / K;
    }
    return s;
  }
  
<span class="udiff-line-added">+ // Memory size transition formatting.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define HEAP_CHANGE_FORMAT &quot;%s: &quot; SIZE_FORMAT &quot;K(&quot; SIZE_FORMAT &quot;K)-&gt;&quot; SIZE_FORMAT &quot;K(&quot; SIZE_FORMAT &quot;K)&quot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define HEAP_CHANGE_FORMAT_ARGS(_name_, _prev_used_, _prev_capacity_, _used_, _capacity_) \</span>
<span class="udiff-line-added">+   (_name_), (_prev_used_) / K, (_prev_capacity_) / K, (_used_) / K, (_capacity_) / K</span>
<span class="udiff-line-added">+ </span>
  //----------------------------------------------------------------------------------------------------
  // VM type definitions
  
  // intx and uintx are the &#39;extended&#39; int and &#39;extended&#39; unsigned int types;
  // they are 32bit wide on a 32-bit platform, and 64bit wide on a 64bit platform.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -449,14 +507,17 @@</span>
  // To assure the IRIW property on processors that are not multiple copy
  // atomic, sync instructions must be issued between volatile reads to
  // assure their ordering, instead of after volatile stores.
  // (See &quot;A Tutorial Introduction to the ARM and POWER Relaxed Memory Models&quot;
  // by Luc Maranget, Susmit Sarkar and Peter Sewell, INRIA/Cambridge)
<span class="udiff-line-modified-removed">- #ifdef CPU_NOT_MULTIPLE_COPY_ATOMIC</span>
<span class="udiff-line-modified-removed">- const bool support_IRIW_for_not_multiple_copy_atomic_cpu = true;</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-modified-added">+ #ifdef CPU_MULTI_COPY_ATOMIC</span>
<span class="udiff-line-modified-added">+ // Not needed.</span>
  const bool support_IRIW_for_not_multiple_copy_atomic_cpu = false;
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ // From all non-multi-copy-atomic architectures, only PPC64 supports IRIW at the moment.</span>
<span class="udiff-line-added">+ // Final decision is subject to JEP 188: Java Memory Model Update.</span>
<span class="udiff-line-added">+ const bool support_IRIW_for_not_multiple_copy_atomic_cpu = PPC64_ONLY(true) NOT_PPC64(false);</span>
  #endif
  
  // The expected size in bytes of a cache line, used to pad data structures.
  #ifndef DEFAULT_CACHE_LINE_SIZE
    #define DEFAULT_CACHE_LINE_SIZE 64
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -535,18 +596,26 @@</span>
  void basic_types_init(); // cannot define here; uses assert
  
  
  // NOTE: replicated in SA in vm/agent/sun/jvm/hotspot/runtime/BasicType.java
  enum BasicType {
<span class="udiff-line-modified-removed">-   T_BOOLEAN     =  4,</span>
<span class="udiff-line-modified-removed">-   T_CHAR        =  5,</span>
<span class="udiff-line-modified-removed">-   T_FLOAT       =  6,</span>
<span class="udiff-line-modified-removed">-   T_DOUBLE      =  7,</span>
<span class="udiff-line-modified-removed">-   T_BYTE        =  8,</span>
<span class="udiff-line-modified-removed">-   T_SHORT       =  9,</span>
<span class="udiff-line-modified-removed">-   T_INT         = 10,</span>
<span class="udiff-line-modified-removed">-   T_LONG        = 11,</span>
<span class="udiff-line-modified-added">+ // The values T_BOOLEAN..T_LONG (4..11) are derived from the JVMS.</span>
<span class="udiff-line-modified-added">+   T_BOOLEAN     = JVM_T_BOOLEAN,</span>
<span class="udiff-line-modified-added">+   T_CHAR        = JVM_T_CHAR,</span>
<span class="udiff-line-modified-added">+   T_FLOAT       = JVM_T_FLOAT,</span>
<span class="udiff-line-modified-added">+   T_DOUBLE      = JVM_T_DOUBLE,</span>
<span class="udiff-line-modified-added">+   T_BYTE        = JVM_T_BYTE,</span>
<span class="udiff-line-modified-added">+   T_SHORT       = JVM_T_SHORT,</span>
<span class="udiff-line-modified-added">+   T_INT         = JVM_T_INT,</span>
<span class="udiff-line-added">+   T_LONG        = JVM_T_LONG,</span>
<span class="udiff-line-added">+   // The remaining values are not part of any standard.</span>
<span class="udiff-line-added">+   // T_OBJECT and T_VOID denote two more semantic choices</span>
<span class="udiff-line-added">+   // for method return values.</span>
<span class="udiff-line-added">+   // T_OBJECT and T_ARRAY describe signature syntax.</span>
<span class="udiff-line-added">+   // T_ADDRESS, T_METADATA, T_NARROWOOP, T_NARROWKLASS describe</span>
<span class="udiff-line-added">+   // internal references within the JVM as if they were Java</span>
<span class="udiff-line-added">+   // types in their own right.</span>
    T_OBJECT      = 12,
    T_ARRAY       = 13,
    T_VOID        = 14,
    T_ADDRESS     = 15,
    T_NARROWOOP   = 16,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -554,10 +623,28 @@</span>
    T_NARROWKLASS = 18,
    T_CONFLICT    = 19, // for stack value type with conflicting contents
    T_ILLEGAL     = 99
  };
  
<span class="udiff-line-added">+ #define SIGNATURE_TYPES_DO(F, N)                \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_BOOLEAN, T_BOOLEAN, N)      \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_CHAR,    T_CHAR,    N)      \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_FLOAT,   T_FLOAT,   N)      \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_DOUBLE,  T_DOUBLE,  N)      \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_BYTE,    T_BYTE,    N)      \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_SHORT,   T_SHORT,   N)      \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_INT,     T_INT,     N)      \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_LONG,    T_LONG,    N)      \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_CLASS,   T_OBJECT,  N)      \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_ARRAY,   T_ARRAY,   N)      \</span>
<span class="udiff-line-added">+     F(JVM_SIGNATURE_VOID,    T_VOID,    N)      \</span>
<span class="udiff-line-added">+     /*end*/</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline bool is_java_type(BasicType t) {</span>
<span class="udiff-line-added">+   return T_BOOLEAN &lt;= t &amp;&amp; t &lt;= T_VOID;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  inline bool is_java_primitive(BasicType t) {
    return T_BOOLEAN &lt;= t &amp;&amp; t &lt;= T_LONG;
  }
  
  inline bool is_subword_type(BasicType t) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -567,30 +654,16 @@</span>
  
  inline bool is_signed_subword_type(BasicType t) {
    return (t == T_BYTE || t == T_SHORT);
  }
  
<span class="udiff-line-modified-removed">- inline bool is_reference_type(BasicType t) {</span>
<span class="udiff-line-modified-removed">-   return (t == T_OBJECT || t == T_ARRAY);</span>
<span class="udiff-line-modified-added">+ inline bool is_double_word_type(BasicType t) {</span>
<span class="udiff-line-modified-added">+   return (t == T_DOUBLE || t == T_LONG);</span>
  }
  
<span class="udiff-line-modified-removed">- // Convert a char from a classfile signature to a BasicType</span>
<span class="udiff-line-modified-removed">- inline BasicType char2type(char c) {</span>
<span class="udiff-line-removed">-   switch( c ) {</span>
<span class="udiff-line-removed">-   case &#39;B&#39;: return T_BYTE;</span>
<span class="udiff-line-removed">-   case &#39;C&#39;: return T_CHAR;</span>
<span class="udiff-line-removed">-   case &#39;D&#39;: return T_DOUBLE;</span>
<span class="udiff-line-removed">-   case &#39;F&#39;: return T_FLOAT;</span>
<span class="udiff-line-removed">-   case &#39;I&#39;: return T_INT;</span>
<span class="udiff-line-removed">-   case &#39;J&#39;: return T_LONG;</span>
<span class="udiff-line-removed">-   case &#39;S&#39;: return T_SHORT;</span>
<span class="udiff-line-removed">-   case &#39;Z&#39;: return T_BOOLEAN;</span>
<span class="udiff-line-removed">-   case &#39;V&#39;: return T_VOID;</span>
<span class="udiff-line-removed">-   case &#39;L&#39;: return T_OBJECT;</span>
<span class="udiff-line-removed">-   case &#39;[&#39;: return T_ARRAY;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return T_ILLEGAL;</span>
<span class="udiff-line-modified-added">+ inline bool is_reference_type(BasicType t) {</span>
<span class="udiff-line-modified-added">+   return (t == T_OBJECT || t == T_ARRAY);</span>
  }
  
  extern char type2char_tab[T_CONFLICT+1];     // Map a BasicType to a jchar
  inline char type2char(BasicType t) { return (uint)t &lt; T_CONFLICT+1 ? type2char_tab[t] : 0; }
  extern int type2size[T_CONFLICT+1];         // Map BasicType to result stack elements
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -618,10 +691,17 @@</span>
    T_NARROWOOP_size   = 1,
    T_NARROWKLASS_size = 1,
    T_VOID_size        = 0
  };
  
<span class="udiff-line-added">+ // this works on valid parameter types but not T_VOID, T_CONFLICT, etc.</span>
<span class="udiff-line-added">+ inline int parameter_type_word_count(BasicType t) {</span>
<span class="udiff-line-added">+   if (is_double_word_type(t))  return 2;</span>
<span class="udiff-line-added">+   assert(is_java_primitive(t) || is_reference_type(t), &quot;no goofy types here please&quot;);</span>
<span class="udiff-line-added">+   assert(type2size[t] == 1, &quot;must be&quot;);</span>
<span class="udiff-line-added">+   return 1;</span>
<span class="udiff-line-added">+ }</span>
  
  // maps a BasicType to its instance field storage type:
  // all sub-word integral types are widened to T_INT
  extern BasicType type2field[T_CONFLICT+1];
  extern BasicType type2wfield[T_CONFLICT+1];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -899,18 +979,15 @@</span>
  template&lt;class T&gt; inline T MAX4(T a, T b, T c, T d) { return MAX2(MAX3(a, b, c), d); }
  template&lt;class T&gt; inline T MIN4(T a, T b, T c, T d) { return MIN2(MIN3(a, b, c), d); }
  
  template&lt;class T&gt; inline T ABS(T x)                 { return (x &gt; 0) ? x : -x; }
  
<span class="udiff-line-modified-removed">- // true if x is a power of 2, false otherwise</span>
<span class="udiff-line-modified-removed">- inline bool is_power_of_2(intptr_t x) {</span>
<span class="udiff-line-modified-removed">-   return ((x != NoBits) &amp;&amp; (mask_bits(x, x - 1) == NoBits));</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- // long version of is_power_of_2</span>
<span class="udiff-line-removed">- inline bool is_power_of_2_long(jlong x) {</span>
<span class="udiff-line-removed">-   return ((x != NoLongBits) &amp;&amp; (mask_long_bits(x, x - 1) == NoLongBits));</span>
<span class="udiff-line-modified-added">+ // Return the given value clamped to the range [min ... max]</span>
<span class="udiff-line-modified-added">+ template&lt;typename T&gt;</span>
<span class="udiff-line-modified-added">+ inline T clamp(T value, T min, T max) {</span>
<span class="udiff-line-modified-added">+   assert(min &lt;= max, &quot;must be&quot;);</span>
<span class="udiff-line-modified-added">+   return MIN2(MAX2(value, min), max);</span>
  }
  
  // Returns largest i such that 2^i &lt;= x.
  // If x == 0, the function returns -1.
  inline int log2_intptr(uintptr_t x) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -962,22 +1039,10 @@</span>
  inline int log2_jlong(jlong x) {
    STATIC_ASSERT(sizeof(jlong) &lt;= sizeof(julong));
    return log2_long((julong)x);
  }
  
<span class="udiff-line-removed">- //* the argument must be exactly a power of 2</span>
<span class="udiff-line-removed">- inline int exact_log2(intptr_t x) {</span>
<span class="udiff-line-removed">-   assert(is_power_of_2(x), &quot;x must be a power of 2: &quot; INTPTR_FORMAT, x);</span>
<span class="udiff-line-removed">-   return log2_intptr(x);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //* the argument must be exactly a power of 2</span>
<span class="udiff-line-removed">- inline int exact_log2_long(jlong x) {</span>
<span class="udiff-line-removed">-   assert(is_power_of_2_long(x), &quot;x must be a power of 2: &quot; JLONG_FORMAT, x);</span>
<span class="udiff-line-removed">-   return log2_long(x);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  inline bool is_odd (intx x) { return x &amp; 1;      }
  inline bool is_even(intx x) { return !is_odd(x); }
  
  // abs methods which cannot overflow and so are well-defined across
  // the entire domain of integer types.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1060,10 +1125,59 @@</span>
  JAVA_INTEGER_OP(-, java_subtract, jlong, julong)
  JAVA_INTEGER_OP(*, java_multiply, jlong, julong)
  
  #undef JAVA_INTEGER_OP
  
<span class="udiff-line-added">+ // Provide integer shift operations with Java semantics.  No overflow</span>
<span class="udiff-line-added">+ // issues - left shifts simply discard shifted out bits.  No undefined</span>
<span class="udiff-line-added">+ // behavior for large or negative shift quantities; instead the actual</span>
<span class="udiff-line-added">+ // shift distance is the argument modulo the lhs value&#39;s size in bits.</span>
<span class="udiff-line-added">+ // No undefined or implementation defined behavior for shifting negative</span>
<span class="udiff-line-added">+ // values; left shift discards bits, right shift sign extends.  We use</span>
<span class="udiff-line-added">+ // the same safe conversion technique as above for java_add and friends.</span>
<span class="udiff-line-added">+ #define JAVA_INTEGER_SHIFT_OP(OP, NAME, TYPE, XTYPE)    \</span>
<span class="udiff-line-added">+ inline TYPE NAME (TYPE lhs, jint rhs) {                 \</span>
<span class="udiff-line-added">+   const uint rhs_mask = (sizeof(TYPE) * 8) - 1;         \</span>
<span class="udiff-line-added">+   STATIC_ASSERT(rhs_mask == 31 || rhs_mask == 63);      \</span>
<span class="udiff-line-added">+   XTYPE xres = static_cast&lt;XTYPE&gt;(lhs);                 \</span>
<span class="udiff-line-added">+   xres OP ## = (rhs &amp; rhs_mask);                        \</span>
<span class="udiff-line-added">+   return reinterpret_cast&lt;TYPE&amp;&gt;(xres);                 \</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JAVA_INTEGER_SHIFT_OP(&lt;&lt;, java_shift_left, jint, juint)</span>
<span class="udiff-line-added">+ JAVA_INTEGER_SHIFT_OP(&lt;&lt;, java_shift_left, jlong, julong)</span>
<span class="udiff-line-added">+ // For signed shift right, assume C++ implementation &gt;&gt; sign extends.</span>
<span class="udiff-line-added">+ JAVA_INTEGER_SHIFT_OP(&gt;&gt;, java_shift_right, jint, jint)</span>
<span class="udiff-line-added">+ JAVA_INTEGER_SHIFT_OP(&gt;&gt;, java_shift_right, jlong, jlong)</span>
<span class="udiff-line-added">+ // For &gt;&gt;&gt; use C++ unsigned &gt;&gt;.</span>
<span class="udiff-line-added">+ JAVA_INTEGER_SHIFT_OP(&gt;&gt;, java_shift_right_unsigned, jint, juint)</span>
<span class="udiff-line-added">+ JAVA_INTEGER_SHIFT_OP(&gt;&gt;, java_shift_right_unsigned, jlong, julong)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #undef JAVA_INTEGER_SHIFT_OP</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //----------------------------------------------------------------------------------------------------</span>
<span class="udiff-line-added">+ // The goal of this code is to provide saturating operations for int/uint.</span>
<span class="udiff-line-added">+ // Checks overflow conditions and saturates the result to min_jint/max_jint.</span>
<span class="udiff-line-added">+ #define SATURATED_INTEGER_OP(OP, NAME, TYPE1, TYPE2) \</span>
<span class="udiff-line-added">+ inline int NAME (TYPE1 in1, TYPE2 in2) {             \</span>
<span class="udiff-line-added">+   jlong res = static_cast&lt;jlong&gt;(in1);               \</span>
<span class="udiff-line-added">+   res OP ## = static_cast&lt;jlong&gt;(in2);               \</span>
<span class="udiff-line-added">+   if (res &gt; max_jint) {                              \</span>
<span class="udiff-line-added">+     res = max_jint;                                  \</span>
<span class="udiff-line-added">+   } else if (res &lt; min_jint) {                       \</span>
<span class="udiff-line-added">+     res = min_jint;                                  \</span>
<span class="udiff-line-added">+   }                                                  \</span>
<span class="udiff-line-added">+   return static_cast&lt;int&gt;(res);                      \</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ SATURATED_INTEGER_OP(+, saturated_add, int, int)</span>
<span class="udiff-line-added">+ SATURATED_INTEGER_OP(+, saturated_add, int, uint)</span>
<span class="udiff-line-added">+ SATURATED_INTEGER_OP(+, saturated_add, uint, int)</span>
<span class="udiff-line-added">+ SATURATED_INTEGER_OP(+, saturated_add, uint, uint)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #undef SATURATED_INTEGER_OP</span>
<span class="udiff-line-added">+ </span>
  // Dereference vptr
  // All C++ compilers that we know of have the vtbl pointer in the first
  // word.  If there are exceptions, this function needs to be made compiler
  // specific.
  static inline void* dereference_vptr(const void* addr) {
</pre>
<center><a href="globalDefinitions.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globalDefinitions_gcc.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
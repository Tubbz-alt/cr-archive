<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/utilities/ostream.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macros.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ostream.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/ostream.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97,17 +97,18 @@</span>
      // trivial copy-through format string
      result = va_arg(ap, const char*);
      result_len = strlen(result);
      if (add_cr &amp;&amp; result_len &gt;= buflen)  result_len = buflen-1;  // truncate
    } else {
<span class="udiff-line-modified-removed">-     int written = os::vsnprintf(buffer, buflen, format, ap);</span>
<span class="udiff-line-modified-removed">-     assert(written &gt;= 0, &quot;vsnprintf encoding error&quot;);</span>
<span class="udiff-line-modified-added">+     int required_len = os::vsnprintf(buffer, buflen, format, ap);</span>
<span class="udiff-line-modified-added">+     assert(required_len &gt;= 0, &quot;vsnprintf encoding error&quot;);</span>
      result = buffer;
<span class="udiff-line-modified-removed">-     if ((size_t)written &lt; buflen) {</span>
<span class="udiff-line-modified-removed">-       result_len = written;</span>
<span class="udiff-line-modified-added">+     if ((size_t)required_len &lt; buflen) {</span>
<span class="udiff-line-modified-added">+       result_len = required_len;</span>
      } else {
<span class="udiff-line-modified-removed">-       DEBUG_ONLY(warning(&quot;increase O_BUFLEN in ostream.hpp -- output truncated&quot;);)</span>
<span class="udiff-line-modified-added">+       DEBUG_ONLY(warning(&quot;outputStream::do_vsnprintf output truncated -- buffer length is %d bytes but %d bytes are needed.&quot;,</span>
<span class="udiff-line-added">+                          add_cr ? (int)buflen + 1 : (int)buflen, add_cr ? required_len + 2 : required_len + 1);)</span>
        result_len = buflen - 1;
      }
    }
    if (add_cr) {
      if (result != buffer) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -307,22 +308,23 @@</span>
    }
  }
  
  stringStream::stringStream(size_t initial_size) : outputStream() {
    buffer_length = initial_size;
<span class="udiff-line-modified-removed">-   buffer        = NEW_RESOURCE_ARRAY(char, buffer_length);</span>
<span class="udiff-line-modified-added">+   buffer        = NEW_C_HEAP_ARRAY(char, buffer_length, mtInternal);</span>
    buffer_pos    = 0;
    buffer_fixed  = false;
<span class="udiff-line-modified-removed">-   DEBUG_ONLY(rm = Thread::current()-&gt;current_resource_mark();)</span>
<span class="udiff-line-modified-added">+   zero_terminate();</span>
  }
  
  // useful for output to fixed chunks of memory, such as performance counters
  stringStream::stringStream(char* fixed_buffer, size_t fixed_buffer_size) : outputStream() {
    buffer_length = fixed_buffer_size;
    buffer        = fixed_buffer;
    buffer_pos    = 0;
    buffer_fixed  = true;
<span class="udiff-line-added">+   zero_terminate();</span>
  }
  
  void stringStream::write(const char* s, size_t len) {
    size_t write_len = len;               // number of non-null bytes to write
    size_t end = buffer_pos + len + 1;    // position after write and final &#39;\0&#39;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -335,44 +337,51 @@</span>
        // For small overruns, double the buffer.  For larger ones,
        // increase to the requested size.
        if (end &lt; buffer_length * 2) {
          end = buffer_length * 2;
        }
<span class="udiff-line-modified-removed">-       char* oldbuf = buffer;</span>
<span class="udiff-line-removed">-       assert(rm == NULL || Thread::current()-&gt;current_resource_mark() == rm,</span>
<span class="udiff-line-removed">-              &quot;StringStream is re-allocated with a different ResourceMark. Current: &quot;</span>
<span class="udiff-line-removed">-              PTR_FORMAT &quot; original: &quot; PTR_FORMAT,</span>
<span class="udiff-line-removed">-              p2i(Thread::current()-&gt;current_resource_mark()), p2i(rm));</span>
<span class="udiff-line-removed">-       buffer = NEW_RESOURCE_ARRAY(char, end);</span>
<span class="udiff-line-removed">-       if (buffer_pos &gt; 0) {</span>
<span class="udiff-line-removed">-         memcpy(buffer, oldbuf, buffer_pos);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);</span>
        buffer_length = end;
      }
    }
    // invariant: buffer is always null-terminated
    guarantee(buffer_pos + write_len + 1 &lt;= buffer_length, &quot;stringStream oob&quot;);
    if (write_len &gt; 0) {
<span class="udiff-line-removed">-     buffer[buffer_pos + write_len] = 0;</span>
      memcpy(buffer + buffer_pos, s, write_len);
      buffer_pos += write_len;
<span class="udiff-line-added">+     zero_terminate();</span>
    }
  
    // Note that the following does not depend on write_len.
    // This means that position and count get updated
    // even when overflow occurs.
    update_position(s, len);
  }
  
<span class="udiff-line-modified-removed">- char* stringStream::as_string() {</span>
<span class="udiff-line-modified-added">+ void stringStream::zero_terminate() {</span>
<span class="udiff-line-added">+   assert(buffer != NULL &amp;&amp;</span>
<span class="udiff-line-added">+          buffer_pos &lt; buffer_length, &quot;sanity&quot;);</span>
<span class="udiff-line-added">+   buffer[buffer_pos] = &#39;\0&#39;;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void stringStream::reset() {</span>
<span class="udiff-line-added">+   buffer_pos = 0; _precount = 0; _position = 0;</span>
<span class="udiff-line-added">+   zero_terminate();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ char* stringStream::as_string() const {</span>
    char* copy = NEW_RESOURCE_ARRAY(char, buffer_pos + 1);
    strncpy(copy, buffer, buffer_pos);
    copy[buffer_pos] = 0;  // terminating null
    return copy;
  }
  
<span class="udiff-line-modified-removed">- stringStream::~stringStream() {}</span>
<span class="udiff-line-modified-added">+ stringStream::~stringStream() {</span>
<span class="udiff-line-added">+   if (buffer_fixed == false &amp;&amp; buffer != NULL) {</span>
<span class="udiff-line-added">+     FREE_C_HEAP_ARRAY(char, buffer);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  xmlStream*   xtty;
  outputStream* tty;
  CDS_ONLY(fileStream* classlist_file;) // Only dump the classes that can be stored into the CDS archive
  extern Mutex* tty_lock;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -520,11 +529,11 @@</span>
    }
  }
  
  void fileStream::write(const char* s, size_t len) {
    if (_file != NULL)  {
<span class="udiff-line-modified-removed">-     // Make an unused local variable to avoid warning from gcc 4.x compiler.</span>
<span class="udiff-line-modified-added">+     // Make an unused local variable to avoid warning from gcc compiler.</span>
      size_t count = fwrite(s, 1, len, _file);
    }
    update_position(s, len);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -559,11 +568,11 @@</span>
    fflush(_file);
  }
  
  void fdStream::write(const char* s, size_t len) {
    if (_fd != -1) {
<span class="udiff-line-modified-removed">-     // Make an unused local variable to avoid warning from gcc 4.x compiler.</span>
<span class="udiff-line-modified-added">+     // Make an unused local variable to avoid warning from gcc compiler.</span>
      size_t count = ::write(_fd, s, (int)len);
    }
    update_position(s, len);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -648,13 +657,14 @@</span>
    xmlStream*xs = _outer_xmlStream;
      if (this == tty)  xtty = xs;
      // Write XML header.
      xs-&gt;print_cr(&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;&quot;);
      // (For now, don&#39;t bother to issue a DTD for this private format.)
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Calculate the start time of the log as ms since the epoch: this is</span>
<span class="udiff-line-added">+     // the current time in ms minus the uptime in ms.</span>
      jlong time_ms = os::javaTimeMillis() - tty-&gt;time_stamp().milliseconds();
<span class="udiff-line-removed">-     // %%% Should be: jlong time_ms = os::start_time_milliseconds(), if</span>
<span class="udiff-line-removed">-     // we ever get round to introduce that method on the os class</span>
      xs-&gt;head(&quot;hotspot_log version=&#39;%d %d&#39;&quot;
               &quot; process=&#39;%d&#39; time_ms=&#39;&quot; INT64_FORMAT &quot;&#39;&quot;,
               LOG_MAJOR_VERSION, LOG_MINOR_VERSION,
               os::current_process_id(), (int64_t)time_ms);
      // Write VM version header immediately.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -942,44 +952,73 @@</span>
    buffer_length = initial_size;
    buffer        = NEW_C_HEAP_ARRAY(char, buffer_length, mtInternal);
    buffer_pos    = 0;
    buffer_fixed  = false;
    buffer_max    = bufmax;
<span class="udiff-line-added">+   truncated     = false;</span>
  }
  
  bufferedStream::bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax) : outputStream() {
    buffer_length = fixed_buffer_size;
    buffer        = fixed_buffer;
    buffer_pos    = 0;
    buffer_fixed  = true;
    buffer_max    = bufmax;
<span class="udiff-line-added">+   truncated     = false;</span>
  }
  
  void bufferedStream::write(const char* s, size_t len) {
  
<span class="udiff-line-added">+   if (truncated) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    if(buffer_pos + len &gt; buffer_max) {
<span class="udiff-line-modified-removed">-     flush();</span>
<span class="udiff-line-modified-added">+     flush(); // Note: may be a noop.</span>
    }
  
    size_t end = buffer_pos + len;
    if (end &gt;= buffer_length) {
      if (buffer_fixed) {
        // if buffer cannot resize, silently truncate
        len = buffer_length - buffer_pos - 1;
<span class="udiff-line-added">+       truncated = true;</span>
      } else {
        // For small overruns, double the buffer.  For larger ones,
        // increase to the requested size.
        if (end &lt; buffer_length * 2) {
          end = buffer_length * 2;
        }
<span class="udiff-line-modified-removed">-       buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);</span>
<span class="udiff-line-modified-removed">-       buffer_length = end;</span>
<span class="udiff-line-modified-added">+       // Impose a cap beyond which the buffer cannot grow - a size which</span>
<span class="udiff-line-modified-added">+       // in all probability indicates a real error, e.g. faulty printing</span>
<span class="udiff-line-added">+       // code looping, while not affecting cases of just-very-large-but-its-normal</span>
<span class="udiff-line-added">+       // output.</span>
<span class="udiff-line-added">+       const size_t reasonable_cap = MAX2(100 * M, buffer_max * 2);</span>
<span class="udiff-line-added">+       if (end &gt; reasonable_cap) {</span>
<span class="udiff-line-added">+         // In debug VM, assert right away.</span>
<span class="udiff-line-added">+         assert(false, &quot;Exceeded max buffer size for this string.&quot;);</span>
<span class="udiff-line-added">+         // Release VM: silently truncate. We do this since these kind of errors</span>
<span class="udiff-line-added">+         // are both difficult to predict with testing (depending on logging content)</span>
<span class="udiff-line-added">+         // and usually not serious enough to kill a production VM for it.</span>
<span class="udiff-line-added">+         end = reasonable_cap;</span>
<span class="udiff-line-added">+         size_t remaining = end - buffer_pos;</span>
<span class="udiff-line-added">+         if (len &gt;= remaining) {</span>
<span class="udiff-line-added">+           len = remaining - 1;</span>
<span class="udiff-line-added">+           truncated = true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (buffer_length &lt; end) {</span>
<span class="udiff-line-added">+         buffer = REALLOC_C_HEAP_ARRAY(char, buffer, end, mtInternal);</span>
<span class="udiff-line-added">+         buffer_length = end;</span>
<span class="udiff-line-added">+       }</span>
      }
    }
<span class="udiff-line-modified-removed">-   memcpy(buffer + buffer_pos, s, len);</span>
<span class="udiff-line-modified-removed">-   buffer_pos += len;</span>
<span class="udiff-line-modified-removed">-   update_position(s, len);</span>
<span class="udiff-line-modified-added">+   if (len &gt; 0) {</span>
<span class="udiff-line-modified-added">+     memcpy(buffer + buffer_pos, s, len);</span>
<span class="udiff-line-modified-added">+     buffer_pos += len;</span>
<span class="udiff-line-added">+     update_position(s, len);</span>
<span class="udiff-line-added">+   }</span>
  }
  
  char* bufferedStream::as_string() {
    char* copy = NEW_RESOURCE_ARRAY(char, buffer_pos+1);
    strncpy(copy, buffer, buffer_pos);
</pre>
<center><a href="macros.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ostream.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/utilities/count_leading_zeros.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="concurrentHashTableTasks.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debug.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/count_leading_zeros.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,47 +25,192 @@</span>
  #ifndef SHARE_UTILITIES_COUNT_LEADING_ZEROS_HPP
  #define SHARE_UTILITIES_COUNT_LEADING_ZEROS_HPP
  
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="udiff-line-removed">- #include &quot;utilities/count_trailing_zeros.hpp&quot;</span>
  
<span class="udiff-line-modified-removed">- #if defined(TARGET_COMPILER_visCPP)</span>
<span class="udiff-line-removed">- #include &lt;intrin.h&gt;</span>
<span class="udiff-line-removed">- #pragma intrinsic(_BitScanReverse)</span>
<span class="udiff-line-removed">- #elif defined(TARGET_COMPILER_xlc)</span>
<span class="udiff-line-removed">- #include &lt;builtins.h&gt;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+ // uint32_t count_leading_zeros(T x)</span>
  
<span class="udiff-line-removed">- // uint32_t count_leading_zeros(uint32_t x)</span>
  // Return the number of leading zeros in x, e.g. the zero-based index
  // of the most significant set bit in x.  Undefined for 0.
<span class="udiff-line-modified-removed">- inline uint32_t count_leading_zeros(uint32_t x) {</span>
<span class="udiff-line-modified-removed">-   assert(x != 0, &quot;precondition&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ // We implement and support variants for 8, 16, 32 and 64 bit integral types.</span>
<span class="udiff-line-added">+ template &lt;typename T, size_t n&gt; struct CountLeadingZerosImpl;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; unsigned count_leading_zeros(T v) {</span>
<span class="udiff-line-added">+   assert(v != 0, &quot;precondition&quot;);</span>
<span class="udiff-line-added">+   return CountLeadingZerosImpl&lt;T, sizeof(T)&gt;::doit(v);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*****************************************************************************</span>
<span class="udiff-line-added">+  * GCC and compatible (including Clang)</span>
<span class="udiff-line-added">+  *****************************************************************************/</span>
  #if defined(TARGET_COMPILER_gcc)
<span class="udiff-line-modified-removed">-   return __builtin_clz(x);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 1&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return __builtin_clz((uint32_t)v &amp; 0xFF) - 24u;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 2&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return __builtin_clz((uint32_t)v &amp; 0xFFFF) - 16u;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 4&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return __builtin_clz(v);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 8&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return __builtin_clzll(v);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*****************************************************************************</span>
<span class="udiff-line-added">+  * Microsoft Visual Studio</span>
<span class="udiff-line-added">+  *****************************************************************************/</span>
  #elif defined(TARGET_COMPILER_visCPP)
<span class="udiff-line-modified-removed">-   unsigned long index;</span>
<span class="udiff-line-modified-removed">-   _BitScanReverse(&amp;index, x);</span>
<span class="udiff-line-modified-removed">-   return index ^ 31u;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ #include &lt;intrin.h&gt;</span>
<span class="udiff-line-modified-added">+ #pragma intrinsic(_BitScanReverse)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+ #pragma intrinsic(_BitScanReverse64)</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 1&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     unsigned long index;</span>
<span class="udiff-line-added">+     _BitScanReverse(&amp;index, (uint32_t)v &amp; 0xFF);</span>
<span class="udiff-line-added">+     return 7u - index;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 2&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     unsigned long index;</span>
<span class="udiff-line-added">+     _BitScanReverse(&amp;index, (uint32_t)v &amp; 0xFFFF);</span>
<span class="udiff-line-added">+     return 15u - index;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 4&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     unsigned long index;</span>
<span class="udiff-line-added">+     _BitScanReverse(&amp;index, v);</span>
<span class="udiff-line-added">+     return 31u - index;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 8&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+     unsigned long index;</span>
<span class="udiff-line-added">+     _BitScanReverse64(&amp;index, v);</span>
<span class="udiff-line-added">+     return 63u - index;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     uint64_t high = ((uint64_t)v) &gt;&gt; 32ULL;</span>
<span class="udiff-line-added">+     if (high != 0) {</span>
<span class="udiff-line-added">+       return count_leading_zeros((uint32_t)high);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       return count_leading_zeros((uint32_t)v) + 32;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*****************************************************************************</span>
<span class="udiff-line-added">+  * IBM XL C/C++</span>
<span class="udiff-line-added">+  *****************************************************************************/</span>
  #elif defined(TARGET_COMPILER_xlc)
<span class="udiff-line-modified-removed">-   return __cntlz4(x);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ #include &lt;builtins.h&gt;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 1&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return __cntlz4((uint32_t)v &amp; 0xFF) - 24u;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 2&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return __cntlz4((uint32_t)v &amp; 0xFFFF) - 16u;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 4&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return __cntlz4(v);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 8&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return __cntlz8(v);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*****************************************************************************</span>
<span class="udiff-line-added">+  * Fallback</span>
<span class="udiff-line-added">+  *****************************************************************************/</span>
  #else
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline uint32_t count_leading_zeros_32(uint32_t x) {</span>
<span class="udiff-line-added">+   assert(x != 0, &quot;precondition&quot;);</span>
<span class="udiff-line-added">+ </span>
    // Efficient and portable fallback implementation:
    // http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn
    // - with positions xor&#39;d by 31 to get number of leading zeros
    // rather than position of highest bit.
<span class="udiff-line-modified-removed">-   static const int MultiplyDeBruijnBitPosition[32] = {</span>
<span class="udiff-line-modified-removed">-       31, 22, 30, 21, 18, 10, 29,  2, 20, 17, 15, 13, 9,  6, 28, 1,</span>
<span class="udiff-line-modified-removed">-       23, 19, 11,  3, 16, 14,  7, 24, 12,  4,  8, 25, 5, 26, 27, 0</span>
<span class="udiff-line-modified-added">+   static const uint32_t MultiplyDeBruijnBitPosition[32] = {</span>
<span class="udiff-line-modified-added">+       31, 22, 30, 21, 18, 10, 29,  2, 20, 17, 15, 13, 9,  6, 28,  1,</span>
<span class="udiff-line-modified-added">+       23, 19, 11,  3, 16, 14,  7, 24, 12,  4,  8, 25, 5, 26, 27,  0</span>
    };
  
<span class="udiff-line-modified-removed">-   x |= x &gt;&gt; 1; // first round down to one less than a power of 2</span>
<span class="udiff-line-modified-added">+   // First round down to one less than a power of 2</span>
<span class="udiff-line-added">+   x |= x &gt;&gt; 1;</span>
    x |= x &gt;&gt; 2;
    x |= x &gt;&gt; 4;
    x |= x &gt;&gt; 8;
    x |= x &gt;&gt; 16;
<span class="udiff-line-modified-removed">-   return MultiplyDeBruijnBitPosition[(uint32_t)( x * 0x07c4acddu ) &gt;&gt; 27];</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+   // Multiply by a magic constant which ensure the highest 5 bits point to</span>
<span class="udiff-line-modified-added">+   // the right index in the lookup table</span>
<span class="udiff-line-added">+   return MultiplyDeBruijnBitPosition[(x * 0x07c4acddu) &gt;&gt; 27u];</span>
  }
  
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 1&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return count_leading_zeros_32((uint32_t)v &amp; 0xFF) - 24u;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 2&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return count_leading_zeros_32((uint32_t)v &amp; 0xFFFF) - 16u;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 4&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     return count_leading_zeros_32(v);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 8&gt; {</span>
<span class="udiff-line-added">+   static unsigned doit(T v) {</span>
<span class="udiff-line-added">+     uint64_t high = ((uint64_t)v) &gt;&gt; 32ULL;</span>
<span class="udiff-line-added">+     if (high != 0) {</span>
<span class="udiff-line-added">+       return count_leading_zeros_32((uint32_t)high);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       return count_leading_zeros_32((uint32_t)v) + 32u;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  #endif // SHARE_UTILITIES_COUNT_LEADING_ZEROS_HPP
</pre>
<center><a href="concurrentHashTableTasks.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debug.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
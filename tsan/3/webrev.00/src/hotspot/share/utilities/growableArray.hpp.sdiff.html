<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/growableArray.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globalDefinitions_xlc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="hashtable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/growableArray.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_GROWABLEARRAY_HPP
 26 #define SHARE_UTILITIES_GROWABLEARRAY_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/oop.hpp&quot;
 30 #include &quot;utilities/debug.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;

 33 
 34 // A growable array.
 35 
 36 /*************************************************************************/
 37 /*                                                                       */
 38 /*     WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING   */
 39 /*                                                                       */
 40 /* Should you use GrowableArrays to contain handles you must be certain  */
 41 /* the the GrowableArray does not outlive the HandleMark that contains   */
 42 /* the handles. Since GrowableArrays are typically resource allocated    */
 43 /* the following is an example of INCORRECT CODE,                        */
 44 /*                                                                       */
 45 /* ResourceMark rm;                                                      */
 46 /* GrowableArray&lt;Handle&gt;* arr = new GrowableArray&lt;Handle&gt;(size);         */
 47 /* if (blah) {                                                           */
 48 /*    while (...) {                                                      */
 49 /*      HandleMark hm;                                                   */
 50 /*      ...                                                              */
 51 /*      Handle h(THREAD, some_oop);                                      */
 52 /*      arr-&gt;append(h);                                                  */
</pre>
<hr />
<pre>
135     // Relax next assert to allow object allocation on resource area,
136     // on stack or embedded into an other object.
137     assert(allocated_on_arena() || allocated_on_stack(),
138            &quot;growable array must be on arena or on stack if elements are on arena&quot;);
139   }
140 
141   void* raw_allocate(int elementSize);
142 
143   // some uses pass the Thread explicitly for speed (4990299 tuning)
144   void* raw_allocate(Thread* thread, int elementSize) {
145     assert(on_stack(), &quot;fast ResourceObj path only&quot;);
146     return (void*)resource_allocate_bytes(thread, elementSize * _max);
147   }
148 
149   void free_C_heap(void* elements);
150 };
151 
152 template&lt;class E&gt; class GrowableArrayIterator;
153 template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator;
154 






155 template&lt;class E&gt; class GrowableArray : public GenericGrowableArray {
156   friend class VMStructs;
157 
158  private:
159   E*     _data;         // data array
160 
161   void grow(int j);
162   void raw_at_put_grow(int i, const E&amp; p, const E&amp; fill);
163   void  clear_and_deallocate();
164  public:
165   GrowableArray(Thread* thread, int initial_size) : GenericGrowableArray(initial_size, 0, false) {
166     _data = (E*)raw_allocate(thread, sizeof(E));
167     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
168   }
169 
170   GrowableArray(int initial_size, bool C_heap = false, MEMFLAGS F = mtInternal)
171     : GenericGrowableArray(initial_size, 0, C_heap, F) {
172     _data = (E*)raw_allocate(sizeof(E));
173 // Needed for Visual Studio 2012 and older
174 #ifdef _MSC_VER
175 #pragma warning(suppress: 4345)
176 #endif
177     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
178   }
179 
180   GrowableArray(int initial_size, int initial_len, const E&amp; filler, bool C_heap = false, MEMFLAGS memflags = mtInternal)
181     : GenericGrowableArray(initial_size, initial_len, C_heap, memflags) {
182     _data = (E*)raw_allocate(sizeof(E));
183     int i = 0;
184     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
185     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
186   }
187 
<span class="line-modified">188   GrowableArray(Arena* arena, int initial_size, int initial_len, const E&amp; filler) : GenericGrowableArray(arena, initial_size, initial_len) {</span>




189     _data = (E*)raw_allocate(sizeof(E));
190     int i = 0;
191     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
192     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
193   }
194 
195   GrowableArray() : GenericGrowableArray(2, 0, false) {
196     _data = (E*)raw_allocate(sizeof(E));
197     ::new ((void*)&amp;_data[0]) E();
198     ::new ((void*)&amp;_data[1]) E();
199   }
200 
201                                 // Does nothing for resource and arena objects
202   ~GrowableArray()              { if (on_C_heap()) clear_and_deallocate(); }
203 
204   void  clear()                 { _len = 0; }
205   int   length() const          { return _len; }
206   int   max_length() const      { return _max; }
207   void  trunc_to(int l)         { assert(l &lt;= _len,&quot;cannot increase length&quot;); _len = l; }
208   bool  is_empty() const        { return _len == 0; }
209   bool  is_nonempty() const     { return _len != 0; }
210   bool  is_full() const         { return _len == _max; }
211   DEBUG_ONLY(E* data_addr() const      { return _data; })
212 
213   void print();
214 
<span class="line-removed">215   inline static bool safe_equals(oop obj1, oop obj2) {</span>
<span class="line-removed">216     return oopDesc::equals(obj1, obj2);</span>
<span class="line-removed">217   }</span>
<span class="line-removed">218 </span>
<span class="line-removed">219   template &lt;class X&gt;</span>
<span class="line-removed">220   inline static bool safe_equals(X i1, X i2) {</span>
<span class="line-removed">221     return i1 == i2;</span>
<span class="line-removed">222   }</span>
<span class="line-removed">223 </span>
224   int append(const E&amp; elem) {
225     check_nesting();
226     if (_len == _max) grow(_len);
227     int idx = _len++;
228     _data[idx] = elem;
229     return idx;
230   }
231 
232   bool append_if_missing(const E&amp; elem) {
233     // Returns TRUE if elem is added.
234     bool missed = !contains(elem);
235     if (missed) append(elem);
236     return missed;
237   }
238 
239   E&amp; at(int i) {
240     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
241     return _data[i];
242   }
243 
</pre>
<hr />
<pre>
288   E at_grow(int i, const E&amp; fill = E()) {
289     assert(0 &lt;= i, &quot;negative index&quot;);
290     check_nesting();
291     if (i &gt;= _len) {
292       if (i &gt;= _max) grow(i);
293       for (int j = _len; j &lt;= i; j++)
294         _data[j] = fill;
295       _len = i+1;
296     }
297     return _data[i];
298   }
299 
300   void at_put_grow(int i, const E&amp; elem, const E&amp; fill = E()) {
301     assert(0 &lt;= i, &quot;negative index&quot;);
302     check_nesting();
303     raw_at_put_grow(i, elem, fill);
304   }
305 
306   bool contains(const E&amp; elem) const {
307     for (int i = 0; i &lt; _len; i++) {
<span class="line-modified">308       if (safe_equals(_data[i], elem)) return true;</span>
309     }
310     return false;
311   }
312 
313   int  find(const E&amp; elem) const {
314     for (int i = 0; i &lt; _len; i++) {
315       if (_data[i] == elem) return i;
316     }
317     return -1;
318   }
319 
320   int  find_from_end(const E&amp; elem) const {
321     for (int i = _len-1; i &gt;= 0; i--) {
322       if (_data[i] == elem) return i;
323     }
324     return -1;
325   }
326 
327   int  find(void* token, bool f(void*, E)) const {
328     for (int i = 0; i &lt; _len; i++) {
</pre>
<hr />
<pre>
426   template &lt;typename K, int compare(const K&amp;, const E&amp;)&gt; int find_sorted(const K&amp; key, bool&amp; found) {
427     found = false;
428     int min = 0;
429     int max = length() - 1;
430 
431     while (max &gt;= min) {
432       int mid = (int)(((uint)max + min) / 2);
433       E value = at(mid);
434       int diff = compare(key, value);
435       if (diff &gt; 0) {
436         min = mid + 1;
437       } else if (diff &lt; 0) {
438         max = mid - 1;
439       } else {
440         found = true;
441         return mid;
442       }
443     }
444     return min;
445   }































446 };
447 
448 // Global GrowableArray methods (one instance in the library per each &#39;E&#39; type).
449 
450 template&lt;class E&gt; void GrowableArray&lt;E&gt;::grow(int j) {
<span class="line-removed">451     // grow the array by doubling its size (amortized growth)</span>
452     int old_max = _max;
<span class="line-modified">453     if (_max == 0) _max = 1; // prevent endless loop</span>
<span class="line-modified">454     while (j &gt;= _max) _max = _max*2;</span>
455     // j &lt; _max
456     E* newData = (E*)raw_allocate(sizeof(E));
457     int i = 0;
458     for (     ; i &lt; _len; i++) ::new ((void*)&amp;newData[i]) E(_data[i]);
459 // Needed for Visual Studio 2012 and older
460 #ifdef _MSC_VER
461 #pragma warning(suppress: 4345)
462 #endif
463     for (     ; i &lt; _max; i++) ::new ((void*)&amp;newData[i]) E();
464     for (i = 0; i &lt; old_max; i++) _data[i].~E();
465     if (on_C_heap() &amp;&amp; _data != NULL) {
466       free_C_heap(_data);
467     }
468     _data = newData;
469 }
470 
471 template&lt;class E&gt; void GrowableArray&lt;E&gt;::raw_at_put_grow(int i, const E&amp; p, const E&amp; fill) {
472     if (i &gt;= _len) {
473       if (i &gt;= _max) grow(i);
474       for (int j = _len; j &lt; i; j++)
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_GROWABLEARRAY_HPP
 26 #define SHARE_UTILITIES_GROWABLEARRAY_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/oop.hpp&quot;
 30 #include &quot;utilities/debug.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
<span class="line-added"> 33 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 34 
 35 // A growable array.
 36 
 37 /*************************************************************************/
 38 /*                                                                       */
 39 /*     WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING   */
 40 /*                                                                       */
 41 /* Should you use GrowableArrays to contain handles you must be certain  */
 42 /* the the GrowableArray does not outlive the HandleMark that contains   */
 43 /* the handles. Since GrowableArrays are typically resource allocated    */
 44 /* the following is an example of INCORRECT CODE,                        */
 45 /*                                                                       */
 46 /* ResourceMark rm;                                                      */
 47 /* GrowableArray&lt;Handle&gt;* arr = new GrowableArray&lt;Handle&gt;(size);         */
 48 /* if (blah) {                                                           */
 49 /*    while (...) {                                                      */
 50 /*      HandleMark hm;                                                   */
 51 /*      ...                                                              */
 52 /*      Handle h(THREAD, some_oop);                                      */
 53 /*      arr-&gt;append(h);                                                  */
</pre>
<hr />
<pre>
136     // Relax next assert to allow object allocation on resource area,
137     // on stack or embedded into an other object.
138     assert(allocated_on_arena() || allocated_on_stack(),
139            &quot;growable array must be on arena or on stack if elements are on arena&quot;);
140   }
141 
142   void* raw_allocate(int elementSize);
143 
144   // some uses pass the Thread explicitly for speed (4990299 tuning)
145   void* raw_allocate(Thread* thread, int elementSize) {
146     assert(on_stack(), &quot;fast ResourceObj path only&quot;);
147     return (void*)resource_allocate_bytes(thread, elementSize * _max);
148   }
149 
150   void free_C_heap(void* elements);
151 };
152 
153 template&lt;class E&gt; class GrowableArrayIterator;
154 template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator;
155 
<span class="line-added">156 template&lt;class E&gt;</span>
<span class="line-added">157 class CompareClosure : public Closure {</span>
<span class="line-added">158 public:</span>
<span class="line-added">159     virtual int do_compare(const E&amp;, const E&amp;) = 0;</span>
<span class="line-added">160 };</span>
<span class="line-added">161 </span>
162 template&lt;class E&gt; class GrowableArray : public GenericGrowableArray {
163   friend class VMStructs;
164 
165  private:
166   E*     _data;         // data array
167 
168   void grow(int j);
169   void raw_at_put_grow(int i, const E&amp; p, const E&amp; fill);
170   void  clear_and_deallocate();
171  public:
172   GrowableArray(Thread* thread, int initial_size) : GenericGrowableArray(initial_size, 0, false) {
173     _data = (E*)raw_allocate(thread, sizeof(E));
174     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
175   }
176 
177   GrowableArray(int initial_size, bool C_heap = false, MEMFLAGS F = mtInternal)
178     : GenericGrowableArray(initial_size, 0, C_heap, F) {
179     _data = (E*)raw_allocate(sizeof(E));
180 // Needed for Visual Studio 2012 and older
181 #ifdef _MSC_VER
182 #pragma warning(suppress: 4345)
183 #endif
184     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
185   }
186 
187   GrowableArray(int initial_size, int initial_len, const E&amp; filler, bool C_heap = false, MEMFLAGS memflags = mtInternal)
188     : GenericGrowableArray(initial_size, initial_len, C_heap, memflags) {
189     _data = (E*)raw_allocate(sizeof(E));
190     int i = 0;
191     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
192     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
193   }
194 
<span class="line-modified">195   // Watch out, if filler was generated by a constructor, the destuctor might</span>
<span class="line-added">196   // be called on the original object invalidating all the copies made here.</span>
<span class="line-added">197   // Carefully design the copy constructor.</span>
<span class="line-added">198   GrowableArray(Arena* arena, int initial_size, int initial_len, const E&amp; filler) :</span>
<span class="line-added">199       GenericGrowableArray(arena, initial_size, initial_len) {</span>
200     _data = (E*)raw_allocate(sizeof(E));
201     int i = 0;
202     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
203     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
204   }
205 
206   GrowableArray() : GenericGrowableArray(2, 0, false) {
207     _data = (E*)raw_allocate(sizeof(E));
208     ::new ((void*)&amp;_data[0]) E();
209     ::new ((void*)&amp;_data[1]) E();
210   }
211 
212                                 // Does nothing for resource and arena objects
213   ~GrowableArray()              { if (on_C_heap()) clear_and_deallocate(); }
214 
215   void  clear()                 { _len = 0; }
216   int   length() const          { return _len; }
217   int   max_length() const      { return _max; }
218   void  trunc_to(int l)         { assert(l &lt;= _len,&quot;cannot increase length&quot;); _len = l; }
219   bool  is_empty() const        { return _len == 0; }
220   bool  is_nonempty() const     { return _len != 0; }
221   bool  is_full() const         { return _len == _max; }
222   DEBUG_ONLY(E* data_addr() const      { return _data; })
223 
224   void print();
225 









226   int append(const E&amp; elem) {
227     check_nesting();
228     if (_len == _max) grow(_len);
229     int idx = _len++;
230     _data[idx] = elem;
231     return idx;
232   }
233 
234   bool append_if_missing(const E&amp; elem) {
235     // Returns TRUE if elem is added.
236     bool missed = !contains(elem);
237     if (missed) append(elem);
238     return missed;
239   }
240 
241   E&amp; at(int i) {
242     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
243     return _data[i];
244   }
245 
</pre>
<hr />
<pre>
290   E at_grow(int i, const E&amp; fill = E()) {
291     assert(0 &lt;= i, &quot;negative index&quot;);
292     check_nesting();
293     if (i &gt;= _len) {
294       if (i &gt;= _max) grow(i);
295       for (int j = _len; j &lt;= i; j++)
296         _data[j] = fill;
297       _len = i+1;
298     }
299     return _data[i];
300   }
301 
302   void at_put_grow(int i, const E&amp; elem, const E&amp; fill = E()) {
303     assert(0 &lt;= i, &quot;negative index&quot;);
304     check_nesting();
305     raw_at_put_grow(i, elem, fill);
306   }
307 
308   bool contains(const E&amp; elem) const {
309     for (int i = 0; i &lt; _len; i++) {
<span class="line-modified">310       if (_data[i] == elem) return true;</span>
311     }
312     return false;
313   }
314 
315   int  find(const E&amp; elem) const {
316     for (int i = 0; i &lt; _len; i++) {
317       if (_data[i] == elem) return i;
318     }
319     return -1;
320   }
321 
322   int  find_from_end(const E&amp; elem) const {
323     for (int i = _len-1; i &gt;= 0; i--) {
324       if (_data[i] == elem) return i;
325     }
326     return -1;
327   }
328 
329   int  find(void* token, bool f(void*, E)) const {
330     for (int i = 0; i &lt; _len; i++) {
</pre>
<hr />
<pre>
428   template &lt;typename K, int compare(const K&amp;, const E&amp;)&gt; int find_sorted(const K&amp; key, bool&amp; found) {
429     found = false;
430     int min = 0;
431     int max = length() - 1;
432 
433     while (max &gt;= min) {
434       int mid = (int)(((uint)max + min) / 2);
435       E value = at(mid);
436       int diff = compare(key, value);
437       if (diff &gt; 0) {
438         min = mid + 1;
439       } else if (diff &lt; 0) {
440         max = mid - 1;
441       } else {
442         found = true;
443         return mid;
444       }
445     }
446     return min;
447   }
<span class="line-added">448 </span>
<span class="line-added">449   E insert_sorted(CompareClosure&lt;E&gt;* cc, const E&amp; key) {</span>
<span class="line-added">450     bool found;</span>
<span class="line-added">451     int location = find_sorted(cc, key, found);</span>
<span class="line-added">452     if (!found) {</span>
<span class="line-added">453       insert_before(location, key);</span>
<span class="line-added">454     }</span>
<span class="line-added">455     return at(location);</span>
<span class="line-added">456   }</span>
<span class="line-added">457 </span>
<span class="line-added">458   template&lt;typename K&gt;</span>
<span class="line-added">459   int find_sorted(CompareClosure&lt;E&gt;* cc, const K&amp; key, bool&amp; found) {</span>
<span class="line-added">460     found = false;</span>
<span class="line-added">461     int min = 0;</span>
<span class="line-added">462     int max = length() - 1;</span>
<span class="line-added">463 </span>
<span class="line-added">464     while (max &gt;= min) {</span>
<span class="line-added">465       int mid = (int)(((uint)max + min) / 2);</span>
<span class="line-added">466       E value = at(mid);</span>
<span class="line-added">467       int diff = cc-&gt;do_compare(key, value);</span>
<span class="line-added">468       if (diff &gt; 0) {</span>
<span class="line-added">469         min = mid + 1;</span>
<span class="line-added">470       } else if (diff &lt; 0) {</span>
<span class="line-added">471         max = mid - 1;</span>
<span class="line-added">472       } else {</span>
<span class="line-added">473         found = true;</span>
<span class="line-added">474         return mid;</span>
<span class="line-added">475       }</span>
<span class="line-added">476     }</span>
<span class="line-added">477     return min;</span>
<span class="line-added">478   }</span>
479 };
480 
481 // Global GrowableArray methods (one instance in the library per each &#39;E&#39; type).
482 
483 template&lt;class E&gt; void GrowableArray&lt;E&gt;::grow(int j) {

484     int old_max = _max;
<span class="line-modified">485     // grow the array by increasing _max to the first power of two larger than the size we need</span>
<span class="line-modified">486     _max = next_power_of_2((uint32_t)j);</span>
487     // j &lt; _max
488     E* newData = (E*)raw_allocate(sizeof(E));
489     int i = 0;
490     for (     ; i &lt; _len; i++) ::new ((void*)&amp;newData[i]) E(_data[i]);
491 // Needed for Visual Studio 2012 and older
492 #ifdef _MSC_VER
493 #pragma warning(suppress: 4345)
494 #endif
495     for (     ; i &lt; _max; i++) ::new ((void*)&amp;newData[i]) E();
496     for (i = 0; i &lt; old_max; i++) _data[i].~E();
497     if (on_C_heap() &amp;&amp; _data != NULL) {
498       free_C_heap(_data);
499     }
500     _data = newData;
501 }
502 
503 template&lt;class E&gt; void GrowableArray&lt;E&gt;::raw_at_put_grow(int i, const E&amp; p, const E&amp; fill) {
504     if (i &gt;= _len) {
505       if (i &gt;= _max) grow(i);
506       for (int j = _len; j &lt; i; j++)
</pre>
</td>
</tr>
</table>
<center><a href="globalDefinitions_xlc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="hashtable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
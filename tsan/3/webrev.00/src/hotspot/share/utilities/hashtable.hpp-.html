<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/utilities/hashtable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_HASHTABLE_HPP
 26 #define SHARE_UTILITIES_HASHTABLE_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/oop.hpp&quot;
 30 #include &quot;oops/symbol.hpp&quot;
 31 #include &quot;runtime/handles.hpp&quot;
 32 #include &quot;utilities/growableArray.hpp&quot;
 33 
 34 // This is a generic hashtable, designed to be used for the symbol
 35 // and string tables.
 36 //
 37 // It is implemented as an open hash table with a fixed number of buckets.
 38 //
 39 // %note:
 40 //  - TableEntrys are allocated in blocks to reduce the space overhead.
 41 
 42 
 43 
 44 template &lt;MEMFLAGS F&gt; class BasicHashtableEntry : public CHeapObj&lt;F&gt; {
 45   friend class VMStructs;
 46 private:
 47   unsigned int         _hash;           // 32-bit hash for item
 48 
 49   // Link to next element in the linked list for this bucket.  EXCEPT
 50   // bit 0 set indicates that this entry is shared and must not be
 51   // unlinked from the table. Bit 0 is set during the dumping of the
 52   // archive. Since shared entries are immutable, _next fields in the
 53   // shared entries will not change.  New entries will always be
 54   // unshared and since pointers are align, bit 0 will always remain 0
 55   // with no extra effort.
 56   BasicHashtableEntry&lt;F&gt;* _next;
 57 
 58   // Windows IA64 compiler requires subclasses to be able to access these
 59 protected:
 60   // Entry objects should not be created, they should be taken from the
 61   // free list with BasicHashtable.new_entry().
 62   BasicHashtableEntry() { ShouldNotReachHere(); }
 63   // Entry objects should not be destroyed.  They should be placed on
 64   // the free list instead with BasicHashtable.free_entry().
 65   ~BasicHashtableEntry() { ShouldNotReachHere(); }
 66 
 67 public:
 68 
 69   unsigned int hash() const             { return _hash; }
 70   void set_hash(unsigned int hash)      { _hash = hash; }
 71   unsigned int* hash_addr()             { return &amp;_hash; }
 72 
 73   static BasicHashtableEntry&lt;F&gt;* make_ptr(BasicHashtableEntry&lt;F&gt;* p) {
 74     return (BasicHashtableEntry*)((intptr_t)p &amp; -2);
 75   }
 76 
 77   BasicHashtableEntry&lt;F&gt;* next() const {
 78     return make_ptr(_next);
 79   }
 80 
 81   void set_next(BasicHashtableEntry&lt;F&gt;* next) {
 82     _next = next;
 83   }
 84 
 85   BasicHashtableEntry&lt;F&gt;** next_addr() {
 86     return &amp;_next;
 87   }
 88 
 89   bool is_shared() const {
 90     return ((intptr_t)_next &amp; 1) != 0;
 91   }
 92 
 93   void set_shared() {
 94     _next = (BasicHashtableEntry&lt;F&gt;*)((intptr_t)_next | 1);
 95   }
 96 };
 97 
 98 
 99 
100 template &lt;class T, MEMFLAGS F&gt; class HashtableEntry : public BasicHashtableEntry&lt;F&gt; {
101   friend class VMStructs;
102 private:
103   T               _literal;          // ref to item in table.
104 
105 public:
106   // Literal
107   T literal() const                   { return _literal; }
108   T* literal_addr()                   { return &amp;_literal; }
109   void set_literal(T s)               { _literal = s; }
110 
111   HashtableEntry* next() const {
112     return (HashtableEntry*)BasicHashtableEntry&lt;F&gt;::next();
113   }
114   HashtableEntry** next_addr() {
115     return (HashtableEntry**)BasicHashtableEntry&lt;F&gt;::next_addr();
116   }
117 };
118 
119 
120 
121 template &lt;MEMFLAGS F&gt; class HashtableBucket : public CHeapObj&lt;F&gt; {
122   friend class VMStructs;
123 private:
124   // Instance variable
125   BasicHashtableEntry&lt;F&gt;*       _entry;
126 
127 public:
128   // Accessing
129   void clear()                        { _entry = NULL; }
130 
131   // The following methods use order access methods to avoid race
132   // conditions in multiprocessor systems.
133   BasicHashtableEntry&lt;F&gt;* get_entry() const;
134   void set_entry(BasicHashtableEntry&lt;F&gt;* l);
135 
136   // The following method is not MT-safe and must be done under lock.
137   BasicHashtableEntry&lt;F&gt;** entry_addr()  { return &amp;_entry; }
138 
139 };
140 
141 
142 template &lt;MEMFLAGS F&gt; class BasicHashtable : public CHeapObj&lt;F&gt; {
143   friend class VMStructs;
144 
145 public:
146   BasicHashtable(int table_size, int entry_size);
147   BasicHashtable(int table_size, int entry_size,
148                  HashtableBucket&lt;F&gt;* buckets, int number_of_entries);
149   ~BasicHashtable();
150 
151   // Bucket handling
152   int hash_to_index(unsigned int full_hash) const {
153     int h = full_hash % _table_size;
154     assert(h &gt;= 0 &amp;&amp; h &lt; _table_size, &quot;Illegal hash value&quot;);
155     return h;
156   }
157 
158 private:
159   // Instance variables
160   int               _table_size;
161   HashtableBucket&lt;F&gt;*     _buckets;
162   BasicHashtableEntry&lt;F&gt;* volatile _free_list;
163   char*             _first_free_entry;
164   char*             _end_block;
165   int               _entry_size;
166   volatile int      _number_of_entries;
167   GrowableArray&lt;char*&gt;* _entry_blocks;
168 
169 protected:
170 
171   void initialize(int table_size, int entry_size, int number_of_entries);
172 
173   // Accessor
174   int entry_size() const { return _entry_size; }
175 
176   // The following method is MT-safe and may be used with caution.
177   BasicHashtableEntry&lt;F&gt;* bucket(int i) const;
178 
179   // The following method is not MT-safe and must be done under lock.
180   BasicHashtableEntry&lt;F&gt;** bucket_addr(int i) { return _buckets[i].entry_addr(); }
181 
182   // Attempt to get an entry from the free list
183   BasicHashtableEntry&lt;F&gt;* new_entry_free_list();
184 
185   // Table entry management
186   BasicHashtableEntry&lt;F&gt;* new_entry(unsigned int hashValue);
187 
188   // Used when moving the entry to another table
189   // Clean up links, but do not add to free_list
190   void unlink_entry(BasicHashtableEntry&lt;F&gt;* entry) {
191     entry-&gt;set_next(NULL);
192     --_number_of_entries;
193   }
194 
195   // Move over freelist and free block for allocation
196   void copy_freelist(BasicHashtable* src) {
197     _free_list = src-&gt;_free_list;
198     src-&gt;_free_list = NULL;
199     _first_free_entry = src-&gt;_first_free_entry;
200     src-&gt;_first_free_entry = NULL;
201     _end_block = src-&gt;_end_block;
202     src-&gt;_end_block = NULL;
203   }
204 
205   // Free the buckets in this hashtable
206   void free_buckets();
207 public:
208   int table_size() const { return _table_size; }
209   void set_entry(int index, BasicHashtableEntry&lt;F&gt;* entry);
210 
211   void add_entry(int index, BasicHashtableEntry&lt;F&gt;* entry);
212 
213   void free_entry(BasicHashtableEntry&lt;F&gt;* entry);
214 
215   int number_of_entries() const { return _number_of_entries; }
216 
217   bool resize(int new_size);
218 
219   // Grow the number of buckets if the average entries per bucket is over the load_factor
220   bool maybe_grow(int max_size, int load_factor = 8);
221 
222   template &lt;class T&gt; void verify_table(const char* table_name) PRODUCT_RETURN;
223 };
224 
225 
226 template &lt;class T, MEMFLAGS F&gt; class Hashtable : public BasicHashtable&lt;F&gt; {
227   friend class VMStructs;
228 
229 public:
230   Hashtable(int table_size, int entry_size)
231     : BasicHashtable&lt;F&gt;(table_size, entry_size) { }
232 
233   Hashtable(int table_size, int entry_size,
234                    HashtableBucket&lt;F&gt;* buckets, int number_of_entries)
235     : BasicHashtable&lt;F&gt;(table_size, entry_size, buckets, number_of_entries) { }
236 
237   // Debugging
238   void print()               PRODUCT_RETURN;
239 
240   unsigned int compute_hash(const Symbol* name) const {
241     return (unsigned int) name-&gt;identity_hash();
242   }
243 
244   int index_for(const Symbol* name) const {
245     return this-&gt;hash_to_index(compute_hash(name));
246   }
247 
248   void print_table_statistics(outputStream* st, const char *table_name, T (*literal_load_barrier)(HashtableEntry&lt;T, F&gt;*) = NULL);
249 
250  protected:
251 
252   // Table entry management
253   HashtableEntry&lt;T, F&gt;* new_entry(unsigned int hashValue, T obj);
254   // Don&#39;t create and use freelist of HashtableEntry.
255   HashtableEntry&lt;T, F&gt;* allocate_new_entry(unsigned int hashValue, T obj);
256 
257   // The following method is MT-safe and may be used with caution.
258   HashtableEntry&lt;T, F&gt;* bucket(int i) const {
259     return (HashtableEntry&lt;T, F&gt;*)BasicHashtable&lt;F&gt;::bucket(i);
260   }
261 
262   // The following method is not MT-safe and must be done under lock.
263   HashtableEntry&lt;T, F&gt;** bucket_addr(int i) {
264     return (HashtableEntry&lt;T, F&gt;**)BasicHashtable&lt;F&gt;::bucket_addr(i);
265   }
266 };
267 
268 // A subclass of BasicHashtable that allows you to do a simple K -&gt; V mapping
269 // without using tons of boilerplate code.
270 template&lt;
271     typename K, typename V, MEMFLAGS F,
272     unsigned (*HASH)  (K const&amp;)           = primitive_hash&lt;K&gt;,
273     bool     (*EQUALS)(K const&amp;, K const&amp;) = primitive_equals&lt;K&gt;
274     &gt;
275 class KVHashtable : public BasicHashtable&lt;F&gt; {
276   class KVHashtableEntry : public BasicHashtableEntry&lt;F&gt; {
277   public:
278     K _key;
279     V _value;
280     KVHashtableEntry* next() {
281       return (KVHashtableEntry*)BasicHashtableEntry&lt;F&gt;::next();
282     }
283   };
284 
285 protected:
286   KVHashtableEntry* bucket(int i) const {
287     return (KVHashtableEntry*)BasicHashtable&lt;F&gt;::bucket(i);
288   }
289 
290   KVHashtableEntry* new_entry(unsigned int hashValue, K key, V value) {
291     KVHashtableEntry* entry = (KVHashtableEntry*)BasicHashtable&lt;F&gt;::new_entry(hashValue);
292     entry-&gt;_key   = key;
293     entry-&gt;_value = value;
294     return entry;
295   }
296 
297 public:
298   KVHashtable(int table_size) : BasicHashtable&lt;F&gt;(table_size, sizeof(KVHashtableEntry)) {}
299 
300   void add(K key, V value) {
301     unsigned int hash = HASH(key);
302     KVHashtableEntry* entry = new_entry(hash, key, value);
303     BasicHashtable&lt;F&gt;::add_entry(BasicHashtable&lt;F&gt;::hash_to_index(hash), entry);
304   }
305 
306   V* lookup(K key) {
307     unsigned int hash = HASH(key);
308     int index = BasicHashtable&lt;F&gt;::hash_to_index(hash);
309     for (KVHashtableEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
310       if (e-&gt;hash() == hash &amp;&amp; e-&gt;_key == key) {
311         return &amp;(e-&gt;_value);
312       }
313     }
314     return NULL;
315   }
316 };
317 
318 
319 #endif // SHARE_UTILITIES_HASHTABLE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/growableArray.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_GROWABLEARRAY_HPP
 26 #define SHARE_UTILITIES_GROWABLEARRAY_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/oop.hpp&quot;
 30 #include &quot;utilities/debug.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 33 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 34 
 35 // A growable array.
 36 
 37 /*************************************************************************/
 38 /*                                                                       */
 39 /*     WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING   */
 40 /*                                                                       */
 41 /* Should you use GrowableArrays to contain handles you must be certain  */
 42 /* the the GrowableArray does not outlive the HandleMark that contains   */
 43 /* the handles. Since GrowableArrays are typically resource allocated    */
 44 /* the following is an example of INCORRECT CODE,                        */
 45 /*                                                                       */
 46 /* ResourceMark rm;                                                      */
 47 /* GrowableArray&lt;Handle&gt;* arr = new GrowableArray&lt;Handle&gt;(size);         */
 48 /* if (blah) {                                                           */
 49 /*    while (...) {                                                      */
 50 /*      HandleMark hm;                                                   */
 51 /*      ...                                                              */
 52 /*      Handle h(THREAD, some_oop);                                      */
 53 /*      arr-&gt;append(h);                                                  */
 54 /*    }                                                                  */
 55 /* }                                                                     */
 56 /* if (arr-&gt;length() != 0 ) {                                            */
 57 /*    oop bad_oop = arr-&gt;at(0)(); // Handle is BAD HERE.                 */
 58 /*    ...                                                                */
 59 /* }                                                                     */
 60 /*                                                                       */
 61 /* If the GrowableArrays you are creating is C_Heap allocated then it    */
 62 /* hould not old handles since the handles could trivially try and       */
 63 /* outlive their HandleMark. In some situations you might need to do     */
 64 /* this and it would be legal but be very careful and see if you can do  */
 65 /* the code in some other manner.                                        */
 66 /*                                                                       */
 67 /*************************************************************************/
 68 
 69 // To call default constructor the placement operator new() is used.
 70 // It should be empty (it only returns the passed void* pointer).
 71 // The definition of placement operator new(size_t, void*) in the &lt;new&gt;.
 72 
 73 #include &lt;new&gt;
 74 
 75 // Need the correct linkage to call qsort without warnings
 76 extern &quot;C&quot; {
 77   typedef int (*_sort_Fn)(const void *, const void *);
 78 }
 79 
 80 class GenericGrowableArray : public ResourceObj {
 81   friend class VMStructs;
 82 
 83  protected:
 84   int    _len;          // current length
 85   int    _max;          // maximum length
 86   Arena* _arena;        // Indicates where allocation occurs:
 87                         //   0 means default ResourceArea
 88                         //   1 means on C heap
 89                         //   otherwise, allocate in _arena
 90 
 91   MEMFLAGS   _memflags;   // memory type if allocation in C heap
 92 
 93 #ifdef ASSERT
 94   int    _nesting;      // resource area nesting at creation
 95   void   set_nesting();
 96   void   check_nesting();
 97 #else
 98 #define  set_nesting();
 99 #define  check_nesting();
100 #endif
101 
102   // Where are we going to allocate memory?
103   bool on_C_heap() { return _arena == (Arena*)1; }
104   bool on_stack () { return _arena == NULL;      }
105   bool on_arena () { return _arena &gt;  (Arena*)1;  }
106 
107   // This GA will use the resource stack for storage if c_heap==false,
108   // Else it will use the C heap.  Use clear_and_deallocate to avoid leaks.
109   GenericGrowableArray(int initial_size, int initial_len, bool c_heap, MEMFLAGS flags = mtNone) {
110     _len = initial_len;
111     _max = initial_size;
112     _memflags = flags;
113 
114     // memory type has to be specified for C heap allocation
115     assert(!(c_heap &amp;&amp; flags == mtNone), &quot;memory type not specified for C heap object&quot;);
116 
117     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);
118     _arena = (c_heap ? (Arena*)1 : NULL);
119     set_nesting();
120     assert(!on_C_heap() || allocated_on_C_heap(), &quot;growable array must be on C heap if elements are&quot;);
121     assert(!on_stack() ||
122            (allocated_on_res_area() || allocated_on_stack()),
123            &quot;growable array must be on stack if elements are not on arena and not on C heap&quot;);
124   }
125 
126   // This GA will use the given arena for storage.
127   // Consider using new(arena) GrowableArray&lt;T&gt; to allocate the header.
128   GenericGrowableArray(Arena* arena, int initial_size, int initial_len) {
129     _len = initial_len;
130     _max = initial_size;
131     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);
132     _arena = arena;
133     _memflags = mtNone;
134 
135     assert(on_arena(), &quot;arena has taken on reserved value 0 or 1&quot;);
136     // Relax next assert to allow object allocation on resource area,
137     // on stack or embedded into an other object.
138     assert(allocated_on_arena() || allocated_on_stack(),
139            &quot;growable array must be on arena or on stack if elements are on arena&quot;);
140   }
141 
142   void* raw_allocate(int elementSize);
143 
144   // some uses pass the Thread explicitly for speed (4990299 tuning)
145   void* raw_allocate(Thread* thread, int elementSize) {
146     assert(on_stack(), &quot;fast ResourceObj path only&quot;);
147     return (void*)resource_allocate_bytes(thread, elementSize * _max);
148   }
149 
150   void free_C_heap(void* elements);
151 };
152 
153 template&lt;class E&gt; class GrowableArrayIterator;
154 template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator;
155 
<a name="2" id="anc2"></a><span class="line-added">156 template&lt;class E&gt;</span>
<span class="line-added">157 class CompareClosure : public Closure {</span>
<span class="line-added">158 public:</span>
<span class="line-added">159     virtual int do_compare(const E&amp;, const E&amp;) = 0;</span>
<span class="line-added">160 };</span>
<span class="line-added">161 </span>
162 template&lt;class E&gt; class GrowableArray : public GenericGrowableArray {
163   friend class VMStructs;
164 
165  private:
166   E*     _data;         // data array
167 
168   void grow(int j);
169   void raw_at_put_grow(int i, const E&amp; p, const E&amp; fill);
170   void  clear_and_deallocate();
171  public:
172   GrowableArray(Thread* thread, int initial_size) : GenericGrowableArray(initial_size, 0, false) {
173     _data = (E*)raw_allocate(thread, sizeof(E));
174     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
175   }
176 
177   GrowableArray(int initial_size, bool C_heap = false, MEMFLAGS F = mtInternal)
178     : GenericGrowableArray(initial_size, 0, C_heap, F) {
179     _data = (E*)raw_allocate(sizeof(E));
180 // Needed for Visual Studio 2012 and older
181 #ifdef _MSC_VER
182 #pragma warning(suppress: 4345)
183 #endif
184     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
185   }
186 
187   GrowableArray(int initial_size, int initial_len, const E&amp; filler, bool C_heap = false, MEMFLAGS memflags = mtInternal)
188     : GenericGrowableArray(initial_size, initial_len, C_heap, memflags) {
189     _data = (E*)raw_allocate(sizeof(E));
190     int i = 0;
191     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
192     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
193   }
194 
<a name="3" id="anc3"></a><span class="line-modified">195   // Watch out, if filler was generated by a constructor, the destuctor might</span>
<span class="line-added">196   // be called on the original object invalidating all the copies made here.</span>
<span class="line-added">197   // Carefully design the copy constructor.</span>
<span class="line-added">198   GrowableArray(Arena* arena, int initial_size, int initial_len, const E&amp; filler) :</span>
<span class="line-added">199       GenericGrowableArray(arena, initial_size, initial_len) {</span>
200     _data = (E*)raw_allocate(sizeof(E));
201     int i = 0;
202     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
203     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
204   }
205 
206   GrowableArray() : GenericGrowableArray(2, 0, false) {
207     _data = (E*)raw_allocate(sizeof(E));
208     ::new ((void*)&amp;_data[0]) E();
209     ::new ((void*)&amp;_data[1]) E();
210   }
211 
212                                 // Does nothing for resource and arena objects
213   ~GrowableArray()              { if (on_C_heap()) clear_and_deallocate(); }
214 
215   void  clear()                 { _len = 0; }
216   int   length() const          { return _len; }
217   int   max_length() const      { return _max; }
218   void  trunc_to(int l)         { assert(l &lt;= _len,&quot;cannot increase length&quot;); _len = l; }
219   bool  is_empty() const        { return _len == 0; }
220   bool  is_nonempty() const     { return _len != 0; }
221   bool  is_full() const         { return _len == _max; }
222   DEBUG_ONLY(E* data_addr() const      { return _data; })
223 
224   void print();
225 
<a name="4" id="anc4"></a>








226   int append(const E&amp; elem) {
227     check_nesting();
228     if (_len == _max) grow(_len);
229     int idx = _len++;
230     _data[idx] = elem;
231     return idx;
232   }
233 
234   bool append_if_missing(const E&amp; elem) {
235     // Returns TRUE if elem is added.
236     bool missed = !contains(elem);
237     if (missed) append(elem);
238     return missed;
239   }
240 
241   E&amp; at(int i) {
242     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
243     return _data[i];
244   }
245 
246   E const&amp; at(int i) const {
247     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
248     return _data[i];
249   }
250 
251   E* adr_at(int i) const {
252     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
253     return &amp;_data[i];
254   }
255 
256   E first() const {
257     assert(_len &gt; 0, &quot;empty list&quot;);
258     return _data[0];
259   }
260 
261   E top() const {
262     assert(_len &gt; 0, &quot;empty list&quot;);
263     return _data[_len-1];
264   }
265 
266   E last() const {
267     return top();
268   }
269 
270   GrowableArrayIterator&lt;E&gt; begin() const {
271     return GrowableArrayIterator&lt;E&gt;(this, 0);
272   }
273 
274   GrowableArrayIterator&lt;E&gt; end() const {
275     return GrowableArrayIterator&lt;E&gt;(this, length());
276   }
277 
278   void push(const E&amp; elem) { append(elem); }
279 
280   E pop() {
281     assert(_len &gt; 0, &quot;empty list&quot;);
282     return _data[--_len];
283   }
284 
285   void at_put(int i, const E&amp; elem) {
286     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
287     _data[i] = elem;
288   }
289 
290   E at_grow(int i, const E&amp; fill = E()) {
291     assert(0 &lt;= i, &quot;negative index&quot;);
292     check_nesting();
293     if (i &gt;= _len) {
294       if (i &gt;= _max) grow(i);
295       for (int j = _len; j &lt;= i; j++)
296         _data[j] = fill;
297       _len = i+1;
298     }
299     return _data[i];
300   }
301 
302   void at_put_grow(int i, const E&amp; elem, const E&amp; fill = E()) {
303     assert(0 &lt;= i, &quot;negative index&quot;);
304     check_nesting();
305     raw_at_put_grow(i, elem, fill);
306   }
307 
308   bool contains(const E&amp; elem) const {
309     for (int i = 0; i &lt; _len; i++) {
<a name="5" id="anc5"></a><span class="line-modified">310       if (_data[i] == elem) return true;</span>
311     }
312     return false;
313   }
314 
315   int  find(const E&amp; elem) const {
316     for (int i = 0; i &lt; _len; i++) {
317       if (_data[i] == elem) return i;
318     }
319     return -1;
320   }
321 
322   int  find_from_end(const E&amp; elem) const {
323     for (int i = _len-1; i &gt;= 0; i--) {
324       if (_data[i] == elem) return i;
325     }
326     return -1;
327   }
328 
329   int  find(void* token, bool f(void*, E)) const {
330     for (int i = 0; i &lt; _len; i++) {
331       if (f(token, _data[i])) return i;
332     }
333     return -1;
334   }
335 
336   int  find_from_end(void* token, bool f(void*, E)) const {
337     // start at the end of the array
338     for (int i = _len-1; i &gt;= 0; i--) {
339       if (f(token, _data[i])) return i;
340     }
341     return -1;
342   }
343 
344   void remove(const E&amp; elem) {
345     for (int i = 0; i &lt; _len; i++) {
346       if (_data[i] == elem) {
347         for (int j = i + 1; j &lt; _len; j++) _data[j-1] = _data[j];
348         _len--;
349         return;
350       }
351     }
352     ShouldNotReachHere();
353   }
354 
355   // The order is preserved.
356   void remove_at(int index) {
357     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
358     for (int j = index + 1; j &lt; _len; j++) _data[j-1] = _data[j];
359     _len--;
360   }
361 
362   // The order is changed.
363   void delete_at(int index) {
364     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
365     if (index &lt; --_len) {
366       // Replace removed element with last one.
367       _data[index] = _data[_len];
368     }
369   }
370 
371   // inserts the given element before the element at index i
372   void insert_before(const int idx, const E&amp; elem) {
373     assert(0 &lt;= idx &amp;&amp; idx &lt;= _len, &quot;illegal index&quot;);
374     check_nesting();
375     if (_len == _max) grow(_len);
376     for (int j = _len - 1; j &gt;= idx; j--) {
377       _data[j + 1] = _data[j];
378     }
379     _len++;
380     _data[idx] = elem;
381   }
382 
383   void insert_before(const int idx, const GrowableArray&lt;E&gt;* array) {
384     assert(0 &lt;= idx &amp;&amp; idx &lt;= _len, &quot;illegal index&quot;);
385     check_nesting();
386     int array_len = array-&gt;length();
387     int new_len = _len + array_len;
388     if (new_len &gt;= _max) grow(new_len);
389 
390     for (int j = _len - 1; j &gt;= idx; j--) {
391       _data[j + array_len] = _data[j];
392     }
393 
394     for (int j = 0; j &lt; array_len; j++) {
395       _data[idx + j] = array-&gt;_data[j];
396     }
397 
398     _len += array_len;
399   }
400 
401   void appendAll(const GrowableArray&lt;E&gt;* l) {
402     for (int i = 0; i &lt; l-&gt;_len; i++) {
403       raw_at_put_grow(_len, l-&gt;_data[i], E());
404     }
405   }
406 
407   void sort(int f(E*,E*)) {
408     qsort(_data, length(), sizeof(E), (_sort_Fn)f);
409   }
410   // sort by fixed-stride sub arrays:
411   void sort(int f(E*,E*), int stride) {
412     qsort(_data, length() / stride, sizeof(E) * stride, (_sort_Fn)f);
413   }
414 
415   // Binary search and insertion utility.  Search array for element
416   // matching key according to the static compare function.  Insert
417   // that element is not already in the list.  Assumes the list is
418   // already sorted according to compare function.
419   template &lt;int compare(const E&amp;, const E&amp;)&gt; E insert_sorted(const E&amp; key) {
420     bool found;
421     int location = find_sorted&lt;E, compare&gt;(key, found);
422     if (!found) {
423       insert_before(location, key);
424     }
425     return at(location);
426   }
427 
428   template &lt;typename K, int compare(const K&amp;, const E&amp;)&gt; int find_sorted(const K&amp; key, bool&amp; found) {
429     found = false;
430     int min = 0;
431     int max = length() - 1;
432 
433     while (max &gt;= min) {
434       int mid = (int)(((uint)max + min) / 2);
435       E value = at(mid);
436       int diff = compare(key, value);
437       if (diff &gt; 0) {
438         min = mid + 1;
439       } else if (diff &lt; 0) {
440         max = mid - 1;
441       } else {
442         found = true;
443         return mid;
444       }
445     }
446     return min;
447   }
<a name="6" id="anc6"></a><span class="line-added">448 </span>
<span class="line-added">449   E insert_sorted(CompareClosure&lt;E&gt;* cc, const E&amp; key) {</span>
<span class="line-added">450     bool found;</span>
<span class="line-added">451     int location = find_sorted(cc, key, found);</span>
<span class="line-added">452     if (!found) {</span>
<span class="line-added">453       insert_before(location, key);</span>
<span class="line-added">454     }</span>
<span class="line-added">455     return at(location);</span>
<span class="line-added">456   }</span>
<span class="line-added">457 </span>
<span class="line-added">458   template&lt;typename K&gt;</span>
<span class="line-added">459   int find_sorted(CompareClosure&lt;E&gt;* cc, const K&amp; key, bool&amp; found) {</span>
<span class="line-added">460     found = false;</span>
<span class="line-added">461     int min = 0;</span>
<span class="line-added">462     int max = length() - 1;</span>
<span class="line-added">463 </span>
<span class="line-added">464     while (max &gt;= min) {</span>
<span class="line-added">465       int mid = (int)(((uint)max + min) / 2);</span>
<span class="line-added">466       E value = at(mid);</span>
<span class="line-added">467       int diff = cc-&gt;do_compare(key, value);</span>
<span class="line-added">468       if (diff &gt; 0) {</span>
<span class="line-added">469         min = mid + 1;</span>
<span class="line-added">470       } else if (diff &lt; 0) {</span>
<span class="line-added">471         max = mid - 1;</span>
<span class="line-added">472       } else {</span>
<span class="line-added">473         found = true;</span>
<span class="line-added">474         return mid;</span>
<span class="line-added">475       }</span>
<span class="line-added">476     }</span>
<span class="line-added">477     return min;</span>
<span class="line-added">478   }</span>
479 };
480 
481 // Global GrowableArray methods (one instance in the library per each &#39;E&#39; type).
482 
483 template&lt;class E&gt; void GrowableArray&lt;E&gt;::grow(int j) {
<a name="7" id="anc7"></a>
484     int old_max = _max;
<a name="8" id="anc8"></a><span class="line-modified">485     // grow the array by increasing _max to the first power of two larger than the size we need</span>
<span class="line-modified">486     _max = next_power_of_2((uint32_t)j);</span>
487     // j &lt; _max
488     E* newData = (E*)raw_allocate(sizeof(E));
489     int i = 0;
490     for (     ; i &lt; _len; i++) ::new ((void*)&amp;newData[i]) E(_data[i]);
491 // Needed for Visual Studio 2012 and older
492 #ifdef _MSC_VER
493 #pragma warning(suppress: 4345)
494 #endif
495     for (     ; i &lt; _max; i++) ::new ((void*)&amp;newData[i]) E();
496     for (i = 0; i &lt; old_max; i++) _data[i].~E();
497     if (on_C_heap() &amp;&amp; _data != NULL) {
498       free_C_heap(_data);
499     }
500     _data = newData;
501 }
502 
503 template&lt;class E&gt; void GrowableArray&lt;E&gt;::raw_at_put_grow(int i, const E&amp; p, const E&amp; fill) {
504     if (i &gt;= _len) {
505       if (i &gt;= _max) grow(i);
506       for (int j = _len; j &lt; i; j++)
507         _data[j] = fill;
508       _len = i+1;
509     }
510     _data[i] = p;
511 }
512 
513 // This function clears and deallocate the data in the growable array that
514 // has been allocated on the C heap.  It&#39;s not public - called by the
515 // destructor.
516 template&lt;class E&gt; void GrowableArray&lt;E&gt;::clear_and_deallocate() {
517     assert(on_C_heap(),
518            &quot;clear_and_deallocate should only be called when on C heap&quot;);
519     clear();
520     if (_data != NULL) {
521       for (int i = 0; i &lt; _max; i++) _data[i].~E();
522       free_C_heap(_data);
523       _data = NULL;
524     }
525 }
526 
527 template&lt;class E&gt; void GrowableArray&lt;E&gt;::print() {
528     tty-&gt;print(&quot;Growable Array &quot; INTPTR_FORMAT, this);
529     tty-&gt;print(&quot;: length %ld (_max %ld) { &quot;, _len, _max);
530     for (int i = 0; i &lt; _len; i++) tty-&gt;print(INTPTR_FORMAT &quot; &quot;, *(intptr_t*)&amp;(_data[i]));
531     tty-&gt;print(&quot;}\n&quot;);
532 }
533 
534 // Custom STL-style iterator to iterate over GrowableArrays
535 // It is constructed by invoking GrowableArray::begin() and GrowableArray::end()
536 template&lt;class E&gt; class GrowableArrayIterator : public StackObj {
537   friend class GrowableArray&lt;E&gt;;
538   template&lt;class F, class UnaryPredicate&gt; friend class GrowableArrayFilterIterator;
539 
540  private:
541   const GrowableArray&lt;E&gt;* _array; // GrowableArray we iterate over
542   int _position;                  // The current position in the GrowableArray
543 
544   // Private constructor used in GrowableArray::begin() and GrowableArray::end()
545   GrowableArrayIterator(const GrowableArray&lt;E&gt;* array, int position) : _array(array), _position(position) {
546     assert(0 &lt;= position &amp;&amp; position &lt;= _array-&gt;length(), &quot;illegal position&quot;);
547   }
548 
549  public:
550   GrowableArrayIterator() : _array(NULL), _position(0) { }
551   GrowableArrayIterator&lt;E&gt;&amp; operator++()  { ++_position; return *this; }
552   E operator*()                           { return _array-&gt;at(_position); }
553 
554   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
555     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
556     return _position == rhs._position;
557   }
558 
559   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
560     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
561     return _position != rhs._position;
562   }
563 };
564 
565 // Custom STL-style iterator to iterate over elements of a GrowableArray that satisfy a given predicate
566 template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator : public StackObj {
567   friend class GrowableArray&lt;E&gt;;
568 
569  private:
570   const GrowableArray&lt;E&gt;* _array;   // GrowableArray we iterate over
571   int _position;                    // Current position in the GrowableArray
572   UnaryPredicate _predicate;        // Unary predicate the elements of the GrowableArray should satisfy
573 
574  public:
575   GrowableArrayFilterIterator(const GrowableArrayIterator&lt;E&gt;&amp; begin, UnaryPredicate filter_predicate)
576    : _array(begin._array), _position(begin._position), _predicate(filter_predicate) {
577     // Advance to first element satisfying the predicate
578     while(_position != _array-&gt;length() &amp;&amp; !_predicate(_array-&gt;at(_position))) {
579       ++_position;
580     }
581   }
582 
583   GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; operator++() {
584     do {
585       // Advance to next element satisfying the predicate
586       ++_position;
587     } while(_position != _array-&gt;length() &amp;&amp; !_predicate(_array-&gt;at(_position)));
588     return *this;
589   }
590 
591   E operator*()   { return _array-&gt;at(_position); }
592 
593   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
594     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
595     return _position == rhs._position;
596   }
597 
598   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
599     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
600     return _position != rhs._position;
601   }
602 
603   bool operator==(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
604     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
605     return _position == rhs._position;
606   }
607 
608   bool operator!=(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
609     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
610     return _position != rhs._position;
611   }
612 };
613 
614 // Arrays for basic types
615 typedef GrowableArray&lt;int&gt; intArray;
616 typedef GrowableArray&lt;int&gt; intStack;
617 typedef GrowableArray&lt;bool&gt; boolArray;
618 
619 #endif // SHARE_UTILITIES_GROWABLEARRAY_HPP
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
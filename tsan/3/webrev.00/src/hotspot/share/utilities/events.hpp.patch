diff a/src/hotspot/share/utilities/events.hpp b/src/hotspot/share/utilities/events.hpp
--- a/src/hotspot/share/utilities/events.hpp
+++ b/src/hotspot/share/utilities/events.hpp
@@ -27,10 +27,12 @@
 
 #include "memory/allocation.hpp"
 #include "runtime/mutexLocker.hpp"
 #include "runtime/thread.hpp"
 #include "utilities/formatBuffer.hpp"
+#include "utilities/globalDefinitions.hpp"
+#include "utilities/ostream.hpp"
 #include "utilities/vmError.hpp"
 
 // Events and EventMark provide interfaces to log events taking place in the vm.
 // This facility is extremly useful for post-mortem debugging. The eventlog
 // often provides crucial information about events leading up to the crash.
@@ -57,11 +59,19 @@
  public:
   // Automatically registers the log so that it will be printed during
   // crashes.
   EventLog();
 
-  virtual void print_log_on(outputStream* out) = 0;
+  // Print log to output stream.
+  virtual void print_log_on(outputStream* out, int max = -1) = 0;
+
+  // Returns true if s matches either the log name or the log handle.
+  virtual bool matches_name_or_handle(const char* s) const = 0;
+
+  // Print log names (for help output of VM.events).
+  virtual void print_names(outputStream* out) const = 0;
+
 };
 
 
 // A templated subclass of EventLog that provides basic ring buffer
 // functionality.  Most event loggers should subclass this, possibly
@@ -76,20 +86,25 @@
     X       data;
   };
 
  protected:
   Mutex           _mutex;
+  // Name is printed out as a header.
   const char*     _name;
+  // Handle is a short specifier used to select this particular event log
+  // for printing (see VM.events command).
+  const char*     _handle;
   int             _length;
   int             _index;
   int             _count;
   EventRecord<T>* _records;
 
  public:
-  EventLogBase<T>(const char* name, int length = LogEventsBufferEntries):
-    _mutex(Mutex::event, name, false, Monitor::_safepoint_check_never),
+  EventLogBase<T>(const char* name, const char* handle, int length = LogEventsBufferEntries):
+    _mutex(Mutex::event, name, true, Mutex::_safepoint_check_never),
     _name(name),
+    _handle(handle),
     _length(length),
     _index(0),
     _count(0) {
     _records = new EventRecord<T>[length];
   }
@@ -114,14 +129,20 @@
     // avoids mutating the ring buffer when printing the log.
     return !VMError::fatal_error_in_progress();
   }
 
   // Print the contents of the log
-  void print_log_on(outputStream* out);
+  void print_log_on(outputStream* out, int max = -1);
+
+  // Returns true if s matches either the log name or the log handle.
+  bool matches_name_or_handle(const char* s) const;
+
+  // Print log names (for help output of VM.events).
+  void print_names(outputStream* out) const;
 
  private:
-  void print_log_impl(outputStream* out);
+  void print_log_impl(outputStream* out, int max = -1);
 
   // Print a single element.  A templated implementation might need to
   // be declared by subclasses.
   void print(outputStream* out, T& e);
 
@@ -135,30 +156,26 @@
 };
 
 // A simple wrapper class for fixed size text messages.
 template <size_t bufsz>
 class FormatStringLogMessage : public FormatBuffer<bufsz> {
- public:
-  // Wrap this buffer in a stringStream.
-  stringStream stream() {
-    return stringStream(this->_buf, this->size());
-  }
 };
 typedef FormatStringLogMessage<256> StringLogMessage;
 typedef FormatStringLogMessage<512> ExtendedStringLogMessage;
 
 // A simple ring buffer of fixed size text messages.
 template <size_t bufsz>
 class FormatStringEventLog : public EventLogBase< FormatStringLogMessage<bufsz> > {
  public:
-  FormatStringEventLog(const char* name, int count = LogEventsBufferEntries) : EventLogBase< FormatStringLogMessage<bufsz> >(name, count) {}
+  FormatStringEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)
+   : EventLogBase< FormatStringLogMessage<bufsz> >(name, short_name, count) {}
 
   void logv(Thread* thread, const char* format, va_list ap) ATTRIBUTE_PRINTF(3, 0) {
     if (!this->should_log()) return;
 
     double timestamp = this->fetch_timestamp();
-    MutexLockerEx ml(&this->_mutex, Mutex::_no_safepoint_check_flag);
+    MutexLocker ml(&this->_mutex, Mutex::_no_safepoint_check_flag);
     int index = this->compute_log_index();
     this->_records[index].thread = thread;
     this->_records[index].timestamp = timestamp;
     this->_records[index].data.printv(format, ap);
   }
@@ -176,19 +193,21 @@
 class InstanceKlass;
 
 // Event log for class unloading events to materialize the class name in place in the log stream.
 class UnloadingEventLog : public EventLogBase<StringLogMessage> {
  public:
-  UnloadingEventLog(const char* name, int count = LogEventsBufferEntries) : EventLogBase<StringLogMessage>(name, count) {}
+  UnloadingEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)
+   : EventLogBase<StringLogMessage>(name, short_name, count) {}
 
   void log(Thread* thread, InstanceKlass* ik);
 };
 
 // Event log for exceptions
 class ExceptionsEventLog : public ExtendedStringEventLog {
  public:
-  ExceptionsEventLog(const char* name, int count = LogEventsBufferEntries) : ExtendedStringEventLog(name, count) {}
+  ExceptionsEventLog(const char* name, const char* short_name, int count = LogEventsBufferEntries)
+   : ExtendedStringEventLog(name, short_name, count) {}
 
   void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
 };
 
 
@@ -212,11 +231,17 @@
   static StringEventLog* _redefinitions;
 
   // Class unloading events
   static UnloadingEventLog* _class_unloading;
  public:
-  static void print_all(outputStream* out);
+
+  // Print all event logs; limit number of events per event log to be printed with max
+  // (max == -1 prints all events).
+  static void print_all(outputStream* out, int max = -1);
+
+  // Print a single event log specified by name or handle.
+  static void print_one(outputStream* out, const char* log_name, int max = -1);
 
   // Dump all events to the tty
   static void print();
 
   // Logs a generic message with timestamp and format as printf.
@@ -235,91 +260,119 @@
   // Register default loggers
   static void init();
 };
 
 inline void Events::log(Thread* thread, const char* format, ...) {
-  if (LogEvents) {
+  if (LogEvents && _messages != NULL) {
     va_list ap;
     va_start(ap, format);
     _messages->logv(thread, format, ap);
     va_end(ap);
   }
 }
 
 inline void Events::log_exception(Thread* thread, const char* format, ...) {
-  if (LogEvents) {
+  if (LogEvents && _exceptions != NULL) {
     va_list ap;
     va_start(ap, format);
     _exceptions->logv(thread, format, ap);
     va_end(ap);
   }
 }
 
 inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {
-  if (LogEvents) {
+  if (LogEvents && _exceptions != NULL) {
     _exceptions->log(thread, h_exception, message, file, line);
   }
 }
 
 inline void Events::log_redefinition(Thread* thread, const char* format, ...) {
-  if (LogEvents) {
+  if (LogEvents && _redefinitions != NULL) {
     va_list ap;
     va_start(ap, format);
     _redefinitions->logv(thread, format, ap);
     va_end(ap);
   }
 }
 
 inline void Events::log_class_unloading(Thread* thread, InstanceKlass* ik) {
-  if (LogEvents) {
+  if (LogEvents && _class_unloading != NULL) {
     _class_unloading->log(thread, ik);
   }
 }
 
 inline void Events::log_deopt_message(Thread* thread, const char* format, ...) {
-  if (LogEvents) {
+  if (LogEvents && _deopt_messages != NULL) {
     va_list ap;
     va_start(ap, format);
     _deopt_messages->logv(thread, format, ap);
     va_end(ap);
   }
 }
 
-
 template <class T>
-inline void EventLogBase<T>::print_log_on(outputStream* out) {
+inline void EventLogBase<T>::print_log_on(outputStream* out, int max) {
   if (Thread::current_or_null() == NULL) {
     // Not yet attached? Don't try to use locking
-    print_log_impl(out);
+    print_log_impl(out, max);
   } else {
-    MutexLockerEx ml(&_mutex, Mutex::_no_safepoint_check_flag);
-    print_log_impl(out);
+    MutexLocker ml(&_mutex, Mutex::_no_safepoint_check_flag);
+    print_log_impl(out, max);
   }
 }
 
+template <class T>
+inline bool EventLogBase<T>::matches_name_or_handle(const char* s) const {
+  return ::strcasecmp(s, _name) == 0 ||
+         ::strcasecmp(s, _handle) == 0;
+}
+
+template <class T>
+inline void EventLogBase<T>::print_names(outputStream* out) const {
+  out->print("\"%s\" : %s", _handle, _name);
+}
+
 // Dump the ring buffer entries that current have entries.
 template <class T>
-inline void EventLogBase<T>::print_log_impl(outputStream* out) {
+inline void EventLogBase<T>::print_log_impl(outputStream* out, int max) {
   out->print_cr("%s (%d events):", _name, _count);
   if (_count == 0) {
     out->print_cr("No events");
     out->cr();
     return;
   }
 
+  int printed = 0;
   if (_count < _length) {
     for (int i = 0; i < _count; i++) {
+      if (max > 0 && printed == max) {
+        break;
+      }
       print(out, _records[i]);
+      printed ++;
     }
   } else {
     for (int i = _index; i < _length; i++) {
+      if (max > 0 && printed == max) {
+        break;
+      }
       print(out, _records[i]);
+      printed ++;
     }
     for (int i = 0; i < _index; i++) {
+      if (max > 0 && printed == max) {
+        break;
+      }
       print(out, _records[i]);
+      printed ++;
     }
   }
+
+  if (printed == max) {
+    out->print_cr("...(skipped)");
+  }
+
   out->cr();
 }
 
 // Implement a printing routine for the StringLogMessage
 template <>

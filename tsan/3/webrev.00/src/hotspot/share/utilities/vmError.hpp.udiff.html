<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/utilities/vmError.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vmError.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="waitBarrier.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/vmError.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -30,12 +30,10 @@</span>
  class Decoder;
  class frame;
  class VM_ReportJavaOutOfMemory;
  
  class VMError : public AllStatic {
<span class="udiff-line-removed">-   friend class VM_ReportJavaOutOfMemory;</span>
<span class="udiff-line-removed">-   friend class Decoder;</span>
    friend class VMStructs;
  
    static int         _id;               // Solaris/Linux signals: 0 - SIGRTMAX
                                          // Windows exceptions: 0xCxxxxxxx system errors
                                          //                     0x8xxxxxxx system warnings
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -63,11 +61,11 @@</span>
    static int         _current_step;
    static const char* _current_step_info;
  
    // Thread id of the first error. We must be able to handle native thread,
    // so use thread id instead of Thread* to identify thread.
<span class="udiff-line-modified-removed">-   static volatile intptr_t first_error_tid;</span>
<span class="udiff-line-modified-added">+   static volatile intptr_t _first_error_tid;</span>
  
    // Core dump status, false if we have been unable to write a core/minidump for some reason
    static bool coredump_status;
  
    // When coredump_status is set to true this will contain the name/path to the core/minidump,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133,10 +131,11 @@</span>
    // Accessors to get/set the start times for step and total timeout.
    static void record_reporting_start_time();
    static jlong get_reporting_start_time();
    static void record_step_start_time();
    static jlong get_step_start_time();
<span class="udiff-line-added">+   static void clear_step_start_time();</span>
  
  public:
  
    // return a string to describe the error
    static char* error_string(char* buf, int buflen);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -174,13 +173,13 @@</span>
    // returns original handler for signal, if it was resetted, or NULL if
    // signal was not changed by error reporter
    static address get_resetted_sighandler(int sig);
  
    // check to see if fatal error reporting is in progress
<span class="udiff-line-modified-removed">-   static bool fatal_error_in_progress() { return first_error_tid != -1; }</span>
<span class="udiff-line-modified-added">+   static bool fatal_error_in_progress() { return _first_error_tid != -1; }</span>
  
<span class="udiff-line-modified-removed">-   static intptr_t get_first_error_tid() { return first_error_tid; }</span>
<span class="udiff-line-modified-added">+   static intptr_t get_first_error_tid() { return _first_error_tid; }</span>
  
    // Called by the WatcherThread to check if error reporting has timed-out.
    //  Returns true if error reporting has not completed within the ErrorLogTimeout limit.
    static bool check_timeout();
  
</pre>
<center><a href="vmError.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="waitBarrier.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
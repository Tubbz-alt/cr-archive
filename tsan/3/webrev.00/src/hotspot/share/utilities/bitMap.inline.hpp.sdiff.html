<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/bitMap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bitMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compilerWarnings.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/bitMap.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_BITMAP_INLINE_HPP
 26 #define SHARE_UTILITIES_BITMAP_INLINE_HPP
 27 
 28 #include &quot;runtime/atomic.hpp&quot;

 29 #include &quot;utilities/bitMap.hpp&quot;
 30 #include &quot;utilities/count_trailing_zeros.hpp&quot;
 31 
 32 inline void BitMap::set_bit(idx_t bit) {
 33   verify_index(bit);
 34   *word_addr(bit) |= bit_mask(bit);
 35 }
 36 
 37 inline void BitMap::clear_bit(idx_t bit) {
 38   verify_index(bit);
 39   *word_addr(bit) &amp;= ~bit_mask(bit);
 40 }
 41 
<span class="line-modified"> 42 inline bool BitMap::par_set_bit(idx_t bit) {</span>





















 43   verify_index(bit);
 44   volatile bm_word_t* const addr = word_addr(bit);
 45   const bm_word_t mask = bit_mask(bit);
<span class="line-modified"> 46   bm_word_t old_val = *addr;</span>
 47 
 48   do {
 49     const bm_word_t new_val = old_val | mask;
 50     if (new_val == old_val) {
 51       return false;     // Someone else beat us to it.
 52     }
<span class="line-modified"> 53     const bm_word_t cur_val = Atomic::cmpxchg(new_val, addr, old_val);</span>
 54     if (cur_val == old_val) {
 55       return true;      // Success.
 56     }
 57     old_val = cur_val;  // The value changed, try again.
 58   } while (true);
 59 }
 60 
<span class="line-modified"> 61 inline bool BitMap::par_clear_bit(idx_t bit) {</span>
 62   verify_index(bit);
 63   volatile bm_word_t* const addr = word_addr(bit);
 64   const bm_word_t mask = ~bit_mask(bit);
<span class="line-modified"> 65   bm_word_t old_val = *addr;</span>
 66 
 67   do {
 68     const bm_word_t new_val = old_val &amp; mask;
 69     if (new_val == old_val) {
 70       return false;     // Someone else beat us to it.
 71     }
<span class="line-modified"> 72     const bm_word_t cur_val = Atomic::cmpxchg(new_val, addr, old_val);</span>
 73     if (cur_val == old_val) {
 74       return true;      // Success.
 75     }
 76     old_val = cur_val;  // The value changed, try again.
 77   } while (true);
 78 }
 79 
 80 inline void BitMap::set_range(idx_t beg, idx_t end, RangeSizeHint hint) {
 81   if (hint == small_range &amp;&amp; end - beg == 1) {
 82     set_bit(beg);
 83   } else {
 84     if (hint == large_range) {
 85       set_large_range(beg, end);
 86     } else {
 87       set_range(beg, end);
 88     }
 89   }
 90 }
 91 
 92 inline void BitMap::clear_range(idx_t beg, idx_t end, RangeSizeHint hint) {
</pre>
<hr />
<pre>
129 inline void BitMap::clear() {
130   clear_range_of_words(0, size_in_words());
131 }
132 
133 inline void BitMap::par_clear_range(idx_t beg, idx_t end, RangeSizeHint hint) {
134   if (hint == small_range &amp;&amp; end - beg == 1) {
135     par_at_put(beg, false);
136   } else {
137     if (hint == large_range) {
138       par_at_put_large_range(beg, end, false);
139     } else {
140       par_at_put_range(beg, end, false);
141     }
142   }
143 }
144 
145 template&lt;BitMap::bm_word_t flip, bool aligned_right&gt;
146 inline BitMap::idx_t BitMap::get_next_bit_impl(idx_t l_index, idx_t r_index) const {
147   STATIC_ASSERT(flip == find_ones_flip || flip == find_zeros_flip);
148   verify_range(l_index, r_index);
<span class="line-modified">149   assert(!aligned_right || is_word_aligned(r_index), &quot;r_index not aligned&quot;);</span>
150 
151   // The first word often contains an interesting bit, either due to
152   // density or because of features of the calling algorithm.  So it&#39;s
153   // important to examine that first word with a minimum of fuss,
154   // minimizing setup time for later words that will be wasted if the
155   // first word is indeed interesting.
156 
157   // The benefit from aligned_right being true is relatively small.
<span class="line-modified">158   // It saves a couple instructions in the setup for the word search</span>
<span class="line-modified">159   // loop.  It also eliminates the range check on the final result.</span>
160   // However, callers often have a comparison with r_index, and
161   // inlining often allows the two comparisons to be combined; it is
162   // important when !aligned_right that return paths either return
163   // r_index or a value dominated by a comparison with r_index.
164   // aligned_right is still helpful when the caller doesn&#39;t have a
165   // range check because features of the calling algorithm guarantee
166   // an interesting bit will be present.
167 
168   if (l_index &lt; r_index) {
169     // Get the word containing l_index, and shift out low bits.
<span class="line-modified">170     idx_t index = word_index(l_index);</span>
171     bm_word_t cword = (map(index) ^ flip) &gt;&gt; bit_in_word(l_index);
172     if ((cword &amp; 1) != 0) {
173       // The first bit is similarly often interesting. When it matters
174       // (density or features of the calling algorithm make it likely
175       // the first bit is set), going straight to the next clause compares
176       // poorly with doing this check first; count_trailing_zeros can be
177       // relatively expensive, plus there is the additional range check.
178       // But when the first bit isn&#39;t set, the cost of having tested for
179       // it is relatively small compared to the rest of the search.
180       return l_index;
181     } else if (cword != 0) {
182       // Flipped and shifted first word is non-zero.
183       idx_t result = l_index + count_trailing_zeros(cword);
184       if (aligned_right || (result &lt; r_index)) return result;
185       // Result is beyond range bound; return r_index.
186     } else {
187       // Flipped and shifted first word is zero.  Word search through
188       // aligned up r_index for a non-zero flipped word.
189       idx_t limit = aligned_right
<span class="line-modified">190         ? word_index(r_index)</span>
<span class="line-modified">191         : (word_index(r_index - 1) + 1); // Align up, knowing r_index &gt; 0.</span>
192       while (++index &lt; limit) {
193         cword = map(index) ^ flip;
194         if (cword != 0) {
195           idx_t result = bit_index(index) + count_trailing_zeros(cword);
196           if (aligned_right || (result &lt; r_index)) return result;
197           // Result is beyond range bound; return r_index.
198           assert((index + 1) == limit, &quot;invariant&quot;);
199           break;
200         }
201       }
202       // No bits in range; return r_index.
203     }
204   }
205   return r_index;
206 }
207 
208 inline BitMap::idx_t
209 BitMap::get_next_one_offset(idx_t l_offset, idx_t r_offset) const {
210   return get_next_bit_impl&lt;find_ones_flip, false&gt;(l_offset, r_offset);
211 }
212 
213 inline BitMap::idx_t
214 BitMap::get_next_zero_offset(idx_t l_offset, idx_t r_offset) const {
215   return get_next_bit_impl&lt;find_zeros_flip, false&gt;(l_offset, r_offset);
216 }
217 
218 inline BitMap::idx_t
219 BitMap::get_next_one_offset_aligned_right(idx_t l_offset, idx_t r_offset) const {
220   return get_next_bit_impl&lt;find_ones_flip, true&gt;(l_offset, r_offset);
221 }
222 
223 // Returns a bit mask for a range of bits [beg, end) within a single word.  Each
224 // bit in the mask is 0 if the bit is in the range, 1 if not in the range.  The
225 // returned mask can be used directly to clear the range, or inverted to set the
226 // range.  Note:  end must not be 0.
227 inline BitMap::bm_word_t
228 BitMap::inverted_bit_mask_for_range(idx_t beg, idx_t end) const {
229   assert(end != 0, &quot;does not work when end == 0&quot;);
<span class="line-modified">230   assert(beg == end || word_index(beg) == word_index(end - 1),</span>
231          &quot;must be a single-word range&quot;);
232   bm_word_t mask = bit_mask(beg) - 1;   // low (right) bits
233   if (bit_in_word(end) != 0) {
234     mask |= ~(bit_mask(end) - 1);       // high (left) bits
235   }
236   return mask;
237 }
238 
239 inline void BitMap::set_large_range_of_words(idx_t beg, idx_t end) {
240   assert(beg &lt;= end, &quot;underflow&quot;);
241   memset(_map + beg, ~(unsigned char)0, (end - beg) * sizeof(bm_word_t));
242 }
243 
244 inline void BitMap::clear_large_range_of_words(idx_t beg, idx_t end) {
245   assert(beg &lt;= end, &quot;underflow&quot;);
246   memset(_map + beg, 0, (end - beg) * sizeof(bm_word_t));
247 }
248 
<span class="line-removed">249 inline BitMap::idx_t BitMap::word_index_round_up(idx_t bit) const {</span>
<span class="line-removed">250   idx_t bit_rounded_up = bit + (BitsPerWord - 1);</span>
<span class="line-removed">251   // Check for integer arithmetic overflow.</span>
<span class="line-removed">252   return bit_rounded_up &gt; bit ? word_index(bit_rounded_up) : size_in_words();</span>
<span class="line-removed">253 }</span>
<span class="line-removed">254 </span>
255 inline bool BitMap2D::is_valid_index(idx_t slot_index, idx_t bit_within_slot_index) {
256   verify_bit_within_slot_index(bit_within_slot_index);
257   return (bit_index(slot_index, bit_within_slot_index) &lt; size_in_bits());
258 }
259 
260 inline bool BitMap2D::at(idx_t slot_index, idx_t bit_within_slot_index) const {
261   verify_bit_within_slot_index(bit_within_slot_index);
262   return _map.at(bit_index(slot_index, bit_within_slot_index));
263 }
264 
265 inline void BitMap2D::set_bit(idx_t slot_index, idx_t bit_within_slot_index) {
266   verify_bit_within_slot_index(bit_within_slot_index);
267   _map.set_bit(bit_index(slot_index, bit_within_slot_index));
268 }
269 
270 inline void BitMap2D::clear_bit(idx_t slot_index, idx_t bit_within_slot_index) {
271   verify_bit_within_slot_index(bit_within_slot_index);
272   _map.clear_bit(bit_index(slot_index, bit_within_slot_index));
273 }
274 
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_BITMAP_INLINE_HPP
 26 #define SHARE_UTILITIES_BITMAP_INLINE_HPP
 27 
 28 #include &quot;runtime/atomic.hpp&quot;
<span class="line-added"> 29 #include &quot;utilities/align.hpp&quot;</span>
 30 #include &quot;utilities/bitMap.hpp&quot;
 31 #include &quot;utilities/count_trailing_zeros.hpp&quot;
 32 
 33 inline void BitMap::set_bit(idx_t bit) {
 34   verify_index(bit);
 35   *word_addr(bit) |= bit_mask(bit);
 36 }
 37 
 38 inline void BitMap::clear_bit(idx_t bit) {
 39   verify_index(bit);
 40   *word_addr(bit) &amp;= ~bit_mask(bit);
 41 }
 42 
<span class="line-modified"> 43 inline const BitMap::bm_word_t BitMap::load_word_ordered(const volatile bm_word_t* const addr, atomic_memory_order memory_order) {</span>
<span class="line-added"> 44   if (memory_order == memory_order_relaxed || memory_order == memory_order_release) {</span>
<span class="line-added"> 45     return Atomic::load(addr);</span>
<span class="line-added"> 46   } else {</span>
<span class="line-added"> 47     assert(memory_order == memory_order_acq_rel ||</span>
<span class="line-added"> 48            memory_order == memory_order_acquire ||</span>
<span class="line-added"> 49            memory_order == memory_order_conservative,</span>
<span class="line-added"> 50            &quot;unexpected memory ordering&quot;);</span>
<span class="line-added"> 51     return Atomic::load_acquire(addr);</span>
<span class="line-added"> 52   }</span>
<span class="line-added"> 53 }</span>
<span class="line-added"> 54 </span>
<span class="line-added"> 55 inline bool BitMap::par_at(idx_t index, atomic_memory_order memory_order) const {</span>
<span class="line-added"> 56   verify_index(index);</span>
<span class="line-added"> 57   assert(memory_order == memory_order_acquire ||</span>
<span class="line-added"> 58          memory_order == memory_order_relaxed,</span>
<span class="line-added"> 59          &quot;unexpected memory ordering&quot;);</span>
<span class="line-added"> 60   const volatile bm_word_t* const addr = word_addr(index);</span>
<span class="line-added"> 61   return (load_word_ordered(addr, memory_order) &amp; bit_mask(index)) != 0;</span>
<span class="line-added"> 62 }</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64 inline bool BitMap::par_set_bit(idx_t bit, atomic_memory_order memory_order) {</span>
 65   verify_index(bit);
 66   volatile bm_word_t* const addr = word_addr(bit);
 67   const bm_word_t mask = bit_mask(bit);
<span class="line-modified"> 68   bm_word_t old_val = load_word_ordered(addr, memory_order);</span>
 69 
 70   do {
 71     const bm_word_t new_val = old_val | mask;
 72     if (new_val == old_val) {
 73       return false;     // Someone else beat us to it.
 74     }
<span class="line-modified"> 75     const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val, memory_order);</span>
 76     if (cur_val == old_val) {
 77       return true;      // Success.
 78     }
 79     old_val = cur_val;  // The value changed, try again.
 80   } while (true);
 81 }
 82 
<span class="line-modified"> 83 inline bool BitMap::par_clear_bit(idx_t bit, atomic_memory_order memory_order) {</span>
 84   verify_index(bit);
 85   volatile bm_word_t* const addr = word_addr(bit);
 86   const bm_word_t mask = ~bit_mask(bit);
<span class="line-modified"> 87   bm_word_t old_val = load_word_ordered(addr, memory_order);</span>
 88 
 89   do {
 90     const bm_word_t new_val = old_val &amp; mask;
 91     if (new_val == old_val) {
 92       return false;     // Someone else beat us to it.
 93     }
<span class="line-modified"> 94     const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val, memory_order);</span>
 95     if (cur_val == old_val) {
 96       return true;      // Success.
 97     }
 98     old_val = cur_val;  // The value changed, try again.
 99   } while (true);
100 }
101 
102 inline void BitMap::set_range(idx_t beg, idx_t end, RangeSizeHint hint) {
103   if (hint == small_range &amp;&amp; end - beg == 1) {
104     set_bit(beg);
105   } else {
106     if (hint == large_range) {
107       set_large_range(beg, end);
108     } else {
109       set_range(beg, end);
110     }
111   }
112 }
113 
114 inline void BitMap::clear_range(idx_t beg, idx_t end, RangeSizeHint hint) {
</pre>
<hr />
<pre>
151 inline void BitMap::clear() {
152   clear_range_of_words(0, size_in_words());
153 }
154 
155 inline void BitMap::par_clear_range(idx_t beg, idx_t end, RangeSizeHint hint) {
156   if (hint == small_range &amp;&amp; end - beg == 1) {
157     par_at_put(beg, false);
158   } else {
159     if (hint == large_range) {
160       par_at_put_large_range(beg, end, false);
161     } else {
162       par_at_put_range(beg, end, false);
163     }
164   }
165 }
166 
167 template&lt;BitMap::bm_word_t flip, bool aligned_right&gt;
168 inline BitMap::idx_t BitMap::get_next_bit_impl(idx_t l_index, idx_t r_index) const {
169   STATIC_ASSERT(flip == find_ones_flip || flip == find_zeros_flip);
170   verify_range(l_index, r_index);
<span class="line-modified">171   assert(!aligned_right || is_aligned(r_index, BitsPerWord), &quot;r_index not aligned&quot;);</span>
172 
173   // The first word often contains an interesting bit, either due to
174   // density or because of features of the calling algorithm.  So it&#39;s
175   // important to examine that first word with a minimum of fuss,
176   // minimizing setup time for later words that will be wasted if the
177   // first word is indeed interesting.
178 
179   // The benefit from aligned_right being true is relatively small.
<span class="line-modified">180   // It saves an operation in the setup for the word search loop.</span>
<span class="line-modified">181   // It also eliminates the range check on the final result.</span>
182   // However, callers often have a comparison with r_index, and
183   // inlining often allows the two comparisons to be combined; it is
184   // important when !aligned_right that return paths either return
185   // r_index or a value dominated by a comparison with r_index.
186   // aligned_right is still helpful when the caller doesn&#39;t have a
187   // range check because features of the calling algorithm guarantee
188   // an interesting bit will be present.
189 
190   if (l_index &lt; r_index) {
191     // Get the word containing l_index, and shift out low bits.
<span class="line-modified">192     idx_t index = to_words_align_down(l_index);</span>
193     bm_word_t cword = (map(index) ^ flip) &gt;&gt; bit_in_word(l_index);
194     if ((cword &amp; 1) != 0) {
195       // The first bit is similarly often interesting. When it matters
196       // (density or features of the calling algorithm make it likely
197       // the first bit is set), going straight to the next clause compares
198       // poorly with doing this check first; count_trailing_zeros can be
199       // relatively expensive, plus there is the additional range check.
200       // But when the first bit isn&#39;t set, the cost of having tested for
201       // it is relatively small compared to the rest of the search.
202       return l_index;
203     } else if (cword != 0) {
204       // Flipped and shifted first word is non-zero.
205       idx_t result = l_index + count_trailing_zeros(cword);
206       if (aligned_right || (result &lt; r_index)) return result;
207       // Result is beyond range bound; return r_index.
208     } else {
209       // Flipped and shifted first word is zero.  Word search through
210       // aligned up r_index for a non-zero flipped word.
211       idx_t limit = aligned_right
<span class="line-modified">212         ? to_words_align_down(r_index) // Miniscule savings when aligned.</span>
<span class="line-modified">213         : to_words_align_up(r_index);</span>
214       while (++index &lt; limit) {
215         cword = map(index) ^ flip;
216         if (cword != 0) {
217           idx_t result = bit_index(index) + count_trailing_zeros(cword);
218           if (aligned_right || (result &lt; r_index)) return result;
219           // Result is beyond range bound; return r_index.
220           assert((index + 1) == limit, &quot;invariant&quot;);
221           break;
222         }
223       }
224       // No bits in range; return r_index.
225     }
226   }
227   return r_index;
228 }
229 
230 inline BitMap::idx_t
231 BitMap::get_next_one_offset(idx_t l_offset, idx_t r_offset) const {
232   return get_next_bit_impl&lt;find_ones_flip, false&gt;(l_offset, r_offset);
233 }
234 
235 inline BitMap::idx_t
236 BitMap::get_next_zero_offset(idx_t l_offset, idx_t r_offset) const {
237   return get_next_bit_impl&lt;find_zeros_flip, false&gt;(l_offset, r_offset);
238 }
239 
240 inline BitMap::idx_t
241 BitMap::get_next_one_offset_aligned_right(idx_t l_offset, idx_t r_offset) const {
242   return get_next_bit_impl&lt;find_ones_flip, true&gt;(l_offset, r_offset);
243 }
244 
245 // Returns a bit mask for a range of bits [beg, end) within a single word.  Each
246 // bit in the mask is 0 if the bit is in the range, 1 if not in the range.  The
247 // returned mask can be used directly to clear the range, or inverted to set the
248 // range.  Note:  end must not be 0.
249 inline BitMap::bm_word_t
250 BitMap::inverted_bit_mask_for_range(idx_t beg, idx_t end) const {
251   assert(end != 0, &quot;does not work when end == 0&quot;);
<span class="line-modified">252   assert(beg == end || to_words_align_down(beg) == to_words_align_down(end - 1),</span>
253          &quot;must be a single-word range&quot;);
254   bm_word_t mask = bit_mask(beg) - 1;   // low (right) bits
255   if (bit_in_word(end) != 0) {
256     mask |= ~(bit_mask(end) - 1);       // high (left) bits
257   }
258   return mask;
259 }
260 
261 inline void BitMap::set_large_range_of_words(idx_t beg, idx_t end) {
262   assert(beg &lt;= end, &quot;underflow&quot;);
263   memset(_map + beg, ~(unsigned char)0, (end - beg) * sizeof(bm_word_t));
264 }
265 
266 inline void BitMap::clear_large_range_of_words(idx_t beg, idx_t end) {
267   assert(beg &lt;= end, &quot;underflow&quot;);
268   memset(_map + beg, 0, (end - beg) * sizeof(bm_word_t));
269 }
270 






271 inline bool BitMap2D::is_valid_index(idx_t slot_index, idx_t bit_within_slot_index) {
272   verify_bit_within_slot_index(bit_within_slot_index);
273   return (bit_index(slot_index, bit_within_slot_index) &lt; size_in_bits());
274 }
275 
276 inline bool BitMap2D::at(idx_t slot_index, idx_t bit_within_slot_index) const {
277   verify_bit_within_slot_index(bit_within_slot_index);
278   return _map.at(bit_index(slot_index, bit_within_slot_index));
279 }
280 
281 inline void BitMap2D::set_bit(idx_t slot_index, idx_t bit_within_slot_index) {
282   verify_bit_within_slot_index(bit_within_slot_index);
283   _map.set_bit(bit_index(slot_index, bit_within_slot_index));
284 }
285 
286 inline void BitMap2D::clear_bit(idx_t slot_index, idx_t bit_within_slot_index) {
287   verify_bit_within_slot_index(bit_within_slot_index);
288   _map.clear_bit(bit_index(slot_index, bit_within_slot_index));
289 }
290 
</pre>
</td>
</tr>
</table>
<center><a href="bitMap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compilerWarnings.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/concurrentHashTableTasks.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_CONCURRENTHASHTABLETASKS_INLINE_HPP
 26 #define SHARE_UTILITIES_CONCURRENTHASHTABLETASKS_INLINE_HPP
 27 
<a name="1" id="anc1"></a>
 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
 30 
 31 // This inline file contains BulkDeleteTask and GrowTasks which are both bucket
 32 // operations, which they are serialized with each other.
 33 
 34 // Base class for pause and/or parallel bulk operations.
<a name="2" id="anc2"></a><span class="line-modified"> 35 template &lt;typename VALUE, typename CONFIG, MEMFLAGS F&gt;</span>
<span class="line-modified"> 36 class ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;::BucketsOperation {</span>
 37  protected:
<a name="3" id="anc3"></a><span class="line-modified"> 38   ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* _cht;</span>
 39 
 40   // Default size of _task_size_log2
 41   static const size_t DEFAULT_TASK_SIZE_LOG2 = 12;
 42 
 43   // The table is split into ranges, every increment is one range.
 44   volatile size_t _next_to_claim;
 45   size_t _task_size_log2; // Number of buckets.
 46   size_t _stop_task;      // Last task
 47   size_t _size_log2;      // Table size.
 48   bool   _is_mt;
 49 
<a name="4" id="anc4"></a><span class="line-modified"> 50   BucketsOperation(ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* cht, bool is_mt = false)</span>
 51     : _cht(cht), _next_to_claim(0), _task_size_log2(DEFAULT_TASK_SIZE_LOG2),
 52     _stop_task(0), _size_log2(0), _is_mt(is_mt) {}
 53 
 54   // Returns true if you succeeded to claim the range start -&gt; (stop-1).
 55   bool claim(size_t* start, size_t* stop) {
<a name="5" id="anc5"></a><span class="line-modified"> 56     size_t claimed = Atomic::add((size_t)1, &amp;_next_to_claim) - 1;</span>
 57     if (claimed &gt;= _stop_task) {
 58       return false;
 59     }
 60     *start = claimed * (((size_t)1) &lt;&lt; _task_size_log2);
 61     *stop  = ((*start) + (((size_t)1) &lt;&lt; _task_size_log2));
 62     return true;
 63   }
 64 
 65   // Calculate starting values.
 66   void setup(Thread* thread) {
 67     thread_owns_resize_lock(thread);
 68     _size_log2 = _cht-&gt;_table-&gt;_log2_size;
 69     _task_size_log2 = MIN2(_task_size_log2, _size_log2);
 70     size_t tmp = _size_log2 &gt; _task_size_log2 ?
 71                  _size_log2 - _task_size_log2 : 0;
 72     _stop_task = (((size_t)1) &lt;&lt; tmp);
 73   }
 74 
 75   // Returns false if all ranges are claimed.
 76   bool have_more_work() {
<a name="6" id="anc6"></a><span class="line-modified"> 77     return OrderAccess::load_acquire(&amp;_next_to_claim) &gt;= _stop_task;</span>
 78   }
 79 
 80   void thread_owns_resize_lock(Thread* thread) {
 81     assert(BucketsOperation::_cht-&gt;_resize_lock_owner == thread,
 82            &quot;Should be locked by me&quot;);
 83     assert(BucketsOperation::_cht-&gt;_resize_lock-&gt;owned_by_self(),
 84            &quot;Operations lock not held&quot;);
 85   }
 86   void thread_owns_only_state_lock(Thread* thread) {
 87     assert(BucketsOperation::_cht-&gt;_resize_lock_owner == thread,
 88            &quot;Should be locked by me&quot;);
 89     assert(!BucketsOperation::_cht-&gt;_resize_lock-&gt;owned_by_self(),
 90            &quot;Operations lock held&quot;);
 91   }
 92   void thread_do_not_own_resize_lock(Thread* thread) {
 93     assert(!BucketsOperation::_cht-&gt;_resize_lock-&gt;owned_by_self(),
 94            &quot;Operations lock held&quot;);
 95     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != thread,
 96            &quot;Should not be locked by me&quot;);
 97   }
 98 
 99 public:
100   // Pauses for safepoint
101   void pause(Thread* thread) {
102     // This leaves internal state locked.
103     this-&gt;thread_owns_resize_lock(thread);
104     BucketsOperation::_cht-&gt;_resize_lock-&gt;unlock();
105     this-&gt;thread_owns_only_state_lock(thread);
106   }
107 
108   // Continues after safepoint.
109   void cont(Thread* thread) {
110     this-&gt;thread_owns_only_state_lock(thread);
111     // If someone slips in here directly after safepoint.
112     while (!BucketsOperation::_cht-&gt;_resize_lock-&gt;try_lock())
113       { /* for ever */ };
114     this-&gt;thread_owns_resize_lock(thread);
115   }
116 };
117 
118 // For doing pausable/parallel bulk delete.
<a name="7" id="anc7"></a><span class="line-modified">119 template &lt;typename VALUE, typename CONFIG, MEMFLAGS F&gt;</span>
<span class="line-modified">120 class ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;::BulkDeleteTask :</span>
121   public BucketsOperation
122 {
123  public:
<a name="8" id="anc8"></a><span class="line-modified">124   BulkDeleteTask(ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* cht, bool is_mt = false)</span>
125     : BucketsOperation(cht, is_mt) {
126   }
127   // Before start prepare must be called.
128   bool prepare(Thread* thread) {
129     bool lock = BucketsOperation::_cht-&gt;try_resize_lock(thread);
130     if (!lock) {
131       return false;
132     }
133     this-&gt;setup(thread);
134     return true;
135   }
136 
137   // Does one range destroying all matching EVALUATE_FUNC and
138   // DELETE_FUNC is called be destruction. Returns true if there is more work.
139   template &lt;typename EVALUATE_FUNC, typename DELETE_FUNC&gt;
140   bool do_task(Thread* thread, EVALUATE_FUNC&amp; eval_f, DELETE_FUNC&amp; del_f) {
141     size_t start, stop;
142     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != NULL,
143            &quot;Should be locked&quot;);
144     if (!this-&gt;claim(&amp;start, &amp;stop)) {
145       return false;
146     }
147     BucketsOperation::_cht-&gt;do_bulk_delete_locked_for(thread, start, stop,
148                                                       eval_f, del_f,
149                                                       BucketsOperation::_is_mt);
150     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != NULL,
151            &quot;Should be locked&quot;);
152     return true;
153   }
154 
155   // Must be called after ranges are done.
156   void done(Thread* thread) {
157     this-&gt;thread_owns_resize_lock(thread);
158     BucketsOperation::_cht-&gt;unlock_resize_lock(thread);
159     this-&gt;thread_do_not_own_resize_lock(thread);
160   }
161 };
162 
<a name="9" id="anc9"></a><span class="line-modified">163 template &lt;typename VALUE, typename CONFIG, MEMFLAGS F&gt;</span>
<span class="line-modified">164 class ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;::GrowTask :</span>
165   public BucketsOperation
166 {
167  public:
<a name="10" id="anc10"></a><span class="line-modified">168   GrowTask(ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* cht) : BucketsOperation(cht) {</span>
169   }
170   // Before start prepare must be called.
171   bool prepare(Thread* thread) {
172     if (!BucketsOperation::_cht-&gt;internal_grow_prolog(
173           thread, BucketsOperation::_cht-&gt;_log2_size_limit)) {
174       return false;
175     }
176     this-&gt;setup(thread);
177     return true;
178   }
179 
180   // Re-sizes a portion of the table. Returns true if there is more work.
181   bool do_task(Thread* thread) {
182     size_t start, stop;
183     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != NULL,
184            &quot;Should be locked&quot;);
185     if (!this-&gt;claim(&amp;start, &amp;stop)) {
186       return false;
187     }
188     BucketsOperation::_cht-&gt;internal_grow_range(thread, start, stop);
189     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != NULL,
190            &quot;Should be locked&quot;);
191     return true;
192   }
193 
194   // Must be called after do_task returns false.
195   void done(Thread* thread) {
196     this-&gt;thread_owns_resize_lock(thread);
197     BucketsOperation::_cht-&gt;internal_grow_epilog(thread);
198     this-&gt;thread_do_not_own_resize_lock(thread);
199   }
200 };
201 
202 #endif // SHARE_UTILITIES_CONCURRENTHASHTABLETASKS_INLINE_HPP
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
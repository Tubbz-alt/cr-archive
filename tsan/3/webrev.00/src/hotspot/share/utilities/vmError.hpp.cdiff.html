<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/vmError.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vmError.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="waitBarrier.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/vmError.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,12 ***</span>
  class Decoder;
  class frame;
  class VM_ReportJavaOutOfMemory;
  
  class VMError : public AllStatic {
<span class="line-removed">-   friend class VM_ReportJavaOutOfMemory;</span>
<span class="line-removed">-   friend class Decoder;</span>
    friend class VMStructs;
  
    static int         _id;               // Solaris/Linux signals: 0 - SIGRTMAX
                                          // Windows exceptions: 0xCxxxxxxx system errors
                                          //                     0x8xxxxxxx system warnings
<span class="line-new-header">--- 30,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,11 ***</span>
    static int         _current_step;
    static const char* _current_step_info;
  
    // Thread id of the first error. We must be able to handle native thread,
    // so use thread id instead of Thread* to identify thread.
<span class="line-modified">!   static volatile intptr_t first_error_tid;</span>
  
    // Core dump status, false if we have been unable to write a core/minidump for some reason
    static bool coredump_status;
  
    // When coredump_status is set to true this will contain the name/path to the core/minidump,
<span class="line-new-header">--- 61,11 ---</span>
    static int         _current_step;
    static const char* _current_step_info;
  
    // Thread id of the first error. We must be able to handle native thread,
    // so use thread id instead of Thread* to identify thread.
<span class="line-modified">!   static volatile intptr_t _first_error_tid;</span>
  
    // Core dump status, false if we have been unable to write a core/minidump for some reason
    static bool coredump_status;
  
    // When coredump_status is set to true this will contain the name/path to the core/minidump,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,10 ***</span>
<span class="line-new-header">--- 131,11 ---</span>
    // Accessors to get/set the start times for step and total timeout.
    static void record_reporting_start_time();
    static jlong get_reporting_start_time();
    static void record_step_start_time();
    static jlong get_step_start_time();
<span class="line-added">+   static void clear_step_start_time();</span>
  
  public:
  
    // return a string to describe the error
    static char* error_string(char* buf, int buflen);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,13 ***</span>
    // returns original handler for signal, if it was resetted, or NULL if
    // signal was not changed by error reporter
    static address get_resetted_sighandler(int sig);
  
    // check to see if fatal error reporting is in progress
<span class="line-modified">!   static bool fatal_error_in_progress() { return first_error_tid != -1; }</span>
  
<span class="line-modified">!   static intptr_t get_first_error_tid() { return first_error_tid; }</span>
  
    // Called by the WatcherThread to check if error reporting has timed-out.
    //  Returns true if error reporting has not completed within the ErrorLogTimeout limit.
    static bool check_timeout();
  
<span class="line-new-header">--- 173,13 ---</span>
    // returns original handler for signal, if it was resetted, or NULL if
    // signal was not changed by error reporter
    static address get_resetted_sighandler(int sig);
  
    // check to see if fatal error reporting is in progress
<span class="line-modified">!   static bool fatal_error_in_progress() { return _first_error_tid != -1; }</span>
  
<span class="line-modified">!   static intptr_t get_first_error_tid() { return _first_error_tid; }</span>
  
    // Called by the WatcherThread to check if error reporting has timed-out.
    //  Returns true if error reporting has not completed within the ErrorLogTimeout limit.
    static bool check_timeout();
  
</pre>
<center><a href="vmError.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="waitBarrier.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
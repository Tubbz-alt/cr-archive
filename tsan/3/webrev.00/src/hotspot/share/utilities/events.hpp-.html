<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/utilities/events.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_EVENTS_HPP
 26 #define SHARE_UTILITIES_EVENTS_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/mutexLocker.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 #include &quot;utilities/formatBuffer.hpp&quot;
 32 #include &quot;utilities/vmError.hpp&quot;
 33 
 34 // Events and EventMark provide interfaces to log events taking place in the vm.
 35 // This facility is extremly useful for post-mortem debugging. The eventlog
 36 // often provides crucial information about events leading up to the crash.
 37 //
 38 // Abstractly the logs can record whatever they way but normally they
 39 // would record at least a timestamp and the current Thread, along
 40 // with whatever data they need in a ring buffer.  Commonly fixed
 41 // length text messages are recorded for simplicity but other
 42 // strategies could be used.  Several logs are provided by default but
 43 // new instances can be created as needed.
 44 
 45 // The base event log dumping class that is registered for dumping at
 46 // crash time.  This is a very generic interface that is mainly here
 47 // for completeness.  Normally the templated EventLogBase would be
 48 // subclassed to provide different log types.
 49 class EventLog : public CHeapObj&lt;mtInternal&gt; {
 50   friend class Events;
 51 
 52  private:
 53   EventLog* _next;
 54 
 55   EventLog* next() const { return _next; }
 56 
 57  public:
 58   // Automatically registers the log so that it will be printed during
 59   // crashes.
 60   EventLog();
 61 
 62   virtual void print_log_on(outputStream* out) = 0;
 63 };
 64 
 65 
 66 // A templated subclass of EventLog that provides basic ring buffer
 67 // functionality.  Most event loggers should subclass this, possibly
 68 // providing a more featureful log function if the existing copy
 69 // semantics aren&#39;t appropriate.  The name is used as the label of the
 70 // log when it is dumped during a crash.
 71 template &lt;class T&gt; class EventLogBase : public EventLog {
 72   template &lt;class X&gt; class EventRecord : public CHeapObj&lt;mtInternal&gt; {
 73    public:
 74     double  timestamp;
 75     Thread* thread;
 76     X       data;
 77   };
 78 
 79  protected:
 80   Mutex           _mutex;
 81   const char*     _name;
 82   int             _length;
 83   int             _index;
 84   int             _count;
 85   EventRecord&lt;T&gt;* _records;
 86 
 87  public:
 88   EventLogBase&lt;T&gt;(const char* name, int length = LogEventsBufferEntries):
 89     _mutex(Mutex::event, name, false, Monitor::_safepoint_check_never),
 90     _name(name),
 91     _length(length),
 92     _index(0),
 93     _count(0) {
 94     _records = new EventRecord&lt;T&gt;[length];
 95   }
 96 
 97   double fetch_timestamp() {
 98     return os::elapsedTime();
 99   }
100 
101   // move the ring buffer to next open slot and return the index of
102   // the slot to use for the current message.  Should only be called
103   // while mutex is held.
104   int compute_log_index() {
105     int index = _index;
106     if (_count &lt; _length) _count++;
107     _index++;
108     if (_index &gt;= _length) _index = 0;
109     return index;
110   }
111 
112   bool should_log() {
113     // Don&#39;t bother adding new entries when we&#39;re crashing.  This also
114     // avoids mutating the ring buffer when printing the log.
115     return !VMError::fatal_error_in_progress();
116   }
117 
118   // Print the contents of the log
119   void print_log_on(outputStream* out);
120 
121  private:
122   void print_log_impl(outputStream* out);
123 
124   // Print a single element.  A templated implementation might need to
125   // be declared by subclasses.
126   void print(outputStream* out, T&amp; e);
127 
128   void print(outputStream* out, EventRecord&lt;T&gt;&amp; e) {
129     out-&gt;print(&quot;Event: %.3f &quot;, e.timestamp);
130     if (e.thread != NULL) {
131       out-&gt;print(&quot;Thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(e.thread));
132     }
133     print(out, e.data);
134   }
135 };
136 
137 // A simple wrapper class for fixed size text messages.
138 template &lt;size_t bufsz&gt;
139 class FormatStringLogMessage : public FormatBuffer&lt;bufsz&gt; {
140  public:
141   // Wrap this buffer in a stringStream.
142   stringStream stream() {
143     return stringStream(this-&gt;_buf, this-&gt;size());
144   }
145 };
146 typedef FormatStringLogMessage&lt;256&gt; StringLogMessage;
147 typedef FormatStringLogMessage&lt;512&gt; ExtendedStringLogMessage;
148 
149 // A simple ring buffer of fixed size text messages.
150 template &lt;size_t bufsz&gt;
151 class FormatStringEventLog : public EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt; {
152  public:
153   FormatStringEventLog(const char* name, int count = LogEventsBufferEntries) : EventLogBase&lt; FormatStringLogMessage&lt;bufsz&gt; &gt;(name, count) {}
154 
155   void logv(Thread* thread, const char* format, va_list ap) ATTRIBUTE_PRINTF(3, 0) {
156     if (!this-&gt;should_log()) return;
157 
158     double timestamp = this-&gt;fetch_timestamp();
159     MutexLockerEx ml(&amp;this-&gt;_mutex, Mutex::_no_safepoint_check_flag);
160     int index = this-&gt;compute_log_index();
161     this-&gt;_records[index].thread = thread;
162     this-&gt;_records[index].timestamp = timestamp;
163     this-&gt;_records[index].data.printv(format, ap);
164   }
165 
166   void log(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(3, 4) {
167     va_list ap;
168     va_start(ap, format);
169     this-&gt;logv(thread, format, ap);
170     va_end(ap);
171   }
172 };
173 typedef FormatStringEventLog&lt;256&gt; StringEventLog;
174 typedef FormatStringEventLog&lt;512&gt; ExtendedStringEventLog;
175 
176 class InstanceKlass;
177 
178 // Event log for class unloading events to materialize the class name in place in the log stream.
179 class UnloadingEventLog : public EventLogBase&lt;StringLogMessage&gt; {
180  public:
181   UnloadingEventLog(const char* name, int count = LogEventsBufferEntries) : EventLogBase&lt;StringLogMessage&gt;(name, count) {}
182 
183   void log(Thread* thread, InstanceKlass* ik);
184 };
185 
186 // Event log for exceptions
187 class ExceptionsEventLog : public ExtendedStringEventLog {
188  public:
189   ExceptionsEventLog(const char* name, int count = LogEventsBufferEntries) : ExtendedStringEventLog(name, count) {}
190 
191   void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
192 };
193 
194 
195 class Events : AllStatic {
196   friend class EventLog;
197 
198  private:
199   static EventLog* _logs;
200 
201   // A log for generic messages that aren&#39;t well categorized.
202   static StringEventLog* _messages;
203 
204   // A log for internal exception related messages, like internal
205   // throws and implicit exceptions.
206   static ExceptionsEventLog* _exceptions;
207 
208   // Deoptization related messages
209   static StringEventLog* _deopt_messages;
210 
211   // Redefinition related messages
212   static StringEventLog* _redefinitions;
213 
214   // Class unloading events
215   static UnloadingEventLog* _class_unloading;
216  public:
217   static void print_all(outputStream* out);
218 
219   // Dump all events to the tty
220   static void print();
221 
222   // Logs a generic message with timestamp and format as printf.
223   static void log(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
224 
225   // Log exception related message
226   static void log_exception(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
227   static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line);
228 
229   static void log_redefinition(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
230 
231   static void log_class_unloading(Thread* thread, InstanceKlass* ik);
232 
233   static void log_deopt_message(Thread* thread, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
234 
235   // Register default loggers
236   static void init();
237 };
238 
239 inline void Events::log(Thread* thread, const char* format, ...) {
240   if (LogEvents) {
241     va_list ap;
242     va_start(ap, format);
243     _messages-&gt;logv(thread, format, ap);
244     va_end(ap);
245   }
246 }
247 
248 inline void Events::log_exception(Thread* thread, const char* format, ...) {
249   if (LogEvents) {
250     va_list ap;
251     va_start(ap, format);
252     _exceptions-&gt;logv(thread, format, ap);
253     va_end(ap);
254   }
255 }
256 
257 inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {
258   if (LogEvents) {
259     _exceptions-&gt;log(thread, h_exception, message, file, line);
260   }
261 }
262 
263 inline void Events::log_redefinition(Thread* thread, const char* format, ...) {
264   if (LogEvents) {
265     va_list ap;
266     va_start(ap, format);
267     _redefinitions-&gt;logv(thread, format, ap);
268     va_end(ap);
269   }
270 }
271 
272 inline void Events::log_class_unloading(Thread* thread, InstanceKlass* ik) {
273   if (LogEvents) {
274     _class_unloading-&gt;log(thread, ik);
275   }
276 }
277 
278 inline void Events::log_deopt_message(Thread* thread, const char* format, ...) {
279   if (LogEvents) {
280     va_list ap;
281     va_start(ap, format);
282     _deopt_messages-&gt;logv(thread, format, ap);
283     va_end(ap);
284   }
285 }
286 
287 
288 template &lt;class T&gt;
289 inline void EventLogBase&lt;T&gt;::print_log_on(outputStream* out) {
290   if (Thread::current_or_null() == NULL) {
291     // Not yet attached? Don&#39;t try to use locking
292     print_log_impl(out);
293   } else {
294     MutexLockerEx ml(&amp;_mutex, Mutex::_no_safepoint_check_flag);
295     print_log_impl(out);
296   }
297 }
298 
299 // Dump the ring buffer entries that current have entries.
300 template &lt;class T&gt;
301 inline void EventLogBase&lt;T&gt;::print_log_impl(outputStream* out) {
302   out-&gt;print_cr(&quot;%s (%d events):&quot;, _name, _count);
303   if (_count == 0) {
304     out-&gt;print_cr(&quot;No events&quot;);
305     out-&gt;cr();
306     return;
307   }
308 
309   if (_count &lt; _length) {
310     for (int i = 0; i &lt; _count; i++) {
311       print(out, _records[i]);
312     }
313   } else {
314     for (int i = _index; i &lt; _length; i++) {
315       print(out, _records[i]);
316     }
317     for (int i = 0; i &lt; _index; i++) {
318       print(out, _records[i]);
319     }
320   }
321   out-&gt;cr();
322 }
323 
324 // Implement a printing routine for the StringLogMessage
325 template &lt;&gt;
326 inline void EventLogBase&lt;StringLogMessage&gt;::print(outputStream* out, StringLogMessage&amp; lm) {
327   out-&gt;print_raw(lm);
328   out-&gt;cr();
329 }
330 
331 // Implement a printing routine for the ExtendedStringLogMessage
332 template &lt;&gt;
333 inline void EventLogBase&lt;ExtendedStringLogMessage&gt;::print(outputStream* out, ExtendedStringLogMessage&amp; lm) {
334   out-&gt;print_raw(lm);
335   out-&gt;cr();
336 }
337 
338 // Place markers for the beginning and end up of a set of events.
339 // These end up in the default log.
340 class EventMark : public StackObj {
341   StringLogMessage _buffer;
342 
343  public:
344   // log a begin event, format as printf
345   EventMark(const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
346   // log an end event
347   ~EventMark();
348 };
349 
350 #endif // SHARE_UTILITIES_EVENTS_HPP
    </pre>
  </body>
</html>
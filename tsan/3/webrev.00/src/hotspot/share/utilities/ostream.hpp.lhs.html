<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/ostream.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_OSTREAM_HPP
 26 #define SHARE_UTILITIES_OSTREAM_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/timer.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 
 32 DEBUG_ONLY(class ResourceMark;)
 33 
 34 // Output streams for printing
 35 //
 36 // Printing guidelines:
 37 // Where possible, please use tty-&gt;print() and tty-&gt;print_cr().
 38 // For product mode VM warnings use warning() which internally uses tty.
 39 // In places where tty is not initialized yet or too much overhead,
 40 // we may use jio_printf:
 41 //     jio_fprintf(defaultStream::output_stream(), &quot;Message&quot;);
 42 // This allows for redirection via -XX:+DisplayVMOutputToStdout and
 43 // -XX:+DisplayVMOutputToStderr
 44 class outputStream : public ResourceObj {
<a name="1" id="anc1"></a>


 45  protected:
 46    int _indentation; // current indentation
 47    int _width;       // width of the page
 48    int _position;    // position on the current line
 49    int _newlines;    // number of &#39;\n&#39; output so far
 50    julong _precount; // number of chars output, less _position
 51    TimeStamp _stamp; // for time stamps
 52    char* _scratch;   // internal scratch buffer for printf
 53    size_t _scratch_len; // size of internal scratch buffer
 54 
 55    void update_position(const char* s, size_t len);
 56    static const char* do_vsnprintf(char* buffer, size_t buflen,
 57                                    const char* format, va_list ap,
 58                                    bool add_cr,
 59                                    size_t&amp; result_len)  ATTRIBUTE_PRINTF(3, 0);
 60 
 61    // calls do_vsnprintf and writes output to stream; uses an on-stack buffer.
 62    void do_vsnprintf_and_write_with_automatic_buffer(const char* format, va_list ap, bool add_cr) ATTRIBUTE_PRINTF(2, 0);
 63    // calls do_vsnprintf and writes output to stream; uses the user-provided buffer;
 64    void do_vsnprintf_and_write_with_scratch_buffer(const char* format, va_list ap, bool add_cr) ATTRIBUTE_PRINTF(2, 0);
 65    // calls do_vsnprintf, then writes output to stream.
 66    void do_vsnprintf_and_write(const char* format, va_list ap, bool add_cr) ATTRIBUTE_PRINTF(2, 0);
 67 
 68  public:
 69    // creation
 70    outputStream(int width = 80);
 71    outputStream(int width, bool has_time_stamps);
 72 
 73    // indentation
 74    outputStream&amp; indent();
 75    void inc() { _indentation++; };
 76    void dec() { _indentation--; };
 77    void inc(int n) { _indentation += n; };
 78    void dec(int n) { _indentation -= n; };
 79    int  indentation() const    { return _indentation; }
 80    void set_indentation(int i) { _indentation = i;    }
 81    void fill_to(int col);
 82    void move_to(int col, int slop = 6, int min_space = 2);
 83 
 84    // sizing
 85    int width()    const { return _width;    }
 86    int position() const { return _position; }
 87    int newlines() const { return _newlines; }
 88    julong count() const { return _precount + _position; }
 89    void set_count(julong count) { _precount = count - _position; }
 90    void set_position(int pos)   { _position = pos; }
 91 
 92    // printing
 93    void print(const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
 94    void print_cr(const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
 95    void vprint(const char *format, va_list argptr) ATTRIBUTE_PRINTF(2, 0);
 96    void vprint_cr(const char* format, va_list argptr) ATTRIBUTE_PRINTF(2, 0);
 97    void print_raw(const char* str)            { write(str, strlen(str)); }
 98    void print_raw(const char* str, int len)   { write(str,         len); }
 99    void print_raw_cr(const char* str)         { write(str, strlen(str)); cr(); }
100    void print_raw_cr(const char* str, int len){ write(str,         len); cr(); }
101    void print_data(void* data, size_t len, bool with_ascii);
102    void put(char ch);
103    void sp(int count = 1);
104    void cr();
105    void cr_indent();
106    void bol() { if (_position &gt; 0)  cr(); }
107 
108 
109    // Time stamp
110    TimeStamp&amp; time_stamp() { return _stamp; }
111    void stamp();
112    void stamp(bool guard, const char* prefix, const char* suffix);
113    void stamp(bool guard) {
114      stamp(guard, &quot;&quot;, &quot;: &quot;);
115    }
116    // Date stamp
117    void date_stamp(bool guard, const char* prefix, const char* suffix);
118    // A simplified call that includes a suffix of &quot;: &quot;
119    void date_stamp(bool guard) {
120      date_stamp(guard, &quot;&quot;, &quot;: &quot;);
121    }
122 
123    // portable printing of 64 bit integers
124    void print_jlong(jlong value);
125    void print_julong(julong value);
126 
127    // flushing
128    virtual void flush() {}
129    virtual void write(const char* str, size_t len) = 0;
130    virtual void rotate_log(bool force, outputStream* out = NULL) {} // GC log rotation
131    virtual ~outputStream() {}   // close properly on deletion
132 
133    // Caller may specify their own scratch buffer to use for printing; otherwise,
134    // an automatic buffer on the stack (with O_BUFLEN len) is used.
135    void set_scratch_buffer(char* p, size_t len) { _scratch = p; _scratch_len = len; }
136 
137    void dec_cr() { dec(); cr(); }
138    void inc_cr() { inc(); cr(); }
139 };
140 
141 // standard output
142 // ANSI C++ name collision
143 extern outputStream* tty;           // tty output
144 
145 class streamIndentor : public StackObj {
146  private:
147   outputStream* _str;
148   int _amount;
149 
150  public:
151   streamIndentor(outputStream* str, int amt = 2) : _str(str), _amount(amt) {
152     _str-&gt;inc(_amount);
153   }
154   ~streamIndentor() { _str-&gt;dec(_amount); }
155 };
156 
157 // advisory locking for the shared tty stream:
158 class ttyLocker: StackObj {
159   friend class ttyUnlocker;
160  private:
161   intx _holder;
162 
163  public:
164   static intx  hold_tty();                // returns a &quot;holder&quot; token
165   static void  release_tty(intx holder);  // must witness same token
166   static bool  release_tty_if_locked();   // returns true if lock was released
167   static void  break_tty_lock_for_safepoint(intx holder);
168 
169   ttyLocker()  { _holder = hold_tty(); }
170   ~ttyLocker() { release_tty(_holder); }
171 };
172 
173 // Release the tty lock if it&#39;s held and reacquire it if it was
174 // locked.  Used to avoid lock ordering problems.
175 class ttyUnlocker: StackObj {
176  private:
177   bool _was_locked;
178  public:
179   ttyUnlocker()  {
180     _was_locked = ttyLocker::release_tty_if_locked();
181   }
182   ~ttyUnlocker() {
183     if (_was_locked) {
184       ttyLocker::hold_tty();
185     }
186   }
187 };
188 
<a name="2" id="anc2"></a><span class="line-modified">189 // for writing to strings; buffer will expand automatically</span>

190 class stringStream : public outputStream {
191  protected:
192   char*  buffer;
193   size_t buffer_pos;
194   size_t buffer_length;
195   bool   buffer_fixed;
<a name="3" id="anc3"></a><span class="line-modified">196   DEBUG_ONLY(ResourceMark* rm;)</span>



197  public:
<a name="4" id="anc4"></a>

198   stringStream(size_t initial_bufsize = 256);
<a name="5" id="anc5"></a>

199   stringStream(char* fixed_buffer, size_t fixed_buffer_size);
200   ~stringStream();
201   virtual void write(const char* c, size_t len);
<a name="6" id="anc6"></a><span class="line-modified">202   size_t      size() { return buffer_pos; }</span>
<span class="line-modified">203   const char* base() { return buffer; }</span>
<span class="line-modified">204   void  reset() { buffer_pos = 0; _precount = 0; _position = 0; }</span>
<span class="line-modified">205   char* as_string();</span>


206 };
207 
208 class fileStream : public outputStream {
209  protected:
210   FILE* _file;
211   bool  _need_close;
212  public:
213   fileStream() { _file = NULL; _need_close = false; }
214   fileStream(const char* file_name);
215   fileStream(const char* file_name, const char* opentype);
216   fileStream(FILE* file, bool need_close = false) { _file = file; _need_close = need_close; }
217   ~fileStream();
218   bool is_open() const { return _file != NULL; }
219   virtual void write(const char* c, size_t len);
220   size_t read(void *data, size_t size, size_t count) { return ::fread(data, size, count, _file); }
221   char* readln(char *data, int count);
222   int eof() { return feof(_file); }
223   long fileSize();
224   void rewind() { ::rewind(_file); }
225   void flush();
226 };
227 
228 CDS_ONLY(extern fileStream*   classlist_file;)
229 
230 // unlike fileStream, fdStream does unbuffered I/O by calling
231 // open() and write() directly. It is async-safe, but output
232 // from multiple thread may be mixed together. Used by fatal
233 // error handler.
234 class fdStream : public outputStream {
235  protected:
236   int  _fd;
237  public:
238   fdStream(int fd = -1) : _fd(fd) { }
239   bool is_open() const { return _fd != -1; }
240   void set_fd(int fd) { _fd = fd; }
241   int fd() const { return _fd; }
242   virtual void write(const char* c, size_t len);
243   void flush() {};
244 };
245 
246 void ostream_init();
247 void ostream_init_log();
248 void ostream_exit();
249 void ostream_abort();
250 
251 // In the non-fixed buffer case an underlying buffer will be created and
252 // managed in C heap. Not MT-safe.
253 class bufferedStream : public outputStream {
254  protected:
255   char*  buffer;
256   size_t buffer_pos;
257   size_t buffer_max;
258   size_t buffer_length;
259   bool   buffer_fixed;
<a name="7" id="anc7"></a>
260  public:
261   bufferedStream(size_t initial_bufsize = 256, size_t bufmax = 1024*1024*10);
262   bufferedStream(char* fixed_buffer, size_t fixed_buffer_size, size_t bufmax = 1024*1024*10);
263   ~bufferedStream();
264   virtual void write(const char* c, size_t len);
265   size_t      size() { return buffer_pos; }
266   const char* base() { return buffer; }
267   void  reset() { buffer_pos = 0; _precount = 0; _position = 0; }
268   char* as_string();
269 };
270 
271 #define O_BUFLEN 2000   // max size of output of individual print() methods
272 
273 #ifndef PRODUCT
274 
275 class networkStream : public bufferedStream {
276 
277   private:
278     int _socket;
279 
280   public:
281     networkStream();
282     ~networkStream();
283 
284     bool connect(const char *host, short port);
285     bool is_open() const { return _socket != -1; }
286     int read(char *buf, size_t len);
287     void close();
288     virtual void flush();
289 };
290 
291 #endif
292 
293 #endif // SHARE_UTILITIES_OSTREAM_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
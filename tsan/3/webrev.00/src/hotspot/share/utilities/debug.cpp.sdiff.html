<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/debug.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="count_leading_zeros.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debug.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/debug.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
306   report_vm_error(file, line, &quot;ShouldNotReachHere()&quot;);
307 }
308 
309 void report_unimplemented(const char* file, int line) {
310   report_vm_error(file, line, &quot;Unimplemented()&quot;);
311 }
312 
313 void report_untested(const char* file, int line, const char* message) {
314 #ifndef PRODUCT
315   warning(&quot;Untested: %s in %s: %d\n&quot;, message, file, line);
316 #endif // !PRODUCT
317 }
318 
319 void report_java_out_of_memory(const char* message) {
320   static int out_of_memory_reported = 0;
321 
322   // A number of threads may attempt to report OutOfMemoryError at around the
323   // same time. To avoid dumping the heap or executing the data collection
324   // commands multiple times we just do it once when the first threads reports
325   // the error.
<span class="line-modified">326   if (Atomic::cmpxchg(1, &amp;out_of_memory_reported, 0) == 0) {</span>
327     // create heap dump before OnOutOfMemoryError commands are executed
328     if (HeapDumpOnOutOfMemoryError) {
329       tty-&gt;print_cr(&quot;java.lang.OutOfMemoryError: %s&quot;, message);
330       HeapDumper::dump_heap_from_oome();
331     }
332 
333     if (OnOutOfMemoryError &amp;&amp; OnOutOfMemoryError[0]) {
334       VMError::report_java_out_of_memory(message);
335     }
336 
337     if (CrashOnOutOfMemoryError) {
338       tty-&gt;print_cr(&quot;Aborting due to java.lang.OutOfMemoryError: %s&quot;, message);
339       fatal(&quot;OutOfMemory encountered: %s&quot;, message);
340     }
341 
342     if (ExitOnOutOfMemoryError) {
343       tty-&gt;print_cr(&quot;Terminating due to java.lang.OutOfMemoryError: %s&quot;, message);
344       os::exit(3);
345     }
346   }
</pre>
<hr />
<pre>
625 }
626 
627 // int versions of all methods to avoid having to type type casts in the debugger
628 
629 void pp(intptr_t p)          { pp((void*)p); }
630 void pp(oop p)               { pp((void*)p); }
631 
632 void help() {
633   Command c(&quot;help&quot;);
634   tty-&gt;print_cr(&quot;basic&quot;);
635   tty-&gt;print_cr(&quot;  pp(void* p)   - try to make sense of p&quot;);
636   tty-&gt;print_cr(&quot;  pv(intptr_t p)- ((PrintableResourceObj*) p)-&gt;print()&quot;);
637   tty-&gt;print_cr(&quot;  ps()          - print current thread stack&quot;);
638   tty-&gt;print_cr(&quot;  pss()         - print all thread stacks&quot;);
639   tty-&gt;print_cr(&quot;  pm(int pc)    - print Method* given compiled PC&quot;);
640   tty-&gt;print_cr(&quot;  findm(intptr_t pc) - finds Method*&quot;);
641   tty-&gt;print_cr(&quot;  find(intptr_t x)   - finds &amp; prints nmethod/stub/bytecode/oop based on pointer into it&quot;);
642   tty-&gt;print_cr(&quot;  pns(void* sp, void* fp, void* pc)  - print native (i.e. mixed) stack trace. E.g.&quot;);
643   tty-&gt;print_cr(&quot;                   pns($sp, $rbp, $pc) on Linux/amd64 and Solaris/amd64 or&quot;);
644   tty-&gt;print_cr(&quot;                   pns($sp, $ebp, $pc) on Linux/x86 or&quot;);

645   tty-&gt;print_cr(&quot;                   pns($sp, 0, $pc)    on Linux/ppc64 or&quot;);
646   tty-&gt;print_cr(&quot;                   pns($sp, $s8, $pc)  on Linux/mips or&quot;);
647   tty-&gt;print_cr(&quot;                   pns($sp + 0x7ff, 0, $pc) on Solaris/SPARC&quot;);
648   tty-&gt;print_cr(&quot;                 - in gdb do &#39;set overload-resolution off&#39; before calling pns()&quot;);
649   tty-&gt;print_cr(&quot;                 - in dbx do &#39;frame 1&#39; before calling pns()&quot;);
650 
651   tty-&gt;print_cr(&quot;misc.&quot;);
652   tty-&gt;print_cr(&quot;  flush()       - flushes the log file&quot;);
653   tty-&gt;print_cr(&quot;  events()      - dump events from ring buffers&quot;);
654 
655 
656   tty-&gt;print_cr(&quot;compiler debugging&quot;);
657   tty-&gt;print_cr(&quot;  debug()       - to set things up for compiler debugging&quot;);
658   tty-&gt;print_cr(&quot;  ndebug()      - undo debug&quot;);
659 }
660 
661 extern &quot;C&quot; void pns(void* sp, void* fp, void* pc) { // print native stack
662   Command c(&quot;pns&quot;);
663   static char buf[O_BUFLEN];
664   Thread* t = Thread::current_or_null();
</pre>
<hr />
<pre>
717 };
718 
719 #endif // !PRODUCT
720 
721 // Support for showing register content on asserts/guarantees.
722 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
723 
724 static ucontext_t g_stored_assertion_context;
725 
726 void initialize_assert_poison() {
727   char* page = os::reserve_memory(os::vm_page_size());
728   if (page) {
729     MemTracker::record_virtual_memory_type(page, mtInternal);
730     if (os::commit_memory(page, os::vm_page_size(), false) &amp;&amp;
731         os::protect_memory(page, os::vm_page_size(), os::MEM_PROT_NONE)) {
732       g_assert_poison = page;
733     }
734   }
735 }
736 




737 static void store_context(const void* context) {
738   memcpy(&amp;g_stored_assertion_context, context, sizeof(ucontext_t));
739 #if defined(__linux) &amp;&amp; defined(PPC64)
740   // on Linux ppc64, ucontext_t contains pointers into itself which have to be patched up
741   //  after copying the context (see comment in sys/ucontext.h):
742   *((void**) &amp;g_stored_assertion_context.uc_mcontext.regs) = &amp;(g_stored_assertion_context.uc_mcontext.gp_regs);
743 #endif
744 }
745 
746 bool handle_assert_poison_fault(const void* ucVoid, const void* faulting_address) {
747   if (faulting_address == g_assert_poison) {
748     // Disarm poison page.
<span class="line-modified">749     os::protect_memory((char*)g_assert_poison, os::vm_page_size(), os::MEM_PROT_RWX);</span>







750     // Store Context away.
751     if (ucVoid) {
752       const intx my_tid = os::current_thread_id();
<span class="line-modified">753       if (Atomic::cmpxchg(my_tid, &amp;g_asserting_thread, (intx)0) == 0) {</span>
754         store_context(ucVoid);
755         g_assertion_context = &amp;g_stored_assertion_context;
756       }
757     }
758     return true;
759   }
760   return false;
761 }
762 #endif // CAN_SHOW_REGISTERS_ON_ASSERT
<span class="line-removed">763 </span>
</pre>
</td>
<td>
<hr />
<pre>
306   report_vm_error(file, line, &quot;ShouldNotReachHere()&quot;);
307 }
308 
309 void report_unimplemented(const char* file, int line) {
310   report_vm_error(file, line, &quot;Unimplemented()&quot;);
311 }
312 
313 void report_untested(const char* file, int line, const char* message) {
314 #ifndef PRODUCT
315   warning(&quot;Untested: %s in %s: %d\n&quot;, message, file, line);
316 #endif // !PRODUCT
317 }
318 
319 void report_java_out_of_memory(const char* message) {
320   static int out_of_memory_reported = 0;
321 
322   // A number of threads may attempt to report OutOfMemoryError at around the
323   // same time. To avoid dumping the heap or executing the data collection
324   // commands multiple times we just do it once when the first threads reports
325   // the error.
<span class="line-modified">326   if (Atomic::cmpxchg(&amp;out_of_memory_reported, 0, 1) == 0) {</span>
327     // create heap dump before OnOutOfMemoryError commands are executed
328     if (HeapDumpOnOutOfMemoryError) {
329       tty-&gt;print_cr(&quot;java.lang.OutOfMemoryError: %s&quot;, message);
330       HeapDumper::dump_heap_from_oome();
331     }
332 
333     if (OnOutOfMemoryError &amp;&amp; OnOutOfMemoryError[0]) {
334       VMError::report_java_out_of_memory(message);
335     }
336 
337     if (CrashOnOutOfMemoryError) {
338       tty-&gt;print_cr(&quot;Aborting due to java.lang.OutOfMemoryError: %s&quot;, message);
339       fatal(&quot;OutOfMemory encountered: %s&quot;, message);
340     }
341 
342     if (ExitOnOutOfMemoryError) {
343       tty-&gt;print_cr(&quot;Terminating due to java.lang.OutOfMemoryError: %s&quot;, message);
344       os::exit(3);
345     }
346   }
</pre>
<hr />
<pre>
625 }
626 
627 // int versions of all methods to avoid having to type type casts in the debugger
628 
629 void pp(intptr_t p)          { pp((void*)p); }
630 void pp(oop p)               { pp((void*)p); }
631 
632 void help() {
633   Command c(&quot;help&quot;);
634   tty-&gt;print_cr(&quot;basic&quot;);
635   tty-&gt;print_cr(&quot;  pp(void* p)   - try to make sense of p&quot;);
636   tty-&gt;print_cr(&quot;  pv(intptr_t p)- ((PrintableResourceObj*) p)-&gt;print()&quot;);
637   tty-&gt;print_cr(&quot;  ps()          - print current thread stack&quot;);
638   tty-&gt;print_cr(&quot;  pss()         - print all thread stacks&quot;);
639   tty-&gt;print_cr(&quot;  pm(int pc)    - print Method* given compiled PC&quot;);
640   tty-&gt;print_cr(&quot;  findm(intptr_t pc) - finds Method*&quot;);
641   tty-&gt;print_cr(&quot;  find(intptr_t x)   - finds &amp; prints nmethod/stub/bytecode/oop based on pointer into it&quot;);
642   tty-&gt;print_cr(&quot;  pns(void* sp, void* fp, void* pc)  - print native (i.e. mixed) stack trace. E.g.&quot;);
643   tty-&gt;print_cr(&quot;                   pns($sp, $rbp, $pc) on Linux/amd64 and Solaris/amd64 or&quot;);
644   tty-&gt;print_cr(&quot;                   pns($sp, $ebp, $pc) on Linux/x86 or&quot;);
<span class="line-added">645   tty-&gt;print_cr(&quot;                   pns($sp, $fp, $pc)  on Linux/AArch64 or&quot;);</span>
646   tty-&gt;print_cr(&quot;                   pns($sp, 0, $pc)    on Linux/ppc64 or&quot;);
647   tty-&gt;print_cr(&quot;                   pns($sp, $s8, $pc)  on Linux/mips or&quot;);
648   tty-&gt;print_cr(&quot;                   pns($sp + 0x7ff, 0, $pc) on Solaris/SPARC&quot;);
649   tty-&gt;print_cr(&quot;                 - in gdb do &#39;set overload-resolution off&#39; before calling pns()&quot;);
650   tty-&gt;print_cr(&quot;                 - in dbx do &#39;frame 1&#39; before calling pns()&quot;);
651 
652   tty-&gt;print_cr(&quot;misc.&quot;);
653   tty-&gt;print_cr(&quot;  flush()       - flushes the log file&quot;);
654   tty-&gt;print_cr(&quot;  events()      - dump events from ring buffers&quot;);
655 
656 
657   tty-&gt;print_cr(&quot;compiler debugging&quot;);
658   tty-&gt;print_cr(&quot;  debug()       - to set things up for compiler debugging&quot;);
659   tty-&gt;print_cr(&quot;  ndebug()      - undo debug&quot;);
660 }
661 
662 extern &quot;C&quot; void pns(void* sp, void* fp, void* pc) { // print native stack
663   Command c(&quot;pns&quot;);
664   static char buf[O_BUFLEN];
665   Thread* t = Thread::current_or_null();
</pre>
<hr />
<pre>
718 };
719 
720 #endif // !PRODUCT
721 
722 // Support for showing register content on asserts/guarantees.
723 #ifdef CAN_SHOW_REGISTERS_ON_ASSERT
724 
725 static ucontext_t g_stored_assertion_context;
726 
727 void initialize_assert_poison() {
728   char* page = os::reserve_memory(os::vm_page_size());
729   if (page) {
730     MemTracker::record_virtual_memory_type(page, mtInternal);
731     if (os::commit_memory(page, os::vm_page_size(), false) &amp;&amp;
732         os::protect_memory(page, os::vm_page_size(), os::MEM_PROT_NONE)) {
733       g_assert_poison = page;
734     }
735   }
736 }
737 
<span class="line-added">738 void disarm_assert_poison() {</span>
<span class="line-added">739   g_assert_poison = &amp;g_dummy;</span>
<span class="line-added">740 }</span>
<span class="line-added">741 </span>
742 static void store_context(const void* context) {
743   memcpy(&amp;g_stored_assertion_context, context, sizeof(ucontext_t));
744 #if defined(__linux) &amp;&amp; defined(PPC64)
745   // on Linux ppc64, ucontext_t contains pointers into itself which have to be patched up
746   //  after copying the context (see comment in sys/ucontext.h):
747   *((void**) &amp;g_stored_assertion_context.uc_mcontext.regs) = &amp;(g_stored_assertion_context.uc_mcontext.gp_regs);
748 #endif
749 }
750 
751 bool handle_assert_poison_fault(const void* ucVoid, const void* faulting_address) {
752   if (faulting_address == g_assert_poison) {
753     // Disarm poison page.
<span class="line-modified">754     if (os::protect_memory((char*)g_assert_poison, os::vm_page_size(), os::MEM_PROT_RWX) == false) {</span>
<span class="line-added">755 #ifdef ASSERT</span>
<span class="line-added">756       fprintf(stderr, &quot;Assertion poison page cannot be unprotected - mprotect failed with %d (%s)&quot;,</span>
<span class="line-added">757               errno, os::strerror(errno));</span>
<span class="line-added">758       fflush(stderr);</span>
<span class="line-added">759 #endif</span>
<span class="line-added">760       return false; // unprotecting memory may fail in OOM situations, as surprising as this sounds.</span>
<span class="line-added">761     }</span>
762     // Store Context away.
763     if (ucVoid) {
764       const intx my_tid = os::current_thread_id();
<span class="line-modified">765       if (Atomic::cmpxchg(&amp;g_asserting_thread, (intx)0, my_tid) == 0) {</span>
766         store_context(ucVoid);
767         g_assertion_context = &amp;g_stored_assertion_context;
768       }
769     }
770     return true;
771   }
772   return false;
773 }
774 #endif // CAN_SHOW_REGISTERS_ON_ASSERT

</pre>
</td>
</tr>
</table>
<center><a href="count_leading_zeros.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debug.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/waitBarrier_generic.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="waitBarrier.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="waitBarrier_generic.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/waitBarrier_generic.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
31 
32 void GenericWaitBarrier::arm(int barrier_tag) {
33   assert(_barrier_tag == 0, &quot;Already armed&quot;);
34   assert(_waiters == 0, &quot;We left a thread hanging&quot;);
35   _barrier_tag = barrier_tag;
36   _waiters = 0;
37   OrderAccess::fence();
38 }
39 
40 int GenericWaitBarrier::wake_if_needed() {
41   assert(_barrier_tag == 0, &quot;Not disarmed&quot;);
42   int w = _waiters;
43   if (w == 0) {
44     // Load of _barrier_threads in caller must not pass the load of _waiters.
45     OrderAccess::loadload();
46     return 0;
47   }
48   assert(w &gt; 0, &quot;Bad counting&quot;);
49   // We need an exact count which never goes below zero,
50   // otherwise the semaphore may be signalled too many times.
<span class="line-modified">51   if (Atomic::cmpxchg(w - 1, &amp;_waiters, w) == w) {</span>
52     _sem_barrier.signal();
53     return w - 1;
54   }
55   return w;
56 }
57 
58 void GenericWaitBarrier::disarm() {
59   assert(_barrier_tag != 0, &quot;Not armed&quot;);
60   _barrier_tag = 0;
61   // Loads of _barrier_threads/_waiters must not float above disarm store and
62   // disarm store must not sink below.
63   OrderAccess::fence();
64   int left;
65   SpinYield sp;
66   do {
67     left = GenericWaitBarrier::wake_if_needed();
68     if (left == 0 &amp;&amp; _barrier_threads &gt; 0) {
69       // There is no thread to wake but we still have barrier threads.
70       sp.wait();
71     }
72     // We must loop here until there are no waiters or potential waiters.
73   } while (left &gt; 0 || _barrier_threads &gt; 0);
74   // API specifies disarm() must provide a trailing fence.
75   OrderAccess::fence();
76 }
77 
78 void GenericWaitBarrier::wait(int barrier_tag) {
79   assert(barrier_tag != 0, &quot;Trying to wait on disarmed value&quot;);
80   if (barrier_tag != _barrier_tag) {
81     // API specifies wait() must provide a trailing fence.
82     OrderAccess::fence();
83     return;
84   }
<span class="line-modified">85   Atomic::add(1, &amp;_barrier_threads);</span>
86   if (barrier_tag != 0 &amp;&amp; barrier_tag == _barrier_tag) {
<span class="line-modified">87     Atomic::add(1, &amp;_waiters);</span>
88     _sem_barrier.wait();
89     // We help out with posting, but we need to do so before we decrement the
90     // _barrier_threads otherwise we might wake threads up in next wait.
91     GenericWaitBarrier::wake_if_needed();
92   }
<span class="line-modified">93   Atomic::add(-1, &amp;_barrier_threads);</span>
94 }
</pre>
</td>
<td>
<hr />
<pre>
31 
32 void GenericWaitBarrier::arm(int barrier_tag) {
33   assert(_barrier_tag == 0, &quot;Already armed&quot;);
34   assert(_waiters == 0, &quot;We left a thread hanging&quot;);
35   _barrier_tag = barrier_tag;
36   _waiters = 0;
37   OrderAccess::fence();
38 }
39 
40 int GenericWaitBarrier::wake_if_needed() {
41   assert(_barrier_tag == 0, &quot;Not disarmed&quot;);
42   int w = _waiters;
43   if (w == 0) {
44     // Load of _barrier_threads in caller must not pass the load of _waiters.
45     OrderAccess::loadload();
46     return 0;
47   }
48   assert(w &gt; 0, &quot;Bad counting&quot;);
49   // We need an exact count which never goes below zero,
50   // otherwise the semaphore may be signalled too many times.
<span class="line-modified">51   if (Atomic::cmpxchg(&amp;_waiters, w, w - 1) == w) {</span>
52     _sem_barrier.signal();
53     return w - 1;
54   }
55   return w;
56 }
57 
58 void GenericWaitBarrier::disarm() {
59   assert(_barrier_tag != 0, &quot;Not armed&quot;);
60   _barrier_tag = 0;
61   // Loads of _barrier_threads/_waiters must not float above disarm store and
62   // disarm store must not sink below.
63   OrderAccess::fence();
64   int left;
65   SpinYield sp;
66   do {
67     left = GenericWaitBarrier::wake_if_needed();
68     if (left == 0 &amp;&amp; _barrier_threads &gt; 0) {
69       // There is no thread to wake but we still have barrier threads.
70       sp.wait();
71     }
72     // We must loop here until there are no waiters or potential waiters.
73   } while (left &gt; 0 || _barrier_threads &gt; 0);
74   // API specifies disarm() must provide a trailing fence.
75   OrderAccess::fence();
76 }
77 
78 void GenericWaitBarrier::wait(int barrier_tag) {
79   assert(barrier_tag != 0, &quot;Trying to wait on disarmed value&quot;);
80   if (barrier_tag != _barrier_tag) {
81     // API specifies wait() must provide a trailing fence.
82     OrderAccess::fence();
83     return;
84   }
<span class="line-modified">85   Atomic::add(&amp;_barrier_threads, 1);</span>
86   if (barrier_tag != 0 &amp;&amp; barrier_tag == _barrier_tag) {
<span class="line-modified">87     Atomic::add(&amp;_waiters, 1);</span>
88     _sem_barrier.wait();
89     // We help out with posting, but we need to do so before we decrement the
90     // _barrier_threads otherwise we might wake threads up in next wait.
91     GenericWaitBarrier::wake_if_needed();
92   }
<span class="line-modified">93   Atomic::add(&amp;_barrier_threads, -1);</span>
94 }
</pre>
</td>
</tr>
</table>
<center><a href="waitBarrier.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="waitBarrier_generic.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/utilities/decoder.cpp b/src/hotspot/share/utilities/decoder.cpp
--- a/src/hotspot/share/utilities/decoder.cpp
+++ b/src/hotspot/share/utilities/decoder.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -76,59 +76,45 @@
     decoder = &_do_nothing_decoder;
   }
   return decoder;
 }
 
-inline bool DecoderLocker::is_first_error_thread() {
-  return (os::current_thread_id() == VMError::get_first_error_tid());
-}
-
-DecoderLocker::DecoderLocker() :
-  MutexLockerEx(DecoderLocker::is_first_error_thread() ?
-                NULL : Decoder::shared_decoder_lock(),
-                Mutex::_no_safepoint_check_flag) {
-  _decoder = is_first_error_thread() ?
-    Decoder::get_error_handler_instance() : Decoder::get_shared_instance();
-  assert(_decoder != NULL, "null decoder");
-}
-
 Mutex* Decoder::shared_decoder_lock() {
   assert(SharedDecoder_lock != NULL, "Just check");
   return SharedDecoder_lock;
 }
 
 bool Decoder::decode(address addr, char* buf, int buflen, int* offset, const char* modulepath, bool demangle) {
-  bool error_handling_thread = os::current_thread_id() == VMError::first_error_tid;
-  MutexLockerEx locker(error_handling_thread ? NULL : shared_decoder_lock(),
-                       Mutex::_no_safepoint_check_flag);
-  AbstractDecoder* decoder = error_handling_thread ?
-    get_error_handler_instance(): get_shared_instance();
-  assert(decoder != NULL, "null decoder");
-
-  return decoder->decode(addr, buf, buflen, offset, modulepath, demangle);
+  bool error_handling_thread = os::current_thread_id() == VMError::get_first_error_tid();
+  if (error_handling_thread) {
+    return get_error_handler_instance()->decode(addr, buf, buflen, offset, modulepath, demangle);
+  } else {
+    MutexLocker locker(shared_decoder_lock(), Mutex::_no_safepoint_check_flag);
+    return get_shared_instance()->decode(addr, buf, buflen, offset, modulepath, demangle);
+  }
+
 }
 
 bool Decoder::decode(address addr, char* buf, int buflen, int* offset, const void* base) {
-  bool error_handling_thread = os::current_thread_id() == VMError::first_error_tid;
-  MutexLockerEx locker(error_handling_thread ? NULL : shared_decoder_lock(),
-                       Mutex::_no_safepoint_check_flag);
-  AbstractDecoder* decoder = error_handling_thread ?
-    get_error_handler_instance(): get_shared_instance();
-  assert(decoder != NULL, "null decoder");
-
-  return decoder->decode(addr, buf, buflen, offset, base);
+  bool error_handling_thread = os::current_thread_id() == VMError::get_first_error_tid();
+  if (error_handling_thread) {
+    return get_error_handler_instance()->decode(addr, buf, buflen, offset, base);
+  } else {
+    MutexLocker locker(shared_decoder_lock(), Mutex::_no_safepoint_check_flag);
+    return get_shared_instance()->decode(addr, buf, buflen, offset, base);
+  }
 }
 
 
 bool Decoder::demangle(const char* symbol, char* buf, int buflen) {
-  bool error_handling_thread = os::current_thread_id() == VMError::first_error_tid;
-  MutexLockerEx locker(error_handling_thread ? NULL : shared_decoder_lock(),
-                       Mutex::_no_safepoint_check_flag);
-  AbstractDecoder* decoder = error_handling_thread ?
-    get_error_handler_instance(): get_shared_instance();
-  assert(decoder != NULL, "null decoder");
-  return decoder->demangle(symbol, buf, buflen);
+  bool error_handling_thread = os::current_thread_id() == VMError::get_first_error_tid();
+  if (error_handling_thread) {
+    return get_error_handler_instance()->demangle(symbol, buf, buflen);
+  } else {
+    MutexLocker locker(shared_decoder_lock(), Mutex::_no_safepoint_check_flag);
+    return get_shared_instance()->demangle(symbol, buf, buflen);
+  }
 }
 
 void Decoder::print_state_on(outputStream* st) {
 }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/hashtable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="growableArray.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="hashtable.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/hashtable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,11 ***</span>
  template &lt;MEMFLAGS F&gt; BasicHashtableEntry&lt;F&gt;* BasicHashtable&lt;F&gt;::new_entry(unsigned int hashValue) {
    BasicHashtableEntry&lt;F&gt;* entry = new_entry_free_list();
  
    if (entry == NULL) {
      if (_first_free_entry + _entry_size &gt;= _end_block) {
<span class="line-modified">!       int block_size = MIN2(512, MAX2((int)_table_size / 2, (int)_number_of_entries));</span>
        int len = _entry_size * block_size;
        len = 1 &lt;&lt; log2_int(len); // round down to power of 2
        assert(len &gt;= _entry_size, &quot;&quot;);
        _first_free_entry = NEW_C_HEAP_ARRAY2(char, len, F, CURRENT_PC);
        _entry_blocks-&gt;append(_first_free_entry);
<span class="line-new-header">--- 59,11 ---</span>
  template &lt;MEMFLAGS F&gt; BasicHashtableEntry&lt;F&gt;* BasicHashtable&lt;F&gt;::new_entry(unsigned int hashValue) {
    BasicHashtableEntry&lt;F&gt;* entry = new_entry_free_list();
  
    if (entry == NULL) {
      if (_first_free_entry + _entry_size &gt;= _end_block) {
<span class="line-modified">!       int block_size = MIN2(512, MAX3(2, (int)_table_size / 2, (int)_number_of_entries));</span>
        int len = _entry_size * block_size;
        len = 1 &lt;&lt; log2_int(len); // round down to power of 2
        assert(len &gt;= _entry_size, &quot;&quot;);
        _first_free_entry = NEW_C_HEAP_ARRAY2(char, len, F, CURRENT_PC);
        _entry_blocks-&gt;append(_first_free_entry);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,14 ***</span>
    entry-&gt;set_next(NULL);
    return entry;
  }
  
  template &lt;MEMFLAGS F&gt; void BasicHashtable&lt;F&gt;::free_buckets() {
<span class="line-modified">!   if (NULL != _buckets) {</span>
<span class="line-modified">!     FREE_C_HEAP_ARRAY(HashtableBucket, _buckets);</span>
<span class="line-removed">-     _buckets = NULL;</span>
<span class="line-removed">-   }</span>
  }
  
  // For oops and Strings the size of the literal is interesting. For other types, nobody cares.
  static int literal_size(ConstantPool*) { return 0; }
  static int literal_size(Klass*)        { return 0; }
<span class="line-new-header">--- 99,12 ---</span>
    entry-&gt;set_next(NULL);
    return entry;
  }
  
  template &lt;MEMFLAGS F&gt; void BasicHashtable&lt;F&gt;::free_buckets() {
<span class="line-modified">!   FREE_C_HEAP_ARRAY(HashtableBucket, _buckets);</span>
<span class="line-modified">!   _buckets = NULL;</span>
  }
  
  // For oops and Strings the size of the literal is interesting. For other types, nobody cares.
  static int literal_size(ConstantPool*) { return 0; }
  static int literal_size(Klass*)        { return 0; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,11 ***</span>
    } else {
      return obj-&gt;size();
    }
  }
  
<span class="line-modified">! static int literal_size(ClassLoaderWeakHandle v) {</span>
    return literal_size(v.peek());
  }
  
  template &lt;MEMFLAGS F&gt; bool BasicHashtable&lt;F&gt;::resize(int new_size) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-new-header">--- 125,11 ---</span>
    } else {
      return obj-&gt;size();
    }
  }
  
<span class="line-modified">! static int literal_size(WeakHandle&lt;vm_class_loader_data&gt; v) {</span>
    return literal_size(v.peek());
  }
  
  template &lt;MEMFLAGS F&gt; bool BasicHashtable&lt;F&gt;::resize(int new_size) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 189,22 ***</span>
    } else {
      return false;
    }
  }
  
<span class="line-modified">! // Dump footprint and bucket length statistics</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // Note: if you create a new subclass of Hashtable&lt;MyNewType, F&gt;, you will need to</span>
<span class="line-removed">- // add a new function static int literal_size(MyNewType lit)</span>
<span class="line-removed">- // because I can&#39;t get template &lt;class T&gt; int literal_size(T) to pick the specializations for Symbol and oop.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // The StringTable and SymbolTable dumping print how much footprint is used by the String and Symbol</span>
<span class="line-removed">- // literals.</span>
<span class="line-removed">- </span>
<span class="line-removed">- template &lt;class T, MEMFLAGS F&gt; void Hashtable&lt;T, F&gt;::print_table_statistics(outputStream* st,</span>
<span class="line-removed">-                                                                             const char *table_name,</span>
<span class="line-removed">-                                                                             T (*literal_load_barrier)(HashtableEntry&lt;T, F&gt;*)) {</span>
    NumberSeq summary;
    int literal_bytes = 0;
    for (int i = 0; i &lt; this-&gt;table_size(); ++i) {
      int count = 0;
      for (HashtableEntry&lt;T, F&gt;* e = this-&gt;bucket(i);
<span class="line-new-header">--- 187,11 ---</span>
    } else {
      return false;
    }
  }
  
<span class="line-modified">! template &lt;class T, MEMFLAGS F&gt; TableStatistics Hashtable&lt;T, F&gt;::statistics_calculate(T (*literal_load_barrier)(HashtableEntry&lt;T, F&gt;*)) {</span>
    NumberSeq summary;
    int literal_bytes = 0;
    for (int i = 0; i &lt; this-&gt;table_size(); ++i) {
      int count = 0;
      for (HashtableEntry&lt;T, F&gt;* e = this-&gt;bucket(i);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 213,40 ***</span>
        T l = (literal_load_barrier != NULL) ? literal_load_barrier(e) : e-&gt;literal();
        literal_bytes += literal_size(l);
      }
      summary.add((double)count);
    }
<span class="line-modified">!   double num_buckets = summary.num();</span>
<span class="line-modified">!   double num_entries = summary.sum();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   int bucket_bytes = (int)num_buckets * sizeof(HashtableBucket&lt;F&gt;);</span>
<span class="line-modified">!   int entry_bytes  = (int)num_entries * sizeof(HashtableEntry&lt;T, F&gt;);</span>
<span class="line-modified">!   int total_bytes = literal_bytes +  bucket_bytes + entry_bytes;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   int bucket_size  = (num_buckets &lt;= 0) ? 0 : (bucket_bytes  / num_buckets);</span>
<span class="line-modified">!   int entry_size   = (num_entries &lt;= 0) ? 0 : (entry_bytes   / num_entries);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   st-&gt;print_cr(&quot;%s statistics:&quot;, table_name);</span>
<span class="line-modified">!   st-&gt;print_cr(&quot;Number of buckets       : %9d = %9d bytes, each %d&quot;, (int)num_buckets, bucket_bytes,  bucket_size);</span>
<span class="line-modified">!   st-&gt;print_cr(&quot;Number of entries       : %9d = %9d bytes, each %d&quot;, (int)num_entries, entry_bytes,   entry_size);</span>
<span class="line-removed">-   if (literal_bytes != 0) {</span>
<span class="line-removed">-     double literal_avg = (num_entries &lt;= 0) ? 0 : (literal_bytes / num_entries);</span>
<span class="line-removed">-     st-&gt;print_cr(&quot;Number of literals      : %9d = %9d bytes, avg %7.3f&quot;, (int)num_entries, literal_bytes, literal_avg);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   st-&gt;print_cr(&quot;Total footprint         : %9s = %9d bytes&quot;, &quot;&quot;, total_bytes);</span>
<span class="line-removed">-   st-&gt;print_cr(&quot;Average bucket size     : %9.3f&quot;, summary.avg());</span>
<span class="line-removed">-   st-&gt;print_cr(&quot;Variance of bucket size : %9.3f&quot;, summary.variance());</span>
<span class="line-removed">-   st-&gt;print_cr(&quot;Std. dev. of bucket size: %9.3f&quot;, summary.sd());</span>
<span class="line-removed">-   st-&gt;print_cr(&quot;Maximum bucket size     : %9d&quot;, (int)summary.maximum());</span>
  }
  
  #ifndef PRODUCT
  template &lt;class T&gt; void print_literal(T l) {
    l-&gt;print();
  }
  
<span class="line-modified">! static void print_literal(ClassLoaderWeakHandle l) {</span>
    l.print();
  }
  
  template &lt;class T, MEMFLAGS F&gt; void Hashtable&lt;T, F&gt;::print() {
    ResourceMark rm;
<span class="line-new-header">--- 200,31 ---</span>
        T l = (literal_load_barrier != NULL) ? literal_load_barrier(e) : e-&gt;literal();
        literal_bytes += literal_size(l);
      }
      summary.add((double)count);
    }
<span class="line-modified">!   return TableStatistics(this-&gt;_stats_rate, summary, literal_bytes, sizeof(HashtableBucket&lt;F&gt;), sizeof(HashtableEntry&lt;T, F&gt;));</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // Dump footprint and bucket length statistics</span>
<span class="line-modified">! //</span>
<span class="line-modified">! // Note: if you create a new subclass of Hashtable&lt;MyNewType, F&gt;, you will need to</span>
<span class="line-modified">! // add a new function static int literal_size(MyNewType lit)</span>
<span class="line-modified">! // because I can&#39;t get template &lt;class T&gt; int literal_size(T) to pick the specializations for Symbol and oop.</span>
<span class="line-modified">! template &lt;class T, MEMFLAGS F&gt; void Hashtable&lt;T, F&gt;::print_table_statistics(outputStream* st,</span>
<span class="line-modified">!                                                                             const char *table_name,</span>
<span class="line-modified">!                                                                             T (*literal_load_barrier)(HashtableEntry&lt;T, F&gt;*)) {</span>
<span class="line-modified">!   TableStatistics ts = statistics_calculate(literal_load_barrier);</span>
<span class="line-modified">!   ts.print(st, table_name);</span>
  }
  
  #ifndef PRODUCT
  template &lt;class T&gt; void print_literal(T l) {
    l-&gt;print();
  }
  
<span class="line-modified">! static void print_literal(WeakHandle&lt;vm_class_loader_data&gt; l) {</span>
    l.print();
  }
  
  template &lt;class T, MEMFLAGS F&gt; void Hashtable&lt;T, F&gt;::print() {
    ResourceMark rm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 306,29 ***</span>
  template class BasicHashtable&lt;mtGC&gt;;
  template class Hashtable&lt;ConstantPool*, mtClass&gt;;
  template class Hashtable&lt;Symbol*, mtSymbol&gt;;
  template class Hashtable&lt;Klass*, mtClass&gt;;
  template class Hashtable&lt;InstanceKlass*, mtClass&gt;;
<span class="line-modified">! template class Hashtable&lt;ClassLoaderWeakHandle, mtClass&gt;;</span>
  template class Hashtable&lt;Symbol*, mtModule&gt;;
  template class Hashtable&lt;oop, mtSymbol&gt;;
<span class="line-removed">- template class Hashtable&lt;ClassLoaderWeakHandle, mtSymbol&gt;;</span>
  template class Hashtable&lt;Symbol*, mtClass&gt;;
  template class HashtableEntry&lt;Symbol*, mtSymbol&gt;;
  template class HashtableEntry&lt;Symbol*, mtClass&gt;;
  template class HashtableEntry&lt;oop, mtSymbol&gt;;
<span class="line-modified">! template class HashtableEntry&lt;ClassLoaderWeakHandle, mtSymbol&gt;;</span>
  template class HashtableBucket&lt;mtClass&gt;;
  template class BasicHashtableEntry&lt;mtSymbol&gt;;
  template class BasicHashtableEntry&lt;mtCode&gt;;
  template class BasicHashtable&lt;mtClass&gt;;
  template class BasicHashtable&lt;mtClassShared&gt;;
  template class BasicHashtable&lt;mtSymbol&gt;;
  template class BasicHashtable&lt;mtCode&gt;;
  template class BasicHashtable&lt;mtInternal&gt;;
  template class BasicHashtable&lt;mtModule&gt;;
  template class BasicHashtable&lt;mtCompiler&gt;;
  
  template void BasicHashtable&lt;mtClass&gt;::verify_table&lt;DictionaryEntry&gt;(char const*);
  template void BasicHashtable&lt;mtModule&gt;::verify_table&lt;ModuleEntry&gt;(char const*);
  template void BasicHashtable&lt;mtModule&gt;::verify_table&lt;PackageEntry&gt;(char const*);
  template void BasicHashtable&lt;mtClass&gt;::verify_table&lt;ProtectionDomainCacheEntry&gt;(char const*);
<span class="line-new-header">--- 284,29 ---</span>
  template class BasicHashtable&lt;mtGC&gt;;
  template class Hashtable&lt;ConstantPool*, mtClass&gt;;
  template class Hashtable&lt;Symbol*, mtSymbol&gt;;
  template class Hashtable&lt;Klass*, mtClass&gt;;
  template class Hashtable&lt;InstanceKlass*, mtClass&gt;;
<span class="line-modified">! template class Hashtable&lt;WeakHandle&lt;vm_class_loader_data&gt;, mtClass&gt;;</span>
  template class Hashtable&lt;Symbol*, mtModule&gt;;
  template class Hashtable&lt;oop, mtSymbol&gt;;
  template class Hashtable&lt;Symbol*, mtClass&gt;;
  template class HashtableEntry&lt;Symbol*, mtSymbol&gt;;
  template class HashtableEntry&lt;Symbol*, mtClass&gt;;
  template class HashtableEntry&lt;oop, mtSymbol&gt;;
<span class="line-modified">! template class HashtableEntry&lt;WeakHandle&lt;vm_class_loader_data&gt;, mtClass&gt;;</span>
  template class HashtableBucket&lt;mtClass&gt;;
  template class BasicHashtableEntry&lt;mtSymbol&gt;;
  template class BasicHashtableEntry&lt;mtCode&gt;;
  template class BasicHashtable&lt;mtClass&gt;;
  template class BasicHashtable&lt;mtClassShared&gt;;
  template class BasicHashtable&lt;mtSymbol&gt;;
  template class BasicHashtable&lt;mtCode&gt;;
  template class BasicHashtable&lt;mtInternal&gt;;
  template class BasicHashtable&lt;mtModule&gt;;
  template class BasicHashtable&lt;mtCompiler&gt;;
<span class="line-added">+ template class BasicHashtable&lt;mtTracing&gt;;</span>
  
  template void BasicHashtable&lt;mtClass&gt;::verify_table&lt;DictionaryEntry&gt;(char const*);
  template void BasicHashtable&lt;mtModule&gt;::verify_table&lt;ModuleEntry&gt;(char const*);
  template void BasicHashtable&lt;mtModule&gt;::verify_table&lt;PackageEntry&gt;(char const*);
  template void BasicHashtable&lt;mtClass&gt;::verify_table&lt;ProtectionDomainCacheEntry&gt;(char const*);
</pre>
<center><a href="growableArray.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="hashtable.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
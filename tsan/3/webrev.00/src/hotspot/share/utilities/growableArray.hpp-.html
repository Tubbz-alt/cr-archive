<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/utilities/growableArray.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_GROWABLEARRAY_HPP
 26 #define SHARE_UTILITIES_GROWABLEARRAY_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/oop.hpp&quot;
 30 #include &quot;utilities/debug.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 
 34 // A growable array.
 35 
 36 /*************************************************************************/
 37 /*                                                                       */
 38 /*     WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING   */
 39 /*                                                                       */
 40 /* Should you use GrowableArrays to contain handles you must be certain  */
 41 /* the the GrowableArray does not outlive the HandleMark that contains   */
 42 /* the handles. Since GrowableArrays are typically resource allocated    */
 43 /* the following is an example of INCORRECT CODE,                        */
 44 /*                                                                       */
 45 /* ResourceMark rm;                                                      */
 46 /* GrowableArray&lt;Handle&gt;* arr = new GrowableArray&lt;Handle&gt;(size);         */
 47 /* if (blah) {                                                           */
 48 /*    while (...) {                                                      */
 49 /*      HandleMark hm;                                                   */
 50 /*      ...                                                              */
 51 /*      Handle h(THREAD, some_oop);                                      */
 52 /*      arr-&gt;append(h);                                                  */
 53 /*    }                                                                  */
 54 /* }                                                                     */
 55 /* if (arr-&gt;length() != 0 ) {                                            */
 56 /*    oop bad_oop = arr-&gt;at(0)(); // Handle is BAD HERE.                 */
 57 /*    ...                                                                */
 58 /* }                                                                     */
 59 /*                                                                       */
 60 /* If the GrowableArrays you are creating is C_Heap allocated then it    */
 61 /* hould not old handles since the handles could trivially try and       */
 62 /* outlive their HandleMark. In some situations you might need to do     */
 63 /* this and it would be legal but be very careful and see if you can do  */
 64 /* the code in some other manner.                                        */
 65 /*                                                                       */
 66 /*************************************************************************/
 67 
 68 // To call default constructor the placement operator new() is used.
 69 // It should be empty (it only returns the passed void* pointer).
 70 // The definition of placement operator new(size_t, void*) in the &lt;new&gt;.
 71 
 72 #include &lt;new&gt;
 73 
 74 // Need the correct linkage to call qsort without warnings
 75 extern &quot;C&quot; {
 76   typedef int (*_sort_Fn)(const void *, const void *);
 77 }
 78 
 79 class GenericGrowableArray : public ResourceObj {
 80   friend class VMStructs;
 81 
 82  protected:
 83   int    _len;          // current length
 84   int    _max;          // maximum length
 85   Arena* _arena;        // Indicates where allocation occurs:
 86                         //   0 means default ResourceArea
 87                         //   1 means on C heap
 88                         //   otherwise, allocate in _arena
 89 
 90   MEMFLAGS   _memflags;   // memory type if allocation in C heap
 91 
 92 #ifdef ASSERT
 93   int    _nesting;      // resource area nesting at creation
 94   void   set_nesting();
 95   void   check_nesting();
 96 #else
 97 #define  set_nesting();
 98 #define  check_nesting();
 99 #endif
100 
101   // Where are we going to allocate memory?
102   bool on_C_heap() { return _arena == (Arena*)1; }
103   bool on_stack () { return _arena == NULL;      }
104   bool on_arena () { return _arena &gt;  (Arena*)1;  }
105 
106   // This GA will use the resource stack for storage if c_heap==false,
107   // Else it will use the C heap.  Use clear_and_deallocate to avoid leaks.
108   GenericGrowableArray(int initial_size, int initial_len, bool c_heap, MEMFLAGS flags = mtNone) {
109     _len = initial_len;
110     _max = initial_size;
111     _memflags = flags;
112 
113     // memory type has to be specified for C heap allocation
114     assert(!(c_heap &amp;&amp; flags == mtNone), &quot;memory type not specified for C heap object&quot;);
115 
116     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);
117     _arena = (c_heap ? (Arena*)1 : NULL);
118     set_nesting();
119     assert(!on_C_heap() || allocated_on_C_heap(), &quot;growable array must be on C heap if elements are&quot;);
120     assert(!on_stack() ||
121            (allocated_on_res_area() || allocated_on_stack()),
122            &quot;growable array must be on stack if elements are not on arena and not on C heap&quot;);
123   }
124 
125   // This GA will use the given arena for storage.
126   // Consider using new(arena) GrowableArray&lt;T&gt; to allocate the header.
127   GenericGrowableArray(Arena* arena, int initial_size, int initial_len) {
128     _len = initial_len;
129     _max = initial_size;
130     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);
131     _arena = arena;
132     _memflags = mtNone;
133 
134     assert(on_arena(), &quot;arena has taken on reserved value 0 or 1&quot;);
135     // Relax next assert to allow object allocation on resource area,
136     // on stack or embedded into an other object.
137     assert(allocated_on_arena() || allocated_on_stack(),
138            &quot;growable array must be on arena or on stack if elements are on arena&quot;);
139   }
140 
141   void* raw_allocate(int elementSize);
142 
143   // some uses pass the Thread explicitly for speed (4990299 tuning)
144   void* raw_allocate(Thread* thread, int elementSize) {
145     assert(on_stack(), &quot;fast ResourceObj path only&quot;);
146     return (void*)resource_allocate_bytes(thread, elementSize * _max);
147   }
148 
149   void free_C_heap(void* elements);
150 };
151 
152 template&lt;class E&gt; class GrowableArrayIterator;
153 template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator;
154 
155 template&lt;class E&gt; class GrowableArray : public GenericGrowableArray {
156   friend class VMStructs;
157 
158  private:
159   E*     _data;         // data array
160 
161   void grow(int j);
162   void raw_at_put_grow(int i, const E&amp; p, const E&amp; fill);
163   void  clear_and_deallocate();
164  public:
165   GrowableArray(Thread* thread, int initial_size) : GenericGrowableArray(initial_size, 0, false) {
166     _data = (E*)raw_allocate(thread, sizeof(E));
167     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
168   }
169 
170   GrowableArray(int initial_size, bool C_heap = false, MEMFLAGS F = mtInternal)
171     : GenericGrowableArray(initial_size, 0, C_heap, F) {
172     _data = (E*)raw_allocate(sizeof(E));
173 // Needed for Visual Studio 2012 and older
174 #ifdef _MSC_VER
175 #pragma warning(suppress: 4345)
176 #endif
177     for (int i = 0; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
178   }
179 
180   GrowableArray(int initial_size, int initial_len, const E&amp; filler, bool C_heap = false, MEMFLAGS memflags = mtInternal)
181     : GenericGrowableArray(initial_size, initial_len, C_heap, memflags) {
182     _data = (E*)raw_allocate(sizeof(E));
183     int i = 0;
184     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
185     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
186   }
187 
188   GrowableArray(Arena* arena, int initial_size, int initial_len, const E&amp; filler) : GenericGrowableArray(arena, initial_size, initial_len) {
189     _data = (E*)raw_allocate(sizeof(E));
190     int i = 0;
191     for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
192     for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
193   }
194 
195   GrowableArray() : GenericGrowableArray(2, 0, false) {
196     _data = (E*)raw_allocate(sizeof(E));
197     ::new ((void*)&amp;_data[0]) E();
198     ::new ((void*)&amp;_data[1]) E();
199   }
200 
201                                 // Does nothing for resource and arena objects
202   ~GrowableArray()              { if (on_C_heap()) clear_and_deallocate(); }
203 
204   void  clear()                 { _len = 0; }
205   int   length() const          { return _len; }
206   int   max_length() const      { return _max; }
207   void  trunc_to(int l)         { assert(l &lt;= _len,&quot;cannot increase length&quot;); _len = l; }
208   bool  is_empty() const        { return _len == 0; }
209   bool  is_nonempty() const     { return _len != 0; }
210   bool  is_full() const         { return _len == _max; }
211   DEBUG_ONLY(E* data_addr() const      { return _data; })
212 
213   void print();
214 
215   inline static bool safe_equals(oop obj1, oop obj2) {
216     return oopDesc::equals(obj1, obj2);
217   }
218 
219   template &lt;class X&gt;
220   inline static bool safe_equals(X i1, X i2) {
221     return i1 == i2;
222   }
223 
224   int append(const E&amp; elem) {
225     check_nesting();
226     if (_len == _max) grow(_len);
227     int idx = _len++;
228     _data[idx] = elem;
229     return idx;
230   }
231 
232   bool append_if_missing(const E&amp; elem) {
233     // Returns TRUE if elem is added.
234     bool missed = !contains(elem);
235     if (missed) append(elem);
236     return missed;
237   }
238 
239   E&amp; at(int i) {
240     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
241     return _data[i];
242   }
243 
244   E const&amp; at(int i) const {
245     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
246     return _data[i];
247   }
248 
249   E* adr_at(int i) const {
250     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
251     return &amp;_data[i];
252   }
253 
254   E first() const {
255     assert(_len &gt; 0, &quot;empty list&quot;);
256     return _data[0];
257   }
258 
259   E top() const {
260     assert(_len &gt; 0, &quot;empty list&quot;);
261     return _data[_len-1];
262   }
263 
264   E last() const {
265     return top();
266   }
267 
268   GrowableArrayIterator&lt;E&gt; begin() const {
269     return GrowableArrayIterator&lt;E&gt;(this, 0);
270   }
271 
272   GrowableArrayIterator&lt;E&gt; end() const {
273     return GrowableArrayIterator&lt;E&gt;(this, length());
274   }
275 
276   void push(const E&amp; elem) { append(elem); }
277 
278   E pop() {
279     assert(_len &gt; 0, &quot;empty list&quot;);
280     return _data[--_len];
281   }
282 
283   void at_put(int i, const E&amp; elem) {
284     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
285     _data[i] = elem;
286   }
287 
288   E at_grow(int i, const E&amp; fill = E()) {
289     assert(0 &lt;= i, &quot;negative index&quot;);
290     check_nesting();
291     if (i &gt;= _len) {
292       if (i &gt;= _max) grow(i);
293       for (int j = _len; j &lt;= i; j++)
294         _data[j] = fill;
295       _len = i+1;
296     }
297     return _data[i];
298   }
299 
300   void at_put_grow(int i, const E&amp; elem, const E&amp; fill = E()) {
301     assert(0 &lt;= i, &quot;negative index&quot;);
302     check_nesting();
303     raw_at_put_grow(i, elem, fill);
304   }
305 
306   bool contains(const E&amp; elem) const {
307     for (int i = 0; i &lt; _len; i++) {
308       if (safe_equals(_data[i], elem)) return true;
309     }
310     return false;
311   }
312 
313   int  find(const E&amp; elem) const {
314     for (int i = 0; i &lt; _len; i++) {
315       if (_data[i] == elem) return i;
316     }
317     return -1;
318   }
319 
320   int  find_from_end(const E&amp; elem) const {
321     for (int i = _len-1; i &gt;= 0; i--) {
322       if (_data[i] == elem) return i;
323     }
324     return -1;
325   }
326 
327   int  find(void* token, bool f(void*, E)) const {
328     for (int i = 0; i &lt; _len; i++) {
329       if (f(token, _data[i])) return i;
330     }
331     return -1;
332   }
333 
334   int  find_from_end(void* token, bool f(void*, E)) const {
335     // start at the end of the array
336     for (int i = _len-1; i &gt;= 0; i--) {
337       if (f(token, _data[i])) return i;
338     }
339     return -1;
340   }
341 
342   void remove(const E&amp; elem) {
343     for (int i = 0; i &lt; _len; i++) {
344       if (_data[i] == elem) {
345         for (int j = i + 1; j &lt; _len; j++) _data[j-1] = _data[j];
346         _len--;
347         return;
348       }
349     }
350     ShouldNotReachHere();
351   }
352 
353   // The order is preserved.
354   void remove_at(int index) {
355     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
356     for (int j = index + 1; j &lt; _len; j++) _data[j-1] = _data[j];
357     _len--;
358   }
359 
360   // The order is changed.
361   void delete_at(int index) {
362     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
363     if (index &lt; --_len) {
364       // Replace removed element with last one.
365       _data[index] = _data[_len];
366     }
367   }
368 
369   // inserts the given element before the element at index i
370   void insert_before(const int idx, const E&amp; elem) {
371     assert(0 &lt;= idx &amp;&amp; idx &lt;= _len, &quot;illegal index&quot;);
372     check_nesting();
373     if (_len == _max) grow(_len);
374     for (int j = _len - 1; j &gt;= idx; j--) {
375       _data[j + 1] = _data[j];
376     }
377     _len++;
378     _data[idx] = elem;
379   }
380 
381   void insert_before(const int idx, const GrowableArray&lt;E&gt;* array) {
382     assert(0 &lt;= idx &amp;&amp; idx &lt;= _len, &quot;illegal index&quot;);
383     check_nesting();
384     int array_len = array-&gt;length();
385     int new_len = _len + array_len;
386     if (new_len &gt;= _max) grow(new_len);
387 
388     for (int j = _len - 1; j &gt;= idx; j--) {
389       _data[j + array_len] = _data[j];
390     }
391 
392     for (int j = 0; j &lt; array_len; j++) {
393       _data[idx + j] = array-&gt;_data[j];
394     }
395 
396     _len += array_len;
397   }
398 
399   void appendAll(const GrowableArray&lt;E&gt;* l) {
400     for (int i = 0; i &lt; l-&gt;_len; i++) {
401       raw_at_put_grow(_len, l-&gt;_data[i], E());
402     }
403   }
404 
405   void sort(int f(E*,E*)) {
406     qsort(_data, length(), sizeof(E), (_sort_Fn)f);
407   }
408   // sort by fixed-stride sub arrays:
409   void sort(int f(E*,E*), int stride) {
410     qsort(_data, length() / stride, sizeof(E) * stride, (_sort_Fn)f);
411   }
412 
413   // Binary search and insertion utility.  Search array for element
414   // matching key according to the static compare function.  Insert
415   // that element is not already in the list.  Assumes the list is
416   // already sorted according to compare function.
417   template &lt;int compare(const E&amp;, const E&amp;)&gt; E insert_sorted(const E&amp; key) {
418     bool found;
419     int location = find_sorted&lt;E, compare&gt;(key, found);
420     if (!found) {
421       insert_before(location, key);
422     }
423     return at(location);
424   }
425 
426   template &lt;typename K, int compare(const K&amp;, const E&amp;)&gt; int find_sorted(const K&amp; key, bool&amp; found) {
427     found = false;
428     int min = 0;
429     int max = length() - 1;
430 
431     while (max &gt;= min) {
432       int mid = (int)(((uint)max + min) / 2);
433       E value = at(mid);
434       int diff = compare(key, value);
435       if (diff &gt; 0) {
436         min = mid + 1;
437       } else if (diff &lt; 0) {
438         max = mid - 1;
439       } else {
440         found = true;
441         return mid;
442       }
443     }
444     return min;
445   }
446 };
447 
448 // Global GrowableArray methods (one instance in the library per each &#39;E&#39; type).
449 
450 template&lt;class E&gt; void GrowableArray&lt;E&gt;::grow(int j) {
451     // grow the array by doubling its size (amortized growth)
452     int old_max = _max;
453     if (_max == 0) _max = 1; // prevent endless loop
454     while (j &gt;= _max) _max = _max*2;
455     // j &lt; _max
456     E* newData = (E*)raw_allocate(sizeof(E));
457     int i = 0;
458     for (     ; i &lt; _len; i++) ::new ((void*)&amp;newData[i]) E(_data[i]);
459 // Needed for Visual Studio 2012 and older
460 #ifdef _MSC_VER
461 #pragma warning(suppress: 4345)
462 #endif
463     for (     ; i &lt; _max; i++) ::new ((void*)&amp;newData[i]) E();
464     for (i = 0; i &lt; old_max; i++) _data[i].~E();
465     if (on_C_heap() &amp;&amp; _data != NULL) {
466       free_C_heap(_data);
467     }
468     _data = newData;
469 }
470 
471 template&lt;class E&gt; void GrowableArray&lt;E&gt;::raw_at_put_grow(int i, const E&amp; p, const E&amp; fill) {
472     if (i &gt;= _len) {
473       if (i &gt;= _max) grow(i);
474       for (int j = _len; j &lt; i; j++)
475         _data[j] = fill;
476       _len = i+1;
477     }
478     _data[i] = p;
479 }
480 
481 // This function clears and deallocate the data in the growable array that
482 // has been allocated on the C heap.  It&#39;s not public - called by the
483 // destructor.
484 template&lt;class E&gt; void GrowableArray&lt;E&gt;::clear_and_deallocate() {
485     assert(on_C_heap(),
486            &quot;clear_and_deallocate should only be called when on C heap&quot;);
487     clear();
488     if (_data != NULL) {
489       for (int i = 0; i &lt; _max; i++) _data[i].~E();
490       free_C_heap(_data);
491       _data = NULL;
492     }
493 }
494 
495 template&lt;class E&gt; void GrowableArray&lt;E&gt;::print() {
496     tty-&gt;print(&quot;Growable Array &quot; INTPTR_FORMAT, this);
497     tty-&gt;print(&quot;: length %ld (_max %ld) { &quot;, _len, _max);
498     for (int i = 0; i &lt; _len; i++) tty-&gt;print(INTPTR_FORMAT &quot; &quot;, *(intptr_t*)&amp;(_data[i]));
499     tty-&gt;print(&quot;}\n&quot;);
500 }
501 
502 // Custom STL-style iterator to iterate over GrowableArrays
503 // It is constructed by invoking GrowableArray::begin() and GrowableArray::end()
504 template&lt;class E&gt; class GrowableArrayIterator : public StackObj {
505   friend class GrowableArray&lt;E&gt;;
506   template&lt;class F, class UnaryPredicate&gt; friend class GrowableArrayFilterIterator;
507 
508  private:
509   const GrowableArray&lt;E&gt;* _array; // GrowableArray we iterate over
510   int _position;                  // The current position in the GrowableArray
511 
512   // Private constructor used in GrowableArray::begin() and GrowableArray::end()
513   GrowableArrayIterator(const GrowableArray&lt;E&gt;* array, int position) : _array(array), _position(position) {
514     assert(0 &lt;= position &amp;&amp; position &lt;= _array-&gt;length(), &quot;illegal position&quot;);
515   }
516 
517  public:
518   GrowableArrayIterator() : _array(NULL), _position(0) { }
519   GrowableArrayIterator&lt;E&gt;&amp; operator++()  { ++_position; return *this; }
520   E operator*()                           { return _array-&gt;at(_position); }
521 
522   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
523     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
524     return _position == rhs._position;
525   }
526 
527   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
528     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
529     return _position != rhs._position;
530   }
531 };
532 
533 // Custom STL-style iterator to iterate over elements of a GrowableArray that satisfy a given predicate
534 template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator : public StackObj {
535   friend class GrowableArray&lt;E&gt;;
536 
537  private:
538   const GrowableArray&lt;E&gt;* _array;   // GrowableArray we iterate over
539   int _position;                    // Current position in the GrowableArray
540   UnaryPredicate _predicate;        // Unary predicate the elements of the GrowableArray should satisfy
541 
542  public:
543   GrowableArrayFilterIterator(const GrowableArrayIterator&lt;E&gt;&amp; begin, UnaryPredicate filter_predicate)
544    : _array(begin._array), _position(begin._position), _predicate(filter_predicate) {
545     // Advance to first element satisfying the predicate
546     while(_position != _array-&gt;length() &amp;&amp; !_predicate(_array-&gt;at(_position))) {
547       ++_position;
548     }
549   }
550 
551   GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; operator++() {
552     do {
553       // Advance to next element satisfying the predicate
554       ++_position;
555     } while(_position != _array-&gt;length() &amp;&amp; !_predicate(_array-&gt;at(_position)));
556     return *this;
557   }
558 
559   E operator*()   { return _array-&gt;at(_position); }
560 
561   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
562     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
563     return _position == rhs._position;
564   }
565 
566   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
567     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
568     return _position != rhs._position;
569   }
570 
571   bool operator==(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
572     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
573     return _position == rhs._position;
574   }
575 
576   bool operator!=(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
577     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
578     return _position != rhs._position;
579   }
580 };
581 
582 // Arrays for basic types
583 typedef GrowableArray&lt;int&gt; intArray;
584 typedef GrowableArray&lt;int&gt; intStack;
585 typedef GrowableArray&lt;bool&gt; boolArray;
586 
587 #endif // SHARE_UTILITIES_GROWABLEARRAY_HPP
    </pre>
  </body>
</html>
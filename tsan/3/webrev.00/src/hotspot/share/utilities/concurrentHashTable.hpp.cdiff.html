<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/concurrentHashTable.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compilerWarnings_gcc.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="concurrentHashTable.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/concurrentHashTable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,21 ***</span>
  #define SHARE_UTILITIES_CONCURRENTHASHTABLE_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;utilities/globalCounter.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  
  // A mostly concurrent-hash-table where the read-side is wait-free, inserts are
  // CAS and deletes mutual exclude each other on per bucket-basis. VALUE is the
  // type kept inside each Node and CONFIG contains hash and allocation methods.
  // A CALLBACK_FUNC and LOOKUP_FUNC needs to be provided for get and insert.
  
  class Thread;
  class Mutex;
  
<span class="line-modified">! template &lt;typename VALUE, typename CONFIG, MEMFLAGS F&gt;</span>
  class ConcurrentHashTable : public CHeapObj&lt;F&gt; {
   private:
    // This is the internal node structure.
    // Only constructed with placement new from memory allocated with MEMFLAGS of
    // the InternalTable or user-defined memory.
    class Node {
<span class="line-new-header">--- 26,23 ---</span>
  #define SHARE_UTILITIES_CONCURRENTHASHTABLE_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;utilities/globalCounter.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-added">+ #include &quot;utilities/tableStatistics.hpp&quot;</span>
  
  // A mostly concurrent-hash-table where the read-side is wait-free, inserts are
  // CAS and deletes mutual exclude each other on per bucket-basis. VALUE is the
  // type kept inside each Node and CONFIG contains hash and allocation methods.
  // A CALLBACK_FUNC and LOOKUP_FUNC needs to be provided for get and insert.
  
  class Thread;
  class Mutex;
  
<span class="line-modified">! template &lt;typename CONFIG, MEMFLAGS F&gt;</span>
  class ConcurrentHashTable : public CHeapObj&lt;F&gt; {
<span class="line-added">+   typedef typename CONFIG::Value VALUE;</span>
   private:
    // This is the internal node structure.
    // Only constructed with placement new from memory allocated with MEMFLAGS of
    // the InternalTable or user-defined memory.
    class Node {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 249,14 ***</span>
    // Scoped critical section, which also handles the invisible epochs.
    // An invisible epoch/version do not need a write_synchronize().
    class ScopedCS: public StackObj {
     protected:
      Thread* _thread;
<span class="line-modified">!     ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* _cht;</span>
      GlobalCounter::CSContext _cs_context;
     public:
<span class="line-modified">!     ScopedCS(Thread* thread, ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* cht);</span>
      ~ScopedCS();
    };
  
  
    // Max number of deletes in one bucket chain during bulk delete.
<span class="line-new-header">--- 251,14 ---</span>
    // Scoped critical section, which also handles the invisible epochs.
    // An invisible epoch/version do not need a write_synchronize().
    class ScopedCS: public StackObj {
     protected:
      Thread* _thread;
<span class="line-modified">!     ConcurrentHashTable&lt;CONFIG, F&gt;* _cht;</span>
      GlobalCounter::CSContext _cs_context;
     public:
<span class="line-modified">!     ScopedCS(Thread* thread, ConcurrentHashTable&lt;CONFIG, F&gt;* cht);</span>
      ~ScopedCS();
    };
  
  
    // Max number of deletes in one bucket chain during bulk delete.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,10 ***</span>
<span class="line-new-header">--- 380,12 ---</span>
                        size_t log2size_limit = DEFAULT_MAX_SIZE_LOG2,
                        size_t grow_hint = DEFAULT_GROW_HINT);
  
    ~ConcurrentHashTable();
  
<span class="line-added">+   TableRateStatistics _stats_rate;</span>
<span class="line-added">+ </span>
    size_t get_size_log2(Thread* thread);
    size_t get_node_size() const { return sizeof(Node); }
    bool is_max_size_reached() { return _size_limit_reached; }
  
    // This means no paused bucket resize operation is going to resume
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,37 ***</span>
    // Destroying items matching EVALUATE_FUNC, before destroying items
    // DELETE_FUNC is called, when the resize lock is successfully obtained.
    template &lt;typename EVALUATE_FUNC, typename DELETE_FUNC&gt;
    void bulk_delete(Thread* thread, EVALUATE_FUNC&amp; eval_f, DELETE_FUNC&amp; del_f);
  
    // Writes statistics to the outputStream. Item sizes are calculated with
    // VALUE_SIZE_FUNC.
    template &lt;typename VALUE_SIZE_FUNC&gt;
    void statistics_to(Thread* thread, VALUE_SIZE_FUNC&amp; vs_f, outputStream* st,
                       const char* table_name);
  
    // Moves all nodes from this table to to_cht
<span class="line-modified">!   bool try_move_nodes_to(Thread* thread, ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* to_cht);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // This is a Curiously Recurring Template Pattern (CRPT) interface for the</span>
<span class="line-removed">-   // specialization.</span>
<span class="line-removed">-   struct BaseConfig {</span>
<span class="line-removed">-    public:</span>
<span class="line-removed">-     // Called when the hash table needs the hash for a VALUE.</span>
<span class="line-removed">-     static uintx get_hash(const VALUE&amp; value, bool* dead) {</span>
<span class="line-removed">-       return CONFIG::get_hash(value, dead);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // Default node allocation.</span>
<span class="line-removed">-     static void* allocate_node(size_t size, const VALUE&amp; value);</span>
<span class="line-removed">-     // Default node reclamation.</span>
<span class="line-removed">-     static void free_node(void* memory, const VALUE&amp; value);</span>
<span class="line-removed">-   };</span>
  
    // Scoped multi getter.
    class MultiGetHandle : private ScopedCS {
     public:
<span class="line-modified">!     MultiGetHandle(Thread* thread, ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* cht)</span>
        : ScopedCS(thread, cht) {}
      // In the MultiGetHandle scope you can lookup items matching LOOKUP_FUNC.
      // The VALUEs are safe as long as you never save the VALUEs outside the
      // scope, e.g. after ~MultiGetHandle().
      template &lt;typename LOOKUP_FUNC&gt;
<span class="line-new-header">--- 456,32 ---</span>
    // Destroying items matching EVALUATE_FUNC, before destroying items
    // DELETE_FUNC is called, when the resize lock is successfully obtained.
    template &lt;typename EVALUATE_FUNC, typename DELETE_FUNC&gt;
    void bulk_delete(Thread* thread, EVALUATE_FUNC&amp; eval_f, DELETE_FUNC&amp; del_f);
  
<span class="line-added">+   // Calcuate statistics. Item sizes are calculated with VALUE_SIZE_FUNC.</span>
<span class="line-added">+   template &lt;typename VALUE_SIZE_FUNC&gt;</span>
<span class="line-added">+   TableStatistics statistics_calculate(Thread* thread, VALUE_SIZE_FUNC&amp; vs_f);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Gets statistics if available, if not return old one. Item sizes are calculated with</span>
<span class="line-added">+   // VALUE_SIZE_FUNC.</span>
<span class="line-added">+   template &lt;typename VALUE_SIZE_FUNC&gt;</span>
<span class="line-added">+   TableStatistics statistics_get(Thread* thread, VALUE_SIZE_FUNC&amp; vs_f, TableStatistics old);</span>
<span class="line-added">+ </span>
    // Writes statistics to the outputStream. Item sizes are calculated with
    // VALUE_SIZE_FUNC.
    template &lt;typename VALUE_SIZE_FUNC&gt;
    void statistics_to(Thread* thread, VALUE_SIZE_FUNC&amp; vs_f, outputStream* st,
                       const char* table_name);
  
    // Moves all nodes from this table to to_cht
<span class="line-modified">!   bool try_move_nodes_to(Thread* thread, ConcurrentHashTable&lt;CONFIG, F&gt;* to_cht);</span>
  
    // Scoped multi getter.
    class MultiGetHandle : private ScopedCS {
     public:
<span class="line-modified">!     MultiGetHandle(Thread* thread, ConcurrentHashTable&lt;CONFIG, F&gt;* cht)</span>
        : ScopedCS(thread, cht) {}
      // In the MultiGetHandle scope you can lookup items matching LOOKUP_FUNC.
      // The VALUEs are safe as long as you never save the VALUEs outside the
      // scope, e.g. after ~MultiGetHandle().
      template &lt;typename LOOKUP_FUNC&gt;
</pre>
<center><a href="compilerWarnings_gcc.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="concurrentHashTable.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
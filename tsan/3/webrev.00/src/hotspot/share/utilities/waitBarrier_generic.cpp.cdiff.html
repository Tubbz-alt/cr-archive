<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/waitBarrier_generic.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="waitBarrier.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="waitBarrier_generic.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/waitBarrier_generic.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 46,11 ***</span>
      return 0;
    }
    assert(w &gt; 0, &quot;Bad counting&quot;);
    // We need an exact count which never goes below zero,
    // otherwise the semaphore may be signalled too many times.
<span class="line-modified">!   if (Atomic::cmpxchg(w - 1, &amp;_waiters, w) == w) {</span>
      _sem_barrier.signal();
      return w - 1;
    }
    return w;
  }
<span class="line-new-header">--- 46,11 ---</span>
      return 0;
    }
    assert(w &gt; 0, &quot;Bad counting&quot;);
    // We need an exact count which never goes below zero,
    // otherwise the semaphore may be signalled too many times.
<span class="line-modified">!   if (Atomic::cmpxchg(&amp;_waiters, w, w - 1) == w) {</span>
      _sem_barrier.signal();
      return w - 1;
    }
    return w;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,15 ***</span>
    if (barrier_tag != _barrier_tag) {
      // API specifies wait() must provide a trailing fence.
      OrderAccess::fence();
      return;
    }
<span class="line-modified">!   Atomic::add(1, &amp;_barrier_threads);</span>
    if (barrier_tag != 0 &amp;&amp; barrier_tag == _barrier_tag) {
<span class="line-modified">!     Atomic::add(1, &amp;_waiters);</span>
      _sem_barrier.wait();
      // We help out with posting, but we need to do so before we decrement the
      // _barrier_threads otherwise we might wake threads up in next wait.
      GenericWaitBarrier::wake_if_needed();
    }
<span class="line-modified">!   Atomic::add(-1, &amp;_barrier_threads);</span>
  }
<span class="line-new-header">--- 80,15 ---</span>
    if (barrier_tag != _barrier_tag) {
      // API specifies wait() must provide a trailing fence.
      OrderAccess::fence();
      return;
    }
<span class="line-modified">!   Atomic::add(&amp;_barrier_threads, 1);</span>
    if (barrier_tag != 0 &amp;&amp; barrier_tag == _barrier_tag) {
<span class="line-modified">!     Atomic::add(&amp;_waiters, 1);</span>
      _sem_barrier.wait();
      // We help out with posting, but we need to do so before we decrement the
      // _barrier_threads otherwise we might wake threads up in next wait.
      GenericWaitBarrier::wake_if_needed();
    }
<span class="line-modified">!   Atomic::add(&amp;_barrier_threads, -1);</span>
  }
</pre>
<center><a href="waitBarrier.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="waitBarrier_generic.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
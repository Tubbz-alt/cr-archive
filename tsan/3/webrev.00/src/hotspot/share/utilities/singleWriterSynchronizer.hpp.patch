diff a/src/hotspot/share/utilities/singleWriterSynchronizer.hpp b/src/hotspot/share/utilities/singleWriterSynchronizer.hpp
--- a/src/hotspot/share/utilities/singleWriterSynchronizer.hpp
+++ b/src/hotspot/share/utilities/singleWriterSynchronizer.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -53,13 +53,11 @@
   volatile uint _waiting_for;
   Semaphore _wakeup;
 
   DEBUG_ONLY(volatile uint _writers;)
 
-  // Noncopyable.
-  SingleWriterSynchronizer(const SingleWriterSynchronizer&);
-  SingleWriterSynchronizer& operator=(const SingleWriterSynchronizer&);
+  NONCOPYABLE(SingleWriterSynchronizer);
 
 public:
   SingleWriterSynchronizer();
 
   // Enter a critical section for this synchronizer.  Entering a
@@ -87,15 +85,15 @@
   // RAII class for managing enter/exit pairs.
   class CriticalSection;
 };
 
 inline uint SingleWriterSynchronizer::enter() {
-  return Atomic::add(2u, &_enter);
+  return Atomic::add(&_enter, 2u);
 }
 
 inline void SingleWriterSynchronizer::exit(uint enter_value) {
-  uint exit_value = Atomic::add(2u, &_exit[enter_value & 1]);
+  uint exit_value = Atomic::add(&_exit[enter_value & 1], 2u);
   // If this exit completes a synchronize request, wakeup possibly
   // waiting synchronizer.  Read of _waiting_for must follow the _exit
   // update.
   if (exit_value == _waiting_for) {
     _wakeup.signal();

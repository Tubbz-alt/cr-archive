diff a/src/hotspot/share/utilities/hashtable.inline.hpp b/src/hotspot/share/utilities/hashtable.inline.hpp
--- a/src/hotspot/share/utilities/hashtable.inline.hpp
+++ b/src/hotspot/share/utilities/hashtable.inline.hpp
@@ -24,11 +24,11 @@
 
 #ifndef SHARE_UTILITIES_HASHTABLE_INLINE_HPP
 #define SHARE_UTILITIES_HASHTABLE_INLINE_HPP
 
 #include "memory/allocation.inline.hpp"
-#include "runtime/orderAccess.hpp"
+#include "runtime/atomic.hpp"
 #include "utilities/hashtable.hpp"
 #include "utilities/dtrace.hpp"
 
 // Inline function definitions for hashtable.hpp.
 
@@ -41,19 +41,21 @@
   initialize(table_size, entry_size, 0);
   _buckets = NEW_C_HEAP_ARRAY2(HashtableBucket<F>, table_size, F, CURRENT_PC);
   for (int index = 0; index < _table_size; index++) {
     _buckets[index].clear();
   }
+  _stats_rate = TableRateStatistics();
 }
 
 
 template <MEMFLAGS F> inline BasicHashtable<F>::BasicHashtable(int table_size, int entry_size,
                                       HashtableBucket<F>* buckets,
                                       int number_of_entries) {
   // Called on startup, no locking needed
   initialize(table_size, entry_size, number_of_entries);
   _buckets = buckets;
+  _stats_rate = TableRateStatistics();
 }
 
 template <MEMFLAGS F> inline BasicHashtable<F>::~BasicHashtable() {
   for (int i = 0; i < _entry_blocks->length(); i++) {
     FREE_C_HEAP_ARRAY(char, _entry_blocks->at(i));
@@ -84,36 +86,43 @@
 template <MEMFLAGS F> inline void HashtableBucket<F>::set_entry(BasicHashtableEntry<F>* l) {
   // Warning: Preserve store ordering.  The PackageEntryTable, ModuleEntryTable and
   //          SystemDictionary are read without locks.  The new entry must be
   //          complete before other threads can be allowed to see it
   //          via a store to _buckets[index].
-  OrderAccess::release_store(&_entry, l);
+  Atomic::release_store(&_entry, l);
 }
 
 
 template <MEMFLAGS F> inline BasicHashtableEntry<F>* HashtableBucket<F>::get_entry() const {
   // Warning: Preserve load ordering.  The PackageEntryTable, ModuleEntryTable and
   //          SystemDictionary are read without locks.  The new entry must be
   //          complete before other threads can be allowed to see it
   //          via a store to _buckets[index].
-  return OrderAccess::load_acquire(&_entry);
+  return Atomic::load_acquire(&_entry);
 }
 
 
 template <MEMFLAGS F> inline void BasicHashtable<F>::set_entry(int index, BasicHashtableEntry<F>* entry) {
   _buckets[index].set_entry(entry);
+  if (entry != NULL) {
+    JFR_ONLY(_stats_rate.add();)
+  } else {
+    JFR_ONLY(_stats_rate.remove();)
+  }
 }
 
 
 template <MEMFLAGS F> inline void BasicHashtable<F>::add_entry(int index, BasicHashtableEntry<F>* entry) {
   entry->set_next(bucket(index));
   _buckets[index].set_entry(entry);
   ++_number_of_entries;
+  JFR_ONLY(_stats_rate.add();)
 }
 
 template <MEMFLAGS F> inline void BasicHashtable<F>::free_entry(BasicHashtableEntry<F>* entry) {
   entry->set_next(_free_list);
   _free_list = entry;
   --_number_of_entries;
+  JFR_ONLY(_stats_rate.remove();)
 }
 
 #endif // SHARE_UTILITIES_HASHTABLE_INLINE_HPP

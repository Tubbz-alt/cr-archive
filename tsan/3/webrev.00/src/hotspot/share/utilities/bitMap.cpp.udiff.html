<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/utilities/bitMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="align.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bitMap.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/bitMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27,10 +27,11 @@</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/population_count.hpp&quot;</span>
  
  STATIC_ASSERT(sizeof(BitMap::bm_word_t) == BytesPerWord); // &quot;Implementation assumption.&quot;
  
  typedef BitMap::bm_word_t bm_word_t;
  typedef BitMap::idx_t     idx_t;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109,46 +110,46 @@</span>
    bm_word_t* ret = reallocate(allocator, map, size_in_bits, 0);
    assert(ret == NULL, &quot;Reallocate shouldn&#39;t have allocated&quot;);
  }
  
  template &lt;class Allocator&gt;
<span class="udiff-line-modified-removed">- void BitMap::resize(const Allocator&amp; allocator, idx_t new_size_in_bits) {</span>
<span class="udiff-line-modified-removed">-   bm_word_t* new_map = reallocate(allocator, map(), size(), new_size_in_bits);</span>
<span class="udiff-line-modified-added">+ void BitMap::resize(const Allocator&amp; allocator, idx_t new_size_in_bits, bool clear) {</span>
<span class="udiff-line-modified-added">+   bm_word_t* new_map = reallocate(allocator, map(), size(), new_size_in_bits, clear);</span>
  
    update(new_map, new_size_in_bits);
  }
  
  template &lt;class Allocator&gt;
<span class="udiff-line-modified-removed">- void BitMap::initialize(const Allocator&amp; allocator, idx_t size_in_bits) {</span>
<span class="udiff-line-modified-added">+ void BitMap::initialize(const Allocator&amp; allocator, idx_t size_in_bits, bool clear) {</span>
    assert(map() == NULL, &quot;precondition&quot;);
    assert(size() == 0,   &quot;precondition&quot;);
  
<span class="udiff-line-modified-removed">-   resize(allocator, size_in_bits);</span>
<span class="udiff-line-modified-added">+   resize(allocator, size_in_bits, clear);</span>
  }
  
  template &lt;class Allocator&gt;
<span class="udiff-line-modified-removed">- void BitMap::reinitialize(const Allocator&amp; allocator, idx_t new_size_in_bits) {</span>
<span class="udiff-line-modified-removed">-   // Remove previous bits.</span>
<span class="udiff-line-modified-removed">-   resize(allocator, 0);</span>
<span class="udiff-line-modified-added">+ void BitMap::reinitialize(const Allocator&amp; allocator, idx_t new_size_in_bits, bool clear) {</span>
<span class="udiff-line-modified-added">+   // Remove previous bits - no need to clear</span>
<span class="udiff-line-modified-added">+   resize(allocator, 0, false /* clear */);</span>
  
<span class="udiff-line-modified-removed">-   initialize(allocator, new_size_in_bits);</span>
<span class="udiff-line-modified-added">+   initialize(allocator, new_size_in_bits, clear);</span>
  }
  
<span class="udiff-line-modified-removed">- ResourceBitMap::ResourceBitMap(idx_t size_in_bits)</span>
<span class="udiff-line-modified-removed">-     : BitMap(allocate(ResourceBitMapAllocator(), size_in_bits), size_in_bits) {</span>
<span class="udiff-line-modified-added">+ ResourceBitMap::ResourceBitMap(idx_t size_in_bits, bool clear)</span>
<span class="udiff-line-modified-added">+     : BitMap(allocate(ResourceBitMapAllocator(), size_in_bits, clear), size_in_bits) {</span>
  }
  
  void ResourceBitMap::resize(idx_t new_size_in_bits) {
<span class="udiff-line-modified-removed">-   BitMap::resize(ResourceBitMapAllocator(), new_size_in_bits);</span>
<span class="udiff-line-modified-added">+   BitMap::resize(ResourceBitMapAllocator(), new_size_in_bits, true /* clear */);</span>
  }
  
  void ResourceBitMap::initialize(idx_t size_in_bits) {
<span class="udiff-line-modified-removed">-   BitMap::initialize(ResourceBitMapAllocator(), size_in_bits);</span>
<span class="udiff-line-modified-added">+   BitMap::initialize(ResourceBitMapAllocator(), size_in_bits, true /* clear */);</span>
  }
  
  void ResourceBitMap::reinitialize(idx_t size_in_bits) {
<span class="udiff-line-modified-removed">-   BitMap::reinitialize(ResourceBitMapAllocator(), size_in_bits);</span>
<span class="udiff-line-modified-added">+   BitMap::reinitialize(ResourceBitMapAllocator(), size_in_bits, true /* clear */);</span>
  }
  
  ArenaBitMap::ArenaBitMap(Arena* arena, idx_t size_in_bits)
      : BitMap(allocate(ArenaBitMapAllocator(arena), size_in_bits), size_in_bits) {
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -159,31 +160,44 @@</span>
  
  CHeapBitMap::~CHeapBitMap() {
    free(CHeapBitMapAllocator(_flags), map(), size());
  }
  
<span class="udiff-line-modified-removed">- void CHeapBitMap::resize(idx_t new_size_in_bits) {</span>
<span class="udiff-line-modified-removed">-   BitMap::resize(CHeapBitMapAllocator(_flags), new_size_in_bits);</span>
<span class="udiff-line-modified-added">+ void CHeapBitMap::resize(idx_t new_size_in_bits, bool clear) {</span>
<span class="udiff-line-modified-added">+   BitMap::resize(CHeapBitMapAllocator(_flags), new_size_in_bits, clear);</span>
  }
  
<span class="udiff-line-modified-removed">- void CHeapBitMap::initialize(idx_t size_in_bits) {</span>
<span class="udiff-line-modified-removed">-   BitMap::initialize(CHeapBitMapAllocator(_flags), size_in_bits);</span>
<span class="udiff-line-modified-added">+ void CHeapBitMap::initialize(idx_t size_in_bits, bool clear) {</span>
<span class="udiff-line-modified-added">+   BitMap::initialize(CHeapBitMapAllocator(_flags), size_in_bits, clear);</span>
  }
  
<span class="udiff-line-modified-removed">- void CHeapBitMap::reinitialize(idx_t size_in_bits) {</span>
<span class="udiff-line-modified-removed">-   BitMap::reinitialize(CHeapBitMapAllocator(_flags), size_in_bits);</span>
<span class="udiff-line-modified-added">+ void CHeapBitMap::reinitialize(idx_t size_in_bits, bool clear) {</span>
<span class="udiff-line-modified-added">+   BitMap::reinitialize(CHeapBitMapAllocator(_flags), size_in_bits, clear);</span>
  }
  
  #ifdef ASSERT
<span class="udiff-line-modified-removed">- void BitMap::verify_index(idx_t index) const {</span>
<span class="udiff-line-modified-removed">-   assert(index &lt; _size, &quot;BitMap index out of bounds&quot;);</span>
<span class="udiff-line-modified-added">+ void BitMap::verify_size(idx_t size_in_bits) {</span>
<span class="udiff-line-modified-added">+   assert(size_in_bits &lt;= max_size_in_bits(),</span>
<span class="udiff-line-added">+          &quot;out of bounds: &quot; SIZE_FORMAT, size_in_bits);</span>
  }
  
<span class="udiff-line-modified-removed">- void BitMap::verify_range(idx_t beg_index, idx_t end_index) const {</span>
<span class="udiff-line-modified-removed">-   assert(beg_index &lt;= end_index, &quot;BitMap range error&quot;);</span>
<span class="udiff-line-modified-removed">-   // Note that [0,0) and [size,size) are both valid ranges.</span>
<span class="udiff-line-modified-removed">-   if (end_index != _size) verify_index(end_index);</span>
<span class="udiff-line-modified-added">+ void BitMap::verify_index(idx_t bit) const {</span>
<span class="udiff-line-modified-added">+   assert(bit &lt; _size,</span>
<span class="udiff-line-modified-added">+          &quot;BitMap index out of bounds: &quot; SIZE_FORMAT &quot; &gt;= &quot; SIZE_FORMAT,</span>
<span class="udiff-line-modified-added">+          bit, _size);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void BitMap::verify_limit(idx_t bit) const {</span>
<span class="udiff-line-added">+   assert(bit &lt;= _size,</span>
<span class="udiff-line-added">+          &quot;BitMap limit out of bounds: &quot; SIZE_FORMAT &quot; &gt; &quot; SIZE_FORMAT,</span>
<span class="udiff-line-added">+          bit, _size);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void BitMap::verify_range(idx_t beg, idx_t end) const {</span>
<span class="udiff-line-added">+   assert(beg &lt;= end,</span>
<span class="udiff-line-added">+          &quot;BitMap range error: &quot; SIZE_FORMAT &quot; &gt; &quot; SIZE_FORMAT, beg, end);</span>
<span class="udiff-line-added">+   verify_limit(end);</span>
  }
  #endif // #ifdef ASSERT
  
  void BitMap::pretouch() {
    os::pretouch_memory(word_addr(0), word_addr(size()));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -215,23 +229,23 @@</span>
      bm_word_t* pw = word_addr(beg);
      bm_word_t  w  = *pw;
      bm_word_t  mr = inverted_bit_mask_for_range(beg, end);
      bm_word_t  nw = value ? (w | ~mr) : (w &amp; mr);
      while (true) {
<span class="udiff-line-modified-removed">-       bm_word_t res = Atomic::cmpxchg(nw, pw, w);</span>
<span class="udiff-line-modified-added">+       bm_word_t res = Atomic::cmpxchg(pw, w, nw);</span>
        if (res == w) break;
        w  = res;
        nw = value ? (w | ~mr) : (w &amp; mr);
      }
    }
  }
  
  void BitMap::set_range(idx_t beg, idx_t end) {
    verify_range(beg, end);
  
<span class="udiff-line-modified-removed">-   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="udiff-line-modified-removed">-   idx_t end_full_word = word_index(end);</span>
<span class="udiff-line-modified-added">+   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="udiff-line-modified-added">+   idx_t end_full_word = to_words_align_down(end);</span>
  
    if (beg_full_word &lt; end_full_word) {
      // The range includes at least one full word.
      set_range_within_word(beg, bit_index(beg_full_word));
      set_range_of_words(beg_full_word, end_full_word);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -245,12 +259,12 @@</span>
  }
  
  void BitMap::clear_range(idx_t beg, idx_t end) {
    verify_range(beg, end);
  
<span class="udiff-line-modified-removed">-   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="udiff-line-modified-removed">-   idx_t end_full_word = word_index(end);</span>
<span class="udiff-line-modified-added">+   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="udiff-line-modified-added">+   idx_t end_full_word = to_words_align_down(end);</span>
  
    if (beg_full_word &lt; end_full_word) {
      // The range includes at least one full word.
      clear_range_within_word(beg, bit_index(beg_full_word));
      clear_range_of_words(beg_full_word, end_full_word);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -263,21 +277,23 @@</span>
    }
  }
  
  bool BitMap::is_small_range_of_words(idx_t beg_full_word, idx_t end_full_word) {
    // There is little point to call large version on small ranges.
<span class="udiff-line-modified-removed">-   // Need to check carefully, keeping potential idx_t underflow in mind.</span>
<span class="udiff-line-modified-added">+   // Need to check carefully, keeping potential idx_t over/underflow in mind,</span>
<span class="udiff-line-added">+   // because beg_full_word &gt; end_full_word can occur when beg and end are in</span>
<span class="udiff-line-added">+   // the same word.</span>
    // The threshold should be at least one word.
    STATIC_ASSERT(small_range_words &gt;= 1);
<span class="udiff-line-modified-removed">-   return (beg_full_word + small_range_words &gt;= end_full_word);</span>
<span class="udiff-line-modified-added">+   return beg_full_word + small_range_words &gt;= end_full_word;</span>
  }
  
  void BitMap::set_large_range(idx_t beg, idx_t end) {
    verify_range(beg, end);
  
<span class="udiff-line-modified-removed">-   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="udiff-line-modified-removed">-   idx_t end_full_word = word_index(end);</span>
<span class="udiff-line-modified-added">+   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="udiff-line-modified-added">+   idx_t end_full_word = to_words_align_down(end);</span>
  
    if (is_small_range_of_words(beg_full_word, end_full_word)) {
      set_range(beg, end);
      return;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -289,12 +305,12 @@</span>
  }
  
  void BitMap::clear_large_range(idx_t beg, idx_t end) {
    verify_range(beg, end);
  
<span class="udiff-line-modified-removed">-   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="udiff-line-modified-removed">-   idx_t end_full_word = word_index(end);</span>
<span class="udiff-line-modified-added">+   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="udiff-line-modified-added">+   idx_t end_full_word = to_words_align_down(end);</span>
  
    if (is_small_range_of_words(beg_full_word, end_full_word)) {
      clear_range(beg, end);
      return;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -341,12 +357,12 @@</span>
  }
  
  void BitMap::par_at_put_range(idx_t beg, idx_t end, bool value) {
    verify_range(beg, end);
  
<span class="udiff-line-modified-removed">-   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="udiff-line-modified-removed">-   idx_t end_full_word = word_index(end);</span>
<span class="udiff-line-modified-added">+   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="udiff-line-modified-added">+   idx_t end_full_word = to_words_align_down(end);</span>
  
    if (beg_full_word &lt; end_full_word) {
      // The range includes at least one full word.
      par_put_range_within_word(beg, bit_index(beg_full_word), value);
      if (value) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -373,12 +389,12 @@</span>
  }
  
  void BitMap::par_at_put_large_range(idx_t beg, idx_t end, bool value) {
    verify_range(beg, end);
  
<span class="udiff-line-modified-removed">-   idx_t beg_full_word = word_index_round_up(beg);</span>
<span class="udiff-line-modified-removed">-   idx_t end_full_word = word_index(end);</span>
<span class="udiff-line-modified-added">+   idx_t beg_full_word = to_words_align_up(beg);</span>
<span class="udiff-line-modified-added">+   idx_t end_full_word = to_words_align_down(end);</span>
  
    if (is_small_range_of_words(beg_full_word, end_full_word)) {
      par_at_put_range(beg, end, value);
      return;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -418,11 +434,11 @@</span>
  
  bool BitMap::contains(const BitMap&amp; other) const {
    assert(size() == other.size(), &quot;must have same size&quot;);
    const bm_word_t* dest_map = map();
    const bm_word_t* other_map = other.map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      // false if other bitmap has bits set which are clear in this bitmap.
      if ((~dest_map[index] &amp; other_map[index]) != 0) return false;
    }
    idx_t rest = bit_in_word(size());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -433,11 +449,11 @@</span>
  
  bool BitMap::intersects(const BitMap&amp; other) const {
    assert(size() == other.size(), &quot;must have same size&quot;);
    const bm_word_t* dest_map = map();
    const bm_word_t* other_map = other.map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      if ((dest_map[index] &amp; other_map[index]) != 0) return true;
    }
    idx_t rest = bit_in_word(size());
    // false unless there is a partial-word tail with non-empty intersection.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -446,11 +462,11 @@</span>
  
  void BitMap::set_union(const BitMap&amp; other) {
    assert(size() == other.size(), &quot;must have same size&quot;);
    bm_word_t* dest_map = map();
    const bm_word_t* other_map = other.map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      dest_map[index] |= other_map[index];
    }
    idx_t rest = bit_in_word(size());
    if (rest &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -461,11 +477,11 @@</span>
  
  void BitMap::set_difference(const BitMap&amp; other) {
    assert(size() == other.size(), &quot;must have same size&quot;);
    bm_word_t* dest_map = map();
    const bm_word_t* other_map = other.map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      dest_map[index] &amp;= ~other_map[index];
    }
    idx_t rest = bit_in_word(size());
    if (rest &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -476,11 +492,11 @@</span>
  
  void BitMap::set_intersection(const BitMap&amp; other) {
    assert(size() == other.size(), &quot;must have same size&quot;);
    bm_word_t* dest_map = map();
    const bm_word_t* other_map = other.map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      dest_map[index] &amp;= other_map[index];
    }
    idx_t rest = bit_in_word(size());
    if (rest &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -492,11 +508,11 @@</span>
  bool BitMap::set_union_with_result(const BitMap&amp; other) {
    assert(size() == other.size(), &quot;must have same size&quot;);
    bool changed = false;
    bm_word_t* dest_map = map();
    const bm_word_t* other_map = other.map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      bm_word_t orig = dest_map[index];
      bm_word_t temp = orig | other_map[index];
      changed = changed || (temp != orig);
      dest_map[index] = temp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -514,11 +530,11 @@</span>
  bool BitMap::set_difference_with_result(const BitMap&amp; other) {
    assert(size() == other.size(), &quot;must have same size&quot;);
    bool changed = false;
    bm_word_t* dest_map = map();
    const bm_word_t* other_map = other.map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      bm_word_t orig = dest_map[index];
      bm_word_t temp = orig &amp; ~other_map[index];
      changed = changed || (temp != orig);
      dest_map[index] = temp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -536,11 +552,11 @@</span>
  bool BitMap::set_intersection_with_result(const BitMap&amp; other) {
    assert(size() == other.size(), &quot;must have same size&quot;);
    bool changed = false;
    bm_word_t* dest_map = map();
    const bm_word_t* other_map = other.map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      bm_word_t orig = dest_map[index];
      bm_word_t temp = orig &amp; other_map[index];
      changed = changed || (temp != orig);
      dest_map[index] = temp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -557,11 +573,11 @@</span>
  
  void BitMap::set_from(const BitMap&amp; other) {
    assert(size() == other.size(), &quot;must have same size&quot;);
    bm_word_t* dest_map = map();
    const bm_word_t* other_map = other.map();
<span class="udiff-line-modified-removed">-   idx_t copy_words = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t copy_words = to_words_align_down(size());</span>
    Copy::disjoint_words((HeapWord*)other_map, (HeapWord*)dest_map, copy_words);
    idx_t rest = bit_in_word(size());
    if (rest &gt; 0) {
      dest_map[copy_words] = merge_tail_of_map(other_map[copy_words],
                                               dest_map[copy_words],
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -571,31 +587,31 @@</span>
  
  bool BitMap::is_same(const BitMap&amp; other) const {
    assert(size() == other.size(), &quot;must have same size&quot;);
    const bm_word_t* dest_map = map();
    const bm_word_t* other_map = other.map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      if (dest_map[index] != other_map[index]) return false;
    }
    idx_t rest = bit_in_word(size());
    return (rest == 0) || (tail_of_map(dest_map[limit] ^ other_map[limit], rest) == 0);
  }
  
  bool BitMap::is_full() const {
    const bm_word_t* words = map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      if (~words[index] != 0) return false;
    }
    idx_t rest = bit_in_word(size());
    return (rest == 0) || (tail_of_map(~words[limit], rest) == 0);
  }
  
  bool BitMap::is_empty() const {
    const bm_word_t* words = map();
<span class="udiff-line-modified-removed">-   idx_t limit = word_index(size());</span>
<span class="udiff-line-modified-added">+   idx_t limit = to_words_align_down(size());</span>
    for (idx_t index = 0; index &lt; limit; ++index) {
      if (words[index] != 0) return false;
    }
    idx_t rest = bit_in_word(size());
    return (rest == 0) || (tail_of_map(words[limit], rest) == 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -610,12 +626,12 @@</span>
  // currently sampled will not be seen. Note also that the
  // interval [leftOffset, rightOffset) is right open.
  bool BitMap::iterate(BitMapClosure* blk, idx_t leftOffset, idx_t rightOffset) {
    verify_range(leftOffset, rightOffset);
  
<span class="udiff-line-modified-removed">-   idx_t startIndex = word_index(leftOffset);</span>
<span class="udiff-line-modified-removed">-   idx_t endIndex   = MIN2(word_index(rightOffset) + 1, size_in_words());</span>
<span class="udiff-line-modified-added">+   idx_t startIndex = to_words_align_down(leftOffset);</span>
<span class="udiff-line-modified-added">+   idx_t endIndex   = to_words_align_up(rightOffset);</span>
    for (idx_t index = startIndex, offset = leftOffset;
         offset &lt; rightOffset &amp;&amp; index &lt; endIndex;
         offset = (++index) &lt;&lt; LogBitsPerWord) {
      idx_t rest = map(index) &gt;&gt; (offset &amp; (BitsPerWord - 1));
      for (; offset &lt; rightOffset &amp;&amp; rest != 0; offset++) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -629,54 +645,15 @@</span>
      }
    }
    return true;
  }
  
<span class="udiff-line-removed">- const BitMap::idx_t* BitMap::_pop_count_table = NULL;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void BitMap::init_pop_count_table() {</span>
<span class="udiff-line-removed">-   if (_pop_count_table == NULL) {</span>
<span class="udiff-line-removed">-     BitMap::idx_t *table = NEW_C_HEAP_ARRAY(idx_t, 256, mtInternal);</span>
<span class="udiff-line-removed">-     for (uint i = 0; i &lt; 256; i++) {</span>
<span class="udiff-line-removed">-       table[i] = num_set_bits(i);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (!Atomic::replace_if_null(table, &amp;_pop_count_table)) {</span>
<span class="udiff-line-removed">-       guarantee(_pop_count_table != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-       FREE_C_HEAP_ARRAY(idx_t, table);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- BitMap::idx_t BitMap::num_set_bits(bm_word_t w) {</span>
<span class="udiff-line-removed">-   idx_t bits = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   while (w != 0) {</span>
<span class="udiff-line-removed">-     while ((w &amp; 1) == 0) {</span>
<span class="udiff-line-removed">-       w &gt;&gt;= 1;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     bits++;</span>
<span class="udiff-line-removed">-     w &gt;&gt;= 1;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return bits;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- BitMap::idx_t BitMap::num_set_bits_from_table(unsigned char c) {</span>
<span class="udiff-line-removed">-   assert(_pop_count_table != NULL, &quot;precondition&quot;);</span>
<span class="udiff-line-removed">-   return _pop_count_table[c];</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  BitMap::idx_t BitMap::count_one_bits() const {
<span class="udiff-line-removed">-   init_pop_count_table(); // If necessary.</span>
    idx_t sum = 0;
<span class="udiff-line-removed">-   typedef unsigned char uchar;</span>
    for (idx_t i = 0; i &lt; size_in_words(); i++) {
      bm_word_t w = map()[i];
<span class="udiff-line-modified-removed">-     for (size_t j = 0; j &lt; sizeof(bm_word_t); j++) {</span>
<span class="udiff-line-removed">-       sum += num_set_bits_from_table(uchar(w &amp; 255));</span>
<span class="udiff-line-removed">-       w &gt;&gt;= 8;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     sum += population_count(w);</span>
    }
    return sum;
  }
  
  void BitMap::print_on_error(outputStream* st, const char* prefix) const {
</pre>
<center><a href="align.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bitMap.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
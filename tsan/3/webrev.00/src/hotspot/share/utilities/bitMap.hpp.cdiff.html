<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/bitMap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bitMap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bitMap.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/bitMap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,17 ***</span>
  
  #ifndef SHARE_UTILITIES_BITMAP_HPP
  #define SHARE_UTILITIES_BITMAP_HPP
  
  #include &quot;memory/allocation.hpp&quot;
<span class="line-modified">! #include &quot;utilities/align.hpp&quot;</span>
  
  // Forward decl;
  class BitMapClosure;
  
  // Operations for bitmaps represented as arrays of unsigned integers.
<span class="line-modified">! // Bit offsets are numbered from 0 to size-1.</span>
  
  // The &quot;abstract&quot; base BitMap class.
  //
  // The constructor and destructor are protected to prevent
  // creation of BitMap instances outside of the BitMap class.
<span class="line-new-header">--- 24,18 ---</span>
  
  #ifndef SHARE_UTILITIES_BITMAP_HPP
  #define SHARE_UTILITIES_BITMAP_HPP
  
  #include &quot;memory/allocation.hpp&quot;
<span class="line-modified">! #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">+ #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  
  // Forward decl;
  class BitMapClosure;
  
  // Operations for bitmaps represented as arrays of unsigned integers.
<span class="line-modified">! // Bits are numbered from 0 to size-1.</span>
  
  // The &quot;abstract&quot; base BitMap class.
  //
  // The constructor and destructor are protected to prevent
  // creation of BitMap instances outside of the BitMap class.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 47,22 ***</span>
  class BitMap {
    friend class BitMap2D;
  
   public:
    typedef size_t idx_t;         // Type used for bit and word indices.
<span class="line-modified">!   typedef uintptr_t bm_word_t;  // Element type of array that represents</span>
<span class="line-modified">!                                 // the bitmap.</span>
  
    // Hints for range sizes.
    typedef enum {
      unknown_range, small_range, large_range
    } RangeSizeHint;
  
   private:
    bm_word_t* _map;     // First word in bitmap
    idx_t      _size;    // Size of bitmap (in bits)
  
    // Helper for get_next_{zero,one}_bit variants.
    // - flip designates whether searching for 1s or 0s.  Must be one of
    //   find_{zeros,ones}_flip.
    // - aligned_right is true if r_index is a priori on a bm_word_t boundary.
    template&lt;bm_word_t flip, bool aligned_right&gt;
<span class="line-new-header">--- 48,53 ---</span>
  class BitMap {
    friend class BitMap2D;
  
   public:
    typedef size_t idx_t;         // Type used for bit and word indices.
<span class="line-modified">!   typedef uintptr_t bm_word_t;  // Element type of array that represents the</span>
<span class="line-modified">!                                 // bitmap, with BitsPerWord bits per element.</span>
<span class="line-added">+   // If this were to fail, there are lots of places that would need repair.</span>
<span class="line-added">+   STATIC_ASSERT((sizeof(bm_word_t) * BitsPerByte) == BitsPerWord);</span>
  
    // Hints for range sizes.
    typedef enum {
      unknown_range, small_range, large_range
    } RangeSizeHint;
  
   private:
    bm_word_t* _map;     // First word in bitmap
    idx_t      _size;    // Size of bitmap (in bits)
  
<span class="line-added">+   // The maximum allowable size of a bitmap, in words or bits.</span>
<span class="line-added">+   // Limit max_size_in_bits so aligning up to a word boundary never overflows.</span>
<span class="line-added">+   static idx_t max_size_in_words() { return raw_to_words_align_down(~idx_t(0)); }</span>
<span class="line-added">+   static idx_t max_size_in_bits() { return max_size_in_words() * BitsPerWord; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Assumes relevant validity checking for bit has already been done.</span>
<span class="line-added">+   static idx_t raw_to_words_align_up(idx_t bit) {</span>
<span class="line-added">+     return raw_to_words_align_down(bit + (BitsPerWord - 1));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Assumes relevant validity checking for bit has already been done.</span>
<span class="line-added">+   static idx_t raw_to_words_align_down(idx_t bit) {</span>
<span class="line-added">+     return bit &gt;&gt; LogBitsPerWord;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Word-aligns bit and converts it to a word offset.</span>
<span class="line-added">+   // precondition: bit &lt;= size()</span>
<span class="line-added">+   idx_t to_words_align_up(idx_t bit) const {</span>
<span class="line-added">+     verify_limit(bit);</span>
<span class="line-added">+     return raw_to_words_align_up(bit);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Word-aligns bit and converts it to a word offset.</span>
<span class="line-added">+   // precondition: bit &lt;= size()</span>
<span class="line-added">+   inline idx_t to_words_align_down(idx_t bit) const {</span>
<span class="line-added">+     verify_limit(bit);</span>
<span class="line-added">+     return raw_to_words_align_down(bit);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Helper for get_next_{zero,one}_bit variants.
    // - flip designates whether searching for 1s or 0s.  Must be one of
    //   find_{zeros,ones}_flip.
    // - aligned_right is true if r_index is a priori on a bm_word_t boundary.
    template&lt;bm_word_t flip, bool aligned_right&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,39 ***</span>
  
    // Threshold for performing small range operation, even when large range
    // operation was requested. Measured in words.
    static const size_t small_range_words = 32;
  
   protected:
    // Return the position of bit within the word that contains it (e.g., if
    // bitmap words are 32 bits, return a number 0 &lt;= n &lt;= 31).
    static idx_t bit_in_word(idx_t bit) { return bit &amp; (BitsPerWord - 1); }
  
    // Return a mask that will select the specified bit, when applied to the word
    // containing the bit.
    static bm_word_t bit_mask(idx_t bit) { return (bm_word_t)1 &lt;&lt; bit_in_word(bit); }
  
<span class="line-removed">-   // Return the index of the word containing the specified bit.</span>
<span class="line-removed">-   static idx_t word_index(idx_t bit)  { return bit &gt;&gt; LogBitsPerWord; }</span>
<span class="line-removed">- </span>
    // Return the bit number of the first bit in the specified word.
    static idx_t bit_index(idx_t word)  { return word &lt;&lt; LogBitsPerWord; }
  
    // Return the array of bitmap words, or a specific word from it.
    bm_word_t* map()                 { return _map; }
    const bm_word_t* map() const     { return _map; }
    bm_word_t  map(idx_t word) const { return _map[word]; }
  
    // Return a pointer to the word containing the specified bit.
<span class="line-modified">!   bm_word_t* word_addr(idx_t bit)             { return map() + word_index(bit); }</span>
<span class="line-modified">!   const bm_word_t* word_addr(idx_t bit) const { return map() + word_index(bit); }</span>
  
    // Set a word to a specified value or to all ones; clear a word.
    void set_word  (idx_t word, bm_word_t val) { _map[word] = val; }
    void set_word  (idx_t word)            { set_word(word, ~(bm_word_t)0); }
    void clear_word(idx_t word)            { _map[word] = 0; }
  
    // Utilities for ranges of bits.  Ranges are half-open [beg, end).
  
    // Ranges within a single word.
    bm_word_t inverted_bit_mask_for_range(idx_t beg, idx_t end) const;
    void  set_range_within_word      (idx_t beg, idx_t end);
<span class="line-new-header">--- 106,44 ---</span>
  
    // Threshold for performing small range operation, even when large range
    // operation was requested. Measured in words.
    static const size_t small_range_words = 32;
  
<span class="line-added">+   static bool is_small_range_of_words(idx_t beg_full_word, idx_t end_full_word);</span>
<span class="line-added">+ </span>
   protected:
    // Return the position of bit within the word that contains it (e.g., if
    // bitmap words are 32 bits, return a number 0 &lt;= n &lt;= 31).
    static idx_t bit_in_word(idx_t bit) { return bit &amp; (BitsPerWord - 1); }
  
    // Return a mask that will select the specified bit, when applied to the word
    // containing the bit.
    static bm_word_t bit_mask(idx_t bit) { return (bm_word_t)1 &lt;&lt; bit_in_word(bit); }
  
    // Return the bit number of the first bit in the specified word.
    static idx_t bit_index(idx_t word)  { return word &lt;&lt; LogBitsPerWord; }
  
    // Return the array of bitmap words, or a specific word from it.
    bm_word_t* map()                 { return _map; }
    const bm_word_t* map() const     { return _map; }
    bm_word_t  map(idx_t word) const { return _map[word]; }
  
    // Return a pointer to the word containing the specified bit.
<span class="line-modified">!   bm_word_t* word_addr(idx_t bit) {</span>
<span class="line-modified">!     return map() + to_words_align_down(bit);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   const bm_word_t* word_addr(idx_t bit) const {</span>
<span class="line-added">+     return map() + to_words_align_down(bit);</span>
<span class="line-added">+   }</span>
  
    // Set a word to a specified value or to all ones; clear a word.
    void set_word  (idx_t word, bm_word_t val) { _map[word] = val; }
    void set_word  (idx_t word)            { set_word(word, ~(bm_word_t)0); }
    void clear_word(idx_t word)            { _map[word] = 0; }
  
<span class="line-added">+   static inline const bm_word_t load_word_ordered(const volatile bm_word_t* const addr, atomic_memory_order memory_order);</span>
<span class="line-added">+ </span>
    // Utilities for ranges of bits.  Ranges are half-open [beg, end).
  
    // Ranges within a single word.
    bm_word_t inverted_bit_mask_for_range(idx_t beg, idx_t end) const;
    void  set_range_within_word      (idx_t beg, idx_t end);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,24 ***</span>
    void      set_large_range_of_words   (idx_t beg, idx_t end);
    void      clear_large_range_of_words (idx_t beg, idx_t end);
  
    static void clear_range_of_words(bm_word_t* map, idx_t beg, idx_t end);
  
<span class="line-removed">-   static bool is_small_range_of_words(idx_t beg_full_word, idx_t end_full_word);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // The index of the first full word in a range.</span>
<span class="line-removed">-   idx_t word_index_round_up(idx_t bit) const;</span>
<span class="line-removed">- </span>
    // Verification.
<span class="line-removed">-   void verify_index(idx_t index) const NOT_DEBUG_RETURN;</span>
<span class="line-removed">-   void verify_range(idx_t beg_index, idx_t end_index) const NOT_DEBUG_RETURN;</span>
  
<span class="line-modified">!   // Statistics.</span>
<span class="line-modified">!   static const idx_t* _pop_count_table;</span>
<span class="line-modified">!   static void init_pop_count_table();</span>
<span class="line-modified">!   static idx_t num_set_bits(bm_word_t w);</span>
<span class="line-modified">!   static idx_t num_set_bits_from_table(unsigned char c);</span>
  
    // Allocation Helpers.
  
    // Allocates and clears the bitmap memory.
    template &lt;class Allocator&gt;
<span class="line-new-header">--- 156,20 ---</span>
    void      set_large_range_of_words   (idx_t beg, idx_t end);
    void      clear_large_range_of_words (idx_t beg, idx_t end);
  
    static void clear_range_of_words(bm_word_t* map, idx_t beg, idx_t end);
  
    // Verification.
  
<span class="line-modified">!   // Verify size_in_bits does not exceed max_size_in_bits().</span>
<span class="line-modified">!   static void verify_size(idx_t size_in_bits) NOT_DEBUG_RETURN;</span>
<span class="line-modified">!   // Verify bit is less than size().</span>
<span class="line-modified">!   void verify_index(idx_t bit) const NOT_DEBUG_RETURN;</span>
<span class="line-modified">!   // Verify bit is not greater than size().</span>
<span class="line-added">+   void verify_limit(idx_t bit) const NOT_DEBUG_RETURN;</span>
<span class="line-added">+   // Verify [beg,end) is a valid range, e.g. beg &lt;= end &lt;= size().</span>
<span class="line-added">+   void verify_range(idx_t beg, idx_t end) const NOT_DEBUG_RETURN;</span>
  
    // Allocation Helpers.
  
    // Allocates and clears the bitmap memory.
    template &lt;class Allocator&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,78 ***</span>
    // Resize the backing bitmap memory.
    //
    // Old bits are transfered to the new memory
    // and the extended memory is cleared.
    template &lt;class Allocator&gt;
<span class="line-modified">!   void resize(const Allocator&amp; allocator, idx_t new_size_in_bits);</span>
  
    // Set up and clear the bitmap memory.
    //
    // Precondition: The bitmap was default constructed and has
    // not yet had memory allocated via resize or (re)initialize.
    template &lt;class Allocator&gt;
<span class="line-modified">!   void initialize(const Allocator&amp; allocator, idx_t size_in_bits);</span>
  
    // Set up and clear the bitmap memory.
    //
    // Can be called on previously initialized bitmaps.
    template &lt;class Allocator&gt;
<span class="line-modified">!   void reinitialize(const Allocator&amp; allocator, idx_t new_size_in_bits);</span>
  
    // Set the map and size.
    void update(bm_word_t* map, idx_t size) {
      _map = map;
      _size = size;
    }
  
    // Protected constructor and destructor.
<span class="line-modified">!   BitMap(bm_word_t* map, idx_t size_in_bits) : _map(map), _size(size_in_bits) {}</span>
    ~BitMap() {}
  
   public:
    // Pretouch the entire range of memory this BitMap covers.
    void pretouch();
  
    // Accessing
    static idx_t calc_size_in_words(size_t size_in_bits) {
<span class="line-modified">!     return word_index(size_in_bits + BitsPerWord - 1);</span>
<span class="line-modified">!   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static idx_t calc_size_in_bytes(size_t size_in_bits) {</span>
<span class="line-removed">-     return calc_size_in_words(size_in_bits) * BytesPerWord;</span>
    }
  
    idx_t size() const          { return _size; }
    idx_t size_in_words() const { return calc_size_in_words(size()); }
<span class="line-modified">!   idx_t size_in_bytes() const { return calc_size_in_bytes(size()); }</span>
  
    bool at(idx_t index) const {
      verify_index(index);
      return (*word_addr(index) &amp; bit_mask(index)) != 0;
    }
  
<span class="line-modified">!   // Align bit index up or down to the next bitmap word boundary, or check</span>
<span class="line-modified">!   // alignment.</span>
<span class="line-removed">-   static idx_t word_align_up(idx_t bit) {</span>
<span class="line-removed">-     return align_up(bit, BitsPerWord);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   static idx_t word_align_down(idx_t bit) {</span>
<span class="line-removed">-     return align_down(bit, BitsPerWord);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   static bool is_word_aligned(idx_t bit) {</span>
<span class="line-removed">-     return word_align_up(bit) == bit;</span>
<span class="line-removed">-   }</span>
  
    // Set or clear the specified bit.
    inline void set_bit(idx_t bit);
    inline void clear_bit(idx_t bit);
  
<span class="line-modified">!   // Atomically set or clear the specified bit.</span>
<span class="line-modified">!   inline bool par_set_bit(idx_t bit);</span>
<span class="line-modified">!   inline bool par_clear_bit(idx_t bit);</span>
  
<span class="line-modified">!   // Put the given value at the given offset. The parallel version</span>
    // will CAS the value into the bitmap and is quite a bit slower.
    // The parallel version also returns a value indicating if the
    // calling thread was the one that changed the value of the bit.
    void at_put(idx_t index, bool value);
    bool par_at_put(idx_t index, bool value);
<span class="line-new-header">--- 188,73 ---</span>
    // Resize the backing bitmap memory.
    //
    // Old bits are transfered to the new memory
    // and the extended memory is cleared.
    template &lt;class Allocator&gt;
<span class="line-modified">!   void resize(const Allocator&amp; allocator, idx_t new_size_in_bits, bool clear);</span>
  
    // Set up and clear the bitmap memory.
    //
    // Precondition: The bitmap was default constructed and has
    // not yet had memory allocated via resize or (re)initialize.
    template &lt;class Allocator&gt;
<span class="line-modified">!   void initialize(const Allocator&amp; allocator, idx_t size_in_bits, bool clear);</span>
  
    // Set up and clear the bitmap memory.
    //
    // Can be called on previously initialized bitmaps.
    template &lt;class Allocator&gt;
<span class="line-modified">!   void reinitialize(const Allocator&amp; allocator, idx_t new_size_in_bits, bool clear);</span>
  
    // Set the map and size.
    void update(bm_word_t* map, idx_t size) {
      _map = map;
      _size = size;
    }
  
    // Protected constructor and destructor.
<span class="line-modified">!   BitMap(bm_word_t* map, idx_t size_in_bits) : _map(map), _size(size_in_bits) {</span>
<span class="line-added">+     verify_size(size_in_bits);</span>
<span class="line-added">+   }</span>
    ~BitMap() {}
  
   public:
    // Pretouch the entire range of memory this BitMap covers.
    void pretouch();
  
    // Accessing
    static idx_t calc_size_in_words(size_t size_in_bits) {
<span class="line-modified">!     verify_size(size_in_bits);</span>
<span class="line-modified">!     return raw_to_words_align_up(size_in_bits);</span>
    }
  
    idx_t size() const          { return _size; }
    idx_t size_in_words() const { return calc_size_in_words(size()); }
<span class="line-modified">!   idx_t size_in_bytes() const { return size_in_words() * BytesPerWord; }</span>
  
    bool at(idx_t index) const {
      verify_index(index);
      return (*word_addr(index) &amp; bit_mask(index)) != 0;
    }
  
<span class="line-modified">!   // memory_order must be memory_order_relaxed or memory_order_acquire.</span>
<span class="line-modified">!   bool par_at(idx_t index, atomic_memory_order memory_order = memory_order_acquire) const;</span>
  
    // Set or clear the specified bit.
    inline void set_bit(idx_t bit);
    inline void clear_bit(idx_t bit);
  
<span class="line-modified">!   // Attempts to change a bit to a desired value. The operation returns true if</span>
<span class="line-modified">!   // this thread changed the value of the bit. It was changed with a RMW operation</span>
<span class="line-modified">!   // using the specified memory_order. The operation returns false if the change</span>
<span class="line-added">+   // could not be set due to the bit already being observed in the desired state.</span>
<span class="line-added">+   // The atomic access that observed the bit in the desired state has acquire</span>
<span class="line-added">+   // semantics, unless memory_order is memory_order_relaxed or memory_order_release.</span>
<span class="line-added">+   inline bool par_set_bit(idx_t bit, atomic_memory_order memory_order = memory_order_conservative);</span>
<span class="line-added">+   inline bool par_clear_bit(idx_t bit, atomic_memory_order memory_order = memory_order_conservative);</span>
  
<span class="line-modified">!   // Put the given value at the given index. The parallel version</span>
    // will CAS the value into the bitmap and is quite a bit slower.
    // The parallel version also returns a value indicating if the
    // calling thread was the one that changed the value of the bit.
    void at_put(idx_t index, bool value);
    bool par_at_put(idx_t index, bool value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 327,12 ***</span>
  // A BitMap with storage in a ResourceArea.
  class ResourceBitMap : public BitMap {
  
   public:
    ResourceBitMap() : BitMap(NULL, 0) {}
<span class="line-modified">!   // Clears the bitmap memory.</span>
<span class="line-modified">!   ResourceBitMap(idx_t size_in_bits);</span>
  
    // Resize the backing bitmap memory.
    //
    // Old bits are transfered to the new memory
    // and the extended memory is cleared.
<span class="line-new-header">--- 355,12 ---</span>
  // A BitMap with storage in a ResourceArea.
  class ResourceBitMap : public BitMap {
  
   public:
    ResourceBitMap() : BitMap(NULL, 0) {}
<span class="line-modified">!   // Conditionally clears the bitmap memory.</span>
<span class="line-modified">!   ResourceBitMap(idx_t size_in_bits, bool clear = true);</span>
  
    // Resize the backing bitmap memory.
    //
    // Old bits are transfered to the new memory
    // and the extended memory is cleared.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 355,23 ***</span>
   public:
    // Clears the bitmap memory.
    ArenaBitMap(Arena* arena, idx_t size_in_bits);
  
   private:
<span class="line-modified">!   // Don&#39;t allow copy or assignment.</span>
<span class="line-removed">-   ArenaBitMap(const ArenaBitMap&amp;);</span>
<span class="line-removed">-   ArenaBitMap&amp; operator=(const ArenaBitMap&amp;);</span>
  };
  
  // A BitMap with storage in the CHeap.
  class CHeapBitMap : public BitMap {
  
   private:
    // Don&#39;t allow copy or assignment, to prevent the
    // allocated memory from leaking out to other instances.
<span class="line-modified">!   CHeapBitMap(const CHeapBitMap&amp;);</span>
<span class="line-removed">-   CHeapBitMap&amp; operator=(const CHeapBitMap&amp;);</span>
  
    // NMT memory type
    MEMFLAGS _flags;
  
   public:
<span class="line-new-header">--- 383,20 ---</span>
   public:
    // Clears the bitmap memory.
    ArenaBitMap(Arena* arena, idx_t size_in_bits);
  
   private:
<span class="line-modified">!   NONCOPYABLE(ArenaBitMap);</span>
  };
  
  // A BitMap with storage in the CHeap.
  class CHeapBitMap : public BitMap {
  
   private:
    // Don&#39;t allow copy or assignment, to prevent the
    // allocated memory from leaking out to other instances.
<span class="line-modified">!   NONCOPYABLE(CHeapBitMap);</span>
  
    // NMT memory type
    MEMFLAGS _flags;
  
   public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 381,23 ***</span>
    ~CHeapBitMap();
  
    // Resize the backing bitmap memory.
    //
    // Old bits are transfered to the new memory
<span class="line-modified">!   // and the extended memory is cleared.</span>
<span class="line-modified">!   void resize(idx_t new_size_in_bits);</span>
  
<span class="line-modified">!   // Set up and clear the bitmap memory.</span>
    //
    // Precondition: The bitmap was default constructed and has
    // not yet had memory allocated via resize or initialize.
<span class="line-modified">!   void initialize(idx_t size_in_bits);</span>
  
<span class="line-modified">!   // Set up and clear the bitmap memory.</span>
    //
    // Can be called on previously initialized bitmaps.
<span class="line-modified">!   void reinitialize(idx_t size_in_bits);</span>
  };
  
  // Convenience class wrapping BitMap which provides multiple bits per slot.
  class BitMap2D {
   public:
<span class="line-new-header">--- 406,23 ---</span>
    ~CHeapBitMap();
  
    // Resize the backing bitmap memory.
    //
    // Old bits are transfered to the new memory
<span class="line-modified">!   // and the extended memory is (optionally) cleared.</span>
<span class="line-modified">!   void resize(idx_t new_size_in_bits, bool clear = true);</span>
  
<span class="line-modified">!   // Set up and (optionally) clear the bitmap memory.</span>
    //
    // Precondition: The bitmap was default constructed and has
    // not yet had memory allocated via resize or initialize.
<span class="line-modified">!   void initialize(idx_t size_in_bits, bool clear = true);</span>
  
<span class="line-modified">!   // Set up and (optionally) clear the bitmap memory.</span>
    //
    // Can be called on previously initialized bitmaps.
<span class="line-modified">!   void reinitialize(idx_t size_in_bits, bool clear = true);</span>
  };
  
  // Convenience class wrapping BitMap which provides multiple bits per slot.
  class BitMap2D {
   public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 441,9 ***</span>
  
  class BitMapClosure {
   public:
    // Callback when bit in map is set.  Should normally return &quot;true&quot;;
    // return of false indicates that the bitmap iteration should terminate.
<span class="line-modified">!   virtual bool do_bit(BitMap::idx_t offset) = 0;</span>
  };
  
  #endif // SHARE_UTILITIES_BITMAP_HPP
<span class="line-new-header">--- 466,9 ---</span>
  
  class BitMapClosure {
   public:
    // Callback when bit in map is set.  Should normally return &quot;true&quot;;
    // return of false indicates that the bitmap iteration should terminate.
<span class="line-modified">!   virtual bool do_bit(BitMap::idx_t index) = 0;</span>
  };
  
  #endif // SHARE_UTILITIES_BITMAP_HPP
</pre>
<center><a href="bitMap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bitMap.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
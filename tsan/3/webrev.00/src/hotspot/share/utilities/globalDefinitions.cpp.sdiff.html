<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/globalDefinitions.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globalCounter.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globalDefinitions.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/globalDefinitions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;

 26 #include &quot;runtime/os.hpp&quot;

 27 #include &quot;utilities/globalDefinitions.hpp&quot;

 28 
 29 // Basic error support
 30 
 31 // Info for oops within a java object.  Defaults are zero so
 32 // things will break badly if incorrectly initialized.
 33 int heapOopSize        = 0;
 34 int LogBytesPerHeapOop = 0;
 35 int LogBitsPerHeapOop  = 0;
 36 int BytesPerHeapOop    = 0;
 37 int BitsPerHeapOop     = 0;
 38 
 39 // Object alignment, in units of HeapWords.
 40 // Defaults are -1 so things will break badly if incorrectly initialized.
 41 int MinObjAlignment            = -1;
 42 int MinObjAlignmentInBytes     = -1;
 43 int MinObjAlignmentInBytesMask = 0;
 44 
 45 int LogMinObjAlignment         = -1;
 46 int LogMinObjAlignmentInBytes  = -1;
 47 
 48 // Oop encoding heap max
 49 uint64_t OopEncodingHeapMax = 0;
 50 
 51 // Something to help porters sleep at night
 52 














 53 void basic_types_init() {
 54 #ifdef ASSERT
 55 #ifdef _LP64
 56   assert(min_intx ==  (intx)CONST64(0x8000000000000000), &quot;correct constant&quot;);
 57   assert(max_intx ==  CONST64(0x7FFFFFFFFFFFFFFF), &quot;correct constant&quot;);
 58   assert(max_uintx == CONST64(0xFFFFFFFFFFFFFFFF), &quot;correct constant&quot;);
 59   assert( 8 == sizeof( intx),      &quot;wrong size for basic type&quot;);
 60   assert( 8 == sizeof( jobject),   &quot;wrong size for basic type&quot;);
 61 #else
 62   assert(min_intx ==  (intx)0x80000000,  &quot;correct constant&quot;);
 63   assert(max_intx ==  0x7FFFFFFF,  &quot;correct constant&quot;);
 64   assert(max_uintx == 0xFFFFFFFF,  &quot;correct constant&quot;);
 65   assert( 4 == sizeof( intx),      &quot;wrong size for basic type&quot;);
 66   assert( 4 == sizeof( jobject),   &quot;wrong size for basic type&quot;);
 67 #endif
 68   assert( (~max_juint) == 0,  &quot;max_juint has all its bits&quot;);
 69   assert( (~max_uintx) == 0,  &quot;max_uintx has all its bits&quot;);
 70   assert( (~max_julong) == 0, &quot;max_julong has all its bits&quot;);
 71   assert( 1 == sizeof( jbyte),     &quot;wrong size for basic type&quot;);
 72   assert( 2 == sizeof( jchar),     &quot;wrong size for basic type&quot;);
 73   assert( 2 == sizeof( jshort),    &quot;wrong size for basic type&quot;);
 74   assert( 4 == sizeof( juint),     &quot;wrong size for basic type&quot;);
 75   assert( 4 == sizeof( jint),      &quot;wrong size for basic type&quot;);
 76   assert( 1 == sizeof( jboolean),  &quot;wrong size for basic type&quot;);
 77   assert( 8 == sizeof( jlong),     &quot;wrong size for basic type&quot;);
 78   assert( 4 == sizeof( jfloat),    &quot;wrong size for basic type&quot;);
 79   assert( 8 == sizeof( jdouble),   &quot;wrong size for basic type&quot;);
 80   assert( 1 == sizeof( u1),        &quot;wrong size for basic type&quot;);
 81   assert( 2 == sizeof( u2),        &quot;wrong size for basic type&quot;);
 82   assert( 4 == sizeof( u4),        &quot;wrong size for basic type&quot;);
 83   assert(wordSize == BytesPerWord, &quot;should be the same since they&#39;re used interchangeably&quot;);
 84   assert(wordSize == HeapWordSize, &quot;should be the same since they&#39;re also used interchangeably&quot;);
 85 


 86   int num_type_chars = 0;
 87   for (int i = 0; i &lt; 99; i++) {
 88     if (type2char((BasicType)i) != 0) {
 89       assert(char2type(type2char((BasicType)i)) == i, &quot;proper inverses&quot;);

 90       num_type_chars++;
 91     }
 92   }
 93   assert(num_type_chars == 11, &quot;must have tested the right number of mappings&quot;);
 94   assert(char2type(0) == T_ILLEGAL, &quot;correct illegality&quot;);
 95 
 96   {
 97     for (int i = T_BOOLEAN; i &lt;= T_CONFLICT; i++) {
 98       BasicType vt = (BasicType)i;
 99       BasicType ft = type2field[vt];
100       switch (vt) {
101       // the following types might plausibly show up in memory layouts:
102       case T_BOOLEAN:
103       case T_BYTE:
104       case T_CHAR:
105       case T_SHORT:
106       case T_INT:
107       case T_FLOAT:
108       case T_DOUBLE:
109       case T_LONG:
</pre>
<hr />
<pre>
160   if (UseCompressedOops) {
161     // Size info for oops within java objects is fixed
162     heapOopSize        = jintSize;
163     LogBytesPerHeapOop = LogBytesPerInt;
164     LogBitsPerHeapOop  = LogBitsPerInt;
165     BytesPerHeapOop    = BytesPerInt;
166     BitsPerHeapOop     = BitsPerInt;
167   } else {
168     heapOopSize        = oopSize;
169     LogBytesPerHeapOop = LogBytesPerWord;
170     LogBitsPerHeapOop  = LogBitsPerWord;
171     BytesPerHeapOop    = BytesPerWord;
172     BitsPerHeapOop     = BitsPerWord;
173   }
174   _type2aelembytes[T_OBJECT] = heapOopSize;
175   _type2aelembytes[T_ARRAY]  = heapOopSize;
176 }
177 
178 
179 // Map BasicType to signature character
<span class="line-modified">180 char type2char_tab[T_CONFLICT+1]={ 0, 0, 0, 0, &#39;Z&#39;, &#39;C&#39;, &#39;F&#39;, &#39;D&#39;, &#39;B&#39;, &#39;S&#39;, &#39;I&#39;, &#39;J&#39;, &#39;L&#39;, &#39;[&#39;, &#39;V&#39;, 0, 0, 0, 0, 0};</span>









181 
182 // Map BasicType to Java type name
183 const char* type2name_tab[T_CONFLICT+1] = {
184   NULL, NULL, NULL, NULL,
185   &quot;boolean&quot;,
186   &quot;char&quot;,
187   &quot;float&quot;,
188   &quot;double&quot;,
189   &quot;byte&quot;,
190   &quot;short&quot;,
191   &quot;int&quot;,
192   &quot;long&quot;,
193   &quot;object&quot;,
194   &quot;array&quot;,
195   &quot;void&quot;,
196   &quot;*address*&quot;,
197   &quot;*narrowoop*&quot;,
198   &quot;*metadata*&quot;,
199   &quot;*narrowklass*&quot;,
200   &quot;*conflict*&quot;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<span class="line-added"> 26 #include &quot;runtime/globals.hpp&quot;</span>
 27 #include &quot;runtime/os.hpp&quot;
<span class="line-added"> 28 #include &quot;runtime/signature.hpp&quot;</span>
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-added"> 30 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 31 
 32 // Basic error support
 33 
 34 // Info for oops within a java object.  Defaults are zero so
 35 // things will break badly if incorrectly initialized.
 36 int heapOopSize        = 0;
 37 int LogBytesPerHeapOop = 0;
 38 int LogBitsPerHeapOop  = 0;
 39 int BytesPerHeapOop    = 0;
 40 int BitsPerHeapOop     = 0;
 41 
 42 // Object alignment, in units of HeapWords.
 43 // Defaults are -1 so things will break badly if incorrectly initialized.
 44 int MinObjAlignment            = -1;
 45 int MinObjAlignmentInBytes     = -1;
 46 int MinObjAlignmentInBytesMask = 0;
 47 
 48 int LogMinObjAlignment         = -1;
 49 int LogMinObjAlignmentInBytes  = -1;
 50 
 51 // Oop encoding heap max
 52 uint64_t OopEncodingHeapMax = 0;
 53 
 54 // Something to help porters sleep at night
 55 
<span class="line-added"> 56 #ifdef ASSERT</span>
<span class="line-added"> 57 BasicType char2type(int ch) {</span>
<span class="line-added"> 58   switch (ch) {</span>
<span class="line-added"> 59 #define EACH_SIG(ch, bt, ignore) \</span>
<span class="line-added"> 60     case ch: return bt;</span>
<span class="line-added"> 61     SIGNATURE_TYPES_DO(EACH_SIG, ignore)</span>
<span class="line-added"> 62 #undef EACH_SIG</span>
<span class="line-added"> 63   }</span>
<span class="line-added"> 64   return T_ILLEGAL;</span>
<span class="line-added"> 65 }</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67 extern bool signature_constants_sane();</span>
<span class="line-added"> 68 #endif //ASSERT</span>
<span class="line-added"> 69 </span>
 70 void basic_types_init() {
 71 #ifdef ASSERT
 72 #ifdef _LP64
 73   assert(min_intx ==  (intx)CONST64(0x8000000000000000), &quot;correct constant&quot;);
 74   assert(max_intx ==  CONST64(0x7FFFFFFFFFFFFFFF), &quot;correct constant&quot;);
 75   assert(max_uintx == CONST64(0xFFFFFFFFFFFFFFFF), &quot;correct constant&quot;);
 76   assert( 8 == sizeof( intx),      &quot;wrong size for basic type&quot;);
 77   assert( 8 == sizeof( jobject),   &quot;wrong size for basic type&quot;);
 78 #else
 79   assert(min_intx ==  (intx)0x80000000,  &quot;correct constant&quot;);
 80   assert(max_intx ==  0x7FFFFFFF,  &quot;correct constant&quot;);
 81   assert(max_uintx == 0xFFFFFFFF,  &quot;correct constant&quot;);
 82   assert( 4 == sizeof( intx),      &quot;wrong size for basic type&quot;);
 83   assert( 4 == sizeof( jobject),   &quot;wrong size for basic type&quot;);
 84 #endif
 85   assert( (~max_juint) == 0,  &quot;max_juint has all its bits&quot;);
 86   assert( (~max_uintx) == 0,  &quot;max_uintx has all its bits&quot;);
 87   assert( (~max_julong) == 0, &quot;max_julong has all its bits&quot;);
 88   assert( 1 == sizeof( jbyte),     &quot;wrong size for basic type&quot;);
 89   assert( 2 == sizeof( jchar),     &quot;wrong size for basic type&quot;);
 90   assert( 2 == sizeof( jshort),    &quot;wrong size for basic type&quot;);
 91   assert( 4 == sizeof( juint),     &quot;wrong size for basic type&quot;);
 92   assert( 4 == sizeof( jint),      &quot;wrong size for basic type&quot;);
 93   assert( 1 == sizeof( jboolean),  &quot;wrong size for basic type&quot;);
 94   assert( 8 == sizeof( jlong),     &quot;wrong size for basic type&quot;);
 95   assert( 4 == sizeof( jfloat),    &quot;wrong size for basic type&quot;);
 96   assert( 8 == sizeof( jdouble),   &quot;wrong size for basic type&quot;);
 97   assert( 1 == sizeof( u1),        &quot;wrong size for basic type&quot;);
 98   assert( 2 == sizeof( u2),        &quot;wrong size for basic type&quot;);
 99   assert( 4 == sizeof( u4),        &quot;wrong size for basic type&quot;);
100   assert(wordSize == BytesPerWord, &quot;should be the same since they&#39;re used interchangeably&quot;);
101   assert(wordSize == HeapWordSize, &quot;should be the same since they&#39;re also used interchangeably&quot;);
102 
<span class="line-added">103   assert(signature_constants_sane(), &quot;&quot;);</span>
<span class="line-added">104 </span>
105   int num_type_chars = 0;
106   for (int i = 0; i &lt; 99; i++) {
107     if (type2char((BasicType)i) != 0) {
108       assert(char2type(type2char((BasicType)i)) == i, &quot;proper inverses&quot;);
<span class="line-added">109       assert(Signature::basic_type(type2char((BasicType)i)) == i, &quot;proper inverses&quot;);</span>
110       num_type_chars++;
111     }
112   }
113   assert(num_type_chars == 11, &quot;must have tested the right number of mappings&quot;);
114   assert(char2type(0) == T_ILLEGAL, &quot;correct illegality&quot;);
115 
116   {
117     for (int i = T_BOOLEAN; i &lt;= T_CONFLICT; i++) {
118       BasicType vt = (BasicType)i;
119       BasicType ft = type2field[vt];
120       switch (vt) {
121       // the following types might plausibly show up in memory layouts:
122       case T_BOOLEAN:
123       case T_BYTE:
124       case T_CHAR:
125       case T_SHORT:
126       case T_INT:
127       case T_FLOAT:
128       case T_DOUBLE:
129       case T_LONG:
</pre>
<hr />
<pre>
180   if (UseCompressedOops) {
181     // Size info for oops within java objects is fixed
182     heapOopSize        = jintSize;
183     LogBytesPerHeapOop = LogBytesPerInt;
184     LogBitsPerHeapOop  = LogBitsPerInt;
185     BytesPerHeapOop    = BytesPerInt;
186     BitsPerHeapOop     = BitsPerInt;
187   } else {
188     heapOopSize        = oopSize;
189     LogBytesPerHeapOop = LogBytesPerWord;
190     LogBitsPerHeapOop  = LogBitsPerWord;
191     BytesPerHeapOop    = BytesPerWord;
192     BitsPerHeapOop     = BitsPerWord;
193   }
194   _type2aelembytes[T_OBJECT] = heapOopSize;
195   _type2aelembytes[T_ARRAY]  = heapOopSize;
196 }
197 
198 
199 // Map BasicType to signature character
<span class="line-modified">200 char type2char_tab[T_CONFLICT+1] = {</span>
<span class="line-added">201   0, 0, 0, 0,</span>
<span class="line-added">202   JVM_SIGNATURE_BOOLEAN, JVM_SIGNATURE_CHAR,</span>
<span class="line-added">203   JVM_SIGNATURE_FLOAT,   JVM_SIGNATURE_DOUBLE,</span>
<span class="line-added">204   JVM_SIGNATURE_BYTE,    JVM_SIGNATURE_SHORT,</span>
<span class="line-added">205   JVM_SIGNATURE_INT,     JVM_SIGNATURE_LONG,</span>
<span class="line-added">206   JVM_SIGNATURE_CLASS,   JVM_SIGNATURE_ARRAY,</span>
<span class="line-added">207   JVM_SIGNATURE_VOID,    0,</span>
<span class="line-added">208   0, 0, 0, 0</span>
<span class="line-added">209 };</span>
210 
211 // Map BasicType to Java type name
212 const char* type2name_tab[T_CONFLICT+1] = {
213   NULL, NULL, NULL, NULL,
214   &quot;boolean&quot;,
215   &quot;char&quot;,
216   &quot;float&quot;,
217   &quot;double&quot;,
218   &quot;byte&quot;,
219   &quot;short&quot;,
220   &quot;int&quot;,
221   &quot;long&quot;,
222   &quot;object&quot;,
223   &quot;array&quot;,
224   &quot;void&quot;,
225   &quot;*address*&quot;,
226   &quot;*narrowoop*&quot;,
227   &quot;*metadata*&quot;,
228   &quot;*narrowklass*&quot;,
229   &quot;*conflict*&quot;
</pre>
</td>
</tr>
</table>
<center><a href="globalCounter.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globalDefinitions.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
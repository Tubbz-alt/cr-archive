<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/concurrentHashTableTasks.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="concurrentHashTable.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="count_leading_zeros.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/concurrentHashTableTasks.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_CONCURRENTHASHTABLETASKS_INLINE_HPP
 26 #define SHARE_UTILITIES_CONCURRENTHASHTABLETASKS_INLINE_HPP
 27 

 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
 30 
 31 // This inline file contains BulkDeleteTask and GrowTasks which are both bucket
 32 // operations, which they are serialized with each other.
 33 
 34 // Base class for pause and/or parallel bulk operations.
<span class="line-modified"> 35 template &lt;typename VALUE, typename CONFIG, MEMFLAGS F&gt;</span>
<span class="line-modified"> 36 class ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;::BucketsOperation {</span>
 37  protected:
<span class="line-modified"> 38   ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* _cht;</span>
 39 
 40   // Default size of _task_size_log2
 41   static const size_t DEFAULT_TASK_SIZE_LOG2 = 12;
 42 
 43   // The table is split into ranges, every increment is one range.
 44   volatile size_t _next_to_claim;
 45   size_t _task_size_log2; // Number of buckets.
 46   size_t _stop_task;      // Last task
 47   size_t _size_log2;      // Table size.
 48   bool   _is_mt;
 49 
<span class="line-modified"> 50   BucketsOperation(ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* cht, bool is_mt = false)</span>
 51     : _cht(cht), _next_to_claim(0), _task_size_log2(DEFAULT_TASK_SIZE_LOG2),
 52     _stop_task(0), _size_log2(0), _is_mt(is_mt) {}
 53 
 54   // Returns true if you succeeded to claim the range start -&gt; (stop-1).
 55   bool claim(size_t* start, size_t* stop) {
<span class="line-modified"> 56     size_t claimed = Atomic::add((size_t)1, &amp;_next_to_claim) - 1;</span>
 57     if (claimed &gt;= _stop_task) {
 58       return false;
 59     }
 60     *start = claimed * (((size_t)1) &lt;&lt; _task_size_log2);
 61     *stop  = ((*start) + (((size_t)1) &lt;&lt; _task_size_log2));
 62     return true;
 63   }
 64 
 65   // Calculate starting values.
 66   void setup(Thread* thread) {
 67     thread_owns_resize_lock(thread);
 68     _size_log2 = _cht-&gt;_table-&gt;_log2_size;
 69     _task_size_log2 = MIN2(_task_size_log2, _size_log2);
 70     size_t tmp = _size_log2 &gt; _task_size_log2 ?
 71                  _size_log2 - _task_size_log2 : 0;
 72     _stop_task = (((size_t)1) &lt;&lt; tmp);
 73   }
 74 
 75   // Returns false if all ranges are claimed.
 76   bool have_more_work() {
<span class="line-modified"> 77     return OrderAccess::load_acquire(&amp;_next_to_claim) &gt;= _stop_task;</span>
 78   }
 79 
 80   void thread_owns_resize_lock(Thread* thread) {
 81     assert(BucketsOperation::_cht-&gt;_resize_lock_owner == thread,
 82            &quot;Should be locked by me&quot;);
 83     assert(BucketsOperation::_cht-&gt;_resize_lock-&gt;owned_by_self(),
 84            &quot;Operations lock not held&quot;);
 85   }
 86   void thread_owns_only_state_lock(Thread* thread) {
 87     assert(BucketsOperation::_cht-&gt;_resize_lock_owner == thread,
 88            &quot;Should be locked by me&quot;);
 89     assert(!BucketsOperation::_cht-&gt;_resize_lock-&gt;owned_by_self(),
 90            &quot;Operations lock held&quot;);
 91   }
 92   void thread_do_not_own_resize_lock(Thread* thread) {
 93     assert(!BucketsOperation::_cht-&gt;_resize_lock-&gt;owned_by_self(),
 94            &quot;Operations lock held&quot;);
 95     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != thread,
 96            &quot;Should not be locked by me&quot;);
 97   }
</pre>
<hr />
<pre>
 99 public:
100   // Pauses for safepoint
101   void pause(Thread* thread) {
102     // This leaves internal state locked.
103     this-&gt;thread_owns_resize_lock(thread);
104     BucketsOperation::_cht-&gt;_resize_lock-&gt;unlock();
105     this-&gt;thread_owns_only_state_lock(thread);
106   }
107 
108   // Continues after safepoint.
109   void cont(Thread* thread) {
110     this-&gt;thread_owns_only_state_lock(thread);
111     // If someone slips in here directly after safepoint.
112     while (!BucketsOperation::_cht-&gt;_resize_lock-&gt;try_lock())
113       { /* for ever */ };
114     this-&gt;thread_owns_resize_lock(thread);
115   }
116 };
117 
118 // For doing pausable/parallel bulk delete.
<span class="line-modified">119 template &lt;typename VALUE, typename CONFIG, MEMFLAGS F&gt;</span>
<span class="line-modified">120 class ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;::BulkDeleteTask :</span>
121   public BucketsOperation
122 {
123  public:
<span class="line-modified">124   BulkDeleteTask(ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* cht, bool is_mt = false)</span>
125     : BucketsOperation(cht, is_mt) {
126   }
127   // Before start prepare must be called.
128   bool prepare(Thread* thread) {
129     bool lock = BucketsOperation::_cht-&gt;try_resize_lock(thread);
130     if (!lock) {
131       return false;
132     }
133     this-&gt;setup(thread);
134     return true;
135   }
136 
137   // Does one range destroying all matching EVALUATE_FUNC and
138   // DELETE_FUNC is called be destruction. Returns true if there is more work.
139   template &lt;typename EVALUATE_FUNC, typename DELETE_FUNC&gt;
140   bool do_task(Thread* thread, EVALUATE_FUNC&amp; eval_f, DELETE_FUNC&amp; del_f) {
141     size_t start, stop;
142     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != NULL,
143            &quot;Should be locked&quot;);
144     if (!this-&gt;claim(&amp;start, &amp;stop)) {
145       return false;
146     }
147     BucketsOperation::_cht-&gt;do_bulk_delete_locked_for(thread, start, stop,
148                                                       eval_f, del_f,
149                                                       BucketsOperation::_is_mt);
150     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != NULL,
151            &quot;Should be locked&quot;);
152     return true;
153   }
154 
155   // Must be called after ranges are done.
156   void done(Thread* thread) {
157     this-&gt;thread_owns_resize_lock(thread);
158     BucketsOperation::_cht-&gt;unlock_resize_lock(thread);
159     this-&gt;thread_do_not_own_resize_lock(thread);
160   }
161 };
162 
<span class="line-modified">163 template &lt;typename VALUE, typename CONFIG, MEMFLAGS F&gt;</span>
<span class="line-modified">164 class ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;::GrowTask :</span>
165   public BucketsOperation
166 {
167  public:
<span class="line-modified">168   GrowTask(ConcurrentHashTable&lt;VALUE, CONFIG, F&gt;* cht) : BucketsOperation(cht) {</span>
169   }
170   // Before start prepare must be called.
171   bool prepare(Thread* thread) {
172     if (!BucketsOperation::_cht-&gt;internal_grow_prolog(
173           thread, BucketsOperation::_cht-&gt;_log2_size_limit)) {
174       return false;
175     }
176     this-&gt;setup(thread);
177     return true;
178   }
179 
180   // Re-sizes a portion of the table. Returns true if there is more work.
181   bool do_task(Thread* thread) {
182     size_t start, stop;
183     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != NULL,
184            &quot;Should be locked&quot;);
185     if (!this-&gt;claim(&amp;start, &amp;stop)) {
186       return false;
187     }
188     BucketsOperation::_cht-&gt;internal_grow_range(thread, start, stop);
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_CONCURRENTHASHTABLETASKS_INLINE_HPP
 26 #define SHARE_UTILITIES_CONCURRENTHASHTABLETASKS_INLINE_HPP
 27 
<span class="line-added"> 28 #include &quot;runtime/atomic.hpp&quot;</span>
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 #include &quot;utilities/concurrentHashTable.inline.hpp&quot;
 31 
 32 // This inline file contains BulkDeleteTask and GrowTasks which are both bucket
 33 // operations, which they are serialized with each other.
 34 
 35 // Base class for pause and/or parallel bulk operations.
<span class="line-modified"> 36 template &lt;typename CONFIG, MEMFLAGS F&gt;</span>
<span class="line-modified"> 37 class ConcurrentHashTable&lt;CONFIG, F&gt;::BucketsOperation {</span>
 38  protected:
<span class="line-modified"> 39   ConcurrentHashTable&lt;CONFIG, F&gt;* _cht;</span>
 40 
 41   // Default size of _task_size_log2
 42   static const size_t DEFAULT_TASK_SIZE_LOG2 = 12;
 43 
 44   // The table is split into ranges, every increment is one range.
 45   volatile size_t _next_to_claim;
 46   size_t _task_size_log2; // Number of buckets.
 47   size_t _stop_task;      // Last task
 48   size_t _size_log2;      // Table size.
 49   bool   _is_mt;
 50 
<span class="line-modified"> 51   BucketsOperation(ConcurrentHashTable&lt;CONFIG, F&gt;* cht, bool is_mt = false)</span>
 52     : _cht(cht), _next_to_claim(0), _task_size_log2(DEFAULT_TASK_SIZE_LOG2),
 53     _stop_task(0), _size_log2(0), _is_mt(is_mt) {}
 54 
 55   // Returns true if you succeeded to claim the range start -&gt; (stop-1).
 56   bool claim(size_t* start, size_t* stop) {
<span class="line-modified"> 57     size_t claimed = Atomic::fetch_and_add(&amp;_next_to_claim, 1u);</span>
 58     if (claimed &gt;= _stop_task) {
 59       return false;
 60     }
 61     *start = claimed * (((size_t)1) &lt;&lt; _task_size_log2);
 62     *stop  = ((*start) + (((size_t)1) &lt;&lt; _task_size_log2));
 63     return true;
 64   }
 65 
 66   // Calculate starting values.
 67   void setup(Thread* thread) {
 68     thread_owns_resize_lock(thread);
 69     _size_log2 = _cht-&gt;_table-&gt;_log2_size;
 70     _task_size_log2 = MIN2(_task_size_log2, _size_log2);
 71     size_t tmp = _size_log2 &gt; _task_size_log2 ?
 72                  _size_log2 - _task_size_log2 : 0;
 73     _stop_task = (((size_t)1) &lt;&lt; tmp);
 74   }
 75 
 76   // Returns false if all ranges are claimed.
 77   bool have_more_work() {
<span class="line-modified"> 78     return Atomic::load_acquire(&amp;_next_to_claim) &gt;= _stop_task;</span>
 79   }
 80 
 81   void thread_owns_resize_lock(Thread* thread) {
 82     assert(BucketsOperation::_cht-&gt;_resize_lock_owner == thread,
 83            &quot;Should be locked by me&quot;);
 84     assert(BucketsOperation::_cht-&gt;_resize_lock-&gt;owned_by_self(),
 85            &quot;Operations lock not held&quot;);
 86   }
 87   void thread_owns_only_state_lock(Thread* thread) {
 88     assert(BucketsOperation::_cht-&gt;_resize_lock_owner == thread,
 89            &quot;Should be locked by me&quot;);
 90     assert(!BucketsOperation::_cht-&gt;_resize_lock-&gt;owned_by_self(),
 91            &quot;Operations lock held&quot;);
 92   }
 93   void thread_do_not_own_resize_lock(Thread* thread) {
 94     assert(!BucketsOperation::_cht-&gt;_resize_lock-&gt;owned_by_self(),
 95            &quot;Operations lock held&quot;);
 96     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != thread,
 97            &quot;Should not be locked by me&quot;);
 98   }
</pre>
<hr />
<pre>
100 public:
101   // Pauses for safepoint
102   void pause(Thread* thread) {
103     // This leaves internal state locked.
104     this-&gt;thread_owns_resize_lock(thread);
105     BucketsOperation::_cht-&gt;_resize_lock-&gt;unlock();
106     this-&gt;thread_owns_only_state_lock(thread);
107   }
108 
109   // Continues after safepoint.
110   void cont(Thread* thread) {
111     this-&gt;thread_owns_only_state_lock(thread);
112     // If someone slips in here directly after safepoint.
113     while (!BucketsOperation::_cht-&gt;_resize_lock-&gt;try_lock())
114       { /* for ever */ };
115     this-&gt;thread_owns_resize_lock(thread);
116   }
117 };
118 
119 // For doing pausable/parallel bulk delete.
<span class="line-modified">120 template &lt;typename CONFIG, MEMFLAGS F&gt;</span>
<span class="line-modified">121 class ConcurrentHashTable&lt;CONFIG, F&gt;::BulkDeleteTask :</span>
122   public BucketsOperation
123 {
124  public:
<span class="line-modified">125   BulkDeleteTask(ConcurrentHashTable&lt;CONFIG, F&gt;* cht, bool is_mt = false)</span>
126     : BucketsOperation(cht, is_mt) {
127   }
128   // Before start prepare must be called.
129   bool prepare(Thread* thread) {
130     bool lock = BucketsOperation::_cht-&gt;try_resize_lock(thread);
131     if (!lock) {
132       return false;
133     }
134     this-&gt;setup(thread);
135     return true;
136   }
137 
138   // Does one range destroying all matching EVALUATE_FUNC and
139   // DELETE_FUNC is called be destruction. Returns true if there is more work.
140   template &lt;typename EVALUATE_FUNC, typename DELETE_FUNC&gt;
141   bool do_task(Thread* thread, EVALUATE_FUNC&amp; eval_f, DELETE_FUNC&amp; del_f) {
142     size_t start, stop;
143     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != NULL,
144            &quot;Should be locked&quot;);
145     if (!this-&gt;claim(&amp;start, &amp;stop)) {
146       return false;
147     }
148     BucketsOperation::_cht-&gt;do_bulk_delete_locked_for(thread, start, stop,
149                                                       eval_f, del_f,
150                                                       BucketsOperation::_is_mt);
151     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != NULL,
152            &quot;Should be locked&quot;);
153     return true;
154   }
155 
156   // Must be called after ranges are done.
157   void done(Thread* thread) {
158     this-&gt;thread_owns_resize_lock(thread);
159     BucketsOperation::_cht-&gt;unlock_resize_lock(thread);
160     this-&gt;thread_do_not_own_resize_lock(thread);
161   }
162 };
163 
<span class="line-modified">164 template &lt;typename CONFIG, MEMFLAGS F&gt;</span>
<span class="line-modified">165 class ConcurrentHashTable&lt;CONFIG, F&gt;::GrowTask :</span>
166   public BucketsOperation
167 {
168  public:
<span class="line-modified">169   GrowTask(ConcurrentHashTable&lt;CONFIG, F&gt;* cht) : BucketsOperation(cht) {</span>
170   }
171   // Before start prepare must be called.
172   bool prepare(Thread* thread) {
173     if (!BucketsOperation::_cht-&gt;internal_grow_prolog(
174           thread, BucketsOperation::_cht-&gt;_log2_size_limit)) {
175       return false;
176     }
177     this-&gt;setup(thread);
178     return true;
179   }
180 
181   // Re-sizes a portion of the table. Returns true if there is more work.
182   bool do_task(Thread* thread) {
183     size_t start, stop;
184     assert(BucketsOperation::_cht-&gt;_resize_lock_owner != NULL,
185            &quot;Should be locked&quot;);
186     if (!this-&gt;claim(&amp;start, &amp;stop)) {
187       return false;
188     }
189     BucketsOperation::_cht-&gt;internal_grow_range(thread, start, stop);
</pre>
</td>
</tr>
</table>
<center><a href="concurrentHashTable.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="count_leading_zeros.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
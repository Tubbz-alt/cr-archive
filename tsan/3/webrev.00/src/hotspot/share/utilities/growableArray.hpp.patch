diff a/src/hotspot/share/utilities/growableArray.hpp b/src/hotspot/share/utilities/growableArray.hpp
--- a/src/hotspot/share/utilities/growableArray.hpp
+++ b/src/hotspot/share/utilities/growableArray.hpp
@@ -28,10 +28,11 @@
 #include "memory/allocation.hpp"
 #include "oops/oop.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/globalDefinitions.hpp"
 #include "utilities/ostream.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 // A growable array.
 
 /*************************************************************************/
 /*                                                                       */
@@ -150,10 +151,16 @@
 };
 
 template<class E> class GrowableArrayIterator;
 template<class E, class UnaryPredicate> class GrowableArrayFilterIterator;
 
+template<class E>
+class CompareClosure : public Closure {
+public:
+    virtual int do_compare(const E&, const E&) = 0;
+};
+
 template<class E> class GrowableArray : public GenericGrowableArray {
   friend class VMStructs;
 
  private:
   E*     _data;         // data array
@@ -183,11 +190,15 @@
     int i = 0;
     for (; i < _len; i++) ::new ((void*)&_data[i]) E(filler);
     for (; i < _max; i++) ::new ((void*)&_data[i]) E();
   }
 
-  GrowableArray(Arena* arena, int initial_size, int initial_len, const E& filler) : GenericGrowableArray(arena, initial_size, initial_len) {
+  // Watch out, if filler was generated by a constructor, the destuctor might
+  // be called on the original object invalidating all the copies made here.
+  // Carefully design the copy constructor.
+  GrowableArray(Arena* arena, int initial_size, int initial_len, const E& filler) :
+      GenericGrowableArray(arena, initial_size, initial_len) {
     _data = (E*)raw_allocate(sizeof(E));
     int i = 0;
     for (; i < _len; i++) ::new ((void*)&_data[i]) E(filler);
     for (; i < _max; i++) ::new ((void*)&_data[i]) E();
   }
@@ -210,19 +221,10 @@
   bool  is_full() const         { return _len == _max; }
   DEBUG_ONLY(E* data_addr() const      { return _data; })
 
   void print();
 
-  inline static bool safe_equals(oop obj1, oop obj2) {
-    return oopDesc::equals(obj1, obj2);
-  }
-
-  template <class X>
-  inline static bool safe_equals(X i1, X i2) {
-    return i1 == i2;
-  }
-
   int append(const E& elem) {
     check_nesting();
     if (_len == _max) grow(_len);
     int idx = _len++;
     _data[idx] = elem;
@@ -303,11 +305,11 @@
     raw_at_put_grow(i, elem, fill);
   }
 
   bool contains(const E& elem) const {
     for (int i = 0; i < _len; i++) {
-      if (safe_equals(_data[i], elem)) return true;
+      if (_data[i] == elem) return true;
     }
     return false;
   }
 
   int  find(const E& elem) const {
@@ -441,19 +443,49 @@
         return mid;
       }
     }
     return min;
   }
+
+  E insert_sorted(CompareClosure<E>* cc, const E& key) {
+    bool found;
+    int location = find_sorted(cc, key, found);
+    if (!found) {
+      insert_before(location, key);
+    }
+    return at(location);
+  }
+
+  template<typename K>
+  int find_sorted(CompareClosure<E>* cc, const K& key, bool& found) {
+    found = false;
+    int min = 0;
+    int max = length() - 1;
+
+    while (max >= min) {
+      int mid = (int)(((uint)max + min) / 2);
+      E value = at(mid);
+      int diff = cc->do_compare(key, value);
+      if (diff > 0) {
+        min = mid + 1;
+      } else if (diff < 0) {
+        max = mid - 1;
+      } else {
+        found = true;
+        return mid;
+      }
+    }
+    return min;
+  }
 };
 
 // Global GrowableArray methods (one instance in the library per each 'E' type).
 
 template<class E> void GrowableArray<E>::grow(int j) {
-    // grow the array by doubling its size (amortized growth)
     int old_max = _max;
-    if (_max == 0) _max = 1; // prevent endless loop
-    while (j >= _max) _max = _max*2;
+    // grow the array by increasing _max to the first power of two larger than the size we need
+    _max = next_power_of_2((uint32_t)j);
     // j < _max
     E* newData = (E*)raw_allocate(sizeof(E));
     int i = 0;
     for (     ; i < _len; i++) ::new ((void*)&newData[i]) E(_data[i]);
 // Needed for Visual Studio 2012 and older

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/waitBarrier_generic.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre> 1 /*
 2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  *
23  */
24 
25 #include &quot;precompiled.hpp&quot;
26 #include &quot;runtime/atomic.hpp&quot;
27 #include &quot;runtime/orderAccess.hpp&quot;
28 #include &quot;runtime/os.hpp&quot;
29 #include &quot;utilities/waitBarrier_generic.hpp&quot;
30 #include &quot;utilities/spinYield.hpp&quot;
31 
32 void GenericWaitBarrier::arm(int barrier_tag) {
33   assert(_barrier_tag == 0, &quot;Already armed&quot;);
34   assert(_waiters == 0, &quot;We left a thread hanging&quot;);
35   _barrier_tag = barrier_tag;
36   _waiters = 0;
37   OrderAccess::fence();
38 }
39 
40 int GenericWaitBarrier::wake_if_needed() {
41   assert(_barrier_tag == 0, &quot;Not disarmed&quot;);
42   int w = _waiters;
43   if (w == 0) {
44     // Load of _barrier_threads in caller must not pass the load of _waiters.
45     OrderAccess::loadload();
46     return 0;
47   }
48   assert(w &gt; 0, &quot;Bad counting&quot;);
49   // We need an exact count which never goes below zero,
50   // otherwise the semaphore may be signalled too many times.
<a name="1" id="anc1"></a><span class="line-modified">51   if (Atomic::cmpxchg(w - 1, &amp;_waiters, w) == w) {</span>
52     _sem_barrier.signal();
53     return w - 1;
54   }
55   return w;
56 }
57 
58 void GenericWaitBarrier::disarm() {
59   assert(_barrier_tag != 0, &quot;Not armed&quot;);
60   _barrier_tag = 0;
61   // Loads of _barrier_threads/_waiters must not float above disarm store and
62   // disarm store must not sink below.
63   OrderAccess::fence();
64   int left;
65   SpinYield sp;
66   do {
67     left = GenericWaitBarrier::wake_if_needed();
68     if (left == 0 &amp;&amp; _barrier_threads &gt; 0) {
69       // There is no thread to wake but we still have barrier threads.
70       sp.wait();
71     }
72     // We must loop here until there are no waiters or potential waiters.
73   } while (left &gt; 0 || _barrier_threads &gt; 0);
74   // API specifies disarm() must provide a trailing fence.
75   OrderAccess::fence();
76 }
77 
78 void GenericWaitBarrier::wait(int barrier_tag) {
79   assert(barrier_tag != 0, &quot;Trying to wait on disarmed value&quot;);
80   if (barrier_tag != _barrier_tag) {
81     // API specifies wait() must provide a trailing fence.
82     OrderAccess::fence();
83     return;
84   }
<a name="2" id="anc2"></a><span class="line-modified">85   Atomic::add(1, &amp;_barrier_threads);</span>
86   if (barrier_tag != 0 &amp;&amp; barrier_tag == _barrier_tag) {
<a name="3" id="anc3"></a><span class="line-modified">87     Atomic::add(1, &amp;_waiters);</span>
88     _sem_barrier.wait();
89     // We help out with posting, but we need to do so before we decrement the
90     // _barrier_threads otherwise we might wake threads up in next wait.
91     GenericWaitBarrier::wake_if_needed();
92   }
<a name="4" id="anc4"></a><span class="line-modified">93   Atomic::add(-1, &amp;_barrier_threads);</span>
94 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
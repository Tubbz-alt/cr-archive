<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/exceptions.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="events.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="exceptions.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/exceptions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;compiler/compileBroker.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;logging/logStream.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;

 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/init.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;runtime/javaCalls.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;runtime/thread.inline.hpp&quot;
 39 #include &quot;runtime/threadCritical.hpp&quot;
 40 #include &quot;runtime/atomic.hpp&quot;
 41 #include &quot;utilities/events.hpp&quot;
 42 #include &quot;utilities/exceptions.hpp&quot;
 43 
 44 // Implementation of ThreadShadow
 45 void check_ThreadShadow() {
 46   const ByteSize offset1 = byte_offset_of(ThreadShadow, _pending_exception);
 47   const ByteSize offset2 = Thread::pending_exception_offset();
 48   if (offset1 != offset2) fatal(&quot;ThreadShadow::_pending_exception is not positioned correctly&quot;);
 49 }
 50 
 51 
</pre>
<hr />
<pre>
211 // NOTE: These must be here (and not in the header file) because of include circularities.
212 void Exceptions::_throw_msg_cause(Thread* thread, const char* file, int line, Symbol* name, const char* message, Handle h_cause) {
213   _throw_msg_cause(thread, file, line, name, message, h_cause, Handle(thread, NULL), Handle(thread, NULL));
214 }
215 void Exceptions::_throw_msg(Thread* thread, const char* file, int line, Symbol* name, const char* message) {
216   _throw_msg(thread, file, line, name, message, Handle(thread, NULL), Handle(thread, NULL));
217 }
218 void Exceptions::_throw_cause(Thread* thread, const char* file, int line, Symbol* name, Handle h_cause) {
219   _throw_cause(thread, file, line, name, h_cause, Handle(thread, NULL), Handle(thread, NULL));
220 }
221 
222 
223 void Exceptions::throw_stack_overflow_exception(Thread* THREAD, const char* file, int line, const methodHandle&amp; method) {
224   Handle exception;
225   if (!THREAD-&gt;has_pending_exception()) {
226     InstanceKlass* k = SystemDictionary::StackOverflowError_klass();
227     oop e = k-&gt;allocate_instance(CHECK);
228     exception = Handle(THREAD, e);  // fill_in_stack trace does gc
229     assert(k-&gt;is_initialized(), &quot;need to increase java_thread_min_stack_allowed calculation&quot;);
230     if (StackTraceInThrowable) {
<span class="line-modified">231       java_lang_Throwable::fill_in_stack_trace(exception, method());</span>
232     }
233     // Increment counter for hs_err file reporting
234     Atomic::inc(&amp;Exceptions::_stack_overflow_errors);
235   } else {
236     // if prior exception, throw that one instead
237     exception = Handle(THREAD, THREAD-&gt;pending_exception());
238   }
239   _throw(THREAD, file, line, exception);
240 }
241 
242 void Exceptions::fthrow(Thread* thread, const char* file, int line, Symbol* h_name, const char* format, ...) {
243   const int max_msg_size = 1024;
244   va_list ap;
245   va_start(ap, format);
246   char msg[max_msg_size];
247   os::vsnprintf(msg, max_msg_size, format, ap);
248   va_end(ap);
249   _throw_msg(thread, file, line, h_name, msg);
250 }
251 
</pre>
<hr />
<pre>
417 
418     // Otherwise wrap the exception in a BootstrapMethodError
419     if (TraceMethodHandles) {
420       tty-&gt;print_cr(&quot;[constant/invoke]dynamic throws BSME for &quot; INTPTR_FORMAT, p2i((void *)exception));
421       exception-&gt;print();
422     }
423     Handle nested_exception(THREAD, exception);
424     THREAD-&gt;clear_pending_exception();
425     THROW_CAUSE(vmSymbols::java_lang_BootstrapMethodError(), nested_exception)
426   }
427 }
428 
429 // Exception counting for hs_err file
430 volatile int Exceptions::_stack_overflow_errors = 0;
431 volatile int Exceptions::_linkage_errors = 0;
432 volatile int Exceptions::_out_of_memory_error_java_heap_errors = 0;
433 volatile int Exceptions::_out_of_memory_error_metaspace_errors = 0;
434 volatile int Exceptions::_out_of_memory_error_class_metaspace_errors = 0;
435 
436 void Exceptions::count_out_of_memory_exceptions(Handle exception) {
<span class="line-modified">437   if (oopDesc::equals(exception(), Universe::out_of_memory_error_metaspace())) {</span>
438      Atomic::inc(&amp;_out_of_memory_error_metaspace_errors);
<span class="line-modified">439   } else if (oopDesc::equals(exception(), Universe::out_of_memory_error_class_metaspace())) {</span>
440      Atomic::inc(&amp;_out_of_memory_error_class_metaspace_errors);
441   } else {
442      // everything else reported as java heap OOM
443      Atomic::inc(&amp;_out_of_memory_error_java_heap_errors);
444   }
445 }
446 
447 void print_oom_count(outputStream* st, const char *err, int count) {
448   if (count &gt; 0) {
449     st-&gt;print_cr(&quot;OutOfMemoryError %s=%d&quot;, err, count);
450   }
451 }
452 
453 bool Exceptions::has_exception_counts() {
454   return (_stack_overflow_errors + _out_of_memory_error_java_heap_errors +
455          _out_of_memory_error_metaspace_errors + _out_of_memory_error_class_metaspace_errors) &gt; 0;
456 }
457 
458 void Exceptions::print_exception_counts_on_error(outputStream* st) {
459   print_oom_count(st, &quot;java_heap_errors&quot;, _out_of_memory_error_java_heap_errors);
</pre>
<hr />
<pre>
508 }
509 
510 void Exceptions::debug_check_abort(Handle exception, const char* message) {
511   if (AbortVMOnException != NULL) {
512     debug_check_abort_helper(exception, message);
513   }
514 }
515 
516 void Exceptions::debug_check_abort_helper(Handle exception, const char* message) {
517   ResourceMark rm;
518   if (message == NULL &amp;&amp; exception-&gt;is_a(SystemDictionary::Throwable_klass())) {
519     oop msg = java_lang_Throwable::message(exception());
520     if (msg != NULL) {
521       message = java_lang_String::as_utf8_string(msg);
522     }
523   }
524   debug_check_abort(exception()-&gt;klass()-&gt;external_name(), message);
525 }
526 
527 // for logging exceptions
<span class="line-modified">528 void Exceptions::log_exception(Handle exception, stringStream tempst) {</span>
529   ResourceMark rm;
<span class="line-modified">530   Symbol* message = java_lang_Throwable::detail_message(exception());</span>
<span class="line-modified">531   if (message != NULL) {</span>
532     log_info(exceptions)(&quot;Exception &lt;%s: %s&gt;\n thrown in %s&quot;,
533                          exception-&gt;print_value_string(),
<span class="line-modified">534                          message-&gt;as_C_string(),</span>
<span class="line-modified">535                          tempst.as_string());</span>
536   } else {
537     log_info(exceptions)(&quot;Exception &lt;%s&gt;\n thrown in %s&quot;,
538                          exception-&gt;print_value_string(),
<span class="line-modified">539                          tempst.as_string());</span>
540   }
541 }
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;compiler/compileBroker.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;logging/logStream.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/handles.inline.hpp&quot;
 35 #include &quot;runtime/init.hpp&quot;
 36 #include &quot;runtime/java.hpp&quot;
 37 #include &quot;runtime/javaCalls.hpp&quot;
 38 #include &quot;runtime/os.hpp&quot;
 39 #include &quot;runtime/thread.inline.hpp&quot;
 40 #include &quot;runtime/threadCritical.hpp&quot;
 41 #include &quot;runtime/atomic.hpp&quot;
 42 #include &quot;utilities/events.hpp&quot;
 43 #include &quot;utilities/exceptions.hpp&quot;
 44 
 45 // Implementation of ThreadShadow
 46 void check_ThreadShadow() {
 47   const ByteSize offset1 = byte_offset_of(ThreadShadow, _pending_exception);
 48   const ByteSize offset2 = Thread::pending_exception_offset();
 49   if (offset1 != offset2) fatal(&quot;ThreadShadow::_pending_exception is not positioned correctly&quot;);
 50 }
 51 
 52 
</pre>
<hr />
<pre>
212 // NOTE: These must be here (and not in the header file) because of include circularities.
213 void Exceptions::_throw_msg_cause(Thread* thread, const char* file, int line, Symbol* name, const char* message, Handle h_cause) {
214   _throw_msg_cause(thread, file, line, name, message, h_cause, Handle(thread, NULL), Handle(thread, NULL));
215 }
216 void Exceptions::_throw_msg(Thread* thread, const char* file, int line, Symbol* name, const char* message) {
217   _throw_msg(thread, file, line, name, message, Handle(thread, NULL), Handle(thread, NULL));
218 }
219 void Exceptions::_throw_cause(Thread* thread, const char* file, int line, Symbol* name, Handle h_cause) {
220   _throw_cause(thread, file, line, name, h_cause, Handle(thread, NULL), Handle(thread, NULL));
221 }
222 
223 
224 void Exceptions::throw_stack_overflow_exception(Thread* THREAD, const char* file, int line, const methodHandle&amp; method) {
225   Handle exception;
226   if (!THREAD-&gt;has_pending_exception()) {
227     InstanceKlass* k = SystemDictionary::StackOverflowError_klass();
228     oop e = k-&gt;allocate_instance(CHECK);
229     exception = Handle(THREAD, e);  // fill_in_stack trace does gc
230     assert(k-&gt;is_initialized(), &quot;need to increase java_thread_min_stack_allowed calculation&quot;);
231     if (StackTraceInThrowable) {
<span class="line-modified">232       java_lang_Throwable::fill_in_stack_trace(exception, method);</span>
233     }
234     // Increment counter for hs_err file reporting
235     Atomic::inc(&amp;Exceptions::_stack_overflow_errors);
236   } else {
237     // if prior exception, throw that one instead
238     exception = Handle(THREAD, THREAD-&gt;pending_exception());
239   }
240   _throw(THREAD, file, line, exception);
241 }
242 
243 void Exceptions::fthrow(Thread* thread, const char* file, int line, Symbol* h_name, const char* format, ...) {
244   const int max_msg_size = 1024;
245   va_list ap;
246   va_start(ap, format);
247   char msg[max_msg_size];
248   os::vsnprintf(msg, max_msg_size, format, ap);
249   va_end(ap);
250   _throw_msg(thread, file, line, h_name, msg);
251 }
252 
</pre>
<hr />
<pre>
418 
419     // Otherwise wrap the exception in a BootstrapMethodError
420     if (TraceMethodHandles) {
421       tty-&gt;print_cr(&quot;[constant/invoke]dynamic throws BSME for &quot; INTPTR_FORMAT, p2i((void *)exception));
422       exception-&gt;print();
423     }
424     Handle nested_exception(THREAD, exception);
425     THREAD-&gt;clear_pending_exception();
426     THROW_CAUSE(vmSymbols::java_lang_BootstrapMethodError(), nested_exception)
427   }
428 }
429 
430 // Exception counting for hs_err file
431 volatile int Exceptions::_stack_overflow_errors = 0;
432 volatile int Exceptions::_linkage_errors = 0;
433 volatile int Exceptions::_out_of_memory_error_java_heap_errors = 0;
434 volatile int Exceptions::_out_of_memory_error_metaspace_errors = 0;
435 volatile int Exceptions::_out_of_memory_error_class_metaspace_errors = 0;
436 
437 void Exceptions::count_out_of_memory_exceptions(Handle exception) {
<span class="line-modified">438   if (exception() == Universe::out_of_memory_error_metaspace()) {</span>
439      Atomic::inc(&amp;_out_of_memory_error_metaspace_errors);
<span class="line-modified">440   } else if (exception() == Universe::out_of_memory_error_class_metaspace()) {</span>
441      Atomic::inc(&amp;_out_of_memory_error_class_metaspace_errors);
442   } else {
443      // everything else reported as java heap OOM
444      Atomic::inc(&amp;_out_of_memory_error_java_heap_errors);
445   }
446 }
447 
448 void print_oom_count(outputStream* st, const char *err, int count) {
449   if (count &gt; 0) {
450     st-&gt;print_cr(&quot;OutOfMemoryError %s=%d&quot;, err, count);
451   }
452 }
453 
454 bool Exceptions::has_exception_counts() {
455   return (_stack_overflow_errors + _out_of_memory_error_java_heap_errors +
456          _out_of_memory_error_metaspace_errors + _out_of_memory_error_class_metaspace_errors) &gt; 0;
457 }
458 
459 void Exceptions::print_exception_counts_on_error(outputStream* st) {
460   print_oom_count(st, &quot;java_heap_errors&quot;, _out_of_memory_error_java_heap_errors);
</pre>
<hr />
<pre>
509 }
510 
511 void Exceptions::debug_check_abort(Handle exception, const char* message) {
512   if (AbortVMOnException != NULL) {
513     debug_check_abort_helper(exception, message);
514   }
515 }
516 
517 void Exceptions::debug_check_abort_helper(Handle exception, const char* message) {
518   ResourceMark rm;
519   if (message == NULL &amp;&amp; exception-&gt;is_a(SystemDictionary::Throwable_klass())) {
520     oop msg = java_lang_Throwable::message(exception());
521     if (msg != NULL) {
522       message = java_lang_String::as_utf8_string(msg);
523     }
524   }
525   debug_check_abort(exception()-&gt;klass()-&gt;external_name(), message);
526 }
527 
528 // for logging exceptions
<span class="line-modified">529 void Exceptions::log_exception(Handle exception, const char* message) {</span>
530   ResourceMark rm;
<span class="line-modified">531   Symbol* detail_message = java_lang_Throwable::detail_message(exception());</span>
<span class="line-modified">532   if (detail_message != NULL) {</span>
533     log_info(exceptions)(&quot;Exception &lt;%s: %s&gt;\n thrown in %s&quot;,
534                          exception-&gt;print_value_string(),
<span class="line-modified">535                          detail_message-&gt;as_C_string(),</span>
<span class="line-modified">536                          message);</span>
537   } else {
538     log_info(exceptions)(&quot;Exception &lt;%s&gt;\n thrown in %s&quot;,
539                          exception-&gt;print_value_string(),
<span class="line-modified">540                          message);</span>
541   }
542 }
</pre>
</td>
</tr>
</table>
<center><a href="events.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="exceptions.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/bitMap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bitMap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compilerWarnings.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/bitMap.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
  
  #ifndef SHARE_UTILITIES_BITMAP_INLINE_HPP
  #define SHARE_UTILITIES_BITMAP_INLINE_HPP
  
  #include &quot;runtime/atomic.hpp&quot;
<span class="line-added">+ #include &quot;utilities/align.hpp&quot;</span>
  #include &quot;utilities/bitMap.hpp&quot;
  #include &quot;utilities/count_trailing_zeros.hpp&quot;
  
  inline void BitMap::set_bit(idx_t bit) {
    verify_index(bit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,41 ***</span>
  inline void BitMap::clear_bit(idx_t bit) {
    verify_index(bit);
    *word_addr(bit) &amp;= ~bit_mask(bit);
  }
  
<span class="line-modified">! inline bool BitMap::par_set_bit(idx_t bit) {</span>
    verify_index(bit);
    volatile bm_word_t* const addr = word_addr(bit);
    const bm_word_t mask = bit_mask(bit);
<span class="line-modified">!   bm_word_t old_val = *addr;</span>
  
    do {
      const bm_word_t new_val = old_val | mask;
      if (new_val == old_val) {
        return false;     // Someone else beat us to it.
      }
<span class="line-modified">!     const bm_word_t cur_val = Atomic::cmpxchg(new_val, addr, old_val);</span>
      if (cur_val == old_val) {
        return true;      // Success.
      }
      old_val = cur_val;  // The value changed, try again.
    } while (true);
  }
  
<span class="line-modified">! inline bool BitMap::par_clear_bit(idx_t bit) {</span>
    verify_index(bit);
    volatile bm_word_t* const addr = word_addr(bit);
    const bm_word_t mask = ~bit_mask(bit);
<span class="line-modified">!   bm_word_t old_val = *addr;</span>
  
    do {
      const bm_word_t new_val = old_val &amp; mask;
      if (new_val == old_val) {
        return false;     // Someone else beat us to it.
      }
<span class="line-modified">!     const bm_word_t cur_val = Atomic::cmpxchg(new_val, addr, old_val);</span>
      if (cur_val == old_val) {
        return true;      // Success.
      }
      old_val = cur_val;  // The value changed, try again.
    } while (true);
<span class="line-new-header">--- 38,62 ---</span>
  inline void BitMap::clear_bit(idx_t bit) {
    verify_index(bit);
    *word_addr(bit) &amp;= ~bit_mask(bit);
  }
  
<span class="line-modified">! inline const BitMap::bm_word_t BitMap::load_word_ordered(const volatile bm_word_t* const addr, atomic_memory_order memory_order) {</span>
<span class="line-added">+   if (memory_order == memory_order_relaxed || memory_order == memory_order_release) {</span>
<span class="line-added">+     return Atomic::load(addr);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     assert(memory_order == memory_order_acq_rel ||</span>
<span class="line-added">+            memory_order == memory_order_acquire ||</span>
<span class="line-added">+            memory_order == memory_order_conservative,</span>
<span class="line-added">+            &quot;unexpected memory ordering&quot;);</span>
<span class="line-added">+     return Atomic::load_acquire(addr);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline bool BitMap::par_at(idx_t index, atomic_memory_order memory_order) const {</span>
<span class="line-added">+   verify_index(index);</span>
<span class="line-added">+   assert(memory_order == memory_order_acquire ||</span>
<span class="line-added">+          memory_order == memory_order_relaxed,</span>
<span class="line-added">+          &quot;unexpected memory ordering&quot;);</span>
<span class="line-added">+   const volatile bm_word_t* const addr = word_addr(index);</span>
<span class="line-added">+   return (load_word_ordered(addr, memory_order) &amp; bit_mask(index)) != 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline bool BitMap::par_set_bit(idx_t bit, atomic_memory_order memory_order) {</span>
    verify_index(bit);
    volatile bm_word_t* const addr = word_addr(bit);
    const bm_word_t mask = bit_mask(bit);
<span class="line-modified">!   bm_word_t old_val = load_word_ordered(addr, memory_order);</span>
  
    do {
      const bm_word_t new_val = old_val | mask;
      if (new_val == old_val) {
        return false;     // Someone else beat us to it.
      }
<span class="line-modified">!     const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val, memory_order);</span>
      if (cur_val == old_val) {
        return true;      // Success.
      }
      old_val = cur_val;  // The value changed, try again.
    } while (true);
  }
  
<span class="line-modified">! inline bool BitMap::par_clear_bit(idx_t bit, atomic_memory_order memory_order) {</span>
    verify_index(bit);
    volatile bm_word_t* const addr = word_addr(bit);
    const bm_word_t mask = ~bit_mask(bit);
<span class="line-modified">!   bm_word_t old_val = load_word_ordered(addr, memory_order);</span>
  
    do {
      const bm_word_t new_val = old_val &amp; mask;
      if (new_val == old_val) {
        return false;     // Someone else beat us to it.
      }
<span class="line-modified">!     const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val, memory_order);</span>
      if (cur_val == old_val) {
        return true;      // Success.
      }
      old_val = cur_val;  // The value changed, try again.
    } while (true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,32 ***</span>
  
  template&lt;BitMap::bm_word_t flip, bool aligned_right&gt;
  inline BitMap::idx_t BitMap::get_next_bit_impl(idx_t l_index, idx_t r_index) const {
    STATIC_ASSERT(flip == find_ones_flip || flip == find_zeros_flip);
    verify_range(l_index, r_index);
<span class="line-modified">!   assert(!aligned_right || is_word_aligned(r_index), &quot;r_index not aligned&quot;);</span>
  
    // The first word often contains an interesting bit, either due to
    // density or because of features of the calling algorithm.  So it&#39;s
    // important to examine that first word with a minimum of fuss,
    // minimizing setup time for later words that will be wasted if the
    // first word is indeed interesting.
  
    // The benefit from aligned_right being true is relatively small.
<span class="line-modified">!   // It saves a couple instructions in the setup for the word search</span>
<span class="line-modified">!   // loop.  It also eliminates the range check on the final result.</span>
    // However, callers often have a comparison with r_index, and
    // inlining often allows the two comparisons to be combined; it is
    // important when !aligned_right that return paths either return
    // r_index or a value dominated by a comparison with r_index.
    // aligned_right is still helpful when the caller doesn&#39;t have a
    // range check because features of the calling algorithm guarantee
    // an interesting bit will be present.
  
    if (l_index &lt; r_index) {
      // Get the word containing l_index, and shift out low bits.
<span class="line-modified">!     idx_t index = word_index(l_index);</span>
      bm_word_t cword = (map(index) ^ flip) &gt;&gt; bit_in_word(l_index);
      if ((cword &amp; 1) != 0) {
        // The first bit is similarly often interesting. When it matters
        // (density or features of the calling algorithm make it likely
        // the first bit is set), going straight to the next clause compares
<span class="line-new-header">--- 166,32 ---</span>
  
  template&lt;BitMap::bm_word_t flip, bool aligned_right&gt;
  inline BitMap::idx_t BitMap::get_next_bit_impl(idx_t l_index, idx_t r_index) const {
    STATIC_ASSERT(flip == find_ones_flip || flip == find_zeros_flip);
    verify_range(l_index, r_index);
<span class="line-modified">!   assert(!aligned_right || is_aligned(r_index, BitsPerWord), &quot;r_index not aligned&quot;);</span>
  
    // The first word often contains an interesting bit, either due to
    // density or because of features of the calling algorithm.  So it&#39;s
    // important to examine that first word with a minimum of fuss,
    // minimizing setup time for later words that will be wasted if the
    // first word is indeed interesting.
  
    // The benefit from aligned_right being true is relatively small.
<span class="line-modified">!   // It saves an operation in the setup for the word search loop.</span>
<span class="line-modified">!   // It also eliminates the range check on the final result.</span>
    // However, callers often have a comparison with r_index, and
    // inlining often allows the two comparisons to be combined; it is
    // important when !aligned_right that return paths either return
    // r_index or a value dominated by a comparison with r_index.
    // aligned_right is still helpful when the caller doesn&#39;t have a
    // range check because features of the calling algorithm guarantee
    // an interesting bit will be present.
  
    if (l_index &lt; r_index) {
      // Get the word containing l_index, and shift out low bits.
<span class="line-modified">!     idx_t index = to_words_align_down(l_index);</span>
      bm_word_t cword = (map(index) ^ flip) &gt;&gt; bit_in_word(l_index);
      if ((cword &amp; 1) != 0) {
        // The first bit is similarly often interesting. When it matters
        // (density or features of the calling algorithm make it likely
        // the first bit is set), going straight to the next clause compares
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,12 ***</span>
        // Result is beyond range bound; return r_index.
      } else {
        // Flipped and shifted first word is zero.  Word search through
        // aligned up r_index for a non-zero flipped word.
        idx_t limit = aligned_right
<span class="line-modified">!         ? word_index(r_index)</span>
<span class="line-modified">!         : (word_index(r_index - 1) + 1); // Align up, knowing r_index &gt; 0.</span>
        while (++index &lt; limit) {
          cword = map(index) ^ flip;
          if (cword != 0) {
            idx_t result = bit_index(index) + count_trailing_zeros(cword);
            if (aligned_right || (result &lt; r_index)) return result;
<span class="line-new-header">--- 207,12 ---</span>
        // Result is beyond range bound; return r_index.
      } else {
        // Flipped and shifted first word is zero.  Word search through
        // aligned up r_index for a non-zero flipped word.
        idx_t limit = aligned_right
<span class="line-modified">!         ? to_words_align_down(r_index) // Miniscule savings when aligned.</span>
<span class="line-modified">!         : to_words_align_up(r_index);</span>
        while (++index &lt; limit) {
          cword = map(index) ^ flip;
          if (cword != 0) {
            idx_t result = bit_index(index) + count_trailing_zeros(cword);
            if (aligned_right || (result &lt; r_index)) return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 225,11 ***</span>
  // returned mask can be used directly to clear the range, or inverted to set the
  // range.  Note:  end must not be 0.
  inline BitMap::bm_word_t
  BitMap::inverted_bit_mask_for_range(idx_t beg, idx_t end) const {
    assert(end != 0, &quot;does not work when end == 0&quot;);
<span class="line-modified">!   assert(beg == end || word_index(beg) == word_index(end - 1),</span>
           &quot;must be a single-word range&quot;);
    bm_word_t mask = bit_mask(beg) - 1;   // low (right) bits
    if (bit_in_word(end) != 0) {
      mask |= ~(bit_mask(end) - 1);       // high (left) bits
    }
<span class="line-new-header">--- 247,11 ---</span>
  // returned mask can be used directly to clear the range, or inverted to set the
  // range.  Note:  end must not be 0.
  inline BitMap::bm_word_t
  BitMap::inverted_bit_mask_for_range(idx_t beg, idx_t end) const {
    assert(end != 0, &quot;does not work when end == 0&quot;);
<span class="line-modified">!   assert(beg == end || to_words_align_down(beg) == to_words_align_down(end - 1),</span>
           &quot;must be a single-word range&quot;);
    bm_word_t mask = bit_mask(beg) - 1;   // low (right) bits
    if (bit_in_word(end) != 0) {
      mask |= ~(bit_mask(end) - 1);       // high (left) bits
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,16 ***</span>
  inline void BitMap::clear_large_range_of_words(idx_t beg, idx_t end) {
    assert(beg &lt;= end, &quot;underflow&quot;);
    memset(_map + beg, 0, (end - beg) * sizeof(bm_word_t));
  }
  
<span class="line-removed">- inline BitMap::idx_t BitMap::word_index_round_up(idx_t bit) const {</span>
<span class="line-removed">-   idx_t bit_rounded_up = bit + (BitsPerWord - 1);</span>
<span class="line-removed">-   // Check for integer arithmetic overflow.</span>
<span class="line-removed">-   return bit_rounded_up &gt; bit ? word_index(bit_rounded_up) : size_in_words();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  inline bool BitMap2D::is_valid_index(idx_t slot_index, idx_t bit_within_slot_index) {
    verify_bit_within_slot_index(bit_within_slot_index);
    return (bit_index(slot_index, bit_within_slot_index) &lt; size_in_bits());
  }
  
<span class="line-new-header">--- 266,10 ---</span>
</pre>
<center><a href="bitMap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compilerWarnings.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
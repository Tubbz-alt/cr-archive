<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/utilities/singleWriterSynchronizer.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_SINGLEWRITERSYNCHRONIZER_HPP
 26 #define SHARE_UTILITIES_SINGLEWRITERSYNCHRONIZER_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/atomic.hpp&quot;
 30 #include &quot;runtime/semaphore.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 // Synchronization primitive inspired by RCU.
 35 //
 36 // Any number of threads may enter critical sections associated with a
 37 // synchronizer object.  One (at a time) other thread may wait for the
 38 // completion of all critical sections for the synchronizer object
 39 // that were extant when the wait was initiated.  Usage is that there
 40 // is some state that can be accessed either before or after some
 41 // change.  An accessing thread performs the access within a critical
 42 // section.  A writer thread performs the state change, and then waits
 43 // for critical sections to complete, thereby ensuring there are no
 44 // threads in a critical section that might have seen the old state.
 45 //
 46 // Generally, GlobalCounter should be used instead of this class, as
 47 // GlobalCounter has measurably better performance and doesn&#39;t have
 48 // the single writer at a time restriction.  Use this only in
 49 // situations where GlobalCounter won&#39;t work for some reason.
 50 class SingleWriterSynchronizer {
 51   volatile uint _enter;
 52   volatile uint _exit[2];
 53   volatile uint _waiting_for;
 54   Semaphore _wakeup;
 55 
 56   DEBUG_ONLY(volatile uint _writers;)
 57 
 58   NONCOPYABLE(SingleWriterSynchronizer);
 59 
 60 public:
 61   SingleWriterSynchronizer();
 62 
 63   // Enter a critical section for this synchronizer.  Entering a
 64   // critical section never blocks.  While in a critical section, a
 65   // thread should avoid blocking, or even take a long time.  In
 66   // particular, a thread must never safepoint while in a critical
 67   // section.
 68   // Precondition: The current thread must not already be in a
 69   // critical section for this synchronizer.
 70   inline uint enter();
 71 
 72   // Exit a critical section for this synchronizer.
 73   // Precondition: enter_value must be the result of the corresponding
 74   // enter() for the critical section.
 75   inline void exit(uint enter_value);
 76 
 77   // Wait until all threads currently in a critical section for this
 78   // synchronizer have exited their critical section.  Threads that
 79   // enter a critical section after the synchronization has started
 80   // are not considered in the wait.
 81   // Precondition: No other thread may be synchronizing on this
 82   // synchronizer.
 83   void synchronize();
 84 
 85   // RAII class for managing enter/exit pairs.
 86   class CriticalSection;
 87 };
 88 
 89 inline uint SingleWriterSynchronizer::enter() {
 90   return Atomic::add(&amp;_enter, 2u);
 91 }
 92 
 93 inline void SingleWriterSynchronizer::exit(uint enter_value) {
 94   uint exit_value = Atomic::add(&amp;_exit[enter_value &amp; 1], 2u);
 95   // If this exit completes a synchronize request, wakeup possibly
 96   // waiting synchronizer.  Read of _waiting_for must follow the _exit
 97   // update.
 98   if (exit_value == _waiting_for) {
 99     _wakeup.signal();
100   }
101 }
102 
103 class SingleWriterSynchronizer::CriticalSection : public StackObj {
104   SingleWriterSynchronizer* _synchronizer;
105   uint _enter_value;
106 
107 public:
108   // Enter synchronizer&#39;s critical section.
109   explicit CriticalSection(SingleWriterSynchronizer* synchronizer) :
110     _synchronizer(synchronizer),
111     _enter_value(synchronizer-&gt;enter())
112   {}
113 
114   // Exit synchronizer&#39;s critical section.
115   ~CriticalSection() {
116     _synchronizer-&gt;exit(_enter_value);
117   }
118 };
119 
120 #endif // SHARE_UTILITIES_SINGLEWRITERSYNCHRONIZER_HPP
    </pre>
  </body>
</html>
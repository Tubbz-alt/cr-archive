<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/utilities/growableArray.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globalDefinitions_xlc.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="hashtable.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/growableArray.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -28,10 +28,11 @@</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;oops/oop.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  // A growable array.
  
  /*************************************************************************/
  /*                                                                       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -150,10 +151,16 @@</span>
  };
  
  template&lt;class E&gt; class GrowableArrayIterator;
  template&lt;class E, class UnaryPredicate&gt; class GrowableArrayFilterIterator;
  
<span class="udiff-line-added">+ template&lt;class E&gt;</span>
<span class="udiff-line-added">+ class CompareClosure : public Closure {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+     virtual int do_compare(const E&amp;, const E&amp;) = 0;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  template&lt;class E&gt; class GrowableArray : public GenericGrowableArray {
    friend class VMStructs;
  
   private:
    E*     _data;         // data array
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -183,11 +190,15 @@</span>
      int i = 0;
      for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
      for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
    }
  
<span class="udiff-line-modified-removed">-   GrowableArray(Arena* arena, int initial_size, int initial_len, const E&amp; filler) : GenericGrowableArray(arena, initial_size, initial_len) {</span>
<span class="udiff-line-modified-added">+   // Watch out, if filler was generated by a constructor, the destuctor might</span>
<span class="udiff-line-added">+   // be called on the original object invalidating all the copies made here.</span>
<span class="udiff-line-added">+   // Carefully design the copy constructor.</span>
<span class="udiff-line-added">+   GrowableArray(Arena* arena, int initial_size, int initial_len, const E&amp; filler) :</span>
<span class="udiff-line-added">+       GenericGrowableArray(arena, initial_size, initial_len) {</span>
      _data = (E*)raw_allocate(sizeof(E));
      int i = 0;
      for (; i &lt; _len; i++) ::new ((void*)&amp;_data[i]) E(filler);
      for (; i &lt; _max; i++) ::new ((void*)&amp;_data[i]) E();
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -210,19 +221,10 @@</span>
    bool  is_full() const         { return _len == _max; }
    DEBUG_ONLY(E* data_addr() const      { return _data; })
  
    void print();
  
<span class="udiff-line-removed">-   inline static bool safe_equals(oop obj1, oop obj2) {</span>
<span class="udiff-line-removed">-     return oopDesc::equals(obj1, obj2);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   template &lt;class X&gt;</span>
<span class="udiff-line-removed">-   inline static bool safe_equals(X i1, X i2) {</span>
<span class="udiff-line-removed">-     return i1 == i2;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    int append(const E&amp; elem) {
      check_nesting();
      if (_len == _max) grow(_len);
      int idx = _len++;
      _data[idx] = elem;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -303,11 +305,11 @@</span>
      raw_at_put_grow(i, elem, fill);
    }
  
    bool contains(const E&amp; elem) const {
      for (int i = 0; i &lt; _len; i++) {
<span class="udiff-line-modified-removed">-       if (safe_equals(_data[i], elem)) return true;</span>
<span class="udiff-line-modified-added">+       if (_data[i] == elem) return true;</span>
      }
      return false;
    }
  
    int  find(const E&amp; elem) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -441,19 +443,49 @@</span>
          return mid;
        }
      }
      return min;
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   E insert_sorted(CompareClosure&lt;E&gt;* cc, const E&amp; key) {</span>
<span class="udiff-line-added">+     bool found;</span>
<span class="udiff-line-added">+     int location = find_sorted(cc, key, found);</span>
<span class="udiff-line-added">+     if (!found) {</span>
<span class="udiff-line-added">+       insert_before(location, key);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return at(location);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   template&lt;typename K&gt;</span>
<span class="udiff-line-added">+   int find_sorted(CompareClosure&lt;E&gt;* cc, const K&amp; key, bool&amp; found) {</span>
<span class="udiff-line-added">+     found = false;</span>
<span class="udiff-line-added">+     int min = 0;</span>
<span class="udiff-line-added">+     int max = length() - 1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     while (max &gt;= min) {</span>
<span class="udiff-line-added">+       int mid = (int)(((uint)max + min) / 2);</span>
<span class="udiff-line-added">+       E value = at(mid);</span>
<span class="udiff-line-added">+       int diff = cc-&gt;do_compare(key, value);</span>
<span class="udiff-line-added">+       if (diff &gt; 0) {</span>
<span class="udiff-line-added">+         min = mid + 1;</span>
<span class="udiff-line-added">+       } else if (diff &lt; 0) {</span>
<span class="udiff-line-added">+         max = mid - 1;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         found = true;</span>
<span class="udiff-line-added">+         return mid;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return min;</span>
<span class="udiff-line-added">+   }</span>
  };
  
  // Global GrowableArray methods (one instance in the library per each &#39;E&#39; type).
  
  template&lt;class E&gt; void GrowableArray&lt;E&gt;::grow(int j) {
<span class="udiff-line-removed">-     // grow the array by doubling its size (amortized growth)</span>
      int old_max = _max;
<span class="udiff-line-modified-removed">-     if (_max == 0) _max = 1; // prevent endless loop</span>
<span class="udiff-line-modified-removed">-     while (j &gt;= _max) _max = _max*2;</span>
<span class="udiff-line-modified-added">+     // grow the array by increasing _max to the first power of two larger than the size we need</span>
<span class="udiff-line-modified-added">+     _max = next_power_of_2((uint32_t)j);</span>
      // j &lt; _max
      E* newData = (E*)raw_allocate(sizeof(E));
      int i = 0;
      for (     ; i &lt; _len; i++) ::new ((void*)&amp;newData[i]) E(_data[i]);
  // Needed for Visual Studio 2012 and older
</pre>
<center><a href="globalDefinitions_xlc.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="hashtable.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/count_leading_zeros.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="concurrentHashTableTasks.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debug.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/count_leading_zeros.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_COUNT_LEADING_ZEROS_HPP
 26 #define SHARE_UTILITIES_COUNT_LEADING_ZEROS_HPP
 27 
 28 #include &quot;utilities/debug.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-removed"> 30 #include &quot;utilities/count_trailing_zeros.hpp&quot;</span>
 31 
<span class="line-modified"> 32 #if defined(TARGET_COMPILER_visCPP)</span>
<span class="line-removed"> 33 #include &lt;intrin.h&gt;</span>
<span class="line-removed"> 34 #pragma intrinsic(_BitScanReverse)</span>
<span class="line-removed"> 35 #elif defined(TARGET_COMPILER_xlc)</span>
<span class="line-removed"> 36 #include &lt;builtins.h&gt;</span>
<span class="line-removed"> 37 #endif</span>
 38 
<span class="line-removed"> 39 // uint32_t count_leading_zeros(uint32_t x)</span>
 40 // Return the number of leading zeros in x, e.g. the zero-based index
 41 // of the most significant set bit in x.  Undefined for 0.
<span class="line-modified"> 42 inline uint32_t count_leading_zeros(uint32_t x) {</span>
<span class="line-modified"> 43   assert(x != 0, &quot;precondition&quot;);</span>










 44 #if defined(TARGET_COMPILER_gcc)
<span class="line-modified"> 45   return __builtin_clz(x);</span>



























 46 #elif defined(TARGET_COMPILER_visCPP)
<span class="line-modified"> 47   unsigned long index;</span>
<span class="line-modified"> 48   _BitScanReverse(&amp;index, x);</span>
<span class="line-modified"> 49   return index ^ 31u;</span>

















































 50 #elif defined(TARGET_COMPILER_xlc)
<span class="line-modified"> 51   return __cntlz4(x);</span>





























 52 #else




 53   // Efficient and portable fallback implementation:
 54   // http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn
 55   // - with positions xor&#39;d by 31 to get number of leading zeros
 56   // rather than position of highest bit.
<span class="line-modified"> 57   static const int MultiplyDeBruijnBitPosition[32] = {</span>
<span class="line-modified"> 58       31, 22, 30, 21, 18, 10, 29,  2, 20, 17, 15, 13, 9,  6, 28, 1,</span>
<span class="line-modified"> 59       23, 19, 11,  3, 16, 14,  7, 24, 12,  4,  8, 25, 5, 26, 27, 0</span>
 60   };
 61 
<span class="line-modified"> 62   x |= x &gt;&gt; 1; // first round down to one less than a power of 2</span>

 63   x |= x &gt;&gt; 2;
 64   x |= x &gt;&gt; 4;
 65   x |= x &gt;&gt; 8;
 66   x |= x &gt;&gt; 16;
<span class="line-modified"> 67   return MultiplyDeBruijnBitPosition[(uint32_t)( x * 0x07c4acddu ) &gt;&gt; 27];</span>
<span class="line-modified"> 68 #endif</span>

 69 }
 70 































 71 #endif // SHARE_UTILITIES_COUNT_LEADING_ZEROS_HPP
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_COUNT_LEADING_ZEROS_HPP
 26 #define SHARE_UTILITIES_COUNT_LEADING_ZEROS_HPP
 27 
 28 #include &quot;utilities/debug.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;

 30 
<span class="line-modified"> 31 // uint32_t count_leading_zeros(T x)</span>





 32 

 33 // Return the number of leading zeros in x, e.g. the zero-based index
 34 // of the most significant set bit in x.  Undefined for 0.
<span class="line-modified"> 35 </span>
<span class="line-modified"> 36 // We implement and support variants for 8, 16, 32 and 64 bit integral types.</span>
<span class="line-added"> 37 template &lt;typename T, size_t n&gt; struct CountLeadingZerosImpl;</span>
<span class="line-added"> 38 </span>
<span class="line-added"> 39 template &lt;typename T&gt; unsigned count_leading_zeros(T v) {</span>
<span class="line-added"> 40   assert(v != 0, &quot;precondition&quot;);</span>
<span class="line-added"> 41   return CountLeadingZerosImpl&lt;T, sizeof(T)&gt;::doit(v);</span>
<span class="line-added"> 42 }</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44 /*****************************************************************************</span>
<span class="line-added"> 45  * GCC and compatible (including Clang)</span>
<span class="line-added"> 46  *****************************************************************************/</span>
 47 #if defined(TARGET_COMPILER_gcc)
<span class="line-modified"> 48 </span>
<span class="line-added"> 49 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 1&gt; {</span>
<span class="line-added"> 50   static unsigned doit(T v) {</span>
<span class="line-added"> 51     return __builtin_clz((uint32_t)v &amp; 0xFF) - 24u;</span>
<span class="line-added"> 52   }</span>
<span class="line-added"> 53 };</span>
<span class="line-added"> 54 </span>
<span class="line-added"> 55 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 2&gt; {</span>
<span class="line-added"> 56   static unsigned doit(T v) {</span>
<span class="line-added"> 57     return __builtin_clz((uint32_t)v &amp; 0xFFFF) - 16u;</span>
<span class="line-added"> 58   }</span>
<span class="line-added"> 59 };</span>
<span class="line-added"> 60 </span>
<span class="line-added"> 61 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 4&gt; {</span>
<span class="line-added"> 62   static unsigned doit(T v) {</span>
<span class="line-added"> 63     return __builtin_clz(v);</span>
<span class="line-added"> 64   }</span>
<span class="line-added"> 65 };</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 8&gt; {</span>
<span class="line-added"> 68   static unsigned doit(T v) {</span>
<span class="line-added"> 69     return __builtin_clzll(v);</span>
<span class="line-added"> 70   }</span>
<span class="line-added"> 71 };</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73 /*****************************************************************************</span>
<span class="line-added"> 74  * Microsoft Visual Studio</span>
<span class="line-added"> 75  *****************************************************************************/</span>
 76 #elif defined(TARGET_COMPILER_visCPP)
<span class="line-modified"> 77 </span>
<span class="line-modified"> 78 #include &lt;intrin.h&gt;</span>
<span class="line-modified"> 79 #pragma intrinsic(_BitScanReverse)</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81 #ifdef _LP64</span>
<span class="line-added"> 82 #pragma intrinsic(_BitScanReverse64)</span>
<span class="line-added"> 83 #endif</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 1&gt; {</span>
<span class="line-added"> 86   static unsigned doit(T v) {</span>
<span class="line-added"> 87     unsigned long index;</span>
<span class="line-added"> 88     _BitScanReverse(&amp;index, (uint32_t)v &amp; 0xFF);</span>
<span class="line-added"> 89     return 7u - index;</span>
<span class="line-added"> 90   }</span>
<span class="line-added"> 91 };</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 2&gt; {</span>
<span class="line-added"> 94   static unsigned doit(T v) {</span>
<span class="line-added"> 95     unsigned long index;</span>
<span class="line-added"> 96     _BitScanReverse(&amp;index, (uint32_t)v &amp; 0xFFFF);</span>
<span class="line-added"> 97     return 15u - index;</span>
<span class="line-added"> 98   }</span>
<span class="line-added"> 99 };</span>
<span class="line-added">100 </span>
<span class="line-added">101 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 4&gt; {</span>
<span class="line-added">102   static unsigned doit(T v) {</span>
<span class="line-added">103     unsigned long index;</span>
<span class="line-added">104     _BitScanReverse(&amp;index, v);</span>
<span class="line-added">105     return 31u - index;</span>
<span class="line-added">106   }</span>
<span class="line-added">107 };</span>
<span class="line-added">108 </span>
<span class="line-added">109 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 8&gt; {</span>
<span class="line-added">110   static unsigned doit(T v) {</span>
<span class="line-added">111 #ifdef _LP64</span>
<span class="line-added">112     unsigned long index;</span>
<span class="line-added">113     _BitScanReverse64(&amp;index, v);</span>
<span class="line-added">114     return 63u - index;</span>
<span class="line-added">115 #else</span>
<span class="line-added">116     uint64_t high = ((uint64_t)v) &gt;&gt; 32ULL;</span>
<span class="line-added">117     if (high != 0) {</span>
<span class="line-added">118       return count_leading_zeros((uint32_t)high);</span>
<span class="line-added">119     } else {</span>
<span class="line-added">120       return count_leading_zeros((uint32_t)v) + 32;</span>
<span class="line-added">121     }</span>
<span class="line-added">122 #endif</span>
<span class="line-added">123   }</span>
<span class="line-added">124 };</span>
<span class="line-added">125 </span>
<span class="line-added">126 /*****************************************************************************</span>
<span class="line-added">127  * IBM XL C/C++</span>
<span class="line-added">128  *****************************************************************************/</span>
129 #elif defined(TARGET_COMPILER_xlc)
<span class="line-modified">130 </span>
<span class="line-added">131 #include &lt;builtins.h&gt;</span>
<span class="line-added">132 </span>
<span class="line-added">133 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 1&gt; {</span>
<span class="line-added">134   static unsigned doit(T v) {</span>
<span class="line-added">135     return __cntlz4((uint32_t)v &amp; 0xFF) - 24u;</span>
<span class="line-added">136   }</span>
<span class="line-added">137 };</span>
<span class="line-added">138 </span>
<span class="line-added">139 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 2&gt; {</span>
<span class="line-added">140   static unsigned doit(T v) {</span>
<span class="line-added">141     return __cntlz4((uint32_t)v &amp; 0xFFFF) - 16u;</span>
<span class="line-added">142   }</span>
<span class="line-added">143 };</span>
<span class="line-added">144 </span>
<span class="line-added">145 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 4&gt; {</span>
<span class="line-added">146   static unsigned doit(T v) {</span>
<span class="line-added">147     return __cntlz4(v);</span>
<span class="line-added">148   }</span>
<span class="line-added">149 };</span>
<span class="line-added">150 </span>
<span class="line-added">151 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 8&gt; {</span>
<span class="line-added">152   static unsigned doit(T v) {</span>
<span class="line-added">153     return __cntlz8(v);</span>
<span class="line-added">154   }</span>
<span class="line-added">155 };</span>
<span class="line-added">156 </span>
<span class="line-added">157 /*****************************************************************************</span>
<span class="line-added">158  * Fallback</span>
<span class="line-added">159  *****************************************************************************/</span>
160 #else
<span class="line-added">161 </span>
<span class="line-added">162 inline uint32_t count_leading_zeros_32(uint32_t x) {</span>
<span class="line-added">163   assert(x != 0, &quot;precondition&quot;);</span>
<span class="line-added">164 </span>
165   // Efficient and portable fallback implementation:
166   // http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn
167   // - with positions xor&#39;d by 31 to get number of leading zeros
168   // rather than position of highest bit.
<span class="line-modified">169   static const uint32_t MultiplyDeBruijnBitPosition[32] = {</span>
<span class="line-modified">170       31, 22, 30, 21, 18, 10, 29,  2, 20, 17, 15, 13, 9,  6, 28,  1,</span>
<span class="line-modified">171       23, 19, 11,  3, 16, 14,  7, 24, 12,  4,  8, 25, 5, 26, 27,  0</span>
172   };
173 
<span class="line-modified">174   // First round down to one less than a power of 2</span>
<span class="line-added">175   x |= x &gt;&gt; 1;</span>
176   x |= x &gt;&gt; 2;
177   x |= x &gt;&gt; 4;
178   x |= x &gt;&gt; 8;
179   x |= x &gt;&gt; 16;
<span class="line-modified">180   // Multiply by a magic constant which ensure the highest 5 bits point to</span>
<span class="line-modified">181   // the right index in the lookup table</span>
<span class="line-added">182   return MultiplyDeBruijnBitPosition[(x * 0x07c4acddu) &gt;&gt; 27u];</span>
183 }
184 
<span class="line-added">185 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 1&gt; {</span>
<span class="line-added">186   static unsigned doit(T v) {</span>
<span class="line-added">187     return count_leading_zeros_32((uint32_t)v &amp; 0xFF) - 24u;</span>
<span class="line-added">188   }</span>
<span class="line-added">189 };</span>
<span class="line-added">190 </span>
<span class="line-added">191 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 2&gt; {</span>
<span class="line-added">192   static unsigned doit(T v) {</span>
<span class="line-added">193     return count_leading_zeros_32((uint32_t)v &amp; 0xFFFF) - 16u;</span>
<span class="line-added">194   }</span>
<span class="line-added">195 };</span>
<span class="line-added">196 </span>
<span class="line-added">197 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 4&gt; {</span>
<span class="line-added">198   static unsigned doit(T v) {</span>
<span class="line-added">199     return count_leading_zeros_32(v);</span>
<span class="line-added">200   }</span>
<span class="line-added">201 };</span>
<span class="line-added">202 </span>
<span class="line-added">203 template &lt;typename T&gt; struct CountLeadingZerosImpl&lt;T, 8&gt; {</span>
<span class="line-added">204   static unsigned doit(T v) {</span>
<span class="line-added">205     uint64_t high = ((uint64_t)v) &gt;&gt; 32ULL;</span>
<span class="line-added">206     if (high != 0) {</span>
<span class="line-added">207       return count_leading_zeros_32((uint32_t)high);</span>
<span class="line-added">208     } else {</span>
<span class="line-added">209       return count_leading_zeros_32((uint32_t)v) + 32u;</span>
<span class="line-added">210     }</span>
<span class="line-added">211   }</span>
<span class="line-added">212 };</span>
<span class="line-added">213 </span>
<span class="line-added">214 #endif</span>
<span class="line-added">215 </span>
216 #endif // SHARE_UTILITIES_COUNT_LEADING_ZEROS_HPP
</pre>
</td>
</tr>
</table>
<center><a href="concurrentHashTableTasks.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="debug.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
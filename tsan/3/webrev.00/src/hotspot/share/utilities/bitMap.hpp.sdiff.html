<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/utilities/bitMap.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bitMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bitMap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/bitMap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_BITMAP_HPP
 26 #define SHARE_UTILITIES_BITMAP_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
<span class="line-modified"> 29 #include &quot;utilities/align.hpp&quot;</span>

 30 
 31 // Forward decl;
 32 class BitMapClosure;
 33 
 34 // Operations for bitmaps represented as arrays of unsigned integers.
<span class="line-modified"> 35 // Bit offsets are numbered from 0 to size-1.</span>
 36 
 37 // The &quot;abstract&quot; base BitMap class.
 38 //
 39 // The constructor and destructor are protected to prevent
 40 // creation of BitMap instances outside of the BitMap class.
 41 //
 42 // The BitMap class doesn&#39;t use virtual calls on purpose,
 43 // this ensures that we don&#39;t get a vtable unnecessarily.
 44 //
 45 // The allocation of the backing storage for the BitMap are handled by
 46 // the subclasses. BitMap doesn&#39;t allocate or delete backing storage.
 47 class BitMap {
 48   friend class BitMap2D;
 49 
 50  public:
 51   typedef size_t idx_t;         // Type used for bit and word indices.
<span class="line-modified"> 52   typedef uintptr_t bm_word_t;  // Element type of array that represents</span>
<span class="line-modified"> 53                                 // the bitmap.</span>


 54 
 55   // Hints for range sizes.
 56   typedef enum {
 57     unknown_range, small_range, large_range
 58   } RangeSizeHint;
 59 
 60  private:
 61   bm_word_t* _map;     // First word in bitmap
 62   idx_t      _size;    // Size of bitmap (in bits)
 63 





























 64   // Helper for get_next_{zero,one}_bit variants.
 65   // - flip designates whether searching for 1s or 0s.  Must be one of
 66   //   find_{zeros,ones}_flip.
 67   // - aligned_right is true if r_index is a priori on a bm_word_t boundary.
 68   template&lt;bm_word_t flip, bool aligned_right&gt;
 69   inline idx_t get_next_bit_impl(idx_t l_index, idx_t r_index) const;
 70 
 71   // Values for get_next_bit_impl flip parameter.
 72   static const bm_word_t find_ones_flip = 0;
 73   static const bm_word_t find_zeros_flip = ~(bm_word_t)0;
 74 
 75   // Threshold for performing small range operation, even when large range
 76   // operation was requested. Measured in words.
 77   static const size_t small_range_words = 32;
 78 


 79  protected:
 80   // Return the position of bit within the word that contains it (e.g., if
 81   // bitmap words are 32 bits, return a number 0 &lt;= n &lt;= 31).
 82   static idx_t bit_in_word(idx_t bit) { return bit &amp; (BitsPerWord - 1); }
 83 
 84   // Return a mask that will select the specified bit, when applied to the word
 85   // containing the bit.
 86   static bm_word_t bit_mask(idx_t bit) { return (bm_word_t)1 &lt;&lt; bit_in_word(bit); }
 87 
<span class="line-removed"> 88   // Return the index of the word containing the specified bit.</span>
<span class="line-removed"> 89   static idx_t word_index(idx_t bit)  { return bit &gt;&gt; LogBitsPerWord; }</span>
<span class="line-removed"> 90 </span>
 91   // Return the bit number of the first bit in the specified word.
 92   static idx_t bit_index(idx_t word)  { return word &lt;&lt; LogBitsPerWord; }
 93 
 94   // Return the array of bitmap words, or a specific word from it.
 95   bm_word_t* map()                 { return _map; }
 96   const bm_word_t* map() const     { return _map; }
 97   bm_word_t  map(idx_t word) const { return _map[word]; }
 98 
 99   // Return a pointer to the word containing the specified bit.
<span class="line-modified">100   bm_word_t* word_addr(idx_t bit)             { return map() + word_index(bit); }</span>
<span class="line-modified">101   const bm_word_t* word_addr(idx_t bit) const { return map() + word_index(bit); }</span>




102 
103   // Set a word to a specified value or to all ones; clear a word.
104   void set_word  (idx_t word, bm_word_t val) { _map[word] = val; }
105   void set_word  (idx_t word)            { set_word(word, ~(bm_word_t)0); }
106   void clear_word(idx_t word)            { _map[word] = 0; }
107 


108   // Utilities for ranges of bits.  Ranges are half-open [beg, end).
109 
110   // Ranges within a single word.
111   bm_word_t inverted_bit_mask_for_range(idx_t beg, idx_t end) const;
112   void  set_range_within_word      (idx_t beg, idx_t end);
113   void  clear_range_within_word    (idx_t beg, idx_t end);
114   void  par_put_range_within_word  (idx_t beg, idx_t end, bool value);
115 
116   // Ranges spanning entire words.
117   void      set_range_of_words         (idx_t beg, idx_t end);
118   void      clear_range_of_words       (idx_t beg, idx_t end);
119   void      set_large_range_of_words   (idx_t beg, idx_t end);
120   void      clear_large_range_of_words (idx_t beg, idx_t end);
121 
122   static void clear_range_of_words(bm_word_t* map, idx_t beg, idx_t end);
123 
<span class="line-removed">124   static bool is_small_range_of_words(idx_t beg_full_word, idx_t end_full_word);</span>
<span class="line-removed">125 </span>
<span class="line-removed">126   // The index of the first full word in a range.</span>
<span class="line-removed">127   idx_t word_index_round_up(idx_t bit) const;</span>
<span class="line-removed">128 </span>
129   // Verification.
<span class="line-removed">130   void verify_index(idx_t index) const NOT_DEBUG_RETURN;</span>
<span class="line-removed">131   void verify_range(idx_t beg_index, idx_t end_index) const NOT_DEBUG_RETURN;</span>
132 
<span class="line-modified">133   // Statistics.</span>
<span class="line-modified">134   static const idx_t* _pop_count_table;</span>
<span class="line-modified">135   static void init_pop_count_table();</span>
<span class="line-modified">136   static idx_t num_set_bits(bm_word_t w);</span>
<span class="line-modified">137   static idx_t num_set_bits_from_table(unsigned char c);</span>



138 
139   // Allocation Helpers.
140 
141   // Allocates and clears the bitmap memory.
142   template &lt;class Allocator&gt;
143   static bm_word_t* allocate(const Allocator&amp;, idx_t size_in_bits, bool clear = true);
144 
145   // Reallocates and clears the new bitmap memory.
146   template &lt;class Allocator&gt;
147   static bm_word_t* reallocate(const Allocator&amp;, bm_word_t* map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear = true);
148 
149   // Free the bitmap memory.
150   template &lt;class Allocator&gt;
151   static void free(const Allocator&amp;, bm_word_t* map, idx_t size_in_bits);
152 
153   // Protected functions, that are used by BitMap sub-classes that support them.
154 
155   // Resize the backing bitmap memory.
156   //
157   // Old bits are transfered to the new memory
158   // and the extended memory is cleared.
159   template &lt;class Allocator&gt;
<span class="line-modified">160   void resize(const Allocator&amp; allocator, idx_t new_size_in_bits);</span>
161 
162   // Set up and clear the bitmap memory.
163   //
164   // Precondition: The bitmap was default constructed and has
165   // not yet had memory allocated via resize or (re)initialize.
166   template &lt;class Allocator&gt;
<span class="line-modified">167   void initialize(const Allocator&amp; allocator, idx_t size_in_bits);</span>
168 
169   // Set up and clear the bitmap memory.
170   //
171   // Can be called on previously initialized bitmaps.
172   template &lt;class Allocator&gt;
<span class="line-modified">173   void reinitialize(const Allocator&amp; allocator, idx_t new_size_in_bits);</span>
174 
175   // Set the map and size.
176   void update(bm_word_t* map, idx_t size) {
177     _map = map;
178     _size = size;
179   }
180 
181   // Protected constructor and destructor.
<span class="line-modified">182   BitMap(bm_word_t* map, idx_t size_in_bits) : _map(map), _size(size_in_bits) {}</span>


183   ~BitMap() {}
184 
185  public:
186   // Pretouch the entire range of memory this BitMap covers.
187   void pretouch();
188 
189   // Accessing
190   static idx_t calc_size_in_words(size_t size_in_bits) {
<span class="line-modified">191     return word_index(size_in_bits + BitsPerWord - 1);</span>
<span class="line-modified">192   }</span>
<span class="line-removed">193 </span>
<span class="line-removed">194   static idx_t calc_size_in_bytes(size_t size_in_bits) {</span>
<span class="line-removed">195     return calc_size_in_words(size_in_bits) * BytesPerWord;</span>
196   }
197 
198   idx_t size() const          { return _size; }
199   idx_t size_in_words() const { return calc_size_in_words(size()); }
<span class="line-modified">200   idx_t size_in_bytes() const { return calc_size_in_bytes(size()); }</span>
201 
202   bool at(idx_t index) const {
203     verify_index(index);
204     return (*word_addr(index) &amp; bit_mask(index)) != 0;
205   }
206 
<span class="line-modified">207   // Align bit index up or down to the next bitmap word boundary, or check</span>
<span class="line-modified">208   // alignment.</span>
<span class="line-removed">209   static idx_t word_align_up(idx_t bit) {</span>
<span class="line-removed">210     return align_up(bit, BitsPerWord);</span>
<span class="line-removed">211   }</span>
<span class="line-removed">212   static idx_t word_align_down(idx_t bit) {</span>
<span class="line-removed">213     return align_down(bit, BitsPerWord);</span>
<span class="line-removed">214   }</span>
<span class="line-removed">215   static bool is_word_aligned(idx_t bit) {</span>
<span class="line-removed">216     return word_align_up(bit) == bit;</span>
<span class="line-removed">217   }</span>
218 
219   // Set or clear the specified bit.
220   inline void set_bit(idx_t bit);
221   inline void clear_bit(idx_t bit);
222 
<span class="line-modified">223   // Atomically set or clear the specified bit.</span>
<span class="line-modified">224   inline bool par_set_bit(idx_t bit);</span>
<span class="line-modified">225   inline bool par_clear_bit(idx_t bit);</span>





226 
<span class="line-modified">227   // Put the given value at the given offset. The parallel version</span>
228   // will CAS the value into the bitmap and is quite a bit slower.
229   // The parallel version also returns a value indicating if the
230   // calling thread was the one that changed the value of the bit.
231   void at_put(idx_t index, bool value);
232   bool par_at_put(idx_t index, bool value);
233 
234   // Update a range of bits.  Ranges are half-open [beg, end).
235   void set_range   (idx_t beg, idx_t end);
236   void clear_range (idx_t beg, idx_t end);
237   void set_large_range   (idx_t beg, idx_t end);
238   void clear_large_range (idx_t beg, idx_t end);
239   void at_put_range(idx_t beg, idx_t end, bool value);
240   void par_at_put_range(idx_t beg, idx_t end, bool value);
241   void at_put_large_range(idx_t beg, idx_t end, bool value);
242   void par_at_put_large_range(idx_t beg, idx_t end, bool value);
243 
244   // Update a range of bits, using a hint about the size.  Currently only
245   // inlines the predominant case of a 1-bit range.  Works best when hint is a
246   // compile-time constant.
247   void set_range(idx_t beg, idx_t end, RangeSizeHint hint);
</pre>
<hr />
<pre>
312  public:
313   // Printing
314   void print_on(outputStream* st) const;
315 #endif
316 };
317 
318 // A concrete implementation of the the &quot;abstract&quot; BitMap class.
319 //
320 // The BitMapView is used when the backing storage is managed externally.
321 class BitMapView : public BitMap {
322  public:
323   BitMapView() : BitMap(NULL, 0) {}
324   BitMapView(bm_word_t* map, idx_t size_in_bits) : BitMap(map, size_in_bits) {}
325 };
326 
327 // A BitMap with storage in a ResourceArea.
328 class ResourceBitMap : public BitMap {
329 
330  public:
331   ResourceBitMap() : BitMap(NULL, 0) {}
<span class="line-modified">332   // Clears the bitmap memory.</span>
<span class="line-modified">333   ResourceBitMap(idx_t size_in_bits);</span>
334 
335   // Resize the backing bitmap memory.
336   //
337   // Old bits are transfered to the new memory
338   // and the extended memory is cleared.
339   void resize(idx_t new_size_in_bits);
340 
341   // Set up and clear the bitmap memory.
342   //
343   // Precondition: The bitmap was default constructed and has
344   // not yet had memory allocated via resize or initialize.
345   void initialize(idx_t size_in_bits);
346 
347   // Set up and clear the bitmap memory.
348   //
349   // Can be called on previously initialized bitmaps.
350   void reinitialize(idx_t size_in_bits);
351 };
352 
353 // A BitMap with storage in a specific Arena.
354 class ArenaBitMap : public BitMap {
355  public:
356   // Clears the bitmap memory.
357   ArenaBitMap(Arena* arena, idx_t size_in_bits);
358 
359  private:
<span class="line-modified">360   // Don&#39;t allow copy or assignment.</span>
<span class="line-removed">361   ArenaBitMap(const ArenaBitMap&amp;);</span>
<span class="line-removed">362   ArenaBitMap&amp; operator=(const ArenaBitMap&amp;);</span>
363 };
364 
365 // A BitMap with storage in the CHeap.
366 class CHeapBitMap : public BitMap {
367 
368  private:
369   // Don&#39;t allow copy or assignment, to prevent the
370   // allocated memory from leaking out to other instances.
<span class="line-modified">371   CHeapBitMap(const CHeapBitMap&amp;);</span>
<span class="line-removed">372   CHeapBitMap&amp; operator=(const CHeapBitMap&amp;);</span>
373 
374   // NMT memory type
375   MEMFLAGS _flags;
376 
377  public:
378   CHeapBitMap(MEMFLAGS flags = mtInternal) : BitMap(NULL, 0), _flags(flags) {}
379   // Clears the bitmap memory.
380   CHeapBitMap(idx_t size_in_bits, MEMFLAGS flags = mtInternal, bool clear = true);
381   ~CHeapBitMap();
382 
383   // Resize the backing bitmap memory.
384   //
385   // Old bits are transfered to the new memory
<span class="line-modified">386   // and the extended memory is cleared.</span>
<span class="line-modified">387   void resize(idx_t new_size_in_bits);</span>
388 
<span class="line-modified">389   // Set up and clear the bitmap memory.</span>
390   //
391   // Precondition: The bitmap was default constructed and has
392   // not yet had memory allocated via resize or initialize.
<span class="line-modified">393   void initialize(idx_t size_in_bits);</span>
394 
<span class="line-modified">395   // Set up and clear the bitmap memory.</span>
396   //
397   // Can be called on previously initialized bitmaps.
<span class="line-modified">398   void reinitialize(idx_t size_in_bits);</span>
399 };
400 
401 // Convenience class wrapping BitMap which provides multiple bits per slot.
402 class BitMap2D {
403  public:
404   typedef BitMap::idx_t idx_t;          // Type used for bit and word indices.
405   typedef BitMap::bm_word_t bm_word_t;  // Element type of array that
406                                         // represents the bitmap.
407  private:
408   ResourceBitMap _map;
409   idx_t          _bits_per_slot;
410 
411   idx_t bit_index(idx_t slot_index, idx_t bit_within_slot_index) const {
412     return slot_index * _bits_per_slot + bit_within_slot_index;
413   }
414 
415   void verify_bit_within_slot_index(idx_t index) const {
416     assert(index &lt; _bits_per_slot, &quot;bit_within_slot index out of bounds&quot;);
417   }
418 
</pre>
<hr />
<pre>
426       _map(size_in_slots * bits_per_slot), _bits_per_slot(bits_per_slot) {}
427 
428   idx_t size_in_bits() {
429     return _map.size();
430   }
431 
432   bool is_valid_index(idx_t slot_index, idx_t bit_within_slot_index);
433   bool at(idx_t slot_index, idx_t bit_within_slot_index) const;
434   void set_bit(idx_t slot_index, idx_t bit_within_slot_index);
435   void clear_bit(idx_t slot_index, idx_t bit_within_slot_index);
436   void at_put(idx_t slot_index, idx_t bit_within_slot_index, bool value);
437   void at_put_grow(idx_t slot_index, idx_t bit_within_slot_index, bool value);
438 };
439 
440 // Closure for iterating over BitMaps
441 
442 class BitMapClosure {
443  public:
444   // Callback when bit in map is set.  Should normally return &quot;true&quot;;
445   // return of false indicates that the bitmap iteration should terminate.
<span class="line-modified">446   virtual bool do_bit(BitMap::idx_t offset) = 0;</span>
447 };
448 
449 #endif // SHARE_UTILITIES_BITMAP_HPP
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_BITMAP_HPP
 26 #define SHARE_UTILITIES_BITMAP_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
<span class="line-modified"> 29 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added"> 30 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 31 
 32 // Forward decl;
 33 class BitMapClosure;
 34 
 35 // Operations for bitmaps represented as arrays of unsigned integers.
<span class="line-modified"> 36 // Bits are numbered from 0 to size-1.</span>
 37 
 38 // The &quot;abstract&quot; base BitMap class.
 39 //
 40 // The constructor and destructor are protected to prevent
 41 // creation of BitMap instances outside of the BitMap class.
 42 //
 43 // The BitMap class doesn&#39;t use virtual calls on purpose,
 44 // this ensures that we don&#39;t get a vtable unnecessarily.
 45 //
 46 // The allocation of the backing storage for the BitMap are handled by
 47 // the subclasses. BitMap doesn&#39;t allocate or delete backing storage.
 48 class BitMap {
 49   friend class BitMap2D;
 50 
 51  public:
 52   typedef size_t idx_t;         // Type used for bit and word indices.
<span class="line-modified"> 53   typedef uintptr_t bm_word_t;  // Element type of array that represents the</span>
<span class="line-modified"> 54                                 // bitmap, with BitsPerWord bits per element.</span>
<span class="line-added"> 55   // If this were to fail, there are lots of places that would need repair.</span>
<span class="line-added"> 56   STATIC_ASSERT((sizeof(bm_word_t) * BitsPerByte) == BitsPerWord);</span>
 57 
 58   // Hints for range sizes.
 59   typedef enum {
 60     unknown_range, small_range, large_range
 61   } RangeSizeHint;
 62 
 63  private:
 64   bm_word_t* _map;     // First word in bitmap
 65   idx_t      _size;    // Size of bitmap (in bits)
 66 
<span class="line-added"> 67   // The maximum allowable size of a bitmap, in words or bits.</span>
<span class="line-added"> 68   // Limit max_size_in_bits so aligning up to a word boundary never overflows.</span>
<span class="line-added"> 69   static idx_t max_size_in_words() { return raw_to_words_align_down(~idx_t(0)); }</span>
<span class="line-added"> 70   static idx_t max_size_in_bits() { return max_size_in_words() * BitsPerWord; }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72   // Assumes relevant validity checking for bit has already been done.</span>
<span class="line-added"> 73   static idx_t raw_to_words_align_up(idx_t bit) {</span>
<span class="line-added"> 74     return raw_to_words_align_down(bit + (BitsPerWord - 1));</span>
<span class="line-added"> 75   }</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77   // Assumes relevant validity checking for bit has already been done.</span>
<span class="line-added"> 78   static idx_t raw_to_words_align_down(idx_t bit) {</span>
<span class="line-added"> 79     return bit &gt;&gt; LogBitsPerWord;</span>
<span class="line-added"> 80   }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82   // Word-aligns bit and converts it to a word offset.</span>
<span class="line-added"> 83   // precondition: bit &lt;= size()</span>
<span class="line-added"> 84   idx_t to_words_align_up(idx_t bit) const {</span>
<span class="line-added"> 85     verify_limit(bit);</span>
<span class="line-added"> 86     return raw_to_words_align_up(bit);</span>
<span class="line-added"> 87   }</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89   // Word-aligns bit and converts it to a word offset.</span>
<span class="line-added"> 90   // precondition: bit &lt;= size()</span>
<span class="line-added"> 91   inline idx_t to_words_align_down(idx_t bit) const {</span>
<span class="line-added"> 92     verify_limit(bit);</span>
<span class="line-added"> 93     return raw_to_words_align_down(bit);</span>
<span class="line-added"> 94   }</span>
<span class="line-added"> 95 </span>
 96   // Helper for get_next_{zero,one}_bit variants.
 97   // - flip designates whether searching for 1s or 0s.  Must be one of
 98   //   find_{zeros,ones}_flip.
 99   // - aligned_right is true if r_index is a priori on a bm_word_t boundary.
100   template&lt;bm_word_t flip, bool aligned_right&gt;
101   inline idx_t get_next_bit_impl(idx_t l_index, idx_t r_index) const;
102 
103   // Values for get_next_bit_impl flip parameter.
104   static const bm_word_t find_ones_flip = 0;
105   static const bm_word_t find_zeros_flip = ~(bm_word_t)0;
106 
107   // Threshold for performing small range operation, even when large range
108   // operation was requested. Measured in words.
109   static const size_t small_range_words = 32;
110 
<span class="line-added">111   static bool is_small_range_of_words(idx_t beg_full_word, idx_t end_full_word);</span>
<span class="line-added">112 </span>
113  protected:
114   // Return the position of bit within the word that contains it (e.g., if
115   // bitmap words are 32 bits, return a number 0 &lt;= n &lt;= 31).
116   static idx_t bit_in_word(idx_t bit) { return bit &amp; (BitsPerWord - 1); }
117 
118   // Return a mask that will select the specified bit, when applied to the word
119   // containing the bit.
120   static bm_word_t bit_mask(idx_t bit) { return (bm_word_t)1 &lt;&lt; bit_in_word(bit); }
121 



122   // Return the bit number of the first bit in the specified word.
123   static idx_t bit_index(idx_t word)  { return word &lt;&lt; LogBitsPerWord; }
124 
125   // Return the array of bitmap words, or a specific word from it.
126   bm_word_t* map()                 { return _map; }
127   const bm_word_t* map() const     { return _map; }
128   bm_word_t  map(idx_t word) const { return _map[word]; }
129 
130   // Return a pointer to the word containing the specified bit.
<span class="line-modified">131   bm_word_t* word_addr(idx_t bit) {</span>
<span class="line-modified">132     return map() + to_words_align_down(bit);</span>
<span class="line-added">133   }</span>
<span class="line-added">134   const bm_word_t* word_addr(idx_t bit) const {</span>
<span class="line-added">135     return map() + to_words_align_down(bit);</span>
<span class="line-added">136   }</span>
137 
138   // Set a word to a specified value or to all ones; clear a word.
139   void set_word  (idx_t word, bm_word_t val) { _map[word] = val; }
140   void set_word  (idx_t word)            { set_word(word, ~(bm_word_t)0); }
141   void clear_word(idx_t word)            { _map[word] = 0; }
142 
<span class="line-added">143   static inline const bm_word_t load_word_ordered(const volatile bm_word_t* const addr, atomic_memory_order memory_order);</span>
<span class="line-added">144 </span>
145   // Utilities for ranges of bits.  Ranges are half-open [beg, end).
146 
147   // Ranges within a single word.
148   bm_word_t inverted_bit_mask_for_range(idx_t beg, idx_t end) const;
149   void  set_range_within_word      (idx_t beg, idx_t end);
150   void  clear_range_within_word    (idx_t beg, idx_t end);
151   void  par_put_range_within_word  (idx_t beg, idx_t end, bool value);
152 
153   // Ranges spanning entire words.
154   void      set_range_of_words         (idx_t beg, idx_t end);
155   void      clear_range_of_words       (idx_t beg, idx_t end);
156   void      set_large_range_of_words   (idx_t beg, idx_t end);
157   void      clear_large_range_of_words (idx_t beg, idx_t end);
158 
159   static void clear_range_of_words(bm_word_t* map, idx_t beg, idx_t end);
160 





161   // Verification.


162 
<span class="line-modified">163   // Verify size_in_bits does not exceed max_size_in_bits().</span>
<span class="line-modified">164   static void verify_size(idx_t size_in_bits) NOT_DEBUG_RETURN;</span>
<span class="line-modified">165   // Verify bit is less than size().</span>
<span class="line-modified">166   void verify_index(idx_t bit) const NOT_DEBUG_RETURN;</span>
<span class="line-modified">167   // Verify bit is not greater than size().</span>
<span class="line-added">168   void verify_limit(idx_t bit) const NOT_DEBUG_RETURN;</span>
<span class="line-added">169   // Verify [beg,end) is a valid range, e.g. beg &lt;= end &lt;= size().</span>
<span class="line-added">170   void verify_range(idx_t beg, idx_t end) const NOT_DEBUG_RETURN;</span>
171 
172   // Allocation Helpers.
173 
174   // Allocates and clears the bitmap memory.
175   template &lt;class Allocator&gt;
176   static bm_word_t* allocate(const Allocator&amp;, idx_t size_in_bits, bool clear = true);
177 
178   // Reallocates and clears the new bitmap memory.
179   template &lt;class Allocator&gt;
180   static bm_word_t* reallocate(const Allocator&amp;, bm_word_t* map, idx_t old_size_in_bits, idx_t new_size_in_bits, bool clear = true);
181 
182   // Free the bitmap memory.
183   template &lt;class Allocator&gt;
184   static void free(const Allocator&amp;, bm_word_t* map, idx_t size_in_bits);
185 
186   // Protected functions, that are used by BitMap sub-classes that support them.
187 
188   // Resize the backing bitmap memory.
189   //
190   // Old bits are transfered to the new memory
191   // and the extended memory is cleared.
192   template &lt;class Allocator&gt;
<span class="line-modified">193   void resize(const Allocator&amp; allocator, idx_t new_size_in_bits, bool clear);</span>
194 
195   // Set up and clear the bitmap memory.
196   //
197   // Precondition: The bitmap was default constructed and has
198   // not yet had memory allocated via resize or (re)initialize.
199   template &lt;class Allocator&gt;
<span class="line-modified">200   void initialize(const Allocator&amp; allocator, idx_t size_in_bits, bool clear);</span>
201 
202   // Set up and clear the bitmap memory.
203   //
204   // Can be called on previously initialized bitmaps.
205   template &lt;class Allocator&gt;
<span class="line-modified">206   void reinitialize(const Allocator&amp; allocator, idx_t new_size_in_bits, bool clear);</span>
207 
208   // Set the map and size.
209   void update(bm_word_t* map, idx_t size) {
210     _map = map;
211     _size = size;
212   }
213 
214   // Protected constructor and destructor.
<span class="line-modified">215   BitMap(bm_word_t* map, idx_t size_in_bits) : _map(map), _size(size_in_bits) {</span>
<span class="line-added">216     verify_size(size_in_bits);</span>
<span class="line-added">217   }</span>
218   ~BitMap() {}
219 
220  public:
221   // Pretouch the entire range of memory this BitMap covers.
222   void pretouch();
223 
224   // Accessing
225   static idx_t calc_size_in_words(size_t size_in_bits) {
<span class="line-modified">226     verify_size(size_in_bits);</span>
<span class="line-modified">227     return raw_to_words_align_up(size_in_bits);</span>



228   }
229 
230   idx_t size() const          { return _size; }
231   idx_t size_in_words() const { return calc_size_in_words(size()); }
<span class="line-modified">232   idx_t size_in_bytes() const { return size_in_words() * BytesPerWord; }</span>
233 
234   bool at(idx_t index) const {
235     verify_index(index);
236     return (*word_addr(index) &amp; bit_mask(index)) != 0;
237   }
238 
<span class="line-modified">239   // memory_order must be memory_order_relaxed or memory_order_acquire.</span>
<span class="line-modified">240   bool par_at(idx_t index, atomic_memory_order memory_order = memory_order_acquire) const;</span>









241 
242   // Set or clear the specified bit.
243   inline void set_bit(idx_t bit);
244   inline void clear_bit(idx_t bit);
245 
<span class="line-modified">246   // Attempts to change a bit to a desired value. The operation returns true if</span>
<span class="line-modified">247   // this thread changed the value of the bit. It was changed with a RMW operation</span>
<span class="line-modified">248   // using the specified memory_order. The operation returns false if the change</span>
<span class="line-added">249   // could not be set due to the bit already being observed in the desired state.</span>
<span class="line-added">250   // The atomic access that observed the bit in the desired state has acquire</span>
<span class="line-added">251   // semantics, unless memory_order is memory_order_relaxed or memory_order_release.</span>
<span class="line-added">252   inline bool par_set_bit(idx_t bit, atomic_memory_order memory_order = memory_order_conservative);</span>
<span class="line-added">253   inline bool par_clear_bit(idx_t bit, atomic_memory_order memory_order = memory_order_conservative);</span>
254 
<span class="line-modified">255   // Put the given value at the given index. The parallel version</span>
256   // will CAS the value into the bitmap and is quite a bit slower.
257   // The parallel version also returns a value indicating if the
258   // calling thread was the one that changed the value of the bit.
259   void at_put(idx_t index, bool value);
260   bool par_at_put(idx_t index, bool value);
261 
262   // Update a range of bits.  Ranges are half-open [beg, end).
263   void set_range   (idx_t beg, idx_t end);
264   void clear_range (idx_t beg, idx_t end);
265   void set_large_range   (idx_t beg, idx_t end);
266   void clear_large_range (idx_t beg, idx_t end);
267   void at_put_range(idx_t beg, idx_t end, bool value);
268   void par_at_put_range(idx_t beg, idx_t end, bool value);
269   void at_put_large_range(idx_t beg, idx_t end, bool value);
270   void par_at_put_large_range(idx_t beg, idx_t end, bool value);
271 
272   // Update a range of bits, using a hint about the size.  Currently only
273   // inlines the predominant case of a 1-bit range.  Works best when hint is a
274   // compile-time constant.
275   void set_range(idx_t beg, idx_t end, RangeSizeHint hint);
</pre>
<hr />
<pre>
340  public:
341   // Printing
342   void print_on(outputStream* st) const;
343 #endif
344 };
345 
346 // A concrete implementation of the the &quot;abstract&quot; BitMap class.
347 //
348 // The BitMapView is used when the backing storage is managed externally.
349 class BitMapView : public BitMap {
350  public:
351   BitMapView() : BitMap(NULL, 0) {}
352   BitMapView(bm_word_t* map, idx_t size_in_bits) : BitMap(map, size_in_bits) {}
353 };
354 
355 // A BitMap with storage in a ResourceArea.
356 class ResourceBitMap : public BitMap {
357 
358  public:
359   ResourceBitMap() : BitMap(NULL, 0) {}
<span class="line-modified">360   // Conditionally clears the bitmap memory.</span>
<span class="line-modified">361   ResourceBitMap(idx_t size_in_bits, bool clear = true);</span>
362 
363   // Resize the backing bitmap memory.
364   //
365   // Old bits are transfered to the new memory
366   // and the extended memory is cleared.
367   void resize(idx_t new_size_in_bits);
368 
369   // Set up and clear the bitmap memory.
370   //
371   // Precondition: The bitmap was default constructed and has
372   // not yet had memory allocated via resize or initialize.
373   void initialize(idx_t size_in_bits);
374 
375   // Set up and clear the bitmap memory.
376   //
377   // Can be called on previously initialized bitmaps.
378   void reinitialize(idx_t size_in_bits);
379 };
380 
381 // A BitMap with storage in a specific Arena.
382 class ArenaBitMap : public BitMap {
383  public:
384   // Clears the bitmap memory.
385   ArenaBitMap(Arena* arena, idx_t size_in_bits);
386 
387  private:
<span class="line-modified">388   NONCOPYABLE(ArenaBitMap);</span>


389 };
390 
391 // A BitMap with storage in the CHeap.
392 class CHeapBitMap : public BitMap {
393 
394  private:
395   // Don&#39;t allow copy or assignment, to prevent the
396   // allocated memory from leaking out to other instances.
<span class="line-modified">397   NONCOPYABLE(CHeapBitMap);</span>

398 
399   // NMT memory type
400   MEMFLAGS _flags;
401 
402  public:
403   CHeapBitMap(MEMFLAGS flags = mtInternal) : BitMap(NULL, 0), _flags(flags) {}
404   // Clears the bitmap memory.
405   CHeapBitMap(idx_t size_in_bits, MEMFLAGS flags = mtInternal, bool clear = true);
406   ~CHeapBitMap();
407 
408   // Resize the backing bitmap memory.
409   //
410   // Old bits are transfered to the new memory
<span class="line-modified">411   // and the extended memory is (optionally) cleared.</span>
<span class="line-modified">412   void resize(idx_t new_size_in_bits, bool clear = true);</span>
413 
<span class="line-modified">414   // Set up and (optionally) clear the bitmap memory.</span>
415   //
416   // Precondition: The bitmap was default constructed and has
417   // not yet had memory allocated via resize or initialize.
<span class="line-modified">418   void initialize(idx_t size_in_bits, bool clear = true);</span>
419 
<span class="line-modified">420   // Set up and (optionally) clear the bitmap memory.</span>
421   //
422   // Can be called on previously initialized bitmaps.
<span class="line-modified">423   void reinitialize(idx_t size_in_bits, bool clear = true);</span>
424 };
425 
426 // Convenience class wrapping BitMap which provides multiple bits per slot.
427 class BitMap2D {
428  public:
429   typedef BitMap::idx_t idx_t;          // Type used for bit and word indices.
430   typedef BitMap::bm_word_t bm_word_t;  // Element type of array that
431                                         // represents the bitmap.
432  private:
433   ResourceBitMap _map;
434   idx_t          _bits_per_slot;
435 
436   idx_t bit_index(idx_t slot_index, idx_t bit_within_slot_index) const {
437     return slot_index * _bits_per_slot + bit_within_slot_index;
438   }
439 
440   void verify_bit_within_slot_index(idx_t index) const {
441     assert(index &lt; _bits_per_slot, &quot;bit_within_slot index out of bounds&quot;);
442   }
443 
</pre>
<hr />
<pre>
451       _map(size_in_slots * bits_per_slot), _bits_per_slot(bits_per_slot) {}
452 
453   idx_t size_in_bits() {
454     return _map.size();
455   }
456 
457   bool is_valid_index(idx_t slot_index, idx_t bit_within_slot_index);
458   bool at(idx_t slot_index, idx_t bit_within_slot_index) const;
459   void set_bit(idx_t slot_index, idx_t bit_within_slot_index);
460   void clear_bit(idx_t slot_index, idx_t bit_within_slot_index);
461   void at_put(idx_t slot_index, idx_t bit_within_slot_index, bool value);
462   void at_put_grow(idx_t slot_index, idx_t bit_within_slot_index, bool value);
463 };
464 
465 // Closure for iterating over BitMaps
466 
467 class BitMapClosure {
468  public:
469   // Callback when bit in map is set.  Should normally return &quot;true&quot;;
470   // return of false indicates that the bitmap iteration should terminate.
<span class="line-modified">471   virtual bool do_bit(BitMap::idx_t index) = 0;</span>
472 };
473 
474 #endif // SHARE_UTILITIES_BITMAP_HPP
</pre>
</td>
</tr>
</table>
<center><a href="bitMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="bitMap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/bitMap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_BITMAP_INLINE_HPP
 26 #define SHARE_UTILITIES_BITMAP_INLINE_HPP
 27 
 28 #include &quot;runtime/atomic.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &quot;utilities/align.hpp&quot;</span>
 30 #include &quot;utilities/bitMap.hpp&quot;
 31 #include &quot;utilities/count_trailing_zeros.hpp&quot;
 32 
 33 inline void BitMap::set_bit(idx_t bit) {
 34   verify_index(bit);
 35   *word_addr(bit) |= bit_mask(bit);
 36 }
 37 
 38 inline void BitMap::clear_bit(idx_t bit) {
 39   verify_index(bit);
 40   *word_addr(bit) &amp;= ~bit_mask(bit);
 41 }
 42 
<a name="2" id="anc2"></a><span class="line-modified"> 43 inline const BitMap::bm_word_t BitMap::load_word_ordered(const volatile bm_word_t* const addr, atomic_memory_order memory_order) {</span>
<span class="line-added"> 44   if (memory_order == memory_order_relaxed || memory_order == memory_order_release) {</span>
<span class="line-added"> 45     return Atomic::load(addr);</span>
<span class="line-added"> 46   } else {</span>
<span class="line-added"> 47     assert(memory_order == memory_order_acq_rel ||</span>
<span class="line-added"> 48            memory_order == memory_order_acquire ||</span>
<span class="line-added"> 49            memory_order == memory_order_conservative,</span>
<span class="line-added"> 50            &quot;unexpected memory ordering&quot;);</span>
<span class="line-added"> 51     return Atomic::load_acquire(addr);</span>
<span class="line-added"> 52   }</span>
<span class="line-added"> 53 }</span>
<span class="line-added"> 54 </span>
<span class="line-added"> 55 inline bool BitMap::par_at(idx_t index, atomic_memory_order memory_order) const {</span>
<span class="line-added"> 56   verify_index(index);</span>
<span class="line-added"> 57   assert(memory_order == memory_order_acquire ||</span>
<span class="line-added"> 58          memory_order == memory_order_relaxed,</span>
<span class="line-added"> 59          &quot;unexpected memory ordering&quot;);</span>
<span class="line-added"> 60   const volatile bm_word_t* const addr = word_addr(index);</span>
<span class="line-added"> 61   return (load_word_ordered(addr, memory_order) &amp; bit_mask(index)) != 0;</span>
<span class="line-added"> 62 }</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64 inline bool BitMap::par_set_bit(idx_t bit, atomic_memory_order memory_order) {</span>
 65   verify_index(bit);
 66   volatile bm_word_t* const addr = word_addr(bit);
 67   const bm_word_t mask = bit_mask(bit);
<a name="3" id="anc3"></a><span class="line-modified"> 68   bm_word_t old_val = load_word_ordered(addr, memory_order);</span>
 69 
 70   do {
 71     const bm_word_t new_val = old_val | mask;
 72     if (new_val == old_val) {
 73       return false;     // Someone else beat us to it.
 74     }
<a name="4" id="anc4"></a><span class="line-modified"> 75     const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val, memory_order);</span>
 76     if (cur_val == old_val) {
 77       return true;      // Success.
 78     }
 79     old_val = cur_val;  // The value changed, try again.
 80   } while (true);
 81 }
 82 
<a name="5" id="anc5"></a><span class="line-modified"> 83 inline bool BitMap::par_clear_bit(idx_t bit, atomic_memory_order memory_order) {</span>
 84   verify_index(bit);
 85   volatile bm_word_t* const addr = word_addr(bit);
 86   const bm_word_t mask = ~bit_mask(bit);
<a name="6" id="anc6"></a><span class="line-modified"> 87   bm_word_t old_val = load_word_ordered(addr, memory_order);</span>
 88 
 89   do {
 90     const bm_word_t new_val = old_val &amp; mask;
 91     if (new_val == old_val) {
 92       return false;     // Someone else beat us to it.
 93     }
<a name="7" id="anc7"></a><span class="line-modified"> 94     const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val, memory_order);</span>
 95     if (cur_val == old_val) {
 96       return true;      // Success.
 97     }
 98     old_val = cur_val;  // The value changed, try again.
 99   } while (true);
100 }
101 
102 inline void BitMap::set_range(idx_t beg, idx_t end, RangeSizeHint hint) {
103   if (hint == small_range &amp;&amp; end - beg == 1) {
104     set_bit(beg);
105   } else {
106     if (hint == large_range) {
107       set_large_range(beg, end);
108     } else {
109       set_range(beg, end);
110     }
111   }
112 }
113 
114 inline void BitMap::clear_range(idx_t beg, idx_t end, RangeSizeHint hint) {
115   if (end - beg == 1) {
116     clear_bit(beg);
117   } else {
118     if (hint == large_range) {
119       clear_large_range(beg, end);
120     } else {
121       clear_range(beg, end);
122     }
123   }
124 }
125 
126 inline void BitMap::par_set_range(idx_t beg, idx_t end, RangeSizeHint hint) {
127   if (hint == small_range &amp;&amp; end - beg == 1) {
128     par_at_put(beg, true);
129   } else {
130     if (hint == large_range) {
131       par_at_put_large_range(beg, end, true);
132     } else {
133       par_at_put_range(beg, end, true);
134     }
135   }
136 }
137 
138 inline void BitMap::set_range_of_words(idx_t beg, idx_t end) {
139   bm_word_t* map = _map;
140   for (idx_t i = beg; i &lt; end; ++i) map[i] = ~(bm_word_t)0;
141 }
142 
143 inline void BitMap::clear_range_of_words(bm_word_t* map, idx_t beg, idx_t end) {
144   for (idx_t i = beg; i &lt; end; ++i) map[i] = 0;
145 }
146 
147 inline void BitMap::clear_range_of_words(idx_t beg, idx_t end) {
148   clear_range_of_words(_map, beg, end);
149 }
150 
151 inline void BitMap::clear() {
152   clear_range_of_words(0, size_in_words());
153 }
154 
155 inline void BitMap::par_clear_range(idx_t beg, idx_t end, RangeSizeHint hint) {
156   if (hint == small_range &amp;&amp; end - beg == 1) {
157     par_at_put(beg, false);
158   } else {
159     if (hint == large_range) {
160       par_at_put_large_range(beg, end, false);
161     } else {
162       par_at_put_range(beg, end, false);
163     }
164   }
165 }
166 
167 template&lt;BitMap::bm_word_t flip, bool aligned_right&gt;
168 inline BitMap::idx_t BitMap::get_next_bit_impl(idx_t l_index, idx_t r_index) const {
169   STATIC_ASSERT(flip == find_ones_flip || flip == find_zeros_flip);
170   verify_range(l_index, r_index);
<a name="8" id="anc8"></a><span class="line-modified">171   assert(!aligned_right || is_aligned(r_index, BitsPerWord), &quot;r_index not aligned&quot;);</span>
172 
173   // The first word often contains an interesting bit, either due to
174   // density or because of features of the calling algorithm.  So it&#39;s
175   // important to examine that first word with a minimum of fuss,
176   // minimizing setup time for later words that will be wasted if the
177   // first word is indeed interesting.
178 
179   // The benefit from aligned_right being true is relatively small.
<a name="9" id="anc9"></a><span class="line-modified">180   // It saves an operation in the setup for the word search loop.</span>
<span class="line-modified">181   // It also eliminates the range check on the final result.</span>
182   // However, callers often have a comparison with r_index, and
183   // inlining often allows the two comparisons to be combined; it is
184   // important when !aligned_right that return paths either return
185   // r_index or a value dominated by a comparison with r_index.
186   // aligned_right is still helpful when the caller doesn&#39;t have a
187   // range check because features of the calling algorithm guarantee
188   // an interesting bit will be present.
189 
190   if (l_index &lt; r_index) {
191     // Get the word containing l_index, and shift out low bits.
<a name="10" id="anc10"></a><span class="line-modified">192     idx_t index = to_words_align_down(l_index);</span>
193     bm_word_t cword = (map(index) ^ flip) &gt;&gt; bit_in_word(l_index);
194     if ((cword &amp; 1) != 0) {
195       // The first bit is similarly often interesting. When it matters
196       // (density or features of the calling algorithm make it likely
197       // the first bit is set), going straight to the next clause compares
198       // poorly with doing this check first; count_trailing_zeros can be
199       // relatively expensive, plus there is the additional range check.
200       // But when the first bit isn&#39;t set, the cost of having tested for
201       // it is relatively small compared to the rest of the search.
202       return l_index;
203     } else if (cword != 0) {
204       // Flipped and shifted first word is non-zero.
205       idx_t result = l_index + count_trailing_zeros(cword);
206       if (aligned_right || (result &lt; r_index)) return result;
207       // Result is beyond range bound; return r_index.
208     } else {
209       // Flipped and shifted first word is zero.  Word search through
210       // aligned up r_index for a non-zero flipped word.
211       idx_t limit = aligned_right
<a name="11" id="anc11"></a><span class="line-modified">212         ? to_words_align_down(r_index) // Miniscule savings when aligned.</span>
<span class="line-modified">213         : to_words_align_up(r_index);</span>
214       while (++index &lt; limit) {
215         cword = map(index) ^ flip;
216         if (cword != 0) {
217           idx_t result = bit_index(index) + count_trailing_zeros(cword);
218           if (aligned_right || (result &lt; r_index)) return result;
219           // Result is beyond range bound; return r_index.
220           assert((index + 1) == limit, &quot;invariant&quot;);
221           break;
222         }
223       }
224       // No bits in range; return r_index.
225     }
226   }
227   return r_index;
228 }
229 
230 inline BitMap::idx_t
231 BitMap::get_next_one_offset(idx_t l_offset, idx_t r_offset) const {
232   return get_next_bit_impl&lt;find_ones_flip, false&gt;(l_offset, r_offset);
233 }
234 
235 inline BitMap::idx_t
236 BitMap::get_next_zero_offset(idx_t l_offset, idx_t r_offset) const {
237   return get_next_bit_impl&lt;find_zeros_flip, false&gt;(l_offset, r_offset);
238 }
239 
240 inline BitMap::idx_t
241 BitMap::get_next_one_offset_aligned_right(idx_t l_offset, idx_t r_offset) const {
242   return get_next_bit_impl&lt;find_ones_flip, true&gt;(l_offset, r_offset);
243 }
244 
245 // Returns a bit mask for a range of bits [beg, end) within a single word.  Each
246 // bit in the mask is 0 if the bit is in the range, 1 if not in the range.  The
247 // returned mask can be used directly to clear the range, or inverted to set the
248 // range.  Note:  end must not be 0.
249 inline BitMap::bm_word_t
250 BitMap::inverted_bit_mask_for_range(idx_t beg, idx_t end) const {
251   assert(end != 0, &quot;does not work when end == 0&quot;);
<a name="12" id="anc12"></a><span class="line-modified">252   assert(beg == end || to_words_align_down(beg) == to_words_align_down(end - 1),</span>
253          &quot;must be a single-word range&quot;);
254   bm_word_t mask = bit_mask(beg) - 1;   // low (right) bits
255   if (bit_in_word(end) != 0) {
256     mask |= ~(bit_mask(end) - 1);       // high (left) bits
257   }
258   return mask;
259 }
260 
261 inline void BitMap::set_large_range_of_words(idx_t beg, idx_t end) {
262   assert(beg &lt;= end, &quot;underflow&quot;);
263   memset(_map + beg, ~(unsigned char)0, (end - beg) * sizeof(bm_word_t));
264 }
265 
266 inline void BitMap::clear_large_range_of_words(idx_t beg, idx_t end) {
267   assert(beg &lt;= end, &quot;underflow&quot;);
268   memset(_map + beg, 0, (end - beg) * sizeof(bm_word_t));
269 }
270 
<a name="13" id="anc13"></a>





271 inline bool BitMap2D::is_valid_index(idx_t slot_index, idx_t bit_within_slot_index) {
272   verify_bit_within_slot_index(bit_within_slot_index);
273   return (bit_index(slot_index, bit_within_slot_index) &lt; size_in_bits());
274 }
275 
276 inline bool BitMap2D::at(idx_t slot_index, idx_t bit_within_slot_index) const {
277   verify_bit_within_slot_index(bit_within_slot_index);
278   return _map.at(bit_index(slot_index, bit_within_slot_index));
279 }
280 
281 inline void BitMap2D::set_bit(idx_t slot_index, idx_t bit_within_slot_index) {
282   verify_bit_within_slot_index(bit_within_slot_index);
283   _map.set_bit(bit_index(slot_index, bit_within_slot_index));
284 }
285 
286 inline void BitMap2D::clear_bit(idx_t slot_index, idx_t bit_within_slot_index) {
287   verify_bit_within_slot_index(bit_within_slot_index);
288   _map.clear_bit(bit_index(slot_index, bit_within_slot_index));
289 }
290 
291 inline void BitMap2D::at_put(idx_t slot_index, idx_t bit_within_slot_index, bool value) {
292   verify_bit_within_slot_index(bit_within_slot_index);
293   _map.at_put(bit_index(slot_index, bit_within_slot_index), value);
294 }
295 
296 inline void BitMap2D::at_put_grow(idx_t slot_index, idx_t bit_within_slot_index, bool value) {
297   verify_bit_within_slot_index(bit_within_slot_index);
298 
299   idx_t bit = bit_index(slot_index, bit_within_slot_index);
300   if (bit &gt;= _map.size()) {
301     _map.resize(2 * MAX2(_map.size(), bit));
302   }
303   _map.at_put(bit, value);
304 }
305 
306 #endif // SHARE_UTILITIES_BITMAP_INLINE_HPP
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
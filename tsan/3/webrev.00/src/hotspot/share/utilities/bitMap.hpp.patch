diff a/src/hotspot/share/utilities/bitMap.hpp b/src/hotspot/share/utilities/bitMap.hpp
--- a/src/hotspot/share/utilities/bitMap.hpp
+++ b/src/hotspot/share/utilities/bitMap.hpp
@@ -24,17 +24,18 @@
 
 #ifndef SHARE_UTILITIES_BITMAP_HPP
 #define SHARE_UTILITIES_BITMAP_HPP
 
 #include "memory/allocation.hpp"
-#include "utilities/align.hpp"
+#include "runtime/atomic.hpp"
+#include "utilities/globalDefinitions.hpp"
 
 // Forward decl;
 class BitMapClosure;
 
 // Operations for bitmaps represented as arrays of unsigned integers.
-// Bit offsets are numbered from 0 to size-1.
+// Bits are numbered from 0 to size-1.
 
 // The "abstract" base BitMap class.
 //
 // The constructor and destructor are protected to prevent
 // creation of BitMap instances outside of the BitMap class.
@@ -47,22 +48,53 @@
 class BitMap {
   friend class BitMap2D;
 
  public:
   typedef size_t idx_t;         // Type used for bit and word indices.
-  typedef uintptr_t bm_word_t;  // Element type of array that represents
-                                // the bitmap.
+  typedef uintptr_t bm_word_t;  // Element type of array that represents the
+                                // bitmap, with BitsPerWord bits per element.
+  // If this were to fail, there are lots of places that would need repair.
+  STATIC_ASSERT((sizeof(bm_word_t) * BitsPerByte) == BitsPerWord);
 
   // Hints for range sizes.
   typedef enum {
     unknown_range, small_range, large_range
   } RangeSizeHint;
 
  private:
   bm_word_t* _map;     // First word in bitmap
   idx_t      _size;    // Size of bitmap (in bits)
 
+  // The maximum allowable size of a bitmap, in words or bits.
+  // Limit max_size_in_bits so aligning up to a word boundary never overflows.
+  static idx_t max_size_in_words() { return raw_to_words_align_down(~idx_t(0)); }
+  static idx_t max_size_in_bits() { return max_size_in_words() * BitsPerWord; }
+
+  // Assumes relevant validity checking for bit has already been done.
+  static idx_t raw_to_words_align_up(idx_t bit) {
+    return raw_to_words_align_down(bit + (BitsPerWord - 1));
+  }
+
+  // Assumes relevant validity checking for bit has already been done.
+  static idx_t raw_to_words_align_down(idx_t bit) {
+    return bit >> LogBitsPerWord;
+  }
+
+  // Word-aligns bit and converts it to a word offset.
+  // precondition: bit <= size()
+  idx_t to_words_align_up(idx_t bit) const {
+    verify_limit(bit);
+    return raw_to_words_align_up(bit);
+  }
+
+  // Word-aligns bit and converts it to a word offset.
+  // precondition: bit <= size()
+  inline idx_t to_words_align_down(idx_t bit) const {
+    verify_limit(bit);
+    return raw_to_words_align_down(bit);
+  }
+
   // Helper for get_next_{zero,one}_bit variants.
   // - flip designates whether searching for 1s or 0s.  Must be one of
   //   find_{zeros,ones}_flip.
   // - aligned_right is true if r_index is a priori on a bm_word_t boundary.
   template<bm_word_t flip, bool aligned_right>
@@ -74,39 +106,44 @@
 
   // Threshold for performing small range operation, even when large range
   // operation was requested. Measured in words.
   static const size_t small_range_words = 32;
 
+  static bool is_small_range_of_words(idx_t beg_full_word, idx_t end_full_word);
+
  protected:
   // Return the position of bit within the word that contains it (e.g., if
   // bitmap words are 32 bits, return a number 0 <= n <= 31).
   static idx_t bit_in_word(idx_t bit) { return bit & (BitsPerWord - 1); }
 
   // Return a mask that will select the specified bit, when applied to the word
   // containing the bit.
   static bm_word_t bit_mask(idx_t bit) { return (bm_word_t)1 << bit_in_word(bit); }
 
-  // Return the index of the word containing the specified bit.
-  static idx_t word_index(idx_t bit)  { return bit >> LogBitsPerWord; }
-
   // Return the bit number of the first bit in the specified word.
   static idx_t bit_index(idx_t word)  { return word << LogBitsPerWord; }
 
   // Return the array of bitmap words, or a specific word from it.
   bm_word_t* map()                 { return _map; }
   const bm_word_t* map() const     { return _map; }
   bm_word_t  map(idx_t word) const { return _map[word]; }
 
   // Return a pointer to the word containing the specified bit.
-  bm_word_t* word_addr(idx_t bit)             { return map() + word_index(bit); }
-  const bm_word_t* word_addr(idx_t bit) const { return map() + word_index(bit); }
+  bm_word_t* word_addr(idx_t bit) {
+    return map() + to_words_align_down(bit);
+  }
+  const bm_word_t* word_addr(idx_t bit) const {
+    return map() + to_words_align_down(bit);
+  }
 
   // Set a word to a specified value or to all ones; clear a word.
   void set_word  (idx_t word, bm_word_t val) { _map[word] = val; }
   void set_word  (idx_t word)            { set_word(word, ~(bm_word_t)0); }
   void clear_word(idx_t word)            { _map[word] = 0; }
 
+  static inline const bm_word_t load_word_ordered(const volatile bm_word_t* const addr, atomic_memory_order memory_order);
+
   // Utilities for ranges of bits.  Ranges are half-open [beg, end).
 
   // Ranges within a single word.
   bm_word_t inverted_bit_mask_for_range(idx_t beg, idx_t end) const;
   void  set_range_within_word      (idx_t beg, idx_t end);
@@ -119,24 +156,20 @@
   void      set_large_range_of_words   (idx_t beg, idx_t end);
   void      clear_large_range_of_words (idx_t beg, idx_t end);
 
   static void clear_range_of_words(bm_word_t* map, idx_t beg, idx_t end);
 
-  static bool is_small_range_of_words(idx_t beg_full_word, idx_t end_full_word);
-
-  // The index of the first full word in a range.
-  idx_t word_index_round_up(idx_t bit) const;
-
   // Verification.
-  void verify_index(idx_t index) const NOT_DEBUG_RETURN;
-  void verify_range(idx_t beg_index, idx_t end_index) const NOT_DEBUG_RETURN;
 
-  // Statistics.
-  static const idx_t* _pop_count_table;
-  static void init_pop_count_table();
-  static idx_t num_set_bits(bm_word_t w);
-  static idx_t num_set_bits_from_table(unsigned char c);
+  // Verify size_in_bits does not exceed max_size_in_bits().
+  static void verify_size(idx_t size_in_bits) NOT_DEBUG_RETURN;
+  // Verify bit is less than size().
+  void verify_index(idx_t bit) const NOT_DEBUG_RETURN;
+  // Verify bit is not greater than size().
+  void verify_limit(idx_t bit) const NOT_DEBUG_RETURN;
+  // Verify [beg,end) is a valid range, e.g. beg <= end <= size().
+  void verify_range(idx_t beg, idx_t end) const NOT_DEBUG_RETURN;
 
   // Allocation Helpers.
 
   // Allocates and clears the bitmap memory.
   template <class Allocator>
@@ -155,78 +188,73 @@
   // Resize the backing bitmap memory.
   //
   // Old bits are transfered to the new memory
   // and the extended memory is cleared.
   template <class Allocator>
-  void resize(const Allocator& allocator, idx_t new_size_in_bits);
+  void resize(const Allocator& allocator, idx_t new_size_in_bits, bool clear);
 
   // Set up and clear the bitmap memory.
   //
   // Precondition: The bitmap was default constructed and has
   // not yet had memory allocated via resize or (re)initialize.
   template <class Allocator>
-  void initialize(const Allocator& allocator, idx_t size_in_bits);
+  void initialize(const Allocator& allocator, idx_t size_in_bits, bool clear);
 
   // Set up and clear the bitmap memory.
   //
   // Can be called on previously initialized bitmaps.
   template <class Allocator>
-  void reinitialize(const Allocator& allocator, idx_t new_size_in_bits);
+  void reinitialize(const Allocator& allocator, idx_t new_size_in_bits, bool clear);
 
   // Set the map and size.
   void update(bm_word_t* map, idx_t size) {
     _map = map;
     _size = size;
   }
 
   // Protected constructor and destructor.
-  BitMap(bm_word_t* map, idx_t size_in_bits) : _map(map), _size(size_in_bits) {}
+  BitMap(bm_word_t* map, idx_t size_in_bits) : _map(map), _size(size_in_bits) {
+    verify_size(size_in_bits);
+  }
   ~BitMap() {}
 
  public:
   // Pretouch the entire range of memory this BitMap covers.
   void pretouch();
 
   // Accessing
   static idx_t calc_size_in_words(size_t size_in_bits) {
-    return word_index(size_in_bits + BitsPerWord - 1);
-  }
-
-  static idx_t calc_size_in_bytes(size_t size_in_bits) {
-    return calc_size_in_words(size_in_bits) * BytesPerWord;
+    verify_size(size_in_bits);
+    return raw_to_words_align_up(size_in_bits);
   }
 
   idx_t size() const          { return _size; }
   idx_t size_in_words() const { return calc_size_in_words(size()); }
-  idx_t size_in_bytes() const { return calc_size_in_bytes(size()); }
+  idx_t size_in_bytes() const { return size_in_words() * BytesPerWord; }
 
   bool at(idx_t index) const {
     verify_index(index);
     return (*word_addr(index) & bit_mask(index)) != 0;
   }
 
-  // Align bit index up or down to the next bitmap word boundary, or check
-  // alignment.
-  static idx_t word_align_up(idx_t bit) {
-    return align_up(bit, BitsPerWord);
-  }
-  static idx_t word_align_down(idx_t bit) {
-    return align_down(bit, BitsPerWord);
-  }
-  static bool is_word_aligned(idx_t bit) {
-    return word_align_up(bit) == bit;
-  }
+  // memory_order must be memory_order_relaxed or memory_order_acquire.
+  bool par_at(idx_t index, atomic_memory_order memory_order = memory_order_acquire) const;
 
   // Set or clear the specified bit.
   inline void set_bit(idx_t bit);
   inline void clear_bit(idx_t bit);
 
-  // Atomically set or clear the specified bit.
-  inline bool par_set_bit(idx_t bit);
-  inline bool par_clear_bit(idx_t bit);
+  // Attempts to change a bit to a desired value. The operation returns true if
+  // this thread changed the value of the bit. It was changed with a RMW operation
+  // using the specified memory_order. The operation returns false if the change
+  // could not be set due to the bit already being observed in the desired state.
+  // The atomic access that observed the bit in the desired state has acquire
+  // semantics, unless memory_order is memory_order_relaxed or memory_order_release.
+  inline bool par_set_bit(idx_t bit, atomic_memory_order memory_order = memory_order_conservative);
+  inline bool par_clear_bit(idx_t bit, atomic_memory_order memory_order = memory_order_conservative);
 
-  // Put the given value at the given offset. The parallel version
+  // Put the given value at the given index. The parallel version
   // will CAS the value into the bitmap and is quite a bit slower.
   // The parallel version also returns a value indicating if the
   // calling thread was the one that changed the value of the bit.
   void at_put(idx_t index, bool value);
   bool par_at_put(idx_t index, bool value);
@@ -327,12 +355,12 @@
 // A BitMap with storage in a ResourceArea.
 class ResourceBitMap : public BitMap {
 
  public:
   ResourceBitMap() : BitMap(NULL, 0) {}
-  // Clears the bitmap memory.
-  ResourceBitMap(idx_t size_in_bits);
+  // Conditionally clears the bitmap memory.
+  ResourceBitMap(idx_t size_in_bits, bool clear = true);
 
   // Resize the backing bitmap memory.
   //
   // Old bits are transfered to the new memory
   // and the extended memory is cleared.
@@ -355,23 +383,20 @@
  public:
   // Clears the bitmap memory.
   ArenaBitMap(Arena* arena, idx_t size_in_bits);
 
  private:
-  // Don't allow copy or assignment.
-  ArenaBitMap(const ArenaBitMap&);
-  ArenaBitMap& operator=(const ArenaBitMap&);
+  NONCOPYABLE(ArenaBitMap);
 };
 
 // A BitMap with storage in the CHeap.
 class CHeapBitMap : public BitMap {
 
  private:
   // Don't allow copy or assignment, to prevent the
   // allocated memory from leaking out to other instances.
-  CHeapBitMap(const CHeapBitMap&);
-  CHeapBitMap& operator=(const CHeapBitMap&);
+  NONCOPYABLE(CHeapBitMap);
 
   // NMT memory type
   MEMFLAGS _flags;
 
  public:
@@ -381,23 +406,23 @@
   ~CHeapBitMap();
 
   // Resize the backing bitmap memory.
   //
   // Old bits are transfered to the new memory
-  // and the extended memory is cleared.
-  void resize(idx_t new_size_in_bits);
+  // and the extended memory is (optionally) cleared.
+  void resize(idx_t new_size_in_bits, bool clear = true);
 
-  // Set up and clear the bitmap memory.
+  // Set up and (optionally) clear the bitmap memory.
   //
   // Precondition: The bitmap was default constructed and has
   // not yet had memory allocated via resize or initialize.
-  void initialize(idx_t size_in_bits);
+  void initialize(idx_t size_in_bits, bool clear = true);
 
-  // Set up and clear the bitmap memory.
+  // Set up and (optionally) clear the bitmap memory.
   //
   // Can be called on previously initialized bitmaps.
-  void reinitialize(idx_t size_in_bits);
+  void reinitialize(idx_t size_in_bits, bool clear = true);
 };
 
 // Convenience class wrapping BitMap which provides multiple bits per slot.
 class BitMap2D {
  public:
@@ -441,9 +466,9 @@
 
 class BitMapClosure {
  public:
   // Callback when bit in map is set.  Should normally return "true";
   // return of false indicates that the bitmap iteration should terminate.
-  virtual bool do_bit(BitMap::idx_t offset) = 0;
+  virtual bool do_bit(BitMap::idx_t index) = 0;
 };
 
 #endif // SHARE_UTILITIES_BITMAP_HPP

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jvmci/jvmciEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCompilerToVMInit.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciEnv.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciEnv.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,57 ***</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
<span class="line-modified">! #include &quot;classfile/javaAssertions.hpp&quot;</span>
<span class="line-removed">- #include &quot;classfile/systemDictionary.hpp&quot;</span>
<span class="line-removed">- #include &quot;classfile/vmSymbols.hpp&quot;</span>
  #include &quot;code/codeCache.hpp&quot;
<span class="line-removed">- #include &quot;code/scopeDesc.hpp&quot;</span>
<span class="line-removed">- #include &quot;compiler/compileBroker.hpp&quot;</span>
<span class="line-removed">- #include &quot;compiler/compileLog.hpp&quot;</span>
<span class="line-removed">- #include &quot;compiler/compilerOracle.hpp&quot;</span>
<span class="line-removed">- #include &quot;interpreter/linkResolver.hpp&quot;</span>
<span class="line-removed">- #include &quot;memory/allocation.inline.hpp&quot;</span>
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="line-removed">- #include &quot;oops/constantPool.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;oops/cpCache.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;oops/method.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;oops/methodData.hpp&quot;</span>
  #include &quot;oops/objArrayKlass.hpp&quot;
<span class="line-modified">! #include &quot;oops/oop.inline.hpp&quot;</span>
<span class="line-modified">! #include &quot;prims/jvmtiExport.hpp&quot;</span>
<span class="line-modified">! #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
<span class="line-modified">! #include &quot;runtime/handles.inline.hpp&quot;</span>
<span class="line-modified">! #include &quot;runtime/init.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/reflection.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/sharedRuntime.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/sweeper.hpp&quot;</span>
<span class="line-removed">- #include &quot;utilities/dtrace.hpp&quot;</span>
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="line-removed">- #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
  
<span class="line-modified">! JVMCIEnv::JVMCIEnv(CompileTask* task, int system_dictionary_modification_counter):</span>
    _task(task),
<span class="line-removed">-   _system_dictionary_modification_counter(system_dictionary_modification_counter),</span>
    _retryable(true),
    _failure_reason(NULL),
<span class="line-modified">!   _failure_reason_on_C_heap(false)</span>
<span class="line-removed">- {</span>
    // Get Jvmti capabilities under lock to get consistent values.
    MutexLocker mu(JvmtiThreadState_lock);
    _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint() ? 1 : 0;
    _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables() ? 1 : 0;
    _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions() ? 1 : 0;
    _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame() ? 1 : 0;
  }
  
<span class="line-modified">! bool JVMCIEnv::jvmti_state_changed() const {</span>
    if (!jvmti_can_access_local_variables() &amp;&amp;
        JvmtiExport::can_access_local_variables()) {
      return true;
    }
    if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
<span class="line-new-header">--- 21,43 ---</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;classfile/stringTable.hpp&quot;</span>
<span class="line-modified">! #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
<span class="line-modified">! #include &quot;oops/typeArrayOop.inline.hpp&quot;</span>
<span class="line-modified">! #include &quot;runtime/deoptimization.hpp&quot;</span>
<span class="line-modified">! #include &quot;runtime/jniHandles.inline.hpp&quot;</span>
<span class="line-modified">! #include &quot;runtime/javaCalls.hpp&quot;</span>
<span class="line-modified">! #include &quot;jvmci/jniAccessMark.inline.hpp&quot;</span>
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
  
<span class="line-modified">! JVMCICompileState::JVMCICompileState(CompileTask* task):</span>
    _task(task),
    _retryable(true),
    _failure_reason(NULL),
<span class="line-modified">!   _failure_reason_on_C_heap(false) {</span>
    // Get Jvmti capabilities under lock to get consistent values.
    MutexLocker mu(JvmtiThreadState_lock);
<span class="line-added">+   _jvmti_redefinition_count             = JvmtiExport::redefinition_count();</span>
    _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint() ? 1 : 0;
    _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables() ? 1 : 0;
    _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions() ? 1 : 0;
    _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame() ? 1 : 0;
  }
  
<span class="line-modified">! bool JVMCICompileState::jvmti_state_changed() const {</span>
<span class="line-added">+   // Some classes were redefined</span>
<span class="line-added">+   if (jvmti_redefinition_count() != JvmtiExport::redefinition_count()) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
    if (!jvmti_can_access_local_variables() &amp;&amp;
        JvmtiExport::can_access_local_variables()) {
      return true;
    }
    if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,534 ***</span>
      return true;
    }
    return false;
  }
  
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! // Note: the logic of this method should mirror the logic of</span>
<span class="line-modified">! // constantPoolOopDesc::verify_constant_pool_resolve.</span>
<span class="line-modified">! bool JVMCIEnv::check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass) {</span>
<span class="line-modified">!   if (accessing_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified">!     accessing_klass = ObjArrayKlass::cast(accessing_klass)-&gt;bottom_klass();</span>
    }
<span class="line-modified">!   if (!accessing_klass-&gt;is_instance_klass()) {</span>
<span class="line-modified">!     return true;</span>
    }
  
<span class="line-modified">!   if (resolved_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified">!     // Find the element klass, if this is an array.</span>
<span class="line-modified">!     resolved_klass = ObjArrayKlass::cast(resolved_klass)-&gt;bottom_klass();</span>
    }
<span class="line-modified">!   if (resolved_klass-&gt;is_instance_klass()) {</span>
<span class="line-modified">!     Reflection::VerifyClassAccessResults result =</span>
<span class="line-modified">!       Reflection::verify_class_access(accessing_klass, InstanceKlass::cast(resolved_klass), true);</span>
<span class="line-modified">!     return result == Reflection::ACCESS_OK;</span>
    }
<span class="line-removed">-   return true;</span>
  }
  
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! Klass* JVMCIEnv::get_klass_by_name_impl(Klass* accessing_klass,</span>
<span class="line-modified">!                                         const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">!                                         Symbol* sym,</span>
<span class="line-modified">!                                         bool require_local) {</span>
<span class="line-modified">!   JVMCI_EXCEPTION_CONTEXT;</span>
  
<span class="line-modified">!   // Now we need to check the SystemDictionary</span>
<span class="line-modified">!   if (sym-&gt;char_at(0) == &#39;L&#39; &amp;&amp;</span>
<span class="line-modified">!     sym-&gt;char_at(sym-&gt;utf8_length()-1) == &#39;;&#39;) {</span>
<span class="line-modified">!     // This is a name from a signature.  Strip off the trimmings.</span>
<span class="line-modified">!     // Call recursive to keep scope of strippedsym.</span>
<span class="line-modified">!     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,</span>
<span class="line-modified">!                     sym-&gt;utf8_length()-2,</span>
<span class="line-modified">!                     CHECK_NULL);</span>
<span class="line-modified">!     return get_klass_by_name_impl(accessing_klass, cpool, strippedsym, require_local);</span>
    }
  
<span class="line-modified">!   Handle loader(THREAD, (oop)NULL);</span>
<span class="line-modified">!   Handle domain(THREAD, (oop)NULL);</span>
<span class="line-modified">!   if (accessing_klass != NULL) {</span>
<span class="line-modified">!     loader = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-modified">!     domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>
    }
  
<span class="line-modified">!   Klass* found_klass = NULL;</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems</span>
<span class="line-modified">!     MutexLocker ml(Compile_lock);</span>
<span class="line-modified">!     if (!require_local) {</span>
<span class="line-modified">!       found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, CHECK_NULL);</span>
      } else {
<span class="line-modified">!       found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain, CHECK_NULL);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // If we fail to find an array klass, look again for its element type.</span>
<span class="line-modified">!   // The element type may be available either locally or via constraints.</span>
<span class="line-modified">!   // In either case, if we can find the element type in the system dictionary,</span>
<span class="line-removed">-   // we must build an array type around it.  The CI requires array klasses</span>
<span class="line-removed">-   // to be loaded if their element klasses are loaded, except when memory</span>
<span class="line-removed">-   // is exhausted.</span>
<span class="line-removed">-   if (sym-&gt;char_at(0) == &#39;[&#39; &amp;&amp;</span>
<span class="line-removed">-       (sym-&gt;char_at(1) == &#39;[&#39; || sym-&gt;char_at(1) == &#39;L&#39;)) {</span>
<span class="line-removed">-     // We have an unloaded array.</span>
<span class="line-removed">-     // Build it on the fly if the element class exists.</span>
<span class="line-removed">-     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,</span>
<span class="line-removed">-                                                  sym-&gt;utf8_length()-1,</span>
<span class="line-removed">-                                                  CHECK_NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Get element Klass recursively.</span>
<span class="line-removed">-     Klass* elem_klass =</span>
<span class="line-removed">-       get_klass_by_name_impl(accessing_klass,</span>
<span class="line-removed">-                              cpool,</span>
<span class="line-removed">-                              elem_sym,</span>
<span class="line-removed">-                              require_local);</span>
<span class="line-removed">-     if (elem_klass != NULL) {</span>
<span class="line-removed">-       // Now make an array for it</span>
<span class="line-removed">-       return elem_klass-&gt;array_klass(THREAD);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {</span>
<span class="line-removed">-     // Look inside the constant pool for pre-resolved class entries.</span>
<span class="line-removed">-     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {</span>
<span class="line-removed">-       if (cpool-&gt;tag_at(i).is_klass()) {</span>
<span class="line-removed">-         Klass*  kls = cpool-&gt;resolved_klass_at(i);</span>
<span class="line-removed">-         if (kls-&gt;name() == sym) {</span>
<span class="line-removed">-           return kls;</span>
<span class="line-removed">-         }</span>
        }
      }
    }
  
<span class="line-modified">!   return found_klass;</span>
  }
  
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! Klass* JVMCIEnv::get_klass_by_name(Klass* accessing_klass,</span>
<span class="line-modified">!                                   Symbol* klass_name,</span>
<span class="line-modified">!                                   bool require_local) {</span>
    ResourceMark rm;
<span class="line-modified">!   constantPoolHandle cpool;</span>
<span class="line-modified">!   return get_klass_by_name_impl(accessing_klass,</span>
<span class="line-modified">!                                 cpool,</span>
<span class="line-modified">!                                 klass_name,</span>
<span class="line-modified">!                                 require_local);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! // Implementation of get_klass_by_index.</span>
<span class="line-modified">! Klass* JVMCIEnv::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">!                                         int index,</span>
<span class="line-modified">!                                         bool&amp; is_accessible,</span>
<span class="line-modified">!                                         Klass* accessor) {</span>
<span class="line-modified">!   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-removed">-   Klass* klass = ConstantPool::klass_at_if_loaded(cpool, index);</span>
<span class="line-removed">-   Symbol* klass_name = NULL;</span>
<span class="line-removed">-   if (klass == NULL) {</span>
<span class="line-removed">-     klass_name = cpool-&gt;klass_name_at(index);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (klass == NULL) {</span>
<span class="line-removed">-     // Not found in constant pool.  Use the name to do the lookup.</span>
<span class="line-removed">-     Klass* k = get_klass_by_name_impl(accessor,</span>
<span class="line-removed">-                                       cpool,</span>
<span class="line-removed">-                                       klass_name,</span>
<span class="line-removed">-                                       false);</span>
<span class="line-removed">-     // Calculate accessibility the hard way.</span>
<span class="line-removed">-     if (k == NULL) {</span>
<span class="line-removed">-       is_accessible = false;</span>
<span class="line-removed">-     } else if (k-&gt;class_loader() != accessor-&gt;class_loader() &amp;&amp;</span>
<span class="line-removed">-                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {</span>
<span class="line-removed">-       // Loaded only remotely.  Not linked yet.</span>
<span class="line-removed">-       is_accessible = false;</span>
      } else {
<span class="line-modified">!       // Linked locally, and we must also check public/private, etc.</span>
<span class="line-modified">!       is_accessible = check_klass_accessibility(accessor, k);</span>
      }
<span class="line-modified">!     if (!is_accessible) {</span>
<span class="line-modified">!       return NULL;</span>
      }
<span class="line-removed">-     return k;</span>
    }
  
<span class="line-modified">!   // It is known to be accessible, since it was found in the constant pool.</span>
<span class="line-modified">!   is_accessible = true;</span>
<span class="line-modified">!   return klass;</span>
  }
  
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! // Get a klass from the constant pool.</span>
<span class="line-modified">! Klass* JVMCIEnv::get_klass_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">!                                     int index,</span>
<span class="line-modified">!                                     bool&amp; is_accessible,</span>
<span class="line-modified">!                                     Klass* accessor) {</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   return get_klass_by_index_impl(cpool, index, is_accessible, accessor);</span>
  }
  
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! // Implementation of get_field_by_index.</span>
<span class="line-modified">! //</span>
<span class="line-modified">! // Implementation note: the results of field lookups are cached</span>
<span class="line-modified">! // in the accessor klass.</span>
<span class="line-modified">! void JVMCIEnv::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor&amp; field_desc,</span>
<span class="line-modified">!                                         int index) {</span>
<span class="line-modified">!   JVMCI_EXCEPTION_CONTEXT;</span>
  
<span class="line-modified">!   assert(klass-&gt;is_linked(), &quot;must be linked before using its constant-pool&quot;);</span>
  
<span class="line-modified">!   constantPoolHandle cpool(thread, klass-&gt;constants());</span>
  
<span class="line-modified">!   // Get the field&#39;s name, signature, and type.</span>
<span class="line-modified">!   Symbol* name  = cpool-&gt;name_ref_at(index);</span>
  
<span class="line-modified">!   int nt_index = cpool-&gt;name_and_type_ref_index_at(index);</span>
<span class="line-modified">!   int sig_index = cpool-&gt;signature_ref_index_at(nt_index);</span>
<span class="line-modified">!   Symbol* signature = cpool-&gt;symbol_at(sig_index);</span>
  
<span class="line-modified">!   // Get the field&#39;s declared holder.</span>
<span class="line-modified">!   int holder_index = cpool-&gt;klass_ref_index_at(index);</span>
<span class="line-modified">!   bool holder_is_accessible;</span>
<span class="line-modified">!   Klass* declared_holder = get_klass_by_index(cpool, holder_index,</span>
<span class="line-modified">!                                               holder_is_accessible,</span>
<span class="line-modified">!                                               klass);</span>
  
<span class="line-modified">!   // The declared holder of this field may not have been loaded.</span>
<span class="line-modified">!   // Bail out with partial field information.</span>
<span class="line-modified">!   if (!holder_is_accessible) {</span>
<span class="line-modified">!     return;</span>
    }
  
  
<span class="line-modified">!   // Perform the field lookup.</span>
<span class="line-modified">!   Klass*  canonical_holder =</span>
<span class="line-removed">-     InstanceKlass::cast(declared_holder)-&gt;find_field(name, signature, &amp;field_desc);</span>
<span class="line-removed">-   if (canonical_holder == NULL) {</span>
      return;
    }
  
<span class="line-modified">!   assert(canonical_holder == field_desc.field_holder(), &quot;just checking&quot;);</span>
  }
  
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! // Get a field by index from a klass&#39;s constant pool.</span>
<span class="line-modified">! void JVMCIEnv::get_field_by_index(InstanceKlass* accessor, fieldDescriptor&amp; fd, int index) {</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   return get_field_by_index_impl(accessor, fd, index);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! // Perform an appropriate method lookup based on accessor, holder,</span>
<span class="line-modified">! // name, signature, and bytecode.</span>
<span class="line-modified">! methodHandle JVMCIEnv::lookup_method(InstanceKlass* accessor,</span>
<span class="line-modified">!                                Klass*         holder,</span>
<span class="line-modified">!                                Symbol*        name,</span>
<span class="line-modified">!                                Symbol*        sig,</span>
<span class="line-modified">!                                Bytecodes::Code bc,</span>
<span class="line-modified">!                                constantTag   tag) {</span>
<span class="line-modified">!   // Accessibility checks are performed in JVMCIEnv::get_method_by_index_impl().</span>
<span class="line-modified">!   assert(check_klass_accessibility(accessor, holder), &quot;holder not accessible&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   methodHandle dest_method;</span>
<span class="line-modified">!   LinkInfo link_info(holder, name, sig, accessor, LinkInfo::needs_access_check, tag);</span>
<span class="line-modified">!   switch (bc) {</span>
<span class="line-removed">-   case Bytecodes::_invokestatic:</span>
<span class="line-removed">-     dest_method =</span>
<span class="line-removed">-       LinkResolver::resolve_static_call_or_null(link_info);</span>
<span class="line-removed">-     break;</span>
<span class="line-removed">-   case Bytecodes::_invokespecial:</span>
<span class="line-removed">-     dest_method =</span>
<span class="line-removed">-       LinkResolver::resolve_special_call_or_null(link_info);</span>
<span class="line-removed">-     break;</span>
<span class="line-removed">-   case Bytecodes::_invokeinterface:</span>
<span class="line-removed">-     dest_method =</span>
<span class="line-removed">-       LinkResolver::linktime_resolve_interface_method_or_null(link_info);</span>
<span class="line-removed">-     break;</span>
<span class="line-removed">-   case Bytecodes::_invokevirtual:</span>
<span class="line-removed">-     dest_method =</span>
<span class="line-removed">-       LinkResolver::linktime_resolve_virtual_method_or_null(link_info);</span>
<span class="line-removed">-     break;</span>
<span class="line-removed">-   default: ShouldNotReachHere();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return dest_method;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- // ------------------------------------------------------------------</span>
<span class="line-removed">- methodHandle JVMCIEnv::get_method_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-removed">-                                           int index, Bytecodes::Code bc,</span>
<span class="line-removed">-                                           InstanceKlass* accessor) {</span>
<span class="line-removed">-   if (bc == Bytecodes::_invokedynamic) {</span>
<span class="line-removed">-     ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);</span>
<span class="line-removed">-     bool is_resolved = !cpce-&gt;is_f1_null();</span>
<span class="line-removed">-     if (is_resolved) {</span>
<span class="line-removed">-       // Get the invoker Method* from the constant pool.</span>
<span class="line-removed">-       // (The appendix argument, if any, will be noted in the method&#39;s signature.)</span>
<span class="line-removed">-       Method* adapter = cpce-&gt;f1_as_method();</span>
<span class="line-removed">-       return methodHandle(adapter);</span>
      }
  
<span class="line-modified">!     return NULL;</span>
    }
  
<span class="line-modified">!   int holder_index = cpool-&gt;klass_ref_index_at(index);</span>
<span class="line-modified">!   bool holder_is_accessible;</span>
<span class="line-modified">!   Klass* holder = get_klass_by_index_impl(cpool, holder_index, holder_is_accessible, accessor);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Get the method&#39;s name and signature.</span>
<span class="line-modified">!   Symbol* name_sym = cpool-&gt;name_ref_at(index);</span>
<span class="line-modified">!   Symbol* sig_sym  = cpool-&gt;signature_ref_at(index);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (cpool-&gt;has_preresolution()</span>
<span class="line-modified">!       || ((holder == SystemDictionary::MethodHandle_klass() || holder == SystemDictionary::VarHandle_klass()) &amp;&amp;</span>
<span class="line-modified">!           MethodHandles::is_signature_polymorphic_name(holder, name_sym))) {</span>
<span class="line-removed">-     // Short-circuit lookups for JSR 292-related call sites.</span>
<span class="line-removed">-     // That is, do not rely only on name-based lookups, because they may fail</span>
<span class="line-removed">-     // if the names are not resolvable in the boot class loader (7056328).</span>
<span class="line-removed">-     switch (bc) {</span>
<span class="line-removed">-     case Bytecodes::_invokevirtual:</span>
<span class="line-removed">-     case Bytecodes::_invokeinterface:</span>
<span class="line-removed">-     case Bytecodes::_invokespecial:</span>
<span class="line-removed">-     case Bytecodes::_invokestatic:</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         Method* m = ConstantPool::method_at_if_loaded(cpool, index);</span>
<span class="line-removed">-         if (m != NULL) {</span>
<span class="line-removed">-           return m;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
        break;
      default:
<span class="line-modified">!       break;</span>
      }
    }
  
<span class="line-modified">!   if (holder_is_accessible) { // Our declared holder is loaded.</span>
<span class="line-modified">!     constantTag tag = cpool-&gt;tag_ref_at(index);</span>
<span class="line-modified">!     methodHandle m = lookup_method(accessor, holder, name_sym, sig_sym, bc, tag);</span>
<span class="line-modified">!     if (!m.is_null()) {</span>
<span class="line-modified">!       // We found the method.</span>
<span class="line-modified">!       return m;</span>
      }
    }
  
<span class="line-modified">!   // Either the declared holder was not loaded, or the method could</span>
<span class="line-modified">!   // not be found.</span>
  
<span class="line-modified">!   return NULL;</span>
  }
  
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! InstanceKlass* JVMCIEnv::get_instance_klass_for_declared_method_holder(Klass* method_holder) {</span>
<span class="line-modified">!   // For the case of &lt;array&gt;.clone(), the method holder can be an ArrayKlass*</span>
<span class="line-modified">!   // instead of an InstanceKlass*.  For that case simply pretend that the</span>
<span class="line-modified">!   // declared holder is Object.clone since that&#39;s where the call will bottom out.</span>
<span class="line-modified">!   if (method_holder-&gt;is_instance_klass()) {</span>
<span class="line-modified">!     return InstanceKlass::cast(method_holder);</span>
<span class="line-modified">!   } else if (method_holder-&gt;is_array_klass()) {</span>
<span class="line-removed">-     return SystemDictionary::Object_klass();</span>
    } else {
<span class="line-modified">!     ShouldNotReachHere();</span>
    }
<span class="line-removed">-   return NULL;</span>
  }
  
  
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! methodHandle JVMCIEnv::get_method_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">!                                      int index, Bytecodes::Code bc,</span>
<span class="line-modified">!                                      InstanceKlass* accessor) {</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   return get_method_by_index_impl(cpool, index, bc, accessor);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! // Check for changes to the system dictionary during compilation</span>
<span class="line-modified">! // class loads, evolution, breakpoints</span>
<span class="line-modified">! JVMCIEnv::CodeInstallResult JVMCIEnv::validate_compile_task_dependencies(Dependencies* dependencies, Handle compiled_code,</span>
<span class="line-removed">-                                                                          JVMCIEnv* env, char** failure_detail) {</span>
<span class="line-removed">-   // If JVMTI capabilities were enabled during compile, the compilation is invalidated.</span>
<span class="line-removed">-   if (env != NULL &amp;&amp; env-&gt;jvmti_state_changed()) {</span>
<span class="line-removed">-     *failure_detail = (char*) &quot;Jvmti state change during compilation invalidated dependencies&quot;;</span>
<span class="line-removed">-     return JVMCIEnv::dependencies_failed;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Dependencies must be checked when the system dictionary changes</span>
<span class="line-removed">-   // or if we don&#39;t know whether it has changed (i.e., env == NULL).</span>
<span class="line-removed">-   bool counter_changed = env == NULL || env-&gt;_system_dictionary_modification_counter != SystemDictionary::number_of_modifications();</span>
<span class="line-removed">-   CompileTask* task = env == NULL ? NULL : env-&gt;task();</span>
<span class="line-removed">-   Dependencies::DepType result = dependencies-&gt;validate_dependencies(task, counter_changed, failure_detail);</span>
<span class="line-removed">-   if (result == Dependencies::end_marker) {</span>
<span class="line-removed">-     return JVMCIEnv::ok;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!Dependencies::is_klass_type(result) || counter_changed) {</span>
<span class="line-removed">-     return JVMCIEnv::dependencies_failed;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // The dependencies were invalid at the time of installation</span>
<span class="line-removed">-   // without any intervening modification of the system</span>
<span class="line-removed">-   // dictionary.  That means they were invalidly constructed.</span>
<span class="line-removed">-   return JVMCIEnv::dependencies_invalid;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // ------------------------------------------------------------------</span>
<span class="line-removed">- JVMCIEnv::CodeInstallResult JVMCIEnv::register_method(</span>
<span class="line-removed">-                                 const methodHandle&amp; method,</span>
<span class="line-removed">-                                 nmethod*&amp; nm,</span>
<span class="line-removed">-                                 int entry_bci,</span>
<span class="line-removed">-                                 CodeOffsets* offsets,</span>
<span class="line-removed">-                                 int orig_pc_offset,</span>
<span class="line-removed">-                                 CodeBuffer* code_buffer,</span>
<span class="line-removed">-                                 int frame_words,</span>
<span class="line-removed">-                                 OopMapSet* oop_map_set,</span>
<span class="line-removed">-                                 ExceptionHandlerTable* handler_table,</span>
<span class="line-removed">-                                 AbstractCompiler* compiler,</span>
<span class="line-removed">-                                 DebugInformationRecorder* debug_info,</span>
<span class="line-removed">-                                 Dependencies* dependencies,</span>
<span class="line-removed">-                                 JVMCIEnv* env,</span>
<span class="line-removed">-                                 int compile_id,</span>
<span class="line-removed">-                                 bool has_unsafe_access,</span>
<span class="line-removed">-                                 bool has_wide_vector,</span>
<span class="line-removed">-                                 Handle installed_code,</span>
<span class="line-removed">-                                 Handle compiled_code,</span>
<span class="line-removed">-                                 Handle speculation_log) {</span>
<span class="line-removed">-   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-removed">-   nm = NULL;</span>
<span class="line-removed">-   int comp_level = CompLevel_full_optimization;</span>
<span class="line-removed">-   char* failure_detail = NULL;</span>
<span class="line-removed">-   JVMCIEnv::CodeInstallResult result;</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     // To prevent compile queue updates.</span>
<span class="line-removed">-     MutexLocker locker(MethodCompileQueue_lock, THREAD);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Prevent SystemDictionary::add_to_hierarchy from running</span>
<span class="line-removed">-     // and invalidating our dependencies until we install this method.</span>
<span class="line-removed">-     MutexLocker ml(Compile_lock);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Encode the dependencies now, so we can check them right away.</span>
<span class="line-removed">-     dependencies-&gt;encode_content_bytes();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Record the dependencies for the current compile in the log</span>
<span class="line-removed">-     if (LogCompilation) {</span>
<span class="line-removed">-       for (Dependencies::DepStream deps(dependencies); deps.next(); ) {</span>
<span class="line-removed">-         deps.log_dependency();</span>
<span class="line-removed">-       }</span>
      }
  
<span class="line-modified">!     // Check for {class loads, evolution, breakpoints} during compilation</span>
<span class="line-modified">!     result = validate_compile_task_dependencies(dependencies, compiled_code, env, &amp;failure_detail);</span>
<span class="line-modified">!     if (result != JVMCIEnv::ok) {</span>
<span class="line-modified">!       // While not a true deoptimization, it is a preemptive decompile.</span>
<span class="line-modified">!       MethodData* mdp = method()-&gt;method_data();</span>
<span class="line-modified">!       if (mdp != NULL) {</span>
<span class="line-modified">!         mdp-&gt;inc_decompile_count();</span>
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-modified">!         if (mdp-&gt;decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {</span>
<span class="line-modified">!           ResourceMark m;</span>
<span class="line-modified">!           tty-&gt;print_cr(&quot;WARN: endless recompilation of %s. Method was set to not compilable.&quot;, method()-&gt;name_and_sig_as_C_string());</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! #endif</span>
        }
  
<span class="line-modified">!       // All buffers in the CodeBuffer are allocated in the CodeCache.</span>
<span class="line-modified">!       // If the code buffer is created on each compile attempt</span>
<span class="line-modified">!       // as in C2, then it must be freed.</span>
<span class="line-modified">!       //code_buffer-&gt;free_blob();</span>
      } else {
<span class="line-modified">!       ImplicitExceptionTable implicit_tbl;</span>
<span class="line-modified">!       nm =  nmethod::new_nmethod(method,</span>
<span class="line-modified">!                                  compile_id,</span>
<span class="line-modified">!                                  entry_bci,</span>
<span class="line-modified">!                                  offsets,</span>
<span class="line-modified">!                                  orig_pc_offset,</span>
<span class="line-modified">!                                  debug_info, dependencies, code_buffer,</span>
<span class="line-modified">!                                  frame_words, oop_map_set,</span>
<span class="line-modified">!                                  handler_table, &amp;implicit_tbl,</span>
<span class="line-modified">!                                  compiler, comp_level,</span>
<span class="line-modified">!                                  JNIHandles::make_weak_global(installed_code),</span>
<span class="line-modified">!                                  JNIHandles::make_weak_global(speculation_log));</span>
<span class="line-modified">! </span>
<span class="line-modified">!       // Free codeBlobs</span>
<span class="line-modified">!       //code_buffer-&gt;free_blob();</span>
<span class="line-modified">!       if (nm == NULL) {</span>
<span class="line-modified">!         // The CodeCache is full.  Print out warning and disable compilation.</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           MutexUnlocker ml(Compile_lock);</span>
<span class="line-modified">!           MutexUnlocker locker(MethodCompileQueue_lock);</span>
<span class="line-modified">!           CompileBroker::handle_full_code_cache(CodeCache::get_code_blob_type(comp_level));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         nm-&gt;set_has_unsafe_access(has_unsafe_access);</span>
<span class="line-modified">!         nm-&gt;set_has_wide_vectors(has_wide_vector);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Record successful registration.</span>
<span class="line-modified">!         // (Put nm into the task handle *before* publishing to the Java heap.)</span>
<span class="line-modified">!         CompileTask* task = env == NULL ? NULL : env-&gt;task();</span>
<span class="line-modified">!         if (task != NULL) {</span>
<span class="line-modified">!           task-&gt;set_code(nm);</span>
          }
  
<span class="line-modified">!         if (installed_code-&gt;is_a(HotSpotNmethod::klass()) &amp;&amp; HotSpotNmethod::isDefault(installed_code())) {</span>
<span class="line-modified">!           if (entry_bci == InvocationEntryBci) {</span>
<span class="line-modified">!             if (TieredCompilation) {</span>
<span class="line-modified">!               // If there is an old version we&#39;re done with it</span>
<span class="line-modified">!               CompiledMethod* old = method-&gt;code();</span>
<span class="line-modified">!               if (TraceMethodReplacement &amp;&amp; old != NULL) {</span>
<span class="line-modified">!                 ResourceMark rm;</span>
<span class="line-modified">!                 char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-modified">!                 tty-&gt;print_cr(&quot;Replacing method %s&quot;, method_name);</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-               if (old != NULL ) {</span>
<span class="line-removed">-                 old-&gt;make_not_entrant();</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (TraceNMethodInstalls) {</span>
<span class="line-removed">-               ResourceMark rm;</span>
<span class="line-removed">-               char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-removed">-               ttyLocker ttyl;</span>
<span class="line-removed">-               tty-&gt;print_cr(&quot;Installing method (%d) %s [entry point: %p]&quot;,</span>
<span class="line-removed">-                             comp_level,</span>
<span class="line-removed">-                             method_name, nm-&gt;entry_point());</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             // Allow the code to be executed</span>
<span class="line-removed">-             method-&gt;set_code(method, nm);</span>
<span class="line-removed">-           } else {</span>
<span class="line-removed">-             if (TraceNMethodInstalls ) {</span>
<span class="line-removed">-               ResourceMark rm;</span>
<span class="line-removed">-               char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-removed">-               ttyLocker ttyl;</span>
<span class="line-removed">-               tty-&gt;print_cr(&quot;Installing osr method (%d) %s @ %d&quot;,</span>
<span class="line-removed">-                             comp_level,</span>
<span class="line-removed">-                             method_name,</span>
<span class="line-removed">-                             entry_bci);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             InstanceKlass::cast(method-&gt;method_holder())-&gt;add_osr_nmethod(nm);</span>
<span class="line-removed">-           }</span>
          }
<span class="line-modified">!         nm-&gt;make_in_use();</span>
        }
<span class="line-modified">!       result = nm != NULL ? JVMCIEnv::ok :JVMCIEnv::cache_full;</span>
      }
    }
  
<span class="line-modified">!   // String creation must be done outside lock</span>
<span class="line-modified">!   if (failure_detail != NULL) {</span>
<span class="line-modified">!     // A failure to allocate the string is silently ignored.</span>
<span class="line-modified">!     Handle message = java_lang_String::create_from_str(failure_detail, THREAD);</span>
<span class="line-modified">!     HotSpotCompiledNmethod::set_installationFailureMessage(compiled_code, message());</span>
    }
  
<span class="line-modified">!   // JVMTI -- compiled method notification (must be done outside lock)</span>
<span class="line-modified">!   if (nm != NULL) {</span>
<span class="line-removed">-     nm-&gt;post_compiled_method_load_event();</span>
  
<span class="line-modified">!     if (env == NULL) {</span>
<span class="line-modified">!       // This compile didn&#39;t come through the CompileBroker so perform the printing here</span>
<span class="line-modified">!       DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);</span>
<span class="line-modified">!       nm-&gt;maybe_print_nmethod(directive);</span>
<span class="line-modified">!       DirectivesStack::release(directive);</span>
<span class="line-modified">!     }</span>
    }
  
<span class="line-modified">!   return result;</span>
<span class="line-modified">! }</span>
<span class="line-new-header">--- 73,1657 ---</span>
      return true;
    }
    return false;
  }
  
<span class="line-modified">! JavaVM* JVMCIEnv::_shared_library_javavm = NULL;</span>
<span class="line-modified">! void* JVMCIEnv::_shared_library_handle = NULL;</span>
<span class="line-modified">! char* JVMCIEnv::_shared_library_path = NULL;</span>
<span class="line-modified">! </span>
<span class="line-modified">! void JVMCIEnv::copy_saved_properties() {</span>
<span class="line-modified">!   assert(!is_hotspot(), &quot;can only copy saved properties from HotSpot to native image&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+ </span>
<span class="line-added">+   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);</span>
<span class="line-added">+   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+     JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error initializing jdk.vm.ci.services.Services&quot;);</span>
    }
<span class="line-modified">!   InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-modified">!   if (ik-&gt;should_be_initialized()) {</span>
<span class="line-added">+     ik-&gt;initialize(THREAD);</span>
<span class="line-added">+     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+       JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error initializing jdk.vm.ci.services.Services&quot;);</span>
<span class="line-added">+     }</span>
    }
  
<span class="line-modified">!   // Get the serialized saved properties from HotSpot</span>
<span class="line-modified">!   TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol(&quot;serializeSavedProperties&quot;);</span>
<span class="line-modified">!   JavaValue result(T_OBJECT);</span>
<span class="line-added">+   JavaCallArguments args;</span>
<span class="line-added">+   JavaCalls::call_static(&amp;result, ik, serializeSavedProperties, vmSymbols::serializePropertiesToByteArray_signature(), &amp;args, THREAD);</span>
<span class="line-added">+   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+     JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error calling jdk.vm.ci.services.Services.serializeSavedProperties&quot;);</span>
    }
<span class="line-modified">!   oop res = (oop) result.get_jobject();</span>
<span class="line-modified">!   assert(res-&gt;is_typeArray(), &quot;must be&quot;);</span>
<span class="line-modified">!   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, &quot;must be&quot;);</span>
<span class="line-modified">!   typeArrayOop ba = typeArrayOop(res);</span>
<span class="line-added">+   int serialized_properties_len = ba-&gt;length();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Copy serialized saved properties from HotSpot object into native buffer</span>
<span class="line-added">+   jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);</span>
<span class="line-added">+   memcpy(serialized_properties, ba-&gt;byte_at_addr(0), serialized_properties_len);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Copy native buffer into shared library object</span>
<span class="line-added">+   JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);</span>
<span class="line-added">+   if (has_pending_exception()) {</span>
<span class="line-added">+     describe_pending_exception(true);</span>
<span class="line-added">+     fatal(&quot;Error in copy_saved_properties&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);</span>
<span class="line-added">+   if (has_pending_exception()) {</span>
<span class="line-added">+     describe_pending_exception(true);</span>
<span class="line-added">+     fatal(&quot;Error in copy_saved_properties&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Initialize saved properties in shared library</span>
<span class="line-added">+   jclass servicesClass = JNIJVMCI::Services::clazz();</span>
<span class="line-added">+   jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();</span>
<span class="line-added">+   JNIAccessMark jni(this);</span>
<span class="line-added">+   jni()-&gt;CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());</span>
<span class="line-added">+   if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+     jni()-&gt;ExceptionDescribe();</span>
<span class="line-added">+     fatal(&quot;Error calling jdk.vm.ci.services.Services.initializeSavedProperties&quot;);</span>
    }
  }
  
<span class="line-modified">! JNIEnv* JVMCIEnv::init_shared_library(JavaThread* thread) {</span>
<span class="line-modified">!   if (_shared_library_javavm == NULL) {</span>
<span class="line-modified">!     MutexLocker locker(JVMCI_lock);</span>
<span class="line-modified">!     if (_shared_library_javavm == NULL) {</span>
<span class="line-modified">!       char path[JVM_MAXPATHLEN];</span>
<span class="line-modified">!       char ebuf[1024];</span>
<span class="line-added">+       if (JVMCILibPath != NULL) {</span>
<span class="line-added">+         if (!os::dll_locate_lib(path, sizeof(path), JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {</span>
<span class="line-added">+           vm_exit_during_initialization(&quot;Unable to create JVMCI shared library path from -XX:JVMCILibPath value&quot;, JVMCILibPath);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         if (!os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {</span>
<span class="line-added">+           vm_exit_during_initialization(&quot;Unable to create path to JVMCI shared library&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       void* handle = os::dll_load(path, ebuf, sizeof ebuf);</span>
<span class="line-added">+       if (handle == NULL) {</span>
<span class="line-added">+         vm_exit_during_initialization(&quot;Unable to load JVMCI shared library&quot;, ebuf);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       _shared_library_handle = handle;</span>
<span class="line-added">+       _shared_library_path = strdup(path);</span>
<span class="line-added">+       jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);</span>
<span class="line-added">+       typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);</span>
<span class="line-added">+ </span>
<span class="line-added">+       JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(handle, &quot;JNI_CreateJavaVM&quot;));</span>
<span class="line-added">+       JNIEnv* env;</span>
<span class="line-added">+       if (JNI_CreateJavaVM == NULL) {</span>
<span class="line-added">+         vm_exit_during_initialization(&quot;Unable to find JNI_CreateJavaVM&quot;, path);</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       ResourceMark rm;</span>
<span class="line-added">+       JavaVMInitArgs vm_args;</span>
<span class="line-added">+       vm_args.version = JNI_VERSION_1_2;</span>
<span class="line-added">+       vm_args.ignoreUnrecognized = JNI_TRUE;</span>
<span class="line-added">+       vm_args.options = NULL;</span>
<span class="line-added">+       vm_args.nOptions = 0;</span>
  
<span class="line-modified">!       JavaVM* the_javavm = NULL;</span>
<span class="line-modified">!       int result = (*JNI_CreateJavaVM)(&amp;the_javavm, (void**) &amp;env, &amp;vm_args);</span>
<span class="line-modified">!       if (result == JNI_OK) {</span>
<span class="line-modified">!         guarantee(env != NULL, &quot;missing env&quot;);</span>
<span class="line-modified">!         _shared_library_javavm = the_javavm;</span>
<span class="line-modified">!         return env;</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         vm_exit_during_initialization(err_msg(&quot;JNI_CreateJavaVM failed with return value %d&quot;, result), path);</span>
<span class="line-modified">!       }</span>
<span class="line-added">+     }</span>
    }
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {</span>
<span class="line-modified">!   assert(thread != NULL, &quot;npe&quot;);</span>
<span class="line-modified">!   // By default there is only one runtime which is the compiler runtime.</span>
<span class="line-modified">!   _runtime = JVMCI::compiler_runtime();</span>
<span class="line-modified">!   _env = NULL;</span>
<span class="line-added">+   _pop_frame_on_close = false;</span>
<span class="line-added">+   _detach_on_close = false;</span>
<span class="line-added">+   if (!UseJVMCINativeLibrary) {</span>
<span class="line-added">+     // In HotSpot mode, JNI isn&#39;t used at all.</span>
<span class="line-added">+     _is_hotspot = true;</span>
<span class="line-added">+     return;</span>
    }
  
<span class="line-modified">!   if (parent_env != NULL) {</span>
<span class="line-modified">!     // If the parent JNI environment is non-null then figure out whether it</span>
<span class="line-modified">!     // is a HotSpot or shared library JNIEnv and set the state appropriately.</span>
<span class="line-modified">!     _is_hotspot = thread-&gt;jni_environment() == parent_env;</span>
<span class="line-modified">!     if (_is_hotspot) {</span>
<span class="line-modified">!       // Select the Java runtime</span>
<span class="line-added">+       _runtime = JVMCI::java_runtime();</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     _env = parent_env;</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Running in JVMCI shared library mode so ensure the shared library</span>
<span class="line-added">+   // is loaded and initialized and get a shared library JNIEnv</span>
<span class="line-added">+   _is_hotspot = false;</span>
<span class="line-added">+   _env = init_shared_library(thread);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (_env != NULL) {</span>
<span class="line-added">+     // Creating the JVMCI shared library VM also attaches the current thread</span>
<span class="line-added">+     _detach_on_close = true;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     _shared_library_javavm-&gt;GetEnv((void**)&amp;parent_env, JNI_VERSION_1_2);</span>
<span class="line-added">+     if (parent_env != NULL) {</span>
<span class="line-added">+       // Even though there&#39;s a parent JNI env, there&#39;s no guarantee</span>
<span class="line-added">+       // it was opened by a JVMCIEnv scope and thus may not have</span>
<span class="line-added">+       // pushed a local JNI frame. As such, we use a new JNI local</span>
<span class="line-added">+       // frame in this scope to ensure local JNI refs are collected</span>
<span class="line-added">+       // in a timely manner after leaving this scope.</span>
<span class="line-added">+       _env = parent_env;</span>
      } else {
<span class="line-modified">!       ResourceMark rm; // Thread name is resource allocated</span>
<span class="line-modified">!       JavaVMAttachArgs attach_args;</span>
<span class="line-modified">!       attach_args.version = JNI_VERSION_1_2;</span>
<span class="line-modified">!       attach_args.name = thread-&gt;name();</span>
<span class="line-modified">!       attach_args.group = NULL;</span>
<span class="line-modified">!       if (_shared_library_javavm-&gt;AttachCurrentThread((void**)&amp;_env, &amp;attach_args) != JNI_OK) {</span>
<span class="line-modified">!         fatal(&quot;Error attaching current thread (%s) to JVMCI shared library JNI interface&quot;, attach_args.name);</span>
        }
<span class="line-added">+       _detach_on_close = true;</span>
      }
    }
  
<span class="line-modified">!   assert(_env != NULL, &quot;missing env&quot;);</span>
<span class="line-added">+   assert(_throw_to_caller == false, &quot;must be&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JNIAccessMark jni(this);</span>
<span class="line-added">+   jint result = _env-&gt;PushLocalFrame(32);</span>
<span class="line-added">+   if (result != JNI_OK) {</span>
<span class="line-added">+     char message[256];</span>
<span class="line-added">+     jio_snprintf(message, 256, &quot;Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d&quot;, _file, _line);</span>
<span class="line-added">+     JVMCIRuntime::exit_on_pending_exception(this, message);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _pop_frame_on_close = true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIEnv::JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line):</span>
<span class="line-added">+     _throw_to_caller(false), _file(file), _line(line), _compile_state(compile_state) {</span>
<span class="line-added">+   init_env_mode_runtime(thread, NULL);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIEnv::JVMCIEnv(JavaThread* thread, const char* file, int line):</span>
<span class="line-added">+     _throw_to_caller(false), _file(file), _line(line), _compile_state(NULL) {</span>
<span class="line-added">+   init_env_mode_runtime(thread, NULL);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIEnv::JVMCIEnv(JavaThread* thread, JNIEnv* parent_env, const char* file, int line):</span>
<span class="line-added">+     _throw_to_caller(true), _file(file), _line(line), _compile_state(NULL) {</span>
<span class="line-added">+   init_env_mode_runtime(thread, parent_env);</span>
<span class="line-added">+   assert(_env == NULL || parent_env == _env, &quot;mismatched JNIEnvironment&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {</span>
<span class="line-added">+   _compile_state = NULL;</span>
<span class="line-added">+   _throw_to_caller = false;</span>
<span class="line-added">+   _file = file;</span>
<span class="line-added">+   _line = line;</span>
<span class="line-added">+   if (is_hotspot) {</span>
<span class="line-added">+     _env = NULL;</span>
<span class="line-added">+     _pop_frame_on_close = false;</span>
<span class="line-added">+     _detach_on_close = false;</span>
<span class="line-added">+     _is_hotspot = true;</span>
<span class="line-added">+     _runtime = JVMCI::java_runtime();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     init_env_mode_runtime(thread, NULL);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Prints a pending exception (if any) and its stack trace.</span>
<span class="line-added">+ void JVMCIEnv::describe_pending_exception(bool clear) {</span>
<span class="line-added">+   if (!is_hotspot()) {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       jthrowable ex = !clear ? jni()-&gt;ExceptionOccurred() : NULL;</span>
<span class="line-added">+       jni()-&gt;ExceptionDescribe();</span>
<span class="line-added">+       if (ex != NULL) {</span>
<span class="line-added">+         jni()-&gt;Throw(ex);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     Thread* THREAD = Thread::current();</span>
<span class="line-added">+     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+       JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! void JVMCIEnv::translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable) {</span>
<span class="line-modified">!   assert(!is_hotspot(), &quot;must_be&quot;);</span>
<span class="line-modified">!   // Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets</span>
<span class="line-modified">!   // may not have been called.</span>
<span class="line-added">+   Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);</span>
<span class="line-added">+   JavaCallArguments jargs;</span>
<span class="line-added">+   jargs.push_oop(throwable);</span>
<span class="line-added">+   JavaValue result(T_OBJECT);</span>
<span class="line-added">+   JavaCalls::call_static(&amp;result,</span>
<span class="line-added">+                           runtimeKlass,</span>
<span class="line-added">+                           vmSymbols::encodeThrowable_name(),</span>
<span class="line-added">+                           vmSymbols::encodeThrowable_signature(), &amp;jargs, THREAD);</span>
<span class="line-added">+   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+     JVMCIRuntime::exit_on_pending_exception(this, &quot;HotSpotJVMCIRuntime.encodeThrowable should not throw an exception&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   oop encoded_throwable_string = (oop) result.get_jobject();</span>
<span class="line-added">+ </span>
    ResourceMark rm;
<span class="line-modified">!   const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   JNIAccessMark jni(this);</span>
<span class="line-modified">!   jobject jni_encoded_throwable_string = jni()-&gt;NewStringUTF(encoded_throwable_chars);</span>
<span class="line-modified">!   jthrowable jni_throwable = (jthrowable) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),</span>
<span class="line-modified">!                                 JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),</span>
<span class="line-modified">!                                 jni_encoded_throwable_string);</span>
<span class="line-modified">!   jni()-&gt;Throw(jni_throwable);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! JVMCIEnv::~JVMCIEnv() {</span>
<span class="line-modified">!   if (_throw_to_caller) {</span>
<span class="line-modified">!     if (is_hotspot()) {</span>
<span class="line-modified">!       // Nothing to do</span>
      } else {
<span class="line-modified">!       if (Thread::current()-&gt;is_Java_thread()) {</span>
<span class="line-modified">!         JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+         if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+           Handle throwable = Handle(THREAD, PENDING_EXCEPTION);</span>
<span class="line-added">+           CLEAR_PENDING_EXCEPTION;</span>
<span class="line-added">+           translate_hotspot_exception_to_jni_exception(THREAD, throwable);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     if (_pop_frame_on_close) {</span>
<span class="line-added">+       // Pop the JNI local frame that was pushed when entering this JVMCIEnv scope.</span>
<span class="line-added">+       JNIAccessMark jni(this);</span>
<span class="line-added">+       jni()-&gt;PopLocalFrame(NULL);</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     if (has_pending_exception()) {</span>
<span class="line-added">+       char message[256];</span>
<span class="line-added">+       jio_snprintf(message, 256, &quot;Uncaught exception exiting JVMCIEnv scope entered at %s:%d&quot;, _file, _line);</span>
<span class="line-added">+       JVMCIRuntime::exit_on_pending_exception(this, message);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (_detach_on_close) {</span>
<span class="line-added">+       get_shared_library_javavm()-&gt;DetachCurrentThread();</span>
      }
    }
<span class="line-added">+ }</span>
  
<span class="line-modified">! jboolean JVMCIEnv::has_pending_exception() {</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     Thread* THREAD = Thread::current();</span>
<span class="line-added">+     return HAS_PENDING_EXCEPTION;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     return jni()-&gt;ExceptionCheck();</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! void JVMCIEnv::clear_pending_exception() {</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     Thread* THREAD = Thread::current();</span>
<span class="line-modified">!     CLEAR_PENDING_EXCEPTION;</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     JNIAccessMark jni(this);</span>
<span class="line-modified">!     jni()-&gt;ExceptionClear();</span>
<span class="line-modified">!   }</span>
  }
  
<span class="line-modified">! int JVMCIEnv::get_length(JVMCIArray array) {</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     return HotSpotJVMCI::resolve(array)-&gt;length();</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     JNIAccessMark jni(this);</span>
<span class="line-modified">!     return jni()-&gt;GetArrayLength(get_jarray(array));</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! JVMCIObject JVMCIEnv::get_object_at(JVMCIObjectArray array, int index) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     oop result = HotSpotJVMCI::resolve(array)-&gt;obj_at(index);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = jni()-&gt;GetObjectArrayElement(get_jobjectArray(array), index);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void JVMCIEnv::put_object_at(JVMCIObjectArray array, int index, JVMCIObject value) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     HotSpotJVMCI::resolve(array)-&gt;obj_at_put(index, HotSpotJVMCI::resolve(value));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;SetObjectArrayElement(get_jobjectArray(array), index, get_jobject(value));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! jboolean JVMCIEnv::get_bool_at(JVMCIPrimitiveArray array, int index) {</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-added">+     return HotSpotJVMCI::resolve(array)-&gt;bool_at(index);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jboolean result;</span>
<span class="line-added">+     jni()-&gt;GetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;result);</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ void JVMCIEnv::put_bool_at(JVMCIPrimitiveArray array, int index, jboolean value) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     HotSpotJVMCI::resolve(array)-&gt;bool_at_put(index, value);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;SetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;value);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! jbyte JVMCIEnv::get_byte_at(JVMCIPrimitiveArray array, int index) {</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     return HotSpotJVMCI::resolve(array)-&gt;byte_at(index);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jbyte result;</span>
<span class="line-added">+     jni()-&gt;GetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;result);</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ void JVMCIEnv::put_byte_at(JVMCIPrimitiveArray array, int index, jbyte value) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     HotSpotJVMCI::resolve(array)-&gt;byte_at_put(index, value);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;SetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;value);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! jint JVMCIEnv::get_int_at(JVMCIPrimitiveArray array, int index) {</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     return HotSpotJVMCI::resolve(array)-&gt;int_at(index);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     JNIAccessMark jni(this);</span>
<span class="line-modified">!     jint result;</span>
<span class="line-added">+     jni()-&gt;GetIntArrayRegion(array.as_jintArray(), index, 1, &amp;result);</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ void JVMCIEnv::put_int_at(JVMCIPrimitiveArray array, int index, jint value) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     HotSpotJVMCI::resolve(array)-&gt;int_at_put(index, value);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;SetIntArrayRegion(array.as_jintArray(), index, 1, &amp;value);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! long JVMCIEnv::get_long_at(JVMCIPrimitiveArray array, int index) {</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     return HotSpotJVMCI::resolve(array)-&gt;long_at(index);</span>
<span class="line-modified">!   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jlong result;</span>
<span class="line-added">+     jni()-&gt;GetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;result);</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ void JVMCIEnv::put_long_at(JVMCIPrimitiveArray array, int index, jlong value) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     HotSpotJVMCI::resolve(array)-&gt;long_at_put(index, value);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;SetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;value);</span>
    }
<span class="line-added">+ }</span>
  
<span class="line-added">+ void JVMCIEnv::copy_bytes_to(JVMCIPrimitiveArray src, jbyte* dest, int offset, jsize length) {</span>
<span class="line-added">+   if (length == 0) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     memcpy(dest, HotSpotJVMCI::resolve(src)-&gt;byte_at_addr(offset), length);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;GetByteArrayRegion(src.as_jbyteArray(), offset, length, dest);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ void JVMCIEnv::copy_bytes_from(jbyte* src, JVMCIPrimitiveArray dest, int offset, jsize length) {</span>
<span class="line-added">+   if (length == 0) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     memcpy(HotSpotJVMCI::resolve(dest)-&gt;byte_at_addr(offset), src, length);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;SetByteArrayRegion(dest.as_jbyteArray(), offset, length, src);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void JVMCIEnv::copy_longs_from(jlong* src, JVMCIPrimitiveArray dest, int offset, jsize length) {</span>
<span class="line-modified">!   if (length == 0) {</span>
      return;
    }
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     memcpy(HotSpotJVMCI::resolve(dest)-&gt;long_at_addr(offset), src, length * sizeof(jlong));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;SetLongArrayRegion(dest.as_jlongArray(), offset, length, src);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! jboolean JVMCIEnv::is_boxing_object(BasicType type, JVMCIObject object) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     return java_lang_boxing_object::is_instance(HotSpotJVMCI::resolve(object), type);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     return jni()-&gt;IsInstanceOf(get_jobject(object), JNIJVMCI::box_class(type));</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! // Get the primitive value from a Java boxing object.  It&#39;s hard error to</span>
<span class="line-modified">! // pass a non-primitive BasicType.</span>
<span class="line-modified">! jvalue JVMCIEnv::get_boxed_value(BasicType type, JVMCIObject object) {</span>
<span class="line-modified">!   jvalue result;</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     if (java_lang_boxing_object::get_value(HotSpotJVMCI::resolve(object), &amp;result) == T_ILLEGAL) {</span>
<span class="line-modified">!       ShouldNotReachHere();</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     JNIAccessMark jni(this);</span>
<span class="line-modified">!     jfieldID field = JNIJVMCI::box_field(type);</span>
<span class="line-modified">!     switch (type) {</span>
<span class="line-modified">!       case T_BOOLEAN: result.z = jni()-&gt;GetBooleanField(get_jobject(object), field); break;</span>
<span class="line-modified">!       case T_BYTE:    result.b = jni()-&gt;GetByteField(get_jobject(object), field); break;</span>
<span class="line-modified">!       case T_SHORT:   result.s = jni()-&gt;GetShortField(get_jobject(object), field); break;</span>
<span class="line-modified">!       case T_CHAR:    result.c = jni()-&gt;GetCharField(get_jobject(object), field); break;</span>
<span class="line-modified">!       case T_INT:     result.i = jni()-&gt;GetIntField(get_jobject(object), field); break;</span>
<span class="line-modified">!       case T_LONG:    result.j = jni()-&gt;GetLongField(get_jobject(object), field); break;</span>
<span class="line-modified">!       case T_FLOAT:   result.f = jni()-&gt;GetFloatField(get_jobject(object), field); break;</span>
<span class="line-modified">!       case T_DOUBLE:  result.d = jni()-&gt;GetDoubleField(get_jobject(object), field); break;</span>
<span class="line-modified">!       default:</span>
<span class="line-modified">!         ShouldNotReachHere();</span>
      }
<span class="line-added">+   }</span>
<span class="line-added">+   return result;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! // Return the BasicType of the object if it&#39;s a boxing object, otherwise return T_ILLEGAL.</span>
<span class="line-added">+ BasicType JVMCIEnv::get_box_type(JVMCIObject object) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     return java_lang_boxing_object::basic_type(HotSpotJVMCI::resolve(object));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jclass clazz = jni()-&gt;GetObjectClass(get_jobject(object));</span>
<span class="line-added">+     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BOOLEAN))) return T_BOOLEAN;</span>
<span class="line-added">+     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BYTE))) return T_BYTE;</span>
<span class="line-added">+     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_SHORT))) return T_SHORT;</span>
<span class="line-added">+     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_CHAR))) return T_CHAR;</span>
<span class="line-added">+     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_INT))) return T_INT;</span>
<span class="line-added">+     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_LONG))) return T_LONG;</span>
<span class="line-added">+     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_FLOAT))) return T_FLOAT;</span>
<span class="line-added">+     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_DOUBLE))) return T_DOUBLE;</span>
<span class="line-added">+     return T_ILLEGAL;</span>
    }
<span class="line-added">+ }</span>
  
<span class="line-modified">! // Create a boxing object of the appropriate primitive type.</span>
<span class="line-modified">! JVMCIObject JVMCIEnv::create_box(BasicType type, jvalue* value, JVMCI_TRAPS) {</span>
<span class="line-modified">!   switch (type) {</span>
<span class="line-modified">!     case T_BOOLEAN:</span>
<span class="line-modified">!     case T_BYTE:</span>
<span class="line-modified">!     case T_CHAR:</span>
<span class="line-modified">!     case T_SHORT:</span>
<span class="line-modified">!     case T_INT:</span>
<span class="line-modified">!     case T_LONG:</span>
<span class="line-modified">!     case T_FLOAT:</span>
<span class="line-modified">!     case T_DOUBLE:</span>
        break;
      default:
<span class="line-modified">!       JVMCI_THROW_MSG_(IllegalArgumentException, &quot;Only boxes for primitive values can be created&quot;, JVMCIObject());</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return HotSpotJVMCI::wrap(box);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject box = jni()-&gt;NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);</span>
<span class="line-added">+     assert(box != NULL, &quot;&quot;);</span>
<span class="line-added">+     return wrap(box);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const char* JVMCIEnv::as_utf8_string(JVMCIObject str) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     int length = jni()-&gt;GetStringLength(str.as_jstring());</span>
<span class="line-added">+     char* result = NEW_RESOURCE_ARRAY(char, length + 1);</span>
<span class="line-added">+     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, result);</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ char* JVMCIEnv::as_utf8_string(JVMCIObject str, char* buf, int buflen) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str), buf, buflen);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     int length = jni()-&gt;GetStringLength(str.as_jstring());</span>
<span class="line-added">+     if (length &gt;= buflen) {</span>
<span class="line-added">+       length = buflen;</span>
      }
<span class="line-added">+     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, buf);</span>
<span class="line-added">+     return buf;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define DO_THROW(name)                             \</span>
<span class="line-added">+ void JVMCIEnv::throw_##name(const char* msg) {     \</span>
<span class="line-added">+   if (is_hotspot()) {                              \</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();    \</span>
<span class="line-added">+     THROW_MSG(HotSpotJVMCI::name::symbol(), msg);  \</span>
<span class="line-added">+   } else {                                         \</span>
<span class="line-added">+     JNIAccessMark jni(this);                       \</span>
<span class="line-added">+     jni()-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg); \</span>
<span class="line-added">+   }                                                \</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ DO_THROW(InternalError)</span>
<span class="line-added">+ DO_THROW(ArrayIndexOutOfBoundsException)</span>
<span class="line-added">+ DO_THROW(IllegalStateException)</span>
<span class="line-added">+ DO_THROW(NullPointerException)</span>
<span class="line-added">+ DO_THROW(IllegalArgumentException)</span>
<span class="line-added">+ DO_THROW(InvalidInstalledCodeException)</span>
<span class="line-added">+ DO_THROW(UnsatisfiedLinkError)</span>
<span class="line-added">+ DO_THROW(UnsupportedOperationException)</span>
<span class="line-added">+ DO_THROW(ClassNotFoundException)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef DO_THROW</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIEnv::fthrow_error(const char* file, int line, const char* format, ...) {</span>
<span class="line-added">+   const int max_msg_size = 1024;</span>
<span class="line-added">+   va_list ap;</span>
<span class="line-added">+   va_start(ap, format);</span>
<span class="line-added">+   char msg[max_msg_size];</span>
<span class="line-added">+   vsnprintf(msg, max_msg_size, format, ap);</span>
<span class="line-added">+   msg[max_msg_size-1] = &#39;\0&#39;;</span>
<span class="line-added">+   va_end(ap);</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     Handle h_loader = Handle();</span>
<span class="line-added">+     Handle h_protection_domain = Handle();</span>
<span class="line-added">+     Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);</span>
    }
<span class="line-added">+ }</span>
  
<span class="line-modified">! JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,</span>
<span class="line-modified">!                                                               jlong compile_state, int id) {</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     Thread* THREAD = Thread::current();</span>
<span class="line-modified">!     JavaCallArguments jargs;</span>
<span class="line-modified">!     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));</span>
<span class="line-added">+     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(method)));</span>
<span class="line-added">+     jargs.push_int(entry_bci);</span>
<span class="line-added">+     jargs.push_long(compile_state);</span>
<span class="line-added">+     jargs.push_int(id);</span>
<span class="line-added">+     JavaValue result(T_OBJECT);</span>
<span class="line-added">+     JavaCalls::call_special(&amp;result,</span>
<span class="line-added">+                             HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),</span>
<span class="line-added">+                             vmSymbols::compileMethod_name(),</span>
<span class="line-added">+                             vmSymbols::compileMethod_signature(), &amp;jargs, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap((oop) result.get_jobject());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = jni()-&gt;CallNonvirtualObjectMethod(runtime.as_jobject(),</span>
<span class="line-added">+                                                      JNIJVMCI::HotSpotJVMCIRuntime::clazz(),</span>
<span class="line-added">+                                                      JNIJVMCI::HotSpotJVMCIRuntime::compileMethod_method(),</span>
<span class="line-added">+                                                      method.as_jobject(), entry_bci, compile_state, id);</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       return JVMCIObject();</span>
      }
<span class="line-added">+     return wrap(result);</span>
    }
<span class="line-added">+ }</span>
  
<span class="line-modified">! void JVMCIEnv::call_HotSpotJVMCIRuntime_bootstrapFinished (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-added">+     Thread* THREAD = Thread::current();</span>
<span class="line-added">+     JavaCallArguments jargs;</span>
<span class="line-added">+     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));</span>
<span class="line-added">+     JavaValue result(T_VOID);</span>
<span class="line-added">+     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::bootstrapFinished_name(), vmSymbols::void_method_signature(), &amp;jargs, CHECK);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::bootstrapFinished_method());</span>
  
<span class="line-modified">!   }</span>
  }
  
<span class="line-modified">! void JVMCIEnv::call_HotSpotJVMCIRuntime_shutdown (JVMCIObject runtime) {</span>
<span class="line-modified">!   HandleMark hm;</span>
<span class="line-modified">!   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     JavaCallArguments jargs;</span>
<span class="line-modified">!     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));</span>
<span class="line-modified">!     JavaValue result(T_VOID);</span>
<span class="line-modified">!     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &amp;jargs, THREAD);</span>
    } else {
<span class="line-modified">!     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (has_pending_exception()) {</span>
<span class="line-added">+     // This should never happen as HotSpotJVMCIRuntime.shutdown() should</span>
<span class="line-added">+     // handle all exceptions.</span>
<span class="line-added">+     describe_pending_exception(true);</span>
    }
  }
  
<span class="line-added">+ JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_runtime (JVMCIEnv* JVMCIENV) {</span>
<span class="line-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaCallArguments jargs;</span>
<span class="line-added">+     JavaValue result(T_OBJECT);</span>
<span class="line-added">+     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &amp;jargs, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap((oop) result.get_jobject());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       return JVMCIObject();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! JVMCIObject JVMCIEnv::call_JVMCI_getRuntime (JVMCIEnv* JVMCIENV) {</span>
<span class="line-modified">!   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     JavaCallArguments jargs;</span>
<span class="line-modified">!     JavaValue result(T_OBJECT);</span>
<span class="line-modified">!     JavaCalls::call_static(&amp;result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &amp;jargs, CHECK_(JVMCIObject()));</span>
<span class="line-modified">!     return wrap((oop) result.get_jobject());</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     JNIAccessMark jni(this);</span>
<span class="line-modified">!     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());</span>
<span class="line-modified">!     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-modified">!       return JVMCIObject();</span>
      }
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_getCompiler (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {</span>
<span class="line-modified">!   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     JavaCallArguments jargs;</span>
<span class="line-modified">!     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));</span>
<span class="line-modified">!     JavaValue result(T_OBJECT);</span>
<span class="line-modified">!     JavaCalls::call_virtual(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &amp;jargs, CHECK_(JVMCIObject()));</span>
<span class="line-modified">!     return wrap((oop) result.get_jobject());</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     JNIAccessMark jni(this);</span>
<span class="line-modified">!     jobject result = jni()-&gt;CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());</span>
<span class="line-modified">!     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-modified">!       return JVMCIObject();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCIEnv* JVMCIENV) {</span>
<span class="line-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaCallArguments jargs;</span>
<span class="line-added">+     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));</span>
<span class="line-added">+     JavaValue result(T_OBJECT);</span>
<span class="line-added">+     JavaCalls::call_static(&amp;result,</span>
<span class="line-added">+                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),</span>
<span class="line-added">+                            vmSymbols::callToString_name(),</span>
<span class="line-added">+                            vmSymbols::callToString_signature(), &amp;jargs, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap((oop) result.get_jobject());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),</span>
<span class="line-added">+                                                      JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),</span>
<span class="line-added">+                                                      object.as_jobject());</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       return JVMCIObject();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS) {</span>
<span class="line-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaCallArguments jargs;</span>
<span class="line-added">+     jargs.push_int(kind);</span>
<span class="line-added">+     jargs.push_long(value);</span>
<span class="line-added">+     JavaValue result(T_OBJECT);</span>
<span class="line-added">+     JavaCalls::call_static(&amp;result,</span>
<span class="line-added">+                            HotSpotJVMCI::PrimitiveConstant::klass(),</span>
<span class="line-added">+                            vmSymbols::forTypeChar_name(),</span>
<span class="line-added">+                            vmSymbols::forTypeChar_signature(), &amp;jargs, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap((oop) result.get_jobject());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),</span>
<span class="line-added">+                                                      JNIJVMCI::PrimitiveConstant::forTypeChar_method(),</span>
<span class="line-added">+                                                      kind, value);</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       return JVMCIObject();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::call_JavaConstant_forFloat(float value, JVMCI_TRAPS) {</span>
<span class="line-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaCallArguments jargs;</span>
<span class="line-added">+     jargs.push_float(value);</span>
<span class="line-added">+     JavaValue result(T_OBJECT);</span>
<span class="line-added">+     JavaCalls::call_static(&amp;result,</span>
<span class="line-added">+                            HotSpotJVMCI::JavaConstant::klass(),</span>
<span class="line-added">+                            vmSymbols::forFloat_name(),</span>
<span class="line-added">+                            vmSymbols::forFloat_signature(), &amp;jargs, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap((oop) result.get_jobject());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),</span>
<span class="line-added">+                                                      JNIJVMCI::JavaConstant::forFloat_method(),</span>
<span class="line-added">+                                                      value);</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       return JVMCIObject();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::call_JavaConstant_forDouble(double value, JVMCI_TRAPS) {</span>
<span class="line-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaCallArguments jargs;</span>
<span class="line-added">+     jargs.push_double(value);</span>
<span class="line-added">+     JavaValue result(T_OBJECT);</span>
<span class="line-added">+     JavaCalls::call_static(&amp;result,</span>
<span class="line-added">+                            HotSpotJVMCI::JavaConstant::klass(),</span>
<span class="line-added">+                            vmSymbols::forDouble_name(),</span>
<span class="line-added">+                            vmSymbols::forDouble_signature(), &amp;jargs, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap((oop) result.get_jobject());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),</span>
<span class="line-added">+                                                      JNIJVMCI::JavaConstant::forDouble_method(),</span>
<span class="line-added">+                                                      value);</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       return JVMCIObject();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::get_jvmci_primitive_type(BasicType type) {</span>
<span class="line-added">+   JVMCIObjectArray primitives = get_HotSpotResolvedPrimitiveType_primitives();</span>
<span class="line-added">+   JVMCIObject result = get_object_at(primitives, type);</span>
<span class="line-added">+   return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS) {</span>
<span class="line-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+   Symbol* file_name_sym;</span>
<span class="line-added">+   int line_number;</span>
<span class="line-added">+   java_lang_StackTraceElement::decode(method, bci, file_name_sym, line_number, CHECK_(JVMCIObject()));</span>
<span class="line-added">+ </span>
<span class="line-added">+   Symbol* method_name_sym = method-&gt;name();</span>
<span class="line-added">+   InstanceKlass* holder = method-&gt;method_holder();</span>
<span class="line-added">+   const char* declaring_class_str = holder-&gt;external_name();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     HotSpotJVMCI::StackTraceElement::klass()-&gt;initialize(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     oop objOop = HotSpotJVMCI::StackTraceElement::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     Handle obj = Handle(THREAD, objOop);</span>
<span class="line-added">+ </span>
<span class="line-added">+     oop declaring_class = StringTable::intern((char*) declaring_class_str, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     HotSpotJVMCI::StackTraceElement::set_declaringClass(this, obj(), declaring_class);</span>
<span class="line-added">+ </span>
<span class="line-added">+     oop method_name = StringTable::intern(method_name_sym, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     HotSpotJVMCI::StackTraceElement::set_methodName(this, obj(), method_name);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (file_name_sym != NULL) {</span>
<span class="line-added">+       oop file_name = StringTable::intern(file_name_sym, CHECK_(JVMCIObject()));</span>
<span class="line-added">+       HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);</span>
<span class="line-added">+     return wrap(obj());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject declaring_class = jni()-&gt;NewStringUTF(declaring_class_str);</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       return JVMCIObject();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     jobject method_name = jni()-&gt;NewStringUTF(method_name_sym-&gt;as_C_string());</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       return JVMCIObject();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     jobject file_name = NULL;</span>
<span class="line-added">+     if (file_name_sym != NULL) {</span>
<span class="line-added">+       file_name = jni()-&gt;NewStringUTF(file_name_sym-&gt;as_C_string());</span>
<span class="line-added">+       if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+         return JVMCIObject();</span>
        }
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     jobject result = jni()-&gt;NewObject(JNIJVMCI::StackTraceElement::clazz(),</span>
<span class="line-added">+                                       JNIJVMCI::StackTraceElement::constructor(),</span>
<span class="line-added">+                                       declaring_class, method_name, file_name, line_number);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::new_HotSpotNmethod(const methodHandle&amp; method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS) {</span>
<span class="line-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject methodObject = get_jvmci_method(method, JVMCI_CHECK_(JVMCIObject()));</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     InstanceKlass* ik = InstanceKlass::cast(HotSpotJVMCI::HotSpotNmethod::klass());</span>
<span class="line-added">+     if (ik-&gt;should_be_initialized()) {</span>
<span class="line-added">+       ik-&gt;initialize(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     oop obj = ik-&gt;allocate_instance(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     Handle obj_h(THREAD, obj);</span>
<span class="line-added">+     Handle nameStr = java_lang_String::create_from_str(name, CHECK_(JVMCIObject()));</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Call constructor</span>
<span class="line-added">+     JavaCallArguments jargs;</span>
<span class="line-added">+     jargs.push_oop(obj_h);</span>
<span class="line-added">+     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(methodObject)));</span>
<span class="line-added">+     jargs.push_oop(nameStr);</span>
<span class="line-added">+     jargs.push_int(isDefault);</span>
<span class="line-added">+     jargs.push_long(compileId);</span>
<span class="line-added">+     JavaValue result(T_VOID);</span>
<span class="line-added">+     JavaCalls::call_special(&amp;result, ik,</span>
<span class="line-added">+                             vmSymbols::object_initializer_name(),</span>
<span class="line-added">+                             vmSymbols::method_string_bool_long_signature(),</span>
<span class="line-added">+                             &amp;jargs, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap(obj_h());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject nameStr = name == NULL ? NULL : jni()-&gt;NewStringUTF(name);</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       return JVMCIObject();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     jobject result = jni()-&gt;NewObject(JNIJVMCI::HotSpotNmethod::clazz(),</span>
<span class="line-added">+                                       JNIJVMCI::HotSpotNmethod::constructor(),</span>
<span class="line-added">+                                       methodObject.as_jobject(), nameStr, isDefault);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::make_local(JVMCIObject object) {</span>
<span class="line-added">+   if (object.is_null()) {</span>
<span class="line-added">+     return JVMCIObject();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     return wrap(JNIHandles::make_local(HotSpotJVMCI::resolve(object)));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     return wrap(jni()-&gt;NewLocalRef(object.as_jobject()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::make_global(JVMCIObject object) {</span>
<span class="line-added">+   if (object.is_null()) {</span>
<span class="line-added">+     return JVMCIObject();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     return wrap(JNIHandles::make_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     return wrap(jni()-&gt;NewGlobalRef(object.as_jobject()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::make_weak(JVMCIObject object) {</span>
<span class="line-added">+   if (object.is_null()) {</span>
<span class="line-added">+     return JVMCIObject();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     return wrap(JNIHandles::make_weak_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     return wrap(jni()-&gt;NewWeakGlobalRef(object.as_jobject()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void JVMCIEnv::destroy_local(JVMCIObject object) {</span>
<span class="line-modified">!   if (is_hotspot()) {</span>
<span class="line-modified">!     JNIHandles::destroy_local(object.as_jobject());</span>
<span class="line-modified">!   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;DeleteLocalRef(object.as_jobject());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIEnv::destroy_global(JVMCIObject object) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JNIHandles::destroy_global(object.as_jobject());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;DeleteGlobalRef(object.as_jobject());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIEnv::destroy_weak(JVMCIObject object) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JNIHandles::destroy_weak_global(object.as_jweak());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jni()-&gt;DeleteWeakGlobalRef(object.as_jweak());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const char* JVMCIEnv::klass_name(JVMCIObject object) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     return HotSpotJVMCI::resolve(object)-&gt;klass()-&gt;signature_name();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JVMCIObject name;</span>
<span class="line-added">+     {</span>
<span class="line-added">+       JNIAccessMark jni(this);</span>
<span class="line-added">+       jclass jcl = jni()-&gt;GetObjectClass(object.as_jobject());</span>
<span class="line-added">+       jobject result = jni()-&gt;CallObjectMethod(jcl, JNIJVMCI::Class_getName_method());</span>
<span class="line-added">+       name = JVMCIObject::create(result, is_hotspot());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return as_utf8_string(name);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS) {</span>
<span class="line-added">+   JVMCIObject method_object;</span>
<span class="line-added">+   if (method() == NULL) {</span>
<span class="line-added">+     return method_object;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Thread* THREAD = Thread::current();</span>
<span class="line-added">+   jmetadata handle = JVMCI::allocate_handle(method);</span>
<span class="line-added">+   jboolean exception = false;</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaValue result(T_OBJECT);</span>
<span class="line-added">+     JavaCallArguments args;</span>
<span class="line-added">+     args.push_long((jlong) handle);</span>
<span class="line-added">+     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass(),</span>
<span class="line-added">+                            vmSymbols::fromMetaspace_name(),</span>
<span class="line-added">+                            vmSymbols::method_fromMetaspace_signature(), &amp;args, THREAD);</span>
<span class="line-added">+     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+       exception = true;</span>
      } else {
<span class="line-modified">!       method_object = wrap((oop)result.get_jobject());</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     JNIAccessMark jni(this);</span>
<span class="line-modified">!     method_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedJavaMethodImpl::clazz(),</span>
<span class="line-modified">!                                                                   JNIJVMCI::HotSpotResolvedJavaMethodImpl_fromMetaspace_method(),</span>
<span class="line-modified">!                                                                   (jlong) handle));</span>
<span class="line-modified">!     exception = jni()-&gt;ExceptionCheck();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (exception) {</span>
<span class="line-modified">!     JVMCI::release_handle(handle);</span>
<span class="line-modified">!     return JVMCIObject();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   assert(asMethod(method_object) == method(), &quot;must be&quot;);</span>
<span class="line-modified">!   if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {</span>
<span class="line-modified">!     JVMCI::release_handle(handle);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   assert(!method_object.is_null(), &quot;must be&quot;);</span>
<span class="line-modified">!   return method_object;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! JVMCIObject JVMCIEnv::get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS) {</span>
<span class="line-modified">!   JVMCIObject type;</span>
<span class="line-modified">!   if (klass.is_null()) {</span>
<span class="line-modified">!     return type;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   jlong pointer = (jlong) klass();</span>
<span class="line-modified">!   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+   JVMCIObject signature = create_string(klass-&gt;signature_name(), JVMCI_CHECK_(JVMCIObject()));</span>
<span class="line-added">+   jboolean exception = false;</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaValue result(T_OBJECT);</span>
<span class="line-added">+     JavaCallArguments args;</span>
<span class="line-added">+     args.push_long(pointer);</span>
<span class="line-added">+     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(signature)));</span>
<span class="line-added">+     JavaCalls::call_static(&amp;result,</span>
<span class="line-added">+                            HotSpotJVMCI::HotSpotResolvedObjectTypeImpl::klass(),</span>
<span class="line-added">+                            vmSymbols::fromMetaspace_name(),</span>
<span class="line-added">+                            vmSymbols::klass_fromMetaspace_signature(), &amp;args, THREAD);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+       exception = true;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       type = wrap((oop)result.get_jobject());</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+ </span>
<span class="line-added">+     HandleMark hm(THREAD);</span>
<span class="line-added">+     type = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),</span>
<span class="line-added">+                                                         JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),</span>
<span class="line-added">+                                                         pointer, signature.as_jstring()));</span>
<span class="line-added">+     exception = jni()-&gt;ExceptionCheck();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (exception) {</span>
<span class="line-added">+     return JVMCIObject();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(type.is_non_null(), &quot;must have result&quot;);</span>
<span class="line-added">+   return type;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS) {</span>
<span class="line-added">+   JVMCIObject cp_object;</span>
<span class="line-added">+   jmetadata handle = JVMCI::allocate_handle(cp);</span>
<span class="line-added">+   jboolean exception = false;</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     JavaValue result(T_OBJECT);</span>
<span class="line-added">+     JavaCallArguments args;</span>
<span class="line-added">+     args.push_long((jlong) handle);</span>
<span class="line-added">+     JavaCalls::call_static(&amp;result,</span>
<span class="line-added">+                            HotSpotJVMCI::HotSpotConstantPool::klass(),</span>
<span class="line-added">+                            vmSymbols::fromMetaspace_name(),</span>
<span class="line-added">+                            vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, THREAD);</span>
<span class="line-added">+     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+       exception = true;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       cp_object = wrap((oop)result.get_jobject());</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     cp_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),</span>
<span class="line-added">+                                                              JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),</span>
<span class="line-added">+                                                              (jlong) handle));</span>
<span class="line-added">+     exception = jni()-&gt;ExceptionCheck();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (exception) {</span>
<span class="line-added">+     JVMCI::release_handle(handle);</span>
<span class="line-added">+     return JVMCIObject();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(!cp_object.is_null(), &quot;must be&quot;);</span>
<span class="line-added">+   // Constant pools aren&#39;t cached so this is always a newly created object using the handle</span>
<span class="line-added">+   assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, &quot;must use same handle&quot;);</span>
<span class="line-added">+   return cp_object;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jbooleanArray result = jni()-&gt;NewBooleanArray(length);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jbyteArray result = jni()-&gt;NewByteArray(length);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())-&gt;array_klass(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) -&gt;allocate(length, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::byte_array(), NULL);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jintArray result = jni()-&gt;NewIntArray(length);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jlongArray result = jni()-&gt;NewLongArray(length);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     HotSpotJVMCI::VMField::klass()-&gt;initialize(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     oop obj = HotSpotJVMCI::VMField::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));</span>
<span class="line-added">+     HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));</span>
<span class="line-added">+     HotSpotJVMCI::VMField::set_offset(this, obj, offset);</span>
<span class="line-added">+     HotSpotJVMCI::VMField::set_address(this, obj, address);</span>
<span class="line-added">+     HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));</span>
<span class="line-added">+     return wrap(obj);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMField::clazz(),</span>
<span class="line-added">+                                     JNIJVMCI::VMField::constructor(),</span>
<span class="line-added">+                                     get_jobject(name), get_jobject(type), offset, address, get_jobject(value));</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     HotSpotJVMCI::VMFlag::klass()-&gt;initialize(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     oop obj = HotSpotJVMCI::VMFlag::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));</span>
<span class="line-added">+     HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));</span>
<span class="line-added">+     HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));</span>
<span class="line-added">+     return wrap(obj);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMFlag::clazz(),</span>
<span class="line-added">+                                     JNIJVMCI::VMFlag::constructor(),</span>
<span class="line-added">+                                     get_jobject(name), get_jobject(type), get_jobject(value));</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;initialize(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));</span>
<span class="line-added">+     HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));</span>
<span class="line-added">+     HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));</span>
<span class="line-added">+     HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);</span>
<span class="line-added">+     return wrap(obj);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),</span>
<span class="line-added">+                                     JNIJVMCI::VMIntrinsicMethod::constructor(),</span>
<span class="line-added">+                                     get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::new_HotSpotStackFrameReference(JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     oop obj = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap(obj);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     ShouldNotReachHere();</span>
<span class="line-added">+     return JVMCIObject();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ JVMCIObject JVMCIEnv::new_JVMCIError(JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     HotSpotJVMCI::JVMCIError::klass()-&gt;initialize(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     oop obj = HotSpotJVMCI::JVMCIError::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return wrap(obj);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     ShouldNotReachHere();</span>
<span class="line-added">+     return JVMCIObject();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::get_object_constant(oop objOop, bool compressed, bool dont_register) {</span>
<span class="line-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+   Handle obj = Handle(THREAD, objOop);</span>
<span class="line-added">+   if (obj.is_null()) {</span>
<span class="line-added">+     return JVMCIObject();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;initialize(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     oop constant = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));</span>
<span class="line-added">+     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());</span>
<span class="line-added">+     HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);</span>
<span class="line-added">+     return wrap(constant);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     jlong handle = make_handle(obj);</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     jobject result = jni()-&gt;NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),</span>
<span class="line-added">+                                       JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),</span>
<span class="line-added">+                                       handle, compressed, dont_register);</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ Handle JVMCIEnv::asConstant(JVMCIObject constant, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (constant.is_null()) {</span>
<span class="line-added">+     return Handle();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     assert(HotSpotJVMCI::DirectHotSpotObjectConstantImpl::is_instance(this, constant), &quot;wrong type&quot;);</span>
<span class="line-added">+     oop obj = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::object(this, HotSpotJVMCI::resolve(constant));</span>
<span class="line-added">+     return Handle(THREAD, obj);</span>
<span class="line-added">+   } else if (isa_IndirectHotSpotObjectConstantImpl(constant)) {</span>
<span class="line-added">+     jlong object_handle = get_IndirectHotSpotObjectConstantImpl_objectHandle(constant);</span>
<span class="line-added">+     if (object_handle == 0L) {</span>
<span class="line-added">+       JVMCI_THROW_MSG_(NullPointerException, &quot;Foreign object reference has been cleared&quot;, Handle());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     oop result = resolve_handle(object_handle);</span>
<span class="line-added">+     if (result == NULL) {</span>
<span class="line-added">+       JVMCI_THROW_MSG_(InternalError, &quot;Constant was unexpectedly NULL&quot;, Handle());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return Handle(THREAD, result);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JVMCI_THROW_MSG_(IllegalArgumentException, &quot;DirectHotSpotObjectConstantImpl shouldn&#39;t reach JVMCI in SVM mode&quot;, Handle());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::wrap(jobject object) {</span>
<span class="line-added">+   return JVMCIObject::create(object, is_hotspot());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ jlong JVMCIEnv::make_handle(const Handle&amp; obj) {</span>
<span class="line-added">+   assert(!obj.is_null(), &quot;should only create handle for non-NULL oops&quot;);</span>
<span class="line-added">+   jobject handle = JVMCI::make_global(obj);</span>
<span class="line-added">+   return (jlong) handle;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ oop JVMCIEnv::resolve_handle(jlong objectHandle) {</span>
<span class="line-added">+   assert(objectHandle != 0, &quot;should be a valid handle&quot;);</span>
<span class="line-added">+   oop obj = *((oopDesc**)objectHandle);</span>
<span class="line-added">+   if (obj != NULL) {</span>
<span class="line-added">+     oopDesc::verify(obj);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return obj;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-added">+     Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));</span>
<span class="line-added">+     return HotSpotJVMCI::wrap(result());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     jobject result;</span>
<span class="line-added">+     jboolean exception = false;</span>
<span class="line-added">+     {</span>
<span class="line-added">+       JNIAccessMark jni(this);</span>
<span class="line-added">+       result = jni()-&gt;NewStringUTF(str);</span>
<span class="line-added">+       exception = jni()-&gt;ExceptionCheck();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return wrap(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool JVMCIEnv::equals(JVMCIObject a, JVMCIObject b) {</span>
<span class="line-added">+   if (is_hotspot()) {</span>
<span class="line-added">+     return HotSpotJVMCI::resolve(a) == HotSpotJVMCI::resolve(b);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(this);</span>
<span class="line-added">+     return jni()-&gt;IsSameObject(a.as_jobject(), b.as_jobject()) != 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ BasicType JVMCIEnv::kindToBasicType(JVMCIObject kind, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (kind.is_null()) {</span>
<span class="line-added">+     JVMCI_THROW_(NullPointerException, T_ILLEGAL);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   jchar ch = get_JavaKind_typeChar(kind);</span>
<span class="line-added">+   switch(ch) {</span>
<span class="line-added">+     case &#39;Z&#39;: return T_BOOLEAN;</span>
<span class="line-added">+     case &#39;B&#39;: return T_BYTE;</span>
<span class="line-added">+     case &#39;S&#39;: return T_SHORT;</span>
<span class="line-added">+     case &#39;C&#39;: return T_CHAR;</span>
<span class="line-added">+     case &#39;I&#39;: return T_INT;</span>
<span class="line-added">+     case &#39;F&#39;: return T_FLOAT;</span>
<span class="line-added">+     case &#39;J&#39;: return T_LONG;</span>
<span class="line-added">+     case &#39;D&#39;: return T_DOUBLE;</span>
<span class="line-added">+     case &#39;A&#39;: return T_OBJECT;</span>
<span class="line-added">+     case &#39;-&#39;: return T_ILLEGAL;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       JVMCI_ERROR_(T_ILLEGAL, &quot;unexpected Kind: %c&quot;, ch);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIEnv::initialize_installed_code(JVMCIObject installed_code, CodeBlob* cb, JVMCI_TRAPS) {</span>
<span class="line-added">+   // Ensure that all updates to the InstalledCode fields are consistent.</span>
<span class="line-added">+   if (get_InstalledCode_address(installed_code) != 0) {</span>
<span class="line-added">+     JVMCI_THROW_MSG(InternalError, &quot;InstalledCode instance already in use&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (!isa_HotSpotInstalledCode(installed_code)) {</span>
<span class="line-added">+     JVMCI_THROW_MSG(InternalError, &quot;InstalledCode instance must be a subclass of HotSpotInstalledCode&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Ignore the version which can stay at 0</span>
<span class="line-added">+   if (cb-&gt;is_nmethod()) {</span>
<span class="line-added">+     nmethod* nm = cb-&gt;as_nmethod_or_null();</span>
<span class="line-added">+     if (!nm-&gt;is_alive()) {</span>
<span class="line-added">+       JVMCI_THROW_MSG(InternalError, &quot;nmethod has been reclaimed&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (nm-&gt;is_in_use()) {</span>
<span class="line-added">+       set_InstalledCode_entryPoint(installed_code, (jlong) nm-&gt;verified_entry_point());</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     set_InstalledCode_entryPoint(installed_code, (jlong) cb-&gt;code_begin());</span>
<span class="line-added">+   }</span>
<span class="line-added">+   set_InstalledCode_address(installed_code, (jlong) cb);</span>
<span class="line-added">+   set_HotSpotInstalledCode_size(installed_code, cb-&gt;size());</span>
<span class="line-added">+   set_HotSpotInstalledCode_codeStart(installed_code, (jlong) cb-&gt;code_begin());</span>
<span class="line-added">+   set_HotSpotInstalledCode_codeSize(installed_code, cb-&gt;code_size());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIEnv::invalidate_nmethod_mirror(JVMCIObject mirror, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (mirror.is_null()) {</span>
<span class="line-added">+     JVMCI_THROW(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   nmethodLocker locker;</span>
<span class="line-added">+   nmethod* nm = JVMCIENV-&gt;get_nmethod(mirror, locker);</span>
<span class="line-added">+   if (nm == NULL) {</span>
<span class="line-added">+     // Nothing to do</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Thread* THREAD = Thread::current();</span>
<span class="line-added">+   if (!mirror.is_hotspot() &amp;&amp; !THREAD-&gt;is_Java_thread()) {</span>
<span class="line-added">+     // Calling back into native might cause the execution to block, so only allow this when calling</span>
<span class="line-added">+     // from a JavaThread, which is the normal case anyway.</span>
<span class="line-added">+     JVMCI_THROW_MSG(IllegalArgumentException,</span>
<span class="line-added">+                     &quot;Cannot invalidate HotSpotNmethod object in shared library VM heap from non-JavaThread&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   nmethodLocker nml(nm);</span>
<span class="line-added">+   if (nm-&gt;is_alive()) {</span>
<span class="line-added">+     // Invalidating the HotSpotNmethod means we want the nmethod to be deoptimized.</span>
<span class="line-added">+     Deoptimization::deoptimize_all_marked(nm);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // A HotSpotNmethod instance can only reference a single nmethod</span>
<span class="line-added">+   // during its lifetime so simply clear it here.</span>
<span class="line-added">+   set_InstalledCode_address(mirror, 0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Klass* JVMCIEnv::asKlass(JVMCIObject obj) {</span>
<span class="line-added">+   return (Klass*) get_HotSpotResolvedObjectTypeImpl_metadataPointer(obj);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Method* JVMCIEnv::asMethod(JVMCIObject obj) {</span>
<span class="line-added">+   Method** metadataHandle = (Method**) get_HotSpotResolvedJavaMethodImpl_metadataHandle(obj);</span>
<span class="line-added">+   return *metadataHandle;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ConstantPool* JVMCIEnv::asConstantPool(JVMCIObject obj) {</span>
<span class="line-added">+   ConstantPool** metadataHandle = (ConstantPool**) get_HotSpotConstantPool_metadataHandle(obj);</span>
<span class="line-added">+   return *metadataHandle;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ CodeBlob* JVMCIEnv::get_code_blob(JVMCIObject obj, nmethodLocker&amp; locker) {</span>
<span class="line-added">+   address code = (address) get_InstalledCode_address(obj);</span>
<span class="line-added">+   if (code == NULL) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (isa_HotSpotNmethod(obj)) {</span>
<span class="line-added">+     nmethod* nm = NULL;</span>
<span class="line-added">+     {</span>
<span class="line-added">+       // Lookup the CodeBlob while holding the CodeCache_lock to ensure the nmethod can&#39;t be freed</span>
<span class="line-added">+       // by nmethod::flush while we&#39;re interrogating it.</span>
<span class="line-added">+       MutexLocker cm_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+       CodeBlob* cb = CodeCache::find_blob_unsafe(code);</span>
<span class="line-added">+       if (cb == (CodeBlob*) code) {</span>
<span class="line-added">+         nmethod* the_nm = cb-&gt;as_nmethod_or_null();</span>
<span class="line-added">+         if (the_nm != NULL &amp;&amp; the_nm-&gt;is_alive()) {</span>
<span class="line-added">+           // Lock the nmethod to stop any further transitions by the sweeper.  It&#39;s still possible</span>
<span class="line-added">+           // for this code to execute in the middle of the sweeping of the nmethod but that will be</span>
<span class="line-added">+           // handled below.</span>
<span class="line-added">+           locker.set_code(nm, true);</span>
<span class="line-added">+           nm = the_nm;</span>
          }
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (nm != NULL) {</span>
<span class="line-added">+       // We found the nmethod but it could be in the process of being freed.  Check the state of the</span>
<span class="line-added">+       // nmethod while holding the CompiledMethod_lock.  This ensures that any transitions by other</span>
<span class="line-added">+       // threads have seen the is_locked_by_vm() update above.</span>
<span class="line-added">+       MutexLocker cm_lock(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+       if (!nm-&gt;is_alive()) {</span>
<span class="line-added">+         //  It was alive when we looked it up but it&#39;s no longer alive so release it.</span>
<span class="line-added">+         locker.set_code(NULL);</span>
<span class="line-added">+         nm = NULL;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     jlong compile_id_snapshot = get_HotSpotNmethod_compileIdSnapshot(obj);</span>
<span class="line-modified">!     if (compile_id_snapshot != 0L) {</span>
<span class="line-modified">!       // Found a live nmethod with the same address, make sure it&#39;s the same nmethod</span>
<span class="line-modified">!       if (nm == (nmethod*) code &amp;&amp; nm-&gt;compile_id() == compile_id_snapshot &amp;&amp; nm-&gt;is_alive()) {</span>
<span class="line-modified">!         if (nm-&gt;is_not_entrant()) {</span>
<span class="line-modified">!           // Zero the entry point so that the nmethod</span>
<span class="line-modified">!           // cannot be invoked by the mirror but can</span>
<span class="line-modified">!           // still be deoptimized.</span>
<span class="line-modified">!           set_InstalledCode_entryPoint(obj, 0);</span>
          }
<span class="line-modified">!         return nm;</span>
        }
<span class="line-modified">!       // The HotSpotNmethod no longer refers to a valid nmethod so clear the state</span>
<span class="line-added">+       locker.set_code(NULL);</span>
<span class="line-added">+       nm = NULL;</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     if (nm == NULL) {</span>
<span class="line-added">+       // The HotSpotNmethod was pointing at some nmethod but the nmethod is no longer valid, so</span>
<span class="line-added">+       // clear the InstalledCode fields of this HotSpotNmethod so that it no longer refers to a</span>
<span class="line-added">+       // nmethod in the code cache.</span>
<span class="line-added">+       set_InstalledCode_address(obj, 0);</span>
<span class="line-added">+       set_InstalledCode_entryPoint(obj, 0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return nm;</span>
    }
  
<span class="line-modified">!   CodeBlob* cb = (CodeBlob*) code;</span>
<span class="line-modified">!   assert(!cb-&gt;is_nmethod(), &quot;unexpected nmethod&quot;);</span>
<span class="line-modified">!   return cb;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ nmethod* JVMCIEnv::get_nmethod(JVMCIObject obj, nmethodLocker&amp; locker) {</span>
<span class="line-added">+   CodeBlob* cb = get_code_blob(obj, locker);</span>
<span class="line-added">+   if (cb != NULL) {</span>
<span class="line-added">+     return cb-&gt;as_nmethod_or_null();</span>
    }
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! // Generate implementations for the initialize, new, isa, get and set methods for all the types and</span>
<span class="line-modified">! // fields declared in the JVMCI_CLASSES_DO macro.</span>
  
<span class="line-modified">! #define START_CLASS(className, fullClassName)                                                                        \</span>
<span class="line-modified">!   void JVMCIEnv::className##_initialize(JVMCI_TRAPS) {                                                               \</span>
<span class="line-modified">!     if (is_hotspot()) {                                                                                              \</span>
<span class="line-modified">!       HotSpotJVMCI::className::initialize(JVMCI_CHECK);                                                              \</span>
<span class="line-modified">!     } else {                                                                                                         \</span>
<span class="line-modified">!       JNIJVMCI::className::initialize(JVMCI_CHECK);                                                                  \</span>
<span class="line-added">+     }                                                                                                                \</span>
<span class="line-added">+   }                                                                                                                  \</span>
<span class="line-added">+   JVMCIObjectArray JVMCIEnv::new_##className##_array(int length, JVMCI_TRAPS) {                                      \</span>
<span class="line-added">+     if (is_hotspot()) {                                                                                              \</span>
<span class="line-added">+       Thread* THREAD = Thread::current();                                                                            \</span>
<span class="line-added">+       objArrayOop array = oopFactory::new_objArray(HotSpotJVMCI::className::klass(), length, CHECK_(JVMCIObject())); \</span>
<span class="line-added">+       return (JVMCIObjectArray) wrap(array);                                                                         \</span>
<span class="line-added">+     } else {                                                                                                         \</span>
<span class="line-added">+       JNIAccessMark jni(this);                                                                                       \</span>
<span class="line-added">+       jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::className::clazz(), NULL);                       \</span>
<span class="line-added">+       return wrap(result);                                                                                           \</span>
<span class="line-added">+     }                                                                                                                \</span>
<span class="line-added">+   }                                                                                                                  \</span>
<span class="line-added">+   bool JVMCIEnv::isa_##className(JVMCIObject object) {                                                               \</span>
<span class="line-added">+     if (is_hotspot()) {                                                                                              \</span>
<span class="line-added">+       return HotSpotJVMCI::className::is_instance(this, object);                                                     \</span>
<span class="line-added">+     } else {                                                                                                         \</span>
<span class="line-added">+       return JNIJVMCI::className::is_instance(this, object);                                                         \</span>
<span class="line-added">+     }                                                                                                                \</span>
    }
  
<span class="line-modified">! #define END_CLASS</span>
<span class="line-modified">! </span>
<span class="line-added">+ #define FIELD(className, name, type, accessor, cast)                 \</span>
<span class="line-added">+   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {         \</span>
<span class="line-added">+     if (is_hotspot()) {                                              \</span>
<span class="line-added">+       return HotSpotJVMCI::className::get_##name(this, obj);         \</span>
<span class="line-added">+     } else {                                                         \</span>
<span class="line-added">+       return JNIJVMCI::className::get_##name(this, obj);             \</span>
<span class="line-added">+     }                                                                \</span>
<span class="line-added">+   }                                                                  \</span>
<span class="line-added">+   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) { \</span>
<span class="line-added">+     if (is_hotspot()) {                                              \</span>
<span class="line-added">+       HotSpotJVMCI::className::set_##name(this, obj, x);             \</span>
<span class="line-added">+     } else {                                                         \</span>
<span class="line-added">+       JNIJVMCI::className::set_##name(this, obj, x);                 \</span>
<span class="line-added">+     }                                                                \</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define EMPTY_CAST</span>
<span class="line-added">+ #define CHAR_FIELD(className, name)                    FIELD(className, name, jchar, Char, EMPTY_CAST)</span>
<span class="line-added">+ #define INT_FIELD(className, name)                     FIELD(className, name, jint, Int, EMPTY_CAST)</span>
<span class="line-added">+ #define BOOLEAN_FIELD(className, name)                 FIELD(className, name, jboolean, Boolean, EMPTY_CAST)</span>
<span class="line-added">+ #define LONG_FIELD(className, name)                    FIELD(className, name, jlong, Long, EMPTY_CAST)</span>
<span class="line-added">+ #define FLOAT_FIELD(className, name)                   FIELD(className, name, jfloat, Float, EMPTY_CAST)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define OBJECT_FIELD(className, name, signature)              OOPISH_FIELD(className, name, JVMCIObject, Object, EMPTY_CAST)</span>
<span class="line-added">+ #define OBJECTARRAY_FIELD(className, name, signature)         OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))</span>
<span class="line-added">+ #define PRIMARRAY_FIELD(className, name, signature)           OOPISH_FIELD(className, name, JVMCIPrimitiveArray, Object, (JVMCIPrimitiveArray))</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STATIC_OBJECT_FIELD(className, name, signature)       STATIC_OOPISH_FIELD(className, name, JVMCIObject, Object, (JVMCIObject))</span>
<span class="line-added">+ #define STATIC_OBJECTARRAY_FIELD(className, name, signature)  STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define OOPISH_FIELD(className, name, type, accessor, cast)           \</span>
<span class="line-added">+   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {          \</span>
<span class="line-added">+     if (is_hotspot()) {                                               \</span>
<span class="line-added">+       return HotSpotJVMCI::className::get_##name(this, obj);          \</span>
<span class="line-added">+     } else {                                                          \</span>
<span class="line-added">+       return JNIJVMCI::className::get_##name(this, obj);              \</span>
<span class="line-added">+     }                                                                 \</span>
<span class="line-added">+   }                                                                   \</span>
<span class="line-added">+   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) {  \</span>
<span class="line-added">+     if (is_hotspot()) {                                               \</span>
<span class="line-added">+       HotSpotJVMCI::className::set_##name(this, obj, x);              \</span>
<span class="line-added">+     } else {                                                          \</span>
<span class="line-added">+       JNIJVMCI::className::set_##name(this, obj, x);                  \</span>
<span class="line-added">+     }                                                                 \</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STATIC_OOPISH_FIELD(className, name, type, accessor, cast)    \</span>
<span class="line-added">+   type JVMCIEnv::get_##className##_##name() {                         \</span>
<span class="line-added">+     if (is_hotspot()) {                                               \</span>
<span class="line-added">+       return HotSpotJVMCI::className::get_##name(this);               \</span>
<span class="line-added">+     } else {                                                          \</span>
<span class="line-added">+       return JNIJVMCI::className::get_##name(this);                   \</span>
<span class="line-added">+     }                                                                 \</span>
<span class="line-added">+   }                                                                   \</span>
<span class="line-added">+   void JVMCIEnv::set_##className##_##name(type x) {                   \</span>
<span class="line-added">+     if (is_hotspot()) {                                               \</span>
<span class="line-added">+       HotSpotJVMCI::className::set_##name(this, x);                   \</span>
<span class="line-added">+     } else {                                                          \</span>
<span class="line-added">+       JNIJVMCI::className::set_##name(this, x);                       \</span>
<span class="line-added">+     }                                                                 \</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STATIC_PRIMITIVE_FIELD(className, name, type, accessor, cast) \</span>
<span class="line-added">+   type JVMCIEnv::get_##className##_##name() {                         \</span>
<span class="line-added">+     if (is_hotspot()) {                                               \</span>
<span class="line-added">+       return HotSpotJVMCI::className::get_##name(this);               \</span>
<span class="line-added">+     } else {                                                          \</span>
<span class="line-added">+       return JNIJVMCI::className::get_##name(this);                   \</span>
<span class="line-added">+     }                                                                 \</span>
<span class="line-added">+   }                                                                   \</span>
<span class="line-added">+   void JVMCIEnv::set_##className##_##name(type x) {                   \</span>
<span class="line-added">+     if (is_hotspot()) {                                               \</span>
<span class="line-added">+       HotSpotJVMCI::className::set_##name(this, x);                   \</span>
<span class="line-added">+     } else {                                                          \</span>
<span class="line-added">+       JNIJVMCI::className::set_##name(this, x);                       \</span>
<span class="line-added">+     }                                                                 \</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint, Int, EMPTY_CAST)</span>
<span class="line-added">+ #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean, Boolean, EMPTY_CAST)</span>
<span class="line-added">+ #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)</span>
<span class="line-added">+ #define CONSTRUCTOR(className, signature)</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef START_CLASS</span>
<span class="line-added">+ #undef END_CLASS</span>
<span class="line-added">+ #undef METHOD</span>
<span class="line-added">+ #undef CONSTRUCTOR</span>
<span class="line-added">+ #undef FIELD</span>
<span class="line-added">+ #undef CHAR_FIELD</span>
<span class="line-added">+ #undef INT_FIELD</span>
<span class="line-added">+ #undef BOOLEAN_FIELD</span>
<span class="line-added">+ #undef LONG_FIELD</span>
<span class="line-added">+ #undef FLOAT_FIELD</span>
<span class="line-added">+ #undef OBJECT_FIELD</span>
<span class="line-added">+ #undef PRIMARRAY_FIELD</span>
<span class="line-added">+ #undef OBJECTARRAY_FIELD</span>
<span class="line-added">+ #undef STATIC_OOPISH_FIELD</span>
<span class="line-added">+ #undef STATIC_OBJECT_FIELD</span>
<span class="line-added">+ #undef STATIC_OBJECTARRAY_FIELD</span>
<span class="line-added">+ #undef STATIC_INT_FIELD</span>
<span class="line-added">+ #undef STATIC_BOOLEAN_FIELD</span>
<span class="line-added">+ #undef EMPTY_CAST</span>
</pre>
<center><a href="jvmciCompilerToVMInit.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciEnv.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
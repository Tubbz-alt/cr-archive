<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jvmci/jvmciCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCodeInstaller.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCompiler.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCompiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -20,22 +20,15 @@</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;jvm.h&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;memory/oopFactory.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;memory/resourceArea.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;oops/oop.inline.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;runtime/javaCalls.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;runtime/handles.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;compiler/compileBroker.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;classfile/moduleEntry.hpp&quot;</span>
  #include &quot;jvmci/jvmciEnv.hpp&quot;
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;runtime/globals_extension.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  
  JVMCICompiler* JVMCICompiler::_instance = NULL;
  elapsedTimer JVMCICompiler::_codeInstallTimer;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -55,27 +48,28 @@</span>
  
    set_state(initialized);
  }
  
  void JVMCICompiler::bootstrap(TRAPS) {
<span class="udiff-line-added">+   assert(THREAD-&gt;is_Java_thread(), &quot;must be&quot;);</span>
    if (Arguments::mode() == Arguments::_int) {
      // Nothing to do in -Xint mode
      return;
    }
    _bootstrapping = true;
    ResourceMark rm;
    HandleMark hm;
    if (PrintBootstrap) {
      tty-&gt;print(&quot;Bootstrapping JVMCI&quot;);
    }
<span class="udiff-line-modified-removed">-   jlong start = os::javaTimeMillis();</span>
<span class="udiff-line-modified-added">+   jlong start = os::javaTimeNanos();</span>
  
    Array&lt;Method*&gt;* objectMethods = SystemDictionary::Object_klass()-&gt;methods();
    // Initialize compile queue with a selected set of methods.
    int len = objectMethods-&gt;length();
    for (int i = 0; i &lt; len; i++) {
<span class="udiff-line-modified-removed">-     methodHandle mh = objectMethods-&gt;at(i);</span>
<span class="udiff-line-modified-added">+     methodHandle mh(THREAD, objectMethods-&gt;at(i));</span>
      if (!mh-&gt;is_native() &amp;&amp; !mh-&gt;is_static() &amp;&amp; !mh-&gt;is_initializer()) {
        ResourceMark rm;
        int hot_count = 10; // TODO: what&#39;s the appropriate value?
        CompileBroker::compile_method(mh, InvocationEntryBci, CompLevel_full_optimization, mh, hot_count, CompileTask::Reason_Bootstrap, THREAD);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -85,11 +79,11 @@</span>
    bool first_round = true;
    int z = 0;
    do {
      // Loop until there is something in the queue.
      do {
<span class="udiff-line-modified-removed">-       os::sleep(THREAD, 100, true);</span>
<span class="udiff-line-modified-added">+       ((JavaThread*)THREAD)-&gt;sleep(100);</span>
        qsize = CompileBroker::queue_size(CompLevel_full_optimization);
      } while (!_bootstrap_compilation_request_handled &amp;&amp; first_round &amp;&amp; qsize == 0);
      first_round = false;
      if (PrintBootstrap) {
        while (z &lt; (_methods_compiled / 100)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98,128 +92,47 @@</span>
        }
      }
    } while (qsize != 0);
  
    if (PrintBootstrap) {
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot; in &quot; JLONG_FORMAT &quot; ms (compiled %d methods)&quot;, os::javaTimeMillis() - start, _methods_compiled);</span>
<span class="udiff-line-modified-added">+     tty-&gt;print_cr(&quot; in &quot; JLONG_FORMAT &quot; ms (compiled %d methods)&quot;,</span>
<span class="udiff-line-added">+                   (jlong)nanos_to_millis(os::javaTimeNanos() - start), _methods_compiled);</span>
    }
    _bootstrapping = false;
<span class="udiff-line-modified-removed">-   JVMCIRuntime::bootstrap_finished(CHECK);</span>
<span class="udiff-line-modified-added">+   JVMCI::compiler_runtime()-&gt;bootstrap_finished(CHECK);</span>
  }
  
<span class="udiff-line-modified-removed">- #define CHECK_EXIT THREAD); \</span>
<span class="udiff-line-modified-removed">- if (HAS_PENDING_EXCEPTION) { \</span>
<span class="udiff-line-modified-removed">-   char buf[256]; \</span>
<span class="udiff-line-modified-removed">-   jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="udiff-line-modified-removed">-   JVMCICompiler::exit_on_pending_exception(PENDING_EXCEPTION, buf); \</span>
<span class="udiff-line-modified-removed">-   return; \</span>
<span class="udiff-line-removed">- } \</span>
<span class="udiff-line-removed">- (void)(0</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JVMCICompiler::compile_method(const methodHandle&amp; method, int entry_bci, JVMCIEnv* env) {</span>
<span class="udiff-line-removed">-   JVMCI_EXCEPTION_CONTEXT</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bool is_osr = entry_bci != InvocationEntryBci;</span>
<span class="udiff-line-removed">-   if (_bootstrapping &amp;&amp; is_osr) {</span>
<span class="udiff-line-removed">-       // no OSR compilations during bootstrap - the compiler is just too slow at this point,</span>
<span class="udiff-line-removed">-       // and we know that there are no endless loops</span>
<span class="udiff-line-removed">-       env-&gt;set_failure(true, &quot;No OSR during boostrap&quot;);</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-modified-added">+ bool JVMCICompiler::force_comp_at_level_simple(const methodHandle&amp; method) {</span>
<span class="udiff-line-modified-added">+   if (UseJVMCINativeLibrary) {</span>
<span class="udiff-line-modified-added">+     // This mechanism exists to force compilation of a JVMCI compiler by C1</span>
<span class="udiff-line-modified-added">+     // to reduces the compilation time spent on the JVMCI compiler itself. In</span>
<span class="udiff-line-modified-added">+     // +UseJVMCINativeLibrary mode, the JVMCI compiler is AOT compiled.</span>
<span class="udiff-line-modified-added">+     return false;</span>
    }
  
<span class="udiff-line-modified-removed">-   JVMCIRuntime::initialize_well_known_classes(CHECK_EXIT);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   HandleMark hm;</span>
<span class="udiff-line-removed">-   Handle receiver = JVMCIRuntime::get_HotSpotJVMCIRuntime(CHECK_EXIT);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   JavaValue method_result(T_OBJECT);</span>
<span class="udiff-line-removed">-   JavaCallArguments args;</span>
<span class="udiff-line-removed">-   args.push_long((jlong) (address) method());</span>
<span class="udiff-line-removed">-   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(),</span>
<span class="udiff-line-removed">-                          vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, THREAD);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   JavaValue result(T_OBJECT);</span>
<span class="udiff-line-removed">-   if (!HAS_PENDING_EXCEPTION) {</span>
<span class="udiff-line-removed">-     JavaCallArguments args;</span>
<span class="udiff-line-removed">-     args.push_oop(receiver);</span>
<span class="udiff-line-removed">-     args.push_oop(Handle(THREAD, (oop)method_result.get_jobject()));</span>
<span class="udiff-line-removed">-     args.push_int(entry_bci);</span>
<span class="udiff-line-removed">-     args.push_long((jlong) (address) env);</span>
<span class="udiff-line-removed">-     args.push_int(env-&gt;task()-&gt;compile_id());</span>
<span class="udiff-line-removed">-     JavaCalls::call_special(&amp;result, receiver-&gt;klass(),</span>
<span class="udiff-line-removed">-                             vmSymbols::compileMethod_name(), vmSymbols::compileMethod_signature(), &amp;args, THREAD);</span>
<span class="udiff-line-modified-added">+   if (_bootstrapping) {</span>
<span class="udiff-line-modified-added">+     // When bootstrapping, the JVMCI compiler can compile its own methods.</span>
<span class="udiff-line-modified-added">+     return false;</span>
    }
  
<span class="udiff-line-modified-removed">-   // An uncaught exception was thrown during compilation.  Generally these</span>
<span class="udiff-line-modified-removed">-   // should be handled by the Java code in some useful way but if they leak</span>
<span class="udiff-line-modified-removed">-   // through to here report them instead of dying or silently ignoring them.</span>
<span class="udiff-line-modified-removed">-   if (HAS_PENDING_EXCEPTION) {</span>
<span class="udiff-line-modified-removed">-     Handle exception(THREAD, PENDING_EXCEPTION);</span>
<span class="udiff-line-modified-removed">-     CLEAR_PENDING_EXCEPTION;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     java_lang_Throwable::java_printStackTrace(exception, THREAD);</span>
<span class="udiff-line-modified-removed">-     if (HAS_PENDING_EXCEPTION) {</span>
<span class="udiff-line-modified-removed">-       CLEAR_PENDING_EXCEPTION;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     env-&gt;set_failure(false, &quot;unexpected exception thrown&quot;);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     oop result_object = (oop) result.get_jobject();</span>
<span class="udiff-line-removed">-     if (result_object != NULL) {</span>
<span class="udiff-line-removed">-       oop failure_message = HotSpotCompilationRequestResult::failureMessage(result_object);</span>
<span class="udiff-line-removed">-       if (failure_message != NULL) {</span>
<span class="udiff-line-removed">-         // Copy failure reason into resource memory first ...</span>
<span class="udiff-line-removed">-         const char* failure_reason = java_lang_String::as_utf8_string(failure_message);</span>
<span class="udiff-line-removed">-         // ... and then into the C heap.</span>
<span class="udiff-line-removed">-         failure_reason = os::strdup(failure_reason, mtCompiler);</span>
<span class="udiff-line-removed">-         bool retryable = HotSpotCompilationRequestResult::retry(result_object) != 0;</span>
<span class="udiff-line-removed">-         env-&gt;set_failure(retryable, failure_reason, true);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         if (env-&gt;task()-&gt;code() == NULL) {</span>
<span class="udiff-line-removed">-           env-&gt;set_failure(true, &quot;no nmethod produced&quot;);</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           env-&gt;task()-&gt;set_num_inlined_bytecodes(HotSpotCompilationRequestResult::inlinedBytecodes(result_object));</span>
<span class="udiff-line-removed">-           Atomic::inc(&amp;_methods_compiled);</span>
<span class="udiff-line-modified-added">+   JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="udiff-line-modified-added">+   if (runtime != NULL &amp;&amp; runtime-&gt;is_HotSpotJVMCIRuntime_initialized()) {</span>
<span class="udiff-line-modified-added">+     JavaThread* thread = JavaThread::current();</span>
<span class="udiff-line-modified-added">+     HandleMark hm(thread);</span>
<span class="udiff-line-modified-added">+     THREAD_JVMCIENV(thread);</span>
<span class="udiff-line-modified-added">+     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(JVMCIENV);</span>
<span class="udiff-line-modified-added">+     objArrayHandle excludeModules(thread, HotSpotJVMCI::HotSpotJVMCIRuntime::excludeFromJVMCICompilation(JVMCIENV, HotSpotJVMCI::resolve(receiver)));</span>
<span class="udiff-line-modified-added">+     if (excludeModules.not_null()) {</span>
<span class="udiff-line-modified-added">+       ModuleEntry* moduleEntry = method-&gt;method_holder()-&gt;module();</span>
<span class="udiff-line-modified-added">+       for (int i = 0; i &lt; excludeModules-&gt;length(); i++) {</span>
<span class="udiff-line-modified-added">+         if (excludeModules-&gt;obj_at(i) == moduleEntry-&gt;module()) {</span>
<span class="udiff-line-modified-added">+           return true;</span>
          }
        }
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       assert(false, &quot;JVMCICompiler.compileMethod should always return non-null&quot;);</span>
      }
    }
<span class="udiff-line-modified-removed">-   if (_bootstrapping) {</span>
<span class="udiff-line-removed">-     _bootstrap_compilation_request_handled = true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- CompLevel JVMCIRuntime::adjust_comp_level(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread) {</span>
<span class="udiff-line-removed">-   if (!thread-&gt;adjusting_comp_level()) {</span>
<span class="udiff-line-removed">-     thread-&gt;set_adjusting_comp_level(true);</span>
<span class="udiff-line-removed">-     level = adjust_comp_level_inner(method, is_osr, level, thread);</span>
<span class="udiff-line-removed">-     thread-&gt;set_adjusting_comp_level(false);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return level;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JVMCICompiler::exit_on_pending_exception(oop exception, const char* message) {</span>
<span class="udiff-line-removed">-   JavaThread* THREAD = JavaThread::current();</span>
<span class="udiff-line-removed">-   CLEAR_PENDING_EXCEPTION;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static volatile int report_error = 0;</span>
<span class="udiff-line-removed">-   if (!report_error &amp;&amp; Atomic::cmpxchg(1, &amp;report_error, 0) == 0) {</span>
<span class="udiff-line-removed">-     // Only report an error once</span>
<span class="udiff-line-removed">-     tty-&gt;print_raw_cr(message);</span>
<span class="udiff-line-removed">-     Handle ex(THREAD, exception);</span>
<span class="udiff-line-removed">-     java_lang_Throwable::java_printStackTrace(ex, THREAD);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // Allow error reporting thread to print the stack trace.  Windows</span>
<span class="udiff-line-removed">-     // doesn&#39;t allow uninterruptible wait for JavaThreads</span>
<span class="udiff-line-removed">-     const bool interruptible = true;</span>
<span class="udiff-line-removed">-     os::sleep(THREAD, 200, interruptible);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   before_exit(THREAD);</span>
<span class="udiff-line-removed">-   vm_exit(-1);</span>
<span class="udiff-line-modified-added">+   return false;</span>
  }
  
  // Compilation entry point for methods
  void JVMCICompiler::compile_method(ciEnv* env, ciMethod* target, int entry_bci, DirectiveSet* directive) {
    ShouldNotReachHere();
</pre>
<center><a href="jvmciCodeInstaller.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCompiler.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
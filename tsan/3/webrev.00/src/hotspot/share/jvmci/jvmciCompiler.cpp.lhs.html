<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 25 #include &quot;jvm.h&quot;</span>
<span class="line-modified"> 26 #include &quot;memory/oopFactory.hpp&quot;</span>
<span class="line-removed"> 27 #include &quot;memory/resourceArea.hpp&quot;</span>
<span class="line-removed"> 28 #include &quot;oops/oop.inline.hpp&quot;</span>
<span class="line-removed"> 29 #include &quot;runtime/javaCalls.hpp&quot;</span>
<span class="line-removed"> 30 #include &quot;runtime/handles.hpp&quot;</span>
<span class="line-removed"> 31 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
<span class="line-removed"> 32 #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
 33 #include &quot;jvmci/jvmciEnv.hpp&quot;
 34 #include &quot;jvmci/jvmciRuntime.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 35 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
<span class="line-removed"> 36 #include &quot;runtime/globals_extension.hpp&quot;</span>
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 
 39 JVMCICompiler* JVMCICompiler::_instance = NULL;
 40 elapsedTimer JVMCICompiler::_codeInstallTimer;
 41 
 42 JVMCICompiler::JVMCICompiler() : AbstractCompiler(compiler_jvmci) {
 43   _bootstrapping = false;
 44   _bootstrap_compilation_request_handled = false;
 45   _methods_compiled = 0;
 46   assert(_instance == NULL, &quot;only one instance allowed&quot;);
 47   _instance = this;
 48 }
 49 
 50 // Initialization
 51 void JVMCICompiler::initialize() {
 52   if (!UseCompiler || !EnableJVMCI || !UseJVMCICompiler || !should_perform_init()) {
 53     return;
 54   }
 55 
 56   set_state(initialized);
 57 }
 58 
 59 void JVMCICompiler::bootstrap(TRAPS) {
<a name="4" id="anc4"></a>
 60   if (Arguments::mode() == Arguments::_int) {
 61     // Nothing to do in -Xint mode
 62     return;
 63   }
 64   _bootstrapping = true;
 65   ResourceMark rm;
 66   HandleMark hm;
 67   if (PrintBootstrap) {
 68     tty-&gt;print(&quot;Bootstrapping JVMCI&quot;);
 69   }
<a name="5" id="anc5"></a><span class="line-modified"> 70   jlong start = os::javaTimeMillis();</span>
 71 
 72   Array&lt;Method*&gt;* objectMethods = SystemDictionary::Object_klass()-&gt;methods();
 73   // Initialize compile queue with a selected set of methods.
 74   int len = objectMethods-&gt;length();
 75   for (int i = 0; i &lt; len; i++) {
<a name="6" id="anc6"></a><span class="line-modified"> 76     methodHandle mh = objectMethods-&gt;at(i);</span>
 77     if (!mh-&gt;is_native() &amp;&amp; !mh-&gt;is_static() &amp;&amp; !mh-&gt;is_initializer()) {
 78       ResourceMark rm;
 79       int hot_count = 10; // TODO: what&#39;s the appropriate value?
 80       CompileBroker::compile_method(mh, InvocationEntryBci, CompLevel_full_optimization, mh, hot_count, CompileTask::Reason_Bootstrap, THREAD);
 81     }
 82   }
 83 
 84   int qsize;
 85   bool first_round = true;
 86   int z = 0;
 87   do {
 88     // Loop until there is something in the queue.
 89     do {
<a name="7" id="anc7"></a><span class="line-modified"> 90       os::sleep(THREAD, 100, true);</span>
 91       qsize = CompileBroker::queue_size(CompLevel_full_optimization);
 92     } while (!_bootstrap_compilation_request_handled &amp;&amp; first_round &amp;&amp; qsize == 0);
 93     first_round = false;
 94     if (PrintBootstrap) {
 95       while (z &lt; (_methods_compiled / 100)) {
 96         ++z;
 97         tty-&gt;print_raw(&quot;.&quot;);
 98       }
 99     }
100   } while (qsize != 0);
101 
102   if (PrintBootstrap) {
<a name="8" id="anc8"></a><span class="line-modified">103     tty-&gt;print_cr(&quot; in &quot; JLONG_FORMAT &quot; ms (compiled %d methods)&quot;, os::javaTimeMillis() - start, _methods_compiled);</span>

104   }
105   _bootstrapping = false;
<a name="9" id="anc9"></a><span class="line-modified">106   JVMCIRuntime::bootstrap_finished(CHECK);</span>
107 }
108 
<a name="10" id="anc10"></a><span class="line-modified">109 #define CHECK_EXIT THREAD); \</span>
<span class="line-modified">110 if (HAS_PENDING_EXCEPTION) { \</span>
<span class="line-modified">111   char buf[256]; \</span>
<span class="line-modified">112   jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="line-modified">113   JVMCICompiler::exit_on_pending_exception(PENDING_EXCEPTION, buf); \</span>
<span class="line-modified">114   return; \</span>
<span class="line-removed">115 } \</span>
<span class="line-removed">116 (void)(0</span>
<span class="line-removed">117 </span>
<span class="line-removed">118 void JVMCICompiler::compile_method(const methodHandle&amp; method, int entry_bci, JVMCIEnv* env) {</span>
<span class="line-removed">119   JVMCI_EXCEPTION_CONTEXT</span>
<span class="line-removed">120 </span>
<span class="line-removed">121   bool is_osr = entry_bci != InvocationEntryBci;</span>
<span class="line-removed">122   if (_bootstrapping &amp;&amp; is_osr) {</span>
<span class="line-removed">123       // no OSR compilations during bootstrap - the compiler is just too slow at this point,</span>
<span class="line-removed">124       // and we know that there are no endless loops</span>
<span class="line-removed">125       env-&gt;set_failure(true, &quot;No OSR during boostrap&quot;);</span>
<span class="line-removed">126       return;</span>
127   }
128 
<a name="11" id="anc11"></a><span class="line-modified">129   JVMCIRuntime::initialize_well_known_classes(CHECK_EXIT);</span>
<span class="line-modified">130 </span>
<span class="line-modified">131   HandleMark hm;</span>
<span class="line-removed">132   Handle receiver = JVMCIRuntime::get_HotSpotJVMCIRuntime(CHECK_EXIT);</span>
<span class="line-removed">133 </span>
<span class="line-removed">134   JavaValue method_result(T_OBJECT);</span>
<span class="line-removed">135   JavaCallArguments args;</span>
<span class="line-removed">136   args.push_long((jlong) (address) method());</span>
<span class="line-removed">137   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(),</span>
<span class="line-removed">138                          vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, THREAD);</span>
<span class="line-removed">139 </span>
<span class="line-removed">140   JavaValue result(T_OBJECT);</span>
<span class="line-removed">141   if (!HAS_PENDING_EXCEPTION) {</span>
<span class="line-removed">142     JavaCallArguments args;</span>
<span class="line-removed">143     args.push_oop(receiver);</span>
<span class="line-removed">144     args.push_oop(Handle(THREAD, (oop)method_result.get_jobject()));</span>
<span class="line-removed">145     args.push_int(entry_bci);</span>
<span class="line-removed">146     args.push_long((jlong) (address) env);</span>
<span class="line-removed">147     args.push_int(env-&gt;task()-&gt;compile_id());</span>
<span class="line-removed">148     JavaCalls::call_special(&amp;result, receiver-&gt;klass(),</span>
<span class="line-removed">149                             vmSymbols::compileMethod_name(), vmSymbols::compileMethod_signature(), &amp;args, THREAD);</span>
150   }
151 
<a name="12" id="anc12"></a><span class="line-modified">152   // An uncaught exception was thrown during compilation.  Generally these</span>
<span class="line-modified">153   // should be handled by the Java code in some useful way but if they leak</span>
<span class="line-modified">154   // through to here report them instead of dying or silently ignoring them.</span>
<span class="line-modified">155   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-modified">156     Handle exception(THREAD, PENDING_EXCEPTION);</span>
<span class="line-modified">157     CLEAR_PENDING_EXCEPTION;</span>
<span class="line-modified">158 </span>
<span class="line-modified">159     java_lang_Throwable::java_printStackTrace(exception, THREAD);</span>
<span class="line-modified">160     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-modified">161       CLEAR_PENDING_EXCEPTION;</span>
<span class="line-modified">162     }</span>
<span class="line-modified">163 </span>
<span class="line-removed">164     env-&gt;set_failure(false, &quot;unexpected exception thrown&quot;);</span>
<span class="line-removed">165   } else {</span>
<span class="line-removed">166     oop result_object = (oop) result.get_jobject();</span>
<span class="line-removed">167     if (result_object != NULL) {</span>
<span class="line-removed">168       oop failure_message = HotSpotCompilationRequestResult::failureMessage(result_object);</span>
<span class="line-removed">169       if (failure_message != NULL) {</span>
<span class="line-removed">170         // Copy failure reason into resource memory first ...</span>
<span class="line-removed">171         const char* failure_reason = java_lang_String::as_utf8_string(failure_message);</span>
<span class="line-removed">172         // ... and then into the C heap.</span>
<span class="line-removed">173         failure_reason = os::strdup(failure_reason, mtCompiler);</span>
<span class="line-removed">174         bool retryable = HotSpotCompilationRequestResult::retry(result_object) != 0;</span>
<span class="line-removed">175         env-&gt;set_failure(retryable, failure_reason, true);</span>
<span class="line-removed">176       } else {</span>
<span class="line-removed">177         if (env-&gt;task()-&gt;code() == NULL) {</span>
<span class="line-removed">178           env-&gt;set_failure(true, &quot;no nmethod produced&quot;);</span>
<span class="line-removed">179         } else {</span>
<span class="line-removed">180           env-&gt;task()-&gt;set_num_inlined_bytecodes(HotSpotCompilationRequestResult::inlinedBytecodes(result_object));</span>
<span class="line-removed">181           Atomic::inc(&amp;_methods_compiled);</span>
182         }
183       }
<a name="13" id="anc13"></a><span class="line-removed">184     } else {</span>
<span class="line-removed">185       assert(false, &quot;JVMCICompiler.compileMethod should always return non-null&quot;);</span>
186     }
187   }
<a name="14" id="anc14"></a><span class="line-modified">188   if (_bootstrapping) {</span>
<span class="line-removed">189     _bootstrap_compilation_request_handled = true;</span>
<span class="line-removed">190   }</span>
<span class="line-removed">191 }</span>
<span class="line-removed">192 </span>
<span class="line-removed">193 CompLevel JVMCIRuntime::adjust_comp_level(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread) {</span>
<span class="line-removed">194   if (!thread-&gt;adjusting_comp_level()) {</span>
<span class="line-removed">195     thread-&gt;set_adjusting_comp_level(true);</span>
<span class="line-removed">196     level = adjust_comp_level_inner(method, is_osr, level, thread);</span>
<span class="line-removed">197     thread-&gt;set_adjusting_comp_level(false);</span>
<span class="line-removed">198   }</span>
<span class="line-removed">199   return level;</span>
<span class="line-removed">200 }</span>
<span class="line-removed">201 </span>
<span class="line-removed">202 void JVMCICompiler::exit_on_pending_exception(oop exception, const char* message) {</span>
<span class="line-removed">203   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-removed">204   CLEAR_PENDING_EXCEPTION;</span>
<span class="line-removed">205 </span>
<span class="line-removed">206   static volatile int report_error = 0;</span>
<span class="line-removed">207   if (!report_error &amp;&amp; Atomic::cmpxchg(1, &amp;report_error, 0) == 0) {</span>
<span class="line-removed">208     // Only report an error once</span>
<span class="line-removed">209     tty-&gt;print_raw_cr(message);</span>
<span class="line-removed">210     Handle ex(THREAD, exception);</span>
<span class="line-removed">211     java_lang_Throwable::java_printStackTrace(ex, THREAD);</span>
<span class="line-removed">212   } else {</span>
<span class="line-removed">213     // Allow error reporting thread to print the stack trace.  Windows</span>
<span class="line-removed">214     // doesn&#39;t allow uninterruptible wait for JavaThreads</span>
<span class="line-removed">215     const bool interruptible = true;</span>
<span class="line-removed">216     os::sleep(THREAD, 200, interruptible);</span>
<span class="line-removed">217   }</span>
<span class="line-removed">218 </span>
<span class="line-removed">219   before_exit(THREAD);</span>
<span class="line-removed">220   vm_exit(-1);</span>
221 }
222 
223 // Compilation entry point for methods
224 void JVMCICompiler::compile_method(ciEnv* env, ciMethod* target, int entry_bci, DirectiveSet* directive) {
225   ShouldNotReachHere();
226 }
227 
228 // Print compilation timers and statistics
229 void JVMCICompiler::print_timers() {
230   print_compilation_timers();
231 }
232 
233 // Print compilation timers and statistics
234 void JVMCICompiler::print_compilation_timers() {
235   TRACE_jvmci_1(&quot;JVMCICompiler::print_timers&quot;);
236   tty-&gt;print_cr(&quot;       JVMCI code install time:        %6.3f s&quot;,    _codeInstallTimer.seconds());
237 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
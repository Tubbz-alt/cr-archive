<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jvmci/jvmciRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciRuntime.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmci_globals.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciRuntime.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,27 +22,72 @@</span>
   */
  
  #ifndef SHARE_JVMCI_JVMCIRUNTIME_HPP
  #define SHARE_JVMCI_JVMCIRUNTIME_HPP
  
<span class="udiff-line-modified-removed">- #include &quot;interpreter/interpreter.hpp&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;memory/allocation.hpp&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;runtime/arguments.hpp&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;runtime/deoptimization.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;code/nmethod.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;jvmci/jvmci.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;jvmci/jvmciExceptions.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;jvmci/jvmciObject.hpp&quot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ class JVMCIEnv;</span>
<span class="udiff-line-added">+ class JVMCICompiler;</span>
<span class="udiff-line-added">+ class JVMCICompileState;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Encapsulates the JVMCI metadata for an nmethod.</span>
<span class="udiff-line-added">+ // JVMCINMethodData objects are inlined into nmethods</span>
<span class="udiff-line-added">+ // at nmethod::_jvmci_data_offset.</span>
<span class="udiff-line-added">+ class JVMCINMethodData {</span>
<span class="udiff-line-added">+   // Index for the HotSpotNmethod mirror in the nmethod&#39;s oops table.</span>
<span class="udiff-line-added">+   // This is -1 if there is no mirror in the oops table.</span>
<span class="udiff-line-added">+   int _nmethod_mirror_index;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Is HotSpotNmethod.name non-null? If so, the value is</span>
<span class="udiff-line-added">+   // embedded in the end of this object.</span>
<span class="udiff-line-added">+   bool _has_name;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Address of the failed speculations list to which a speculation</span>
<span class="udiff-line-added">+   // is appended when it causes a deoptimization.</span>
<span class="udiff-line-added">+   FailedSpeculation** _failed_speculations;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   // Computes the size of a JVMCINMethodData object</span>
<span class="udiff-line-added">+   static int compute_size(const char* nmethod_mirror_name) {</span>
<span class="udiff-line-added">+     int size = sizeof(JVMCINMethodData);</span>
<span class="udiff-line-added">+     if (nmethod_mirror_name != NULL) {</span>
<span class="udiff-line-added">+       size += (int) strlen(nmethod_mirror_name) + 1;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return size;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void initialize(int nmethod_mirror_index,</span>
<span class="udiff-line-added">+              const char* name,</span>
<span class="udiff-line-added">+              FailedSpeculation** failed_speculations);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Adds `speculation` to the failed speculations list.</span>
<span class="udiff-line-added">+   void add_failed_speculation(nmethod* nm, jlong speculation);</span>
  
<span class="udiff-line-modified-removed">- #define JVMCI_ERROR(...)       \</span>
<span class="udiff-line-modified-removed">-   { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return; }</span>
<span class="udiff-line-modified-added">+   // Gets the JVMCI name of the nmethod (which may be NULL).</span>
<span class="udiff-line-modified-added">+   const char* name() { return _has_name ? (char*)(((address) this) + sizeof(JVMCINMethodData)) : NULL; }</span>
  
<span class="udiff-line-modified-removed">- #define JVMCI_ERROR_(ret, ...) \</span>
<span class="udiff-line-modified-removed">-   { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return ret; }</span>
<span class="udiff-line-modified-added">+   // Clears the HotSpotNmethod.address field in the  mirror. If nm</span>
<span class="udiff-line-modified-added">+   // is dead, the HotSpotNmethod.entryPoint field is also cleared.</span>
<span class="udiff-line-added">+   void invalidate_nmethod_mirror(nmethod* nm);</span>
  
<span class="udiff-line-modified-removed">- #define JVMCI_ERROR_0(...)    JVMCI_ERROR_(0, __VA_ARGS__)</span>
<span class="udiff-line-modified-removed">- #define JVMCI_ERROR_NULL(...) JVMCI_ERROR_(NULL, __VA_ARGS__)</span>
<span class="udiff-line-modified-removed">- #define JVMCI_ERROR_OK(...)   JVMCI_ERROR_(JVMCIEnv::ok, __VA_ARGS__)</span>
<span class="udiff-line-modified-removed">- #define CHECK_OK              CHECK_(JVMCIEnv::ok)</span>
<span class="udiff-line-modified-added">+   // Gets the mirror from nm&#39;s oops table.</span>
<span class="udiff-line-modified-added">+   oop get_nmethod_mirror(nmethod* nm, bool phantom_ref);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Sets the mirror in nm&#39;s oops table.</span>
<span class="udiff-line-added">+   void set_nmethod_mirror(nmethod* nm, oop mirror);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Clears the mirror in nm&#39;s oops table.</span>
<span class="udiff-line-added">+   void clear_nmethod_mirror(nmethod* nm);</span>
<span class="udiff-line-added">+ };</span>
  
<span class="udiff-line-modified-removed">- class JVMCIRuntime: public AllStatic {</span>
<span class="udiff-line-modified-added">+ // A top level class that represents an initialized JVMCI runtime.</span>
<span class="udiff-line-added">+ // There is one instance of this class per HotSpotJVMCIRuntime object.</span>
<span class="udiff-line-added">+ class JVMCIRuntime: public CHeapObj&lt;mtJVMCI&gt; {</span>
   public:
    // Constants describing whether JVMCI wants to be able to adjust the compilation
    // level selected for a method by the VM compilation policy and if so, based on
    // what information about the method being schedule for compilation.
    enum CompLevelAdjustment {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -50,78 +95,192 @@</span>
       by_holder = 1,        // adjust based on declaring class of method
       by_full_signature = 2 // adjust based on declaring class, name and signature of method
    };
  
   private:
<span class="udiff-line-modified-removed">-   static jobject _HotSpotJVMCIRuntime_instance;</span>
<span class="udiff-line-modified-removed">-   static bool _HotSpotJVMCIRuntime_initialized;</span>
<span class="udiff-line-modified-removed">-   static bool _well_known_classes_initialized;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   static CompLevelAdjustment _comp_level_adjustment;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   static bool _shutdown_called;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   static CompLevel adjust_comp_level_inner(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread);</span>
<span class="udiff-line-modified-added">+   volatile bool _being_initialized;</span>
<span class="udiff-line-modified-added">+   volatile bool _initialized;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   JVMCIObject _HotSpotJVMCIRuntime_instance;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   bool _shutdown_called;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   JVMCIObject create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   // Implementation methods for loading and constant pool access.</span>
<span class="udiff-line-added">+   static Klass* get_klass_by_name_impl(Klass*&amp; accessing_klass,</span>
<span class="udiff-line-added">+                                        const constantPoolHandle&amp; cpool,</span>
<span class="udiff-line-added">+                                        Symbol* klass_name,</span>
<span class="udiff-line-added">+                                        bool require_local);</span>
<span class="udiff-line-added">+   static Klass*   get_klass_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="udiff-line-added">+                                           int klass_index,</span>
<span class="udiff-line-added">+                                           bool&amp; is_accessible,</span>
<span class="udiff-line-added">+                                           Klass* loading_klass);</span>
<span class="udiff-line-added">+   static void   get_field_by_index_impl(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,</span>
<span class="udiff-line-added">+                                         int field_index);</span>
<span class="udiff-line-added">+   static Method*  get_method_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="udiff-line-added">+                                            int method_index, Bytecodes::Code bc,</span>
<span class="udiff-line-added">+                                            InstanceKlass* loading_klass);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Helper methods</span>
<span class="udiff-line-added">+   static bool       check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass);</span>
<span class="udiff-line-added">+   static Method*    lookup_method(InstanceKlass*  accessor,</span>
<span class="udiff-line-added">+                                   Klass*  holder,</span>
<span class="udiff-line-added">+                                   Symbol*         name,</span>
<span class="udiff-line-added">+                                   Symbol*         sig,</span>
<span class="udiff-line-added">+                                   Bytecodes::Code bc,</span>
<span class="udiff-line-added">+                                   constantTag     tag);</span>
  
   public:
<span class="udiff-line-modified-removed">-   static bool is_HotSpotJVMCIRuntime_initialized() {</span>
<span class="udiff-line-modified-removed">-     return _HotSpotJVMCIRuntime_initialized;</span>
<span class="udiff-line-modified-added">+   JVMCIRuntime() {</span>
<span class="udiff-line-modified-added">+     _initialized = false;</span>
<span class="udiff-line-added">+     _being_initialized = false;</span>
<span class="udiff-line-added">+     _shutdown_called = false;</span>
    }
  
    /**
<span class="udiff-line-modified-removed">-    * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary</span>
<span class="udiff-line-modified-added">+    * Compute offsets and construct any state required before executing JVMCI code.</span>
     */
<span class="udiff-line-modified-removed">-   static Handle get_HotSpotJVMCIRuntime(TRAPS);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static jobject get_HotSpotJVMCIRuntime_jobject(TRAPS) {</span>
<span class="udiff-line-removed">-     initialize_JVMCI(CHECK_NULL);</span>
<span class="udiff-line-removed">-     assert(_HotSpotJVMCIRuntime_initialized, &quot;must be&quot;);</span>
<span class="udiff-line-removed">-     return _HotSpotJVMCIRuntime_instance;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static Handle callStatic(const char* className, const char* methodName, const char* returnType, JavaCallArguments* args, TRAPS);</span>
<span class="udiff-line-modified-added">+   void initialize(JVMCIEnv* jvmciEnv);</span>
  
    /**
<span class="udiff-line-modified-removed">-    * Determines if the VM is sufficiently booted to initialize JVMCI.</span>
<span class="udiff-line-modified-added">+    * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary</span>
     */
<span class="udiff-line-modified-removed">-   static bool can_initialize_JVMCI();</span>
<span class="udiff-line-modified-added">+   JVMCIObject get_HotSpotJVMCIRuntime(JVMCI_TRAPS);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool is_HotSpotJVMCIRuntime_initialized() {</span>
<span class="udiff-line-added">+     return _HotSpotJVMCIRuntime_instance.is_non_null();</span>
<span class="udiff-line-added">+   }</span>
  
    /**
     * Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()
     */
<span class="udiff-line-modified-removed">-   static void initialize_JVMCI(TRAPS);</span>
<span class="udiff-line-modified-added">+   void initialize_JVMCI(JVMCI_TRAPS);</span>
  
    /**
     * Explicitly initialize HotSpotJVMCIRuntime itself
     */
<span class="udiff-line-modified-removed">-   static void initialize_HotSpotJVMCIRuntime(TRAPS);</span>
<span class="udiff-line-modified-added">+   void initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS);</span>
  
<span class="udiff-line-modified-removed">-   static void initialize_well_known_classes(TRAPS);</span>
<span class="udiff-line-modified-added">+   void call_getCompiler(TRAPS);</span>
  
<span class="udiff-line-modified-removed">-   static void metadata_do(void f(Metadata*));</span>
<span class="udiff-line-modified-added">+   void shutdown();</span>
  
<span class="udiff-line-modified-removed">-   static void shutdown(TRAPS);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static void bootstrap_finished(TRAPS);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static bool shutdown_called() {</span>
<span class="udiff-line-modified-added">+   bool shutdown_called() {</span>
      return _shutdown_called;
    }
  
<span class="udiff-line-added">+   void bootstrap_finished(TRAPS);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Look up a klass by name from a particular class loader (the accessor&#39;s).</span>
<span class="udiff-line-added">+   // If require_local, result must be defined in that class loader, or NULL.</span>
<span class="udiff-line-added">+   // If !require_local, a result from remote class loader may be reported,</span>
<span class="udiff-line-added">+   // if sufficient class loader constraints exist such that initiating</span>
<span class="udiff-line-added">+   // a class loading request from the given loader is bound to return</span>
<span class="udiff-line-added">+   // the class defined in the remote loader (or throw an error).</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // Return an unloaded klass if !require_local and no class at all is found.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // The CI treats a klass as loaded if it is consistently defined in</span>
<span class="udiff-line-added">+   // another loader, even if it hasn&#39;t yet been loaded in all loaders</span>
<span class="udiff-line-added">+   // that could potentially see it via delegation.</span>
<span class="udiff-line-added">+   static Klass* get_klass_by_name(Klass* accessing_klass,</span>
<span class="udiff-line-added">+                                   Symbol* klass_name,</span>
<span class="udiff-line-added">+                                   bool require_local);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Constant pool access.</span>
<span class="udiff-line-added">+   static Klass*   get_klass_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="udiff-line-added">+                                      int klass_index,</span>
<span class="udiff-line-added">+                                      bool&amp; is_accessible,</span>
<span class="udiff-line-added">+                                      Klass* loading_klass);</span>
<span class="udiff-line-added">+   static void   get_field_by_index(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,</span>
<span class="udiff-line-added">+                                    int field_index);</span>
<span class="udiff-line-added">+   static Method*  get_method_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="udiff-line-added">+                                       int method_index, Bytecodes::Code bc,</span>
<span class="udiff-line-added">+                                       InstanceKlass* loading_klass);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // converts the Klass* representing the holder of a method into a</span>
<span class="udiff-line-added">+   // InstanceKlass*.  This is needed since the holder of a method in</span>
<span class="udiff-line-added">+   // the bytecodes could be an array type.  Basically this converts</span>
<span class="udiff-line-added">+   // array types into java/lang/Object and other types stay as they are.</span>
<span class="udiff-line-added">+   static InstanceKlass* get_instance_klass_for_declared_method_holder(Klass* klass);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Helper routine for determining the validity of a compilation</span>
<span class="udiff-line-added">+   // with respect to concurrent class loading.</span>
<span class="udiff-line-added">+   static JVMCI::CodeInstallResult validate_compile_task_dependencies(Dependencies* target, JVMCICompileState* task, char** failure_detail);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Compiles `target` with the JVMCI compiler.</span>
<span class="udiff-line-added">+   void compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; target, int entry_bci);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Register the result of a compilation.</span>
<span class="udiff-line-added">+   JVMCI::CodeInstallResult register_method(JVMCIEnv* JVMCIENV,</span>
<span class="udiff-line-added">+                        const methodHandle&amp;       target,</span>
<span class="udiff-line-added">+                        nmethod*&amp;                 nm,</span>
<span class="udiff-line-added">+                        int                       entry_bci,</span>
<span class="udiff-line-added">+                        CodeOffsets*              offsets,</span>
<span class="udiff-line-added">+                        int                       orig_pc_offset,</span>
<span class="udiff-line-added">+                        CodeBuffer*               code_buffer,</span>
<span class="udiff-line-added">+                        int                       frame_words,</span>
<span class="udiff-line-added">+                        OopMapSet*                oop_map_set,</span>
<span class="udiff-line-added">+                        ExceptionHandlerTable*    handler_table,</span>
<span class="udiff-line-added">+                        ImplicitExceptionTable* implicit_exception_table,</span>
<span class="udiff-line-added">+                        AbstractCompiler*         compiler,</span>
<span class="udiff-line-added">+                        DebugInformationRecorder* debug_info,</span>
<span class="udiff-line-added">+                        Dependencies*             dependencies,</span>
<span class="udiff-line-added">+                        int                       compile_id,</span>
<span class="udiff-line-added">+                        bool                      has_unsafe_access,</span>
<span class="udiff-line-added">+                        bool                      has_wide_vector,</span>
<span class="udiff-line-added">+                        JVMCIObject               compiled_code,</span>
<span class="udiff-line-added">+                        JVMCIObject               nmethod_mirror,</span>
<span class="udiff-line-added">+                        FailedSpeculation**       failed_speculations,</span>
<span class="udiff-line-added">+                        char*                     speculations,</span>
<span class="udiff-line-added">+                        int                       speculations_len);</span>
<span class="udiff-line-added">+ </span>
    /**
<span class="udiff-line-modified-removed">-    * Lets JVMCI modify the compilation level currently selected for a method by</span>
<span class="udiff-line-removed">-    * the VM compilation policy.</span>
<span class="udiff-line-removed">-    *</span>
<span class="udiff-line-removed">-    * @param method the method being scheduled for compilation</span>
<span class="udiff-line-removed">-    * @param is_osr specifies if the compilation is an OSR compilation</span>
<span class="udiff-line-removed">-    * @param level the compilation level currently selected by the VM compilation policy</span>
<span class="udiff-line-removed">-    * @param thread the current thread</span>
<span class="udiff-line-removed">-    * @return the compilation level to use for the compilation</span>
<span class="udiff-line-modified-added">+    * Exits the VM due to an unexpected exception.</span>
     */
<span class="udiff-line-modified-removed">-   static CompLevel adjust_comp_level(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   static BasicType kindToBasicType(Handle kind, TRAPS);</span>
<span class="udiff-line-modified-added">+   static void exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   static void describe_pending_hotspot_exception(JavaThread* THREAD, bool clear);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define CHECK_EXIT THREAD); \</span>
<span class="udiff-line-added">+   if (HAS_PENDING_EXCEPTION) { \</span>
<span class="udiff-line-added">+     char buf[256]; \</span>
<span class="udiff-line-added">+     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="udiff-line-added">+     JVMCIRuntime::exit_on_pending_exception(NULL, buf); \</span>
<span class="udiff-line-added">+     return; \</span>
<span class="udiff-line-added">+   } \</span>
<span class="udiff-line-added">+   (void)(0</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define CHECK_EXIT_(v) THREAD);                 \</span>
<span class="udiff-line-added">+   if (HAS_PENDING_EXCEPTION) { \</span>
<span class="udiff-line-added">+     char buf[256]; \</span>
<span class="udiff-line-added">+     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="udiff-line-added">+     JVMCIRuntime::exit_on_pending_exception(NULL, buf); \</span>
<span class="udiff-line-added">+     return v; \</span>
<span class="udiff-line-added">+   } \</span>
<span class="udiff-line-added">+   (void)(0</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define JVMCI_CHECK_EXIT JVMCIENV); \</span>
<span class="udiff-line-added">+   if (JVMCIENV-&gt;has_pending_exception()) {      \</span>
<span class="udiff-line-added">+     char buf[256]; \</span>
<span class="udiff-line-added">+     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="udiff-line-added">+     JVMCIRuntime::exit_on_pending_exception(JVMCIENV, buf); \</span>
<span class="udiff-line-added">+     return; \</span>
<span class="udiff-line-added">+   } \</span>
<span class="udiff-line-added">+   (void)(0</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define JVMCI_CHECK_EXIT_(result) JVMCIENV); \</span>
<span class="udiff-line-added">+   if (JVMCIENV-&gt;has_pending_exception()) {      \</span>
<span class="udiff-line-added">+     char buf[256]; \</span>
<span class="udiff-line-added">+     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="udiff-line-added">+     JVMCIRuntime::exit_on_pending_exception(JVMCIENV, buf); \</span>
<span class="udiff-line-added">+     return result; \</span>
<span class="udiff-line-added">+   } \</span>
<span class="udiff-line-added">+   (void)(0</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static BasicType kindToBasicType(const Handle&amp; kind, TRAPS);</span>
  
    static void new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail);
    static void new_array_common(JavaThread* thread, Klass* klass, jint length, bool null_on_fail);
    static void new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail);
    static void dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,11 +307,10 @@</span>
    static void new_array_or_null(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, true); }
    static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, true); }
    static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, true); }
    static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, true); }
  
<span class="udiff-line-removed">-   static jboolean thread_is_interrupted(JavaThread* thread, oopDesc* obj, jboolean clear_interrupted);</span>
    static void vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3);
    static jint identity_hash_code(JavaThread* thread, oopDesc* obj);
    static address exception_handler_for_pc(JavaThread* thread);
    static void monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock);
    static void monitorexit (JavaThread* thread, oopDesc* obj, BasicLock* lock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -172,32 +330,29 @@</span>
    static void write_barrier_post(JavaThread* thread, void* card);
  #endif
    static jboolean validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child);
  
    // used to throw exceptions from compiled JVMCI code
<span class="udiff-line-modified-removed">-   static void throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);</span>
<span class="udiff-line-modified-added">+   static int throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);</span>
    // helper methods to throw exception with complex messages
<span class="udiff-line-modified-removed">-   static void throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);</span>
<span class="udiff-line-modified-removed">-   static void throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Forces initialization of the JVMCI runtime.</span>
<span class="udiff-line-removed">-   static void force_initialization(TRAPS);</span>
<span class="udiff-line-modified-added">+   static int throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);</span>
<span class="udiff-line-modified-added">+   static int throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);</span>
  
    // Test only function
<span class="udiff-line-modified-removed">-   static int test_deoptimize_call_int(JavaThread* thread, int value);</span>
<span class="udiff-line-modified-added">+   static jint test_deoptimize_call_int(JavaThread* thread, int value);</span>
  };
  
  // Tracing macros.
  
  #define IF_TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1)) ; else
  #define IF_TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2)) ; else
  #define IF_TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3)) ; else
  #define IF_TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4)) ; else
  #define IF_TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5)) ; else
  
<span class="udiff-line-modified-removed">- #define TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1 &amp;&amp; (tty-&gt;print(&quot;JVMCITrace-1: &quot;), true))) ; else tty-&gt;print_cr</span>
<span class="udiff-line-modified-removed">- #define TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2 &amp;&amp; (tty-&gt;print(&quot;   JVMCITrace-2: &quot;), true))) ; else tty-&gt;print_cr</span>
<span class="udiff-line-modified-removed">- #define TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3 &amp;&amp; (tty-&gt;print(&quot;      JVMCITrace-3: &quot;), true))) ; else tty-&gt;print_cr</span>
<span class="udiff-line-modified-removed">- #define TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4 &amp;&amp; (tty-&gt;print(&quot;         JVMCITrace-4: &quot;), true))) ; else tty-&gt;print_cr</span>
<span class="udiff-line-modified-removed">- #define TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5 &amp;&amp; (tty-&gt;print(&quot;            JVMCITrace-5: &quot;), true))) ; else tty-&gt;print_cr</span>
<span class="udiff-line-modified-added">+ #define TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot; JVMCITrace-1: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="udiff-line-modified-added">+ #define TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;    JVMCITrace-2: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="udiff-line-modified-added">+ #define TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;       JVMCITrace-3: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="udiff-line-modified-added">+ #define TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;          JVMCITrace-4: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="udiff-line-modified-added">+ #define TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;             JVMCITrace-5: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
  
  #endif // SHARE_JVMCI_JVMCIRUNTIME_HPP
</pre>
<center><a href="jvmciRuntime.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmci_globals.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
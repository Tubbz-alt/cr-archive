<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_JVMCI_JVMCIRUNTIME_HPP
 25 #define SHARE_JVMCI_JVMCIRUNTIME_HPP
 26 
<a name="1" id="anc1"></a><span class="line-modified"> 27 #include &quot;interpreter/interpreter.hpp&quot;</span>
<span class="line-modified"> 28 #include &quot;memory/allocation.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;runtime/arguments.hpp&quot;</span>
<span class="line-modified"> 30 #include &quot;runtime/deoptimization.hpp&quot;</span>





































 31 
<a name="2" id="anc2"></a><span class="line-modified"> 32 #define JVMCI_ERROR(...)       \</span>
<span class="line-modified"> 33   { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return; }</span>
 34 
<a name="3" id="anc3"></a><span class="line-modified"> 35 #define JVMCI_ERROR_(ret, ...) \</span>
<span class="line-modified"> 36   { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return ret; }</span>

 37 
<a name="4" id="anc4"></a><span class="line-modified"> 38 #define JVMCI_ERROR_0(...)    JVMCI_ERROR_(0, __VA_ARGS__)</span>
<span class="line-modified"> 39 #define JVMCI_ERROR_NULL(...) JVMCI_ERROR_(NULL, __VA_ARGS__)</span>
<span class="line-modified"> 40 #define JVMCI_ERROR_OK(...)   JVMCI_ERROR_(JVMCIEnv::ok, __VA_ARGS__)</span>
<span class="line-modified"> 41 #define CHECK_OK              CHECK_(JVMCIEnv::ok)</span>





 42 
<a name="5" id="anc5"></a><span class="line-modified"> 43 class JVMCIRuntime: public AllStatic {</span>


 44  public:
 45   // Constants describing whether JVMCI wants to be able to adjust the compilation
 46   // level selected for a method by the VM compilation policy and if so, based on
 47   // what information about the method being schedule for compilation.
 48   enum CompLevelAdjustment {
 49      none = 0,             // no adjustment
 50      by_holder = 1,        // adjust based on declaring class of method
 51      by_full_signature = 2 // adjust based on declaring class, name and signature of method
 52   };
 53 
 54  private:
<a name="6" id="anc6"></a><span class="line-modified"> 55   static jobject _HotSpotJVMCIRuntime_instance;</span>
<span class="line-modified"> 56   static bool _HotSpotJVMCIRuntime_initialized;</span>
<span class="line-modified"> 57   static bool _well_known_classes_initialized;</span>
<span class="line-modified"> 58 </span>
<span class="line-modified"> 59   static CompLevelAdjustment _comp_level_adjustment;</span>
<span class="line-modified"> 60 </span>
<span class="line-modified"> 61   static bool _shutdown_called;</span>
<span class="line-modified"> 62 </span>
<span class="line-modified"> 63   static CompLevel adjust_comp_level_inner(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread);</span>























 64 
 65  public:
<a name="7" id="anc7"></a><span class="line-modified"> 66   static bool is_HotSpotJVMCIRuntime_initialized() {</span>
<span class="line-modified"> 67     return _HotSpotJVMCIRuntime_initialized;</span>


 68   }
 69 
 70   /**
<a name="8" id="anc8"></a><span class="line-modified"> 71    * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary</span>
 72    */
<a name="9" id="anc9"></a><span class="line-modified"> 73   static Handle get_HotSpotJVMCIRuntime(TRAPS);</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75   static jobject get_HotSpotJVMCIRuntime_jobject(TRAPS) {</span>
<span class="line-removed"> 76     initialize_JVMCI(CHECK_NULL);</span>
<span class="line-removed"> 77     assert(_HotSpotJVMCIRuntime_initialized, &quot;must be&quot;);</span>
<span class="line-removed"> 78     return _HotSpotJVMCIRuntime_instance;</span>
<span class="line-removed"> 79   }</span>
<span class="line-removed"> 80 </span>
<span class="line-removed"> 81   static Handle callStatic(const char* className, const char* methodName, const char* returnType, JavaCallArguments* args, TRAPS);</span>
 82 
 83   /**
<a name="10" id="anc10"></a><span class="line-modified"> 84    * Determines if the VM is sufficiently booted to initialize JVMCI.</span>
 85    */
<a name="11" id="anc11"></a><span class="line-modified"> 86   static bool can_initialize_JVMCI();</span>




 87 
 88   /**
 89    * Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()
 90    */
<a name="12" id="anc12"></a><span class="line-modified"> 91   static void initialize_JVMCI(TRAPS);</span>
 92 
 93   /**
 94    * Explicitly initialize HotSpotJVMCIRuntime itself
 95    */
<a name="13" id="anc13"></a><span class="line-modified"> 96   static void initialize_HotSpotJVMCIRuntime(TRAPS);</span>
 97 
<a name="14" id="anc14"></a><span class="line-modified"> 98   static void initialize_well_known_classes(TRAPS);</span>
 99 
<a name="15" id="anc15"></a><span class="line-modified">100   static void metadata_do(void f(Metadata*));</span>
101 
<a name="16" id="anc16"></a><span class="line-modified">102   static void shutdown(TRAPS);</span>
<span class="line-removed">103 </span>
<span class="line-removed">104   static void bootstrap_finished(TRAPS);</span>
<span class="line-removed">105 </span>
<span class="line-removed">106   static bool shutdown_called() {</span>
107     return _shutdown_called;
108   }
109 
<a name="17" id="anc17"></a>

































































110   /**
<a name="18" id="anc18"></a><span class="line-modified">111    * Lets JVMCI modify the compilation level currently selected for a method by</span>
<span class="line-removed">112    * the VM compilation policy.</span>
<span class="line-removed">113    *</span>
<span class="line-removed">114    * @param method the method being scheduled for compilation</span>
<span class="line-removed">115    * @param is_osr specifies if the compilation is an OSR compilation</span>
<span class="line-removed">116    * @param level the compilation level currently selected by the VM compilation policy</span>
<span class="line-removed">117    * @param thread the current thread</span>
<span class="line-removed">118    * @return the compilation level to use for the compilation</span>
119    */
<a name="19" id="anc19"></a><span class="line-modified">120   static CompLevel adjust_comp_level(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread);</span>
<span class="line-modified">121 </span>
<span class="line-modified">122   static BasicType kindToBasicType(Handle kind, TRAPS);</span>






































123 
124   static void new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail);
125   static void new_array_common(JavaThread* thread, Klass* klass, jint length, bool null_on_fail);
126   static void new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail);
127   static void dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail);
128   static void dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail);
129 
130   // The following routines are called from compiled JVMCI code
131 
132   // When allocation fails, these stubs:
133   // 1. Exercise -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError handling and also
134   //    post a JVMTI_EVENT_RESOURCE_EXHAUSTED event if the failure is an OutOfMemroyError
135   // 2. Return NULL with a pending exception.
136   // Compiled code must ensure these stubs are not called twice for the same allocation
137   // site due to the non-repeatable side effects in the case of OOME.
138   static void new_instance(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, false); }
139   static void new_array(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, false); }
140   static void new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, false); }
141   static void dynamic_new_array(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, false); }
142   static void dynamic_new_instance(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, false); }
143 
144   // When allocation fails, these stubs return NULL and have no pending exception. Compiled code
145   // can use these stubs if a failed allocation will be retried (e.g., by deoptimizing and
146   // re-executing in the interpreter).
147   static void new_instance_or_null(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, true); }
148   static void new_array_or_null(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, true); }
149   static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, true); }
150   static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, true); }
151   static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, true); }
152 
<a name="20" id="anc20"></a><span class="line-removed">153   static jboolean thread_is_interrupted(JavaThread* thread, oopDesc* obj, jboolean clear_interrupted);</span>
154   static void vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3);
155   static jint identity_hash_code(JavaThread* thread, oopDesc* obj);
156   static address exception_handler_for_pc(JavaThread* thread);
157   static void monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock);
158   static void monitorexit (JavaThread* thread, oopDesc* obj, BasicLock* lock);
159   static jboolean object_notify(JavaThread* thread, oopDesc* obj);
160   static jboolean object_notifyAll(JavaThread* thread, oopDesc* obj);
161   static void vm_error(JavaThread* thread, jlong where, jlong format, jlong value);
162   static oopDesc* load_and_clear_exception(JavaThread* thread);
163   static void log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3);
164   static void log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline);
165   // Print the passed in object, optionally followed by a newline.  If
166   // as_string is true and the object is a java.lang.String then it
167   // printed as a string, otherwise the type of the object is printed
168   // followed by its address.
169   static void log_object(JavaThread* thread, oopDesc* object, bool as_string, bool newline);
170 #if INCLUDE_G1GC
171   static void write_barrier_pre(JavaThread* thread, oopDesc* obj);
172   static void write_barrier_post(JavaThread* thread, void* card);
173 #endif
174   static jboolean validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child);
175 
176   // used to throw exceptions from compiled JVMCI code
<a name="21" id="anc21"></a><span class="line-modified">177   static void throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);</span>
178   // helper methods to throw exception with complex messages
<a name="22" id="anc22"></a><span class="line-modified">179   static void throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);</span>
<span class="line-modified">180   static void throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);</span>
<span class="line-removed">181 </span>
<span class="line-removed">182   // Forces initialization of the JVMCI runtime.</span>
<span class="line-removed">183   static void force_initialization(TRAPS);</span>
184 
185   // Test only function
<a name="23" id="anc23"></a><span class="line-modified">186   static int test_deoptimize_call_int(JavaThread* thread, int value);</span>
187 };
188 
189 // Tracing macros.
190 
191 #define IF_TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1)) ; else
192 #define IF_TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2)) ; else
193 #define IF_TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3)) ; else
194 #define IF_TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4)) ; else
195 #define IF_TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5)) ; else
196 
<a name="24" id="anc24"></a><span class="line-modified">197 #define TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1 &amp;&amp; (tty-&gt;print(&quot;JVMCITrace-1: &quot;), true))) ; else tty-&gt;print_cr</span>
<span class="line-modified">198 #define TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2 &amp;&amp; (tty-&gt;print(&quot;   JVMCITrace-2: &quot;), true))) ; else tty-&gt;print_cr</span>
<span class="line-modified">199 #define TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3 &amp;&amp; (tty-&gt;print(&quot;      JVMCITrace-3: &quot;), true))) ; else tty-&gt;print_cr</span>
<span class="line-modified">200 #define TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4 &amp;&amp; (tty-&gt;print(&quot;         JVMCITrace-4: &quot;), true))) ; else tty-&gt;print_cr</span>
<span class="line-modified">201 #define TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5 &amp;&amp; (tty-&gt;print(&quot;            JVMCITrace-5: &quot;), true))) ; else tty-&gt;print_cr</span>
202 
203 #endif // SHARE_JVMCI_JVMCIRUNTIME_HPP
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
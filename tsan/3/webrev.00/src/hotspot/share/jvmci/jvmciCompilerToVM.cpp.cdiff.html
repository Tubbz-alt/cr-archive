<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCompiler.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCompilerToVM.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,29 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;ci/ciUtilities.inline.hpp&quot;</span>
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;code/scopeDesc.hpp&quot;
<span class="line-removed">- #include &quot;interpreter/linkResolver.hpp&quot;</span>
<span class="line-removed">- #include &quot;memory/oopFactory.hpp&quot;</span>
<span class="line-removed">- #include &quot;oops/cpCache.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;oops/generateOopMap.hpp&quot;</span>
<span class="line-removed">- #include &quot;oops/method.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;oops/typeArrayOop.inline.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/flags/jvmFlag.hpp&quot;</span>
  #include &quot;runtime/frame.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/handles.inline.hpp&quot;</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/timerTrace.hpp&quot;
  #include &quot;runtime/vframe_hp.hpp&quot;
  
<span class="line-new-header">--- 20,34 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;classfile/classLoaderData.inline.hpp&quot;</span>
  #include &quot;classfile/javaClasses.inline.hpp&quot;
<span class="line-added">+ #include &quot;classfile/stringTable.hpp&quot;</span>
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;code/scopeDesc.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
<span class="line-added">+ #include &quot;interpreter/linkResolver.hpp&quot;</span>
<span class="line-added">+ #include &quot;interpreter/bytecodeStream.hpp&quot;</span>
  #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="line-added">+ #include &quot;logging/log.hpp&quot;</span>
<span class="line-added">+ #include &quot;logging/logTag.hpp&quot;</span>
<span class="line-added">+ #include &quot;memory/oopFactory.hpp&quot;</span>
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/constantPool.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/method.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/typeArrayOop.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;prims/nativeLookup.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/deoptimization.hpp&quot;</span>
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/timerTrace.hpp&quot;
  #include &quot;runtime/vframe_hp.hpp&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,103 ***</span>
      _holder = Handle(_thread, klass-&gt;klass_holder());
    }
    return *this;
  }
  
<span class="line-modified">! void JNIHandleMark::push_jni_handle_block() {</span>
<span class="line-modified">!   JavaThread* thread = JavaThread::current();</span>
    if (thread != NULL) {
      // Allocate a new block for JNI handles.
      // Inlined code from jni_PushLocalFrame()
<span class="line-modified">!     JNIHandleBlock* java_handles = ((JavaThread*)thread)-&gt;active_handles();</span>
      JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
      assert(compile_handles != NULL &amp;&amp; java_handles != NULL, &quot;should not be NULL&quot;);
      compile_handles-&gt;set_pop_frame_link(java_handles);
      thread-&gt;set_active_handles(compile_handles);
    }
  }
  
<span class="line-modified">! void JNIHandleMark::pop_jni_handle_block() {</span>
<span class="line-removed">-   JavaThread* thread = JavaThread::current();</span>
    if (thread != NULL) {
      // Release our JNI handle block
      JNIHandleBlock* compile_handles = thread-&gt;active_handles();
      JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
      thread-&gt;set_active_handles(java_handles);
      compile_handles-&gt;set_pop_frame_link(NULL);
      JNIHandleBlock::release_block(compile_handles, thread); // may block
    }
  }
  
<span class="line-modified">! // Entry to native method implementation that transitions current thread to &#39;_thread_in_vm&#39;.</span>
<span class="line-modified">! #define C2V_VMENTRY(result_type, name, signature) \</span>
<span class="line-modified">!   JNIEXPORT result_type JNICALL c2v_ ## name signature { \</span>
<span class="line-modified">!   TRACE_jvmci_1(&quot;CompilerToVM::&quot; #name); \</span>
<span class="line-modified">!   TRACE_CALL(result_type, jvmci_ ## name signature) \</span>
<span class="line-modified">!   JVMCI_VM_ENTRY_MARK; \</span>
<span class="line-modified">! </span>
<span class="line-modified">! #define C2V_END }</span>
<span class="line-removed">- </span>
<span class="line-removed">- oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {</span>
<span class="line-removed">-   if (method() != NULL) {</span>
<span class="line-removed">-     JavaValue result(T_OBJECT);</span>
<span class="line-removed">-     JavaCallArguments args;</span>
<span class="line-removed">-     args.push_long((jlong) (address) method());</span>
<span class="line-removed">-     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return (oop)result.get_jobject();</span>
    }
<span class="line-modified">!   return NULL;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! oop CompilerToVM::get_jvmci_type(JVMCIKlassHandle&amp; klass, TRAPS) {</span>
<span class="line-removed">-   if (!klass.is_null()) {</span>
<span class="line-removed">-     JavaValue result(T_OBJECT);</span>
<span class="line-removed">-     JavaCallArguments args;</span>
<span class="line-removed">-     args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));</span>
<span class="line-removed">-     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return (oop)result.get_jobject();</span>
    }
<span class="line-modified">!   return NULL;</span>
<span class="line-modified">! }</span>
  
  Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
    assert(_index &lt; _args-&gt;length(), &quot;out of bounds&quot;);
    oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
    assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), &quot;arg type mismatch&quot;);
    return Handle(Thread::current(), arg);
  }
  
<span class="line-modified">! jobjectArray readConfiguration0(JNIEnv *env, TRAPS);</span>
  
<span class="line-modified">! C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))</span>
<span class="line-modified">!    jobjectArray config = readConfiguration0(env, CHECK_NULL);</span>
<span class="line-modified">!    return config;</span>
<span class="line-modified">! C2V_END</span>
  
<span class="line-modified">! C2V_VMENTRY(jobject, getFlagValue, (JNIEnv *, jobject c2vm, jobject name_handle))</span>
<span class="line-modified">! #define RETURN_BOXED_LONG(value) oop box; jvalue p; p.j = (jlong) (value); box = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);</span>
<span class="line-modified">! #define RETURN_BOXED_DOUBLE(value) oop box; jvalue p; p.d = (jdouble) (value); box = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);</span>
<span class="line-modified">!   Handle name(THREAD, JNIHandles::resolve(name_handle));</span>
    if (name.is_null()) {
<span class="line-modified">!     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
    }
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   const char* cstring = java_lang_String::as_utf8_string(name());</span>
<span class="line-removed">-   JVMFlag* flag = JVMFlag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);</span>
    if (flag == NULL) {
      return c2vm;
    }
    if (flag-&gt;is_bool()) {
      jvalue prim;
      prim.z = flag-&gt;get_bool();
<span class="line-modified">!     oop box = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="line-modified">!     return JNIHandles::make_local(THREAD, box);</span>
    } else if (flag-&gt;is_ccstr()) {
<span class="line-modified">!     Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);</span>
<span class="line-modified">!     return JNIHandles::make_local(THREAD, value());</span>
    } else if (flag-&gt;is_intx()) {
      RETURN_BOXED_LONG(flag-&gt;get_intx());
    } else if (flag-&gt;is_int()) {
      RETURN_BOXED_LONG(flag-&gt;get_int());
    } else if (flag-&gt;is_uint()) {
<span class="line-new-header">--- 65,164 ---</span>
      _holder = Handle(_thread, klass-&gt;klass_holder());
    }
    return *this;
  }
  
<span class="line-modified">! static void requireInHotSpot(const char* caller, JVMCI_TRAPS) {</span>
<span class="line-modified">!   if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-added">+     JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot call %s from JVMCI shared library&quot;, caller));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JNIHandleMark::push_jni_handle_block(JavaThread* thread) {</span>
    if (thread != NULL) {
      // Allocate a new block for JNI handles.
      // Inlined code from jni_PushLocalFrame()
<span class="line-modified">!     JNIHandleBlock* java_handles = thread-&gt;active_handles();</span>
      JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
      assert(compile_handles != NULL &amp;&amp; java_handles != NULL, &quot;should not be NULL&quot;);
      compile_handles-&gt;set_pop_frame_link(java_handles);
      thread-&gt;set_active_handles(compile_handles);
    }
  }
  
<span class="line-modified">! void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {</span>
    if (thread != NULL) {
      // Release our JNI handle block
      JNIHandleBlock* compile_handles = thread-&gt;active_handles();
      JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
      thread-&gt;set_active_handles(java_handles);
      compile_handles-&gt;set_pop_frame_link(NULL);
      JNIHandleBlock::release_block(compile_handles, thread); // may block
    }
  }
  
<span class="line-modified">! class JVMCITraceMark : public StackObj {</span>
<span class="line-modified">!   const char* _msg;</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   JVMCITraceMark(const char* msg) {</span>
<span class="line-modified">!     _msg = msg;</span>
<span class="line-modified">!     if (JVMCITraceLevel &gt;= 1) {</span>
<span class="line-modified">!       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Enter %s&quot;, p2i(JavaThread::current()), _msg);</span>
<span class="line-modified">!     }</span>
    }
<span class="line-modified">!   ~JVMCITraceMark() {</span>
<span class="line-modified">!     if (JVMCITraceLevel &gt;= 1) {</span>
<span class="line-modified">!       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Exit %s&quot;, p2i(JavaThread::current()), _msg);</span>
<span class="line-modified">!     }</span>
    }
<span class="line-modified">! };</span>
<span class="line-modified">! </span>
  
  Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
    assert(_index &lt; _args-&gt;length(), &quot;out of bounds&quot;);
    oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
    assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), &quot;arg type mismatch&quot;);
    return Handle(Thread::current(), arg);
  }
  
<span class="line-modified">! // Bring the JVMCI compiler thread into the VM state.</span>
<span class="line-added">+ #define JVMCI_VM_ENTRY_MARK                   \</span>
<span class="line-added">+   ThreadInVMfromNative __tiv(thread);         \</span>
<span class="line-added">+   ResetNoHandleMark rnhm;                     \</span>
<span class="line-added">+   HandleMarkCleaner __hm(thread);             \</span>
<span class="line-added">+   Thread* THREAD = thread;                    \</span>
<span class="line-added">+   debug_only(VMNativeEntryWrapper __vew;)</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Native method block that transitions current thread to &#39;_thread_in_vm&#39;.</span>
<span class="line-added">+ #define C2V_BLOCK(result_type, name, signature)      \</span>
<span class="line-added">+   TRACE_CALL(result_type, jvmci_ ## name signature)  \</span>
<span class="line-added">+   JVMCI_VM_ENTRY_MARK;                               \</span>
<span class="line-added">+   ResourceMark rm;                                   \</span>
<span class="line-added">+   JNI_JVMCIENV(thread, env);</span>
<span class="line-added">+ </span>
<span class="line-added">+ static Thread* get_current_thread() {</span>
<span class="line-added">+   return Thread::current_or_null_safe();</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! // Entry to native method implementation that transitions</span>
<span class="line-modified">! // current thread to &#39;_thread_in_vm&#39;.</span>
<span class="line-modified">! #define C2V_VMENTRY(result_type, name, signature)        \</span>
<span class="line-modified">!   JNIEXPORT result_type JNICALL c2v_ ## name signature { \</span>
<span class="line-added">+   Thread* base_thread = get_current_thread();            \</span>
<span class="line-added">+   if (base_thread == NULL) {                             \</span>
<span class="line-added">+     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \</span>
<span class="line-added">+         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \</span>
<span class="line-added">+     return;                                              \</span>
<span class="line-added">+   }                                                      \</span>
<span class="line-added">+   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-added">+   JavaThread* thread = (JavaThread*) base_thread;        \</span>
<span class="line-added">+   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \</span>
<span class="line-added">+   C2V_BLOCK(result_type, name, signature)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define C2V_VMENTRY_(result_type, name, signature, result) \</span>
<span class="line-added">+   JNIEXPORT result_type JNICALL c2v_ ## name signature { \</span>
<span class="line-added">+   Thread* base_thread = get_current_thread();            \</span>
<span class="line-added">+   if (base_thread == NULL) {                             \</span>
<span class="line-added">+     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \</span>
<span class="line-added">+         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \</span>
<span class="line-added">+     return result;                                       \</span>
<span class="line-added">+   }                                                      \</span>
<span class="line-added">+   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-added">+   JavaThread* thread = (JavaThread*) base_thread;        \</span>
<span class="line-added">+   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \</span>
<span class="line-added">+   C2V_BLOCK(result_type, name, signature)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)</span>
<span class="line-added">+ #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Entry to native method implementation that does not transition</span>
<span class="line-added">+ // current thread to &#39;_thread_in_vm&#39;.</span>
<span class="line-added">+ #define C2V_VMENTRY_PREFIX(result_type, name, signature) \</span>
<span class="line-added">+   JNIEXPORT result_type JNICALL c2v_ ## name signature { \</span>
<span class="line-added">+   Thread* base_thread = get_current_thread();</span>
  
<span class="line-modified">! #define C2V_END }</span>
<span class="line-modified">! </span>
<span class="line-modified">! #define JNI_THROW(caller, name, msg) do {                                         \</span>
<span class="line-modified">!     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \</span>
<span class="line-added">+     if (__throw_res != JNI_OK) {                                                  \</span>
<span class="line-added">+       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \</span>
<span class="line-added">+     }                                                                             \</span>
<span class="line-added">+     return;                                                                       \</span>
<span class="line-added">+   } while (0);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define JNI_THROW_(caller, name, msg, result) do {                                \</span>
<span class="line-added">+     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \</span>
<span class="line-added">+     if (__throw_res != JNI_OK) {                                                  \</span>
<span class="line-added">+       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \</span>
<span class="line-added">+     }                                                                             \</span>
<span class="line-added">+     return result;                                                                \</span>
<span class="line-added">+   } while (0)</span>
<span class="line-added">+ </span>
<span class="line-added">+ jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobjectArray, readConfiguration, (JNIEnv* env))</span>
<span class="line-added">+   jobjectArray config = readConfiguration0(env, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   return config;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, getFlagValue, (JNIEnv* env, jobject c2vm, jobject name_handle))</span>
<span class="line-added">+ #define RETURN_BOXED_LONG(value) jvalue p; p.j = (jlong) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_LONG, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();</span>
<span class="line-added">+ #define RETURN_BOXED_DOUBLE(value) jvalue p; p.d = (jdouble) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_DOUBLE, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();</span>
<span class="line-added">+   JVMCIObject name = JVMCIENV-&gt;wrap(name_handle);</span>
    if (name.is_null()) {
<span class="line-modified">!     JVMCI_THROW_NULL(NullPointerException);</span>
    }
<span class="line-modified">!   const char* cstring = JVMCIENV-&gt;as_utf8_string(name);</span>
<span class="line-modified">!   const JVMFlag* flag = JVMFlag::find_declared_flag(cstring);</span>
    if (flag == NULL) {
      return c2vm;
    }
    if (flag-&gt;is_bool()) {
      jvalue prim;
      prim.z = flag-&gt;get_bool();
<span class="line-modified">!     JVMCIObject box = JVMCIENV-&gt;create_box(T_BOOLEAN, &amp;prim, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!     return JVMCIENV-&gt;get_jobject(box);</span>
    } else if (flag-&gt;is_ccstr()) {
<span class="line-modified">!     JVMCIObject value = JVMCIENV-&gt;create_string(flag-&gt;get_ccstr(), JVMCI_CHECK_NULL);</span>
<span class="line-modified">!     return JVMCIENV-&gt;get_jobject(value);</span>
    } else if (flag-&gt;is_intx()) {
      RETURN_BOXED_LONG(flag-&gt;get_intx());
    } else if (flag-&gt;is_int()) {
      RETURN_BOXED_LONG(flag-&gt;get_int());
    } else if (flag-&gt;is_uint()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,16 ***</span>
    }
  #undef RETURN_BOXED_LONG
  #undef RETURN_BOXED_DOUBLE
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
<span class="line-modified">!   ResourceMark rm;</span>
  
    int code_size = method-&gt;code_size();
<span class="line-modified">!   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);</span>
  
    guarantee(method-&gt;method_holder()-&gt;is_rewritten(), &quot;Method&#39;s holder should be rewritten&quot;);
    // iterate over all bytecodes and replace non-Java bytecodes
  
    for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
<span class="line-new-header">--- 240,27 ---</span>
    }
  #undef RETURN_BOXED_LONG
  #undef RETURN_BOXED_DOUBLE
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getObjectAtAddress, (JNIEnv* env, jobject c2vm, jlong oop_address))</span>
<span class="line-modified">!   requireInHotSpot(&quot;getObjectAtAddress&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   if (oop_address == 0) {</span>
<span class="line-added">+     JVMCI_THROW_MSG_NULL(InternalError, &quot;Handle must be non-zero&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   oop obj = *((oopDesc**) oop_address);</span>
<span class="line-added">+   if (obj != NULL) {</span>
<span class="line-added">+     oopDesc::verify(obj);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return JNIHandles::make_local(obj);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jbyteArray, getBytecode, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-added">+   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
  
    int code_size = method-&gt;code_size();
<span class="line-modified">!   jbyte* reconstituted_code = NEW_RESOURCE_ARRAY(jbyte, code_size);</span>
  
    guarantee(method-&gt;method_holder()-&gt;is_rewritten(), &quot;Method&#39;s holder should be rewritten&quot;);
    // iterate over all bytecodes and replace non-Java bytecodes
  
    for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,13 ***</span>
      Bytecodes::Code raw_code = s.raw_code();
      int bci = s.bci();
      int len = s.instruction_size();
  
      // Restore original byte code.
<span class="line-modified">!     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));</span>
      if (len &gt; 1) {
<span class="line-modified">!       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);</span>
      }
  
      if (len &gt; 1) {
        // Restore the big-endian constant pool indexes.
        // Cf. Rewriter::scan_method
<span class="line-new-header">--- 268,13 ---</span>
      Bytecodes::Code raw_code = s.raw_code();
      int bci = s.bci();
      int len = s.instruction_size();
  
      // Restore original byte code.
<span class="line-modified">!     reconstituted_code[bci] =  (jbyte) (s.is_wide()? Bytecodes::_wide : code);</span>
      if (len &gt; 1) {
<span class="line-modified">!       memcpy(reconstituted_code + (bci + 1), s.bcp()+1, len-1);</span>
      }
  
      if (len &gt; 1) {
        // Restore the big-endian constant pool indexes.
        // Cf. Rewriter::scan_method
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,68 ***</span>
          case Bytecodes::_invokevirtual:
          case Bytecodes::_invokespecial:
          case Bytecodes::_invokestatic:
          case Bytecodes::_invokeinterface:
          case Bytecodes::_invokehandle: {
<span class="line-modified">!           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));</span>
<span class="line-modified">!           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);</span>
            break;
          }
  
          case Bytecodes::_invokedynamic: {
<span class="line-modified">!           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));</span>
<span class="line-modified">!           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);</span>
            break;
          }
  
          default:
            break;
        }
  
        // Not all ldc byte code are rewritten.
        switch (raw_code) {
          case Bytecodes::_fast_aldc: {
<span class="line-modified">!           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;</span>
            int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
            assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
<span class="line-modified">!           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);</span>
            break;
          }
  
          case Bytecodes::_fast_aldc_w: {
<span class="line-modified">!           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));</span>
            int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
            assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
<span class="line-modified">!           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);</span>
            break;
          }
  
          default:
            break;
        }
      }
    }
  
<span class="line-modified">!   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-removed">-   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
    return method-&gt;exception_table_length();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-removed">-   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
    if (method-&gt;exception_table_length() == 0) {
      return 0L;
    }
    return (jlong) (address) method-&gt;exception_table_start();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, asResolvedJavaMethod, (JNIEnv *, jobject, jobject executable_handle))</span>
    oop executable = JNIHandles::resolve(executable_handle);
    oop mirror = NULL;
    int slot = 0;
  
    if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
<span class="line-new-header">--- 286,69 ---</span>
          case Bytecodes::_invokevirtual:
          case Bytecodes::_invokespecial:
          case Bytecodes::_invokestatic:
          case Bytecodes::_invokeinterface:
          case Bytecodes::_invokehandle: {
<span class="line-modified">!           int cp_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));</span>
<span class="line-modified">!           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);</span>
            break;
          }
  
          case Bytecodes::_invokedynamic: {
<span class="line-modified">!           int cp_index = Bytes::get_native_u4((address) reconstituted_code + (bci + 1));</span>
<span class="line-modified">!           Bytes::put_Java_u4((address) reconstituted_code + (bci + 1), (u4) cp_index);</span>
            break;
          }
  
          default:
            break;
        }
  
        // Not all ldc byte code are rewritten.
        switch (raw_code) {
          case Bytecodes::_fast_aldc: {
<span class="line-modified">!           int cpc_index = reconstituted_code[bci + 1] &amp; 0xff;</span>
            int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
            assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
<span class="line-modified">!           reconstituted_code[bci + 1] = (jbyte) cp_index;</span>
            break;
          }
  
          case Bytecodes::_fast_aldc_w: {
<span class="line-modified">!           int cpc_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));</span>
            int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
            assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
<span class="line-modified">!           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);</span>
            break;
          }
  
          default:
            break;
        }
      }
    }
  
<span class="line-modified">!   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   JVMCIENV-&gt;copy_bytes_from(reconstituted_code, result, 0, code_size);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jbyteArray(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, getExceptionTableLength, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
    return method-&gt;exception_table_length();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jlong, getExceptionTableStart, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
    if (method-&gt;exception_table_length() == 0) {
      return 0L;
    }
    return (jlong) (address) method-&gt;exception_table_start();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, asResolvedJavaMethod, (JNIEnv* env, jobject, jobject executable_handle))</span>
<span class="line-added">+   requireInHotSpot(&quot;asResolvedJavaMethod&quot;, JVMCI_CHECK_NULL);</span>
    oop executable = JNIHandles::resolve(executable_handle);
    oop mirror = NULL;
    int slot = 0;
  
    if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,107 ***</span>
      assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
      mirror = java_lang_reflect_Method::clazz(executable);
      slot = java_lang_reflect_Method::slot(executable);
    }
    Klass* holder = java_lang_Class::as_Klass(mirror);
<span class="line-modified">!   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);</span>
<span class="line-modified">!   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  }
  
<span class="line-modified">! C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))</span>
<span class="line-modified">!   methodHandle method;</span>
<span class="line-modified">!   oop base_object = JNIHandles::resolve(base);</span>
<span class="line-modified">!   if (base_object == NULL) {</span>
      method = *((Method**)(offset));
<span class="line-modified">!   } else if (base_object-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {</span>
<span class="line-modified">!     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);</span>
<span class="line-modified">!   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {</span>
<span class="line-modified">!     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-modified">!                 err_msg(&quot;Unexpected type: %s&quot;, base_object-&gt;klass()-&gt;external_name()));</span>
    }
<span class="line-modified">!   assert (method.is_null() || method-&gt;is_method(), &quot;invalid read&quot;);</span>
<span class="line-modified">!   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  }
  
<span class="line-modified">! C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject object_handle))</span>
<span class="line-modified">!   constantPoolHandle cp;</span>
<span class="line-modified">!   oop object = JNIHandles::resolve(object_handle);</span>
<span class="line-modified">!   if (object == NULL) {</span>
<span class="line-modified">!     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
    }
<span class="line-modified">!   if (object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {</span>
<span class="line-modified">!     cp = CompilerToVM::asMethod(object)-&gt;constMethod()-&gt;constants();</span>
<span class="line-modified">!   } else if (object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {</span>
<span class="line-modified">!     cp = InstanceKlass::cast(CompilerToVM::asKlass(object))-&gt;constants();</span>
    } else {
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-modified">!                 err_msg(&quot;Unexpected type: %s&quot;, object-&gt;klass()-&gt;external_name()));</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   assert(!cp.is_null(), &quot;npe&quot;);</span>
<span class="line-modified">!   JavaValue method_result(T_OBJECT);</span>
<span class="line-modified">!   JavaCallArguments args;</span>
<span class="line-modified">!   args.push_long((jlong) (address) cp());</span>
<span class="line-removed">-   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);</span>
<span class="line-removed">-   return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());</span>
  }
  
<span class="line-modified">! C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))</span>
    JVMCIKlassHandle klass(THREAD);
<span class="line-modified">!   oop base_object = JNIHandles::resolve(base);</span>
    jlong base_address = 0;
<span class="line-modified">!   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {</span>
<span class="line-modified">!     klass = base_object-&gt;klass();</span>
    } else if (!compressed) {
<span class="line-modified">!     if (base_object != NULL) {</span>
<span class="line-modified">!       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {</span>
<span class="line-modified">!         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);</span>
<span class="line-modified">!       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {</span>
<span class="line-modified">!         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);</span>
<span class="line-modified">!       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {</span>
<span class="line-modified">!         base_address = (jlong) CompilerToVM::asKlass(base_object);</span>
<span class="line-modified">!       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {</span>
<span class="line-modified">!         base_address = (jlong) (address) base_object;</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-modified">!                     err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;, base_object-&gt;klass()-&gt;external_name(), offset, compressed ? &quot;true&quot; : &quot;false&quot;));</span>
        }
      }
      klass = *((Klass**) (intptr_t) (base_address + offset));
    } else {
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
                  err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;,
<span class="line-modified">!                         base_object != NULL ? base_object-&gt;klass()-&gt;external_name() : &quot;null&quot;,</span>
                          offset, compressed ? &quot;true&quot; : &quot;false&quot;));
    }
    assert (klass == NULL || klass-&gt;is_klass(), &quot;invalid read&quot;);
<span class="line-modified">!   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  }
  
<span class="line-modified">! C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
<span class="line-removed">-   Klass* holder = CompilerToVM::asKlass(jvmci_type);</span>
    if (holder-&gt;is_interface()) {
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Interface %s should be handled in Java code&quot;, holder-&gt;external_name()));</span>
    }
  
    methodHandle ucm;
    {
      MutexLocker locker(Compile_lock);
<span class="line-modified">!     ucm = Dependencies::find_unique_concrete_method(holder, method());</span>
    }
<span class="line-modified">!   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))</span>
<span class="line-modified">!   Klass* klass = CompilerToVM::asKlass(jvmci_type);</span>
    if (!klass-&gt;is_interface()) {
      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
          err_msg(&quot;Expected interface type, got %s&quot;, klass-&gt;external_name()));
    }
    InstanceKlass* iklass = InstanceKlass::cast(klass);
<span class="line-new-header">--- 358,122 ---</span>
      assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
      mirror = java_lang_reflect_Method::clazz(executable);
      slot = java_lang_reflect_Method::slot(executable);
    }
    Klass* holder = java_lang_Class::as_Klass(mirror);
<span class="line-modified">!   methodHandle method (THREAD, InstanceKlass::cast(holder)-&gt;method_with_idnum(slot));</span>
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(result);</span>
  }
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getResolvedJavaMethod, (JNIEnv* env, jobject, jobject base, jlong offset))</span>
<span class="line-modified">!   Method* method;</span>
<span class="line-modified">!   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);</span>
<span class="line-modified">!   if (base_object.is_null()) {</span>
      method = *((Method**)(offset));
<span class="line-modified">!   } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {</span>
<span class="line-modified">!     Handle obj = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!     if (obj-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {</span>
<span class="line-modified">!       method = (Method*) (intptr_t) obj-&gt;long_field(offset);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(&quot;Unexpected type: %s&quot;, obj-&gt;klass()-&gt;external_name()));</span>
<span class="line-modified">!     }</span>
<span class="line-added">+   } else if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {</span>
<span class="line-added">+     method = JVMCIENV-&gt;asMethod(base_object);</span>
    }
<span class="line-modified">!   if (method == NULL) {</span>
<span class="line-modified">!     JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base_object)));</span>
<span class="line-modified">!   }</span>
<span class="line-added">+   assert (method-&gt;is_method(), &quot;invalid read&quot;);</span>
<span class="line-added">+   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(methodHandle(THREAD, method), JVMCI_CHECK_NULL);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(result);</span>
  }
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getConstantPool, (JNIEnv* env, jobject, jobject object_handle))</span>
<span class="line-modified">!   ConstantPool* cp = NULL;</span>
<span class="line-modified">!   JVMCIObject object = JVMCIENV-&gt;wrap(object_handle);</span>
<span class="line-modified">!   if (object.is_null()) {</span>
<span class="line-modified">!     JVMCI_THROW_NULL(NullPointerException);</span>
    }
<span class="line-modified">!   if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(object)) {</span>
<span class="line-modified">!     cp = JVMCIENV-&gt;asMethod(object)-&gt;constMethod()-&gt;constants();</span>
<span class="line-modified">!   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(object)) {</span>
<span class="line-modified">!     cp = InstanceKlass::cast(JVMCIENV-&gt;asKlass(object))-&gt;constants();</span>
    } else {
<span class="line-modified">!     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
<span class="line-modified">!                 err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(object)));</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   assert(cp != NULL, &quot;npe&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;get_jvmci_constant_pool(constantPoolHandle(THREAD, cp), JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(result);</span>
  }
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getResolvedJavaType0, (JNIEnv* env, jobject, jobject base, jlong offset, jboolean compressed))</span>
    JVMCIKlassHandle klass(THREAD);
<span class="line-modified">!   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);</span>
    jlong base_address = 0;
<span class="line-modified">!   if (base_object.is_non_null() &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {</span>
<span class="line-modified">!     // klass = JVMCIENV-&gt;unhandle(base_object)-&gt;klass();</span>
<span class="line-added">+     if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {</span>
<span class="line-added">+       Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);</span>
<span class="line-added">+       klass = base_oop-&gt;klass();</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(false, &quot;What types are we actually expecting here?&quot;);</span>
<span class="line-added">+     }</span>
    } else if (!compressed) {
<span class="line-modified">!     if (base_object.is_non_null()) {</span>
<span class="line-modified">!       if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {</span>
<span class="line-modified">!         base_address = (intptr_t) JVMCIENV-&gt;asMethod(base_object);</span>
<span class="line-modified">!       } else if (JVMCIENV-&gt;isa_HotSpotConstantPool(base_object)) {</span>
<span class="line-modified">!         base_address = (intptr_t) JVMCIENV-&gt;asConstantPool(base_object);</span>
<span class="line-modified">!       } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {</span>
<span class="line-modified">!         base_address = (intptr_t) JVMCIENV-&gt;asKlass(base_object);</span>
<span class="line-modified">!       } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {</span>
<span class="line-modified">!         Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!         if (base_oop-&gt;is_a(SystemDictionary::Class_klass())) {</span>
<span class="line-modified">!           base_address = cast_from_oop&lt;jlong&gt;(base_oop());</span>
<span class="line-modified">!         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (base_address == 0) {</span>
<span class="line-added">+         JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
<span class="line-added">+                     err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;, JVMCIENV-&gt;klass_name(base_object), offset, compressed ? &quot;true&quot; : &quot;false&quot;));</span>
        }
      }
      klass = *((Klass**) (intptr_t) (base_address + offset));
    } else {
<span class="line-modified">!     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
                  err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;,
<span class="line-modified">!                         base_object.is_non_null() ? JVMCIENV-&gt;klass_name(base_object) : &quot;null&quot;,</span>
                          offset, compressed ? &quot;true&quot; : &quot;false&quot;));
    }
    assert (klass == NULL || klass-&gt;is_klass(), &quot;invalid read&quot;);
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(result);</span>
  }
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, findUniqueConcreteMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
<span class="line-modified">!   Klass* holder = JVMCIENV-&gt;asKlass(jvmci_type);</span>
    if (holder-&gt;is_interface()) {
<span class="line-modified">!     JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, holder-&gt;external_name()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (method-&gt;can_be_statically_bound()) {</span>
<span class="line-added">+     JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Effectively static method %s.%s should be handled in Java code&quot;, method-&gt;method_holder()-&gt;external_name(), method-&gt;external_name()));</span>
    }
  
    methodHandle ucm;
    {
      MutexLocker locker(Compile_lock);
<span class="line-modified">!     ucm = methodHandle(THREAD, Dependencies::find_unique_concrete_method(holder, method()));</span>
    }
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(ucm, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getImplementor, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-modified">!   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
    if (!klass-&gt;is_interface()) {
      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
          err_msg(&quot;Expected interface type, got %s&quot;, klass-&gt;external_name()));
    }
    InstanceKlass* iklass = InstanceKlass::cast(klass);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,213 ***</span>
    {
      // Need Compile_lock around implementor()
      MutexLocker locker(Compile_lock);
      handle = iklass-&gt;implementor();
    }
<span class="line-modified">!   oop implementor = CompilerToVM::get_jvmci_type(handle, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, implementor);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
    return method-&gt;is_ignored_by_security_stack_walk();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jboolean, isCompilable,(JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
<span class="line-modified">!   constantPoolHandle cp = method-&gt;constMethod()-&gt;constants();</span>
<span class="line-modified">!   assert(!cp.is_null(), &quot;npe&quot;);</span>
    // don&#39;t inline method when constant pool contains a CONSTANT_Dynamic
    return !method-&gt;is_not_compilable(CompLevel_full_optimization) &amp;&amp; !cp-&gt;has_dynamic_constant();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jboolean, hasNeverInlineDirective,(JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
    return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
    return CompilerOracle::should_inline(method) || method-&gt;force_inline();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   Handle name(THREAD, JNIHandles::resolve(jname));</span>
<span class="line-modified">!   Symbol* class_name = java_lang_String::as_symbol(name(), CHECK_0);</span>
<span class="line-modified">!   if (java_lang_String::length(name()) &lt;= 1) {</span>
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Primitive type %s should be handled in Java code&quot;, class_name-&gt;as_C_string()));</span>
    }
  
    JVMCIKlassHandle resolved_klass(THREAD);
<span class="line-modified">!   if (JNIHandles::resolve(accessing_class) == NULL) {</span>
<span class="line-modified">!     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
    }
<span class="line-removed">-   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));</span>
<span class="line-removed">-   Handle class_loader(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-removed">-   Handle protection_domain(THREAD, accessing_klass-&gt;protection_domain());</span>
  
    if (resolve) {
      resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
    } else {
<span class="line-modified">!     if (class_name-&gt;char_at(0) == &#39;L&#39; &amp;&amp;</span>
<span class="line-removed">-       class_name-&gt;char_at(class_name-&gt;utf8_length()-1) == &#39;;&#39;) {</span>
        // This is a name from a signature.  Strip off the trimmings.
        // Call recursive to keep scope of strippedsym.
<span class="line-modified">!       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,</span>
<span class="line-removed">-                                                           class_name-&gt;utf8_length()-2,</span>
<span class="line-removed">-                                                           CHECK_0);</span>
        resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
<span class="line-modified">!     } else if (FieldType::is_array(class_name)) {</span>
<span class="line-modified">!       FieldArrayInfo fd;</span>
<span class="line-modified">!       // dimension and object_key in FieldArrayInfo are assigned as a side-effect</span>
<span class="line-modified">!       // of this call</span>
<span class="line-modified">!       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);</span>
<span class="line-removed">-       if (t == T_OBJECT) {</span>
<span class="line-removed">-         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),</span>
<span class="line-removed">-                                                             class_name-&gt;utf8_length()-2-fd.dimension(),</span>
<span class="line-removed">-                                                             CHECK_0);</span>
<span class="line-removed">-         // naked oop &quot;k&quot; is OK here -- we assign back into it</span>
          resolved_klass = SystemDictionary::find(strippedsym,
<span class="line-modified">!                                                              class_loader,</span>
<span class="line-modified">!                                                              protection_domain,</span>
<span class="line-modified">!                                                              CHECK_0);</span>
          if (!resolved_klass.is_null()) {
<span class="line-modified">!           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);</span>
          }
        } else {
<span class="line-modified">!         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(t))-&gt;array_klass(fd.dimension(), CHECK_0);</span>
        }
      }
    }
<span class="line-modified">!   oop result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
<span class="line-modified">!   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    return cp-&gt;name_and_type_ref_index_at(index);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
<span class="line-modified">!   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, sym());</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
<span class="line-modified">!   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, sym());</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    return cp-&gt;klass_ref_index_at(index);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    Klass* klass = cp-&gt;klass_at(index, CHECK_NULL);
    JVMCIKlassHandle resolved_klass(THREAD, klass);
    if (resolved_klass-&gt;is_instance_klass()) {
<span class="line-modified">!     InstanceKlass::cast(resolved_klass())-&gt;link_class_or_fail(THREAD);</span>
    }
<span class="line-modified">!   oop jvmci_type = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, jvmci_type);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    Klass* loading_klass = cp-&gt;pool_holder();
    bool is_accessible = false;
<span class="line-modified">!   JVMCIKlassHandle klass(THREAD, JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass));</span>
    Symbol* symbol = NULL;
<span class="line-modified">!   if (klass == NULL) {</span>
<span class="line-modified">!     symbol = cp-&gt;klass_name_at(index);</span>
    }
<span class="line-modified">!   oop result_oop;</span>
    if (!klass.is_null()) {
<span class="line-modified">!     result_oop = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);</span>
    } else {
<span class="line-modified">!     Handle result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);</span>
<span class="line-removed">-     result_oop = result();</span>
    }
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result_oop);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
<span class="line-modified">!   return JNIHandles::make_local(THREAD, appendix_oop);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    InstanceKlass* pool_holder = cp-&gt;pool_holder();
    Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
<span class="line-modified">!   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);</span>
<span class="line-modified">!   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    return cp-&gt;remap_instruction_operand_from_cache(index);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-removed">-   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
    fieldDescriptor fd;
<span class="line-modified">!   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);</span>
    LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
<span class="line-modified">!   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);</span>
<span class="line-modified">!   if (info == NULL || info-&gt;length() != 3) {</span>
      JVMCI_ERROR_NULL(&quot;info must not be null and have a length of 3&quot;);
    }
<span class="line-modified">!   info-&gt;int_at_put(0, fd.access_flags().as_int());</span>
<span class="line-modified">!   info-&gt;int_at_put(1, fd.offset());</span>
<span class="line-modified">!   info-&gt;int_at_put(2, fd.index());</span>
    JVMCIKlassHandle handle(THREAD, fd.field_holder());
<span class="line-modified">!   oop field_holder = CompilerToVM::get_jvmci_type(handle, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, field_holder);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   Klass* klass = CompilerToVM::asKlass(jvmci_type);</span>
<span class="line-removed">-   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
    if (klass-&gt;is_interface()) {
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Interface %s should be handled in Java code&quot;, klass-&gt;external_name()));</span>
    }
    if (!method-&gt;method_holder()-&gt;is_interface()) {
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Method %s is not held by an interface, this case should be handled in Java code&quot;, method-&gt;name_and_sig_as_C_string()));</span>
    }
    if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Class %s must be linked&quot;, klass-&gt;external_name()));</span>
    }
    return LinkResolver::vtable_index_of_interface_method(klass, method);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))</span>
<span class="line-modified">!   Klass* recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);</span>
<span class="line-modified">!   Klass* caller_klass = CompilerToVM::asKlass(caller_jvmci_type);</span>
<span class="line-modified">!   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
  
    Klass* resolved     = method-&gt;method_holder();
    Symbol* h_name      = method-&gt;name();
    Symbol* h_signature = method-&gt;signature();
  
<span class="line-new-header">--- 481,267 ---</span>
    {
      // Need Compile_lock around implementor()
      MutexLocker locker(Compile_lock);
      handle = iklass-&gt;implementor();
    }
<span class="line-modified">!   JVMCIObject implementor = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(implementor);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
    return method-&gt;is_ignored_by_security_stack_walk();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jboolean, isCompilable,(JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
<span class="line-modified">!   ConstantPool* cp = method-&gt;constMethod()-&gt;constants();</span>
<span class="line-modified">!   assert(cp != NULL, &quot;npe&quot;);</span>
    // don&#39;t inline method when constant pool contains a CONSTANT_Dynamic
    return !method-&gt;is_not_compilable(CompLevel_full_optimization) &amp;&amp; !cp-&gt;has_dynamic_constant();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jboolean, hasNeverInlineDirective,(JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
    return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jboolean, shouldInlineMethod,(JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
    return CompilerOracle::should_inline(method) || method-&gt;force_inline();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, lookupType, (JNIEnv* env, jobject, jstring jname, jclass accessing_class, jboolean resolve))</span>
<span class="line-modified">!   JVMCIObject name = JVMCIENV-&gt;wrap(jname);</span>
<span class="line-modified">!   const char* str = JVMCIENV-&gt;as_utf8_string(name);</span>
<span class="line-modified">!   TempNewSymbol class_name = SymbolTable::new_symbol(str);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (class_name-&gt;utf8_length() &lt;= 1) {</span>
<span class="line-added">+     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Primitive type %s should be handled in Java code&quot;, class_name-&gt;as_C_string()));</span>
    }
  
    JVMCIKlassHandle resolved_klass(THREAD);
<span class="line-modified">!   Klass* accessing_klass = NULL;</span>
<span class="line-modified">!   Handle class_loader;</span>
<span class="line-added">+   Handle protection_domain;</span>
<span class="line-added">+   if (accessing_class != NULL) {</span>
<span class="line-added">+     accessing_klass = JVMCIENV-&gt;asKlass(accessing_class);</span>
<span class="line-added">+     class_loader = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-added">+     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Use the System class loader</span>
<span class="line-added">+     class_loader = Handle(THREAD, SystemDictionary::java_system_loader());</span>
<span class="line-added">+     JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);</span>
    }
  
    if (resolve) {
      resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
<span class="line-added">+     if (resolved_klass == NULL) {</span>
<span class="line-added">+       JVMCI_THROW_MSG_NULL(ClassNotFoundException, str);</span>
<span class="line-added">+     }</span>
    } else {
<span class="line-modified">!     if (Signature::has_envelope(class_name)) {</span>
        // This is a name from a signature.  Strip off the trimmings.
        // Call recursive to keep scope of strippedsym.
<span class="line-modified">!       TempNewSymbol strippedsym = Signature::strip_envelope(class_name);</span>
        resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
<span class="line-modified">!     } else if (Signature::is_array(class_name)) {</span>
<span class="line-modified">!       SignatureStream ss(class_name, false);</span>
<span class="line-modified">!       int ndim = ss.skip_array_prefix();</span>
<span class="line-modified">!       if (ss.type() == T_OBJECT) {</span>
<span class="line-modified">!         Symbol* strippedsym = ss.as_symbol();</span>
          resolved_klass = SystemDictionary::find(strippedsym,
<span class="line-modified">!                                                 class_loader,</span>
<span class="line-modified">!                                                 protection_domain,</span>
<span class="line-modified">!                                                 CHECK_0);</span>
          if (!resolved_klass.is_null()) {
<span class="line-modified">!           resolved_klass = resolved_klass-&gt;array_klass(ndim, CHECK_0);</span>
          }
        } else {
<span class="line-modified">!         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(ss.type()))-&gt;array_klass(ndim, CHECK_0);</span>
        }
<span class="line-added">+     } else {</span>
<span class="line-added">+       resolved_klass = SystemDictionary::find(class_name, class_loader, protection_domain, CHECK_0);</span>
      }
    }
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getArrayType, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-modified">!   if (jvmci_type == NULL) {</span>
<span class="line-modified">!     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-modified">!   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject jvmci_type_object = JVMCIENV-&gt;wrap(jvmci_type);</span>
<span class="line-added">+   JVMCIKlassHandle array_klass(THREAD);</span>
<span class="line-added">+   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(jvmci_type_object)) {</span>
<span class="line-added">+     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(jvmci_type_object), JVMCI_CHECK_0);</span>
<span class="line-added">+     if (type == T_VOID) {</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     array_klass = Universe::typeArrayKlassObj(type);</span>
<span class="line-added">+     if (array_klass == NULL) {</span>
<span class="line-added">+       JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;No array klass for primitive type %s&quot;, type2name(type)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
<span class="line-added">+     if (klass == NULL) {</span>
<span class="line-added">+       JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     array_klass = klass-&gt;array_klass(CHECK_NULL);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(array_klass, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, lookupClass, (JNIEnv* env, jobject, jclass mirror))</span>
<span class="line-modified">!   requireInHotSpot(&quot;lookupClass&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   if (mirror == NULL) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIKlassHandle klass(THREAD);</span>
<span class="line-added">+   klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));</span>
<span class="line-added">+   if (klass == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_MSG_NULL(IllegalArgumentException, &quot;Primitive classes are unsupported&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-added">+   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(result));</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    return cp-&gt;name_and_type_ref_index_at(index);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
<span class="line-modified">!   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;name_ref_at(which), JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(sym);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
<span class="line-modified">!   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;signature_ref_at(which), JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(sym);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    return cp-&gt;klass_ref_index_at(index);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, resolveTypeInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    Klass* klass = cp-&gt;klass_at(index, CHECK_NULL);
    JVMCIKlassHandle resolved_klass(THREAD, klass);
    if (resolved_klass-&gt;is_instance_klass()) {
<span class="line-modified">!     InstanceKlass::cast(resolved_klass())-&gt;link_class(CHECK_NULL);</span>
<span class="line-added">+     if (!InstanceKlass::cast(resolved_klass())-&gt;is_linked()) {</span>
<span class="line-added">+       // link_class() should not return here if there is an issue.</span>
<span class="line-added">+       JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Class %s must be linked&quot;, resolved_klass()-&gt;external_name()));</span>
<span class="line-added">+     }</span>
    }
<span class="line-modified">!   JVMCIObject klassObject = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(klassObject);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, lookupKlassInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    Klass* loading_klass = cp-&gt;pool_holder();
    bool is_accessible = false;
<span class="line-modified">!   JVMCIKlassHandle klass(THREAD, JVMCIRuntime::get_klass_by_index(cp, index, is_accessible, loading_klass));</span>
    Symbol* symbol = NULL;
<span class="line-modified">!   if (klass.is_null()) {</span>
<span class="line-modified">!     constantTag tag = cp-&gt;tag_at(index);</span>
<span class="line-added">+     if (tag.is_klass()) {</span>
<span class="line-added">+       // The klass has been inserted into the constant pool</span>
<span class="line-added">+       // very recently.</span>
<span class="line-added">+       klass = cp-&gt;resolved_klass_at(index);</span>
<span class="line-added">+     } else if (tag.is_symbol()) {</span>
<span class="line-added">+       symbol = cp-&gt;symbol_at(index);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(cp-&gt;tag_at(index).is_unresolved_klass(), &quot;wrong tag&quot;);</span>
<span class="line-added">+       symbol = cp-&gt;klass_name_at(index);</span>
<span class="line-added">+     }</span>
    }
<span class="line-modified">!   JVMCIObject result;</span>
    if (!klass.is_null()) {
<span class="line-modified">!     result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);</span>
    } else {
<span class="line-modified">!     result = JVMCIENV-&gt;create_string(symbol, JVMCI_CHECK_NULL);</span>
    }
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(appendix_oop));</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    InstanceKlass* pool_holder = cp-&gt;pool_holder();
    Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
<span class="line-modified">!   methodHandle method(THREAD, JVMCIRuntime::get_method_by_index(cp, index, bc, pool_holder));</span>
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    return cp-&gt;remap_instruction_operand_from_cache(index);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, resolveFieldInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
    fieldDescriptor fd;
<span class="line-modified">!   methodHandle mh(THREAD, (jvmci_method != NULL) ? JVMCIENV-&gt;asMethod(jvmci_method) : NULL);</span>
<span class="line-added">+   LinkInfo link_info(cp, index, mh, CHECK_0);</span>
    LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
<span class="line-modified">!   JVMCIPrimitiveArray info = JVMCIENV-&gt;wrap(info_handle);</span>
<span class="line-modified">!   if (info.is_null() || JVMCIENV-&gt;get_length(info) != 3) {</span>
      JVMCI_ERROR_NULL(&quot;info must not be null and have a length of 3&quot;);
    }
<span class="line-modified">!   JVMCIENV-&gt;put_int_at(info, 0, fd.access_flags().as_int());</span>
<span class="line-modified">!   JVMCIENV-&gt;put_int_at(info, 1, fd.offset());</span>
<span class="line-modified">!   JVMCIENV-&gt;put_int_at(info, 2, fd.index());</span>
    JVMCIKlassHandle handle(THREAD, fd.field_holder());
<span class="line-modified">!   JVMCIObject field_holder = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(field_holder);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, getVtableIndexForInterfaceMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))</span>
<span class="line-modified">!   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
<span class="line-modified">!   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
    if (klass-&gt;is_interface()) {
<span class="line-modified">!     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, klass-&gt;external_name()));</span>
    }
    if (!method-&gt;method_holder()-&gt;is_interface()) {
<span class="line-modified">!     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Method %s is not held by an interface, this case should be handled in Java code&quot;, method-&gt;name_and_sig_as_C_string()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (!klass-&gt;is_instance_klass()) {</span>
<span class="line-added">+     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be instance klass&quot;, klass-&gt;external_name()));</span>
    }
    if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
<span class="line-modified">!     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be linked&quot;, klass-&gt;external_name()));</span>
    }
    return LinkResolver::vtable_index_of_interface_method(klass, method);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, resolveMethod, (JNIEnv* env, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))</span>
<span class="line-modified">!   Klass* recv_klass = JVMCIENV-&gt;asKlass(receiver_jvmci_type);</span>
<span class="line-modified">!   Klass* caller_klass = JVMCIENV-&gt;asKlass(caller_jvmci_type);</span>
<span class="line-modified">!   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
  
    Klass* resolved     = method-&gt;method_holder();
    Symbol* h_name      = method-&gt;name();
    Symbol* h_signature = method-&gt;signature();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 613,11 ***</span>
      // LinkResolver::check_method_accessability for the matching logic.
      resolved = recv_klass;
    }
  
    LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
<span class="line-modified">!   methodHandle m;</span>
    // Only do exact lookup if receiver klass has been linked.  Otherwise,
    // the vtable has not been setup, and the LinkResolver will fail.
    if (recv_klass-&gt;is_array_klass() ||
        (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
      if (resolved-&gt;is_interface()) {
<span class="line-new-header">--- 760,11 ---</span>
      // LinkResolver::check_method_accessability for the matching logic.
      resolved = recv_klass;
    }
  
    LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
<span class="line-modified">!   Method* m = NULL;</span>
    // Only do exact lookup if receiver klass has been linked.  Otherwise,
    // the vtable has not been setup, and the LinkResolver will fail.
    if (recv_klass-&gt;is_array_klass() ||
        (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
      if (resolved-&gt;is_interface()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 625,205 ***</span>
      } else {
        m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
      }
    }
  
<span class="line-modified">!   if (m.is_null()) {</span>
      // Return NULL if there was a problem with lookup (uninitialized class, etc.)
      return NULL;
    }
  
<span class="line-modified">!   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))</span>
<span class="line-modified">!   Klass* klass = CompilerToVM::asKlass(jvmci_type);</span>
    assert(klass != NULL, &quot;method must not be called for primitive types&quot;);
    return Dependencies::find_finalizable_subclass(klass) != NULL;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))</span>
<span class="line-modified">!   Klass* klass = CompilerToVM::asKlass(jvmci_type);</span>
    if (!klass-&gt;is_instance_klass()) {
      return NULL;
    }
    InstanceKlass* iklass = InstanceKlass::cast(klass);
<span class="line-modified">!   oop result = CompilerToVM::get_jvmci_method(iklass-&gt;class_initializer(), CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))</span>
    address target_addr = (address) addr;
    if (target_addr != 0x0) {
      int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
      int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
      return MAX2(ABS(off_low), ABS(off_high));
    }
    return -1;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv *, jobject,  jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
    method-&gt;set_not_c1_compilable();
    method-&gt;set_not_c2_compilable();
    method-&gt;set_dont_inline(true);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))</span>
<span class="line-modified">!   ResourceMark rm;</span>
    HandleMark hm;
<span class="line-modified">!   JNIHandleMark jni_hm;</span>
  
<span class="line-modified">!   Handle target_handle(THREAD, JNIHandles::resolve(target));</span>
<span class="line-modified">!   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));</span>
    CodeBlob* cb = NULL;
<span class="line-modified">!   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));</span>
<span class="line-modified">!   Handle speculation_log_handle(THREAD, JNIHandles::resolve(speculation_log));</span>
  
    JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
  
    TraceTime install_time(&quot;installCode&quot;, JVMCICompiler::codeInstallTimer());
<span class="line-modified">!   bool is_immutable_PIC = HotSpotCompiledCode::isImmutablePIC(compiled_code_handle) &gt; 0;</span>
<span class="line-modified">!   CodeInstaller installer(is_immutable_PIC);</span>
<span class="line-modified">!   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);</span>
  
    if (PrintCodeCacheOnCompilation) {
      stringStream s;
<span class="line-modified">!     // Dump code cache  into a buffer before locking the tty,</span>
      {
<span class="line-modified">!       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
        CodeCache::print_summary(&amp;s, false);
      }
      ttyLocker ttyl;
      tty-&gt;print_raw_cr(s.as_string());
    }
  
<span class="line-modified">!   if (result != JVMCIEnv::ok) {</span>
      assert(cb == NULL, &quot;should be&quot;);
    } else {
<span class="line-modified">!     if (installed_code_handle.not_null()) {</span>
<span class="line-modified">!       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), &quot;wrong type&quot;);</span>
<span class="line-modified">!       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         // Ensure that all updates to the InstalledCode fields are consistent.</span>
<span class="line-modified">!         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!         InstalledCode::set_address(installed_code_handle, (jlong) cb);</span>
<span class="line-modified">!         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);</span>
<span class="line-removed">-         if (cb-&gt;is_nmethod()) {</span>
<span class="line-removed">-           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {</span>
<span class="line-removed">-           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());</span>
<span class="line-removed">-           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());</span>
<span class="line-removed">-           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());</span>
<span class="line-removed">-         }</span>
        }
      }
    }
    return result;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))</span>
  #if INCLUDE_AOT
<span class="line-removed">-   ResourceMark rm;</span>
    HandleMark hm;
  
<span class="line-modified">!   Handle target_handle(THREAD, JNIHandles::resolve(target));</span>
<span class="line-modified">!   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));</span>
<span class="line-modified">!   Handle metadata_handle(THREAD, JNIHandles::resolve(metadata));</span>
  
    CodeMetadata code_metadata;
<span class="line-removed">-   CodeBlob *cb = NULL;</span>
<span class="line-removed">-   CodeInstaller installer(true /* immutable PIC compilation */);</span>
  
<span class="line-modified">!   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);</span>
<span class="line-modified">!   if (result != JVMCIEnv::ok) {</span>
      return result;
    }
  
    if (code_metadata.get_nr_pc_desc() &gt; 0) {
<span class="line-modified">!     typeArrayHandle pcArrayOop = oopFactory::new_byteArray_handle(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-modified">!     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());</span>
<span class="line-modified">!     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());</span>
    }
  
    if (code_metadata.get_scopes_size() &gt; 0) {
<span class="line-modified">!     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray_handle(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-modified">!     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());</span>
<span class="line-modified">!     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());</span>
    }
  
    RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
<span class="line-modified">!   typeArrayHandle relocArrayOop = oopFactory::new_byteArray_handle((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-modified">!   if (reloc_buffer-&gt;size() &gt; 0) {</span>
<span class="line-modified">!     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());</span>
<span class="line-modified">!   }</span>
<span class="line-removed">-   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());</span>
  
    const OopMapSet* oopMapSet = installer.oopMapSet();
    {
      ResourceMark mark;
      ImmutableOopMapBuilder builder(oopMapSet);
<span class="line-modified">!     int oopmap_size = builder.heap_size();</span>
<span class="line-modified">!     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray_handle(oopmap_size, CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-modified">!     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));</span>
<span class="line-modified">!     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());</span>
    }
  
    AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
  
    int nr_meta_refs = recorder-&gt;nr_meta_refs();
<span class="line-modified">!   objArrayOop metadataArray = oopFactory::new_objectArray(nr_meta_refs, CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-removed">-   objArrayHandle metadataArrayHandle(THREAD, metadataArray);</span>
    for (int i = 0; i &lt; nr_meta_refs; ++i) {
      jobject element = recorder-&gt;meta_element(i);
      if (element == NULL) {
<span class="line-modified">!       return JVMCIEnv::cache_full;</span>
      }
<span class="line-modified">!     metadataArrayHandle-&gt;obj_at_put(i, JNIHandles::resolve(element));</span>
    }
<span class="line-modified">!   HotSpotMetaData::set_metadata(metadata_handle, metadataArrayHandle());</span>
  
    ExceptionHandlerTable* handler = code_metadata.get_exception_table();
    int table_size = handler-&gt;size_in_bytes();
<span class="line-modified">!   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray_handle(table_size, CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-removed">- </span>
    if (table_size &gt; 0) {
<span class="line-modified">!     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));</span>
    }
<span class="line-modified">!   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());</span>
  
    return result;
  #else
<span class="line-modified">!   THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;unimplemented&quot;);</span>
  #endif
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))</span>
    JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
    CompilerStatistics* stats = compiler-&gt;stats();
    stats-&gt;_standard.reset();
    stats-&gt;_osr.reset();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))</span>
<span class="line-removed">-   ResourceMark rm;</span>
    HandleMark hm;
  
    if (installedCode == NULL) {
<span class="line-modified">!     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), &quot;installedCode is null&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   jlong codeBlob = InstalledCode::address(installedCode);</span>
<span class="line-removed">-   if (codeBlob == 0L) {</span>
<span class="line-removed">-     return NULL;</span>
    }
  
<span class="line-modified">!   CodeBlob* cb = (CodeBlob*) (address) codeBlob;</span>
    if (cb == NULL) {
      return NULL;
    }
  
    // We don&#39;t want the stringStream buffer to resize during disassembly as it
<span class="line-new-header">--- 772,213 ---</span>
      } else {
        m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
      }
    }
  
<span class="line-modified">!   if (m == NULL) {</span>
      // Return NULL if there was a problem with lookup (uninitialized class, etc.)
      return NULL;
    }
  
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(methodHandle(THREAD, m), JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jboolean, hasFinalizableSubclass,(JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-modified">!   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
    assert(klass != NULL, &quot;method must not be called for primitive types&quot;);
    return Dependencies::find_finalizable_subclass(klass) != NULL;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getClassInitializer, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-modified">!   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
    if (!klass-&gt;is_instance_klass()) {
      return NULL;
    }
    InstanceKlass* iklass = InstanceKlass::cast(klass);
<span class="line-modified">!   methodHandle clinit(THREAD, iklass-&gt;class_initializer());</span>
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(clinit, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jlong, getMaxCallTargetOffset, (JNIEnv* env, jobject, jlong addr))</span>
    address target_addr = (address) addr;
    if (target_addr != 0x0) {
      int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
      int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
      return MAX2(ABS(off_low), ABS(off_high));
    }
    return -1;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv* env, jobject,  jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
    method-&gt;set_not_c1_compilable();
    method-&gt;set_not_c2_compilable();
    method-&gt;set_dont_inline(true);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, installCode, (JNIEnv *env, jobject, jobject target, jobject compiled_code,</span>
<span class="line-modified">!             jobject installed_code, jlong failed_speculations_address, jbyteArray speculations_obj))</span>
    HandleMark hm;
<span class="line-modified">!   JNIHandleMark jni_hm(thread);</span>
  
<span class="line-modified">!   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);</span>
<span class="line-modified">!   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);</span>
    CodeBlob* cb = NULL;
<span class="line-modified">!   JVMCIObject installed_code_handle = JVMCIENV-&gt;wrap(installed_code);</span>
<span class="line-modified">!   JVMCIPrimitiveArray speculations_handle = JVMCIENV-&gt;wrap(speculations_obj);</span>
<span class="line-added">+ </span>
<span class="line-added">+   int speculations_len = JVMCIENV-&gt;get_length(speculations_handle);</span>
<span class="line-added">+   char* speculations = NEW_RESOURCE_ARRAY(char, speculations_len);</span>
<span class="line-added">+   JVMCIENV-&gt;copy_bytes_to(speculations_handle, (jbyte*) speculations, 0, speculations_len);</span>
  
    JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
  
    TraceTime install_time(&quot;installCode&quot;, JVMCICompiler::codeInstallTimer());
<span class="line-modified">!   bool is_immutable_PIC = JVMCIENV-&gt;get_HotSpotCompiledCode_isImmutablePIC(compiled_code_handle) &gt; 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   CodeInstaller installer(JVMCIENV, is_immutable_PIC);</span>
<span class="line-added">+   JVMCI::CodeInstallResult result = installer.install(compiler,</span>
<span class="line-added">+       target_handle,</span>
<span class="line-added">+       compiled_code_handle,</span>
<span class="line-added">+       cb,</span>
<span class="line-added">+       installed_code_handle,</span>
<span class="line-added">+       (FailedSpeculation**)(address) failed_speculations_address,</span>
<span class="line-added">+       speculations,</span>
<span class="line-added">+       speculations_len,</span>
<span class="line-added">+       JVMCI_CHECK_0);</span>
  
    if (PrintCodeCacheOnCompilation) {
      stringStream s;
<span class="line-modified">!     // Dump code cache into a buffer before locking the tty,</span>
      {
<span class="line-modified">!       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
        CodeCache::print_summary(&amp;s, false);
      }
      ttyLocker ttyl;
      tty-&gt;print_raw_cr(s.as_string());
    }
  
<span class="line-modified">!   if (result != JVMCI::ok) {</span>
      assert(cb == NULL, &quot;should be&quot;);
    } else {
<span class="line-modified">!     if (installed_code_handle.is_non_null()) {</span>
<span class="line-modified">!       if (cb-&gt;is_nmethod()) {</span>
<span class="line-modified">!         assert(JVMCIENV-&gt;isa_HotSpotNmethod(installed_code_handle), &quot;wrong type&quot;);</span>
<span class="line-modified">!         // Clear the link to an old nmethod first</span>
<span class="line-modified">!         JVMCIObject nmethod_mirror = installed_code_handle;</span>
<span class="line-modified">!         JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK_0);</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         assert(JVMCIENV-&gt;isa_InstalledCode(installed_code_handle), &quot;wrong type&quot;);</span>
        }
<span class="line-added">+       // Initialize the link to the new code blob</span>
<span class="line-added">+       JVMCIENV-&gt;initialize_installed_code(installed_code_handle, cb, JVMCI_CHECK_0);</span>
      }
    }
    return result;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, getMetadata, (JNIEnv *env, jobject, jobject target, jobject compiled_code, jobject metadata))</span>
  #if INCLUDE_AOT
    HandleMark hm;
<span class="line-added">+   assert(JVMCIENV-&gt;is_hotspot(), &quot;AOT code is executed only in HotSpot mode&quot;);</span>
  
<span class="line-modified">!   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);</span>
<span class="line-modified">!   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);</span>
<span class="line-modified">!   JVMCIObject metadata_handle = JVMCIENV-&gt;wrap(metadata);</span>
  
    CodeMetadata code_metadata;
  
<span class="line-modified">!   CodeInstaller installer(JVMCIENV, true /* immutable PIC compilation */);</span>
<span class="line-modified">!   JVMCI::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, JVMCI_CHECK_0);</span>
<span class="line-added">+   if (result != JVMCI::ok) {</span>
      return result;
    }
  
    if (code_metadata.get_nr_pc_desc() &gt; 0) {
<span class="line-modified">!     int size = sizeof(PcDesc) * code_metadata.get_nr_pc_desc();</span>
<span class="line-modified">!     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));</span>
<span class="line-modified">!     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_pc_desc(), array, 0, size);</span>
<span class="line-added">+     HotSpotJVMCI::HotSpotMetaData::set_pcDescBytes(JVMCIENV, metadata_handle, array);</span>
    }
  
    if (code_metadata.get_scopes_size() &gt; 0) {
<span class="line-modified">!     int size = code_metadata.get_scopes_size();</span>
<span class="line-modified">!     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));</span>
<span class="line-modified">!     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_scopes_desc(), array, 0, size);</span>
<span class="line-added">+     HotSpotJVMCI::HotSpotMetaData::set_scopesDescBytes(JVMCIENV, metadata_handle, array);</span>
    }
  
    RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
<span class="line-modified">!   int size = (int) reloc_buffer-&gt;size();</span>
<span class="line-modified">!   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));</span>
<span class="line-modified">!   JVMCIENV-&gt;copy_bytes_from((jbyte*) reloc_buffer-&gt;begin(), array, 0, size);</span>
<span class="line-modified">!   HotSpotJVMCI::HotSpotMetaData::set_relocBytes(JVMCIENV, metadata_handle, array);</span>
  
    const OopMapSet* oopMapSet = installer.oopMapSet();
    {
      ResourceMark mark;
      ImmutableOopMapBuilder builder(oopMapSet);
<span class="line-modified">!     int size = builder.heap_size();</span>
<span class="line-modified">!     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));</span>
<span class="line-modified">!     builder.generate_into((address) HotSpotJVMCI::resolve(array)-&gt;byte_at_addr(0));</span>
<span class="line-modified">!     HotSpotJVMCI::HotSpotMetaData::set_oopMaps(JVMCIENV, metadata_handle, array);</span>
    }
  
    AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
  
    int nr_meta_refs = recorder-&gt;nr_meta_refs();
<span class="line-modified">!   JVMCIObjectArray metadataArray = JVMCIENV-&gt;new_Object_array(nr_meta_refs, JVMCI_CHECK_(JVMCI::cache_full));</span>
    for (int i = 0; i &lt; nr_meta_refs; ++i) {
      jobject element = recorder-&gt;meta_element(i);
      if (element == NULL) {
<span class="line-modified">!       return JVMCI::cache_full;</span>
      }
<span class="line-modified">!     JVMCIENV-&gt;put_object_at(metadataArray, i, JVMCIENV-&gt;wrap(element));</span>
    }
<span class="line-modified">!   HotSpotJVMCI::HotSpotMetaData::set_metadata(JVMCIENV, metadata_handle, metadataArray);</span>
  
    ExceptionHandlerTable* handler = code_metadata.get_exception_table();
    int table_size = handler-&gt;size_in_bytes();
<span class="line-modified">!   JVMCIPrimitiveArray exceptionArray = JVMCIENV-&gt;new_byteArray(table_size, JVMCI_CHECK_(JVMCI::cache_full));</span>
    if (table_size &gt; 0) {
<span class="line-modified">!     handler-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(exceptionArray)-&gt;byte_at_addr(0));</span>
    }
<span class="line-modified">!   HotSpotJVMCI::HotSpotMetaData::set_exceptionBytes(JVMCIENV, metadata_handle, exceptionArray);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ImplicitExceptionTable* implicit = code_metadata.get_implicit_exception_table();</span>
<span class="line-added">+   int implicit_table_size = implicit-&gt;size_in_bytes();</span>
<span class="line-added">+   JVMCIPrimitiveArray implicitExceptionArray = JVMCIENV-&gt;new_byteArray(implicit_table_size, JVMCI_CHECK_(JVMCI::cache_full));</span>
<span class="line-added">+   if (implicit_table_size &gt; 0) {</span>
<span class="line-added">+     implicit-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(implicitExceptionArray)-&gt;byte_at_addr(0), implicit_table_size);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   HotSpotJVMCI::HotSpotMetaData::set_implicitExceptionBytes(JVMCIENV, metadata_handle, implicitExceptionArray);</span>
  
    return result;
  #else
<span class="line-modified">!   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);</span>
  #endif
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv* env, jobject))</span>
    JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
    CompilerStatistics* stats = compiler-&gt;stats();
    stats-&gt;_standard.reset();
    stats-&gt;_osr.reset();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, disassembleCodeBlob, (JNIEnv* env, jobject, jobject installedCode))</span>
    HandleMark hm;
  
    if (installedCode == NULL) {
<span class="line-modified">!     JVMCI_THROW_MSG_NULL(NullPointerException, &quot;installedCode is null&quot;);</span>
    }
  
<span class="line-modified">!   JVMCIObject installedCodeObject = JVMCIENV-&gt;wrap(installedCode);</span>
<span class="line-added">+   nmethodLocker locker;</span>
<span class="line-added">+   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(installedCodeObject, locker);</span>
    if (cb == NULL) {
      return NULL;
    }
  
    // We don&#39;t want the stringStream buffer to resize during disassembly as it
</pre>
<hr />
<pre>
<span class="line-old-header">*** 844,49 ***</span>
    Disassembler::decode(cb, &amp;st);
    if (st.size() &lt;= 0) {
      return NULL;
    }
  
<span class="line-modified">!   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result());</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))</span>
<span class="line-removed">-   ResourceMark rm;</span>
    HandleMark hm;
  
<span class="line-modified">!   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
<span class="line-modified">!   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, element);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))</span>
<span class="line-modified">!   ResourceMark rm;</span>
    HandleMark hm;
  
<span class="line-modified">!   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);</span>
<span class="line-modified">!   if (nmethodValue == 0L) {</span>
<span class="line-modified">!     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());</span>
    }
<span class="line-modified">!   nmethod* nm = (nmethod*) (address) nmethodValue;</span>
<span class="line-removed">-   methodHandle mh = nm-&gt;method();</span>
    Symbol* signature = mh-&gt;signature();
    JavaCallArguments jca(mh-&gt;size_of_parameters());
  
    JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
<span class="line-modified">!   JavaValue result(jap.get_ret_type());</span>
    jca.set_alternative_target(nm);
    JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
  
<span class="line-modified">!   if (jap.get_ret_type() == T_VOID) {</span>
      return NULL;
<span class="line-modified">!   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {</span>
<span class="line-modified">!     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());</span>
    } else {
      jvalue *value = (jvalue *) result.get_value_addr();
      // Narrow the value down if required (Important on big endian machines)
<span class="line-modified">!     switch (jap.get_ret_type()) {</span>
        case T_BOOLEAN:
         value-&gt;z = (jboolean) value-&gt;i;
         break;
        case T_BYTE:
         value-&gt;b = (jbyte) value-&gt;i;
<span class="line-new-header">--- 999,52 ---</span>
    Disassembler::decode(cb, &amp;st);
    if (st.size() &lt;= 0) {
      return NULL;
    }
  
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;create_string(st.as_string(), JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, jobject jvmci_method, int bci))</span>
    HandleMark hm;
  
<span class="line-modified">!   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
<span class="line-modified">!   JVMCIObject element = JVMCIENV-&gt;new_StackTraceElement(method, bci, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(element);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, executeHotSpotNmethod, (JNIEnv* env, jobject, jobject args, jobject hs_nmethod))</span>
<span class="line-modified">!   // The incoming arguments array would have to contain JavaConstants instead of regular objects</span>
<span class="line-added">+   // and the return value would have to be wrapped as a JavaConstant.</span>
<span class="line-added">+   requireInHotSpot(&quot;executeHotSpotNmethod&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">+ </span>
    HandleMark hm;
  
<span class="line-modified">!   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);</span>
<span class="line-modified">!   nmethodLocker locker;</span>
<span class="line-modified">!   nmethod* nm = JVMCIENV-&gt;get_nmethod(nmethod_mirror, locker);</span>
<span class="line-added">+   if (nm == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_NULL(InvalidInstalledCodeException);</span>
    }
<span class="line-modified">!   methodHandle mh(THREAD, nm-&gt;method());</span>
    Symbol* signature = mh-&gt;signature();
    JavaCallArguments jca(mh-&gt;size_of_parameters());
  
    JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
<span class="line-modified">!   JavaValue result(jap.return_type());</span>
    jca.set_alternative_target(nm);
    JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
  
<span class="line-modified">!   if (jap.return_type() == T_VOID) {</span>
      return NULL;
<span class="line-modified">!   } else if (is_reference_type(jap.return_type())) {</span>
<span class="line-modified">!     return JNIHandles::make_local((oop) result.get_jobject());</span>
    } else {
      jvalue *value = (jvalue *) result.get_value_addr();
      // Narrow the value down if required (Important on big endian machines)
<span class="line-modified">!     switch (jap.return_type()) {</span>
        case T_BOOLEAN:
         value-&gt;z = (jboolean) value-&gt;i;
         break;
        case T_BYTE:
         value-&gt;b = (jbyte) value-&gt;i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 898,59 ***</span>
         value-&gt;s = (jshort) value-&gt;i;
         break;
        default:
          break;
      }
<span class="line-modified">!     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);</span>
<span class="line-modified">!     return JNIHandles::make_local(THREAD, o);</span>
    }
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
    if (!method-&gt;has_linenumber_table()) {
      return NULL;
    }
    u2 num_entries = 0;
    CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
    while (streamForSize.read_pair()) {
      num_entries++;
    }
  
    CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
<span class="line-modified">!   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);</span>
  
    int i = 0;
    jlong value;
    while (stream.read_pair()) {
      value = ((long) stream.bci());
<span class="line-modified">!     result-&gt;long_at_put(i, value);</span>
      value = ((long) stream.line());
<span class="line-modified">!     result-&gt;long_at_put(i + 1, value);</span>
      i += 2;
    }
  
<span class="line-modified">!   return (jlongArray) JNIHandles::make_local(THREAD, result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-removed">-   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
    if (!method-&gt;has_localvariable_table()) {
      return 0;
    }
    return (jlong) (address) method-&gt;localvariable_table_start();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-removed">-   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
    return method-&gt;localvariable_table_length();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
    MethodCounters* mcs = method-&gt;method_counters();
    if (mcs != NULL) {
      mcs-&gt;clear_counters();
    }
    NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
<span class="line-new-header">--- 1056,57 ---</span>
         value-&gt;s = (jshort) value-&gt;i;
         break;
        default:
          break;
      }
<span class="line-modified">!     JVMCIObject o = JVMCIENV-&gt;create_box(jap.return_type(), value, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!     return JVMCIENV-&gt;get_jobject(o);</span>
    }
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jlongArray, getLineNumberTable, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
    if (!method-&gt;has_linenumber_table()) {
      return NULL;
    }
    u2 num_entries = 0;
    CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
    while (streamForSize.read_pair()) {
      num_entries++;
    }
  
    CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
<span class="line-modified">!   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(2 * num_entries, JVMCI_CHECK_NULL);</span>
  
    int i = 0;
    jlong value;
    while (stream.read_pair()) {
      value = ((long) stream.bci());
<span class="line-modified">!     JVMCIENV-&gt;put_long_at(result, i, value);</span>
      value = ((long) stream.line());
<span class="line-modified">!     JVMCIENV-&gt;put_long_at(result, i + 1, value);</span>
      i += 2;
    }
  
<span class="line-modified">!   return (jlongArray) JVMCIENV-&gt;get_jobject(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jlong, getLocalVariableTableStart, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
    if (!method-&gt;has_localvariable_table()) {
      return 0;
    }
    return (jlong) (address) method-&gt;localvariable_table_start();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, getLocalVariableTableLength, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
    return method-&gt;localvariable_table_length();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, reprofile, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
    MethodCounters* mcs = method-&gt;method_counters();
    if (mcs != NULL) {
      mcs-&gt;clear_counters();
    }
    NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 969,56 ***</span>
      method_data-&gt;initialize();
    }
  C2V_END
  
  
<span class="line-modified">! C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))</span>
<span class="line-modified">!   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));</span>
<span class="line-modified">!   nmethod::invalidate_installed_code(installed_code_handle, CHECK);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))</span>
<span class="line-modified">!   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);</span>
<span class="line-removed">-   JavaThread::collect_counters(arrayOop);</span>
<span class="line-removed">-   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))</span>
    HandleMark hm;
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   if (JNIHandles::resolve(jvmci_method) == NULL) {</span>
<span class="line-removed">-     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
    }
<span class="line-modified">!   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
    if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;Unexpected bci %d&quot;, entry_bci));</span>
    }
    return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
  C2V_END
  
  
<span class="line-modified">! C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))</span>
<span class="line-modified">!   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);</span>
    return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))</span>
<span class="line-modified">!   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
    return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))</span>
<span class="line-modified">!   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, sym());</span>
  C2V_END
  
<span class="line-modified">! bool matches(jobjectArray methods, Method* method) {</span>
    objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
  
    for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
      oop resolved = methods_oop-&gt;obj_at(i);
<span class="line-modified">!     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {</span>
        return true;
      }
    }
    return false;
  }
<span class="line-new-header">--- 1125,73 ---</span>
      method_data-&gt;initialize();
    }
  C2V_END
  
  
<span class="line-modified">! C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod))</span>
<span class="line-modified">!   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);</span>
<span class="line-modified">!   JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, readUncompressedOop, (JNIEnv* env, jobject, jlong addr))</span>
<span class="line-added">+   oop ret = RawAccess&lt;&gt;::oop_load((oop*)(address)addr);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(ret));</span>
<span class="line-added">+  C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jlongArray, collectCounters, (JNIEnv* env, jobject))</span>
<span class="line-added">+   // Returns a zero length array if counters aren&#39;t enabled</span>
<span class="line-added">+   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_longArray(JVMCICounterSize, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   if (JVMCICounterSize &gt; 0) {</span>
<span class="line-added">+     jlong* temp_array = NEW_RESOURCE_ARRAY(jlong, JVMCICounterSize);</span>
<span class="line-added">+     JavaThread::collect_counters(temp_array, JVMCICounterSize);</span>
<span class="line-added">+     JVMCIENV-&gt;copy_longs_from(temp_array, array, 0, JVMCICounterSize);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return (jlongArray) JVMCIENV-&gt;get_jobject(array);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jint, getCountersSize, (JNIEnv* env, jobject))</span>
<span class="line-added">+   return (jint) JVMCICounterSize;</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, setCountersSize, (JNIEnv* env, jobject, jint new_size))</span>
<span class="line-modified">!   JavaThread::resize_all_jvmci_counters(new_size);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci))</span>
    HandleMark hm;
<span class="line-modified">!   if (jvmci_method == NULL) {</span>
<span class="line-modified">!     JVMCI_THROW_0(NullPointerException);</span>
    }
<span class="line-modified">!   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
    if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
<span class="line-modified">!     JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Unexpected bci %d&quot;, entry_bci));</span>
    }
    return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
  C2V_END
  
  
<span class="line-modified">! C2V_VMENTRY_0(jboolean, isMature, (JNIEnv* env, jobject, jlong metaspace_method_data))</span>
<span class="line-modified">!   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);</span>
    return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jboolean, hasCompiledCodeForOSR, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci, int comp_level))</span>
<span class="line-modified">!   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
    return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getSymbol, (JNIEnv* env, jobject, jlong symbol))</span>
<span class="line-modified">!   JVMCIObject sym = JVMCIENV-&gt;create_string((Symbol*)(address)symbol, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(sym);</span>
  C2V_END
  
<span class="line-modified">! bool matches(jobjectArray methods, Method* method, JVMCIEnv* JVMCIENV) {</span>
    objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
  
    for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
      oop resolved = methods_oop-&gt;obj_at(i);
<span class="line-modified">!     if ((resolved-&gt;klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; HotSpotJVMCI::asMethod(JVMCIENV, resolved) == method) {</span>
        return true;
      }
    }
    return false;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1028,29 ***</span>
    Handle receiver = args-&gt;receiver();
    Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
    LinkInfo link_info(spec_klass, name, signature);
    LinkResolver::resolve_interface_call(
            callinfo, receiver, recvrKlass, link_info, true, CHECK);
<span class="line-modified">!   methodHandle method = callinfo.selected_method();</span>
    assert(method.not_null(), &quot;should have thrown exception&quot;);
  
    // Invoke the method
    JavaCalls::call(result, method, args, CHECK);
  }
  
<span class="line-modified">! C2V_VMENTRY(jobject, iterateFrames, (JNIEnv*, jobject compilerToVM, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, jobject visitor_handle))</span>
<span class="line-removed">-   ResourceMark rm;</span>
  
    if (!thread-&gt;has_last_Java_frame()) {
      return NULL;
    }
    Handle visitor(THREAD, JNIHandles::resolve_non_null(visitor_handle));
<span class="line-removed">-   Handle frame_reference = HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);</span>
<span class="line-removed">-   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);</span>
  
<span class="line-modified">!   StackFrameStream fst(thread);</span>
  
    jobjectArray methods = initial_methods;
  
    int frame_number = 0;
    vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
  
<span class="line-new-header">--- 1201,30 ---</span>
    Handle receiver = args-&gt;receiver();
    Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
    LinkInfo link_info(spec_klass, name, signature);
    LinkResolver::resolve_interface_call(
            callinfo, receiver, recvrKlass, link_info, true, CHECK);
<span class="line-modified">!   methodHandle method(THREAD, callinfo.selected_method());</span>
    assert(method.not_null(), &quot;should have thrown exception&quot;);
  
    // Invoke the method
    JavaCalls::call(result, method, args, CHECK);
  }
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, iterateFrames, (JNIEnv* env, jobject compilerToVM, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, jobject visitor_handle))</span>
  
    if (!thread-&gt;has_last_Java_frame()) {
      return NULL;
    }
    Handle visitor(THREAD, JNIHandles::resolve_non_null(visitor_handle));
  
<span class="line-modified">!   requireInHotSpot(&quot;iterateFrames&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);</span>
<span class="line-added">+   Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);</span>
  
<span class="line-added">+   StackFrameStream fst(thread);</span>
    jobjectArray methods = initial_methods;
  
    int frame_number = 0;
    vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1060,11 ***</span>
      while (true) {
        StackValueCollection* locals = NULL;
        if (vf-&gt;is_compiled_frame()) {
          // compiled method frame
          compiledVFrame* cvf = compiledVFrame::cast(vf);
<span class="line-modified">!         if (methods == NULL || matches(methods, cvf-&gt;method())) {</span>
            if (initialSkip &gt; 0) {
              initialSkip--;
            } else {
              ScopeDesc* scope = cvf-&gt;scope();
              // native wrappers do not have a scope
<span class="line-new-header">--- 1234,11 ---</span>
      while (true) {
        StackValueCollection* locals = NULL;
        if (vf-&gt;is_compiled_frame()) {
          // compiled method frame
          compiledVFrame* cvf = compiledVFrame::cast(vf);
<span class="line-modified">!         if (methods == NULL || matches(methods, cvf-&gt;method(), JVMCIENV)) {</span>
            if (initialSkip &gt; 0) {
              initialSkip--;
            } else {
              ScopeDesc* scope = cvf-&gt;scope();
              // native wrappers do not have a scope
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1080,11 ***</span>
                    if (sv-&gt;value().is_null()) {
                      objects-&gt;append(sv);
                    }
                  }
                }
<span class="line-modified">!               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), objects, CHECK_NULL);</span>
                Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);
                realloc_called = true;
  
                GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
                assert(local_values != NULL, &quot;NULL locals&quot;);
<span class="line-new-header">--- 1254,11 ---</span>
                    if (sv-&gt;value().is_null()) {
                      objects-&gt;append(sv);
                    }
                  }
                }
<span class="line-modified">!               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);</span>
                Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);
                realloc_called = true;
  
                GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
                assert(local_values != NULL, &quot;NULL locals&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1094,67 ***</span>
                  ScopeValue* value = local_values-&gt;at(i);
                  if (value-&gt;is_object()) {
                    array-&gt;bool_at_put(i, true);
                  }
                }
<span class="line-modified">!               HotSpotStackFrameReference::set_localIsVirtual(frame_reference, array());</span>
              } else {
<span class="line-modified">!               HotSpotStackFrameReference::set_localIsVirtual(frame_reference, NULL);</span>
              }
  
              locals = cvf-&gt;locals();
<span class="line-modified">!             HotSpotStackFrameReference::set_bci(frame_reference, cvf-&gt;bci());</span>
<span class="line-modified">!             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);</span>
<span class="line-modified">!             HotSpotStackFrameReference::set_method(frame_reference, method);</span>
            }
          }
        } else if (vf-&gt;is_interpreted_frame()) {
          // interpreted method frame
          interpretedVFrame* ivf = interpretedVFrame::cast(vf);
<span class="line-modified">!         if (methods == NULL || matches(methods, ivf-&gt;method())) {</span>
            if (initialSkip &gt; 0) {
              initialSkip--;
            } else {
              locals = ivf-&gt;locals();
<span class="line-modified">!             HotSpotStackFrameReference::set_bci(frame_reference, ivf-&gt;bci());</span>
<span class="line-modified">!             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);</span>
<span class="line-modified">!             HotSpotStackFrameReference::set_method(frame_reference, method);</span>
<span class="line-modified">!             HotSpotStackFrameReference::set_localIsVirtual(frame_reference, NULL);</span>
            }
          }
        }
  
        // locals != NULL means that we found a matching frame and result is already partially initialized
        if (locals != NULL) {
          methods = match_methods;
<span class="line-modified">!         HotSpotStackFrameReference::set_compilerToVM(frame_reference, JNIHandles::resolve(compilerToVM));</span>
<span class="line-modified">!         HotSpotStackFrameReference::set_stackPointer(frame_reference, (jlong) fst.current()-&gt;sp());</span>
<span class="line-modified">!         HotSpotStackFrameReference::set_frameNumber(frame_reference, frame_number);</span>
  
          // initialize the locals array
          objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
          objArrayHandle array(THREAD, array_oop);
          for (int i = 0; i &lt; locals-&gt;size(); i++) {
            StackValue* var = locals-&gt;at(i);
            if (var-&gt;type() == T_OBJECT) {
              array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
            }
          }
<span class="line-modified">!         HotSpotStackFrameReference::set_locals(frame_reference, array());</span>
<span class="line-modified">!         HotSpotStackFrameReference::set_objectsMaterialized(frame_reference, JNI_FALSE);</span>
  
          JavaValue result(T_OBJECT);
          JavaCallArguments args(visitor);
          args.push_oop(frame_reference);
<span class="line-modified">!         call_interface(&amp;result, SystemDictionary::InspectedFrameVisitor_klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &amp;args, CHECK_NULL);</span>
          if (result.get_jobject() != NULL) {
            return JNIHandles::make_local(thread, (oop) result.get_jobject());
          }
          assert(initialSkip == 0, &quot;There should be no match before initialSkip == 0&quot;);
<span class="line-modified">!         if (HotSpotStackFrameReference::objectsMaterialized(frame_reference) == JNI_TRUE) {</span>
            // the frame has been deoptimized, we need to re-synchronize the frame and vframe
<span class="line-modified">!           intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(frame_reference);</span>
            fst = StackFrameStream(thread);
            while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
              fst.next();
            }
            if (fst.current()-&gt;sp() != stack_pointer) {
<span class="line-new-header">--- 1268,69 ---</span>
                  ScopeValue* value = local_values-&gt;at(i);
                  if (value-&gt;is_object()) {
                    array-&gt;bool_at_put(i, true);
                  }
                }
<span class="line-modified">!               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());</span>
              } else {
<span class="line-modified">!               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);</span>
              }
  
              locals = cvf-&gt;locals();
<span class="line-modified">!             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf-&gt;bci());</span>
<span class="line-modified">!             methodHandle mh(THREAD, cvf-&gt;method());</span>
<span class="line-modified">!             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);</span>
<span class="line-added">+             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));</span>
            }
          }
        } else if (vf-&gt;is_interpreted_frame()) {
          // interpreted method frame
          interpretedVFrame* ivf = interpretedVFrame::cast(vf);
<span class="line-modified">!         if (methods == NULL || matches(methods, ivf-&gt;method(), JVMCIENV)) {</span>
            if (initialSkip &gt; 0) {
              initialSkip--;
            } else {
              locals = ivf-&gt;locals();
<span class="line-modified">!             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf-&gt;bci());</span>
<span class="line-modified">!             methodHandle mh(THREAD, ivf-&gt;method());</span>
<span class="line-modified">!             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));</span>
<span class="line-added">+             HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);</span>
            }
          }
        }
  
        // locals != NULL means that we found a matching frame and result is already partially initialized
        if (locals != NULL) {
          methods = match_methods;
<span class="line-modified">!         HotSpotJVMCI::HotSpotStackFrameReference::set_compilerToVM(JVMCIENV, frame_reference(), JNIHandles::resolve(compilerToVM));</span>
<span class="line-modified">!         HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) fst.current()-&gt;sp());</span>
<span class="line-modified">!         HotSpotJVMCI::HotSpotStackFrameReference::set_frameNumber(JVMCIENV, frame_reference(), frame_number);</span>
  
          // initialize the locals array
          objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
          objArrayHandle array(THREAD, array_oop);
          for (int i = 0; i &lt; locals-&gt;size(); i++) {
            StackValue* var = locals-&gt;at(i);
            if (var-&gt;type() == T_OBJECT) {
              array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
            }
          }
<span class="line-modified">!         HotSpotJVMCI::HotSpotStackFrameReference::set_locals(JVMCIENV, frame_reference(), array());</span>
<span class="line-modified">!         HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, frame_reference(), JNI_FALSE);</span>
  
          JavaValue result(T_OBJECT);
          JavaCallArguments args(visitor);
          args.push_oop(frame_reference);
<span class="line-modified">!         call_interface(&amp;result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &amp;args, CHECK_NULL);</span>
          if (result.get_jobject() != NULL) {
            return JNIHandles::make_local(thread, (oop) result.get_jobject());
          }
          assert(initialSkip == 0, &quot;There should be no match before initialSkip == 0&quot;);
<span class="line-modified">!         if (HotSpotJVMCI::HotSpotStackFrameReference::objectsMaterialized(JVMCIENV, frame_reference()) == JNI_TRUE) {</span>
            // the frame has been deoptimized, we need to re-synchronize the frame and vframe
<span class="line-modified">!           intptr_t* stack_pointer = (intptr_t*) HotSpotJVMCI::HotSpotStackFrameReference::stackPointer(JVMCIENV, frame_reference());</span>
            fst = StackFrameStream(thread);
            while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
              fst.next();
            }
            if (fst.current()-&gt;sp() != stack_pointer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1170,12 ***</span>
              }
              vf = vf-&gt;sender();
              assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
            }
          }
<span class="line-modified">!         frame_reference = HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);</span>
<span class="line-modified">!         HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);</span>
        }
  
        if (vf-&gt;is_top()) {
          break;
        }
<span class="line-new-header">--- 1346,12 ---</span>
              }
              vf = vf-&gt;sender();
              assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
            }
          }
<span class="line-modified">!         frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);</span>
<span class="line-modified">!         HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);</span>
        }
  
        if (vf-&gt;is_top()) {
          break;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1193,32 ***</span>
  
    // the end was reached without finding a matching method
    return NULL;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    CallInfo callInfo;
    LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
    ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
    cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
    Symbol* name = cp-&gt;name_ref_at(index);
    if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
      CallInfo callInfo;
      LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
      ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
      cp_cache_entry-&gt;set_method_handle(cp, callInfo);
    }
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jint, isResolvedInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
    ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
    if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
      // MethodHandle.invoke* --&gt; LambdaForm?
      ResourceMark rm;
  
<span class="line-new-header">--- 1369,32 ---</span>
  
    // the end was reached without finding a matching method
    return NULL;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    CallInfo callInfo;
    LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
    ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
    cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
    Symbol* name = cp-&gt;name_ref_at(index);
    if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
      CallInfo callInfo;
      LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
      ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
      cp_cache_entry-&gt;set_method_handle(cp, callInfo);
    }
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, isResolvedInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">!   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
    ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
    if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
      // MethodHandle.invoke* --&gt; LambdaForm?
      ResourceMark rm;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1229,22 ***</span>
      Symbol* name_sym = cp-&gt;name_ref_at(index);
  
      vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), &quot;!&quot;);
      vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), &quot;!&quot;);
  
<span class="line-modified">!     methodHandle adapter_method(cp_cache_entry-&gt;f1_as_method());</span>
  
      methodHandle resolved_method(adapter_method);
  
      // Can we treat it as a regular invokevirtual?
      if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
        vmassert(!resolved_method-&gt;is_static(),&quot;!&quot;);
        vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),&quot;!&quot;);
        vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), &quot;!&quot;);
        vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, &quot;!&quot;);
  
<span class="line-modified">!       methodHandle m(LinkResolver::linktime_resolve_virtual_method_or_null(link_info));</span>
        vmassert(m == resolved_method, &quot;!!&quot;);
        return -1;
      }
  
      return Bytecodes::_invokevirtual;
<span class="line-new-header">--- 1405,22 ---</span>
      Symbol* name_sym = cp-&gt;name_ref_at(index);
  
      vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), &quot;!&quot;);
      vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), &quot;!&quot;);
  
<span class="line-modified">!     methodHandle adapter_method(THREAD, cp_cache_entry-&gt;f1_as_method());</span>
  
      methodHandle resolved_method(adapter_method);
  
      // Can we treat it as a regular invokevirtual?
      if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
        vmassert(!resolved_method-&gt;is_static(),&quot;!&quot;);
        vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),&quot;!&quot;);
        vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), &quot;!&quot;);
        vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, &quot;!&quot;);
  
<span class="line-modified">!       methodHandle m(THREAD, LinkResolver::linktime_resolve_virtual_method_or_null(link_info));</span>
        vmassert(m == resolved_method, &quot;!!&quot;);
        return -1;
      }
  
      return Bytecodes::_invokevirtual;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1254,67 ***</span>
    }
    return -1;
  C2V_END
  
  
<span class="line-modified">! C2V_VMENTRY(jobject, getSignaturePolymorphicHolders, (JNIEnv*, jobject))</span>
<span class="line-modified">!   objArrayHandle holders = oopFactory::new_objArray_handle(SystemDictionary::String_klass(), 2, CHECK_NULL);</span>
<span class="line-modified">!   Handle mh = java_lang_String::create_from_str(&quot;Ljava/lang/invoke/MethodHandle;&quot;, CHECK_NULL);</span>
<span class="line-modified">!   Handle vh = java_lang_String::create_from_str(&quot;Ljava/lang/invoke/VarHandle;&quot;, CHECK_NULL);</span>
<span class="line-modified">!   holders-&gt;obj_at_put(0, mh());</span>
<span class="line-modified">!   holders-&gt;obj_at_put(1, vh());</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, holders());</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))</span>
    //see compute_recording_non_safepoints in debugInfroRec.cpp
    if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
      return true;
    }
    return DebugNonSafepoints;
  C2V_END
  
  // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
<span class="line-modified">! C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (hs_frame == NULL) {</span>
<span class="line-removed">-     THROW_MSG(vmSymbols::java_lang_NullPointerException(), &quot;stack frame is null&quot;)</span>
    }
  
<span class="line-modified">!   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK);</span>
  
    // look for the given stack frame
<span class="line-modified">!   StackFrameStream fst(thread);</span>
<span class="line-modified">!   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);</span>
    while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
      fst.next();
    }
    if (fst.current()-&gt;sp() != stack_pointer) {
<span class="line-modified">!     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found&quot;)</span>
    }
  
    if (invalidate) {
      if (!fst.current()-&gt;is_compiled_frame()) {
<span class="line-modified">!       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)</span>
      }
      assert(fst.current()-&gt;cb()-&gt;is_nmethod(), &quot;nmethod expected&quot;);
      ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
    }
<span class="line-modified">!   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);</span>
    // look for the frame again as it has been updated by deopt (pc, deopt state...)
    StackFrameStream fstAfterDeopt(thread);
    while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
      fstAfterDeopt.next();
    }
    if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
<span class="line-modified">!     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found after deopt&quot;)</span>
    }
  
    vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
    if (!vf-&gt;is_compiled_frame()) {
<span class="line-modified">!     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)</span>
    }
  
    GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
    while (true) {
      assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
<span class="line-new-header">--- 1430,68 ---</span>
    }
    return -1;
  C2V_END
  
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getSignaturePolymorphicHolders, (JNIEnv* env, jobject))</span>
<span class="line-modified">!   JVMCIObjectArray holders = JVMCIENV-&gt;new_String_array(2, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   JVMCIObject mh = JVMCIENV-&gt;create_string(&quot;Ljava/lang/invoke/MethodHandle;&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   JVMCIObject vh = JVMCIENV-&gt;create_string(&quot;Ljava/lang/invoke/VarHandle;&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   JVMCIENV-&gt;put_object_at(holders, 0, mh);</span>
<span class="line-modified">!   JVMCIENV-&gt;put_object_at(holders, 1, vh);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(holders);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jboolean, shouldDebugNonSafepoints, (JNIEnv* env, jobject))</span>
    //see compute_recording_non_safepoints in debugInfroRec.cpp
    if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
      return true;
    }
    return DebugNonSafepoints;
  C2V_END
  
  // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
<span class="line-modified">! C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv* env, jobject, jobject _hs_frame, bool invalidate))</span>
<span class="line-modified">!   JVMCIObject hs_frame = JVMCIENV-&gt;wrap(_hs_frame);</span>
<span class="line-modified">!   if (hs_frame.is_null()) {</span>
<span class="line-modified">!     JVMCI_THROW_MSG(NullPointerException, &quot;stack frame is null&quot;);</span>
    }
  
<span class="line-modified">!   requireInHotSpot(&quot;materializeVirtualObjects&quot;, JVMCI_CHECK);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIENV-&gt;HotSpotStackFrameReference_initialize(JVMCI_CHECK);</span>
  
    // look for the given stack frame
<span class="line-modified">!   StackFrameStream fst(thread, false);</span>
<span class="line-modified">!   intptr_t* stack_pointer = (intptr_t*) JVMCIENV-&gt;get_HotSpotStackFrameReference_stackPointer(hs_frame);</span>
    while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
      fst.next();
    }
    if (fst.current()-&gt;sp() != stack_pointer) {
<span class="line-modified">!     JVMCI_THROW_MSG(IllegalStateException, &quot;stack frame not found&quot;);</span>
    }
  
    if (invalidate) {
      if (!fst.current()-&gt;is_compiled_frame()) {
<span class="line-modified">!       JVMCI_THROW_MSG(IllegalStateException, &quot;compiled stack frame expected&quot;);</span>
      }
      assert(fst.current()-&gt;cb()-&gt;is_nmethod(), &quot;nmethod expected&quot;);
      ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
    }
<span class="line-modified">!   Deoptimization::deoptimize(thread, *fst.current(), Deoptimization::Reason_none);</span>
    // look for the frame again as it has been updated by deopt (pc, deopt state...)
    StackFrameStream fstAfterDeopt(thread);
    while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
      fstAfterDeopt.next();
    }
    if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
<span class="line-modified">!     JVMCI_THROW_MSG(IllegalStateException, &quot;stack frame not found after deopt&quot;);</span>
    }
  
    vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
    if (!vf-&gt;is_compiled_frame()) {
<span class="line-modified">!     JVMCI_THROW_MSG(IllegalStateException, &quot;compiled stack frame expected&quot;);</span>
    }
  
    GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
    while (true) {
      assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1323,13 ***</span>
        break;
      }
      vf = vf-&gt;sender();
    }
  
<span class="line-modified">!   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);</span>
    if (last_frame_number &gt;= virtualFrames-&gt;length()) {
<span class="line-modified">!     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;invalid frame number&quot;)</span>
    }
  
    // Reallocate the non-escaping objects and restore their fields.
    assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,&quot;invalid scope&quot;);
    GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
<span class="line-new-header">--- 1500,13 ---</span>
        break;
      }
      vf = vf-&gt;sender();
    }
  
<span class="line-modified">!   int last_frame_number = JVMCIENV-&gt;get_HotSpotStackFrameReference_frameNumber(hs_frame);</span>
    if (last_frame_number &gt;= virtualFrames-&gt;length()) {
<span class="line-modified">!     JVMCI_THROW_MSG(IllegalStateException, &quot;invalid frame number&quot;);</span>
    }
  
    // Reallocate the non-escaping objects and restore their fields.
    assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,&quot;invalid scope&quot;);
    GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1337,11 ***</span>
    if (objects == NULL) {
      // no objects to materialize
      return;
    }
  
<span class="line-modified">!   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, CHECK);</span>
    Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
  
    for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
      compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
  
<span class="line-new-header">--- 1514,11 ---</span>
    if (objects == NULL) {
      // no objects to materialize
      return;
    }
  
<span class="line-modified">!   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, CHECK);</span>
    Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
  
    for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
      compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1350,11 ***</span>
      if (locals != NULL) {
        for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
          StackValue* var = locals-&gt;at(i2);
          if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
            jvalue val;
<span class="line-modified">!           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();</span>
            cvf-&gt;update_local(T_OBJECT, i2, val);
          }
        }
      }
  
<span class="line-new-header">--- 1527,11 ---</span>
      if (locals != NULL) {
        for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
          StackValue* var = locals-&gt;at(i2);
          if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
            jvalue val;
<span class="line-modified">!           val.l = cast_from_oop&lt;jobject&gt;(locals-&gt;at(i2)-&gt;get_obj()());</span>
            cvf-&gt;update_local(T_OBJECT, i2, val);
          }
        }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1363,11 ***</span>
      if (expressions != NULL) {
        for (int i2 = 0; i2 &lt; expressions-&gt;size(); i2++) {
          StackValue* var = expressions-&gt;at(i2);
          if (var-&gt;type() == T_OBJECT &amp;&amp; scopeExpressions-&gt;at(i2)-&gt;is_object()) {
            jvalue val;
<span class="line-modified">!           val.l = (jobject) expressions-&gt;at(i2)-&gt;get_obj()();</span>
            cvf-&gt;update_stack(T_OBJECT, i2, val);
          }
        }
      }
  
<span class="line-new-header">--- 1540,11 ---</span>
      if (expressions != NULL) {
        for (int i2 = 0; i2 &lt; expressions-&gt;size(); i2++) {
          StackValue* var = expressions-&gt;at(i2);
          if (var-&gt;type() == T_OBJECT &amp;&amp; scopeExpressions-&gt;at(i2)-&gt;is_object()) {
            jvalue val;
<span class="line-modified">!           val.l = cast_from_oop&lt;jobject&gt;(expressions-&gt;at(i2)-&gt;get_obj()());</span>
            cvf-&gt;update_stack(T_OBJECT, i2, val);
          }
        }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1379,53 ***</span>
        }
      }
    }
  
    // all locals are materialized by now
<span class="line-modified">!   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);</span>
<span class="line-removed">- </span>
    // update the locals array
<span class="line-modified">!   objArrayHandle array(THREAD, HotSpotStackFrameReference::locals(hs_frame));</span>
    StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
    for (int i = 0; i &lt; locals-&gt;size(); i++) {
      StackValue* var = locals-&gt;at(i);
      if (var-&gt;type() == T_OBJECT) {
<span class="line-modified">!       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());</span>
      }
    }
<span class="line-modified">!   HotSpotStackFrameReference::set_objectsMaterialized(hs_frame, JNI_TRUE);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))</span>
    if (bytes == NULL) {
<span class="line-modified">!     THROW(vmSymbols::java_lang_NullPointerException());</span>
    }
<span class="line-modified">!   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);</span>
  
    // Check if offset and length are non negative.
    if (offset &lt; 0 || length &lt; 0) {
<span class="line-modified">!     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span>
    }
    // Check if the range is valid.
<span class="line-modified">!   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {</span>
<span class="line-modified">!     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span>
    }
    while (length &gt; 0) {
<span class="line-modified">!     jbyte* start = array-&gt;byte_at_addr(offset);</span>
<span class="line-modified">!     tty-&gt;write((char*) start, MIN2(length, (jint)O_BUFLEN));</span>
      length -= O_BUFLEN;
      offset += O_BUFLEN;
    }
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))</span>
    tty-&gt;flush();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-removed">-   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);</span>
    ProfileData* profile_data = mdo-&gt;data_at(position);
    if (mdo-&gt;is_valid(profile_data)) {
      return profile_data-&gt;size_in_bytes();
    }
    DataLayout* data    = mdo-&gt;extra_data_base();
<span class="line-new-header">--- 1556,114 ---</span>
        }
      }
    }
  
    // all locals are materialized by now
<span class="line-modified">!   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);</span>
    // update the locals array
<span class="line-modified">!   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);</span>
    StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
    for (int i = 0; i &lt; locals-&gt;size(); i++) {
      StackValue* var = locals-&gt;at(i);
      if (var-&gt;type() == T_OBJECT) {
<span class="line-modified">!       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));</span>
      }
    }
<span class="line-modified">!   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);</span>
  C2V_END
  
<span class="line-modified">! // Creates a scope where the current thread is attached and detached</span>
<span class="line-added">+ // from HotSpot if it wasn&#39;t already attached when entering the scope.</span>
<span class="line-added">+ extern &quot;C&quot; void jio_printf(const char *fmt, ...);</span>
<span class="line-added">+ class AttachDetach : public StackObj {</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   bool _attached;</span>
<span class="line-added">+   AttachDetach(JNIEnv* env, Thread* current_thread) {</span>
<span class="line-added">+     if (current_thread == NULL) {</span>
<span class="line-added">+       extern struct JavaVM_ main_vm;</span>
<span class="line-added">+       JNIEnv* hotspotEnv;</span>
<span class="line-added">+       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);</span>
<span class="line-added">+       _attached = res == JNI_OK;</span>
<span class="line-added">+       static volatile int report_attach_error = 0;</span>
<span class="line-added">+       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {</span>
<span class="line-added">+         // Only report an attach error once</span>
<span class="line-added">+         jio_printf(&quot;Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n&quot;, res);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       _attached = false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   ~AttachDetach() {</span>
<span class="line-added">+     if (_attached &amp;&amp; get_current_thread() != NULL) {</span>
<span class="line-added">+       extern struct JavaVM_ main_vm;</span>
<span class="line-added">+       jint res = main_vm.DetachCurrentThread();</span>
<span class="line-added">+       static volatile int report_detach_error = 0;</span>
<span class="line-added">+       if (res != JNI_OK &amp;&amp; report_detach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_detach_error, 0, 1) == 0) {</span>
<span class="line-added">+         // Only report an attach error once</span>
<span class="line-added">+         jio_printf(&quot;Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\n&quot;, res);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))</span>
<span class="line-added">+   AttachDetach ad(env, base_thread);</span>
<span class="line-added">+   bool use_tty = true;</span>
<span class="line-added">+   if (base_thread == NULL) {</span>
<span class="line-added">+     if (!ad._attached) {</span>
<span class="line-added">+       // Can only use tty if the current thread is attached</span>
<span class="line-added">+       return 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     base_thread = get_current_thread();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCITraceMark jtm(&quot;writeDebugOutput&quot;);</span>
<span class="line-added">+   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);</span>
<span class="line-added">+   JavaThread* thread = (JavaThread*) base_thread;</span>
<span class="line-added">+   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))</span>
    if (bytes == NULL) {
<span class="line-modified">!     if (can_throw) {</span>
<span class="line-added">+       JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return -1;</span>
    }
<span class="line-modified">!   JVMCIPrimitiveArray array = JVMCIENV-&gt;wrap(bytes);</span>
  
    // Check if offset and length are non negative.
    if (offset &lt; 0 || length &lt; 0) {
<span class="line-modified">!     if (can_throw) {</span>
<span class="line-added">+       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return -2;</span>
    }
    // Check if the range is valid.
<span class="line-modified">!   int array_length = JVMCIENV-&gt;get_length(array);</span>
<span class="line-modified">!   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array_length)) {</span>
<span class="line-added">+     if (can_throw) {</span>
<span class="line-added">+       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return -2;</span>
    }
<span class="line-added">+   jbyte buffer[O_BUFLEN];</span>
    while (length &gt; 0) {
<span class="line-modified">!     int copy_len = MIN2(length, (jint)O_BUFLEN);</span>
<span class="line-modified">!     JVMCIENV-&gt;copy_bytes_to(array, buffer, offset, copy_len);</span>
<span class="line-added">+     tty-&gt;write((char*) buffer, copy_len);</span>
      length -= O_BUFLEN;
      offset += O_BUFLEN;
    }
<span class="line-added">+   if (flush) {</span>
<span class="line-added">+     tty-&gt;flush();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return 0;</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, flushDebugOutput, (JNIEnv* env, jobject))</span>
    tty-&gt;flush();
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, methodDataProfileDataSize, (JNIEnv* env, jobject, jlong metaspace_method_data, jint position))</span>
<span class="line-modified">!   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);</span>
    ProfileData* profile_data = mdo-&gt;data_at(position);
    if (mdo-&gt;is_valid(profile_data)) {
      return profile_data-&gt;size_in_bytes();
    }
    DataLayout* data    = mdo-&gt;extra_data_base();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1435,52 ***</span>
      profile_data = data-&gt;data_in();
      if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
        return profile_data-&gt;size_in_bytes();
      }
    }
<span class="line-modified">!   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;Invalid profile data position %d&quot;, position));</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jlong, getFingerprint, (JNIEnv*, jobject, jlong metaspace_klass))</span>
  #if INCLUDE_AOT
<span class="line-modified">!   Klass *k = CompilerToVM::asKlass(metaspace_klass);</span>
    if (k-&gt;is_instance_klass()) {
      return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
    } else {
      return 0;
    }
  #else
<span class="line-modified">!   THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;unimplemented&quot;);</span>
  #endif
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, getHostClass, (JNIEnv*, jobject, jobject jvmci_type))</span>
<span class="line-modified">!   InstanceKlass* k = InstanceKlass::cast(CompilerToVM::asKlass(jvmci_type));</span>
    InstanceKlass* host = k-&gt;unsafe_anonymous_host();
    JVMCIKlassHandle handle(THREAD, host);
<span class="line-modified">!   oop result = CompilerToVM::get_jvmci_type(handle, CHECK_NULL);</span>
<span class="line-modified">!   return JNIHandles::make_local(THREAD, result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))</span>
    if (bytecode_frame_handle == NULL) {
<span class="line-modified">!     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
    }
  
<span class="line-modified">!   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);</span>
<span class="line-modified">!   oop bytecode_frame = top_bytecode_frame;</span>
    int size = 0;
    int callee_parameters = 0;
    int callee_locals = 0;
<span class="line-modified">!   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));</span>
<span class="line-modified">!   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);</span>
  
<span class="line-modified">!   while (bytecode_frame != NULL) {</span>
<span class="line-modified">!     int locks = BytecodeFrame::numLocks(bytecode_frame);</span>
<span class="line-modified">!     int temps = BytecodeFrame::numStack(bytecode_frame);</span>
<span class="line-modified">!     bool is_top_frame = (bytecode_frame == top_bytecode_frame);</span>
<span class="line-modified">!     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));</span>
  
      int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
                                                                   temps + callee_parameters,
                                                                   extra_args,
                                                                   locks,
<span class="line-new-header">--- 1673,119 ---</span>
      profile_data = data-&gt;data_in();
      if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
        return profile_data-&gt;size_in_bytes();
      }
    }
<span class="line-modified">!   JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Invalid profile data position %d&quot;, position));</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jlong, getFingerprint, (JNIEnv* env, jobject, jlong metaspace_klass))</span>
  #if INCLUDE_AOT
<span class="line-modified">!   Klass *k = (Klass*) (address) metaspace_klass;</span>
    if (k-&gt;is_instance_klass()) {
      return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
    } else {
      return 0;
    }
  #else
<span class="line-modified">!   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);</span>
  #endif
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getHostClass, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-modified">!   InstanceKlass* k = InstanceKlass::cast(JVMCIENV-&gt;asKlass(jvmci_type));</span>
    InstanceKlass* host = k-&gt;unsafe_anonymous_host();
    JVMCIKlassHandle handle(THREAD, host);
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(result);</span>
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, getInterfaces, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-added">+   if (jvmci_type == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
<span class="line-added">+   if (klass == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (!klass-&gt;is_instance_klass()) {</span>
<span class="line-added">+     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be instance klass&quot;, klass-&gt;external_name()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   InstanceKlass* iklass = InstanceKlass::cast(klass);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Regular instance klass, fill in all local interfaces</span>
<span class="line-added">+   int size = iklass-&gt;local_interfaces()-&gt;length();</span>
<span class="line-added">+   JVMCIObjectArray interfaces = JVMCIENV-&gt;new_HotSpotResolvedObjectTypeImpl_array(size, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   for (int index = 0; index &lt; size; index++) {</span>
<span class="line-added">+     JVMCIKlassHandle klass(THREAD);</span>
<span class="line-added">+     Klass* k = iklass-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-added">+     klass = k;</span>
<span class="line-added">+     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);</span>
<span class="line-added">+     JVMCIENV-&gt;put_object_at(interfaces, index, type);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(interfaces);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, getComponentType, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-added">+   if (jvmci_type == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
<span class="line-added">+   oop mirror = klass-&gt;java_mirror();</span>
<span class="line-added">+   if (java_lang_Class::is_primitive(mirror) ||</span>
<span class="line-added">+       !java_lang_Class::as_Klass(mirror)-&gt;is_array_klass()) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   oop component_mirror = java_lang_Class::component_mirror(mirror);</span>
<span class="line-added">+   if (component_mirror == NULL) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Klass* component_klass = java_lang_Class::as_Klass(component_mirror);</span>
<span class="line-added">+   if (component_klass != NULL) {</span>
<span class="line-added">+     JVMCIKlassHandle klass_handle(THREAD);</span>
<span class="line-added">+     klass_handle = component_klass;</span>
<span class="line-added">+     JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);</span>
<span class="line-added">+     return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   BasicType type = java_lang_Class::primitive_type(component_mirror);</span>
<span class="line-added">+   JVMCIObject result = JVMCIENV-&gt;get_jvmci_primitive_type(type);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY(void, ensureInitialized, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-added">+   if (jvmci_type == NULL) {</span>
<span class="line-added">+     JVMCI_THROW(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
<span class="line-added">+   if (klass != NULL &amp;&amp; klass-&gt;should_be_initialized()) {</span>
<span class="line-added">+     InstanceKlass* k = InstanceKlass::cast(klass);</span>
<span class="line-added">+     k-&gt;initialize(CHECK);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jint, interpreterFrameSize, (JNIEnv* env, jobject, jobject bytecode_frame_handle))</span>
    if (bytecode_frame_handle == NULL) {
<span class="line-modified">!     JVMCI_THROW_0(NullPointerException);</span>
    }
  
<span class="line-modified">!   JVMCIObject top_bytecode_frame = JVMCIENV-&gt;wrap(bytecode_frame_handle);</span>
<span class="line-modified">!   JVMCIObject bytecode_frame = top_bytecode_frame;</span>
    int size = 0;
    int callee_parameters = 0;
    int callee_locals = 0;
<span class="line-modified">!   Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));</span>
<span class="line-modified">!   int extra_args = method-&gt;max_stack() - JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);</span>
  
<span class="line-modified">!   while (bytecode_frame.is_non_null()) {</span>
<span class="line-modified">!     int locks = JVMCIENV-&gt;get_BytecodeFrame_numLocks(bytecode_frame);</span>
<span class="line-modified">!     int temps = JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);</span>
<span class="line-modified">!     bool is_top_frame = (JVMCIENV-&gt;equals(bytecode_frame, top_bytecode_frame));</span>
<span class="line-modified">!     Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));</span>
  
      int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
                                                                   temps + callee_parameters,
                                                                   extra_args,
                                                                   locks,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1490,80 ***</span>
      size += frame_size;
  
      callee_parameters = method-&gt;size_of_parameters();
      callee_locals = method-&gt;max_locals();
      extra_args = 0;
<span class="line-modified">!     bytecode_frame = BytecodePosition::caller(bytecode_frame);</span>
    }
    return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, compileToBytecode, (JNIEnv*, jobject, jobject lambda_form_handle))</span>
<span class="line-modified">!   Handle lambda_form(THREAD, JNIHandles::resolve_non_null(lambda_form_handle));</span>
    if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
<span class="line-modified">!     TempNewSymbol compileToBytecode = SymbolTable::new_symbol(&quot;compileToBytecode&quot;, CHECK);</span>
      JavaValue result(T_VOID);
      JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
    } else {
<span class="line-modified">!     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-modified">!                 err_msg(&quot;Unexpected type: %s&quot;, lambda_form-&gt;klass()-&gt;external_name()));</span>
    }
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">!   methodHandle m = CompilerToVM::asMethod(jvmci_method);</span>
    oop executable;
    if (m-&gt;is_initializer()) {
      if (m-&gt;is_static_initializer()) {
<span class="line-modified">!       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-modified">!         &quot;Cannot create java.lang.reflect.Method for class initializer&quot;);</span>
      }
      executable = Reflection::new_constructor(m, CHECK_NULL);
    } else {
      executable = Reflection::new_method(m, false, CHECK_NULL);
    }
<span class="line-modified">!   return JNIHandles::make_local(thread, executable);</span>
  }
  
<span class="line-modified">! C2V_VMENTRY(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))</span>
<span class="line-modified">!   Klass* klass = CompilerToVM::asKlass(jvmci_type);</span>
    if (!klass-&gt;is_instance_klass()) {
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
          err_msg(&quot;Expected non-primitive type, got %s&quot;, klass-&gt;external_name()));
    }
    InstanceKlass* iklass = InstanceKlass::cast(klass);
    Array&lt;u2&gt;* fields = iklass-&gt;fields();
<span class="line-modified">!   if (index &lt; 0 || index &gt; fields-&gt;length()) {</span>
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
          err_msg(&quot;Field index %d out of bounds for %s&quot;, index, klass-&gt;external_name()));
    }
    fieldDescriptor fd(iklass, index);
    oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
    return JNIHandles::make_local(env, reflected);
  }
  
  #define CC (char*)  /*cast a literal from (const char*)*/
  #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
  
  #define STRING                  &quot;Ljava/lang/String;&quot;
  #define OBJECT                  &quot;Ljava/lang/Object;&quot;
  #define CLASS                   &quot;Ljava/lang/Class;&quot;
  #define EXECUTABLE              &quot;Ljava/lang/reflect/Executable;&quot;
  #define STACK_TRACE_ELEMENT     &quot;Ljava/lang/StackTraceElement;&quot;
  #define INSTALLED_CODE          &quot;Ljdk/vm/ci/code/InstalledCode;&quot;
  #define TARGET_DESCRIPTION      &quot;Ljdk/vm/ci/code/TargetDescription;&quot;
  #define BYTECODE_FRAME          &quot;Ljdk/vm/ci/code/BytecodeFrame;&quot;
  #define INSPECTED_FRAME_VISITOR &quot;Ljdk/vm/ci/code/stack/InspectedFrameVisitor;&quot;
  #define RESOLVED_METHOD         &quot;Ljdk/vm/ci/meta/ResolvedJavaMethod;&quot;
  #define HS_RESOLVED_METHOD      &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;&quot;
  #define HS_RESOLVED_KLASS       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;&quot;
  #define HS_CONSTANT_POOL        &quot;Ljdk/vm/ci/hotspot/HotSpotConstantPool;&quot;
  #define HS_COMPILED_CODE        &quot;Ljdk/vm/ci/hotspot/HotSpotCompiledCode;&quot;
  #define HS_CONFIG               &quot;Ljdk/vm/ci/hotspot/HotSpotVMConfig;&quot;
  #define HS_METADATA             &quot;Ljdk/vm/ci/hotspot/HotSpotMetaData;&quot;
  #define HS_STACK_FRAME_REF      &quot;Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;&quot;
  #define HS_SPECULATION_LOG      &quot;Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;&quot;
  #define REFLECTION_EXECUTABLE   &quot;Ljava/lang/reflect/Executable;&quot;
  #define REFLECTION_FIELD        &quot;Ljava/lang/reflect/Field;&quot;
  #define METASPACE_METHOD_DATA   &quot;J&quot;
  
  JNINativeMethod CompilerToVM::methods[] = {
<span class="line-new-header">--- 1795,870 ---</span>
      size += frame_size;
  
      callee_parameters = method-&gt;size_of_parameters();
      callee_locals = method-&gt;max_locals();
      extra_args = 0;
<span class="line-modified">!     bytecode_frame = JVMCIENV-&gt;get_BytecodePosition_caller(bytecode_frame);</span>
    }
    return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY(void, compileToBytecode, (JNIEnv* env, jobject, jobject lambda_form_handle))</span>
<span class="line-modified">!   Handle lambda_form = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(lambda_form_handle), JVMCI_CHECK);</span>
    if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
<span class="line-modified">!     TempNewSymbol compileToBytecode = SymbolTable::new_symbol(&quot;compileToBytecode&quot;);</span>
      JavaValue result(T_VOID);
      JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
    } else {
<span class="line-modified">!     JVMCI_THROW_MSG(IllegalArgumentException,</span>
<span class="line-modified">!                     err_msg(&quot;Unexpected type: %s&quot;, lambda_form-&gt;klass()-&gt;external_name()))</span>
    }
  C2V_END
  
<span class="line-modified">! C2V_VMENTRY_0(jint, getIdentityHashCode, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-modified">!   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);</span>
<span class="line-added">+   return obj-&gt;identity_hash();</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jboolean, isInternedString, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">+   Handle str = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);</span>
<span class="line-added">+   if (!java_lang_String::is_instance(str())) {</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int len;</span>
<span class="line-added">+   jchar* name = java_lang_String::as_unicode_string(str(), len, CHECK_0);</span>
<span class="line-added">+   return (StringTable::lookup(name, len) != NULL);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, unboxPrimitive, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">+   if (object == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle box = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);</span>
<span class="line-added">+   BasicType type = java_lang_boxing_object::basic_type(box());</span>
<span class="line-added">+   jvalue result;</span>
<span class="line-added">+   if (java_lang_boxing_object::get_value(box(), &amp;result) == T_ILLEGAL) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObject boxResult = JVMCIENV-&gt;create_box(type, &amp;result, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(boxResult);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, boxPrimitive, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">+   if (object == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObject box = JVMCIENV-&gt;wrap(object);</span>
<span class="line-added">+   BasicType type = JVMCIENV-&gt;get_box_type(box);</span>
<span class="line-added">+   if (type == T_ILLEGAL) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   jvalue value = JVMCIENV-&gt;get_boxed_value(type, box);</span>
<span class="line-added">+   JavaValue box_result(T_OBJECT);</span>
<span class="line-added">+   JavaCallArguments jargs;</span>
<span class="line-added">+   Klass* box_klass = NULL;</span>
<span class="line-added">+   Symbol* box_signature = NULL;</span>
<span class="line-added">+ #define BOX_CASE(bt, v, argtype, name)           \</span>
<span class="line-added">+   case bt: \</span>
<span class="line-added">+     jargs.push_##argtype(value.v); \</span>
<span class="line-added">+     box_klass = SystemDictionary::name##_klass(); \</span>
<span class="line-added">+     box_signature = vmSymbols::name##_valueOf_signature(); \</span>
<span class="line-added">+     break</span>
<span class="line-added">+ </span>
<span class="line-added">+   switch (type) {</span>
<span class="line-added">+     BOX_CASE(T_BOOLEAN, z, int, Boolean);</span>
<span class="line-added">+     BOX_CASE(T_BYTE, b, int, Byte);</span>
<span class="line-added">+     BOX_CASE(T_CHAR, c, int, Character);</span>
<span class="line-added">+     BOX_CASE(T_SHORT, s, int, Short);</span>
<span class="line-added">+     BOX_CASE(T_INT, i, int, Integer);</span>
<span class="line-added">+     BOX_CASE(T_LONG, j, long, Long);</span>
<span class="line-added">+     BOX_CASE(T_FLOAT, f, float, Float);</span>
<span class="line-added">+     BOX_CASE(T_DOUBLE, d, double, Double);</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       ShouldNotReachHere();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #undef BOX_CASE</span>
<span class="line-added">+ </span>
<span class="line-added">+   JavaCalls::call_static(&amp;box_result,</span>
<span class="line-added">+                          box_klass,</span>
<span class="line-added">+                          vmSymbols::valueOf_name(),</span>
<span class="line-added">+                          box_signature, &amp;jargs, CHECK_NULL);</span>
<span class="line-added">+   oop hotspot_box = (oop) box_result.get_jobject();</span>
<span class="line-added">+   JVMCIObject result = JVMCIENV-&gt;get_object_constant(hotspot_box, false);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobjectArray, getDeclaredConstructors, (JNIEnv* env, jobject, jobject holder))</span>
<span class="line-added">+   if (holder == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Klass* klass = JVMCIENV-&gt;asKlass(holder);</span>
<span class="line-added">+   if (!klass-&gt;is_instance_klass()) {</span>
<span class="line-added">+     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);</span>
<span class="line-added">+     return JVMCIENV-&gt;get_jobjectArray(methods);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   InstanceKlass* iklass = InstanceKlass::cast(klass);</span>
<span class="line-added">+   // Ensure class is linked</span>
<span class="line-added">+   iklass-&gt;link_class(CHECK_NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   GrowableArray&lt;Method*&gt; constructors_array;</span>
<span class="line-added">+   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {</span>
<span class="line-added">+     Method* m = iklass-&gt;methods()-&gt;at(i);</span>
<span class="line-added">+     if (m-&gt;is_initializer() &amp;&amp; !m-&gt;is_static()) {</span>
<span class="line-added">+       constructors_array.append(m);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(constructors_array.length(), JVMCI_CHECK_NULL);</span>
<span class="line-added">+   for (int i = 0; i &lt; constructors_array.length(); i++) {</span>
<span class="line-added">+     methodHandle ctor(THREAD, constructors_array.at(i));</span>
<span class="line-added">+     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(ctor, JVMCI_CHECK_NULL);</span>
<span class="line-added">+     JVMCIENV-&gt;put_object_at(methods, i, method);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobjectArray(methods);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobjectArray, getDeclaredMethods, (JNIEnv* env, jobject, jobject holder))</span>
<span class="line-added">+   if (holder == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Klass* klass = JVMCIENV-&gt;asKlass(holder);</span>
<span class="line-added">+   if (!klass-&gt;is_instance_klass()) {</span>
<span class="line-added">+     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);</span>
<span class="line-added">+     return JVMCIENV-&gt;get_jobjectArray(methods);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   InstanceKlass* iklass = InstanceKlass::cast(klass);</span>
<span class="line-added">+   // Ensure class is linked</span>
<span class="line-added">+   iklass-&gt;link_class(CHECK_NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   GrowableArray&lt;Method*&gt; methods_array;</span>
<span class="line-added">+   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {</span>
<span class="line-added">+     Method* m = iklass-&gt;methods()-&gt;at(i);</span>
<span class="line-added">+     if (!m-&gt;is_initializer() &amp;&amp; !m-&gt;is_overpass()) {</span>
<span class="line-added">+       methods_array.append(m);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(methods_array.length(), JVMCI_CHECK_NULL);</span>
<span class="line-added">+   for (int i = 0; i &lt; methods_array.length(); i++) {</span>
<span class="line-added">+     methodHandle mh(THREAD, methods_array.at(i));</span>
<span class="line-added">+     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);</span>
<span class="line-added">+     JVMCIENV-&gt;put_object_at(methods, i, method);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobjectArray(methods);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject field, jboolean is_volatile))</span>
<span class="line-added">+   if (object == NULL || field == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObject field_object = JVMCIENV-&gt;wrap(field);</span>
<span class="line-added">+   JVMCIObject java_type = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_type(field_object);</span>
<span class="line-added">+   int modifiers = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_modifiers(field_object);</span>
<span class="line-added">+   Klass* holder = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_holder(field_object));</span>
<span class="line-added">+   if (!holder-&gt;is_instance_klass()) {</span>
<span class="line-added">+     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Holder %s must be instance klass&quot;, holder-&gt;external_name()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   InstanceKlass* ik = InstanceKlass::cast(holder);</span>
<span class="line-added">+   BasicType constant_type;</span>
<span class="line-added">+   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(java_type)) {</span>
<span class="line-added">+     constant_type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(java_type), JVMCI_CHECK_NULL);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     constant_type = T_OBJECT;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int displacement = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_offset(field_object);</span>
<span class="line-added">+   fieldDescriptor fd;</span>
<span class="line-added">+   if (!ik-&gt;find_local_field_from_offset(displacement, (modifiers &amp; JVM_ACC_STATIC) != 0, &amp;fd)) {</span>
<span class="line-added">+     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Can&#39;t find field with displacement %d&quot;, displacement));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObject base = JVMCIENV-&gt;wrap(object);</span>
<span class="line-added">+   Handle obj;</span>
<span class="line-added">+   if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base)) {</span>
<span class="line-added">+     obj = JVMCIENV-&gt;asConstant(base, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base)) {</span>
<span class="line-added">+     Klass* klass = JVMCIENV-&gt;asKlass(base);</span>
<span class="line-added">+     obj = Handle(THREAD, klass-&gt;java_mirror());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
<span class="line-added">+                          err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base)));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   jlong value = 0;</span>
<span class="line-added">+   JVMCIObject kind;</span>
<span class="line-added">+   switch (constant_type) {</span>
<span class="line-added">+     case T_OBJECT: {</span>
<span class="line-added">+       oop object = is_volatile ? obj-&gt;obj_field_acquire(displacement) : obj-&gt;obj_field(displacement);</span>
<span class="line-added">+       JVMCIObject result = JVMCIENV-&gt;get_object_constant(object);</span>
<span class="line-added">+       if (result.is_null()) {</span>
<span class="line-added">+         return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_JavaConstant_NULL_POINTER());</span>
<span class="line-added">+       }</span>
<span class="line-added">+       return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case T_FLOAT: {</span>
<span class="line-added">+       float f = is_volatile ? obj-&gt;float_field_acquire(displacement) : obj-&gt;float_field(displacement);</span>
<span class="line-added">+       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forFloat(f, JVMCI_CHECK_NULL);</span>
<span class="line-added">+       return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case T_DOUBLE: {</span>
<span class="line-added">+       double f = is_volatile ? obj-&gt;double_field_acquire(displacement) : obj-&gt;double_field(displacement);</span>
<span class="line-added">+       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forDouble(f, JVMCI_CHECK_NULL);</span>
<span class="line-added">+       return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case T_BOOLEAN: value = is_volatile ? obj-&gt;bool_field_acquire(displacement) : obj-&gt;bool_field(displacement); break;</span>
<span class="line-added">+     case T_BYTE: value = is_volatile ? obj-&gt;byte_field_acquire(displacement) : obj-&gt;byte_field(displacement); break;</span>
<span class="line-added">+     case T_SHORT: value = is_volatile ? obj-&gt;short_field_acquire(displacement) : obj-&gt;short_field(displacement); break;</span>
<span class="line-added">+     case T_CHAR: value = is_volatile ? obj-&gt;char_field_acquire(displacement) : obj-&gt;char_field(displacement); break;</span>
<span class="line-added">+     case T_INT: value = is_volatile ? obj-&gt;int_field_acquire(displacement) : obj-&gt;int_field(displacement); break;</span>
<span class="line-added">+     case T_LONG: value = is_volatile ? obj-&gt;long_field_acquire(displacement) : obj-&gt;long_field(displacement); break;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       ShouldNotReachHere();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObject result = JVMCIENV-&gt;call_PrimitiveConstant_forTypeChar(type2char(constant_type), value, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jboolean, isInstance, (JNIEnv* env, jobject, jobject holder, jobject object))</span>
<span class="line-added">+   if (object == NULL || holder == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);</span>
<span class="line-added">+   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));</span>
<span class="line-added">+   return obj-&gt;is_a(klass);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jboolean, isAssignableFrom, (JNIEnv* env, jobject, jobject holder, jobject otherHolder))</span>
<span class="line-added">+   if (holder == NULL || otherHolder == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));</span>
<span class="line-added">+   Klass* otherKlass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(otherHolder));</span>
<span class="line-added">+   return otherKlass-&gt;is_subtype_of(klass);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jboolean, isTrustedForIntrinsics, (JNIEnv* env, jobject, jobject holder))</span>
<span class="line-added">+   if (holder == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   InstanceKlass* ik = InstanceKlass::cast(JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder)));</span>
<span class="line-added">+   if (ik-&gt;class_loader_data()-&gt;is_boot_class_loader_data() || ik-&gt;class_loader_data()-&gt;is_platform_class_loader_data()) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, asJavaType, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">+   if (object == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);</span>
<span class="line-added">+   if (java_lang_Class::is_instance(obj())) {</span>
<span class="line-added">+     if (java_lang_Class::is_primitive(obj())) {</span>
<span class="line-added">+       JVMCIObject type = JVMCIENV-&gt;get_jvmci_primitive_type(java_lang_Class::primitive_type(obj()));</span>
<span class="line-added">+       return JVMCIENV-&gt;get_jobject(type);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     Klass* klass = java_lang_Class::as_Klass(obj());</span>
<span class="line-added">+     JVMCIKlassHandle klass_handle(THREAD);</span>
<span class="line-added">+     klass_handle = klass;</span>
<span class="line-added">+     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);</span>
<span class="line-added">+     return JVMCIENV-&gt;get_jobject(type);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, asString, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">+   if (object == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);</span>
<span class="line-added">+   const char* str = java_lang_String::as_utf8_string(obj());</span>
<span class="line-added">+   JVMCIObject result = JVMCIENV-&gt;create_string(str, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jboolean, equals, (JNIEnv* env, jobject, jobject x, jlong xHandle, jobject y, jlong yHandle))</span>
<span class="line-added">+   if (x == NULL || y == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return JVMCIENV-&gt;resolve_handle(xHandle) == JVMCIENV-&gt;resolve_handle(yHandle);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, getJavaMirror, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">+   if (object == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObject base_object = JVMCIENV-&gt;wrap(object);</span>
<span class="line-added">+   Handle mirror;</span>
<span class="line-added">+   if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {</span>
<span class="line-added">+     mirror = Handle(THREAD, JVMCIENV-&gt;asKlass(base_object)-&gt;java_mirror());</span>
<span class="line-added">+   } else if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(base_object)) {</span>
<span class="line-added">+     mirror = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_mirror(base_object), JVMCI_CHECK_NULL);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
<span class="line-added">+                          err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base_object)));</span>
<span class="line-added">+  }</span>
<span class="line-added">+   JVMCIObject result = JVMCIENV-&gt;get_object_constant(mirror());</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jint, getArrayLength, (JNIEnv* env, jobject, jobject x))</span>
<span class="line-added">+   if (x == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">+   if (xobj-&gt;klass()-&gt;is_array_klass()) {</span>
<span class="line-added">+     return arrayOop(xobj())-&gt;length();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return -1;</span>
<span class="line-added">+  C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, readArrayElement, (JNIEnv* env, jobject, jobject x, int index))</span>
<span class="line-added">+   if (x == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_NULL);</span>
<span class="line-added">+   if (xobj-&gt;klass()-&gt;is_array_klass()) {</span>
<span class="line-added">+     arrayOop array = arrayOop(xobj());</span>
<span class="line-added">+     BasicType element_type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();</span>
<span class="line-added">+     if (index &lt; 0 || index &gt;= array-&gt;length()) {</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     JVMCIObject result;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (element_type == T_OBJECT) {</span>
<span class="line-added">+       result = JVMCIENV-&gt;get_object_constant(objArrayOop(xobj())-&gt;obj_at(index));</span>
<span class="line-added">+       if (result.is_null()) {</span>
<span class="line-added">+         result = JVMCIENV-&gt;get_JavaConstant_NULL_POINTER();</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       jvalue value;</span>
<span class="line-added">+       switch (element_type) {</span>
<span class="line-added">+         case T_DOUBLE:        value.d = typeArrayOop(xobj())-&gt;double_at(index);        break;</span>
<span class="line-added">+         case T_FLOAT:         value.f = typeArrayOop(xobj())-&gt;float_at(index);         break;</span>
<span class="line-added">+         case T_LONG:          value.j = typeArrayOop(xobj())-&gt;long_at(index);          break;</span>
<span class="line-added">+         case T_INT:           value.i = typeArrayOop(xobj())-&gt;int_at(index);            break;</span>
<span class="line-added">+         case T_SHORT:         value.s = typeArrayOop(xobj())-&gt;short_at(index);          break;</span>
<span class="line-added">+         case T_CHAR:          value.c = typeArrayOop(xobj())-&gt;char_at(index);           break;</span>
<span class="line-added">+         case T_BYTE:          value.b = typeArrayOop(xobj())-&gt;byte_at(index);           break;</span>
<span class="line-added">+         case T_BOOLEAN:       value.z = typeArrayOop(xobj())-&gt;byte_at(index) &amp; 1;       break;</span>
<span class="line-added">+         default:              ShouldNotReachHere();</span>
<span class="line-added">+       }</span>
<span class="line-added">+       result = JVMCIENV-&gt;create_box(element_type, &amp;value, JVMCI_CHECK_NULL);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     assert(!result.is_null(), &quot;must have a value&quot;);</span>
<span class="line-added">+     return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return NULL;;</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jint, arrayBaseOffset, (JNIEnv* env, jobject, jobject kind))</span>
<span class="line-added">+   if (kind == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);</span>
<span class="line-added">+   return arrayOopDesc::header_size(type) * HeapWordSize;</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jint, arrayIndexScale, (JNIEnv* env, jobject, jobject kind))</span>
<span class="line-added">+   if (kind == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);</span>
<span class="line-added">+   return type2aelembytes(type);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jbyte, getByte, (JNIEnv* env, jobject, jobject x, long displacement))</span>
<span class="line-added">+   if (x == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">+   return xobj-&gt;byte_field(displacement);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jshort, getShort, (JNIEnv* env, jobject, jobject x, long displacement))</span>
<span class="line-added">+   if (x == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">+   return xobj-&gt;short_field(displacement);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jint, getInt, (JNIEnv* env, jobject, jobject x, long displacement))</span>
<span class="line-added">+   if (x == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">+   return xobj-&gt;int_field(displacement);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jlong, getLong, (JNIEnv* env, jobject, jobject x, long displacement))</span>
<span class="line-added">+   if (x == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">+   return xobj-&gt;long_field(displacement);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))</span>
<span class="line-added">+   if (x == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">+   oop res = xobj-&gt;obj_field(displacement);</span>
<span class="line-added">+   JVMCIObject result = JVMCIENV-&gt;get_object_constant(res);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))</span>
<span class="line-added">+   jobject handle = (jobject)(address)h;</span>
<span class="line-added">+   if (handle != NULL) {</span>
<span class="line-added">+     JVMCI::destroy_global(handle);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void requireJVMCINativeLibrary(JVMCI_TRAPS) {</span>
<span class="line-added">+   if (!UseJVMCINativeLibrary) {</span>
<span class="line-added">+     JVMCI_THROW_MSG(UnsupportedOperationException, &quot;JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static JavaVM* requireNativeLibraryJavaVM(const char* caller, JVMCI_TRAPS) {</span>
<span class="line-added">+   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();</span>
<span class="line-added">+   if (javaVM == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_MSG_NULL(IllegalStateException, err_msg(&quot;Require JVMCI shared library to be initialized in %s&quot;, caller));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return javaVM;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))</span>
<span class="line-added">+   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);</span>
<span class="line-added">+   requireInHotSpot(&quot;registerNativeMethods&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   void* shared_library = JVMCIEnv::get_shared_library_handle();</span>
<span class="line-added">+   if (shared_library == NULL) {</span>
<span class="line-added">+     // Ensure the JVMCI shared library runtime is initialized.</span>
<span class="line-added">+     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);</span>
<span class="line-added">+     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;</span>
<span class="line-added">+     HandleMark hm;</span>
<span class="line-added">+     JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="line-added">+     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);</span>
<span class="line-added">+     if (peerEnv-&gt;has_pending_exception()) {</span>
<span class="line-added">+       peerEnv-&gt;describe_pending_exception(true);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     shared_library = JVMCIEnv::get_shared_library_handle();</span>
<span class="line-added">+     if (shared_library == NULL) {</span>
<span class="line-added">+       JVMCI_THROW_MSG_0(InternalError, &quot;Error initializing JVMCI runtime&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (mirror == NULL) {</span>
<span class="line-added">+     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));</span>
<span class="line-added">+   if (klass == NULL || !klass-&gt;is_instance_klass()) {</span>
<span class="line-added">+     JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;clazz is for primitive type&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   InstanceKlass* iklass = InstanceKlass::cast(klass);</span>
<span class="line-added">+   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {</span>
<span class="line-added">+     methodHandle method(THREAD, iklass-&gt;methods()-&gt;at(i));</span>
<span class="line-added">+     if (method-&gt;is_native()) {</span>
<span class="line-added">+ </span>
<span class="line-added">+       // Compute argument size</span>
<span class="line-added">+       int args_size = 1                             // JNIEnv</span>
<span class="line-added">+                     + (method-&gt;is_static() ? 1 : 0) // class for static methods</span>
<span class="line-added">+                     + method-&gt;size_of_parameters(); // actual parameters</span>
<span class="line-added">+ </span>
<span class="line-added">+       // 1) Try JNI short style</span>
<span class="line-added">+       stringStream st;</span>
<span class="line-added">+       char* pure_name = NativeLookup::pure_jni_name(method);</span>
<span class="line-added">+       os::print_jni_name_prefix_on(&amp;st, args_size);</span>
<span class="line-added">+       st.print_raw(pure_name);</span>
<span class="line-added">+       os::print_jni_name_suffix_on(&amp;st, args_size);</span>
<span class="line-added">+       char* jni_name = st.as_string();</span>
<span class="line-added">+ </span>
<span class="line-added">+       address entry = (address) os::dll_lookup(shared_library, jni_name);</span>
<span class="line-added">+       if (entry == NULL) {</span>
<span class="line-added">+         // 2) Try JNI long style</span>
<span class="line-added">+         st.reset();</span>
<span class="line-added">+         char* long_name = NativeLookup::long_jni_name(method);</span>
<span class="line-added">+         os::print_jni_name_prefix_on(&amp;st, args_size);</span>
<span class="line-added">+         st.print_raw(pure_name);</span>
<span class="line-added">+         st.print_raw(long_name);</span>
<span class="line-added">+         os::print_jni_name_suffix_on(&amp;st, args_size);</span>
<span class="line-added">+         char* jni_long_name = st.as_string();</span>
<span class="line-added">+         entry = (address) os::dll_lookup(shared_library, jni_long_name);</span>
<span class="line-added">+         if (entry == NULL) {</span>
<span class="line-added">+           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [neither %s nor %s exist in %s]&quot;,</span>
<span class="line-added">+               method-&gt;name_and_sig_as_C_string(),</span>
<span class="line-added">+               jni_name, jni_long_name, JVMCIEnv::get_shared_library_path()));</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (method-&gt;has_native_function() &amp;&amp; entry != method-&gt;native_function()) {</span>
<span class="line-added">+         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [cannot re-link from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT &quot;]&quot;,</span>
<span class="line-added">+             method-&gt;name_and_sig_as_C_string(), p2i(method-&gt;native_function()), p2i(entry)));</span>
<span class="line-added">+       }</span>
<span class="line-added">+       method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting);</span>
<span class="line-added">+       log_debug(jni, resolve)(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,</span>
<span class="line-added">+                               method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-added">+                               method-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();</span>
<span class="line-added">+   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(4, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   JVMCIENV-&gt;put_long_at(result, 0, (jlong) (address) javaVM);</span>
<span class="line-added">+   JVMCIENV-&gt;put_long_at(result, 1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);</span>
<span class="line-added">+   JVMCIENV-&gt;put_long_at(result, 2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);</span>
<span class="line-added">+   JVMCIENV-&gt;put_long_at(result, 3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);</span>
<span class="line-added">+   return (jlongArray) JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))</span>
<span class="line-added">+   if (base_thread == NULL) {</span>
<span class="line-added">+     // Called from unattached JVMCI shared library thread</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCITraceMark jtm(&quot;isCurrentThreadAttached&quot;);</span>
<span class="line-added">+   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);</span>
<span class="line-added">+   JavaThread* thread = (JavaThread*) base_thread;</span>
<span class="line-added">+   if (thread-&gt;jni_environment() == env) {</span>
<span class="line-added">+     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))</span>
<span class="line-added">+     requireJVMCINativeLibrary(JVMCI_CHECK_0);</span>
<span class="line-added">+     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;isCurrentThreadAttached&quot;, JVMCI_CHECK_0);</span>
<span class="line-added">+     JNIEnv* peerEnv;</span>
<span class="line-added">+     return javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))</span>
<span class="line-added">+   if (base_thread == NULL) {</span>
<span class="line-added">+     // Called from unattached JVMCI shared library thread</span>
<span class="line-added">+     return 0L;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCITraceMark jtm(&quot;getCurrentJavaThread&quot;);</span>
<span class="line-added">+   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);</span>
<span class="line-added">+   return (jlong) p2i(base_thread);</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))</span>
<span class="line-added">+   if (base_thread == NULL) {</span>
<span class="line-added">+     // Called from unattached JVMCI shared library thread</span>
<span class="line-added">+     extern struct JavaVM_ main_vm;</span>
<span class="line-added">+     JNIEnv* hotspotEnv;</span>
<span class="line-added">+     jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**)&amp;hotspotEnv, NULL) :</span>
<span class="line-added">+                            main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);</span>
<span class="line-added">+     if (res != JNI_OK) {</span>
<span class="line-added">+       JNI_THROW_(&quot;attachCurrentThread&quot;, InternalError, err_msg(&quot;Trying to attach thread returned %d&quot;, res), false);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCITraceMark jtm(&quot;attachCurrentThread&quot;);</span>
<span class="line-added">+   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-added">+   JavaThread* thread = (JavaThread*) base_thread;</span>
<span class="line-added">+   if (thread-&gt;jni_environment() == env) {</span>
<span class="line-added">+     // Called from HotSpot</span>
<span class="line-added">+     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))</span>
<span class="line-added">+     requireJVMCINativeLibrary(JVMCI_CHECK_0);</span>
<span class="line-added">+     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;attachCurrentThread&quot;, JVMCI_CHECK_0);</span>
<span class="line-added">+     JavaVMAttachArgs attach_args;</span>
<span class="line-added">+     attach_args.version = JNI_VERSION_1_2;</span>
<span class="line-added">+     attach_args.name = thread-&gt;name();</span>
<span class="line-added">+     attach_args.group = NULL;</span>
<span class="line-added">+     JNIEnv* peerEnv;</span>
<span class="line-added">+     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK) {</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     jint res = as_daemon ? javaVM-&gt;AttachCurrentThreadAsDaemon((void**)&amp;peerEnv, &amp;attach_args) :</span>
<span class="line-added">+                            javaVM-&gt;AttachCurrentThread((void**)&amp;peerEnv, &amp;attach_args);</span>
<span class="line-added">+     if (res == JNI_OK) {</span>
<span class="line-added">+       guarantee(peerEnv != NULL, &quot;must be&quot;);</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, attach_args.name));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   // Called from JVMCI shared library</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))</span>
<span class="line-added">+   if (base_thread == NULL) {</span>
<span class="line-added">+     // Called from unattached JVMCI shared library thread</span>
<span class="line-added">+     JNI_THROW(&quot;detachCurrentThread&quot;, IllegalStateException, err_msg(&quot;Cannot detach non-attached thread&quot;));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCITraceMark jtm(&quot;detachCurrentThread&quot;);</span>
<span class="line-added">+   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-added">+   JavaThread* thread = (JavaThread*) base_thread;</span>
<span class="line-added">+   if (thread-&gt;jni_environment() == env) {</span>
<span class="line-added">+     // Called from HotSpot</span>
<span class="line-added">+     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))</span>
<span class="line-added">+     requireJVMCINativeLibrary(JVMCI_CHECK);</span>
<span class="line-added">+     requireInHotSpot(&quot;detachCurrentThread&quot;, JVMCI_CHECK);</span>
<span class="line-added">+     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;detachCurrentThread&quot;, JVMCI_CHECK);</span>
<span class="line-added">+     JNIEnv* peerEnv;</span>
<span class="line-added">+     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) != JNI_OK) {</span>
<span class="line-added">+       JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot detach non-attached thread: %s&quot;, thread-&gt;name()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     jint res = javaVM-&gt;DetachCurrentThread();</span>
<span class="line-added">+     if (res != JNI_OK) {</span>
<span class="line-added">+       JVMCI_THROW_MSG(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, thread-&gt;name()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Called from attached JVMCI shared library thread</span>
<span class="line-added">+     extern struct JavaVM_ main_vm;</span>
<span class="line-added">+     jint res = main_vm.DetachCurrentThread();</span>
<span class="line-added">+     if (res != JNI_OK) {</span>
<span class="line-added">+       JNI_THROW(&quot;detachCurrentThread&quot;, InternalError, err_msg(&quot;Cannot detach non-attached thread&quot;));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ C2V_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))</span>
<span class="line-added">+   requireJVMCINativeLibrary(JVMCI_CHECK_0);</span>
<span class="line-added">+   if (obj_handle == NULL) {</span>
<span class="line-added">+     return 0L;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV-&gt;is_hotspot(), __FILE__, __LINE__);</span>
<span class="line-added">+   JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;</span>
<span class="line-added">+   JVMCIEnv* thisEnv = JVMCIENV;</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject obj = thisEnv-&gt;wrap(obj_handle);</span>
<span class="line-added">+   JVMCIObject result;</span>
<span class="line-added">+   if (thisEnv-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {</span>
<span class="line-added">+     methodHandle method(THREAD, thisEnv-&gt;asMethod(obj));</span>
<span class="line-added">+     result = peerEnv-&gt;get_jvmci_method(method, JVMCI_CHECK_0);</span>
<span class="line-added">+   } else if (thisEnv-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {</span>
<span class="line-added">+     Klass* klass = thisEnv-&gt;asKlass(obj);</span>
<span class="line-added">+     JVMCIKlassHandle klass_handle(THREAD);</span>
<span class="line-added">+     klass_handle = klass;</span>
<span class="line-added">+     result = peerEnv-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_0);</span>
<span class="line-added">+   } else if (thisEnv-&gt;isa_HotSpotResolvedPrimitiveType(obj)) {</span>
<span class="line-added">+     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(obj), JVMCI_CHECK_0);</span>
<span class="line-added">+     result = peerEnv-&gt;get_jvmci_primitive_type(type);</span>
<span class="line-added">+   } else if (thisEnv-&gt;isa_IndirectHotSpotObjectConstantImpl(obj) ||</span>
<span class="line-added">+              thisEnv-&gt;isa_DirectHotSpotObjectConstantImpl(obj)) {</span>
<span class="line-added">+     Handle constant = thisEnv-&gt;asConstant(obj, JVMCI_CHECK_0);</span>
<span class="line-added">+     result = peerEnv-&gt;get_object_constant(constant());</span>
<span class="line-added">+   } else if (thisEnv-&gt;isa_HotSpotNmethod(obj)) {</span>
<span class="line-added">+     nmethodLocker locker;</span>
<span class="line-added">+     nmethod* nm = JVMCIENV-&gt;get_nmethod(obj, locker);</span>
<span class="line-added">+     if (nm != NULL) {</span>
<span class="line-added">+       JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();</span>
<span class="line-added">+       if (data != NULL) {</span>
<span class="line-added">+         if (peerEnv-&gt;is_hotspot()) {</span>
<span class="line-added">+           // Only the mirror in the HotSpot heap is accessible</span>
<span class="line-added">+           // through JVMCINMethodData</span>
<span class="line-added">+           oop nmethod_mirror = data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ true);</span>
<span class="line-added">+           if (nmethod_mirror != NULL) {</span>
<span class="line-added">+             result = HotSpotJVMCI::wrap(nmethod_mirror);</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (result.is_null()) {</span>
<span class="line-added">+       JVMCIObject methodObject = thisEnv-&gt;get_HotSpotNmethod_method(obj);</span>
<span class="line-added">+       methodHandle mh(THREAD, thisEnv-&gt;asMethod(methodObject));</span>
<span class="line-added">+       jboolean isDefault = thisEnv-&gt;get_HotSpotNmethod_isDefault(obj);</span>
<span class="line-added">+       jlong compileIdSnapshot = thisEnv-&gt;get_HotSpotNmethod_compileIdSnapshot(obj);</span>
<span class="line-added">+       JVMCIObject name_string = thisEnv-&gt;get_InstalledCode_name(obj);</span>
<span class="line-added">+       const char* cstring = name_string.is_null() ? NULL : thisEnv-&gt;as_utf8_string(name_string);</span>
<span class="line-added">+       // Create a new HotSpotNmethod instance in the peer runtime</span>
<span class="line-added">+       result = peerEnv-&gt;new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);</span>
<span class="line-added">+       if (nm == NULL) {</span>
<span class="line-added">+         // nmethod must have been unloaded</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         // Link the new HotSpotNmethod to the nmethod</span>
<span class="line-added">+         peerEnv-&gt;initialize_installed_code(result, nm, JVMCI_CHECK_0);</span>
<span class="line-added">+         // Only HotSpotNmethod instances in the HotSpot heap are tracked directly by the runtime.</span>
<span class="line-added">+         if (peerEnv-&gt;is_hotspot()) {</span>
<span class="line-added">+           JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();</span>
<span class="line-added">+           if (data == NULL) {</span>
<span class="line-added">+             JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;Cannot set HotSpotNmethod mirror for default nmethod&quot;);</span>
<span class="line-added">+           }</span>
<span class="line-added">+           if (data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) != NULL) {</span>
<span class="line-added">+             JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;Cannot overwrite existing HotSpotNmethod mirror for nmethod&quot;);</span>
<span class="line-added">+           }</span>
<span class="line-added">+           oop nmethod_mirror = HotSpotJVMCI::resolve(result);</span>
<span class="line-added">+           data-&gt;set_nmethod_mirror(nm, nmethod_mirror);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JVMCI_THROW_MSG_0(IllegalArgumentException,</span>
<span class="line-added">+                 err_msg(&quot;Cannot translate object of type: %s&quot;, thisEnv-&gt;klass_name(obj)));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return (jlong) peerEnv-&gt;make_global(result).as_jobject();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, unhand, (JNIEnv* env, jobject, jlong obj_handle))</span>
<span class="line-added">+   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);</span>
<span class="line-added">+   if (obj_handle == 0L) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   jobject global_handle = (jobject) obj_handle;</span>
<span class="line-added">+   JVMCIObject global_handle_obj = JVMCIENV-&gt;wrap((jobject) obj_handle);</span>
<span class="line-added">+   jobject result = JVMCIENV-&gt;make_local(global_handle_obj).as_jobject();</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIENV-&gt;destroy_global(global_handle_obj);</span>
<span class="line-added">+   return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY(void, updateHotSpotNmethod, (JNIEnv* env, jobject, jobject code_handle))</span>
<span class="line-added">+   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);</span>
<span class="line-added">+   // Execute this operation for the side effect of updating the InstalledCode state</span>
<span class="line-added">+   nmethodLocker locker;</span>
<span class="line-added">+   JVMCIENV-&gt;get_nmethod(code, locker);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jbyteArray, getCode, (JNIEnv* env, jobject, jobject code_handle))</span>
<span class="line-added">+   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);</span>
<span class="line-added">+   nmethodLocker locker;</span>
<span class="line-added">+   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(code, locker);</span>
<span class="line-added">+   if (cb == NULL) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int code_size = cb-&gt;code_size();</span>
<span class="line-added">+   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   JVMCIENV-&gt;copy_bytes_from((jbyte*) cb-&gt;code_begin(), result, 0, code_size);</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jbyteArray(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_NULL(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-added">+   requireInHotSpot(&quot;asReflectionExecutable&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   methodHandle m(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
    oop executable;
    if (m-&gt;is_initializer()) {
      if (m-&gt;is_static_initializer()) {
<span class="line-modified">!       JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
<span class="line-modified">!           &quot;Cannot create java.lang.reflect.Method for class initializer&quot;);</span>
      }
      executable = Reflection::new_constructor(m, CHECK_NULL);
    } else {
      executable = Reflection::new_method(m, false, CHECK_NULL);
    }
<span class="line-modified">!   return JNIHandles::make_local(THREAD, executable);</span>
  }
  
<span class="line-modified">! C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))</span>
<span class="line-modified">!   requireInHotSpot(&quot;asReflectionField&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
    if (!klass-&gt;is_instance_klass()) {
<span class="line-modified">!     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
          err_msg(&quot;Expected non-primitive type, got %s&quot;, klass-&gt;external_name()));
    }
    InstanceKlass* iklass = InstanceKlass::cast(klass);
    Array&lt;u2&gt;* fields = iklass-&gt;fields();
<span class="line-modified">!   if (index &lt; 0 ||index &gt; fields-&gt;length()) {</span>
<span class="line-modified">!     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
          err_msg(&quot;Field index %d out of bounds for %s&quot;, index, klass-&gt;external_name()));
    }
    fieldDescriptor fd(iklass, index);
    oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
    return JNIHandles::make_local(env, reflected);
  }
  
<span class="line-added">+ C2V_VMENTRY_NULL(jobjectArray, getFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address, jobjectArray current))</span>
<span class="line-added">+   FailedSpeculation* head = *((FailedSpeculation**)(address) failed_speculations_address);</span>
<span class="line-added">+   int result_length = 0;</span>
<span class="line-added">+   for (FailedSpeculation* fs = head; fs != NULL; fs = fs-&gt;next()) {</span>
<span class="line-added">+     result_length++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int current_length = 0;</span>
<span class="line-added">+   JVMCIObjectArray current_array = NULL;</span>
<span class="line-added">+   if (current != NULL) {</span>
<span class="line-added">+     current_array = JVMCIENV-&gt;wrap(current);</span>
<span class="line-added">+     current_length = JVMCIENV-&gt;get_length(current_array);</span>
<span class="line-added">+     if (current_length == result_length) {</span>
<span class="line-added">+       // No new failures</span>
<span class="line-added">+       return current;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObjectArray result = JVMCIENV-&gt;new_byte_array_array(result_length, JVMCI_CHECK_NULL);</span>
<span class="line-added">+   int result_index = 0;</span>
<span class="line-added">+   for (FailedSpeculation* fs = head; result_index &lt; result_length; fs = fs-&gt;next()) {</span>
<span class="line-added">+     assert(fs != NULL, &quot;npe&quot;);</span>
<span class="line-added">+     JVMCIPrimitiveArray entry;</span>
<span class="line-added">+     if (result_index &lt; current_length) {</span>
<span class="line-added">+       entry = (JVMCIPrimitiveArray) JVMCIENV-&gt;get_object_at(current_array, result_index);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       entry = JVMCIENV-&gt;new_byteArray(fs-&gt;data_len(), JVMCI_CHECK_NULL);</span>
<span class="line-added">+       JVMCIENV-&gt;copy_bytes_from((jbyte*) fs-&gt;data(), entry, 0, fs-&gt;data_len());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     JVMCIENV-&gt;put_object_at(result, result_index++, entry);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return JVMCIENV-&gt;get_jobjectArray(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jlong, getFailedSpeculationsAddress, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-added">+   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
<span class="line-added">+   MethodData* method_data = method-&gt;method_data();</span>
<span class="line-added">+   if (method_data == NULL) {</span>
<span class="line-added">+     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();</span>
<span class="line-added">+     method_data = MethodData::allocate(loader_data, method, CHECK_0);</span>
<span class="line-added">+     method-&gt;set_method_data(method_data);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return (jlong) method_data-&gt;get_failed_speculations_address();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY(void, releaseFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address))</span>
<span class="line-added">+   FailedSpeculation::free_failed_speculations((FailedSpeculation**)(address) failed_speculations_address);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY_0(jboolean, addFailedSpeculation, (JNIEnv* env, jobject, jlong failed_speculations_address, jbyteArray speculation_obj))</span>
<span class="line-added">+   JVMCIPrimitiveArray speculation_handle = JVMCIENV-&gt;wrap(speculation_obj);</span>
<span class="line-added">+   int speculation_len = JVMCIENV-&gt;get_length(speculation_handle);</span>
<span class="line-added">+   char* speculation = NEW_RESOURCE_ARRAY(char, speculation_len);</span>
<span class="line-added">+   JVMCIENV-&gt;copy_bytes_to(speculation_handle, (jbyte*) speculation, 0, speculation_len);</span>
<span class="line-added">+   return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ C2V_VMENTRY(void, callSystemExit, (JNIEnv* env, jobject, jint status))</span>
<span class="line-added">+   JavaValue result(T_VOID);</span>
<span class="line-added">+   JavaCallArguments jargs(1);</span>
<span class="line-added">+   jargs.push_int(status);</span>
<span class="line-added">+   JavaCalls::call_static(&amp;result,</span>
<span class="line-added">+                        SystemDictionary::System_klass(),</span>
<span class="line-added">+                        vmSymbols::exit_method_name(),</span>
<span class="line-added">+                        vmSymbols::int_void_signature(),</span>
<span class="line-added">+                        &amp;jargs,</span>
<span class="line-added">+                        CHECK);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #define CC (char*)  /*cast a literal from (const char*)*/
  #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
  
  #define STRING                  &quot;Ljava/lang/String;&quot;
  #define OBJECT                  &quot;Ljava/lang/Object;&quot;
  #define CLASS                   &quot;Ljava/lang/Class;&quot;
<span class="line-added">+ #define OBJECTCONSTANT          &quot;Ljdk/vm/ci/hotspot/HotSpotObjectConstantImpl;&quot;</span>
<span class="line-added">+ #define HANDLECONSTANT          &quot;Ljdk/vm/ci/hotspot/IndirectHotSpotObjectConstantImpl;&quot;</span>
  #define EXECUTABLE              &quot;Ljava/lang/reflect/Executable;&quot;
  #define STACK_TRACE_ELEMENT     &quot;Ljava/lang/StackTraceElement;&quot;
  #define INSTALLED_CODE          &quot;Ljdk/vm/ci/code/InstalledCode;&quot;
  #define TARGET_DESCRIPTION      &quot;Ljdk/vm/ci/code/TargetDescription;&quot;
  #define BYTECODE_FRAME          &quot;Ljdk/vm/ci/code/BytecodeFrame;&quot;
<span class="line-added">+ #define JAVACONSTANT            &quot;Ljdk/vm/ci/meta/JavaConstant;&quot;</span>
  #define INSPECTED_FRAME_VISITOR &quot;Ljdk/vm/ci/code/stack/InspectedFrameVisitor;&quot;
  #define RESOLVED_METHOD         &quot;Ljdk/vm/ci/meta/ResolvedJavaMethod;&quot;
  #define HS_RESOLVED_METHOD      &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;&quot;
  #define HS_RESOLVED_KLASS       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;&quot;
<span class="line-added">+ #define HS_RESOLVED_TYPE        &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaType;&quot;</span>
<span class="line-added">+ #define HS_RESOLVED_FIELD       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaField;&quot;</span>
<span class="line-added">+ #define HS_INSTALLED_CODE       &quot;Ljdk/vm/ci/hotspot/HotSpotInstalledCode;&quot;</span>
<span class="line-added">+ #define HS_NMETHOD              &quot;Ljdk/vm/ci/hotspot/HotSpotNmethod;&quot;</span>
  #define HS_CONSTANT_POOL        &quot;Ljdk/vm/ci/hotspot/HotSpotConstantPool;&quot;
  #define HS_COMPILED_CODE        &quot;Ljdk/vm/ci/hotspot/HotSpotCompiledCode;&quot;
  #define HS_CONFIG               &quot;Ljdk/vm/ci/hotspot/HotSpotVMConfig;&quot;
  #define HS_METADATA             &quot;Ljdk/vm/ci/hotspot/HotSpotMetaData;&quot;
  #define HS_STACK_FRAME_REF      &quot;Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;&quot;
  #define HS_SPECULATION_LOG      &quot;Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;&quot;
<span class="line-added">+ #define METASPACE_OBJECT        &quot;Ljdk/vm/ci/hotspot/MetaspaceObject;&quot;</span>
  #define REFLECTION_EXECUTABLE   &quot;Ljava/lang/reflect/Executable;&quot;
  #define REFLECTION_FIELD        &quot;Ljava/lang/reflect/Field;&quot;
  #define METASPACE_METHOD_DATA   &quot;J&quot;
  
  JNINativeMethod CompilerToVM::methods[] = {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1576,21 ***</span>
    {CC &quot;methodIsIgnoredBySecurityStackWalk&quot;,           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
    {CC &quot;setNotInlinableOrCompilable&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(setNotInlinableOrCompilable)},
    {CC &quot;isCompilable&quot;,                                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(isCompilable)},
    {CC &quot;hasNeverInlineDirective&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(hasNeverInlineDirective)},
    {CC &quot;shouldInlineMethod&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(shouldInlineMethod)},
<span class="line-modified">!   {CC &quot;lookupType&quot;,                                   CC &quot;(&quot; STRING CLASS &quot;Z)&quot; HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},</span>
    {CC &quot;lookupNameInPool&quot;,                             CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupNameInPool)},
    {CC &quot;lookupNameAndTypeRefIndexInPool&quot;,              CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
    {CC &quot;lookupSignatureInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupSignatureInPool)},
    {CC &quot;lookupKlassRefIndexInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupKlassRefIndexInPool)},
    {CC &quot;lookupKlassInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)Ljava/lang/Object;&quot;,                                       FN_PTR(lookupKlassInPool)},
<span class="line-modified">!   {CC &quot;lookupAppendixInPool&quot;,                         CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECT,                                                  FN_PTR(lookupAppendixInPool)},</span>
    {CC &quot;lookupMethodInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;IB)&quot; HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
    {CC &quot;constantPoolRemapInstructionOperandFromCache&quot;, CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
<span class="line-modified">!   {CC &quot;resolveConstantInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECT,                                                  FN_PTR(resolveConstantInPool)},</span>
<span class="line-removed">-   {CC &quot;resolvePossiblyCachedConstantInPool&quot;,          CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},</span>
    {CC &quot;resolveTypeInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
    {CC &quot;resolveFieldInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;I&quot; HS_RESOLVED_METHOD &quot;B[I)&quot; HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
    {CC &quot;resolveInvokeDynamicInPool&quot;,                   CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeDynamicInPool)},
    {CC &quot;resolveInvokeHandleInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeHandleInPool)},
    {CC &quot;isResolvedInvokeHandleInPool&quot;,                 CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(isResolvedInvokeHandleInPool)},
<span class="line-new-header">--- 2671,22 ---</span>
    {CC &quot;methodIsIgnoredBySecurityStackWalk&quot;,           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
    {CC &quot;setNotInlinableOrCompilable&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(setNotInlinableOrCompilable)},
    {CC &quot;isCompilable&quot;,                                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(isCompilable)},
    {CC &quot;hasNeverInlineDirective&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(hasNeverInlineDirective)},
    {CC &quot;shouldInlineMethod&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(shouldInlineMethod)},
<span class="line-modified">!   {CC &quot;lookupType&quot;,                                   CC &quot;(&quot; STRING HS_RESOLVED_KLASS &quot;Z)&quot; HS_RESOLVED_TYPE,                                FN_PTR(lookupType)},</span>
<span class="line-added">+   {CC &quot;getArrayType&quot;,                                 CC &quot;(&quot; HS_RESOLVED_TYPE &quot;)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getArrayType)},</span>
<span class="line-added">+   {CC &quot;lookupClass&quot;,                                  CC &quot;(&quot; CLASS &quot;)&quot; HS_RESOLVED_TYPE,                                                    FN_PTR(lookupClass)},</span>
    {CC &quot;lookupNameInPool&quot;,                             CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupNameInPool)},
    {CC &quot;lookupNameAndTypeRefIndexInPool&quot;,              CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
    {CC &quot;lookupSignatureInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupSignatureInPool)},
    {CC &quot;lookupKlassRefIndexInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupKlassRefIndexInPool)},
    {CC &quot;lookupKlassInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)Ljava/lang/Object;&quot;,                                       FN_PTR(lookupKlassInPool)},
<span class="line-modified">!   {CC &quot;lookupAppendixInPool&quot;,                         CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECTCONSTANT,                                          FN_PTR(lookupAppendixInPool)},</span>
    {CC &quot;lookupMethodInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;IB)&quot; HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
    {CC &quot;constantPoolRemapInstructionOperandFromCache&quot;, CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
<span class="line-modified">!   {CC &quot;resolvePossiblyCachedConstantInPool&quot;,          CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECTCONSTANT,                                          FN_PTR(resolvePossiblyCachedConstantInPool)},</span>
    {CC &quot;resolveTypeInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
    {CC &quot;resolveFieldInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;I&quot; HS_RESOLVED_METHOD &quot;B[I)&quot; HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
    {CC &quot;resolveInvokeDynamicInPool&quot;,                   CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeDynamicInPool)},
    {CC &quot;resolveInvokeHandleInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeHandleInPool)},
    {CC &quot;isResolvedInvokeHandleInPool&quot;,                 CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(isResolvedInvokeHandleInPool)},
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1599,42 ***</span>
    {CC &quot;getVtableIndexForInterfaceMethod&quot;,             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)I&quot;,                                     FN_PTR(getVtableIndexForInterfaceMethod)},
    {CC &quot;getClassInitializer&quot;,                          CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
    {CC &quot;hasFinalizableSubclass&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(hasFinalizableSubclass)},
    {CC &quot;getMaxCallTargetOffset&quot;,                       CC &quot;(J)J&quot;,                                                                            FN_PTR(getMaxCallTargetOffset)},
    {CC &quot;asResolvedJavaMethod&quot;,                         CC &quot;(&quot; EXECUTABLE &quot;)&quot; HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
<span class="line-modified">!   {CC &quot;getResolvedJavaMethod&quot;,                        CC &quot;(Ljava/lang/Object;J)&quot; HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},</span>
<span class="line-modified">!   {CC &quot;getConstantPool&quot;,                              CC &quot;(Ljava/lang/Object;)&quot; HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},</span>
<span class="line-modified">!   {CC &quot;getResolvedJavaType&quot;,                          CC &quot;(Ljava/lang/Object;JZ)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},</span>
    {CC &quot;readConfiguration&quot;,                            CC &quot;()[&quot; OBJECT,                                                                      FN_PTR(readConfiguration)},
<span class="line-modified">!   {CC &quot;installCode&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG &quot;)I&quot;,    FN_PTR(installCode)},</span>
    {CC &quot;getMetadata&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA &quot;)I&quot;,                          FN_PTR(getMetadata)},
    {CC &quot;resetCompilationStatistics&quot;,                   CC &quot;()V&quot;,                                                                             FN_PTR(resetCompilationStatistics)},
    {CC &quot;disassembleCodeBlob&quot;,                          CC &quot;(&quot; INSTALLED_CODE &quot;)&quot; STRING,                                                     FN_PTR(disassembleCodeBlob)},
<span class="line-modified">!   {CC &quot;executeInstalledCode&quot;,                         CC &quot;([&quot; OBJECT INSTALLED_CODE &quot;)&quot; OBJECT,                                             FN_PTR(executeInstalledCode)},</span>
    {CC &quot;getLineNumberTable&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[J&quot;,                                                      FN_PTR(getLineNumberTable)},
    {CC &quot;getLocalVariableTableStart&quot;,                   CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getLocalVariableTableStart)},
    {CC &quot;getLocalVariableTableLength&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getLocalVariableTableLength)},
    {CC &quot;reprofile&quot;,                                    CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(reprofile)},
<span class="line-modified">!   {CC &quot;invalidateInstalledCode&quot;,                      CC &quot;(&quot; INSTALLED_CODE &quot;)V&quot;,                                                           FN_PTR(invalidateInstalledCode)},</span>
    {CC &quot;collectCounters&quot;,                              CC &quot;()[J&quot;,                                                                            FN_PTR(collectCounters)},
    {CC &quot;allocateCompileId&quot;,                            CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)I&quot;,                                                      FN_PTR(allocateCompileId)},
    {CC &quot;isMature&quot;,                                     CC &quot;(&quot; METASPACE_METHOD_DATA &quot;)Z&quot;,                                                    FN_PTR(isMature)},
    {CC &quot;hasCompiledCodeForOSR&quot;,                        CC &quot;(&quot; HS_RESOLVED_METHOD &quot;II)Z&quot;,                                                     FN_PTR(hasCompiledCodeForOSR)},
    {CC &quot;getSymbol&quot;,                                    CC &quot;(J)&quot; STRING,                                                                      FN_PTR(getSymbol)},
    {CC &quot;iterateFrames&quot;,                                CC &quot;([&quot; RESOLVED_METHOD &quot;[&quot; RESOLVED_METHOD &quot;I&quot; INSPECTED_FRAME_VISITOR &quot;)&quot; OBJECT,   FN_PTR(iterateFrames)},
    {CC &quot;materializeVirtualObjects&quot;,                    CC &quot;(&quot; HS_STACK_FRAME_REF &quot;Z)V&quot;,                                                      FN_PTR(materializeVirtualObjects)},
    {CC &quot;shouldDebugNonSafepoints&quot;,                     CC &quot;()Z&quot;,                                                                             FN_PTR(shouldDebugNonSafepoints)},
<span class="line-modified">!   {CC &quot;writeDebugOutput&quot;,                             CC &quot;([BII)V&quot;,                                                                         FN_PTR(writeDebugOutput)},</span>
    {CC &quot;flushDebugOutput&quot;,                             CC &quot;()V&quot;,                                                                             FN_PTR(flushDebugOutput)},
    {CC &quot;methodDataProfileDataSize&quot;,                    CC &quot;(JI)I&quot;,                                                                           FN_PTR(methodDataProfileDataSize)},
    {CC &quot;getFingerprint&quot;,                               CC &quot;(J)J&quot;,                                                                            FN_PTR(getFingerprint)},
    {CC &quot;getHostClass&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
    {CC &quot;interpreterFrameSize&quot;,                         CC &quot;(&quot; BYTECODE_FRAME &quot;)I&quot;,                                                           FN_PTR(interpreterFrameSize)},
<span class="line-modified">!   {CC &quot;compileToBytecode&quot;,                            CC &quot;(&quot; OBJECT &quot;)V&quot;,                                                                   FN_PTR(compileToBytecode)},</span>
    {CC &quot;getFlagValue&quot;,                                 CC &quot;(&quot; STRING &quot;)&quot; OBJECT,                                                             FN_PTR(getFlagValue)},
    {CC &quot;asReflectionExecutable&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)&quot; REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
    {CC &quot;asReflectionField&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;I)&quot; REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},
  };
  
  int CompilerToVM::methods_count() {
    return sizeof(methods) / sizeof(JNINativeMethod);
  }
<span class="line-new-header">--- 2695,88 ---</span>
    {CC &quot;getVtableIndexForInterfaceMethod&quot;,             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)I&quot;,                                     FN_PTR(getVtableIndexForInterfaceMethod)},
    {CC &quot;getClassInitializer&quot;,                          CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
    {CC &quot;hasFinalizableSubclass&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(hasFinalizableSubclass)},
    {CC &quot;getMaxCallTargetOffset&quot;,                       CC &quot;(J)J&quot;,                                                                            FN_PTR(getMaxCallTargetOffset)},
    {CC &quot;asResolvedJavaMethod&quot;,                         CC &quot;(&quot; EXECUTABLE &quot;)&quot; HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
<span class="line-modified">!   {CC &quot;getResolvedJavaMethod&quot;,                        CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},</span>
<span class="line-modified">!   {CC &quot;getConstantPool&quot;,                              CC &quot;(&quot; METASPACE_OBJECT &quot;)&quot; HS_CONSTANT_POOL,                                         FN_PTR(getConstantPool)},</span>
<span class="line-modified">!   {CC &quot;getResolvedJavaType0&quot;,                         CC &quot;(Ljava/lang/Object;JZ)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType0)},</span>
    {CC &quot;readConfiguration&quot;,                            CC &quot;()[&quot; OBJECT,                                                                      FN_PTR(readConfiguration)},
<span class="line-modified">!   {CC &quot;installCode&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE &quot;J[B)I&quot;,                    FN_PTR(installCode)},</span>
    {CC &quot;getMetadata&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA &quot;)I&quot;,                          FN_PTR(getMetadata)},
    {CC &quot;resetCompilationStatistics&quot;,                   CC &quot;()V&quot;,                                                                             FN_PTR(resetCompilationStatistics)},
    {CC &quot;disassembleCodeBlob&quot;,                          CC &quot;(&quot; INSTALLED_CODE &quot;)&quot; STRING,                                                     FN_PTR(disassembleCodeBlob)},
<span class="line-modified">!   {CC &quot;executeHotSpotNmethod&quot;,                        CC &quot;([&quot; OBJECT HS_NMETHOD &quot;)&quot; OBJECT,                                                 FN_PTR(executeHotSpotNmethod)},</span>
    {CC &quot;getLineNumberTable&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[J&quot;,                                                      FN_PTR(getLineNumberTable)},
    {CC &quot;getLocalVariableTableStart&quot;,                   CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getLocalVariableTableStart)},
    {CC &quot;getLocalVariableTableLength&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getLocalVariableTableLength)},
    {CC &quot;reprofile&quot;,                                    CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(reprofile)},
<span class="line-modified">!   {CC &quot;invalidateHotSpotNmethod&quot;,                     CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(invalidateHotSpotNmethod)},</span>
<span class="line-added">+   {CC &quot;readUncompressedOop&quot;,                          CC &quot;(J)&quot; OBJECTCONSTANT,                                                              FN_PTR(readUncompressedOop)},</span>
    {CC &quot;collectCounters&quot;,                              CC &quot;()[J&quot;,                                                                            FN_PTR(collectCounters)},
<span class="line-added">+   {CC &quot;getCountersSize&quot;,                              CC &quot;()I&quot;,                                                                             FN_PTR(getCountersSize)},</span>
<span class="line-added">+   {CC &quot;setCountersSize&quot;,                              CC &quot;(I)V&quot;,                                                                            FN_PTR(setCountersSize)},</span>
    {CC &quot;allocateCompileId&quot;,                            CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)I&quot;,                                                      FN_PTR(allocateCompileId)},
    {CC &quot;isMature&quot;,                                     CC &quot;(&quot; METASPACE_METHOD_DATA &quot;)Z&quot;,                                                    FN_PTR(isMature)},
    {CC &quot;hasCompiledCodeForOSR&quot;,                        CC &quot;(&quot; HS_RESOLVED_METHOD &quot;II)Z&quot;,                                                     FN_PTR(hasCompiledCodeForOSR)},
    {CC &quot;getSymbol&quot;,                                    CC &quot;(J)&quot; STRING,                                                                      FN_PTR(getSymbol)},
    {CC &quot;iterateFrames&quot;,                                CC &quot;([&quot; RESOLVED_METHOD &quot;[&quot; RESOLVED_METHOD &quot;I&quot; INSPECTED_FRAME_VISITOR &quot;)&quot; OBJECT,   FN_PTR(iterateFrames)},
    {CC &quot;materializeVirtualObjects&quot;,                    CC &quot;(&quot; HS_STACK_FRAME_REF &quot;Z)V&quot;,                                                      FN_PTR(materializeVirtualObjects)},
    {CC &quot;shouldDebugNonSafepoints&quot;,                     CC &quot;()Z&quot;,                                                                             FN_PTR(shouldDebugNonSafepoints)},
<span class="line-modified">!   {CC &quot;writeDebugOutput&quot;,                             CC &quot;([BIIZZ)I&quot;,                                                                       FN_PTR(writeDebugOutput)},</span>
    {CC &quot;flushDebugOutput&quot;,                             CC &quot;()V&quot;,                                                                             FN_PTR(flushDebugOutput)},
    {CC &quot;methodDataProfileDataSize&quot;,                    CC &quot;(JI)I&quot;,                                                                           FN_PTR(methodDataProfileDataSize)},
    {CC &quot;getFingerprint&quot;,                               CC &quot;(J)J&quot;,                                                                            FN_PTR(getFingerprint)},
    {CC &quot;getHostClass&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
    {CC &quot;interpreterFrameSize&quot;,                         CC &quot;(&quot; BYTECODE_FRAME &quot;)I&quot;,                                                           FN_PTR(interpreterFrameSize)},
<span class="line-modified">!   {CC &quot;compileToBytecode&quot;,                            CC &quot;(&quot; OBJECTCONSTANT &quot;)V&quot;,                                                           FN_PTR(compileToBytecode)},</span>
    {CC &quot;getFlagValue&quot;,                                 CC &quot;(&quot; STRING &quot;)&quot; OBJECT,                                                             FN_PTR(getFlagValue)},
<span class="line-added">+   {CC &quot;getObjectAtAddress&quot;,                           CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(getObjectAtAddress)},</span>
<span class="line-added">+   {CC &quot;getInterfaces&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; HS_RESOLVED_KLASS,                                      FN_PTR(getInterfaces)},</span>
<span class="line-added">+   {CC &quot;getComponentType&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_TYPE,                                        FN_PTR(getComponentType)},</span>
<span class="line-added">+   {CC &quot;ensureInitialized&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)V&quot;,                                                        FN_PTR(ensureInitialized)},</span>
<span class="line-added">+   {CC &quot;getIdentityHashCode&quot;,                          CC &quot;(&quot; OBJECTCONSTANT &quot;)I&quot;,                                                           FN_PTR(getIdentityHashCode)},</span>
<span class="line-added">+   {CC &quot;isInternedString&quot;,                             CC &quot;(&quot; OBJECTCONSTANT &quot;)Z&quot;,                                                           FN_PTR(isInternedString)},</span>
<span class="line-added">+   {CC &quot;unboxPrimitive&quot;,                               CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; OBJECT,                                                     FN_PTR(unboxPrimitive)},</span>
<span class="line-added">+   {CC &quot;boxPrimitive&quot;,                                 CC &quot;(&quot; OBJECT &quot;)&quot; OBJECTCONSTANT,                                                     FN_PTR(boxPrimitive)},</span>
<span class="line-added">+   {CC &quot;getDeclaredConstructors&quot;,                      CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; RESOLVED_METHOD,                                        FN_PTR(getDeclaredConstructors)},</span>
<span class="line-added">+   {CC &quot;getDeclaredMethods&quot;,                           CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; RESOLVED_METHOD,                                        FN_PTR(getDeclaredMethods)},</span>
<span class="line-added">+   {CC &quot;readFieldValue&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_FIELD &quot;Z)&quot; JAVACONSTANT,                         FN_PTR(readFieldValue)},</span>
<span class="line-added">+   {CC &quot;readFieldValue&quot;,                               CC &quot;(&quot; OBJECTCONSTANT HS_RESOLVED_FIELD &quot;Z)&quot; JAVACONSTANT,                            FN_PTR(readFieldValue)},</span>
<span class="line-added">+   {CC &quot;isInstance&quot;,                                   CC &quot;(&quot; HS_RESOLVED_KLASS OBJECTCONSTANT &quot;)Z&quot;,                                         FN_PTR(isInstance)},</span>
<span class="line-added">+   {CC &quot;isAssignableFrom&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_KLASS &quot;)Z&quot;,                                      FN_PTR(isAssignableFrom)},</span>
<span class="line-added">+   {CC &quot;isTrustedForIntrinsics&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(isTrustedForIntrinsics)},</span>
<span class="line-added">+   {CC &quot;asJavaType&quot;,                                   CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; HS_RESOLVED_TYPE,                                           FN_PTR(asJavaType)},</span>
<span class="line-added">+   {CC &quot;asString&quot;,                                     CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; STRING,                                                     FN_PTR(asString)},</span>
<span class="line-added">+   {CC &quot;equals&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J&quot; OBJECTCONSTANT &quot;J)Z&quot;,                                       FN_PTR(equals)},</span>
<span class="line-added">+   {CC &quot;getJavaMirror&quot;,                                CC &quot;(&quot; HS_RESOLVED_TYPE &quot;)&quot; OBJECTCONSTANT,                                           FN_PTR(getJavaMirror)},</span>
<span class="line-added">+   {CC &quot;getArrayLength&quot;,                               CC &quot;(&quot; OBJECTCONSTANT &quot;)I&quot;,                                                           FN_PTR(getArrayLength)},</span>
<span class="line-added">+   {CC &quot;readArrayElement&quot;,                             CC &quot;(&quot; OBJECTCONSTANT &quot;I)Ljava/lang/Object;&quot;,                                         FN_PTR(readArrayElement)},</span>
<span class="line-added">+   {CC &quot;arrayBaseOffset&quot;,                              CC &quot;(Ljdk/vm/ci/meta/JavaKind;)I&quot;,                                                    FN_PTR(arrayBaseOffset)},</span>
<span class="line-added">+   {CC &quot;arrayIndexScale&quot;,                              CC &quot;(Ljdk/vm/ci/meta/JavaKind;)I&quot;,                                                    FN_PTR(arrayIndexScale)},</span>
<span class="line-added">+   {CC &quot;getByte&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)B&quot;,                                                          FN_PTR(getByte)},</span>
<span class="line-added">+   {CC &quot;getShort&quot;,                                     CC &quot;(&quot; OBJECTCONSTANT &quot;J)S&quot;,                                                          FN_PTR(getShort)},</span>
<span class="line-added">+   {CC &quot;getInt&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J)I&quot;,                                                          FN_PTR(getInt)},</span>
<span class="line-added">+   {CC &quot;getLong&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)J&quot;,                                                          FN_PTR(getLong)},</span>
<span class="line-added">+   {CC &quot;getObject&quot;,                                    CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; OBJECTCONSTANT,                                            FN_PTR(getObject)},</span>
<span class="line-added">+   {CC &quot;deleteGlobalHandle&quot;,                           CC &quot;(J)V&quot;,                                                                            FN_PTR(deleteGlobalHandle)},</span>
<span class="line-added">+   {CC &quot;registerNativeMethods&quot;,                        CC &quot;(&quot; CLASS &quot;)[J&quot;,                                                                   FN_PTR(registerNativeMethods)},</span>
<span class="line-added">+   {CC &quot;isCurrentThreadAttached&quot;,                      CC &quot;()Z&quot;,                                                                             FN_PTR(isCurrentThreadAttached)},</span>
<span class="line-added">+   {CC &quot;getCurrentJavaThread&quot;,                         CC &quot;()J&quot;,                                                                             FN_PTR(getCurrentJavaThread)},</span>
<span class="line-added">+   {CC &quot;attachCurrentThread&quot;,                          CC &quot;(Z)Z&quot;,                                                                            FN_PTR(attachCurrentThread)},</span>
<span class="line-added">+   {CC &quot;detachCurrentThread&quot;,                          CC &quot;()V&quot;,                                                                             FN_PTR(detachCurrentThread)},</span>
<span class="line-added">+   {CC &quot;translate&quot;,                                    CC &quot;(&quot; OBJECT &quot;)J&quot;,                                                                   FN_PTR(translate)},</span>
<span class="line-added">+   {CC &quot;unhand&quot;,                                       CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(unhand)},</span>
<span class="line-added">+   {CC &quot;updateHotSpotNmethod&quot;,                         CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(updateHotSpotNmethod)},</span>
<span class="line-added">+   {CC &quot;getCode&quot;,                                      CC &quot;(&quot; HS_INSTALLED_CODE &quot;)[B&quot;,                                                       FN_PTR(getCode)},</span>
    {CC &quot;asReflectionExecutable&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)&quot; REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
    {CC &quot;asReflectionField&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;I)&quot; REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},
<span class="line-added">+   {CC &quot;getFailedSpeculations&quot;,                        CC &quot;(J[[B)[[B&quot;,                                                                       FN_PTR(getFailedSpeculations)},</span>
<span class="line-added">+   {CC &quot;getFailedSpeculationsAddress&quot;,                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getFailedSpeculationsAddress)},</span>
<span class="line-added">+   {CC &quot;releaseFailedSpeculations&quot;,                    CC &quot;(J)V&quot;,                                                                            FN_PTR(releaseFailedSpeculations)},</span>
<span class="line-added">+   {CC &quot;addFailedSpeculation&quot;,                         CC &quot;(J[B)Z&quot;,                                                                          FN_PTR(addFailedSpeculation)},</span>
<span class="line-added">+   {CC &quot;callSystemExit&quot;,                               CC &quot;(I)V&quot;,                                                                            FN_PTR(callSystemExit)},</span>
  };
  
  int CompilerToVM::methods_count() {
    return sizeof(methods) / sizeof(JNINativeMethod);
  }
</pre>
<center><a href="jvmciCompiler.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCompilerToVM.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciEnv.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciJavaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciEnv.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JVMCI_JVMCIENV_HPP
 26 #define SHARE_JVMCI_JVMCIENV_HPP
 27 
<span class="line-modified"> 28 #include &quot;classfile/systemDictionary.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;code/debugInfoRec.hpp&quot;</span>
<span class="line-removed"> 30 #include &quot;code/dependencies.hpp&quot;</span>
<span class="line-removed"> 31 #include &quot;code/exceptionHandlerTable.hpp&quot;</span>
<span class="line-removed"> 32 #include &quot;compiler/oopMap.hpp&quot;</span>
 33 #include &quot;runtime/thread.hpp&quot;
 34 
 35 class CompileTask;
<span class="line-modified"> 36 </span>
<span class="line-modified"> 37 // Bring the JVMCI compiler thread into the VM state.</span>
<span class="line-modified"> 38 #define JVMCI_VM_ENTRY_MARK                       \</span>
<span class="line-modified"> 39   JavaThread* thread = JavaThread::current(); \</span>
<span class="line-modified"> 40   ThreadInVMfromNative __tiv(thread);       \</span>
<span class="line-removed"> 41   ResetNoHandleMark rnhm;                   \</span>
<span class="line-removed"> 42   HandleMarkCleaner __hm(thread);           \</span>
<span class="line-removed"> 43   Thread* THREAD = thread;                  \</span>
<span class="line-removed"> 44   debug_only(VMNativeEntryWrapper __vew;)</span>
 45 
 46 #define JVMCI_EXCEPTION_CONTEXT \
 47   JavaThread* thread=JavaThread::current(); \
 48   Thread* THREAD = thread;
 49 
<span class="line-modified"> 50 //</span>
<span class="line-modified"> 51 // This class is the top level broker for requests from the compiler</span>
<span class="line-modified"> 52 // to the VM.</span>
<span class="line-modified"> 53 class JVMCIEnv : StackObj {</span>
<span class="line-modified"> 54   CI_PACKAGE_ACCESS_TO</span>






 55 
<span class="line-modified"> 56   friend class JVMCIVMStructs;</span>
<span class="line-modified"> 57   friend class CompileBroker;</span>
<span class="line-modified"> 58   friend class Dependencies;  // for get_object, during logging</span>



 59 
<span class="line-modified"> 60 public:</span>

 61 
<span class="line-modified"> 62   enum CodeInstallResult {</span>
<span class="line-modified"> 63      ok,</span>
<span class="line-modified"> 64      dependencies_failed,</span>
<span class="line-modified"> 65      dependencies_invalid,</span>
<span class="line-removed"> 66      cache_full,</span>
<span class="line-removed"> 67      code_too_large</span>
<span class="line-removed"> 68   };</span>
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70   // Look up a klass by name from a particular class loader (the accessor&#39;s).</span>
<span class="line-removed"> 71   // If require_local, result must be defined in that class loader, or NULL.</span>
<span class="line-removed"> 72   // If !require_local, a result from remote class loader may be reported,</span>
<span class="line-removed"> 73   // if sufficient class loader constraints exist such that initiating</span>
<span class="line-removed"> 74   // a class loading request from the given loader is bound to return</span>
<span class="line-removed"> 75   // the class defined in the remote loader (or throw an error).</span>
<span class="line-removed"> 76   //</span>
<span class="line-removed"> 77   // Return an unloaded klass if !require_local and no class at all is found.</span>
<span class="line-removed"> 78   //</span>
<span class="line-removed"> 79   // The CI treats a klass as loaded if it is consistently defined in</span>
<span class="line-removed"> 80   // another loader, even if it hasn&#39;t yet been loaded in all loaders</span>
<span class="line-removed"> 81   // that could potentially see it via delegation.</span>
<span class="line-removed"> 82   static Klass* get_klass_by_name(Klass* accessing_klass, Symbol* klass_name, bool require_local);</span>
<span class="line-removed"> 83 </span>
<span class="line-removed"> 84   // Constant pool access.</span>
<span class="line-removed"> 85   static Klass* get_klass_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-removed"> 86                                    int klass_index,</span>
<span class="line-removed"> 87                                    bool&amp; is_accessible,</span>
<span class="line-removed"> 88                                    Klass* loading_klass);</span>
<span class="line-removed"> 89   static void   get_field_by_index(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,</span>
<span class="line-removed"> 90                                    int field_index);</span>
<span class="line-removed"> 91   static methodHandle  get_method_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-removed"> 92                                     int method_index, Bytecodes::Code bc,</span>
<span class="line-removed"> 93                                     InstanceKlass* loading_klass);</span>
<span class="line-removed"> 94 </span>
<span class="line-removed"> 95   JVMCIEnv(CompileTask* task, int system_dictionary_modification_counter);</span>
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97 private:</span>
<span class="line-removed"> 98   CompileTask*     _task;</span>
<span class="line-removed"> 99   int              _system_dictionary_modification_counter;</span>
100 
<span class="line-modified">101   // Compilation result values</span>
<span class="line-modified">102   bool             _retryable;</span>
<span class="line-modified">103   const char*      _failure_reason;</span>
104 
<span class="line-modified">105   // Specifies if _failure_reason is on the C heap.</span>
<span class="line-modified">106   bool             _failure_reason_on_C_heap;</span>

















107 
108   // Cache JVMTI state. Defined as bytes so that reading them from Java
109   // via Unsafe is well defined (the C++ type for bool is implementation
110   // defined and may not be the same as a Java boolean).

111   jbyte  _jvmti_can_hotswap_or_post_breakpoint;
112   jbyte  _jvmti_can_access_local_variables;
113   jbyte  _jvmti_can_post_on_exceptions;
114   jbyte  _jvmti_can_pop_frame;
115 
<span class="line-modified">116   // Implementation methods for loading and constant pool access.</span>
<span class="line-modified">117   static Klass* get_klass_by_name_impl(Klass* accessing_klass,</span>
<span class="line-modified">118                                   const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">119                                   Symbol* klass_name,</span>
<span class="line-modified">120                                   bool require_local);</span>
<span class="line-modified">121   static Klass* get_klass_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">122                                      int klass_index,</span>
<span class="line-modified">123                                      bool&amp; is_accessible,</span>
<span class="line-modified">124                                      Klass* loading_klass);</span>
<span class="line-modified">125   static void   get_field_by_index_impl(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,</span>
<span class="line-removed">126                                      int field_index);</span>
<span class="line-removed">127   static methodHandle  get_method_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-removed">128                                       int method_index, Bytecodes::Code bc,</span>
<span class="line-removed">129                                       InstanceKlass* loading_klass);</span>
<span class="line-removed">130 </span>
<span class="line-removed">131   // Helper methods</span>
<span class="line-removed">132   static bool       check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass);</span>
<span class="line-removed">133   static methodHandle  lookup_method(InstanceKlass*  accessor,</span>
<span class="line-removed">134                            Klass*         holder,</span>
<span class="line-removed">135                            Symbol*        name,</span>
<span class="line-removed">136                            Symbol*        sig,</span>
<span class="line-removed">137                            Bytecodes::Code bc,</span>
<span class="line-removed">138                            constantTag     tag);</span>
<span class="line-removed">139 </span>
<span class="line-removed">140   private:</span>
<span class="line-removed">141 </span>
<span class="line-removed">142   // Is this thread currently in the VM state?</span>
<span class="line-removed">143   static bool is_in_vm();</span>
<span class="line-removed">144 </span>
<span class="line-removed">145   // Helper routine for determining the validity of a compilation</span>
<span class="line-removed">146   // with respect to concurrent class loading.</span>
<span class="line-removed">147   static JVMCIEnv::CodeInstallResult validate_compile_task_dependencies(Dependencies* target, Handle compiled_code,</span>
<span class="line-removed">148                                                                         JVMCIEnv* env, char** failure_detail);</span>
149 
<span class="line-removed">150 public:</span>
151   CompileTask* task() { return _task; }
152 
153   bool  jvmti_state_changed() const;

154   bool  jvmti_can_hotswap_or_post_breakpoint() const { return  _jvmti_can_hotswap_or_post_breakpoint != 0; }
155   bool  jvmti_can_access_local_variables() const     { return  _jvmti_can_access_local_variables != 0; }
156   bool  jvmti_can_post_on_exceptions() const         { return  _jvmti_can_post_on_exceptions != 0; }
157   bool  jvmti_can_pop_frame() const                  { return  _jvmti_can_pop_frame != 0; }
158 
159   const char* failure_reason() { return _failure_reason; }
160   bool failure_reason_on_C_heap() { return _failure_reason_on_C_heap; }
161   bool retryable() { return _retryable; }
162 
163   void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false) {
164     _failure_reason = reason;
165     _failure_reason_on_C_heap = reason_on_C_heap;
166     _retryable = retryable;
167   }



























































































































































































































































































































































168 
<span class="line-modified">169   // Register the result of a compilation.</span>
<span class="line-removed">170   static JVMCIEnv::CodeInstallResult register_method(</span>
<span class="line-removed">171                        const methodHandle&amp;       target,</span>
<span class="line-removed">172                        nmethod*&amp;                 nm,</span>
<span class="line-removed">173                        int                       entry_bci,</span>
<span class="line-removed">174                        CodeOffsets*              offsets,</span>
<span class="line-removed">175                        int                       orig_pc_offset,</span>
<span class="line-removed">176                        CodeBuffer*               code_buffer,</span>
<span class="line-removed">177                        int                       frame_words,</span>
<span class="line-removed">178                        OopMapSet*                oop_map_set,</span>
<span class="line-removed">179                        ExceptionHandlerTable*    handler_table,</span>
<span class="line-removed">180                        AbstractCompiler*         compiler,</span>
<span class="line-removed">181                        DebugInformationRecorder* debug_info,</span>
<span class="line-removed">182                        Dependencies*             dependencies,</span>
<span class="line-removed">183                        JVMCIEnv*                 env,</span>
<span class="line-removed">184                        int                       compile_id,</span>
<span class="line-removed">185                        bool                      has_unsafe_access,</span>
<span class="line-removed">186                        bool                      has_wide_vector,</span>
<span class="line-removed">187                        Handle                    installed_code,</span>
<span class="line-removed">188                        Handle                    compiled_code,</span>
<span class="line-removed">189                        Handle                    speculation_log);</span>
<span class="line-removed">190 </span>
<span class="line-removed">191   // converts the Klass* representing the holder of a method into a</span>
<span class="line-removed">192   // InstanceKlass*.  This is needed since the holder of a method in</span>
<span class="line-removed">193   // the bytecodes could be an array type.  Basically this converts</span>
<span class="line-removed">194   // array types into java/lang/Object and other types stay as they are.</span>
<span class="line-removed">195   static InstanceKlass* get_instance_klass_for_declared_method_holder(Klass* klass);</span>
196 };
197 
198 #endif // SHARE_JVMCI_JVMCIENV_HPP
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JVMCI_JVMCIENV_HPP
 26 #define SHARE_JVMCI_JVMCIENV_HPP
 27 
<span class="line-modified"> 28 #include &quot;classfile/javaClasses.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>



 30 #include &quot;runtime/thread.hpp&quot;
 31 
 32 class CompileTask;
<span class="line-modified"> 33 class JVMCIObject;</span>
<span class="line-modified"> 34 class JVMCIObjectArray;</span>
<span class="line-modified"> 35 class JVMCIPrimitiveArray;</span>
<span class="line-modified"> 36 class JVMCICompiler;</span>
<span class="line-modified"> 37 class JVMCIRuntime;</span>




 38 
 39 #define JVMCI_EXCEPTION_CONTEXT \
 40   JavaThread* thread=JavaThread::current(); \
 41   Thread* THREAD = thread;
 42 
<span class="line-modified"> 43 // Helper to log more context on a JNI exception</span>
<span class="line-modified"> 44 #define JVMCI_EXCEPTION_CHECK(env, ...) \</span>
<span class="line-modified"> 45   do { \</span>
<span class="line-modified"> 46     if (env-&gt;ExceptionCheck()) { \</span>
<span class="line-modified"> 47       if (env != JavaThread::current()-&gt;jni_environment() &amp;&amp; JVMCIEnv::get_shared_library_path() != NULL) { \</span>
<span class="line-added"> 48         tty-&gt;print_cr(&quot;In JVMCI shared library (%s):&quot;, JVMCIEnv::get_shared_library_path()); \</span>
<span class="line-added"> 49       } \</span>
<span class="line-added"> 50       tty-&gt;print_cr(__VA_ARGS__); \</span>
<span class="line-added"> 51       return; \</span>
<span class="line-added"> 52     } \</span>
<span class="line-added"> 53   } while(0)</span>
 54 
<span class="line-modified"> 55 // Helper class to ensure that references to Klass* are kept alive for G1</span>
<span class="line-modified"> 56 class JVMCIKlassHandle : public StackObj {</span>
<span class="line-modified"> 57  private:</span>
<span class="line-added"> 58   Klass*     _klass;</span>
<span class="line-added"> 59   Handle     _holder;</span>
<span class="line-added"> 60   Thread*    _thread;</span>
 61 
<span class="line-modified"> 62   Klass*        klass() const                     { return _klass; }</span>
<span class="line-added"> 63   Klass*        non_null_klass() const            { assert(_klass != NULL, &quot;resolving NULL _klass&quot;); return _klass; }</span>
 64 
<span class="line-modified"> 65  public:</span>
<span class="line-modified"> 66   /* Constructors */</span>
<span class="line-modified"> 67   JVMCIKlassHandle (Thread* thread) : _klass(NULL), _thread(thread) {}</span>
<span class="line-modified"> 68   JVMCIKlassHandle (Thread* thread, Klass* klass);</span>


































 69 
<span class="line-modified"> 70   JVMCIKlassHandle (const JVMCIKlassHandle &amp;h): _klass(h._klass), _holder(h._holder), _thread(h._thread) {}</span>
<span class="line-modified"> 71   JVMCIKlassHandle&amp; operator=(const JVMCIKlassHandle &amp;s);</span>
<span class="line-modified"> 72   JVMCIKlassHandle&amp; operator=(Klass* klass);</span>
 73 
<span class="line-modified"> 74   /* Operators for ease of use */</span>
<span class="line-modified"> 75   Klass*        operator () () const            { return klass(); }</span>
<span class="line-added"> 76   Klass*        operator -&gt; () const            { return non_null_klass(); }</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78   bool    operator == (Klass* o) const          { return klass() == o; }</span>
<span class="line-added"> 79   bool    operator == (const JVMCIKlassHandle&amp; h) const  { return klass() == h.klass(); }</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81   /* Null checks */</span>
<span class="line-added"> 82   bool    is_null() const                      { return _klass == NULL; }</span>
<span class="line-added"> 83   bool    not_null() const                     { return _klass != NULL; }</span>
<span class="line-added"> 84 };</span>
<span class="line-added"> 85 </span>
<span class="line-added"> 86 // A class that maintains the state needed for compilations requested</span>
<span class="line-added"> 87 // by the CompileBroker.  It is created in the broker and passed through</span>
<span class="line-added"> 88 // into the code installation step.</span>
<span class="line-added"> 89 class JVMCICompileState : public ResourceObj {</span>
<span class="line-added"> 90   friend class JVMCIVMStructs;</span>
<span class="line-added"> 91  private:</span>
<span class="line-added"> 92   CompileTask*     _task;</span>
 93 
 94   // Cache JVMTI state. Defined as bytes so that reading them from Java
 95   // via Unsafe is well defined (the C++ type for bool is implementation
 96   // defined and may not be the same as a Java boolean).
<span class="line-added"> 97   uint64_t _jvmti_redefinition_count;</span>
 98   jbyte  _jvmti_can_hotswap_or_post_breakpoint;
 99   jbyte  _jvmti_can_access_local_variables;
100   jbyte  _jvmti_can_post_on_exceptions;
101   jbyte  _jvmti_can_pop_frame;
102 
<span class="line-modified">103   // Compilation result values.</span>
<span class="line-modified">104   bool             _retryable;</span>
<span class="line-modified">105   const char*      _failure_reason;</span>
<span class="line-modified">106 </span>
<span class="line-modified">107   // Specifies if _failure_reason is on the C heap. If so, it is allocated</span>
<span class="line-modified">108   // with the mtJVMCI NMT flag.</span>
<span class="line-modified">109   bool             _failure_reason_on_C_heap;</span>
<span class="line-modified">110 </span>
<span class="line-modified">111  public:</span>
<span class="line-modified">112   JVMCICompileState(CompileTask* task);</span>























113 

114   CompileTask* task() { return _task; }
115 
116   bool  jvmti_state_changed() const;
<span class="line-added">117   uint64_t jvmti_redefinition_count() const          { return  _jvmti_redefinition_count; }</span>
118   bool  jvmti_can_hotswap_or_post_breakpoint() const { return  _jvmti_can_hotswap_or_post_breakpoint != 0; }
119   bool  jvmti_can_access_local_variables() const     { return  _jvmti_can_access_local_variables != 0; }
120   bool  jvmti_can_post_on_exceptions() const         { return  _jvmti_can_post_on_exceptions != 0; }
121   bool  jvmti_can_pop_frame() const                  { return  _jvmti_can_pop_frame != 0; }
122 
123   const char* failure_reason() { return _failure_reason; }
124   bool failure_reason_on_C_heap() { return _failure_reason_on_C_heap; }
125   bool retryable() { return _retryable; }
126 
127   void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false) {
128     _failure_reason = reason;
129     _failure_reason_on_C_heap = reason_on_C_heap;
130     _retryable = retryable;
131   }
<span class="line-added">132 };</span>
<span class="line-added">133 </span>
<span class="line-added">134 </span>
<span class="line-added">135 // This class is a top level wrapper around interactions between HotSpot</span>
<span class="line-added">136 // and the JVMCI Java code.  It supports both a HotSpot heap based</span>
<span class="line-added">137 // runtime with HotSpot oop based accessors as well as a shared library</span>
<span class="line-added">138 // based runtime that is accessed through JNI. It abstracts away all</span>
<span class="line-added">139 // interactions with JVMCI objects so that a single version of the</span>
<span class="line-added">140 // HotSpot C++ code can can work with either runtime.</span>
<span class="line-added">141 class JVMCIEnv : public ResourceObj {</span>
<span class="line-added">142   friend class JNIAccessMark;</span>
<span class="line-added">143 </span>
<span class="line-added">144   static char*   _shared_library_path;   // argument to os:dll_load</span>
<span class="line-added">145   static void*   _shared_library_handle; // result of os::dll_load</span>
<span class="line-added">146   static JavaVM* _shared_library_javavm; // result of calling JNI_CreateJavaVM in shared library</span>
<span class="line-added">147 </span>
<span class="line-added">148   // Initializes the shared library JavaVM if not already initialized.</span>
<span class="line-added">149   // Returns the JNI interface pointer for the current thread</span>
<span class="line-added">150   // if initialization was performed by this call, NULL if</span>
<span class="line-added">151   // initialization was performed by a previous call.</span>
<span class="line-added">152   static JNIEnv* init_shared_library(JavaThread* thread);</span>
<span class="line-added">153 </span>
<span class="line-added">154   // Initializes the _env, _mode and _runtime fields.</span>
<span class="line-added">155   void init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env);</span>
<span class="line-added">156 </span>
<span class="line-added">157   void init(JavaThread* thread, bool is_hotspot, const char* file, int line);</span>
<span class="line-added">158 </span>
<span class="line-added">159   JNIEnv*                 _env;  // JNI env for calling into shared library</span>
<span class="line-added">160   bool     _pop_frame_on_close;  // Must pop frame on close?</span>
<span class="line-added">161   bool        _detach_on_close;  // Must detach on close?</span>
<span class="line-added">162   JVMCIRuntime*       _runtime;  // Access to a HotSpotJVMCIRuntime</span>
<span class="line-added">163   bool             _is_hotspot;  // Which heap is the HotSpotJVMCIRuntime in</span>
<span class="line-added">164   bool        _throw_to_caller;  // Propagate an exception raised in this env to the caller?</span>
<span class="line-added">165   const char*            _file;  // The file and ...</span>
<span class="line-added">166   int                    _line;  // ... line where this JNIEnv was created</span>
<span class="line-added">167 </span>
<span class="line-added">168   // Translates an exception on the HotSpot heap to an exception on</span>
<span class="line-added">169   // the shared library heap. The translation includes the stack and</span>
<span class="line-added">170   // causes of `throwable`. The translated exception is pending in the</span>
<span class="line-added">171   // shared library thread upon returning.</span>
<span class="line-added">172   void translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable);</span>
<span class="line-added">173 </span>
<span class="line-added">174 public:</span>
<span class="line-added">175   // Opens a JVMCIEnv scope for a Java to VM call (e.g., via CompilerToVM).</span>
<span class="line-added">176   // An exception occurring within the scope is left pending when the</span>
<span class="line-added">177   // scope closes so that it will be propagated back to Java.</span>
<span class="line-added">178   // The JVMCIEnv destructor translates the exception object for the</span>
<span class="line-added">179   // Java runtime if necessary.</span>
<span class="line-added">180   JVMCIEnv(JavaThread* thread, JNIEnv* env, const char* file, int line);</span>
<span class="line-added">181 </span>
<span class="line-added">182   // Opens a JVMCIEnv scope for a compilation scheduled by the CompileBroker.</span>
<span class="line-added">183   // An exception occurring within the scope must not be propagated back to</span>
<span class="line-added">184   // the CompileBroker.</span>
<span class="line-added">185   JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line);</span>
<span class="line-added">186 </span>
<span class="line-added">187   // Opens a JNIEnv scope for a call from within the VM. An exception occurring</span>
<span class="line-added">188   // within the scope must not be propagated back to the caller.</span>
<span class="line-added">189   JVMCIEnv(JavaThread* env, const char* file, int line);</span>
<span class="line-added">190 </span>
<span class="line-added">191   // Opens a JNIEnv scope for accessing `for_object`. An exception occurring</span>
<span class="line-added">192   // within the scope must not be propagated back to the caller.</span>
<span class="line-added">193   JVMCIEnv(JavaThread* thread, JVMCIObject for_object, const char* file, int line) {</span>
<span class="line-added">194     // A JNI call to access an object in the shared library heap</span>
<span class="line-added">195     // can block or take a long time so do not allow such access</span>
<span class="line-added">196     // on the VM thread.</span>
<span class="line-added">197     assert(for_object.is_hotspot() || !Thread::current()-&gt;is_VM_thread(),</span>
<span class="line-added">198         &quot;cannot open JVMCIEnv scope when in the VM thread for accessing a shared library heap object&quot;);</span>
<span class="line-added">199     init(thread, for_object.is_hotspot(), file, line);</span>
<span class="line-added">200   }</span>
<span class="line-added">201 </span>
<span class="line-added">202   // Opens a JNIEnv scope for the HotSpot runtime if `is_hotspot` is true</span>
<span class="line-added">203   // otherwise for the shared library runtime. An exception occurring</span>
<span class="line-added">204   // within the scope must not be propagated back to the caller.</span>
<span class="line-added">205   JVMCIEnv(JavaThread* thread, bool is_hotspot, const char* file, int line) {</span>
<span class="line-added">206     init(thread, is_hotspot, file, line);</span>
<span class="line-added">207   }</span>
<span class="line-added">208 </span>
<span class="line-added">209   ~JVMCIEnv();</span>
<span class="line-added">210 </span>
<span class="line-added">211   JVMCIRuntime* runtime() {</span>
<span class="line-added">212     return _runtime;</span>
<span class="line-added">213   }</span>
<span class="line-added">214 </span>
<span class="line-added">215   // Initializes Services.savedProperties in the shared library by copying</span>
<span class="line-added">216   // the values from the same field in the HotSpot heap.</span>
<span class="line-added">217   void copy_saved_properties();</span>
<span class="line-added">218 </span>
<span class="line-added">219   jboolean has_pending_exception();</span>
<span class="line-added">220   void clear_pending_exception();</span>
<span class="line-added">221 </span>
<span class="line-added">222   // Prints an exception and stack trace of a pending exception.</span>
<span class="line-added">223   void describe_pending_exception(bool clear);</span>
<span class="line-added">224 </span>
<span class="line-added">225   int get_length(JVMCIArray array);</span>
<span class="line-added">226 </span>
<span class="line-added">227   JVMCIObject get_object_at(JVMCIObjectArray array, int index);</span>
<span class="line-added">228   void put_object_at(JVMCIObjectArray array, int index, JVMCIObject value);</span>
<span class="line-added">229 </span>
<span class="line-added">230   jboolean get_bool_at(JVMCIPrimitiveArray array, int index);</span>
<span class="line-added">231   void put_bool_at(JVMCIPrimitiveArray array, int index, jboolean value);</span>
<span class="line-added">232 </span>
<span class="line-added">233   jbyte get_byte_at(JVMCIPrimitiveArray array, int index);</span>
<span class="line-added">234   void put_byte_at(JVMCIPrimitiveArray array, int index, jbyte value);</span>
<span class="line-added">235 </span>
<span class="line-added">236   jint get_int_at(JVMCIPrimitiveArray array, int index);</span>
<span class="line-added">237   void put_int_at(JVMCIPrimitiveArray array, int index, jint value);</span>
<span class="line-added">238 </span>
<span class="line-added">239   long get_long_at(JVMCIPrimitiveArray array, int index);</span>
<span class="line-added">240   void put_long_at(JVMCIPrimitiveArray array, int index, jlong value);</span>
<span class="line-added">241 </span>
<span class="line-added">242   void copy_bytes_to(JVMCIPrimitiveArray src, jbyte* dest, int offset, jsize length);</span>
<span class="line-added">243   void copy_bytes_from(jbyte* src, JVMCIPrimitiveArray dest, int offset, jsize length);</span>
<span class="line-added">244 </span>
<span class="line-added">245   void copy_longs_from(jlong* src, JVMCIPrimitiveArray dest, int offset, jsize length);</span>
<span class="line-added">246 </span>
<span class="line-added">247   JVMCIObjectArray initialize_intrinsics(JVMCI_TRAPS);</span>
<span class="line-added">248 </span>
<span class="line-added">249   jboolean is_boxing_object(BasicType type, JVMCIObject object);</span>
<span class="line-added">250 </span>
<span class="line-added">251   // Get the primitive value from a Java boxing object.  It&#39;s hard error to</span>
<span class="line-added">252   // pass a non-primitive BasicType.</span>
<span class="line-added">253   jvalue get_boxed_value(BasicType type, JVMCIObject object);</span>
<span class="line-added">254 </span>
<span class="line-added">255   // Return the BasicType of the object if it&#39;s a boxing object, otherwise return T_ILLEGAL.</span>
<span class="line-added">256   BasicType get_box_type(JVMCIObject object);</span>
<span class="line-added">257 </span>
<span class="line-added">258   // Create a boxing object of the appropriate primitive type.</span>
<span class="line-added">259   JVMCIObject create_box(BasicType type, jvalue* value, JVMCI_TRAPS);</span>
<span class="line-added">260 </span>
<span class="line-added">261   const char* as_utf8_string(JVMCIObject str);</span>
<span class="line-added">262   char* as_utf8_string(JVMCIObject str, char* buf, int buflen);</span>
<span class="line-added">263 </span>
<span class="line-added">264   JVMCIObject create_string(Symbol* str, JVMCI_TRAPS) {</span>
<span class="line-added">265     return create_string(str-&gt;as_C_string(), JVMCI_CHECK_(JVMCIObject()));</span>
<span class="line-added">266   }</span>
<span class="line-added">267 </span>
<span class="line-added">268   JVMCIObject create_string(const char* str, JVMCI_TRAPS);</span>
<span class="line-added">269 </span>
<span class="line-added">270   bool equals(JVMCIObject a, JVMCIObject b);</span>
<span class="line-added">271 </span>
<span class="line-added">272   // Convert into a JNI handle for the appropriate runtime</span>
<span class="line-added">273   jobject get_jobject(JVMCIObject object)                       { assert(object.as_jobject() == NULL || is_hotspot() == object.is_hotspot(), &quot;mismatch&quot;); return object.as_jobject(); }</span>
<span class="line-added">274   jarray get_jarray(JVMCIArray array)                           { assert(array.as_jobject() == NULL || is_hotspot() == array.is_hotspot(), &quot;mismatch&quot;); return array.as_jobject(); }</span>
<span class="line-added">275   jobjectArray get_jobjectArray(JVMCIObjectArray objectArray)   { assert(objectArray.as_jobject() == NULL || is_hotspot() == objectArray.is_hotspot(), &quot;mismatch&quot;); return objectArray.as_jobject(); }</span>
<span class="line-added">276   jbyteArray get_jbyteArray(JVMCIPrimitiveArray primitiveArray) { assert(primitiveArray.as_jobject() == NULL || is_hotspot() == primitiveArray.is_hotspot(), &quot;mismatch&quot;); return primitiveArray.as_jbyteArray(); }</span>
<span class="line-added">277 </span>
<span class="line-added">278   JVMCIObject         wrap(jobject obj);</span>
<span class="line-added">279   JVMCIObjectArray    wrap(jobjectArray obj)  { return (JVMCIObjectArray)    wrap((jobject) obj); }</span>
<span class="line-added">280   JVMCIPrimitiveArray wrap(jintArray obj)     { return (JVMCIPrimitiveArray) wrap((jobject) obj); }</span>
<span class="line-added">281   JVMCIPrimitiveArray wrap(jbooleanArray obj) { return (JVMCIPrimitiveArray) wrap((jobject) obj); }</span>
<span class="line-added">282   JVMCIPrimitiveArray wrap(jbyteArray obj)    { return (JVMCIPrimitiveArray) wrap((jobject) obj); }</span>
<span class="line-added">283   JVMCIPrimitiveArray wrap(jlongArray obj)    { return (JVMCIPrimitiveArray) wrap((jobject) obj); }</span>
<span class="line-added">284 </span>
<span class="line-added">285  private:</span>
<span class="line-added">286   JVMCIObject wrap(oop obj)                  { assert(is_hotspot(), &quot;must be&quot;); return wrap(JNIHandles::make_local(obj)); }</span>
<span class="line-added">287   JVMCIObjectArray wrap(objArrayOop obj)     { assert(is_hotspot(), &quot;must be&quot;); return (JVMCIObjectArray) wrap(JNIHandles::make_local(obj)); }</span>
<span class="line-added">288   JVMCIPrimitiveArray wrap(typeArrayOop obj) { assert(is_hotspot(), &quot;must be&quot;); return (JVMCIPrimitiveArray) wrap(JNIHandles::make_local(obj)); }</span>
<span class="line-added">289 </span>
<span class="line-added">290  public:</span>
<span class="line-added">291   // Compiles a method with the JVMIC compiler.</span>
<span class="line-added">292   // Caller must handle pending exception.</span>
<span class="line-added">293   JVMCIObject call_HotSpotJVMCIRuntime_compileMethod(JVMCIObject runtime, JVMCIObject method, int entry_bci,</span>
<span class="line-added">294                                                      jlong compile_state, int id);</span>
<span class="line-added">295 </span>
<span class="line-added">296   void call_HotSpotJVMCIRuntime_bootstrapFinished(JVMCIObject runtime, JVMCI_TRAPS);</span>
<span class="line-added">297   void call_HotSpotJVMCIRuntime_shutdown(JVMCIObject runtime);</span>
<span class="line-added">298   JVMCIObject call_HotSpotJVMCIRuntime_runtime(JVMCI_TRAPS);</span>
<span class="line-added">299   JVMCIObject call_JVMCI_getRuntime(JVMCI_TRAPS);</span>
<span class="line-added">300   JVMCIObject call_HotSpotJVMCIRuntime_getCompiler(JVMCIObject runtime, JVMCI_TRAPS);</span>
<span class="line-added">301 </span>
<span class="line-added">302   JVMCIObject call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCI_TRAPS);</span>
<span class="line-added">303 </span>
<span class="line-added">304   JVMCIObject call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS);</span>
<span class="line-added">305   JVMCIObject call_JavaConstant_forFloat(float value, JVMCI_TRAPS);</span>
<span class="line-added">306   JVMCIObject call_JavaConstant_forDouble(double value, JVMCI_TRAPS);</span>
<span class="line-added">307 </span>
<span class="line-added">308   BasicType kindToBasicType(JVMCIObject kind, JVMCI_TRAPS);</span>
<span class="line-added">309 </span>
<span class="line-added">310 #define DO_THROW(name) \</span>
<span class="line-added">311   void throw_##name(const char* msg = NULL);</span>
<span class="line-added">312 </span>
<span class="line-added">313   DO_THROW(InternalError)</span>
<span class="line-added">314   DO_THROW(ArrayIndexOutOfBoundsException)</span>
<span class="line-added">315   DO_THROW(IllegalStateException)</span>
<span class="line-added">316   DO_THROW(NullPointerException)</span>
<span class="line-added">317   DO_THROW(IllegalArgumentException)</span>
<span class="line-added">318   DO_THROW(InvalidInstalledCodeException)</span>
<span class="line-added">319   DO_THROW(UnsatisfiedLinkError)</span>
<span class="line-added">320   DO_THROW(UnsupportedOperationException)</span>
<span class="line-added">321   DO_THROW(ClassNotFoundException)</span>
<span class="line-added">322 </span>
<span class="line-added">323 #undef DO_THROW</span>
<span class="line-added">324 </span>
<span class="line-added">325   void fthrow_error(const char* file, int line, const char* format, ...) ATTRIBUTE_PRINTF(4, 5);</span>
<span class="line-added">326 </span>
<span class="line-added">327   // Given an instance of HotSpotInstalledCode return the corresponding CodeBlob*.  The</span>
<span class="line-added">328   // nmethodLocker is required to keep the CodeBlob alive in the case where it&#39;s an nmethod.</span>
<span class="line-added">329   CodeBlob* get_code_blob(JVMCIObject code, nmethodLocker&amp; locker);</span>
<span class="line-added">330 </span>
<span class="line-added">331   // Given an instance of HotSpotInstalledCode return the corresponding nmethod.  The</span>
<span class="line-added">332   // nmethodLocker is required to keep the nmethod alive.</span>
<span class="line-added">333   nmethod* get_nmethod(JVMCIObject code, nmethodLocker&amp; locker);</span>
<span class="line-added">334 </span>
<span class="line-added">335   MethodData* asMethodData(jlong metaspaceMethodData) {</span>
<span class="line-added">336     return (MethodData*) (address) metaspaceMethodData;</span>
<span class="line-added">337   }</span>
<span class="line-added">338 </span>
<span class="line-added">339   const char* klass_name(JVMCIObject object);</span>
<span class="line-added">340 </span>
<span class="line-added">341   // Unpack an instance of HotSpotResolvedJavaMethodImpl into the original Method*</span>
<span class="line-added">342   Method* asMethod(JVMCIObject jvmci_method);</span>
<span class="line-added">343   Method* asMethod(jobject jvmci_method) { return asMethod(wrap(jvmci_method)); }</span>
<span class="line-added">344 </span>
<span class="line-added">345   // Unpack an instance of HotSpotResolvedObjectTypeImpl into the original Klass*</span>
<span class="line-added">346   Klass* asKlass(JVMCIObject jvmci_type);</span>
<span class="line-added">347   Klass* asKlass(jobject jvmci_type)  { return asKlass(wrap(jvmci_type)); }</span>
<span class="line-added">348 </span>
<span class="line-added">349   JVMCIObject get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS);</span>
<span class="line-added">350 </span>
<span class="line-added">351   JVMCIObject get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS);</span>
<span class="line-added">352 </span>
<span class="line-added">353   // Unpack an instance of HotSpotConstantPool into the original ConstantPool*</span>
<span class="line-added">354   ConstantPool* asConstantPool(JVMCIObject constant_pool);</span>
<span class="line-added">355   ConstantPool* asConstantPool(jobject constant_pool)  { return asConstantPool(wrap(constant_pool)); }</span>
<span class="line-added">356 </span>
<span class="line-added">357   JVMCIObject get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS);</span>
<span class="line-added">358   JVMCIObject get_jvmci_primitive_type(BasicType type);</span>
<span class="line-added">359 </span>
<span class="line-added">360   Handle asConstant(JVMCIObject object, JVMCI_TRAPS);</span>
<span class="line-added">361   JVMCIObject get_object_constant(oop objOop, bool compressed = false, bool dont_register = false);</span>
<span class="line-added">362 </span>
<span class="line-added">363   JVMCIPrimitiveArray new_booleanArray(int length, JVMCI_TRAPS);</span>
<span class="line-added">364   JVMCIPrimitiveArray new_byteArray(int length, JVMCI_TRAPS);</span>
<span class="line-added">365   JVMCIPrimitiveArray new_intArray(int length, JVMCI_TRAPS);</span>
<span class="line-added">366   JVMCIPrimitiveArray new_longArray(int length, JVMCI_TRAPS);</span>
<span class="line-added">367 </span>
<span class="line-added">368   JVMCIObjectArray new_byte_array_array(int length, JVMCI_TRAPS);</span>
<span class="line-added">369 </span>
<span class="line-added">370   JVMCIObject new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS);</span>
<span class="line-added">371   JVMCIObject new_HotSpotNmethod(const methodHandle&amp; method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS);</span>
<span class="line-added">372   JVMCIObject new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS);</span>
<span class="line-added">373   JVMCIObject new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS);</span>
<span class="line-added">374   JVMCIObject new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS);</span>
<span class="line-added">375   JVMCIObject new_HotSpotStackFrameReference(JVMCI_TRAPS);</span>
<span class="line-added">376   JVMCIObject new_JVMCIError(JVMCI_TRAPS);</span>
<span class="line-added">377 </span>
<span class="line-added">378   jlong make_handle(const Handle&amp; obj);</span>
<span class="line-added">379   oop resolve_handle(jlong objectHandle);</span>
<span class="line-added">380 </span>
<span class="line-added">381   // These are analagous to the JNI routines</span>
<span class="line-added">382   JVMCIObject make_local(JVMCIObject object);</span>
<span class="line-added">383   JVMCIObject make_global(JVMCIObject object);</span>
<span class="line-added">384   JVMCIObject make_weak(JVMCIObject object);</span>
<span class="line-added">385   void destroy_local(JVMCIObject object);</span>
<span class="line-added">386   void destroy_global(JVMCIObject object);</span>
<span class="line-added">387   void destroy_weak(JVMCIObject object);</span>
<span class="line-added">388 </span>
<span class="line-added">389   // Deoptimizes the nmethod (if any) in the HotSpotNmethod.address</span>
<span class="line-added">390   // field of mirror. The field is subsequently zeroed.</span>
<span class="line-added">391   void invalidate_nmethod_mirror(JVMCIObject mirror, JVMCI_TRAPS);</span>
<span class="line-added">392 </span>
<span class="line-added">393   void initialize_installed_code(JVMCIObject installed_code, CodeBlob* cb, JVMCI_TRAPS);</span>
<span class="line-added">394 </span>
<span class="line-added">395  private:</span>
<span class="line-added">396   JVMCICompileState* _compile_state;</span>
<span class="line-added">397 </span>
<span class="line-added">398  public:</span>
<span class="line-added">399   static JavaVM* get_shared_library_javavm() { return _shared_library_javavm; }</span>
<span class="line-added">400   static void* get_shared_library_handle()   { return _shared_library_handle; }</span>
<span class="line-added">401   static char* get_shared_library_path()     { return _shared_library_path; }</span>
<span class="line-added">402 </span>
<span class="line-added">403   // Determines if this is for the JVMCI runtime in the HotSpot</span>
<span class="line-added">404   // heap (true) or the shared library heap (false).</span>
<span class="line-added">405   bool is_hotspot() { return _is_hotspot; }</span>
<span class="line-added">406 </span>
<span class="line-added">407   JVMCICompileState* compile_state() { return _compile_state; }</span>
<span class="line-added">408   void set_compile_state(JVMCICompileState* compile_state) {</span>
<span class="line-added">409     assert(_compile_state == NULL, &quot;set only once&quot;);</span>
<span class="line-added">410     _compile_state = compile_state;</span>
<span class="line-added">411   }</span>
<span class="line-added">412   // Generate declarations for the initialize, new, isa, get and set methods for all the types and</span>
<span class="line-added">413   // fields declared in the JVMCI_CLASSES_DO macro.</span>
<span class="line-added">414 </span>
<span class="line-added">415 #define START_CLASS(className, fullClassName)                           \</span>
<span class="line-added">416   void className##_initialize(JVMCI_TRAPS); \</span>
<span class="line-added">417   JVMCIObjectArray new_##className##_array(int length, JVMCI_TRAPS); \</span>
<span class="line-added">418   bool isa_##className(JVMCIObject object);</span>
<span class="line-added">419 </span>
<span class="line-added">420 #define END_CLASS</span>
<span class="line-added">421 </span>
<span class="line-added">422 #define FIELD(className, name, type, accessor)                                                                                                                         \</span>
<span class="line-added">423   type get_ ## className ## _ ## name(JVMCIObject obj); \</span>
<span class="line-added">424   void set_ ## className ## _ ## name(JVMCIObject obj, type x);</span>
<span class="line-added">425 </span>
<span class="line-added">426 #define OOPISH_FIELD(className, name, type, hstype, accessor) \</span>
<span class="line-added">427   FIELD(className, name, type, accessor)</span>
<span class="line-added">428 </span>
<span class="line-added">429 #define STATIC_FIELD(className, name, type) \</span>
<span class="line-added">430   type get_ ## className ## _ ## name(); \</span>
<span class="line-added">431   void set_ ## className ## _ ## name(type x);</span>
<span class="line-added">432 </span>
<span class="line-added">433 #define STATIC_OOPISH_FIELD(className, name, type, hstype) \</span>
<span class="line-added">434   STATIC_FIELD(className, name, type)</span>
<span class="line-added">435 </span>
<span class="line-added">436 #define EMPTY_CAST</span>
<span class="line-added">437 #define CHAR_FIELD(className,  name) FIELD(className, name, jchar, char_field)</span>
<span class="line-added">438 #define INT_FIELD(className,  name) FIELD(className, name, jint, int_field)</span>
<span class="line-added">439 #define BOOLEAN_FIELD(className,  name) FIELD(className, name, jboolean, bool_field)</span>
<span class="line-added">440 #define LONG_FIELD(className,  name) FIELD(className, name, jlong, long_field)</span>
<span class="line-added">441 #define FLOAT_FIELD(className,  name) FIELD(className, name, jfloat, float_field)</span>
<span class="line-added">442 #define OBJECT_FIELD(className,  name, signature) OOPISH_FIELD(className, name, JVMCIObject, oop, obj_field)</span>
<span class="line-added">443 #define OBJECTARRAY_FIELD(className,  name, signature) OOPISH_FIELD(className, name, JVMCIObjectArray, objArrayOop, obj_field)</span>
<span class="line-added">444 #define PRIMARRAY_FIELD(className,  name, signature) OOPISH_FIELD(className, name, JVMCIPrimitiveArray, typeArrayOop, obj_field)</span>
<span class="line-added">445 </span>
<span class="line-added">446 #define STATIC_INT_FIELD(className, name) STATIC_FIELD(className, name, jint)</span>
<span class="line-added">447 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_FIELD(className, name, jboolean)</span>
<span class="line-added">448 #define STATIC_OBJECT_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, JVMCIObject, oop)</span>
<span class="line-added">449 #define STATIC_OBJECTARRAY_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, objArrayOop)</span>
<span class="line-added">450 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)</span>
<span class="line-added">451 #define CONSTRUCTOR(className, signature)</span>
<span class="line-added">452 </span>
<span class="line-added">453   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
<span class="line-added">454 </span>
<span class="line-added">455 #undef JNI_START_CLASS</span>
<span class="line-added">456 #undef START_CLASS</span>
<span class="line-added">457 #undef END_CLASS</span>
<span class="line-added">458 #undef METHOD</span>
<span class="line-added">459 #undef CONSTRUCTOR</span>
<span class="line-added">460 #undef FIELD</span>
<span class="line-added">461 #undef CHAR_FIELD</span>
<span class="line-added">462 #undef INT_FIELD</span>
<span class="line-added">463 #undef BOOLEAN_FIELD</span>
<span class="line-added">464 #undef LONG_FIELD</span>
<span class="line-added">465 #undef FLOAT_FIELD</span>
<span class="line-added">466 #undef OBJECT_FIELD</span>
<span class="line-added">467 #undef PRIMARRAY_FIELD</span>
<span class="line-added">468 #undef OBJECTARRAY_FIELD</span>
<span class="line-added">469 #undef FIELD</span>
<span class="line-added">470 #undef OOPISH_FIELD</span>
<span class="line-added">471 #undef STATIC_FIELD</span>
<span class="line-added">472 #undef STATIC_OOPISH_FIELD</span>
<span class="line-added">473 #undef STATIC_FIELD</span>
<span class="line-added">474 #undef STATIC_OBJECT_FIELD</span>
<span class="line-added">475 #undef STATIC_OBJECTARRAY_FIELD</span>
<span class="line-added">476 #undef STATIC_INT_FIELD</span>
<span class="line-added">477 #undef STATIC_BOOLEAN_FIELD</span>
<span class="line-added">478 #undef EMPTY_CAST</span>
479 
<span class="line-modified">480   // End of JVMCIEnv</span>


























481 };
482 
483 #endif // SHARE_JVMCI_JVMCIENV_HPP
</pre>
</td>
</tr>
</table>
<center><a href="jvmciEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciJavaClasses.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jvmci/jvmciCodeInstaller.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compilerRuntime.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCodeInstaller.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCodeInstaller.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -20,63 +20,45 @@</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-removed">- #include &quot;asm/register.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;classfile/vmSymbols.hpp&quot;</span>
  #include &quot;code/compiledIC.hpp&quot;
<span class="udiff-line-removed">- #include &quot;code/vmreg.inline.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
<span class="udiff-line-removed">- #include &quot;compiler/disassembler.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
  #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
<span class="udiff-line-removed">- #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
  #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;memory/allocation.inline.hpp&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;oops/arrayOop.inline.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;oops/oop.inline.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;oops/typeArrayOop.inline.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;runtime/handles.inline.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/compressedOops.inline.hpp&quot;</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/javaCalls.hpp&quot;</span>
  #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/safepointMechanism.inline.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  
  // frequently used constants
  // Allocate them with new so they are never destroyed (otherwise, a
  // forced exit could destroy these objects while they are still in
  // use).
<span class="udiff-line-modified-removed">- ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantOopWriteValue(NULL);</span>
<span class="udiff-line-modified-removed">- ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(-1);</span>
<span class="udiff-line-modified-removed">- ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue((jint)0);</span>
<span class="udiff-line-modified-removed">- ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(1);</span>
<span class="udiff-line-modified-removed">- ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(2);</span>
<span class="udiff-line-modified-removed">- LocationValue*         CodeInstaller::_illegal_value = new (ResourceObj::C_HEAP, mtCompiler) LocationValue(Location());</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- Method* getMethodFromHotSpotMethod(oop hotspot_method) {</span>
<span class="udiff-line-removed">-   assert(hotspot_method != NULL &amp;&amp; hotspot_method-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()), &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-   return CompilerToVM::asMethod(hotspot_method);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- VMReg getVMRegFromLocation(Handle location, int total_frame_size, TRAPS) {</span>
<span class="udiff-line-modified-added">+ ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantOopWriteValue(NULL);</span>
<span class="udiff-line-modified-added">+ ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(-1);</span>
<span class="udiff-line-modified-added">+ ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue((jint)0);</span>
<span class="udiff-line-modified-added">+ ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(1);</span>
<span class="udiff-line-modified-added">+ ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(2);</span>
<span class="udiff-line-modified-added">+ LocationValue*         CodeInstaller::_illegal_value = new (ResourceObj::C_HEAP, mtJVMCI) LocationValue(Location());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ VMReg CodeInstaller::getVMRegFromLocation(JVMCIObject location, int total_frame_size, JVMCI_TRAPS) {</span>
    if (location.is_null()) {
<span class="udiff-line-modified-removed">-     THROW_NULL(vmSymbols::java_lang_NullPointerException());</span>
<span class="udiff-line-modified-added">+     JVMCI_THROW_NULL(NullPointerException);</span>
    }
  
<span class="udiff-line-modified-removed">-   Handle reg(THREAD, code_Location::reg(location));</span>
<span class="udiff-line-modified-removed">-   jint offset = code_Location::offset(location);</span>
<span class="udiff-line-modified-added">+   JVMCIObject reg = jvmci_env()-&gt;get_code_Location_reg(location);</span>
<span class="udiff-line-modified-added">+   jint offset = jvmci_env()-&gt;get_code_Location_offset(location);</span>
  
<span class="udiff-line-modified-removed">-   if (reg.not_null()) {</span>
<span class="udiff-line-modified-added">+   if (reg.is_non_null()) {</span>
      // register
<span class="udiff-line-modified-removed">-     jint number = code_Register::number(reg);</span>
<span class="udiff-line-modified-removed">-     VMReg vmReg = CodeInstaller::get_hotspot_reg(number, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+     jint number = jvmci_env()-&gt;get_code_Register_number(reg);</span>
<span class="udiff-line-modified-added">+     VMReg vmReg = CodeInstaller::get_hotspot_reg(number, JVMCI_CHECK_NULL);</span>
      if (offset % 4 == 0) {
        return vmReg-&gt;next(offset / 4);
      } else {
        JVMCI_ERROR_NULL(&quot;unaligned subregister offset %d in oop map&quot;, offset);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -100,75 +82,49 @@</span>
        JVMCI_ERROR_NULL(&quot;unaligned stack offset %d in oop map&quot;, offset);
      }
    }
  }
  
<span class="udiff-line-removed">- objArrayOop CodeInstaller::sites() {</span>
<span class="udiff-line-removed">-   return (objArrayOop) JNIHandles::resolve(_sites_handle);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- arrayOop CodeInstaller::code() {</span>
<span class="udiff-line-removed">-   return (arrayOop) JNIHandles::resolve(_code_handle);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- arrayOop CodeInstaller::data_section() {</span>
<span class="udiff-line-removed">-   return (arrayOop) JNIHandles::resolve(_data_section_handle);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- objArrayOop CodeInstaller::data_section_patches() {</span>
<span class="udiff-line-removed">-   return (objArrayOop) JNIHandles::resolve(_data_section_patches_handle);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-removed">- objArrayOop CodeInstaller::comments() {</span>
<span class="udiff-line-removed">-   return (objArrayOop) JNIHandles::resolve(_comments_handle);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- oop CodeInstaller::word_kind() {</span>
<span class="udiff-line-removed">-   return JNIHandles::resolve(_word_kind_handle);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // creates a HotSpot oop map out of the byte arrays provided by DebugInfo
<span class="udiff-line-modified-removed">- OopMap* CodeInstaller::create_oop_map(Handle debug_info, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   Handle reference_map(THREAD, DebugInfo::referenceMap(debug_info));</span>
<span class="udiff-line-modified-added">+ OopMap* CodeInstaller::create_oop_map(JVMCIObject debug_info, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject reference_map = jvmci_env()-&gt;get_DebugInfo_referenceMap(debug_info);</span>
    if (reference_map.is_null()) {
<span class="udiff-line-modified-removed">-     THROW_NULL(vmSymbols::java_lang_NullPointerException());</span>
<span class="udiff-line-modified-added">+     JVMCI_THROW_NULL(NullPointerException);</span>
    }
<span class="udiff-line-modified-removed">-   if (!reference_map-&gt;is_a(HotSpotReferenceMap::klass())) {</span>
<span class="udiff-line-modified-removed">-     JVMCI_ERROR_NULL(&quot;unknown reference map: %s&quot;, reference_map-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+   if (!jvmci_env()-&gt;isa_HotSpotReferenceMap(reference_map)) {</span>
<span class="udiff-line-modified-added">+     JVMCI_ERROR_NULL(&quot;unknown reference map: %s&quot;, jvmci_env()-&gt;klass_name(reference_map));</span>
    }
<span class="udiff-line-modified-removed">-   if (!_has_wide_vector &amp;&amp; SharedRuntime::is_wide_vector(HotSpotReferenceMap::maxRegisterSize(reference_map))) {</span>
<span class="udiff-line-modified-added">+   if (!_has_wide_vector &amp;&amp; SharedRuntime::is_wide_vector(jvmci_env()-&gt;get_HotSpotReferenceMap_maxRegisterSize(reference_map))) {</span>
      if (SharedRuntime::polling_page_vectors_safepoint_handler_blob() == NULL) {
        JVMCI_ERROR_NULL(&quot;JVMCI is producing code using vectors larger than the runtime supports&quot;);
      }
      _has_wide_vector = true;
    }
    OopMap* map = new OopMap(_total_frame_size, _parameter_count);
<span class="udiff-line-modified-removed">-   objArrayHandle objects(THREAD, HotSpotReferenceMap::objects(reference_map));</span>
<span class="udiff-line-modified-removed">-   objArrayHandle derivedBase(THREAD, HotSpotReferenceMap::derivedBase(reference_map));</span>
<span class="udiff-line-modified-removed">-   typeArrayHandle sizeInBytes(THREAD, HotSpotReferenceMap::sizeInBytes(reference_map));</span>
<span class="udiff-line-modified-added">+   JVMCIObjectArray objects = jvmci_env()-&gt;get_HotSpotReferenceMap_objects(reference_map);</span>
<span class="udiff-line-modified-added">+   JVMCIObjectArray derivedBase = jvmci_env()-&gt;get_HotSpotReferenceMap_derivedBase(reference_map);</span>
<span class="udiff-line-modified-added">+   JVMCIPrimitiveArray sizeInBytes = jvmci_env()-&gt;get_HotSpotReferenceMap_sizeInBytes(reference_map);</span>
    if (objects.is_null() || derivedBase.is_null() || sizeInBytes.is_null()) {
<span class="udiff-line-modified-removed">-     THROW_NULL(vmSymbols::java_lang_NullPointerException());</span>
<span class="udiff-line-modified-added">+     JVMCI_THROW_NULL(NullPointerException);</span>
    }
<span class="udiff-line-modified-removed">-   if (objects-&gt;length() != derivedBase-&gt;length() || objects-&gt;length() != sizeInBytes-&gt;length()) {</span>
<span class="udiff-line-modified-removed">-     JVMCI_ERROR_NULL(&quot;arrays in reference map have different sizes: %d %d %d&quot;, objects-&gt;length(), derivedBase-&gt;length(), sizeInBytes-&gt;length());</span>
<span class="udiff-line-modified-added">+   if (JVMCIENV-&gt;get_length(objects) != JVMCIENV-&gt;get_length(derivedBase) || JVMCIENV-&gt;get_length(objects) != JVMCIENV-&gt;get_length(sizeInBytes)) {</span>
<span class="udiff-line-modified-added">+     JVMCI_ERROR_NULL(&quot;arrays in reference map have different sizes: %d %d %d&quot;, JVMCIENV-&gt;get_length(objects), JVMCIENV-&gt;get_length(derivedBase), JVMCIENV-&gt;get_length(sizeInBytes));</span>
    }
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; objects-&gt;length(); i++) {</span>
<span class="udiff-line-modified-removed">-     Handle location(THREAD, objects-&gt;obj_at(i));</span>
<span class="udiff-line-modified-removed">-     Handle baseLocation(THREAD, derivedBase-&gt;obj_at(i));</span>
<span class="udiff-line-modified-removed">-     int bytes = sizeInBytes-&gt;int_at(i);</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(objects); i++) {</span>
<span class="udiff-line-modified-added">+     JVMCIObject location = JVMCIENV-&gt;get_object_at(objects, i);</span>
<span class="udiff-line-modified-added">+     JVMCIObject baseLocation = JVMCIENV-&gt;get_object_at(derivedBase, i);</span>
<span class="udiff-line-modified-added">+     jint bytes = JVMCIENV-&gt;get_int_at(sizeInBytes, i);</span>
  
<span class="udiff-line-modified-removed">-     VMReg vmReg = getVMRegFromLocation(location, _total_frame_size, CHECK_NULL);</span>
<span class="udiff-line-modified-removed">-     if (baseLocation.not_null()) {</span>
<span class="udiff-line-modified-added">+     VMReg vmReg = getVMRegFromLocation(location, _total_frame_size, JVMCI_CHECK_NULL);</span>
<span class="udiff-line-modified-added">+     if (baseLocation.is_non_null()) {</span>
        // derived oop
  #ifdef _LP64
        if (bytes == 8) {
  #else
        if (bytes == 4) {
  #endif
<span class="udiff-line-modified-removed">-         VMReg baseReg = getVMRegFromLocation(baseLocation, _total_frame_size, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+         VMReg baseReg = getVMRegFromLocation(baseLocation, _total_frame_size, JVMCI_CHECK_NULL);</span>
          map-&gt;set_derived_oop(vmReg, baseReg);
        } else {
          JVMCI_ERROR_NULL(&quot;invalid derived oop size in ReferenceMap: %d&quot;, bytes);
        }
  #ifdef _LP64
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -185,20 +141,20 @@</span>
      } else {
        JVMCI_ERROR_NULL(&quot;invalid oop size in ReferenceMap: %d&quot;, bytes);
      }
    }
  
<span class="udiff-line-modified-removed">-   Handle callee_save_info(THREAD, (oop) DebugInfo::calleeSaveInfo(debug_info));</span>
<span class="udiff-line-modified-removed">-   if (callee_save_info.not_null()) {</span>
<span class="udiff-line-modified-removed">-     objArrayHandle registers(THREAD, RegisterSaveLayout::registers(callee_save_info));</span>
<span class="udiff-line-modified-removed">-     typeArrayHandle slots(THREAD, RegisterSaveLayout::slots(callee_save_info));</span>
<span class="udiff-line-modified-removed">-     for (jint i = 0; i &lt; slots-&gt;length(); i++) {</span>
<span class="udiff-line-modified-removed">-       Handle jvmci_reg (THREAD, registers-&gt;obj_at(i));</span>
<span class="udiff-line-modified-removed">-       jint jvmci_reg_number = code_Register::number(jvmci_reg);</span>
<span class="udiff-line-modified-removed">-       VMReg hotspot_reg = CodeInstaller::get_hotspot_reg(jvmci_reg_number, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   JVMCIObject callee_save_info = jvmci_env()-&gt;get_DebugInfo_calleeSaveInfo(debug_info);</span>
<span class="udiff-line-modified-added">+   if (callee_save_info.is_non_null()) {</span>
<span class="udiff-line-modified-added">+     JVMCIObjectArray registers = jvmci_env()-&gt;get_RegisterSaveLayout_registers(callee_save_info);</span>
<span class="udiff-line-modified-added">+     JVMCIPrimitiveArray slots = jvmci_env()-&gt;get_RegisterSaveLayout_slots(callee_save_info);</span>
<span class="udiff-line-modified-added">+     for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(slots); i++) {</span>
<span class="udiff-line-modified-added">+       JVMCIObject jvmci_reg = JVMCIENV-&gt;get_object_at(registers, i);</span>
<span class="udiff-line-modified-added">+       jint jvmci_reg_number = jvmci_env()-&gt;get_code_Register_number(jvmci_reg);</span>
<span class="udiff-line-modified-added">+       VMReg hotspot_reg = CodeInstaller::get_hotspot_reg(jvmci_reg_number, JVMCI_CHECK_NULL);</span>
        // HotSpot stack slots are 4 bytes
<span class="udiff-line-modified-removed">-       jint jvmci_slot = slots-&gt;int_at(i);</span>
<span class="udiff-line-modified-added">+       jint jvmci_slot = JVMCIENV-&gt;get_int_at(slots, i);</span>
        jint hotspot_slot = jvmci_slot * VMRegImpl::slots_per_word;
        VMReg hotspot_slot_as_reg = VMRegImpl::stack2reg(hotspot_slot);
        map-&gt;set_callee_saved(hotspot_slot_as_reg, hotspot_reg);
  #ifdef _LP64
        // (copied from generate_oop_map() in c1_Runtime1_x86.cpp)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -209,11 +165,12 @@</span>
    }
    return map;
  }
  
  #if INCLUDE_AOT
<span class="udiff-line-modified-removed">- AOTOopRecorder::AOTOopRecorder(Arena* arena, bool deduplicate) : OopRecorder(arena, deduplicate) {</span>
<span class="udiff-line-modified-added">+ AOTOopRecorder::AOTOopRecorder(CodeInstaller* code_inst, Arena* arena, bool deduplicate) : OopRecorder(arena, deduplicate) {</span>
<span class="udiff-line-added">+   _code_inst = code_inst;</span>
    _meta_refs = new GrowableArray&lt;jobject&gt;();
  }
  
  int AOTOopRecorder::nr_meta_refs() const {
    return _meta_refs-&gt;length();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -223,10 +180,11 @@</span>
    return _meta_refs-&gt;at(pos);
  }
  
  int AOTOopRecorder::find_index(Metadata* h) {
    JavaThread* THREAD = JavaThread::current();
<span class="udiff-line-added">+   JVMCIEnv* JVMCIENV = _code_inst-&gt;jvmci_env();</span>
    int oldCount = metadata_count();
    int index =  this-&gt;OopRecorder::find_index(h);
    int newCount = metadata_count();
  
    if (oldCount == newCount) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -235,22 +193,22 @@</span>
    }
  
    vmassert(index + 1 == newCount, &quot;must be last&quot;);
  
    JVMCIKlassHandle klass(THREAD);
<span class="udiff-line-modified-removed">-   oop result = NULL;</span>
<span class="udiff-line-modified-added">+   JVMCIObject result;</span>
    guarantee(h != NULL,
              &quot;If DebugInformationRecorder::describe_scope passes NULL oldCount == newCount must hold.&quot;);
    if (h-&gt;is_klass()) {
      klass = (Klass*) h;
<span class="udiff-line-modified-removed">-     result = CompilerToVM::get_jvmci_type(klass, CATCH);</span>
<span class="udiff-line-modified-added">+     result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CATCH);</span>
    } else if (h-&gt;is_method()) {
      Method* method = (Method*) h;
<span class="udiff-line-modified-removed">-     methodHandle mh(method);</span>
<span class="udiff-line-modified-removed">-     result = CompilerToVM::get_jvmci_method(method, CATCH);</span>
<span class="udiff-line-modified-added">+     methodHandle mh(THREAD, method);</span>
<span class="udiff-line-modified-added">+     result = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CATCH);</span>
    }
<span class="udiff-line-modified-removed">-   jobject ref = JNIHandles::make_local(THREAD, result);</span>
<span class="udiff-line-modified-added">+   jobject ref = JVMCIENV-&gt;get_jobject(result);</span>
    record_meta_ref(ref, index);
  
    return index;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -270,82 +228,82 @@</span>
    assert(index == _meta_refs-&gt;length(), &quot;must be last&quot;);
    _meta_refs-&gt;append(o);
  }
  #endif // INCLUDE_AOT
  
<span class="udiff-line-modified-removed">- void* CodeInstaller::record_metadata_reference(CodeSection* section, address dest, Handle constant, TRAPS) {</span>
<span class="udiff-line-modified-added">+ void* CodeInstaller::record_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS) {</span>
    /*
     * This method needs to return a raw (untyped) pointer, since the value of a pointer to the base
     * class is in general not equal to the pointer of the subclass. When patching metaspace pointers,
     * the compiler expects a direct pointer to the subclass (Klass* or Method*), not a pointer to the
     * base class (Metadata* or MetaspaceObj*).
     */
<span class="udiff-line-modified-removed">-   oop obj = HotSpotMetaspaceConstantImpl::metaspaceObject(constant);</span>
<span class="udiff-line-modified-removed">-   if (obj-&gt;is_a(HotSpotResolvedObjectTypeImpl::klass())) {</span>
<span class="udiff-line-modified-removed">-     Klass* klass = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(obj));</span>
<span class="udiff-line-modified-removed">-     assert(!HotSpotMetaspaceConstantImpl::compressed(constant), &quot;unexpected compressed klass pointer %s @ &quot; INTPTR_FORMAT, klass-&gt;name()-&gt;as_C_string(), p2i(klass));</span>
<span class="udiff-line-modified-added">+   JVMCIObject obj = jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_metaspaceObject(constant);</span>
<span class="udiff-line-modified-added">+   if (jvmci_env()-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {</span>
<span class="udiff-line-modified-added">+     Klass* klass = JVMCIENV-&gt;asKlass(obj);</span>
<span class="udiff-line-modified-added">+     assert(!jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant), &quot;unexpected compressed klass pointer %s @ &quot; INTPTR_FORMAT, klass-&gt;name()-&gt;as_C_string(), p2i(klass));</span>
      int index = _oop_recorder-&gt;find_index(klass);
      section-&gt;relocate(dest, metadata_Relocation::spec(index));
      TRACE_jvmci_3(&quot;metadata[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), klass-&gt;name()-&gt;as_C_string());
      return klass;
<span class="udiff-line-modified-removed">-   } else if (obj-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass())) {</span>
<span class="udiff-line-modified-removed">-     Method* method = (Method*) (address) HotSpotResolvedJavaMethodImpl::metaspaceMethod(obj);</span>
<span class="udiff-line-modified-removed">-     assert(!HotSpotMetaspaceConstantImpl::compressed(constant), &quot;unexpected compressed method pointer %s @ &quot; INTPTR_FORMAT, method-&gt;name()-&gt;as_C_string(), p2i(method));</span>
<span class="udiff-line-modified-added">+   } else if (jvmci_env()-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {</span>
<span class="udiff-line-modified-added">+     Method* method = jvmci_env()-&gt;asMethod(obj);</span>
<span class="udiff-line-modified-added">+     assert(!jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant), &quot;unexpected compressed method pointer %s @ &quot; INTPTR_FORMAT, method-&gt;name()-&gt;as_C_string(), p2i(method));</span>
      int index = _oop_recorder-&gt;find_index(method);
      section-&gt;relocate(dest, metadata_Relocation::spec(index));
      TRACE_jvmci_3(&quot;metadata[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), method-&gt;name()-&gt;as_C_string());
      return method;
    } else {
<span class="udiff-line-modified-removed">-     JVMCI_ERROR_NULL(&quot;unexpected metadata reference for constant of type %s&quot;, obj-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+     JVMCI_ERROR_NULL(&quot;unexpected metadata reference for constant of type %s&quot;, jvmci_env()-&gt;klass_name(obj));</span>
    }
  }
  
  #ifdef _LP64
<span class="udiff-line-modified-removed">- narrowKlass CodeInstaller::record_narrow_metadata_reference(CodeSection* section, address dest, Handle constant, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   oop obj = HotSpotMetaspaceConstantImpl::metaspaceObject(constant);</span>
<span class="udiff-line-modified-removed">-   assert(HotSpotMetaspaceConstantImpl::compressed(constant), &quot;unexpected uncompressed pointer&quot;);</span>
<span class="udiff-line-modified-added">+ narrowKlass CodeInstaller::record_narrow_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject obj = jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_metaspaceObject(constant);</span>
<span class="udiff-line-modified-added">+   assert(jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant), &quot;unexpected uncompressed pointer&quot;);</span>
  
<span class="udiff-line-modified-removed">-   if (!obj-&gt;is_a(HotSpotResolvedObjectTypeImpl::klass())) {</span>
<span class="udiff-line-modified-removed">-     JVMCI_ERROR_0(&quot;unexpected compressed pointer of type %s&quot;, obj-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+   if (!jvmci_env()-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {</span>
<span class="udiff-line-modified-added">+     JVMCI_ERROR_0(&quot;unexpected compressed pointer of type %s&quot;, jvmci_env()-&gt;klass_name(obj));</span>
    }
  
<span class="udiff-line-modified-removed">-   Klass* klass = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(obj));</span>
<span class="udiff-line-modified-added">+   Klass* klass = JVMCIENV-&gt;asKlass(obj);</span>
    int index = _oop_recorder-&gt;find_index(klass);
    section-&gt;relocate(dest, metadata_Relocation::spec(index));
    TRACE_jvmci_3(&quot;narrowKlass[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), klass-&gt;name()-&gt;as_C_string());
<span class="udiff-line-modified-removed">-   return Klass::encode_klass(klass);</span>
<span class="udiff-line-modified-added">+   return CompressedKlassPointers::encode(klass);</span>
  }
  #endif
  
<span class="udiff-line-modified-removed">- Location::Type CodeInstaller::get_oop_type(Thread* thread, Handle value) {</span>
<span class="udiff-line-modified-removed">-   Handle valueKind(thread, Value::valueKind(value));</span>
<span class="udiff-line-modified-removed">-   Handle platformKind(thread, ValueKind::platformKind(valueKind));</span>
<span class="udiff-line-modified-added">+ Location::Type CodeInstaller::get_oop_type(JVMCIObject value) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject valueKind = jvmci_env()-&gt;get_Value_valueKind(value);</span>
<span class="udiff-line-modified-added">+   JVMCIObject platformKind = jvmci_env()-&gt;get_ValueKind_platformKind(valueKind);</span>
  
<span class="udiff-line-modified-removed">-   if (platformKind == word_kind()) {</span>
<span class="udiff-line-modified-added">+   if (jvmci_env()-&gt;equals(platformKind, word_kind())) {</span>
      return Location::oop;
    } else {
      return Location::narrowoop;
    }
  }
  
<span class="udiff-line-modified-removed">- ScopeValue* CodeInstaller::get_scope_value(Handle value, BasicType type, GrowableArray&lt;ScopeValue*&gt;* objects, ScopeValue* &amp;second, TRAPS) {</span>
<span class="udiff-line-modified-added">+ ScopeValue* CodeInstaller::get_scope_value(JVMCIObject value, BasicType type, GrowableArray&lt;ScopeValue*&gt;* objects, ScopeValue* &amp;second, JVMCI_TRAPS) {</span>
    second = NULL;
    if (value.is_null()) {
<span class="udiff-line-modified-removed">-     THROW_NULL(vmSymbols::java_lang_NullPointerException());</span>
<span class="udiff-line-modified-removed">-   } else if (value == Value::ILLEGAL()) {</span>
<span class="udiff-line-modified-added">+     JVMCI_THROW_NULL(NullPointerException);</span>
<span class="udiff-line-modified-added">+   } else if (JVMCIENV-&gt;equals(value, jvmci_env()-&gt;get_Value_ILLEGAL())) {</span>
      if (type != T_ILLEGAL) {
        JVMCI_ERROR_NULL(&quot;unexpected illegal value, expected %s&quot;, basictype_to_str(type));
      }
      return _illegal_value;
<span class="udiff-line-modified-removed">-   } else if (value-&gt;is_a(RegisterValue::klass())) {</span>
<span class="udiff-line-modified-removed">-     Handle reg(THREAD, RegisterValue::reg(value));</span>
<span class="udiff-line-modified-removed">-     jint number = code_Register::number(reg);</span>
<span class="udiff-line-modified-removed">-     VMReg hotspotRegister = get_hotspot_reg(number, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   } else if (jvmci_env()-&gt;isa_RegisterValue(value)) {</span>
<span class="udiff-line-modified-added">+     JVMCIObject reg = jvmci_env()-&gt;get_RegisterValue_reg(value);</span>
<span class="udiff-line-modified-added">+     jint number = jvmci_env()-&gt;get_code_Register_number(reg);</span>
<span class="udiff-line-modified-added">+     VMReg hotspotRegister = get_hotspot_reg(number, JVMCI_CHECK_NULL);</span>
      if (is_general_purpose_reg(hotspotRegister)) {
        Location::Type locationType;
        if (type == T_OBJECT) {
<span class="udiff-line-modified-removed">-         locationType = get_oop_type(THREAD, value);</span>
<span class="udiff-line-modified-added">+         locationType = get_oop_type(value);</span>
        } else if (type == T_LONG) {
          locationType = Location::lng;
        } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {
          locationType = Location::int_in_long;
        } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -370,19 +328,19 @@</span>
        if (type == T_DOUBLE) {
          second = value;
        }
        return value;
      }
<span class="udiff-line-modified-removed">-   } else if (value-&gt;is_a(StackSlot::klass())) {</span>
<span class="udiff-line-modified-removed">-     jint offset = StackSlot::offset(value);</span>
<span class="udiff-line-modified-removed">-     if (StackSlot::addFrameSize(value)) {</span>
<span class="udiff-line-modified-added">+   } else if (jvmci_env()-&gt;isa_StackSlot(value)) {</span>
<span class="udiff-line-modified-added">+     jint offset = jvmci_env()-&gt;get_StackSlot_offset(value);</span>
<span class="udiff-line-modified-added">+     if (jvmci_env()-&gt;get_StackSlot_addFrameSize(value)) {</span>
        offset += _total_frame_size;
      }
  
      Location::Type locationType;
      if (type == T_OBJECT) {
<span class="udiff-line-modified-removed">-       locationType = get_oop_type(THREAD, value);</span>
<span class="udiff-line-modified-added">+       locationType = get_oop_type(value);</span>
      } else if (type == T_LONG) {
        locationType = Location::lng;
      } else if (type == T_DOUBLE) {
        locationType = Location::dbl;
      } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -393,58 +351,57 @@</span>
      ScopeValue* value = new LocationValue(Location::new_stk_loc(locationType, offset));
      if (type == T_DOUBLE || type == T_LONG) {
        second = value;
      }
      return value;
<span class="udiff-line-modified-removed">-   } else if (value-&gt;is_a(JavaConstant::klass())) {</span>
<span class="udiff-line-modified-removed">-     if (value-&gt;is_a(PrimitiveConstant::klass())) {</span>
<span class="udiff-line-modified-removed">-       if (value-&gt;is_a(RawConstant::klass())) {</span>
<span class="udiff-line-modified-removed">-         jlong prim = PrimitiveConstant::primitive(value);</span>
<span class="udiff-line-modified-added">+   } else if (jvmci_env()-&gt;isa_JavaConstant(value)) {</span>
<span class="udiff-line-modified-added">+     if (jvmci_env()-&gt;isa_PrimitiveConstant(value)) {</span>
<span class="udiff-line-modified-added">+       if (jvmci_env()-&gt;isa_RawConstant(value)) {</span>
<span class="udiff-line-modified-added">+         jlong prim = jvmci_env()-&gt;get_PrimitiveConstant_primitive(value);</span>
          return new ConstantLongValue(prim);
        } else {
<span class="udiff-line-modified-removed">-         Handle primitive_constant_kind(THREAD, PrimitiveConstant::kind(value));</span>
<span class="udiff-line-removed">-         BasicType constantType = JVMCIRuntime::kindToBasicType(primitive_constant_kind, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+         BasicType constantType = jvmci_env()-&gt;kindToBasicType(jvmci_env()-&gt;get_PrimitiveConstant_kind(value), JVMCI_CHECK_NULL);</span>
          if (type != constantType) {
            JVMCI_ERROR_NULL(&quot;primitive constant type doesn&#39;t match, expected %s but got %s&quot;, basictype_to_str(type), basictype_to_str(constantType));
          }
          if (type == T_INT || type == T_FLOAT) {
<span class="udiff-line-modified-removed">-           jint prim = (jint)PrimitiveConstant::primitive(value);</span>
<span class="udiff-line-modified-added">+           jint prim = (jint)jvmci_env()-&gt;get_PrimitiveConstant_primitive(value);</span>
            switch (prim) {
              case -1: return _int_m1_scope_value;
              case  0: return _int_0_scope_value;
              case  1: return _int_1_scope_value;
              case  2: return _int_2_scope_value;
              default: return new ConstantIntValue(prim);
            }
          } else if (type == T_LONG || type == T_DOUBLE) {
<span class="udiff-line-modified-removed">-           jlong prim = PrimitiveConstant::primitive(value);</span>
<span class="udiff-line-modified-added">+           jlong prim = jvmci_env()-&gt;get_PrimitiveConstant_primitive(value);</span>
            second = _int_1_scope_value;
            return new ConstantLongValue(prim);
          } else {
            JVMCI_ERROR_NULL(&quot;unexpected primitive constant type %s&quot;, basictype_to_str(type));
          }
        }
<span class="udiff-line-modified-removed">-     } else if (value-&gt;is_a(NullConstant::klass()) || value-&gt;is_a(HotSpotCompressedNullConstant::klass())) {</span>
<span class="udiff-line-modified-added">+     } else if (jvmci_env()-&gt;isa_NullConstant(value) || jvmci_env()-&gt;isa_HotSpotCompressedNullConstant(value)) {</span>
        if (type == T_OBJECT) {
          return _oop_null_scope_value;
        } else {
          JVMCI_ERROR_NULL(&quot;unexpected null constant, expected %s&quot;, basictype_to_str(type));
        }
<span class="udiff-line-modified-removed">-     } else if (value-&gt;is_a(HotSpotObjectConstantImpl::klass())) {</span>
<span class="udiff-line-modified-added">+     } else if (jvmci_env()-&gt;isa_HotSpotObjectConstantImpl(value)) {</span>
        if (type == T_OBJECT) {
<span class="udiff-line-modified-removed">-         oop obj = HotSpotObjectConstantImpl::object(value);</span>
<span class="udiff-line-modified-added">+         Handle obj = jvmci_env()-&gt;asConstant(value, JVMCI_CHECK_NULL);</span>
          if (obj == NULL) {
            JVMCI_ERROR_NULL(&quot;null value must be in NullConstant&quot;);
          }
<span class="udiff-line-modified-removed">-         return new ConstantOopWriteValue(JNIHandles::make_local(obj));</span>
<span class="udiff-line-modified-added">+         return new ConstantOopWriteValue(JNIHandles::make_local(obj()));</span>
        } else {
          JVMCI_ERROR_NULL(&quot;unexpected object constant, expected %s&quot;, basictype_to_str(type));
        }
      }
<span class="udiff-line-modified-removed">-   } else if (value-&gt;is_a(VirtualObject::klass())) {</span>
<span class="udiff-line-modified-added">+   } else if (jvmci_env()-&gt;isa_VirtualObject(value)) {</span>
      if (type == T_OBJECT) {
<span class="udiff-line-modified-removed">-       int id = VirtualObject::id(value);</span>
<span class="udiff-line-modified-added">+       int id = jvmci_env()-&gt;get_VirtualObject_id(value);</span>
        if (0 &lt;= id &amp;&amp; id &lt; objects-&gt;length()) {
          ScopeValue* object = objects-&gt;at(id);
          if (object != NULL) {
            return object;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -453,30 +410,26 @@</span>
      } else {
        JVMCI_ERROR_NULL(&quot;unexpected virtual object, expected %s&quot;, basictype_to_str(type));
      }
    }
  
<span class="udiff-line-modified-removed">-   JVMCI_ERROR_NULL(&quot;unexpected value in scope: %s&quot;, value-&gt;klass()-&gt;signature_name())</span>
<span class="udiff-line-modified-added">+   JVMCI_ERROR_NULL(&quot;unexpected value in scope: %s&quot;, jvmci_env()-&gt;klass_name(value))</span>
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::record_object_value(ObjectValue* sv, Handle value, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   // Might want a HandleMark here.</span>
<span class="udiff-line-modified-removed">-   Handle type(THREAD, VirtualObject::type(value));</span>
<span class="udiff-line-modified-removed">-   int id = VirtualObject::id(value);</span>
<span class="udiff-line-removed">-   oop javaMirror = HotSpotResolvedObjectTypeImpl::javaClass(type);</span>
<span class="udiff-line-removed">-   Klass* klass = java_lang_Class::as_Klass(javaMirror);</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::record_object_value(ObjectValue* sv, JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject type = jvmci_env()-&gt;get_VirtualObject_type(value);</span>
<span class="udiff-line-modified-added">+   int id = jvmci_env()-&gt;get_VirtualObject_id(value);</span>
<span class="udiff-line-modified-added">+   Klass* klass = JVMCIENV-&gt;asKlass(type);</span>
    bool isLongArray = klass == Universe::longArrayKlassObj();
  
<span class="udiff-line-modified-removed">-   objArrayHandle values(THREAD, VirtualObject::values(value));</span>
<span class="udiff-line-modified-removed">-   objArrayHandle slotKinds(THREAD, VirtualObject::slotKinds(value));</span>
<span class="udiff-line-modified-removed">-   for (jint i = 0; i &lt; values-&gt;length(); i++) {</span>
<span class="udiff-line-removed">-     HandleMark hm(THREAD);</span>
<span class="udiff-line-modified-added">+   JVMCIObjectArray values = jvmci_env()-&gt;get_VirtualObject_values(value);</span>
<span class="udiff-line-modified-added">+   JVMCIObjectArray slotKinds = jvmci_env()-&gt;get_VirtualObject_slotKinds(value);</span>
<span class="udiff-line-modified-added">+   for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(values); i++) {</span>
      ScopeValue* cur_second = NULL;
<span class="udiff-line-modified-removed">-     Handle object(THREAD, values-&gt;obj_at(i));</span>
<span class="udiff-line-modified-removed">-     Handle slot_kind (THREAD, slotKinds-&gt;obj_at(i));</span>
<span class="udiff-line-modified-removed">-     BasicType type = JVMCIRuntime::kindToBasicType(slot_kind, CHECK);</span>
<span class="udiff-line-removed">-     ScopeValue* value = get_scope_value(object, type, objects, cur_second, CHECK);</span>
<span class="udiff-line-modified-added">+     JVMCIObject object = JVMCIENV-&gt;get_object_at(values, i);</span>
<span class="udiff-line-modified-added">+     BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);</span>
<span class="udiff-line-modified-added">+     ScopeValue* value = get_scope_value(object, type, objects, cur_second, JVMCI_CHECK);</span>
  
      if (isLongArray &amp;&amp; cur_second == NULL) {
        // we&#39;re trying to put ints into a long array... this isn&#39;t really valid, but it&#39;s used for some optimizations.
        // add an int 0 constant
        cur_second = _int_0_scope_value;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -488,83 +441,78 @@</span>
      assert(value != NULL, &quot;missing value&quot;);
      sv-&gt;field_values()-&gt;append(value);
    }
  }
  
<span class="udiff-line-modified-removed">- MonitorValue* CodeInstaller::get_monitor_value(Handle value, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {</span>
<span class="udiff-line-modified-added">+ MonitorValue* CodeInstaller::get_monitor_value(JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS) {</span>
    if (value.is_null()) {
<span class="udiff-line-modified-removed">-     THROW_NULL(vmSymbols::java_lang_NullPointerException());</span>
<span class="udiff-line-modified-added">+     JVMCI_THROW_NULL(NullPointerException);</span>
    }
<span class="udiff-line-modified-removed">-   if (!value-&gt;is_a(StackLockValue::klass())) {</span>
<span class="udiff-line-modified-removed">-     JVMCI_ERROR_NULL(&quot;Monitors must be of type StackLockValue, got %s&quot;, value-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+   if (!jvmci_env()-&gt;isa_StackLockValue(value)) {</span>
<span class="udiff-line-modified-added">+     JVMCI_ERROR_NULL(&quot;Monitors must be of type StackLockValue, got %s&quot;, jvmci_env()-&gt;klass_name(value));</span>
    }
  
    ScopeValue* second = NULL;
<span class="udiff-line-modified-removed">-   Handle stack_lock_owner(THREAD, StackLockValue::owner(value));</span>
<span class="udiff-line-removed">-   ScopeValue* owner_value = get_scope_value(stack_lock_owner, T_OBJECT, objects, second, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   ScopeValue* owner_value = get_scope_value(jvmci_env()-&gt;get_StackLockValue_owner(value), T_OBJECT, objects, second, JVMCI_CHECK_NULL);</span>
    assert(second == NULL, &quot;monitor cannot occupy two stack slots&quot;);
  
<span class="udiff-line-modified-removed">-   Handle stack_lock_slot(THREAD, StackLockValue::slot(value));</span>
<span class="udiff-line-removed">-   ScopeValue* lock_data_value = get_scope_value(stack_lock_slot, T_LONG, objects, second, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   ScopeValue* lock_data_value = get_scope_value(jvmci_env()-&gt;get_StackLockValue_slot(value), T_LONG, objects, second, JVMCI_CHECK_NULL);</span>
    assert(second == lock_data_value, &quot;monitor is LONG value that occupies two stack slots&quot;);
    assert(lock_data_value-&gt;is_location(), &quot;invalid monitor location&quot;);
    Location lock_data_loc = ((LocationValue*)lock_data_value)-&gt;location();
  
    bool eliminated = false;
<span class="udiff-line-modified-removed">-   if (StackLockValue::eliminated(value)) {</span>
<span class="udiff-line-modified-added">+   if (jvmci_env()-&gt;get_StackLockValue_eliminated(value)) {</span>
      eliminated = true;
    }
  
    return new MonitorValue(owner_value, lock_data_loc, eliminated);
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::initialize_dependencies(oop compiled_code, OopRecorder* recorder, TRAPS) {</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::initialize_dependencies(JVMCIObject compiled_code, OopRecorder* oop_recorder, JVMCI_TRAPS) {</span>
    JavaThread* thread = JavaThread::current();
<span class="udiff-line-removed">-   assert(THREAD == thread, &quot;&quot;);</span>
    CompilerThread* compilerThread = thread-&gt;is_Compiler_thread() ? thread-&gt;as_CompilerThread() : NULL;
<span class="udiff-line-modified-removed">-   _oop_recorder = recorder;</span>
<span class="udiff-line-modified-added">+   _oop_recorder = oop_recorder;</span>
    _dependencies = new Dependencies(&amp;_arena, _oop_recorder, compilerThread != NULL ? compilerThread-&gt;log() : NULL);
<span class="udiff-line-modified-removed">-   objArrayHandle assumptions(THREAD, HotSpotCompiledCode::assumptions(compiled_code));</span>
<span class="udiff-line-modified-removed">-   if (!assumptions.is_null()) {</span>
<span class="udiff-line-modified-removed">-     int length = assumptions-&gt;length();</span>
<span class="udiff-line-modified-added">+   JVMCIObjectArray assumptions = jvmci_env()-&gt;get_HotSpotCompiledCode_assumptions(compiled_code);</span>
<span class="udiff-line-modified-added">+   if (assumptions.is_non_null()) {</span>
<span class="udiff-line-modified-added">+     int length = JVMCIENV-&gt;get_length(assumptions);</span>
      for (int i = 0; i &lt; length; ++i) {
<span class="udiff-line-modified-removed">-       Handle assumption(THREAD, assumptions-&gt;obj_at(i));</span>
<span class="udiff-line-modified-removed">-       if (!assumption.is_null()) {</span>
<span class="udiff-line-modified-removed">-         if (assumption-&gt;klass() == Assumptions_NoFinalizableSubclass::klass()) {</span>
<span class="udiff-line-modified-removed">-           assumption_NoFinalizableSubclass(THREAD, assumption);</span>
<span class="udiff-line-modified-removed">-         } else if (assumption-&gt;klass() == Assumptions_ConcreteSubtype::klass()) {</span>
<span class="udiff-line-modified-removed">-           assumption_ConcreteSubtype(THREAD, assumption);</span>
<span class="udiff-line-modified-removed">-         } else if (assumption-&gt;klass() == Assumptions_LeafType::klass()) {</span>
<span class="udiff-line-modified-removed">-           assumption_LeafType(THREAD, assumption);</span>
<span class="udiff-line-modified-removed">-         } else if (assumption-&gt;klass() == Assumptions_ConcreteMethod::klass()) {</span>
<span class="udiff-line-modified-removed">-           assumption_ConcreteMethod(THREAD, assumption);</span>
<span class="udiff-line-modified-removed">-         } else if (assumption-&gt;klass() == Assumptions_CallSiteTargetValue::klass()) {</span>
<span class="udiff-line-modified-removed">-           assumption_CallSiteTargetValue(THREAD, assumption);</span>
<span class="udiff-line-modified-added">+       JVMCIObject assumption = JVMCIENV-&gt;get_object_at(assumptions, i);</span>
<span class="udiff-line-modified-added">+       if (assumption.is_non_null()) {</span>
<span class="udiff-line-modified-added">+         if (jvmci_env()-&gt;isa_Assumptions_NoFinalizableSubclass(assumption)) {</span>
<span class="udiff-line-modified-added">+           assumption_NoFinalizableSubclass(assumption);</span>
<span class="udiff-line-modified-added">+         } else if (jvmci_env()-&gt;isa_Assumptions_ConcreteSubtype(assumption)) {</span>
<span class="udiff-line-modified-added">+           assumption_ConcreteSubtype(assumption);</span>
<span class="udiff-line-modified-added">+         } else if (jvmci_env()-&gt;isa_Assumptions_LeafType(assumption)) {</span>
<span class="udiff-line-modified-added">+           assumption_LeafType(assumption);</span>
<span class="udiff-line-modified-added">+         } else if (jvmci_env()-&gt;isa_Assumptions_ConcreteMethod(assumption)) {</span>
<span class="udiff-line-modified-added">+           assumption_ConcreteMethod(assumption);</span>
<span class="udiff-line-modified-added">+         } else if (jvmci_env()-&gt;isa_Assumptions_CallSiteTargetValue(assumption)) {</span>
<span class="udiff-line-modified-added">+           assumption_CallSiteTargetValue(assumption, JVMCI_CHECK);</span>
          } else {
<span class="udiff-line-modified-removed">-           JVMCI_ERROR(&quot;unexpected Assumption subclass %s&quot;, assumption-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+           JVMCI_ERROR(&quot;unexpected Assumption subclass %s&quot;, jvmci_env()-&gt;klass_name(assumption));</span>
          }
        }
      }
    }
    if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
<span class="udiff-line-modified-removed">-     objArrayHandle methods(THREAD, HotSpotCompiledCode::methods(compiled_code));</span>
<span class="udiff-line-modified-removed">-     if (!methods.is_null()) {</span>
<span class="udiff-line-modified-removed">-       int length = methods-&gt;length();</span>
<span class="udiff-line-modified-added">+     JVMCIObjectArray methods = jvmci_env()-&gt;get_HotSpotCompiledCode_methods(compiled_code);</span>
<span class="udiff-line-modified-added">+     if (methods.is_non_null()) {</span>
<span class="udiff-line-modified-added">+       int length = JVMCIENV-&gt;get_length(methods);</span>
        for (int i = 0; i &lt; length; ++i) {
<span class="udiff-line-modified-removed">-         Handle method_handle(THREAD, methods-&gt;obj_at(i));</span>
<span class="udiff-line-modified-removed">-         methodHandle method = getMethodFromHotSpotMethod(method_handle());</span>
<span class="udiff-line-modified-removed">-         _dependencies-&gt;assert_evol_method(method());</span>
<span class="udiff-line-modified-added">+         JVMCIObject method_handle = JVMCIENV-&gt;get_object_at(methods, i);</span>
<span class="udiff-line-modified-added">+         Method* method = jvmci_env()-&gt;asMethod(method_handle);</span>
<span class="udiff-line-modified-added">+         _dependencies-&gt;assert_evol_method(method);</span>
        }
      }
    }
  }
  
  #if INCLUDE_AOT
  RelocBuffer::~RelocBuffer() {
<span class="udiff-line-modified-removed">-   if (_buffer != NULL) {</span>
<span class="udiff-line-removed">-     FREE_C_HEAP_ARRAY(char, _buffer);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   FREE_C_HEAP_ARRAY(char, _buffer);</span>
  }
  
  address RelocBuffer::begin() const {
    if (_buffer != NULL) {
      return (address) _buffer;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -579,108 +527,128 @@</span>
  
  void RelocBuffer::ensure_size(size_t bytes) {
    assert(_buffer == NULL, &quot;can only be used once&quot;);
    assert(_size == 0, &quot;can only be used once&quot;);
    if (bytes &gt;= RelocBuffer::stack_size) {
<span class="udiff-line-modified-removed">-     _buffer = NEW_C_HEAP_ARRAY(char, bytes, mtInternal);</span>
<span class="udiff-line-modified-added">+     _buffer = NEW_C_HEAP_ARRAY(char, bytes, mtJVMCI);</span>
    }
    _size = bytes;
  }
  
<span class="udiff-line-modified-removed">- JVMCIEnv::CodeInstallResult CodeInstaller::gather_metadata(Handle target, Handle compiled_code, CodeMetadata&amp; metadata, TRAPS) {</span>
<span class="udiff-line-modified-added">+ JVMCI::CodeInstallResult CodeInstaller::gather_metadata(JVMCIObject target, JVMCIObject compiled_code, CodeMetadata&amp; metadata, JVMCI_TRAPS) {</span>
<span class="udiff-line-added">+   assert(JVMCIENV-&gt;is_hotspot(), &quot;AOT code is executed only in HotSpot mode&quot;);</span>
    CodeBuffer buffer(&quot;JVMCI Compiler CodeBuffer for Metadata&quot;);
<span class="udiff-line-modified-removed">-   jobject compiled_code_obj = JNIHandles::make_local(compiled_code());</span>
<span class="udiff-line-modified-removed">-   AOTOopRecorder* recorder = new AOTOopRecorder(&amp;_arena, true);</span>
<span class="udiff-line-removed">-   initialize_dependencies(JNIHandles::resolve(compiled_code_obj), recorder, CHECK_OK);</span>
<span class="udiff-line-modified-added">+   AOTOopRecorder* recorder = new AOTOopRecorder(this, &amp;_arena, true);</span>
<span class="udiff-line-modified-added">+   initialize_dependencies(compiled_code, recorder, JVMCI_CHECK_OK);</span>
  
    metadata.set_oop_recorder(recorder);
  
    // Get instructions and constants CodeSections early because we need it.
    _instructions = buffer.insts();
    _constants = buffer.consts();
    buffer.set_immutable_PIC(_immutable_pic_compilation);
  
<span class="udiff-line-modified-removed">-   initialize_fields(target(), JNIHandles::resolve(compiled_code_obj), CHECK_OK);</span>
<span class="udiff-line-modified-removed">-   JVMCIEnv::CodeInstallResult result = initialize_buffer(buffer, false, CHECK_OK);</span>
<span class="udiff-line-modified-removed">-   if (result != JVMCIEnv::ok) {</span>
<span class="udiff-line-modified-added">+   initialize_fields(target, compiled_code, JVMCI_CHECK_OK);</span>
<span class="udiff-line-modified-added">+   JVMCI::CodeInstallResult result = initialize_buffer(buffer, false, JVMCI_CHECK_OK);</span>
<span class="udiff-line-modified-added">+   if (result != JVMCI::ok) {</span>
      return result;
    }
  
    _debug_recorder-&gt;pcs_size(); // create the sentinel record
  
    assert(_debug_recorder-&gt;pcs_length() &gt;= 2, &quot;must be at least 2&quot;);
  
    metadata.set_pc_desc(_debug_recorder-&gt;pcs(), _debug_recorder-&gt;pcs_length());
    metadata.set_scopes(_debug_recorder-&gt;stream()-&gt;buffer(), _debug_recorder-&gt;data_size());
    metadata.set_exception_table(&amp;_exception_handler_table);
<span class="udiff-line-added">+   metadata.set_implicit_exception_table(&amp;_implicit_exception_table);</span>
  
    RelocBuffer* reloc_buffer = metadata.get_reloc_buffer();
  
    reloc_buffer-&gt;ensure_size(buffer.total_relocation_size());
    size_t size = (size_t) buffer.copy_relocations_to(reloc_buffer-&gt;begin(), (CodeBuffer::csize_t) reloc_buffer-&gt;size(), true);
    reloc_buffer-&gt;set_size(size);
<span class="udiff-line-modified-removed">-   return JVMCIEnv::ok;</span>
<span class="udiff-line-modified-added">+   return JVMCI::ok;</span>
  }
  #endif // INCLUDE_AOT
  
  // constructor used to create a method
<span class="udiff-line-modified-removed">- JVMCIEnv::CodeInstallResult CodeInstaller::install(JVMCICompiler* compiler, Handle target, Handle compiled_code, CodeBlob*&amp; cb, Handle installed_code, Handle speculation_log, TRAPS) {</span>
<span class="udiff-line-modified-added">+ JVMCI::CodeInstallResult CodeInstaller::install(JVMCICompiler* compiler,</span>
<span class="udiff-line-added">+     JVMCIObject target,</span>
<span class="udiff-line-added">+     JVMCIObject compiled_code,</span>
<span class="udiff-line-added">+     CodeBlob*&amp; cb,</span>
<span class="udiff-line-added">+     JVMCIObject installed_code,</span>
<span class="udiff-line-added">+     FailedSpeculation** failed_speculations,</span>
<span class="udiff-line-added">+     char* speculations,</span>
<span class="udiff-line-added">+     int speculations_len,</span>
<span class="udiff-line-added">+     JVMCI_TRAPS) {</span>
<span class="udiff-line-added">+ </span>
    CodeBuffer buffer(&quot;JVMCI Compiler CodeBuffer&quot;);
<span class="udiff-line-removed">-   jobject compiled_code_obj = JNIHandles::make_local(compiled_code());</span>
    OopRecorder* recorder = new OopRecorder(&amp;_arena, true);
<span class="udiff-line-modified-removed">-   initialize_dependencies(JNIHandles::resolve(compiled_code_obj), recorder, CHECK_OK);</span>
<span class="udiff-line-modified-added">+   initialize_dependencies(compiled_code, recorder, JVMCI_CHECK_OK);</span>
  
    // Get instructions and constants CodeSections early because we need it.
    _instructions = buffer.insts();
    _constants = buffer.consts();
  #if INCLUDE_AOT
    buffer.set_immutable_PIC(_immutable_pic_compilation);
  #endif
  
<span class="udiff-line-modified-removed">-   initialize_fields(target(), JNIHandles::resolve(compiled_code_obj), CHECK_OK);</span>
<span class="udiff-line-modified-removed">-   JVMCIEnv::CodeInstallResult result = initialize_buffer(buffer, true, CHECK_OK);</span>
<span class="udiff-line-modified-removed">-   if (result != JVMCIEnv::ok) {</span>
<span class="udiff-line-modified-added">+   initialize_fields(target, compiled_code, JVMCI_CHECK_OK);</span>
<span class="udiff-line-modified-added">+   JVMCI::CodeInstallResult result = initialize_buffer(buffer, true, JVMCI_CHECK_OK);</span>
<span class="udiff-line-modified-added">+   if (result != JVMCI::ok) {</span>
      return result;
    }
  
    int stack_slots = _total_frame_size / HeapWordSize; // conversion to words
  
<span class="udiff-line-modified-removed">-   if (!compiled_code-&gt;is_a(HotSpotCompiledNmethod::klass())) {</span>
<span class="udiff-line-modified-removed">-     oop stubName = HotSpotCompiledCode::name(compiled_code_obj);</span>
<span class="udiff-line-modified-removed">-     if (stubName == NULL) {</span>
<span class="udiff-line-modified-added">+   if (!jvmci_env()-&gt;isa_HotSpotCompiledNmethod(compiled_code)) {</span>
<span class="udiff-line-modified-added">+     JVMCIObject stubName = jvmci_env()-&gt;get_HotSpotCompiledCode_name(compiled_code);</span>
<span class="udiff-line-modified-added">+     if (stubName.is_null()) {</span>
        JVMCI_ERROR_OK(&quot;stub should have a name&quot;);
      }
<span class="udiff-line-modified-removed">-     char* name = strdup(java_lang_String::as_utf8_string(stubName));</span>
<span class="udiff-line-modified-added">+     char* name = strdup(jvmci_env()-&gt;as_utf8_string(stubName));</span>
      cb = RuntimeStub::new_runtime_stub(name,
                                         &amp;buffer,
                                         CodeOffsets::frame_never_safe,
                                         stack_slots,
                                         _debug_recorder-&gt;_oopmaps,
                                         false);
<span class="udiff-line-modified-removed">-     result = JVMCIEnv::ok;</span>
<span class="udiff-line-modified-added">+     result = JVMCI::ok;</span>
    } else {
<span class="udiff-line-modified-removed">-     nmethod* nm = NULL;</span>
<span class="udiff-line-modified-removed">-     methodHandle method = getMethodFromHotSpotMethod(HotSpotCompiledNmethod::method(compiled_code));</span>
<span class="udiff-line-modified-removed">-     jint entry_bci = HotSpotCompiledNmethod::entryBCI(compiled_code);</span>
<span class="udiff-line-modified-removed">-     jint id = HotSpotCompiledNmethod::id(compiled_code);</span>
<span class="udiff-line-modified-removed">-     bool has_unsafe_access = HotSpotCompiledNmethod::hasUnsafeAccess(compiled_code) == JNI_TRUE;</span>
<span class="udiff-line-modified-removed">-     JVMCIEnv* env = (JVMCIEnv*) (address) HotSpotCompiledNmethod::jvmciEnv(compiled_code);</span>
<span class="udiff-line-modified-added">+     JVMCICompileState* compile_state = (JVMCICompileState*) (address) jvmci_env()-&gt;get_HotSpotCompiledNmethod_compileState(compiled_code);</span>
<span class="udiff-line-modified-added">+     if (compile_state != NULL) {</span>
<span class="udiff-line-modified-added">+       jvmci_env()-&gt;set_compile_state(compile_state);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     Thread* thread = Thread::current();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     methodHandle method(thread, jvmci_env()-&gt;asMethod(jvmci_env()-&gt;get_HotSpotCompiledNmethod_method(compiled_code)));</span>
<span class="udiff-line-added">+     jint entry_bci = jvmci_env()-&gt;get_HotSpotCompiledNmethod_entryBCI(compiled_code);</span>
<span class="udiff-line-added">+     bool has_unsafe_access = jvmci_env()-&gt;get_HotSpotCompiledNmethod_hasUnsafeAccess(compiled_code) == JNI_TRUE;</span>
<span class="udiff-line-added">+     jint id = jvmci_env()-&gt;get_HotSpotCompiledNmethod_id(compiled_code);</span>
      if (id == -1) {
        // Make sure a valid compile_id is associated with every compile
<span class="udiff-line-modified-removed">-       id = CompileBroker::assign_compile_id_unlocked(Thread::current(), method, entry_bci);</span>
<span class="udiff-line-modified-added">+       id = CompileBroker::assign_compile_id_unlocked(thread, method, entry_bci);</span>
<span class="udiff-line-added">+       jvmci_env()-&gt;set_HotSpotCompiledNmethod_id(compiled_code, id);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (!jvmci_env()-&gt;isa_HotSpotNmethod(installed_code)) {</span>
<span class="udiff-line-added">+       JVMCI_THROW_MSG_(IllegalArgumentException, &quot;InstalledCode object must be a HotSpotNmethod when installing a HotSpotCompiledNmethod&quot;, JVMCI::ok);</span>
      }
<span class="udiff-line-modified-removed">-     result = JVMCIEnv::register_method(method, nm, entry_bci, &amp;_offsets, _orig_pc_offset, &amp;buffer,</span>
<span class="udiff-line-modified-removed">-                                        stack_slots, _debug_recorder-&gt;_oopmaps, &amp;_exception_handler_table,</span>
<span class="udiff-line-modified-removed">-                                        compiler, _debug_recorder, _dependencies, env, id,</span>
<span class="udiff-line-modified-removed">-                                        has_unsafe_access, _has_wide_vector, installed_code, compiled_code, speculation_log);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     JVMCIObject mirror = installed_code;</span>
<span class="udiff-line-modified-added">+     nmethod* nm = NULL;</span>
<span class="udiff-line-modified-added">+     result = runtime()-&gt;register_method(jvmci_env(), method, nm, entry_bci, &amp;_offsets, _orig_pc_offset, &amp;buffer,</span>
<span class="udiff-line-added">+                                         stack_slots, _debug_recorder-&gt;_oopmaps, &amp;_exception_handler_table, &amp;_implicit_exception_table,</span>
<span class="udiff-line-added">+                                         compiler, _debug_recorder, _dependencies, id,</span>
<span class="udiff-line-added">+                                         has_unsafe_access, _has_wide_vector, compiled_code, mirror,</span>
<span class="udiff-line-added">+                                         failed_speculations, speculations, speculations_len);</span>
      cb = nm-&gt;as_codeblob_or_null();
<span class="udiff-line-modified-removed">-     if (nm != NULL &amp;&amp; env == NULL) {</span>
<span class="udiff-line-modified-added">+     if (nm != NULL &amp;&amp; compile_state == NULL) {</span>
<span class="udiff-line-added">+       // This compile didn&#39;t come through the CompileBroker so perform the printing here</span>
        DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);
<span class="udiff-line-modified-removed">-       bool printnmethods = directive-&gt;PrintAssemblyOption || directive-&gt;PrintNMethodsOption;</span>
<span class="udiff-line-removed">-       if (!printnmethods &amp;&amp; (PrintDebugInfo || PrintRelocations || PrintDependencies || PrintExceptionHandlers)) {</span>
<span class="udiff-line-removed">-         nm-&gt;print_nmethod(printnmethods);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       nm-&gt;maybe_print_nmethod(directive);</span>
        DirectivesStack::release(directive);
      }
    }
  
    if (cb != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -688,97 +656,97 @@</span>
      guarantee((cb-&gt;code_begin() - cb-&gt;content_begin()) &gt;= _constants_size, &quot;%d &lt; %d&quot;, (int)(cb-&gt;code_begin() - cb-&gt;content_begin()), _constants_size);
    }
    return result;
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::initialize_fields(oop target, oop compiled_code, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   if (compiled_code-&gt;is_a(HotSpotCompiledNmethod::klass())) {</span>
<span class="udiff-line-modified-removed">-     Handle hotspotJavaMethod(THREAD, HotSpotCompiledNmethod::method(compiled_code));</span>
<span class="udiff-line-modified-removed">-     methodHandle method = getMethodFromHotSpotMethod(hotspotJavaMethod());</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::initialize_fields(JVMCIObject target, JVMCIObject compiled_code, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   if (jvmci_env()-&gt;isa_HotSpotCompiledNmethod(compiled_code)) {</span>
<span class="udiff-line-modified-added">+     JVMCIObject hotspotJavaMethod = jvmci_env()-&gt;get_HotSpotCompiledNmethod_method(compiled_code);</span>
<span class="udiff-line-modified-added">+     Thread* thread = Thread::current();</span>
<span class="udiff-line-added">+     methodHandle method(thread, jvmci_env()-&gt;asMethod(hotspotJavaMethod));</span>
      _parameter_count = method-&gt;size_of_parameters();
      TRACE_jvmci_2(&quot;installing code for %s&quot;, method-&gt;name_and_sig_as_C_string());
    } else {
      // Must be a HotSpotCompiledRuntimeStub.
      // Only used in OopMap constructor for non-product builds
      _parameter_count = 0;
    }
<span class="udiff-line-modified-removed">-   _sites_handle = JNIHandles::make_local(HotSpotCompiledCode::sites(compiled_code));</span>
<span class="udiff-line-modified-added">+   _sites_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_sites(compiled_code);</span>
  
<span class="udiff-line-modified-removed">-   _code_handle = JNIHandles::make_local(HotSpotCompiledCode::targetCode(compiled_code));</span>
<span class="udiff-line-modified-removed">-   _code_size = HotSpotCompiledCode::targetCodeSize(compiled_code);</span>
<span class="udiff-line-modified-removed">-   _total_frame_size = HotSpotCompiledCode::totalFrameSize(compiled_code);</span>
<span class="udiff-line-modified-added">+   _code_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_targetCode(compiled_code);</span>
<span class="udiff-line-modified-added">+   _code_size = jvmci_env()-&gt;get_HotSpotCompiledCode_targetCodeSize(compiled_code);</span>
<span class="udiff-line-modified-added">+   _total_frame_size = jvmci_env()-&gt;get_HotSpotCompiledCode_totalFrameSize(compiled_code);</span>
  
<span class="udiff-line-modified-removed">-   oop deoptRescueSlot = HotSpotCompiledCode::deoptRescueSlot(compiled_code);</span>
<span class="udiff-line-modified-removed">-   if (deoptRescueSlot == NULL) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject deoptRescueSlot = jvmci_env()-&gt;get_HotSpotCompiledCode_deoptRescueSlot(compiled_code);</span>
<span class="udiff-line-modified-added">+   if (deoptRescueSlot.is_null()) {</span>
      _orig_pc_offset = -1;
    } else {
<span class="udiff-line-modified-removed">-     _orig_pc_offset = StackSlot::offset(deoptRescueSlot);</span>
<span class="udiff-line-modified-removed">-     if (StackSlot::addFrameSize(deoptRescueSlot)) {</span>
<span class="udiff-line-modified-added">+     _orig_pc_offset = jvmci_env()-&gt;get_StackSlot_offset(deoptRescueSlot);</span>
<span class="udiff-line-modified-added">+     if (jvmci_env()-&gt;get_StackSlot_addFrameSize(deoptRescueSlot)) {</span>
        _orig_pc_offset += _total_frame_size;
      }
      if (_orig_pc_offset &lt; 0) {
        JVMCI_ERROR(&quot;invalid deopt rescue slot: %d&quot;, _orig_pc_offset);
      }
    }
  
    // Pre-calculate the constants section size.  This is required for PC-relative addressing.
<span class="udiff-line-modified-removed">-   _data_section_handle = JNIHandles::make_local(HotSpotCompiledCode::dataSection(compiled_code));</span>
<span class="udiff-line-modified-removed">-   if ((_constants-&gt;alignment() % HotSpotCompiledCode::dataSectionAlignment(compiled_code)) != 0) {</span>
<span class="udiff-line-modified-removed">-     JVMCI_ERROR(&quot;invalid data section alignment: %d&quot;, HotSpotCompiledCode::dataSectionAlignment(compiled_code));</span>
<span class="udiff-line-modified-added">+   _data_section_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_dataSection(compiled_code);</span>
<span class="udiff-line-modified-added">+   if ((_constants-&gt;alignment() % jvmci_env()-&gt;get_HotSpotCompiledCode_dataSectionAlignment(compiled_code)) != 0) {</span>
<span class="udiff-line-modified-added">+     JVMCI_ERROR(&quot;invalid data section alignment: %d&quot;, jvmci_env()-&gt;get_HotSpotCompiledCode_dataSectionAlignment(compiled_code));</span>
    }
<span class="udiff-line-modified-removed">-   _constants_size = data_section()-&gt;length();</span>
<span class="udiff-line-modified-added">+   _constants_size = JVMCIENV-&gt;get_length(data_section());</span>
  
<span class="udiff-line-modified-removed">-   _data_section_patches_handle = JNIHandles::make_local(HotSpotCompiledCode::dataSectionPatches(compiled_code));</span>
<span class="udiff-line-modified-added">+   _data_section_patches_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_dataSectionPatches(compiled_code);</span>
  
  #ifndef PRODUCT
<span class="udiff-line-modified-removed">-   _comments_handle = JNIHandles::make_local(HotSpotCompiledCode::comments(compiled_code));</span>
<span class="udiff-line-modified-added">+   _comments_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_comments(compiled_code);</span>
  #endif
  
    _next_call_type = INVOKE_INVALID;
  
    _has_wide_vector = false;
  
<span class="udiff-line-modified-removed">-   oop arch = TargetDescription::arch(target);</span>
<span class="udiff-line-modified-removed">-   _word_kind_handle = JNIHandles::make_local(Architecture::wordKind(arch));</span>
<span class="udiff-line-modified-added">+   JVMCIObject arch = jvmci_env()-&gt;get_TargetDescription_arch(target);</span>
<span class="udiff-line-modified-added">+   _word_kind_handle = jvmci_env()-&gt;get_Architecture_wordKind(arch);</span>
  }
  
<span class="udiff-line-modified-removed">- int CodeInstaller::estimate_stubs_size(TRAPS) {</span>
<span class="udiff-line-modified-added">+ int CodeInstaller::estimate_stubs_size(JVMCI_TRAPS) {</span>
    // Estimate the number of static and aot call stubs that might be emitted.
    int static_call_stubs = 0;
    int aot_call_stubs = 0;
    int trampoline_stubs = 0;
<span class="udiff-line-modified-removed">-   objArrayOop sites = this-&gt;sites();</span>
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; sites-&gt;length(); i++) {</span>
<span class="udiff-line-modified-removed">-     oop site = sites-&gt;obj_at(i);</span>
<span class="udiff-line-modified-removed">-     if (site != NULL) {</span>
<span class="udiff-line-modified-removed">-       if (site-&gt;is_a(site_Mark::klass())) {</span>
<span class="udiff-line-modified-removed">-         oop id_obj = site_Mark::id(site);</span>
<span class="udiff-line-modified-removed">-         if (id_obj != NULL) {</span>
<span class="udiff-line-modified-removed">-           if (!java_lang_boxing_object::is_instance(id_obj, T_INT)) {</span>
<span class="udiff-line-modified-removed">-             JVMCI_ERROR_0(&quot;expected Integer id, got %s&quot;, id_obj-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+   JVMCIObjectArray sites = this-&gt;sites();</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(sites); i++) {</span>
<span class="udiff-line-modified-added">+     JVMCIObject site = JVMCIENV-&gt;get_object_at(sites, i);</span>
<span class="udiff-line-modified-added">+     if (!site.is_null()) {</span>
<span class="udiff-line-modified-added">+       if (jvmci_env()-&gt;isa_site_Mark(site)) {</span>
<span class="udiff-line-modified-added">+         JVMCIObject id_obj = jvmci_env()-&gt;get_site_Mark_id(site);</span>
<span class="udiff-line-modified-added">+         if (id_obj.is_non_null()) {</span>
<span class="udiff-line-modified-added">+           if (!jvmci_env()-&gt;is_boxing_object(T_INT, id_obj)) {</span>
<span class="udiff-line-modified-added">+             JVMCI_ERROR_0(&quot;expected Integer id, got %s&quot;, jvmci_env()-&gt;klass_name(id_obj));</span>
            }
<span class="udiff-line-modified-removed">-           jint id = id_obj-&gt;int_field(java_lang_boxing_object::value_offset_in_bytes(T_INT));</span>
<span class="udiff-line-modified-added">+           jint id = jvmci_env()-&gt;get_boxed_value(T_INT, id_obj).i;</span>
            switch (id) {
<span class="udiff-line-modified-removed">-           case INVOKEINTERFACE:</span>
<span class="udiff-line-modified-removed">-           case INVOKEVIRTUAL:</span>
<span class="udiff-line-modified-removed">-             trampoline_stubs++;</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-removed">-           case INVOKESTATIC:</span>
<span class="udiff-line-modified-removed">-           case INVOKESPECIAL:</span>
<span class="udiff-line-modified-removed">-             static_call_stubs++;</span>
<span class="udiff-line-modified-removed">-             trampoline_stubs++;</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-removed">-           default:</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+             case INVOKEINTERFACE:</span>
<span class="udiff-line-modified-added">+             case INVOKEVIRTUAL:</span>
<span class="udiff-line-modified-added">+               trampoline_stubs++;</span>
<span class="udiff-line-modified-added">+               break;</span>
<span class="udiff-line-modified-added">+             case INVOKESTATIC:</span>
<span class="udiff-line-modified-added">+             case INVOKESPECIAL:</span>
<span class="udiff-line-modified-added">+               static_call_stubs++;</span>
<span class="udiff-line-modified-added">+               trampoline_stubs++;</span>
<span class="udiff-line-modified-added">+               break;</span>
<span class="udiff-line-modified-added">+             default:</span>
<span class="udiff-line-modified-added">+               break;</span>
            }
          }
        }
  #if INCLUDE_AOT
<span class="udiff-line-modified-removed">-       if (UseAOT &amp;&amp; site-&gt;is_a(site_Call::klass())) {</span>
<span class="udiff-line-modified-removed">-         oop target = site_Call::target(site);</span>
<span class="udiff-line-modified-removed">-         InstanceKlass* target_klass = InstanceKlass::cast(target-&gt;klass());</span>
<span class="udiff-line-removed">-         if (!target_klass-&gt;is_subclass_of(SystemDictionary::HotSpotForeignCallTarget_klass())) {</span>
<span class="udiff-line-modified-added">+       if (UseAOT &amp;&amp; jvmci_env()-&gt;isa_site_Call(site)) {</span>
<span class="udiff-line-modified-added">+         JVMCIObject target = jvmci_env()-&gt; get_site_Call_target(site);</span>
<span class="udiff-line-modified-added">+         if (!jvmci_env()-&gt;isa_HotSpotForeignCallTarget(target)) {</span>
            // Add far aot trampolines.
            aot_call_stubs++;
          }
        }
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -791,29 +759,29 @@</span>
  #endif
    return size;
  }
  
  // perform data and call relocation on the CodeBuffer
<span class="udiff-line-modified-removed">- JVMCIEnv::CodeInstallResult CodeInstaller::initialize_buffer(CodeBuffer&amp; buffer, bool check_size, TRAPS) {</span>
<span class="udiff-line-modified-added">+ JVMCI::CodeInstallResult CodeInstaller::initialize_buffer(CodeBuffer&amp; buffer, bool check_size, JVMCI_TRAPS) {</span>
    HandleMark hm;
<span class="udiff-line-modified-removed">-   objArrayHandle sites(THREAD, this-&gt;sites());</span>
<span class="udiff-line-modified-removed">-   int locs_buffer_size = sites-&gt;length() * (relocInfo::length_limit + sizeof(relocInfo));</span>
<span class="udiff-line-modified-added">+   JVMCIObjectArray sites = this-&gt;sites();</span>
<span class="udiff-line-modified-added">+   int locs_buffer_size = JVMCIENV-&gt;get_length(sites) * (relocInfo::length_limit + sizeof(relocInfo));</span>
  
    // Allocate enough space in the stub section for the static call
    // stubs.  Stubs have extra relocs but they are managed by the stub
    // section itself so they don&#39;t need to be accounted for in the
    // locs_buffer above.
<span class="udiff-line-modified-removed">-   int stubs_size = estimate_stubs_size(CHECK_OK);</span>
<span class="udiff-line-modified-added">+   int stubs_size = estimate_stubs_size(JVMCI_CHECK_OK);</span>
    int total_size = align_up(_code_size, buffer.insts()-&gt;alignment()) + align_up(_constants_size, buffer.consts()-&gt;alignment()) + align_up(stubs_size, buffer.stubs()-&gt;alignment());
  
    if (check_size &amp;&amp; total_size &gt; JVMCINMethodSizeLimit) {
<span class="udiff-line-modified-removed">-     return JVMCIEnv::code_too_large;</span>
<span class="udiff-line-modified-added">+     return JVMCI::code_too_large;</span>
    }
  
    buffer.initialize(total_size, locs_buffer_size);
    if (buffer.blob() == NULL) {
<span class="udiff-line-modified-removed">-     return JVMCIEnv::cache_full;</span>
<span class="udiff-line-modified-added">+     return JVMCI::cache_full;</span>
    }
    buffer.initialize_stubs_size(stubs_size);
    buffer.initialize_consts_size(_constants_size);
  
    _debug_recorder = new DebugInformationRecorder(_oop_recorder);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -821,102 +789,108 @@</span>
  
    buffer.initialize_oop_recorder(_oop_recorder);
  
    // copy the constant data into the newly created CodeBuffer
    address end_data = _constants-&gt;start() + _constants_size;
<span class="udiff-line-modified-removed">-   memcpy(_constants-&gt;start(), data_section()-&gt;base(T_BYTE), _constants_size);</span>
<span class="udiff-line-modified-added">+   JVMCIENV-&gt;copy_bytes_to(data_section(), (jbyte*) _constants-&gt;start(), 0, _constants_size);</span>
    _constants-&gt;set_end(end_data);
  
    // copy the code into the newly created CodeBuffer
    address end_pc = _instructions-&gt;start() + _code_size;
    guarantee(_instructions-&gt;allocates2(end_pc), &quot;initialize should have reserved enough space for all the code&quot;);
<span class="udiff-line-modified-removed">-   memcpy(_instructions-&gt;start(), code()-&gt;base(T_BYTE), _code_size);</span>
<span class="udiff-line-modified-added">+   JVMCIENV-&gt;copy_bytes_to(code(), (jbyte*) _instructions-&gt;start(), 0, _code_size);</span>
    _instructions-&gt;set_end(end_pc);
  
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; data_section_patches()-&gt;length(); i++) {</span>
<span class="udiff-line-modified-removed">-     HandleMark hm(THREAD);</span>
<span class="udiff-line-modified-removed">-     Handle patch(THREAD, data_section_patches()-&gt;obj_at(i));</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(data_section_patches()); i++) {</span>
<span class="udiff-line-modified-added">+     // HandleMark hm(THREAD);</span>
<span class="udiff-line-modified-added">+     JVMCIObject patch = JVMCIENV-&gt;get_object_at(data_section_patches(), i);</span>
      if (patch.is_null()) {
<span class="udiff-line-modified-removed">-       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);</span>
<span class="udiff-line-modified-added">+       JVMCI_THROW_(NullPointerException, JVMCI::ok);</span>
      }
<span class="udiff-line-modified-removed">-     Handle reference(THREAD, site_DataPatch::reference(patch));</span>
<span class="udiff-line-modified-added">+     JVMCIObject reference = jvmci_env()-&gt;get_site_DataPatch_reference(patch);</span>
      if (reference.is_null()) {
<span class="udiff-line-modified-removed">-       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);</span>
<span class="udiff-line-modified-added">+       JVMCI_THROW_(NullPointerException, JVMCI::ok);</span>
      }
<span class="udiff-line-modified-removed">-     if (!reference-&gt;is_a(site_ConstantReference::klass())) {</span>
<span class="udiff-line-modified-removed">-       JVMCI_ERROR_OK(&quot;invalid patch in data section: %s&quot;, reference-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+     if (!jvmci_env()-&gt;isa_site_ConstantReference(reference)) {</span>
<span class="udiff-line-modified-added">+       JVMCI_ERROR_OK(&quot;invalid patch in data section: %s&quot;, jvmci_env()-&gt;klass_name(reference));</span>
      }
<span class="udiff-line-modified-removed">-     Handle constant(THREAD, site_ConstantReference::constant(reference));</span>
<span class="udiff-line-modified-added">+     JVMCIObject constant = jvmci_env()-&gt;get_site_ConstantReference_constant(reference);</span>
      if (constant.is_null()) {
<span class="udiff-line-modified-removed">-       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);</span>
<span class="udiff-line-modified-added">+       JVMCI_THROW_(NullPointerException, JVMCI::ok);</span>
      }
<span class="udiff-line-modified-removed">-     address dest = _constants-&gt;start() + site_Site::pcOffset(patch);</span>
<span class="udiff-line-modified-removed">-     if (constant-&gt;is_a(HotSpotMetaspaceConstantImpl::klass())) {</span>
<span class="udiff-line-modified-removed">-       if (HotSpotMetaspaceConstantImpl::compressed(constant)) {</span>
<span class="udiff-line-modified-added">+     address dest = _constants-&gt;start() + jvmci_env()-&gt;get_site_Site_pcOffset(patch);</span>
<span class="udiff-line-modified-added">+     if (jvmci_env()-&gt;isa_HotSpotMetaspaceConstantImpl(constant)) {</span>
<span class="udiff-line-modified-added">+       if (jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant)) {</span>
  #ifdef _LP64
<span class="udiff-line-modified-removed">-         *((narrowKlass*) dest) = record_narrow_metadata_reference(_constants, dest, constant, CHECK_OK);</span>
<span class="udiff-line-modified-added">+         *((narrowKlass*) dest) = record_narrow_metadata_reference(_constants, dest, constant, JVMCI_CHECK_OK);</span>
  #else
          JVMCI_ERROR_OK(&quot;unexpected compressed Klass* in 32-bit mode&quot;);
  #endif
        } else {
<span class="udiff-line-modified-removed">-         *((void**) dest) = record_metadata_reference(_constants, dest, constant, CHECK_OK);</span>
<span class="udiff-line-modified-added">+         *((void**) dest) = record_metadata_reference(_constants, dest, constant, JVMCI_CHECK_OK);</span>
        }
<span class="udiff-line-modified-removed">-     } else if (constant-&gt;is_a(HotSpotObjectConstantImpl::klass())) {</span>
<span class="udiff-line-modified-removed">-       Handle obj(THREAD, HotSpotObjectConstantImpl::object(constant));</span>
<span class="udiff-line-modified-added">+     } else if (jvmci_env()-&gt;isa_HotSpotObjectConstantImpl(constant)) {</span>
<span class="udiff-line-modified-added">+       Handle obj = jvmci_env()-&gt;asConstant(constant, JVMCI_CHECK_OK);</span>
        jobject value = JNIHandles::make_local(obj());
        int oop_index = _oop_recorder-&gt;find_index(value);
  
<span class="udiff-line-modified-removed">-       if (HotSpotObjectConstantImpl::compressed(constant)) {</span>
<span class="udiff-line-modified-added">+       if (jvmci_env()-&gt;get_HotSpotObjectConstantImpl_compressed(constant)) {</span>
  #ifdef _LP64
          _constants-&gt;relocate(dest, oop_Relocation::spec(oop_index), relocInfo::narrow_oop_in_const);
  #else
          JVMCI_ERROR_OK(&quot;unexpected compressed oop in 32-bit mode&quot;);
  #endif
        } else {
          _constants-&gt;relocate(dest, oop_Relocation::spec(oop_index));
        }
      } else {
<span class="udiff-line-modified-removed">-       JVMCI_ERROR_OK(&quot;invalid constant in data section: %s&quot;, constant-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+       JVMCI_ERROR_OK(&quot;invalid constant in data section: %s&quot;, jvmci_env()-&gt;klass_name(constant));</span>
      }
    }
    jint last_pc_offset = -1;
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; sites-&gt;length(); i++) {</span>
<span class="udiff-line-modified-removed">-     HandleMark hm(THREAD);</span>
<span class="udiff-line-modified-removed">-     Handle site(THREAD, sites-&gt;obj_at(i));</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(sites); i++) {</span>
<span class="udiff-line-modified-added">+     // HandleMark hm(THREAD);</span>
<span class="udiff-line-modified-added">+     JVMCIObject site = JVMCIENV-&gt;get_object_at(sites, i);</span>
      if (site.is_null()) {
<span class="udiff-line-modified-removed">-       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);</span>
<span class="udiff-line-modified-added">+       JVMCI_THROW_(NullPointerException, JVMCI::ok);</span>
      }
  
<span class="udiff-line-modified-removed">-     jint pc_offset = site_Site::pcOffset(site);</span>
<span class="udiff-line-modified-added">+     jint pc_offset = jvmci_env()-&gt;get_site_Site_pcOffset(site);</span>
  
<span class="udiff-line-modified-removed">-     if (site-&gt;is_a(site_Call::klass())) {</span>
<span class="udiff-line-modified-added">+     if (jvmci_env()-&gt;isa_site_Call(site)) {</span>
        TRACE_jvmci_4(&quot;call at %i&quot;, pc_offset);
<span class="udiff-line-modified-removed">-       site_Call(buffer, pc_offset, site, CHECK_OK);</span>
<span class="udiff-line-modified-removed">-     } else if (site-&gt;is_a(site_Infopoint::klass())) {</span>
<span class="udiff-line-modified-added">+       site_Call(buffer, pc_offset, site, JVMCI_CHECK_OK);</span>
<span class="udiff-line-modified-added">+     } else if (jvmci_env()-&gt;isa_site_Infopoint(site)) {</span>
        // three reasons for infopoints denote actual safepoints
<span class="udiff-line-modified-removed">-       oop reason = site_Infopoint::reason(site);</span>
<span class="udiff-line-modified-removed">-       if (site_InfopointReason::SAFEPOINT() == reason || site_InfopointReason::CALL() == reason || site_InfopointReason::IMPLICIT_EXCEPTION() == reason) {</span>
<span class="udiff-line-modified-added">+       JVMCIObject reason = jvmci_env()-&gt;get_site_Infopoint_reason(site);</span>
<span class="udiff-line-modified-added">+       if (JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_SAFEPOINT()) ||</span>
<span class="udiff-line-added">+           JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_CALL()) ||</span>
<span class="udiff-line-added">+           JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_IMPLICIT_EXCEPTION())) {</span>
          TRACE_jvmci_4(&quot;safepoint at %i&quot;, pc_offset);
<span class="udiff-line-modified-removed">-         site_Safepoint(buffer, pc_offset, site, CHECK_OK);</span>
<span class="udiff-line-modified-added">+         site_Safepoint(buffer, pc_offset, site, JVMCI_CHECK_OK);</span>
          if (_orig_pc_offset &lt; 0) {
            JVMCI_ERROR_OK(&quot;method contains safepoint, but has no deopt rescue slot&quot;);
          }
<span class="udiff-line-added">+         if (JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_IMPLICIT_EXCEPTION())) {</span>
<span class="udiff-line-added">+           TRACE_jvmci_4(&quot;implicit exception at %i&quot;, pc_offset);</span>
<span class="udiff-line-added">+           _implicit_exception_table.add_deoptimize(pc_offset);</span>
<span class="udiff-line-added">+         }</span>
        } else {
          TRACE_jvmci_4(&quot;infopoint at %i&quot;, pc_offset);
<span class="udiff-line-modified-removed">-         site_Infopoint(buffer, pc_offset, site, CHECK_OK);</span>
<span class="udiff-line-modified-added">+         site_Infopoint(buffer, pc_offset, site, JVMCI_CHECK_OK);</span>
        }
<span class="udiff-line-modified-removed">-     } else if (site-&gt;is_a(site_DataPatch::klass())) {</span>
<span class="udiff-line-modified-added">+     } else if (jvmci_env()-&gt;isa_site_DataPatch(site)) {</span>
        TRACE_jvmci_4(&quot;datapatch at %i&quot;, pc_offset);
<span class="udiff-line-modified-removed">-       site_DataPatch(buffer, pc_offset, site, CHECK_OK);</span>
<span class="udiff-line-modified-removed">-     } else if (site-&gt;is_a(site_Mark::klass())) {</span>
<span class="udiff-line-modified-added">+       site_DataPatch(buffer, pc_offset, site, JVMCI_CHECK_OK);</span>
<span class="udiff-line-modified-added">+     } else if (jvmci_env()-&gt;isa_site_Mark(site)) {</span>
        TRACE_jvmci_4(&quot;mark at %i&quot;, pc_offset);
<span class="udiff-line-modified-removed">-       site_Mark(buffer, pc_offset, site, CHECK_OK);</span>
<span class="udiff-line-modified-removed">-     } else if (site-&gt;is_a(site_ExceptionHandler::klass())) {</span>
<span class="udiff-line-modified-added">+       site_Mark(buffer, pc_offset, site, JVMCI_CHECK_OK);</span>
<span class="udiff-line-modified-added">+     } else if (jvmci_env()-&gt;isa_site_ExceptionHandler(site)) {</span>
        TRACE_jvmci_4(&quot;exceptionhandler at %i&quot;, pc_offset);
        site_ExceptionHandler(pc_offset, site);
      } else {
<span class="udiff-line-modified-removed">-       JVMCI_ERROR_OK(&quot;unexpected site subclass: %s&quot;, site-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+       JVMCI_ERROR_OK(&quot;unexpected site subclass: %s&quot;, jvmci_env()-&gt;klass_name(site));</span>
      }
      last_pc_offset = pc_offset;
  
      JavaThread* thread = JavaThread::current();
      if (SafepointMechanism::should_block(thread)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -924,65 +898,66 @@</span>
        ThreadToNativeFromVM ttnfv(thread);
      }
    }
  
  #ifndef PRODUCT
<span class="udiff-line-modified-removed">-   if (comments() != NULL) {</span>
<span class="udiff-line-modified-removed">-     for (int i = 0; i &lt; comments()-&gt;length(); i++) {</span>
<span class="udiff-line-modified-removed">-       oop comment = comments()-&gt;obj_at(i);</span>
<span class="udiff-line-modified-removed">-       assert(comment-&gt;is_a(HotSpotCompiledCode_Comment::klass()), &quot;cce&quot;);</span>
<span class="udiff-line-modified-removed">-       jint offset = HotSpotCompiledCode_Comment::pcOffset(comment);</span>
<span class="udiff-line-modified-removed">-       char* text = java_lang_String::as_utf8_string(HotSpotCompiledCode_Comment::text(comment));</span>
<span class="udiff-line-modified-added">+   if (comments().is_non_null()) {</span>
<span class="udiff-line-modified-added">+     for (int i = 0; i &lt; JVMCIENV-&gt;get_length(comments()); i++) {</span>
<span class="udiff-line-modified-added">+       JVMCIObject comment = JVMCIENV-&gt;get_object_at(comments(), i);</span>
<span class="udiff-line-modified-added">+       assert(jvmci_env()-&gt;isa_HotSpotCompiledCode_Comment(comment), &quot;cce&quot;);</span>
<span class="udiff-line-modified-added">+       jint offset = jvmci_env()-&gt;get_HotSpotCompiledCode_Comment_pcOffset(comment);</span>
<span class="udiff-line-modified-added">+       const char* text = jvmci_env()-&gt;as_utf8_string(jvmci_env()-&gt;get_HotSpotCompiledCode_Comment_text(comment));</span>
        buffer.block_comment(offset, text);
      }
    }
  #endif
<span class="udiff-line-modified-removed">-   return JVMCIEnv::ok;</span>
<span class="udiff-line-modified-added">+   return JVMCI::ok;</span>
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::assumption_NoFinalizableSubclass(Thread* thread, Handle assumption) {</span>
<span class="udiff-line-modified-removed">-   Handle receiverType_handle (thread, Assumptions_NoFinalizableSubclass::receiverType(assumption()));</span>
<span class="udiff-line-modified-removed">-   Klass* receiverType = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(receiverType_handle));</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::assumption_NoFinalizableSubclass(JVMCIObject assumption) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject receiverType_handle = jvmci_env()-&gt;get_Assumptions_NoFinalizableSubclass_receiverType(assumption);</span>
<span class="udiff-line-modified-added">+   Klass* receiverType = jvmci_env()-&gt;asKlass(receiverType_handle);</span>
    _dependencies-&gt;assert_has_no_finalizable_subclasses(receiverType);
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::assumption_ConcreteSubtype(Thread* thread, Handle assumption) {</span>
<span class="udiff-line-modified-removed">-   Handle context_handle (thread, Assumptions_ConcreteSubtype::context(assumption()));</span>
<span class="udiff-line-modified-removed">-   Handle subtype_handle (thread, Assumptions_ConcreteSubtype::subtype(assumption()));</span>
<span class="udiff-line-modified-removed">-   Klass* context = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(context_handle));</span>
<span class="udiff-line-modified-removed">-   Klass* subtype = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(subtype_handle));</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::assumption_ConcreteSubtype(JVMCIObject assumption) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject context_handle = jvmci_env()-&gt;get_Assumptions_ConcreteSubtype_context(assumption);</span>
<span class="udiff-line-modified-added">+   JVMCIObject subtype_handle = jvmci_env()-&gt;get_Assumptions_ConcreteSubtype_subtype(assumption);</span>
<span class="udiff-line-modified-added">+   Klass* context = jvmci_env()-&gt;asKlass(context_handle);</span>
<span class="udiff-line-modified-added">+   Klass* subtype = jvmci_env()-&gt;asKlass(subtype_handle);</span>
  
    assert(context-&gt;is_abstract(), &quot;&quot;);
    _dependencies-&gt;assert_abstract_with_unique_concrete_subtype(context, subtype);
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::assumption_LeafType(Thread* thread, Handle assumption) {</span>
<span class="udiff-line-modified-removed">-   Handle context_handle (thread, Assumptions_LeafType::context(assumption()));</span>
<span class="udiff-line-modified-removed">-   Klass* context = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(context_handle));</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::assumption_LeafType(JVMCIObject assumption) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject context_handle = jvmci_env()-&gt;get_Assumptions_LeafType_context(assumption);</span>
<span class="udiff-line-modified-added">+   Klass* context = jvmci_env()-&gt;asKlass(context_handle);</span>
  
    _dependencies-&gt;assert_leaf_type(context);
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::assumption_ConcreteMethod(Thread* thread, Handle assumption) {</span>
<span class="udiff-line-modified-removed">-   Handle impl_handle (thread, Assumptions_ConcreteMethod::impl(assumption()));</span>
<span class="udiff-line-modified-removed">-   Handle context_handle (thread, Assumptions_ConcreteMethod::context(assumption()));</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::assumption_ConcreteMethod(JVMCIObject assumption) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject impl_handle = jvmci_env()-&gt;get_Assumptions_ConcreteMethod_impl(assumption);</span>
<span class="udiff-line-modified-added">+   JVMCIObject context_handle = jvmci_env()-&gt;get_Assumptions_ConcreteMethod_context(assumption);</span>
  
<span class="udiff-line-modified-removed">-   methodHandle impl = getMethodFromHotSpotMethod(impl_handle());</span>
<span class="udiff-line-modified-removed">-   Klass* context = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(context_handle));</span>
<span class="udiff-line-modified-added">+   Method* impl = jvmci_env()-&gt;asMethod(impl_handle);</span>
<span class="udiff-line-modified-added">+   Klass* context = jvmci_env()-&gt;asKlass(context_handle);</span>
  
<span class="udiff-line-modified-removed">-   _dependencies-&gt;assert_unique_concrete_method(context, impl());</span>
<span class="udiff-line-modified-added">+   _dependencies-&gt;assert_unique_concrete_method(context, impl);</span>
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::assumption_CallSiteTargetValue(Thread* thread, Handle assumption) {</span>
<span class="udiff-line-modified-removed">-   Handle callSite(thread, HotSpotObjectConstantImpl::object(Assumptions_CallSiteTargetValue::callSite(assumption())));</span>
<span class="udiff-line-modified-removed">-   Handle methodHandle(thread, HotSpotObjectConstantImpl::object(Assumptions_CallSiteTargetValue::methodHandle(assumption())));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+ void CodeInstaller::assumption_CallSiteTargetValue(JVMCIObject assumption, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject callSiteConstant = jvmci_env()-&gt;get_Assumptions_CallSiteTargetValue_callSite(assumption);</span>
<span class="udiff-line-modified-added">+   Handle callSite = jvmci_env()-&gt;asConstant(callSiteConstant, JVMCI_CHECK);</span>
<span class="udiff-line-modified-added">+   JVMCIObject methodConstant = jvmci_env()-&gt;get_Assumptions_CallSiteTargetValue_methodHandle(assumption);</span>
<span class="udiff-line-added">+   Handle methodHandle = jvmci_env()-&gt;asConstant(methodConstant, JVMCI_CHECK);</span>
    _dependencies-&gt;assert_call_site_target_value(callSite(), methodHandle());
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::site_ExceptionHandler(jint pc_offset, Handle exc) {</span>
<span class="udiff-line-modified-removed">-   jint handler_offset = site_ExceptionHandler::handlerPos(exc);</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::site_ExceptionHandler(jint pc_offset, JVMCIObject exc) {</span>
<span class="udiff-line-modified-added">+   jint handler_offset = jvmci_env()-&gt;get_site_ExceptionHandler_handlerPos(exc);</span>
  
    // Subtable header
    _exception_handler_table.add_entry(HandlerTableEntry(1, pc_offset, 0));
  
    // Subtable entry
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1003,254 +978,259 @@</span>
        return true;
      }
    return true;
  }
  
<span class="udiff-line-modified-removed">- GrowableArray&lt;ScopeValue*&gt;* CodeInstaller::record_virtual_objects(Handle debug_info, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   objArrayHandle virtualObjects(THREAD, DebugInfo::virtualObjectMapping(debug_info));</span>
<span class="udiff-line-modified-added">+ GrowableArray&lt;ScopeValue*&gt;* CodeInstaller::record_virtual_objects(JVMCIObject debug_info, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObjectArray virtualObjects = jvmci_env()-&gt;get_DebugInfo_virtualObjectMapping(debug_info);</span>
    if (virtualObjects.is_null()) {
      return NULL;
    }
<span class="udiff-line-modified-removed">-   GrowableArray&lt;ScopeValue*&gt;* objects = new GrowableArray&lt;ScopeValue*&gt;(virtualObjects-&gt;length(), virtualObjects-&gt;length(), NULL);</span>
<span class="udiff-line-modified-added">+   GrowableArray&lt;ScopeValue*&gt;* objects = new GrowableArray&lt;ScopeValue*&gt;(JVMCIENV-&gt;get_length(virtualObjects), JVMCIENV-&gt;get_length(virtualObjects), NULL);</span>
    // Create the unique ObjectValues
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; virtualObjects-&gt;length(); i++) {</span>
<span class="udiff-line-modified-removed">-     HandleMark hm(THREAD);</span>
<span class="udiff-line-modified-removed">-     Handle value(THREAD, virtualObjects-&gt;obj_at(i));</span>
<span class="udiff-line-modified-removed">-     int id = VirtualObject::id(value);</span>
<span class="udiff-line-modified-removed">-     Handle type(THREAD, VirtualObject::type(value));</span>
<span class="udiff-line-modified-removed">-     oop javaMirror = HotSpotResolvedObjectTypeImpl::javaClass(type);</span>
<span class="udiff-line-modified-removed">-     ObjectValue* sv = new ObjectValue(id, new ConstantOopWriteValue(JNIHandles::make_local(Thread::current(), javaMirror)));</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(virtualObjects); i++) {</span>
<span class="udiff-line-modified-added">+     // HandleMark hm(THREAD);</span>
<span class="udiff-line-modified-added">+     JVMCIObject value = JVMCIENV-&gt;get_object_at(virtualObjects, i);</span>
<span class="udiff-line-modified-added">+     int id = jvmci_env()-&gt;get_VirtualObject_id(value);</span>
<span class="udiff-line-modified-added">+     JVMCIObject type = jvmci_env()-&gt;get_VirtualObject_type(value);</span>
<span class="udiff-line-modified-added">+     bool is_auto_box = jvmci_env()-&gt;get_VirtualObject_isAutoBox(value);</span>
<span class="udiff-line-modified-added">+     Klass* klass = jvmci_env()-&gt;asKlass(type);</span>
<span class="udiff-line-added">+     oop javaMirror = klass-&gt;java_mirror();</span>
<span class="udiff-line-added">+     ScopeValue *klass_sv = new ConstantOopWriteValue(JNIHandles::make_local(Thread::current(), javaMirror));</span>
<span class="udiff-line-added">+     ObjectValue* sv = is_auto_box ? new AutoBoxObjectValue(id, klass_sv) : new ObjectValue(id, klass_sv);</span>
      if (id &lt; 0 || id &gt;= objects-&gt;length()) {
        JVMCI_ERROR_NULL(&quot;virtual object id %d out of bounds&quot;, id);
      }
      if (objects-&gt;at(id) != NULL) {
        JVMCI_ERROR_NULL(&quot;duplicate virtual object id %d&quot;, id);
      }
      objects-&gt;at_put(id, sv);
    }
    // All the values which could be referenced by the VirtualObjects
    // exist, so now describe all the VirtualObjects themselves.
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; virtualObjects-&gt;length(); i++) {</span>
<span class="udiff-line-modified-removed">-     HandleMark hm(THREAD);</span>
<span class="udiff-line-modified-removed">-     Handle value(THREAD, virtualObjects-&gt;obj_at(i));</span>
<span class="udiff-line-modified-removed">-     int id = VirtualObject::id(value);</span>
<span class="udiff-line-modified-removed">-     record_object_value(objects-&gt;at(id)-&gt;as_ObjectValue(), value, objects, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(virtualObjects); i++) {</span>
<span class="udiff-line-modified-added">+     // HandleMark hm(THREAD);</span>
<span class="udiff-line-modified-added">+     JVMCIObject value = JVMCIENV-&gt;get_object_at(virtualObjects, i);</span>
<span class="udiff-line-modified-added">+     int id = jvmci_env()-&gt;get_VirtualObject_id(value);</span>
<span class="udiff-line-modified-added">+     record_object_value(objects-&gt;at(id)-&gt;as_ObjectValue(), value, objects, JVMCI_CHECK_NULL);</span>
    }
    _debug_recorder-&gt;dump_object_pool(objects);
    return objects;
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::record_scope(jint pc_offset, Handle debug_info, ScopeMode scope_mode, bool return_oop, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   Handle position(THREAD, DebugInfo::bytecodePosition(debug_info));</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::record_scope(jint pc_offset, JVMCIObject debug_info, ScopeMode scope_mode, bool return_oop, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject position = jvmci_env()-&gt;get_DebugInfo_bytecodePosition(debug_info);</span>
    if (position.is_null()) {
      // Stubs do not record scope info, just oop maps
      return;
    }
  
    GrowableArray&lt;ScopeValue*&gt;* objectMapping;
    if (scope_mode == CodeInstaller::FullFrame) {
<span class="udiff-line-modified-removed">-     objectMapping = record_virtual_objects(debug_info, CHECK);</span>
<span class="udiff-line-modified-added">+     objectMapping = record_virtual_objects(debug_info, JVMCI_CHECK);</span>
    } else {
      objectMapping = NULL;
    }
<span class="udiff-line-modified-removed">-   record_scope(pc_offset, position, scope_mode, objectMapping, return_oop, CHECK);</span>
<span class="udiff-line-modified-added">+   record_scope(pc_offset, position, scope_mode, objectMapping, return_oop, JVMCI_CHECK);</span>
  }
  
  int CodeInstaller::map_jvmci_bci(int bci) {
    if (bci &lt; 0) {
<span class="udiff-line-modified-removed">-     if (bci == BytecodeFrame::BEFORE_BCI()) {</span>
<span class="udiff-line-modified-added">+     if (bci == jvmci_env()-&gt;get_BytecodeFrame_BEFORE_BCI()) {</span>
        return BeforeBci;
<span class="udiff-line-modified-removed">-     } else if (bci == BytecodeFrame::AFTER_BCI()) {</span>
<span class="udiff-line-modified-added">+     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_AFTER_BCI()) {</span>
        return AfterBci;
<span class="udiff-line-modified-removed">-     } else if (bci == BytecodeFrame::UNWIND_BCI()) {</span>
<span class="udiff-line-modified-added">+     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_UNWIND_BCI()) {</span>
        return UnwindBci;
<span class="udiff-line-modified-removed">-     } else if (bci == BytecodeFrame::AFTER_EXCEPTION_BCI()) {</span>
<span class="udiff-line-modified-added">+     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_AFTER_EXCEPTION_BCI()) {</span>
        return AfterExceptionBci;
<span class="udiff-line-modified-removed">-     } else if (bci == BytecodeFrame::UNKNOWN_BCI()) {</span>
<span class="udiff-line-modified-added">+     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_UNKNOWN_BCI()) {</span>
        return UnknownBci;
<span class="udiff-line-modified-removed">-     } else if (bci == BytecodeFrame::INVALID_FRAMESTATE_BCI()) {</span>
<span class="udiff-line-modified-added">+     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_INVALID_FRAMESTATE_BCI()) {</span>
        return InvalidFrameStateBci;
      }
      ShouldNotReachHere();
    }
    return bci;
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::record_scope(jint pc_offset, Handle position, ScopeMode scope_mode, GrowableArray&lt;ScopeValue*&gt;* objects, bool return_oop, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   Handle frame;</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::record_scope(jint pc_offset, JVMCIObject position, ScopeMode scope_mode, GrowableArray&lt;ScopeValue*&gt;* objects, bool return_oop, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject frame;</span>
    if (scope_mode == CodeInstaller::FullFrame) {
<span class="udiff-line-modified-removed">-     if (!position-&gt;is_a(BytecodeFrame::klass())) {</span>
<span class="udiff-line-modified-added">+     if (!jvmci_env()-&gt;isa_BytecodeFrame(position)) {</span>
        JVMCI_ERROR(&quot;Full frame expected for debug info at %i&quot;, pc_offset);
      }
      frame = position;
    }
<span class="udiff-line-modified-removed">-   Handle caller_frame (THREAD, BytecodePosition::caller(position));</span>
<span class="udiff-line-modified-removed">-   if (caller_frame.not_null()) {</span>
<span class="udiff-line-modified-removed">-     record_scope(pc_offset, caller_frame, scope_mode, objects, return_oop, CHECK);</span>
<span class="udiff-line-modified-added">+   JVMCIObject caller_frame = jvmci_env()-&gt;get_BytecodePosition_caller(position);</span>
<span class="udiff-line-modified-added">+   if (caller_frame.is_non_null()) {</span>
<span class="udiff-line-modified-added">+     record_scope(pc_offset, caller_frame, scope_mode, objects, return_oop, JVMCI_CHECK);</span>
    }
  
<span class="udiff-line-modified-removed">-   Handle hotspot_method (THREAD, BytecodePosition::method(position));</span>
<span class="udiff-line-modified-removed">-   Method* method = getMethodFromHotSpotMethod(hotspot_method());</span>
<span class="udiff-line-modified-removed">-   jint bci = map_jvmci_bci(BytecodePosition::bci(position));</span>
<span class="udiff-line-modified-added">+   JVMCIObject hotspot_method = jvmci_env()-&gt;get_BytecodePosition_method(position);</span>
<span class="udiff-line-modified-added">+   Thread* thread = Thread::current();</span>
<span class="udiff-line-modified-added">+   methodHandle method(thread, jvmci_env()-&gt;asMethod(hotspot_method));</span>
<span class="udiff-line-added">+   jint bci = map_jvmci_bci(jvmci_env()-&gt;get_BytecodePosition_bci(position));</span>
<span class="udiff-line-added">+   if (bci == jvmci_env()-&gt;get_BytecodeFrame_BEFORE_BCI()) {</span>
<span class="udiff-line-added">+     bci = SynchronizationEntryBCI;</span>
<span class="udiff-line-added">+   }</span>
  
    TRACE_jvmci_2(&quot;Recording scope pc_offset=%d bci=%d method=%s&quot;, pc_offset, bci, method-&gt;name_and_sig_as_C_string());
  
    bool reexecute = false;
<span class="udiff-line-modified-removed">-   if (frame.not_null()) {</span>
<span class="udiff-line-modified-removed">-     if (bci &lt; 0) {</span>
<span class="udiff-line-modified-added">+   if (frame.is_non_null()) {</span>
<span class="udiff-line-modified-added">+     if (bci &lt; 0){</span>
         reexecute = false;
      } else {
<span class="udiff-line-modified-removed">-       Bytecodes::Code code = Bytecodes::java_code_at(method, method-&gt;bcp_from(bci));</span>
<span class="udiff-line-modified-added">+       Bytecodes::Code code = Bytecodes::java_code_at(method(), method-&gt;bcp_from(bci));</span>
        reexecute = bytecode_should_reexecute(code);
<span class="udiff-line-modified-removed">-       if (frame.not_null()) {</span>
<span class="udiff-line-modified-removed">-         reexecute = (BytecodeFrame::duringCall(frame) == JNI_FALSE);</span>
<span class="udiff-line-modified-added">+       if (frame.is_non_null()) {</span>
<span class="udiff-line-modified-added">+         reexecute = (jvmci_env()-&gt;get_BytecodeFrame_duringCall(frame) == JNI_FALSE);</span>
        }
      }
    }
  
    DebugToken* locals_token = NULL;
    DebugToken* expressions_token = NULL;
    DebugToken* monitors_token = NULL;
    bool throw_exception = false;
  
<span class="udiff-line-modified-removed">-   if (frame.not_null()) {</span>
<span class="udiff-line-modified-removed">-     jint local_count = BytecodeFrame::numLocals(frame);</span>
<span class="udiff-line-modified-removed">-     jint expression_count = BytecodeFrame::numStack(frame);</span>
<span class="udiff-line-modified-removed">-     jint monitor_count = BytecodeFrame::numLocks(frame);</span>
<span class="udiff-line-modified-removed">-     objArrayHandle values(THREAD, BytecodeFrame::values(frame));</span>
<span class="udiff-line-modified-removed">-     objArrayHandle slotKinds(THREAD, BytecodeFrame::slotKinds(frame));</span>
<span class="udiff-line-modified-added">+   if (frame.is_non_null()) {</span>
<span class="udiff-line-modified-added">+     jint local_count = jvmci_env()-&gt;get_BytecodeFrame_numLocals(frame);</span>
<span class="udiff-line-modified-added">+     jint expression_count = jvmci_env()-&gt;get_BytecodeFrame_numStack(frame);</span>
<span class="udiff-line-modified-added">+     jint monitor_count = jvmci_env()-&gt;get_BytecodeFrame_numLocks(frame);</span>
<span class="udiff-line-modified-added">+     JVMCIObjectArray values = jvmci_env()-&gt;get_BytecodeFrame_values(frame);</span>
<span class="udiff-line-modified-added">+     JVMCIObjectArray slotKinds = jvmci_env()-&gt;get_BytecodeFrame_slotKinds(frame);</span>
  
      if (values.is_null() || slotKinds.is_null()) {
<span class="udiff-line-modified-removed">-       THROW(vmSymbols::java_lang_NullPointerException());</span>
<span class="udiff-line-modified-added">+       JVMCI_THROW(NullPointerException);</span>
      }
<span class="udiff-line-modified-removed">-     if (local_count + expression_count + monitor_count != values-&gt;length()) {</span>
<span class="udiff-line-modified-removed">-       JVMCI_ERROR(&quot;unexpected values length %d in scope (%d locals, %d expressions, %d monitors)&quot;, values-&gt;length(), local_count, expression_count, monitor_count);</span>
<span class="udiff-line-modified-added">+     if (local_count + expression_count + monitor_count != JVMCIENV-&gt;get_length(values)) {</span>
<span class="udiff-line-modified-added">+       JVMCI_ERROR(&quot;unexpected values length %d in scope (%d locals, %d expressions, %d monitors)&quot;, JVMCIENV-&gt;get_length(values), local_count, expression_count, monitor_count);</span>
      }
<span class="udiff-line-modified-removed">-     if (local_count + expression_count != slotKinds-&gt;length()) {</span>
<span class="udiff-line-modified-removed">-       JVMCI_ERROR(&quot;unexpected slotKinds length %d in scope (%d locals, %d expressions)&quot;, slotKinds-&gt;length(), local_count, expression_count);</span>
<span class="udiff-line-modified-added">+     if (local_count + expression_count != JVMCIENV-&gt;get_length(slotKinds)) {</span>
<span class="udiff-line-modified-added">+       JVMCI_ERROR(&quot;unexpected slotKinds length %d in scope (%d locals, %d expressions)&quot;, JVMCIENV-&gt;get_length(slotKinds), local_count, expression_count);</span>
      }
  
      GrowableArray&lt;ScopeValue*&gt;* locals = local_count &gt; 0 ? new GrowableArray&lt;ScopeValue*&gt; (local_count) : NULL;
      GrowableArray&lt;ScopeValue*&gt;* expressions = expression_count &gt; 0 ? new GrowableArray&lt;ScopeValue*&gt; (expression_count) : NULL;
      GrowableArray&lt;MonitorValue*&gt;* monitors = monitor_count &gt; 0 ? new GrowableArray&lt;MonitorValue*&gt; (monitor_count) : NULL;
  
<span class="udiff-line-modified-removed">-     TRACE_jvmci_2(&quot;Scope at bci %d with %d values&quot;, bci, values-&gt;length());</span>
<span class="udiff-line-modified-added">+     TRACE_jvmci_2(&quot;Scope at bci %d with %d values&quot;, bci, JVMCIENV-&gt;get_length(values));</span>
      TRACE_jvmci_2(&quot;%d locals %d expressions, %d monitors&quot;, local_count, expression_count, monitor_count);
  
<span class="udiff-line-modified-removed">-     for (jint i = 0; i &lt; values-&gt;length(); i++) {</span>
<span class="udiff-line-modified-removed">-       HandleMark hm(THREAD);</span>
<span class="udiff-line-modified-added">+     for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(values); i++) {</span>
<span class="udiff-line-modified-added">+       // HandleMark hm(THREAD);</span>
        ScopeValue* second = NULL;
<span class="udiff-line-modified-removed">-       Handle value(THREAD, values-&gt;obj_at(i));</span>
<span class="udiff-line-modified-added">+       JVMCIObject value = JVMCIENV-&gt;get_object_at(values, i);</span>
        if (i &lt; local_count) {
<span class="udiff-line-modified-removed">-         BasicType type = JVMCIRuntime::kindToBasicType(Handle(THREAD, slotKinds-&gt;obj_at(i)), CHECK);</span>
<span class="udiff-line-modified-removed">-         ScopeValue* first = get_scope_value(value, type, objects, second, CHECK);</span>
<span class="udiff-line-modified-added">+         BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);</span>
<span class="udiff-line-modified-added">+         ScopeValue* first = get_scope_value(value, type, objects, second, JVMCI_CHECK);</span>
          if (second != NULL) {
            locals-&gt;append(second);
          }
          locals-&gt;append(first);
        } else if (i &lt; local_count + expression_count) {
<span class="udiff-line-modified-removed">-         BasicType type = JVMCIRuntime::kindToBasicType(Handle(THREAD, slotKinds-&gt;obj_at(i)), CHECK);</span>
<span class="udiff-line-modified-removed">-         ScopeValue* first = get_scope_value(value, type, objects, second, CHECK);</span>
<span class="udiff-line-modified-added">+         BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);</span>
<span class="udiff-line-modified-added">+         ScopeValue* first = get_scope_value(value, type, objects, second, JVMCI_CHECK);</span>
          if (second != NULL) {
            expressions-&gt;append(second);
          }
          expressions-&gt;append(first);
        } else {
<span class="udiff-line-modified-removed">-         MonitorValue *monitor = get_monitor_value(value, objects, CHECK);</span>
<span class="udiff-line-modified-added">+         MonitorValue *monitor = get_monitor_value(value, objects, JVMCI_CHECK);</span>
          monitors-&gt;append(monitor);
        }
        if (second != NULL) {
          i++;
<span class="udiff-line-modified-removed">-         if (i &gt;= values-&gt;length() || values-&gt;obj_at(i) != Value::ILLEGAL()) {</span>
<span class="udiff-line-modified-added">+         if (i &gt;= JVMCIENV-&gt;get_length(values) || !JVMCIENV-&gt;equals(JVMCIENV-&gt;get_object_at(values, i), jvmci_env()-&gt;get_Value_ILLEGAL())) {</span>
            JVMCI_ERROR(&quot;double-slot value not followed by Value.ILLEGAL&quot;);
          }
        }
      }
  
      locals_token = _debug_recorder-&gt;create_scope_values(locals);
      expressions_token = _debug_recorder-&gt;create_scope_values(expressions);
      monitors_token = _debug_recorder-&gt;create_monitor_values(monitors);
  
<span class="udiff-line-modified-removed">-     throw_exception = BytecodeFrame::rethrowException(frame) == JNI_TRUE;</span>
<span class="udiff-line-modified-added">+     throw_exception = jvmci_env()-&gt;get_BytecodeFrame_rethrowException(frame) == JNI_TRUE;</span>
    }
  
    _debug_recorder-&gt;describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, false, return_oop,
                                    locals_token, expressions_token, monitors_token);
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::site_Safepoint(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   Handle debug_info (THREAD, site_Infopoint::debugInfo(site));</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::site_Safepoint(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject debug_info = jvmci_env()-&gt;get_site_Infopoint_debugInfo(site);</span>
    if (debug_info.is_null()) {
      JVMCI_ERROR(&quot;debug info expected at safepoint at %i&quot;, pc_offset);
    }
  
    // address instruction = _instructions-&gt;start() + pc_offset;
    // jint next_pc_offset = Assembler::locate_next_instruction(instruction) - _instructions-&gt;start();
<span class="udiff-line-modified-removed">-   OopMap *map = create_oop_map(debug_info, CHECK);</span>
<span class="udiff-line-modified-added">+   OopMap *map = create_oop_map(debug_info, JVMCI_CHECK);</span>
    _debug_recorder-&gt;add_safepoint(pc_offset, map);
<span class="udiff-line-modified-removed">-   record_scope(pc_offset, debug_info, CodeInstaller::FullFrame, CHECK);</span>
<span class="udiff-line-modified-added">+   record_scope(pc_offset, debug_info, CodeInstaller::FullFrame, JVMCI_CHECK);</span>
    _debug_recorder-&gt;end_safepoint(pc_offset);
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::site_Infopoint(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   Handle debug_info (THREAD, site_Infopoint::debugInfo(site));</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::site_Infopoint(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject debug_info = jvmci_env()-&gt;get_site_Infopoint_debugInfo(site);</span>
    if (debug_info.is_null()) {
      JVMCI_ERROR(&quot;debug info expected at infopoint at %i&quot;, pc_offset);
    }
  
    // We&#39;d like to check that pc_offset is greater than the
    // last pc recorded with _debug_recorder (raising an exception if not)
    // but DebugInformationRecorder doesn&#39;t have sufficient public API.
  
    _debug_recorder-&gt;add_non_safepoint(pc_offset);
<span class="udiff-line-modified-removed">-   record_scope(pc_offset, debug_info, CodeInstaller::BytecodePosition, CHECK);</span>
<span class="udiff-line-modified-added">+   record_scope(pc_offset, debug_info, CodeInstaller::BytecodePosition, JVMCI_CHECK);</span>
    _debug_recorder-&gt;end_non_safepoint(pc_offset);
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::site_Call(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   Handle target(THREAD, site_Call::target(site));</span>
<span class="udiff-line-modified-removed">-   InstanceKlass* target_klass = InstanceKlass::cast(target-&gt;klass());</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   Handle hotspot_method; // JavaMethod</span>
<span class="udiff-line-removed">-   Handle foreign_call;</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::site_Call(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject target = jvmci_env()-&gt;get_site_Call_target(site);</span>
<span class="udiff-line-modified-added">+   JVMCIObject hotspot_method; // JavaMethod</span>
<span class="udiff-line-modified-added">+   JVMCIObject foreign_call;</span>
  
<span class="udiff-line-modified-removed">-   if (target_klass-&gt;is_subclass_of(SystemDictionary::HotSpotForeignCallTarget_klass())) {</span>
<span class="udiff-line-modified-added">+   if (jvmci_env()-&gt;isa_HotSpotForeignCallTarget(target)) {</span>
      foreign_call = target;
    } else {
      hotspot_method = target;
    }
  
<span class="udiff-line-modified-removed">-   Handle debug_info (THREAD, site_Call::debugInfo(site));</span>
<span class="udiff-line-modified-added">+   JVMCIObject debug_info = jvmci_env()-&gt;get_site_Infopoint_debugInfo(site);</span>
  
<span class="udiff-line-modified-removed">-   assert(hotspot_method.not_null() ^ foreign_call.not_null(), &quot;Call site needs exactly one type&quot;);</span>
<span class="udiff-line-modified-added">+   assert(hotspot_method.is_non_null() ^ foreign_call.is_non_null(), &quot;Call site needs exactly one type&quot;);</span>
  
    NativeInstruction* inst = nativeInstruction_at(_instructions-&gt;start() + pc_offset);
<span class="udiff-line-modified-removed">-   jint next_pc_offset = CodeInstaller::pd_next_offset(inst, pc_offset, hotspot_method, CHECK);</span>
<span class="udiff-line-modified-added">+   jint next_pc_offset = CodeInstaller::pd_next_offset(inst, pc_offset, hotspot_method, JVMCI_CHECK);</span>
  
<span class="udiff-line-modified-removed">-   if (debug_info.not_null()) {</span>
<span class="udiff-line-modified-removed">-     OopMap *map = create_oop_map(debug_info, CHECK);</span>
<span class="udiff-line-modified-added">+   if (debug_info.is_non_null()) {</span>
<span class="udiff-line-modified-added">+     OopMap *map = create_oop_map(debug_info, JVMCI_CHECK);</span>
      _debug_recorder-&gt;add_safepoint(next_pc_offset, map);
  
<span class="udiff-line-modified-removed">-     bool return_oop = hotspot_method.not_null() &amp;&amp; getMethodFromHotSpotMethod(hotspot_method())-&gt;is_returning_oop();</span>
<span class="udiff-line-modified-added">+     bool return_oop = hotspot_method.is_non_null() &amp;&amp; jvmci_env()-&gt;asMethod(hotspot_method)-&gt;is_returning_oop();</span>
  
<span class="udiff-line-modified-removed">-     record_scope(next_pc_offset, debug_info, CodeInstaller::FullFrame, return_oop, CHECK);</span>
<span class="udiff-line-modified-added">+     record_scope(next_pc_offset, debug_info, CodeInstaller::FullFrame, return_oop, JVMCI_CHECK);</span>
    }
  
<span class="udiff-line-modified-removed">-   if (foreign_call.not_null()) {</span>
<span class="udiff-line-modified-removed">-     jlong foreign_call_destination = HotSpotForeignCallTarget::address(foreign_call);</span>
<span class="udiff-line-modified-added">+   if (foreign_call.is_non_null()) {</span>
<span class="udiff-line-modified-added">+     jlong foreign_call_destination = jvmci_env()-&gt;get_HotSpotForeignCallTarget_address(foreign_call);</span>
      if (_immutable_pic_compilation) {
        // Use fake short distance during PIC compilation.
        foreign_call_destination = (jlong)(_instructions-&gt;start() + pc_offset);
      }
<span class="udiff-line-modified-removed">-     CodeInstaller::pd_relocate_ForeignCall(inst, foreign_call_destination, CHECK);</span>
<span class="udiff-line-modified-added">+     CodeInstaller::pd_relocate_ForeignCall(inst, foreign_call_destination, JVMCI_CHECK);</span>
    } else { // method != NULL
      if (debug_info.is_null()) {
        JVMCI_ERROR(&quot;debug info expected at call at %i&quot;, pc_offset);
      }
  
      TRACE_jvmci_3(&quot;method call&quot;);
<span class="udiff-line-modified-removed">-     CodeInstaller::pd_relocate_JavaMethod(buffer, hotspot_method, pc_offset, CHECK);</span>
<span class="udiff-line-modified-added">+     CodeInstaller::pd_relocate_JavaMethod(buffer, hotspot_method, pc_offset, JVMCI_CHECK);</span>
      if (_next_call_type == INVOKESTATIC || _next_call_type == INVOKESPECIAL) {
        // Need a static call stub for transitions from compiled to interpreted.
        CompiledStaticCall::emit_to_interp_stub(buffer, _instructions-&gt;start() + pc_offset);
      }
  #if INCLUDE_AOT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1259,61 +1239,71 @@</span>
  #endif
    }
  
    _next_call_type = INVOKE_INVALID;
  
<span class="udiff-line-modified-removed">-   if (debug_info.not_null()) {</span>
<span class="udiff-line-modified-added">+   if (debug_info.is_non_null()) {</span>
      _debug_recorder-&gt;end_safepoint(next_pc_offset);
    }
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::site_DataPatch(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   Handle reference(THREAD, site_DataPatch::reference(site));</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::site_DataPatch(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject reference = jvmci_env()-&gt;get_site_DataPatch_reference(site);</span>
    if (reference.is_null()) {
<span class="udiff-line-modified-removed">-     THROW(vmSymbols::java_lang_NullPointerException());</span>
<span class="udiff-line-modified-removed">-   } else if (reference-&gt;is_a(site_ConstantReference::klass())) {</span>
<span class="udiff-line-modified-removed">-     Handle constant(THREAD, site_ConstantReference::constant(reference));</span>
<span class="udiff-line-modified-added">+     JVMCI_THROW(NullPointerException);</span>
<span class="udiff-line-modified-added">+   } else if (jvmci_env()-&gt;isa_site_ConstantReference(reference)) {</span>
<span class="udiff-line-modified-added">+     JVMCIObject constant = jvmci_env()-&gt;get_site_ConstantReference_constant(reference);</span>
      if (constant.is_null()) {
<span class="udiff-line-modified-removed">-       THROW(vmSymbols::java_lang_NullPointerException());</span>
<span class="udiff-line-modified-removed">-     } else if (constant-&gt;is_a(HotSpotObjectConstantImpl::klass())) {</span>
<span class="udiff-line-modified-added">+       JVMCI_THROW(NullPointerException);</span>
<span class="udiff-line-modified-added">+     } else if (jvmci_env()-&gt;isa_DirectHotSpotObjectConstantImpl(constant)) {</span>
<span class="udiff-line-added">+       if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="udiff-line-added">+         JVMCIObject string = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_callToString(constant, JVMCI_CHECK);</span>
<span class="udiff-line-added">+         const char* to_string = JVMCIENV-&gt;as_utf8_string(string);</span>
<span class="udiff-line-added">+         JVMCI_THROW_MSG(IllegalArgumentException, err_msg(&quot;Direct object constant reached the backend: %s&quot;, to_string));</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (!_immutable_pic_compilation) {</span>
<span class="udiff-line-added">+         // Do not patch during PIC compilation.</span>
<span class="udiff-line-added">+         pd_patch_OopConstant(pc_offset, constant, JVMCI_CHECK);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else if (jvmci_env()-&gt;isa_IndirectHotSpotObjectConstantImpl(constant)) {</span>
        if (!_immutable_pic_compilation) {
          // Do not patch during PIC compilation.
<span class="udiff-line-modified-removed">-         pd_patch_OopConstant(pc_offset, constant, CHECK);</span>
<span class="udiff-line-modified-added">+         pd_patch_OopConstant(pc_offset, constant, JVMCI_CHECK);</span>
        }
<span class="udiff-line-modified-removed">-     } else if (constant-&gt;is_a(HotSpotMetaspaceConstantImpl::klass())) {</span>
<span class="udiff-line-modified-added">+     } else if (jvmci_env()-&gt;isa_HotSpotMetaspaceConstantImpl(constant)) {</span>
        if (!_immutable_pic_compilation) {
<span class="udiff-line-modified-removed">-         pd_patch_MetaspaceConstant(pc_offset, constant, CHECK);</span>
<span class="udiff-line-modified-added">+         pd_patch_MetaspaceConstant(pc_offset, constant, JVMCI_CHECK);</span>
        }
  #if INCLUDE_AOT
<span class="udiff-line-modified-removed">-     } else if (constant-&gt;is_a(HotSpotSentinelConstant::klass())) {</span>
<span class="udiff-line-modified-added">+     } else if (jvmci_env()-&gt;isa_HotSpotSentinelConstant(constant)) {</span>
        if (!_immutable_pic_compilation) {
<span class="udiff-line-modified-removed">-         JVMCI_ERROR(&quot;sentinel constant not supported for normal compiles: %s&quot;, constant-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+         JVMCI_ERROR(&quot;sentinel constant not supported for normal compiles: %s&quot;, jvmci_env()-&gt;klass_name(constant));</span>
        }
  #endif
      } else {
<span class="udiff-line-modified-removed">-       JVMCI_ERROR(&quot;unknown constant type in data patch: %s&quot;, constant-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+       JVMCI_ERROR(&quot;unknown constant type in data patch: %s&quot;, jvmci_env()-&gt;klass_name(constant));</span>
      }
<span class="udiff-line-modified-removed">-   } else if (reference-&gt;is_a(site_DataSectionReference::klass())) {</span>
<span class="udiff-line-modified-removed">-     int data_offset = site_DataSectionReference::offset(reference);</span>
<span class="udiff-line-modified-added">+   } else if (jvmci_env()-&gt;isa_site_DataSectionReference(reference)) {</span>
<span class="udiff-line-modified-added">+     int data_offset = jvmci_env()-&gt;get_site_DataSectionReference_offset(reference);</span>
      if (0 &lt;= data_offset &amp;&amp; data_offset &lt; _constants_size) {
<span class="udiff-line-modified-removed">-       pd_patch_DataSectionReference(pc_offset, data_offset, CHECK);</span>
<span class="udiff-line-modified-added">+       pd_patch_DataSectionReference(pc_offset, data_offset, JVMCI_CHECK);</span>
      } else {
        JVMCI_ERROR(&quot;data offset 0x%X points outside data section (size 0x%X)&quot;, data_offset, _constants_size);
      }
    } else {
<span class="udiff-line-modified-removed">-     JVMCI_ERROR(&quot;unknown data patch type: %s&quot;, reference-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+     JVMCI_ERROR(&quot;unknown data patch type: %s&quot;, jvmci_env()-&gt;klass_name(reference));</span>
    }
  }
  
<span class="udiff-line-modified-removed">- void CodeInstaller::site_Mark(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   Handle id_obj (THREAD, site_Mark::id(site));</span>
<span class="udiff-line-modified-added">+ void CodeInstaller::site_Mark(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {</span>
<span class="udiff-line-modified-added">+   JVMCIObject id_obj = jvmci_env()-&gt;get_site_Mark_id(site);</span>
  
<span class="udiff-line-modified-removed">-   if (id_obj.not_null()) {</span>
<span class="udiff-line-modified-removed">-     if (!java_lang_boxing_object::is_instance(id_obj(), T_INT)) {</span>
<span class="udiff-line-modified-removed">-       JVMCI_ERROR(&quot;expected Integer id, got %s&quot;, id_obj-&gt;klass()-&gt;signature_name());</span>
<span class="udiff-line-modified-added">+   if (id_obj.is_non_null()) {</span>
<span class="udiff-line-modified-added">+     if (!jvmci_env()-&gt;is_boxing_object(T_INT, id_obj)) {</span>
<span class="udiff-line-modified-added">+       JVMCI_ERROR(&quot;expected Integer id, got %s&quot;, jvmci_env()-&gt;klass_name(id_obj));</span>
      }
<span class="udiff-line-modified-removed">-     jint id = id_obj-&gt;int_field(java_lang_boxing_object::value_offset_in_bytes(T_INT));</span>
<span class="udiff-line-modified-added">+     jint id = jvmci_env()-&gt;get_boxed_value(T_INT, id_obj).i;</span>
  
      address pc = _instructions-&gt;start() + pc_offset;
  
      switch (id) {
        case UNVERIFIED_ENTRY:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1341,11 +1331,11 @@</span>
          break;
        case POLL_NEAR:
        case POLL_FAR:
        case POLL_RETURN_NEAR:
        case POLL_RETURN_FAR:
<span class="udiff-line-modified-removed">-         pd_relocate_poll(pc, id, CHECK);</span>
<span class="udiff-line-modified-added">+         pd_relocate_poll(pc, id, JVMCI_CHECK);</span>
          break;
        case CARD_TABLE_SHIFT:
        case CARD_TABLE_ADDRESS:
        case HEAP_TOP_ADDRESS:
        case HEAP_END_ADDRESS:
</pre>
<center><a href="compilerRuntime.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCodeInstaller.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/jvmci/compilerRuntime.cpp b/src/hotspot/share/jvmci/compilerRuntime.cpp
--- a/src/hotspot/share/jvmci/compilerRuntime.cpp
+++ b/src/hotspot/share/jvmci/compilerRuntime.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,15 +23,15 @@
 
 #include "precompiled.hpp"
 #include "aot/aotLoader.hpp"
 #include "classfile/stringTable.hpp"
 #include "classfile/symbolTable.hpp"
+#include "compiler/compilationPolicy.hpp"
 #include "interpreter/linkResolver.hpp"
 #include "jvmci/compilerRuntime.hpp"
 #include "oops/cpCache.inline.hpp"
 #include "oops/oop.inline.hpp"
-#include "runtime/compilationPolicy.hpp"
 #include "runtime/deoptimization.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/vframe.inline.hpp"
@@ -43,11 +43,11 @@
     oop str = *(oop*)string_result; // Is it resolved already?
     if (str == NULL) { // Do resolution
       // First 2 bytes of name contains length (number of bytes).
       int len = Bytes::get_Java_u2((address)name);
       name += 2;
-      TempNewSymbol sym = SymbolTable::new_symbol(name, len, CHECK);
+      TempNewSymbol sym = SymbolTable::new_symbol(name, len);
       str = StringTable::intern(sym, CHECK);
       assert(java_lang_String::is_instance(str), "must be string");
       *(oop*)string_result = str; // Store result
     }
     assert(str != NULL, "Should be allocated!");
@@ -70,17 +70,15 @@
 
   // Use class loader of aot method.
   Handle loader(THREAD, caller->method_holder()->class_loader());
   Handle protection_domain(THREAD, caller->method_holder()->protection_domain());
 
-  // Ignore wrapping L and ;
-  if (name[0] == 'L') {
-    assert(len > 2, "small name %s", name);
-    name++;
-    len -= 2;
+  TempNewSymbol sym = SymbolTable::new_symbol(name, len);
+  if (sym != NULL && Signature::has_envelope(sym)) {
+    // Ignore wrapping L and ;
+    sym = Signature::strip_envelope(sym);
   }
-  TempNewSymbol sym = SymbolTable::new_symbol(name, len, CHECK_NULL);
   if (sym == NULL) {
     return NULL;
   }
   Klass* k = SystemDictionary::resolve_or_fail(sym, loader, protection_domain, true, CHECK_NULL);
 
@@ -139,11 +137,11 @@
     Bytecode_invoke bytecode(caller, bci);
     int index = bytecode.index();
 
     // Make sure it's resolved first
     CallInfo callInfo;
-    constantPoolHandle cp(holder->constants());
+    constantPoolHandle cp(THREAD, holder->constants());
     ConstantPoolCacheEntry* cp_cache_entry = cp->cache()->entry_at(cp->decode_cpcache_index(index, true));
     Bytecodes::Code invoke_code = bytecode.invoke_code();
     if (!cp_cache_entry->is_resolved(invoke_code)) {
         LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, invoke_code, CHECK);
         if (bytecode.is_invokedynamic()) {
@@ -155,11 +153,11 @@
     }
 
     Handle appendix(THREAD, cp_cache_entry->appendix_if_resolved(cp));
     Klass *appendix_klass = appendix.is_null() ? NULL : appendix->klass();
 
-    methodHandle adapter_method(cp_cache_entry->f1_as_method());
+    methodHandle adapter_method(THREAD, cp_cache_entry->f1_as_method());
     InstanceKlass *adapter_klass = adapter_method->method_holder();
 
     if (appendix_klass != NULL && appendix_klass->is_instance_klass()) {
         vmassert(InstanceKlass::cast(appendix_klass)->is_initialized(), "sanity");
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jvmci/jvmciEnv.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciEnv.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciJavaClasses.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciEnv.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,136 ***</span>
   */
  
  #ifndef SHARE_JVMCI_JVMCIENV_HPP
  #define SHARE_JVMCI_JVMCIENV_HPP
  
<span class="line-modified">! #include &quot;classfile/systemDictionary.hpp&quot;</span>
<span class="line-modified">! #include &quot;code/debugInfoRec.hpp&quot;</span>
<span class="line-removed">- #include &quot;code/dependencies.hpp&quot;</span>
<span class="line-removed">- #include &quot;code/exceptionHandlerTable.hpp&quot;</span>
<span class="line-removed">- #include &quot;compiler/oopMap.hpp&quot;</span>
  #include &quot;runtime/thread.hpp&quot;
  
  class CompileTask;
<span class="line-modified">! </span>
<span class="line-modified">! // Bring the JVMCI compiler thread into the VM state.</span>
<span class="line-modified">! #define JVMCI_VM_ENTRY_MARK                       \</span>
<span class="line-modified">!   JavaThread* thread = JavaThread::current(); \</span>
<span class="line-modified">!   ThreadInVMfromNative __tiv(thread);       \</span>
<span class="line-removed">-   ResetNoHandleMark rnhm;                   \</span>
<span class="line-removed">-   HandleMarkCleaner __hm(thread);           \</span>
<span class="line-removed">-   Thread* THREAD = thread;                  \</span>
<span class="line-removed">-   debug_only(VMNativeEntryWrapper __vew;)</span>
  
  #define JVMCI_EXCEPTION_CONTEXT \
    JavaThread* thread=JavaThread::current(); \
    Thread* THREAD = thread;
  
<span class="line-modified">! //</span>
<span class="line-modified">! // This class is the top level broker for requests from the compiler</span>
<span class="line-modified">! // to the VM.</span>
<span class="line-modified">! class JVMCIEnv : StackObj {</span>
<span class="line-modified">!   CI_PACKAGE_ACCESS_TO</span>
  
<span class="line-modified">!   friend class JVMCIVMStructs;</span>
<span class="line-modified">!   friend class CompileBroker;</span>
<span class="line-modified">!   friend class Dependencies;  // for get_object, during logging</span>
  
<span class="line-modified">! public:</span>
  
<span class="line-modified">!   enum CodeInstallResult {</span>
<span class="line-modified">!      ok,</span>
<span class="line-modified">!      dependencies_failed,</span>
<span class="line-modified">!      dependencies_invalid,</span>
<span class="line-removed">-      cache_full,</span>
<span class="line-removed">-      code_too_large</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Look up a klass by name from a particular class loader (the accessor&#39;s).</span>
<span class="line-removed">-   // If require_local, result must be defined in that class loader, or NULL.</span>
<span class="line-removed">-   // If !require_local, a result from remote class loader may be reported,</span>
<span class="line-removed">-   // if sufficient class loader constraints exist such that initiating</span>
<span class="line-removed">-   // a class loading request from the given loader is bound to return</span>
<span class="line-removed">-   // the class defined in the remote loader (or throw an error).</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // Return an unloaded klass if !require_local and no class at all is found.</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // The CI treats a klass as loaded if it is consistently defined in</span>
<span class="line-removed">-   // another loader, even if it hasn&#39;t yet been loaded in all loaders</span>
<span class="line-removed">-   // that could potentially see it via delegation.</span>
<span class="line-removed">-   static Klass* get_klass_by_name(Klass* accessing_klass, Symbol* klass_name, bool require_local);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Constant pool access.</span>
<span class="line-removed">-   static Klass* get_klass_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-removed">-                                    int klass_index,</span>
<span class="line-removed">-                                    bool&amp; is_accessible,</span>
<span class="line-removed">-                                    Klass* loading_klass);</span>
<span class="line-removed">-   static void   get_field_by_index(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,</span>
<span class="line-removed">-                                    int field_index);</span>
<span class="line-removed">-   static methodHandle  get_method_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-removed">-                                     int method_index, Bytecodes::Code bc,</span>
<span class="line-removed">-                                     InstanceKlass* loading_klass);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   JVMCIEnv(CompileTask* task, int system_dictionary_modification_counter);</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   CompileTask*     _task;</span>
<span class="line-removed">-   int              _system_dictionary_modification_counter;</span>
  
<span class="line-modified">!   // Compilation result values</span>
<span class="line-modified">!   bool             _retryable;</span>
<span class="line-modified">!   const char*      _failure_reason;</span>
  
<span class="line-modified">!   // Specifies if _failure_reason is on the C heap.</span>
<span class="line-modified">!   bool             _failure_reason_on_C_heap;</span>
  
    // Cache JVMTI state. Defined as bytes so that reading them from Java
    // via Unsafe is well defined (the C++ type for bool is implementation
    // defined and may not be the same as a Java boolean).
    jbyte  _jvmti_can_hotswap_or_post_breakpoint;
    jbyte  _jvmti_can_access_local_variables;
    jbyte  _jvmti_can_post_on_exceptions;
    jbyte  _jvmti_can_pop_frame;
  
<span class="line-modified">!   // Implementation methods for loading and constant pool access.</span>
<span class="line-modified">!   static Klass* get_klass_by_name_impl(Klass* accessing_klass,</span>
<span class="line-modified">!                                   const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">!                                   Symbol* klass_name,</span>
<span class="line-modified">!                                   bool require_local);</span>
<span class="line-modified">!   static Klass* get_klass_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">!                                      int klass_index,</span>
<span class="line-modified">!                                      bool&amp; is_accessible,</span>
<span class="line-modified">!                                      Klass* loading_klass);</span>
<span class="line-modified">!   static void   get_field_by_index_impl(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,</span>
<span class="line-removed">-                                      int field_index);</span>
<span class="line-removed">-   static methodHandle  get_method_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-removed">-                                       int method_index, Bytecodes::Code bc,</span>
<span class="line-removed">-                                       InstanceKlass* loading_klass);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Helper methods</span>
<span class="line-removed">-   static bool       check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass);</span>
<span class="line-removed">-   static methodHandle  lookup_method(InstanceKlass*  accessor,</span>
<span class="line-removed">-                            Klass*         holder,</span>
<span class="line-removed">-                            Symbol*        name,</span>
<span class="line-removed">-                            Symbol*        sig,</span>
<span class="line-removed">-                            Bytecodes::Code bc,</span>
<span class="line-removed">-                            constantTag     tag);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   private:</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Is this thread currently in the VM state?</span>
<span class="line-removed">-   static bool is_in_vm();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Helper routine for determining the validity of a compilation</span>
<span class="line-removed">-   // with respect to concurrent class loading.</span>
<span class="line-removed">-   static JVMCIEnv::CodeInstallResult validate_compile_task_dependencies(Dependencies* target, Handle compiled_code,</span>
<span class="line-removed">-                                                                         JVMCIEnv* env, char** failure_detail);</span>
  
<span class="line-removed">- public:</span>
    CompileTask* task() { return _task; }
  
    bool  jvmti_state_changed() const;
    bool  jvmti_can_hotswap_or_post_breakpoint() const { return  _jvmti_can_hotswap_or_post_breakpoint != 0; }
    bool  jvmti_can_access_local_variables() const     { return  _jvmti_can_access_local_variables != 0; }
    bool  jvmti_can_post_on_exceptions() const         { return  _jvmti_can_post_on_exceptions != 0; }
    bool  jvmti_can_pop_frame() const                  { return  _jvmti_can_pop_frame != 0; }
  
<span class="line-new-header">--- 23,100 ---</span>
   */
  
  #ifndef SHARE_JVMCI_JVMCIENV_HPP
  #define SHARE_JVMCI_JVMCIENV_HPP
  
<span class="line-modified">! #include &quot;classfile/javaClasses.hpp&quot;</span>
<span class="line-modified">! #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
  #include &quot;runtime/thread.hpp&quot;
  
  class CompileTask;
<span class="line-modified">! class JVMCIObject;</span>
<span class="line-modified">! class JVMCIObjectArray;</span>
<span class="line-modified">! class JVMCIPrimitiveArray;</span>
<span class="line-modified">! class JVMCICompiler;</span>
<span class="line-modified">! class JVMCIRuntime;</span>
  
  #define JVMCI_EXCEPTION_CONTEXT \
    JavaThread* thread=JavaThread::current(); \
    Thread* THREAD = thread;
  
<span class="line-modified">! // Helper to log more context on a JNI exception</span>
<span class="line-modified">! #define JVMCI_EXCEPTION_CHECK(env, ...) \</span>
<span class="line-modified">!   do { \</span>
<span class="line-modified">!     if (env-&gt;ExceptionCheck()) { \</span>
<span class="line-modified">!       if (env != JavaThread::current()-&gt;jni_environment() &amp;&amp; JVMCIEnv::get_shared_library_path() != NULL) { \</span>
<span class="line-added">+         tty-&gt;print_cr(&quot;In JVMCI shared library (%s):&quot;, JVMCIEnv::get_shared_library_path()); \</span>
<span class="line-added">+       } \</span>
<span class="line-added">+       tty-&gt;print_cr(__VA_ARGS__); \</span>
<span class="line-added">+       return; \</span>
<span class="line-added">+     } \</span>
<span class="line-added">+   } while(0)</span>
  
<span class="line-modified">! // Helper class to ensure that references to Klass* are kept alive for G1</span>
<span class="line-modified">! class JVMCIKlassHandle : public StackObj {</span>
<span class="line-modified">!  private:</span>
<span class="line-added">+   Klass*     _klass;</span>
<span class="line-added">+   Handle     _holder;</span>
<span class="line-added">+   Thread*    _thread;</span>
  
<span class="line-modified">!   Klass*        klass() const                     { return _klass; }</span>
<span class="line-added">+   Klass*        non_null_klass() const            { assert(_klass != NULL, &quot;resolving NULL _klass&quot;); return _klass; }</span>
  
<span class="line-modified">!  public:</span>
<span class="line-modified">!   /* Constructors */</span>
<span class="line-modified">!   JVMCIKlassHandle (Thread* thread) : _klass(NULL), _thread(thread) {}</span>
<span class="line-modified">!   JVMCIKlassHandle (Thread* thread, Klass* klass);</span>
  
<span class="line-modified">!   JVMCIKlassHandle (const JVMCIKlassHandle &amp;h): _klass(h._klass), _holder(h._holder), _thread(h._thread) {}</span>
<span class="line-modified">!   JVMCIKlassHandle&amp; operator=(const JVMCIKlassHandle &amp;s);</span>
<span class="line-modified">!   JVMCIKlassHandle&amp; operator=(Klass* klass);</span>
  
<span class="line-modified">!   /* Operators for ease of use */</span>
<span class="line-modified">!   Klass*        operator () () const            { return klass(); }</span>
<span class="line-added">+   Klass*        operator -&gt; () const            { return non_null_klass(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool    operator == (Klass* o) const          { return klass() == o; }</span>
<span class="line-added">+   bool    operator == (const JVMCIKlassHandle&amp; h) const  { return klass() == h.klass(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Null checks */</span>
<span class="line-added">+   bool    is_null() const                      { return _klass == NULL; }</span>
<span class="line-added">+   bool    not_null() const                     { return _klass != NULL; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ // A class that maintains the state needed for compilations requested</span>
<span class="line-added">+ // by the CompileBroker.  It is created in the broker and passed through</span>
<span class="line-added">+ // into the code installation step.</span>
<span class="line-added">+ class JVMCICompileState : public ResourceObj {</span>
<span class="line-added">+   friend class JVMCIVMStructs;</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   CompileTask*     _task;</span>
  
    // Cache JVMTI state. Defined as bytes so that reading them from Java
    // via Unsafe is well defined (the C++ type for bool is implementation
    // defined and may not be the same as a Java boolean).
<span class="line-added">+   uint64_t _jvmti_redefinition_count;</span>
    jbyte  _jvmti_can_hotswap_or_post_breakpoint;
    jbyte  _jvmti_can_access_local_variables;
    jbyte  _jvmti_can_post_on_exceptions;
    jbyte  _jvmti_can_pop_frame;
  
<span class="line-modified">!   // Compilation result values.</span>
<span class="line-modified">!   bool             _retryable;</span>
<span class="line-modified">!   const char*      _failure_reason;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Specifies if _failure_reason is on the C heap. If so, it is allocated</span>
<span class="line-modified">!   // with the mtJVMCI NMT flag.</span>
<span class="line-modified">!   bool             _failure_reason_on_C_heap;</span>
<span class="line-modified">! </span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   JVMCICompileState(CompileTask* task);</span>
  
    CompileTask* task() { return _task; }
  
    bool  jvmti_state_changed() const;
<span class="line-added">+   uint64_t jvmti_redefinition_count() const          { return  _jvmti_redefinition_count; }</span>
    bool  jvmti_can_hotswap_or_post_breakpoint() const { return  _jvmti_can_hotswap_or_post_breakpoint != 0; }
    bool  jvmti_can_access_local_variables() const     { return  _jvmti_can_access_local_variables != 0; }
    bool  jvmti_can_post_on_exceptions() const         { return  _jvmti_can_post_on_exceptions != 0; }
    bool  jvmti_can_pop_frame() const                  { return  _jvmti_can_pop_frame != 0; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,36 ***</span>
    void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false) {
      _failure_reason = reason;
      _failure_reason_on_C_heap = reason_on_C_heap;
      _retryable = retryable;
    }
  
<span class="line-modified">!   // Register the result of a compilation.</span>
<span class="line-removed">-   static JVMCIEnv::CodeInstallResult register_method(</span>
<span class="line-removed">-                        const methodHandle&amp;       target,</span>
<span class="line-removed">-                        nmethod*&amp;                 nm,</span>
<span class="line-removed">-                        int                       entry_bci,</span>
<span class="line-removed">-                        CodeOffsets*              offsets,</span>
<span class="line-removed">-                        int                       orig_pc_offset,</span>
<span class="line-removed">-                        CodeBuffer*               code_buffer,</span>
<span class="line-removed">-                        int                       frame_words,</span>
<span class="line-removed">-                        OopMapSet*                oop_map_set,</span>
<span class="line-removed">-                        ExceptionHandlerTable*    handler_table,</span>
<span class="line-removed">-                        AbstractCompiler*         compiler,</span>
<span class="line-removed">-                        DebugInformationRecorder* debug_info,</span>
<span class="line-removed">-                        Dependencies*             dependencies,</span>
<span class="line-removed">-                        JVMCIEnv*                 env,</span>
<span class="line-removed">-                        int                       compile_id,</span>
<span class="line-removed">-                        bool                      has_unsafe_access,</span>
<span class="line-removed">-                        bool                      has_wide_vector,</span>
<span class="line-removed">-                        Handle                    installed_code,</span>
<span class="line-removed">-                        Handle                    compiled_code,</span>
<span class="line-removed">-                        Handle                    speculation_log);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // converts the Klass* representing the holder of a method into a</span>
<span class="line-removed">-   // InstanceKlass*.  This is needed since the holder of a method in</span>
<span class="line-removed">-   // the bytecodes could be an array type.  Basically this converts</span>
<span class="line-removed">-   // array types into java/lang/Object and other types stay as they are.</span>
<span class="line-removed">-   static InstanceKlass* get_instance_klass_for_declared_method_holder(Klass* klass);</span>
  };
  
  #endif // SHARE_JVMCI_JVMCIENV_HPP
<span class="line-new-header">--- 127,357 ---</span>
    void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false) {
      _failure_reason = reason;
      _failure_reason_on_C_heap = reason_on_C_heap;
      _retryable = retryable;
    }
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ // This class is a top level wrapper around interactions between HotSpot</span>
<span class="line-added">+ // and the JVMCI Java code.  It supports both a HotSpot heap based</span>
<span class="line-added">+ // runtime with HotSpot oop based accessors as well as a shared library</span>
<span class="line-added">+ // based runtime that is accessed through JNI. It abstracts away all</span>
<span class="line-added">+ // interactions with JVMCI objects so that a single version of the</span>
<span class="line-added">+ // HotSpot C++ code can can work with either runtime.</span>
<span class="line-added">+ class JVMCIEnv : public ResourceObj {</span>
<span class="line-added">+   friend class JNIAccessMark;</span>
<span class="line-added">+ </span>
<span class="line-added">+   static char*   _shared_library_path;   // argument to os:dll_load</span>
<span class="line-added">+   static void*   _shared_library_handle; // result of os::dll_load</span>
<span class="line-added">+   static JavaVM* _shared_library_javavm; // result of calling JNI_CreateJavaVM in shared library</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Initializes the shared library JavaVM if not already initialized.</span>
<span class="line-added">+   // Returns the JNI interface pointer for the current thread</span>
<span class="line-added">+   // if initialization was performed by this call, NULL if</span>
<span class="line-added">+   // initialization was performed by a previous call.</span>
<span class="line-added">+   static JNIEnv* init_shared_library(JavaThread* thread);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Initializes the _env, _mode and _runtime fields.</span>
<span class="line-added">+   void init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env);</span>
<span class="line-added">+ </span>
<span class="line-added">+   void init(JavaThread* thread, bool is_hotspot, const char* file, int line);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JNIEnv*                 _env;  // JNI env for calling into shared library</span>
<span class="line-added">+   bool     _pop_frame_on_close;  // Must pop frame on close?</span>
<span class="line-added">+   bool        _detach_on_close;  // Must detach on close?</span>
<span class="line-added">+   JVMCIRuntime*       _runtime;  // Access to a HotSpotJVMCIRuntime</span>
<span class="line-added">+   bool             _is_hotspot;  // Which heap is the HotSpotJVMCIRuntime in</span>
<span class="line-added">+   bool        _throw_to_caller;  // Propagate an exception raised in this env to the caller?</span>
<span class="line-added">+   const char*            _file;  // The file and ...</span>
<span class="line-added">+   int                    _line;  // ... line where this JNIEnv was created</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Translates an exception on the HotSpot heap to an exception on</span>
<span class="line-added">+   // the shared library heap. The translation includes the stack and</span>
<span class="line-added">+   // causes of `throwable`. The translated exception is pending in the</span>
<span class="line-added">+   // shared library thread upon returning.</span>
<span class="line-added">+   void translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable);</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   // Opens a JVMCIEnv scope for a Java to VM call (e.g., via CompilerToVM).</span>
<span class="line-added">+   // An exception occurring within the scope is left pending when the</span>
<span class="line-added">+   // scope closes so that it will be propagated back to Java.</span>
<span class="line-added">+   // The JVMCIEnv destructor translates the exception object for the</span>
<span class="line-added">+   // Java runtime if necessary.</span>
<span class="line-added">+   JVMCIEnv(JavaThread* thread, JNIEnv* env, const char* file, int line);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Opens a JVMCIEnv scope for a compilation scheduled by the CompileBroker.</span>
<span class="line-added">+   // An exception occurring within the scope must not be propagated back to</span>
<span class="line-added">+   // the CompileBroker.</span>
<span class="line-added">+   JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Opens a JNIEnv scope for a call from within the VM. An exception occurring</span>
<span class="line-added">+   // within the scope must not be propagated back to the caller.</span>
<span class="line-added">+   JVMCIEnv(JavaThread* env, const char* file, int line);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Opens a JNIEnv scope for accessing `for_object`. An exception occurring</span>
<span class="line-added">+   // within the scope must not be propagated back to the caller.</span>
<span class="line-added">+   JVMCIEnv(JavaThread* thread, JVMCIObject for_object, const char* file, int line) {</span>
<span class="line-added">+     // A JNI call to access an object in the shared library heap</span>
<span class="line-added">+     // can block or take a long time so do not allow such access</span>
<span class="line-added">+     // on the VM thread.</span>
<span class="line-added">+     assert(for_object.is_hotspot() || !Thread::current()-&gt;is_VM_thread(),</span>
<span class="line-added">+         &quot;cannot open JVMCIEnv scope when in the VM thread for accessing a shared library heap object&quot;);</span>
<span class="line-added">+     init(thread, for_object.is_hotspot(), file, line);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Opens a JNIEnv scope for the HotSpot runtime if `is_hotspot` is true</span>
<span class="line-added">+   // otherwise for the shared library runtime. An exception occurring</span>
<span class="line-added">+   // within the scope must not be propagated back to the caller.</span>
<span class="line-added">+   JVMCIEnv(JavaThread* thread, bool is_hotspot, const char* file, int line) {</span>
<span class="line-added">+     init(thread, is_hotspot, file, line);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~JVMCIEnv();</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIRuntime* runtime() {</span>
<span class="line-added">+     return _runtime;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Initializes Services.savedProperties in the shared library by copying</span>
<span class="line-added">+   // the values from the same field in the HotSpot heap.</span>
<span class="line-added">+   void copy_saved_properties();</span>
<span class="line-added">+ </span>
<span class="line-added">+   jboolean has_pending_exception();</span>
<span class="line-added">+   void clear_pending_exception();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Prints an exception and stack trace of a pending exception.</span>
<span class="line-added">+   void describe_pending_exception(bool clear);</span>
<span class="line-added">+ </span>
<span class="line-added">+   int get_length(JVMCIArray array);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject get_object_at(JVMCIObjectArray array, int index);</span>
<span class="line-added">+   void put_object_at(JVMCIObjectArray array, int index, JVMCIObject value);</span>
<span class="line-added">+ </span>
<span class="line-added">+   jboolean get_bool_at(JVMCIPrimitiveArray array, int index);</span>
<span class="line-added">+   void put_bool_at(JVMCIPrimitiveArray array, int index, jboolean value);</span>
<span class="line-added">+ </span>
<span class="line-added">+   jbyte get_byte_at(JVMCIPrimitiveArray array, int index);</span>
<span class="line-added">+   void put_byte_at(JVMCIPrimitiveArray array, int index, jbyte value);</span>
<span class="line-added">+ </span>
<span class="line-added">+   jint get_int_at(JVMCIPrimitiveArray array, int index);</span>
<span class="line-added">+   void put_int_at(JVMCIPrimitiveArray array, int index, jint value);</span>
<span class="line-added">+ </span>
<span class="line-added">+   long get_long_at(JVMCIPrimitiveArray array, int index);</span>
<span class="line-added">+   void put_long_at(JVMCIPrimitiveArray array, int index, jlong value);</span>
<span class="line-added">+ </span>
<span class="line-added">+   void copy_bytes_to(JVMCIPrimitiveArray src, jbyte* dest, int offset, jsize length);</span>
<span class="line-added">+   void copy_bytes_from(jbyte* src, JVMCIPrimitiveArray dest, int offset, jsize length);</span>
<span class="line-added">+ </span>
<span class="line-added">+   void copy_longs_from(jlong* src, JVMCIPrimitiveArray dest, int offset, jsize length);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObjectArray initialize_intrinsics(JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   jboolean is_boxing_object(BasicType type, JVMCIObject object);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Get the primitive value from a Java boxing object.  It&#39;s hard error to</span>
<span class="line-added">+   // pass a non-primitive BasicType.</span>
<span class="line-added">+   jvalue get_boxed_value(BasicType type, JVMCIObject object);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Return the BasicType of the object if it&#39;s a boxing object, otherwise return T_ILLEGAL.</span>
<span class="line-added">+   BasicType get_box_type(JVMCIObject object);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Create a boxing object of the appropriate primitive type.</span>
<span class="line-added">+   JVMCIObject create_box(BasicType type, jvalue* value, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   const char* as_utf8_string(JVMCIObject str);</span>
<span class="line-added">+   char* as_utf8_string(JVMCIObject str, char* buf, int buflen);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject create_string(Symbol* str, JVMCI_TRAPS) {</span>
<span class="line-added">+     return create_string(str-&gt;as_C_string(), JVMCI_CHECK_(JVMCIObject()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject create_string(const char* str, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool equals(JVMCIObject a, JVMCIObject b);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Convert into a JNI handle for the appropriate runtime</span>
<span class="line-added">+   jobject get_jobject(JVMCIObject object)                       { assert(object.as_jobject() == NULL || is_hotspot() == object.is_hotspot(), &quot;mismatch&quot;); return object.as_jobject(); }</span>
<span class="line-added">+   jarray get_jarray(JVMCIArray array)                           { assert(array.as_jobject() == NULL || is_hotspot() == array.is_hotspot(), &quot;mismatch&quot;); return array.as_jobject(); }</span>
<span class="line-added">+   jobjectArray get_jobjectArray(JVMCIObjectArray objectArray)   { assert(objectArray.as_jobject() == NULL || is_hotspot() == objectArray.is_hotspot(), &quot;mismatch&quot;); return objectArray.as_jobject(); }</span>
<span class="line-added">+   jbyteArray get_jbyteArray(JVMCIPrimitiveArray primitiveArray) { assert(primitiveArray.as_jobject() == NULL || is_hotspot() == primitiveArray.is_hotspot(), &quot;mismatch&quot;); return primitiveArray.as_jbyteArray(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject         wrap(jobject obj);</span>
<span class="line-added">+   JVMCIObjectArray    wrap(jobjectArray obj)  { return (JVMCIObjectArray)    wrap((jobject) obj); }</span>
<span class="line-added">+   JVMCIPrimitiveArray wrap(jintArray obj)     { return (JVMCIPrimitiveArray) wrap((jobject) obj); }</span>
<span class="line-added">+   JVMCIPrimitiveArray wrap(jbooleanArray obj) { return (JVMCIPrimitiveArray) wrap((jobject) obj); }</span>
<span class="line-added">+   JVMCIPrimitiveArray wrap(jbyteArray obj)    { return (JVMCIPrimitiveArray) wrap((jobject) obj); }</span>
<span class="line-added">+   JVMCIPrimitiveArray wrap(jlongArray obj)    { return (JVMCIPrimitiveArray) wrap((jobject) obj); }</span>
<span class="line-added">+ </span>
<span class="line-added">+  private:</span>
<span class="line-added">+   JVMCIObject wrap(oop obj)                  { assert(is_hotspot(), &quot;must be&quot;); return wrap(JNIHandles::make_local(obj)); }</span>
<span class="line-added">+   JVMCIObjectArray wrap(objArrayOop obj)     { assert(is_hotspot(), &quot;must be&quot;); return (JVMCIObjectArray) wrap(JNIHandles::make_local(obj)); }</span>
<span class="line-added">+   JVMCIPrimitiveArray wrap(typeArrayOop obj) { assert(is_hotspot(), &quot;must be&quot;); return (JVMCIPrimitiveArray) wrap(JNIHandles::make_local(obj)); }</span>
<span class="line-added">+ </span>
<span class="line-added">+  public:</span>
<span class="line-added">+   // Compiles a method with the JVMIC compiler.</span>
<span class="line-added">+   // Caller must handle pending exception.</span>
<span class="line-added">+   JVMCIObject call_HotSpotJVMCIRuntime_compileMethod(JVMCIObject runtime, JVMCIObject method, int entry_bci,</span>
<span class="line-added">+                                                      jlong compile_state, int id);</span>
<span class="line-added">+ </span>
<span class="line-added">+   void call_HotSpotJVMCIRuntime_bootstrapFinished(JVMCIObject runtime, JVMCI_TRAPS);</span>
<span class="line-added">+   void call_HotSpotJVMCIRuntime_shutdown(JVMCIObject runtime);</span>
<span class="line-added">+   JVMCIObject call_HotSpotJVMCIRuntime_runtime(JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject call_JVMCI_getRuntime(JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject call_HotSpotJVMCIRuntime_getCompiler(JVMCIObject runtime, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject call_JavaConstant_forFloat(float value, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject call_JavaConstant_forDouble(double value, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   BasicType kindToBasicType(JVMCIObject kind, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define DO_THROW(name) \</span>
<span class="line-added">+   void throw_##name(const char* msg = NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   DO_THROW(InternalError)</span>
<span class="line-added">+   DO_THROW(ArrayIndexOutOfBoundsException)</span>
<span class="line-added">+   DO_THROW(IllegalStateException)</span>
<span class="line-added">+   DO_THROW(NullPointerException)</span>
<span class="line-added">+   DO_THROW(IllegalArgumentException)</span>
<span class="line-added">+   DO_THROW(InvalidInstalledCodeException)</span>
<span class="line-added">+   DO_THROW(UnsatisfiedLinkError)</span>
<span class="line-added">+   DO_THROW(UnsupportedOperationException)</span>
<span class="line-added">+   DO_THROW(ClassNotFoundException)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef DO_THROW</span>
<span class="line-added">+ </span>
<span class="line-added">+   void fthrow_error(const char* file, int line, const char* format, ...) ATTRIBUTE_PRINTF(4, 5);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Given an instance of HotSpotInstalledCode return the corresponding CodeBlob*.  The</span>
<span class="line-added">+   // nmethodLocker is required to keep the CodeBlob alive in the case where it&#39;s an nmethod.</span>
<span class="line-added">+   CodeBlob* get_code_blob(JVMCIObject code, nmethodLocker&amp; locker);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Given an instance of HotSpotInstalledCode return the corresponding nmethod.  The</span>
<span class="line-added">+   // nmethodLocker is required to keep the nmethod alive.</span>
<span class="line-added">+   nmethod* get_nmethod(JVMCIObject code, nmethodLocker&amp; locker);</span>
<span class="line-added">+ </span>
<span class="line-added">+   MethodData* asMethodData(jlong metaspaceMethodData) {</span>
<span class="line-added">+     return (MethodData*) (address) metaspaceMethodData;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   const char* klass_name(JVMCIObject object);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Unpack an instance of HotSpotResolvedJavaMethodImpl into the original Method*</span>
<span class="line-added">+   Method* asMethod(JVMCIObject jvmci_method);</span>
<span class="line-added">+   Method* asMethod(jobject jvmci_method) { return asMethod(wrap(jvmci_method)); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Unpack an instance of HotSpotResolvedObjectTypeImpl into the original Klass*</span>
<span class="line-added">+   Klass* asKlass(JVMCIObject jvmci_type);</span>
<span class="line-added">+   Klass* asKlass(jobject jvmci_type)  { return asKlass(wrap(jvmci_type)); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Unpack an instance of HotSpotConstantPool into the original ConstantPool*</span>
<span class="line-added">+   ConstantPool* asConstantPool(JVMCIObject constant_pool);</span>
<span class="line-added">+   ConstantPool* asConstantPool(jobject constant_pool)  { return asConstantPool(wrap(constant_pool)); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject get_jvmci_primitive_type(BasicType type);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Handle asConstant(JVMCIObject object, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject get_object_constant(oop objOop, bool compressed = false, bool dont_register = false);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIPrimitiveArray new_booleanArray(int length, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIPrimitiveArray new_byteArray(int length, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIPrimitiveArray new_intArray(int length, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIPrimitiveArray new_longArray(int length, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObjectArray new_byte_array_array(int length, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject new_HotSpotNmethod(const methodHandle&amp; method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject new_HotSpotStackFrameReference(JVMCI_TRAPS);</span>
<span class="line-added">+   JVMCIObject new_JVMCIError(JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   jlong make_handle(const Handle&amp; obj);</span>
<span class="line-added">+   oop resolve_handle(jlong objectHandle);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // These are analagous to the JNI routines</span>
<span class="line-added">+   JVMCIObject make_local(JVMCIObject object);</span>
<span class="line-added">+   JVMCIObject make_global(JVMCIObject object);</span>
<span class="line-added">+   JVMCIObject make_weak(JVMCIObject object);</span>
<span class="line-added">+   void destroy_local(JVMCIObject object);</span>
<span class="line-added">+   void destroy_global(JVMCIObject object);</span>
<span class="line-added">+   void destroy_weak(JVMCIObject object);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Deoptimizes the nmethod (if any) in the HotSpotNmethod.address</span>
<span class="line-added">+   // field of mirror. The field is subsequently zeroed.</span>
<span class="line-added">+   void invalidate_nmethod_mirror(JVMCIObject mirror, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   void initialize_installed_code(JVMCIObject installed_code, CodeBlob* cb, JVMCI_TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+  private:</span>
<span class="line-added">+   JVMCICompileState* _compile_state;</span>
<span class="line-added">+ </span>
<span class="line-added">+  public:</span>
<span class="line-added">+   static JavaVM* get_shared_library_javavm() { return _shared_library_javavm; }</span>
<span class="line-added">+   static void* get_shared_library_handle()   { return _shared_library_handle; }</span>
<span class="line-added">+   static char* get_shared_library_path()     { return _shared_library_path; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Determines if this is for the JVMCI runtime in the HotSpot</span>
<span class="line-added">+   // heap (true) or the shared library heap (false).</span>
<span class="line-added">+   bool is_hotspot() { return _is_hotspot; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCICompileState* compile_state() { return _compile_state; }</span>
<span class="line-added">+   void set_compile_state(JVMCICompileState* compile_state) {</span>
<span class="line-added">+     assert(_compile_state == NULL, &quot;set only once&quot;);</span>
<span class="line-added">+     _compile_state = compile_state;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   // Generate declarations for the initialize, new, isa, get and set methods for all the types and</span>
<span class="line-added">+   // fields declared in the JVMCI_CLASSES_DO macro.</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define START_CLASS(className, fullClassName)                           \</span>
<span class="line-added">+   void className##_initialize(JVMCI_TRAPS); \</span>
<span class="line-added">+   JVMCIObjectArray new_##className##_array(int length, JVMCI_TRAPS); \</span>
<span class="line-added">+   bool isa_##className(JVMCIObject object);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define END_CLASS</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define FIELD(className, name, type, accessor)                                                                                                                         \</span>
<span class="line-added">+   type get_ ## className ## _ ## name(JVMCIObject obj); \</span>
<span class="line-added">+   void set_ ## className ## _ ## name(JVMCIObject obj, type x);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define OOPISH_FIELD(className, name, type, hstype, accessor) \</span>
<span class="line-added">+   FIELD(className, name, type, accessor)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STATIC_FIELD(className, name, type) \</span>
<span class="line-added">+   type get_ ## className ## _ ## name(); \</span>
<span class="line-added">+   void set_ ## className ## _ ## name(type x);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STATIC_OOPISH_FIELD(className, name, type, hstype) \</span>
<span class="line-added">+   STATIC_FIELD(className, name, type)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define EMPTY_CAST</span>
<span class="line-added">+ #define CHAR_FIELD(className,  name) FIELD(className, name, jchar, char_field)</span>
<span class="line-added">+ #define INT_FIELD(className,  name) FIELD(className, name, jint, int_field)</span>
<span class="line-added">+ #define BOOLEAN_FIELD(className,  name) FIELD(className, name, jboolean, bool_field)</span>
<span class="line-added">+ #define LONG_FIELD(className,  name) FIELD(className, name, jlong, long_field)</span>
<span class="line-added">+ #define FLOAT_FIELD(className,  name) FIELD(className, name, jfloat, float_field)</span>
<span class="line-added">+ #define OBJECT_FIELD(className,  name, signature) OOPISH_FIELD(className, name, JVMCIObject, oop, obj_field)</span>
<span class="line-added">+ #define OBJECTARRAY_FIELD(className,  name, signature) OOPISH_FIELD(className, name, JVMCIObjectArray, objArrayOop, obj_field)</span>
<span class="line-added">+ #define PRIMARRAY_FIELD(className,  name, signature) OOPISH_FIELD(className, name, JVMCIPrimitiveArray, typeArrayOop, obj_field)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STATIC_INT_FIELD(className, name) STATIC_FIELD(className, name, jint)</span>
<span class="line-added">+ #define STATIC_BOOLEAN_FIELD(className, name) STATIC_FIELD(className, name, jboolean)</span>
<span class="line-added">+ #define STATIC_OBJECT_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, JVMCIObject, oop)</span>
<span class="line-added">+ #define STATIC_OBJECTARRAY_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, objArrayOop)</span>
<span class="line-added">+ #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)</span>
<span class="line-added">+ #define CONSTRUCTOR(className, signature)</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef JNI_START_CLASS</span>
<span class="line-added">+ #undef START_CLASS</span>
<span class="line-added">+ #undef END_CLASS</span>
<span class="line-added">+ #undef METHOD</span>
<span class="line-added">+ #undef CONSTRUCTOR</span>
<span class="line-added">+ #undef FIELD</span>
<span class="line-added">+ #undef CHAR_FIELD</span>
<span class="line-added">+ #undef INT_FIELD</span>
<span class="line-added">+ #undef BOOLEAN_FIELD</span>
<span class="line-added">+ #undef LONG_FIELD</span>
<span class="line-added">+ #undef FLOAT_FIELD</span>
<span class="line-added">+ #undef OBJECT_FIELD</span>
<span class="line-added">+ #undef PRIMARRAY_FIELD</span>
<span class="line-added">+ #undef OBJECTARRAY_FIELD</span>
<span class="line-added">+ #undef FIELD</span>
<span class="line-added">+ #undef OOPISH_FIELD</span>
<span class="line-added">+ #undef STATIC_FIELD</span>
<span class="line-added">+ #undef STATIC_OOPISH_FIELD</span>
<span class="line-added">+ #undef STATIC_FIELD</span>
<span class="line-added">+ #undef STATIC_OBJECT_FIELD</span>
<span class="line-added">+ #undef STATIC_OBJECTARRAY_FIELD</span>
<span class="line-added">+ #undef STATIC_INT_FIELD</span>
<span class="line-added">+ #undef STATIC_BOOLEAN_FIELD</span>
<span class="line-added">+ #undef EMPTY_CAST</span>
  
<span class="line-modified">!   // End of JVMCIEnv</span>
  };
  
  #endif // SHARE_JVMCI_JVMCIENV_HPP
</pre>
<center><a href="jvmciEnv.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciJavaClasses.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jvmci/jvmciJavaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;classfile/symbolTable.hpp&quot;
 26 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;oops/oop.inline.hpp&quot;
 29 #include &quot;runtime/jniHandles.inline.hpp&quot;
 30 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 31 
 32 
 33 // This macro expands for non-inline functions, in class declarations.
 34 
 35 #define START_CLASS(name)                                                                                                                                \
 36     void name::check(oop obj, const char* field_name, int offset) {                                                                                          \
 37       assert(obj != NULL, &quot;NULL field access of %s.%s&quot;, #name, field_name);                                                                                  \
 38       assert(obj-&gt;is_a(SystemDictionary::name##_klass()), &quot;wrong class, &quot; #name &quot; expected, found %s&quot;, obj-&gt;klass()-&gt;external_name());                       \
 39       assert(offset != 0, &quot;must be valid offset&quot;);                                                                                                           \
 40     }
 41 
 42 #define END_CLASS
 43 
 44 #define FIELD(klass, name, type, accessor, cast)                                                                                                                                \
 45     type klass::name(jobject obj)               { check(JNIHandles::resolve(obj), #name, _##name##_offset); return cast JNIHandles::resolve(obj)-&gt;accessor(_##name##_offset); }     \
 46     void klass::set_##name(jobject obj, type x) { check(JNIHandles::resolve(obj), #name, _##name##_offset); JNIHandles::resolve(obj)-&gt;accessor##_put(_##name##_offset, x); }
 47 
 48 #define EMPTY_CAST
 49 #define CHAR_FIELD(klass, name) FIELD(klass, name, jchar, char_field, EMPTY_CAST)
 50 #define INT_FIELD(klass, name) FIELD(klass, name, jint, int_field, EMPTY_CAST)
 51 #define BOOLEAN_FIELD(klass, name) FIELD(klass, name, jboolean, bool_field, EMPTY_CAST)
 52 #define LONG_FIELD(klass, name) FIELD(klass, name, jlong, long_field, EMPTY_CAST)
 53 #define FLOAT_FIELD(klass, name) FIELD(klass, name, jfloat, float_field, EMPTY_CAST)
 54 #define OOP_FIELD(klass, name, signature) FIELD(klass, name, oop, obj_field, EMPTY_CAST)
 55 #define OBJARRAYOOP_FIELD(klass, name, signature) FIELD(klass, name, objArrayOop, obj_field, (objArrayOop))
 56 #define TYPEARRAYOOP_FIELD(klass, name, signature) FIELD(klass, name, typeArrayOop, obj_field, (typeArrayOop))
 57 #define STATIC_OOP_FIELD(klassName, name, signature) STATIC_OOPISH_FIELD(klassName, name, oop, signature)
 58 #define STATIC_OBJARRAYOOP_FIELD(klassName, name, signature) STATIC_OOPISH_FIELD(klassName, name, objArrayOop, signature)
 59 #define STATIC_OOPISH_FIELD(klassName, name, type, signature)                                                  \
 60     type klassName::name() {                                                                                   \
 61       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \
 62       InstanceKlass* ik = klassName::klass();                                                                  \
 63       oop base = ik-&gt;static_field_base_raw();                                                                  \
 64       oop result = HeapAccess&lt;&gt;::oop_load_at(base, _##name##_offset);                                          \
 65       return type(result);                                                                                     \
 66     }                                                                                                          \
 67     void klassName::set_##name(type x) {                                                                       \
 68       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \
 69       assert(klassName::klass() != NULL, &quot;Class not yet loaded: &quot; #klassName);                                 \
 70       InstanceKlass* ik = klassName::klass();                                                                  \
 71       oop base = ik-&gt;static_field_base_raw();                                                                  \
 72       HeapAccess&lt;&gt;::oop_store_at(base, _##name##_offset, x);                                                   \
 73     }
 74 #define STATIC_PRIMITIVE_FIELD(klassName, name, jtypename)                                                     \
 75     jtypename klassName::name() {                                                                              \
 76       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \
 77       InstanceKlass* ik = klassName::klass();                                                                  \
 78       oop base = ik-&gt;static_field_base_raw();                                                                  \
 79       return HeapAccess&lt;&gt;::load_at(base, _##name##_offset);                                                    \
 80     }                                                                                                          \
 81     void klassName::set_##name(jtypename x) {                                                                  \
 82       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \
 83       InstanceKlass* ik = klassName::klass();                                                                  \
 84       oop base = ik-&gt;static_field_base_raw();                                                                  \
 85       HeapAccess&lt;&gt;::store_at(base, _##name##_offset, x);                                                       \
 86     }
 87 
 88 #define STATIC_INT_FIELD(klassName, name) STATIC_PRIMITIVE_FIELD(klassName, name, jint)
 89 #define STATIC_BOOLEAN_FIELD(klassName, name) STATIC_PRIMITIVE_FIELD(klassName, name, jboolean)
 90 
 91 COMPILER_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OOP_FIELD, TYPEARRAYOOP_FIELD, OBJARRAYOOP_FIELD, STATIC_OOP_FIELD, STATIC_OBJARRAYOOP_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD)
 92 #undef START_CLASS
 93 #undef END_CLASS
 94 #undef FIELD
 95 #undef CHAR_FIELD
 96 #undef INT_FIELD
 97 #undef BOOLEAN_FIELD
 98 #undef LONG_FIELD
 99 #undef FLOAT_FIELD
100 #undef OOP_FIELD
101 #undef TYPEARRAYOOP_FIELD
102 #undef OBJARRAYOOP_FIELD
103 #undef STATIC_OOPISH_FIELD
104 #undef STATIC_OOP_FIELD
105 #undef STATIC_OBJARRAYOOP_FIELD
106 #undef STATIC_INT_FIELD
107 #undef STATIC_BOOLEAN_FIELD
108 #undef STATIC_PRIMITIVE_FIELD
109 #undef EMPTY_CAST
110 
111 // This function is similar to javaClasses.cpp, it computes the field offset of a (static or instance) field.
112 // It looks up the name and signature symbols without creating new ones, all the symbols of these classes need to be already loaded.
113 
114 void compute_offset(int &amp;dest_offset, Klass* klass, const char* name, const char* signature, bool static_field, TRAPS) {
115   InstanceKlass* ik = InstanceKlass::cast(klass);
116   Symbol* name_symbol = SymbolTable::probe(name, (int)strlen(name));
117   Symbol* signature_symbol = SymbolTable::probe(signature, (int)strlen(signature));
118   if (name_symbol == NULL || signature_symbol == NULL) {
119 #ifndef PRODUCT
120     ik-&gt;print_on(tty);
121 #endif
122     fatal(&quot;symbol with name %s and signature %s was not found in symbol table (klass=%s)&quot;, name, signature, klass-&gt;name()-&gt;as_C_string());
123   }
124 
125   fieldDescriptor fd;
126   if (!ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd)) {
127     ResourceMark rm;
128     fatal(&quot;Invalid layout of %s %s at %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string(), ik-&gt;external_name());
129   }
130   guarantee(fd.is_static() == static_field, &quot;static/instance mismatch&quot;);
131   dest_offset = fd.offset();
132   assert(dest_offset != 0, &quot;must be valid offset&quot;);
133   if (static_field) {
134     // Must ensure classes for static fields are initialized as the
135     // accessor itself does not include a class initialization check.
136     ik-&gt;initialize(CHECK);
137   }
138 }
139 
140 // This piece of macro magic creates the contents of the jvmci_compute_offsets method that initializes the field indices of all the access classes.
141 
142 #define START_CLASS(name) { Klass* k = SystemDictionary::name##_klass(); assert(k != NULL, &quot;Could not find class &quot; #name &quot;&quot;);
143 
144 #define END_CLASS }
145 
146 #define FIELD(klass, name, signature, static_field) compute_offset(klass::_##name##_offset, k, #name, signature, static_field, CHECK);
147 #define CHAR_FIELD(klass, name) FIELD(klass, name, &quot;C&quot;, false)
148 #define INT_FIELD(klass, name) FIELD(klass, name, &quot;I&quot;, false)
149 #define BOOLEAN_FIELD(klass, name) FIELD(klass, name, &quot;Z&quot;, false)
150 #define LONG_FIELD(klass, name) FIELD(klass, name, &quot;J&quot;, false)
151 #define FLOAT_FIELD(klass, name) FIELD(klass, name, &quot;F&quot;, false)
152 #define OOP_FIELD(klass, name, signature) FIELD(klass, name, signature, false)
153 #define STATIC_OOP_FIELD(klass, name, signature) FIELD(klass, name, signature, true)
154 #define STATIC_INT_FIELD(klass, name) FIELD(klass, name, &quot;I&quot;, true)
155 #define STATIC_BOOLEAN_FIELD(klass, name) FIELD(klass, name, &quot;Z&quot;, true)
156 
157 
158 void JVMCIJavaClasses::compute_offsets(TRAPS) {
159   COMPILER_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OOP_FIELD, OOP_FIELD, OOP_FIELD, STATIC_OOP_FIELD, STATIC_OOP_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD)
160 }
161 
162 #define EMPTY0
163 #define EMPTY1(x)
164 #define EMPTY2(x,y)
165 #define FIELD2(klass, name) int klass::_##name##_offset = 0;
166 #define FIELD3(klass, name, sig) FIELD2(klass, name)
167 
168 COMPILER_CLASSES_DO(EMPTY1, EMPTY0, FIELD2, FIELD2, FIELD2, FIELD2, FIELD2, FIELD3, FIELD3, FIELD3, FIELD3, FIELD3, FIELD2, FIELD2)
169 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciCodeInstaller.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compilerRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCodeInstaller.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCodeInstaller.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
<span class="line-removed">  25 #include &quot;asm/register.hpp&quot;</span>
<span class="line-removed">  26 #include &quot;classfile/vmSymbols.hpp&quot;</span>
  27 #include &quot;code/compiledIC.hpp&quot;
<span class="line-removed">  28 #include &quot;code/vmreg.inline.hpp&quot;</span>
  29 #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-removed">  30 #include &quot;compiler/disassembler.hpp&quot;</span>
<span class="line-removed">  31 #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
<span class="line-removed">  32 #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
  33 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
<span class="line-removed">  34 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
  35 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  36 #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="line-modified">  37 #include &quot;memory/allocation.inline.hpp&quot;</span>
<span class="line-modified">  38 #include &quot;oops/arrayOop.inline.hpp&quot;</span>
<span class="line-removed">  39 #include &quot;oops/oop.inline.hpp&quot;</span>
<span class="line-removed">  40 #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
<span class="line-removed">  41 #include &quot;oops/typeArrayOop.inline.hpp&quot;</span>
<span class="line-removed">  42 #include &quot;runtime/handles.inline.hpp&quot;</span>
  43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-removed">  44 #include &quot;runtime/javaCalls.hpp&quot;</span>
  45 #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-removed">  46 #include &quot;runtime/safepointMechanism.inline.hpp&quot;</span>
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;utilities/align.hpp&quot;
  49 
  50 // frequently used constants
  51 // Allocate them with new so they are never destroyed (otherwise, a
  52 // forced exit could destroy these objects while they are still in
  53 // use).
<span class="line-modified">  54 ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantOopWriteValue(NULL);</span>
<span class="line-modified">  55 ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(-1);</span>
<span class="line-modified">  56 ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue((jint)0);</span>
<span class="line-modified">  57 ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(1);</span>
<span class="line-modified">  58 ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(2);</span>
<span class="line-modified">  59 LocationValue*         CodeInstaller::_illegal_value = new (ResourceObj::C_HEAP, mtCompiler) LocationValue(Location());</span>
<span class="line-modified">  60 </span>
<span class="line-modified">  61 Method* getMethodFromHotSpotMethod(oop hotspot_method) {</span>
<span class="line-removed">  62   assert(hotspot_method != NULL &amp;&amp; hotspot_method-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()), &quot;sanity&quot;);</span>
<span class="line-removed">  63   return CompilerToVM::asMethod(hotspot_method);</span>
<span class="line-removed">  64 }</span>
<span class="line-removed">  65 </span>
<span class="line-removed">  66 VMReg getVMRegFromLocation(Handle location, int total_frame_size, TRAPS) {</span>
  67   if (location.is_null()) {
<span class="line-modified">  68     THROW_NULL(vmSymbols::java_lang_NullPointerException());</span>
  69   }
  70 
<span class="line-modified">  71   Handle reg(THREAD, code_Location::reg(location));</span>
<span class="line-modified">  72   jint offset = code_Location::offset(location);</span>
  73 
<span class="line-modified">  74   if (reg.not_null()) {</span>
  75     // register
<span class="line-modified">  76     jint number = code_Register::number(reg);</span>
<span class="line-modified">  77     VMReg vmReg = CodeInstaller::get_hotspot_reg(number, CHECK_NULL);</span>
  78     if (offset % 4 == 0) {
  79       return vmReg-&gt;next(offset / 4);
  80     } else {
  81       JVMCI_ERROR_NULL(&quot;unaligned subregister offset %d in oop map&quot;, offset);
  82     }
  83   } else {
  84     // stack slot
  85     if (offset % 4 == 0) {
  86       VMReg vmReg = VMRegImpl::stack2reg(offset / 4);
  87       if (!OopMapValue::legal_vm_reg_name(vmReg)) {
  88         // This restriction only applies to VMRegs that are used in OopMap but
  89         // since that&#39;s the only use of VMRegs it&#39;s simplest to put this test
  90         // here.  This test should also be equivalent legal_vm_reg_name but JVMCI
  91         // clients can use max_oop_map_stack_stack_offset to detect this problem
  92         // directly.  The asserts just ensure that the tests are in agreement.
  93         assert(offset &gt; CompilerToVM::Data::max_oop_map_stack_offset(), &quot;illegal VMReg&quot;);
  94         JVMCI_ERROR_NULL(&quot;stack offset %d is too large to be encoded in OopMap (max %d)&quot;,
  95                          offset, CompilerToVM::Data::max_oop_map_stack_offset());
  96       }
  97       assert(OopMapValue::legal_vm_reg_name(vmReg), &quot;illegal VMReg&quot;);
  98       return vmReg;
  99     } else {
 100       JVMCI_ERROR_NULL(&quot;unaligned stack offset %d in oop map&quot;, offset);
 101     }
 102   }
 103 }
 104 
<span class="line-removed"> 105 objArrayOop CodeInstaller::sites() {</span>
<span class="line-removed"> 106   return (objArrayOop) JNIHandles::resolve(_sites_handle);</span>
<span class="line-removed"> 107 }</span>
<span class="line-removed"> 108 </span>
<span class="line-removed"> 109 arrayOop CodeInstaller::code() {</span>
<span class="line-removed"> 110   return (arrayOop) JNIHandles::resolve(_code_handle);</span>
<span class="line-removed"> 111 }</span>
<span class="line-removed"> 112 </span>
<span class="line-removed"> 113 arrayOop CodeInstaller::data_section() {</span>
<span class="line-removed"> 114   return (arrayOop) JNIHandles::resolve(_data_section_handle);</span>
<span class="line-removed"> 115 }</span>
<span class="line-removed"> 116 </span>
<span class="line-removed"> 117 objArrayOop CodeInstaller::data_section_patches() {</span>
<span class="line-removed"> 118   return (objArrayOop) JNIHandles::resolve(_data_section_patches_handle);</span>
<span class="line-removed"> 119 }</span>
<span class="line-removed"> 120 </span>
<span class="line-removed"> 121 #ifndef PRODUCT</span>
<span class="line-removed"> 122 objArrayOop CodeInstaller::comments() {</span>
<span class="line-removed"> 123   return (objArrayOop) JNIHandles::resolve(_comments_handle);</span>
<span class="line-removed"> 124 }</span>
<span class="line-removed"> 125 #endif</span>
<span class="line-removed"> 126 </span>
<span class="line-removed"> 127 oop CodeInstaller::word_kind() {</span>
<span class="line-removed"> 128   return JNIHandles::resolve(_word_kind_handle);</span>
<span class="line-removed"> 129 }</span>
<span class="line-removed"> 130 </span>
 131 // creates a HotSpot oop map out of the byte arrays provided by DebugInfo
<span class="line-modified"> 132 OopMap* CodeInstaller::create_oop_map(Handle debug_info, TRAPS) {</span>
<span class="line-modified"> 133   Handle reference_map(THREAD, DebugInfo::referenceMap(debug_info));</span>
 134   if (reference_map.is_null()) {
<span class="line-modified"> 135     THROW_NULL(vmSymbols::java_lang_NullPointerException());</span>
 136   }
<span class="line-modified"> 137   if (!reference_map-&gt;is_a(HotSpotReferenceMap::klass())) {</span>
<span class="line-modified"> 138     JVMCI_ERROR_NULL(&quot;unknown reference map: %s&quot;, reference_map-&gt;klass()-&gt;signature_name());</span>
 139   }
<span class="line-modified"> 140   if (!_has_wide_vector &amp;&amp; SharedRuntime::is_wide_vector(HotSpotReferenceMap::maxRegisterSize(reference_map))) {</span>
 141     if (SharedRuntime::polling_page_vectors_safepoint_handler_blob() == NULL) {
 142       JVMCI_ERROR_NULL(&quot;JVMCI is producing code using vectors larger than the runtime supports&quot;);
 143     }
 144     _has_wide_vector = true;
 145   }
 146   OopMap* map = new OopMap(_total_frame_size, _parameter_count);
<span class="line-modified"> 147   objArrayHandle objects(THREAD, HotSpotReferenceMap::objects(reference_map));</span>
<span class="line-modified"> 148   objArrayHandle derivedBase(THREAD, HotSpotReferenceMap::derivedBase(reference_map));</span>
<span class="line-modified"> 149   typeArrayHandle sizeInBytes(THREAD, HotSpotReferenceMap::sizeInBytes(reference_map));</span>
 150   if (objects.is_null() || derivedBase.is_null() || sizeInBytes.is_null()) {
<span class="line-modified"> 151     THROW_NULL(vmSymbols::java_lang_NullPointerException());</span>
 152   }
<span class="line-modified"> 153   if (objects-&gt;length() != derivedBase-&gt;length() || objects-&gt;length() != sizeInBytes-&gt;length()) {</span>
<span class="line-modified"> 154     JVMCI_ERROR_NULL(&quot;arrays in reference map have different sizes: %d %d %d&quot;, objects-&gt;length(), derivedBase-&gt;length(), sizeInBytes-&gt;length());</span>
 155   }
<span class="line-modified"> 156   for (int i = 0; i &lt; objects-&gt;length(); i++) {</span>
<span class="line-modified"> 157     Handle location(THREAD, objects-&gt;obj_at(i));</span>
<span class="line-modified"> 158     Handle baseLocation(THREAD, derivedBase-&gt;obj_at(i));</span>
<span class="line-modified"> 159     int bytes = sizeInBytes-&gt;int_at(i);</span>
 160 
<span class="line-modified"> 161     VMReg vmReg = getVMRegFromLocation(location, _total_frame_size, CHECK_NULL);</span>
<span class="line-modified"> 162     if (baseLocation.not_null()) {</span>
 163       // derived oop
 164 #ifdef _LP64
 165       if (bytes == 8) {
 166 #else
 167       if (bytes == 4) {
 168 #endif
<span class="line-modified"> 169         VMReg baseReg = getVMRegFromLocation(baseLocation, _total_frame_size, CHECK_NULL);</span>
 170         map-&gt;set_derived_oop(vmReg, baseReg);
 171       } else {
 172         JVMCI_ERROR_NULL(&quot;invalid derived oop size in ReferenceMap: %d&quot;, bytes);
 173       }
 174 #ifdef _LP64
 175     } else if (bytes == 8) {
 176       // wide oop
 177       map-&gt;set_oop(vmReg);
 178     } else if (bytes == 4) {
 179       // narrow oop
 180       map-&gt;set_narrowoop(vmReg);
 181 #else
 182     } else if (bytes == 4) {
 183       map-&gt;set_oop(vmReg);
 184 #endif
 185     } else {
 186       JVMCI_ERROR_NULL(&quot;invalid oop size in ReferenceMap: %d&quot;, bytes);
 187     }
 188   }
 189 
<span class="line-modified"> 190   Handle callee_save_info(THREAD, (oop) DebugInfo::calleeSaveInfo(debug_info));</span>
<span class="line-modified"> 191   if (callee_save_info.not_null()) {</span>
<span class="line-modified"> 192     objArrayHandle registers(THREAD, RegisterSaveLayout::registers(callee_save_info));</span>
<span class="line-modified"> 193     typeArrayHandle slots(THREAD, RegisterSaveLayout::slots(callee_save_info));</span>
<span class="line-modified"> 194     for (jint i = 0; i &lt; slots-&gt;length(); i++) {</span>
<span class="line-modified"> 195       Handle jvmci_reg (THREAD, registers-&gt;obj_at(i));</span>
<span class="line-modified"> 196       jint jvmci_reg_number = code_Register::number(jvmci_reg);</span>
<span class="line-modified"> 197       VMReg hotspot_reg = CodeInstaller::get_hotspot_reg(jvmci_reg_number, CHECK_NULL);</span>
 198       // HotSpot stack slots are 4 bytes
<span class="line-modified"> 199       jint jvmci_slot = slots-&gt;int_at(i);</span>
 200       jint hotspot_slot = jvmci_slot * VMRegImpl::slots_per_word;
 201       VMReg hotspot_slot_as_reg = VMRegImpl::stack2reg(hotspot_slot);
 202       map-&gt;set_callee_saved(hotspot_slot_as_reg, hotspot_reg);
 203 #ifdef _LP64
 204       // (copied from generate_oop_map() in c1_Runtime1_x86.cpp)
 205       VMReg hotspot_slot_hi_as_reg = VMRegImpl::stack2reg(hotspot_slot + 1);
 206       map-&gt;set_callee_saved(hotspot_slot_hi_as_reg, hotspot_reg-&gt;next());
 207 #endif
 208     }
 209   }
 210   return map;
 211 }
 212 
 213 #if INCLUDE_AOT
<span class="line-modified"> 214 AOTOopRecorder::AOTOopRecorder(Arena* arena, bool deduplicate) : OopRecorder(arena, deduplicate) {</span>

 215   _meta_refs = new GrowableArray&lt;jobject&gt;();
 216 }
 217 
 218 int AOTOopRecorder::nr_meta_refs() const {
 219   return _meta_refs-&gt;length();
 220 }
 221 
 222 jobject AOTOopRecorder::meta_element(int pos) const {
 223   return _meta_refs-&gt;at(pos);
 224 }
 225 
 226 int AOTOopRecorder::find_index(Metadata* h) {
 227   JavaThread* THREAD = JavaThread::current();

 228   int oldCount = metadata_count();
 229   int index =  this-&gt;OopRecorder::find_index(h);
 230   int newCount = metadata_count();
 231 
 232   if (oldCount == newCount) {
 233     // found a match
 234     return index;
 235   }
 236 
 237   vmassert(index + 1 == newCount, &quot;must be last&quot;);
 238 
 239   JVMCIKlassHandle klass(THREAD);
<span class="line-modified"> 240   oop result = NULL;</span>
 241   guarantee(h != NULL,
 242             &quot;If DebugInformationRecorder::describe_scope passes NULL oldCount == newCount must hold.&quot;);
 243   if (h-&gt;is_klass()) {
 244     klass = (Klass*) h;
<span class="line-modified"> 245     result = CompilerToVM::get_jvmci_type(klass, CATCH);</span>
 246   } else if (h-&gt;is_method()) {
 247     Method* method = (Method*) h;
<span class="line-modified"> 248     methodHandle mh(method);</span>
<span class="line-modified"> 249     result = CompilerToVM::get_jvmci_method(method, CATCH);</span>
 250   }
<span class="line-modified"> 251   jobject ref = JNIHandles::make_local(THREAD, result);</span>
 252   record_meta_ref(ref, index);
 253 
 254   return index;
 255 }
 256 
 257 int AOTOopRecorder::find_index(jobject h) {
 258   if (h == NULL) {
 259     return 0;
 260   }
 261   oop javaMirror = JNIHandles::resolve(h);
 262   Klass* klass = java_lang_Class::as_Klass(javaMirror);
 263   return find_index(klass);
 264 }
 265 
 266 void AOTOopRecorder::record_meta_ref(jobject o, int index) {
 267   assert(index &gt; 0, &quot;must be 1..n&quot;);
 268   index -= 1; // reduce by one to convert to array index
 269 
 270   assert(index == _meta_refs-&gt;length(), &quot;must be last&quot;);
 271   _meta_refs-&gt;append(o);
 272 }
 273 #endif // INCLUDE_AOT
 274 
<span class="line-modified"> 275 void* CodeInstaller::record_metadata_reference(CodeSection* section, address dest, Handle constant, TRAPS) {</span>
 276   /*
 277    * This method needs to return a raw (untyped) pointer, since the value of a pointer to the base
 278    * class is in general not equal to the pointer of the subclass. When patching metaspace pointers,
 279    * the compiler expects a direct pointer to the subclass (Klass* or Method*), not a pointer to the
 280    * base class (Metadata* or MetaspaceObj*).
 281    */
<span class="line-modified"> 282   oop obj = HotSpotMetaspaceConstantImpl::metaspaceObject(constant);</span>
<span class="line-modified"> 283   if (obj-&gt;is_a(HotSpotResolvedObjectTypeImpl::klass())) {</span>
<span class="line-modified"> 284     Klass* klass = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(obj));</span>
<span class="line-modified"> 285     assert(!HotSpotMetaspaceConstantImpl::compressed(constant), &quot;unexpected compressed klass pointer %s @ &quot; INTPTR_FORMAT, klass-&gt;name()-&gt;as_C_string(), p2i(klass));</span>
 286     int index = _oop_recorder-&gt;find_index(klass);
 287     section-&gt;relocate(dest, metadata_Relocation::spec(index));
 288     TRACE_jvmci_3(&quot;metadata[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), klass-&gt;name()-&gt;as_C_string());
 289     return klass;
<span class="line-modified"> 290   } else if (obj-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass())) {</span>
<span class="line-modified"> 291     Method* method = (Method*) (address) HotSpotResolvedJavaMethodImpl::metaspaceMethod(obj);</span>
<span class="line-modified"> 292     assert(!HotSpotMetaspaceConstantImpl::compressed(constant), &quot;unexpected compressed method pointer %s @ &quot; INTPTR_FORMAT, method-&gt;name()-&gt;as_C_string(), p2i(method));</span>
 293     int index = _oop_recorder-&gt;find_index(method);
 294     section-&gt;relocate(dest, metadata_Relocation::spec(index));
 295     TRACE_jvmci_3(&quot;metadata[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), method-&gt;name()-&gt;as_C_string());
 296     return method;
 297   } else {
<span class="line-modified"> 298     JVMCI_ERROR_NULL(&quot;unexpected metadata reference for constant of type %s&quot;, obj-&gt;klass()-&gt;signature_name());</span>
 299   }
 300 }
 301 
 302 #ifdef _LP64
<span class="line-modified"> 303 narrowKlass CodeInstaller::record_narrow_metadata_reference(CodeSection* section, address dest, Handle constant, TRAPS) {</span>
<span class="line-modified"> 304   oop obj = HotSpotMetaspaceConstantImpl::metaspaceObject(constant);</span>
<span class="line-modified"> 305   assert(HotSpotMetaspaceConstantImpl::compressed(constant), &quot;unexpected uncompressed pointer&quot;);</span>
 306 
<span class="line-modified"> 307   if (!obj-&gt;is_a(HotSpotResolvedObjectTypeImpl::klass())) {</span>
<span class="line-modified"> 308     JVMCI_ERROR_0(&quot;unexpected compressed pointer of type %s&quot;, obj-&gt;klass()-&gt;signature_name());</span>
 309   }
 310 
<span class="line-modified"> 311   Klass* klass = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(obj));</span>
 312   int index = _oop_recorder-&gt;find_index(klass);
 313   section-&gt;relocate(dest, metadata_Relocation::spec(index));
 314   TRACE_jvmci_3(&quot;narrowKlass[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), klass-&gt;name()-&gt;as_C_string());
<span class="line-modified"> 315   return Klass::encode_klass(klass);</span>
 316 }
 317 #endif
 318 
<span class="line-modified"> 319 Location::Type CodeInstaller::get_oop_type(Thread* thread, Handle value) {</span>
<span class="line-modified"> 320   Handle valueKind(thread, Value::valueKind(value));</span>
<span class="line-modified"> 321   Handle platformKind(thread, ValueKind::platformKind(valueKind));</span>
 322 
<span class="line-modified"> 323   if (platformKind == word_kind()) {</span>
 324     return Location::oop;
 325   } else {
 326     return Location::narrowoop;
 327   }
 328 }
 329 
<span class="line-modified"> 330 ScopeValue* CodeInstaller::get_scope_value(Handle value, BasicType type, GrowableArray&lt;ScopeValue*&gt;* objects, ScopeValue* &amp;second, TRAPS) {</span>
 331   second = NULL;
 332   if (value.is_null()) {
<span class="line-modified"> 333     THROW_NULL(vmSymbols::java_lang_NullPointerException());</span>
<span class="line-modified"> 334   } else if (value == Value::ILLEGAL()) {</span>
 335     if (type != T_ILLEGAL) {
 336       JVMCI_ERROR_NULL(&quot;unexpected illegal value, expected %s&quot;, basictype_to_str(type));
 337     }
 338     return _illegal_value;
<span class="line-modified"> 339   } else if (value-&gt;is_a(RegisterValue::klass())) {</span>
<span class="line-modified"> 340     Handle reg(THREAD, RegisterValue::reg(value));</span>
<span class="line-modified"> 341     jint number = code_Register::number(reg);</span>
<span class="line-modified"> 342     VMReg hotspotRegister = get_hotspot_reg(number, CHECK_NULL);</span>
 343     if (is_general_purpose_reg(hotspotRegister)) {
 344       Location::Type locationType;
 345       if (type == T_OBJECT) {
<span class="line-modified"> 346         locationType = get_oop_type(THREAD, value);</span>
 347       } else if (type == T_LONG) {
 348         locationType = Location::lng;
 349       } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {
 350         locationType = Location::int_in_long;
 351       } else {
 352         JVMCI_ERROR_NULL(&quot;unexpected type %s in cpu register&quot;, basictype_to_str(type));
 353       }
 354       ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));
 355       if (type == T_LONG) {
 356         second = value;
 357       }
 358       return value;
 359     } else {
 360       Location::Type locationType;
 361       if (type == T_FLOAT) {
 362         // this seems weird, but the same value is used in c1_LinearScan
 363         locationType = Location::normal;
 364       } else if (type == T_DOUBLE) {
 365         locationType = Location::dbl;
 366       } else {
 367         JVMCI_ERROR_NULL(&quot;unexpected type %s in floating point register&quot;, basictype_to_str(type));
 368       }
 369       ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));
 370       if (type == T_DOUBLE) {
 371         second = value;
 372       }
 373       return value;
 374     }
<span class="line-modified"> 375   } else if (value-&gt;is_a(StackSlot::klass())) {</span>
<span class="line-modified"> 376     jint offset = StackSlot::offset(value);</span>
<span class="line-modified"> 377     if (StackSlot::addFrameSize(value)) {</span>
 378       offset += _total_frame_size;
 379     }
 380 
 381     Location::Type locationType;
 382     if (type == T_OBJECT) {
<span class="line-modified"> 383       locationType = get_oop_type(THREAD, value);</span>
 384     } else if (type == T_LONG) {
 385       locationType = Location::lng;
 386     } else if (type == T_DOUBLE) {
 387       locationType = Location::dbl;
 388     } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {
 389       locationType = Location::normal;
 390     } else {
 391       JVMCI_ERROR_NULL(&quot;unexpected type %s in stack slot&quot;, basictype_to_str(type));
 392     }
 393     ScopeValue* value = new LocationValue(Location::new_stk_loc(locationType, offset));
 394     if (type == T_DOUBLE || type == T_LONG) {
 395       second = value;
 396     }
 397     return value;
<span class="line-modified"> 398   } else if (value-&gt;is_a(JavaConstant::klass())) {</span>
<span class="line-modified"> 399     if (value-&gt;is_a(PrimitiveConstant::klass())) {</span>
<span class="line-modified"> 400       if (value-&gt;is_a(RawConstant::klass())) {</span>
<span class="line-modified"> 401         jlong prim = PrimitiveConstant::primitive(value);</span>
 402         return new ConstantLongValue(prim);
 403       } else {
<span class="line-modified"> 404         Handle primitive_constant_kind(THREAD, PrimitiveConstant::kind(value));</span>
<span class="line-removed"> 405         BasicType constantType = JVMCIRuntime::kindToBasicType(primitive_constant_kind, CHECK_NULL);</span>
 406         if (type != constantType) {
 407           JVMCI_ERROR_NULL(&quot;primitive constant type doesn&#39;t match, expected %s but got %s&quot;, basictype_to_str(type), basictype_to_str(constantType));
 408         }
 409         if (type == T_INT || type == T_FLOAT) {
<span class="line-modified"> 410           jint prim = (jint)PrimitiveConstant::primitive(value);</span>
 411           switch (prim) {
 412             case -1: return _int_m1_scope_value;
 413             case  0: return _int_0_scope_value;
 414             case  1: return _int_1_scope_value;
 415             case  2: return _int_2_scope_value;
 416             default: return new ConstantIntValue(prim);
 417           }
 418         } else if (type == T_LONG || type == T_DOUBLE) {
<span class="line-modified"> 419           jlong prim = PrimitiveConstant::primitive(value);</span>
 420           second = _int_1_scope_value;
 421           return new ConstantLongValue(prim);
 422         } else {
 423           JVMCI_ERROR_NULL(&quot;unexpected primitive constant type %s&quot;, basictype_to_str(type));
 424         }
 425       }
<span class="line-modified"> 426     } else if (value-&gt;is_a(NullConstant::klass()) || value-&gt;is_a(HotSpotCompressedNullConstant::klass())) {</span>
 427       if (type == T_OBJECT) {
 428         return _oop_null_scope_value;
 429       } else {
 430         JVMCI_ERROR_NULL(&quot;unexpected null constant, expected %s&quot;, basictype_to_str(type));
 431       }
<span class="line-modified"> 432     } else if (value-&gt;is_a(HotSpotObjectConstantImpl::klass())) {</span>
 433       if (type == T_OBJECT) {
<span class="line-modified"> 434         oop obj = HotSpotObjectConstantImpl::object(value);</span>
 435         if (obj == NULL) {
 436           JVMCI_ERROR_NULL(&quot;null value must be in NullConstant&quot;);
 437         }
<span class="line-modified"> 438         return new ConstantOopWriteValue(JNIHandles::make_local(obj));</span>
 439       } else {
 440         JVMCI_ERROR_NULL(&quot;unexpected object constant, expected %s&quot;, basictype_to_str(type));
 441       }
 442     }
<span class="line-modified"> 443   } else if (value-&gt;is_a(VirtualObject::klass())) {</span>
 444     if (type == T_OBJECT) {
<span class="line-modified"> 445       int id = VirtualObject::id(value);</span>
 446       if (0 &lt;= id &amp;&amp; id &lt; objects-&gt;length()) {
 447         ScopeValue* object = objects-&gt;at(id);
 448         if (object != NULL) {
 449           return object;
 450         }
 451       }
 452       JVMCI_ERROR_NULL(&quot;unknown virtual object id %d&quot;, id);
 453     } else {
 454       JVMCI_ERROR_NULL(&quot;unexpected virtual object, expected %s&quot;, basictype_to_str(type));
 455     }
 456   }
 457 
<span class="line-modified"> 458   JVMCI_ERROR_NULL(&quot;unexpected value in scope: %s&quot;, value-&gt;klass()-&gt;signature_name())</span>
 459 }
 460 
<span class="line-modified"> 461 void CodeInstaller::record_object_value(ObjectValue* sv, Handle value, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {</span>
<span class="line-modified"> 462   // Might want a HandleMark here.</span>
<span class="line-modified"> 463   Handle type(THREAD, VirtualObject::type(value));</span>
<span class="line-modified"> 464   int id = VirtualObject::id(value);</span>
<span class="line-removed"> 465   oop javaMirror = HotSpotResolvedObjectTypeImpl::javaClass(type);</span>
<span class="line-removed"> 466   Klass* klass = java_lang_Class::as_Klass(javaMirror);</span>
 467   bool isLongArray = klass == Universe::longArrayKlassObj();
 468 
<span class="line-modified"> 469   objArrayHandle values(THREAD, VirtualObject::values(value));</span>
<span class="line-modified"> 470   objArrayHandle slotKinds(THREAD, VirtualObject::slotKinds(value));</span>
<span class="line-modified"> 471   for (jint i = 0; i &lt; values-&gt;length(); i++) {</span>
<span class="line-removed"> 472     HandleMark hm(THREAD);</span>
 473     ScopeValue* cur_second = NULL;
<span class="line-modified"> 474     Handle object(THREAD, values-&gt;obj_at(i));</span>
<span class="line-modified"> 475     Handle slot_kind (THREAD, slotKinds-&gt;obj_at(i));</span>
<span class="line-modified"> 476     BasicType type = JVMCIRuntime::kindToBasicType(slot_kind, CHECK);</span>
<span class="line-removed"> 477     ScopeValue* value = get_scope_value(object, type, objects, cur_second, CHECK);</span>
 478 
 479     if (isLongArray &amp;&amp; cur_second == NULL) {
 480       // we&#39;re trying to put ints into a long array... this isn&#39;t really valid, but it&#39;s used for some optimizations.
 481       // add an int 0 constant
 482       cur_second = _int_0_scope_value;
 483     }
 484 
 485     if (cur_second != NULL) {
 486       sv-&gt;field_values()-&gt;append(cur_second);
 487     }
 488     assert(value != NULL, &quot;missing value&quot;);
 489     sv-&gt;field_values()-&gt;append(value);
 490   }
 491 }
 492 
<span class="line-modified"> 493 MonitorValue* CodeInstaller::get_monitor_value(Handle value, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {</span>
 494   if (value.is_null()) {
<span class="line-modified"> 495     THROW_NULL(vmSymbols::java_lang_NullPointerException());</span>
 496   }
<span class="line-modified"> 497   if (!value-&gt;is_a(StackLockValue::klass())) {</span>
<span class="line-modified"> 498     JVMCI_ERROR_NULL(&quot;Monitors must be of type StackLockValue, got %s&quot;, value-&gt;klass()-&gt;signature_name());</span>
 499   }
 500 
 501   ScopeValue* second = NULL;
<span class="line-modified"> 502   Handle stack_lock_owner(THREAD, StackLockValue::owner(value));</span>
<span class="line-removed"> 503   ScopeValue* owner_value = get_scope_value(stack_lock_owner, T_OBJECT, objects, second, CHECK_NULL);</span>
 504   assert(second == NULL, &quot;monitor cannot occupy two stack slots&quot;);
 505 
<span class="line-modified"> 506   Handle stack_lock_slot(THREAD, StackLockValue::slot(value));</span>
<span class="line-removed"> 507   ScopeValue* lock_data_value = get_scope_value(stack_lock_slot, T_LONG, objects, second, CHECK_NULL);</span>
 508   assert(second == lock_data_value, &quot;monitor is LONG value that occupies two stack slots&quot;);
 509   assert(lock_data_value-&gt;is_location(), &quot;invalid monitor location&quot;);
 510   Location lock_data_loc = ((LocationValue*)lock_data_value)-&gt;location();
 511 
 512   bool eliminated = false;
<span class="line-modified"> 513   if (StackLockValue::eliminated(value)) {</span>
 514     eliminated = true;
 515   }
 516 
 517   return new MonitorValue(owner_value, lock_data_loc, eliminated);
 518 }
 519 
<span class="line-modified"> 520 void CodeInstaller::initialize_dependencies(oop compiled_code, OopRecorder* recorder, TRAPS) {</span>
 521   JavaThread* thread = JavaThread::current();
<span class="line-removed"> 522   assert(THREAD == thread, &quot;&quot;);</span>
 523   CompilerThread* compilerThread = thread-&gt;is_Compiler_thread() ? thread-&gt;as_CompilerThread() : NULL;
<span class="line-modified"> 524   _oop_recorder = recorder;</span>
 525   _dependencies = new Dependencies(&amp;_arena, _oop_recorder, compilerThread != NULL ? compilerThread-&gt;log() : NULL);
<span class="line-modified"> 526   objArrayHandle assumptions(THREAD, HotSpotCompiledCode::assumptions(compiled_code));</span>
<span class="line-modified"> 527   if (!assumptions.is_null()) {</span>
<span class="line-modified"> 528     int length = assumptions-&gt;length();</span>
 529     for (int i = 0; i &lt; length; ++i) {
<span class="line-modified"> 530       Handle assumption(THREAD, assumptions-&gt;obj_at(i));</span>
<span class="line-modified"> 531       if (!assumption.is_null()) {</span>
<span class="line-modified"> 532         if (assumption-&gt;klass() == Assumptions_NoFinalizableSubclass::klass()) {</span>
<span class="line-modified"> 533           assumption_NoFinalizableSubclass(THREAD, assumption);</span>
<span class="line-modified"> 534         } else if (assumption-&gt;klass() == Assumptions_ConcreteSubtype::klass()) {</span>
<span class="line-modified"> 535           assumption_ConcreteSubtype(THREAD, assumption);</span>
<span class="line-modified"> 536         } else if (assumption-&gt;klass() == Assumptions_LeafType::klass()) {</span>
<span class="line-modified"> 537           assumption_LeafType(THREAD, assumption);</span>
<span class="line-modified"> 538         } else if (assumption-&gt;klass() == Assumptions_ConcreteMethod::klass()) {</span>
<span class="line-modified"> 539           assumption_ConcreteMethod(THREAD, assumption);</span>
<span class="line-modified"> 540         } else if (assumption-&gt;klass() == Assumptions_CallSiteTargetValue::klass()) {</span>
<span class="line-modified"> 541           assumption_CallSiteTargetValue(THREAD, assumption);</span>
 542         } else {
<span class="line-modified"> 543           JVMCI_ERROR(&quot;unexpected Assumption subclass %s&quot;, assumption-&gt;klass()-&gt;signature_name());</span>
 544         }
 545       }
 546     }
 547   }
 548   if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
<span class="line-modified"> 549     objArrayHandle methods(THREAD, HotSpotCompiledCode::methods(compiled_code));</span>
<span class="line-modified"> 550     if (!methods.is_null()) {</span>
<span class="line-modified"> 551       int length = methods-&gt;length();</span>
 552       for (int i = 0; i &lt; length; ++i) {
<span class="line-modified"> 553         Handle method_handle(THREAD, methods-&gt;obj_at(i));</span>
<span class="line-modified"> 554         methodHandle method = getMethodFromHotSpotMethod(method_handle());</span>
<span class="line-modified"> 555         _dependencies-&gt;assert_evol_method(method());</span>
 556       }
 557     }
 558   }
 559 }
 560 
 561 #if INCLUDE_AOT
 562 RelocBuffer::~RelocBuffer() {
<span class="line-modified"> 563   if (_buffer != NULL) {</span>
<span class="line-removed"> 564     FREE_C_HEAP_ARRAY(char, _buffer);</span>
<span class="line-removed"> 565   }</span>
 566 }
 567 
 568 address RelocBuffer::begin() const {
 569   if (_buffer != NULL) {
 570     return (address) _buffer;
 571   }
 572   return (address) _static_buffer;
 573 }
 574 
 575 void RelocBuffer::set_size(size_t bytes) {
 576   assert(bytes &lt;= _size, &quot;can&#39;t grow in size!&quot;);
 577   _size = bytes;
 578 }
 579 
 580 void RelocBuffer::ensure_size(size_t bytes) {
 581   assert(_buffer == NULL, &quot;can only be used once&quot;);
 582   assert(_size == 0, &quot;can only be used once&quot;);
 583   if (bytes &gt;= RelocBuffer::stack_size) {
<span class="line-modified"> 584     _buffer = NEW_C_HEAP_ARRAY(char, bytes, mtInternal);</span>
 585   }
 586   _size = bytes;
 587 }
 588 
<span class="line-modified"> 589 JVMCIEnv::CodeInstallResult CodeInstaller::gather_metadata(Handle target, Handle compiled_code, CodeMetadata&amp; metadata, TRAPS) {</span>

 590   CodeBuffer buffer(&quot;JVMCI Compiler CodeBuffer for Metadata&quot;);
<span class="line-modified"> 591   jobject compiled_code_obj = JNIHandles::make_local(compiled_code());</span>
<span class="line-modified"> 592   AOTOopRecorder* recorder = new AOTOopRecorder(&amp;_arena, true);</span>
<span class="line-removed"> 593   initialize_dependencies(JNIHandles::resolve(compiled_code_obj), recorder, CHECK_OK);</span>
 594 
 595   metadata.set_oop_recorder(recorder);
 596 
 597   // Get instructions and constants CodeSections early because we need it.
 598   _instructions = buffer.insts();
 599   _constants = buffer.consts();
 600   buffer.set_immutable_PIC(_immutable_pic_compilation);
 601 
<span class="line-modified"> 602   initialize_fields(target(), JNIHandles::resolve(compiled_code_obj), CHECK_OK);</span>
<span class="line-modified"> 603   JVMCIEnv::CodeInstallResult result = initialize_buffer(buffer, false, CHECK_OK);</span>
<span class="line-modified"> 604   if (result != JVMCIEnv::ok) {</span>
 605     return result;
 606   }
 607 
 608   _debug_recorder-&gt;pcs_size(); // create the sentinel record
 609 
 610   assert(_debug_recorder-&gt;pcs_length() &gt;= 2, &quot;must be at least 2&quot;);
 611 
 612   metadata.set_pc_desc(_debug_recorder-&gt;pcs(), _debug_recorder-&gt;pcs_length());
 613   metadata.set_scopes(_debug_recorder-&gt;stream()-&gt;buffer(), _debug_recorder-&gt;data_size());
 614   metadata.set_exception_table(&amp;_exception_handler_table);

 615 
 616   RelocBuffer* reloc_buffer = metadata.get_reloc_buffer();
 617 
 618   reloc_buffer-&gt;ensure_size(buffer.total_relocation_size());
 619   size_t size = (size_t) buffer.copy_relocations_to(reloc_buffer-&gt;begin(), (CodeBuffer::csize_t) reloc_buffer-&gt;size(), true);
 620   reloc_buffer-&gt;set_size(size);
<span class="line-modified"> 621   return JVMCIEnv::ok;</span>
 622 }
 623 #endif // INCLUDE_AOT
 624 
 625 // constructor used to create a method
<span class="line-modified"> 626 JVMCIEnv::CodeInstallResult CodeInstaller::install(JVMCICompiler* compiler, Handle target, Handle compiled_code, CodeBlob*&amp; cb, Handle installed_code, Handle speculation_log, TRAPS) {</span>









 627   CodeBuffer buffer(&quot;JVMCI Compiler CodeBuffer&quot;);
<span class="line-removed"> 628   jobject compiled_code_obj = JNIHandles::make_local(compiled_code());</span>
 629   OopRecorder* recorder = new OopRecorder(&amp;_arena, true);
<span class="line-modified"> 630   initialize_dependencies(JNIHandles::resolve(compiled_code_obj), recorder, CHECK_OK);</span>
 631 
 632   // Get instructions and constants CodeSections early because we need it.
 633   _instructions = buffer.insts();
 634   _constants = buffer.consts();
 635 #if INCLUDE_AOT
 636   buffer.set_immutable_PIC(_immutable_pic_compilation);
 637 #endif
 638 
<span class="line-modified"> 639   initialize_fields(target(), JNIHandles::resolve(compiled_code_obj), CHECK_OK);</span>
<span class="line-modified"> 640   JVMCIEnv::CodeInstallResult result = initialize_buffer(buffer, true, CHECK_OK);</span>
<span class="line-modified"> 641   if (result != JVMCIEnv::ok) {</span>
 642     return result;
 643   }
 644 
 645   int stack_slots = _total_frame_size / HeapWordSize; // conversion to words
 646 
<span class="line-modified"> 647   if (!compiled_code-&gt;is_a(HotSpotCompiledNmethod::klass())) {</span>
<span class="line-modified"> 648     oop stubName = HotSpotCompiledCode::name(compiled_code_obj);</span>
<span class="line-modified"> 649     if (stubName == NULL) {</span>
 650       JVMCI_ERROR_OK(&quot;stub should have a name&quot;);
 651     }
<span class="line-modified"> 652     char* name = strdup(java_lang_String::as_utf8_string(stubName));</span>
 653     cb = RuntimeStub::new_runtime_stub(name,
 654                                        &amp;buffer,
 655                                        CodeOffsets::frame_never_safe,
 656                                        stack_slots,
 657                                        _debug_recorder-&gt;_oopmaps,
 658                                        false);
<span class="line-modified"> 659     result = JVMCIEnv::ok;</span>
 660   } else {
<span class="line-modified"> 661     nmethod* nm = NULL;</span>
<span class="line-modified"> 662     methodHandle method = getMethodFromHotSpotMethod(HotSpotCompiledNmethod::method(compiled_code));</span>
<span class="line-modified"> 663     jint entry_bci = HotSpotCompiledNmethod::entryBCI(compiled_code);</span>
<span class="line-modified"> 664     jint id = HotSpotCompiledNmethod::id(compiled_code);</span>
<span class="line-modified"> 665     bool has_unsafe_access = HotSpotCompiledNmethod::hasUnsafeAccess(compiled_code) == JNI_TRUE;</span>
<span class="line-modified"> 666     JVMCIEnv* env = (JVMCIEnv*) (address) HotSpotCompiledNmethod::jvmciEnv(compiled_code);</span>





 667     if (id == -1) {
 668       // Make sure a valid compile_id is associated with every compile
<span class="line-modified"> 669       id = CompileBroker::assign_compile_id_unlocked(Thread::current(), method, entry_bci);</span>




 670     }
<span class="line-modified"> 671     result = JVMCIEnv::register_method(method, nm, entry_bci, &amp;_offsets, _orig_pc_offset, &amp;buffer,</span>
<span class="line-modified"> 672                                        stack_slots, _debug_recorder-&gt;_oopmaps, &amp;_exception_handler_table,</span>
<span class="line-modified"> 673                                        compiler, _debug_recorder, _dependencies, env, id,</span>
<span class="line-modified"> 674                                        has_unsafe_access, _has_wide_vector, installed_code, compiled_code, speculation_log);</span>




 675     cb = nm-&gt;as_codeblob_or_null();
<span class="line-modified"> 676     if (nm != NULL &amp;&amp; env == NULL) {</span>

 677       DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);
<span class="line-modified"> 678       bool printnmethods = directive-&gt;PrintAssemblyOption || directive-&gt;PrintNMethodsOption;</span>
<span class="line-removed"> 679       if (!printnmethods &amp;&amp; (PrintDebugInfo || PrintRelocations || PrintDependencies || PrintExceptionHandlers)) {</span>
<span class="line-removed"> 680         nm-&gt;print_nmethod(printnmethods);</span>
<span class="line-removed"> 681       }</span>
 682       DirectivesStack::release(directive);
 683     }
 684   }
 685 
 686   if (cb != NULL) {
 687     // Make sure the pre-calculated constants section size was correct.
 688     guarantee((cb-&gt;code_begin() - cb-&gt;content_begin()) &gt;= _constants_size, &quot;%d &lt; %d&quot;, (int)(cb-&gt;code_begin() - cb-&gt;content_begin()), _constants_size);
 689   }
 690   return result;
 691 }
 692 
<span class="line-modified"> 693 void CodeInstaller::initialize_fields(oop target, oop compiled_code, TRAPS) {</span>
<span class="line-modified"> 694   if (compiled_code-&gt;is_a(HotSpotCompiledNmethod::klass())) {</span>
<span class="line-modified"> 695     Handle hotspotJavaMethod(THREAD, HotSpotCompiledNmethod::method(compiled_code));</span>
<span class="line-modified"> 696     methodHandle method = getMethodFromHotSpotMethod(hotspotJavaMethod());</span>

 697     _parameter_count = method-&gt;size_of_parameters();
 698     TRACE_jvmci_2(&quot;installing code for %s&quot;, method-&gt;name_and_sig_as_C_string());
 699   } else {
 700     // Must be a HotSpotCompiledRuntimeStub.
 701     // Only used in OopMap constructor for non-product builds
 702     _parameter_count = 0;
 703   }
<span class="line-modified"> 704   _sites_handle = JNIHandles::make_local(HotSpotCompiledCode::sites(compiled_code));</span>
 705 
<span class="line-modified"> 706   _code_handle = JNIHandles::make_local(HotSpotCompiledCode::targetCode(compiled_code));</span>
<span class="line-modified"> 707   _code_size = HotSpotCompiledCode::targetCodeSize(compiled_code);</span>
<span class="line-modified"> 708   _total_frame_size = HotSpotCompiledCode::totalFrameSize(compiled_code);</span>
 709 
<span class="line-modified"> 710   oop deoptRescueSlot = HotSpotCompiledCode::deoptRescueSlot(compiled_code);</span>
<span class="line-modified"> 711   if (deoptRescueSlot == NULL) {</span>
 712     _orig_pc_offset = -1;
 713   } else {
<span class="line-modified"> 714     _orig_pc_offset = StackSlot::offset(deoptRescueSlot);</span>
<span class="line-modified"> 715     if (StackSlot::addFrameSize(deoptRescueSlot)) {</span>
 716       _orig_pc_offset += _total_frame_size;
 717     }
 718     if (_orig_pc_offset &lt; 0) {
 719       JVMCI_ERROR(&quot;invalid deopt rescue slot: %d&quot;, _orig_pc_offset);
 720     }
 721   }
 722 
 723   // Pre-calculate the constants section size.  This is required for PC-relative addressing.
<span class="line-modified"> 724   _data_section_handle = JNIHandles::make_local(HotSpotCompiledCode::dataSection(compiled_code));</span>
<span class="line-modified"> 725   if ((_constants-&gt;alignment() % HotSpotCompiledCode::dataSectionAlignment(compiled_code)) != 0) {</span>
<span class="line-modified"> 726     JVMCI_ERROR(&quot;invalid data section alignment: %d&quot;, HotSpotCompiledCode::dataSectionAlignment(compiled_code));</span>
 727   }
<span class="line-modified"> 728   _constants_size = data_section()-&gt;length();</span>
 729 
<span class="line-modified"> 730   _data_section_patches_handle = JNIHandles::make_local(HotSpotCompiledCode::dataSectionPatches(compiled_code));</span>
 731 
 732 #ifndef PRODUCT
<span class="line-modified"> 733   _comments_handle = JNIHandles::make_local(HotSpotCompiledCode::comments(compiled_code));</span>
 734 #endif
 735 
 736   _next_call_type = INVOKE_INVALID;
 737 
 738   _has_wide_vector = false;
 739 
<span class="line-modified"> 740   oop arch = TargetDescription::arch(target);</span>
<span class="line-modified"> 741   _word_kind_handle = JNIHandles::make_local(Architecture::wordKind(arch));</span>
 742 }
 743 
<span class="line-modified"> 744 int CodeInstaller::estimate_stubs_size(TRAPS) {</span>
 745   // Estimate the number of static and aot call stubs that might be emitted.
 746   int static_call_stubs = 0;
 747   int aot_call_stubs = 0;
 748   int trampoline_stubs = 0;
<span class="line-modified"> 749   objArrayOop sites = this-&gt;sites();</span>
<span class="line-modified"> 750   for (int i = 0; i &lt; sites-&gt;length(); i++) {</span>
<span class="line-modified"> 751     oop site = sites-&gt;obj_at(i);</span>
<span class="line-modified"> 752     if (site != NULL) {</span>
<span class="line-modified"> 753       if (site-&gt;is_a(site_Mark::klass())) {</span>
<span class="line-modified"> 754         oop id_obj = site_Mark::id(site);</span>
<span class="line-modified"> 755         if (id_obj != NULL) {</span>
<span class="line-modified"> 756           if (!java_lang_boxing_object::is_instance(id_obj, T_INT)) {</span>
<span class="line-modified"> 757             JVMCI_ERROR_0(&quot;expected Integer id, got %s&quot;, id_obj-&gt;klass()-&gt;signature_name());</span>
 758           }
<span class="line-modified"> 759           jint id = id_obj-&gt;int_field(java_lang_boxing_object::value_offset_in_bytes(T_INT));</span>
 760           switch (id) {
<span class="line-modified"> 761           case INVOKEINTERFACE:</span>
<span class="line-modified"> 762           case INVOKEVIRTUAL:</span>
<span class="line-modified"> 763             trampoline_stubs++;</span>
<span class="line-modified"> 764             break;</span>
<span class="line-modified"> 765           case INVOKESTATIC:</span>
<span class="line-modified"> 766           case INVOKESPECIAL:</span>
<span class="line-modified"> 767             static_call_stubs++;</span>
<span class="line-modified"> 768             trampoline_stubs++;</span>
<span class="line-modified"> 769             break;</span>
<span class="line-modified"> 770           default:</span>
<span class="line-modified"> 771             break;</span>
 772           }
 773         }
 774       }
 775 #if INCLUDE_AOT
<span class="line-modified"> 776       if (UseAOT &amp;&amp; site-&gt;is_a(site_Call::klass())) {</span>
<span class="line-modified"> 777         oop target = site_Call::target(site);</span>
<span class="line-modified"> 778         InstanceKlass* target_klass = InstanceKlass::cast(target-&gt;klass());</span>
<span class="line-removed"> 779         if (!target_klass-&gt;is_subclass_of(SystemDictionary::HotSpotForeignCallTarget_klass())) {</span>
 780           // Add far aot trampolines.
 781           aot_call_stubs++;
 782         }
 783       }
 784 #endif
 785     }
 786   }
 787   int size = static_call_stubs * CompiledStaticCall::to_interp_stub_size();
 788   size += trampoline_stubs * CompiledStaticCall::to_trampoline_stub_size();
 789 #if INCLUDE_AOT
 790   size += aot_call_stubs * CompiledStaticCall::to_aot_stub_size();
 791 #endif
 792   return size;
 793 }
 794 
 795 // perform data and call relocation on the CodeBuffer
<span class="line-modified"> 796 JVMCIEnv::CodeInstallResult CodeInstaller::initialize_buffer(CodeBuffer&amp; buffer, bool check_size, TRAPS) {</span>
 797   HandleMark hm;
<span class="line-modified"> 798   objArrayHandle sites(THREAD, this-&gt;sites());</span>
<span class="line-modified"> 799   int locs_buffer_size = sites-&gt;length() * (relocInfo::length_limit + sizeof(relocInfo));</span>
 800 
 801   // Allocate enough space in the stub section for the static call
 802   // stubs.  Stubs have extra relocs but they are managed by the stub
 803   // section itself so they don&#39;t need to be accounted for in the
 804   // locs_buffer above.
<span class="line-modified"> 805   int stubs_size = estimate_stubs_size(CHECK_OK);</span>
 806   int total_size = align_up(_code_size, buffer.insts()-&gt;alignment()) + align_up(_constants_size, buffer.consts()-&gt;alignment()) + align_up(stubs_size, buffer.stubs()-&gt;alignment());
 807 
 808   if (check_size &amp;&amp; total_size &gt; JVMCINMethodSizeLimit) {
<span class="line-modified"> 809     return JVMCIEnv::code_too_large;</span>
 810   }
 811 
 812   buffer.initialize(total_size, locs_buffer_size);
 813   if (buffer.blob() == NULL) {
<span class="line-modified"> 814     return JVMCIEnv::cache_full;</span>
 815   }
 816   buffer.initialize_stubs_size(stubs_size);
 817   buffer.initialize_consts_size(_constants_size);
 818 
 819   _debug_recorder = new DebugInformationRecorder(_oop_recorder);
 820   _debug_recorder-&gt;set_oopmaps(new OopMapSet());
 821 
 822   buffer.initialize_oop_recorder(_oop_recorder);
 823 
 824   // copy the constant data into the newly created CodeBuffer
 825   address end_data = _constants-&gt;start() + _constants_size;
<span class="line-modified"> 826   memcpy(_constants-&gt;start(), data_section()-&gt;base(T_BYTE), _constants_size);</span>
 827   _constants-&gt;set_end(end_data);
 828 
 829   // copy the code into the newly created CodeBuffer
 830   address end_pc = _instructions-&gt;start() + _code_size;
 831   guarantee(_instructions-&gt;allocates2(end_pc), &quot;initialize should have reserved enough space for all the code&quot;);
<span class="line-modified"> 832   memcpy(_instructions-&gt;start(), code()-&gt;base(T_BYTE), _code_size);</span>
 833   _instructions-&gt;set_end(end_pc);
 834 
<span class="line-modified"> 835   for (int i = 0; i &lt; data_section_patches()-&gt;length(); i++) {</span>
<span class="line-modified"> 836     HandleMark hm(THREAD);</span>
<span class="line-modified"> 837     Handle patch(THREAD, data_section_patches()-&gt;obj_at(i));</span>
 838     if (patch.is_null()) {
<span class="line-modified"> 839       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);</span>
 840     }
<span class="line-modified"> 841     Handle reference(THREAD, site_DataPatch::reference(patch));</span>
 842     if (reference.is_null()) {
<span class="line-modified"> 843       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);</span>
 844     }
<span class="line-modified"> 845     if (!reference-&gt;is_a(site_ConstantReference::klass())) {</span>
<span class="line-modified"> 846       JVMCI_ERROR_OK(&quot;invalid patch in data section: %s&quot;, reference-&gt;klass()-&gt;signature_name());</span>
 847     }
<span class="line-modified"> 848     Handle constant(THREAD, site_ConstantReference::constant(reference));</span>
 849     if (constant.is_null()) {
<span class="line-modified"> 850       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);</span>
 851     }
<span class="line-modified"> 852     address dest = _constants-&gt;start() + site_Site::pcOffset(patch);</span>
<span class="line-modified"> 853     if (constant-&gt;is_a(HotSpotMetaspaceConstantImpl::klass())) {</span>
<span class="line-modified"> 854       if (HotSpotMetaspaceConstantImpl::compressed(constant)) {</span>
 855 #ifdef _LP64
<span class="line-modified"> 856         *((narrowKlass*) dest) = record_narrow_metadata_reference(_constants, dest, constant, CHECK_OK);</span>
 857 #else
 858         JVMCI_ERROR_OK(&quot;unexpected compressed Klass* in 32-bit mode&quot;);
 859 #endif
 860       } else {
<span class="line-modified"> 861         *((void**) dest) = record_metadata_reference(_constants, dest, constant, CHECK_OK);</span>
 862       }
<span class="line-modified"> 863     } else if (constant-&gt;is_a(HotSpotObjectConstantImpl::klass())) {</span>
<span class="line-modified"> 864       Handle obj(THREAD, HotSpotObjectConstantImpl::object(constant));</span>
 865       jobject value = JNIHandles::make_local(obj());
 866       int oop_index = _oop_recorder-&gt;find_index(value);
 867 
<span class="line-modified"> 868       if (HotSpotObjectConstantImpl::compressed(constant)) {</span>
 869 #ifdef _LP64
 870         _constants-&gt;relocate(dest, oop_Relocation::spec(oop_index), relocInfo::narrow_oop_in_const);
 871 #else
 872         JVMCI_ERROR_OK(&quot;unexpected compressed oop in 32-bit mode&quot;);
 873 #endif
 874       } else {
 875         _constants-&gt;relocate(dest, oop_Relocation::spec(oop_index));
 876       }
 877     } else {
<span class="line-modified"> 878       JVMCI_ERROR_OK(&quot;invalid constant in data section: %s&quot;, constant-&gt;klass()-&gt;signature_name());</span>
 879     }
 880   }
 881   jint last_pc_offset = -1;
<span class="line-modified"> 882   for (int i = 0; i &lt; sites-&gt;length(); i++) {</span>
<span class="line-modified"> 883     HandleMark hm(THREAD);</span>
<span class="line-modified"> 884     Handle site(THREAD, sites-&gt;obj_at(i));</span>
 885     if (site.is_null()) {
<span class="line-modified"> 886       THROW_(vmSymbols::java_lang_NullPointerException(), JVMCIEnv::ok);</span>
 887     }
 888 
<span class="line-modified"> 889     jint pc_offset = site_Site::pcOffset(site);</span>
 890 
<span class="line-modified"> 891     if (site-&gt;is_a(site_Call::klass())) {</span>
 892       TRACE_jvmci_4(&quot;call at %i&quot;, pc_offset);
<span class="line-modified"> 893       site_Call(buffer, pc_offset, site, CHECK_OK);</span>
<span class="line-modified"> 894     } else if (site-&gt;is_a(site_Infopoint::klass())) {</span>
 895       // three reasons for infopoints denote actual safepoints
<span class="line-modified"> 896       oop reason = site_Infopoint::reason(site);</span>
<span class="line-modified"> 897       if (site_InfopointReason::SAFEPOINT() == reason || site_InfopointReason::CALL() == reason || site_InfopointReason::IMPLICIT_EXCEPTION() == reason) {</span>


 898         TRACE_jvmci_4(&quot;safepoint at %i&quot;, pc_offset);
<span class="line-modified"> 899         site_Safepoint(buffer, pc_offset, site, CHECK_OK);</span>
 900         if (_orig_pc_offset &lt; 0) {
 901           JVMCI_ERROR_OK(&quot;method contains safepoint, but has no deopt rescue slot&quot;);
 902         }




 903       } else {
 904         TRACE_jvmci_4(&quot;infopoint at %i&quot;, pc_offset);
<span class="line-modified"> 905         site_Infopoint(buffer, pc_offset, site, CHECK_OK);</span>
 906       }
<span class="line-modified"> 907     } else if (site-&gt;is_a(site_DataPatch::klass())) {</span>
 908       TRACE_jvmci_4(&quot;datapatch at %i&quot;, pc_offset);
<span class="line-modified"> 909       site_DataPatch(buffer, pc_offset, site, CHECK_OK);</span>
<span class="line-modified"> 910     } else if (site-&gt;is_a(site_Mark::klass())) {</span>
 911       TRACE_jvmci_4(&quot;mark at %i&quot;, pc_offset);
<span class="line-modified"> 912       site_Mark(buffer, pc_offset, site, CHECK_OK);</span>
<span class="line-modified"> 913     } else if (site-&gt;is_a(site_ExceptionHandler::klass())) {</span>
 914       TRACE_jvmci_4(&quot;exceptionhandler at %i&quot;, pc_offset);
 915       site_ExceptionHandler(pc_offset, site);
 916     } else {
<span class="line-modified"> 917       JVMCI_ERROR_OK(&quot;unexpected site subclass: %s&quot;, site-&gt;klass()-&gt;signature_name());</span>
 918     }
 919     last_pc_offset = pc_offset;
 920 
 921     JavaThread* thread = JavaThread::current();
 922     if (SafepointMechanism::should_block(thread)) {
 923       // this is a hacky way to force a safepoint check but nothing else was jumping out at me.
 924       ThreadToNativeFromVM ttnfv(thread);
 925     }
 926   }
 927 
 928 #ifndef PRODUCT
<span class="line-modified"> 929   if (comments() != NULL) {</span>
<span class="line-modified"> 930     for (int i = 0; i &lt; comments()-&gt;length(); i++) {</span>
<span class="line-modified"> 931       oop comment = comments()-&gt;obj_at(i);</span>
<span class="line-modified"> 932       assert(comment-&gt;is_a(HotSpotCompiledCode_Comment::klass()), &quot;cce&quot;);</span>
<span class="line-modified"> 933       jint offset = HotSpotCompiledCode_Comment::pcOffset(comment);</span>
<span class="line-modified"> 934       char* text = java_lang_String::as_utf8_string(HotSpotCompiledCode_Comment::text(comment));</span>
 935       buffer.block_comment(offset, text);
 936     }
 937   }
 938 #endif
<span class="line-modified"> 939   return JVMCIEnv::ok;</span>
 940 }
 941 
<span class="line-modified"> 942 void CodeInstaller::assumption_NoFinalizableSubclass(Thread* thread, Handle assumption) {</span>
<span class="line-modified"> 943   Handle receiverType_handle (thread, Assumptions_NoFinalizableSubclass::receiverType(assumption()));</span>
<span class="line-modified"> 944   Klass* receiverType = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(receiverType_handle));</span>
 945   _dependencies-&gt;assert_has_no_finalizable_subclasses(receiverType);
 946 }
 947 
<span class="line-modified"> 948 void CodeInstaller::assumption_ConcreteSubtype(Thread* thread, Handle assumption) {</span>
<span class="line-modified"> 949   Handle context_handle (thread, Assumptions_ConcreteSubtype::context(assumption()));</span>
<span class="line-modified"> 950   Handle subtype_handle (thread, Assumptions_ConcreteSubtype::subtype(assumption()));</span>
<span class="line-modified"> 951   Klass* context = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(context_handle));</span>
<span class="line-modified"> 952   Klass* subtype = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(subtype_handle));</span>
 953 
 954   assert(context-&gt;is_abstract(), &quot;&quot;);
 955   _dependencies-&gt;assert_abstract_with_unique_concrete_subtype(context, subtype);
 956 }
 957 
<span class="line-modified"> 958 void CodeInstaller::assumption_LeafType(Thread* thread, Handle assumption) {</span>
<span class="line-modified"> 959   Handle context_handle (thread, Assumptions_LeafType::context(assumption()));</span>
<span class="line-modified"> 960   Klass* context = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(context_handle));</span>
 961 
 962   _dependencies-&gt;assert_leaf_type(context);
 963 }
 964 
<span class="line-modified"> 965 void CodeInstaller::assumption_ConcreteMethod(Thread* thread, Handle assumption) {</span>
<span class="line-modified"> 966   Handle impl_handle (thread, Assumptions_ConcreteMethod::impl(assumption()));</span>
<span class="line-modified"> 967   Handle context_handle (thread, Assumptions_ConcreteMethod::context(assumption()));</span>
 968 
<span class="line-modified"> 969   methodHandle impl = getMethodFromHotSpotMethod(impl_handle());</span>
<span class="line-modified"> 970   Klass* context = java_lang_Class::as_Klass(HotSpotResolvedObjectTypeImpl::javaClass(context_handle));</span>
 971 
<span class="line-modified"> 972   _dependencies-&gt;assert_unique_concrete_method(context, impl());</span>
 973 }
 974 
<span class="line-modified"> 975 void CodeInstaller::assumption_CallSiteTargetValue(Thread* thread, Handle assumption) {</span>
<span class="line-modified"> 976   Handle callSite(thread, HotSpotObjectConstantImpl::object(Assumptions_CallSiteTargetValue::callSite(assumption())));</span>
<span class="line-modified"> 977   Handle methodHandle(thread, HotSpotObjectConstantImpl::object(Assumptions_CallSiteTargetValue::methodHandle(assumption())));</span>
<span class="line-modified"> 978 </span>

 979   _dependencies-&gt;assert_call_site_target_value(callSite(), methodHandle());
 980 }
 981 
<span class="line-modified"> 982 void CodeInstaller::site_ExceptionHandler(jint pc_offset, Handle exc) {</span>
<span class="line-modified"> 983   jint handler_offset = site_ExceptionHandler::handlerPos(exc);</span>
 984 
 985   // Subtable header
 986   _exception_handler_table.add_entry(HandlerTableEntry(1, pc_offset, 0));
 987 
 988   // Subtable entry
 989   _exception_handler_table.add_entry(HandlerTableEntry(-1, handler_offset, 0));
 990 }
 991 
 992 // If deoptimization happens, the interpreter should reexecute these bytecodes.
 993 // This function mainly helps the compilers to set up the reexecute bit.
 994 static bool bytecode_should_reexecute(Bytecodes::Code code) {
 995   switch (code) {
 996     case Bytecodes::_invokedynamic:
 997     case Bytecodes::_invokevirtual:
 998     case Bytecodes::_invokeinterface:
 999     case Bytecodes::_invokespecial:
1000     case Bytecodes::_invokestatic:
1001       return false;
1002     default:
1003       return true;
1004     }
1005   return true;
1006 }
1007 
<span class="line-modified">1008 GrowableArray&lt;ScopeValue*&gt;* CodeInstaller::record_virtual_objects(Handle debug_info, TRAPS) {</span>
<span class="line-modified">1009   objArrayHandle virtualObjects(THREAD, DebugInfo::virtualObjectMapping(debug_info));</span>
1010   if (virtualObjects.is_null()) {
1011     return NULL;
1012   }
<span class="line-modified">1013   GrowableArray&lt;ScopeValue*&gt;* objects = new GrowableArray&lt;ScopeValue*&gt;(virtualObjects-&gt;length(), virtualObjects-&gt;length(), NULL);</span>
1014   // Create the unique ObjectValues
<span class="line-modified">1015   for (int i = 0; i &lt; virtualObjects-&gt;length(); i++) {</span>
<span class="line-modified">1016     HandleMark hm(THREAD);</span>
<span class="line-modified">1017     Handle value(THREAD, virtualObjects-&gt;obj_at(i));</span>
<span class="line-modified">1018     int id = VirtualObject::id(value);</span>
<span class="line-modified">1019     Handle type(THREAD, VirtualObject::type(value));</span>
<span class="line-modified">1020     oop javaMirror = HotSpotResolvedObjectTypeImpl::javaClass(type);</span>
<span class="line-modified">1021     ObjectValue* sv = new ObjectValue(id, new ConstantOopWriteValue(JNIHandles::make_local(Thread::current(), javaMirror)));</span>



1022     if (id &lt; 0 || id &gt;= objects-&gt;length()) {
1023       JVMCI_ERROR_NULL(&quot;virtual object id %d out of bounds&quot;, id);
1024     }
1025     if (objects-&gt;at(id) != NULL) {
1026       JVMCI_ERROR_NULL(&quot;duplicate virtual object id %d&quot;, id);
1027     }
1028     objects-&gt;at_put(id, sv);
1029   }
1030   // All the values which could be referenced by the VirtualObjects
1031   // exist, so now describe all the VirtualObjects themselves.
<span class="line-modified">1032   for (int i = 0; i &lt; virtualObjects-&gt;length(); i++) {</span>
<span class="line-modified">1033     HandleMark hm(THREAD);</span>
<span class="line-modified">1034     Handle value(THREAD, virtualObjects-&gt;obj_at(i));</span>
<span class="line-modified">1035     int id = VirtualObject::id(value);</span>
<span class="line-modified">1036     record_object_value(objects-&gt;at(id)-&gt;as_ObjectValue(), value, objects, CHECK_NULL);</span>
1037   }
1038   _debug_recorder-&gt;dump_object_pool(objects);
1039   return objects;
1040 }
1041 
<span class="line-modified">1042 void CodeInstaller::record_scope(jint pc_offset, Handle debug_info, ScopeMode scope_mode, bool return_oop, TRAPS) {</span>
<span class="line-modified">1043   Handle position(THREAD, DebugInfo::bytecodePosition(debug_info));</span>
1044   if (position.is_null()) {
1045     // Stubs do not record scope info, just oop maps
1046     return;
1047   }
1048 
1049   GrowableArray&lt;ScopeValue*&gt;* objectMapping;
1050   if (scope_mode == CodeInstaller::FullFrame) {
<span class="line-modified">1051     objectMapping = record_virtual_objects(debug_info, CHECK);</span>
1052   } else {
1053     objectMapping = NULL;
1054   }
<span class="line-modified">1055   record_scope(pc_offset, position, scope_mode, objectMapping, return_oop, CHECK);</span>
1056 }
1057 
1058 int CodeInstaller::map_jvmci_bci(int bci) {
1059   if (bci &lt; 0) {
<span class="line-modified">1060     if (bci == BytecodeFrame::BEFORE_BCI()) {</span>
1061       return BeforeBci;
<span class="line-modified">1062     } else if (bci == BytecodeFrame::AFTER_BCI()) {</span>
1063       return AfterBci;
<span class="line-modified">1064     } else if (bci == BytecodeFrame::UNWIND_BCI()) {</span>
1065       return UnwindBci;
<span class="line-modified">1066     } else if (bci == BytecodeFrame::AFTER_EXCEPTION_BCI()) {</span>
1067       return AfterExceptionBci;
<span class="line-modified">1068     } else if (bci == BytecodeFrame::UNKNOWN_BCI()) {</span>
1069       return UnknownBci;
<span class="line-modified">1070     } else if (bci == BytecodeFrame::INVALID_FRAMESTATE_BCI()) {</span>
1071       return InvalidFrameStateBci;
1072     }
1073     ShouldNotReachHere();
1074   }
1075   return bci;
1076 }
1077 
<span class="line-modified">1078 void CodeInstaller::record_scope(jint pc_offset, Handle position, ScopeMode scope_mode, GrowableArray&lt;ScopeValue*&gt;* objects, bool return_oop, TRAPS) {</span>
<span class="line-modified">1079   Handle frame;</span>
1080   if (scope_mode == CodeInstaller::FullFrame) {
<span class="line-modified">1081     if (!position-&gt;is_a(BytecodeFrame::klass())) {</span>
1082       JVMCI_ERROR(&quot;Full frame expected for debug info at %i&quot;, pc_offset);
1083     }
1084     frame = position;
1085   }
<span class="line-modified">1086   Handle caller_frame (THREAD, BytecodePosition::caller(position));</span>
<span class="line-modified">1087   if (caller_frame.not_null()) {</span>
<span class="line-modified">1088     record_scope(pc_offset, caller_frame, scope_mode, objects, return_oop, CHECK);</span>
1089   }
1090 
<span class="line-modified">1091   Handle hotspot_method (THREAD, BytecodePosition::method(position));</span>
<span class="line-modified">1092   Method* method = getMethodFromHotSpotMethod(hotspot_method());</span>
<span class="line-modified">1093   jint bci = map_jvmci_bci(BytecodePosition::bci(position));</span>




1094 
1095   TRACE_jvmci_2(&quot;Recording scope pc_offset=%d bci=%d method=%s&quot;, pc_offset, bci, method-&gt;name_and_sig_as_C_string());
1096 
1097   bool reexecute = false;
<span class="line-modified">1098   if (frame.not_null()) {</span>
<span class="line-modified">1099     if (bci &lt; 0) {</span>
1100        reexecute = false;
1101     } else {
<span class="line-modified">1102       Bytecodes::Code code = Bytecodes::java_code_at(method, method-&gt;bcp_from(bci));</span>
1103       reexecute = bytecode_should_reexecute(code);
<span class="line-modified">1104       if (frame.not_null()) {</span>
<span class="line-modified">1105         reexecute = (BytecodeFrame::duringCall(frame) == JNI_FALSE);</span>
1106       }
1107     }
1108   }
1109 
1110   DebugToken* locals_token = NULL;
1111   DebugToken* expressions_token = NULL;
1112   DebugToken* monitors_token = NULL;
1113   bool throw_exception = false;
1114 
<span class="line-modified">1115   if (frame.not_null()) {</span>
<span class="line-modified">1116     jint local_count = BytecodeFrame::numLocals(frame);</span>
<span class="line-modified">1117     jint expression_count = BytecodeFrame::numStack(frame);</span>
<span class="line-modified">1118     jint monitor_count = BytecodeFrame::numLocks(frame);</span>
<span class="line-modified">1119     objArrayHandle values(THREAD, BytecodeFrame::values(frame));</span>
<span class="line-modified">1120     objArrayHandle slotKinds(THREAD, BytecodeFrame::slotKinds(frame));</span>
1121 
1122     if (values.is_null() || slotKinds.is_null()) {
<span class="line-modified">1123       THROW(vmSymbols::java_lang_NullPointerException());</span>
1124     }
<span class="line-modified">1125     if (local_count + expression_count + monitor_count != values-&gt;length()) {</span>
<span class="line-modified">1126       JVMCI_ERROR(&quot;unexpected values length %d in scope (%d locals, %d expressions, %d monitors)&quot;, values-&gt;length(), local_count, expression_count, monitor_count);</span>
1127     }
<span class="line-modified">1128     if (local_count + expression_count != slotKinds-&gt;length()) {</span>
<span class="line-modified">1129       JVMCI_ERROR(&quot;unexpected slotKinds length %d in scope (%d locals, %d expressions)&quot;, slotKinds-&gt;length(), local_count, expression_count);</span>
1130     }
1131 
1132     GrowableArray&lt;ScopeValue*&gt;* locals = local_count &gt; 0 ? new GrowableArray&lt;ScopeValue*&gt; (local_count) : NULL;
1133     GrowableArray&lt;ScopeValue*&gt;* expressions = expression_count &gt; 0 ? new GrowableArray&lt;ScopeValue*&gt; (expression_count) : NULL;
1134     GrowableArray&lt;MonitorValue*&gt;* monitors = monitor_count &gt; 0 ? new GrowableArray&lt;MonitorValue*&gt; (monitor_count) : NULL;
1135 
<span class="line-modified">1136     TRACE_jvmci_2(&quot;Scope at bci %d with %d values&quot;, bci, values-&gt;length());</span>
1137     TRACE_jvmci_2(&quot;%d locals %d expressions, %d monitors&quot;, local_count, expression_count, monitor_count);
1138 
<span class="line-modified">1139     for (jint i = 0; i &lt; values-&gt;length(); i++) {</span>
<span class="line-modified">1140       HandleMark hm(THREAD);</span>
1141       ScopeValue* second = NULL;
<span class="line-modified">1142       Handle value(THREAD, values-&gt;obj_at(i));</span>
1143       if (i &lt; local_count) {
<span class="line-modified">1144         BasicType type = JVMCIRuntime::kindToBasicType(Handle(THREAD, slotKinds-&gt;obj_at(i)), CHECK);</span>
<span class="line-modified">1145         ScopeValue* first = get_scope_value(value, type, objects, second, CHECK);</span>
1146         if (second != NULL) {
1147           locals-&gt;append(second);
1148         }
1149         locals-&gt;append(first);
1150       } else if (i &lt; local_count + expression_count) {
<span class="line-modified">1151         BasicType type = JVMCIRuntime::kindToBasicType(Handle(THREAD, slotKinds-&gt;obj_at(i)), CHECK);</span>
<span class="line-modified">1152         ScopeValue* first = get_scope_value(value, type, objects, second, CHECK);</span>
1153         if (second != NULL) {
1154           expressions-&gt;append(second);
1155         }
1156         expressions-&gt;append(first);
1157       } else {
<span class="line-modified">1158         MonitorValue *monitor = get_monitor_value(value, objects, CHECK);</span>
1159         monitors-&gt;append(monitor);
1160       }
1161       if (second != NULL) {
1162         i++;
<span class="line-modified">1163         if (i &gt;= values-&gt;length() || values-&gt;obj_at(i) != Value::ILLEGAL()) {</span>
1164           JVMCI_ERROR(&quot;double-slot value not followed by Value.ILLEGAL&quot;);
1165         }
1166       }
1167     }
1168 
1169     locals_token = _debug_recorder-&gt;create_scope_values(locals);
1170     expressions_token = _debug_recorder-&gt;create_scope_values(expressions);
1171     monitors_token = _debug_recorder-&gt;create_monitor_values(monitors);
1172 
<span class="line-modified">1173     throw_exception = BytecodeFrame::rethrowException(frame) == JNI_TRUE;</span>
1174   }
1175 
1176   _debug_recorder-&gt;describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, false, return_oop,
1177                                   locals_token, expressions_token, monitors_token);
1178 }
1179 
<span class="line-modified">1180 void CodeInstaller::site_Safepoint(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {</span>
<span class="line-modified">1181   Handle debug_info (THREAD, site_Infopoint::debugInfo(site));</span>
1182   if (debug_info.is_null()) {
1183     JVMCI_ERROR(&quot;debug info expected at safepoint at %i&quot;, pc_offset);
1184   }
1185 
1186   // address instruction = _instructions-&gt;start() + pc_offset;
1187   // jint next_pc_offset = Assembler::locate_next_instruction(instruction) - _instructions-&gt;start();
<span class="line-modified">1188   OopMap *map = create_oop_map(debug_info, CHECK);</span>
1189   _debug_recorder-&gt;add_safepoint(pc_offset, map);
<span class="line-modified">1190   record_scope(pc_offset, debug_info, CodeInstaller::FullFrame, CHECK);</span>
1191   _debug_recorder-&gt;end_safepoint(pc_offset);
1192 }
1193 
<span class="line-modified">1194 void CodeInstaller::site_Infopoint(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {</span>
<span class="line-modified">1195   Handle debug_info (THREAD, site_Infopoint::debugInfo(site));</span>
1196   if (debug_info.is_null()) {
1197     JVMCI_ERROR(&quot;debug info expected at infopoint at %i&quot;, pc_offset);
1198   }
1199 
1200   // We&#39;d like to check that pc_offset is greater than the
1201   // last pc recorded with _debug_recorder (raising an exception if not)
1202   // but DebugInformationRecorder doesn&#39;t have sufficient public API.
1203 
1204   _debug_recorder-&gt;add_non_safepoint(pc_offset);
<span class="line-modified">1205   record_scope(pc_offset, debug_info, CodeInstaller::BytecodePosition, CHECK);</span>
1206   _debug_recorder-&gt;end_non_safepoint(pc_offset);
1207 }
1208 
<span class="line-modified">1209 void CodeInstaller::site_Call(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {</span>
<span class="line-modified">1210   Handle target(THREAD, site_Call::target(site));</span>
<span class="line-modified">1211   InstanceKlass* target_klass = InstanceKlass::cast(target-&gt;klass());</span>
<span class="line-modified">1212 </span>
<span class="line-removed">1213   Handle hotspot_method; // JavaMethod</span>
<span class="line-removed">1214   Handle foreign_call;</span>
1215 
<span class="line-modified">1216   if (target_klass-&gt;is_subclass_of(SystemDictionary::HotSpotForeignCallTarget_klass())) {</span>
1217     foreign_call = target;
1218   } else {
1219     hotspot_method = target;
1220   }
1221 
<span class="line-modified">1222   Handle debug_info (THREAD, site_Call::debugInfo(site));</span>
1223 
<span class="line-modified">1224   assert(hotspot_method.not_null() ^ foreign_call.not_null(), &quot;Call site needs exactly one type&quot;);</span>
1225 
1226   NativeInstruction* inst = nativeInstruction_at(_instructions-&gt;start() + pc_offset);
<span class="line-modified">1227   jint next_pc_offset = CodeInstaller::pd_next_offset(inst, pc_offset, hotspot_method, CHECK);</span>
1228 
<span class="line-modified">1229   if (debug_info.not_null()) {</span>
<span class="line-modified">1230     OopMap *map = create_oop_map(debug_info, CHECK);</span>
1231     _debug_recorder-&gt;add_safepoint(next_pc_offset, map);
1232 
<span class="line-modified">1233     bool return_oop = hotspot_method.not_null() &amp;&amp; getMethodFromHotSpotMethod(hotspot_method())-&gt;is_returning_oop();</span>
1234 
<span class="line-modified">1235     record_scope(next_pc_offset, debug_info, CodeInstaller::FullFrame, return_oop, CHECK);</span>
1236   }
1237 
<span class="line-modified">1238   if (foreign_call.not_null()) {</span>
<span class="line-modified">1239     jlong foreign_call_destination = HotSpotForeignCallTarget::address(foreign_call);</span>
1240     if (_immutable_pic_compilation) {
1241       // Use fake short distance during PIC compilation.
1242       foreign_call_destination = (jlong)(_instructions-&gt;start() + pc_offset);
1243     }
<span class="line-modified">1244     CodeInstaller::pd_relocate_ForeignCall(inst, foreign_call_destination, CHECK);</span>
1245   } else { // method != NULL
1246     if (debug_info.is_null()) {
1247       JVMCI_ERROR(&quot;debug info expected at call at %i&quot;, pc_offset);
1248     }
1249 
1250     TRACE_jvmci_3(&quot;method call&quot;);
<span class="line-modified">1251     CodeInstaller::pd_relocate_JavaMethod(buffer, hotspot_method, pc_offset, CHECK);</span>
1252     if (_next_call_type == INVOKESTATIC || _next_call_type == INVOKESPECIAL) {
1253       // Need a static call stub for transitions from compiled to interpreted.
1254       CompiledStaticCall::emit_to_interp_stub(buffer, _instructions-&gt;start() + pc_offset);
1255     }
1256 #if INCLUDE_AOT
1257     // Trampoline to far aot code.
1258     CompiledStaticCall::emit_to_aot_stub(buffer, _instructions-&gt;start() + pc_offset);
1259 #endif
1260   }
1261 
1262   _next_call_type = INVOKE_INVALID;
1263 
<span class="line-modified">1264   if (debug_info.not_null()) {</span>
1265     _debug_recorder-&gt;end_safepoint(next_pc_offset);
1266   }
1267 }
1268 
<span class="line-modified">1269 void CodeInstaller::site_DataPatch(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {</span>
<span class="line-modified">1270   Handle reference(THREAD, site_DataPatch::reference(site));</span>
1271   if (reference.is_null()) {
<span class="line-modified">1272     THROW(vmSymbols::java_lang_NullPointerException());</span>
<span class="line-modified">1273   } else if (reference-&gt;is_a(site_ConstantReference::klass())) {</span>
<span class="line-modified">1274     Handle constant(THREAD, site_ConstantReference::constant(reference));</span>
1275     if (constant.is_null()) {
<span class="line-modified">1276       THROW(vmSymbols::java_lang_NullPointerException());</span>
<span class="line-modified">1277     } else if (constant-&gt;is_a(HotSpotObjectConstantImpl::klass())) {</span>










1278       if (!_immutable_pic_compilation) {
1279         // Do not patch during PIC compilation.
<span class="line-modified">1280         pd_patch_OopConstant(pc_offset, constant, CHECK);</span>
1281       }
<span class="line-modified">1282     } else if (constant-&gt;is_a(HotSpotMetaspaceConstantImpl::klass())) {</span>
1283       if (!_immutable_pic_compilation) {
<span class="line-modified">1284         pd_patch_MetaspaceConstant(pc_offset, constant, CHECK);</span>
1285       }
1286 #if INCLUDE_AOT
<span class="line-modified">1287     } else if (constant-&gt;is_a(HotSpotSentinelConstant::klass())) {</span>
1288       if (!_immutable_pic_compilation) {
<span class="line-modified">1289         JVMCI_ERROR(&quot;sentinel constant not supported for normal compiles: %s&quot;, constant-&gt;klass()-&gt;signature_name());</span>
1290       }
1291 #endif
1292     } else {
<span class="line-modified">1293       JVMCI_ERROR(&quot;unknown constant type in data patch: %s&quot;, constant-&gt;klass()-&gt;signature_name());</span>
1294     }
<span class="line-modified">1295   } else if (reference-&gt;is_a(site_DataSectionReference::klass())) {</span>
<span class="line-modified">1296     int data_offset = site_DataSectionReference::offset(reference);</span>
1297     if (0 &lt;= data_offset &amp;&amp; data_offset &lt; _constants_size) {
<span class="line-modified">1298       pd_patch_DataSectionReference(pc_offset, data_offset, CHECK);</span>
1299     } else {
1300       JVMCI_ERROR(&quot;data offset 0x%X points outside data section (size 0x%X)&quot;, data_offset, _constants_size);
1301     }
1302   } else {
<span class="line-modified">1303     JVMCI_ERROR(&quot;unknown data patch type: %s&quot;, reference-&gt;klass()-&gt;signature_name());</span>
1304   }
1305 }
1306 
<span class="line-modified">1307 void CodeInstaller::site_Mark(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS) {</span>
<span class="line-modified">1308   Handle id_obj (THREAD, site_Mark::id(site));</span>
1309 
<span class="line-modified">1310   if (id_obj.not_null()) {</span>
<span class="line-modified">1311     if (!java_lang_boxing_object::is_instance(id_obj(), T_INT)) {</span>
<span class="line-modified">1312       JVMCI_ERROR(&quot;expected Integer id, got %s&quot;, id_obj-&gt;klass()-&gt;signature_name());</span>
1313     }
<span class="line-modified">1314     jint id = id_obj-&gt;int_field(java_lang_boxing_object::value_offset_in_bytes(T_INT));</span>
1315 
1316     address pc = _instructions-&gt;start() + pc_offset;
1317 
1318     switch (id) {
1319       case UNVERIFIED_ENTRY:
1320         _offsets.set_value(CodeOffsets::Entry, pc_offset);
1321         break;
1322       case VERIFIED_ENTRY:
1323         _offsets.set_value(CodeOffsets::Verified_Entry, pc_offset);
1324         break;
1325       case OSR_ENTRY:
1326         _offsets.set_value(CodeOffsets::OSR_Entry, pc_offset);
1327         break;
1328       case EXCEPTION_HANDLER_ENTRY:
1329         _offsets.set_value(CodeOffsets::Exceptions, pc_offset);
1330         break;
1331       case DEOPT_HANDLER_ENTRY:
1332         _offsets.set_value(CodeOffsets::Deopt, pc_offset);
1333         break;
1334       case INVOKEVIRTUAL:
1335       case INVOKEINTERFACE:
1336       case INLINE_INVOKE:
1337       case INVOKESTATIC:
1338       case INVOKESPECIAL:
1339         _next_call_type = (MarkId) id;
1340         _invoke_mark_pc = pc;
1341         break;
1342       case POLL_NEAR:
1343       case POLL_FAR:
1344       case POLL_RETURN_NEAR:
1345       case POLL_RETURN_FAR:
<span class="line-modified">1346         pd_relocate_poll(pc, id, CHECK);</span>
1347         break;
1348       case CARD_TABLE_SHIFT:
1349       case CARD_TABLE_ADDRESS:
1350       case HEAP_TOP_ADDRESS:
1351       case HEAP_END_ADDRESS:
1352       case NARROW_KLASS_BASE_ADDRESS:
1353       case NARROW_OOP_BASE_ADDRESS:
1354       case CRC_TABLE_ADDRESS:
1355       case LOG_OF_HEAP_REGION_GRAIN_BYTES:
1356       case INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED:
1357         break;
1358       default:
1359         JVMCI_ERROR(&quot;invalid mark id: %d&quot;, id);
1360         break;
1361     }
1362   }
1363 }
</pre>
</td>
<td>
<hr />
<pre>
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;


  25 #include &quot;code/compiledIC.hpp&quot;

  26 #include &quot;compiler/compileBroker.hpp&quot;



  27 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;

  28 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  29 #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="line-modified">  30 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-modified">  31 #include &quot;oops/compressedOops.inline.hpp&quot;</span>




  32 #include &quot;runtime/interfaceSupport.inline.hpp&quot;

  33 #include &quot;runtime/jniHandles.inline.hpp&quot;

  34 #include &quot;runtime/sharedRuntime.hpp&quot;
  35 #include &quot;utilities/align.hpp&quot;
  36 
  37 // frequently used constants
  38 // Allocate them with new so they are never destroyed (otherwise, a
  39 // forced exit could destroy these objects while they are still in
  40 // use).
<span class="line-modified">  41 ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantOopWriteValue(NULL);</span>
<span class="line-modified">  42 ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(-1);</span>
<span class="line-modified">  43 ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue((jint)0);</span>
<span class="line-modified">  44 ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(1);</span>
<span class="line-modified">  45 ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(2);</span>
<span class="line-modified">  46 LocationValue*         CodeInstaller::_illegal_value = new (ResourceObj::C_HEAP, mtJVMCI) LocationValue(Location());</span>
<span class="line-modified">  47 </span>
<span class="line-modified">  48 VMReg CodeInstaller::getVMRegFromLocation(JVMCIObject location, int total_frame_size, JVMCI_TRAPS) {</span>





  49   if (location.is_null()) {
<span class="line-modified">  50     JVMCI_THROW_NULL(NullPointerException);</span>
  51   }
  52 
<span class="line-modified">  53   JVMCIObject reg = jvmci_env()-&gt;get_code_Location_reg(location);</span>
<span class="line-modified">  54   jint offset = jvmci_env()-&gt;get_code_Location_offset(location);</span>
  55 
<span class="line-modified">  56   if (reg.is_non_null()) {</span>
  57     // register
<span class="line-modified">  58     jint number = jvmci_env()-&gt;get_code_Register_number(reg);</span>
<span class="line-modified">  59     VMReg vmReg = CodeInstaller::get_hotspot_reg(number, JVMCI_CHECK_NULL);</span>
  60     if (offset % 4 == 0) {
  61       return vmReg-&gt;next(offset / 4);
  62     } else {
  63       JVMCI_ERROR_NULL(&quot;unaligned subregister offset %d in oop map&quot;, offset);
  64     }
  65   } else {
  66     // stack slot
  67     if (offset % 4 == 0) {
  68       VMReg vmReg = VMRegImpl::stack2reg(offset / 4);
  69       if (!OopMapValue::legal_vm_reg_name(vmReg)) {
  70         // This restriction only applies to VMRegs that are used in OopMap but
  71         // since that&#39;s the only use of VMRegs it&#39;s simplest to put this test
  72         // here.  This test should also be equivalent legal_vm_reg_name but JVMCI
  73         // clients can use max_oop_map_stack_stack_offset to detect this problem
  74         // directly.  The asserts just ensure that the tests are in agreement.
  75         assert(offset &gt; CompilerToVM::Data::max_oop_map_stack_offset(), &quot;illegal VMReg&quot;);
  76         JVMCI_ERROR_NULL(&quot;stack offset %d is too large to be encoded in OopMap (max %d)&quot;,
  77                          offset, CompilerToVM::Data::max_oop_map_stack_offset());
  78       }
  79       assert(OopMapValue::legal_vm_reg_name(vmReg), &quot;illegal VMReg&quot;);
  80       return vmReg;
  81     } else {
  82       JVMCI_ERROR_NULL(&quot;unaligned stack offset %d in oop map&quot;, offset);
  83     }
  84   }
  85 }
  86 


























  87 // creates a HotSpot oop map out of the byte arrays provided by DebugInfo
<span class="line-modified">  88 OopMap* CodeInstaller::create_oop_map(JVMCIObject debug_info, JVMCI_TRAPS) {</span>
<span class="line-modified">  89   JVMCIObject reference_map = jvmci_env()-&gt;get_DebugInfo_referenceMap(debug_info);</span>
  90   if (reference_map.is_null()) {
<span class="line-modified">  91     JVMCI_THROW_NULL(NullPointerException);</span>
  92   }
<span class="line-modified">  93   if (!jvmci_env()-&gt;isa_HotSpotReferenceMap(reference_map)) {</span>
<span class="line-modified">  94     JVMCI_ERROR_NULL(&quot;unknown reference map: %s&quot;, jvmci_env()-&gt;klass_name(reference_map));</span>
  95   }
<span class="line-modified">  96   if (!_has_wide_vector &amp;&amp; SharedRuntime::is_wide_vector(jvmci_env()-&gt;get_HotSpotReferenceMap_maxRegisterSize(reference_map))) {</span>
  97     if (SharedRuntime::polling_page_vectors_safepoint_handler_blob() == NULL) {
  98       JVMCI_ERROR_NULL(&quot;JVMCI is producing code using vectors larger than the runtime supports&quot;);
  99     }
 100     _has_wide_vector = true;
 101   }
 102   OopMap* map = new OopMap(_total_frame_size, _parameter_count);
<span class="line-modified"> 103   JVMCIObjectArray objects = jvmci_env()-&gt;get_HotSpotReferenceMap_objects(reference_map);</span>
<span class="line-modified"> 104   JVMCIObjectArray derivedBase = jvmci_env()-&gt;get_HotSpotReferenceMap_derivedBase(reference_map);</span>
<span class="line-modified"> 105   JVMCIPrimitiveArray sizeInBytes = jvmci_env()-&gt;get_HotSpotReferenceMap_sizeInBytes(reference_map);</span>
 106   if (objects.is_null() || derivedBase.is_null() || sizeInBytes.is_null()) {
<span class="line-modified"> 107     JVMCI_THROW_NULL(NullPointerException);</span>
 108   }
<span class="line-modified"> 109   if (JVMCIENV-&gt;get_length(objects) != JVMCIENV-&gt;get_length(derivedBase) || JVMCIENV-&gt;get_length(objects) != JVMCIENV-&gt;get_length(sizeInBytes)) {</span>
<span class="line-modified"> 110     JVMCI_ERROR_NULL(&quot;arrays in reference map have different sizes: %d %d %d&quot;, JVMCIENV-&gt;get_length(objects), JVMCIENV-&gt;get_length(derivedBase), JVMCIENV-&gt;get_length(sizeInBytes));</span>
 111   }
<span class="line-modified"> 112   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(objects); i++) {</span>
<span class="line-modified"> 113     JVMCIObject location = JVMCIENV-&gt;get_object_at(objects, i);</span>
<span class="line-modified"> 114     JVMCIObject baseLocation = JVMCIENV-&gt;get_object_at(derivedBase, i);</span>
<span class="line-modified"> 115     jint bytes = JVMCIENV-&gt;get_int_at(sizeInBytes, i);</span>
 116 
<span class="line-modified"> 117     VMReg vmReg = getVMRegFromLocation(location, _total_frame_size, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 118     if (baseLocation.is_non_null()) {</span>
 119       // derived oop
 120 #ifdef _LP64
 121       if (bytes == 8) {
 122 #else
 123       if (bytes == 4) {
 124 #endif
<span class="line-modified"> 125         VMReg baseReg = getVMRegFromLocation(baseLocation, _total_frame_size, JVMCI_CHECK_NULL);</span>
 126         map-&gt;set_derived_oop(vmReg, baseReg);
 127       } else {
 128         JVMCI_ERROR_NULL(&quot;invalid derived oop size in ReferenceMap: %d&quot;, bytes);
 129       }
 130 #ifdef _LP64
 131     } else if (bytes == 8) {
 132       // wide oop
 133       map-&gt;set_oop(vmReg);
 134     } else if (bytes == 4) {
 135       // narrow oop
 136       map-&gt;set_narrowoop(vmReg);
 137 #else
 138     } else if (bytes == 4) {
 139       map-&gt;set_oop(vmReg);
 140 #endif
 141     } else {
 142       JVMCI_ERROR_NULL(&quot;invalid oop size in ReferenceMap: %d&quot;, bytes);
 143     }
 144   }
 145 
<span class="line-modified"> 146   JVMCIObject callee_save_info = jvmci_env()-&gt;get_DebugInfo_calleeSaveInfo(debug_info);</span>
<span class="line-modified"> 147   if (callee_save_info.is_non_null()) {</span>
<span class="line-modified"> 148     JVMCIObjectArray registers = jvmci_env()-&gt;get_RegisterSaveLayout_registers(callee_save_info);</span>
<span class="line-modified"> 149     JVMCIPrimitiveArray slots = jvmci_env()-&gt;get_RegisterSaveLayout_slots(callee_save_info);</span>
<span class="line-modified"> 150     for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(slots); i++) {</span>
<span class="line-modified"> 151       JVMCIObject jvmci_reg = JVMCIENV-&gt;get_object_at(registers, i);</span>
<span class="line-modified"> 152       jint jvmci_reg_number = jvmci_env()-&gt;get_code_Register_number(jvmci_reg);</span>
<span class="line-modified"> 153       VMReg hotspot_reg = CodeInstaller::get_hotspot_reg(jvmci_reg_number, JVMCI_CHECK_NULL);</span>
 154       // HotSpot stack slots are 4 bytes
<span class="line-modified"> 155       jint jvmci_slot = JVMCIENV-&gt;get_int_at(slots, i);</span>
 156       jint hotspot_slot = jvmci_slot * VMRegImpl::slots_per_word;
 157       VMReg hotspot_slot_as_reg = VMRegImpl::stack2reg(hotspot_slot);
 158       map-&gt;set_callee_saved(hotspot_slot_as_reg, hotspot_reg);
 159 #ifdef _LP64
 160       // (copied from generate_oop_map() in c1_Runtime1_x86.cpp)
 161       VMReg hotspot_slot_hi_as_reg = VMRegImpl::stack2reg(hotspot_slot + 1);
 162       map-&gt;set_callee_saved(hotspot_slot_hi_as_reg, hotspot_reg-&gt;next());
 163 #endif
 164     }
 165   }
 166   return map;
 167 }
 168 
 169 #if INCLUDE_AOT
<span class="line-modified"> 170 AOTOopRecorder::AOTOopRecorder(CodeInstaller* code_inst, Arena* arena, bool deduplicate) : OopRecorder(arena, deduplicate) {</span>
<span class="line-added"> 171   _code_inst = code_inst;</span>
 172   _meta_refs = new GrowableArray&lt;jobject&gt;();
 173 }
 174 
 175 int AOTOopRecorder::nr_meta_refs() const {
 176   return _meta_refs-&gt;length();
 177 }
 178 
 179 jobject AOTOopRecorder::meta_element(int pos) const {
 180   return _meta_refs-&gt;at(pos);
 181 }
 182 
 183 int AOTOopRecorder::find_index(Metadata* h) {
 184   JavaThread* THREAD = JavaThread::current();
<span class="line-added"> 185   JVMCIEnv* JVMCIENV = _code_inst-&gt;jvmci_env();</span>
 186   int oldCount = metadata_count();
 187   int index =  this-&gt;OopRecorder::find_index(h);
 188   int newCount = metadata_count();
 189 
 190   if (oldCount == newCount) {
 191     // found a match
 192     return index;
 193   }
 194 
 195   vmassert(index + 1 == newCount, &quot;must be last&quot;);
 196 
 197   JVMCIKlassHandle klass(THREAD);
<span class="line-modified"> 198   JVMCIObject result;</span>
 199   guarantee(h != NULL,
 200             &quot;If DebugInformationRecorder::describe_scope passes NULL oldCount == newCount must hold.&quot;);
 201   if (h-&gt;is_klass()) {
 202     klass = (Klass*) h;
<span class="line-modified"> 203     result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CATCH);</span>
 204   } else if (h-&gt;is_method()) {
 205     Method* method = (Method*) h;
<span class="line-modified"> 206     methodHandle mh(THREAD, method);</span>
<span class="line-modified"> 207     result = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CATCH);</span>
 208   }
<span class="line-modified"> 209   jobject ref = JVMCIENV-&gt;get_jobject(result);</span>
 210   record_meta_ref(ref, index);
 211 
 212   return index;
 213 }
 214 
 215 int AOTOopRecorder::find_index(jobject h) {
 216   if (h == NULL) {
 217     return 0;
 218   }
 219   oop javaMirror = JNIHandles::resolve(h);
 220   Klass* klass = java_lang_Class::as_Klass(javaMirror);
 221   return find_index(klass);
 222 }
 223 
 224 void AOTOopRecorder::record_meta_ref(jobject o, int index) {
 225   assert(index &gt; 0, &quot;must be 1..n&quot;);
 226   index -= 1; // reduce by one to convert to array index
 227 
 228   assert(index == _meta_refs-&gt;length(), &quot;must be last&quot;);
 229   _meta_refs-&gt;append(o);
 230 }
 231 #endif // INCLUDE_AOT
 232 
<span class="line-modified"> 233 void* CodeInstaller::record_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS) {</span>
 234   /*
 235    * This method needs to return a raw (untyped) pointer, since the value of a pointer to the base
 236    * class is in general not equal to the pointer of the subclass. When patching metaspace pointers,
 237    * the compiler expects a direct pointer to the subclass (Klass* or Method*), not a pointer to the
 238    * base class (Metadata* or MetaspaceObj*).
 239    */
<span class="line-modified"> 240   JVMCIObject obj = jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_metaspaceObject(constant);</span>
<span class="line-modified"> 241   if (jvmci_env()-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {</span>
<span class="line-modified"> 242     Klass* klass = JVMCIENV-&gt;asKlass(obj);</span>
<span class="line-modified"> 243     assert(!jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant), &quot;unexpected compressed klass pointer %s @ &quot; INTPTR_FORMAT, klass-&gt;name()-&gt;as_C_string(), p2i(klass));</span>
 244     int index = _oop_recorder-&gt;find_index(klass);
 245     section-&gt;relocate(dest, metadata_Relocation::spec(index));
 246     TRACE_jvmci_3(&quot;metadata[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), klass-&gt;name()-&gt;as_C_string());
 247     return klass;
<span class="line-modified"> 248   } else if (jvmci_env()-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {</span>
<span class="line-modified"> 249     Method* method = jvmci_env()-&gt;asMethod(obj);</span>
<span class="line-modified"> 250     assert(!jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant), &quot;unexpected compressed method pointer %s @ &quot; INTPTR_FORMAT, method-&gt;name()-&gt;as_C_string(), p2i(method));</span>
 251     int index = _oop_recorder-&gt;find_index(method);
 252     section-&gt;relocate(dest, metadata_Relocation::spec(index));
 253     TRACE_jvmci_3(&quot;metadata[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), method-&gt;name()-&gt;as_C_string());
 254     return method;
 255   } else {
<span class="line-modified"> 256     JVMCI_ERROR_NULL(&quot;unexpected metadata reference for constant of type %s&quot;, jvmci_env()-&gt;klass_name(obj));</span>
 257   }
 258 }
 259 
 260 #ifdef _LP64
<span class="line-modified"> 261 narrowKlass CodeInstaller::record_narrow_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS) {</span>
<span class="line-modified"> 262   JVMCIObject obj = jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_metaspaceObject(constant);</span>
<span class="line-modified"> 263   assert(jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant), &quot;unexpected uncompressed pointer&quot;);</span>
 264 
<span class="line-modified"> 265   if (!jvmci_env()-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {</span>
<span class="line-modified"> 266     JVMCI_ERROR_0(&quot;unexpected compressed pointer of type %s&quot;, jvmci_env()-&gt;klass_name(obj));</span>
 267   }
 268 
<span class="line-modified"> 269   Klass* klass = JVMCIENV-&gt;asKlass(obj);</span>
 270   int index = _oop_recorder-&gt;find_index(klass);
 271   section-&gt;relocate(dest, metadata_Relocation::spec(index));
 272   TRACE_jvmci_3(&quot;narrowKlass[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), klass-&gt;name()-&gt;as_C_string());
<span class="line-modified"> 273   return CompressedKlassPointers::encode(klass);</span>
 274 }
 275 #endif
 276 
<span class="line-modified"> 277 Location::Type CodeInstaller::get_oop_type(JVMCIObject value) {</span>
<span class="line-modified"> 278   JVMCIObject valueKind = jvmci_env()-&gt;get_Value_valueKind(value);</span>
<span class="line-modified"> 279   JVMCIObject platformKind = jvmci_env()-&gt;get_ValueKind_platformKind(valueKind);</span>
 280 
<span class="line-modified"> 281   if (jvmci_env()-&gt;equals(platformKind, word_kind())) {</span>
 282     return Location::oop;
 283   } else {
 284     return Location::narrowoop;
 285   }
 286 }
 287 
<span class="line-modified"> 288 ScopeValue* CodeInstaller::get_scope_value(JVMCIObject value, BasicType type, GrowableArray&lt;ScopeValue*&gt;* objects, ScopeValue* &amp;second, JVMCI_TRAPS) {</span>
 289   second = NULL;
 290   if (value.is_null()) {
<span class="line-modified"> 291     JVMCI_THROW_NULL(NullPointerException);</span>
<span class="line-modified"> 292   } else if (JVMCIENV-&gt;equals(value, jvmci_env()-&gt;get_Value_ILLEGAL())) {</span>
 293     if (type != T_ILLEGAL) {
 294       JVMCI_ERROR_NULL(&quot;unexpected illegal value, expected %s&quot;, basictype_to_str(type));
 295     }
 296     return _illegal_value;
<span class="line-modified"> 297   } else if (jvmci_env()-&gt;isa_RegisterValue(value)) {</span>
<span class="line-modified"> 298     JVMCIObject reg = jvmci_env()-&gt;get_RegisterValue_reg(value);</span>
<span class="line-modified"> 299     jint number = jvmci_env()-&gt;get_code_Register_number(reg);</span>
<span class="line-modified"> 300     VMReg hotspotRegister = get_hotspot_reg(number, JVMCI_CHECK_NULL);</span>
 301     if (is_general_purpose_reg(hotspotRegister)) {
 302       Location::Type locationType;
 303       if (type == T_OBJECT) {
<span class="line-modified"> 304         locationType = get_oop_type(value);</span>
 305       } else if (type == T_LONG) {
 306         locationType = Location::lng;
 307       } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {
 308         locationType = Location::int_in_long;
 309       } else {
 310         JVMCI_ERROR_NULL(&quot;unexpected type %s in cpu register&quot;, basictype_to_str(type));
 311       }
 312       ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));
 313       if (type == T_LONG) {
 314         second = value;
 315       }
 316       return value;
 317     } else {
 318       Location::Type locationType;
 319       if (type == T_FLOAT) {
 320         // this seems weird, but the same value is used in c1_LinearScan
 321         locationType = Location::normal;
 322       } else if (type == T_DOUBLE) {
 323         locationType = Location::dbl;
 324       } else {
 325         JVMCI_ERROR_NULL(&quot;unexpected type %s in floating point register&quot;, basictype_to_str(type));
 326       }
 327       ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));
 328       if (type == T_DOUBLE) {
 329         second = value;
 330       }
 331       return value;
 332     }
<span class="line-modified"> 333   } else if (jvmci_env()-&gt;isa_StackSlot(value)) {</span>
<span class="line-modified"> 334     jint offset = jvmci_env()-&gt;get_StackSlot_offset(value);</span>
<span class="line-modified"> 335     if (jvmci_env()-&gt;get_StackSlot_addFrameSize(value)) {</span>
 336       offset += _total_frame_size;
 337     }
 338 
 339     Location::Type locationType;
 340     if (type == T_OBJECT) {
<span class="line-modified"> 341       locationType = get_oop_type(value);</span>
 342     } else if (type == T_LONG) {
 343       locationType = Location::lng;
 344     } else if (type == T_DOUBLE) {
 345       locationType = Location::dbl;
 346     } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {
 347       locationType = Location::normal;
 348     } else {
 349       JVMCI_ERROR_NULL(&quot;unexpected type %s in stack slot&quot;, basictype_to_str(type));
 350     }
 351     ScopeValue* value = new LocationValue(Location::new_stk_loc(locationType, offset));
 352     if (type == T_DOUBLE || type == T_LONG) {
 353       second = value;
 354     }
 355     return value;
<span class="line-modified"> 356   } else if (jvmci_env()-&gt;isa_JavaConstant(value)) {</span>
<span class="line-modified"> 357     if (jvmci_env()-&gt;isa_PrimitiveConstant(value)) {</span>
<span class="line-modified"> 358       if (jvmci_env()-&gt;isa_RawConstant(value)) {</span>
<span class="line-modified"> 359         jlong prim = jvmci_env()-&gt;get_PrimitiveConstant_primitive(value);</span>
 360         return new ConstantLongValue(prim);
 361       } else {
<span class="line-modified"> 362         BasicType constantType = jvmci_env()-&gt;kindToBasicType(jvmci_env()-&gt;get_PrimitiveConstant_kind(value), JVMCI_CHECK_NULL);</span>

 363         if (type != constantType) {
 364           JVMCI_ERROR_NULL(&quot;primitive constant type doesn&#39;t match, expected %s but got %s&quot;, basictype_to_str(type), basictype_to_str(constantType));
 365         }
 366         if (type == T_INT || type == T_FLOAT) {
<span class="line-modified"> 367           jint prim = (jint)jvmci_env()-&gt;get_PrimitiveConstant_primitive(value);</span>
 368           switch (prim) {
 369             case -1: return _int_m1_scope_value;
 370             case  0: return _int_0_scope_value;
 371             case  1: return _int_1_scope_value;
 372             case  2: return _int_2_scope_value;
 373             default: return new ConstantIntValue(prim);
 374           }
 375         } else if (type == T_LONG || type == T_DOUBLE) {
<span class="line-modified"> 376           jlong prim = jvmci_env()-&gt;get_PrimitiveConstant_primitive(value);</span>
 377           second = _int_1_scope_value;
 378           return new ConstantLongValue(prim);
 379         } else {
 380           JVMCI_ERROR_NULL(&quot;unexpected primitive constant type %s&quot;, basictype_to_str(type));
 381         }
 382       }
<span class="line-modified"> 383     } else if (jvmci_env()-&gt;isa_NullConstant(value) || jvmci_env()-&gt;isa_HotSpotCompressedNullConstant(value)) {</span>
 384       if (type == T_OBJECT) {
 385         return _oop_null_scope_value;
 386       } else {
 387         JVMCI_ERROR_NULL(&quot;unexpected null constant, expected %s&quot;, basictype_to_str(type));
 388       }
<span class="line-modified"> 389     } else if (jvmci_env()-&gt;isa_HotSpotObjectConstantImpl(value)) {</span>
 390       if (type == T_OBJECT) {
<span class="line-modified"> 391         Handle obj = jvmci_env()-&gt;asConstant(value, JVMCI_CHECK_NULL);</span>
 392         if (obj == NULL) {
 393           JVMCI_ERROR_NULL(&quot;null value must be in NullConstant&quot;);
 394         }
<span class="line-modified"> 395         return new ConstantOopWriteValue(JNIHandles::make_local(obj()));</span>
 396       } else {
 397         JVMCI_ERROR_NULL(&quot;unexpected object constant, expected %s&quot;, basictype_to_str(type));
 398       }
 399     }
<span class="line-modified"> 400   } else if (jvmci_env()-&gt;isa_VirtualObject(value)) {</span>
 401     if (type == T_OBJECT) {
<span class="line-modified"> 402       int id = jvmci_env()-&gt;get_VirtualObject_id(value);</span>
 403       if (0 &lt;= id &amp;&amp; id &lt; objects-&gt;length()) {
 404         ScopeValue* object = objects-&gt;at(id);
 405         if (object != NULL) {
 406           return object;
 407         }
 408       }
 409       JVMCI_ERROR_NULL(&quot;unknown virtual object id %d&quot;, id);
 410     } else {
 411       JVMCI_ERROR_NULL(&quot;unexpected virtual object, expected %s&quot;, basictype_to_str(type));
 412     }
 413   }
 414 
<span class="line-modified"> 415   JVMCI_ERROR_NULL(&quot;unexpected value in scope: %s&quot;, jvmci_env()-&gt;klass_name(value))</span>
 416 }
 417 
<span class="line-modified"> 418 void CodeInstaller::record_object_value(ObjectValue* sv, JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS) {</span>
<span class="line-modified"> 419   JVMCIObject type = jvmci_env()-&gt;get_VirtualObject_type(value);</span>
<span class="line-modified"> 420   int id = jvmci_env()-&gt;get_VirtualObject_id(value);</span>
<span class="line-modified"> 421   Klass* klass = JVMCIENV-&gt;asKlass(type);</span>


 422   bool isLongArray = klass == Universe::longArrayKlassObj();
 423 
<span class="line-modified"> 424   JVMCIObjectArray values = jvmci_env()-&gt;get_VirtualObject_values(value);</span>
<span class="line-modified"> 425   JVMCIObjectArray slotKinds = jvmci_env()-&gt;get_VirtualObject_slotKinds(value);</span>
<span class="line-modified"> 426   for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(values); i++) {</span>

 427     ScopeValue* cur_second = NULL;
<span class="line-modified"> 428     JVMCIObject object = JVMCIENV-&gt;get_object_at(values, i);</span>
<span class="line-modified"> 429     BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);</span>
<span class="line-modified"> 430     ScopeValue* value = get_scope_value(object, type, objects, cur_second, JVMCI_CHECK);</span>

 431 
 432     if (isLongArray &amp;&amp; cur_second == NULL) {
 433       // we&#39;re trying to put ints into a long array... this isn&#39;t really valid, but it&#39;s used for some optimizations.
 434       // add an int 0 constant
 435       cur_second = _int_0_scope_value;
 436     }
 437 
 438     if (cur_second != NULL) {
 439       sv-&gt;field_values()-&gt;append(cur_second);
 440     }
 441     assert(value != NULL, &quot;missing value&quot;);
 442     sv-&gt;field_values()-&gt;append(value);
 443   }
 444 }
 445 
<span class="line-modified"> 446 MonitorValue* CodeInstaller::get_monitor_value(JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS) {</span>
 447   if (value.is_null()) {
<span class="line-modified"> 448     JVMCI_THROW_NULL(NullPointerException);</span>
 449   }
<span class="line-modified"> 450   if (!jvmci_env()-&gt;isa_StackLockValue(value)) {</span>
<span class="line-modified"> 451     JVMCI_ERROR_NULL(&quot;Monitors must be of type StackLockValue, got %s&quot;, jvmci_env()-&gt;klass_name(value));</span>
 452   }
 453 
 454   ScopeValue* second = NULL;
<span class="line-modified"> 455   ScopeValue* owner_value = get_scope_value(jvmci_env()-&gt;get_StackLockValue_owner(value), T_OBJECT, objects, second, JVMCI_CHECK_NULL);</span>

 456   assert(second == NULL, &quot;monitor cannot occupy two stack slots&quot;);
 457 
<span class="line-modified"> 458   ScopeValue* lock_data_value = get_scope_value(jvmci_env()-&gt;get_StackLockValue_slot(value), T_LONG, objects, second, JVMCI_CHECK_NULL);</span>

 459   assert(second == lock_data_value, &quot;monitor is LONG value that occupies two stack slots&quot;);
 460   assert(lock_data_value-&gt;is_location(), &quot;invalid monitor location&quot;);
 461   Location lock_data_loc = ((LocationValue*)lock_data_value)-&gt;location();
 462 
 463   bool eliminated = false;
<span class="line-modified"> 464   if (jvmci_env()-&gt;get_StackLockValue_eliminated(value)) {</span>
 465     eliminated = true;
 466   }
 467 
 468   return new MonitorValue(owner_value, lock_data_loc, eliminated);
 469 }
 470 
<span class="line-modified"> 471 void CodeInstaller::initialize_dependencies(JVMCIObject compiled_code, OopRecorder* oop_recorder, JVMCI_TRAPS) {</span>
 472   JavaThread* thread = JavaThread::current();

 473   CompilerThread* compilerThread = thread-&gt;is_Compiler_thread() ? thread-&gt;as_CompilerThread() : NULL;
<span class="line-modified"> 474   _oop_recorder = oop_recorder;</span>
 475   _dependencies = new Dependencies(&amp;_arena, _oop_recorder, compilerThread != NULL ? compilerThread-&gt;log() : NULL);
<span class="line-modified"> 476   JVMCIObjectArray assumptions = jvmci_env()-&gt;get_HotSpotCompiledCode_assumptions(compiled_code);</span>
<span class="line-modified"> 477   if (assumptions.is_non_null()) {</span>
<span class="line-modified"> 478     int length = JVMCIENV-&gt;get_length(assumptions);</span>
 479     for (int i = 0; i &lt; length; ++i) {
<span class="line-modified"> 480       JVMCIObject assumption = JVMCIENV-&gt;get_object_at(assumptions, i);</span>
<span class="line-modified"> 481       if (assumption.is_non_null()) {</span>
<span class="line-modified"> 482         if (jvmci_env()-&gt;isa_Assumptions_NoFinalizableSubclass(assumption)) {</span>
<span class="line-modified"> 483           assumption_NoFinalizableSubclass(assumption);</span>
<span class="line-modified"> 484         } else if (jvmci_env()-&gt;isa_Assumptions_ConcreteSubtype(assumption)) {</span>
<span class="line-modified"> 485           assumption_ConcreteSubtype(assumption);</span>
<span class="line-modified"> 486         } else if (jvmci_env()-&gt;isa_Assumptions_LeafType(assumption)) {</span>
<span class="line-modified"> 487           assumption_LeafType(assumption);</span>
<span class="line-modified"> 488         } else if (jvmci_env()-&gt;isa_Assumptions_ConcreteMethod(assumption)) {</span>
<span class="line-modified"> 489           assumption_ConcreteMethod(assumption);</span>
<span class="line-modified"> 490         } else if (jvmci_env()-&gt;isa_Assumptions_CallSiteTargetValue(assumption)) {</span>
<span class="line-modified"> 491           assumption_CallSiteTargetValue(assumption, JVMCI_CHECK);</span>
 492         } else {
<span class="line-modified"> 493           JVMCI_ERROR(&quot;unexpected Assumption subclass %s&quot;, jvmci_env()-&gt;klass_name(assumption));</span>
 494         }
 495       }
 496     }
 497   }
 498   if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
<span class="line-modified"> 499     JVMCIObjectArray methods = jvmci_env()-&gt;get_HotSpotCompiledCode_methods(compiled_code);</span>
<span class="line-modified"> 500     if (methods.is_non_null()) {</span>
<span class="line-modified"> 501       int length = JVMCIENV-&gt;get_length(methods);</span>
 502       for (int i = 0; i &lt; length; ++i) {
<span class="line-modified"> 503         JVMCIObject method_handle = JVMCIENV-&gt;get_object_at(methods, i);</span>
<span class="line-modified"> 504         Method* method = jvmci_env()-&gt;asMethod(method_handle);</span>
<span class="line-modified"> 505         _dependencies-&gt;assert_evol_method(method);</span>
 506       }
 507     }
 508   }
 509 }
 510 
 511 #if INCLUDE_AOT
 512 RelocBuffer::~RelocBuffer() {
<span class="line-modified"> 513   FREE_C_HEAP_ARRAY(char, _buffer);</span>


 514 }
 515 
 516 address RelocBuffer::begin() const {
 517   if (_buffer != NULL) {
 518     return (address) _buffer;
 519   }
 520   return (address) _static_buffer;
 521 }
 522 
 523 void RelocBuffer::set_size(size_t bytes) {
 524   assert(bytes &lt;= _size, &quot;can&#39;t grow in size!&quot;);
 525   _size = bytes;
 526 }
 527 
 528 void RelocBuffer::ensure_size(size_t bytes) {
 529   assert(_buffer == NULL, &quot;can only be used once&quot;);
 530   assert(_size == 0, &quot;can only be used once&quot;);
 531   if (bytes &gt;= RelocBuffer::stack_size) {
<span class="line-modified"> 532     _buffer = NEW_C_HEAP_ARRAY(char, bytes, mtJVMCI);</span>
 533   }
 534   _size = bytes;
 535 }
 536 
<span class="line-modified"> 537 JVMCI::CodeInstallResult CodeInstaller::gather_metadata(JVMCIObject target, JVMCIObject compiled_code, CodeMetadata&amp; metadata, JVMCI_TRAPS) {</span>
<span class="line-added"> 538   assert(JVMCIENV-&gt;is_hotspot(), &quot;AOT code is executed only in HotSpot mode&quot;);</span>
 539   CodeBuffer buffer(&quot;JVMCI Compiler CodeBuffer for Metadata&quot;);
<span class="line-modified"> 540   AOTOopRecorder* recorder = new AOTOopRecorder(this, &amp;_arena, true);</span>
<span class="line-modified"> 541   initialize_dependencies(compiled_code, recorder, JVMCI_CHECK_OK);</span>

 542 
 543   metadata.set_oop_recorder(recorder);
 544 
 545   // Get instructions and constants CodeSections early because we need it.
 546   _instructions = buffer.insts();
 547   _constants = buffer.consts();
 548   buffer.set_immutable_PIC(_immutable_pic_compilation);
 549 
<span class="line-modified"> 550   initialize_fields(target, compiled_code, JVMCI_CHECK_OK);</span>
<span class="line-modified"> 551   JVMCI::CodeInstallResult result = initialize_buffer(buffer, false, JVMCI_CHECK_OK);</span>
<span class="line-modified"> 552   if (result != JVMCI::ok) {</span>
 553     return result;
 554   }
 555 
 556   _debug_recorder-&gt;pcs_size(); // create the sentinel record
 557 
 558   assert(_debug_recorder-&gt;pcs_length() &gt;= 2, &quot;must be at least 2&quot;);
 559 
 560   metadata.set_pc_desc(_debug_recorder-&gt;pcs(), _debug_recorder-&gt;pcs_length());
 561   metadata.set_scopes(_debug_recorder-&gt;stream()-&gt;buffer(), _debug_recorder-&gt;data_size());
 562   metadata.set_exception_table(&amp;_exception_handler_table);
<span class="line-added"> 563   metadata.set_implicit_exception_table(&amp;_implicit_exception_table);</span>
 564 
 565   RelocBuffer* reloc_buffer = metadata.get_reloc_buffer();
 566 
 567   reloc_buffer-&gt;ensure_size(buffer.total_relocation_size());
 568   size_t size = (size_t) buffer.copy_relocations_to(reloc_buffer-&gt;begin(), (CodeBuffer::csize_t) reloc_buffer-&gt;size(), true);
 569   reloc_buffer-&gt;set_size(size);
<span class="line-modified"> 570   return JVMCI::ok;</span>
 571 }
 572 #endif // INCLUDE_AOT
 573 
 574 // constructor used to create a method
<span class="line-modified"> 575 JVMCI::CodeInstallResult CodeInstaller::install(JVMCICompiler* compiler,</span>
<span class="line-added"> 576     JVMCIObject target,</span>
<span class="line-added"> 577     JVMCIObject compiled_code,</span>
<span class="line-added"> 578     CodeBlob*&amp; cb,</span>
<span class="line-added"> 579     JVMCIObject installed_code,</span>
<span class="line-added"> 580     FailedSpeculation** failed_speculations,</span>
<span class="line-added"> 581     char* speculations,</span>
<span class="line-added"> 582     int speculations_len,</span>
<span class="line-added"> 583     JVMCI_TRAPS) {</span>
<span class="line-added"> 584 </span>
 585   CodeBuffer buffer(&quot;JVMCI Compiler CodeBuffer&quot;);

 586   OopRecorder* recorder = new OopRecorder(&amp;_arena, true);
<span class="line-modified"> 587   initialize_dependencies(compiled_code, recorder, JVMCI_CHECK_OK);</span>
 588 
 589   // Get instructions and constants CodeSections early because we need it.
 590   _instructions = buffer.insts();
 591   _constants = buffer.consts();
 592 #if INCLUDE_AOT
 593   buffer.set_immutable_PIC(_immutable_pic_compilation);
 594 #endif
 595 
<span class="line-modified"> 596   initialize_fields(target, compiled_code, JVMCI_CHECK_OK);</span>
<span class="line-modified"> 597   JVMCI::CodeInstallResult result = initialize_buffer(buffer, true, JVMCI_CHECK_OK);</span>
<span class="line-modified"> 598   if (result != JVMCI::ok) {</span>
 599     return result;
 600   }
 601 
 602   int stack_slots = _total_frame_size / HeapWordSize; // conversion to words
 603 
<span class="line-modified"> 604   if (!jvmci_env()-&gt;isa_HotSpotCompiledNmethod(compiled_code)) {</span>
<span class="line-modified"> 605     JVMCIObject stubName = jvmci_env()-&gt;get_HotSpotCompiledCode_name(compiled_code);</span>
<span class="line-modified"> 606     if (stubName.is_null()) {</span>
 607       JVMCI_ERROR_OK(&quot;stub should have a name&quot;);
 608     }
<span class="line-modified"> 609     char* name = strdup(jvmci_env()-&gt;as_utf8_string(stubName));</span>
 610     cb = RuntimeStub::new_runtime_stub(name,
 611                                        &amp;buffer,
 612                                        CodeOffsets::frame_never_safe,
 613                                        stack_slots,
 614                                        _debug_recorder-&gt;_oopmaps,
 615                                        false);
<span class="line-modified"> 616     result = JVMCI::ok;</span>
 617   } else {
<span class="line-modified"> 618     JVMCICompileState* compile_state = (JVMCICompileState*) (address) jvmci_env()-&gt;get_HotSpotCompiledNmethod_compileState(compiled_code);</span>
<span class="line-modified"> 619     if (compile_state != NULL) {</span>
<span class="line-modified"> 620       jvmci_env()-&gt;set_compile_state(compile_state);</span>
<span class="line-modified"> 621     }</span>
<span class="line-modified"> 622 </span>
<span class="line-modified"> 623     Thread* thread = Thread::current();</span>
<span class="line-added"> 624 </span>
<span class="line-added"> 625     methodHandle method(thread, jvmci_env()-&gt;asMethod(jvmci_env()-&gt;get_HotSpotCompiledNmethod_method(compiled_code)));</span>
<span class="line-added"> 626     jint entry_bci = jvmci_env()-&gt;get_HotSpotCompiledNmethod_entryBCI(compiled_code);</span>
<span class="line-added"> 627     bool has_unsafe_access = jvmci_env()-&gt;get_HotSpotCompiledNmethod_hasUnsafeAccess(compiled_code) == JNI_TRUE;</span>
<span class="line-added"> 628     jint id = jvmci_env()-&gt;get_HotSpotCompiledNmethod_id(compiled_code);</span>
 629     if (id == -1) {
 630       // Make sure a valid compile_id is associated with every compile
<span class="line-modified"> 631       id = CompileBroker::assign_compile_id_unlocked(thread, method, entry_bci);</span>
<span class="line-added"> 632       jvmci_env()-&gt;set_HotSpotCompiledNmethod_id(compiled_code, id);</span>
<span class="line-added"> 633     }</span>
<span class="line-added"> 634     if (!jvmci_env()-&gt;isa_HotSpotNmethod(installed_code)) {</span>
<span class="line-added"> 635       JVMCI_THROW_MSG_(IllegalArgumentException, &quot;InstalledCode object must be a HotSpotNmethod when installing a HotSpotCompiledNmethod&quot;, JVMCI::ok);</span>
 636     }
<span class="line-modified"> 637 </span>
<span class="line-modified"> 638     JVMCIObject mirror = installed_code;</span>
<span class="line-modified"> 639     nmethod* nm = NULL;</span>
<span class="line-modified"> 640     result = runtime()-&gt;register_method(jvmci_env(), method, nm, entry_bci, &amp;_offsets, _orig_pc_offset, &amp;buffer,</span>
<span class="line-added"> 641                                         stack_slots, _debug_recorder-&gt;_oopmaps, &amp;_exception_handler_table, &amp;_implicit_exception_table,</span>
<span class="line-added"> 642                                         compiler, _debug_recorder, _dependencies, id,</span>
<span class="line-added"> 643                                         has_unsafe_access, _has_wide_vector, compiled_code, mirror,</span>
<span class="line-added"> 644                                         failed_speculations, speculations, speculations_len);</span>
 645     cb = nm-&gt;as_codeblob_or_null();
<span class="line-modified"> 646     if (nm != NULL &amp;&amp; compile_state == NULL) {</span>
<span class="line-added"> 647       // This compile didn&#39;t come through the CompileBroker so perform the printing here</span>
 648       DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);
<span class="line-modified"> 649       nm-&gt;maybe_print_nmethod(directive);</span>



 650       DirectivesStack::release(directive);
 651     }
 652   }
 653 
 654   if (cb != NULL) {
 655     // Make sure the pre-calculated constants section size was correct.
 656     guarantee((cb-&gt;code_begin() - cb-&gt;content_begin()) &gt;= _constants_size, &quot;%d &lt; %d&quot;, (int)(cb-&gt;code_begin() - cb-&gt;content_begin()), _constants_size);
 657   }
 658   return result;
 659 }
 660 
<span class="line-modified"> 661 void CodeInstaller::initialize_fields(JVMCIObject target, JVMCIObject compiled_code, JVMCI_TRAPS) {</span>
<span class="line-modified"> 662   if (jvmci_env()-&gt;isa_HotSpotCompiledNmethod(compiled_code)) {</span>
<span class="line-modified"> 663     JVMCIObject hotspotJavaMethod = jvmci_env()-&gt;get_HotSpotCompiledNmethod_method(compiled_code);</span>
<span class="line-modified"> 664     Thread* thread = Thread::current();</span>
<span class="line-added"> 665     methodHandle method(thread, jvmci_env()-&gt;asMethod(hotspotJavaMethod));</span>
 666     _parameter_count = method-&gt;size_of_parameters();
 667     TRACE_jvmci_2(&quot;installing code for %s&quot;, method-&gt;name_and_sig_as_C_string());
 668   } else {
 669     // Must be a HotSpotCompiledRuntimeStub.
 670     // Only used in OopMap constructor for non-product builds
 671     _parameter_count = 0;
 672   }
<span class="line-modified"> 673   _sites_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_sites(compiled_code);</span>
 674 
<span class="line-modified"> 675   _code_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_targetCode(compiled_code);</span>
<span class="line-modified"> 676   _code_size = jvmci_env()-&gt;get_HotSpotCompiledCode_targetCodeSize(compiled_code);</span>
<span class="line-modified"> 677   _total_frame_size = jvmci_env()-&gt;get_HotSpotCompiledCode_totalFrameSize(compiled_code);</span>
 678 
<span class="line-modified"> 679   JVMCIObject deoptRescueSlot = jvmci_env()-&gt;get_HotSpotCompiledCode_deoptRescueSlot(compiled_code);</span>
<span class="line-modified"> 680   if (deoptRescueSlot.is_null()) {</span>
 681     _orig_pc_offset = -1;
 682   } else {
<span class="line-modified"> 683     _orig_pc_offset = jvmci_env()-&gt;get_StackSlot_offset(deoptRescueSlot);</span>
<span class="line-modified"> 684     if (jvmci_env()-&gt;get_StackSlot_addFrameSize(deoptRescueSlot)) {</span>
 685       _orig_pc_offset += _total_frame_size;
 686     }
 687     if (_orig_pc_offset &lt; 0) {
 688       JVMCI_ERROR(&quot;invalid deopt rescue slot: %d&quot;, _orig_pc_offset);
 689     }
 690   }
 691 
 692   // Pre-calculate the constants section size.  This is required for PC-relative addressing.
<span class="line-modified"> 693   _data_section_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_dataSection(compiled_code);</span>
<span class="line-modified"> 694   if ((_constants-&gt;alignment() % jvmci_env()-&gt;get_HotSpotCompiledCode_dataSectionAlignment(compiled_code)) != 0) {</span>
<span class="line-modified"> 695     JVMCI_ERROR(&quot;invalid data section alignment: %d&quot;, jvmci_env()-&gt;get_HotSpotCompiledCode_dataSectionAlignment(compiled_code));</span>
 696   }
<span class="line-modified"> 697   _constants_size = JVMCIENV-&gt;get_length(data_section());</span>
 698 
<span class="line-modified"> 699   _data_section_patches_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_dataSectionPatches(compiled_code);</span>
 700 
 701 #ifndef PRODUCT
<span class="line-modified"> 702   _comments_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_comments(compiled_code);</span>
 703 #endif
 704 
 705   _next_call_type = INVOKE_INVALID;
 706 
 707   _has_wide_vector = false;
 708 
<span class="line-modified"> 709   JVMCIObject arch = jvmci_env()-&gt;get_TargetDescription_arch(target);</span>
<span class="line-modified"> 710   _word_kind_handle = jvmci_env()-&gt;get_Architecture_wordKind(arch);</span>
 711 }
 712 
<span class="line-modified"> 713 int CodeInstaller::estimate_stubs_size(JVMCI_TRAPS) {</span>
 714   // Estimate the number of static and aot call stubs that might be emitted.
 715   int static_call_stubs = 0;
 716   int aot_call_stubs = 0;
 717   int trampoline_stubs = 0;
<span class="line-modified"> 718   JVMCIObjectArray sites = this-&gt;sites();</span>
<span class="line-modified"> 719   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(sites); i++) {</span>
<span class="line-modified"> 720     JVMCIObject site = JVMCIENV-&gt;get_object_at(sites, i);</span>
<span class="line-modified"> 721     if (!site.is_null()) {</span>
<span class="line-modified"> 722       if (jvmci_env()-&gt;isa_site_Mark(site)) {</span>
<span class="line-modified"> 723         JVMCIObject id_obj = jvmci_env()-&gt;get_site_Mark_id(site);</span>
<span class="line-modified"> 724         if (id_obj.is_non_null()) {</span>
<span class="line-modified"> 725           if (!jvmci_env()-&gt;is_boxing_object(T_INT, id_obj)) {</span>
<span class="line-modified"> 726             JVMCI_ERROR_0(&quot;expected Integer id, got %s&quot;, jvmci_env()-&gt;klass_name(id_obj));</span>
 727           }
<span class="line-modified"> 728           jint id = jvmci_env()-&gt;get_boxed_value(T_INT, id_obj).i;</span>
 729           switch (id) {
<span class="line-modified"> 730             case INVOKEINTERFACE:</span>
<span class="line-modified"> 731             case INVOKEVIRTUAL:</span>
<span class="line-modified"> 732               trampoline_stubs++;</span>
<span class="line-modified"> 733               break;</span>
<span class="line-modified"> 734             case INVOKESTATIC:</span>
<span class="line-modified"> 735             case INVOKESPECIAL:</span>
<span class="line-modified"> 736               static_call_stubs++;</span>
<span class="line-modified"> 737               trampoline_stubs++;</span>
<span class="line-modified"> 738               break;</span>
<span class="line-modified"> 739             default:</span>
<span class="line-modified"> 740               break;</span>
 741           }
 742         }
 743       }
 744 #if INCLUDE_AOT
<span class="line-modified"> 745       if (UseAOT &amp;&amp; jvmci_env()-&gt;isa_site_Call(site)) {</span>
<span class="line-modified"> 746         JVMCIObject target = jvmci_env()-&gt; get_site_Call_target(site);</span>
<span class="line-modified"> 747         if (!jvmci_env()-&gt;isa_HotSpotForeignCallTarget(target)) {</span>

 748           // Add far aot trampolines.
 749           aot_call_stubs++;
 750         }
 751       }
 752 #endif
 753     }
 754   }
 755   int size = static_call_stubs * CompiledStaticCall::to_interp_stub_size();
 756   size += trampoline_stubs * CompiledStaticCall::to_trampoline_stub_size();
 757 #if INCLUDE_AOT
 758   size += aot_call_stubs * CompiledStaticCall::to_aot_stub_size();
 759 #endif
 760   return size;
 761 }
 762 
 763 // perform data and call relocation on the CodeBuffer
<span class="line-modified"> 764 JVMCI::CodeInstallResult CodeInstaller::initialize_buffer(CodeBuffer&amp; buffer, bool check_size, JVMCI_TRAPS) {</span>
 765   HandleMark hm;
<span class="line-modified"> 766   JVMCIObjectArray sites = this-&gt;sites();</span>
<span class="line-modified"> 767   int locs_buffer_size = JVMCIENV-&gt;get_length(sites) * (relocInfo::length_limit + sizeof(relocInfo));</span>
 768 
 769   // Allocate enough space in the stub section for the static call
 770   // stubs.  Stubs have extra relocs but they are managed by the stub
 771   // section itself so they don&#39;t need to be accounted for in the
 772   // locs_buffer above.
<span class="line-modified"> 773   int stubs_size = estimate_stubs_size(JVMCI_CHECK_OK);</span>
 774   int total_size = align_up(_code_size, buffer.insts()-&gt;alignment()) + align_up(_constants_size, buffer.consts()-&gt;alignment()) + align_up(stubs_size, buffer.stubs()-&gt;alignment());
 775 
 776   if (check_size &amp;&amp; total_size &gt; JVMCINMethodSizeLimit) {
<span class="line-modified"> 777     return JVMCI::code_too_large;</span>
 778   }
 779 
 780   buffer.initialize(total_size, locs_buffer_size);
 781   if (buffer.blob() == NULL) {
<span class="line-modified"> 782     return JVMCI::cache_full;</span>
 783   }
 784   buffer.initialize_stubs_size(stubs_size);
 785   buffer.initialize_consts_size(_constants_size);
 786 
 787   _debug_recorder = new DebugInformationRecorder(_oop_recorder);
 788   _debug_recorder-&gt;set_oopmaps(new OopMapSet());
 789 
 790   buffer.initialize_oop_recorder(_oop_recorder);
 791 
 792   // copy the constant data into the newly created CodeBuffer
 793   address end_data = _constants-&gt;start() + _constants_size;
<span class="line-modified"> 794   JVMCIENV-&gt;copy_bytes_to(data_section(), (jbyte*) _constants-&gt;start(), 0, _constants_size);</span>
 795   _constants-&gt;set_end(end_data);
 796 
 797   // copy the code into the newly created CodeBuffer
 798   address end_pc = _instructions-&gt;start() + _code_size;
 799   guarantee(_instructions-&gt;allocates2(end_pc), &quot;initialize should have reserved enough space for all the code&quot;);
<span class="line-modified"> 800   JVMCIENV-&gt;copy_bytes_to(code(), (jbyte*) _instructions-&gt;start(), 0, _code_size);</span>
 801   _instructions-&gt;set_end(end_pc);
 802 
<span class="line-modified"> 803   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(data_section_patches()); i++) {</span>
<span class="line-modified"> 804     // HandleMark hm(THREAD);</span>
<span class="line-modified"> 805     JVMCIObject patch = JVMCIENV-&gt;get_object_at(data_section_patches(), i);</span>
 806     if (patch.is_null()) {
<span class="line-modified"> 807       JVMCI_THROW_(NullPointerException, JVMCI::ok);</span>
 808     }
<span class="line-modified"> 809     JVMCIObject reference = jvmci_env()-&gt;get_site_DataPatch_reference(patch);</span>
 810     if (reference.is_null()) {
<span class="line-modified"> 811       JVMCI_THROW_(NullPointerException, JVMCI::ok);</span>
 812     }
<span class="line-modified"> 813     if (!jvmci_env()-&gt;isa_site_ConstantReference(reference)) {</span>
<span class="line-modified"> 814       JVMCI_ERROR_OK(&quot;invalid patch in data section: %s&quot;, jvmci_env()-&gt;klass_name(reference));</span>
 815     }
<span class="line-modified"> 816     JVMCIObject constant = jvmci_env()-&gt;get_site_ConstantReference_constant(reference);</span>
 817     if (constant.is_null()) {
<span class="line-modified"> 818       JVMCI_THROW_(NullPointerException, JVMCI::ok);</span>
 819     }
<span class="line-modified"> 820     address dest = _constants-&gt;start() + jvmci_env()-&gt;get_site_Site_pcOffset(patch);</span>
<span class="line-modified"> 821     if (jvmci_env()-&gt;isa_HotSpotMetaspaceConstantImpl(constant)) {</span>
<span class="line-modified"> 822       if (jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant)) {</span>
 823 #ifdef _LP64
<span class="line-modified"> 824         *((narrowKlass*) dest) = record_narrow_metadata_reference(_constants, dest, constant, JVMCI_CHECK_OK);</span>
 825 #else
 826         JVMCI_ERROR_OK(&quot;unexpected compressed Klass* in 32-bit mode&quot;);
 827 #endif
 828       } else {
<span class="line-modified"> 829         *((void**) dest) = record_metadata_reference(_constants, dest, constant, JVMCI_CHECK_OK);</span>
 830       }
<span class="line-modified"> 831     } else if (jvmci_env()-&gt;isa_HotSpotObjectConstantImpl(constant)) {</span>
<span class="line-modified"> 832       Handle obj = jvmci_env()-&gt;asConstant(constant, JVMCI_CHECK_OK);</span>
 833       jobject value = JNIHandles::make_local(obj());
 834       int oop_index = _oop_recorder-&gt;find_index(value);
 835 
<span class="line-modified"> 836       if (jvmci_env()-&gt;get_HotSpotObjectConstantImpl_compressed(constant)) {</span>
 837 #ifdef _LP64
 838         _constants-&gt;relocate(dest, oop_Relocation::spec(oop_index), relocInfo::narrow_oop_in_const);
 839 #else
 840         JVMCI_ERROR_OK(&quot;unexpected compressed oop in 32-bit mode&quot;);
 841 #endif
 842       } else {
 843         _constants-&gt;relocate(dest, oop_Relocation::spec(oop_index));
 844       }
 845     } else {
<span class="line-modified"> 846       JVMCI_ERROR_OK(&quot;invalid constant in data section: %s&quot;, jvmci_env()-&gt;klass_name(constant));</span>
 847     }
 848   }
 849   jint last_pc_offset = -1;
<span class="line-modified"> 850   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(sites); i++) {</span>
<span class="line-modified"> 851     // HandleMark hm(THREAD);</span>
<span class="line-modified"> 852     JVMCIObject site = JVMCIENV-&gt;get_object_at(sites, i);</span>
 853     if (site.is_null()) {
<span class="line-modified"> 854       JVMCI_THROW_(NullPointerException, JVMCI::ok);</span>
 855     }
 856 
<span class="line-modified"> 857     jint pc_offset = jvmci_env()-&gt;get_site_Site_pcOffset(site);</span>
 858 
<span class="line-modified"> 859     if (jvmci_env()-&gt;isa_site_Call(site)) {</span>
 860       TRACE_jvmci_4(&quot;call at %i&quot;, pc_offset);
<span class="line-modified"> 861       site_Call(buffer, pc_offset, site, JVMCI_CHECK_OK);</span>
<span class="line-modified"> 862     } else if (jvmci_env()-&gt;isa_site_Infopoint(site)) {</span>
 863       // three reasons for infopoints denote actual safepoints
<span class="line-modified"> 864       JVMCIObject reason = jvmci_env()-&gt;get_site_Infopoint_reason(site);</span>
<span class="line-modified"> 865       if (JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_SAFEPOINT()) ||</span>
<span class="line-added"> 866           JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_CALL()) ||</span>
<span class="line-added"> 867           JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_IMPLICIT_EXCEPTION())) {</span>
 868         TRACE_jvmci_4(&quot;safepoint at %i&quot;, pc_offset);
<span class="line-modified"> 869         site_Safepoint(buffer, pc_offset, site, JVMCI_CHECK_OK);</span>
 870         if (_orig_pc_offset &lt; 0) {
 871           JVMCI_ERROR_OK(&quot;method contains safepoint, but has no deopt rescue slot&quot;);
 872         }
<span class="line-added"> 873         if (JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_IMPLICIT_EXCEPTION())) {</span>
<span class="line-added"> 874           TRACE_jvmci_4(&quot;implicit exception at %i&quot;, pc_offset);</span>
<span class="line-added"> 875           _implicit_exception_table.add_deoptimize(pc_offset);</span>
<span class="line-added"> 876         }</span>
 877       } else {
 878         TRACE_jvmci_4(&quot;infopoint at %i&quot;, pc_offset);
<span class="line-modified"> 879         site_Infopoint(buffer, pc_offset, site, JVMCI_CHECK_OK);</span>
 880       }
<span class="line-modified"> 881     } else if (jvmci_env()-&gt;isa_site_DataPatch(site)) {</span>
 882       TRACE_jvmci_4(&quot;datapatch at %i&quot;, pc_offset);
<span class="line-modified"> 883       site_DataPatch(buffer, pc_offset, site, JVMCI_CHECK_OK);</span>
<span class="line-modified"> 884     } else if (jvmci_env()-&gt;isa_site_Mark(site)) {</span>
 885       TRACE_jvmci_4(&quot;mark at %i&quot;, pc_offset);
<span class="line-modified"> 886       site_Mark(buffer, pc_offset, site, JVMCI_CHECK_OK);</span>
<span class="line-modified"> 887     } else if (jvmci_env()-&gt;isa_site_ExceptionHandler(site)) {</span>
 888       TRACE_jvmci_4(&quot;exceptionhandler at %i&quot;, pc_offset);
 889       site_ExceptionHandler(pc_offset, site);
 890     } else {
<span class="line-modified"> 891       JVMCI_ERROR_OK(&quot;unexpected site subclass: %s&quot;, jvmci_env()-&gt;klass_name(site));</span>
 892     }
 893     last_pc_offset = pc_offset;
 894 
 895     JavaThread* thread = JavaThread::current();
 896     if (SafepointMechanism::should_block(thread)) {
 897       // this is a hacky way to force a safepoint check but nothing else was jumping out at me.
 898       ThreadToNativeFromVM ttnfv(thread);
 899     }
 900   }
 901 
 902 #ifndef PRODUCT
<span class="line-modified"> 903   if (comments().is_non_null()) {</span>
<span class="line-modified"> 904     for (int i = 0; i &lt; JVMCIENV-&gt;get_length(comments()); i++) {</span>
<span class="line-modified"> 905       JVMCIObject comment = JVMCIENV-&gt;get_object_at(comments(), i);</span>
<span class="line-modified"> 906       assert(jvmci_env()-&gt;isa_HotSpotCompiledCode_Comment(comment), &quot;cce&quot;);</span>
<span class="line-modified"> 907       jint offset = jvmci_env()-&gt;get_HotSpotCompiledCode_Comment_pcOffset(comment);</span>
<span class="line-modified"> 908       const char* text = jvmci_env()-&gt;as_utf8_string(jvmci_env()-&gt;get_HotSpotCompiledCode_Comment_text(comment));</span>
 909       buffer.block_comment(offset, text);
 910     }
 911   }
 912 #endif
<span class="line-modified"> 913   return JVMCI::ok;</span>
 914 }
 915 
<span class="line-modified"> 916 void CodeInstaller::assumption_NoFinalizableSubclass(JVMCIObject assumption) {</span>
<span class="line-modified"> 917   JVMCIObject receiverType_handle = jvmci_env()-&gt;get_Assumptions_NoFinalizableSubclass_receiverType(assumption);</span>
<span class="line-modified"> 918   Klass* receiverType = jvmci_env()-&gt;asKlass(receiverType_handle);</span>
 919   _dependencies-&gt;assert_has_no_finalizable_subclasses(receiverType);
 920 }
 921 
<span class="line-modified"> 922 void CodeInstaller::assumption_ConcreteSubtype(JVMCIObject assumption) {</span>
<span class="line-modified"> 923   JVMCIObject context_handle = jvmci_env()-&gt;get_Assumptions_ConcreteSubtype_context(assumption);</span>
<span class="line-modified"> 924   JVMCIObject subtype_handle = jvmci_env()-&gt;get_Assumptions_ConcreteSubtype_subtype(assumption);</span>
<span class="line-modified"> 925   Klass* context = jvmci_env()-&gt;asKlass(context_handle);</span>
<span class="line-modified"> 926   Klass* subtype = jvmci_env()-&gt;asKlass(subtype_handle);</span>
 927 
 928   assert(context-&gt;is_abstract(), &quot;&quot;);
 929   _dependencies-&gt;assert_abstract_with_unique_concrete_subtype(context, subtype);
 930 }
 931 
<span class="line-modified"> 932 void CodeInstaller::assumption_LeafType(JVMCIObject assumption) {</span>
<span class="line-modified"> 933   JVMCIObject context_handle = jvmci_env()-&gt;get_Assumptions_LeafType_context(assumption);</span>
<span class="line-modified"> 934   Klass* context = jvmci_env()-&gt;asKlass(context_handle);</span>
 935 
 936   _dependencies-&gt;assert_leaf_type(context);
 937 }
 938 
<span class="line-modified"> 939 void CodeInstaller::assumption_ConcreteMethod(JVMCIObject assumption) {</span>
<span class="line-modified"> 940   JVMCIObject impl_handle = jvmci_env()-&gt;get_Assumptions_ConcreteMethod_impl(assumption);</span>
<span class="line-modified"> 941   JVMCIObject context_handle = jvmci_env()-&gt;get_Assumptions_ConcreteMethod_context(assumption);</span>
 942 
<span class="line-modified"> 943   Method* impl = jvmci_env()-&gt;asMethod(impl_handle);</span>
<span class="line-modified"> 944   Klass* context = jvmci_env()-&gt;asKlass(context_handle);</span>
 945 
<span class="line-modified"> 946   _dependencies-&gt;assert_unique_concrete_method(context, impl);</span>
 947 }
 948 
<span class="line-modified"> 949 void CodeInstaller::assumption_CallSiteTargetValue(JVMCIObject assumption, JVMCI_TRAPS) {</span>
<span class="line-modified"> 950   JVMCIObject callSiteConstant = jvmci_env()-&gt;get_Assumptions_CallSiteTargetValue_callSite(assumption);</span>
<span class="line-modified"> 951   Handle callSite = jvmci_env()-&gt;asConstant(callSiteConstant, JVMCI_CHECK);</span>
<span class="line-modified"> 952   JVMCIObject methodConstant = jvmci_env()-&gt;get_Assumptions_CallSiteTargetValue_methodHandle(assumption);</span>
<span class="line-added"> 953   Handle methodHandle = jvmci_env()-&gt;asConstant(methodConstant, JVMCI_CHECK);</span>
 954   _dependencies-&gt;assert_call_site_target_value(callSite(), methodHandle());
 955 }
 956 
<span class="line-modified"> 957 void CodeInstaller::site_ExceptionHandler(jint pc_offset, JVMCIObject exc) {</span>
<span class="line-modified"> 958   jint handler_offset = jvmci_env()-&gt;get_site_ExceptionHandler_handlerPos(exc);</span>
 959 
 960   // Subtable header
 961   _exception_handler_table.add_entry(HandlerTableEntry(1, pc_offset, 0));
 962 
 963   // Subtable entry
 964   _exception_handler_table.add_entry(HandlerTableEntry(-1, handler_offset, 0));
 965 }
 966 
 967 // If deoptimization happens, the interpreter should reexecute these bytecodes.
 968 // This function mainly helps the compilers to set up the reexecute bit.
 969 static bool bytecode_should_reexecute(Bytecodes::Code code) {
 970   switch (code) {
 971     case Bytecodes::_invokedynamic:
 972     case Bytecodes::_invokevirtual:
 973     case Bytecodes::_invokeinterface:
 974     case Bytecodes::_invokespecial:
 975     case Bytecodes::_invokestatic:
 976       return false;
 977     default:
 978       return true;
 979     }
 980   return true;
 981 }
 982 
<span class="line-modified"> 983 GrowableArray&lt;ScopeValue*&gt;* CodeInstaller::record_virtual_objects(JVMCIObject debug_info, JVMCI_TRAPS) {</span>
<span class="line-modified"> 984   JVMCIObjectArray virtualObjects = jvmci_env()-&gt;get_DebugInfo_virtualObjectMapping(debug_info);</span>
 985   if (virtualObjects.is_null()) {
 986     return NULL;
 987   }
<span class="line-modified"> 988   GrowableArray&lt;ScopeValue*&gt;* objects = new GrowableArray&lt;ScopeValue*&gt;(JVMCIENV-&gt;get_length(virtualObjects), JVMCIENV-&gt;get_length(virtualObjects), NULL);</span>
 989   // Create the unique ObjectValues
<span class="line-modified"> 990   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(virtualObjects); i++) {</span>
<span class="line-modified"> 991     // HandleMark hm(THREAD);</span>
<span class="line-modified"> 992     JVMCIObject value = JVMCIENV-&gt;get_object_at(virtualObjects, i);</span>
<span class="line-modified"> 993     int id = jvmci_env()-&gt;get_VirtualObject_id(value);</span>
<span class="line-modified"> 994     JVMCIObject type = jvmci_env()-&gt;get_VirtualObject_type(value);</span>
<span class="line-modified"> 995     bool is_auto_box = jvmci_env()-&gt;get_VirtualObject_isAutoBox(value);</span>
<span class="line-modified"> 996     Klass* klass = jvmci_env()-&gt;asKlass(type);</span>
<span class="line-added"> 997     oop javaMirror = klass-&gt;java_mirror();</span>
<span class="line-added"> 998     ScopeValue *klass_sv = new ConstantOopWriteValue(JNIHandles::make_local(Thread::current(), javaMirror));</span>
<span class="line-added"> 999     ObjectValue* sv = is_auto_box ? new AutoBoxObjectValue(id, klass_sv) : new ObjectValue(id, klass_sv);</span>
1000     if (id &lt; 0 || id &gt;= objects-&gt;length()) {
1001       JVMCI_ERROR_NULL(&quot;virtual object id %d out of bounds&quot;, id);
1002     }
1003     if (objects-&gt;at(id) != NULL) {
1004       JVMCI_ERROR_NULL(&quot;duplicate virtual object id %d&quot;, id);
1005     }
1006     objects-&gt;at_put(id, sv);
1007   }
1008   // All the values which could be referenced by the VirtualObjects
1009   // exist, so now describe all the VirtualObjects themselves.
<span class="line-modified">1010   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(virtualObjects); i++) {</span>
<span class="line-modified">1011     // HandleMark hm(THREAD);</span>
<span class="line-modified">1012     JVMCIObject value = JVMCIENV-&gt;get_object_at(virtualObjects, i);</span>
<span class="line-modified">1013     int id = jvmci_env()-&gt;get_VirtualObject_id(value);</span>
<span class="line-modified">1014     record_object_value(objects-&gt;at(id)-&gt;as_ObjectValue(), value, objects, JVMCI_CHECK_NULL);</span>
1015   }
1016   _debug_recorder-&gt;dump_object_pool(objects);
1017   return objects;
1018 }
1019 
<span class="line-modified">1020 void CodeInstaller::record_scope(jint pc_offset, JVMCIObject debug_info, ScopeMode scope_mode, bool return_oop, JVMCI_TRAPS) {</span>
<span class="line-modified">1021   JVMCIObject position = jvmci_env()-&gt;get_DebugInfo_bytecodePosition(debug_info);</span>
1022   if (position.is_null()) {
1023     // Stubs do not record scope info, just oop maps
1024     return;
1025   }
1026 
1027   GrowableArray&lt;ScopeValue*&gt;* objectMapping;
1028   if (scope_mode == CodeInstaller::FullFrame) {
<span class="line-modified">1029     objectMapping = record_virtual_objects(debug_info, JVMCI_CHECK);</span>
1030   } else {
1031     objectMapping = NULL;
1032   }
<span class="line-modified">1033   record_scope(pc_offset, position, scope_mode, objectMapping, return_oop, JVMCI_CHECK);</span>
1034 }
1035 
1036 int CodeInstaller::map_jvmci_bci(int bci) {
1037   if (bci &lt; 0) {
<span class="line-modified">1038     if (bci == jvmci_env()-&gt;get_BytecodeFrame_BEFORE_BCI()) {</span>
1039       return BeforeBci;
<span class="line-modified">1040     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_AFTER_BCI()) {</span>
1041       return AfterBci;
<span class="line-modified">1042     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_UNWIND_BCI()) {</span>
1043       return UnwindBci;
<span class="line-modified">1044     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_AFTER_EXCEPTION_BCI()) {</span>
1045       return AfterExceptionBci;
<span class="line-modified">1046     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_UNKNOWN_BCI()) {</span>
1047       return UnknownBci;
<span class="line-modified">1048     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_INVALID_FRAMESTATE_BCI()) {</span>
1049       return InvalidFrameStateBci;
1050     }
1051     ShouldNotReachHere();
1052   }
1053   return bci;
1054 }
1055 
<span class="line-modified">1056 void CodeInstaller::record_scope(jint pc_offset, JVMCIObject position, ScopeMode scope_mode, GrowableArray&lt;ScopeValue*&gt;* objects, bool return_oop, JVMCI_TRAPS) {</span>
<span class="line-modified">1057   JVMCIObject frame;</span>
1058   if (scope_mode == CodeInstaller::FullFrame) {
<span class="line-modified">1059     if (!jvmci_env()-&gt;isa_BytecodeFrame(position)) {</span>
1060       JVMCI_ERROR(&quot;Full frame expected for debug info at %i&quot;, pc_offset);
1061     }
1062     frame = position;
1063   }
<span class="line-modified">1064   JVMCIObject caller_frame = jvmci_env()-&gt;get_BytecodePosition_caller(position);</span>
<span class="line-modified">1065   if (caller_frame.is_non_null()) {</span>
<span class="line-modified">1066     record_scope(pc_offset, caller_frame, scope_mode, objects, return_oop, JVMCI_CHECK);</span>
1067   }
1068 
<span class="line-modified">1069   JVMCIObject hotspot_method = jvmci_env()-&gt;get_BytecodePosition_method(position);</span>
<span class="line-modified">1070   Thread* thread = Thread::current();</span>
<span class="line-modified">1071   methodHandle method(thread, jvmci_env()-&gt;asMethod(hotspot_method));</span>
<span class="line-added">1072   jint bci = map_jvmci_bci(jvmci_env()-&gt;get_BytecodePosition_bci(position));</span>
<span class="line-added">1073   if (bci == jvmci_env()-&gt;get_BytecodeFrame_BEFORE_BCI()) {</span>
<span class="line-added">1074     bci = SynchronizationEntryBCI;</span>
<span class="line-added">1075   }</span>
1076 
1077   TRACE_jvmci_2(&quot;Recording scope pc_offset=%d bci=%d method=%s&quot;, pc_offset, bci, method-&gt;name_and_sig_as_C_string());
1078 
1079   bool reexecute = false;
<span class="line-modified">1080   if (frame.is_non_null()) {</span>
<span class="line-modified">1081     if (bci &lt; 0){</span>
1082        reexecute = false;
1083     } else {
<span class="line-modified">1084       Bytecodes::Code code = Bytecodes::java_code_at(method(), method-&gt;bcp_from(bci));</span>
1085       reexecute = bytecode_should_reexecute(code);
<span class="line-modified">1086       if (frame.is_non_null()) {</span>
<span class="line-modified">1087         reexecute = (jvmci_env()-&gt;get_BytecodeFrame_duringCall(frame) == JNI_FALSE);</span>
1088       }
1089     }
1090   }
1091 
1092   DebugToken* locals_token = NULL;
1093   DebugToken* expressions_token = NULL;
1094   DebugToken* monitors_token = NULL;
1095   bool throw_exception = false;
1096 
<span class="line-modified">1097   if (frame.is_non_null()) {</span>
<span class="line-modified">1098     jint local_count = jvmci_env()-&gt;get_BytecodeFrame_numLocals(frame);</span>
<span class="line-modified">1099     jint expression_count = jvmci_env()-&gt;get_BytecodeFrame_numStack(frame);</span>
<span class="line-modified">1100     jint monitor_count = jvmci_env()-&gt;get_BytecodeFrame_numLocks(frame);</span>
<span class="line-modified">1101     JVMCIObjectArray values = jvmci_env()-&gt;get_BytecodeFrame_values(frame);</span>
<span class="line-modified">1102     JVMCIObjectArray slotKinds = jvmci_env()-&gt;get_BytecodeFrame_slotKinds(frame);</span>
1103 
1104     if (values.is_null() || slotKinds.is_null()) {
<span class="line-modified">1105       JVMCI_THROW(NullPointerException);</span>
1106     }
<span class="line-modified">1107     if (local_count + expression_count + monitor_count != JVMCIENV-&gt;get_length(values)) {</span>
<span class="line-modified">1108       JVMCI_ERROR(&quot;unexpected values length %d in scope (%d locals, %d expressions, %d monitors)&quot;, JVMCIENV-&gt;get_length(values), local_count, expression_count, monitor_count);</span>
1109     }
<span class="line-modified">1110     if (local_count + expression_count != JVMCIENV-&gt;get_length(slotKinds)) {</span>
<span class="line-modified">1111       JVMCI_ERROR(&quot;unexpected slotKinds length %d in scope (%d locals, %d expressions)&quot;, JVMCIENV-&gt;get_length(slotKinds), local_count, expression_count);</span>
1112     }
1113 
1114     GrowableArray&lt;ScopeValue*&gt;* locals = local_count &gt; 0 ? new GrowableArray&lt;ScopeValue*&gt; (local_count) : NULL;
1115     GrowableArray&lt;ScopeValue*&gt;* expressions = expression_count &gt; 0 ? new GrowableArray&lt;ScopeValue*&gt; (expression_count) : NULL;
1116     GrowableArray&lt;MonitorValue*&gt;* monitors = monitor_count &gt; 0 ? new GrowableArray&lt;MonitorValue*&gt; (monitor_count) : NULL;
1117 
<span class="line-modified">1118     TRACE_jvmci_2(&quot;Scope at bci %d with %d values&quot;, bci, JVMCIENV-&gt;get_length(values));</span>
1119     TRACE_jvmci_2(&quot;%d locals %d expressions, %d monitors&quot;, local_count, expression_count, monitor_count);
1120 
<span class="line-modified">1121     for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(values); i++) {</span>
<span class="line-modified">1122       // HandleMark hm(THREAD);</span>
1123       ScopeValue* second = NULL;
<span class="line-modified">1124       JVMCIObject value = JVMCIENV-&gt;get_object_at(values, i);</span>
1125       if (i &lt; local_count) {
<span class="line-modified">1126         BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);</span>
<span class="line-modified">1127         ScopeValue* first = get_scope_value(value, type, objects, second, JVMCI_CHECK);</span>
1128         if (second != NULL) {
1129           locals-&gt;append(second);
1130         }
1131         locals-&gt;append(first);
1132       } else if (i &lt; local_count + expression_count) {
<span class="line-modified">1133         BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);</span>
<span class="line-modified">1134         ScopeValue* first = get_scope_value(value, type, objects, second, JVMCI_CHECK);</span>
1135         if (second != NULL) {
1136           expressions-&gt;append(second);
1137         }
1138         expressions-&gt;append(first);
1139       } else {
<span class="line-modified">1140         MonitorValue *monitor = get_monitor_value(value, objects, JVMCI_CHECK);</span>
1141         monitors-&gt;append(monitor);
1142       }
1143       if (second != NULL) {
1144         i++;
<span class="line-modified">1145         if (i &gt;= JVMCIENV-&gt;get_length(values) || !JVMCIENV-&gt;equals(JVMCIENV-&gt;get_object_at(values, i), jvmci_env()-&gt;get_Value_ILLEGAL())) {</span>
1146           JVMCI_ERROR(&quot;double-slot value not followed by Value.ILLEGAL&quot;);
1147         }
1148       }
1149     }
1150 
1151     locals_token = _debug_recorder-&gt;create_scope_values(locals);
1152     expressions_token = _debug_recorder-&gt;create_scope_values(expressions);
1153     monitors_token = _debug_recorder-&gt;create_monitor_values(monitors);
1154 
<span class="line-modified">1155     throw_exception = jvmci_env()-&gt;get_BytecodeFrame_rethrowException(frame) == JNI_TRUE;</span>
1156   }
1157 
1158   _debug_recorder-&gt;describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, false, return_oop,
1159                                   locals_token, expressions_token, monitors_token);
1160 }
1161 
<span class="line-modified">1162 void CodeInstaller::site_Safepoint(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {</span>
<span class="line-modified">1163   JVMCIObject debug_info = jvmci_env()-&gt;get_site_Infopoint_debugInfo(site);</span>
1164   if (debug_info.is_null()) {
1165     JVMCI_ERROR(&quot;debug info expected at safepoint at %i&quot;, pc_offset);
1166   }
1167 
1168   // address instruction = _instructions-&gt;start() + pc_offset;
1169   // jint next_pc_offset = Assembler::locate_next_instruction(instruction) - _instructions-&gt;start();
<span class="line-modified">1170   OopMap *map = create_oop_map(debug_info, JVMCI_CHECK);</span>
1171   _debug_recorder-&gt;add_safepoint(pc_offset, map);
<span class="line-modified">1172   record_scope(pc_offset, debug_info, CodeInstaller::FullFrame, JVMCI_CHECK);</span>
1173   _debug_recorder-&gt;end_safepoint(pc_offset);
1174 }
1175 
<span class="line-modified">1176 void CodeInstaller::site_Infopoint(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {</span>
<span class="line-modified">1177   JVMCIObject debug_info = jvmci_env()-&gt;get_site_Infopoint_debugInfo(site);</span>
1178   if (debug_info.is_null()) {
1179     JVMCI_ERROR(&quot;debug info expected at infopoint at %i&quot;, pc_offset);
1180   }
1181 
1182   // We&#39;d like to check that pc_offset is greater than the
1183   // last pc recorded with _debug_recorder (raising an exception if not)
1184   // but DebugInformationRecorder doesn&#39;t have sufficient public API.
1185 
1186   _debug_recorder-&gt;add_non_safepoint(pc_offset);
<span class="line-modified">1187   record_scope(pc_offset, debug_info, CodeInstaller::BytecodePosition, JVMCI_CHECK);</span>
1188   _debug_recorder-&gt;end_non_safepoint(pc_offset);
1189 }
1190 
<span class="line-modified">1191 void CodeInstaller::site_Call(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {</span>
<span class="line-modified">1192   JVMCIObject target = jvmci_env()-&gt;get_site_Call_target(site);</span>
<span class="line-modified">1193   JVMCIObject hotspot_method; // JavaMethod</span>
<span class="line-modified">1194   JVMCIObject foreign_call;</span>


1195 
<span class="line-modified">1196   if (jvmci_env()-&gt;isa_HotSpotForeignCallTarget(target)) {</span>
1197     foreign_call = target;
1198   } else {
1199     hotspot_method = target;
1200   }
1201 
<span class="line-modified">1202   JVMCIObject debug_info = jvmci_env()-&gt;get_site_Infopoint_debugInfo(site);</span>
1203 
<span class="line-modified">1204   assert(hotspot_method.is_non_null() ^ foreign_call.is_non_null(), &quot;Call site needs exactly one type&quot;);</span>
1205 
1206   NativeInstruction* inst = nativeInstruction_at(_instructions-&gt;start() + pc_offset);
<span class="line-modified">1207   jint next_pc_offset = CodeInstaller::pd_next_offset(inst, pc_offset, hotspot_method, JVMCI_CHECK);</span>
1208 
<span class="line-modified">1209   if (debug_info.is_non_null()) {</span>
<span class="line-modified">1210     OopMap *map = create_oop_map(debug_info, JVMCI_CHECK);</span>
1211     _debug_recorder-&gt;add_safepoint(next_pc_offset, map);
1212 
<span class="line-modified">1213     bool return_oop = hotspot_method.is_non_null() &amp;&amp; jvmci_env()-&gt;asMethod(hotspot_method)-&gt;is_returning_oop();</span>
1214 
<span class="line-modified">1215     record_scope(next_pc_offset, debug_info, CodeInstaller::FullFrame, return_oop, JVMCI_CHECK);</span>
1216   }
1217 
<span class="line-modified">1218   if (foreign_call.is_non_null()) {</span>
<span class="line-modified">1219     jlong foreign_call_destination = jvmci_env()-&gt;get_HotSpotForeignCallTarget_address(foreign_call);</span>
1220     if (_immutable_pic_compilation) {
1221       // Use fake short distance during PIC compilation.
1222       foreign_call_destination = (jlong)(_instructions-&gt;start() + pc_offset);
1223     }
<span class="line-modified">1224     CodeInstaller::pd_relocate_ForeignCall(inst, foreign_call_destination, JVMCI_CHECK);</span>
1225   } else { // method != NULL
1226     if (debug_info.is_null()) {
1227       JVMCI_ERROR(&quot;debug info expected at call at %i&quot;, pc_offset);
1228     }
1229 
1230     TRACE_jvmci_3(&quot;method call&quot;);
<span class="line-modified">1231     CodeInstaller::pd_relocate_JavaMethod(buffer, hotspot_method, pc_offset, JVMCI_CHECK);</span>
1232     if (_next_call_type == INVOKESTATIC || _next_call_type == INVOKESPECIAL) {
1233       // Need a static call stub for transitions from compiled to interpreted.
1234       CompiledStaticCall::emit_to_interp_stub(buffer, _instructions-&gt;start() + pc_offset);
1235     }
1236 #if INCLUDE_AOT
1237     // Trampoline to far aot code.
1238     CompiledStaticCall::emit_to_aot_stub(buffer, _instructions-&gt;start() + pc_offset);
1239 #endif
1240   }
1241 
1242   _next_call_type = INVOKE_INVALID;
1243 
<span class="line-modified">1244   if (debug_info.is_non_null()) {</span>
1245     _debug_recorder-&gt;end_safepoint(next_pc_offset);
1246   }
1247 }
1248 
<span class="line-modified">1249 void CodeInstaller::site_DataPatch(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {</span>
<span class="line-modified">1250   JVMCIObject reference = jvmci_env()-&gt;get_site_DataPatch_reference(site);</span>
1251   if (reference.is_null()) {
<span class="line-modified">1252     JVMCI_THROW(NullPointerException);</span>
<span class="line-modified">1253   } else if (jvmci_env()-&gt;isa_site_ConstantReference(reference)) {</span>
<span class="line-modified">1254     JVMCIObject constant = jvmci_env()-&gt;get_site_ConstantReference_constant(reference);</span>
1255     if (constant.is_null()) {
<span class="line-modified">1256       JVMCI_THROW(NullPointerException);</span>
<span class="line-modified">1257     } else if (jvmci_env()-&gt;isa_DirectHotSpotObjectConstantImpl(constant)) {</span>
<span class="line-added">1258       if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-added">1259         JVMCIObject string = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_callToString(constant, JVMCI_CHECK);</span>
<span class="line-added">1260         const char* to_string = JVMCIENV-&gt;as_utf8_string(string);</span>
<span class="line-added">1261         JVMCI_THROW_MSG(IllegalArgumentException, err_msg(&quot;Direct object constant reached the backend: %s&quot;, to_string));</span>
<span class="line-added">1262       }</span>
<span class="line-added">1263       if (!_immutable_pic_compilation) {</span>
<span class="line-added">1264         // Do not patch during PIC compilation.</span>
<span class="line-added">1265         pd_patch_OopConstant(pc_offset, constant, JVMCI_CHECK);</span>
<span class="line-added">1266       }</span>
<span class="line-added">1267     } else if (jvmci_env()-&gt;isa_IndirectHotSpotObjectConstantImpl(constant)) {</span>
1268       if (!_immutable_pic_compilation) {
1269         // Do not patch during PIC compilation.
<span class="line-modified">1270         pd_patch_OopConstant(pc_offset, constant, JVMCI_CHECK);</span>
1271       }
<span class="line-modified">1272     } else if (jvmci_env()-&gt;isa_HotSpotMetaspaceConstantImpl(constant)) {</span>
1273       if (!_immutable_pic_compilation) {
<span class="line-modified">1274         pd_patch_MetaspaceConstant(pc_offset, constant, JVMCI_CHECK);</span>
1275       }
1276 #if INCLUDE_AOT
<span class="line-modified">1277     } else if (jvmci_env()-&gt;isa_HotSpotSentinelConstant(constant)) {</span>
1278       if (!_immutable_pic_compilation) {
<span class="line-modified">1279         JVMCI_ERROR(&quot;sentinel constant not supported for normal compiles: %s&quot;, jvmci_env()-&gt;klass_name(constant));</span>
1280       }
1281 #endif
1282     } else {
<span class="line-modified">1283       JVMCI_ERROR(&quot;unknown constant type in data patch: %s&quot;, jvmci_env()-&gt;klass_name(constant));</span>
1284     }
<span class="line-modified">1285   } else if (jvmci_env()-&gt;isa_site_DataSectionReference(reference)) {</span>
<span class="line-modified">1286     int data_offset = jvmci_env()-&gt;get_site_DataSectionReference_offset(reference);</span>
1287     if (0 &lt;= data_offset &amp;&amp; data_offset &lt; _constants_size) {
<span class="line-modified">1288       pd_patch_DataSectionReference(pc_offset, data_offset, JVMCI_CHECK);</span>
1289     } else {
1290       JVMCI_ERROR(&quot;data offset 0x%X points outside data section (size 0x%X)&quot;, data_offset, _constants_size);
1291     }
1292   } else {
<span class="line-modified">1293     JVMCI_ERROR(&quot;unknown data patch type: %s&quot;, jvmci_env()-&gt;klass_name(reference));</span>
1294   }
1295 }
1296 
<span class="line-modified">1297 void CodeInstaller::site_Mark(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {</span>
<span class="line-modified">1298   JVMCIObject id_obj = jvmci_env()-&gt;get_site_Mark_id(site);</span>
1299 
<span class="line-modified">1300   if (id_obj.is_non_null()) {</span>
<span class="line-modified">1301     if (!jvmci_env()-&gt;is_boxing_object(T_INT, id_obj)) {</span>
<span class="line-modified">1302       JVMCI_ERROR(&quot;expected Integer id, got %s&quot;, jvmci_env()-&gt;klass_name(id_obj));</span>
1303     }
<span class="line-modified">1304     jint id = jvmci_env()-&gt;get_boxed_value(T_INT, id_obj).i;</span>
1305 
1306     address pc = _instructions-&gt;start() + pc_offset;
1307 
1308     switch (id) {
1309       case UNVERIFIED_ENTRY:
1310         _offsets.set_value(CodeOffsets::Entry, pc_offset);
1311         break;
1312       case VERIFIED_ENTRY:
1313         _offsets.set_value(CodeOffsets::Verified_Entry, pc_offset);
1314         break;
1315       case OSR_ENTRY:
1316         _offsets.set_value(CodeOffsets::OSR_Entry, pc_offset);
1317         break;
1318       case EXCEPTION_HANDLER_ENTRY:
1319         _offsets.set_value(CodeOffsets::Exceptions, pc_offset);
1320         break;
1321       case DEOPT_HANDLER_ENTRY:
1322         _offsets.set_value(CodeOffsets::Deopt, pc_offset);
1323         break;
1324       case INVOKEVIRTUAL:
1325       case INVOKEINTERFACE:
1326       case INLINE_INVOKE:
1327       case INVOKESTATIC:
1328       case INVOKESPECIAL:
1329         _next_call_type = (MarkId) id;
1330         _invoke_mark_pc = pc;
1331         break;
1332       case POLL_NEAR:
1333       case POLL_FAR:
1334       case POLL_RETURN_NEAR:
1335       case POLL_RETURN_FAR:
<span class="line-modified">1336         pd_relocate_poll(pc, id, JVMCI_CHECK);</span>
1337         break;
1338       case CARD_TABLE_SHIFT:
1339       case CARD_TABLE_ADDRESS:
1340       case HEAP_TOP_ADDRESS:
1341       case HEAP_END_ADDRESS:
1342       case NARROW_KLASS_BASE_ADDRESS:
1343       case NARROW_OOP_BASE_ADDRESS:
1344       case CRC_TABLE_ADDRESS:
1345       case LOG_OF_HEAP_REGION_GRAIN_BYTES:
1346       case INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED:
1347         break;
1348       default:
1349         JVMCI_ERROR(&quot;invalid mark id: %d&quot;, id);
1350         break;
1351     }
1352   }
1353 }
</pre>
</td>
</tr>
</table>
<center><a href="compilerRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCodeInstaller.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
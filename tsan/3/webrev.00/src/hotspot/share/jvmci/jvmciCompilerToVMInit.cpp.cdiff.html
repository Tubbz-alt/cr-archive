<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jvmci/jvmciCompilerToVMInit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCompilerToVM.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciEnv.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCompilerToVMInit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,17 ***</span>
  
  // no precompiled headers
  #include &quot;ci/ciUtilities.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/cardTable.hpp&quot;
<span class="line-modified">! #include &quot;memory/oopFactory.hpp&quot;</span>
<span class="line-modified">! #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
  #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  #include &quot;jvmci/vmStructs_jvmci.hpp&quot;
<span class="line-modified">! #include &quot;runtime/flags/jvmFlag.hpp&quot;</span>
<span class="line-modified">! #include &quot;runtime/handles.inline.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/resourceHash.hpp&quot;
  
  
  int CompilerToVM::Data::Klass_vtable_start_offset;
<span class="line-new-header">--- 23,17 ---</span>
  
  // no precompiled headers
  #include &quot;ci/ciUtilities.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/cardTable.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/collectedHeap.hpp&quot;</span>
<span class="line-modified">! #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
  #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  #include &quot;jvmci/vmStructs_jvmci.hpp&quot;
<span class="line-modified">! #include &quot;memory/universe.hpp&quot;</span>
<span class="line-modified">! #include &quot;oops/compressedOops.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/klass.inline.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/resourceHash.hpp&quot;
  
  
  int CompilerToVM::Data::Klass_vtable_start_offset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,10 ***</span>
<span class="line-new-header">--- 42,11 ---</span>
  int CompilerToVM::Data::Method_extra_stack_entries;
  
  address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
  address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
  address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
<span class="line-added">+ address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack_with_exception_in_tls;</span>
  address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
  
  size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
  
  CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,29 ***</span>
  address CompilerToVM::Data::dpow;
  
  address CompilerToVM::Data::symbol_init;
  address CompilerToVM::Data::symbol_clinit;
  
<span class="line-modified">! void CompilerToVM::Data::initialize(TRAPS) {</span>
    Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
    Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
  
    Method_extra_stack_entries = Method::extra_stack_entries();
  
    SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
    SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
    SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
    SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
  
    ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
  
    Universe_collectedHeap = Universe::heap();
    Universe_base_vtable_size = Universe::base_vtable_size();
<span class="line-modified">!   Universe_narrow_oop_base = Universe::narrow_oop_base();</span>
<span class="line-modified">!   Universe_narrow_oop_shift = Universe::narrow_oop_shift();</span>
<span class="line-modified">!   Universe_narrow_klass_base = Universe::narrow_klass_base();</span>
<span class="line-modified">!   Universe_narrow_klass_shift = Universe::narrow_klass_shift();</span>
    Universe_non_oop_bits = Universe::non_oop_word();
    Universe_verify_oop_mask = Universe::verify_oop_mask();
    Universe_verify_oop_bits = Universe::verify_oop_bits();
  
    _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
<span class="line-new-header">--- 87,30 ---</span>
  address CompilerToVM::Data::dpow;
  
  address CompilerToVM::Data::symbol_init;
  address CompilerToVM::Data::symbol_clinit;
  
<span class="line-modified">! void CompilerToVM::Data::initialize(JVMCI_TRAPS) {</span>
    Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
    Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
  
    Method_extra_stack_entries = Method::extra_stack_entries();
  
    SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
    SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
    SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
<span class="line-added">+   SharedRuntime_deopt_blob_unpack_with_exception_in_tls = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();</span>
    SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
  
    ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
  
    Universe_collectedHeap = Universe::heap();
    Universe_base_vtable_size = Universe::base_vtable_size();
<span class="line-modified">!   Universe_narrow_oop_base = CompressedOops::base();</span>
<span class="line-modified">!   Universe_narrow_oop_shift = CompressedOops::shift();</span>
<span class="line-modified">!   Universe_narrow_klass_base = CompressedKlassPointers::base();</span>
<span class="line-modified">!   Universe_narrow_klass_shift = CompressedKlassPointers::shift();</span>
    Universe_non_oop_bits = Universe::non_oop_word();
    Universe_verify_oop_mask = Universe::verify_oop_mask();
    Universe_verify_oop_bits = Universe::verify_oop_bits();
  
    _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,46 ***</span>
    SET_TRIGFUNC(dpow);
  
  #undef SET_TRIGFUNC
  }
  
<span class="line-modified">! objArrayHandle CompilerToVM::initialize_intrinsics(TRAPS) {</span>
<span class="line-modified">!   objArrayHandle vmIntrinsics = oopFactory::new_objArray_handle(VMIntrinsicMethod::klass(), (vmIntrinsics::ID_LIMIT - 1), CHECK_(objArrayHandle()));</span>
    int index = 0;
<span class="line-removed">-   // The intrinsics for a class are usually adjacent to each other.</span>
<span class="line-removed">-   // When they are, the string for the class name can be reused.</span>
    vmSymbols::SID kls_sid = vmSymbols::NO_SID;
<span class="line-modified">!   Handle kls_str;</span>
  #define VM_SYMBOL_TO_STRING(s) \
<span class="line-modified">!   java_lang_String::create_from_symbol(vmSymbols::symbol_at(vmSymbols::VM_SYMBOL_ENUM_NAME(s)), CHECK_(objArrayHandle()))</span>
  #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \
<span class="line-removed">-     instanceHandle vmIntrinsicMethod = InstanceKlass::cast(VMIntrinsicMethod::klass())-&gt;allocate_instance_handle(CHECK_(objArrayHandle())); \</span>
      vmSymbols::SID sid = vmSymbols::VM_SYMBOL_ENUM_NAME(kls);             \
      if (kls_sid != sid) {                                                 \
        kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
        kls_sid = sid;                                                      \
      }                                                                     \
<span class="line-modified">!     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \</span>
<span class="line-modified">!     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \</span>
<span class="line-modified">!     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \</span>
<span class="line-modified">!     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \</span>
<span class="line-removed">-     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \</span>
<span class="line-removed">-     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \</span>
<span class="line-removed">-       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \</span>
    }
  
    VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
  #undef VM_SYMBOL_TO_STRING
  #undef VM_INTRINSIC_INFO
    assert(index == vmIntrinsics::ID_LIMIT - 1, &quot;must be&quot;);
  
    return vmIntrinsics;
  }
  
<span class="line-removed">- /**</span>
<span class="line-removed">-  * The set of VM flags known to be used.</span>
<span class="line-removed">-  */</span>
  #define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \
    do_intx_flag(AllocateInstancePrefetchLines)                              \
    do_intx_flag(AllocatePrefetchDistance)                                   \
    do_intx_flag(AllocatePrefetchInstr)                                      \
    do_intx_flag(AllocatePrefetchLines)                                      \
<span class="line-new-header">--- 157,37 ---</span>
    SET_TRIGFUNC(dpow);
  
  #undef SET_TRIGFUNC
  }
  
<span class="line-modified">! JVMCIObjectArray CompilerToVM::initialize_intrinsics(JVMCI_TRAPS) {</span>
<span class="line-modified">!   JVMCIObjectArray vmIntrinsics = JVMCIENV-&gt;new_VMIntrinsicMethod_array(vmIntrinsics::ID_LIMIT - 1, JVMCI_CHECK_NULL);</span>
    int index = 0;
    vmSymbols::SID kls_sid = vmSymbols::NO_SID;
<span class="line-modified">!   JVMCIObject kls_str;</span>
  #define VM_SYMBOL_TO_STRING(s) \
<span class="line-modified">!   JVMCIENV-&gt;create_string(vmSymbols::symbol_at(vmSymbols::VM_SYMBOL_ENUM_NAME(s)), JVMCI_CHECK_NULL)</span>
  #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \
      vmSymbols::SID sid = vmSymbols::VM_SYMBOL_ENUM_NAME(kls);             \
      if (kls_sid != sid) {                                                 \
        kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
        kls_sid = sid;                                                      \
      }                                                                     \
<span class="line-modified">!     JVMCIObject name_str = VM_SYMBOL_TO_STRING(name);                    \</span>
<span class="line-modified">!     JVMCIObject sig_str = VM_SYMBOL_TO_STRING(sig);                      \</span>
<span class="line-modified">!     JVMCIObject vmIntrinsicMethod = JVMCIENV-&gt;new_VMIntrinsicMethod(kls_str, name_str, sig_str, (jint) vmIntrinsics::id, JVMCI_CHECK_NULL); \</span>
<span class="line-modified">!     JVMCIENV-&gt;put_object_at(vmIntrinsics, index++, vmIntrinsicMethod);   \</span>
    }
  
    VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
  #undef VM_SYMBOL_TO_STRING
  #undef VM_INTRINSIC_INFO
    assert(index == vmIntrinsics::ID_LIMIT - 1, &quot;must be&quot;);
  
    return vmIntrinsics;
  }
  
  #define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \
    do_intx_flag(AllocateInstancePrefetchLines)                              \
    do_intx_flag(AllocatePrefetchDistance)                                   \
    do_intx_flag(AllocatePrefetchInstr)                                      \
    do_intx_flag(AllocatePrefetchLines)                                      \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,16 ***</span>
    do_bool_flag(BootstrapJVMCI)                                             \
    do_bool_flag(CITime)                                                     \
    do_bool_flag(CITimeEach)                                                 \
    do_uintx_flag(CodeCacheSegmentSize)                                      \
    do_intx_flag(CodeEntryAlignment)                                         \
<span class="line-removed">-   do_bool_flag(CompactFields)                                              \</span>
    do_intx_flag(ContendedPaddingWidth)                                      \
    do_bool_flag(DontCompileHugeMethods)                                     \
    do_bool_flag(EagerJVMCI)                                                 \
    do_bool_flag(EnableContended)                                            \
<span class="line-removed">-   do_intx_flag(FieldsAllocationStyle)                                      \</span>
    do_bool_flag(FoldStableValues)                                           \
    do_bool_flag(ForceUnreachable)                                           \
    do_intx_flag(HugeMethodLimit)                                            \
    do_bool_flag(Inline)                                                     \
    do_intx_flag(JVMCICounterSize)                                           \
<span class="line-new-header">--- 197,14 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,14 ***</span>
    do_bool_flag(UseCRC32Intrinsics)                                         \
    do_bool_flag(UseCompressedClassPointers)                                 \
    do_bool_flag(UseCompressedOops)                                          \
    X86_ONLY(do_bool_flag(UseCountLeadingZerosInstruction))                  \
    X86_ONLY(do_bool_flag(UseCountTrailingZerosInstruction))                 \
<span class="line-removed">-   do_bool_flag(UseConcMarkSweepGC)                                         \</span>
    do_bool_flag(UseG1GC)                                                    \
    do_bool_flag(UseParallelGC)                                              \
<span class="line-removed">-   do_bool_flag(UseParallelOldGC)                                           \</span>
    do_bool_flag(UseSerialGC)                                                \
    do_bool_flag(UseZGC)                                                     \
    do_bool_flag(UseEpsilonGC)                                               \
    COMPILER2_PRESENT(do_bool_flag(UseMontgomeryMultiplyIntrinsic))          \
    COMPILER2_PRESENT(do_bool_flag(UseMontgomerySquareIntrinsic))            \
<span class="line-new-header">--- 226,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,177 ***</span>
    COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \
    do_bool_flag(UseStackBanging)                                            \
    do_bool_flag(UseTLAB)                                                    \
    do_bool_flag(VerifyOops)                                                 \
  
<span class="line-modified">! #define BOXED_BOOLEAN(name, value) oop name = ((jboolean)(value) ? boxedTrue() : boxedFalse())</span>
<span class="line-modified">! #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)</span>
  #define BOXED_LONG(name, value) \
<span class="line-removed">-   oop name; \</span>
    do { \
      jvalue p; p.j = (jlong) (value); \
<span class="line-modified">!     Handle* e = longs.get(p.j); \</span>
      if (e == NULL) { \
<span class="line-modified">!       oop o = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); \</span>
<span class="line-removed">-       Handle h(THREAD, o); \</span>
        longs.put(p.j, h); \
<span class="line-modified">!       name = h(); \</span>
      } else { \
<span class="line-modified">!       name = (*e)(); \</span>
      } \
    } while (0)
  
  #define CSTRING_TO_JSTRING(name, value) \
<span class="line-modified">!   Handle name; \</span>
    do { \
      if (value != NULL) { \
<span class="line-modified">!       Handle* e = strings.get(value); \</span>
        if (e == NULL) { \
<span class="line-modified">!         Handle h = java_lang_String::create_from_str(value, CHECK_NULL); \</span>
          strings.put(value, h); \
          name = h; \
        } else { \
          name = (*e); \
        } \
      } \
    } while (0)
  
<span class="line-modified">! jobjectArray readConfiguration0(JNIEnv *env, TRAPS) {</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   HandleMark hm;</span>
<span class="line-modified">! </span>
<span class="line-removed">-   // Used to canonicalize Long and String values.</span>
<span class="line-removed">-   ResourceHashtable&lt;jlong, Handle&gt; longs;</span>
<span class="line-removed">-   ResourceHashtable&lt;const char*, Handle, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;</span>
  
    jvalue prim;
<span class="line-modified">!   prim.z = true;  oop boxedTrueOop =  java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="line-modified">!   Handle boxedTrue(THREAD, boxedTrueOop);</span>
<span class="line-removed">-   prim.z = false; oop boxedFalseOop = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="line-removed">-   Handle boxedFalse(THREAD, boxedFalseOop);</span>
  
<span class="line-modified">!   CompilerToVM::Data::initialize(CHECK_NULL);</span>
  
<span class="line-modified">!   VMField::klass()-&gt;initialize(CHECK_NULL);</span>
<span class="line-modified">!   VMFlag::klass()-&gt;initialize(CHECK_NULL);</span>
<span class="line-modified">!   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);</span>
  
    int len = JVMCIVMStructs::localHotSpotVMStructs_count();
<span class="line-modified">!   objArrayHandle vmFields = oopFactory::new_objArray_handle(VMField::klass(), len, CHECK_NULL);</span>
    for (int i = 0; i &lt; len ; i++) {
      VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
<span class="line-removed">-     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);</span>
      size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* &quot;::&quot; */;
      char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
      sprintf(name_buf, &quot;%s::%s&quot;, vmField.typeName, vmField.fieldName);
      CSTRING_TO_JSTRING(name, name_buf);
      CSTRING_TO_JSTRING(type, vmField.typeString);
<span class="line-modified">!     VMField::set_name(vmFieldObj, name());</span>
<span class="line-removed">-     VMField::set_type(vmFieldObj, type());</span>
<span class="line-removed">-     VMField::set_offset(vmFieldObj, vmField.offset);</span>
<span class="line-removed">-     VMField::set_address(vmFieldObj, (jlong) vmField.address);</span>
      if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {
        if (strcmp(vmField.typeString, &quot;bool&quot;) == 0) {
          BOXED_BOOLEAN(box, *(jbyte*) vmField.address);
<span class="line-modified">!         VMField::set_value(vmFieldObj, box);</span>
        } else if (strcmp(vmField.typeString, &quot;int&quot;) == 0 ||
<span class="line-modified">!                  strcmp(vmField.typeString, &quot;jint&quot;) == 0) {</span>
          BOXED_LONG(box, *(jint*) vmField.address);
<span class="line-modified">!         VMField::set_value(vmFieldObj, box);</span>
        } else if (strcmp(vmField.typeString, &quot;uint64_t&quot;) == 0) {
          BOXED_LONG(box, *(uint64_t*) vmField.address);
<span class="line-modified">!         VMField::set_value(vmFieldObj, box);</span>
        } else if (strcmp(vmField.typeString, &quot;address&quot;) == 0 ||
                   strcmp(vmField.typeString, &quot;intptr_t&quot;) == 0 ||
                   strcmp(vmField.typeString, &quot;uintptr_t&quot;) == 0 ||
                   strcmp(vmField.typeString, &quot;OopHandle&quot;) == 0 ||
                   strcmp(vmField.typeString, &quot;size_t&quot;) == 0 ||
                   // All foo* types are addresses.
                   vmField.typeString[strlen(vmField.typeString) - 1] == &#39;*&#39;) {
          BOXED_LONG(box, *((address*) vmField.address));
<span class="line-modified">!         VMField::set_value(vmFieldObj, box);</span>
        } else {
          JVMCI_ERROR_NULL(&quot;VM field %s has unsupported type %s&quot;, name_buf, vmField.typeString);
        }
      }
<span class="line-modified">!     vmFields-&gt;obj_at_put(i, vmFieldObj());</span>
    }
  
    int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
    int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
    len = ints_len + longs_len;
<span class="line-modified">!   objArrayHandle vmConstants = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);</span>
    int insert = 0;
    for (int i = 0; i &lt; ints_len ; i++) {
      VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
      CSTRING_TO_JSTRING(name, c.name);
      BOXED_LONG(value, c.value);
<span class="line-modified">!     vmConstants-&gt;obj_at_put(insert++, name());</span>
<span class="line-modified">!     vmConstants-&gt;obj_at_put(insert++, value);</span>
    }
    for (int i = 0; i &lt; longs_len ; i++) {
      VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
      CSTRING_TO_JSTRING(name, c.name);
      BOXED_LONG(value, c.value);
<span class="line-modified">!     vmConstants-&gt;obj_at_put(insert++, name());</span>
<span class="line-modified">!     vmConstants-&gt;obj_at_put(insert++, value);</span>
    }
    assert(insert == len * 2, &quot;must be&quot;);
  
    len = JVMCIVMStructs::localHotSpotVMAddresses_count();
<span class="line-modified">!   objArrayHandle vmAddresses = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);</span>
    for (int i = 0; i &lt; len ; i++) {
      VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
      CSTRING_TO_JSTRING(name, a.name);
      BOXED_LONG(value, a.value);
<span class="line-modified">!     vmAddresses-&gt;obj_at_put(i * 2, name());</span>
<span class="line-modified">!     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);</span>
    }
  
  #define COUNT_FLAG(ignore) +1
  #ifdef ASSERT
  #define CHECK_FLAG(type, name) { \
<span class="line-modified">!   JVMFlag* flag = JVMFlag::find_flag(#name, strlen(#name), /*allow_locked*/ true, /* return_flag */ true); \</span>
    assert(flag != NULL, &quot;No such flag named &quot; #name); \
    assert(flag-&gt;is_##type(), &quot;JVMFlag &quot; #name &quot; is not of type &quot; #type); \
  }
  #else
  #define CHECK_FLAG(type, name)
  #endif
  
<span class="line-modified">! #define ADD_FLAG(type, name, convert) { \</span>
<span class="line-modified">!   CHECK_FLAG(type, name) \</span>
<span class="line-modified">!   instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL); \</span>
<span class="line-modified">!   CSTRING_TO_JSTRING(fname, #name); \</span>
<span class="line-modified">!   CSTRING_TO_JSTRING(ftype, #type); \</span>
<span class="line-modified">!   VMFlag::set_name(vmFlagObj, fname()); \</span>
<span class="line-modified">!   VMFlag::set_type(vmFlagObj, ftype()); \</span>
<span class="line-removed">-   convert(value, name); \</span>
<span class="line-removed">-   VMFlag::set_value(vmFlagObj, value); \</span>
<span class="line-removed">-   vmFlags-&gt;obj_at_put(i++, vmFlagObj()); \</span>
  }
  #define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)
  #define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)
  #define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)
  
    len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);
<span class="line-modified">!   objArrayHandle vmFlags = oopFactory::new_objArray_handle(VMFlag::klass(), len, CHECK_NULL);</span>
    int i = 0;
    PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)
  
<span class="line-modified">!   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 5, CHECK_NULL);</span>
<span class="line-modified">!   data-&gt;obj_at_put(0, vmFields());</span>
<span class="line-modified">!   data-&gt;obj_at_put(1, vmConstants());</span>
<span class="line-modified">!   data-&gt;obj_at_put(2, vmAddresses());</span>
<span class="line-modified">!   data-&gt;obj_at_put(3, vmFlags());</span>
<span class="line-modified">!   data-&gt;obj_at_put(4, vmIntrinsics());</span>
<span class="line-modified">! </span>
<span class="line-modified">!   return (jobjectArray) JNIHandles::make_local(THREAD, data);</span>
<span class="line-removed">- #undef COUNT_FLAG</span>
<span class="line-removed">- #undef ADD_FLAG</span>
<span class="line-removed">- #undef ADD_BOOL_FLAG</span>
<span class="line-removed">- #undef ADD_INTX_FLAG</span>
<span class="line-removed">- #undef ADD_UINTX_FLAG</span>
<span class="line-removed">- #undef CHECK_FLAG</span>
  }
<span class="line-new-header">--- 245,163 ---</span>
    COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \
    do_bool_flag(UseStackBanging)                                            \
    do_bool_flag(UseTLAB)                                                    \
    do_bool_flag(VerifyOops)                                                 \
  
<span class="line-modified">! #define BOXED_BOOLEAN(name, value) name = ((jboolean)(value) ? boxedTrue : boxedFalse)</span>
<span class="line-modified">! #define BOXED_DOUBLE(name, value) do { jvalue p; p.d = (jdouble) (value); name = JVMCIENV-&gt;create_box(T_DOUBLE, &amp;p, JVMCI_CHECK_NULL);} while(0)</span>
  #define BOXED_LONG(name, value) \
    do { \
      jvalue p; p.j = (jlong) (value); \
<span class="line-modified">!     JVMCIObject* e = longs.get(p.j); \</span>
      if (e == NULL) { \
<span class="line-modified">!       JVMCIObject h = JVMCIENV-&gt;create_box(T_LONG, &amp;p, JVMCI_CHECK_NULL); \</span>
        longs.put(p.j, h); \
<span class="line-modified">!       name = h; \</span>
      } else { \
<span class="line-modified">!       name = (*e); \</span>
      } \
    } while (0)
  
  #define CSTRING_TO_JSTRING(name, value) \
<span class="line-modified">!   JVMCIObject name; \</span>
    do { \
      if (value != NULL) { \
<span class="line-modified">!       JVMCIObject* e = strings.get(value); \</span>
        if (e == NULL) { \
<span class="line-modified">!         JVMCIObject h = JVMCIENV-&gt;create_string(value, JVMCI_CHECK_NULL); \</span>
          strings.put(value, h); \
          name = h; \
        } else { \
          name = (*e); \
        } \
      } \
    } while (0)
  
<span class="line-modified">! jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS) {</span>
<span class="line-modified">!   Thread* THREAD = Thread::current();</span>
<span class="line-modified">!   ResourceHashtable&lt;jlong, JVMCIObject&gt; longs;</span>
<span class="line-modified">!   ResourceHashtable&lt;const char*, JVMCIObject, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;</span>
  
    jvalue prim;
<span class="line-modified">!   prim.z = true;  JVMCIObject boxedTrue =  JVMCIENV-&gt;create_box(T_BOOLEAN, &amp;prim, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   prim.z = false; JVMCIObject boxedFalse = JVMCIENV-&gt;create_box(T_BOOLEAN, &amp;prim, JVMCI_CHECK_NULL);</span>
  
<span class="line-modified">!   CompilerToVM::Data::initialize(JVMCI_CHECK_NULL);</span>
  
<span class="line-modified">!   JVMCIENV-&gt;VMField_initialize(JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   JVMCIENV-&gt;VMFlag_initialize(JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   JVMCIENV-&gt;VMIntrinsicMethod_initialize(JVMCI_CHECK_NULL);</span>
  
    int len = JVMCIVMStructs::localHotSpotVMStructs_count();
<span class="line-modified">!   JVMCIObjectArray vmFields = JVMCIENV-&gt;new_VMField_array(len, JVMCI_CHECK_NULL);</span>
    for (int i = 0; i &lt; len ; i++) {
      VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
      size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* &quot;::&quot; */;
      char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
      sprintf(name_buf, &quot;%s::%s&quot;, vmField.typeName, vmField.fieldName);
      CSTRING_TO_JSTRING(name, name_buf);
      CSTRING_TO_JSTRING(type, vmField.typeString);
<span class="line-modified">!     JVMCIObject box;</span>
      if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {
        if (strcmp(vmField.typeString, &quot;bool&quot;) == 0) {
          BOXED_BOOLEAN(box, *(jbyte*) vmField.address);
<span class="line-modified">!         assert(box.is_non_null(), &quot;must have a box&quot;);</span>
        } else if (strcmp(vmField.typeString, &quot;int&quot;) == 0 ||
<span class="line-modified">!                  strcmp(vmField.typeString, &quot;jint&quot;) == 0 ||</span>
<span class="line-added">+                  strcmp(vmField.typeString, &quot;uint32_t&quot;) == 0) {</span>
          BOXED_LONG(box, *(jint*) vmField.address);
<span class="line-modified">!         assert(box.is_non_null(), &quot;must have a box&quot;);</span>
        } else if (strcmp(vmField.typeString, &quot;uint64_t&quot;) == 0) {
          BOXED_LONG(box, *(uint64_t*) vmField.address);
<span class="line-modified">!         assert(box.is_non_null(), &quot;must have a box&quot;);</span>
        } else if (strcmp(vmField.typeString, &quot;address&quot;) == 0 ||
                   strcmp(vmField.typeString, &quot;intptr_t&quot;) == 0 ||
                   strcmp(vmField.typeString, &quot;uintptr_t&quot;) == 0 ||
                   strcmp(vmField.typeString, &quot;OopHandle&quot;) == 0 ||
                   strcmp(vmField.typeString, &quot;size_t&quot;) == 0 ||
                   // All foo* types are addresses.
                   vmField.typeString[strlen(vmField.typeString) - 1] == &#39;*&#39;) {
          BOXED_LONG(box, *((address*) vmField.address));
<span class="line-modified">!         assert(box.is_non_null(), &quot;must have a box&quot;);</span>
        } else {
          JVMCI_ERROR_NULL(&quot;VM field %s has unsupported type %s&quot;, name_buf, vmField.typeString);
        }
      }
<span class="line-modified">!     JVMCIObject vmFieldObj = JVMCIENV-&gt;new_VMField(name, type, vmField.offset, (jlong) vmField.address, box, JVMCI_CHECK_NULL);</span>
<span class="line-added">+     JVMCIENV-&gt;put_object_at(vmFields, i, vmFieldObj);</span>
    }
  
    int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
    int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
    len = ints_len + longs_len;
<span class="line-modified">!   JVMCIObjectArray vmConstants = JVMCIENV-&gt;new_Object_array(len * 2, JVMCI_CHECK_NULL);</span>
    int insert = 0;
    for (int i = 0; i &lt; ints_len ; i++) {
      VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
      CSTRING_TO_JSTRING(name, c.name);
<span class="line-added">+     JVMCIObject value;</span>
      BOXED_LONG(value, c.value);
<span class="line-modified">!     JVMCIENV-&gt;put_object_at(vmConstants, insert++, name);</span>
<span class="line-modified">!     JVMCIENV-&gt;put_object_at(vmConstants, insert++, value);</span>
    }
    for (int i = 0; i &lt; longs_len ; i++) {
      VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
      CSTRING_TO_JSTRING(name, c.name);
<span class="line-added">+     JVMCIObject value;</span>
      BOXED_LONG(value, c.value);
<span class="line-modified">!     JVMCIENV-&gt;put_object_at(vmConstants, insert++, name);</span>
<span class="line-modified">!     JVMCIENV-&gt;put_object_at(vmConstants, insert++, value);</span>
    }
    assert(insert == len * 2, &quot;must be&quot;);
  
    len = JVMCIVMStructs::localHotSpotVMAddresses_count();
<span class="line-modified">!   JVMCIObjectArray vmAddresses = JVMCIENV-&gt;new_Object_array(len * 2, JVMCI_CHECK_NULL);</span>
    for (int i = 0; i &lt; len ; i++) {
      VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
      CSTRING_TO_JSTRING(name, a.name);
<span class="line-added">+     JVMCIObject value;</span>
      BOXED_LONG(value, a.value);
<span class="line-modified">!     JVMCIENV-&gt;put_object_at(vmAddresses, i * 2, name);</span>
<span class="line-modified">!     JVMCIENV-&gt;put_object_at(vmAddresses, i * 2 + 1, value);</span>
    }
  
  #define COUNT_FLAG(ignore) +1
  #ifdef ASSERT
  #define CHECK_FLAG(type, name) { \
<span class="line-modified">!   const JVMFlag* flag = JVMFlag::find_declared_flag(#name); \</span>
    assert(flag != NULL, &quot;No such flag named &quot; #name); \
    assert(flag-&gt;is_##type(), &quot;JVMFlag &quot; #name &quot; is not of type &quot; #type); \
  }
  #else
  #define CHECK_FLAG(type, name)
  #endif
  
<span class="line-modified">! #define ADD_FLAG(type, name, convert) {                                                \</span>
<span class="line-modified">!   CHECK_FLAG(type, name)                                                               \</span>
<span class="line-modified">!   CSTRING_TO_JSTRING(fname, #name);                                                    \</span>
<span class="line-modified">!   CSTRING_TO_JSTRING(ftype, #type);                                                    \</span>
<span class="line-modified">!   convert(value, name);                                                                \</span>
<span class="line-modified">!   JVMCIObject vmFlagObj = JVMCIENV-&gt;new_VMFlag(fname, ftype, value, JVMCI_CHECK_NULL); \</span>
<span class="line-modified">!   JVMCIENV-&gt;put_object_at(vmFlags, i++, vmFlagObj);                                    \</span>
  }
  #define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)
  #define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)
  #define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)
  
    len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);
<span class="line-modified">!   JVMCIObjectArray vmFlags = JVMCIENV-&gt;new_VMFlag_array(len, JVMCI_CHECK_NULL);</span>
    int i = 0;
<span class="line-added">+   JVMCIObject value;</span>
    PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)
  
<span class="line-modified">!   JVMCIObjectArray vmIntrinsics = CompilerToVM::initialize_intrinsics(JVMCI_CHECK_NULL);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   JVMCIObjectArray data = JVMCIENV-&gt;new_Object_array(5, JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   JVMCIENV-&gt;put_object_at(data, 0, vmFields);</span>
<span class="line-modified">!   JVMCIENV-&gt;put_object_at(data, 1, vmConstants);</span>
<span class="line-modified">!   JVMCIENV-&gt;put_object_at(data, 2, vmAddresses);</span>
<span class="line-modified">!   JVMCIENV-&gt;put_object_at(data, 3, vmFlags);</span>
<span class="line-modified">!   JVMCIENV-&gt;put_object_at(data, 4, vmIntrinsics);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobjectArray(data);</span>
  }
</pre>
<center><a href="jvmciCompilerToVM.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciEnv.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
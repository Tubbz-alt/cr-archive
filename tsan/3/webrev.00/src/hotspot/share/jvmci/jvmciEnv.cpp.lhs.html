<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 26 #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
<span class="line-modified"> 27 #include &quot;classfile/javaAssertions.hpp&quot;</span>
<span class="line-removed"> 28 #include &quot;classfile/systemDictionary.hpp&quot;</span>
<span class="line-removed"> 29 #include &quot;classfile/vmSymbols.hpp&quot;</span>
 30 #include &quot;code/codeCache.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 31 #include &quot;code/scopeDesc.hpp&quot;</span>
<span class="line-removed"> 32 #include &quot;compiler/compileBroker.hpp&quot;</span>
<span class="line-removed"> 33 #include &quot;compiler/compileLog.hpp&quot;</span>
<span class="line-removed"> 34 #include &quot;compiler/compilerOracle.hpp&quot;</span>
<span class="line-removed"> 35 #include &quot;interpreter/linkResolver.hpp&quot;</span>
<span class="line-removed"> 36 #include &quot;memory/allocation.inline.hpp&quot;</span>
 37 #include &quot;memory/oopFactory.hpp&quot;
 38 #include &quot;memory/resourceArea.hpp&quot;
 39 #include &quot;memory/universe.hpp&quot;
<a name="3" id="anc3"></a><span class="line-removed"> 40 #include &quot;oops/constantPool.inline.hpp&quot;</span>
<span class="line-removed"> 41 #include &quot;oops/cpCache.inline.hpp&quot;</span>
<span class="line-removed"> 42 #include &quot;oops/method.inline.hpp&quot;</span>
<span class="line-removed"> 43 #include &quot;oops/methodData.hpp&quot;</span>
 44 #include &quot;oops/objArrayKlass.hpp&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 45 #include &quot;oops/oop.inline.hpp&quot;</span>
<span class="line-modified"> 46 #include &quot;prims/jvmtiExport.hpp&quot;</span>
<span class="line-modified"> 47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
<span class="line-modified"> 48 #include &quot;runtime/handles.inline.hpp&quot;</span>
<span class="line-modified"> 49 #include &quot;runtime/init.hpp&quot;</span>
<span class="line-removed"> 50 #include &quot;runtime/reflection.hpp&quot;</span>
<span class="line-removed"> 51 #include &quot;runtime/sharedRuntime.hpp&quot;</span>
<span class="line-removed"> 52 #include &quot;runtime/sweeper.hpp&quot;</span>
<span class="line-removed"> 53 #include &quot;utilities/dtrace.hpp&quot;</span>
 54 #include &quot;jvmci/jvmciRuntime.hpp&quot;
<a name="5" id="anc5"></a><span class="line-removed"> 55 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
 56 
<a name="6" id="anc6"></a><span class="line-modified"> 57 JVMCIEnv::JVMCIEnv(CompileTask* task, int system_dictionary_modification_counter):</span>
 58   _task(task),
<a name="7" id="anc7"></a><span class="line-removed"> 59   _system_dictionary_modification_counter(system_dictionary_modification_counter),</span>
 60   _retryable(true),
 61   _failure_reason(NULL),
<a name="8" id="anc8"></a><span class="line-modified"> 62   _failure_reason_on_C_heap(false)</span>
<span class="line-removed"> 63 {</span>
 64   // Get Jvmti capabilities under lock to get consistent values.
 65   MutexLocker mu(JvmtiThreadState_lock);
<a name="9" id="anc9"></a>
 66   _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint() ? 1 : 0;
 67   _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables() ? 1 : 0;
 68   _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions() ? 1 : 0;
 69   _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame() ? 1 : 0;
 70 }
 71 
<a name="10" id="anc10"></a><span class="line-modified"> 72 bool JVMCIEnv::jvmti_state_changed() const {</span>




 73   if (!jvmti_can_access_local_variables() &amp;&amp;
 74       JvmtiExport::can_access_local_variables()) {
 75     return true;
 76   }
 77   if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
 78       JvmtiExport::can_hotswap_or_post_breakpoint()) {
 79     return true;
 80   }
 81   if (!jvmti_can_post_on_exceptions() &amp;&amp;
 82       JvmtiExport::can_post_on_exceptions()) {
 83     return true;
 84   }
 85   if (!jvmti_can_pop_frame() &amp;&amp;
 86       JvmtiExport::can_pop_frame()) {
 87     return true;
 88   }
 89   return false;
 90 }
 91 
<a name="11" id="anc11"></a><span class="line-modified"> 92 // ------------------------------------------------------------------</span>
<span class="line-modified"> 93 // Note: the logic of this method should mirror the logic of</span>
<span class="line-modified"> 94 // constantPoolOopDesc::verify_constant_pool_resolve.</span>
<span class="line-modified"> 95 bool JVMCIEnv::check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass) {</span>
<span class="line-modified"> 96   if (accessing_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified"> 97     accessing_klass = ObjArrayKlass::cast(accessing_klass)-&gt;bottom_klass();</span>






 98   }
<a name="12" id="anc12"></a><span class="line-modified"> 99   if (!accessing_klass-&gt;is_instance_klass()) {</span>
<span class="line-modified">100     return true;</span>




101   }
102 
<a name="13" id="anc13"></a><span class="line-modified">103   if (resolved_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified">104     // Find the element klass, if this is an array.</span>
<span class="line-modified">105     resolved_klass = ObjArrayKlass::cast(resolved_klass)-&gt;bottom_klass();</span>




106   }
<a name="14" id="anc14"></a><span class="line-modified">107   if (resolved_klass-&gt;is_instance_klass()) {</span>
<span class="line-modified">108     Reflection::VerifyClassAccessResults result =</span>
<span class="line-modified">109       Reflection::verify_class_access(accessing_klass, InstanceKlass::cast(resolved_klass), true);</span>
<span class="line-modified">110     return result == Reflection::ACCESS_OK;</span>


























111   }
<a name="15" id="anc15"></a><span class="line-removed">112   return true;</span>
113 }
114 
<a name="16" id="anc16"></a><span class="line-modified">115 // ------------------------------------------------------------------</span>
<span class="line-modified">116 Klass* JVMCIEnv::get_klass_by_name_impl(Klass* accessing_klass,</span>
<span class="line-modified">117                                         const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">118                                         Symbol* sym,</span>
<span class="line-modified">119                                         bool require_local) {</span>
<span class="line-modified">120   JVMCI_EXCEPTION_CONTEXT;</span>































121 
<a name="17" id="anc17"></a><span class="line-modified">122   // Now we need to check the SystemDictionary</span>
<span class="line-modified">123   if (sym-&gt;char_at(0) == &#39;L&#39; &amp;&amp;</span>
<span class="line-modified">124     sym-&gt;char_at(sym-&gt;utf8_length()-1) == &#39;;&#39;) {</span>
<span class="line-modified">125     // This is a name from a signature.  Strip off the trimmings.</span>
<span class="line-modified">126     // Call recursive to keep scope of strippedsym.</span>
<span class="line-modified">127     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,</span>
<span class="line-modified">128                     sym-&gt;utf8_length()-2,</span>
<span class="line-modified">129                     CHECK_NULL);</span>
<span class="line-modified">130     return get_klass_by_name_impl(accessing_klass, cpool, strippedsym, require_local);</span>

131   }
<a name="18" id="anc18"></a>

132 
<a name="19" id="anc19"></a><span class="line-modified">133   Handle loader(THREAD, (oop)NULL);</span>
<span class="line-modified">134   Handle domain(THREAD, (oop)NULL);</span>
<span class="line-modified">135   if (accessing_klass != NULL) {</span>
<span class="line-modified">136     loader = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-modified">137     domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>






138   }
139 
<a name="20" id="anc20"></a><span class="line-modified">140   Klass* found_klass = NULL;</span>
<span class="line-modified">141   {</span>
<span class="line-modified">142     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems</span>
<span class="line-modified">143     MutexLocker ml(Compile_lock);</span>
<span class="line-modified">144     if (!require_local) {</span>
<span class="line-modified">145       found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, CHECK_NULL);</span>
























146     } else {
<a name="21" id="anc21"></a><span class="line-modified">147       found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain, CHECK_NULL);</span>
<span class="line-modified">148     }</span>
<span class="line-modified">149   }</span>
<span class="line-modified">150 </span>
<span class="line-modified">151   // If we fail to find an array klass, look again for its element type.</span>
<span class="line-modified">152   // The element type may be available either locally or via constraints.</span>
<span class="line-modified">153   // In either case, if we can find the element type in the system dictionary,</span>
<span class="line-removed">154   // we must build an array type around it.  The CI requires array klasses</span>
<span class="line-removed">155   // to be loaded if their element klasses are loaded, except when memory</span>
<span class="line-removed">156   // is exhausted.</span>
<span class="line-removed">157   if (sym-&gt;char_at(0) == &#39;[&#39; &amp;&amp;</span>
<span class="line-removed">158       (sym-&gt;char_at(1) == &#39;[&#39; || sym-&gt;char_at(1) == &#39;L&#39;)) {</span>
<span class="line-removed">159     // We have an unloaded array.</span>
<span class="line-removed">160     // Build it on the fly if the element class exists.</span>
<span class="line-removed">161     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,</span>
<span class="line-removed">162                                                  sym-&gt;utf8_length()-1,</span>
<span class="line-removed">163                                                  CHECK_NULL);</span>
<span class="line-removed">164 </span>
<span class="line-removed">165     // Get element Klass recursively.</span>
<span class="line-removed">166     Klass* elem_klass =</span>
<span class="line-removed">167       get_klass_by_name_impl(accessing_klass,</span>
<span class="line-removed">168                              cpool,</span>
<span class="line-removed">169                              elem_sym,</span>
<span class="line-removed">170                              require_local);</span>
<span class="line-removed">171     if (elem_klass != NULL) {</span>
<span class="line-removed">172       // Now make an array for it</span>
<span class="line-removed">173       return elem_klass-&gt;array_klass(THREAD);</span>
<span class="line-removed">174     }</span>
<span class="line-removed">175   }</span>
<span class="line-removed">176 </span>
<span class="line-removed">177   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {</span>
<span class="line-removed">178     // Look inside the constant pool for pre-resolved class entries.</span>
<span class="line-removed">179     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {</span>
<span class="line-removed">180       if (cpool-&gt;tag_at(i).is_klass()) {</span>
<span class="line-removed">181         Klass*  kls = cpool-&gt;resolved_klass_at(i);</span>
<span class="line-removed">182         if (kls-&gt;name() == sym) {</span>
<span class="line-removed">183           return kls;</span>
<span class="line-removed">184         }</span>
185       }
<a name="22" id="anc22"></a>
186     }
187   }
188 
<a name="23" id="anc23"></a><span class="line-modified">189   return found_klass;</span>





























































190 }
191 
<a name="24" id="anc24"></a><span class="line-modified">192 // ------------------------------------------------------------------</span>
<span class="line-modified">193 Klass* JVMCIEnv::get_klass_by_name(Klass* accessing_klass,</span>
<span class="line-modified">194                                   Symbol* klass_name,</span>
<span class="line-modified">195                                   bool require_local) {</span>














196   ResourceMark rm;
<a name="25" id="anc25"></a><span class="line-modified">197   constantPoolHandle cpool;</span>
<span class="line-modified">198   return get_klass_by_name_impl(accessing_klass,</span>
<span class="line-modified">199                                 cpool,</span>
<span class="line-modified">200                                 klass_name,</span>
<span class="line-modified">201                                 require_local);</span>
<span class="line-modified">202 }</span>
<span class="line-modified">203 </span>
<span class="line-modified">204 // ------------------------------------------------------------------</span>
<span class="line-modified">205 // Implementation of get_klass_by_index.</span>
<span class="line-modified">206 Klass* JVMCIEnv::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">207                                         int index,</span>
<span class="line-modified">208                                         bool&amp; is_accessible,</span>
<span class="line-modified">209                                         Klass* accessor) {</span>
<span class="line-modified">210   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-removed">211   Klass* klass = ConstantPool::klass_at_if_loaded(cpool, index);</span>
<span class="line-removed">212   Symbol* klass_name = NULL;</span>
<span class="line-removed">213   if (klass == NULL) {</span>
<span class="line-removed">214     klass_name = cpool-&gt;klass_name_at(index);</span>
<span class="line-removed">215   }</span>
<span class="line-removed">216 </span>
<span class="line-removed">217   if (klass == NULL) {</span>
<span class="line-removed">218     // Not found in constant pool.  Use the name to do the lookup.</span>
<span class="line-removed">219     Klass* k = get_klass_by_name_impl(accessor,</span>
<span class="line-removed">220                                       cpool,</span>
<span class="line-removed">221                                       klass_name,</span>
<span class="line-removed">222                                       false);</span>
<span class="line-removed">223     // Calculate accessibility the hard way.</span>
<span class="line-removed">224     if (k == NULL) {</span>
<span class="line-removed">225       is_accessible = false;</span>
<span class="line-removed">226     } else if (k-&gt;class_loader() != accessor-&gt;class_loader() &amp;&amp;</span>
<span class="line-removed">227                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {</span>
<span class="line-removed">228       // Loaded only remotely.  Not linked yet.</span>
<span class="line-removed">229       is_accessible = false;</span>
230     } else {
<a name="26" id="anc26"></a><span class="line-modified">231       // Linked locally, and we must also check public/private, etc.</span>
<span class="line-modified">232       is_accessible = check_klass_accessibility(accessor, k);</span>












233     }
<a name="27" id="anc27"></a><span class="line-modified">234     if (!is_accessible) {</span>
<span class="line-modified">235       return NULL;</span>







236     }
<a name="28" id="anc28"></a><span class="line-removed">237     return k;</span>
238   }
<a name="29" id="anc29"></a>
239 
<a name="30" id="anc30"></a><span class="line-modified">240   // It is known to be accessible, since it was found in the constant pool.</span>
<span class="line-modified">241   is_accessible = true;</span>
<span class="line-modified">242   return klass;</span>





243 }
244 
<a name="31" id="anc31"></a><span class="line-modified">245 // ------------------------------------------------------------------</span>
<span class="line-modified">246 // Get a klass from the constant pool.</span>
<span class="line-modified">247 Klass* JVMCIEnv::get_klass_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">248                                     int index,</span>
<span class="line-modified">249                                     bool&amp; is_accessible,</span>
<span class="line-modified">250                                     Klass* accessor) {</span>
<span class="line-modified">251   ResourceMark rm;</span>
<span class="line-modified">252   return get_klass_by_index_impl(cpool, index, is_accessible, accessor);</span>
253 }
254 
<a name="32" id="anc32"></a><span class="line-modified">255 // ------------------------------------------------------------------</span>
<span class="line-modified">256 // Implementation of get_field_by_index.</span>
<span class="line-modified">257 //</span>
<span class="line-modified">258 // Implementation note: the results of field lookups are cached</span>
<span class="line-modified">259 // in the accessor klass.</span>
<span class="line-modified">260 void JVMCIEnv::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor&amp; field_desc,</span>
<span class="line-modified">261                                         int index) {</span>
<span class="line-modified">262   JVMCI_EXCEPTION_CONTEXT;</span>
263 
<a name="33" id="anc33"></a><span class="line-modified">264   assert(klass-&gt;is_linked(), &quot;must be linked before using its constant-pool&quot;);</span>









265 
<a name="34" id="anc34"></a><span class="line-modified">266   constantPoolHandle cpool(thread, klass-&gt;constants());</span>







267 
<a name="35" id="anc35"></a><span class="line-modified">268   // Get the field&#39;s name, signature, and type.</span>
<span class="line-modified">269   Symbol* name  = cpool-&gt;name_ref_at(index);</span>
















270 
<a name="36" id="anc36"></a><span class="line-modified">271   int nt_index = cpool-&gt;name_and_type_ref_index_at(index);</span>
<span class="line-modified">272   int sig_index = cpool-&gt;signature_ref_index_at(nt_index);</span>
<span class="line-modified">273   Symbol* signature = cpool-&gt;symbol_at(sig_index);</span>















274 
<a name="37" id="anc37"></a><span class="line-modified">275   // Get the field&#39;s declared holder.</span>
<span class="line-modified">276   int holder_index = cpool-&gt;klass_ref_index_at(index);</span>
<span class="line-modified">277   bool holder_is_accessible;</span>
<span class="line-modified">278   Klass* declared_holder = get_klass_by_index(cpool, holder_index,</span>
<span class="line-modified">279                                               holder_is_accessible,</span>
<span class="line-modified">280                                               klass);</span>












281 
<a name="38" id="anc38"></a><span class="line-modified">282   // The declared holder of this field may not have been loaded.</span>
<span class="line-modified">283   // Bail out with partial field information.</span>
<span class="line-modified">284   if (!holder_is_accessible) {</span>
<span class="line-modified">285     return;</span>












286   }
<a name="39" id="anc39"></a>
287 
<a name="40" id="anc40"></a>





















288 
<a name="41" id="anc41"></a><span class="line-modified">289   // Perform the field lookup.</span>
<span class="line-modified">290   Klass*  canonical_holder =</span>
<span class="line-removed">291     InstanceKlass::cast(declared_holder)-&gt;find_field(name, signature, &amp;field_desc);</span>
<span class="line-removed">292   if (canonical_holder == NULL) {</span>
293     return;
294   }
<a name="42" id="anc42"></a>






295 
<a name="43" id="anc43"></a><span class="line-modified">296   assert(canonical_holder == field_desc.field_holder(), &quot;just checking&quot;);</span>






297 }
298 
<a name="44" id="anc44"></a><span class="line-modified">299 // ------------------------------------------------------------------</span>
<span class="line-modified">300 // Get a field by index from a klass&#39;s constant pool.</span>
<span class="line-modified">301 void JVMCIEnv::get_field_by_index(InstanceKlass* accessor, fieldDescriptor&amp; fd, int index) {</span>
<span class="line-modified">302   ResourceMark rm;</span>
<span class="line-modified">303   return get_field_by_index_impl(accessor, fd, index);</span>
<span class="line-modified">304 }</span>
<span class="line-modified">305 </span>
<span class="line-modified">306 // ------------------------------------------------------------------</span>
<span class="line-modified">307 // Perform an appropriate method lookup based on accessor, holder,</span>
<span class="line-modified">308 // name, signature, and bytecode.</span>
<span class="line-modified">309 methodHandle JVMCIEnv::lookup_method(InstanceKlass* accessor,</span>
<span class="line-modified">310                                Klass*         holder,</span>
<span class="line-modified">311                                Symbol*        name,</span>
<span class="line-modified">312                                Symbol*        sig,</span>
<span class="line-modified">313                                Bytecodes::Code bc,</span>
<span class="line-modified">314                                constantTag   tag) {</span>
<span class="line-modified">315   // Accessibility checks are performed in JVMCIEnv::get_method_by_index_impl().</span>
<span class="line-modified">316   assert(check_klass_accessibility(accessor, holder), &quot;holder not accessible&quot;);</span>
<span class="line-modified">317 </span>
<span class="line-modified">318   methodHandle dest_method;</span>
<span class="line-modified">319   LinkInfo link_info(holder, name, sig, accessor, LinkInfo::needs_access_check, tag);</span>
<span class="line-modified">320   switch (bc) {</span>
<span class="line-removed">321   case Bytecodes::_invokestatic:</span>
<span class="line-removed">322     dest_method =</span>
<span class="line-removed">323       LinkResolver::resolve_static_call_or_null(link_info);</span>
<span class="line-removed">324     break;</span>
<span class="line-removed">325   case Bytecodes::_invokespecial:</span>
<span class="line-removed">326     dest_method =</span>
<span class="line-removed">327       LinkResolver::resolve_special_call_or_null(link_info);</span>
<span class="line-removed">328     break;</span>
<span class="line-removed">329   case Bytecodes::_invokeinterface:</span>
<span class="line-removed">330     dest_method =</span>
<span class="line-removed">331       LinkResolver::linktime_resolve_interface_method_or_null(link_info);</span>
<span class="line-removed">332     break;</span>
<span class="line-removed">333   case Bytecodes::_invokevirtual:</span>
<span class="line-removed">334     dest_method =</span>
<span class="line-removed">335       LinkResolver::linktime_resolve_virtual_method_or_null(link_info);</span>
<span class="line-removed">336     break;</span>
<span class="line-removed">337   default: ShouldNotReachHere();</span>
<span class="line-removed">338   }</span>
<span class="line-removed">339 </span>
<span class="line-removed">340   return dest_method;</span>
<span class="line-removed">341 }</span>
<span class="line-removed">342 </span>
<span class="line-removed">343 </span>
<span class="line-removed">344 // ------------------------------------------------------------------</span>
<span class="line-removed">345 methodHandle JVMCIEnv::get_method_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-removed">346                                           int index, Bytecodes::Code bc,</span>
<span class="line-removed">347                                           InstanceKlass* accessor) {</span>
<span class="line-removed">348   if (bc == Bytecodes::_invokedynamic) {</span>
<span class="line-removed">349     ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);</span>
<span class="line-removed">350     bool is_resolved = !cpce-&gt;is_f1_null();</span>
<span class="line-removed">351     if (is_resolved) {</span>
<span class="line-removed">352       // Get the invoker Method* from the constant pool.</span>
<span class="line-removed">353       // (The appendix argument, if any, will be noted in the method&#39;s signature.)</span>
<span class="line-removed">354       Method* adapter = cpce-&gt;f1_as_method();</span>
<span class="line-removed">355       return methodHandle(adapter);</span>
356     }
<a name="45" id="anc45"></a>


357 
<a name="46" id="anc46"></a><span class="line-modified">358     return NULL;</span>















359   }
<a name="47" id="anc47"></a>
360 
<a name="48" id="anc48"></a><span class="line-modified">361   int holder_index = cpool-&gt;klass_ref_index_at(index);</span>
<span class="line-modified">362   bool holder_is_accessible;</span>
<span class="line-modified">363   Klass* holder = get_klass_by_index_impl(cpool, holder_index, holder_is_accessible, accessor);</span>
<span class="line-modified">364 </span>
<span class="line-modified">365   // Get the method&#39;s name and signature.</span>
<span class="line-modified">366   Symbol* name_sym = cpool-&gt;name_ref_at(index);</span>
<span class="line-modified">367   Symbol* sig_sym  = cpool-&gt;signature_ref_at(index);</span>
<span class="line-modified">368 </span>
<span class="line-modified">369   if (cpool-&gt;has_preresolution()</span>
<span class="line-modified">370       || ((holder == SystemDictionary::MethodHandle_klass() || holder == SystemDictionary::VarHandle_klass()) &amp;&amp;</span>
<span class="line-modified">371           MethodHandles::is_signature_polymorphic_name(holder, name_sym))) {</span>
<span class="line-removed">372     // Short-circuit lookups for JSR 292-related call sites.</span>
<span class="line-removed">373     // That is, do not rely only on name-based lookups, because they may fail</span>
<span class="line-removed">374     // if the names are not resolvable in the boot class loader (7056328).</span>
<span class="line-removed">375     switch (bc) {</span>
<span class="line-removed">376     case Bytecodes::_invokevirtual:</span>
<span class="line-removed">377     case Bytecodes::_invokeinterface:</span>
<span class="line-removed">378     case Bytecodes::_invokespecial:</span>
<span class="line-removed">379     case Bytecodes::_invokestatic:</span>
<span class="line-removed">380       {</span>
<span class="line-removed">381         Method* m = ConstantPool::method_at_if_loaded(cpool, index);</span>
<span class="line-removed">382         if (m != NULL) {</span>
<span class="line-removed">383           return m;</span>
<span class="line-removed">384         }</span>
<span class="line-removed">385       }</span>
386       break;
387     default:
<a name="49" id="anc49"></a><span class="line-modified">388       break;</span>

































389     }
<a name="50" id="anc50"></a>











































390   }
<a name="51" id="anc51"></a>
391 
<a name="52" id="anc52"></a><span class="line-modified">392   if (holder_is_accessible) { // Our declared holder is loaded.</span>
<span class="line-modified">393     constantTag tag = cpool-&gt;tag_ref_at(index);</span>
<span class="line-modified">394     methodHandle m = lookup_method(accessor, holder, name_sym, sig_sym, bc, tag);</span>
<span class="line-modified">395     if (!m.is_null()) {</span>
<span class="line-modified">396       // We found the method.</span>
<span class="line-modified">397       return m;</span>


















398     }
<a name="53" id="anc53"></a>
399   }
<a name="54" id="anc54"></a>
400 
<a name="55" id="anc55"></a><span class="line-modified">401   // Either the declared holder was not loaded, or the method could</span>
<span class="line-modified">402   // not be found.</span>








403 
<a name="56" id="anc56"></a><span class="line-modified">404   return NULL;</span>
405 }
406 
<a name="57" id="anc57"></a><span class="line-modified">407 // ------------------------------------------------------------------</span>
<span class="line-modified">408 InstanceKlass* JVMCIEnv::get_instance_klass_for_declared_method_holder(Klass* method_holder) {</span>
<span class="line-modified">409   // For the case of &lt;array&gt;.clone(), the method holder can be an ArrayKlass*</span>
<span class="line-modified">410   // instead of an InstanceKlass*.  For that case simply pretend that the</span>
<span class="line-modified">411   // declared holder is Object.clone since that&#39;s where the call will bottom out.</span>
<span class="line-modified">412   if (method_holder-&gt;is_instance_klass()) {</span>
<span class="line-modified">413     return InstanceKlass::cast(method_holder);</span>
<span class="line-modified">414   } else if (method_holder-&gt;is_array_klass()) {</span>
<span class="line-removed">415     return SystemDictionary::Object_klass();</span>
416   } else {
<a name="58" id="anc58"></a><span class="line-modified">417     ShouldNotReachHere();</span>






418   }
<a name="59" id="anc59"></a><span class="line-removed">419   return NULL;</span>
420 }
421 
<a name="60" id="anc60"></a>















422 
<a name="61" id="anc61"></a><span class="line-modified">423 // ------------------------------------------------------------------</span>
<span class="line-modified">424 methodHandle JVMCIEnv::get_method_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">425                                      int index, Bytecodes::Code bc,</span>
<span class="line-modified">426                                      InstanceKlass* accessor) {</span>
<span class="line-modified">427   ResourceMark rm;</span>
<span class="line-modified">428   return get_method_by_index_impl(cpool, index, bc, accessor);</span>
<span class="line-modified">429 }</span>
<span class="line-modified">430 </span>
<span class="line-modified">431 // ------------------------------------------------------------------</span>
<span class="line-modified">432 // Check for changes to the system dictionary during compilation</span>
<span class="line-modified">433 // class loads, evolution, breakpoints</span>
<span class="line-modified">434 JVMCIEnv::CodeInstallResult JVMCIEnv::validate_compile_task_dependencies(Dependencies* dependencies, Handle compiled_code,</span>
<span class="line-removed">435                                                                          JVMCIEnv* env, char** failure_detail) {</span>
<span class="line-removed">436   // If JVMTI capabilities were enabled during compile, the compilation is invalidated.</span>
<span class="line-removed">437   if (env != NULL &amp;&amp; env-&gt;jvmti_state_changed()) {</span>
<span class="line-removed">438     *failure_detail = (char*) &quot;Jvmti state change during compilation invalidated dependencies&quot;;</span>
<span class="line-removed">439     return JVMCIEnv::dependencies_failed;</span>
<span class="line-removed">440   }</span>
<span class="line-removed">441 </span>
<span class="line-removed">442   // Dependencies must be checked when the system dictionary changes</span>
<span class="line-removed">443   // or if we don&#39;t know whether it has changed (i.e., env == NULL).</span>
<span class="line-removed">444   bool counter_changed = env == NULL || env-&gt;_system_dictionary_modification_counter != SystemDictionary::number_of_modifications();</span>
<span class="line-removed">445   CompileTask* task = env == NULL ? NULL : env-&gt;task();</span>
<span class="line-removed">446   Dependencies::DepType result = dependencies-&gt;validate_dependencies(task, counter_changed, failure_detail);</span>
<span class="line-removed">447   if (result == Dependencies::end_marker) {</span>
<span class="line-removed">448     return JVMCIEnv::ok;</span>
<span class="line-removed">449   }</span>
<span class="line-removed">450 </span>
<span class="line-removed">451   if (!Dependencies::is_klass_type(result) || counter_changed) {</span>
<span class="line-removed">452     return JVMCIEnv::dependencies_failed;</span>
<span class="line-removed">453   }</span>
<span class="line-removed">454   // The dependencies were invalid at the time of installation</span>
<span class="line-removed">455   // without any intervening modification of the system</span>
<span class="line-removed">456   // dictionary.  That means they were invalidly constructed.</span>
<span class="line-removed">457   return JVMCIEnv::dependencies_invalid;</span>
<span class="line-removed">458 }</span>
<span class="line-removed">459 </span>
<span class="line-removed">460 // ------------------------------------------------------------------</span>
<span class="line-removed">461 JVMCIEnv::CodeInstallResult JVMCIEnv::register_method(</span>
<span class="line-removed">462                                 const methodHandle&amp; method,</span>
<span class="line-removed">463                                 nmethod*&amp; nm,</span>
<span class="line-removed">464                                 int entry_bci,</span>
<span class="line-removed">465                                 CodeOffsets* offsets,</span>
<span class="line-removed">466                                 int orig_pc_offset,</span>
<span class="line-removed">467                                 CodeBuffer* code_buffer,</span>
<span class="line-removed">468                                 int frame_words,</span>
<span class="line-removed">469                                 OopMapSet* oop_map_set,</span>
<span class="line-removed">470                                 ExceptionHandlerTable* handler_table,</span>
<span class="line-removed">471                                 AbstractCompiler* compiler,</span>
<span class="line-removed">472                                 DebugInformationRecorder* debug_info,</span>
<span class="line-removed">473                                 Dependencies* dependencies,</span>
<span class="line-removed">474                                 JVMCIEnv* env,</span>
<span class="line-removed">475                                 int compile_id,</span>
<span class="line-removed">476                                 bool has_unsafe_access,</span>
<span class="line-removed">477                                 bool has_wide_vector,</span>
<span class="line-removed">478                                 Handle installed_code,</span>
<span class="line-removed">479                                 Handle compiled_code,</span>
<span class="line-removed">480                                 Handle speculation_log) {</span>
<span class="line-removed">481   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-removed">482   nm = NULL;</span>
<span class="line-removed">483   int comp_level = CompLevel_full_optimization;</span>
<span class="line-removed">484   char* failure_detail = NULL;</span>
<span class="line-removed">485   JVMCIEnv::CodeInstallResult result;</span>
<span class="line-removed">486   {</span>
<span class="line-removed">487     // To prevent compile queue updates.</span>
<span class="line-removed">488     MutexLocker locker(MethodCompileQueue_lock, THREAD);</span>
<span class="line-removed">489 </span>
<span class="line-removed">490     // Prevent SystemDictionary::add_to_hierarchy from running</span>
<span class="line-removed">491     // and invalidating our dependencies until we install this method.</span>
<span class="line-removed">492     MutexLocker ml(Compile_lock);</span>
<span class="line-removed">493 </span>
<span class="line-removed">494     // Encode the dependencies now, so we can check them right away.</span>
<span class="line-removed">495     dependencies-&gt;encode_content_bytes();</span>
<span class="line-removed">496 </span>
<span class="line-removed">497     // Record the dependencies for the current compile in the log</span>
<span class="line-removed">498     if (LogCompilation) {</span>
<span class="line-removed">499       for (Dependencies::DepStream deps(dependencies); deps.next(); ) {</span>
<span class="line-removed">500         deps.log_dependency();</span>
<span class="line-removed">501       }</span>
502     }
<a name="62" id="anc62"></a>


503 
<a name="63" id="anc63"></a><span class="line-modified">504     // Check for {class loads, evolution, breakpoints} during compilation</span>
<span class="line-modified">505     result = validate_compile_task_dependencies(dependencies, compiled_code, env, &amp;failure_detail);</span>
<span class="line-modified">506     if (result != JVMCIEnv::ok) {</span>
<span class="line-modified">507       // While not a true deoptimization, it is a preemptive decompile.</span>
<span class="line-modified">508       MethodData* mdp = method()-&gt;method_data();</span>
<span class="line-modified">509       if (mdp != NULL) {</span>
<span class="line-modified">510         mdp-&gt;inc_decompile_count();</span>
<span class="line-modified">511 #ifdef ASSERT</span>
<span class="line-modified">512         if (mdp-&gt;decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {</span>
<span class="line-modified">513           ResourceMark m;</span>
<span class="line-modified">514           tty-&gt;print_cr(&quot;WARN: endless recompilation of %s. Method was set to not compilable.&quot;, method()-&gt;name_and_sig_as_C_string());</span>
<span class="line-modified">515         }</span>
<span class="line-modified">516 #endif</span>




















































































































































517       }
<a name="64" id="anc64"></a>




















































































518 
<a name="65" id="anc65"></a><span class="line-modified">519       // All buffers in the CodeBuffer are allocated in the CodeCache.</span>
<span class="line-modified">520       // If the code buffer is created on each compile attempt</span>
<span class="line-modified">521       // as in C2, then it must be freed.</span>
<span class="line-modified">522       //code_buffer-&gt;free_blob();</span>
























































523     } else {
<a name="66" id="anc66"></a><span class="line-modified">524       ImplicitExceptionTable implicit_tbl;</span>
<span class="line-modified">525       nm =  nmethod::new_nmethod(method,</span>
<span class="line-modified">526                                  compile_id,</span>
<span class="line-modified">527                                  entry_bci,</span>
<span class="line-modified">528                                  offsets,</span>
<span class="line-modified">529                                  orig_pc_offset,</span>
<span class="line-modified">530                                  debug_info, dependencies, code_buffer,</span>
<span class="line-modified">531                                  frame_words, oop_map_set,</span>
<span class="line-modified">532                                  handler_table, &amp;implicit_tbl,</span>
<span class="line-modified">533                                  compiler, comp_level,</span>
<span class="line-modified">534                                  JNIHandles::make_weak_global(installed_code),</span>
<span class="line-modified">535                                  JNIHandles::make_weak_global(speculation_log));</span>
<span class="line-modified">536 </span>
<span class="line-modified">537       // Free codeBlobs</span>
<span class="line-modified">538       //code_buffer-&gt;free_blob();</span>
<span class="line-modified">539       if (nm == NULL) {</span>
<span class="line-modified">540         // The CodeCache is full.  Print out warning and disable compilation.</span>
<span class="line-modified">541         {</span>
<span class="line-modified">542           MutexUnlocker ml(Compile_lock);</span>
<span class="line-modified">543           MutexUnlocker locker(MethodCompileQueue_lock);</span>
<span class="line-modified">544           CompileBroker::handle_full_code_cache(CodeCache::get_code_blob_type(comp_level));</span>
<span class="line-modified">545         }</span>
<span class="line-modified">546       } else {</span>
<span class="line-modified">547         nm-&gt;set_has_unsafe_access(has_unsafe_access);</span>
<span class="line-modified">548         nm-&gt;set_has_wide_vectors(has_wide_vector);</span>
<span class="line-modified">549 </span>
<span class="line-modified">550         // Record successful registration.</span>
<span class="line-modified">551         // (Put nm into the task handle *before* publishing to the Java heap.)</span>
<span class="line-modified">552         CompileTask* task = env == NULL ? NULL : env-&gt;task();</span>
<span class="line-modified">553         if (task != NULL) {</span>
<span class="line-modified">554           task-&gt;set_code(nm);</span>



































































































































































































































































































































































































































555         }
<a name="67" id="anc67"></a>













556 
<a name="68" id="anc68"></a><span class="line-modified">557         if (installed_code-&gt;is_a(HotSpotNmethod::klass()) &amp;&amp; HotSpotNmethod::isDefault(installed_code())) {</span>
<span class="line-modified">558           if (entry_bci == InvocationEntryBci) {</span>
<span class="line-modified">559             if (TieredCompilation) {</span>
<span class="line-modified">560               // If there is an old version we&#39;re done with it</span>
<span class="line-modified">561               CompiledMethod* old = method-&gt;code();</span>
<span class="line-modified">562               if (TraceMethodReplacement &amp;&amp; old != NULL) {</span>
<span class="line-modified">563                 ResourceMark rm;</span>
<span class="line-modified">564                 char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-modified">565                 tty-&gt;print_cr(&quot;Replacing method %s&quot;, method_name);</span>
<span class="line-removed">566               }</span>
<span class="line-removed">567               if (old != NULL ) {</span>
<span class="line-removed">568                 old-&gt;make_not_entrant();</span>
<span class="line-removed">569               }</span>
<span class="line-removed">570             }</span>
<span class="line-removed">571             if (TraceNMethodInstalls) {</span>
<span class="line-removed">572               ResourceMark rm;</span>
<span class="line-removed">573               char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-removed">574               ttyLocker ttyl;</span>
<span class="line-removed">575               tty-&gt;print_cr(&quot;Installing method (%d) %s [entry point: %p]&quot;,</span>
<span class="line-removed">576                             comp_level,</span>
<span class="line-removed">577                             method_name, nm-&gt;entry_point());</span>
<span class="line-removed">578             }</span>
<span class="line-removed">579             // Allow the code to be executed</span>
<span class="line-removed">580             method-&gt;set_code(method, nm);</span>
<span class="line-removed">581           } else {</span>
<span class="line-removed">582             if (TraceNMethodInstalls ) {</span>
<span class="line-removed">583               ResourceMark rm;</span>
<span class="line-removed">584               char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-removed">585               ttyLocker ttyl;</span>
<span class="line-removed">586               tty-&gt;print_cr(&quot;Installing osr method (%d) %s @ %d&quot;,</span>
<span class="line-removed">587                             comp_level,</span>
<span class="line-removed">588                             method_name,</span>
<span class="line-removed">589                             entry_bci);</span>
<span class="line-removed">590             }</span>
<span class="line-removed">591             InstanceKlass::cast(method-&gt;method_holder())-&gt;add_osr_nmethod(nm);</span>
<span class="line-removed">592           }</span>
593         }
<a name="69" id="anc69"></a><span class="line-modified">594         nm-&gt;make_in_use();</span>
595       }
<a name="70" id="anc70"></a><span class="line-modified">596       result = nm != NULL ? JVMCIEnv::ok :JVMCIEnv::cache_full;</span>


597     }
<a name="71" id="anc71"></a>








598   }
599 
<a name="72" id="anc72"></a><span class="line-modified">600   // String creation must be done outside lock</span>
<span class="line-modified">601   if (failure_detail != NULL) {</span>
<span class="line-modified">602     // A failure to allocate the string is silently ignored.</span>
<span class="line-modified">603     Handle message = java_lang_String::create_from_str(failure_detail, THREAD);</span>
<span class="line-modified">604     HotSpotCompiledNmethod::set_installationFailureMessage(compiled_code, message());</span>




605   }
<a name="73" id="anc73"></a>

606 
<a name="74" id="anc74"></a><span class="line-modified">607   // JVMTI -- compiled method notification (must be done outside lock)</span>
<span class="line-modified">608   if (nm != NULL) {</span>
<span class="line-removed">609     nm-&gt;post_compiled_method_load_event();</span>
610 
<a name="75" id="anc75"></a><span class="line-modified">611     if (env == NULL) {</span>
<span class="line-modified">612       // This compile didn&#39;t come through the CompileBroker so perform the printing here</span>
<span class="line-modified">613       DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);</span>
<span class="line-modified">614       nm-&gt;maybe_print_nmethod(directive);</span>
<span class="line-modified">615       DirectivesStack::release(directive);</span>
<span class="line-modified">616     }</span>



















617   }
618 
<a name="76" id="anc76"></a><span class="line-modified">619   return result;</span>
<span class="line-modified">620 }</span>







































































































<a name="77" id="anc77"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="77" type="hidden" />
</body>
</html>
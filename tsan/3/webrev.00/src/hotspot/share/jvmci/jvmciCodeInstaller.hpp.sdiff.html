<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciCodeInstaller.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCodeInstaller.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCompiler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCodeInstaller.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_JVMCI_JVMCICODEINSTALLER_HPP
 25 #define SHARE_JVMCI_JVMCICODEINSTALLER_HPP
 26 
<span class="line-modified"> 27 #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
<span class="line-modified"> 28 #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
 29 #include &quot;code/nativeInst.hpp&quot;


 30 
 31 #if INCLUDE_AOT
 32 class RelocBuffer : public StackObj {
 33   enum { stack_size = 1024 };
 34 public:
 35   RelocBuffer() : _size(0), _buffer(0) {}
 36   ~RelocBuffer();
 37   void ensure_size(size_t bytes);
 38   void set_size(size_t bytes);
 39   address begin() const;
 40   size_t size() const { return _size; }
 41 private:
 42   size_t _size;
 43   char _static_buffer[stack_size];
 44   char *_buffer;
 45 };
 46 


 47 class AOTOopRecorder : public OopRecorder {
 48 public:
<span class="line-modified"> 49   AOTOopRecorder(Arena* arena = NULL, bool deduplicate = false);</span>
 50 
 51   virtual int find_index(Metadata* h);
 52   virtual int find_index(jobject h);
 53   int nr_meta_refs() const;
 54   jobject meta_element(int pos) const;
 55 
 56 private:
 57   void record_meta_ref(jobject ref, int index);
 58 
 59   GrowableArray&lt;jobject&gt;* _meta_refs;


 60 };

 61 
 62 class CodeMetadata {
 63 public:
 64   CodeMetadata() {}
 65 
 66   CodeBlob* get_code_blob() const { return _cb; }
 67 
 68   PcDesc* get_pc_desc() const { return _pc_desc; }
 69   int get_nr_pc_desc() const { return _nr_pc_desc; }
 70 
 71   u_char* get_scopes_desc() const { return _scopes_desc; }
 72   int get_scopes_size() const { return _nr_scopes_desc; }
 73 

 74   RelocBuffer* get_reloc_buffer() { return &amp;_reloc_buffer; }
<span class="line-removed"> 75 </span>
 76   AOTOopRecorder* get_oop_recorder() { return _oop_recorder; }

 77 
 78   ExceptionHandlerTable* get_exception_table() { return _exception_table; }
 79 


 80   void set_pc_desc(PcDesc* desc, int count) {
 81     _pc_desc = desc;
 82     _nr_pc_desc = count;
 83   }
 84 
 85   void set_scopes(u_char* scopes, int size) {
 86     _scopes_desc = scopes;
 87     _nr_scopes_desc = size;
 88   }
 89 

 90   void set_oop_recorder(AOTOopRecorder* recorder) {
 91     _oop_recorder = recorder;
 92   }

 93 
 94   void set_exception_table(ExceptionHandlerTable* table) {
 95     _exception_table = table;
 96   }
 97 




 98 private:
 99   CodeBlob* _cb;
100   PcDesc* _pc_desc;
101   int _nr_pc_desc;
102 
103   u_char* _scopes_desc;
104   int _nr_scopes_desc;
105 

106   RelocBuffer _reloc_buffer;
107   AOTOopRecorder* _oop_recorder;

108   ExceptionHandlerTable* _exception_table;

109 };
<span class="line-removed">110 #endif // INCLUDE_AOT</span>
111 
112 /*
113  * This class handles the conversion from a InstalledCode to a CodeBlob or an nmethod.
114  */
115 class CodeInstaller : public StackObj {
116   friend class JVMCIVMStructs;
117 private:
118   enum MarkId {
119     VERIFIED_ENTRY                         = 1,
120     UNVERIFIED_ENTRY                       = 2,
121     OSR_ENTRY                              = 3,
122     EXCEPTION_HANDLER_ENTRY                = 4,
123     DEOPT_HANDLER_ENTRY                    = 5,
124     INVOKEINTERFACE                        = 6,
125     INVOKEVIRTUAL                          = 7,
126     INVOKESTATIC                           = 8,
127     INVOKESPECIAL                          = 9,
128     INLINE_INVOKE                          = 10,
129     POLL_NEAR                              = 11,
130     POLL_RETURN_NEAR                       = 12,
131     POLL_FAR                               = 13,
132     POLL_RETURN_FAR                        = 14,
133     CARD_TABLE_ADDRESS                     = 15,
134     CARD_TABLE_SHIFT                       = 16,
135     HEAP_TOP_ADDRESS                       = 17,
136     HEAP_END_ADDRESS                       = 18,
137     NARROW_KLASS_BASE_ADDRESS              = 19,
138     NARROW_OOP_BASE_ADDRESS                = 20,
139     CRC_TABLE_ADDRESS                      = 21,
140     LOG_OF_HEAP_REGION_GRAIN_BYTES         = 22,
141     INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED = 23,
142     INVOKE_INVALID                         = -1
143   };
144 
145   Arena         _arena;










146 
<span class="line-removed">147   jobject       _data_section_handle;</span>
<span class="line-removed">148   jobject       _data_section_patches_handle;</span>
<span class="line-removed">149   jobject       _sites_handle;</span>
150   CodeOffsets   _offsets;
151 
<span class="line-removed">152   jobject       _code_handle;</span>
153   jint          _code_size;
154   jint          _total_frame_size;
155   jint          _orig_pc_offset;
156   jint          _parameter_count;
157   jint          _constants_size;
<span class="line-removed">158 #ifndef PRODUCT</span>
<span class="line-removed">159   jobject       _comments_handle;</span>
<span class="line-removed">160 #endif</span>
161 
162   bool          _has_wide_vector;
<span class="line-removed">163   jobject       _word_kind_handle;</span>
164 
165   MarkId        _next_call_type;
166   address       _invoke_mark_pc;
167 
168   CodeSection*  _instructions;
169   CodeSection*  _constants;
170 
171   OopRecorder*              _oop_recorder;
172   DebugInformationRecorder* _debug_recorder;
173   Dependencies*             _dependencies;
174   ExceptionHandlerTable     _exception_handler_table;

175 
176   bool _immutable_pic_compilation;  // Installer is called for Immutable PIC compilation.
177 
178   static ConstantOopWriteValue* _oop_null_scope_value;
179   static ConstantIntValue*    _int_m1_scope_value;
180   static ConstantIntValue*    _int_0_scope_value;
181   static ConstantIntValue*    _int_1_scope_value;
182   static ConstantIntValue*    _int_2_scope_value;
183   static LocationValue*       _illegal_value;
184 
<span class="line-modified">185   jint pd_next_offset(NativeInstruction* inst, jint pc_offset, Handle method, TRAPS);</span>
<span class="line-modified">186   void pd_patch_OopConstant(int pc_offset, Handle constant, TRAPS);</span>
<span class="line-modified">187   void pd_patch_MetaspaceConstant(int pc_offset, Handle constant, TRAPS);</span>
<span class="line-modified">188   void pd_patch_DataSectionReference(int pc_offset, int data_offset, TRAPS);</span>
<span class="line-modified">189   void pd_relocate_ForeignCall(NativeInstruction* inst, jlong foreign_call_destination, TRAPS);</span>
<span class="line-modified">190   void pd_relocate_JavaMethod(CodeBuffer &amp;cbuf, Handle method, jint pc_offset, TRAPS);</span>
<span class="line-modified">191   void pd_relocate_poll(address pc, jint mark, TRAPS);</span>
<span class="line-modified">192 </span>
<span class="line-modified">193   objArrayOop sites();</span>
<span class="line-modified">194   arrayOop code();</span>
<span class="line-modified">195   arrayOop data_section();</span>
<span class="line-modified">196   objArrayOop data_section_patches();</span>
197 #ifndef PRODUCT
<span class="line-modified">198   objArrayOop comments();</span>
199 #endif
<span class="line-modified">200 </span>
<span class="line-removed">201   oop word_kind();</span>
202 
203 public:
204 
<span class="line-modified">205   CodeInstaller(bool immutable_pic_compilation) : _arena(mtCompiler), _immutable_pic_compilation(immutable_pic_compilation) {}</span>
206 
207 #if INCLUDE_AOT
<span class="line-modified">208   JVMCIEnv::CodeInstallResult gather_metadata(Handle target, Handle compiled_code, CodeMetadata&amp; metadata, TRAPS);</span>
209 #endif
<span class="line-modified">210   JVMCIEnv::CodeInstallResult install(JVMCICompiler* compiler, Handle target, Handle compiled_code, CodeBlob*&amp; cb, Handle installed_code, Handle speculation_log, TRAPS);</span>











211 
212   static address runtime_call_target_address(oop runtime_call);
<span class="line-modified">213   static VMReg get_hotspot_reg(jint jvmciRegisterNumber, TRAPS);</span>
214   static bool is_general_purpose_reg(VMReg hotspotRegister);
215 
216   const OopMapSet* oopMapSet() const { return _debug_recorder-&gt;_oopmaps; }
217 
218 protected:
<span class="line-modified">219   Location::Type get_oop_type(Thread* thread, Handle value);</span>
<span class="line-modified">220   ScopeValue* get_scope_value(Handle value, BasicType type, GrowableArray&lt;ScopeValue*&gt;* objects, ScopeValue* &amp;second, TRAPS);</span>
<span class="line-modified">221   MonitorValue* get_monitor_value(Handle value, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS);</span>
222 
<span class="line-modified">223   void* record_metadata_reference(CodeSection* section, address dest, Handle constant, TRAPS);</span>
224 #ifdef _LP64
<span class="line-modified">225   narrowKlass record_narrow_metadata_reference(CodeSection* section, address dest, Handle constant, TRAPS);</span>
226 #endif
227 
228   // extract the fields of the HotSpotCompiledCode
<span class="line-modified">229   void initialize_fields(oop target, oop target_method, TRAPS);</span>
<span class="line-modified">230   void initialize_dependencies(oop target_method, OopRecorder* oop_recorder, TRAPS);</span>
231 
<span class="line-modified">232   int estimate_stubs_size(TRAPS);</span>
233 
234   // perform data and call relocation on the CodeBuffer
<span class="line-modified">235   JVMCIEnv::CodeInstallResult initialize_buffer(CodeBuffer&amp; buffer, bool check_size, TRAPS);</span>






236 
<span class="line-modified">237   void assumption_NoFinalizableSubclass(Thread* thread, Handle assumption);</span>
<span class="line-modified">238   void assumption_ConcreteSubtype(Thread* thread, Handle assumption);</span>
<span class="line-modified">239   void assumption_LeafType(Thread* thread, Handle assumption);</span>
<span class="line-modified">240   void assumption_ConcreteMethod(Thread* thread, Handle assumption);</span>
<span class="line-modified">241   void assumption_CallSiteTargetValue(Thread* thread, Handle assumption);</span>

242 
<span class="line-modified">243   void site_Safepoint(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS);</span>
<span class="line-removed">244   void site_Infopoint(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS);</span>
<span class="line-removed">245   void site_Call(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS);</span>
<span class="line-removed">246   void site_DataPatch(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS);</span>
<span class="line-removed">247   void site_Mark(CodeBuffer&amp; buffer, jint pc_offset, Handle site, TRAPS);</span>
<span class="line-removed">248   void site_ExceptionHandler(jint pc_offset, Handle site);</span>
249 
<span class="line-modified">250   OopMap* create_oop_map(Handle debug_info, TRAPS);</span>
251 
252   /**
253    * Specifies the level of detail to record for a scope.
254    */
255   enum ScopeMode {
256     // Only record a method and BCI
257     BytecodePosition,
258     // Record a method, bci and JVM frame state
259     FullFrame
260   };
261 
262   int map_jvmci_bci(int bci);
<span class="line-modified">263   void record_scope(jint pc_offset, Handle debug_info, ScopeMode scope_mode, bool return_oop, TRAPS);</span>
<span class="line-modified">264   void record_scope(jint pc_offset, Handle debug_info, ScopeMode scope_mode, TRAPS) {</span>
<span class="line-modified">265     record_scope(pc_offset, debug_info, scope_mode, false /* return_oop */, THREAD);</span>

266   }
<span class="line-modified">267   void record_scope(jint pc_offset, Handle position, ScopeMode scope_mode, GrowableArray&lt;ScopeValue*&gt;* objects, bool return_oop, TRAPS);</span>
<span class="line-modified">268   void record_object_value(ObjectValue* sv, Handle value, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS);</span>
269 
<span class="line-modified">270   GrowableArray&lt;ScopeValue*&gt;* record_virtual_objects(Handle debug_info, TRAPS);</span>
271 
272   int estimateStubSpace(int static_call_stubs);
273 };
274 
<span class="line-removed">275 /**</span>
<span class="line-removed">276  * Gets the Method metaspace object from a HotSpotResolvedJavaMethodImpl Java object.</span>
<span class="line-removed">277  */</span>
<span class="line-removed">278 Method* getMethodFromHotSpotMethod(oop hotspot_method);</span>
<span class="line-removed">279 </span>
<span class="line-removed">280 </span>
<span class="line-removed">281 </span>
282 #endif // SHARE_JVMCI_JVMCICODEINSTALLER_HPP
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_JVMCI_JVMCICODEINSTALLER_HPP
 25 #define SHARE_JVMCI_JVMCICODEINSTALLER_HPP
 26 
<span class="line-modified"> 27 #include &quot;code/debugInfoRec.hpp&quot;</span>
<span class="line-modified"> 28 #include &quot;code/exceptionHandlerTable.hpp&quot;</span>
 29 #include &quot;code/nativeInst.hpp&quot;
<span class="line-added"> 30 #include &quot;jvmci/jvmci.hpp&quot;</span>
<span class="line-added"> 31 #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
 32 
 33 #if INCLUDE_AOT
 34 class RelocBuffer : public StackObj {
 35   enum { stack_size = 1024 };
 36 public:
 37   RelocBuffer() : _size(0), _buffer(0) {}
 38   ~RelocBuffer();
 39   void ensure_size(size_t bytes);
 40   void set_size(size_t bytes);
 41   address begin() const;
 42   size_t size() const { return _size; }
 43 private:
 44   size_t _size;
 45   char _static_buffer[stack_size];
 46   char *_buffer;
 47 };
 48 
<span class="line-added"> 49 class CodeInstaller;</span>
<span class="line-added"> 50 </span>
 51 class AOTOopRecorder : public OopRecorder {
 52 public:
<span class="line-modified"> 53   AOTOopRecorder(CodeInstaller* code_inst, Arena* arena = NULL, bool deduplicate = false);</span>
 54 
 55   virtual int find_index(Metadata* h);
 56   virtual int find_index(jobject h);
 57   int nr_meta_refs() const;
 58   jobject meta_element(int pos) const;
 59 
 60 private:
 61   void record_meta_ref(jobject ref, int index);
 62 
 63   GrowableArray&lt;jobject&gt;* _meta_refs;
<span class="line-added"> 64 </span>
<span class="line-added"> 65   CodeInstaller* _code_inst;</span>
 66 };
<span class="line-added"> 67 #endif // INCLUDE_AOT</span>
 68 
 69 class CodeMetadata {
 70 public:
 71   CodeMetadata() {}
 72 
 73   CodeBlob* get_code_blob() const { return _cb; }
 74 
 75   PcDesc* get_pc_desc() const { return _pc_desc; }
 76   int get_nr_pc_desc() const { return _nr_pc_desc; }
 77 
 78   u_char* get_scopes_desc() const { return _scopes_desc; }
 79   int get_scopes_size() const { return _nr_scopes_desc; }
 80 
<span class="line-added"> 81 #if INCLUDE_AOT</span>
 82   RelocBuffer* get_reloc_buffer() { return &amp;_reloc_buffer; }

 83   AOTOopRecorder* get_oop_recorder() { return _oop_recorder; }
<span class="line-added"> 84 #endif</span>
 85 
 86   ExceptionHandlerTable* get_exception_table() { return _exception_table; }
 87 
<span class="line-added"> 88   ImplicitExceptionTable* get_implicit_exception_table() { return _implicit_exception_table; }</span>
<span class="line-added"> 89 </span>
 90   void set_pc_desc(PcDesc* desc, int count) {
 91     _pc_desc = desc;
 92     _nr_pc_desc = count;
 93   }
 94 
 95   void set_scopes(u_char* scopes, int size) {
 96     _scopes_desc = scopes;
 97     _nr_scopes_desc = size;
 98   }
 99 
<span class="line-added">100 #if INCLUDE_AOT</span>
101   void set_oop_recorder(AOTOopRecorder* recorder) {
102     _oop_recorder = recorder;
103   }
<span class="line-added">104 #endif</span>
105 
106   void set_exception_table(ExceptionHandlerTable* table) {
107     _exception_table = table;
108   }
109 
<span class="line-added">110   void set_implicit_exception_table(ImplicitExceptionTable* table) {</span>
<span class="line-added">111     _implicit_exception_table = table;</span>
<span class="line-added">112   }</span>
<span class="line-added">113 </span>
114 private:
115   CodeBlob* _cb;
116   PcDesc* _pc_desc;
117   int _nr_pc_desc;
118 
119   u_char* _scopes_desc;
120   int _nr_scopes_desc;
121 
<span class="line-added">122 #if INCLUDE_AOT</span>
123   RelocBuffer _reloc_buffer;
124   AOTOopRecorder* _oop_recorder;
<span class="line-added">125 #endif</span>
126   ExceptionHandlerTable* _exception_table;
<span class="line-added">127   ImplicitExceptionTable* _implicit_exception_table;</span>
128 };

129 
130 /*
131  * This class handles the conversion from a InstalledCode to a CodeBlob or an nmethod.
132  */
133 class CodeInstaller : public StackObj {
134   friend class JVMCIVMStructs;
135 private:
136   enum MarkId {
137     VERIFIED_ENTRY                         = 1,
138     UNVERIFIED_ENTRY                       = 2,
139     OSR_ENTRY                              = 3,
140     EXCEPTION_HANDLER_ENTRY                = 4,
141     DEOPT_HANDLER_ENTRY                    = 5,
142     INVOKEINTERFACE                        = 6,
143     INVOKEVIRTUAL                          = 7,
144     INVOKESTATIC                           = 8,
145     INVOKESPECIAL                          = 9,
146     INLINE_INVOKE                          = 10,
147     POLL_NEAR                              = 11,
148     POLL_RETURN_NEAR                       = 12,
149     POLL_FAR                               = 13,
150     POLL_RETURN_FAR                        = 14,
151     CARD_TABLE_ADDRESS                     = 15,
152     CARD_TABLE_SHIFT                       = 16,
153     HEAP_TOP_ADDRESS                       = 17,
154     HEAP_END_ADDRESS                       = 18,
155     NARROW_KLASS_BASE_ADDRESS              = 19,
156     NARROW_OOP_BASE_ADDRESS                = 20,
157     CRC_TABLE_ADDRESS                      = 21,
158     LOG_OF_HEAP_REGION_GRAIN_BYTES         = 22,
159     INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED = 23,
160     INVOKE_INVALID                         = -1
161   };
162 
163   Arena         _arena;
<span class="line-added">164   JVMCIEnv*     _jvmci_env;</span>
<span class="line-added">165 </span>
<span class="line-added">166   JVMCIPrimitiveArray    _data_section_handle;</span>
<span class="line-added">167   JVMCIObjectArray       _data_section_patches_handle;</span>
<span class="line-added">168   JVMCIObjectArray       _sites_handle;</span>
<span class="line-added">169 #ifndef PRODUCT</span>
<span class="line-added">170   JVMCIObjectArray       _comments_handle;</span>
<span class="line-added">171 #endif</span>
<span class="line-added">172   JVMCIPrimitiveArray    _code_handle;</span>
<span class="line-added">173   JVMCIObject            _word_kind_handle;</span>
174 



175   CodeOffsets   _offsets;
176 

177   jint          _code_size;
178   jint          _total_frame_size;
179   jint          _orig_pc_offset;
180   jint          _parameter_count;
181   jint          _constants_size;



182 
183   bool          _has_wide_vector;

184 
185   MarkId        _next_call_type;
186   address       _invoke_mark_pc;
187 
188   CodeSection*  _instructions;
189   CodeSection*  _constants;
190 
191   OopRecorder*              _oop_recorder;
192   DebugInformationRecorder* _debug_recorder;
193   Dependencies*             _dependencies;
194   ExceptionHandlerTable     _exception_handler_table;
<span class="line-added">195   ImplicitExceptionTable    _implicit_exception_table;</span>
196 
197   bool _immutable_pic_compilation;  // Installer is called for Immutable PIC compilation.
198 
199   static ConstantOopWriteValue* _oop_null_scope_value;
200   static ConstantIntValue*    _int_m1_scope_value;
201   static ConstantIntValue*    _int_0_scope_value;
202   static ConstantIntValue*    _int_1_scope_value;
203   static ConstantIntValue*    _int_2_scope_value;
204   static LocationValue*       _illegal_value;
205 
<span class="line-modified">206   jint pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCIObject method, JVMCI_TRAPS);</span>
<span class="line-modified">207   void pd_patch_OopConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS);</span>
<span class="line-modified">208   void pd_patch_MetaspaceConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS);</span>
<span class="line-modified">209   void pd_patch_DataSectionReference(int pc_offset, int data_offset, JVMCI_TRAPS);</span>
<span class="line-modified">210   void pd_relocate_ForeignCall(NativeInstruction* inst, jlong foreign_call_destination, JVMCI_TRAPS);</span>
<span class="line-modified">211   void pd_relocate_JavaMethod(CodeBuffer &amp;cbuf, JVMCIObject method, jint pc_offset, JVMCI_TRAPS);</span>
<span class="line-modified">212   void pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS);</span>
<span class="line-modified">213 </span>
<span class="line-modified">214   JVMCIObjectArray sites()                { return _sites_handle; }</span>
<span class="line-modified">215   JVMCIPrimitiveArray code()              { return _code_handle; }</span>
<span class="line-modified">216   JVMCIPrimitiveArray  data_section()     { return _data_section_handle; }</span>
<span class="line-modified">217   JVMCIObjectArray data_section_patches() { return _data_section_patches_handle; }</span>
218 #ifndef PRODUCT
<span class="line-modified">219   JVMCIObjectArray comments()             { return _comments_handle; }</span>
220 #endif
<span class="line-modified">221   JVMCIObject word_kind()                 { return _word_kind_handle; }</span>

222 
223 public:
224 
<span class="line-modified">225   CodeInstaller(JVMCIEnv* jvmci_env, bool immutable_pic_compilation) : _arena(mtJVMCI), _jvmci_env(jvmci_env), _immutable_pic_compilation(immutable_pic_compilation) {}</span>
226 
227 #if INCLUDE_AOT
<span class="line-modified">228   JVMCI::CodeInstallResult gather_metadata(JVMCIObject target, JVMCIObject compiled_code, CodeMetadata&amp; metadata, JVMCI_TRAPS);</span>
229 #endif
<span class="line-modified">230   JVMCI::CodeInstallResult install(JVMCICompiler* compiler,</span>
<span class="line-added">231                                    JVMCIObject target,</span>
<span class="line-added">232                                    JVMCIObject compiled_code,</span>
<span class="line-added">233                                    CodeBlob*&amp; cb,</span>
<span class="line-added">234                                    JVMCIObject installed_code,</span>
<span class="line-added">235                                    FailedSpeculation** failed_speculations,</span>
<span class="line-added">236                                    char* speculations,</span>
<span class="line-added">237                                    int speculations_len,</span>
<span class="line-added">238                                    JVMCI_TRAPS);</span>
<span class="line-added">239 </span>
<span class="line-added">240   JVMCIEnv* jvmci_env() { return _jvmci_env; }</span>
<span class="line-added">241   JVMCIRuntime* runtime() { return _jvmci_env-&gt;runtime(); }</span>
242 
243   static address runtime_call_target_address(oop runtime_call);
<span class="line-modified">244   static VMReg get_hotspot_reg(jint jvmciRegisterNumber, JVMCI_TRAPS);</span>
245   static bool is_general_purpose_reg(VMReg hotspotRegister);
246 
247   const OopMapSet* oopMapSet() const { return _debug_recorder-&gt;_oopmaps; }
248 
249 protected:
<span class="line-modified">250   Location::Type get_oop_type(JVMCIObject value);</span>
<span class="line-modified">251   ScopeValue* get_scope_value(JVMCIObject value, BasicType type, GrowableArray&lt;ScopeValue*&gt;* objects, ScopeValue* &amp;second, JVMCI_TRAPS);</span>
<span class="line-modified">252   MonitorValue* get_monitor_value(JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS);</span>
253 
<span class="line-modified">254   void* record_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS);</span>
255 #ifdef _LP64
<span class="line-modified">256   narrowKlass record_narrow_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS);</span>
257 #endif
258 
259   // extract the fields of the HotSpotCompiledCode
<span class="line-modified">260   void initialize_fields(JVMCIObject target, JVMCIObject compiled_code, JVMCI_TRAPS);</span>
<span class="line-modified">261   void initialize_dependencies(JVMCIObject compiled_code, OopRecorder* oop_recorder, JVMCI_TRAPS);</span>
262 
<span class="line-modified">263   int estimate_stubs_size(JVMCI_TRAPS);</span>
264 
265   // perform data and call relocation on the CodeBuffer
<span class="line-modified">266   JVMCI::CodeInstallResult initialize_buffer(CodeBuffer&amp; buffer, bool check_size, JVMCI_TRAPS);</span>
<span class="line-added">267 </span>
<span class="line-added">268   void assumption_NoFinalizableSubclass(JVMCIObject assumption);</span>
<span class="line-added">269   void assumption_ConcreteSubtype(JVMCIObject assumption);</span>
<span class="line-added">270   void assumption_LeafType(JVMCIObject assumption);</span>
<span class="line-added">271   void assumption_ConcreteMethod(JVMCIObject assumption);</span>
<span class="line-added">272   void assumption_CallSiteTargetValue(JVMCIObject assumption, JVMCI_TRAPS);</span>
273 
<span class="line-modified">274   void site_Safepoint(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS);</span>
<span class="line-modified">275   void site_Infopoint(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS);</span>
<span class="line-modified">276   void site_Call(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS);</span>
<span class="line-modified">277   void site_DataPatch(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS);</span>
<span class="line-modified">278   void site_Mark(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS);</span>
<span class="line-added">279   void site_ExceptionHandler(jint pc_offset, JVMCIObject site);</span>
280 
<span class="line-modified">281   OopMap* create_oop_map(JVMCIObject debug_info, JVMCI_TRAPS);</span>





282 
<span class="line-modified">283   VMReg getVMRegFromLocation(JVMCIObject location, int total_frame_size, JVMCI_TRAPS);</span>
284 
285   /**
286    * Specifies the level of detail to record for a scope.
287    */
288   enum ScopeMode {
289     // Only record a method and BCI
290     BytecodePosition,
291     // Record a method, bci and JVM frame state
292     FullFrame
293   };
294 
295   int map_jvmci_bci(int bci);
<span class="line-modified">296 </span>
<span class="line-modified">297   void record_scope(jint pc_offset, JVMCIObject debug_info, ScopeMode scope_mode, bool return_oop, JVMCI_TRAPS);</span>
<span class="line-modified">298   void record_scope(jint pc_offset, JVMCIObject debug_info, ScopeMode scope_mode, JVMCI_TRAPS) {</span>
<span class="line-added">299     record_scope(pc_offset, debug_info, scope_mode, false /* return_oop */, JVMCIENV);</span>
300   }
<span class="line-modified">301   void record_scope(jint pc_offset, JVMCIObject position, ScopeMode scope_mode, GrowableArray&lt;ScopeValue*&gt;* objects, bool return_oop, JVMCI_TRAPS);</span>
<span class="line-modified">302   void record_object_value(ObjectValue* sv, JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS);</span>
303 
<span class="line-modified">304   GrowableArray&lt;ScopeValue*&gt;* record_virtual_objects(JVMCIObject debug_info, JVMCI_TRAPS);</span>
305 
306   int estimateStubSpace(int static_call_stubs);
307 };
308 







309 #endif // SHARE_JVMCI_JVMCICODEINSTALLER_HPP
</pre>
</td>
</tr>
</table>
<center><a href="jvmciCodeInstaller.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCompiler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
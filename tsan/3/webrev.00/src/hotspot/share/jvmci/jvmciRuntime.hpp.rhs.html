<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_JVMCI_JVMCIRUNTIME_HPP
 25 #define SHARE_JVMCI_JVMCIRUNTIME_HPP
 26 
<a name="1" id="anc1"></a><span class="line-modified"> 27 #include &quot;code/nmethod.hpp&quot;</span>
<span class="line-modified"> 28 #include &quot;jvmci/jvmci.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;jvmci/jvmciExceptions.hpp&quot;</span>
<span class="line-modified"> 30 #include &quot;jvmci/jvmciObject.hpp&quot;</span>
<span class="line-added"> 31 </span>
<span class="line-added"> 32 class JVMCIEnv;</span>
<span class="line-added"> 33 class JVMCICompiler;</span>
<span class="line-added"> 34 class JVMCICompileState;</span>
<span class="line-added"> 35 </span>
<span class="line-added"> 36 // Encapsulates the JVMCI metadata for an nmethod.</span>
<span class="line-added"> 37 // JVMCINMethodData objects are inlined into nmethods</span>
<span class="line-added"> 38 // at nmethod::_jvmci_data_offset.</span>
<span class="line-added"> 39 class JVMCINMethodData {</span>
<span class="line-added"> 40   // Index for the HotSpotNmethod mirror in the nmethod&#39;s oops table.</span>
<span class="line-added"> 41   // This is -1 if there is no mirror in the oops table.</span>
<span class="line-added"> 42   int _nmethod_mirror_index;</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44   // Is HotSpotNmethod.name non-null? If so, the value is</span>
<span class="line-added"> 45   // embedded in the end of this object.</span>
<span class="line-added"> 46   bool _has_name;</span>
<span class="line-added"> 47 </span>
<span class="line-added"> 48   // Address of the failed speculations list to which a speculation</span>
<span class="line-added"> 49   // is appended when it causes a deoptimization.</span>
<span class="line-added"> 50   FailedSpeculation** _failed_speculations;</span>
<span class="line-added"> 51 </span>
<span class="line-added"> 52 public:</span>
<span class="line-added"> 53   // Computes the size of a JVMCINMethodData object</span>
<span class="line-added"> 54   static int compute_size(const char* nmethod_mirror_name) {</span>
<span class="line-added"> 55     int size = sizeof(JVMCINMethodData);</span>
<span class="line-added"> 56     if (nmethod_mirror_name != NULL) {</span>
<span class="line-added"> 57       size += (int) strlen(nmethod_mirror_name) + 1;</span>
<span class="line-added"> 58     }</span>
<span class="line-added"> 59     return size;</span>
<span class="line-added"> 60   }</span>
<span class="line-added"> 61 </span>
<span class="line-added"> 62   void initialize(int nmethod_mirror_index,</span>
<span class="line-added"> 63              const char* name,</span>
<span class="line-added"> 64              FailedSpeculation** failed_speculations);</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66   // Adds `speculation` to the failed speculations list.</span>
<span class="line-added"> 67   void add_failed_speculation(nmethod* nm, jlong speculation);</span>
 68 
<a name="2" id="anc2"></a><span class="line-modified"> 69   // Gets the JVMCI name of the nmethod (which may be NULL).</span>
<span class="line-modified"> 70   const char* name() { return _has_name ? (char*)(((address) this) + sizeof(JVMCINMethodData)) : NULL; }</span>
 71 
<a name="3" id="anc3"></a><span class="line-modified"> 72   // Clears the HotSpotNmethod.address field in the  mirror. If nm</span>
<span class="line-modified"> 73   // is dead, the HotSpotNmethod.entryPoint field is also cleared.</span>
<span class="line-added"> 74   void invalidate_nmethod_mirror(nmethod* nm);</span>
 75 
<a name="4" id="anc4"></a><span class="line-modified"> 76   // Gets the mirror from nm&#39;s oops table.</span>
<span class="line-modified"> 77   oop get_nmethod_mirror(nmethod* nm, bool phantom_ref);</span>
<span class="line-modified"> 78 </span>
<span class="line-modified"> 79   // Sets the mirror in nm&#39;s oops table.</span>
<span class="line-added"> 80   void set_nmethod_mirror(nmethod* nm, oop mirror);</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82   // Clears the mirror in nm&#39;s oops table.</span>
<span class="line-added"> 83   void clear_nmethod_mirror(nmethod* nm);</span>
<span class="line-added"> 84 };</span>
 85 
<a name="5" id="anc5"></a><span class="line-modified"> 86 // A top level class that represents an initialized JVMCI runtime.</span>
<span class="line-added"> 87 // There is one instance of this class per HotSpotJVMCIRuntime object.</span>
<span class="line-added"> 88 class JVMCIRuntime: public CHeapObj&lt;mtJVMCI&gt; {</span>
 89  public:
 90   // Constants describing whether JVMCI wants to be able to adjust the compilation
 91   // level selected for a method by the VM compilation policy and if so, based on
 92   // what information about the method being schedule for compilation.
 93   enum CompLevelAdjustment {
 94      none = 0,             // no adjustment
 95      by_holder = 1,        // adjust based on declaring class of method
 96      by_full_signature = 2 // adjust based on declaring class, name and signature of method
 97   };
 98 
 99  private:
<a name="6" id="anc6"></a><span class="line-modified">100   volatile bool _being_initialized;</span>
<span class="line-modified">101   volatile bool _initialized;</span>
<span class="line-modified">102 </span>
<span class="line-modified">103   JVMCIObject _HotSpotJVMCIRuntime_instance;</span>
<span class="line-modified">104 </span>
<span class="line-modified">105   bool _shutdown_called;</span>
<span class="line-modified">106 </span>
<span class="line-modified">107   JVMCIObject create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS);</span>
<span class="line-modified">108 </span>
<span class="line-added">109   // Implementation methods for loading and constant pool access.</span>
<span class="line-added">110   static Klass* get_klass_by_name_impl(Klass*&amp; accessing_klass,</span>
<span class="line-added">111                                        const constantPoolHandle&amp; cpool,</span>
<span class="line-added">112                                        Symbol* klass_name,</span>
<span class="line-added">113                                        bool require_local);</span>
<span class="line-added">114   static Klass*   get_klass_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">115                                           int klass_index,</span>
<span class="line-added">116                                           bool&amp; is_accessible,</span>
<span class="line-added">117                                           Klass* loading_klass);</span>
<span class="line-added">118   static void   get_field_by_index_impl(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,</span>
<span class="line-added">119                                         int field_index);</span>
<span class="line-added">120   static Method*  get_method_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">121                                            int method_index, Bytecodes::Code bc,</span>
<span class="line-added">122                                            InstanceKlass* loading_klass);</span>
<span class="line-added">123 </span>
<span class="line-added">124   // Helper methods</span>
<span class="line-added">125   static bool       check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass);</span>
<span class="line-added">126   static Method*    lookup_method(InstanceKlass*  accessor,</span>
<span class="line-added">127                                   Klass*  holder,</span>
<span class="line-added">128                                   Symbol*         name,</span>
<span class="line-added">129                                   Symbol*         sig,</span>
<span class="line-added">130                                   Bytecodes::Code bc,</span>
<span class="line-added">131                                   constantTag     tag);</span>
132 
133  public:
<a name="7" id="anc7"></a><span class="line-modified">134   JVMCIRuntime() {</span>
<span class="line-modified">135     _initialized = false;</span>
<span class="line-added">136     _being_initialized = false;</span>
<span class="line-added">137     _shutdown_called = false;</span>
138   }
139 
140   /**
<a name="8" id="anc8"></a><span class="line-modified">141    * Compute offsets and construct any state required before executing JVMCI code.</span>
142    */
<a name="9" id="anc9"></a><span class="line-modified">143   void initialize(JVMCIEnv* jvmciEnv);</span>








144 
145   /**
<a name="10" id="anc10"></a><span class="line-modified">146    * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary</span>
147    */
<a name="11" id="anc11"></a><span class="line-modified">148   JVMCIObject get_HotSpotJVMCIRuntime(JVMCI_TRAPS);</span>
<span class="line-added">149 </span>
<span class="line-added">150   bool is_HotSpotJVMCIRuntime_initialized() {</span>
<span class="line-added">151     return _HotSpotJVMCIRuntime_instance.is_non_null();</span>
<span class="line-added">152   }</span>
153 
154   /**
155    * Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()
156    */
<a name="12" id="anc12"></a><span class="line-modified">157   void initialize_JVMCI(JVMCI_TRAPS);</span>
158 
159   /**
160    * Explicitly initialize HotSpotJVMCIRuntime itself
161    */
<a name="13" id="anc13"></a><span class="line-modified">162   void initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS);</span>
163 
<a name="14" id="anc14"></a><span class="line-modified">164   void call_getCompiler(TRAPS);</span>
165 
<a name="15" id="anc15"></a><span class="line-modified">166   void shutdown();</span>
167 
<a name="16" id="anc16"></a><span class="line-modified">168   bool shutdown_called() {</span>




169     return _shutdown_called;
170   }
171 
<a name="17" id="anc17"></a><span class="line-added">172   void bootstrap_finished(TRAPS);</span>
<span class="line-added">173 </span>
<span class="line-added">174   // Look up a klass by name from a particular class loader (the accessor&#39;s).</span>
<span class="line-added">175   // If require_local, result must be defined in that class loader, or NULL.</span>
<span class="line-added">176   // If !require_local, a result from remote class loader may be reported,</span>
<span class="line-added">177   // if sufficient class loader constraints exist such that initiating</span>
<span class="line-added">178   // a class loading request from the given loader is bound to return</span>
<span class="line-added">179   // the class defined in the remote loader (or throw an error).</span>
<span class="line-added">180   //</span>
<span class="line-added">181   // Return an unloaded klass if !require_local and no class at all is found.</span>
<span class="line-added">182   //</span>
<span class="line-added">183   // The CI treats a klass as loaded if it is consistently defined in</span>
<span class="line-added">184   // another loader, even if it hasn&#39;t yet been loaded in all loaders</span>
<span class="line-added">185   // that could potentially see it via delegation.</span>
<span class="line-added">186   static Klass* get_klass_by_name(Klass* accessing_klass,</span>
<span class="line-added">187                                   Symbol* klass_name,</span>
<span class="line-added">188                                   bool require_local);</span>
<span class="line-added">189 </span>
<span class="line-added">190   // Constant pool access.</span>
<span class="line-added">191   static Klass*   get_klass_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">192                                      int klass_index,</span>
<span class="line-added">193                                      bool&amp; is_accessible,</span>
<span class="line-added">194                                      Klass* loading_klass);</span>
<span class="line-added">195   static void   get_field_by_index(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,</span>
<span class="line-added">196                                    int field_index);</span>
<span class="line-added">197   static Method*  get_method_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">198                                       int method_index, Bytecodes::Code bc,</span>
<span class="line-added">199                                       InstanceKlass* loading_klass);</span>
<span class="line-added">200 </span>
<span class="line-added">201   // converts the Klass* representing the holder of a method into a</span>
<span class="line-added">202   // InstanceKlass*.  This is needed since the holder of a method in</span>
<span class="line-added">203   // the bytecodes could be an array type.  Basically this converts</span>
<span class="line-added">204   // array types into java/lang/Object and other types stay as they are.</span>
<span class="line-added">205   static InstanceKlass* get_instance_klass_for_declared_method_holder(Klass* klass);</span>
<span class="line-added">206 </span>
<span class="line-added">207   // Helper routine for determining the validity of a compilation</span>
<span class="line-added">208   // with respect to concurrent class loading.</span>
<span class="line-added">209   static JVMCI::CodeInstallResult validate_compile_task_dependencies(Dependencies* target, JVMCICompileState* task, char** failure_detail);</span>
<span class="line-added">210 </span>
<span class="line-added">211   // Compiles `target` with the JVMCI compiler.</span>
<span class="line-added">212   void compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; target, int entry_bci);</span>
<span class="line-added">213 </span>
<span class="line-added">214   // Register the result of a compilation.</span>
<span class="line-added">215   JVMCI::CodeInstallResult register_method(JVMCIEnv* JVMCIENV,</span>
<span class="line-added">216                        const methodHandle&amp;       target,</span>
<span class="line-added">217                        nmethod*&amp;                 nm,</span>
<span class="line-added">218                        int                       entry_bci,</span>
<span class="line-added">219                        CodeOffsets*              offsets,</span>
<span class="line-added">220                        int                       orig_pc_offset,</span>
<span class="line-added">221                        CodeBuffer*               code_buffer,</span>
<span class="line-added">222                        int                       frame_words,</span>
<span class="line-added">223                        OopMapSet*                oop_map_set,</span>
<span class="line-added">224                        ExceptionHandlerTable*    handler_table,</span>
<span class="line-added">225                        ImplicitExceptionTable* implicit_exception_table,</span>
<span class="line-added">226                        AbstractCompiler*         compiler,</span>
<span class="line-added">227                        DebugInformationRecorder* debug_info,</span>
<span class="line-added">228                        Dependencies*             dependencies,</span>
<span class="line-added">229                        int                       compile_id,</span>
<span class="line-added">230                        bool                      has_unsafe_access,</span>
<span class="line-added">231                        bool                      has_wide_vector,</span>
<span class="line-added">232                        JVMCIObject               compiled_code,</span>
<span class="line-added">233                        JVMCIObject               nmethod_mirror,</span>
<span class="line-added">234                        FailedSpeculation**       failed_speculations,</span>
<span class="line-added">235                        char*                     speculations,</span>
<span class="line-added">236                        int                       speculations_len);</span>
<span class="line-added">237 </span>
238   /**
<a name="18" id="anc18"></a><span class="line-modified">239    * Exits the VM due to an unexpected exception.</span>







240    */
<a name="19" id="anc19"></a><span class="line-modified">241   static void exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message);</span>
<span class="line-modified">242 </span>
<span class="line-modified">243   static void describe_pending_hotspot_exception(JavaThread* THREAD, bool clear);</span>
<span class="line-added">244 </span>
<span class="line-added">245 #define CHECK_EXIT THREAD); \</span>
<span class="line-added">246   if (HAS_PENDING_EXCEPTION) { \</span>
<span class="line-added">247     char buf[256]; \</span>
<span class="line-added">248     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="line-added">249     JVMCIRuntime::exit_on_pending_exception(NULL, buf); \</span>
<span class="line-added">250     return; \</span>
<span class="line-added">251   } \</span>
<span class="line-added">252   (void)(0</span>
<span class="line-added">253 </span>
<span class="line-added">254 #define CHECK_EXIT_(v) THREAD);                 \</span>
<span class="line-added">255   if (HAS_PENDING_EXCEPTION) { \</span>
<span class="line-added">256     char buf[256]; \</span>
<span class="line-added">257     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="line-added">258     JVMCIRuntime::exit_on_pending_exception(NULL, buf); \</span>
<span class="line-added">259     return v; \</span>
<span class="line-added">260   } \</span>
<span class="line-added">261   (void)(0</span>
<span class="line-added">262 </span>
<span class="line-added">263 #define JVMCI_CHECK_EXIT JVMCIENV); \</span>
<span class="line-added">264   if (JVMCIENV-&gt;has_pending_exception()) {      \</span>
<span class="line-added">265     char buf[256]; \</span>
<span class="line-added">266     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="line-added">267     JVMCIRuntime::exit_on_pending_exception(JVMCIENV, buf); \</span>
<span class="line-added">268     return; \</span>
<span class="line-added">269   } \</span>
<span class="line-added">270   (void)(0</span>
<span class="line-added">271 </span>
<span class="line-added">272 #define JVMCI_CHECK_EXIT_(result) JVMCIENV); \</span>
<span class="line-added">273   if (JVMCIENV-&gt;has_pending_exception()) {      \</span>
<span class="line-added">274     char buf[256]; \</span>
<span class="line-added">275     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \</span>
<span class="line-added">276     JVMCIRuntime::exit_on_pending_exception(JVMCIENV, buf); \</span>
<span class="line-added">277     return result; \</span>
<span class="line-added">278   } \</span>
<span class="line-added">279   (void)(0</span>
<span class="line-added">280 </span>
<span class="line-added">281   static BasicType kindToBasicType(const Handle&amp; kind, TRAPS);</span>
282 
283   static void new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail);
284   static void new_array_common(JavaThread* thread, Klass* klass, jint length, bool null_on_fail);
285   static void new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail);
286   static void dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail);
287   static void dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail);
288 
289   // The following routines are called from compiled JVMCI code
290 
291   // When allocation fails, these stubs:
292   // 1. Exercise -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError handling and also
293   //    post a JVMTI_EVENT_RESOURCE_EXHAUSTED event if the failure is an OutOfMemroyError
294   // 2. Return NULL with a pending exception.
295   // Compiled code must ensure these stubs are not called twice for the same allocation
296   // site due to the non-repeatable side effects in the case of OOME.
297   static void new_instance(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, false); }
298   static void new_array(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, false); }
299   static void new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, false); }
300   static void dynamic_new_array(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, false); }
301   static void dynamic_new_instance(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, false); }
302 
303   // When allocation fails, these stubs return NULL and have no pending exception. Compiled code
304   // can use these stubs if a failed allocation will be retried (e.g., by deoptimizing and
305   // re-executing in the interpreter).
306   static void new_instance_or_null(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, true); }
307   static void new_array_or_null(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, true); }
308   static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, true); }
309   static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, true); }
310   static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, true); }
311 
<a name="20" id="anc20"></a>
312   static void vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3);
313   static jint identity_hash_code(JavaThread* thread, oopDesc* obj);
314   static address exception_handler_for_pc(JavaThread* thread);
315   static void monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock);
316   static void monitorexit (JavaThread* thread, oopDesc* obj, BasicLock* lock);
317   static jboolean object_notify(JavaThread* thread, oopDesc* obj);
318   static jboolean object_notifyAll(JavaThread* thread, oopDesc* obj);
319   static void vm_error(JavaThread* thread, jlong where, jlong format, jlong value);
320   static oopDesc* load_and_clear_exception(JavaThread* thread);
321   static void log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3);
322   static void log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline);
323   // Print the passed in object, optionally followed by a newline.  If
324   // as_string is true and the object is a java.lang.String then it
325   // printed as a string, otherwise the type of the object is printed
326   // followed by its address.
327   static void log_object(JavaThread* thread, oopDesc* object, bool as_string, bool newline);
328 #if INCLUDE_G1GC
329   static void write_barrier_pre(JavaThread* thread, oopDesc* obj);
330   static void write_barrier_post(JavaThread* thread, void* card);
331 #endif
332   static jboolean validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child);
333 
334   // used to throw exceptions from compiled JVMCI code
<a name="21" id="anc21"></a><span class="line-modified">335   static int throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);</span>
336   // helper methods to throw exception with complex messages
<a name="22" id="anc22"></a><span class="line-modified">337   static int throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);</span>
<span class="line-modified">338   static int throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);</span>



339 
340   // Test only function
<a name="23" id="anc23"></a><span class="line-modified">341   static jint test_deoptimize_call_int(JavaThread* thread, int value);</span>
342 };
343 
344 // Tracing macros.
345 
346 #define IF_TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1)) ; else
347 #define IF_TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2)) ; else
348 #define IF_TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3)) ; else
349 #define IF_TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4)) ; else
350 #define IF_TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5)) ; else
351 
<a name="24" id="anc24"></a><span class="line-modified">352 #define TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot; JVMCITrace-1: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="line-modified">353 #define TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;    JVMCITrace-2: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="line-modified">354 #define TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;       JVMCITrace-3: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="line-modified">355 #define TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;          JVMCITrace-4: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="line-modified">356 #define TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;             JVMCITrace-5: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
357 
358 #endif // SHARE_JVMCI_JVMCIRUNTIME_HPP
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
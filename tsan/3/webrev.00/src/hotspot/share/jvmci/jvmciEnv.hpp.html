<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jvmci/jvmciEnv.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JVMCI_JVMCIENV_HPP
 26 #define SHARE_JVMCI_JVMCIENV_HPP
 27 
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 
 32 class CompileTask;
 33 class JVMCIObject;
 34 class JVMCIObjectArray;
 35 class JVMCIPrimitiveArray;
 36 class JVMCICompiler;
 37 class JVMCIRuntime;
 38 
 39 #define JVMCI_EXCEPTION_CONTEXT \
 40   JavaThread* thread=JavaThread::current(); \
 41   Thread* THREAD = thread;
 42 
 43 // Helper to log more context on a JNI exception
 44 #define JVMCI_EXCEPTION_CHECK(env, ...) \
 45   do { \
 46     if (env-&gt;ExceptionCheck()) { \
 47       if (env != JavaThread::current()-&gt;jni_environment() &amp;&amp; JVMCIEnv::get_shared_library_path() != NULL) { \
 48         tty-&gt;print_cr(&quot;In JVMCI shared library (%s):&quot;, JVMCIEnv::get_shared_library_path()); \
 49       } \
 50       tty-&gt;print_cr(__VA_ARGS__); \
 51       return; \
 52     } \
 53   } while(0)
 54 
 55 // Helper class to ensure that references to Klass* are kept alive for G1
 56 class JVMCIKlassHandle : public StackObj {
 57  private:
 58   Klass*     _klass;
 59   Handle     _holder;
 60   Thread*    _thread;
 61 
 62   Klass*        klass() const                     { return _klass; }
 63   Klass*        non_null_klass() const            { assert(_klass != NULL, &quot;resolving NULL _klass&quot;); return _klass; }
 64 
 65  public:
 66   /* Constructors */
 67   JVMCIKlassHandle (Thread* thread) : _klass(NULL), _thread(thread) {}
 68   JVMCIKlassHandle (Thread* thread, Klass* klass);
 69 
 70   JVMCIKlassHandle (const JVMCIKlassHandle &amp;h): _klass(h._klass), _holder(h._holder), _thread(h._thread) {}
 71   JVMCIKlassHandle&amp; operator=(const JVMCIKlassHandle &amp;s);
 72   JVMCIKlassHandle&amp; operator=(Klass* klass);
 73 
 74   /* Operators for ease of use */
 75   Klass*        operator () () const            { return klass(); }
 76   Klass*        operator -&gt; () const            { return non_null_klass(); }
 77 
 78   bool    operator == (Klass* o) const          { return klass() == o; }
 79   bool    operator == (const JVMCIKlassHandle&amp; h) const  { return klass() == h.klass(); }
 80 
 81   /* Null checks */
 82   bool    is_null() const                      { return _klass == NULL; }
 83   bool    not_null() const                     { return _klass != NULL; }
 84 };
 85 
 86 // A class that maintains the state needed for compilations requested
 87 // by the CompileBroker.  It is created in the broker and passed through
 88 // into the code installation step.
 89 class JVMCICompileState : public ResourceObj {
 90   friend class JVMCIVMStructs;
 91  private:
 92   CompileTask*     _task;
 93 
 94   // Cache JVMTI state. Defined as bytes so that reading them from Java
 95   // via Unsafe is well defined (the C++ type for bool is implementation
 96   // defined and may not be the same as a Java boolean).
 97   uint64_t _jvmti_redefinition_count;
 98   jbyte  _jvmti_can_hotswap_or_post_breakpoint;
 99   jbyte  _jvmti_can_access_local_variables;
100   jbyte  _jvmti_can_post_on_exceptions;
101   jbyte  _jvmti_can_pop_frame;
102 
103   // Compilation result values.
104   bool             _retryable;
105   const char*      _failure_reason;
106 
107   // Specifies if _failure_reason is on the C heap. If so, it is allocated
108   // with the mtJVMCI NMT flag.
109   bool             _failure_reason_on_C_heap;
110 
111  public:
112   JVMCICompileState(CompileTask* task);
113 
114   CompileTask* task() { return _task; }
115 
116   bool  jvmti_state_changed() const;
117   uint64_t jvmti_redefinition_count() const          { return  _jvmti_redefinition_count; }
118   bool  jvmti_can_hotswap_or_post_breakpoint() const { return  _jvmti_can_hotswap_or_post_breakpoint != 0; }
119   bool  jvmti_can_access_local_variables() const     { return  _jvmti_can_access_local_variables != 0; }
120   bool  jvmti_can_post_on_exceptions() const         { return  _jvmti_can_post_on_exceptions != 0; }
121   bool  jvmti_can_pop_frame() const                  { return  _jvmti_can_pop_frame != 0; }
122 
123   const char* failure_reason() { return _failure_reason; }
124   bool failure_reason_on_C_heap() { return _failure_reason_on_C_heap; }
125   bool retryable() { return _retryable; }
126 
127   void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false) {
128     _failure_reason = reason;
129     _failure_reason_on_C_heap = reason_on_C_heap;
130     _retryable = retryable;
131   }
132 };
133 
134 
135 // This class is a top level wrapper around interactions between HotSpot
136 // and the JVMCI Java code.  It supports both a HotSpot heap based
137 // runtime with HotSpot oop based accessors as well as a shared library
138 // based runtime that is accessed through JNI. It abstracts away all
139 // interactions with JVMCI objects so that a single version of the
140 // HotSpot C++ code can can work with either runtime.
141 class JVMCIEnv : public ResourceObj {
142   friend class JNIAccessMark;
143 
144   static char*   _shared_library_path;   // argument to os:dll_load
145   static void*   _shared_library_handle; // result of os::dll_load
146   static JavaVM* _shared_library_javavm; // result of calling JNI_CreateJavaVM in shared library
147 
148   // Initializes the shared library JavaVM if not already initialized.
149   // Returns the JNI interface pointer for the current thread
150   // if initialization was performed by this call, NULL if
151   // initialization was performed by a previous call.
152   static JNIEnv* init_shared_library(JavaThread* thread);
153 
154   // Initializes the _env, _mode and _runtime fields.
155   void init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env);
156 
157   void init(JavaThread* thread, bool is_hotspot, const char* file, int line);
158 
159   JNIEnv*                 _env;  // JNI env for calling into shared library
160   bool     _pop_frame_on_close;  // Must pop frame on close?
161   bool        _detach_on_close;  // Must detach on close?
162   JVMCIRuntime*       _runtime;  // Access to a HotSpotJVMCIRuntime
163   bool             _is_hotspot;  // Which heap is the HotSpotJVMCIRuntime in
164   bool        _throw_to_caller;  // Propagate an exception raised in this env to the caller?
165   const char*            _file;  // The file and ...
166   int                    _line;  // ... line where this JNIEnv was created
167 
168   // Translates an exception on the HotSpot heap to an exception on
169   // the shared library heap. The translation includes the stack and
170   // causes of `throwable`. The translated exception is pending in the
171   // shared library thread upon returning.
172   void translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable);
173 
174 public:
175   // Opens a JVMCIEnv scope for a Java to VM call (e.g., via CompilerToVM).
176   // An exception occurring within the scope is left pending when the
177   // scope closes so that it will be propagated back to Java.
178   // The JVMCIEnv destructor translates the exception object for the
179   // Java runtime if necessary.
180   JVMCIEnv(JavaThread* thread, JNIEnv* env, const char* file, int line);
181 
182   // Opens a JVMCIEnv scope for a compilation scheduled by the CompileBroker.
183   // An exception occurring within the scope must not be propagated back to
184   // the CompileBroker.
185   JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line);
186 
187   // Opens a JNIEnv scope for a call from within the VM. An exception occurring
188   // within the scope must not be propagated back to the caller.
189   JVMCIEnv(JavaThread* env, const char* file, int line);
190 
191   // Opens a JNIEnv scope for accessing `for_object`. An exception occurring
192   // within the scope must not be propagated back to the caller.
193   JVMCIEnv(JavaThread* thread, JVMCIObject for_object, const char* file, int line) {
194     // A JNI call to access an object in the shared library heap
195     // can block or take a long time so do not allow such access
196     // on the VM thread.
197     assert(for_object.is_hotspot() || !Thread::current()-&gt;is_VM_thread(),
198         &quot;cannot open JVMCIEnv scope when in the VM thread for accessing a shared library heap object&quot;);
199     init(thread, for_object.is_hotspot(), file, line);
200   }
201 
202   // Opens a JNIEnv scope for the HotSpot runtime if `is_hotspot` is true
203   // otherwise for the shared library runtime. An exception occurring
204   // within the scope must not be propagated back to the caller.
205   JVMCIEnv(JavaThread* thread, bool is_hotspot, const char* file, int line) {
206     init(thread, is_hotspot, file, line);
207   }
208 
209   ~JVMCIEnv();
210 
211   JVMCIRuntime* runtime() {
212     return _runtime;
213   }
214 
215   // Initializes Services.savedProperties in the shared library by copying
216   // the values from the same field in the HotSpot heap.
217   void copy_saved_properties();
218 
219   jboolean has_pending_exception();
220   void clear_pending_exception();
221 
222   // Prints an exception and stack trace of a pending exception.
223   void describe_pending_exception(bool clear);
224 
225   int get_length(JVMCIArray array);
226 
227   JVMCIObject get_object_at(JVMCIObjectArray array, int index);
228   void put_object_at(JVMCIObjectArray array, int index, JVMCIObject value);
229 
230   jboolean get_bool_at(JVMCIPrimitiveArray array, int index);
231   void put_bool_at(JVMCIPrimitiveArray array, int index, jboolean value);
232 
233   jbyte get_byte_at(JVMCIPrimitiveArray array, int index);
234   void put_byte_at(JVMCIPrimitiveArray array, int index, jbyte value);
235 
236   jint get_int_at(JVMCIPrimitiveArray array, int index);
237   void put_int_at(JVMCIPrimitiveArray array, int index, jint value);
238 
239   long get_long_at(JVMCIPrimitiveArray array, int index);
240   void put_long_at(JVMCIPrimitiveArray array, int index, jlong value);
241 
242   void copy_bytes_to(JVMCIPrimitiveArray src, jbyte* dest, int offset, jsize length);
243   void copy_bytes_from(jbyte* src, JVMCIPrimitiveArray dest, int offset, jsize length);
244 
245   void copy_longs_from(jlong* src, JVMCIPrimitiveArray dest, int offset, jsize length);
246 
247   JVMCIObjectArray initialize_intrinsics(JVMCI_TRAPS);
248 
249   jboolean is_boxing_object(BasicType type, JVMCIObject object);
250 
251   // Get the primitive value from a Java boxing object.  It&#39;s hard error to
252   // pass a non-primitive BasicType.
253   jvalue get_boxed_value(BasicType type, JVMCIObject object);
254 
255   // Return the BasicType of the object if it&#39;s a boxing object, otherwise return T_ILLEGAL.
256   BasicType get_box_type(JVMCIObject object);
257 
258   // Create a boxing object of the appropriate primitive type.
259   JVMCIObject create_box(BasicType type, jvalue* value, JVMCI_TRAPS);
260 
261   const char* as_utf8_string(JVMCIObject str);
262   char* as_utf8_string(JVMCIObject str, char* buf, int buflen);
263 
264   JVMCIObject create_string(Symbol* str, JVMCI_TRAPS) {
265     return create_string(str-&gt;as_C_string(), JVMCI_CHECK_(JVMCIObject()));
266   }
267 
268   JVMCIObject create_string(const char* str, JVMCI_TRAPS);
269 
270   bool equals(JVMCIObject a, JVMCIObject b);
271 
272   // Convert into a JNI handle for the appropriate runtime
273   jobject get_jobject(JVMCIObject object)                       { assert(object.as_jobject() == NULL || is_hotspot() == object.is_hotspot(), &quot;mismatch&quot;); return object.as_jobject(); }
274   jarray get_jarray(JVMCIArray array)                           { assert(array.as_jobject() == NULL || is_hotspot() == array.is_hotspot(), &quot;mismatch&quot;); return array.as_jobject(); }
275   jobjectArray get_jobjectArray(JVMCIObjectArray objectArray)   { assert(objectArray.as_jobject() == NULL || is_hotspot() == objectArray.is_hotspot(), &quot;mismatch&quot;); return objectArray.as_jobject(); }
276   jbyteArray get_jbyteArray(JVMCIPrimitiveArray primitiveArray) { assert(primitiveArray.as_jobject() == NULL || is_hotspot() == primitiveArray.is_hotspot(), &quot;mismatch&quot;); return primitiveArray.as_jbyteArray(); }
277 
278   JVMCIObject         wrap(jobject obj);
279   JVMCIObjectArray    wrap(jobjectArray obj)  { return (JVMCIObjectArray)    wrap((jobject) obj); }
280   JVMCIPrimitiveArray wrap(jintArray obj)     { return (JVMCIPrimitiveArray) wrap((jobject) obj); }
281   JVMCIPrimitiveArray wrap(jbooleanArray obj) { return (JVMCIPrimitiveArray) wrap((jobject) obj); }
282   JVMCIPrimitiveArray wrap(jbyteArray obj)    { return (JVMCIPrimitiveArray) wrap((jobject) obj); }
283   JVMCIPrimitiveArray wrap(jlongArray obj)    { return (JVMCIPrimitiveArray) wrap((jobject) obj); }
284 
285  private:
286   JVMCIObject wrap(oop obj)                  { assert(is_hotspot(), &quot;must be&quot;); return wrap(JNIHandles::make_local(obj)); }
287   JVMCIObjectArray wrap(objArrayOop obj)     { assert(is_hotspot(), &quot;must be&quot;); return (JVMCIObjectArray) wrap(JNIHandles::make_local(obj)); }
288   JVMCIPrimitiveArray wrap(typeArrayOop obj) { assert(is_hotspot(), &quot;must be&quot;); return (JVMCIPrimitiveArray) wrap(JNIHandles::make_local(obj)); }
289 
290  public:
291   // Compiles a method with the JVMIC compiler.
292   // Caller must handle pending exception.
293   JVMCIObject call_HotSpotJVMCIRuntime_compileMethod(JVMCIObject runtime, JVMCIObject method, int entry_bci,
294                                                      jlong compile_state, int id);
295 
296   void call_HotSpotJVMCIRuntime_bootstrapFinished(JVMCIObject runtime, JVMCI_TRAPS);
297   void call_HotSpotJVMCIRuntime_shutdown(JVMCIObject runtime);
298   JVMCIObject call_HotSpotJVMCIRuntime_runtime(JVMCI_TRAPS);
299   JVMCIObject call_JVMCI_getRuntime(JVMCI_TRAPS);
300   JVMCIObject call_HotSpotJVMCIRuntime_getCompiler(JVMCIObject runtime, JVMCI_TRAPS);
301 
302   JVMCIObject call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCI_TRAPS);
303 
304   JVMCIObject call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS);
305   JVMCIObject call_JavaConstant_forFloat(float value, JVMCI_TRAPS);
306   JVMCIObject call_JavaConstant_forDouble(double value, JVMCI_TRAPS);
307 
308   BasicType kindToBasicType(JVMCIObject kind, JVMCI_TRAPS);
309 
310 #define DO_THROW(name) \
311   void throw_##name(const char* msg = NULL);
312 
313   DO_THROW(InternalError)
314   DO_THROW(ArrayIndexOutOfBoundsException)
315   DO_THROW(IllegalStateException)
316   DO_THROW(NullPointerException)
317   DO_THROW(IllegalArgumentException)
318   DO_THROW(InvalidInstalledCodeException)
319   DO_THROW(UnsatisfiedLinkError)
320   DO_THROW(UnsupportedOperationException)
321   DO_THROW(ClassNotFoundException)
322 
323 #undef DO_THROW
324 
325   void fthrow_error(const char* file, int line, const char* format, ...) ATTRIBUTE_PRINTF(4, 5);
326 
327   // Given an instance of HotSpotInstalledCode return the corresponding CodeBlob*.  The
328   // nmethodLocker is required to keep the CodeBlob alive in the case where it&#39;s an nmethod.
329   CodeBlob* get_code_blob(JVMCIObject code, nmethodLocker&amp; locker);
330 
331   // Given an instance of HotSpotInstalledCode return the corresponding nmethod.  The
332   // nmethodLocker is required to keep the nmethod alive.
333   nmethod* get_nmethod(JVMCIObject code, nmethodLocker&amp; locker);
334 
335   MethodData* asMethodData(jlong metaspaceMethodData) {
336     return (MethodData*) (address) metaspaceMethodData;
337   }
338 
339   const char* klass_name(JVMCIObject object);
340 
341   // Unpack an instance of HotSpotResolvedJavaMethodImpl into the original Method*
342   Method* asMethod(JVMCIObject jvmci_method);
343   Method* asMethod(jobject jvmci_method) { return asMethod(wrap(jvmci_method)); }
344 
345   // Unpack an instance of HotSpotResolvedObjectTypeImpl into the original Klass*
346   Klass* asKlass(JVMCIObject jvmci_type);
347   Klass* asKlass(jobject jvmci_type)  { return asKlass(wrap(jvmci_type)); }
348 
349   JVMCIObject get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS);
350 
351   JVMCIObject get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS);
352 
353   // Unpack an instance of HotSpotConstantPool into the original ConstantPool*
354   ConstantPool* asConstantPool(JVMCIObject constant_pool);
355   ConstantPool* asConstantPool(jobject constant_pool)  { return asConstantPool(wrap(constant_pool)); }
356 
357   JVMCIObject get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS);
358   JVMCIObject get_jvmci_primitive_type(BasicType type);
359 
360   Handle asConstant(JVMCIObject object, JVMCI_TRAPS);
361   JVMCIObject get_object_constant(oop objOop, bool compressed = false, bool dont_register = false);
362 
363   JVMCIPrimitiveArray new_booleanArray(int length, JVMCI_TRAPS);
364   JVMCIPrimitiveArray new_byteArray(int length, JVMCI_TRAPS);
365   JVMCIPrimitiveArray new_intArray(int length, JVMCI_TRAPS);
366   JVMCIPrimitiveArray new_longArray(int length, JVMCI_TRAPS);
367 
368   JVMCIObjectArray new_byte_array_array(int length, JVMCI_TRAPS);
369 
370   JVMCIObject new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS);
371   JVMCIObject new_HotSpotNmethod(const methodHandle&amp; method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS);
372   JVMCIObject new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS);
373   JVMCIObject new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS);
374   JVMCIObject new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS);
375   JVMCIObject new_HotSpotStackFrameReference(JVMCI_TRAPS);
376   JVMCIObject new_JVMCIError(JVMCI_TRAPS);
377 
378   jlong make_handle(const Handle&amp; obj);
379   oop resolve_handle(jlong objectHandle);
380 
381   // These are analagous to the JNI routines
382   JVMCIObject make_local(JVMCIObject object);
383   JVMCIObject make_global(JVMCIObject object);
384   JVMCIObject make_weak(JVMCIObject object);
385   void destroy_local(JVMCIObject object);
386   void destroy_global(JVMCIObject object);
387   void destroy_weak(JVMCIObject object);
388 
389   // Deoptimizes the nmethod (if any) in the HotSpotNmethod.address
390   // field of mirror. The field is subsequently zeroed.
391   void invalidate_nmethod_mirror(JVMCIObject mirror, JVMCI_TRAPS);
392 
393   void initialize_installed_code(JVMCIObject installed_code, CodeBlob* cb, JVMCI_TRAPS);
394 
395  private:
396   JVMCICompileState* _compile_state;
397 
398  public:
399   static JavaVM* get_shared_library_javavm() { return _shared_library_javavm; }
400   static void* get_shared_library_handle()   { return _shared_library_handle; }
401   static char* get_shared_library_path()     { return _shared_library_path; }
402 
403   // Determines if this is for the JVMCI runtime in the HotSpot
404   // heap (true) or the shared library heap (false).
405   bool is_hotspot() { return _is_hotspot; }
406 
407   JVMCICompileState* compile_state() { return _compile_state; }
408   void set_compile_state(JVMCICompileState* compile_state) {
409     assert(_compile_state == NULL, &quot;set only once&quot;);
410     _compile_state = compile_state;
411   }
412   // Generate declarations for the initialize, new, isa, get and set methods for all the types and
413   // fields declared in the JVMCI_CLASSES_DO macro.
414 
415 #define START_CLASS(className, fullClassName)                           \
416   void className##_initialize(JVMCI_TRAPS); \
417   JVMCIObjectArray new_##className##_array(int length, JVMCI_TRAPS); \
418   bool isa_##className(JVMCIObject object);
419 
420 #define END_CLASS
421 
422 #define FIELD(className, name, type, accessor)                                                                                                                         \
423   type get_ ## className ## _ ## name(JVMCIObject obj); \
424   void set_ ## className ## _ ## name(JVMCIObject obj, type x);
425 
426 #define OOPISH_FIELD(className, name, type, hstype, accessor) \
427   FIELD(className, name, type, accessor)
428 
429 #define STATIC_FIELD(className, name, type) \
430   type get_ ## className ## _ ## name(); \
431   void set_ ## className ## _ ## name(type x);
432 
433 #define STATIC_OOPISH_FIELD(className, name, type, hstype) \
434   STATIC_FIELD(className, name, type)
435 
436 #define EMPTY_CAST
437 #define CHAR_FIELD(className,  name) FIELD(className, name, jchar, char_field)
438 #define INT_FIELD(className,  name) FIELD(className, name, jint, int_field)
439 #define BOOLEAN_FIELD(className,  name) FIELD(className, name, jboolean, bool_field)
440 #define LONG_FIELD(className,  name) FIELD(className, name, jlong, long_field)
441 #define FLOAT_FIELD(className,  name) FIELD(className, name, jfloat, float_field)
442 #define OBJECT_FIELD(className,  name, signature) OOPISH_FIELD(className, name, JVMCIObject, oop, obj_field)
443 #define OBJECTARRAY_FIELD(className,  name, signature) OOPISH_FIELD(className, name, JVMCIObjectArray, objArrayOop, obj_field)
444 #define PRIMARRAY_FIELD(className,  name, signature) OOPISH_FIELD(className, name, JVMCIPrimitiveArray, typeArrayOop, obj_field)
445 
446 #define STATIC_INT_FIELD(className, name) STATIC_FIELD(className, name, jint)
447 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_FIELD(className, name, jboolean)
448 #define STATIC_OBJECT_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, JVMCIObject, oop)
449 #define STATIC_OBJECTARRAY_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, objArrayOop)
450 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
451 #define CONSTRUCTOR(className, signature)
452 
453   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
454 
455 #undef JNI_START_CLASS
456 #undef START_CLASS
457 #undef END_CLASS
458 #undef METHOD
459 #undef CONSTRUCTOR
460 #undef FIELD
461 #undef CHAR_FIELD
462 #undef INT_FIELD
463 #undef BOOLEAN_FIELD
464 #undef LONG_FIELD
465 #undef FLOAT_FIELD
466 #undef OBJECT_FIELD
467 #undef PRIMARRAY_FIELD
468 #undef OBJECTARRAY_FIELD
469 #undef FIELD
470 #undef OOPISH_FIELD
471 #undef STATIC_FIELD
472 #undef STATIC_OOPISH_FIELD
473 #undef STATIC_FIELD
474 #undef STATIC_OBJECT_FIELD
475 #undef STATIC_OBJECTARRAY_FIELD
476 #undef STATIC_INT_FIELD
477 #undef STATIC_BOOLEAN_FIELD
478 #undef EMPTY_CAST
479 
480   // End of JVMCIEnv
481 };
482 
483 #endif // SHARE_JVMCI_JVMCIENV_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jvmci/jvmciJavaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciEnv.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciJavaClasses.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciJavaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,149 ***</span>
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-removed">- #include &quot;oops/oop.inline.hpp&quot;</span>
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  
  
<span class="line-modified">! // This macro expands for non-inline functions, in class declarations.</span>
  
<span class="line-modified">! #define START_CLASS(name)                                                                                                                                \</span>
<span class="line-modified">!     void name::check(oop obj, const char* field_name, int offset) {                                                                                          \</span>
<span class="line-modified">!       assert(obj != NULL, &quot;NULL field access of %s.%s&quot;, #name, field_name);                                                                                  \</span>
<span class="line-modified">!       assert(obj-&gt;is_a(SystemDictionary::name##_klass()), &quot;wrong class, &quot; #name &quot; expected, found %s&quot;, obj-&gt;klass()-&gt;external_name());                       \</span>
<span class="line-modified">!       assert(offset != 0, &quot;must be valid offset&quot;);                                                                                                           \</span>
<span class="line-modified">!     }</span>
  
  #define END_CLASS
  
<span class="line-modified">! #define FIELD(klass, name, type, accessor, cast)                                                                                                                                \</span>
<span class="line-modified">!     type klass::name(jobject obj)               { check(JNIHandles::resolve(obj), #name, _##name##_offset); return cast JNIHandles::resolve(obj)-&gt;accessor(_##name##_offset); }     \</span>
<span class="line-modified">!     void klass::set_##name(jobject obj, type x) { check(JNIHandles::resolve(obj), #name, _##name##_offset); JNIHandles::resolve(obj)-&gt;accessor##_put(_##name##_offset, x); }</span>
  
  #define EMPTY_CAST
<span class="line-modified">! #define CHAR_FIELD(klass, name) FIELD(klass, name, jchar, char_field, EMPTY_CAST)</span>
<span class="line-modified">! #define INT_FIELD(klass, name) FIELD(klass, name, jint, int_field, EMPTY_CAST)</span>
<span class="line-modified">! #define BOOLEAN_FIELD(klass, name) FIELD(klass, name, jboolean, bool_field, EMPTY_CAST)</span>
<span class="line-modified">! #define LONG_FIELD(klass, name) FIELD(klass, name, jlong, long_field, EMPTY_CAST)</span>
<span class="line-modified">! #define FLOAT_FIELD(klass, name) FIELD(klass, name, jfloat, float_field, EMPTY_CAST)</span>
<span class="line-modified">! #define OOP_FIELD(klass, name, signature) FIELD(klass, name, oop, obj_field, EMPTY_CAST)</span>
<span class="line-modified">! #define OBJARRAYOOP_FIELD(klass, name, signature) FIELD(klass, name, objArrayOop, obj_field, (objArrayOop))</span>
<span class="line-modified">! #define TYPEARRAYOOP_FIELD(klass, name, signature) FIELD(klass, name, typeArrayOop, obj_field, (typeArrayOop))</span>
<span class="line-modified">! #define STATIC_OOP_FIELD(klassName, name, signature) STATIC_OOPISH_FIELD(klassName, name, oop, signature)</span>
<span class="line-modified">! #define STATIC_OBJARRAYOOP_FIELD(klassName, name, signature) STATIC_OOPISH_FIELD(klassName, name, objArrayOop, signature)</span>
<span class="line-modified">! #define STATIC_OOPISH_FIELD(klassName, name, type, signature)                                                  \</span>
<span class="line-modified">!     type klassName::name() {                                                                                   \</span>
<span class="line-modified">!       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \</span>
<span class="line-modified">!       InstanceKlass* ik = klassName::klass();                                                                  \</span>
<span class="line-modified">!       oop base = ik-&gt;static_field_base_raw();                                                                  \</span>
<span class="line-modified">!       oop result = HeapAccess&lt;&gt;::oop_load_at(base, _##name##_offset);                                          \</span>
<span class="line-modified">!       return type(result);                                                                                     \</span>
<span class="line-modified">!     }                                                                                                          \</span>
<span class="line-modified">!     void klassName::set_##name(type x) {                                                                       \</span>
<span class="line-modified">!       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \</span>
<span class="line-modified">!       assert(klassName::klass() != NULL, &quot;Class not yet loaded: &quot; #klassName);                                 \</span>
<span class="line-modified">!       InstanceKlass* ik = klassName::klass();                                                                  \</span>
<span class="line-modified">!       oop base = ik-&gt;static_field_base_raw();                                                                  \</span>
<span class="line-modified">!       HeapAccess&lt;&gt;::oop_store_at(base, _##name##_offset, x);                                                   \</span>
      }
<span class="line-modified">! #define STATIC_PRIMITIVE_FIELD(klassName, name, jtypename)                                                     \</span>
<span class="line-modified">!     jtypename klassName::name() {                                                                              \</span>
<span class="line-modified">!       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \</span>
<span class="line-modified">!       InstanceKlass* ik = klassName::klass();                                                                  \</span>
<span class="line-modified">!       oop base = ik-&gt;static_field_base_raw();                                                                  \</span>
<span class="line-modified">!       return HeapAccess&lt;&gt;::load_at(base, _##name##_offset);                                                    \</span>
<span class="line-modified">!     }                                                                                                          \</span>
<span class="line-modified">!     void klassName::set_##name(jtypename x) {                                                                  \</span>
<span class="line-modified">!       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \</span>
<span class="line-modified">!       InstanceKlass* ik = klassName::klass();                                                                  \</span>
<span class="line-modified">!       oop base = ik-&gt;static_field_base_raw();                                                                  \</span>
<span class="line-modified">!       HeapAccess&lt;&gt;::store_at(base, _##name##_offset, x);                                                       \</span>
      }
  
<span class="line-modified">! #define STATIC_INT_FIELD(klassName, name) STATIC_PRIMITIVE_FIELD(klassName, name, jint)</span>
<span class="line-modified">! #define STATIC_BOOLEAN_FIELD(klassName, name) STATIC_PRIMITIVE_FIELD(klassName, name, jboolean)</span>
  
<span class="line-removed">- COMPILER_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OOP_FIELD, TYPEARRAYOOP_FIELD, OBJARRAYOOP_FIELD, STATIC_OOP_FIELD, STATIC_OBJARRAYOOP_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD)</span>
  #undef START_CLASS
  #undef END_CLASS
  #undef FIELD
  #undef CHAR_FIELD
  #undef INT_FIELD
  #undef BOOLEAN_FIELD
  #undef LONG_FIELD
  #undef FLOAT_FIELD
<span class="line-modified">! #undef OOP_FIELD</span>
<span class="line-modified">! #undef TYPEARRAYOOP_FIELD</span>
<span class="line-modified">! #undef OBJARRAYOOP_FIELD</span>
  #undef STATIC_OOPISH_FIELD
<span class="line-modified">! #undef STATIC_OOP_FIELD</span>
<span class="line-modified">! #undef STATIC_OBJARRAYOOP_FIELD</span>
  #undef STATIC_INT_FIELD
  #undef STATIC_BOOLEAN_FIELD
  #undef STATIC_PRIMITIVE_FIELD
  #undef EMPTY_CAST
  
<span class="line-modified">! // This function is similar to javaClasses.cpp, it computes the field offset of a (static or instance) field.</span>
<span class="line-modified">! // It looks up the name and signature symbols without creating new ones, all the symbols of these classes need to be already loaded.</span>
<span class="line-modified">! </span>
<span class="line-modified">! void compute_offset(int &amp;dest_offset, Klass* klass, const char* name, const char* signature, bool static_field, TRAPS) {</span>
<span class="line-modified">!   InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-modified">!   Symbol* name_symbol = SymbolTable::probe(name, (int)strlen(name));</span>
<span class="line-modified">!   Symbol* signature_symbol = SymbolTable::probe(signature, (int)strlen(signature));</span>
<span class="line-modified">!   if (name_symbol == NULL || signature_symbol == NULL) {</span>
<span class="line-modified">! #ifndef PRODUCT</span>
<span class="line-modified">!     ik-&gt;print_on(tty);</span>
<span class="line-modified">! #endif</span>
<span class="line-modified">!     fatal(&quot;symbol with name %s and signature %s was not found in symbol table (klass=%s)&quot;, name, signature, klass-&gt;name()-&gt;as_C_string());</span>
    }
  
<span class="line-modified">!   fieldDescriptor fd;</span>
<span class="line-modified">!   if (!ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd)) {</span>
      ResourceMark rm;
<span class="line-modified">!     fatal(&quot;Invalid layout of %s %s at %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string(), ik-&gt;external_name());</span>
    }
<span class="line-modified">!   guarantee(fd.is_static() == static_field, &quot;static/instance mismatch&quot;);</span>
<span class="line-modified">!   dest_offset = fd.offset();</span>
<span class="line-modified">!   assert(dest_offset != 0, &quot;must be valid offset&quot;);</span>
<span class="line-modified">!   if (static_field) {</span>
<span class="line-modified">!     // Must ensure classes for static fields are initialized as the</span>
<span class="line-modified">!     // accessor itself does not include a class initialization check.</span>
<span class="line-modified">!     ik-&gt;initialize(CHECK);</span>
    }
  }
  
<span class="line-modified">! // This piece of macro magic creates the contents of the jvmci_compute_offsets method that initializes the field indices of all the access classes.</span>
  
<span class="line-modified">! #define START_CLASS(name) { Klass* k = SystemDictionary::name##_klass(); assert(k != NULL, &quot;Could not find class &quot; #name &quot;&quot;);</span>
  
<span class="line-modified">! #define END_CLASS }</span>
  
<span class="line-modified">! #define FIELD(klass, name, signature, static_field) compute_offset(klass::_##name##_offset, k, #name, signature, static_field, CHECK);</span>
<span class="line-modified">! #define CHAR_FIELD(klass, name) FIELD(klass, name, &quot;C&quot;, false)</span>
<span class="line-modified">! #define INT_FIELD(klass, name) FIELD(klass, name, &quot;I&quot;, false)</span>
<span class="line-modified">! #define BOOLEAN_FIELD(klass, name) FIELD(klass, name, &quot;Z&quot;, false)</span>
<span class="line-modified">! #define LONG_FIELD(klass, name) FIELD(klass, name, &quot;J&quot;, false)</span>
<span class="line-modified">! #define FLOAT_FIELD(klass, name) FIELD(klass, name, &quot;F&quot;, false)</span>
<span class="line-modified">! #define OOP_FIELD(klass, name, signature) FIELD(klass, name, signature, false)</span>
<span class="line-modified">! #define STATIC_OOP_FIELD(klass, name, signature) FIELD(klass, name, signature, true)</span>
<span class="line-modified">! #define STATIC_INT_FIELD(klass, name) FIELD(klass, name, &quot;I&quot;, true)</span>
<span class="line-modified">! #define STATIC_BOOLEAN_FIELD(klass, name) FIELD(klass, name, &quot;Z&quot;, true)</span>
  
  
<span class="line-modified">! void JVMCIJavaClasses::compute_offsets(TRAPS) {</span>
<span class="line-modified">!   COMPILER_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OOP_FIELD, OOP_FIELD, OOP_FIELD, STATIC_OOP_FIELD, STATIC_OOP_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD)</span>
  }
  
  #define EMPTY0
  #define EMPTY1(x)
  #define EMPTY2(x,y)
<span class="line-modified">! #define FIELD2(klass, name) int klass::_##name##_offset = 0;</span>
<span class="line-modified">! #define FIELD3(klass, name, sig) FIELD2(klass, name)</span>
  
<span class="line-modified">! COMPILER_CLASSES_DO(EMPTY1, EMPTY0, FIELD2, FIELD2, FIELD2, FIELD2, FIELD2, FIELD3, FIELD3, FIELD3, FIELD3, FIELD3, FIELD2, FIELD2)</span>
  
<span class="line-new-header">--- 21,651 ---</span>
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
<span class="line-added">+ #include &quot;interpreter/linkResolver.hpp&quot;</span>
<span class="line-added">+ #include &quot;jvmci/jniAccessMark.inline.hpp&quot;</span>
  #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
<span class="line-added">+ #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  
<span class="line-added">+ // ------------------------------------------------------------------</span>
  
<span class="line-modified">! oop HotSpotJVMCI::resolve(JVMCIObject obj) {</span>
<span class="line-added">+   return JNIHandles::resolve(obj.as_jobject());</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! arrayOop HotSpotJVMCI::resolve(JVMCIArray obj) {</span>
<span class="line-modified">!   return (arrayOop) JNIHandles::resolve(obj.as_jobject());</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! objArrayOop HotSpotJVMCI::resolve(JVMCIObjectArray obj) {</span>
<span class="line-modified">!   return (objArrayOop) JNIHandles::resolve(obj.as_jobject());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ typeArrayOop HotSpotJVMCI::resolve(JVMCIPrimitiveArray obj) {</span>
<span class="line-added">+   return (typeArrayOop) JNIHandles::resolve(obj.as_jobject());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JVMCIObject HotSpotJVMCI::wrap(oop obj) {</span>
<span class="line-added">+   assert(Thread::current()-&gt;is_Java_thread(), &quot;must be&quot;);</span>
<span class="line-added">+   return JVMCIObject(JNIHandles::make_local(obj), true);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * Computes the field offset of a static or instance field.</span>
<span class="line-added">+  * It looks up the name and signature symbols without creating new ones;</span>
<span class="line-added">+  * all the symbols of these classes need to be already loaded.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void HotSpotJVMCI::compute_offset(int &amp;dest_offset, Klass* klass, const char* name, const char* signature, bool static_field, TRAPS) {</span>
<span class="line-added">+   InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-added">+   Symbol* name_symbol = SymbolTable::probe(name, (int)strlen(name));</span>
<span class="line-added">+   Symbol* signature_symbol = SymbolTable::probe(signature, (int)strlen(signature));</span>
<span class="line-added">+   if (name_symbol == NULL || signature_symbol == NULL) {</span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+     ik-&gt;print_on(tty);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     fatal(&quot;symbol with name %s and signature %s was not found in symbol table (klass=%s)&quot;, name, signature, klass-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   fieldDescriptor fd;</span>
<span class="line-added">+   if (!ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd)) {</span>
<span class="line-added">+     ResourceMark rm;</span>
<span class="line-added">+     fatal(&quot;Could not find field %s.%s with signature %s&quot;, ik-&gt;external_name(), name, signature);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   guarantee(fd.is_static() == static_field, &quot;static/instance mismatch&quot;);</span>
<span class="line-added">+   dest_offset = fd.offset();</span>
<span class="line-added">+   assert(dest_offset != 0, &quot;must be valid offset&quot;);</span>
<span class="line-added">+   if (static_field) {</span>
<span class="line-added">+     // Must ensure classes for static fields are initialized as the</span>
<span class="line-added">+     // accessor itself does not include a class initialization check.</span>
<span class="line-added">+     ik-&gt;initialize(CHECK);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+ static void check_resolve_method(const char* call_type, Klass* resolved_klass, Symbol* method_name, Symbol* method_signature, TRAPS) {</span>
<span class="line-added">+   Method* method;</span>
<span class="line-added">+   LinkInfo link_info(resolved_klass, method_name, method_signature, NULL, LinkInfo::skip_access_check);</span>
<span class="line-added">+   if (strcmp(call_type, &quot;call_static&quot;) == 0) {</span>
<span class="line-added">+     method = LinkResolver::resolve_static_call_or_null(link_info);</span>
<span class="line-added">+   } else if (strcmp(call_type, &quot;call_virtual&quot;) == 0) {</span>
<span class="line-added">+     method = LinkResolver::resolve_virtual_call_or_null(resolved_klass, link_info);</span>
<span class="line-added">+   } else if (strcmp(call_type, &quot;call_special&quot;) == 0) {</span>
<span class="line-added">+     method = LinkResolver::resolve_special_call_or_null(link_info);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     fatal(&quot;Unknown or unsupported call type: %s&quot;, call_type);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (method == NULL) {</span>
<span class="line-added">+     fatal(&quot;Could not resolve %s.%s%s&quot;, resolved_klass-&gt;external_name(), method_name-&gt;as_C_string(), method_signature-&gt;as_C_string());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ jclass JNIJVMCI::_box_classes[T_CONFLICT+1];</span>
<span class="line-added">+ jclass JNIJVMCI::_byte_array;</span>
<span class="line-added">+ jfieldID JNIJVMCI::_box_fields[T_CONFLICT+1];</span>
<span class="line-added">+ jmethodID JNIJVMCI::_box_constructors[T_CONFLICT+1];</span>
<span class="line-added">+ jmethodID JNIJVMCI::_Class_getName_method;</span>
<span class="line-added">+ </span>
<span class="line-added">+ jmethodID JNIJVMCI::_HotSpotResolvedJavaMethodImpl_fromMetaspace_method;</span>
<span class="line-added">+ jmethodID JNIJVMCI::_HotSpotConstantPool_fromMetaspace_method;</span>
<span class="line-added">+ jmethodID JNIJVMCI::_HotSpotResolvedObjectTypeImpl_fromMetaspace_method;</span>
<span class="line-added">+ jmethodID JNIJVMCI::_HotSpotResolvedPrimitiveType_fromMetaspace_method;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define START_CLASS(className, fullClassName)                          { \</span>
<span class="line-added">+   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::fullClassName(), true, CHECK); \</span>
<span class="line-added">+   className::_klass = InstanceKlass::cast(k); \</span>
<span class="line-added">+   className::_klass-&gt;initialize(CHECK);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define END_CLASS }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define FIELD(className, name, signature, static_field) compute_offset(className::_##name##_offset, className::_klass, #name, signature, static_field, CHECK);</span>
<span class="line-added">+ #define CHAR_FIELD(className, name) FIELD(className, name, &quot;C&quot;, false)</span>
<span class="line-added">+ #define INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, false)</span>
<span class="line-added">+ #define BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, false)</span>
<span class="line-added">+ #define LONG_FIELD(className, name) FIELD(className, name, &quot;J&quot;, false)</span>
<span class="line-added">+ #define FLOAT_FIELD(className, name) FIELD(className, name, &quot;F&quot;, false)</span>
<span class="line-added">+ #define OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, false)</span>
<span class="line-added">+ #define STATIC_OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, true)</span>
<span class="line-added">+ #define STATIC_INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, true)</span>
<span class="line-added">+ #define STATIC_BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, true)</span>
<span class="line-added">+ #ifdef PRODUCT</span>
<span class="line-added">+ #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)</span>
<span class="line-added">+ #define CONSTRUCTOR(className, signature)</span>
<span class="line-added">+ #else</span>
<span class="line-added">+ #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \</span>
<span class="line-added">+   check_resolve_method(#hsCallType, k, vmSymbols::methodName##_name(), vmSymbols::signatureSymbolName(), CHECK);</span>
<span class="line-added">+ #define CONSTRUCTOR(className, signature) { \</span>
<span class="line-added">+   TempNewSymbol sig = SymbolTable::new_symbol(signature); \</span>
<span class="line-added">+   check_resolve_method(&quot;call_special&quot;, k, vmSymbols::object_initializer_name(), sig, CHECK); \</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * Computes and initializes the offsets used by HotSpotJVMCI.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void HotSpotJVMCI::compute_offsets(TRAPS) {</span>
<span class="line-added">+   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, OBJECT_FIELD, OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef START_CLASS</span>
<span class="line-added">+ #undef END_CLASS</span>
<span class="line-added">+ #undef METHOD</span>
<span class="line-added">+ #undef CONSTRUCTOR</span>
<span class="line-added">+ #undef FIELD</span>
<span class="line-added">+ #undef CHAR_FIELD</span>
<span class="line-added">+ #undef INT_FIELD</span>
<span class="line-added">+ #undef BOOLEAN_FIELD</span>
<span class="line-added">+ #undef LONG_FIELD</span>
<span class="line-added">+ #undef FLOAT_FIELD</span>
<span class="line-added">+ #undef OBJECT_FIELD</span>
<span class="line-added">+ #undef PRIMARRAY_FIELD</span>
<span class="line-added">+ #undef OBJECTARRAY_FIELD</span>
<span class="line-added">+ #undef STATIC_FIELD</span>
<span class="line-added">+ #undef STATIC_OBJECT_FIELD</span>
<span class="line-added">+ #undef STATIC_OBJECTARRAY_FIELD</span>
<span class="line-added">+ #undef STATIC_INT_FIELD</span>
<span class="line-added">+ #undef STATIC_BOOLEAN_FIELD</span>
<span class="line-added">+ #undef EMPTY_CAST</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define START_CLASS(className, fullClassName)                                           \</span>
<span class="line-added">+   void HotSpotJVMCI::className::initialize(JVMCI_TRAPS) {                               \</span>
<span class="line-added">+     Thread* THREAD = Thread::current();                                                 \</span>
<span class="line-added">+     className::klass()-&gt;initialize(CHECK);                                              \</span>
<span class="line-added">+   }                                                                                     \</span>
<span class="line-added">+   bool HotSpotJVMCI::className::is_instance(JVMCIEnv* env, JVMCIObject object) {        \</span>
<span class="line-added">+     return resolve(object)-&gt;is_a(className::klass());                                   \</span>
<span class="line-added">+   }                                                                                     \</span>
<span class="line-added">+   void HotSpotJVMCI::className::check(oop obj, const char* field_name, int offset) {    \</span>
<span class="line-added">+     assert(obj != NULL, &quot;NULL field access of %s.%s&quot;, #className, field_name); \</span>
<span class="line-added">+     assert(obj-&gt;is_a(className::klass()), &quot;wrong class, &quot; #className &quot; expected, found %s&quot;, obj-&gt;klass()-&gt;external_name()); \</span>
<span class="line-added">+     assert(offset != 0, &quot;must be valid offset&quot;);                                        \</span>
<span class="line-added">+   }                                                                                     \</span>
<span class="line-added">+   InstanceKlass* HotSpotJVMCI::className::_klass = NULL;</span>
  
  #define END_CLASS
  
<span class="line-modified">! #define FIELD(className, name, type, accessor, cast)                     \</span>
<span class="line-modified">!   type HotSpotJVMCI::className::name(JVMCIEnv* env, oop obj)               { className::check(obj, #name, className::_##name##_offset); return cast obj-&gt;accessor(className::_##name##_offset); } \</span>
<span class="line-modified">!   void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, oop obj, type x) { className::check(obj, #name, className::_##name##_offset); obj-&gt;accessor##_put(className::_##name##_offset, x); }</span>
  
  #define EMPTY_CAST
<span class="line-modified">! #define CHAR_FIELD(className, name) FIELD(className, name, jchar, char_field, EMPTY_CAST)</span>
<span class="line-modified">! #define INT_FIELD(className, name) FIELD(className, name, jint, int_field, EMPTY_CAST)</span>
<span class="line-modified">! #define BOOLEAN_FIELD(className, name) FIELD(className, name, jboolean, bool_field, EMPTY_CAST)</span>
<span class="line-modified">! #define LONG_FIELD(className, name) FIELD(className, name, jlong, long_field, EMPTY_CAST)</span>
<span class="line-modified">! #define FLOAT_FIELD(className, name) FIELD(className, name, jfloat, float_field, EMPTY_CAST)</span>
<span class="line-modified">! </span>
<span class="line-modified">! #define OBJECT_FIELD(className, name, signature) FIELD(className, name, oop, obj_field, EMPTY_CAST)</span>
<span class="line-modified">! #define OBJECTARRAY_FIELD(className, name, signature) FIELD(className, name, objArrayOop, obj_field, (objArrayOop))</span>
<span class="line-modified">! #define PRIMARRAY_FIELD(className, name, signature) FIELD(className, name, typeArrayOop, obj_field, (typeArrayOop))</span>
<span class="line-modified">! #define STATIC_OBJECT_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, oop)</span>
<span class="line-modified">! #define STATIC_OBJECTARRAY_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, objArrayOop)</span>
<span class="line-modified">! #define STATIC_OOPISH_FIELD(className, name, type)                                                                        \</span>
<span class="line-modified">!     type HotSpotJVMCI::className::name(JVMCIEnv* env) {                                                                   \</span>
<span class="line-modified">!       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \</span>
<span class="line-modified">!       InstanceKlass* ik = className::klass();                                                                             \</span>
<span class="line-modified">!       oop base = ik-&gt;static_field_base_raw();                                                                             \</span>
<span class="line-modified">!       oop result = HeapAccess&lt;&gt;::oop_load_at(base, className::_##name##_offset);                                          \</span>
<span class="line-modified">!       return type(result);                                                                                                \</span>
<span class="line-modified">!     }                                                                                                                     \</span>
<span class="line-modified">!     void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, type x) {                                                     \</span>
<span class="line-modified">!       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \</span>
<span class="line-modified">!       assert(className::klass() != NULL, &quot;Class not yet loaded: &quot; #className);                                            \</span>
<span class="line-modified">!       InstanceKlass* ik = className::klass();                                                                             \</span>
<span class="line-modified">!       oop base = ik-&gt;static_field_base_raw();                                                                             \</span>
<span class="line-added">+       HeapAccess&lt;&gt;::oop_store_at(base, className::_##name##_offset, x);                                                   \</span>
      }
<span class="line-modified">! #define STATIC_PRIMITIVE_FIELD(className, name, jtypename)                                                                \</span>
<span class="line-modified">!     jtypename HotSpotJVMCI::className::get_##name(JVMCIEnv* env) {                                                        \</span>
<span class="line-modified">!       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \</span>
<span class="line-modified">!       InstanceKlass* ik = className::klass();                                                                             \</span>
<span class="line-modified">!       oop base = ik-&gt;static_field_base_raw();                                                                             \</span>
<span class="line-modified">!       return HeapAccess&lt;&gt;::load_at(base, className::_##name##_offset);                                                    \</span>
<span class="line-modified">!     }                                                                                                                     \</span>
<span class="line-modified">!     void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, jtypename x) {                                                \</span>
<span class="line-modified">!       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \</span>
<span class="line-modified">!       InstanceKlass* ik = className::klass();                                                                             \</span>
<span class="line-modified">!       oop base = ik-&gt;static_field_base_raw();                                                                             \</span>
<span class="line-modified">!       HeapAccess&lt;&gt;::store_at(base, _##name##_offset, x);                                                                  \</span>
      }
  
<span class="line-modified">! #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint)</span>
<span class="line-modified">! #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean)</span>
<span class="line-added">+ #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)</span>
<span class="line-added">+ #define CONSTRUCTOR(className, signature)</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * Generates the method and field definitions for the classes in HotSpotJVMCI. For example:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * void HotSpotJVMCI::Architecture::initialize(JVMCIEnv* env) { ... }</span>
<span class="line-added">+  * bool HotSpotJVMCI::Architecture::is_instance(JVMCIEnv* env, JVMCIObject object) { ... }</span>
<span class="line-added">+  * void HotSpotJVMCI::Architecture::check(oop obj, const char* field_name, int offset) { ... }</span>
<span class="line-added">+  *  oop HotSpotJVMCI::Architecture::wordKind(JVMCIEnv* env, oop obj) { ... }</span>
<span class="line-added">+  * void HotSpotJVMCI::Architecture::set_wordKind(JVMCIEnv* env, oop obj, oop x) { ... }</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * InstanceKlass *HotSpotJVMCI::Architecture::_klass = NULL;</span>
<span class="line-added">+  */</span>
<span class="line-added">+ JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
  
  #undef START_CLASS
  #undef END_CLASS
<span class="line-added">+ #undef METHOD</span>
<span class="line-added">+ #undef CONSTRUCTOR</span>
  #undef FIELD
  #undef CHAR_FIELD
  #undef INT_FIELD
  #undef BOOLEAN_FIELD
  #undef LONG_FIELD
  #undef FLOAT_FIELD
<span class="line-modified">! #undef OBJECT_FIELD</span>
<span class="line-modified">! #undef PRIMARRAY_FIELD</span>
<span class="line-modified">! #undef OBJECTARRAY_FIELD</span>
  #undef STATIC_OOPISH_FIELD
<span class="line-modified">! #undef STATIC_OBJECT_FIELD</span>
<span class="line-modified">! #undef STATIC_OBJECTARRAY_FIELD</span>
  #undef STATIC_INT_FIELD
  #undef STATIC_BOOLEAN_FIELD
  #undef STATIC_PRIMITIVE_FIELD
  #undef EMPTY_CAST
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * Initializes the JNI id of a field. As per the JNI specification,</span>
<span class="line-modified">!  * this ensures the declaring class is initialized.</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! void JNIJVMCI::initialize_field_id(JNIEnv* env, jfieldID &amp;fieldid, jclass clazz, const char* class_name, const char* name, const char* signature, bool static_field) {</span>
<span class="line-modified">!   if (JVMCILibDumpJNIConfig != NULL) {</span>
<span class="line-modified">!     fileStream* st = JVMCIGlobals::get_jni_config_file();</span>
<span class="line-modified">!     st-&gt;print_cr(&quot;field %s %s %s&quot;, class_name, name, signature);</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (env-&gt;ExceptionCheck()) {</span>
<span class="line-modified">!     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (static_field) {</span>
<span class="line-added">+     // Class initialization barrier</span>
<span class="line-added">+     fieldid = env-&gt;GetStaticFieldID(clazz, name, signature);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Class initialization barrier</span>
<span class="line-added">+     fieldid = env-&gt;GetFieldID(clazz, name, signature);</span>
    }
  
<span class="line-modified">!   if (env-&gt;ExceptionCheck()) {</span>
<span class="line-modified">!     env-&gt;ExceptionDescribe();</span>
<span class="line-added">+     env-&gt;ExceptionClear();</span>
      ResourceMark rm;
<span class="line-modified">!     Thread* THREAD = Thread::current();</span>
<span class="line-added">+     fatal(&quot;Could not find field %s.%s with signature %s&quot;, class_name, name, signature);</span>
    }
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! #define START_CLASS(className, fullClassName) {                                             \</span>
<span class="line-modified">!   current_class_name = vmSymbols::fullClassName()-&gt;as_C_string();                           \</span>
<span class="line-modified">!   if (JVMCILibDumpJNIConfig != NULL) {                                                      \</span>
<span class="line-modified">!     fileStream* st = JVMCIGlobals::get_jni_config_file();                                   \</span>
<span class="line-modified">!     st-&gt;print_cr(&quot;class %s&quot;, current_class_name);                                           \</span>
<span class="line-added">+   } else {                                                                                  \</span>
<span class="line-added">+     jclass k = env-&gt;FindClass(current_class_name);                                          \</span>
<span class="line-added">+     JVMCI_EXCEPTION_CHECK(env, &quot;FindClass(%s)&quot;, current_class_name);                        \</span>
<span class="line-added">+     assert(k != NULL, #fullClassName &quot; not initialized&quot;);                                   \</span>
<span class="line-added">+     className::_class = (jclass) env-&gt;NewGlobalRef(k);                                      \</span>
    }
<span class="line-added">+ </span>
<span class="line-added">+ #define END_CLASS current_class_name = NULL; }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define FIELD(className, name, signature, static_field) initialize_field_id(env, className::_##name##_field_id, className::_class, current_class_name, #name, signature, static_field);</span>
<span class="line-added">+ #define CHAR_FIELD(className, name) FIELD(className, name, &quot;C&quot;, false)</span>
<span class="line-added">+ #define INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, false)</span>
<span class="line-added">+ #define BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, false)</span>
<span class="line-added">+ #define LONG_FIELD(className, name) FIELD(className, name, &quot;J&quot;, false)</span>
<span class="line-added">+ #define FLOAT_FIELD(className, name) FIELD(className, name, &quot;F&quot;, false)</span>
<span class="line-added">+ #define OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, false)</span>
<span class="line-added">+ #define STATIC_OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, true)</span>
<span class="line-added">+ #define STATIC_INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, true)</span>
<span class="line-added">+ #define STATIC_BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, true)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define GET_JNI_METHOD(jniGetMethod, dst, clazz, methodName, signature)                        \</span>
<span class="line-added">+           if (JVMCILibDumpJNIConfig != NULL) {                                                       \</span>
<span class="line-added">+             fileStream* st = JVMCIGlobals::get_jni_config_file();                                    \</span>
<span class="line-added">+             st-&gt;print_cr(&quot;method %s %s %s&quot;, current_class_name, methodName, signature);              \</span>
<span class="line-added">+           } else {                                                                                   \</span>
<span class="line-added">+                   dst = env-&gt;jniGetMethod(clazz, methodName, signature);                                   \</span>
<span class="line-added">+                   JVMCI_EXCEPTION_CHECK(env, #jniGetMethod &quot;(%s.%s%s)&quot;, current_class_name, methodName, signature); \</span>
<span class="line-added">+                 assert(dst != NULL, &quot;uninitialized&quot;);                                          \</span>
<span class="line-added">+           }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define GET_JNI_CONSTRUCTOR(clazz, signature) \</span>
<span class="line-added">+   GET_JNI_METHOD(GetMethodID, JNIJVMCI::clazz::_constructor, clazz::_class, &quot;&lt;init&gt;&quot;, signature) \</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \</span>
<span class="line-added">+      GET_JNI_METHOD(jniGetMethod,                                        \</span>
<span class="line-added">+                     className::_##methodName##_method,                   \</span>
<span class="line-added">+                     className::clazz(),                                  \</span>
<span class="line-added">+                     vmSymbols::methodName##_name()-&gt;as_C_string(),       \</span>
<span class="line-added">+                     vmSymbols::signatureSymbolName()-&gt;as_C_string())</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define CONSTRUCTOR(className, signature) \</span>
<span class="line-added">+   GET_JNI_CONSTRUCTOR(className, signature)</span>
<span class="line-added">+ </span>
<span class="line-added">+ extern &quot;C&quot; {</span>
<span class="line-added">+   void     JNICALL JVM_RegisterJVMCINatives(JNIEnv *env, jclass compilerToVMClass);</span>
<span class="line-added">+   jobject  JNICALL JVM_GetJVMCIRuntime(JNIEnv *env, jclass c);</span>
  }
  
<span class="line-modified">! // Dumps symbols for public &lt;init&gt;() and &lt;init&gt;(String) methods of</span>
<span class="line-added">+ // non-abstract Throwable subtypes known by the VM. This is to</span>
<span class="line-added">+ // support the use of reflection in jdk.vm.ci.hotspot.TranslatedException.create().</span>
<span class="line-added">+ class ThrowableInitDumper : public SymbolClosure {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   fileStream* _st;</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   ThrowableInitDumper(fileStream* st)     { _st = st; }</span>
<span class="line-added">+   void do_symbol(Symbol** p) {</span>
<span class="line-added">+     Thread* THREAD = Thread::current();</span>
<span class="line-added">+     Symbol* name = *p;</span>
<span class="line-added">+     if (name == NULL) {</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     Klass* k = SystemDictionary::resolve_or_null(name, CHECK_EXIT);</span>
<span class="line-added">+     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {</span>
<span class="line-added">+       InstanceKlass* iklass = InstanceKlass::cast(k);</span>
<span class="line-added">+       if (iklass-&gt;is_subclass_of(SystemDictionary::Throwable_klass()) &amp;&amp; iklass-&gt;is_public() &amp;&amp; !iklass-&gt;is_abstract()) {</span>
<span class="line-added">+         const char* class_name = NULL;</span>
<span class="line-added">+         Array&lt;Method*&gt;* methods = iklass-&gt;methods();</span>
<span class="line-added">+         for (int i = 0; i &lt; methods-&gt;length(); i++) {</span>
<span class="line-added">+           Method* m = methods-&gt;at(i);</span>
<span class="line-added">+           if (m-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
<span class="line-added">+               m-&gt;is_public() &amp;&amp;</span>
<span class="line-added">+               (m-&gt;signature() == vmSymbols::void_method_signature() || m-&gt;signature() == vmSymbols::string_void_signature())) {</span>
<span class="line-added">+             if (class_name == NULL) {</span>
<span class="line-added">+               class_name = name-&gt;as_C_string();</span>
<span class="line-added">+               _st-&gt;print_cr(&quot;class %s&quot;, class_name);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             _st-&gt;print_cr(&quot;method %s %s %s&quot;, class_name, m-&gt;name()-&gt;as_C_string(), m-&gt;signature()-&gt;as_C_string());</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
  
<span class="line-modified">! #define IN_CLASS(fullClassName) current_class_name = vmSymbols::fullClassName()-&gt;as_C_string()</span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * Initializes the JNI method and field ids used in JNIJVMCI.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void JNIJVMCI::initialize_ids(JNIEnv* env) {</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   const char* current_class_name = NULL;</span>
<span class="line-added">+   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, OBJECT_FIELD, OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
  
<span class="line-modified">!   IN_CLASS(java_lang_Class);</span>
<span class="line-added">+   GET_JNI_METHOD(GetMethodID, _Class_getName_method, Class::_class, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);</span>
  
<span class="line-modified">!   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedPrimitiveType);</span>
<span class="line-modified">!   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedPrimitiveType_fromMetaspace_method, HotSpotResolvedPrimitiveType::_class,</span>
<span class="line-modified">!                                                                                           vmSymbols::fromMetaspace_name()-&gt;as_C_string(),</span>
<span class="line-modified">!                                                                                           vmSymbols::primitive_fromMetaspace_signature()-&gt;as_C_string());</span>
<span class="line-modified">!   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedObjectTypeImpl);</span>
<span class="line-modified">!   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedObjectTypeImpl_fromMetaspace_method, HotSpotResolvedObjectTypeImpl::_class,</span>
<span class="line-modified">!                                                                                            vmSymbols::fromMetaspace_name()-&gt;as_C_string(),</span>
<span class="line-modified">!                                                                                            vmSymbols::klass_fromMetaspace_signature()-&gt;as_C_string());</span>
<span class="line-modified">!   IN_CLASS(jdk_vm_ci_hotspot_HotSpotConstantPool);</span>
<span class="line-modified">!   GET_JNI_METHOD(GetStaticMethodID, _HotSpotConstantPool_fromMetaspace_method, HotSpotConstantPool::_class,</span>
<span class="line-added">+                                                                                   vmSymbols::fromMetaspace_name()-&gt;as_C_string(),</span>
<span class="line-added">+                                                                                   vmSymbols::constantPool_fromMetaspace_signature()-&gt;as_C_string());</span>
<span class="line-added">+   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedJavaMethodImpl);</span>
<span class="line-added">+   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedJavaMethodImpl_fromMetaspace_method, HotSpotResolvedJavaMethodImpl::_class,</span>
<span class="line-added">+                                                                                            vmSymbols::fromMetaspace_name()-&gt;as_C_string(),</span>
<span class="line-added">+                                                                                            vmSymbols::method_fromMetaspace_signature()-&gt;as_C_string());</span>
  
<span class="line-added">+ #define BOX_CLASSES(generate)     \</span>
<span class="line-added">+   generate(Boolean, T_BOOLEAN, Z) \</span>
<span class="line-added">+   generate(Byte, T_BYTE, B)       \</span>
<span class="line-added">+   generate(Character, T_CHAR, C)  \</span>
<span class="line-added">+   generate(Short, T_SHORT, S)     \</span>
<span class="line-added">+   generate(Integer, T_INT, I)     \</span>
<span class="line-added">+   generate(Long, T_LONG, J)       \</span>
<span class="line-added">+   generate(Float, T_FLOAT, F)     \</span>
<span class="line-added">+   generate(Double, T_DOUBLE, D)   \</span>
  
<span class="line-modified">! #define DO_BOX_CLASS(klass, basicType, type) \</span>
<span class="line-modified">!   current_class_name = &quot;java/lang/&quot; #klass;                                                                       \</span>
<span class="line-added">+   if (JVMCILibDumpJNIConfig == NULL) {                                                                            \</span>
<span class="line-added">+     _box_classes[basicType] = env-&gt;FindClass(&quot;java/lang/&quot; #klass);                                                \</span>
<span class="line-added">+     JVMCI_EXCEPTION_CHECK(env, &quot;FindClass(%s)&quot;, #klass);                                                          \</span>
<span class="line-added">+     _box_classes[basicType] = (jclass) env-&gt;NewGlobalRef(_box_classes[basicType]);                                \</span>
<span class="line-added">+     assert(_box_classes[basicType] != NULL, &quot;uninitialized&quot;);                                                     \</span>
<span class="line-added">+     _box_fields[basicType] = env-&gt;GetFieldID(_box_classes[basicType], &quot;value&quot;, #type);                            \</span>
<span class="line-added">+     JVMCI_EXCEPTION_CHECK(env, &quot;GetFieldID(%s, value, %s)&quot;, #klass, #type);                                       \</span>
<span class="line-added">+     GET_JNI_METHOD(GetMethodID, _box_constructors[basicType], _box_classes[basicType], &quot;&lt;init&gt;&quot;, &quot;(&quot; #type &quot;)V&quot;); \</span>
<span class="line-added">+   } else {                                                                                                        \</span>
<span class="line-added">+     fileStream* st = JVMCIGlobals::get_jni_config_file();                                                         \</span>
<span class="line-added">+     st-&gt;print_cr(&quot;field %s value %s&quot;, current_class_name, #type);                                                 \</span>
<span class="line-added">+     st-&gt;print_cr(&quot;method %s &lt;init&gt; (%s)V&quot;, current_class_name, #type);                                            \</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   BOX_CLASSES(DO_BOX_CLASS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (JVMCILibDumpJNIConfig == NULL) {</span>
<span class="line-added">+     _byte_array = env-&gt;FindClass(&quot;[B&quot;);</span>
<span class="line-added">+     JVMCI_EXCEPTION_CHECK(env, &quot;FindClass([B)&quot;);</span>
<span class="line-added">+     _byte_array = (jclass) env-&gt;NewGlobalRef(_byte_array);</span>
<span class="line-added">+     assert(_byte_array != NULL, &quot;uninitialized&quot;);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     fileStream* st = JVMCIGlobals::get_jni_config_file();</span>
<span class="line-added">+     st-&gt;print_cr(&quot;class [B&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define DUMP_ALL_NATIVE_METHODS(class_symbol) do {                                                                  \</span>
<span class="line-added">+   current_class_name = class_symbol-&gt;as_C_string();                                                                 \</span>
<span class="line-added">+   Klass* k = SystemDictionary::resolve_or_fail(class_symbol, true, CHECK_EXIT);                                     \</span>
<span class="line-added">+   InstanceKlass* iklass = InstanceKlass::cast(k);                                                                   \</span>
<span class="line-added">+   Array&lt;Method*&gt;* methods = iklass-&gt;methods();                                                                      \</span>
<span class="line-added">+   for (int i = 0; i &lt; methods-&gt;length(); i++) {                                                                     \</span>
<span class="line-added">+     Method* m = methods-&gt;at(i);                                                                                     \</span>
<span class="line-added">+     if (m-&gt;is_native()) {                                                                                           \</span>
<span class="line-added">+       st-&gt;print_cr(&quot;method %s %s %s&quot;, current_class_name, m-&gt;name()-&gt;as_C_string(), m-&gt;signature()-&gt;as_C_string()); \</span>
<span class="line-added">+     }                                                                                                               \</span>
<span class="line-added">+   }                                                                                                                 \</span>
<span class="line-added">+ } while(0)</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (JVMCILibDumpJNIConfig != NULL) {</span>
<span class="line-added">+     Thread* THREAD = Thread::current();</span>
<span class="line-added">+     fileStream* st = JVMCIGlobals::get_jni_config_file();</span>
<span class="line-added">+ </span>
<span class="line-added">+     DUMP_ALL_NATIVE_METHODS(vmSymbols::jdk_vm_ci_hotspot_CompilerToVM());</span>
<span class="line-added">+     ThrowableInitDumper dumper(st);</span>
<span class="line-added">+     vmSymbols::symbols_do(&amp;dumper);</span>
<span class="line-added">+ </span>
<span class="line-added">+     st-&gt;flush();</span>
<span class="line-added">+     tty-&gt;print_cr(&quot;Dumped JVMCI shared library JNI configuration to %s&quot;, JVMCILibDumpJNIConfig);</span>
<span class="line-added">+     vm_exit(0);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef DUMP_ALL_NATIVE_METHODS</span>
<span class="line-added">+ #undef DO_BOX_CLASS</span>
<span class="line-added">+ #undef BOX_CLASSES</span>
<span class="line-added">+ #undef IN_CLASS</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define CC (char*)  /*cast a literal from (const char*)*/</span>
<span class="line-added">+ #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(f))</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (env != JavaThread::current()-&gt;jni_environment()) {</span>
<span class="line-added">+     jclass clazz = env-&gt;FindClass(&quot;jdk/vm/ci/hotspot/CompilerToVM&quot;);</span>
<span class="line-added">+     if (env-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       env-&gt;ExceptionDescribe();</span>
<span class="line-added">+       guarantee(false, &quot;Could not find class jdk/vm/ci/hotspot/CompilerToVM&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     JNINativeMethod CompilerToVM_native_methods[] = {</span>
<span class="line-added">+       { CC&quot;registerNatives&quot;,     CC&quot;()V&quot;, FN_PTR(JVM_RegisterJVMCINatives)     },</span>
<span class="line-added">+     };</span>
<span class="line-added">+     env-&gt;RegisterNatives(clazz, CompilerToVM_native_methods, 1);</span>
<span class="line-added">+     if (env-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       env-&gt;ExceptionDescribe();</span>
<span class="line-added">+       guarantee(false, &quot;&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     JNINativeMethod JVMCI_native_methods[] = {</span>
<span class="line-added">+       { CC&quot;initializeRuntime&quot;,   CC&quot;()Ljdk/vm/ci/runtime/JVMCIRuntime;&quot;, FN_PTR(JVM_GetJVMCIRuntime) },</span>
<span class="line-added">+     };</span>
<span class="line-added">+     env-&gt;RegisterNatives(JVMCI::clazz(), JVMCI_native_methods, 1);</span>
<span class="line-added">+     if (env-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       env-&gt;ExceptionDescribe();</span>
<span class="line-added">+       guarantee(false, &quot;&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-added">+ #undef METHOD</span>
<span class="line-added">+ #undef CONSTRUCTOR</span>
<span class="line-added">+ #undef FIELD2</span>
<span class="line-added">+ </span>
  #define EMPTY0
  #define EMPTY1(x)
  #define EMPTY2(x,y)
<span class="line-modified">! #define FIELD3(className, name, sig) FIELD2(className, name)</span>
<span class="line-modified">! #define FIELD2(className, name) \</span>
<span class="line-added">+   jfieldID JNIJVMCI::className::_##name##_field_id = 0; \</span>
<span class="line-added">+   int HotSpotJVMCI::className::_##name##_offset = 0;</span>
<span class="line-added">+ #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)</span>
<span class="line-added">+ #define CONSTRUCTOR(className, signature)</span>
  
<span class="line-modified">! // Generates the definitions of static fields used by the accessors. For example:</span>
<span class="line-added">+ //  jfieldID JNIJVMCI::Architecture::_wordKind_field_id = 0;</span>
<span class="line-added">+ //  jfieldID HotSpotJVMCI::Architecture::_wordKind_offset = 0;</span>
<span class="line-added">+ JVMCI_CLASSES_DO(EMPTY2, EMPTY0, FIELD2, FIELD2, FIELD2, FIELD2, FIELD2, FIELD3, FIELD3, FIELD3, FIELD3, FIELD3, FIELD2, FIELD2, METHOD, CONSTRUCTOR)</span>
  
<span class="line-added">+ #undef START_CLASS</span>
<span class="line-added">+ #undef END_CLASS</span>
<span class="line-added">+ #undef METHOD</span>
<span class="line-added">+ #undef CONSTRUCTOR</span>
<span class="line-added">+ #undef FIELD</span>
<span class="line-added">+ #undef CHAR_FIELD</span>
<span class="line-added">+ #undef INT_FIELD</span>
<span class="line-added">+ #undef BOOLEAN_FIELD</span>
<span class="line-added">+ #undef LONG_FIELD</span>
<span class="line-added">+ #undef FLOAT_FIELD</span>
<span class="line-added">+ #undef OBJECT_FIELD</span>
<span class="line-added">+ #undef PRIMARRAY_FIELD</span>
<span class="line-added">+ #undef OBJECTARRAY_FIELD</span>
<span class="line-added">+ #undef STATIC_FIELD</span>
<span class="line-added">+ #undef STATIC_OBJECT_FIELD</span>
<span class="line-added">+ #undef STATIC_OBJECTARRAY_FIELD</span>
<span class="line-added">+ #undef STATIC_INT_FIELD</span>
<span class="line-added">+ #undef STATIC_BOOLEAN_FIELD</span>
<span class="line-added">+ #undef EMPTY_CAST</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ #define START_CLASS(className, fullClassName)                                                                                     \</span>
<span class="line-added">+   void JNIJVMCI::className::initialize(JVMCI_TRAPS) {                                                                             \</span>
<span class="line-added">+     /* should already be initialized */                                                                                           \</span>
<span class="line-added">+   }                                                                                                                               \</span>
<span class="line-added">+   bool JNIJVMCI::className::is_instance(JVMCIEnv* jvmciEnv, JVMCIObject object) {                                                 \</span>
<span class="line-added">+     JNIAccessMark jni(jvmciEnv);                                                                                                  \</span>
<span class="line-added">+     return jni()-&gt;IsInstanceOf(object.as_jobject(), className::clazz()) != 0;                                                     \</span>
<span class="line-added">+   }                                                                                                                               \</span>
<span class="line-added">+   void JNIJVMCI::className::check(JVMCIEnv* jvmciEnv, JVMCIObject obj, const char* field_name, jfieldID offset) {                 \</span>
<span class="line-added">+     assert(obj.is_non_null(), &quot;NULL field access of %s.%s&quot;, #className, field_name);                                     \</span>
<span class="line-added">+     assert(jvmciEnv-&gt;isa_##className(obj), &quot;wrong class, &quot; #className &quot; expected, found %s&quot;, jvmciEnv-&gt;klass_name(obj)); \</span>
<span class="line-added">+     assert(offset != 0, &quot;must be valid offset&quot;);                                                                                  \</span>
<span class="line-added">+   }                                                                                                                               \</span>
<span class="line-added">+   jclass JNIJVMCI::className::_class = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define END_CLASS</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define FIELD(className, name, type, accessor, cast)                                                                \</span>
<span class="line-added">+   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj) {                                       \</span>
<span class="line-added">+    className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                                           \</span>
<span class="line-added">+    JNIAccessMark jni(jvmciEnv);                               \</span>
<span class="line-added">+    return cast jni()-&gt;Get##accessor##Field(resolve_handle(obj), className::_##name##_field_id); \</span>
<span class="line-added">+   }                                                                                                                 \</span>
<span class="line-added">+   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj, type x) {                               \</span>
<span class="line-added">+     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                                          \</span>
<span class="line-added">+     JNIAccessMark jni(jvmciEnv); \</span>
<span class="line-added">+     jni()-&gt;Set##accessor##Field(resolve_handle(obj), className::_##name##_field_id, x);         \</span>
<span class="line-added">+   } \</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define EMPTY_CAST</span>
<span class="line-added">+ #define CHAR_FIELD(className, name)                    FIELD(className, name, jchar, Char, EMPTY_CAST)</span>
<span class="line-added">+ #define INT_FIELD(className, name)                     FIELD(className, name, jint, Int, EMPTY_CAST)</span>
<span class="line-added">+ #define BOOLEAN_FIELD(className, name)                 FIELD(className, name, jboolean, Boolean, EMPTY_CAST)</span>
<span class="line-added">+ #define LONG_FIELD(className, name)                    FIELD(className, name, jlong, Long, EMPTY_CAST)</span>
<span class="line-added">+ #define FLOAT_FIELD(className, name)                   FIELD(className, name, jfloat, Float, EMPTY_CAST)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define OBJECT_FIELD(className, name, signature)              OOPISH_FIELD(className, name, JVMCIObject, Object, EMPTY_CAST)</span>
<span class="line-added">+ #define OBJECTARRAY_FIELD(className, name, signature)         OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))</span>
<span class="line-added">+ #define PRIMARRAY_FIELD(className, name, signature)           OOPISH_FIELD(className, name, JVMCIPrimitiveArray, Object, (JVMCIPrimitiveArray))</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STATIC_OBJECT_FIELD(className, name, signature)       STATIC_OOPISH_FIELD(className, name, JVMCIObject, Object, (JVMCIObject))</span>
<span class="line-added">+ #define STATIC_OBJECTARRAY_FIELD(className, name, signature)  STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define OOPISH_FIELD(className, name, type, accessor, cast)                                             \</span>
<span class="line-added">+   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj) {                           \</span>
<span class="line-added">+     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                              \</span>
<span class="line-added">+     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">+     return cast wrap(jni()-&gt;Get##accessor##Field(resolve_handle(obj), className::_##name##_field_id));  \</span>
<span class="line-added">+   }                                                                                                     \</span>
<span class="line-added">+   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj, type x) {                   \</span>
<span class="line-added">+     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                              \</span>
<span class="line-added">+     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">+     jni()-&gt;Set##accessor##Field(resolve_handle(obj), className::_##name##_field_id, resolve_handle(x)); \</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STATIC_OOPISH_FIELD(className, name, type, accessor, cast)                                      \</span>
<span class="line-added">+   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv) {                                            \</span>
<span class="line-added">+     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">+     return cast wrap(jni()-&gt;GetStatic##accessor##Field(className::clazz(), className::_##name##_field_id));  \</span>
<span class="line-added">+   }                                                                                                     \</span>
<span class="line-added">+   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, type x) {                                    \</span>
<span class="line-added">+     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">+     jni()-&gt;SetStatic##accessor##Field(className::clazz(), className::_##name##_field_id, resolve_handle(x)); \</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STATIC_PRIMITIVE_FIELD(className, name, type, accessor, cast)                                   \</span>
<span class="line-added">+   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv) {                                            \</span>
<span class="line-added">+     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">+     return cast jni()-&gt;GetStatic##accessor##Field(className::clazz(), className::_##name##_field_id);   \</span>
<span class="line-added">+   }                                                                                                     \</span>
<span class="line-added">+   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, type x) {                                    \</span>
<span class="line-added">+     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">+     jni()-&gt;SetStatic##accessor##Field(className::clazz(), className::_##name##_field_id, x);            \</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint, Int, EMPTY_CAST)</span>
<span class="line-added">+ #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean, Boolean, EMPTY_CAST)</span>
<span class="line-added">+ #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \</span>
<span class="line-added">+   jmethodID JNIJVMCI::className::_##methodName##_method;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define CONSTRUCTOR(className, signature) \</span>
<span class="line-added">+   jmethodID JNIJVMCI::className::_constructor;</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * Generates the method definitions for the classes in HotSpotJVMCI.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef METHOD</span>
<span class="line-added">+ #undef CONSTRUCTOR</span>
<span class="line-added">+ #undef START_CLASS</span>
<span class="line-added">+ #undef END_CLASS</span>
<span class="line-added">+ #undef FIELD</span>
<span class="line-added">+ #undef CHAR_FIELD</span>
<span class="line-added">+ #undef INT_FIELD</span>
<span class="line-added">+ #undef BOOLEAN_FIELD</span>
<span class="line-added">+ #undef LONG_FIELD</span>
<span class="line-added">+ #undef FLOAT_FIELD</span>
<span class="line-added">+ #undef OBJECT_FIELD</span>
<span class="line-added">+ #undef PRIMARRAY_FIELD</span>
<span class="line-added">+ #undef OBJECTARRAY_FIELD</span>
<span class="line-added">+ #undef STATIC_OOPISH_FIELD</span>
<span class="line-added">+ #undef STATIC_OBJECT_FIELD</span>
<span class="line-added">+ #undef STATIC_OBJECTARRAY_FIELD</span>
<span class="line-added">+ #undef STATIC_INT_FIELD</span>
<span class="line-added">+ #undef STATIC_BOOLEAN_FIELD</span>
<span class="line-added">+ #undef STATIC_PRIMITIVE_FIELD</span>
<span class="line-added">+ #undef OOPISH_FIELD</span>
<span class="line-added">+ #undef EMPTY_CAST</span>
</pre>
<center><a href="jvmciEnv.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciJavaClasses.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
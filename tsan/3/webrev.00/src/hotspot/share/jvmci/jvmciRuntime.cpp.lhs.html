<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 25 #include &quot;jvm.h&quot;</span>
<span class="line-removed"> 26 #include &quot;asm/codeBuffer.hpp&quot;</span>
<span class="line-removed"> 27 #include &quot;classfile/javaClasses.inline.hpp&quot;</span>
<span class="line-removed"> 28 #include &quot;code/codeCache.hpp&quot;</span>
<span class="line-removed"> 29 #include &quot;code/compiledMethod.inline.hpp&quot;</span>
 30 #include &quot;compiler/compileBroker.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 31 #include &quot;compiler/disassembler.hpp&quot;</span>
<span class="line-removed"> 32 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
 33 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 34 #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
<span class="line-removed"> 35 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
<span class="line-removed"> 36 #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
 37 #include &quot;logging/log.hpp&quot;
<a name="5" id="anc5"></a><span class="line-removed"> 38 #include &quot;memory/allocation.inline.hpp&quot;</span>
 39 #include &quot;memory/oopFactory.hpp&quot;
<a name="6" id="anc6"></a><span class="line-modified"> 40 #include &quot;memory/resourceArea.hpp&quot;</span>



 41 #include &quot;oops/oop.inline.hpp&quot;
<a name="7" id="anc7"></a><span class="line-modified"> 42 #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
 43 #include &quot;runtime/biasedLocking.hpp&quot;
<a name="8" id="anc8"></a>

 44 #include &quot;runtime/frame.inline.hpp&quot;
<a name="9" id="anc9"></a><span class="line-removed"> 45 #include &quot;runtime/handles.inline.hpp&quot;</span>
<span class="line-removed"> 46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
<span class="line-removed"> 47 #include &quot;runtime/jniHandles.inline.hpp&quot;</span>
<span class="line-removed"> 48 #include &quot;runtime/reflection.hpp&quot;</span>
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
<a name="10" id="anc10"></a><span class="line-removed"> 50 #include &quot;runtime/threadSMR.hpp&quot;</span>
<span class="line-removed"> 51 #include &quot;utilities/debug.hpp&quot;</span>
<span class="line-removed"> 52 #include &quot;utilities/defaultStream.hpp&quot;</span>
<span class="line-removed"> 53 #include &quot;utilities/macros.hpp&quot;</span>
 54 #if INCLUDE_G1GC
 55 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
 56 #endif // INCLUDE_G1GC
 57 
<a name="11" id="anc11"></a><span class="line-removed"> 58 #if defined(_MSC_VER)</span>
<span class="line-removed"> 59 #define strtoll _strtoi64</span>
<span class="line-removed"> 60 #endif</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62 jobject JVMCIRuntime::_HotSpotJVMCIRuntime_instance = NULL;</span>
<span class="line-removed"> 63 bool JVMCIRuntime::_HotSpotJVMCIRuntime_initialized = false;</span>
<span class="line-removed"> 64 bool JVMCIRuntime::_well_known_classes_initialized = false;</span>
<span class="line-removed"> 65 JVMCIRuntime::CompLevelAdjustment JVMCIRuntime::_comp_level_adjustment = JVMCIRuntime::none;</span>
<span class="line-removed"> 66 bool JVMCIRuntime::_shutdown_called = false;</span>
<span class="line-removed"> 67 </span>
<span class="line-removed"> 68 BasicType JVMCIRuntime::kindToBasicType(Handle kind, TRAPS) {</span>
<span class="line-removed"> 69   if (kind.is_null()) {</span>
<span class="line-removed"> 70     THROW_(vmSymbols::java_lang_NullPointerException(), T_ILLEGAL);</span>
<span class="line-removed"> 71   }</span>
<span class="line-removed"> 72   jchar ch = JavaKind::typeChar(kind);</span>
<span class="line-removed"> 73   switch(ch) {</span>
<span class="line-removed"> 74     case &#39;Z&#39;: return T_BOOLEAN;</span>
<span class="line-removed"> 75     case &#39;B&#39;: return T_BYTE;</span>
<span class="line-removed"> 76     case &#39;S&#39;: return T_SHORT;</span>
<span class="line-removed"> 77     case &#39;C&#39;: return T_CHAR;</span>
<span class="line-removed"> 78     case &#39;I&#39;: return T_INT;</span>
<span class="line-removed"> 79     case &#39;F&#39;: return T_FLOAT;</span>
<span class="line-removed"> 80     case &#39;J&#39;: return T_LONG;</span>
<span class="line-removed"> 81     case &#39;D&#39;: return T_DOUBLE;</span>
<span class="line-removed"> 82     case &#39;A&#39;: return T_OBJECT;</span>
<span class="line-removed"> 83     case &#39;-&#39;: return T_ILLEGAL;</span>
<span class="line-removed"> 84     default:</span>
<span class="line-removed"> 85       JVMCI_ERROR_(T_ILLEGAL, &quot;unexpected Kind: %c&quot;, ch);</span>
<span class="line-removed"> 86   }</span>
<span class="line-removed"> 87 }</span>
<span class="line-removed"> 88 </span>
 89 // Simple helper to see if the caller of a runtime stub which
 90 // entered the VM has been deoptimized
 91 
 92 static bool caller_is_deopted() {
 93   JavaThread* thread = JavaThread::current();
 94   RegisterMap reg_map(thread, false);
 95   frame runtime_frame = thread-&gt;last_frame();
 96   frame caller_frame = runtime_frame.sender(&amp;reg_map);
 97   assert(caller_frame.is_compiled_frame(), &quot;must be compiled&quot;);
 98   return caller_frame.is_deoptimized_frame();
 99 }
100 
101 // Stress deoptimization
102 static void deopt_caller() {
103   if ( !caller_is_deopted()) {
104     JavaThread* thread = JavaThread::current();
105     RegisterMap reg_map(thread, false);
106     frame runtime_frame = thread-&gt;last_frame();
107     frame caller_frame = runtime_frame.sender(&amp;reg_map);
108     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
109     assert(caller_is_deopted(), &quot;Must be deoptimized&quot;);
110   }
111 }
112 
113 // Manages a scope for a JVMCI runtime call that attempts a heap allocation.
114 // If there is a pending exception upon closing the scope and the runtime
115 // call is of the variety where allocation failure returns NULL without an
116 // exception, the following action is taken:
117 //   1. The pending exception is cleared
118 //   2. NULL is written to JavaThread::_vm_result
119 //   3. Checks that an OutOfMemoryError is Universe::out_of_memory_error_retry().
120 class RetryableAllocationMark: public StackObj {
121  private:
122   JavaThread* _thread;
123  public:
124   RetryableAllocationMark(JavaThread* thread, bool activate) {
125     if (activate) {
126       assert(!thread-&gt;in_retryable_allocation(), &quot;retryable allocation scope is non-reentrant&quot;);
127       _thread = thread;
128       _thread-&gt;set_in_retryable_allocation(true);
129     } else {
130       _thread = NULL;
131     }
132   }
133   ~RetryableAllocationMark() {
134     if (_thread != NULL) {
135       _thread-&gt;set_in_retryable_allocation(false);
136       JavaThread* THREAD = _thread;
137       if (HAS_PENDING_EXCEPTION) {
138         oop ex = PENDING_EXCEPTION;
139         CLEAR_PENDING_EXCEPTION;
140         oop retry_oome = Universe::out_of_memory_error_retry();
141         if (ex-&gt;is_a(retry_oome-&gt;klass()) &amp;&amp; retry_oome != ex) {
142           ResourceMark rm;
143           fatal(&quot;Unexpected exception in scope of retryable allocation: &quot; INTPTR_FORMAT &quot; of type %s&quot;, p2i(ex), ex-&gt;klass()-&gt;external_name());
144         }
145         _thread-&gt;set_vm_result(NULL);
146       }
147     }
148   }
149 };
150 
151 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))
152   JRT_BLOCK;
153   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
154   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
<a name="12" id="anc12"></a><span class="line-modified">155   InstanceKlass* ik = InstanceKlass::cast(klass);</span>
156   {
157     RetryableAllocationMark ram(thread, null_on_fail);
<a name="13" id="anc13"></a><span class="line-modified">158     ik-&gt;check_valid_for_instantiation(true, CHECK);</span>
159     oop obj;
160     if (null_on_fail) {
<a name="14" id="anc14"></a><span class="line-modified">161       if (!ik-&gt;is_initialized()) {</span>
162         // Cannot re-execute class initialization without side effects
163         // so return without attempting the initialization
164         return;
165       }
166     } else {
167       // make sure klass is initialized
<a name="15" id="anc15"></a><span class="line-modified">168       ik-&gt;initialize(CHECK);</span>
169     }
170     // allocate instance and return via TLS
<a name="16" id="anc16"></a><span class="line-modified">171     obj = ik-&gt;allocate_instance(CHECK);</span>
172     thread-&gt;set_vm_result(obj);
173   }
174   JRT_BLOCK_END;
175   SharedRuntime::on_slowpath_allocation_exit(thread);
176 JRT_END
177 
178 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* thread, Klass* array_klass, jint length, bool null_on_fail))
179   JRT_BLOCK;
180   // Note: no handle for klass needed since they are not used
181   //       anymore after new_objArray() and no GC can happen before.
182   //       (This may have to change if this code changes!)
183   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);
184   oop obj;
185   if (array_klass-&gt;is_typeArray_klass()) {
186     BasicType elt_type = TypeArrayKlass::cast(array_klass)-&gt;element_type();
187     RetryableAllocationMark ram(thread, null_on_fail);
188     obj = oopFactory::new_typeArray(elt_type, length, CHECK);
189   } else {
190     Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
191     Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();
192     RetryableAllocationMark ram(thread, null_on_fail);
193     obj = oopFactory::new_objArray(elem_klass, length, CHECK);
194   }
195   thread-&gt;set_vm_result(obj);
196   // This is pretty rare but this runtime patch is stressful to deoptimization
197   // if we deoptimize here so force a deopt to stress the path.
198   if (DeoptimizeALot) {
199     static int deopts = 0;
200     // Alternate between deoptimizing and raising an error (which will also cause a deopt)
201     if (deopts++ % 2 == 0) {
202       if (null_on_fail) {
203         return;
204       } else {
205         ResourceMark rm(THREAD);
206         THROW(vmSymbols::java_lang_OutOfMemoryError());
207       }
208     } else {
209       deopt_caller();
210     }
211   }
212   JRT_BLOCK_END;
213   SharedRuntime::on_slowpath_allocation_exit(thread);
214 JRT_END
215 
216 JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail))
217   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
218   assert(rank &gt;= 1, &quot;rank must be nonzero&quot;);
219   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
220   RetryableAllocationMark ram(thread, null_on_fail);
221   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
222   thread-&gt;set_vm_result(obj);
223 JRT_END
224 
225 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail))
226   RetryableAllocationMark ram(thread, null_on_fail);
227   oop obj = Reflection::reflect_new_array(element_mirror, length, CHECK);
228   thread-&gt;set_vm_result(obj);
229 JRT_END
230 
231 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail))
232   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(type_mirror));
233 
234   if (klass == NULL) {
235     ResourceMark rm(THREAD);
236     THROW(vmSymbols::java_lang_InstantiationException());
237   }
238   RetryableAllocationMark ram(thread, null_on_fail);
239 
240   // Create new instance (the receiver)
241   klass-&gt;check_valid_for_instantiation(false, CHECK);
242 
243   if (null_on_fail) {
244     if (!klass-&gt;is_initialized()) {
245       // Cannot re-execute class initialization without side effects
246       // so return without attempting the initialization
247       return;
248     }
249   } else {
250     // Make sure klass gets initialized
251     klass-&gt;initialize(CHECK);
252   }
253 
254   oop obj = klass-&gt;allocate_instance(CHECK);
255   thread-&gt;set_vm_result(obj);
256 JRT_END
257 
258 extern void vm_exit(int code);
259 
260 // Enter this method from compiled code handler below. This is where we transition
261 // to VM mode. This is done as a helper routine so that the method called directly
262 // from compiled code does not have to transition to VM. This allows the entry
263 // method to see if the nmethod that we have just looked up a handler for has
264 // been deoptimized while we were in the vm. This simplifies the assembly code
265 // cpu directories.
266 //
267 // We are entering here from exception stub (via the entry method below)
268 // If there is a compiled exception handler in this method, we will continue there;
269 // otherwise we will unwind the stack and continue at the caller of top frame method
270 // Note: we enter in Java using a special JRT wrapper. This wrapper allows us to
271 // control the area where we can allow a safepoint. After we exit the safepoint area we can
272 // check to see if the handler we are going to return is now in a nmethod that has
273 // been deoptimized. If that is the case we return the deopt blob
274 // unpack_with_exception entry instead. This makes life for the exception blob easier
275 // because making that same check and diverting is painful from assembly language.
276 JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, CompiledMethod*&amp; cm))
277   // Reset method handle flag.
278   thread-&gt;set_is_method_handle_return(false);
279 
280   Handle exception(thread, ex);
281   cm = CodeCache::find_compiled(pc);
282   assert(cm != NULL, &quot;this is not a compiled method&quot;);
283   // Adjust the pc as needed/
284   if (cm-&gt;is_deopt_pc(pc)) {
285     RegisterMap map(thread, false);
286     frame exception_frame = thread-&gt;last_frame().sender(&amp;map);
287     // if the frame isn&#39;t deopted then pc must not correspond to the caller of last_frame
288     assert(exception_frame.is_deoptimized_frame(), &quot;must be deopted&quot;);
289     pc = exception_frame.pc();
290   }
291 #ifdef ASSERT
292   assert(exception.not_null(), &quot;NULL exceptions should be handled by throw_exception&quot;);
<a name="17" id="anc17"></a>
293   // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
294   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
295     if (ExitVMOnVerifyError) vm_exit(-1);
296     ShouldNotReachHere();
297   }
298 #endif
299 
300   // Check the stack guard pages and reenable them if necessary and there is
301   // enough space on the stack to do so.  Use fast exceptions only if the guard
302   // pages are enabled.
303   bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
304   if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
305 
306   if (JvmtiExport::can_post_on_exceptions()) {
307     // To ensure correct notification of exception catches and throws
308     // we have to deoptimize here.  If we attempted to notify the
309     // catches and throws during this exception lookup it&#39;s possible
310     // we could deoptimize on the way out of the VM and end back in
311     // the interpreter at the throw site.  This would result in double
312     // notifications since the interpreter would also notify about
313     // these same catches and throws as it unwound the frame.
314 
315     RegisterMap reg_map(thread);
316     frame stub_frame = thread-&gt;last_frame();
317     frame caller_frame = stub_frame.sender(&amp;reg_map);
318 
319     // We don&#39;t really want to deoptimize the nmethod itself since we
320     // can actually continue in the exception handler ourselves but I
321     // don&#39;t see an easy way to have the desired effect.
322     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
323     assert(caller_is_deopted(), &quot;Must be deoptimized&quot;);
324 
325     return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
326   }
327 
328   // ExceptionCache is used only for exceptions at call sites and not for implicit exceptions
329   if (guard_pages_enabled) {
330     address fast_continuation = cm-&gt;handler_for_exception_and_pc(exception, pc);
331     if (fast_continuation != NULL) {
332       // Set flag if return address is a method handle call site.
333       thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
334       return fast_continuation;
335     }
336   }
337 
338   // If the stack guard pages are enabled, check whether there is a handler in
339   // the current method.  Otherwise (guard pages disabled), force an unwind and
340   // skip the exception cache update (i.e., just leave continuation==NULL).
341   address continuation = NULL;
342   if (guard_pages_enabled) {
343 
344     // New exception handling mechanism can support inlined methods
345     // with exception handlers since the mappings are from PC to PC
346 
347     // debugging support
348     // tracing
349     if (log_is_enabled(Info, exceptions)) {
350       ResourceMark rm;
351       stringStream tempst;
352       assert(cm-&gt;method() != NULL, &quot;Unexpected null method()&quot;);
353       tempst.print(&quot;compiled method &lt;%s&gt;\n&quot;
354                    &quot; at PC&quot; INTPTR_FORMAT &quot; for thread &quot; INTPTR_FORMAT,
355                    cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
<a name="18" id="anc18"></a><span class="line-modified">356       Exceptions::log_exception(exception, tempst);</span>
357     }
358     // for AbortVMOnException flag
359     NOT_PRODUCT(Exceptions::debug_check_abort(exception));
360 
361     // Clear out the exception oop and pc since looking up an
362     // exception handler can cause class loading, which might throw an
363     // exception and those fields are expected to be clear during
364     // normal bytecode execution.
365     thread-&gt;clear_exception_oop_and_pc();
366 
367     bool recursive_exception = false;
368     continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
369     // If an exception was thrown during exception dispatch, the exception oop may have changed
370     thread-&gt;set_exception_oop(exception());
371     thread-&gt;set_exception_pc(pc);
372 
<a name="19" id="anc19"></a><span class="line-modified">373     // the exception cache is used only by non-implicit exceptions</span>
<span class="line-modified">374     // Update the exception cache only when there didn&#39;t happen</span>
<span class="line-modified">375     // another exception during the computation of the compiled</span>
<span class="line-modified">376     // exception handler. Checking for exception oop equality is not</span>

377     // sufficient because some exceptions are pre-allocated and reused.
378     if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
379       cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
380     }
381   }
382 
383   // Set flag if return address is a method handle call site.
384   thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
385 
386   if (log_is_enabled(Info, exceptions)) {
387     ResourceMark rm;
388     log_info(exceptions)(&quot;Thread &quot; PTR_FORMAT &quot; continuing at PC &quot; PTR_FORMAT
389                          &quot; for exception thrown at PC &quot; PTR_FORMAT,
390                          p2i(thread), p2i(continuation), p2i(pc));
391   }
392 
393   return continuation;
394 JRT_END
395 
396 // Enter this method from compiled code only if there is a Java exception handler
397 // in the method handling the exception.
398 // We are entering here from exception stub. We don&#39;t do a normal VM transition here.
399 // We do it in a helper. This is so we can check to see if the nmethod we have just
400 // searched for an exception handler has been deoptimized in the meantime.
401 address JVMCIRuntime::exception_handler_for_pc(JavaThread* thread) {
402   oop exception = thread-&gt;exception_oop();
403   address pc = thread-&gt;exception_pc();
404   // Still in Java mode
405   DEBUG_ONLY(ResetNoHandleMark rnhm);
406   CompiledMethod* cm = NULL;
407   address continuation = NULL;
408   {
409     // Enter VM mode by calling the helper
410     ResetNoHandleMark rnhm;
411     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
412   }
413   // Back in JAVA, use no oops DON&#39;T safepoint
414 
415   // Now check to see if the compiled method we were called from is now deoptimized.
416   // If so we must return to the deopt blob and deoptimize the nmethod
417   if (cm != NULL &amp;&amp; caller_is_deopted()) {
418     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
419   }
420 
421   assert(continuation != NULL, &quot;no handler found&quot;);
422   return continuation;
423 }
424 
425 JRT_ENTRY_NO_ASYNC(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))
426   IF_TRACE_jvmci_3 {
427     char type[O_BUFLEN];
428     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
<a name="20" id="anc20"></a><span class="line-modified">429     markOop mark = obj-&gt;mark();</span>
<span class="line-modified">430     TRACE_jvmci_3(&quot;%s: entered locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, p2i(mark), p2i(lock));</span>
431     tty-&gt;flush();
432   }
<a name="21" id="anc21"></a><span class="line-removed">433 #ifdef ASSERT</span>
434   if (PrintBiasedLockingStatistics) {
435     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
436   }
<a name="22" id="anc22"></a><span class="line-removed">437 #endif</span>
438   Handle h_obj(thread, obj);
<a name="23" id="anc23"></a><span class="line-modified">439   if (UseBiasedLocking) {</span>
<span class="line-modified">440     // Retry fast entry if bias is revoked to avoid unnecessary inflation</span>
<span class="line-removed">441     ObjectSynchronizer::fast_enter(h_obj, lock, true, CHECK);</span>
<span class="line-removed">442   } else {</span>
<span class="line-removed">443     if (JVMCIUseFastLocking) {</span>
<span class="line-removed">444       // When using fast locking, the compiled code has already tried the fast case</span>
<span class="line-removed">445       ObjectSynchronizer::slow_enter(h_obj, lock, THREAD);</span>
<span class="line-removed">446     } else {</span>
<span class="line-removed">447       ObjectSynchronizer::fast_enter(h_obj, lock, false, THREAD);</span>
<span class="line-removed">448     }</span>
<span class="line-removed">449   }</span>
450   TRACE_jvmci_3(&quot;%s: exiting locking slow with obj=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj));
451 JRT_END
452 
453 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
454   assert(thread == JavaThread::current(), &quot;threads must correspond&quot;);
455   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
456   // monitorexit is non-blocking (leaf routine) =&gt; no exceptions can be thrown
457   EXCEPTION_MARK;
458 
<a name="24" id="anc24"></a><span class="line-modified">459 #ifdef DEBUG</span>
460   if (!oopDesc::is_oop(obj)) {
461     ResetNoHandleMark rhm;
462     nmethod* method = thread-&gt;last_frame().cb()-&gt;as_nmethod_or_null();
463     if (method != NULL) {
464       tty-&gt;print_cr(&quot;ERROR in monitorexit in method %s wrong obj &quot; INTPTR_FORMAT, method-&gt;name(), p2i(obj));
465     }
466     thread-&gt;print_stack_on(tty);
467     assert(false, &quot;invalid lock object pointer dected&quot;);
468   }
469 #endif
470 
<a name="25" id="anc25"></a><span class="line-modified">471   if (JVMCIUseFastLocking) {</span>
<span class="line-removed">472     // When using fast locking, the compiled code has already tried the fast case</span>
<span class="line-removed">473     ObjectSynchronizer::slow_exit(obj, lock, THREAD);</span>
<span class="line-removed">474   } else {</span>
<span class="line-removed">475     ObjectSynchronizer::fast_exit(obj, lock, THREAD);</span>
<span class="line-removed">476   }</span>
477   IF_TRACE_jvmci_3 {
478     char type[O_BUFLEN];
479     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
<a name="26" id="anc26"></a><span class="line-modified">480     TRACE_jvmci_3(&quot;%s: exited locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, p2i(obj-&gt;mark()), p2i(lock));</span>
481     tty-&gt;flush();
482   }
483 JRT_END
484 
485 // Object.notify() fast path, caller does slow path
486 JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))
487 
488   // Very few notify/notifyAll operations find any threads on the waitset, so
489   // the dominant fast-path is to simply return.
490   // Relatedly, it&#39;s critical that notify/notifyAll be fast in order to
491   // reduce lock hold times.
492   if (!SafepointSynchronize::is_synchronizing()) {
493     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
494       return true;
495     }
496   }
497   return false; // caller must perform slow path
498 
499 JRT_END
500 
501 // Object.notifyAll() fast path, caller does slow path
502 JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))
503 
504   if (!SafepointSynchronize::is_synchronizing() ) {
505     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
506       return true;
507     }
508   }
509   return false; // caller must perform slow path
510 
511 JRT_END
512 
<a name="27" id="anc27"></a><span class="line-modified">513 JRT_ENTRY(void, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))</span>
<span class="line-modified">514   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);</span>

515   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
<a name="28" id="anc28"></a>

516 JRT_END
517 
<a name="29" id="anc29"></a><span class="line-modified">518 JRT_ENTRY(void, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))</span>

519   ResourceMark rm(thread);
<a name="30" id="anc30"></a><span class="line-modified">520   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);</span>
521   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());
<a name="31" id="anc31"></a>

522 JRT_END
523 
<a name="32" id="anc32"></a><span class="line-modified">524 JRT_ENTRY(void, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))</span>

525   ResourceMark rm(thread);
526   const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
<a name="33" id="anc33"></a><span class="line-modified">527   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);</span>
528   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
<a name="34" id="anc34"></a>

529 JRT_END
530 
531 JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
532   ttyLocker ttyl;
533 
534   if (obj == NULL) {
535     tty-&gt;print(&quot;NULL&quot;);
536   } else if (oopDesc::is_oop_or_null(obj, true) &amp;&amp; (!as_string || !java_lang_String::is_instance(obj))) {
537     if (oopDesc::is_oop_or_null(obj, true)) {
538       char buf[O_BUFLEN];
539       tty-&gt;print(&quot;%s@&quot; INTPTR_FORMAT, obj-&gt;klass()-&gt;name()-&gt;as_C_string(buf, O_BUFLEN), p2i(obj));
540     } else {
541       tty-&gt;print(INTPTR_FORMAT, p2i(obj));
542     }
543   } else {
544     ResourceMark rm;
545     assert(obj != NULL &amp;&amp; java_lang_String::is_instance(obj), &quot;must be&quot;);
546     char *buf = java_lang_String::as_utf8_string(obj);
547     tty-&gt;print_raw(buf);
548   }
549   if (newline) {
550     tty-&gt;cr();
551   }
552 JRT_END
553 
554 #if INCLUDE_G1GC
555 
556 JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))
557   G1ThreadLocalData::satb_mark_queue(thread).enqueue(obj);
558 JRT_END
559 
560 JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))
561   G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);
562 JRT_END
563 
564 #endif // INCLUDE_G1GC
565 
566 JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
567   bool ret = true;
<a name="35" id="anc35"></a><span class="line-modified">568   if(!Universe::heap()-&gt;is_in_closed_subset(parent)) {</span>
569     tty-&gt;print_cr(&quot;Parent Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(parent));
570     parent-&gt;print();
571     ret=false;
572   }
<a name="36" id="anc36"></a><span class="line-modified">573   if(!Universe::heap()-&gt;is_in_closed_subset(child)) {</span>
574     tty-&gt;print_cr(&quot;Child Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(child));
575     child-&gt;print();
576     ret=false;
577   }
578   return (jint)ret;
579 JRT_END
580 
581 JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* thread, jlong where, jlong format, jlong value))
582   ResourceMark rm;
583   const char *error_msg = where == 0L ? &quot;&lt;internal JVMCI error&gt;&quot; : (char*) (address) where;
584   char *detail_msg = NULL;
585   if (format != 0L) {
586     const char* buf = (char*) (address) format;
587     size_t detail_msg_length = strlen(buf) * 2;
588     detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
589     jio_snprintf(detail_msg, detail_msg_length, buf, value);
<a name="37" id="anc37"></a><span class="line-removed">590     report_vm_error(__FILE__, __LINE__, error_msg, &quot;%s&quot;, detail_msg);</span>
<span class="line-removed">591   } else {</span>
<span class="line-removed">592     report_vm_error(__FILE__, __LINE__, error_msg);</span>
593   }
<a name="38" id="anc38"></a>
594 JRT_END
595 
596 JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
597   oop exception = thread-&gt;exception_oop();
598   assert(exception != NULL, &quot;npe&quot;);
599   thread-&gt;set_exception_oop(NULL);
600   thread-&gt;set_exception_pc(0);
601   return exception;
602 JRT_END
603 
604 PRAGMA_DIAG_PUSH
605 PRAGMA_FORMAT_NONLITERAL_IGNORED
606 JRT_LEAF(void, JVMCIRuntime::log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3))
607   ResourceMark rm;
608   tty-&gt;print(format, v1, v2, v3);
609 JRT_END
610 PRAGMA_DIAG_POP
611 
612 static void decipher(jlong v, bool ignoreZero) {
613   if (v != 0 || !ignoreZero) {
614     void* p = (void *)(address) v;
615     CodeBlob* cb = CodeCache::find_blob(p);
616     if (cb) {
617       if (cb-&gt;is_nmethod()) {
618         char buf[O_BUFLEN];
619         tty-&gt;print(&quot;%s [&quot; INTPTR_FORMAT &quot;+&quot; JLONG_FORMAT &quot;]&quot;, cb-&gt;as_nmethod_or_null()-&gt;method()-&gt;name_and_sig_as_C_string(buf, O_BUFLEN), p2i(cb-&gt;code_begin()), (jlong)((address)v - cb-&gt;code_begin()));
620         return;
621       }
622       cb-&gt;print_value_on(tty);
623       return;
624     }
625     if (Universe::heap()-&gt;is_in(p)) {
626       oop obj = oop(p);
627       obj-&gt;print_value_on(tty);
628       return;
629     }
630     tty-&gt;print(INTPTR_FORMAT &quot; [long: &quot; JLONG_FORMAT &quot;, double %lf, char %c]&quot;,p2i((void *)v), (jlong)v, (jdouble)v, (char)v);
631   }
632 }
633 
634 PRAGMA_DIAG_PUSH
635 PRAGMA_FORMAT_NONLITERAL_IGNORED
636 JRT_LEAF(void, JVMCIRuntime::vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3))
637   ResourceMark rm;
638   const char *buf = (const char*) (address) format;
639   if (vmError) {
640     if (buf != NULL) {
641       fatal(buf, v1, v2, v3);
642     } else {
643       fatal(&quot;&lt;anonymous error&gt;&quot;);
644     }
645   } else if (buf != NULL) {
646     tty-&gt;print(buf, v1, v2, v3);
647   } else {
648     assert(v2 == 0, &quot;v2 != 0&quot;);
649     assert(v3 == 0, &quot;v3 != 0&quot;);
650     decipher(v1, false);
651   }
652 JRT_END
653 PRAGMA_DIAG_POP
654 
655 JRT_LEAF(void, JVMCIRuntime::log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline))
656   union {
657       jlong l;
658       jdouble d;
659       jfloat f;
660   } uu;
661   uu.l = value;
662   switch (typeChar) {
663     case &#39;Z&#39;: tty-&gt;print(value == 0 ? &quot;false&quot; : &quot;true&quot;); break;
664     case &#39;B&#39;: tty-&gt;print(&quot;%d&quot;, (jbyte) value); break;
665     case &#39;C&#39;: tty-&gt;print(&quot;%c&quot;, (jchar) value); break;
666     case &#39;S&#39;: tty-&gt;print(&quot;%d&quot;, (jshort) value); break;
667     case &#39;I&#39;: tty-&gt;print(&quot;%d&quot;, (jint) value); break;
668     case &#39;F&#39;: tty-&gt;print(&quot;%f&quot;, uu.f); break;
669     case &#39;J&#39;: tty-&gt;print(JLONG_FORMAT, value); break;
670     case &#39;D&#39;: tty-&gt;print(&quot;%lf&quot;, uu.d); break;
671     default: assert(false, &quot;unknown typeChar&quot;); break;
672   }
673   if (newline) {
674     tty-&gt;cr();
675   }
676 JRT_END
677 
678 JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
679   return (jint) obj-&gt;identity_hash();
680 JRT_END
681 
<a name="39" id="anc39"></a><span class="line-modified">682 JRT_ENTRY(jboolean, JVMCIRuntime::thread_is_interrupted(JavaThread* thread, oopDesc* receiver, jboolean clear_interrupted))</span>
<span class="line-removed">683   Handle receiverHandle(thread, receiver);</span>
<span class="line-removed">684   // A nested ThreadsListHandle may require the Threads_lock which</span>
<span class="line-removed">685   // requires thread_in_vm which is why this method cannot be JRT_LEAF.</span>
<span class="line-removed">686   ThreadsListHandle tlh;</span>
<span class="line-removed">687 </span>
<span class="line-removed">688   JavaThread* receiverThread = java_lang_Thread::thread(receiverHandle());</span>
<span class="line-removed">689   if (receiverThread == NULL || (EnableThreadSMRExtraValidityChecks &amp;&amp; !tlh.includes(receiverThread))) {</span>
<span class="line-removed">690     // The other thread may exit during this process, which is ok so return false.</span>
<span class="line-removed">691     return JNI_FALSE;</span>
<span class="line-removed">692   } else {</span>
<span class="line-removed">693     return (jint) Thread::is_interrupted(receiverThread, clear_interrupted != 0);</span>
<span class="line-removed">694   }</span>
<span class="line-removed">695 JRT_END</span>
<span class="line-removed">696 </span>
<span class="line-removed">697 JRT_ENTRY(int, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))</span>
698   deopt_caller();
<a name="40" id="anc40"></a><span class="line-modified">699   return value;</span>
700 JRT_END
701 
<a name="41" id="anc41"></a><span class="line-removed">702 void JVMCIRuntime::force_initialization(TRAPS) {</span>
<span class="line-removed">703   JVMCIRuntime::initialize_well_known_classes(CHECK);</span>
<span class="line-removed">704 </span>
<span class="line-removed">705   ResourceMark rm;</span>
<span class="line-removed">706   TempNewSymbol getCompiler = SymbolTable::new_symbol(&quot;getCompiler&quot;, CHECK);</span>
<span class="line-removed">707   TempNewSymbol sig = SymbolTable::new_symbol(&quot;()Ljdk/vm/ci/runtime/JVMCICompiler;&quot;, CHECK);</span>
<span class="line-removed">708   Handle jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(CHECK);</span>
<span class="line-removed">709   JavaValue result(T_OBJECT);</span>
<span class="line-removed">710   JavaCalls::call_virtual(&amp;result, jvmciRuntime, HotSpotJVMCIRuntime::klass(), getCompiler, sig, CHECK);</span>
<span class="line-removed">711 }</span>
712 
713 // private static JVMCIRuntime JVMCI.initializeRuntime()
<a name="42" id="anc42"></a><span class="line-modified">714 JVM_ENTRY(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))</span>

715   if (!EnableJVMCI) {
<a name="43" id="anc43"></a><span class="line-modified">716     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVMCI is not enabled&quot;)</span>
717   }
<a name="44" id="anc44"></a><span class="line-modified">718   JVMCIRuntime::initialize_HotSpotJVMCIRuntime(CHECK_NULL);</span>
<span class="line-modified">719   jobject ret = JVMCIRuntime::get_HotSpotJVMCIRuntime_jobject(CHECK_NULL);</span>
<span class="line-modified">720   return ret;</span>
721 JVM_END
722 
<a name="45" id="anc45"></a><span class="line-modified">723 Handle JVMCIRuntime::callStatic(const char* className, const char* methodName, const char* signature, JavaCallArguments* args, TRAPS) {</span>
<span class="line-modified">724   TempNewSymbol name = SymbolTable::new_symbol(className, CHECK_(Handle()));</span>
<span class="line-modified">725   Klass* klass = SystemDictionary::resolve_or_fail(name, true, CHECK_(Handle()));</span>
<span class="line-modified">726   TempNewSymbol runtime = SymbolTable::new_symbol(methodName, CHECK_(Handle()));</span>
<span class="line-modified">727   TempNewSymbol sig = SymbolTable::new_symbol(signature, CHECK_(Handle()));</span>
<span class="line-modified">728   JavaValue result(T_OBJECT);</span>
<span class="line-modified">729   if (args == NULL) {</span>
<span class="line-modified">730     JavaCalls::call_static(&amp;result, klass, runtime, sig, CHECK_(Handle()));</span>










731   } else {
<a name="46" id="anc46"></a><span class="line-modified">732     JavaCalls::call_static(&amp;result, klass, runtime, sig, args, CHECK_(Handle()));</span>
733   }
<a name="47" id="anc47"></a><span class="line-removed">734   return Handle(THREAD, (oop)result.get_jobject());</span>
735 }
736 
<a name="48" id="anc48"></a><span class="line-modified">737 Handle JVMCIRuntime::get_HotSpotJVMCIRuntime(TRAPS) {</span>
<span class="line-modified">738   initialize_JVMCI(CHECK_(Handle()));</span>
<span class="line-modified">739   return Handle(THREAD, JNIHandles::resolve_non_null(_HotSpotJVMCIRuntime_instance));</span>





740 }
741 
<a name="49" id="anc49"></a><span class="line-modified">742 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(TRAPS) {</span>
<span class="line-modified">743   guarantee(!_HotSpotJVMCIRuntime_initialized, &quot;cannot reinitialize HotSpotJVMCIRuntime&quot;);</span>
<span class="line-modified">744   JVMCIRuntime::initialize_well_known_classes(CHECK);</span>
<span class="line-modified">745   // This should only be called in the context of the JVMCI class being initialized</span>
<span class="line-modified">746   InstanceKlass* klass = SystemDictionary::JVMCI_klass();</span>
<span class="line-modified">747   guarantee(klass-&gt;is_being_initialized() &amp;&amp; klass-&gt;is_reentrant_initialization(THREAD),</span>
<span class="line-modified">748          &quot;HotSpotJVMCIRuntime initialization should only be triggered through JVMCI initialization&quot;);</span>
<span class="line-modified">749 </span>
<span class="line-modified">750   Handle result = callStatic(&quot;jdk/vm/ci/hotspot/HotSpotJVMCIRuntime&quot;,</span>
<span class="line-modified">751                              &quot;runtime&quot;,</span>
<span class="line-modified">752                              &quot;()Ljdk/vm/ci/hotspot/HotSpotJVMCIRuntime;&quot;, NULL, CHECK);</span>
<span class="line-modified">753   int adjustment = HotSpotJVMCIRuntime::compilationLevelAdjustment(result);</span>
<span class="line-modified">754   assert(adjustment &gt;= JVMCIRuntime::none &amp;&amp;</span>
<span class="line-modified">755          adjustment &lt;= JVMCIRuntime::by_full_signature,</span>
<span class="line-modified">756          &quot;compilation level adjustment out of bounds&quot;);</span>
<span class="line-modified">757   _comp_level_adjustment = (CompLevelAdjustment) adjustment;</span>
<span class="line-modified">758   _HotSpotJVMCIRuntime_initialized = true;</span>
<span class="line-modified">759   _HotSpotJVMCIRuntime_instance = JNIHandles::make_global(result);</span>
<span class="line-modified">760 }</span>
<span class="line-modified">761 </span>
<span class="line-modified">762 void JVMCIRuntime::initialize_JVMCI(TRAPS) {</span>
<span class="line-modified">763   if (JNIHandles::resolve(_HotSpotJVMCIRuntime_instance) == NULL) {</span>
<span class="line-modified">764     callStatic(&quot;jdk/vm/ci/runtime/JVMCI&quot;,</span>
<span class="line-modified">765                &quot;getRuntime&quot;,</span>
<span class="line-modified">766                &quot;()Ljdk/vm/ci/runtime/JVMCIRuntime;&quot;, NULL, CHECK);</span>
<span class="line-modified">767   }</span>
<span class="line-modified">768   assert(_HotSpotJVMCIRuntime_initialized == true, &quot;what?&quot;);</span>
<span class="line-modified">769 }</span>
<span class="line-modified">770 </span>
<span class="line-removed">771 bool JVMCIRuntime::can_initialize_JVMCI() {</span>
<span class="line-removed">772   // Initializing JVMCI requires the module system to be initialized past phase 3.</span>
<span class="line-removed">773   // The JVMCI API itself isn&#39;t available until phase 2 and ServiceLoader (which</span>
<span class="line-removed">774   // JVMCI initialization requires) isn&#39;t usable until after phase 3. Testing</span>
<span class="line-removed">775   // whether the system loader is initialized satisfies all these invariants.</span>
<span class="line-removed">776   if (SystemDictionary::java_system_loader() == NULL) {</span>
<span class="line-removed">777     return false;</span>
<span class="line-removed">778   }</span>
<span class="line-removed">779   assert(Universe::is_module_initialized(), &quot;must be&quot;);</span>
<span class="line-removed">780   return true;</span>
781 }
782 
<a name="50" id="anc50"></a><span class="line-modified">783 void JVMCIRuntime::initialize_well_known_classes(TRAPS) {</span>
<span class="line-modified">784   if (JVMCIRuntime::_well_known_classes_initialized == false) {</span>
<span class="line-modified">785     guarantee(can_initialize_JVMCI(), &quot;VM is not yet sufficiently booted to initialize JVMCI&quot;);</span>
<span class="line-modified">786     SystemDictionary::WKID scan = SystemDictionary::FIRST_JVMCI_WKID;</span>
<span class="line-modified">787     SystemDictionary::resolve_wk_klasses_through(SystemDictionary::LAST_JVMCI_WKID, scan, CHECK);</span>
<span class="line-modified">788     JVMCIJavaClasses::compute_offsets(CHECK);</span>
<span class="line-modified">789     JVMCIRuntime::_well_known_classes_initialized = true;</span>

















790   }
791 }
792 
<a name="51" id="anc51"></a><span class="line-modified">793 void JVMCIRuntime::metadata_do(void f(Metadata*)) {</span>
<span class="line-modified">794   // For simplicity, the existence of HotSpotJVMCIMetaAccessContext in</span>
<span class="line-modified">795   // the SystemDictionary well known classes should ensure the other</span>
<span class="line-modified">796   // classes have already been loaded, so make sure their order in the</span>
<span class="line-modified">797   // table enforces that.</span>
<span class="line-modified">798   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotResolvedJavaMethodImpl) &lt;</span>
<span class="line-modified">799          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), &quot;must be loaded earlier&quot;);</span>
<span class="line-modified">800   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotConstantPool) &lt;</span>
<span class="line-removed">801          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), &quot;must be loaded earlier&quot;);</span>
<span class="line-removed">802   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotResolvedObjectTypeImpl) &lt;</span>
<span class="line-removed">803          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), &quot;must be loaded earlier&quot;);</span>
804 
<a name="52" id="anc52"></a><span class="line-modified">805   if (HotSpotJVMCIMetaAccessContext::klass() == NULL ||</span>
<span class="line-modified">806       !HotSpotJVMCIMetaAccessContext::klass()-&gt;is_linked()) {</span>
<span class="line-modified">807     // Nothing could be registered yet</span>







808     return;
809   }
810 
<a name="53" id="anc53"></a><span class="line-modified">811   // WeakReference&lt;HotSpotJVMCIMetaAccessContext&gt;[]</span>
<span class="line-modified">812   objArrayOop allContexts = HotSpotJVMCIMetaAccessContext::allContexts();</span>
<span class="line-modified">813   if (allContexts == NULL) {</span>
814     return;
815   }
816 
<a name="54" id="anc54"></a><span class="line-modified">817   // These must be loaded at this point but the linking state doesn&#39;t matter.</span>
<span class="line-modified">818   assert(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass() != NULL, &quot;must be loaded&quot;);</span>
<span class="line-modified">819   assert(SystemDictionary::HotSpotConstantPool_klass() != NULL, &quot;must be loaded&quot;);</span>
<span class="line-modified">820   assert(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass() != NULL, &quot;must be loaded&quot;);</span>
<span class="line-modified">821 </span>
<span class="line-modified">822   for (int i = 0; i &lt; allContexts-&gt;length(); i++) {</span>
<span class="line-modified">823     oop ref = allContexts-&gt;obj_at(i);</span>
<span class="line-modified">824     if (ref != NULL) {</span>
<span class="line-modified">825       oop referent = java_lang_ref_Reference::referent(ref);</span>
<span class="line-modified">826       if (referent != NULL) {</span>
<span class="line-modified">827         // Chunked Object[] with last element pointing to next chunk</span>
<span class="line-modified">828         objArrayOop metadataRoots = HotSpotJVMCIMetaAccessContext::metadataRoots(referent);</span>
<span class="line-modified">829         while (metadataRoots != NULL) {</span>
<span class="line-modified">830           for (int typeIndex = 0; typeIndex &lt; metadataRoots-&gt;length() - 1; typeIndex++) {</span>
<span class="line-modified">831             oop reference = metadataRoots-&gt;obj_at(typeIndex);</span>
<span class="line-modified">832             if (reference == NULL) {</span>
<span class="line-modified">833               continue;</span>
<span class="line-modified">834             }</span>
<span class="line-modified">835             oop metadataRoot = java_lang_ref_Reference::referent(reference);</span>
<span class="line-modified">836             if (metadataRoot == NULL) {</span>
<span class="line-modified">837               continue;</span>
<span class="line-modified">838             }</span>
<span class="line-modified">839             if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {</span>
<span class="line-modified">840               Method* method = CompilerToVM::asMethod(metadataRoot);</span>
<span class="line-removed">841               f(method);</span>
<span class="line-removed">842             } else if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {</span>
<span class="line-removed">843               ConstantPool* constantPool = CompilerToVM::asConstantPool(metadataRoot);</span>
<span class="line-removed">844               f(constantPool);</span>
<span class="line-removed">845             } else if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {</span>
<span class="line-removed">846               Klass* klass = CompilerToVM::asKlass(metadataRoot);</span>
<span class="line-removed">847               f(klass);</span>
<span class="line-removed">848             } else {</span>
<span class="line-removed">849               metadataRoot-&gt;print();</span>
<span class="line-removed">850               ShouldNotReachHere();</span>
<span class="line-removed">851             }</span>
<span class="line-removed">852           }</span>
<span class="line-removed">853           metadataRoots = (objArrayOop)metadataRoots-&gt;obj_at(metadataRoots-&gt;length() - 1);</span>
<span class="line-removed">854           assert(metadataRoots == NULL || metadataRoots-&gt;is_objArray(), &quot;wrong type&quot;);</span>
<span class="line-removed">855         }</span>
856       }
857     }
<a name="55" id="anc55"></a>












858   }
<a name="56" id="anc56"></a>



859 }
860 
<a name="57" id="anc57"></a><span class="line-modified">861 // private static void CompilerToVM.registerNatives()</span>
<span class="line-modified">862 JVM_ENTRY(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))</span>
<span class="line-modified">863   if (!EnableJVMCI) {</span>
<span class="line-modified">864     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;JVMCI is not enabled&quot;);</span>


















865   }
<a name="58" id="anc58"></a>
866 
<a name="59" id="anc59"></a><span class="line-modified">867 #ifdef _LP64</span>
<span class="line-modified">868 #ifndef SPARC</span>
<span class="line-modified">869   uintptr_t heap_end = (uintptr_t) Universe::heap()-&gt;reserved_region().end();</span>
<span class="line-modified">870   uintptr_t allocation_end = heap_end + ((uintptr_t)16) * 1024 * 1024 * 1024;</span>
<span class="line-modified">871   guarantee(heap_end &lt; allocation_end, &quot;heap end too close to end of address space (might lead to erroneous TLAB allocations)&quot;);</span>
<span class="line-modified">872 #endif // !SPARC</span>
<span class="line-modified">873 #else</span>
<span class="line-modified">874   fatal(&quot;check TLAB allocation code for address space conflicts&quot;);</span>
<span class="line-modified">875 #endif // _LP64</span>



876 
<a name="60" id="anc60"></a><span class="line-modified">877   JVMCIRuntime::initialize_well_known_classes(CHECK);</span>









878 
879   {
<a name="61" id="anc61"></a>

880     ThreadToNativeFromVM trans(thread);
<a name="62" id="anc62"></a><span class="line-modified">881     env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count());</span>
















882   }
883 JVM_END
884 
<a name="63" id="anc63"></a><span class="line-modified">885 void JVMCIRuntime::shutdown(TRAPS) {</span>
<span class="line-modified">886   if (_HotSpotJVMCIRuntime_instance != NULL) {</span>

887     _shutdown_called = true;
<a name="64" id="anc64"></a><span class="line-modified">888     HandleMark hm(THREAD);</span>
<span class="line-modified">889     Handle receiver = get_HotSpotJVMCIRuntime(CHECK);</span>
<span class="line-modified">890     JavaValue result(T_VOID);</span>
<span class="line-modified">891     JavaCallArguments args;</span>
<span class="line-modified">892     args.push_oop(receiver);</span>
<span class="line-modified">893     JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::shutdown_method_name(), vmSymbols::void_method_signature(), &amp;args, CHECK);</span>
<span class="line-modified">894   }</span>
<span class="line-modified">895 }</span>
<span class="line-modified">896 </span>
<span class="line-modified">897 CompLevel JVMCIRuntime::adjust_comp_level_inner(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread) {</span>
<span class="line-modified">898   JVMCICompiler* compiler = JVMCICompiler::instance(false, thread);</span>
<span class="line-modified">899   if (compiler != NULL &amp;&amp; compiler-&gt;is_bootstrapping()) {</span>
<span class="line-modified">900     return level;</span>
<span class="line-modified">901   }</span>
<span class="line-modified">902   if (!is_HotSpotJVMCIRuntime_initialized() || _comp_level_adjustment == JVMCIRuntime::none) {</span>
<span class="line-modified">903     // JVMCI cannot participate in compilation scheduling until</span>
<span class="line-modified">904     // JVMCI is initialized and indicates it wants to participate.</span>
<span class="line-modified">905     return level;</span>
<span class="line-modified">906   }</span>
<span class="line-modified">907 </span>
<span class="line-modified">908 #define CHECK_RETURN THREAD); \</span>
<span class="line-modified">909   if (HAS_PENDING_EXCEPTION) { \</span>
<span class="line-modified">910     Handle exception(THREAD, PENDING_EXCEPTION); \</span>
<span class="line-modified">911     CLEAR_PENDING_EXCEPTION; \</span>
<span class="line-modified">912   \</span>
<span class="line-modified">913     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) { \</span>
<span class="line-modified">914       /* In the special case of ThreadDeath, we need to reset the */ \</span>
<span class="line-modified">915       /* pending async exception so that it is propagated.        */ \</span>
<span class="line-modified">916       thread-&gt;set_pending_async_exception(exception()); \</span>
<span class="line-modified">917       return level; \</span>
<span class="line-modified">918     } \</span>
<span class="line-modified">919     tty-&gt;print(&quot;Uncaught exception while adjusting compilation level: &quot;); \</span>
<span class="line-modified">920     java_lang_Throwable::print(exception(), tty); \</span>
<span class="line-modified">921     tty-&gt;cr(); \</span>
<span class="line-modified">922     java_lang_Throwable::print_stack_trace(exception, tty); \</span>
<span class="line-modified">923     if (HAS_PENDING_EXCEPTION) { \</span>
<span class="line-modified">924       CLEAR_PENDING_EXCEPTION; \</span>
<span class="line-modified">925     } \</span>
<span class="line-modified">926     return level; \</span>
<span class="line-modified">927   } \</span>
<span class="line-modified">928   (void)(0</span>
<span class="line-modified">929 </span>
<span class="line-modified">930 </span>
<span class="line-modified">931   Thread* THREAD = thread;</span>
<span class="line-modified">932   HandleMark hm;</span>
<span class="line-modified">933   Handle receiver = JVMCIRuntime::get_HotSpotJVMCIRuntime(CHECK_RETURN);</span>
<span class="line-removed">934   Handle name;</span>
<span class="line-removed">935   Handle sig;</span>
<span class="line-removed">936   if (_comp_level_adjustment == JVMCIRuntime::by_full_signature) {</span>
<span class="line-removed">937     name = java_lang_String::create_from_symbol(method-&gt;name(), CHECK_RETURN);</span>
<span class="line-removed">938     sig = java_lang_String::create_from_symbol(method-&gt;signature(), CHECK_RETURN);</span>
939   } else {
<a name="65" id="anc65"></a><span class="line-modified">940     name = Handle();</span>
<span class="line-modified">941     sig = Handle();</span>
942   }
943 
<a name="66" id="anc66"></a><span class="line-modified">944   JavaValue result(T_INT);</span>
<span class="line-modified">945   JavaCallArguments args;</span>
<span class="line-modified">946   args.push_oop(receiver);</span>
<span class="line-modified">947   args.push_oop(Handle(THREAD, method-&gt;method_holder()-&gt;java_mirror()));</span>
<span class="line-modified">948   args.push_oop(name);</span>
<span class="line-modified">949   args.push_oop(sig);</span>
<span class="line-modified">950   args.push_int(is_osr);</span>
<span class="line-modified">951   args.push_int(level);</span>
<span class="line-modified">952   JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::adjustCompilationLevel_name(),</span>
<span class="line-modified">953                           vmSymbols::adjustCompilationLevel_signature(), &amp;args, CHECK_RETURN);</span>




954 
<a name="67" id="anc67"></a><span class="line-modified">955   int comp_level = result.get_jint();</span>
<span class="line-modified">956   if (comp_level &lt; CompLevel_none || comp_level &gt; CompLevel_full_optimization) {</span>
<span class="line-modified">957     assert(false, &quot;compilation level out of bounds&quot;);</span>
<span class="line-removed">958     return level;</span>
959   }
<a name="68" id="anc68"></a><span class="line-modified">960   return (CompLevel) comp_level;</span>
<span class="line-modified">961 #undef CHECK_RETURN</span>




962 }
963 
<a name="69" id="anc69"></a><span class="line-modified">964 void JVMCIRuntime::bootstrap_finished(TRAPS) {</span>
<span class="line-modified">965   HandleMark hm(THREAD);</span>
<span class="line-modified">966   Handle receiver = get_HotSpotJVMCIRuntime(CHECK);</span>
<span class="line-modified">967   JavaValue result(T_VOID);</span>
<span class="line-modified">968   JavaCallArguments args;</span>
<span class="line-modified">969   args.push_oop(receiver);</span>
<span class="line-modified">970   JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::bootstrapFinished_method_name(), vmSymbols::void_method_signature(), &amp;args, CHECK);</span>



































































































































































































































































































































































































































































































































































































971 }
<a name="70" id="anc70"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="70" type="hidden" />
</body>
</html>
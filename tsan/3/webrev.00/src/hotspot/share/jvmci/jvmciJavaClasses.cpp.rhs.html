<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciJavaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;classfile/symbolTable.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 26 #include &quot;interpreter/linkResolver.hpp&quot;</span>
<span class="line-added"> 27 #include &quot;jvmci/jniAccessMark.inline.hpp&quot;</span>
 28 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added"> 29 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
 30 #include &quot;memory/resourceArea.hpp&quot;
<a name="4" id="anc4"></a>
 31 #include &quot;runtime/jniHandles.inline.hpp&quot;
 32 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 33 
<a name="5" id="anc5"></a><span class="line-added"> 34 // ------------------------------------------------------------------</span>
 35 
<a name="6" id="anc6"></a><span class="line-modified"> 36 oop HotSpotJVMCI::resolve(JVMCIObject obj) {</span>
<span class="line-added"> 37   return JNIHandles::resolve(obj.as_jobject());</span>
<span class="line-added"> 38 }</span>
 39 
<a name="7" id="anc7"></a><span class="line-modified"> 40 arrayOop HotSpotJVMCI::resolve(JVMCIArray obj) {</span>
<span class="line-modified"> 41   return (arrayOop) JNIHandles::resolve(obj.as_jobject());</span>
<span class="line-modified"> 42 }</span>
<span class="line-modified"> 43 </span>
<span class="line-modified"> 44 objArrayOop HotSpotJVMCI::resolve(JVMCIObjectArray obj) {</span>
<span class="line-modified"> 45   return (objArrayOop) JNIHandles::resolve(obj.as_jobject());</span>
<span class="line-added"> 46 }</span>
<span class="line-added"> 47 </span>
<span class="line-added"> 48 typeArrayOop HotSpotJVMCI::resolve(JVMCIPrimitiveArray obj) {</span>
<span class="line-added"> 49   return (typeArrayOop) JNIHandles::resolve(obj.as_jobject());</span>
<span class="line-added"> 50 }</span>
<span class="line-added"> 51 </span>
<span class="line-added"> 52 JVMCIObject HotSpotJVMCI::wrap(oop obj) {</span>
<span class="line-added"> 53   assert(Thread::current()-&gt;is_Java_thread(), &quot;must be&quot;);</span>
<span class="line-added"> 54   return JVMCIObject(JNIHandles::make_local(obj), true);</span>
<span class="line-added"> 55 }</span>
<span class="line-added"> 56 </span>
<span class="line-added"> 57 /**</span>
<span class="line-added"> 58  * Computes the field offset of a static or instance field.</span>
<span class="line-added"> 59  * It looks up the name and signature symbols without creating new ones;</span>
<span class="line-added"> 60  * all the symbols of these classes need to be already loaded.</span>
<span class="line-added"> 61  */</span>
<span class="line-added"> 62 void HotSpotJVMCI::compute_offset(int &amp;dest_offset, Klass* klass, const char* name, const char* signature, bool static_field, TRAPS) {</span>
<span class="line-added"> 63   InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-added"> 64   Symbol* name_symbol = SymbolTable::probe(name, (int)strlen(name));</span>
<span class="line-added"> 65   Symbol* signature_symbol = SymbolTable::probe(signature, (int)strlen(signature));</span>
<span class="line-added"> 66   if (name_symbol == NULL || signature_symbol == NULL) {</span>
<span class="line-added"> 67 #ifndef PRODUCT</span>
<span class="line-added"> 68     ik-&gt;print_on(tty);</span>
<span class="line-added"> 69 #endif</span>
<span class="line-added"> 70     fatal(&quot;symbol with name %s and signature %s was not found in symbol table (klass=%s)&quot;, name, signature, klass-&gt;name()-&gt;as_C_string());</span>
<span class="line-added"> 71   }</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73   fieldDescriptor fd;</span>
<span class="line-added"> 74   if (!ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd)) {</span>
<span class="line-added"> 75     ResourceMark rm;</span>
<span class="line-added"> 76     fatal(&quot;Could not find field %s.%s with signature %s&quot;, ik-&gt;external_name(), name, signature);</span>
<span class="line-added"> 77   }</span>
<span class="line-added"> 78   guarantee(fd.is_static() == static_field, &quot;static/instance mismatch&quot;);</span>
<span class="line-added"> 79   dest_offset = fd.offset();</span>
<span class="line-added"> 80   assert(dest_offset != 0, &quot;must be valid offset&quot;);</span>
<span class="line-added"> 81   if (static_field) {</span>
<span class="line-added"> 82     // Must ensure classes for static fields are initialized as the</span>
<span class="line-added"> 83     // accessor itself does not include a class initialization check.</span>
<span class="line-added"> 84     ik-&gt;initialize(CHECK);</span>
<span class="line-added"> 85   }</span>
<span class="line-added"> 86 }</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88 #ifndef PRODUCT</span>
<span class="line-added"> 89 static void check_resolve_method(const char* call_type, Klass* resolved_klass, Symbol* method_name, Symbol* method_signature, TRAPS) {</span>
<span class="line-added"> 90   Method* method;</span>
<span class="line-added"> 91   LinkInfo link_info(resolved_klass, method_name, method_signature, NULL, LinkInfo::skip_access_check);</span>
<span class="line-added"> 92   if (strcmp(call_type, &quot;call_static&quot;) == 0) {</span>
<span class="line-added"> 93     method = LinkResolver::resolve_static_call_or_null(link_info);</span>
<span class="line-added"> 94   } else if (strcmp(call_type, &quot;call_virtual&quot;) == 0) {</span>
<span class="line-added"> 95     method = LinkResolver::resolve_virtual_call_or_null(resolved_klass, link_info);</span>
<span class="line-added"> 96   } else if (strcmp(call_type, &quot;call_special&quot;) == 0) {</span>
<span class="line-added"> 97     method = LinkResolver::resolve_special_call_or_null(link_info);</span>
<span class="line-added"> 98   } else {</span>
<span class="line-added"> 99     fatal(&quot;Unknown or unsupported call type: %s&quot;, call_type);</span>
<span class="line-added">100   }</span>
<span class="line-added">101   if (method == NULL) {</span>
<span class="line-added">102     fatal(&quot;Could not resolve %s.%s%s&quot;, resolved_klass-&gt;external_name(), method_name-&gt;as_C_string(), method_signature-&gt;as_C_string());</span>
<span class="line-added">103   }</span>
<span class="line-added">104 }</span>
<span class="line-added">105 #endif</span>
<span class="line-added">106 </span>
<span class="line-added">107 jclass JNIJVMCI::_box_classes[T_CONFLICT+1];</span>
<span class="line-added">108 jclass JNIJVMCI::_byte_array;</span>
<span class="line-added">109 jfieldID JNIJVMCI::_box_fields[T_CONFLICT+1];</span>
<span class="line-added">110 jmethodID JNIJVMCI::_box_constructors[T_CONFLICT+1];</span>
<span class="line-added">111 jmethodID JNIJVMCI::_Class_getName_method;</span>
<span class="line-added">112 </span>
<span class="line-added">113 jmethodID JNIJVMCI::_HotSpotResolvedJavaMethodImpl_fromMetaspace_method;</span>
<span class="line-added">114 jmethodID JNIJVMCI::_HotSpotConstantPool_fromMetaspace_method;</span>
<span class="line-added">115 jmethodID JNIJVMCI::_HotSpotResolvedObjectTypeImpl_fromMetaspace_method;</span>
<span class="line-added">116 jmethodID JNIJVMCI::_HotSpotResolvedPrimitiveType_fromMetaspace_method;</span>
<span class="line-added">117 </span>
<span class="line-added">118 #define START_CLASS(className, fullClassName)                          { \</span>
<span class="line-added">119   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::fullClassName(), true, CHECK); \</span>
<span class="line-added">120   className::_klass = InstanceKlass::cast(k); \</span>
<span class="line-added">121   className::_klass-&gt;initialize(CHECK);</span>
<span class="line-added">122 </span>
<span class="line-added">123 #define END_CLASS }</span>
<span class="line-added">124 </span>
<span class="line-added">125 #define FIELD(className, name, signature, static_field) compute_offset(className::_##name##_offset, className::_klass, #name, signature, static_field, CHECK);</span>
<span class="line-added">126 #define CHAR_FIELD(className, name) FIELD(className, name, &quot;C&quot;, false)</span>
<span class="line-added">127 #define INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, false)</span>
<span class="line-added">128 #define BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, false)</span>
<span class="line-added">129 #define LONG_FIELD(className, name) FIELD(className, name, &quot;J&quot;, false)</span>
<span class="line-added">130 #define FLOAT_FIELD(className, name) FIELD(className, name, &quot;F&quot;, false)</span>
<span class="line-added">131 #define OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, false)</span>
<span class="line-added">132 #define STATIC_OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, true)</span>
<span class="line-added">133 #define STATIC_INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, true)</span>
<span class="line-added">134 #define STATIC_BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, true)</span>
<span class="line-added">135 #ifdef PRODUCT</span>
<span class="line-added">136 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)</span>
<span class="line-added">137 #define CONSTRUCTOR(className, signature)</span>
<span class="line-added">138 #else</span>
<span class="line-added">139 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \</span>
<span class="line-added">140   check_resolve_method(#hsCallType, k, vmSymbols::methodName##_name(), vmSymbols::signatureSymbolName(), CHECK);</span>
<span class="line-added">141 #define CONSTRUCTOR(className, signature) { \</span>
<span class="line-added">142   TempNewSymbol sig = SymbolTable::new_symbol(signature); \</span>
<span class="line-added">143   check_resolve_method(&quot;call_special&quot;, k, vmSymbols::object_initializer_name(), sig, CHECK); \</span>
<span class="line-added">144   }</span>
<span class="line-added">145 #endif</span>
<span class="line-added">146 /**</span>
<span class="line-added">147  * Computes and initializes the offsets used by HotSpotJVMCI.</span>
<span class="line-added">148  */</span>
<span class="line-added">149 void HotSpotJVMCI::compute_offsets(TRAPS) {</span>
<span class="line-added">150   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, OBJECT_FIELD, OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
<span class="line-added">151 }</span>
<span class="line-added">152 </span>
<span class="line-added">153 #undef START_CLASS</span>
<span class="line-added">154 #undef END_CLASS</span>
<span class="line-added">155 #undef METHOD</span>
<span class="line-added">156 #undef CONSTRUCTOR</span>
<span class="line-added">157 #undef FIELD</span>
<span class="line-added">158 #undef CHAR_FIELD</span>
<span class="line-added">159 #undef INT_FIELD</span>
<span class="line-added">160 #undef BOOLEAN_FIELD</span>
<span class="line-added">161 #undef LONG_FIELD</span>
<span class="line-added">162 #undef FLOAT_FIELD</span>
<span class="line-added">163 #undef OBJECT_FIELD</span>
<span class="line-added">164 #undef PRIMARRAY_FIELD</span>
<span class="line-added">165 #undef OBJECTARRAY_FIELD</span>
<span class="line-added">166 #undef STATIC_FIELD</span>
<span class="line-added">167 #undef STATIC_OBJECT_FIELD</span>
<span class="line-added">168 #undef STATIC_OBJECTARRAY_FIELD</span>
<span class="line-added">169 #undef STATIC_INT_FIELD</span>
<span class="line-added">170 #undef STATIC_BOOLEAN_FIELD</span>
<span class="line-added">171 #undef EMPTY_CAST</span>
<span class="line-added">172 </span>
<span class="line-added">173 // ------------------------------------------------------------------</span>
<span class="line-added">174 </span>
<span class="line-added">175 #define START_CLASS(className, fullClassName)                                           \</span>
<span class="line-added">176   void HotSpotJVMCI::className::initialize(JVMCI_TRAPS) {                               \</span>
<span class="line-added">177     Thread* THREAD = Thread::current();                                                 \</span>
<span class="line-added">178     className::klass()-&gt;initialize(CHECK);                                              \</span>
<span class="line-added">179   }                                                                                     \</span>
<span class="line-added">180   bool HotSpotJVMCI::className::is_instance(JVMCIEnv* env, JVMCIObject object) {        \</span>
<span class="line-added">181     return resolve(object)-&gt;is_a(className::klass());                                   \</span>
<span class="line-added">182   }                                                                                     \</span>
<span class="line-added">183   void HotSpotJVMCI::className::check(oop obj, const char* field_name, int offset) {    \</span>
<span class="line-added">184     assert(obj != NULL, &quot;NULL field access of %s.%s&quot;, #className, field_name); \</span>
<span class="line-added">185     assert(obj-&gt;is_a(className::klass()), &quot;wrong class, &quot; #className &quot; expected, found %s&quot;, obj-&gt;klass()-&gt;external_name()); \</span>
<span class="line-added">186     assert(offset != 0, &quot;must be valid offset&quot;);                                        \</span>
<span class="line-added">187   }                                                                                     \</span>
<span class="line-added">188   InstanceKlass* HotSpotJVMCI::className::_klass = NULL;</span>
189 
190 #define END_CLASS
191 
<a name="8" id="anc8"></a><span class="line-modified">192 #define FIELD(className, name, type, accessor, cast)                     \</span>
<span class="line-modified">193   type HotSpotJVMCI::className::name(JVMCIEnv* env, oop obj)               { className::check(obj, #name, className::_##name##_offset); return cast obj-&gt;accessor(className::_##name##_offset); } \</span>
<span class="line-modified">194   void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, oop obj, type x) { className::check(obj, #name, className::_##name##_offset); obj-&gt;accessor##_put(className::_##name##_offset, x); }</span>
195 
196 #define EMPTY_CAST
<a name="9" id="anc9"></a><span class="line-modified">197 #define CHAR_FIELD(className, name) FIELD(className, name, jchar, char_field, EMPTY_CAST)</span>
<span class="line-modified">198 #define INT_FIELD(className, name) FIELD(className, name, jint, int_field, EMPTY_CAST)</span>
<span class="line-modified">199 #define BOOLEAN_FIELD(className, name) FIELD(className, name, jboolean, bool_field, EMPTY_CAST)</span>
<span class="line-modified">200 #define LONG_FIELD(className, name) FIELD(className, name, jlong, long_field, EMPTY_CAST)</span>
<span class="line-modified">201 #define FLOAT_FIELD(className, name) FIELD(className, name, jfloat, float_field, EMPTY_CAST)</span>
<span class="line-modified">202 </span>
<span class="line-modified">203 #define OBJECT_FIELD(className, name, signature) FIELD(className, name, oop, obj_field, EMPTY_CAST)</span>
<span class="line-modified">204 #define OBJECTARRAY_FIELD(className, name, signature) FIELD(className, name, objArrayOop, obj_field, (objArrayOop))</span>
<span class="line-modified">205 #define PRIMARRAY_FIELD(className, name, signature) FIELD(className, name, typeArrayOop, obj_field, (typeArrayOop))</span>
<span class="line-modified">206 #define STATIC_OBJECT_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, oop)</span>
<span class="line-modified">207 #define STATIC_OBJECTARRAY_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, objArrayOop)</span>
<span class="line-modified">208 #define STATIC_OOPISH_FIELD(className, name, type)                                                                        \</span>
<span class="line-modified">209     type HotSpotJVMCI::className::name(JVMCIEnv* env) {                                                                   \</span>
<span class="line-modified">210       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \</span>
<span class="line-modified">211       InstanceKlass* ik = className::klass();                                                                             \</span>
<span class="line-modified">212       oop base = ik-&gt;static_field_base_raw();                                                                             \</span>
<span class="line-modified">213       oop result = HeapAccess&lt;&gt;::oop_load_at(base, className::_##name##_offset);                                          \</span>
<span class="line-modified">214       return type(result);                                                                                                \</span>
<span class="line-modified">215     }                                                                                                                     \</span>
<span class="line-modified">216     void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, type x) {                                                     \</span>
<span class="line-modified">217       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \</span>
<span class="line-modified">218       assert(className::klass() != NULL, &quot;Class not yet loaded: &quot; #className);                                            \</span>
<span class="line-modified">219       InstanceKlass* ik = className::klass();                                                                             \</span>
<span class="line-modified">220       oop base = ik-&gt;static_field_base_raw();                                                                             \</span>
<span class="line-added">221       HeapAccess&lt;&gt;::oop_store_at(base, className::_##name##_offset, x);                                                   \</span>
222     }
<a name="10" id="anc10"></a><span class="line-modified">223 #define STATIC_PRIMITIVE_FIELD(className, name, jtypename)                                                                \</span>
<span class="line-modified">224     jtypename HotSpotJVMCI::className::get_##name(JVMCIEnv* env) {                                                        \</span>
<span class="line-modified">225       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \</span>
<span class="line-modified">226       InstanceKlass* ik = className::klass();                                                                             \</span>
<span class="line-modified">227       oop base = ik-&gt;static_field_base_raw();                                                                             \</span>
<span class="line-modified">228       return HeapAccess&lt;&gt;::load_at(base, className::_##name##_offset);                                                    \</span>
<span class="line-modified">229     }                                                                                                                     \</span>
<span class="line-modified">230     void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, jtypename x) {                                                \</span>
<span class="line-modified">231       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \</span>
<span class="line-modified">232       InstanceKlass* ik = className::klass();                                                                             \</span>
<span class="line-modified">233       oop base = ik-&gt;static_field_base_raw();                                                                             \</span>
<span class="line-modified">234       HeapAccess&lt;&gt;::store_at(base, _##name##_offset, x);                                                                  \</span>
235     }
236 
<a name="11" id="anc11"></a><span class="line-modified">237 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint)</span>
<span class="line-modified">238 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean)</span>
<span class="line-added">239 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)</span>
<span class="line-added">240 #define CONSTRUCTOR(className, signature)</span>
<span class="line-added">241 </span>
<span class="line-added">242 /**</span>
<span class="line-added">243  * Generates the method and field definitions for the classes in HotSpotJVMCI. For example:</span>
<span class="line-added">244  *</span>
<span class="line-added">245  * void HotSpotJVMCI::Architecture::initialize(JVMCIEnv* env) { ... }</span>
<span class="line-added">246  * bool HotSpotJVMCI::Architecture::is_instance(JVMCIEnv* env, JVMCIObject object) { ... }</span>
<span class="line-added">247  * void HotSpotJVMCI::Architecture::check(oop obj, const char* field_name, int offset) { ... }</span>
<span class="line-added">248  *  oop HotSpotJVMCI::Architecture::wordKind(JVMCIEnv* env, oop obj) { ... }</span>
<span class="line-added">249  * void HotSpotJVMCI::Architecture::set_wordKind(JVMCIEnv* env, oop obj, oop x) { ... }</span>
<span class="line-added">250  *</span>
<span class="line-added">251  * InstanceKlass *HotSpotJVMCI::Architecture::_klass = NULL;</span>
<span class="line-added">252  */</span>
<span class="line-added">253 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
254 
<a name="12" id="anc12"></a>
255 #undef START_CLASS
256 #undef END_CLASS
<a name="13" id="anc13"></a><span class="line-added">257 #undef METHOD</span>
<span class="line-added">258 #undef CONSTRUCTOR</span>
259 #undef FIELD
260 #undef CHAR_FIELD
261 #undef INT_FIELD
262 #undef BOOLEAN_FIELD
263 #undef LONG_FIELD
264 #undef FLOAT_FIELD
<a name="14" id="anc14"></a><span class="line-modified">265 #undef OBJECT_FIELD</span>
<span class="line-modified">266 #undef PRIMARRAY_FIELD</span>
<span class="line-modified">267 #undef OBJECTARRAY_FIELD</span>
268 #undef STATIC_OOPISH_FIELD
<a name="15" id="anc15"></a><span class="line-modified">269 #undef STATIC_OBJECT_FIELD</span>
<span class="line-modified">270 #undef STATIC_OBJECTARRAY_FIELD</span>
271 #undef STATIC_INT_FIELD
272 #undef STATIC_BOOLEAN_FIELD
273 #undef STATIC_PRIMITIVE_FIELD
274 #undef EMPTY_CAST
275 
<a name="16" id="anc16"></a><span class="line-modified">276 /**</span>
<span class="line-modified">277  * Initializes the JNI id of a field. As per the JNI specification,</span>
<span class="line-modified">278  * this ensures the declaring class is initialized.</span>
<span class="line-modified">279  */</span>
<span class="line-modified">280 void JNIJVMCI::initialize_field_id(JNIEnv* env, jfieldID &amp;fieldid, jclass clazz, const char* class_name, const char* name, const char* signature, bool static_field) {</span>
<span class="line-modified">281   if (JVMCILibDumpJNIConfig != NULL) {</span>
<span class="line-modified">282     fileStream* st = JVMCIGlobals::get_jni_config_file();</span>
<span class="line-modified">283     st-&gt;print_cr(&quot;field %s %s %s&quot;, class_name, name, signature);</span>
<span class="line-modified">284     return;</span>
<span class="line-modified">285   }</span>
<span class="line-modified">286   if (env-&gt;ExceptionCheck()) {</span>
<span class="line-modified">287     return;</span>
<span class="line-added">288   }</span>
<span class="line-added">289   if (static_field) {</span>
<span class="line-added">290     // Class initialization barrier</span>
<span class="line-added">291     fieldid = env-&gt;GetStaticFieldID(clazz, name, signature);</span>
<span class="line-added">292   } else {</span>
<span class="line-added">293     // Class initialization barrier</span>
<span class="line-added">294     fieldid = env-&gt;GetFieldID(clazz, name, signature);</span>
295   }
296 
<a name="17" id="anc17"></a><span class="line-modified">297   if (env-&gt;ExceptionCheck()) {</span>
<span class="line-modified">298     env-&gt;ExceptionDescribe();</span>
<span class="line-added">299     env-&gt;ExceptionClear();</span>
300     ResourceMark rm;
<a name="18" id="anc18"></a><span class="line-modified">301     Thread* THREAD = Thread::current();</span>
<span class="line-added">302     fatal(&quot;Could not find field %s.%s with signature %s&quot;, class_name, name, signature);</span>
303   }
<a name="19" id="anc19"></a><span class="line-modified">304 }</span>
<span class="line-modified">305 </span>
<span class="line-modified">306 #define START_CLASS(className, fullClassName) {                                             \</span>
<span class="line-modified">307   current_class_name = vmSymbols::fullClassName()-&gt;as_C_string();                           \</span>
<span class="line-modified">308   if (JVMCILibDumpJNIConfig != NULL) {                                                      \</span>
<span class="line-modified">309     fileStream* st = JVMCIGlobals::get_jni_config_file();                                   \</span>
<span class="line-modified">310     st-&gt;print_cr(&quot;class %s&quot;, current_class_name);                                           \</span>
<span class="line-added">311   } else {                                                                                  \</span>
<span class="line-added">312     jclass k = env-&gt;FindClass(current_class_name);                                          \</span>
<span class="line-added">313     JVMCI_EXCEPTION_CHECK(env, &quot;FindClass(%s)&quot;, current_class_name);                        \</span>
<span class="line-added">314     assert(k != NULL, #fullClassName &quot; not initialized&quot;);                                   \</span>
<span class="line-added">315     className::_class = (jclass) env-&gt;NewGlobalRef(k);                                      \</span>
316   }
<a name="20" id="anc20"></a><span class="line-added">317 </span>
<span class="line-added">318 #define END_CLASS current_class_name = NULL; }</span>
<span class="line-added">319 </span>
<span class="line-added">320 #define FIELD(className, name, signature, static_field) initialize_field_id(env, className::_##name##_field_id, className::_class, current_class_name, #name, signature, static_field);</span>
<span class="line-added">321 #define CHAR_FIELD(className, name) FIELD(className, name, &quot;C&quot;, false)</span>
<span class="line-added">322 #define INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, false)</span>
<span class="line-added">323 #define BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, false)</span>
<span class="line-added">324 #define LONG_FIELD(className, name) FIELD(className, name, &quot;J&quot;, false)</span>
<span class="line-added">325 #define FLOAT_FIELD(className, name) FIELD(className, name, &quot;F&quot;, false)</span>
<span class="line-added">326 #define OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, false)</span>
<span class="line-added">327 #define STATIC_OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, true)</span>
<span class="line-added">328 #define STATIC_INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, true)</span>
<span class="line-added">329 #define STATIC_BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, true)</span>
<span class="line-added">330 </span>
<span class="line-added">331 #define GET_JNI_METHOD(jniGetMethod, dst, clazz, methodName, signature)                        \</span>
<span class="line-added">332           if (JVMCILibDumpJNIConfig != NULL) {                                                       \</span>
<span class="line-added">333             fileStream* st = JVMCIGlobals::get_jni_config_file();                                    \</span>
<span class="line-added">334             st-&gt;print_cr(&quot;method %s %s %s&quot;, current_class_name, methodName, signature);              \</span>
<span class="line-added">335           } else {                                                                                   \</span>
<span class="line-added">336                   dst = env-&gt;jniGetMethod(clazz, methodName, signature);                                   \</span>
<span class="line-added">337                   JVMCI_EXCEPTION_CHECK(env, #jniGetMethod &quot;(%s.%s%s)&quot;, current_class_name, methodName, signature); \</span>
<span class="line-added">338                 assert(dst != NULL, &quot;uninitialized&quot;);                                          \</span>
<span class="line-added">339           }</span>
<span class="line-added">340 </span>
<span class="line-added">341 #define GET_JNI_CONSTRUCTOR(clazz, signature) \</span>
<span class="line-added">342   GET_JNI_METHOD(GetMethodID, JNIJVMCI::clazz::_constructor, clazz::_class, &quot;&lt;init&gt;&quot;, signature) \</span>
<span class="line-added">343 </span>
<span class="line-added">344 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \</span>
<span class="line-added">345      GET_JNI_METHOD(jniGetMethod,                                        \</span>
<span class="line-added">346                     className::_##methodName##_method,                   \</span>
<span class="line-added">347                     className::clazz(),                                  \</span>
<span class="line-added">348                     vmSymbols::methodName##_name()-&gt;as_C_string(),       \</span>
<span class="line-added">349                     vmSymbols::signatureSymbolName()-&gt;as_C_string())</span>
<span class="line-added">350 </span>
<span class="line-added">351 #define CONSTRUCTOR(className, signature) \</span>
<span class="line-added">352   GET_JNI_CONSTRUCTOR(className, signature)</span>
<span class="line-added">353 </span>
<span class="line-added">354 extern &quot;C&quot; {</span>
<span class="line-added">355   void     JNICALL JVM_RegisterJVMCINatives(JNIEnv *env, jclass compilerToVMClass);</span>
<span class="line-added">356   jobject  JNICALL JVM_GetJVMCIRuntime(JNIEnv *env, jclass c);</span>
357 }
358 
<a name="21" id="anc21"></a><span class="line-modified">359 // Dumps symbols for public &lt;init&gt;() and &lt;init&gt;(String) methods of</span>
<span class="line-added">360 // non-abstract Throwable subtypes known by the VM. This is to</span>
<span class="line-added">361 // support the use of reflection in jdk.vm.ci.hotspot.TranslatedException.create().</span>
<span class="line-added">362 class ThrowableInitDumper : public SymbolClosure {</span>
<span class="line-added">363  private:</span>
<span class="line-added">364   fileStream* _st;</span>
<span class="line-added">365  public:</span>
<span class="line-added">366   ThrowableInitDumper(fileStream* st)     { _st = st; }</span>
<span class="line-added">367   void do_symbol(Symbol** p) {</span>
<span class="line-added">368     Thread* THREAD = Thread::current();</span>
<span class="line-added">369     Symbol* name = *p;</span>
<span class="line-added">370     if (name == NULL) {</span>
<span class="line-added">371       return;</span>
<span class="line-added">372     }</span>
<span class="line-added">373     Klass* k = SystemDictionary::resolve_or_null(name, CHECK_EXIT);</span>
<span class="line-added">374     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {</span>
<span class="line-added">375       InstanceKlass* iklass = InstanceKlass::cast(k);</span>
<span class="line-added">376       if (iklass-&gt;is_subclass_of(SystemDictionary::Throwable_klass()) &amp;&amp; iklass-&gt;is_public() &amp;&amp; !iklass-&gt;is_abstract()) {</span>
<span class="line-added">377         const char* class_name = NULL;</span>
<span class="line-added">378         Array&lt;Method*&gt;* methods = iklass-&gt;methods();</span>
<span class="line-added">379         for (int i = 0; i &lt; methods-&gt;length(); i++) {</span>
<span class="line-added">380           Method* m = methods-&gt;at(i);</span>
<span class="line-added">381           if (m-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
<span class="line-added">382               m-&gt;is_public() &amp;&amp;</span>
<span class="line-added">383               (m-&gt;signature() == vmSymbols::void_method_signature() || m-&gt;signature() == vmSymbols::string_void_signature())) {</span>
<span class="line-added">384             if (class_name == NULL) {</span>
<span class="line-added">385               class_name = name-&gt;as_C_string();</span>
<span class="line-added">386               _st-&gt;print_cr(&quot;class %s&quot;, class_name);</span>
<span class="line-added">387             }</span>
<span class="line-added">388             _st-&gt;print_cr(&quot;method %s %s %s&quot;, class_name, m-&gt;name()-&gt;as_C_string(), m-&gt;signature()-&gt;as_C_string());</span>
<span class="line-added">389           }</span>
<span class="line-added">390         }</span>
<span class="line-added">391       }</span>
<span class="line-added">392     }</span>
<span class="line-added">393   }</span>
<span class="line-added">394 };</span>
395 
<a name="22" id="anc22"></a><span class="line-modified">396 #define IN_CLASS(fullClassName) current_class_name = vmSymbols::fullClassName()-&gt;as_C_string()</span>
<span class="line-added">397 /**</span>
<span class="line-added">398  * Initializes the JNI method and field ids used in JNIJVMCI.</span>
<span class="line-added">399  */</span>
<span class="line-added">400 void JNIJVMCI::initialize_ids(JNIEnv* env) {</span>
<span class="line-added">401   ResourceMark rm;</span>
<span class="line-added">402   const char* current_class_name = NULL;</span>
<span class="line-added">403   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, OBJECT_FIELD, OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
404 
<a name="23" id="anc23"></a><span class="line-modified">405   IN_CLASS(java_lang_Class);</span>
<span class="line-added">406   GET_JNI_METHOD(GetMethodID, _Class_getName_method, Class::_class, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);</span>
407 
<a name="24" id="anc24"></a><span class="line-modified">408   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedPrimitiveType);</span>
<span class="line-modified">409   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedPrimitiveType_fromMetaspace_method, HotSpotResolvedPrimitiveType::_class,</span>
<span class="line-modified">410                                                                                           vmSymbols::fromMetaspace_name()-&gt;as_C_string(),</span>
<span class="line-modified">411                                                                                           vmSymbols::primitive_fromMetaspace_signature()-&gt;as_C_string());</span>
<span class="line-modified">412   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedObjectTypeImpl);</span>
<span class="line-modified">413   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedObjectTypeImpl_fromMetaspace_method, HotSpotResolvedObjectTypeImpl::_class,</span>
<span class="line-modified">414                                                                                            vmSymbols::fromMetaspace_name()-&gt;as_C_string(),</span>
<span class="line-modified">415                                                                                            vmSymbols::klass_fromMetaspace_signature()-&gt;as_C_string());</span>
<span class="line-modified">416   IN_CLASS(jdk_vm_ci_hotspot_HotSpotConstantPool);</span>
<span class="line-modified">417   GET_JNI_METHOD(GetStaticMethodID, _HotSpotConstantPool_fromMetaspace_method, HotSpotConstantPool::_class,</span>
<span class="line-added">418                                                                                   vmSymbols::fromMetaspace_name()-&gt;as_C_string(),</span>
<span class="line-added">419                                                                                   vmSymbols::constantPool_fromMetaspace_signature()-&gt;as_C_string());</span>
<span class="line-added">420   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedJavaMethodImpl);</span>
<span class="line-added">421   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedJavaMethodImpl_fromMetaspace_method, HotSpotResolvedJavaMethodImpl::_class,</span>
<span class="line-added">422                                                                                            vmSymbols::fromMetaspace_name()-&gt;as_C_string(),</span>
<span class="line-added">423                                                                                            vmSymbols::method_fromMetaspace_signature()-&gt;as_C_string());</span>
424 
<a name="25" id="anc25"></a><span class="line-added">425 #define BOX_CLASSES(generate)     \</span>
<span class="line-added">426   generate(Boolean, T_BOOLEAN, Z) \</span>
<span class="line-added">427   generate(Byte, T_BYTE, B)       \</span>
<span class="line-added">428   generate(Character, T_CHAR, C)  \</span>
<span class="line-added">429   generate(Short, T_SHORT, S)     \</span>
<span class="line-added">430   generate(Integer, T_INT, I)     \</span>
<span class="line-added">431   generate(Long, T_LONG, J)       \</span>
<span class="line-added">432   generate(Float, T_FLOAT, F)     \</span>
<span class="line-added">433   generate(Double, T_DOUBLE, D)   \</span>
434 
<a name="26" id="anc26"></a><span class="line-modified">435 #define DO_BOX_CLASS(klass, basicType, type) \</span>
<span class="line-modified">436   current_class_name = &quot;java/lang/&quot; #klass;                                                                       \</span>
<span class="line-added">437   if (JVMCILibDumpJNIConfig == NULL) {                                                                            \</span>
<span class="line-added">438     _box_classes[basicType] = env-&gt;FindClass(&quot;java/lang/&quot; #klass);                                                \</span>
<span class="line-added">439     JVMCI_EXCEPTION_CHECK(env, &quot;FindClass(%s)&quot;, #klass);                                                          \</span>
<span class="line-added">440     _box_classes[basicType] = (jclass) env-&gt;NewGlobalRef(_box_classes[basicType]);                                \</span>
<span class="line-added">441     assert(_box_classes[basicType] != NULL, &quot;uninitialized&quot;);                                                     \</span>
<span class="line-added">442     _box_fields[basicType] = env-&gt;GetFieldID(_box_classes[basicType], &quot;value&quot;, #type);                            \</span>
<span class="line-added">443     JVMCI_EXCEPTION_CHECK(env, &quot;GetFieldID(%s, value, %s)&quot;, #klass, #type);                                       \</span>
<span class="line-added">444     GET_JNI_METHOD(GetMethodID, _box_constructors[basicType], _box_classes[basicType], &quot;&lt;init&gt;&quot;, &quot;(&quot; #type &quot;)V&quot;); \</span>
<span class="line-added">445   } else {                                                                                                        \</span>
<span class="line-added">446     fileStream* st = JVMCIGlobals::get_jni_config_file();                                                         \</span>
<span class="line-added">447     st-&gt;print_cr(&quot;field %s value %s&quot;, current_class_name, #type);                                                 \</span>
<span class="line-added">448     st-&gt;print_cr(&quot;method %s &lt;init&gt; (%s)V&quot;, current_class_name, #type);                                            \</span>
<span class="line-added">449   }</span>
<span class="line-added">450 </span>
<span class="line-added">451   BOX_CLASSES(DO_BOX_CLASS);</span>
<span class="line-added">452 </span>
<span class="line-added">453   if (JVMCILibDumpJNIConfig == NULL) {</span>
<span class="line-added">454     _byte_array = env-&gt;FindClass(&quot;[B&quot;);</span>
<span class="line-added">455     JVMCI_EXCEPTION_CHECK(env, &quot;FindClass([B)&quot;);</span>
<span class="line-added">456     _byte_array = (jclass) env-&gt;NewGlobalRef(_byte_array);</span>
<span class="line-added">457     assert(_byte_array != NULL, &quot;uninitialized&quot;);</span>
<span class="line-added">458   } else {</span>
<span class="line-added">459     fileStream* st = JVMCIGlobals::get_jni_config_file();</span>
<span class="line-added">460     st-&gt;print_cr(&quot;class [B&quot;);</span>
<span class="line-added">461   }</span>
<span class="line-added">462 </span>
<span class="line-added">463 #define DUMP_ALL_NATIVE_METHODS(class_symbol) do {                                                                  \</span>
<span class="line-added">464   current_class_name = class_symbol-&gt;as_C_string();                                                                 \</span>
<span class="line-added">465   Klass* k = SystemDictionary::resolve_or_fail(class_symbol, true, CHECK_EXIT);                                     \</span>
<span class="line-added">466   InstanceKlass* iklass = InstanceKlass::cast(k);                                                                   \</span>
<span class="line-added">467   Array&lt;Method*&gt;* methods = iklass-&gt;methods();                                                                      \</span>
<span class="line-added">468   for (int i = 0; i &lt; methods-&gt;length(); i++) {                                                                     \</span>
<span class="line-added">469     Method* m = methods-&gt;at(i);                                                                                     \</span>
<span class="line-added">470     if (m-&gt;is_native()) {                                                                                           \</span>
<span class="line-added">471       st-&gt;print_cr(&quot;method %s %s %s&quot;, current_class_name, m-&gt;name()-&gt;as_C_string(), m-&gt;signature()-&gt;as_C_string()); \</span>
<span class="line-added">472     }                                                                                                               \</span>
<span class="line-added">473   }                                                                                                                 \</span>
<span class="line-added">474 } while(0)</span>
<span class="line-added">475 </span>
<span class="line-added">476   if (JVMCILibDumpJNIConfig != NULL) {</span>
<span class="line-added">477     Thread* THREAD = Thread::current();</span>
<span class="line-added">478     fileStream* st = JVMCIGlobals::get_jni_config_file();</span>
<span class="line-added">479 </span>
<span class="line-added">480     DUMP_ALL_NATIVE_METHODS(vmSymbols::jdk_vm_ci_hotspot_CompilerToVM());</span>
<span class="line-added">481     ThrowableInitDumper dumper(st);</span>
<span class="line-added">482     vmSymbols::symbols_do(&amp;dumper);</span>
<span class="line-added">483 </span>
<span class="line-added">484     st-&gt;flush();</span>
<span class="line-added">485     tty-&gt;print_cr(&quot;Dumped JVMCI shared library JNI configuration to %s&quot;, JVMCILibDumpJNIConfig);</span>
<span class="line-added">486     vm_exit(0);</span>
<span class="line-added">487   }</span>
<span class="line-added">488 </span>
<span class="line-added">489 #undef DUMP_ALL_NATIVE_METHODS</span>
<span class="line-added">490 #undef DO_BOX_CLASS</span>
<span class="line-added">491 #undef BOX_CLASSES</span>
<span class="line-added">492 #undef IN_CLASS</span>
<span class="line-added">493 </span>
<span class="line-added">494 #define CC (char*)  /*cast a literal from (const char*)*/</span>
<span class="line-added">495 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(f))</span>
<span class="line-added">496 </span>
<span class="line-added">497   if (env != JavaThread::current()-&gt;jni_environment()) {</span>
<span class="line-added">498     jclass clazz = env-&gt;FindClass(&quot;jdk/vm/ci/hotspot/CompilerToVM&quot;);</span>
<span class="line-added">499     if (env-&gt;ExceptionCheck()) {</span>
<span class="line-added">500       env-&gt;ExceptionDescribe();</span>
<span class="line-added">501       guarantee(false, &quot;Could not find class jdk/vm/ci/hotspot/CompilerToVM&quot;);</span>
<span class="line-added">502     }</span>
<span class="line-added">503     JNINativeMethod CompilerToVM_native_methods[] = {</span>
<span class="line-added">504       { CC&quot;registerNatives&quot;,     CC&quot;()V&quot;, FN_PTR(JVM_RegisterJVMCINatives)     },</span>
<span class="line-added">505     };</span>
<span class="line-added">506     env-&gt;RegisterNatives(clazz, CompilerToVM_native_methods, 1);</span>
<span class="line-added">507     if (env-&gt;ExceptionCheck()) {</span>
<span class="line-added">508       env-&gt;ExceptionDescribe();</span>
<span class="line-added">509       guarantee(false, &quot;&quot;);</span>
<span class="line-added">510     }</span>
<span class="line-added">511 </span>
<span class="line-added">512     JNINativeMethod JVMCI_native_methods[] = {</span>
<span class="line-added">513       { CC&quot;initializeRuntime&quot;,   CC&quot;()Ljdk/vm/ci/runtime/JVMCIRuntime;&quot;, FN_PTR(JVM_GetJVMCIRuntime) },</span>
<span class="line-added">514     };</span>
<span class="line-added">515     env-&gt;RegisterNatives(JVMCI::clazz(), JVMCI_native_methods, 1);</span>
<span class="line-added">516     if (env-&gt;ExceptionCheck()) {</span>
<span class="line-added">517       env-&gt;ExceptionDescribe();</span>
<span class="line-added">518       guarantee(false, &quot;&quot;);</span>
<span class="line-added">519     }</span>
<span class="line-added">520   }</span>
521 }
522 
<a name="27" id="anc27"></a><span class="line-added">523 #undef METHOD</span>
<span class="line-added">524 #undef CONSTRUCTOR</span>
<span class="line-added">525 #undef FIELD2</span>
<span class="line-added">526 </span>
527 #define EMPTY0
528 #define EMPTY1(x)
529 #define EMPTY2(x,y)
<a name="28" id="anc28"></a><span class="line-modified">530 #define FIELD3(className, name, sig) FIELD2(className, name)</span>
<span class="line-modified">531 #define FIELD2(className, name) \</span>
<span class="line-added">532   jfieldID JNIJVMCI::className::_##name##_field_id = 0; \</span>
<span class="line-added">533   int HotSpotJVMCI::className::_##name##_offset = 0;</span>
<span class="line-added">534 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)</span>
<span class="line-added">535 #define CONSTRUCTOR(className, signature)</span>
536 
<a name="29" id="anc29"></a><span class="line-modified">537 // Generates the definitions of static fields used by the accessors. For example:</span>
<span class="line-added">538 //  jfieldID JNIJVMCI::Architecture::_wordKind_field_id = 0;</span>
<span class="line-added">539 //  jfieldID HotSpotJVMCI::Architecture::_wordKind_offset = 0;</span>
<span class="line-added">540 JVMCI_CLASSES_DO(EMPTY2, EMPTY0, FIELD2, FIELD2, FIELD2, FIELD2, FIELD2, FIELD3, FIELD3, FIELD3, FIELD3, FIELD3, FIELD2, FIELD2, METHOD, CONSTRUCTOR)</span>
541 
<a name="30" id="anc30"></a><span class="line-added">542 #undef START_CLASS</span>
<span class="line-added">543 #undef END_CLASS</span>
<span class="line-added">544 #undef METHOD</span>
<span class="line-added">545 #undef CONSTRUCTOR</span>
<span class="line-added">546 #undef FIELD</span>
<span class="line-added">547 #undef CHAR_FIELD</span>
<span class="line-added">548 #undef INT_FIELD</span>
<span class="line-added">549 #undef BOOLEAN_FIELD</span>
<span class="line-added">550 #undef LONG_FIELD</span>
<span class="line-added">551 #undef FLOAT_FIELD</span>
<span class="line-added">552 #undef OBJECT_FIELD</span>
<span class="line-added">553 #undef PRIMARRAY_FIELD</span>
<span class="line-added">554 #undef OBJECTARRAY_FIELD</span>
<span class="line-added">555 #undef STATIC_FIELD</span>
<span class="line-added">556 #undef STATIC_OBJECT_FIELD</span>
<span class="line-added">557 #undef STATIC_OBJECTARRAY_FIELD</span>
<span class="line-added">558 #undef STATIC_INT_FIELD</span>
<span class="line-added">559 #undef STATIC_BOOLEAN_FIELD</span>
<span class="line-added">560 #undef EMPTY_CAST</span>
<span class="line-added">561 </span>
<span class="line-added">562 </span>
<span class="line-added">563 #define START_CLASS(className, fullClassName)                                                                                     \</span>
<span class="line-added">564   void JNIJVMCI::className::initialize(JVMCI_TRAPS) {                                                                             \</span>
<span class="line-added">565     /* should already be initialized */                                                                                           \</span>
<span class="line-added">566   }                                                                                                                               \</span>
<span class="line-added">567   bool JNIJVMCI::className::is_instance(JVMCIEnv* jvmciEnv, JVMCIObject object) {                                                 \</span>
<span class="line-added">568     JNIAccessMark jni(jvmciEnv);                                                                                                  \</span>
<span class="line-added">569     return jni()-&gt;IsInstanceOf(object.as_jobject(), className::clazz()) != 0;                                                     \</span>
<span class="line-added">570   }                                                                                                                               \</span>
<span class="line-added">571   void JNIJVMCI::className::check(JVMCIEnv* jvmciEnv, JVMCIObject obj, const char* field_name, jfieldID offset) {                 \</span>
<span class="line-added">572     assert(obj.is_non_null(), &quot;NULL field access of %s.%s&quot;, #className, field_name);                                     \</span>
<span class="line-added">573     assert(jvmciEnv-&gt;isa_##className(obj), &quot;wrong class, &quot; #className &quot; expected, found %s&quot;, jvmciEnv-&gt;klass_name(obj)); \</span>
<span class="line-added">574     assert(offset != 0, &quot;must be valid offset&quot;);                                                                                  \</span>
<span class="line-added">575   }                                                                                                                               \</span>
<span class="line-added">576   jclass JNIJVMCI::className::_class = NULL;</span>
<span class="line-added">577 </span>
<span class="line-added">578 #define END_CLASS</span>
<span class="line-added">579 </span>
<span class="line-added">580 #define FIELD(className, name, type, accessor, cast)                                                                \</span>
<span class="line-added">581   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj) {                                       \</span>
<span class="line-added">582    className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                                           \</span>
<span class="line-added">583    JNIAccessMark jni(jvmciEnv);                               \</span>
<span class="line-added">584    return cast jni()-&gt;Get##accessor##Field(resolve_handle(obj), className::_##name##_field_id); \</span>
<span class="line-added">585   }                                                                                                                 \</span>
<span class="line-added">586   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj, type x) {                               \</span>
<span class="line-added">587     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                                          \</span>
<span class="line-added">588     JNIAccessMark jni(jvmciEnv); \</span>
<span class="line-added">589     jni()-&gt;Set##accessor##Field(resolve_handle(obj), className::_##name##_field_id, x);         \</span>
<span class="line-added">590   } \</span>
<span class="line-added">591 </span>
<span class="line-added">592 #define EMPTY_CAST</span>
<span class="line-added">593 #define CHAR_FIELD(className, name)                    FIELD(className, name, jchar, Char, EMPTY_CAST)</span>
<span class="line-added">594 #define INT_FIELD(className, name)                     FIELD(className, name, jint, Int, EMPTY_CAST)</span>
<span class="line-added">595 #define BOOLEAN_FIELD(className, name)                 FIELD(className, name, jboolean, Boolean, EMPTY_CAST)</span>
<span class="line-added">596 #define LONG_FIELD(className, name)                    FIELD(className, name, jlong, Long, EMPTY_CAST)</span>
<span class="line-added">597 #define FLOAT_FIELD(className, name)                   FIELD(className, name, jfloat, Float, EMPTY_CAST)</span>
<span class="line-added">598 </span>
<span class="line-added">599 #define OBJECT_FIELD(className, name, signature)              OOPISH_FIELD(className, name, JVMCIObject, Object, EMPTY_CAST)</span>
<span class="line-added">600 #define OBJECTARRAY_FIELD(className, name, signature)         OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))</span>
<span class="line-added">601 #define PRIMARRAY_FIELD(className, name, signature)           OOPISH_FIELD(className, name, JVMCIPrimitiveArray, Object, (JVMCIPrimitiveArray))</span>
<span class="line-added">602 </span>
<span class="line-added">603 #define STATIC_OBJECT_FIELD(className, name, signature)       STATIC_OOPISH_FIELD(className, name, JVMCIObject, Object, (JVMCIObject))</span>
<span class="line-added">604 #define STATIC_OBJECTARRAY_FIELD(className, name, signature)  STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))</span>
<span class="line-added">605 </span>
<span class="line-added">606 #define OOPISH_FIELD(className, name, type, accessor, cast)                                             \</span>
<span class="line-added">607   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj) {                           \</span>
<span class="line-added">608     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                              \</span>
<span class="line-added">609     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">610     return cast wrap(jni()-&gt;Get##accessor##Field(resolve_handle(obj), className::_##name##_field_id));  \</span>
<span class="line-added">611   }                                                                                                     \</span>
<span class="line-added">612   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj, type x) {                   \</span>
<span class="line-added">613     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                              \</span>
<span class="line-added">614     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">615     jni()-&gt;Set##accessor##Field(resolve_handle(obj), className::_##name##_field_id, resolve_handle(x)); \</span>
<span class="line-added">616   }</span>
<span class="line-added">617 </span>
<span class="line-added">618 #define STATIC_OOPISH_FIELD(className, name, type, accessor, cast)                                      \</span>
<span class="line-added">619   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv) {                                            \</span>
<span class="line-added">620     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">621     return cast wrap(jni()-&gt;GetStatic##accessor##Field(className::clazz(), className::_##name##_field_id));  \</span>
<span class="line-added">622   }                                                                                                     \</span>
<span class="line-added">623   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, type x) {                                    \</span>
<span class="line-added">624     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">625     jni()-&gt;SetStatic##accessor##Field(className::clazz(), className::_##name##_field_id, resolve_handle(x)); \</span>
<span class="line-added">626   }</span>
<span class="line-added">627 </span>
<span class="line-added">628 #define STATIC_PRIMITIVE_FIELD(className, name, type, accessor, cast)                                   \</span>
<span class="line-added">629   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv) {                                            \</span>
<span class="line-added">630     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">631     return cast jni()-&gt;GetStatic##accessor##Field(className::clazz(), className::_##name##_field_id);   \</span>
<span class="line-added">632   }                                                                                                     \</span>
<span class="line-added">633   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, type x) {                                    \</span>
<span class="line-added">634     JNIAccessMark jni(jvmciEnv);                                                                        \</span>
<span class="line-added">635     jni()-&gt;SetStatic##accessor##Field(className::clazz(), className::_##name##_field_id, x);            \</span>
<span class="line-added">636   }</span>
<span class="line-added">637 </span>
<span class="line-added">638 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint, Int, EMPTY_CAST)</span>
<span class="line-added">639 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean, Boolean, EMPTY_CAST)</span>
<span class="line-added">640 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \</span>
<span class="line-added">641   jmethodID JNIJVMCI::className::_##methodName##_method;</span>
<span class="line-added">642 </span>
<span class="line-added">643 #define CONSTRUCTOR(className, signature) \</span>
<span class="line-added">644   jmethodID JNIJVMCI::className::_constructor;</span>
<span class="line-added">645 </span>
<span class="line-added">646 /**</span>
<span class="line-added">647  * Generates the method definitions for the classes in HotSpotJVMCI.</span>
<span class="line-added">648  */</span>
<span class="line-added">649 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)</span>
<span class="line-added">650 </span>
<span class="line-added">651 #undef METHOD</span>
<span class="line-added">652 #undef CONSTRUCTOR</span>
<span class="line-added">653 #undef START_CLASS</span>
<span class="line-added">654 #undef END_CLASS</span>
<span class="line-added">655 #undef FIELD</span>
<span class="line-added">656 #undef CHAR_FIELD</span>
<span class="line-added">657 #undef INT_FIELD</span>
<span class="line-added">658 #undef BOOLEAN_FIELD</span>
<span class="line-added">659 #undef LONG_FIELD</span>
<span class="line-added">660 #undef FLOAT_FIELD</span>
<span class="line-added">661 #undef OBJECT_FIELD</span>
<span class="line-added">662 #undef PRIMARRAY_FIELD</span>
<span class="line-added">663 #undef OBJECTARRAY_FIELD</span>
<span class="line-added">664 #undef STATIC_OOPISH_FIELD</span>
<span class="line-added">665 #undef STATIC_OBJECT_FIELD</span>
<span class="line-added">666 #undef STATIC_OBJECTARRAY_FIELD</span>
<span class="line-added">667 #undef STATIC_INT_FIELD</span>
<span class="line-added">668 #undef STATIC_BOOLEAN_FIELD</span>
<span class="line-added">669 #undef STATIC_PRIMITIVE_FIELD</span>
<span class="line-added">670 #undef OOPISH_FIELD</span>
<span class="line-added">671 #undef EMPTY_CAST</span>
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
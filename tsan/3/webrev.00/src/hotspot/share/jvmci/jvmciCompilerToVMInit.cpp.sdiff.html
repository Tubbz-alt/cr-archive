<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciCompilerToVMInit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCompilerToVM.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCompilerToVMInit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 // no precompiled headers
 25 #include &quot;ci/ciUtilities.hpp&quot;
 26 #include &quot;gc/shared/barrierSet.hpp&quot;
 27 #include &quot;gc/shared/cardTable.hpp&quot;
<span class="line-modified"> 28 #include &quot;memory/oopFactory.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
<span class="line-removed"> 30 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
 31 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
 32 #include &quot;jvmci/vmStructs_jvmci.hpp&quot;
<span class="line-modified"> 33 #include &quot;runtime/flags/jvmFlag.hpp&quot;</span>
<span class="line-modified"> 34 #include &quot;runtime/handles.inline.hpp&quot;</span>

 35 #include &quot;runtime/sharedRuntime.hpp&quot;
 36 #include &quot;utilities/resourceHash.hpp&quot;
 37 
 38 
 39 int CompilerToVM::Data::Klass_vtable_start_offset;
 40 int CompilerToVM::Data::Klass_vtable_length_offset;
 41 
 42 int CompilerToVM::Data::Method_extra_stack_entries;
 43 
 44 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
 45 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
 46 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;

 47 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 48 
 49 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 50 
 51 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 52 int CompilerToVM::Data::Universe_base_vtable_size;
 53 address CompilerToVM::Data::Universe_narrow_oop_base;
 54 int CompilerToVM::Data::Universe_narrow_oop_shift;
 55 address CompilerToVM::Data::Universe_narrow_klass_base;
 56 int CompilerToVM::Data::Universe_narrow_klass_shift;
 57 void* CompilerToVM::Data::Universe_non_oop_bits;
 58 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 59 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 60 
 61 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 62 HeapWord** CompilerToVM::Data::_heap_end_addr;
 63 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
 64 int CompilerToVM::Data::_max_oop_map_stack_offset;
 65 int CompilerToVM::Data::_fields_annotations_base_offset;
 66 
</pre>
<hr />
<pre>
 71 
 72 int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);
 73 int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);
 74 int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);
 75 int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);
 76 int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);
 77 int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);
 78 int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);
 79 
 80 address CompilerToVM::Data::dsin;
 81 address CompilerToVM::Data::dcos;
 82 address CompilerToVM::Data::dtan;
 83 address CompilerToVM::Data::dexp;
 84 address CompilerToVM::Data::dlog;
 85 address CompilerToVM::Data::dlog10;
 86 address CompilerToVM::Data::dpow;
 87 
 88 address CompilerToVM::Data::symbol_init;
 89 address CompilerToVM::Data::symbol_clinit;
 90 
<span class="line-modified"> 91 void CompilerToVM::Data::initialize(TRAPS) {</span>
 92   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 93   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 94 
 95   Method_extra_stack_entries = Method::extra_stack_entries();
 96 
 97   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 98   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
 99   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();

100   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
101 
102   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
103 
104   Universe_collectedHeap = Universe::heap();
105   Universe_base_vtable_size = Universe::base_vtable_size();
<span class="line-modified">106   Universe_narrow_oop_base = Universe::narrow_oop_base();</span>
<span class="line-modified">107   Universe_narrow_oop_shift = Universe::narrow_oop_shift();</span>
<span class="line-modified">108   Universe_narrow_klass_base = Universe::narrow_klass_base();</span>
<span class="line-modified">109   Universe_narrow_klass_shift = Universe::narrow_klass_shift();</span>
110   Universe_non_oop_bits = Universe::non_oop_word();
111   Universe_verify_oop_mask = Universe::verify_oop_mask();
112   Universe_verify_oop_bits = Universe::verify_oop_bits();
113 
114   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
115   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
116   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
117 
118   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
119   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
120   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), &quot;should be valid&quot;);
121   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), &quot;should be invalid&quot;);
122 
123   symbol_init = (address) vmSymbols::object_initializer_name();
124   symbol_clinit = (address) vmSymbols::class_initializer_name();
125 
126   _fields_annotations_base_offset = Array&lt;AnnotationArray*&gt;::base_offset_in_bytes();
127 
128   BarrierSet* bs = BarrierSet::barrier_set();
129   if (bs-&gt;is_a(BarrierSet::CardTableBarrierSet)) {
</pre>
<hr />
<pre>
140   vm_page_size = os::vm_page_size();
141 
142 #define SET_TRIGFUNC(name)                                      \
143   if (StubRoutines::name() != NULL) {                           \
144     name = StubRoutines::name();                                \
145   } else {                                                      \
146     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
147   }
148 
149   SET_TRIGFUNC(dsin);
150   SET_TRIGFUNC(dcos);
151   SET_TRIGFUNC(dtan);
152   SET_TRIGFUNC(dexp);
153   SET_TRIGFUNC(dlog10);
154   SET_TRIGFUNC(dlog);
155   SET_TRIGFUNC(dpow);
156 
157 #undef SET_TRIGFUNC
158 }
159 
<span class="line-modified">160 objArrayHandle CompilerToVM::initialize_intrinsics(TRAPS) {</span>
<span class="line-modified">161   objArrayHandle vmIntrinsics = oopFactory::new_objArray_handle(VMIntrinsicMethod::klass(), (vmIntrinsics::ID_LIMIT - 1), CHECK_(objArrayHandle()));</span>
162   int index = 0;
<span class="line-removed">163   // The intrinsics for a class are usually adjacent to each other.</span>
<span class="line-removed">164   // When they are, the string for the class name can be reused.</span>
165   vmSymbols::SID kls_sid = vmSymbols::NO_SID;
<span class="line-modified">166   Handle kls_str;</span>
167 #define VM_SYMBOL_TO_STRING(s) \
<span class="line-modified">168   java_lang_String::create_from_symbol(vmSymbols::symbol_at(vmSymbols::VM_SYMBOL_ENUM_NAME(s)), CHECK_(objArrayHandle()))</span>
169 #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \
<span class="line-removed">170     instanceHandle vmIntrinsicMethod = InstanceKlass::cast(VMIntrinsicMethod::klass())-&gt;allocate_instance_handle(CHECK_(objArrayHandle())); \</span>
171     vmSymbols::SID sid = vmSymbols::VM_SYMBOL_ENUM_NAME(kls);             \
172     if (kls_sid != sid) {                                                 \
173       kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
174       kls_sid = sid;                                                      \
175     }                                                                     \
<span class="line-modified">176     Handle name_str = VM_SYMBOL_TO_STRING(name);                          \</span>
<span class="line-modified">177     Handle sig_str = VM_SYMBOL_TO_STRING(sig);                            \</span>
<span class="line-modified">178     VMIntrinsicMethod::set_declaringClass(vmIntrinsicMethod, kls_str());  \</span>
<span class="line-modified">179     VMIntrinsicMethod::set_name(vmIntrinsicMethod, name_str());           \</span>
<span class="line-removed">180     VMIntrinsicMethod::set_descriptor(vmIntrinsicMethod, sig_str());      \</span>
<span class="line-removed">181     VMIntrinsicMethod::set_id(vmIntrinsicMethod, vmIntrinsics::id);       \</span>
<span class="line-removed">182       vmIntrinsics-&gt;obj_at_put(index++, vmIntrinsicMethod());             \</span>
183   }
184 
185   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
186 #undef VM_SYMBOL_TO_STRING
187 #undef VM_INTRINSIC_INFO
188   assert(index == vmIntrinsics::ID_LIMIT - 1, &quot;must be&quot;);
189 
190   return vmIntrinsics;
191 }
192 
<span class="line-removed">193 /**</span>
<span class="line-removed">194  * The set of VM flags known to be used.</span>
<span class="line-removed">195  */</span>
196 #define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \
197   do_intx_flag(AllocateInstancePrefetchLines)                              \
198   do_intx_flag(AllocatePrefetchDistance)                                   \
199   do_intx_flag(AllocatePrefetchInstr)                                      \
200   do_intx_flag(AllocatePrefetchLines)                                      \
201   do_intx_flag(AllocatePrefetchStepSize)                                   \
202   do_intx_flag(AllocatePrefetchStyle)                                      \
203   do_intx_flag(BciProfileWidth)                                            \
204   do_bool_flag(BootstrapJVMCI)                                             \
205   do_bool_flag(CITime)                                                     \
206   do_bool_flag(CITimeEach)                                                 \
207   do_uintx_flag(CodeCacheSegmentSize)                                      \
208   do_intx_flag(CodeEntryAlignment)                                         \
<span class="line-removed">209   do_bool_flag(CompactFields)                                              \</span>
210   do_intx_flag(ContendedPaddingWidth)                                      \
211   do_bool_flag(DontCompileHugeMethods)                                     \
212   do_bool_flag(EagerJVMCI)                                                 \
213   do_bool_flag(EnableContended)                                            \
<span class="line-removed">214   do_intx_flag(FieldsAllocationStyle)                                      \</span>
215   do_bool_flag(FoldStableValues)                                           \
216   do_bool_flag(ForceUnreachable)                                           \
217   do_intx_flag(HugeMethodLimit)                                            \
218   do_bool_flag(Inline)                                                     \
219   do_intx_flag(JVMCICounterSize)                                           \
220   do_bool_flag(JVMCIPrintProperties)                                       \
221   do_bool_flag(JVMCIUseFastLocking)                                        \
222   do_intx_flag(MethodProfileWidth)                                         \
223   do_intx_flag(ObjectAlignmentInBytes)                                     \
224   do_bool_flag(PrintInlining)                                              \
225   do_bool_flag(ReduceInitialCardMarks)                                     \
226   do_bool_flag(RestrictContended)                                          \
227   do_intx_flag(StackReservedPages)                                         \
228   do_intx_flag(StackShadowPages)                                           \
229   do_bool_flag(TLABStats)                                                  \
230   do_uintx_flag(TLABWasteIncrement)                                        \
231   do_intx_flag(TypeProfileWidth)                                           \
232   do_bool_flag(UseAESIntrinsics)                                           \
233   X86_ONLY(do_intx_flag(UseAVX))                                           \
234   do_bool_flag(UseBiasedLocking)                                           \
235   do_bool_flag(UseCRC32Intrinsics)                                         \
236   do_bool_flag(UseCompressedClassPointers)                                 \
237   do_bool_flag(UseCompressedOops)                                          \
238   X86_ONLY(do_bool_flag(UseCountLeadingZerosInstruction))                  \
239   X86_ONLY(do_bool_flag(UseCountTrailingZerosInstruction))                 \
<span class="line-removed">240   do_bool_flag(UseConcMarkSweepGC)                                         \</span>
241   do_bool_flag(UseG1GC)                                                    \
242   do_bool_flag(UseParallelGC)                                              \
<span class="line-removed">243   do_bool_flag(UseParallelOldGC)                                           \</span>
244   do_bool_flag(UseSerialGC)                                                \
245   do_bool_flag(UseZGC)                                                     \
246   do_bool_flag(UseEpsilonGC)                                               \
247   COMPILER2_PRESENT(do_bool_flag(UseMontgomeryMultiplyIntrinsic))          \
248   COMPILER2_PRESENT(do_bool_flag(UseMontgomerySquareIntrinsic))            \
249   COMPILER2_PRESENT(do_bool_flag(UseMulAddIntrinsic))                      \
250   COMPILER2_PRESENT(do_bool_flag(UseMultiplyToLenIntrinsic))               \
251   do_bool_flag(UsePopCountInstruction)                                     \
252   do_bool_flag(UseSHA1Intrinsics)                                          \
253   do_bool_flag(UseSHA256Intrinsics)                                        \
254   do_bool_flag(UseSHA512Intrinsics)                                        \
255   do_intx_flag(UseSSE)                                                     \
256   COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \
257   do_bool_flag(UseStackBanging)                                            \
258   do_bool_flag(UseTLAB)                                                    \
259   do_bool_flag(VerifyOops)                                                 \
260 
<span class="line-modified">261 #define BOXED_BOOLEAN(name, value) oop name = ((jboolean)(value) ? boxedTrue() : boxedFalse())</span>
<span class="line-modified">262 #define BOXED_DOUBLE(name, value) oop name; do { jvalue p; p.d = (jdouble) (value); name = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL);} while(0)</span>
263 #define BOXED_LONG(name, value) \
<span class="line-removed">264   oop name; \</span>
265   do { \
266     jvalue p; p.j = (jlong) (value); \
<span class="line-modified">267     Handle* e = longs.get(p.j); \</span>
268     if (e == NULL) { \
<span class="line-modified">269       oop o = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); \</span>
<span class="line-removed">270       Handle h(THREAD, o); \</span>
271       longs.put(p.j, h); \
<span class="line-modified">272       name = h(); \</span>
273     } else { \
<span class="line-modified">274       name = (*e)(); \</span>
275     } \
276   } while (0)
277 
278 #define CSTRING_TO_JSTRING(name, value) \
<span class="line-modified">279   Handle name; \</span>
280   do { \
281     if (value != NULL) { \
<span class="line-modified">282       Handle* e = strings.get(value); \</span>
283       if (e == NULL) { \
<span class="line-modified">284         Handle h = java_lang_String::create_from_str(value, CHECK_NULL); \</span>
285         strings.put(value, h); \
286         name = h; \
287       } else { \
288         name = (*e); \
289       } \
290     } \
291   } while (0)
292 
<span class="line-modified">293 jobjectArray readConfiguration0(JNIEnv *env, TRAPS) {</span>
<span class="line-modified">294   ResourceMark rm;</span>
<span class="line-modified">295   HandleMark hm;</span>
<span class="line-modified">296 </span>
<span class="line-removed">297   // Used to canonicalize Long and String values.</span>
<span class="line-removed">298   ResourceHashtable&lt;jlong, Handle&gt; longs;</span>
<span class="line-removed">299   ResourceHashtable&lt;const char*, Handle, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;</span>
300 
301   jvalue prim;
<span class="line-modified">302   prim.z = true;  oop boxedTrueOop =  java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="line-modified">303   Handle boxedTrue(THREAD, boxedTrueOop);</span>
<span class="line-removed">304   prim.z = false; oop boxedFalseOop = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="line-removed">305   Handle boxedFalse(THREAD, boxedFalseOop);</span>
306 
<span class="line-modified">307   CompilerToVM::Data::initialize(CHECK_NULL);</span>
308 
<span class="line-modified">309   VMField::klass()-&gt;initialize(CHECK_NULL);</span>
<span class="line-modified">310   VMFlag::klass()-&gt;initialize(CHECK_NULL);</span>
<span class="line-modified">311   VMIntrinsicMethod::klass()-&gt;initialize(CHECK_NULL);</span>
312 
313   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
<span class="line-modified">314   objArrayHandle vmFields = oopFactory::new_objArray_handle(VMField::klass(), len, CHECK_NULL);</span>
315   for (int i = 0; i &lt; len ; i++) {
316     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];
<span class="line-removed">317     instanceHandle vmFieldObj = InstanceKlass::cast(VMField::klass())-&gt;allocate_instance_handle(CHECK_NULL);</span>
318     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* &quot;::&quot; */;
319     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
320     sprintf(name_buf, &quot;%s::%s&quot;, vmField.typeName, vmField.fieldName);
321     CSTRING_TO_JSTRING(name, name_buf);
322     CSTRING_TO_JSTRING(type, vmField.typeString);
<span class="line-modified">323     VMField::set_name(vmFieldObj, name());</span>
<span class="line-removed">324     VMField::set_type(vmFieldObj, type());</span>
<span class="line-removed">325     VMField::set_offset(vmFieldObj, vmField.offset);</span>
<span class="line-removed">326     VMField::set_address(vmFieldObj, (jlong) vmField.address);</span>
327     if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {
328       if (strcmp(vmField.typeString, &quot;bool&quot;) == 0) {
329         BOXED_BOOLEAN(box, *(jbyte*) vmField.address);
<span class="line-modified">330         VMField::set_value(vmFieldObj, box);</span>
331       } else if (strcmp(vmField.typeString, &quot;int&quot;) == 0 ||
<span class="line-modified">332                  strcmp(vmField.typeString, &quot;jint&quot;) == 0) {</span>

333         BOXED_LONG(box, *(jint*) vmField.address);
<span class="line-modified">334         VMField::set_value(vmFieldObj, box);</span>
335       } else if (strcmp(vmField.typeString, &quot;uint64_t&quot;) == 0) {
336         BOXED_LONG(box, *(uint64_t*) vmField.address);
<span class="line-modified">337         VMField::set_value(vmFieldObj, box);</span>
338       } else if (strcmp(vmField.typeString, &quot;address&quot;) == 0 ||
339                  strcmp(vmField.typeString, &quot;intptr_t&quot;) == 0 ||
340                  strcmp(vmField.typeString, &quot;uintptr_t&quot;) == 0 ||
341                  strcmp(vmField.typeString, &quot;OopHandle&quot;) == 0 ||
342                  strcmp(vmField.typeString, &quot;size_t&quot;) == 0 ||
343                  // All foo* types are addresses.
344                  vmField.typeString[strlen(vmField.typeString) - 1] == &#39;*&#39;) {
345         BOXED_LONG(box, *((address*) vmField.address));
<span class="line-modified">346         VMField::set_value(vmFieldObj, box);</span>
347       } else {
348         JVMCI_ERROR_NULL(&quot;VM field %s has unsupported type %s&quot;, name_buf, vmField.typeString);
349       }
350     }
<span class="line-modified">351     vmFields-&gt;obj_at_put(i, vmFieldObj());</span>

352   }
353 
354   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
355   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
356   len = ints_len + longs_len;
<span class="line-modified">357   objArrayHandle vmConstants = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);</span>
358   int insert = 0;
359   for (int i = 0; i &lt; ints_len ; i++) {
360     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
361     CSTRING_TO_JSTRING(name, c.name);

362     BOXED_LONG(value, c.value);
<span class="line-modified">363     vmConstants-&gt;obj_at_put(insert++, name());</span>
<span class="line-modified">364     vmConstants-&gt;obj_at_put(insert++, value);</span>
365   }
366   for (int i = 0; i &lt; longs_len ; i++) {
367     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
368     CSTRING_TO_JSTRING(name, c.name);

369     BOXED_LONG(value, c.value);
<span class="line-modified">370     vmConstants-&gt;obj_at_put(insert++, name());</span>
<span class="line-modified">371     vmConstants-&gt;obj_at_put(insert++, value);</span>
372   }
373   assert(insert == len * 2, &quot;must be&quot;);
374 
375   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
<span class="line-modified">376   objArrayHandle vmAddresses = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), len * 2, CHECK_NULL);</span>
377   for (int i = 0; i &lt; len ; i++) {
378     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
379     CSTRING_TO_JSTRING(name, a.name);

380     BOXED_LONG(value, a.value);
<span class="line-modified">381     vmAddresses-&gt;obj_at_put(i * 2, name());</span>
<span class="line-modified">382     vmAddresses-&gt;obj_at_put(i * 2 + 1, value);</span>
383   }
384 
385 #define COUNT_FLAG(ignore) +1
386 #ifdef ASSERT
387 #define CHECK_FLAG(type, name) { \
<span class="line-modified">388   JVMFlag* flag = JVMFlag::find_flag(#name, strlen(#name), /*allow_locked*/ true, /* return_flag */ true); \</span>
389   assert(flag != NULL, &quot;No such flag named &quot; #name); \
390   assert(flag-&gt;is_##type(), &quot;JVMFlag &quot; #name &quot; is not of type &quot; #type); \
391 }
392 #else
393 #define CHECK_FLAG(type, name)
394 #endif
395 
<span class="line-modified">396 #define ADD_FLAG(type, name, convert) { \</span>
<span class="line-modified">397   CHECK_FLAG(type, name) \</span>
<span class="line-modified">398   instanceHandle vmFlagObj = InstanceKlass::cast(VMFlag::klass())-&gt;allocate_instance_handle(CHECK_NULL); \</span>
<span class="line-modified">399   CSTRING_TO_JSTRING(fname, #name); \</span>
<span class="line-modified">400   CSTRING_TO_JSTRING(ftype, #type); \</span>
<span class="line-modified">401   VMFlag::set_name(vmFlagObj, fname()); \</span>
<span class="line-modified">402   VMFlag::set_type(vmFlagObj, ftype()); \</span>
<span class="line-removed">403   convert(value, name); \</span>
<span class="line-removed">404   VMFlag::set_value(vmFlagObj, value); \</span>
<span class="line-removed">405   vmFlags-&gt;obj_at_put(i++, vmFlagObj()); \</span>
406 }
407 #define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)
408 #define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)
409 #define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)
410 
411   len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);
<span class="line-modified">412   objArrayHandle vmFlags = oopFactory::new_objArray_handle(VMFlag::klass(), len, CHECK_NULL);</span>
413   int i = 0;

414   PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)
415 
<span class="line-modified">416   objArrayHandle vmIntrinsics = CompilerToVM::initialize_intrinsics(CHECK_NULL);</span>
<span class="line-modified">417 </span>
<span class="line-modified">418   objArrayOop data = oopFactory::new_objArray(SystemDictionary::Object_klass(), 5, CHECK_NULL);</span>
<span class="line-modified">419   data-&gt;obj_at_put(0, vmFields());</span>
<span class="line-modified">420   data-&gt;obj_at_put(1, vmConstants());</span>
<span class="line-modified">421   data-&gt;obj_at_put(2, vmAddresses());</span>
<span class="line-modified">422   data-&gt;obj_at_put(3, vmFlags());</span>
<span class="line-modified">423   data-&gt;obj_at_put(4, vmIntrinsics());</span>
<span class="line-modified">424 </span>
<span class="line-modified">425   return (jobjectArray) JNIHandles::make_local(THREAD, data);</span>
<span class="line-removed">426 #undef COUNT_FLAG</span>
<span class="line-removed">427 #undef ADD_FLAG</span>
<span class="line-removed">428 #undef ADD_BOOL_FLAG</span>
<span class="line-removed">429 #undef ADD_INTX_FLAG</span>
<span class="line-removed">430 #undef ADD_UINTX_FLAG</span>
<span class="line-removed">431 #undef CHECK_FLAG</span>
432 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 // no precompiled headers
 25 #include &quot;ci/ciUtilities.hpp&quot;
 26 #include &quot;gc/shared/barrierSet.hpp&quot;
 27 #include &quot;gc/shared/cardTable.hpp&quot;
<span class="line-modified"> 28 #include &quot;gc/shared/collectedHeap.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;jvmci/jvmciEnv.hpp&quot;</span>

 30 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
 31 #include &quot;jvmci/vmStructs_jvmci.hpp&quot;
<span class="line-modified"> 32 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-modified"> 33 #include &quot;oops/compressedOops.hpp&quot;</span>
<span class="line-added"> 34 #include &quot;oops/klass.inline.hpp&quot;</span>
 35 #include &quot;runtime/sharedRuntime.hpp&quot;
 36 #include &quot;utilities/resourceHash.hpp&quot;
 37 
 38 
 39 int CompilerToVM::Data::Klass_vtable_start_offset;
 40 int CompilerToVM::Data::Klass_vtable_length_offset;
 41 
 42 int CompilerToVM::Data::Method_extra_stack_entries;
 43 
 44 address CompilerToVM::Data::SharedRuntime_ic_miss_stub;
 45 address CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub;
 46 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack;
<span class="line-added"> 47 address CompilerToVM::Data::SharedRuntime_deopt_blob_unpack_with_exception_in_tls;</span>
 48 address CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap;
 49 
 50 size_t CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve;
 51 
 52 CollectedHeap* CompilerToVM::Data::Universe_collectedHeap;
 53 int CompilerToVM::Data::Universe_base_vtable_size;
 54 address CompilerToVM::Data::Universe_narrow_oop_base;
 55 int CompilerToVM::Data::Universe_narrow_oop_shift;
 56 address CompilerToVM::Data::Universe_narrow_klass_base;
 57 int CompilerToVM::Data::Universe_narrow_klass_shift;
 58 void* CompilerToVM::Data::Universe_non_oop_bits;
 59 uintptr_t CompilerToVM::Data::Universe_verify_oop_mask;
 60 uintptr_t CompilerToVM::Data::Universe_verify_oop_bits;
 61 
 62 bool       CompilerToVM::Data::_supports_inline_contig_alloc;
 63 HeapWord** CompilerToVM::Data::_heap_end_addr;
 64 HeapWord* volatile* CompilerToVM::Data::_heap_top_addr;
 65 int CompilerToVM::Data::_max_oop_map_stack_offset;
 66 int CompilerToVM::Data::_fields_annotations_base_offset;
 67 
</pre>
<hr />
<pre>
 72 
 73 int CompilerToVM::Data::sizeof_vtableEntry = sizeof(vtableEntry);
 74 int CompilerToVM::Data::sizeof_ExceptionTableElement = sizeof(ExceptionTableElement);
 75 int CompilerToVM::Data::sizeof_LocalVariableTableElement = sizeof(LocalVariableTableElement);
 76 int CompilerToVM::Data::sizeof_ConstantPool = sizeof(ConstantPool);
 77 int CompilerToVM::Data::sizeof_narrowKlass = sizeof(narrowKlass);
 78 int CompilerToVM::Data::sizeof_arrayOopDesc = sizeof(arrayOopDesc);
 79 int CompilerToVM::Data::sizeof_BasicLock = sizeof(BasicLock);
 80 
 81 address CompilerToVM::Data::dsin;
 82 address CompilerToVM::Data::dcos;
 83 address CompilerToVM::Data::dtan;
 84 address CompilerToVM::Data::dexp;
 85 address CompilerToVM::Data::dlog;
 86 address CompilerToVM::Data::dlog10;
 87 address CompilerToVM::Data::dpow;
 88 
 89 address CompilerToVM::Data::symbol_init;
 90 address CompilerToVM::Data::symbol_clinit;
 91 
<span class="line-modified"> 92 void CompilerToVM::Data::initialize(JVMCI_TRAPS) {</span>
 93   Klass_vtable_start_offset = in_bytes(Klass::vtable_start_offset());
 94   Klass_vtable_length_offset = in_bytes(Klass::vtable_length_offset());
 95 
 96   Method_extra_stack_entries = Method::extra_stack_entries();
 97 
 98   SharedRuntime_ic_miss_stub = SharedRuntime::get_ic_miss_stub();
 99   SharedRuntime_handle_wrong_method_stub = SharedRuntime::get_handle_wrong_method_stub();
100   SharedRuntime_deopt_blob_unpack = SharedRuntime::deopt_blob()-&gt;unpack();
<span class="line-added">101   SharedRuntime_deopt_blob_unpack_with_exception_in_tls = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();</span>
102   SharedRuntime_deopt_blob_uncommon_trap = SharedRuntime::deopt_blob()-&gt;uncommon_trap();
103 
104   ThreadLocalAllocBuffer_alignment_reserve = ThreadLocalAllocBuffer::alignment_reserve();
105 
106   Universe_collectedHeap = Universe::heap();
107   Universe_base_vtable_size = Universe::base_vtable_size();
<span class="line-modified">108   Universe_narrow_oop_base = CompressedOops::base();</span>
<span class="line-modified">109   Universe_narrow_oop_shift = CompressedOops::shift();</span>
<span class="line-modified">110   Universe_narrow_klass_base = CompressedKlassPointers::base();</span>
<span class="line-modified">111   Universe_narrow_klass_shift = CompressedKlassPointers::shift();</span>
112   Universe_non_oop_bits = Universe::non_oop_word();
113   Universe_verify_oop_mask = Universe::verify_oop_mask();
114   Universe_verify_oop_bits = Universe::verify_oop_bits();
115 
116   _supports_inline_contig_alloc = Universe::heap()-&gt;supports_inline_contig_alloc();
117   _heap_end_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;end_addr() : (HeapWord**) -1;
118   _heap_top_addr = _supports_inline_contig_alloc ? Universe::heap()-&gt;top_addr() : (HeapWord* volatile*) -1;
119 
120   _max_oop_map_stack_offset = (OopMapValue::register_mask - VMRegImpl::stack2reg(0)-&gt;value()) * VMRegImpl::stack_slot_size;
121   int max_oop_map_stack_index = _max_oop_map_stack_offset / VMRegImpl::stack_slot_size;
122   assert(OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index)), &quot;should be valid&quot;);
123   assert(!OopMapValue::legal_vm_reg_name(VMRegImpl::stack2reg(max_oop_map_stack_index + 1)), &quot;should be invalid&quot;);
124 
125   symbol_init = (address) vmSymbols::object_initializer_name();
126   symbol_clinit = (address) vmSymbols::class_initializer_name();
127 
128   _fields_annotations_base_offset = Array&lt;AnnotationArray*&gt;::base_offset_in_bytes();
129 
130   BarrierSet* bs = BarrierSet::barrier_set();
131   if (bs-&gt;is_a(BarrierSet::CardTableBarrierSet)) {
</pre>
<hr />
<pre>
142   vm_page_size = os::vm_page_size();
143 
144 #define SET_TRIGFUNC(name)                                      \
145   if (StubRoutines::name() != NULL) {                           \
146     name = StubRoutines::name();                                \
147   } else {                                                      \
148     name = CAST_FROM_FN_PTR(address, SharedRuntime::name);      \
149   }
150 
151   SET_TRIGFUNC(dsin);
152   SET_TRIGFUNC(dcos);
153   SET_TRIGFUNC(dtan);
154   SET_TRIGFUNC(dexp);
155   SET_TRIGFUNC(dlog10);
156   SET_TRIGFUNC(dlog);
157   SET_TRIGFUNC(dpow);
158 
159 #undef SET_TRIGFUNC
160 }
161 
<span class="line-modified">162 JVMCIObjectArray CompilerToVM::initialize_intrinsics(JVMCI_TRAPS) {</span>
<span class="line-modified">163   JVMCIObjectArray vmIntrinsics = JVMCIENV-&gt;new_VMIntrinsicMethod_array(vmIntrinsics::ID_LIMIT - 1, JVMCI_CHECK_NULL);</span>
164   int index = 0;


165   vmSymbols::SID kls_sid = vmSymbols::NO_SID;
<span class="line-modified">166   JVMCIObject kls_str;</span>
167 #define VM_SYMBOL_TO_STRING(s) \
<span class="line-modified">168   JVMCIENV-&gt;create_string(vmSymbols::symbol_at(vmSymbols::VM_SYMBOL_ENUM_NAME(s)), JVMCI_CHECK_NULL)</span>
169 #define VM_INTRINSIC_INFO(id, kls, name, sig, ignore_fcode) {             \

170     vmSymbols::SID sid = vmSymbols::VM_SYMBOL_ENUM_NAME(kls);             \
171     if (kls_sid != sid) {                                                 \
172       kls_str = VM_SYMBOL_TO_STRING(kls);                                 \
173       kls_sid = sid;                                                      \
174     }                                                                     \
<span class="line-modified">175     JVMCIObject name_str = VM_SYMBOL_TO_STRING(name);                    \</span>
<span class="line-modified">176     JVMCIObject sig_str = VM_SYMBOL_TO_STRING(sig);                      \</span>
<span class="line-modified">177     JVMCIObject vmIntrinsicMethod = JVMCIENV-&gt;new_VMIntrinsicMethod(kls_str, name_str, sig_str, (jint) vmIntrinsics::id, JVMCI_CHECK_NULL); \</span>
<span class="line-modified">178     JVMCIENV-&gt;put_object_at(vmIntrinsics, index++, vmIntrinsicMethod);   \</span>



179   }
180 
181   VM_INTRINSICS_DO(VM_INTRINSIC_INFO, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
182 #undef VM_SYMBOL_TO_STRING
183 #undef VM_INTRINSIC_INFO
184   assert(index == vmIntrinsics::ID_LIMIT - 1, &quot;must be&quot;);
185 
186   return vmIntrinsics;
187 }
188 



189 #define PREDEFINED_CONFIG_FLAGS(do_bool_flag, do_intx_flag, do_uintx_flag) \
190   do_intx_flag(AllocateInstancePrefetchLines)                              \
191   do_intx_flag(AllocatePrefetchDistance)                                   \
192   do_intx_flag(AllocatePrefetchInstr)                                      \
193   do_intx_flag(AllocatePrefetchLines)                                      \
194   do_intx_flag(AllocatePrefetchStepSize)                                   \
195   do_intx_flag(AllocatePrefetchStyle)                                      \
196   do_intx_flag(BciProfileWidth)                                            \
197   do_bool_flag(BootstrapJVMCI)                                             \
198   do_bool_flag(CITime)                                                     \
199   do_bool_flag(CITimeEach)                                                 \
200   do_uintx_flag(CodeCacheSegmentSize)                                      \
201   do_intx_flag(CodeEntryAlignment)                                         \

202   do_intx_flag(ContendedPaddingWidth)                                      \
203   do_bool_flag(DontCompileHugeMethods)                                     \
204   do_bool_flag(EagerJVMCI)                                                 \
205   do_bool_flag(EnableContended)                                            \

206   do_bool_flag(FoldStableValues)                                           \
207   do_bool_flag(ForceUnreachable)                                           \
208   do_intx_flag(HugeMethodLimit)                                            \
209   do_bool_flag(Inline)                                                     \
210   do_intx_flag(JVMCICounterSize)                                           \
211   do_bool_flag(JVMCIPrintProperties)                                       \
212   do_bool_flag(JVMCIUseFastLocking)                                        \
213   do_intx_flag(MethodProfileWidth)                                         \
214   do_intx_flag(ObjectAlignmentInBytes)                                     \
215   do_bool_flag(PrintInlining)                                              \
216   do_bool_flag(ReduceInitialCardMarks)                                     \
217   do_bool_flag(RestrictContended)                                          \
218   do_intx_flag(StackReservedPages)                                         \
219   do_intx_flag(StackShadowPages)                                           \
220   do_bool_flag(TLABStats)                                                  \
221   do_uintx_flag(TLABWasteIncrement)                                        \
222   do_intx_flag(TypeProfileWidth)                                           \
223   do_bool_flag(UseAESIntrinsics)                                           \
224   X86_ONLY(do_intx_flag(UseAVX))                                           \
225   do_bool_flag(UseBiasedLocking)                                           \
226   do_bool_flag(UseCRC32Intrinsics)                                         \
227   do_bool_flag(UseCompressedClassPointers)                                 \
228   do_bool_flag(UseCompressedOops)                                          \
229   X86_ONLY(do_bool_flag(UseCountLeadingZerosInstruction))                  \
230   X86_ONLY(do_bool_flag(UseCountTrailingZerosInstruction))                 \

231   do_bool_flag(UseG1GC)                                                    \
232   do_bool_flag(UseParallelGC)                                              \

233   do_bool_flag(UseSerialGC)                                                \
234   do_bool_flag(UseZGC)                                                     \
235   do_bool_flag(UseEpsilonGC)                                               \
236   COMPILER2_PRESENT(do_bool_flag(UseMontgomeryMultiplyIntrinsic))          \
237   COMPILER2_PRESENT(do_bool_flag(UseMontgomerySquareIntrinsic))            \
238   COMPILER2_PRESENT(do_bool_flag(UseMulAddIntrinsic))                      \
239   COMPILER2_PRESENT(do_bool_flag(UseMultiplyToLenIntrinsic))               \
240   do_bool_flag(UsePopCountInstruction)                                     \
241   do_bool_flag(UseSHA1Intrinsics)                                          \
242   do_bool_flag(UseSHA256Intrinsics)                                        \
243   do_bool_flag(UseSHA512Intrinsics)                                        \
244   do_intx_flag(UseSSE)                                                     \
245   COMPILER2_PRESENT(do_bool_flag(UseSquareToLenIntrinsic))                 \
246   do_bool_flag(UseStackBanging)                                            \
247   do_bool_flag(UseTLAB)                                                    \
248   do_bool_flag(VerifyOops)                                                 \
249 
<span class="line-modified">250 #define BOXED_BOOLEAN(name, value) name = ((jboolean)(value) ? boxedTrue : boxedFalse)</span>
<span class="line-modified">251 #define BOXED_DOUBLE(name, value) do { jvalue p; p.d = (jdouble) (value); name = JVMCIENV-&gt;create_box(T_DOUBLE, &amp;p, JVMCI_CHECK_NULL);} while(0)</span>
252 #define BOXED_LONG(name, value) \

253   do { \
254     jvalue p; p.j = (jlong) (value); \
<span class="line-modified">255     JVMCIObject* e = longs.get(p.j); \</span>
256     if (e == NULL) { \
<span class="line-modified">257       JVMCIObject h = JVMCIENV-&gt;create_box(T_LONG, &amp;p, JVMCI_CHECK_NULL); \</span>

258       longs.put(p.j, h); \
<span class="line-modified">259       name = h; \</span>
260     } else { \
<span class="line-modified">261       name = (*e); \</span>
262     } \
263   } while (0)
264 
265 #define CSTRING_TO_JSTRING(name, value) \
<span class="line-modified">266   JVMCIObject name; \</span>
267   do { \
268     if (value != NULL) { \
<span class="line-modified">269       JVMCIObject* e = strings.get(value); \</span>
270       if (e == NULL) { \
<span class="line-modified">271         JVMCIObject h = JVMCIENV-&gt;create_string(value, JVMCI_CHECK_NULL); \</span>
272         strings.put(value, h); \
273         name = h; \
274       } else { \
275         name = (*e); \
276       } \
277     } \
278   } while (0)
279 
<span class="line-modified">280 jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS) {</span>
<span class="line-modified">281   Thread* THREAD = Thread::current();</span>
<span class="line-modified">282   ResourceHashtable&lt;jlong, JVMCIObject&gt; longs;</span>
<span class="line-modified">283   ResourceHashtable&lt;const char*, JVMCIObject, &amp;CompilerToVM::cstring_hash, &amp;CompilerToVM::cstring_equals&gt; strings;</span>



284 
285   jvalue prim;
<span class="line-modified">286   prim.z = true;  JVMCIObject boxedTrue =  JVMCIENV-&gt;create_box(T_BOOLEAN, &amp;prim, JVMCI_CHECK_NULL);</span>
<span class="line-modified">287   prim.z = false; JVMCIObject boxedFalse = JVMCIENV-&gt;create_box(T_BOOLEAN, &amp;prim, JVMCI_CHECK_NULL);</span>


288 
<span class="line-modified">289   CompilerToVM::Data::initialize(JVMCI_CHECK_NULL);</span>
290 
<span class="line-modified">291   JVMCIENV-&gt;VMField_initialize(JVMCI_CHECK_NULL);</span>
<span class="line-modified">292   JVMCIENV-&gt;VMFlag_initialize(JVMCI_CHECK_NULL);</span>
<span class="line-modified">293   JVMCIENV-&gt;VMIntrinsicMethod_initialize(JVMCI_CHECK_NULL);</span>
294 
295   int len = JVMCIVMStructs::localHotSpotVMStructs_count();
<span class="line-modified">296   JVMCIObjectArray vmFields = JVMCIENV-&gt;new_VMField_array(len, JVMCI_CHECK_NULL);</span>
297   for (int i = 0; i &lt; len ; i++) {
298     VMStructEntry vmField = JVMCIVMStructs::localHotSpotVMStructs[i];

299     size_t name_buf_len = strlen(vmField.typeName) + strlen(vmField.fieldName) + 2 /* &quot;::&quot; */;
300     char* name_buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, name_buf_len + 1);
301     sprintf(name_buf, &quot;%s::%s&quot;, vmField.typeName, vmField.fieldName);
302     CSTRING_TO_JSTRING(name, name_buf);
303     CSTRING_TO_JSTRING(type, vmField.typeString);
<span class="line-modified">304     JVMCIObject box;</span>



305     if (vmField.isStatic &amp;&amp; vmField.typeString != NULL) {
306       if (strcmp(vmField.typeString, &quot;bool&quot;) == 0) {
307         BOXED_BOOLEAN(box, *(jbyte*) vmField.address);
<span class="line-modified">308         assert(box.is_non_null(), &quot;must have a box&quot;);</span>
309       } else if (strcmp(vmField.typeString, &quot;int&quot;) == 0 ||
<span class="line-modified">310                  strcmp(vmField.typeString, &quot;jint&quot;) == 0 ||</span>
<span class="line-added">311                  strcmp(vmField.typeString, &quot;uint32_t&quot;) == 0) {</span>
312         BOXED_LONG(box, *(jint*) vmField.address);
<span class="line-modified">313         assert(box.is_non_null(), &quot;must have a box&quot;);</span>
314       } else if (strcmp(vmField.typeString, &quot;uint64_t&quot;) == 0) {
315         BOXED_LONG(box, *(uint64_t*) vmField.address);
<span class="line-modified">316         assert(box.is_non_null(), &quot;must have a box&quot;);</span>
317       } else if (strcmp(vmField.typeString, &quot;address&quot;) == 0 ||
318                  strcmp(vmField.typeString, &quot;intptr_t&quot;) == 0 ||
319                  strcmp(vmField.typeString, &quot;uintptr_t&quot;) == 0 ||
320                  strcmp(vmField.typeString, &quot;OopHandle&quot;) == 0 ||
321                  strcmp(vmField.typeString, &quot;size_t&quot;) == 0 ||
322                  // All foo* types are addresses.
323                  vmField.typeString[strlen(vmField.typeString) - 1] == &#39;*&#39;) {
324         BOXED_LONG(box, *((address*) vmField.address));
<span class="line-modified">325         assert(box.is_non_null(), &quot;must have a box&quot;);</span>
326       } else {
327         JVMCI_ERROR_NULL(&quot;VM field %s has unsupported type %s&quot;, name_buf, vmField.typeString);
328       }
329     }
<span class="line-modified">330     JVMCIObject vmFieldObj = JVMCIENV-&gt;new_VMField(name, type, vmField.offset, (jlong) vmField.address, box, JVMCI_CHECK_NULL);</span>
<span class="line-added">331     JVMCIENV-&gt;put_object_at(vmFields, i, vmFieldObj);</span>
332   }
333 
334   int ints_len = JVMCIVMStructs::localHotSpotVMIntConstants_count();
335   int longs_len = JVMCIVMStructs::localHotSpotVMLongConstants_count();
336   len = ints_len + longs_len;
<span class="line-modified">337   JVMCIObjectArray vmConstants = JVMCIENV-&gt;new_Object_array(len * 2, JVMCI_CHECK_NULL);</span>
338   int insert = 0;
339   for (int i = 0; i &lt; ints_len ; i++) {
340     VMIntConstantEntry c = JVMCIVMStructs::localHotSpotVMIntConstants[i];
341     CSTRING_TO_JSTRING(name, c.name);
<span class="line-added">342     JVMCIObject value;</span>
343     BOXED_LONG(value, c.value);
<span class="line-modified">344     JVMCIENV-&gt;put_object_at(vmConstants, insert++, name);</span>
<span class="line-modified">345     JVMCIENV-&gt;put_object_at(vmConstants, insert++, value);</span>
346   }
347   for (int i = 0; i &lt; longs_len ; i++) {
348     VMLongConstantEntry c = JVMCIVMStructs::localHotSpotVMLongConstants[i];
349     CSTRING_TO_JSTRING(name, c.name);
<span class="line-added">350     JVMCIObject value;</span>
351     BOXED_LONG(value, c.value);
<span class="line-modified">352     JVMCIENV-&gt;put_object_at(vmConstants, insert++, name);</span>
<span class="line-modified">353     JVMCIENV-&gt;put_object_at(vmConstants, insert++, value);</span>
354   }
355   assert(insert == len * 2, &quot;must be&quot;);
356 
357   len = JVMCIVMStructs::localHotSpotVMAddresses_count();
<span class="line-modified">358   JVMCIObjectArray vmAddresses = JVMCIENV-&gt;new_Object_array(len * 2, JVMCI_CHECK_NULL);</span>
359   for (int i = 0; i &lt; len ; i++) {
360     VMAddressEntry a = JVMCIVMStructs::localHotSpotVMAddresses[i];
361     CSTRING_TO_JSTRING(name, a.name);
<span class="line-added">362     JVMCIObject value;</span>
363     BOXED_LONG(value, a.value);
<span class="line-modified">364     JVMCIENV-&gt;put_object_at(vmAddresses, i * 2, name);</span>
<span class="line-modified">365     JVMCIENV-&gt;put_object_at(vmAddresses, i * 2 + 1, value);</span>
366   }
367 
368 #define COUNT_FLAG(ignore) +1
369 #ifdef ASSERT
370 #define CHECK_FLAG(type, name) { \
<span class="line-modified">371   const JVMFlag* flag = JVMFlag::find_declared_flag(#name); \</span>
372   assert(flag != NULL, &quot;No such flag named &quot; #name); \
373   assert(flag-&gt;is_##type(), &quot;JVMFlag &quot; #name &quot; is not of type &quot; #type); \
374 }
375 #else
376 #define CHECK_FLAG(type, name)
377 #endif
378 
<span class="line-modified">379 #define ADD_FLAG(type, name, convert) {                                                \</span>
<span class="line-modified">380   CHECK_FLAG(type, name)                                                               \</span>
<span class="line-modified">381   CSTRING_TO_JSTRING(fname, #name);                                                    \</span>
<span class="line-modified">382   CSTRING_TO_JSTRING(ftype, #type);                                                    \</span>
<span class="line-modified">383   convert(value, name);                                                                \</span>
<span class="line-modified">384   JVMCIObject vmFlagObj = JVMCIENV-&gt;new_VMFlag(fname, ftype, value, JVMCI_CHECK_NULL); \</span>
<span class="line-modified">385   JVMCIENV-&gt;put_object_at(vmFlags, i++, vmFlagObj);                                    \</span>



386 }
387 #define ADD_BOOL_FLAG(name)  ADD_FLAG(bool, name, BOXED_BOOLEAN)
388 #define ADD_INTX_FLAG(name)  ADD_FLAG(intx, name, BOXED_LONG)
389 #define ADD_UINTX_FLAG(name) ADD_FLAG(uintx, name, BOXED_LONG)
390 
391   len = 0 + PREDEFINED_CONFIG_FLAGS(COUNT_FLAG, COUNT_FLAG, COUNT_FLAG);
<span class="line-modified">392   JVMCIObjectArray vmFlags = JVMCIENV-&gt;new_VMFlag_array(len, JVMCI_CHECK_NULL);</span>
393   int i = 0;
<span class="line-added">394   JVMCIObject value;</span>
395   PREDEFINED_CONFIG_FLAGS(ADD_BOOL_FLAG, ADD_INTX_FLAG, ADD_UINTX_FLAG)
396 
<span class="line-modified">397   JVMCIObjectArray vmIntrinsics = CompilerToVM::initialize_intrinsics(JVMCI_CHECK_NULL);</span>
<span class="line-modified">398 </span>
<span class="line-modified">399   JVMCIObjectArray data = JVMCIENV-&gt;new_Object_array(5, JVMCI_CHECK_NULL);</span>
<span class="line-modified">400   JVMCIENV-&gt;put_object_at(data, 0, vmFields);</span>
<span class="line-modified">401   JVMCIENV-&gt;put_object_at(data, 1, vmConstants);</span>
<span class="line-modified">402   JVMCIENV-&gt;put_object_at(data, 2, vmAddresses);</span>
<span class="line-modified">403   JVMCIENV-&gt;put_object_at(data, 3, vmFlags);</span>
<span class="line-modified">404   JVMCIENV-&gt;put_object_at(data, 4, vmIntrinsics);</span>
<span class="line-modified">405 </span>
<span class="line-modified">406   return JVMCIENV-&gt;get_jobjectArray(data);</span>






407 }
</pre>
</td>
</tr>
</table>
<center><a href="jvmciCompilerToVM.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciEnv.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
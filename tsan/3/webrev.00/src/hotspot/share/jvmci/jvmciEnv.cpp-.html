<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jvmci/jvmciEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvmci/jvmciEnv.hpp&quot;
 27 #include &quot;classfile/javaAssertions.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;classfile/vmSymbols.hpp&quot;
 30 #include &quot;code/codeCache.hpp&quot;
 31 #include &quot;code/scopeDesc.hpp&quot;
 32 #include &quot;compiler/compileBroker.hpp&quot;
 33 #include &quot;compiler/compileLog.hpp&quot;
 34 #include &quot;compiler/compilerOracle.hpp&quot;
 35 #include &quot;interpreter/linkResolver.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;memory/oopFactory.hpp&quot;
 38 #include &quot;memory/resourceArea.hpp&quot;
 39 #include &quot;memory/universe.hpp&quot;
 40 #include &quot;oops/constantPool.inline.hpp&quot;
 41 #include &quot;oops/cpCache.inline.hpp&quot;
 42 #include &quot;oops/method.inline.hpp&quot;
 43 #include &quot;oops/methodData.hpp&quot;
 44 #include &quot;oops/objArrayKlass.hpp&quot;
 45 #include &quot;oops/oop.inline.hpp&quot;
 46 #include &quot;prims/jvmtiExport.hpp&quot;
 47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 48 #include &quot;runtime/handles.inline.hpp&quot;
 49 #include &quot;runtime/init.hpp&quot;
 50 #include &quot;runtime/reflection.hpp&quot;
 51 #include &quot;runtime/sharedRuntime.hpp&quot;
 52 #include &quot;runtime/sweeper.hpp&quot;
 53 #include &quot;utilities/dtrace.hpp&quot;
 54 #include &quot;jvmci/jvmciRuntime.hpp&quot;
 55 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
 56 
 57 JVMCIEnv::JVMCIEnv(CompileTask* task, int system_dictionary_modification_counter):
 58   _task(task),
 59   _system_dictionary_modification_counter(system_dictionary_modification_counter),
 60   _retryable(true),
 61   _failure_reason(NULL),
 62   _failure_reason_on_C_heap(false)
 63 {
 64   // Get Jvmti capabilities under lock to get consistent values.
 65   MutexLocker mu(JvmtiThreadState_lock);
 66   _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint() ? 1 : 0;
 67   _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables() ? 1 : 0;
 68   _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions() ? 1 : 0;
 69   _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame() ? 1 : 0;
 70 }
 71 
 72 bool JVMCIEnv::jvmti_state_changed() const {
 73   if (!jvmti_can_access_local_variables() &amp;&amp;
 74       JvmtiExport::can_access_local_variables()) {
 75     return true;
 76   }
 77   if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
 78       JvmtiExport::can_hotswap_or_post_breakpoint()) {
 79     return true;
 80   }
 81   if (!jvmti_can_post_on_exceptions() &amp;&amp;
 82       JvmtiExport::can_post_on_exceptions()) {
 83     return true;
 84   }
 85   if (!jvmti_can_pop_frame() &amp;&amp;
 86       JvmtiExport::can_pop_frame()) {
 87     return true;
 88   }
 89   return false;
 90 }
 91 
 92 // ------------------------------------------------------------------
 93 // Note: the logic of this method should mirror the logic of
 94 // constantPoolOopDesc::verify_constant_pool_resolve.
 95 bool JVMCIEnv::check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass) {
 96   if (accessing_klass-&gt;is_objArray_klass()) {
 97     accessing_klass = ObjArrayKlass::cast(accessing_klass)-&gt;bottom_klass();
 98   }
 99   if (!accessing_klass-&gt;is_instance_klass()) {
100     return true;
101   }
102 
103   if (resolved_klass-&gt;is_objArray_klass()) {
104     // Find the element klass, if this is an array.
105     resolved_klass = ObjArrayKlass::cast(resolved_klass)-&gt;bottom_klass();
106   }
107   if (resolved_klass-&gt;is_instance_klass()) {
108     Reflection::VerifyClassAccessResults result =
109       Reflection::verify_class_access(accessing_klass, InstanceKlass::cast(resolved_klass), true);
110     return result == Reflection::ACCESS_OK;
111   }
112   return true;
113 }
114 
115 // ------------------------------------------------------------------
116 Klass* JVMCIEnv::get_klass_by_name_impl(Klass* accessing_klass,
117                                         const constantPoolHandle&amp; cpool,
118                                         Symbol* sym,
119                                         bool require_local) {
120   JVMCI_EXCEPTION_CONTEXT;
121 
122   // Now we need to check the SystemDictionary
123   if (sym-&gt;char_at(0) == &#39;L&#39; &amp;&amp;
124     sym-&gt;char_at(sym-&gt;utf8_length()-1) == &#39;;&#39;) {
125     // This is a name from a signature.  Strip off the trimmings.
126     // Call recursive to keep scope of strippedsym.
127     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
128                     sym-&gt;utf8_length()-2,
129                     CHECK_NULL);
130     return get_klass_by_name_impl(accessing_klass, cpool, strippedsym, require_local);
131   }
132 
133   Handle loader(THREAD, (oop)NULL);
134   Handle domain(THREAD, (oop)NULL);
135   if (accessing_klass != NULL) {
136     loader = Handle(THREAD, accessing_klass-&gt;class_loader());
137     domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
138   }
139 
140   Klass* found_klass = NULL;
141   {
142     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems
143     MutexLocker ml(Compile_lock);
144     if (!require_local) {
145       found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, CHECK_NULL);
146     } else {
147       found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain, CHECK_NULL);
148     }
149   }
150 
151   // If we fail to find an array klass, look again for its element type.
152   // The element type may be available either locally or via constraints.
153   // In either case, if we can find the element type in the system dictionary,
154   // we must build an array type around it.  The CI requires array klasses
155   // to be loaded if their element klasses are loaded, except when memory
156   // is exhausted.
157   if (sym-&gt;char_at(0) == &#39;[&#39; &amp;&amp;
158       (sym-&gt;char_at(1) == &#39;[&#39; || sym-&gt;char_at(1) == &#39;L&#39;)) {
159     // We have an unloaded array.
160     // Build it on the fly if the element class exists.
161     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
162                                                  sym-&gt;utf8_length()-1,
163                                                  CHECK_NULL);
164 
165     // Get element Klass recursively.
166     Klass* elem_klass =
167       get_klass_by_name_impl(accessing_klass,
168                              cpool,
169                              elem_sym,
170                              require_local);
171     if (elem_klass != NULL) {
172       // Now make an array for it
173       return elem_klass-&gt;array_klass(THREAD);
174     }
175   }
176 
177   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {
178     // Look inside the constant pool for pre-resolved class entries.
179     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {
180       if (cpool-&gt;tag_at(i).is_klass()) {
181         Klass*  kls = cpool-&gt;resolved_klass_at(i);
182         if (kls-&gt;name() == sym) {
183           return kls;
184         }
185       }
186     }
187   }
188 
189   return found_klass;
190 }
191 
192 // ------------------------------------------------------------------
193 Klass* JVMCIEnv::get_klass_by_name(Klass* accessing_klass,
194                                   Symbol* klass_name,
195                                   bool require_local) {
196   ResourceMark rm;
197   constantPoolHandle cpool;
198   return get_klass_by_name_impl(accessing_klass,
199                                 cpool,
200                                 klass_name,
201                                 require_local);
202 }
203 
204 // ------------------------------------------------------------------
205 // Implementation of get_klass_by_index.
206 Klass* JVMCIEnv::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
207                                         int index,
208                                         bool&amp; is_accessible,
209                                         Klass* accessor) {
210   JVMCI_EXCEPTION_CONTEXT;
211   Klass* klass = ConstantPool::klass_at_if_loaded(cpool, index);
212   Symbol* klass_name = NULL;
213   if (klass == NULL) {
214     klass_name = cpool-&gt;klass_name_at(index);
215   }
216 
217   if (klass == NULL) {
218     // Not found in constant pool.  Use the name to do the lookup.
219     Klass* k = get_klass_by_name_impl(accessor,
220                                       cpool,
221                                       klass_name,
222                                       false);
223     // Calculate accessibility the hard way.
224     if (k == NULL) {
225       is_accessible = false;
226     } else if (k-&gt;class_loader() != accessor-&gt;class_loader() &amp;&amp;
227                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {
228       // Loaded only remotely.  Not linked yet.
229       is_accessible = false;
230     } else {
231       // Linked locally, and we must also check public/private, etc.
232       is_accessible = check_klass_accessibility(accessor, k);
233     }
234     if (!is_accessible) {
235       return NULL;
236     }
237     return k;
238   }
239 
240   // It is known to be accessible, since it was found in the constant pool.
241   is_accessible = true;
242   return klass;
243 }
244 
245 // ------------------------------------------------------------------
246 // Get a klass from the constant pool.
247 Klass* JVMCIEnv::get_klass_by_index(const constantPoolHandle&amp; cpool,
248                                     int index,
249                                     bool&amp; is_accessible,
250                                     Klass* accessor) {
251   ResourceMark rm;
252   return get_klass_by_index_impl(cpool, index, is_accessible, accessor);
253 }
254 
255 // ------------------------------------------------------------------
256 // Implementation of get_field_by_index.
257 //
258 // Implementation note: the results of field lookups are cached
259 // in the accessor klass.
260 void JVMCIEnv::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor&amp; field_desc,
261                                         int index) {
262   JVMCI_EXCEPTION_CONTEXT;
263 
264   assert(klass-&gt;is_linked(), &quot;must be linked before using its constant-pool&quot;);
265 
266   constantPoolHandle cpool(thread, klass-&gt;constants());
267 
268   // Get the field&#39;s name, signature, and type.
269   Symbol* name  = cpool-&gt;name_ref_at(index);
270 
271   int nt_index = cpool-&gt;name_and_type_ref_index_at(index);
272   int sig_index = cpool-&gt;signature_ref_index_at(nt_index);
273   Symbol* signature = cpool-&gt;symbol_at(sig_index);
274 
275   // Get the field&#39;s declared holder.
276   int holder_index = cpool-&gt;klass_ref_index_at(index);
277   bool holder_is_accessible;
278   Klass* declared_holder = get_klass_by_index(cpool, holder_index,
279                                               holder_is_accessible,
280                                               klass);
281 
282   // The declared holder of this field may not have been loaded.
283   // Bail out with partial field information.
284   if (!holder_is_accessible) {
285     return;
286   }
287 
288 
289   // Perform the field lookup.
290   Klass*  canonical_holder =
291     InstanceKlass::cast(declared_holder)-&gt;find_field(name, signature, &amp;field_desc);
292   if (canonical_holder == NULL) {
293     return;
294   }
295 
296   assert(canonical_holder == field_desc.field_holder(), &quot;just checking&quot;);
297 }
298 
299 // ------------------------------------------------------------------
300 // Get a field by index from a klass&#39;s constant pool.
301 void JVMCIEnv::get_field_by_index(InstanceKlass* accessor, fieldDescriptor&amp; fd, int index) {
302   ResourceMark rm;
303   return get_field_by_index_impl(accessor, fd, index);
304 }
305 
306 // ------------------------------------------------------------------
307 // Perform an appropriate method lookup based on accessor, holder,
308 // name, signature, and bytecode.
309 methodHandle JVMCIEnv::lookup_method(InstanceKlass* accessor,
310                                Klass*         holder,
311                                Symbol*        name,
312                                Symbol*        sig,
313                                Bytecodes::Code bc,
314                                constantTag   tag) {
315   // Accessibility checks are performed in JVMCIEnv::get_method_by_index_impl().
316   assert(check_klass_accessibility(accessor, holder), &quot;holder not accessible&quot;);
317 
318   methodHandle dest_method;
319   LinkInfo link_info(holder, name, sig, accessor, LinkInfo::needs_access_check, tag);
320   switch (bc) {
321   case Bytecodes::_invokestatic:
322     dest_method =
323       LinkResolver::resolve_static_call_or_null(link_info);
324     break;
325   case Bytecodes::_invokespecial:
326     dest_method =
327       LinkResolver::resolve_special_call_or_null(link_info);
328     break;
329   case Bytecodes::_invokeinterface:
330     dest_method =
331       LinkResolver::linktime_resolve_interface_method_or_null(link_info);
332     break;
333   case Bytecodes::_invokevirtual:
334     dest_method =
335       LinkResolver::linktime_resolve_virtual_method_or_null(link_info);
336     break;
337   default: ShouldNotReachHere();
338   }
339 
340   return dest_method;
341 }
342 
343 
344 // ------------------------------------------------------------------
345 methodHandle JVMCIEnv::get_method_by_index_impl(const constantPoolHandle&amp; cpool,
346                                           int index, Bytecodes::Code bc,
347                                           InstanceKlass* accessor) {
348   if (bc == Bytecodes::_invokedynamic) {
349     ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);
350     bool is_resolved = !cpce-&gt;is_f1_null();
351     if (is_resolved) {
352       // Get the invoker Method* from the constant pool.
353       // (The appendix argument, if any, will be noted in the method&#39;s signature.)
354       Method* adapter = cpce-&gt;f1_as_method();
355       return methodHandle(adapter);
356     }
357 
358     return NULL;
359   }
360 
361   int holder_index = cpool-&gt;klass_ref_index_at(index);
362   bool holder_is_accessible;
363   Klass* holder = get_klass_by_index_impl(cpool, holder_index, holder_is_accessible, accessor);
364 
365   // Get the method&#39;s name and signature.
366   Symbol* name_sym = cpool-&gt;name_ref_at(index);
367   Symbol* sig_sym  = cpool-&gt;signature_ref_at(index);
368 
369   if (cpool-&gt;has_preresolution()
370       || ((holder == SystemDictionary::MethodHandle_klass() || holder == SystemDictionary::VarHandle_klass()) &amp;&amp;
371           MethodHandles::is_signature_polymorphic_name(holder, name_sym))) {
372     // Short-circuit lookups for JSR 292-related call sites.
373     // That is, do not rely only on name-based lookups, because they may fail
374     // if the names are not resolvable in the boot class loader (7056328).
375     switch (bc) {
376     case Bytecodes::_invokevirtual:
377     case Bytecodes::_invokeinterface:
378     case Bytecodes::_invokespecial:
379     case Bytecodes::_invokestatic:
380       {
381         Method* m = ConstantPool::method_at_if_loaded(cpool, index);
382         if (m != NULL) {
383           return m;
384         }
385       }
386       break;
387     default:
388       break;
389     }
390   }
391 
392   if (holder_is_accessible) { // Our declared holder is loaded.
393     constantTag tag = cpool-&gt;tag_ref_at(index);
394     methodHandle m = lookup_method(accessor, holder, name_sym, sig_sym, bc, tag);
395     if (!m.is_null()) {
396       // We found the method.
397       return m;
398     }
399   }
400 
401   // Either the declared holder was not loaded, or the method could
402   // not be found.
403 
404   return NULL;
405 }
406 
407 // ------------------------------------------------------------------
408 InstanceKlass* JVMCIEnv::get_instance_klass_for_declared_method_holder(Klass* method_holder) {
409   // For the case of &lt;array&gt;.clone(), the method holder can be an ArrayKlass*
410   // instead of an InstanceKlass*.  For that case simply pretend that the
411   // declared holder is Object.clone since that&#39;s where the call will bottom out.
412   if (method_holder-&gt;is_instance_klass()) {
413     return InstanceKlass::cast(method_holder);
414   } else if (method_holder-&gt;is_array_klass()) {
415     return SystemDictionary::Object_klass();
416   } else {
417     ShouldNotReachHere();
418   }
419   return NULL;
420 }
421 
422 
423 // ------------------------------------------------------------------
424 methodHandle JVMCIEnv::get_method_by_index(const constantPoolHandle&amp; cpool,
425                                      int index, Bytecodes::Code bc,
426                                      InstanceKlass* accessor) {
427   ResourceMark rm;
428   return get_method_by_index_impl(cpool, index, bc, accessor);
429 }
430 
431 // ------------------------------------------------------------------
432 // Check for changes to the system dictionary during compilation
433 // class loads, evolution, breakpoints
434 JVMCIEnv::CodeInstallResult JVMCIEnv::validate_compile_task_dependencies(Dependencies* dependencies, Handle compiled_code,
435                                                                          JVMCIEnv* env, char** failure_detail) {
436   // If JVMTI capabilities were enabled during compile, the compilation is invalidated.
437   if (env != NULL &amp;&amp; env-&gt;jvmti_state_changed()) {
438     *failure_detail = (char*) &quot;Jvmti state change during compilation invalidated dependencies&quot;;
439     return JVMCIEnv::dependencies_failed;
440   }
441 
442   // Dependencies must be checked when the system dictionary changes
443   // or if we don&#39;t know whether it has changed (i.e., env == NULL).
444   bool counter_changed = env == NULL || env-&gt;_system_dictionary_modification_counter != SystemDictionary::number_of_modifications();
445   CompileTask* task = env == NULL ? NULL : env-&gt;task();
446   Dependencies::DepType result = dependencies-&gt;validate_dependencies(task, counter_changed, failure_detail);
447   if (result == Dependencies::end_marker) {
448     return JVMCIEnv::ok;
449   }
450 
451   if (!Dependencies::is_klass_type(result) || counter_changed) {
452     return JVMCIEnv::dependencies_failed;
453   }
454   // The dependencies were invalid at the time of installation
455   // without any intervening modification of the system
456   // dictionary.  That means they were invalidly constructed.
457   return JVMCIEnv::dependencies_invalid;
458 }
459 
460 // ------------------------------------------------------------------
461 JVMCIEnv::CodeInstallResult JVMCIEnv::register_method(
462                                 const methodHandle&amp; method,
463                                 nmethod*&amp; nm,
464                                 int entry_bci,
465                                 CodeOffsets* offsets,
466                                 int orig_pc_offset,
467                                 CodeBuffer* code_buffer,
468                                 int frame_words,
469                                 OopMapSet* oop_map_set,
470                                 ExceptionHandlerTable* handler_table,
471                                 AbstractCompiler* compiler,
472                                 DebugInformationRecorder* debug_info,
473                                 Dependencies* dependencies,
474                                 JVMCIEnv* env,
475                                 int compile_id,
476                                 bool has_unsafe_access,
477                                 bool has_wide_vector,
478                                 Handle installed_code,
479                                 Handle compiled_code,
480                                 Handle speculation_log) {
481   JVMCI_EXCEPTION_CONTEXT;
482   nm = NULL;
483   int comp_level = CompLevel_full_optimization;
484   char* failure_detail = NULL;
485   JVMCIEnv::CodeInstallResult result;
486   {
487     // To prevent compile queue updates.
488     MutexLocker locker(MethodCompileQueue_lock, THREAD);
489 
490     // Prevent SystemDictionary::add_to_hierarchy from running
491     // and invalidating our dependencies until we install this method.
492     MutexLocker ml(Compile_lock);
493 
494     // Encode the dependencies now, so we can check them right away.
495     dependencies-&gt;encode_content_bytes();
496 
497     // Record the dependencies for the current compile in the log
498     if (LogCompilation) {
499       for (Dependencies::DepStream deps(dependencies); deps.next(); ) {
500         deps.log_dependency();
501       }
502     }
503 
504     // Check for {class loads, evolution, breakpoints} during compilation
505     result = validate_compile_task_dependencies(dependencies, compiled_code, env, &amp;failure_detail);
506     if (result != JVMCIEnv::ok) {
507       // While not a true deoptimization, it is a preemptive decompile.
508       MethodData* mdp = method()-&gt;method_data();
509       if (mdp != NULL) {
510         mdp-&gt;inc_decompile_count();
511 #ifdef ASSERT
512         if (mdp-&gt;decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
513           ResourceMark m;
514           tty-&gt;print_cr(&quot;WARN: endless recompilation of %s. Method was set to not compilable.&quot;, method()-&gt;name_and_sig_as_C_string());
515         }
516 #endif
517       }
518 
519       // All buffers in the CodeBuffer are allocated in the CodeCache.
520       // If the code buffer is created on each compile attempt
521       // as in C2, then it must be freed.
522       //code_buffer-&gt;free_blob();
523     } else {
524       ImplicitExceptionTable implicit_tbl;
525       nm =  nmethod::new_nmethod(method,
526                                  compile_id,
527                                  entry_bci,
528                                  offsets,
529                                  orig_pc_offset,
530                                  debug_info, dependencies, code_buffer,
531                                  frame_words, oop_map_set,
532                                  handler_table, &amp;implicit_tbl,
533                                  compiler, comp_level,
534                                  JNIHandles::make_weak_global(installed_code),
535                                  JNIHandles::make_weak_global(speculation_log));
536 
537       // Free codeBlobs
538       //code_buffer-&gt;free_blob();
539       if (nm == NULL) {
540         // The CodeCache is full.  Print out warning and disable compilation.
541         {
542           MutexUnlocker ml(Compile_lock);
543           MutexUnlocker locker(MethodCompileQueue_lock);
544           CompileBroker::handle_full_code_cache(CodeCache::get_code_blob_type(comp_level));
545         }
546       } else {
547         nm-&gt;set_has_unsafe_access(has_unsafe_access);
548         nm-&gt;set_has_wide_vectors(has_wide_vector);
549 
550         // Record successful registration.
551         // (Put nm into the task handle *before* publishing to the Java heap.)
552         CompileTask* task = env == NULL ? NULL : env-&gt;task();
553         if (task != NULL) {
554           task-&gt;set_code(nm);
555         }
556 
557         if (installed_code-&gt;is_a(HotSpotNmethod::klass()) &amp;&amp; HotSpotNmethod::isDefault(installed_code())) {
558           if (entry_bci == InvocationEntryBci) {
559             if (TieredCompilation) {
560               // If there is an old version we&#39;re done with it
561               CompiledMethod* old = method-&gt;code();
562               if (TraceMethodReplacement &amp;&amp; old != NULL) {
563                 ResourceMark rm;
564                 char *method_name = method-&gt;name_and_sig_as_C_string();
565                 tty-&gt;print_cr(&quot;Replacing method %s&quot;, method_name);
566               }
567               if (old != NULL ) {
568                 old-&gt;make_not_entrant();
569               }
570             }
571             if (TraceNMethodInstalls) {
572               ResourceMark rm;
573               char *method_name = method-&gt;name_and_sig_as_C_string();
574               ttyLocker ttyl;
575               tty-&gt;print_cr(&quot;Installing method (%d) %s [entry point: %p]&quot;,
576                             comp_level,
577                             method_name, nm-&gt;entry_point());
578             }
579             // Allow the code to be executed
580             method-&gt;set_code(method, nm);
581           } else {
582             if (TraceNMethodInstalls ) {
583               ResourceMark rm;
584               char *method_name = method-&gt;name_and_sig_as_C_string();
585               ttyLocker ttyl;
586               tty-&gt;print_cr(&quot;Installing osr method (%d) %s @ %d&quot;,
587                             comp_level,
588                             method_name,
589                             entry_bci);
590             }
591             InstanceKlass::cast(method-&gt;method_holder())-&gt;add_osr_nmethod(nm);
592           }
593         }
594         nm-&gt;make_in_use();
595       }
596       result = nm != NULL ? JVMCIEnv::ok :JVMCIEnv::cache_full;
597     }
598   }
599 
600   // String creation must be done outside lock
601   if (failure_detail != NULL) {
602     // A failure to allocate the string is silently ignored.
603     Handle message = java_lang_String::create_from_str(failure_detail, THREAD);
604     HotSpotCompiledNmethod::set_installationFailureMessage(compiled_code, message());
605   }
606 
607   // JVMTI -- compiled method notification (must be done outside lock)
608   if (nm != NULL) {
609     nm-&gt;post_compiled_method_load_event();
610 
611     if (env == NULL) {
612       // This compile didn&#39;t come through the CompileBroker so perform the printing here
613       DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);
614       nm-&gt;maybe_print_nmethod(directive);
615       DirectivesStack::release(directive);
616     }
617   }
618 
619   return result;
620 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciJavaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;classfile/symbolTable.hpp&quot;
<a name="2" id="anc2"></a>

 26 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
<a name="3" id="anc3"></a>
 27 #include &quot;memory/resourceArea.hpp&quot;
<a name="4" id="anc4"></a><span class="line-removed"> 28 #include &quot;oops/oop.inline.hpp&quot;</span>
 29 #include &quot;runtime/jniHandles.inline.hpp&quot;
 30 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 31 
<a name="5" id="anc5"></a>
 32 
<a name="6" id="anc6"></a><span class="line-modified"> 33 // This macro expands for non-inline functions, in class declarations.</span>


 34 
<a name="7" id="anc7"></a><span class="line-modified"> 35 #define START_CLASS(name)                                                                                                                                \</span>
<span class="line-modified"> 36     void name::check(oop obj, const char* field_name, int offset) {                                                                                          \</span>
<span class="line-modified"> 37       assert(obj != NULL, &quot;NULL field access of %s.%s&quot;, #name, field_name);                                                                                  \</span>
<span class="line-modified"> 38       assert(obj-&gt;is_a(SystemDictionary::name##_klass()), &quot;wrong class, &quot; #name &quot; expected, found %s&quot;, obj-&gt;klass()-&gt;external_name());                       \</span>
<span class="line-modified"> 39       assert(offset != 0, &quot;must be valid offset&quot;);                                                                                                           \</span>
<span class="line-modified"> 40     }</span>















































































































































 41 
 42 #define END_CLASS
 43 
<a name="8" id="anc8"></a><span class="line-modified"> 44 #define FIELD(klass, name, type, accessor, cast)                                                                                                                                \</span>
<span class="line-modified"> 45     type klass::name(jobject obj)               { check(JNIHandles::resolve(obj), #name, _##name##_offset); return cast JNIHandles::resolve(obj)-&gt;accessor(_##name##_offset); }     \</span>
<span class="line-modified"> 46     void klass::set_##name(jobject obj, type x) { check(JNIHandles::resolve(obj), #name, _##name##_offset); JNIHandles::resolve(obj)-&gt;accessor##_put(_##name##_offset, x); }</span>
 47 
 48 #define EMPTY_CAST
<a name="9" id="anc9"></a><span class="line-modified"> 49 #define CHAR_FIELD(klass, name) FIELD(klass, name, jchar, char_field, EMPTY_CAST)</span>
<span class="line-modified"> 50 #define INT_FIELD(klass, name) FIELD(klass, name, jint, int_field, EMPTY_CAST)</span>
<span class="line-modified"> 51 #define BOOLEAN_FIELD(klass, name) FIELD(klass, name, jboolean, bool_field, EMPTY_CAST)</span>
<span class="line-modified"> 52 #define LONG_FIELD(klass, name) FIELD(klass, name, jlong, long_field, EMPTY_CAST)</span>
<span class="line-modified"> 53 #define FLOAT_FIELD(klass, name) FIELD(klass, name, jfloat, float_field, EMPTY_CAST)</span>
<span class="line-modified"> 54 #define OOP_FIELD(klass, name, signature) FIELD(klass, name, oop, obj_field, EMPTY_CAST)</span>
<span class="line-modified"> 55 #define OBJARRAYOOP_FIELD(klass, name, signature) FIELD(klass, name, objArrayOop, obj_field, (objArrayOop))</span>
<span class="line-modified"> 56 #define TYPEARRAYOOP_FIELD(klass, name, signature) FIELD(klass, name, typeArrayOop, obj_field, (typeArrayOop))</span>
<span class="line-modified"> 57 #define STATIC_OOP_FIELD(klassName, name, signature) STATIC_OOPISH_FIELD(klassName, name, oop, signature)</span>
<span class="line-modified"> 58 #define STATIC_OBJARRAYOOP_FIELD(klassName, name, signature) STATIC_OOPISH_FIELD(klassName, name, objArrayOop, signature)</span>
<span class="line-modified"> 59 #define STATIC_OOPISH_FIELD(klassName, name, type, signature)                                                  \</span>
<span class="line-modified"> 60     type klassName::name() {                                                                                   \</span>
<span class="line-modified"> 61       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \</span>
<span class="line-modified"> 62       InstanceKlass* ik = klassName::klass();                                                                  \</span>
<span class="line-modified"> 63       oop base = ik-&gt;static_field_base_raw();                                                                  \</span>
<span class="line-modified"> 64       oop result = HeapAccess&lt;&gt;::oop_load_at(base, _##name##_offset);                                          \</span>
<span class="line-modified"> 65       return type(result);                                                                                     \</span>
<span class="line-modified"> 66     }                                                                                                          \</span>
<span class="line-modified"> 67     void klassName::set_##name(type x) {                                                                       \</span>
<span class="line-modified"> 68       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \</span>
<span class="line-modified"> 69       assert(klassName::klass() != NULL, &quot;Class not yet loaded: &quot; #klassName);                                 \</span>
<span class="line-modified"> 70       InstanceKlass* ik = klassName::klass();                                                                  \</span>
<span class="line-modified"> 71       oop base = ik-&gt;static_field_base_raw();                                                                  \</span>
<span class="line-modified"> 72       HeapAccess&lt;&gt;::oop_store_at(base, _##name##_offset, x);                                                   \</span>

 73     }
<a name="10" id="anc10"></a><span class="line-modified"> 74 #define STATIC_PRIMITIVE_FIELD(klassName, name, jtypename)                                                     \</span>
<span class="line-modified"> 75     jtypename klassName::name() {                                                                              \</span>
<span class="line-modified"> 76       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \</span>
<span class="line-modified"> 77       InstanceKlass* ik = klassName::klass();                                                                  \</span>
<span class="line-modified"> 78       oop base = ik-&gt;static_field_base_raw();                                                                  \</span>
<span class="line-modified"> 79       return HeapAccess&lt;&gt;::load_at(base, _##name##_offset);                                                    \</span>
<span class="line-modified"> 80     }                                                                                                          \</span>
<span class="line-modified"> 81     void klassName::set_##name(jtypename x) {                                                                  \</span>
<span class="line-modified"> 82       assert(klassName::klass() != NULL &amp;&amp; klassName::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #klassName); \</span>
<span class="line-modified"> 83       InstanceKlass* ik = klassName::klass();                                                                  \</span>
<span class="line-modified"> 84       oop base = ik-&gt;static_field_base_raw();                                                                  \</span>
<span class="line-modified"> 85       HeapAccess&lt;&gt;::store_at(base, _##name##_offset, x);                                                       \</span>
 86     }
 87 
<a name="11" id="anc11"></a><span class="line-modified"> 88 #define STATIC_INT_FIELD(klassName, name) STATIC_PRIMITIVE_FIELD(klassName, name, jint)</span>
<span class="line-modified"> 89 #define STATIC_BOOLEAN_FIELD(klassName, name) STATIC_PRIMITIVE_FIELD(klassName, name, jboolean)</span>















 90 
<a name="12" id="anc12"></a><span class="line-removed"> 91 COMPILER_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OOP_FIELD, TYPEARRAYOOP_FIELD, OBJARRAYOOP_FIELD, STATIC_OOP_FIELD, STATIC_OBJARRAYOOP_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD)</span>
 92 #undef START_CLASS
 93 #undef END_CLASS
<a name="13" id="anc13"></a>

 94 #undef FIELD
 95 #undef CHAR_FIELD
 96 #undef INT_FIELD
 97 #undef BOOLEAN_FIELD
 98 #undef LONG_FIELD
 99 #undef FLOAT_FIELD
<a name="14" id="anc14"></a><span class="line-modified">100 #undef OOP_FIELD</span>
<span class="line-modified">101 #undef TYPEARRAYOOP_FIELD</span>
<span class="line-modified">102 #undef OBJARRAYOOP_FIELD</span>
103 #undef STATIC_OOPISH_FIELD
<a name="15" id="anc15"></a><span class="line-modified">104 #undef STATIC_OOP_FIELD</span>
<span class="line-modified">105 #undef STATIC_OBJARRAYOOP_FIELD</span>
106 #undef STATIC_INT_FIELD
107 #undef STATIC_BOOLEAN_FIELD
108 #undef STATIC_PRIMITIVE_FIELD
109 #undef EMPTY_CAST
110 
<a name="16" id="anc16"></a><span class="line-modified">111 // This function is similar to javaClasses.cpp, it computes the field offset of a (static or instance) field.</span>
<span class="line-modified">112 // It looks up the name and signature symbols without creating new ones, all the symbols of these classes need to be already loaded.</span>
<span class="line-modified">113 </span>
<span class="line-modified">114 void compute_offset(int &amp;dest_offset, Klass* klass, const char* name, const char* signature, bool static_field, TRAPS) {</span>
<span class="line-modified">115   InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-modified">116   Symbol* name_symbol = SymbolTable::probe(name, (int)strlen(name));</span>
<span class="line-modified">117   Symbol* signature_symbol = SymbolTable::probe(signature, (int)strlen(signature));</span>
<span class="line-modified">118   if (name_symbol == NULL || signature_symbol == NULL) {</span>
<span class="line-modified">119 #ifndef PRODUCT</span>
<span class="line-modified">120     ik-&gt;print_on(tty);</span>
<span class="line-modified">121 #endif</span>
<span class="line-modified">122     fatal(&quot;symbol with name %s and signature %s was not found in symbol table (klass=%s)&quot;, name, signature, klass-&gt;name()-&gt;as_C_string());</span>







123   }
124 
<a name="17" id="anc17"></a><span class="line-modified">125   fieldDescriptor fd;</span>
<span class="line-modified">126   if (!ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd)) {</span>

127     ResourceMark rm;
<a name="18" id="anc18"></a><span class="line-modified">128     fatal(&quot;Invalid layout of %s %s at %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string(), ik-&gt;external_name());</span>

129   }
<a name="19" id="anc19"></a><span class="line-modified">130   guarantee(fd.is_static() == static_field, &quot;static/instance mismatch&quot;);</span>
<span class="line-modified">131   dest_offset = fd.offset();</span>
<span class="line-modified">132   assert(dest_offset != 0, &quot;must be valid offset&quot;);</span>
<span class="line-modified">133   if (static_field) {</span>
<span class="line-modified">134     // Must ensure classes for static fields are initialized as the</span>
<span class="line-modified">135     // accessor itself does not include a class initialization check.</span>
<span class="line-modified">136     ik-&gt;initialize(CHECK);</span>





137   }
<a name="20" id="anc20"></a>







































138 }
139 
<a name="21" id="anc21"></a><span class="line-modified">140 // This piece of macro magic creates the contents of the jvmci_compute_offsets method that initializes the field indices of all the access classes.</span>



































141 
<a name="22" id="anc22"></a><span class="line-modified">142 #define START_CLASS(name) { Klass* k = SystemDictionary::name##_klass(); assert(k != NULL, &quot;Could not find class &quot; #name &quot;&quot;);</span>







143 
<a name="23" id="anc23"></a><span class="line-modified">144 #define END_CLASS }</span>

145 
<a name="24" id="anc24"></a><span class="line-modified">146 #define FIELD(klass, name, signature, static_field) compute_offset(klass::_##name##_offset, k, #name, signature, static_field, CHECK);</span>
<span class="line-modified">147 #define CHAR_FIELD(klass, name) FIELD(klass, name, &quot;C&quot;, false)</span>
<span class="line-modified">148 #define INT_FIELD(klass, name) FIELD(klass, name, &quot;I&quot;, false)</span>
<span class="line-modified">149 #define BOOLEAN_FIELD(klass, name) FIELD(klass, name, &quot;Z&quot;, false)</span>
<span class="line-modified">150 #define LONG_FIELD(klass, name) FIELD(klass, name, &quot;J&quot;, false)</span>
<span class="line-modified">151 #define FLOAT_FIELD(klass, name) FIELD(klass, name, &quot;F&quot;, false)</span>
<span class="line-modified">152 #define OOP_FIELD(klass, name, signature) FIELD(klass, name, signature, false)</span>
<span class="line-modified">153 #define STATIC_OOP_FIELD(klass, name, signature) FIELD(klass, name, signature, true)</span>
<span class="line-modified">154 #define STATIC_INT_FIELD(klass, name) FIELD(klass, name, &quot;I&quot;, true)</span>
<span class="line-modified">155 #define STATIC_BOOLEAN_FIELD(klass, name) FIELD(klass, name, &quot;Z&quot;, true)</span>






156 
<a name="25" id="anc25"></a>








157 
<a name="26" id="anc26"></a><span class="line-modified">158 void JVMCIJavaClasses::compute_offsets(TRAPS) {</span>
<span class="line-modified">159   COMPILER_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OOP_FIELD, OOP_FIELD, OOP_FIELD, STATIC_OOP_FIELD, STATIC_OOP_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD)</span>




















































































160 }
161 
<a name="27" id="anc27"></a>



162 #define EMPTY0
163 #define EMPTY1(x)
164 #define EMPTY2(x,y)
<a name="28" id="anc28"></a><span class="line-modified">165 #define FIELD2(klass, name) int klass::_##name##_offset = 0;</span>
<span class="line-modified">166 #define FIELD3(klass, name, sig) FIELD2(klass, name)</span>




167 
<a name="29" id="anc29"></a><span class="line-modified">168 COMPILER_CLASSES_DO(EMPTY1, EMPTY0, FIELD2, FIELD2, FIELD2, FIELD2, FIELD2, FIELD3, FIELD3, FIELD3, FIELD3, FIELD3, FIELD2, FIELD2)</span>



169 
<a name="30" id="anc30"></a>

































































































































<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
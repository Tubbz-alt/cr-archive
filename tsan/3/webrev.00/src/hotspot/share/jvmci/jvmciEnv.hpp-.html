<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jvmci/jvmciEnv.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_JVMCI_JVMCIENV_HPP
 26 #define SHARE_JVMCI_JVMCIENV_HPP
 27 
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;code/debugInfoRec.hpp&quot;
 30 #include &quot;code/dependencies.hpp&quot;
 31 #include &quot;code/exceptionHandlerTable.hpp&quot;
 32 #include &quot;compiler/oopMap.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 
 35 class CompileTask;
 36 
 37 // Bring the JVMCI compiler thread into the VM state.
 38 #define JVMCI_VM_ENTRY_MARK                       \
 39   JavaThread* thread = JavaThread::current(); \
 40   ThreadInVMfromNative __tiv(thread);       \
 41   ResetNoHandleMark rnhm;                   \
 42   HandleMarkCleaner __hm(thread);           \
 43   Thread* THREAD = thread;                  \
 44   debug_only(VMNativeEntryWrapper __vew;)
 45 
 46 #define JVMCI_EXCEPTION_CONTEXT \
 47   JavaThread* thread=JavaThread::current(); \
 48   Thread* THREAD = thread;
 49 
 50 //
 51 // This class is the top level broker for requests from the compiler
 52 // to the VM.
 53 class JVMCIEnv : StackObj {
 54   CI_PACKAGE_ACCESS_TO
 55 
 56   friend class JVMCIVMStructs;
 57   friend class CompileBroker;
 58   friend class Dependencies;  // for get_object, during logging
 59 
 60 public:
 61 
 62   enum CodeInstallResult {
 63      ok,
 64      dependencies_failed,
 65      dependencies_invalid,
 66      cache_full,
 67      code_too_large
 68   };
 69 
 70   // Look up a klass by name from a particular class loader (the accessor&#39;s).
 71   // If require_local, result must be defined in that class loader, or NULL.
 72   // If !require_local, a result from remote class loader may be reported,
 73   // if sufficient class loader constraints exist such that initiating
 74   // a class loading request from the given loader is bound to return
 75   // the class defined in the remote loader (or throw an error).
 76   //
 77   // Return an unloaded klass if !require_local and no class at all is found.
 78   //
 79   // The CI treats a klass as loaded if it is consistently defined in
 80   // another loader, even if it hasn&#39;t yet been loaded in all loaders
 81   // that could potentially see it via delegation.
 82   static Klass* get_klass_by_name(Klass* accessing_klass, Symbol* klass_name, bool require_local);
 83 
 84   // Constant pool access.
 85   static Klass* get_klass_by_index(const constantPoolHandle&amp; cpool,
 86                                    int klass_index,
 87                                    bool&amp; is_accessible,
 88                                    Klass* loading_klass);
 89   static void   get_field_by_index(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,
 90                                    int field_index);
 91   static methodHandle  get_method_by_index(const constantPoolHandle&amp; cpool,
 92                                     int method_index, Bytecodes::Code bc,
 93                                     InstanceKlass* loading_klass);
 94 
 95   JVMCIEnv(CompileTask* task, int system_dictionary_modification_counter);
 96 
 97 private:
 98   CompileTask*     _task;
 99   int              _system_dictionary_modification_counter;
100 
101   // Compilation result values
102   bool             _retryable;
103   const char*      _failure_reason;
104 
105   // Specifies if _failure_reason is on the C heap.
106   bool             _failure_reason_on_C_heap;
107 
108   // Cache JVMTI state. Defined as bytes so that reading them from Java
109   // via Unsafe is well defined (the C++ type for bool is implementation
110   // defined and may not be the same as a Java boolean).
111   jbyte  _jvmti_can_hotswap_or_post_breakpoint;
112   jbyte  _jvmti_can_access_local_variables;
113   jbyte  _jvmti_can_post_on_exceptions;
114   jbyte  _jvmti_can_pop_frame;
115 
116   // Implementation methods for loading and constant pool access.
117   static Klass* get_klass_by_name_impl(Klass* accessing_klass,
118                                   const constantPoolHandle&amp; cpool,
119                                   Symbol* klass_name,
120                                   bool require_local);
121   static Klass* get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
122                                      int klass_index,
123                                      bool&amp; is_accessible,
124                                      Klass* loading_klass);
125   static void   get_field_by_index_impl(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,
126                                      int field_index);
127   static methodHandle  get_method_by_index_impl(const constantPoolHandle&amp; cpool,
128                                       int method_index, Bytecodes::Code bc,
129                                       InstanceKlass* loading_klass);
130 
131   // Helper methods
132   static bool       check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass);
133   static methodHandle  lookup_method(InstanceKlass*  accessor,
134                            Klass*         holder,
135                            Symbol*        name,
136                            Symbol*        sig,
137                            Bytecodes::Code bc,
138                            constantTag     tag);
139 
140   private:
141 
142   // Is this thread currently in the VM state?
143   static bool is_in_vm();
144 
145   // Helper routine for determining the validity of a compilation
146   // with respect to concurrent class loading.
147   static JVMCIEnv::CodeInstallResult validate_compile_task_dependencies(Dependencies* target, Handle compiled_code,
148                                                                         JVMCIEnv* env, char** failure_detail);
149 
150 public:
151   CompileTask* task() { return _task; }
152 
153   bool  jvmti_state_changed() const;
154   bool  jvmti_can_hotswap_or_post_breakpoint() const { return  _jvmti_can_hotswap_or_post_breakpoint != 0; }
155   bool  jvmti_can_access_local_variables() const     { return  _jvmti_can_access_local_variables != 0; }
156   bool  jvmti_can_post_on_exceptions() const         { return  _jvmti_can_post_on_exceptions != 0; }
157   bool  jvmti_can_pop_frame() const                  { return  _jvmti_can_pop_frame != 0; }
158 
159   const char* failure_reason() { return _failure_reason; }
160   bool failure_reason_on_C_heap() { return _failure_reason_on_C_heap; }
161   bool retryable() { return _retryable; }
162 
163   void set_failure(bool retryable, const char* reason, bool reason_on_C_heap = false) {
164     _failure_reason = reason;
165     _failure_reason_on_C_heap = reason_on_C_heap;
166     _retryable = retryable;
167   }
168 
169   // Register the result of a compilation.
170   static JVMCIEnv::CodeInstallResult register_method(
171                        const methodHandle&amp;       target,
172                        nmethod*&amp;                 nm,
173                        int                       entry_bci,
174                        CodeOffsets*              offsets,
175                        int                       orig_pc_offset,
176                        CodeBuffer*               code_buffer,
177                        int                       frame_words,
178                        OopMapSet*                oop_map_set,
179                        ExceptionHandlerTable*    handler_table,
180                        AbstractCompiler*         compiler,
181                        DebugInformationRecorder* debug_info,
182                        Dependencies*             dependencies,
183                        JVMCIEnv*                 env,
184                        int                       compile_id,
185                        bool                      has_unsafe_access,
186                        bool                      has_wide_vector,
187                        Handle                    installed_code,
188                        Handle                    compiled_code,
189                        Handle                    speculation_log);
190 
191   // converts the Klass* representing the holder of a method into a
192   // InstanceKlass*.  This is needed since the holder of a method in
193   // the bytecodes could be an array type.  Basically this converts
194   // array types into java/lang/Object and other types stay as they are.
195   static InstanceKlass* get_instance_klass_for_declared_method_holder(Klass* klass);
196 };
197 
198 #endif // SHARE_JVMCI_JVMCIENV_HPP
    </pre>
  </body>
</html>
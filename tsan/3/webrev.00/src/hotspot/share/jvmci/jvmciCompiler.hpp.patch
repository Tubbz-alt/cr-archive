diff a/src/hotspot/share/jvmci/jvmciCompiler.hpp b/src/hotspot/share/jvmci/jvmciCompiler.hpp
--- a/src/hotspot/share/jvmci/jvmciCompiler.hpp
+++ b/src/hotspot/share/jvmci/jvmciCompiler.hpp
@@ -23,12 +23,11 @@
 
 #ifndef SHARE_JVMCI_JVMCICOMPILER_HPP
 #define SHARE_JVMCI_JVMCICOMPILER_HPP
 
 #include "compiler/abstractCompiler.hpp"
-#include "jvmci/jvmciEnv.hpp"
-#include "utilities/exceptions.hpp"
+#include "runtime/atomic.hpp"
 
 class JVMCICompiler : public AbstractCompiler {
 private:
   bool _bootstrapping;
 
@@ -63,11 +62,11 @@
       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), "The JVMCI compiler instance has not been created");
     }
     return _instance;
   }
 
-  virtual const char* name() { return "JVMCI"; }
+  virtual const char* name() { return UseJVMCINativeLibrary ? "JVMCI-native" : "JVMCI"; }
 
   virtual bool supports_native()                 { return true; }
   virtual bool supports_osr   ()                 { return true; }
 
   bool is_jvmci()                                { return true; }
@@ -83,26 +82,35 @@
    * Initialize the compile queue with the methods in java.lang.Object and
    * then wait until the queue is empty.
    */
   void bootstrap(TRAPS);
 
+  // Should force compilation of method at CompLevel_simple?
+  bool force_comp_at_level_simple(const methodHandle& method);
+
   bool is_bootstrapping() const { return _bootstrapping; }
 
+  void set_bootstrap_compilation_request_handled() {
+    _instance->_bootstrap_compilation_request_handled = true;
+  }
+
   // Compilation entry point for methods
   virtual void compile_method(ciEnv* env, ciMethod* target, int entry_bci, DirectiveSet* directive);
 
-  void compile_method(const methodHandle& target, int entry_bci, JVMCIEnv* env);
-
   // Print compilation timers and statistics
   virtual void print_timers();
 
   /**
    * Gets the number of methods that have been successfully compiled by
    * a call to JVMCICompiler::compile_method().
    */
   int methods_compiled() { return _methods_compiled; }
 
+  void inc_methods_compiled() {
+    Atomic::inc(&_methods_compiled);
+  }
+
   // Print compilation timers and statistics
   static void print_compilation_timers();
 
   static elapsedTimer* codeInstallTimer() { return &_codeInstallTimer; }
 };

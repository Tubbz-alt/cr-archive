<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jvmci/jvmciRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciJavaClasses.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciRuntime.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,74 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;jvm.h&quot;</span>
<span class="line-removed">- #include &quot;asm/codeBuffer.hpp&quot;</span>
<span class="line-removed">- #include &quot;classfile/javaClasses.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;code/codeCache.hpp&quot;</span>
<span class="line-removed">- #include &quot;code/compiledMethod.inline.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-modified">! #include &quot;compiler/disassembler.hpp&quot;</span>
<span class="line-removed">- #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
  #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
<span class="line-modified">! #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
<span class="line-removed">- #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
<span class="line-removed">- #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
<span class="line-removed">- #include &quot;memory/allocation.inline.hpp&quot;</span>
  #include &quot;memory/oopFactory.hpp&quot;
<span class="line-modified">! #include &quot;memory/resourceArea.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified">! #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/handles.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/jniHandles.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/reflection.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-removed">- #include &quot;runtime/threadSMR.hpp&quot;</span>
<span class="line-removed">- #include &quot;utilities/debug.hpp&quot;</span>
<span class="line-removed">- #include &quot;utilities/defaultStream.hpp&quot;</span>
<span class="line-removed">- #include &quot;utilities/macros.hpp&quot;</span>
  #if INCLUDE_G1GC
  #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  #endif // INCLUDE_G1GC
  
<span class="line-removed">- #if defined(_MSC_VER)</span>
<span class="line-removed">- #define strtoll _strtoi64</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- jobject JVMCIRuntime::_HotSpotJVMCIRuntime_instance = NULL;</span>
<span class="line-removed">- bool JVMCIRuntime::_HotSpotJVMCIRuntime_initialized = false;</span>
<span class="line-removed">- bool JVMCIRuntime::_well_known_classes_initialized = false;</span>
<span class="line-removed">- JVMCIRuntime::CompLevelAdjustment JVMCIRuntime::_comp_level_adjustment = JVMCIRuntime::none;</span>
<span class="line-removed">- bool JVMCIRuntime::_shutdown_called = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">- BasicType JVMCIRuntime::kindToBasicType(Handle kind, TRAPS) {</span>
<span class="line-removed">-   if (kind.is_null()) {</span>
<span class="line-removed">-     THROW_(vmSymbols::java_lang_NullPointerException(), T_ILLEGAL);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   jchar ch = JavaKind::typeChar(kind);</span>
<span class="line-removed">-   switch(ch) {</span>
<span class="line-removed">-     case &#39;Z&#39;: return T_BOOLEAN;</span>
<span class="line-removed">-     case &#39;B&#39;: return T_BYTE;</span>
<span class="line-removed">-     case &#39;S&#39;: return T_SHORT;</span>
<span class="line-removed">-     case &#39;C&#39;: return T_CHAR;</span>
<span class="line-removed">-     case &#39;I&#39;: return T_INT;</span>
<span class="line-removed">-     case &#39;F&#39;: return T_FLOAT;</span>
<span class="line-removed">-     case &#39;J&#39;: return T_LONG;</span>
<span class="line-removed">-     case &#39;D&#39;: return T_DOUBLE;</span>
<span class="line-removed">-     case &#39;A&#39;: return T_OBJECT;</span>
<span class="line-removed">-     case &#39;-&#39;: return T_ILLEGAL;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-       JVMCI_ERROR_(T_ILLEGAL, &quot;unexpected Kind: %c&quot;, ch);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Simple helper to see if the caller of a runtime stub which
  // entered the VM has been deoptimized
  
  static bool caller_is_deopted() {
    JavaThread* thread = JavaThread::current();
<span class="line-new-header">--- 20,32 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-modified">! #include &quot;jvmci/jniAccessMark.inline.hpp&quot;</span>
  #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
<span class="line-modified">! #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
<span class="line-modified">! #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/constantPool.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/method.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/objArrayKlass.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified">! #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/biasedLocking.hpp&quot;
<span class="line-added">+ #include &quot;runtime/deoptimization.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #if INCLUDE_G1GC
  #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  #endif // INCLUDE_G1GC
  
  // Simple helper to see if the caller of a runtime stub which
  // entered the VM has been deoptimized
  
  static bool caller_is_deopted() {
    JavaThread* thread = JavaThread::current();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,27 ***</span>
  
  JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))
    JRT_BLOCK;
    assert(klass-&gt;is_klass(), &quot;not a class&quot;);
    Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
<span class="line-modified">!   InstanceKlass* ik = InstanceKlass::cast(klass);</span>
    {
      RetryableAllocationMark ram(thread, null_on_fail);
<span class="line-modified">!     ik-&gt;check_valid_for_instantiation(true, CHECK);</span>
      oop obj;
      if (null_on_fail) {
<span class="line-modified">!       if (!ik-&gt;is_initialized()) {</span>
          // Cannot re-execute class initialization without side effects
          // so return without attempting the initialization
          return;
        }
      } else {
        // make sure klass is initialized
<span class="line-modified">!       ik-&gt;initialize(CHECK);</span>
      }
      // allocate instance and return via TLS
<span class="line-modified">!     obj = ik-&gt;allocate_instance(CHECK);</span>
      thread-&gt;set_vm_result(obj);
    }
    JRT_BLOCK_END;
    SharedRuntime::on_slowpath_allocation_exit(thread);
  JRT_END
<span class="line-new-header">--- 108,27 ---</span>
  
  JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))
    JRT_BLOCK;
    assert(klass-&gt;is_klass(), &quot;not a class&quot;);
    Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
<span class="line-modified">!   InstanceKlass* h = InstanceKlass::cast(klass);</span>
    {
      RetryableAllocationMark ram(thread, null_on_fail);
<span class="line-modified">!     h-&gt;check_valid_for_instantiation(true, CHECK);</span>
      oop obj;
      if (null_on_fail) {
<span class="line-modified">!       if (!h-&gt;is_initialized()) {</span>
          // Cannot re-execute class initialization without side effects
          // so return without attempting the initialization
          return;
        }
      } else {
        // make sure klass is initialized
<span class="line-modified">!       h-&gt;initialize(CHECK);</span>
      }
      // allocate instance and return via TLS
<span class="line-modified">!     obj = h-&gt;allocate_instance(CHECK);</span>
      thread-&gt;set_vm_result(obj);
    }
    JRT_BLOCK_END;
    SharedRuntime::on_slowpath_allocation_exit(thread);
  JRT_END
</pre>
<hr />
<pre>
<span class="line-old-header">*** 288,10 ***</span>
<span class="line-new-header">--- 246,11 ---</span>
      assert(exception_frame.is_deoptimized_frame(), &quot;must be deopted&quot;);
      pc = exception_frame.pc();
    }
  #ifdef ASSERT
    assert(exception.not_null(), &quot;NULL exceptions should be handled by throw_exception&quot;);
<span class="line-added">+   assert(oopDesc::is_oop(exception()), &quot;just checking&quot;);</span>
    // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
    if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
      if (ExitVMOnVerifyError) vm_exit(-1);
      ShouldNotReachHere();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,11 ***</span>
        stringStream tempst;
        assert(cm-&gt;method() != NULL, &quot;Unexpected null method()&quot;);
        tempst.print(&quot;compiled method &lt;%s&gt;\n&quot;
                     &quot; at PC&quot; INTPTR_FORMAT &quot; for thread &quot; INTPTR_FORMAT,
                     cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
<span class="line-modified">!       Exceptions::log_exception(exception, tempst);</span>
      }
      // for AbortVMOnException flag
      NOT_PRODUCT(Exceptions::debug_check_abort(exception));
  
      // Clear out the exception oop and pc since looking up an
<span class="line-new-header">--- 310,11 ---</span>
        stringStream tempst;
        assert(cm-&gt;method() != NULL, &quot;Unexpected null method()&quot;);
        tempst.print(&quot;compiled method &lt;%s&gt;\n&quot;
                     &quot; at PC&quot; INTPTR_FORMAT &quot; for thread &quot; INTPTR_FORMAT,
                     cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
<span class="line-modified">!       Exceptions::log_exception(exception, tempst.as_string());</span>
      }
      // for AbortVMOnException flag
      NOT_PRODUCT(Exceptions::debug_check_abort(exception));
  
      // Clear out the exception oop and pc since looking up an
</pre>
<hr />
<pre>
<span class="line-old-header">*** 368,14 ***</span>
      continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
      // If an exception was thrown during exception dispatch, the exception oop may have changed
      thread-&gt;set_exception_oop(exception());
      thread-&gt;set_exception_pc(pc);
  
<span class="line-modified">!     // the exception cache is used only by non-implicit exceptions</span>
<span class="line-modified">!     // Update the exception cache only when there didn&#39;t happen</span>
<span class="line-modified">!     // another exception during the computation of the compiled</span>
<span class="line-modified">!     // exception handler. Checking for exception oop equality is not</span>
      // sufficient because some exceptions are pre-allocated and reused.
      if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
        cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
      }
    }
<span class="line-new-header">--- 327,15 ---</span>
      continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
      // If an exception was thrown during exception dispatch, the exception oop may have changed
      thread-&gt;set_exception_oop(exception());
      thread-&gt;set_exception_pc(pc);
  
<span class="line-modified">!     // The exception cache is used only for non-implicit exceptions</span>
<span class="line-modified">!     // Update the exception cache only when another exception did</span>
<span class="line-modified">!     // occur during the computation of the compiled exception handler</span>
<span class="line-modified">!     // (e.g., when loading the class of the catch type).</span>
<span class="line-added">+     // Checking for exception oop equality is not</span>
      // sufficient because some exceptions are pre-allocated and reused.
      if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
        cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,41 ***</span>
  
  JRT_ENTRY_NO_ASYNC(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))
    IF_TRACE_jvmci_3 {
      char type[O_BUFLEN];
      obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
<span class="line-modified">!     markOop mark = obj-&gt;mark();</span>
<span class="line-modified">!     TRACE_jvmci_3(&quot;%s: entered locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, p2i(mark), p2i(lock));</span>
      tty-&gt;flush();
    }
<span class="line-removed">- #ifdef ASSERT</span>
    if (PrintBiasedLockingStatistics) {
      Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
    }
<span class="line-removed">- #endif</span>
    Handle h_obj(thread, obj);
<span class="line-modified">!   if (UseBiasedLocking) {</span>
<span class="line-modified">!     // Retry fast entry if bias is revoked to avoid unnecessary inflation</span>
<span class="line-removed">-     ObjectSynchronizer::fast_enter(h_obj, lock, true, CHECK);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     if (JVMCIUseFastLocking) {</span>
<span class="line-removed">-       // When using fast locking, the compiled code has already tried the fast case</span>
<span class="line-removed">-       ObjectSynchronizer::slow_enter(h_obj, lock, THREAD);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       ObjectSynchronizer::fast_enter(h_obj, lock, false, THREAD);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
    TRACE_jvmci_3(&quot;%s: exiting locking slow with obj=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj));
  JRT_END
  
  JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
    assert(thread == JavaThread::current(), &quot;threads must correspond&quot;);
    assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
    // monitorexit is non-blocking (leaf routine) =&gt; no exceptions can be thrown
    EXCEPTION_MARK;
  
<span class="line-modified">! #ifdef DEBUG</span>
    if (!oopDesc::is_oop(obj)) {
      ResetNoHandleMark rhm;
      nmethod* method = thread-&gt;last_frame().cb()-&gt;as_nmethod_or_null();
      if (method != NULL) {
        tty-&gt;print_cr(&quot;ERROR in monitorexit in method %s wrong obj &quot; INTPTR_FORMAT, method-&gt;name(), p2i(obj));
<span class="line-new-header">--- 384,30 ---</span>
  
  JRT_ENTRY_NO_ASYNC(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))
    IF_TRACE_jvmci_3 {
      char type[O_BUFLEN];
      obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
<span class="line-modified">!     markWord mark = obj-&gt;mark();</span>
<span class="line-modified">!     TRACE_jvmci_3(&quot;%s: entered locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, mark.value(), p2i(lock));</span>
      tty-&gt;flush();
    }
    if (PrintBiasedLockingStatistics) {
      Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
    }
    Handle h_obj(thread, obj);
<span class="line-modified">!   assert(oopDesc::is_oop(h_obj()), &quot;must be NULL or an object&quot;);</span>
<span class="line-modified">!   ObjectSynchronizer::enter(h_obj, lock, THREAD);</span>
    TRACE_jvmci_3(&quot;%s: exiting locking slow with obj=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj));
  JRT_END
  
  JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
    assert(thread == JavaThread::current(), &quot;threads must correspond&quot;);
    assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
    // monitorexit is non-blocking (leaf routine) =&gt; no exceptions can be thrown
    EXCEPTION_MARK;
  
<span class="line-modified">! #ifdef ASSERT</span>
    if (!oopDesc::is_oop(obj)) {
      ResetNoHandleMark rhm;
      nmethod* method = thread-&gt;last_frame().cb()-&gt;as_nmethod_or_null();
      if (method != NULL) {
        tty-&gt;print_cr(&quot;ERROR in monitorexit in method %s wrong obj &quot; INTPTR_FORMAT, method-&gt;name(), p2i(obj));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 466,20 ***</span>
      thread-&gt;print_stack_on(tty);
      assert(false, &quot;invalid lock object pointer dected&quot;);
    }
  #endif
  
<span class="line-modified">!   if (JVMCIUseFastLocking) {</span>
<span class="line-removed">-     // When using fast locking, the compiled code has already tried the fast case</span>
<span class="line-removed">-     ObjectSynchronizer::slow_exit(obj, lock, THREAD);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     ObjectSynchronizer::fast_exit(obj, lock, THREAD);</span>
<span class="line-removed">-   }</span>
    IF_TRACE_jvmci_3 {
      char type[O_BUFLEN];
      obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
<span class="line-modified">!     TRACE_jvmci_3(&quot;%s: exited locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, p2i(obj-&gt;mark()), p2i(lock));</span>
      tty-&gt;flush();
    }
  JRT_END
  
  // Object.notify() fast path, caller does slow path
<span class="line-new-header">--- 415,15 ---</span>
      thread-&gt;print_stack_on(tty);
      assert(false, &quot;invalid lock object pointer dected&quot;);
    }
  #endif
  
<span class="line-modified">!   ObjectSynchronizer::exit(obj, lock, THREAD);</span>
    IF_TRACE_jvmci_3 {
      char type[O_BUFLEN];
      obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
<span class="line-modified">!     TRACE_jvmci_3(&quot;%s: exited locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, obj-&gt;mark().value(), p2i(lock));</span>
      tty-&gt;flush();
    }
  JRT_END
  
  // Object.notify() fast path, caller does slow path
</pre>
<hr />
<pre>
<span class="line-old-header">*** 508,26 ***</span>
    }
    return false; // caller must perform slow path
  
  JRT_END
  
<span class="line-modified">! JRT_ENTRY(void, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))</span>
<span class="line-modified">!   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);</span>
    SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
  JRT_END
  
<span class="line-modified">! JRT_ENTRY(void, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))</span>
    ResourceMark rm(thread);
<span class="line-modified">!   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);</span>
    SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());
  JRT_END
  
<span class="line-modified">! JRT_ENTRY(void, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))</span>
    ResourceMark rm(thread);
    const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
<span class="line-modified">!   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);</span>
    SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
  JRT_END
  
  JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
    ttyLocker ttyl;
  
<span class="line-new-header">--- 452,35 ---</span>
    }
    return false; // caller must perform slow path
  
  JRT_END
  
<span class="line-modified">! JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))</span>
<span class="line-modified">!   JRT_BLOCK;</span>
<span class="line-added">+   TempNewSymbol symbol = SymbolTable::new_symbol(exception);</span>
    SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
<span class="line-added">+   JRT_BLOCK_END;</span>
<span class="line-added">+   return caller_is_deopted();</span>
  JRT_END
  
<span class="line-modified">! JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))</span>
<span class="line-added">+   JRT_BLOCK;</span>
    ResourceMark rm(thread);
<span class="line-modified">!   TempNewSymbol symbol = SymbolTable::new_symbol(exception);</span>
    SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());
<span class="line-added">+   JRT_BLOCK_END;</span>
<span class="line-added">+   return caller_is_deopted();</span>
  JRT_END
  
<span class="line-modified">! JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))</span>
<span class="line-added">+   JRT_BLOCK;</span>
    ResourceMark rm(thread);
    const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
<span class="line-modified">!   TempNewSymbol symbol = SymbolTable::new_symbol(exception);</span>
    SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
<span class="line-added">+   JRT_BLOCK_END;</span>
<span class="line-added">+   return caller_is_deopted();</span>
  JRT_END
  
  JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
    ttyLocker ttyl;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 563,16 ***</span>
  
  #endif // INCLUDE_G1GC
  
  JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
    bool ret = true;
<span class="line-modified">!   if(!Universe::heap()-&gt;is_in_closed_subset(parent)) {</span>
      tty-&gt;print_cr(&quot;Parent Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(parent));
      parent-&gt;print();
      ret=false;
    }
<span class="line-modified">!   if(!Universe::heap()-&gt;is_in_closed_subset(child)) {</span>
      tty-&gt;print_cr(&quot;Child Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(child));
      child-&gt;print();
      ret=false;
    }
    return (jint)ret;
<span class="line-new-header">--- 516,16 ---</span>
  
  #endif // INCLUDE_G1GC
  
  JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
    bool ret = true;
<span class="line-modified">!   if(!Universe::heap()-&gt;is_in(parent)) {</span>
      tty-&gt;print_cr(&quot;Parent Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(parent));
      parent-&gt;print();
      ret=false;
    }
<span class="line-modified">!   if(!Universe::heap()-&gt;is_in(child)) {</span>
      tty-&gt;print_cr(&quot;Child Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(child));
      child-&gt;print();
      ret=false;
    }
    return (jint)ret;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,14 ***</span>
    if (format != 0L) {
      const char* buf = (char*) (address) format;
      size_t detail_msg_length = strlen(buf) * 2;
      detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
      jio_snprintf(detail_msg, detail_msg_length, buf, value);
<span class="line-removed">-     report_vm_error(__FILE__, __LINE__, error_msg, &quot;%s&quot;, detail_msg);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     report_vm_error(__FILE__, __LINE__, error_msg);</span>
    }
  JRT_END
  
  JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
    oop exception = thread-&gt;exception_oop();
    assert(exception != NULL, &quot;npe&quot;);
<span class="line-new-header">--- 538,12 ---</span>
    if (format != 0L) {
      const char* buf = (char*) (address) format;
      size_t detail_msg_length = strlen(buf) * 2;
      detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
      jio_snprintf(detail_msg, detail_msg_length, buf, value);
    }
<span class="line-added">+   report_vm_error(__FILE__, __LINE__, error_msg, &quot;%s&quot;, detail_msg);</span>
  JRT_END
  
  JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
    oop exception = thread-&gt;exception_oop();
    assert(exception != NULL, &quot;npe&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 677,295 ***</span>
  
  JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
    return (jint) obj-&gt;identity_hash();
  JRT_END
  
<span class="line-modified">! JRT_ENTRY(jboolean, JVMCIRuntime::thread_is_interrupted(JavaThread* thread, oopDesc* receiver, jboolean clear_interrupted))</span>
<span class="line-removed">-   Handle receiverHandle(thread, receiver);</span>
<span class="line-removed">-   // A nested ThreadsListHandle may require the Threads_lock which</span>
<span class="line-removed">-   // requires thread_in_vm which is why this method cannot be JRT_LEAF.</span>
<span class="line-removed">-   ThreadsListHandle tlh;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   JavaThread* receiverThread = java_lang_Thread::thread(receiverHandle());</span>
<span class="line-removed">-   if (receiverThread == NULL || (EnableThreadSMRExtraValidityChecks &amp;&amp; !tlh.includes(receiverThread))) {</span>
<span class="line-removed">-     // The other thread may exit during this process, which is ok so return false.</span>
<span class="line-removed">-     return JNI_FALSE;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return (jint) Thread::is_interrupted(receiverThread, clear_interrupted != 0);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- JRT_END</span>
<span class="line-removed">- </span>
<span class="line-removed">- JRT_ENTRY(int, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))</span>
    deopt_caller();
<span class="line-modified">!   return value;</span>
  JRT_END
  
<span class="line-removed">- void JVMCIRuntime::force_initialization(TRAPS) {</span>
<span class="line-removed">-   JVMCIRuntime::initialize_well_known_classes(CHECK);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ResourceMark rm;</span>
<span class="line-removed">-   TempNewSymbol getCompiler = SymbolTable::new_symbol(&quot;getCompiler&quot;, CHECK);</span>
<span class="line-removed">-   TempNewSymbol sig = SymbolTable::new_symbol(&quot;()Ljdk/vm/ci/runtime/JVMCICompiler;&quot;, CHECK);</span>
<span class="line-removed">-   Handle jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(CHECK);</span>
<span class="line-removed">-   JavaValue result(T_OBJECT);</span>
<span class="line-removed">-   JavaCalls::call_virtual(&amp;result, jvmciRuntime, HotSpotJVMCIRuntime::klass(), getCompiler, sig, CHECK);</span>
<span class="line-removed">- }</span>
  
  // private static JVMCIRuntime JVMCI.initializeRuntime()
<span class="line-modified">! JVM_ENTRY(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))</span>
    if (!EnableJVMCI) {
<span class="line-modified">!     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVMCI is not enabled&quot;)</span>
    }
<span class="line-modified">!   JVMCIRuntime::initialize_HotSpotJVMCIRuntime(CHECK_NULL);</span>
<span class="line-modified">!   jobject ret = JVMCIRuntime::get_HotSpotJVMCIRuntime_jobject(CHECK_NULL);</span>
<span class="line-modified">!   return ret;</span>
  JVM_END
  
<span class="line-modified">! Handle JVMCIRuntime::callStatic(const char* className, const char* methodName, const char* signature, JavaCallArguments* args, TRAPS) {</span>
<span class="line-modified">!   TempNewSymbol name = SymbolTable::new_symbol(className, CHECK_(Handle()));</span>
<span class="line-modified">!   Klass* klass = SystemDictionary::resolve_or_fail(name, true, CHECK_(Handle()));</span>
<span class="line-modified">!   TempNewSymbol runtime = SymbolTable::new_symbol(methodName, CHECK_(Handle()));</span>
<span class="line-modified">!   TempNewSymbol sig = SymbolTable::new_symbol(signature, CHECK_(Handle()));</span>
<span class="line-modified">!   JavaValue result(T_OBJECT);</span>
<span class="line-modified">!   if (args == NULL) {</span>
<span class="line-modified">!     JavaCalls::call_static(&amp;result, klass, runtime, sig, CHECK_(Handle()));</span>
    } else {
<span class="line-modified">!     JavaCalls::call_static(&amp;result, klass, runtime, sig, args, CHECK_(Handle()));</span>
    }
<span class="line-removed">-   return Handle(THREAD, (oop)result.get_jobject());</span>
  }
  
<span class="line-modified">! Handle JVMCIRuntime::get_HotSpotJVMCIRuntime(TRAPS) {</span>
<span class="line-modified">!   initialize_JVMCI(CHECK_(Handle()));</span>
<span class="line-modified">!   return Handle(THREAD, JNIHandles::resolve_non_null(_HotSpotJVMCIRuntime_instance));</span>
  }
  
<span class="line-modified">! void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(TRAPS) {</span>
<span class="line-modified">!   guarantee(!_HotSpotJVMCIRuntime_initialized, &quot;cannot reinitialize HotSpotJVMCIRuntime&quot;);</span>
<span class="line-modified">!   JVMCIRuntime::initialize_well_known_classes(CHECK);</span>
<span class="line-modified">!   // This should only be called in the context of the JVMCI class being initialized</span>
<span class="line-modified">!   InstanceKlass* klass = SystemDictionary::JVMCI_klass();</span>
<span class="line-modified">!   guarantee(klass-&gt;is_being_initialized() &amp;&amp; klass-&gt;is_reentrant_initialization(THREAD),</span>
<span class="line-modified">!          &quot;HotSpotJVMCIRuntime initialization should only be triggered through JVMCI initialization&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Handle result = callStatic(&quot;jdk/vm/ci/hotspot/HotSpotJVMCIRuntime&quot;,</span>
<span class="line-modified">!                              &quot;runtime&quot;,</span>
<span class="line-modified">!                              &quot;()Ljdk/vm/ci/hotspot/HotSpotJVMCIRuntime;&quot;, NULL, CHECK);</span>
<span class="line-modified">!   int adjustment = HotSpotJVMCIRuntime::compilationLevelAdjustment(result);</span>
<span class="line-modified">!   assert(adjustment &gt;= JVMCIRuntime::none &amp;&amp;</span>
<span class="line-modified">!          adjustment &lt;= JVMCIRuntime::by_full_signature,</span>
<span class="line-modified">!          &quot;compilation level adjustment out of bounds&quot;);</span>
<span class="line-modified">!   _comp_level_adjustment = (CompLevelAdjustment) adjustment;</span>
<span class="line-modified">!   _HotSpotJVMCIRuntime_initialized = true;</span>
<span class="line-modified">!   _HotSpotJVMCIRuntime_instance = JNIHandles::make_global(result);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void JVMCIRuntime::initialize_JVMCI(TRAPS) {</span>
<span class="line-modified">!   if (JNIHandles::resolve(_HotSpotJVMCIRuntime_instance) == NULL) {</span>
<span class="line-modified">!     callStatic(&quot;jdk/vm/ci/runtime/JVMCI&quot;,</span>
<span class="line-modified">!                &quot;getRuntime&quot;,</span>
<span class="line-modified">!                &quot;()Ljdk/vm/ci/runtime/JVMCIRuntime;&quot;, NULL, CHECK);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   assert(_HotSpotJVMCIRuntime_initialized == true, &quot;what?&quot;);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-removed">- bool JVMCIRuntime::can_initialize_JVMCI() {</span>
<span class="line-removed">-   // Initializing JVMCI requires the module system to be initialized past phase 3.</span>
<span class="line-removed">-   // The JVMCI API itself isn&#39;t available until phase 2 and ServiceLoader (which</span>
<span class="line-removed">-   // JVMCI initialization requires) isn&#39;t usable until after phase 3. Testing</span>
<span class="line-removed">-   // whether the system loader is initialized satisfies all these invariants.</span>
<span class="line-removed">-   if (SystemDictionary::java_system_loader() == NULL) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert(Universe::is_module_initialized(), &quot;must be&quot;);</span>
<span class="line-removed">-   return true;</span>
  }
  
<span class="line-modified">! void JVMCIRuntime::initialize_well_known_classes(TRAPS) {</span>
<span class="line-modified">!   if (JVMCIRuntime::_well_known_classes_initialized == false) {</span>
<span class="line-modified">!     guarantee(can_initialize_JVMCI(), &quot;VM is not yet sufficiently booted to initialize JVMCI&quot;);</span>
<span class="line-modified">!     SystemDictionary::WKID scan = SystemDictionary::FIRST_JVMCI_WKID;</span>
<span class="line-modified">!     SystemDictionary::resolve_wk_klasses_through(SystemDictionary::LAST_JVMCI_WKID, scan, CHECK);</span>
<span class="line-modified">!     JVMCIJavaClasses::compute_offsets(CHECK);</span>
<span class="line-modified">!     JVMCIRuntime::_well_known_classes_initialized = true;</span>
    }
  }
  
<span class="line-modified">! void JVMCIRuntime::metadata_do(void f(Metadata*)) {</span>
<span class="line-modified">!   // For simplicity, the existence of HotSpotJVMCIMetaAccessContext in</span>
<span class="line-modified">!   // the SystemDictionary well known classes should ensure the other</span>
<span class="line-modified">!   // classes have already been loaded, so make sure their order in the</span>
<span class="line-modified">!   // table enforces that.</span>
<span class="line-modified">!   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotResolvedJavaMethodImpl) &lt;</span>
<span class="line-modified">!          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), &quot;must be loaded earlier&quot;);</span>
<span class="line-modified">!   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotConstantPool) &lt;</span>
<span class="line-removed">-          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), &quot;must be loaded earlier&quot;);</span>
<span class="line-removed">-   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotResolvedObjectTypeImpl) &lt;</span>
<span class="line-removed">-          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), &quot;must be loaded earlier&quot;);</span>
  
<span class="line-modified">!   if (HotSpotJVMCIMetaAccessContext::klass() == NULL ||</span>
<span class="line-modified">!       !HotSpotJVMCIMetaAccessContext::klass()-&gt;is_linked()) {</span>
<span class="line-modified">!     // Nothing could be registered yet</span>
      return;
    }
  
<span class="line-modified">!   // WeakReference&lt;HotSpotJVMCIMetaAccessContext&gt;[]</span>
<span class="line-modified">!   objArrayOop allContexts = HotSpotJVMCIMetaAccessContext::allContexts();</span>
<span class="line-modified">!   if (allContexts == NULL) {</span>
      return;
    }
  
<span class="line-modified">!   // These must be loaded at this point but the linking state doesn&#39;t matter.</span>
<span class="line-modified">!   assert(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass() != NULL, &quot;must be loaded&quot;);</span>
<span class="line-modified">!   assert(SystemDictionary::HotSpotConstantPool_klass() != NULL, &quot;must be loaded&quot;);</span>
<span class="line-modified">!   assert(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass() != NULL, &quot;must be loaded&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   for (int i = 0; i &lt; allContexts-&gt;length(); i++) {</span>
<span class="line-modified">!     oop ref = allContexts-&gt;obj_at(i);</span>
<span class="line-modified">!     if (ref != NULL) {</span>
<span class="line-modified">!       oop referent = java_lang_ref_Reference::referent(ref);</span>
<span class="line-modified">!       if (referent != NULL) {</span>
<span class="line-modified">!         // Chunked Object[] with last element pointing to next chunk</span>
<span class="line-modified">!         objArrayOop metadataRoots = HotSpotJVMCIMetaAccessContext::metadataRoots(referent);</span>
<span class="line-modified">!         while (metadataRoots != NULL) {</span>
<span class="line-modified">!           for (int typeIndex = 0; typeIndex &lt; metadataRoots-&gt;length() - 1; typeIndex++) {</span>
<span class="line-modified">!             oop reference = metadataRoots-&gt;obj_at(typeIndex);</span>
<span class="line-modified">!             if (reference == NULL) {</span>
<span class="line-modified">!               continue;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             oop metadataRoot = java_lang_ref_Reference::referent(reference);</span>
<span class="line-modified">!             if (metadataRoot == NULL) {</span>
<span class="line-modified">!               continue;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {</span>
<span class="line-modified">!               Method* method = CompilerToVM::asMethod(metadataRoot);</span>
<span class="line-removed">-               f(method);</span>
<span class="line-removed">-             } else if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {</span>
<span class="line-removed">-               ConstantPool* constantPool = CompilerToVM::asConstantPool(metadataRoot);</span>
<span class="line-removed">-               f(constantPool);</span>
<span class="line-removed">-             } else if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {</span>
<span class="line-removed">-               Klass* klass = CompilerToVM::asKlass(metadataRoot);</span>
<span class="line-removed">-               f(klass);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-               metadataRoot-&gt;print();</span>
<span class="line-removed">-               ShouldNotReachHere();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           metadataRoots = (objArrayOop)metadataRoots-&gt;obj_at(metadataRoots-&gt;length() - 1);</span>
<span class="line-removed">-           assert(metadataRoots == NULL || metadataRoots-&gt;is_objArray(), &quot;wrong type&quot;);</span>
<span class="line-removed">-         }</span>
        }
      }
    }
  }
  
<span class="line-modified">! // private static void CompilerToVM.registerNatives()</span>
<span class="line-modified">! JVM_ENTRY(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))</span>
<span class="line-modified">!   if (!EnableJVMCI) {</span>
<span class="line-modified">!     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;JVMCI is not enabled&quot;);</span>
    }
  
<span class="line-modified">! #ifdef _LP64</span>
<span class="line-modified">! #ifndef SPARC</span>
<span class="line-modified">!   uintptr_t heap_end = (uintptr_t) Universe::heap()-&gt;reserved_region().end();</span>
<span class="line-modified">!   uintptr_t allocation_end = heap_end + ((uintptr_t)16) * 1024 * 1024 * 1024;</span>
<span class="line-modified">!   guarantee(heap_end &lt; allocation_end, &quot;heap end too close to end of address space (might lead to erroneous TLAB allocations)&quot;);</span>
<span class="line-modified">! #endif // !SPARC</span>
<span class="line-modified">! #else</span>
<span class="line-modified">!   fatal(&quot;check TLAB allocation code for address space conflicts&quot;);</span>
<span class="line-modified">! #endif // _LP64</span>
  
<span class="line-modified">!   JVMCIRuntime::initialize_well_known_classes(CHECK);</span>
  
    {
      ThreadToNativeFromVM trans(thread);
<span class="line-modified">!     env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count());</span>
    }
  JVM_END
  
<span class="line-modified">! void JVMCIRuntime::shutdown(TRAPS) {</span>
<span class="line-modified">!   if (_HotSpotJVMCIRuntime_instance != NULL) {</span>
      _shutdown_called = true;
<span class="line-modified">!     HandleMark hm(THREAD);</span>
<span class="line-modified">!     Handle receiver = get_HotSpotJVMCIRuntime(CHECK);</span>
<span class="line-modified">!     JavaValue result(T_VOID);</span>
<span class="line-modified">!     JavaCallArguments args;</span>
<span class="line-modified">!     args.push_oop(receiver);</span>
<span class="line-modified">!     JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::shutdown_method_name(), vmSymbols::void_method_signature(), &amp;args, CHECK);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! CompLevel JVMCIRuntime::adjust_comp_level_inner(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread) {</span>
<span class="line-modified">!   JVMCICompiler* compiler = JVMCICompiler::instance(false, thread);</span>
<span class="line-modified">!   if (compiler != NULL &amp;&amp; compiler-&gt;is_bootstrapping()) {</span>
<span class="line-modified">!     return level;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (!is_HotSpotJVMCIRuntime_initialized() || _comp_level_adjustment == JVMCIRuntime::none) {</span>
<span class="line-modified">!     // JVMCI cannot participate in compilation scheduling until</span>
<span class="line-modified">!     // JVMCI is initialized and indicates it wants to participate.</span>
<span class="line-modified">!     return level;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">! #define CHECK_RETURN THREAD); \</span>
<span class="line-modified">!   if (HAS_PENDING_EXCEPTION) { \</span>
<span class="line-modified">!     Handle exception(THREAD, PENDING_EXCEPTION); \</span>
<span class="line-modified">!     CLEAR_PENDING_EXCEPTION; \</span>
<span class="line-modified">!   \</span>
<span class="line-modified">!     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) { \</span>
<span class="line-modified">!       /* In the special case of ThreadDeath, we need to reset the */ \</span>
<span class="line-modified">!       /* pending async exception so that it is propagated.        */ \</span>
<span class="line-modified">!       thread-&gt;set_pending_async_exception(exception()); \</span>
<span class="line-modified">!       return level; \</span>
<span class="line-modified">!     } \</span>
<span class="line-modified">!     tty-&gt;print(&quot;Uncaught exception while adjusting compilation level: &quot;); \</span>
<span class="line-modified">!     java_lang_Throwable::print(exception(), tty); \</span>
<span class="line-modified">!     tty-&gt;cr(); \</span>
<span class="line-modified">!     java_lang_Throwable::print_stack_trace(exception, tty); \</span>
<span class="line-modified">!     if (HAS_PENDING_EXCEPTION) { \</span>
<span class="line-modified">!       CLEAR_PENDING_EXCEPTION; \</span>
<span class="line-modified">!     } \</span>
<span class="line-modified">!     return level; \</span>
<span class="line-modified">!   } \</span>
<span class="line-modified">!   (void)(0</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!   Thread* THREAD = thread;</span>
<span class="line-modified">!   HandleMark hm;</span>
<span class="line-modified">!   Handle receiver = JVMCIRuntime::get_HotSpotJVMCIRuntime(CHECK_RETURN);</span>
<span class="line-removed">-   Handle name;</span>
<span class="line-removed">-   Handle sig;</span>
<span class="line-removed">-   if (_comp_level_adjustment == JVMCIRuntime::by_full_signature) {</span>
<span class="line-removed">-     name = java_lang_String::create_from_symbol(method-&gt;name(), CHECK_RETURN);</span>
<span class="line-removed">-     sig = java_lang_String::create_from_symbol(method-&gt;signature(), CHECK_RETURN);</span>
    } else {
<span class="line-modified">!     name = Handle();</span>
<span class="line-modified">!     sig = Handle();</span>
    }
  
<span class="line-modified">!   JavaValue result(T_INT);</span>
<span class="line-modified">!   JavaCallArguments args;</span>
<span class="line-modified">!   args.push_oop(receiver);</span>
<span class="line-modified">!   args.push_oop(Handle(THREAD, method-&gt;method_holder()-&gt;java_mirror()));</span>
<span class="line-modified">!   args.push_oop(name);</span>
<span class="line-modified">!   args.push_oop(sig);</span>
<span class="line-modified">!   args.push_int(is_osr);</span>
<span class="line-modified">!   args.push_int(level);</span>
<span class="line-modified">!   JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::adjustCompilationLevel_name(),</span>
<span class="line-modified">!                           vmSymbols::adjustCompilationLevel_signature(), &amp;args, CHECK_RETURN);</span>
  
<span class="line-modified">!   int comp_level = result.get_jint();</span>
<span class="line-modified">!   if (comp_level &lt; CompLevel_none || comp_level &gt; CompLevel_full_optimization) {</span>
<span class="line-modified">!     assert(false, &quot;compilation level out of bounds&quot;);</span>
<span class="line-removed">-     return level;</span>
    }
<span class="line-modified">!   return (CompLevel) comp_level;</span>
<span class="line-modified">! #undef CHECK_RETURN</span>
  }
  
<span class="line-modified">! void JVMCIRuntime::bootstrap_finished(TRAPS) {</span>
<span class="line-modified">!   HandleMark hm(THREAD);</span>
<span class="line-modified">!   Handle receiver = get_HotSpotJVMCIRuntime(CHECK);</span>
<span class="line-modified">!   JavaValue result(T_VOID);</span>
<span class="line-modified">!   JavaCallArguments args;</span>
<span class="line-modified">!   args.push_oop(receiver);</span>
<span class="line-modified">!   JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::bootstrapFinished_method_name(), vmSymbols::void_method_signature(), &amp;args, CHECK);</span>
  }
<span class="line-new-header">--- 628,929 ---</span>
  
  JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
    return (jint) obj-&gt;identity_hash();
  JRT_END
  
<span class="line-modified">! JRT_ENTRY(jint, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))</span>
    deopt_caller();
<span class="line-modified">!   return (jint) value;</span>
  JRT_END
  
  
  // private static JVMCIRuntime JVMCI.initializeRuntime()
<span class="line-modified">! JVM_ENTRY_NO_ENV(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))</span>
<span class="line-added">+   JNI_JVMCIENV(thread, env);</span>
    if (!EnableJVMCI) {
<span class="line-modified">!     JVMCI_THROW_MSG_NULL(InternalError, &quot;JVMCI is not enabled&quot;);</span>
    }
<span class="line-modified">!   JVMCIENV-&gt;runtime()-&gt;initialize_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   JVMCIObject runtime = JVMCIENV-&gt;runtime()-&gt;get_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);</span>
<span class="line-modified">!   return JVMCIENV-&gt;get_jobject(runtime);</span>
  JVM_END
  
<span class="line-modified">! void JVMCIRuntime::call_getCompiler(TRAPS) {</span>
<span class="line-modified">!   THREAD_JVMCIENV(JavaThread::current());</span>
<span class="line-modified">!   JVMCIObject jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_CHECK);</span>
<span class="line-modified">!   initialize(JVMCIENV);</span>
<span class="line-modified">!   JVMCIENV-&gt;call_HotSpotJVMCIRuntime_getCompiler(jvmciRuntime, JVMCI_CHECK);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void JVMCINMethodData::initialize(</span>
<span class="line-added">+   int nmethod_mirror_index,</span>
<span class="line-added">+   const char* name,</span>
<span class="line-added">+   FailedSpeculation** failed_speculations)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   _failed_speculations = failed_speculations;</span>
<span class="line-added">+   _nmethod_mirror_index = nmethod_mirror_index;</span>
<span class="line-added">+   if (name != NULL) {</span>
<span class="line-added">+     _has_name = true;</span>
<span class="line-added">+     char* dest = (char*) this-&gt;name();</span>
<span class="line-added">+     strcpy(dest, name);</span>
    } else {
<span class="line-modified">!     _has_name = false;</span>
    }
  }
  
<span class="line-modified">! void JVMCINMethodData::add_failed_speculation(nmethod* nm, jlong speculation) {</span>
<span class="line-modified">!   uint index = (speculation &gt;&gt; 32) &amp; 0xFFFFFFFF;</span>
<span class="line-modified">!   int length = (int) speculation;</span>
<span class="line-added">+   if (index + length &gt; (uint) nm-&gt;speculations_size()) {</span>
<span class="line-added">+     fatal(INTPTR_FORMAT &quot;[index: %d, length: %d] out of bounds wrt encoded speculations of length %u&quot;, speculation, index, length, nm-&gt;speculations_size());</span>
<span class="line-added">+   }</span>
<span class="line-added">+   address data = nm-&gt;speculations_begin() + index;</span>
<span class="line-added">+   FailedSpeculation::add_failed_speculation(nm, _failed_speculations, data, length);</span>
  }
  
<span class="line-modified">! oop JVMCINMethodData::get_nmethod_mirror(nmethod* nm, bool phantom_ref) {</span>
<span class="line-modified">!   if (_nmethod_mirror_index == -1) {</span>
<span class="line-modified">!     return NULL;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (phantom_ref) {</span>
<span class="line-modified">!     return nm-&gt;oop_at_phantom(_nmethod_mirror_index);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     return nm-&gt;oop_at(_nmethod_mirror_index);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void JVMCINMethodData::set_nmethod_mirror(nmethod* nm, oop new_mirror) {</span>
<span class="line-modified">!   assert(_nmethod_mirror_index != -1, &quot;cannot set JVMCI mirror for nmethod&quot;);</span>
<span class="line-modified">!   oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);</span>
<span class="line-modified">!   assert(new_mirror != NULL, &quot;use clear_nmethod_mirror to clear the mirror&quot;);</span>
<span class="line-modified">!   assert(*addr == NULL, &quot;cannot overwrite non-null mirror&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   *addr = new_mirror;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Since we&#39;ve patched some oops in the nmethod,</span>
<span class="line-modified">!   // (re)register it with the heap.</span>
<span class="line-modified">!   Universe::heap()-&gt;register_nmethod(nm);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void JVMCINMethodData::clear_nmethod_mirror(nmethod* nm) {</span>
<span class="line-modified">!   if (_nmethod_mirror_index != -1) {</span>
<span class="line-modified">!     oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);</span>
<span class="line-modified">!     *addr = NULL;</span>
<span class="line-modified">!   }</span>
  }
  
<span class="line-modified">! void JVMCINMethodData::invalidate_nmethod_mirror(nmethod* nm) {</span>
<span class="line-modified">!   oop nmethod_mirror = get_nmethod_mirror(nm, /* phantom_ref */ false);</span>
<span class="line-modified">!   if (nmethod_mirror == NULL) {</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Update the values in the mirror if it still refers to nm.</span>
<span class="line-added">+   // We cannot use JVMCIObject to wrap the mirror as this is called</span>
<span class="line-added">+   // during GC, forbidding the creation of JNIHandles.</span>
<span class="line-added">+   JVMCIEnv* jvmciEnv = NULL;</span>
<span class="line-added">+   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);</span>
<span class="line-added">+   if (nm == current) {</span>
<span class="line-added">+     if (!nm-&gt;is_alive()) {</span>
<span class="line-added">+       // Break the link from the mirror to nm such that</span>
<span class="line-added">+       // future invocations via the mirror will result in</span>
<span class="line-added">+       // an InvalidInstalledCodeException.</span>
<span class="line-added">+       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);</span>
<span class="line-added">+       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);</span>
<span class="line-added">+     } else if (nm-&gt;is_not_entrant()) {</span>
<span class="line-added">+       // Zero the entry point so any new invocation will fail but keep</span>
<span class="line-added">+       // the address link around that so that existing activations can</span>
<span class="line-added">+       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).</span>
<span class="line-added">+       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);</span>
<span class="line-added">+     }</span>
    }
  }
  
<span class="line-modified">! void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {</span>
<span class="line-modified">!   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
<span class="line-modified">!     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {</span>
<span class="line-modified">!       JVMCI_THROW_MSG(InternalError, &quot;JVMCI has already been enabled in the JVMCI shared library&quot;);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   initialize(JVMCIENV);</span>
  
<span class="line-modified">!   // This should only be called in the context of the JVMCI class being initialized</span>
<span class="line-modified">!   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);</span>
<span class="line-modified">! </span>
<span class="line-added">+   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {</span>
<span class="line-added">+   assert(this != NULL, &quot;sanity&quot;);</span>
<span class="line-added">+   // Check first without JVMCI_lock</span>
<span class="line-added">+   if (_initialized) {</span>
      return;
    }
  
<span class="line-modified">!   MutexLocker locker(JVMCI_lock);</span>
<span class="line-modified">!   // Check again under JVMCI_lock</span>
<span class="line-modified">!   if (_initialized) {</span>
      return;
    }
  
<span class="line-modified">!   while (_being_initialized) {</span>
<span class="line-modified">!     JVMCI_lock-&gt;wait();</span>
<span class="line-modified">!     if (_initialized) {</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   _being_initialized = true;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     MutexUnlocker unlock(JVMCI_lock);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     HandleMark hm;</span>
<span class="line-modified">!     ResourceMark rm;</span>
<span class="line-modified">!     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-modified">!     if (JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-modified">!       HotSpotJVMCI::compute_offsets(CHECK_EXIT);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       JNIAccessMark jni(JVMCIENV);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       JNIJVMCI::initialize_ids(jni.env());</span>
<span class="line-modified">!       if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-modified">!         jni()-&gt;ExceptionDescribe();</span>
<span class="line-modified">!         fatal(&quot;JNI exception during init&quot;);</span>
        }
      }
<span class="line-added">+     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added">+     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added">+     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added">+     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added">+     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added">+     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added">+     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added">+     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added">+     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-added">+       JVMCIENV-&gt;copy_saved_properties();</span>
<span class="line-added">+     }</span>
    }
<span class="line-added">+ </span>
<span class="line-added">+   _initialized = true;</span>
<span class="line-added">+   _being_initialized = false;</span>
<span class="line-added">+   JVMCI_lock-&gt;notify_all();</span>
  }
  
<span class="line-modified">! JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {</span>
<span class="line-modified">!   Thread* THREAD = Thread::current();</span>
<span class="line-modified">!   // These primitive types are long lived and are created before the runtime is fully set up</span>
<span class="line-modified">!   // so skip registering them for scanning.</span>
<span class="line-added">+   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);</span>
<span class="line-added">+   if (JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-added">+     JavaValue result(T_OBJECT);</span>
<span class="line-added">+     JavaCallArguments args;</span>
<span class="line-added">+     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));</span>
<span class="line-added">+     args.push_int(type2char(type));</span>
<span class="line-added">+     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     JNIAccessMark jni(JVMCIENV);</span>
<span class="line-added">+     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),</span>
<span class="line-added">+                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),</span>
<span class="line-added">+                                            mirror.as_jobject(), type2char(type));</span>
<span class="line-added">+     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added">+       return JVMCIObject();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return JVMCIENV-&gt;wrap(result);</span>
    }
<span class="line-added">+ }</span>
  
<span class="line-modified">! void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {</span>
<span class="line-modified">!   if (!is_HotSpotJVMCIRuntime_initialized()) {</span>
<span class="line-modified">!     initialize(JVMCI_CHECK);</span>
<span class="line-modified">!     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {</span>
<span class="line-modified">!   initialize(JVMCIENV);</span>
<span class="line-added">+   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));</span>
<span class="line-added">+   return _HotSpotJVMCIRuntime_instance;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! </span>
<span class="line-added">+ // private void CompilerToVM.registerNatives()</span>
<span class="line-added">+ JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))</span>
<span class="line-added">+   JNI_JVMCIENV(thread, env);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!EnableJVMCI) {</span>
<span class="line-added">+     JVMCI_THROW_MSG(InternalError, &quot;JVMCI is not enabled&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);</span>
  
    {
<span class="line-added">+     ResourceMark rm;</span>
<span class="line-added">+     HandleMark hm(thread);</span>
      ThreadToNativeFromVM trans(thread);
<span class="line-modified">! </span>
<span class="line-added">+     // Ensure _non_oop_bits is initialized</span>
<span class="line-added">+     Universe::non_oop_word();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {</span>
<span class="line-added">+       if (!env-&gt;ExceptionCheck()) {</span>
<span class="line-added">+         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {</span>
<span class="line-added">+           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {</span>
<span class="line-added">+             guarantee(false, &quot;Error registering JNI method %s%s&quot;, CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         env-&gt;ExceptionDescribe();</span>
<span class="line-added">+       }</span>
<span class="line-added">+       guarantee(false, &quot;Failed registering CompilerToVM native methods&quot;);</span>
<span class="line-added">+     }</span>
    }
  JVM_END
  
<span class="line-modified">! </span>
<span class="line-modified">! void JVMCIRuntime::shutdown() {</span>
<span class="line-added">+   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
      _shutdown_called = true;
<span class="line-modified">! </span>
<span class="line-modified">!     THREAD_JVMCIENV(JavaThread::current());</span>
<span class="line-modified">!     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void JVMCIRuntime::bootstrap_finished(TRAPS) {</span>
<span class="line-modified">!   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
<span class="line-modified">!     THREAD_JVMCIENV(JavaThread::current());</span>
<span class="line-modified">!     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {</span>
<span class="line-modified">!   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-modified">!     Handle exception(THREAD, PENDING_EXCEPTION);</span>
<span class="line-modified">!     const char* exception_file = THREAD-&gt;exception_file();</span>
<span class="line-modified">!     int exception_line = THREAD-&gt;exception_line();</span>
<span class="line-modified">!     CLEAR_PENDING_EXCEPTION;</span>
<span class="line-modified">!     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {</span>
<span class="line-modified">!       // Don&#39;t print anything if we are being killed.</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       java_lang_Throwable::print_stack_trace(exception, tty);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       // Clear and ignore any exceptions raised during printing</span>
<span class="line-modified">!       CLEAR_PENDING_EXCEPTION;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (!clear) {</span>
<span class="line-modified">!       THREAD-&gt;set_pending_exception(exception(), exception_file, exception_line);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">! void JVMCIRuntime::exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message) {</span>
<span class="line-modified">!   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   static volatile int report_error = 0;</span>
<span class="line-modified">!   if (!report_error &amp;&amp; Atomic::cmpxchg(&amp;report_error, 0, 1) == 0) {</span>
<span class="line-modified">!     // Only report an error once</span>
<span class="line-modified">!     tty-&gt;print_raw_cr(message);</span>
<span class="line-modified">!     if (JVMCIENV != NULL) {</span>
<span class="line-modified">!       JVMCIENV-&gt;describe_pending_exception(true);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       describe_pending_hotspot_exception(THREAD, true);</span>
<span class="line-modified">!     }</span>
    } else {
<span class="line-modified">!     // Allow error reporting thread to print the stack trace.</span>
<span class="line-modified">!     THREAD-&gt;sleep(200);</span>
    }
  
<span class="line-modified">!   before_exit(THREAD);</span>
<span class="line-modified">!   vm_exit(-1);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! // Note: the logic of this method should mirror the logic of</span>
<span class="line-modified">! // constantPoolOopDesc::verify_constant_pool_resolve.</span>
<span class="line-modified">! bool JVMCIRuntime::check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass) {</span>
<span class="line-modified">!   if (accessing_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified">!     accessing_klass = ObjArrayKlass::cast(accessing_klass)-&gt;bottom_klass();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (!accessing_klass-&gt;is_instance_klass()) {</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   if (resolved_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified">!     // Find the element klass, if this is an array.</span>
<span class="line-modified">!     resolved_klass = ObjArrayKlass::cast(resolved_klass)-&gt;bottom_klass();</span>
    }
<span class="line-modified">!   if (resolved_klass-&gt;is_instance_klass()) {</span>
<span class="line-modified">!     Reflection::VerifyClassAccessResults result =</span>
<span class="line-added">+       Reflection::verify_class_access(accessing_klass, InstanceKlass::cast(resolved_klass), true);</span>
<span class="line-added">+     return result == Reflection::ACCESS_OK;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return true;</span>
  }
  
<span class="line-modified">! // ------------------------------------------------------------------</span>
<span class="line-modified">! Klass* JVMCIRuntime::get_klass_by_name_impl(Klass*&amp; accessing_klass,</span>
<span class="line-modified">!                                           const constantPoolHandle&amp; cpool,</span>
<span class="line-modified">!                                           Symbol* sym,</span>
<span class="line-modified">!                                           bool require_local) {</span>
<span class="line-modified">!   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-modified">! </span>
<span class="line-added">+   // Now we need to check the SystemDictionary</span>
<span class="line-added">+   if (sym-&gt;char_at(0) == JVM_SIGNATURE_CLASS &amp;&amp;</span>
<span class="line-added">+       sym-&gt;char_at(sym-&gt;utf8_length()-1) == JVM_SIGNATURE_ENDCLASS) {</span>
<span class="line-added">+     // This is a name from a signature.  Strip off the trimmings.</span>
<span class="line-added">+     // Call recursive to keep scope of strippedsym.</span>
<span class="line-added">+     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,</span>
<span class="line-added">+                                                         sym-&gt;utf8_length()-2);</span>
<span class="line-added">+     return get_klass_by_name_impl(accessing_klass, cpool, strippedsym, require_local);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Handle loader(THREAD, (oop)NULL);</span>
<span class="line-added">+   Handle domain(THREAD, (oop)NULL);</span>
<span class="line-added">+   if (accessing_klass != NULL) {</span>
<span class="line-added">+     loader = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-added">+     domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Klass* found_klass;</span>
<span class="line-added">+   {</span>
<span class="line-added">+     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems</span>
<span class="line-added">+     MutexLocker ml(Compile_lock);</span>
<span class="line-added">+     if (!require_local) {</span>
<span class="line-added">+       found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, CHECK_NULL);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain, CHECK_NULL);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If we fail to find an array klass, look again for its element type.</span>
<span class="line-added">+   // The element type may be available either locally or via constraints.</span>
<span class="line-added">+   // In either case, if we can find the element type in the system dictionary,</span>
<span class="line-added">+   // we must build an array type around it.  The CI requires array klasses</span>
<span class="line-added">+   // to be loaded if their element klasses are loaded, except when memory</span>
<span class="line-added">+   // is exhausted.</span>
<span class="line-added">+   if (sym-&gt;char_at(0) == JVM_SIGNATURE_ARRAY &amp;&amp;</span>
<span class="line-added">+       (sym-&gt;char_at(1) == JVM_SIGNATURE_ARRAY || sym-&gt;char_at(1) == JVM_SIGNATURE_CLASS)) {</span>
<span class="line-added">+     // We have an unloaded array.</span>
<span class="line-added">+     // Build it on the fly if the element class exists.</span>
<span class="line-added">+     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,</span>
<span class="line-added">+                                                      sym-&gt;utf8_length()-1);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Get element Klass recursively.</span>
<span class="line-added">+     Klass* elem_klass =</span>
<span class="line-added">+       get_klass_by_name_impl(accessing_klass,</span>
<span class="line-added">+                              cpool,</span>
<span class="line-added">+                              elem_sym,</span>
<span class="line-added">+                              require_local);</span>
<span class="line-added">+     if (elem_klass != NULL) {</span>
<span class="line-added">+       // Now make an array for it</span>
<span class="line-added">+       return elem_klass-&gt;array_klass(THREAD);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {</span>
<span class="line-added">+     // Look inside the constant pool for pre-resolved class entries.</span>
<span class="line-added">+     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {</span>
<span class="line-added">+       if (cpool-&gt;tag_at(i).is_klass()) {</span>
<span class="line-added">+         Klass*  kls = cpool-&gt;resolved_klass_at(i);</span>
<span class="line-added">+         if (kls-&gt;name() == sym) {</span>
<span class="line-added">+           return kls;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return found_klass;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ Klass* JVMCIRuntime::get_klass_by_name(Klass* accessing_klass,</span>
<span class="line-added">+                                   Symbol* klass_name,</span>
<span class="line-added">+                                   bool require_local) {</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   constantPoolHandle cpool;</span>
<span class="line-added">+   return get_klass_by_name_impl(accessing_klass,</span>
<span class="line-added">+                                                  cpool,</span>
<span class="line-added">+                                                  klass_name,</span>
<span class="line-added">+                                                  require_local);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ // Implementation of get_klass_by_index.</span>
<span class="line-added">+ Klass* JVMCIRuntime::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">+                                         int index,</span>
<span class="line-added">+                                         bool&amp; is_accessible,</span>
<span class="line-added">+                                         Klass* accessor) {</span>
<span class="line-added">+   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-added">+   Klass* klass = ConstantPool::klass_at_if_loaded(cpool, index);</span>
<span class="line-added">+   Symbol* klass_name = NULL;</span>
<span class="line-added">+   if (klass == NULL) {</span>
<span class="line-added">+     klass_name = cpool-&gt;klass_name_at(index);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (klass == NULL) {</span>
<span class="line-added">+     // Not found in constant pool.  Use the name to do the lookup.</span>
<span class="line-added">+     Klass* k = get_klass_by_name_impl(accessor,</span>
<span class="line-added">+                                         cpool,</span>
<span class="line-added">+                                         klass_name,</span>
<span class="line-added">+                                         false);</span>
<span class="line-added">+     // Calculate accessibility the hard way.</span>
<span class="line-added">+     if (k == NULL) {</span>
<span class="line-added">+       is_accessible = false;</span>
<span class="line-added">+     } else if (k-&gt;class_loader() != accessor-&gt;class_loader() &amp;&amp;</span>
<span class="line-added">+                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {</span>
<span class="line-added">+       // Loaded only remotely.  Not linked yet.</span>
<span class="line-added">+       is_accessible = false;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // Linked locally, and we must also check public/private, etc.</span>
<span class="line-added">+       is_accessible = check_klass_accessibility(accessor, k);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (!is_accessible) {</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return k;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // It is known to be accessible, since it was found in the constant pool.</span>
<span class="line-added">+   is_accessible = true;</span>
<span class="line-added">+   return klass;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ // Get a klass from the constant pool.</span>
<span class="line-added">+ Klass* JVMCIRuntime::get_klass_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">+                                    int index,</span>
<span class="line-added">+                                    bool&amp; is_accessible,</span>
<span class="line-added">+                                    Klass* accessor) {</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   Klass* result = get_klass_by_index_impl(cpool, index, is_accessible, accessor);</span>
<span class="line-added">+   return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ // Implementation of get_field_by_index.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Implementation note: the results of field lookups are cached</span>
<span class="line-added">+ // in the accessor klass.</span>
<span class="line-added">+ void JVMCIRuntime::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor&amp; field_desc,</span>
<span class="line-added">+                                         int index) {</span>
<span class="line-added">+   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(klass-&gt;is_linked(), &quot;must be linked before using its constant-pool&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   constantPoolHandle cpool(thread, klass-&gt;constants());</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Get the field&#39;s name, signature, and type.</span>
<span class="line-added">+   Symbol* name  = cpool-&gt;name_ref_at(index);</span>
<span class="line-added">+ </span>
<span class="line-added">+   int nt_index = cpool-&gt;name_and_type_ref_index_at(index);</span>
<span class="line-added">+   int sig_index = cpool-&gt;signature_ref_index_at(nt_index);</span>
<span class="line-added">+   Symbol* signature = cpool-&gt;symbol_at(sig_index);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Get the field&#39;s declared holder.</span>
<span class="line-added">+   int holder_index = cpool-&gt;klass_ref_index_at(index);</span>
<span class="line-added">+   bool holder_is_accessible;</span>
<span class="line-added">+   Klass* declared_holder = get_klass_by_index(cpool, holder_index,</span>
<span class="line-added">+                                                holder_is_accessible,</span>
<span class="line-added">+                                                klass);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // The declared holder of this field may not have been loaded.</span>
<span class="line-added">+   // Bail out with partial field information.</span>
<span class="line-added">+   if (!holder_is_accessible) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+   // Perform the field lookup.</span>
<span class="line-added">+   Klass*  canonical_holder =</span>
<span class="line-added">+     InstanceKlass::cast(declared_holder)-&gt;find_field(name, signature, &amp;field_desc);</span>
<span class="line-added">+   if (canonical_holder == NULL) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(canonical_holder == field_desc.field_holder(), &quot;just checking&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ // Get a field by index from a klass&#39;s constant pool.</span>
<span class="line-added">+ void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor&amp; fd, int index) {</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   return get_field_by_index_impl(accessor, fd, index);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ // Perform an appropriate method lookup based on accessor, holder,</span>
<span class="line-added">+ // name, signature, and bytecode.</span>
<span class="line-added">+ Method* JVMCIRuntime::lookup_method(InstanceKlass* accessor,</span>
<span class="line-added">+                                     Klass*        holder,</span>
<span class="line-added">+                                     Symbol*       name,</span>
<span class="line-added">+                                     Symbol*       sig,</span>
<span class="line-added">+                                     Bytecodes::Code bc,</span>
<span class="line-added">+                                     constantTag   tag) {</span>
<span class="line-added">+   // Accessibility checks are performed in JVMCIEnv::get_method_by_index_impl().</span>
<span class="line-added">+   assert(check_klass_accessibility(accessor, holder), &quot;holder not accessible&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Method* dest_method;</span>
<span class="line-added">+   LinkInfo link_info(holder, name, sig, accessor, LinkInfo::needs_access_check, tag);</span>
<span class="line-added">+   switch (bc) {</span>
<span class="line-added">+   case Bytecodes::_invokestatic:</span>
<span class="line-added">+     dest_method =</span>
<span class="line-added">+       LinkResolver::resolve_static_call_or_null(link_info);</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   case Bytecodes::_invokespecial:</span>
<span class="line-added">+     dest_method =</span>
<span class="line-added">+       LinkResolver::resolve_special_call_or_null(link_info);</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   case Bytecodes::_invokeinterface:</span>
<span class="line-added">+     dest_method =</span>
<span class="line-added">+       LinkResolver::linktime_resolve_interface_method_or_null(link_info);</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   case Bytecodes::_invokevirtual:</span>
<span class="line-added">+     dest_method =</span>
<span class="line-added">+       LinkResolver::linktime_resolve_virtual_method_or_null(link_info);</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   default: ShouldNotReachHere();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return dest_method;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ Method* JVMCIRuntime::get_method_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">+                                                int index, Bytecodes::Code bc,</span>
<span class="line-added">+                                                InstanceKlass* accessor) {</span>
<span class="line-added">+   if (bc == Bytecodes::_invokedynamic) {</span>
<span class="line-added">+     ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);</span>
<span class="line-added">+     bool is_resolved = !cpce-&gt;is_f1_null();</span>
<span class="line-added">+     if (is_resolved) {</span>
<span class="line-added">+       // Get the invoker Method* from the constant pool.</span>
<span class="line-added">+       // (The appendix argument, if any, will be noted in the method&#39;s signature.)</span>
<span class="line-added">+       Method* adapter = cpce-&gt;f1_as_method();</span>
<span class="line-added">+       return adapter;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int holder_index = cpool-&gt;klass_ref_index_at(index);</span>
<span class="line-added">+   bool holder_is_accessible;</span>
<span class="line-added">+   Klass* holder = get_klass_by_index_impl(cpool, holder_index, holder_is_accessible, accessor);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Get the method&#39;s name and signature.</span>
<span class="line-added">+   Symbol* name_sym = cpool-&gt;name_ref_at(index);</span>
<span class="line-added">+   Symbol* sig_sym  = cpool-&gt;signature_ref_at(index);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (cpool-&gt;has_preresolution()</span>
<span class="line-added">+       || ((holder == SystemDictionary::MethodHandle_klass() || holder == SystemDictionary::VarHandle_klass()) &amp;&amp;</span>
<span class="line-added">+           MethodHandles::is_signature_polymorphic_name(holder, name_sym))) {</span>
<span class="line-added">+     // Short-circuit lookups for JSR 292-related call sites.</span>
<span class="line-added">+     // That is, do not rely only on name-based lookups, because they may fail</span>
<span class="line-added">+     // if the names are not resolvable in the boot class loader (7056328).</span>
<span class="line-added">+     switch (bc) {</span>
<span class="line-added">+     case Bytecodes::_invokevirtual:</span>
<span class="line-added">+     case Bytecodes::_invokeinterface:</span>
<span class="line-added">+     case Bytecodes::_invokespecial:</span>
<span class="line-added">+     case Bytecodes::_invokestatic:</span>
<span class="line-added">+       {</span>
<span class="line-added">+         Method* m = ConstantPool::method_at_if_loaded(cpool, index);</span>
<span class="line-added">+         if (m != NULL) {</span>
<span class="line-added">+           return m;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (holder_is_accessible) { // Our declared holder is loaded.</span>
<span class="line-added">+     constantTag tag = cpool-&gt;tag_ref_at(index);</span>
<span class="line-added">+     Method* m = lookup_method(accessor, holder, name_sym, sig_sym, bc, tag);</span>
<span class="line-added">+     if (m != NULL) {</span>
<span class="line-added">+       // We found the method.</span>
<span class="line-added">+       return m;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Either the declared holder was not loaded, or the method could</span>
<span class="line-added">+   // not be found.</span>
<span class="line-added">+ </span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ InstanceKlass* JVMCIRuntime::get_instance_klass_for_declared_method_holder(Klass* method_holder) {</span>
<span class="line-added">+   // For the case of &lt;array&gt;.clone(), the method holder can be an ArrayKlass*</span>
<span class="line-added">+   // instead of an InstanceKlass*.  For that case simply pretend that the</span>
<span class="line-added">+   // declared holder is Object.clone since that&#39;s where the call will bottom out.</span>
<span class="line-added">+   if (method_holder-&gt;is_instance_klass()) {</span>
<span class="line-added">+     return InstanceKlass::cast(method_holder);</span>
<span class="line-added">+   } else if (method_holder-&gt;is_array_klass()) {</span>
<span class="line-added">+     return SystemDictionary::Object_klass();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     ShouldNotReachHere();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ Method* JVMCIRuntime::get_method_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">+                                      int index, Bytecodes::Code bc,</span>
<span class="line-added">+                                      InstanceKlass* accessor) {</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   return get_method_by_index_impl(cpool, index, bc, accessor);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ // Check for changes to the system dictionary during compilation</span>
<span class="line-added">+ // class loads, evolution, breakpoints</span>
<span class="line-added">+ JVMCI::CodeInstallResult JVMCIRuntime::validate_compile_task_dependencies(Dependencies* dependencies, JVMCICompileState* compile_state, char** failure_detail) {</span>
<span class="line-added">+   // If JVMTI capabilities were enabled during compile, the compilation is invalidated.</span>
<span class="line-added">+   if (compile_state != NULL &amp;&amp; compile_state-&gt;jvmti_state_changed()) {</span>
<span class="line-added">+     *failure_detail = (char*) &quot;Jvmti state change during compilation invalidated dependencies&quot;;</span>
<span class="line-added">+     return JVMCI::dependencies_failed;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   CompileTask* task = compile_state == NULL ? NULL : compile_state-&gt;task();</span>
<span class="line-added">+   Dependencies::DepType result = dependencies-&gt;validate_dependencies(task, failure_detail);</span>
<span class="line-added">+   if (result == Dependencies::end_marker) {</span>
<span class="line-added">+     return JVMCI::ok;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return JVMCI::dependencies_failed;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Reports a pending exception and exits the VM.</span>
<span class="line-added">+ static void fatal_exception_in_compile(JVMCIEnv* JVMCIENV, JavaThread* thread, const char* msg) {</span>
<span class="line-added">+   // Only report a fatal JVMCI compilation exception once</span>
<span class="line-added">+   static volatile int report_init_failure = 0;</span>
<span class="line-added">+   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(&amp;report_init_failure, 0, 1) == 0) {</span>
<span class="line-added">+       tty-&gt;print_cr(&quot;%s:&quot;, msg);</span>
<span class="line-added">+       JVMCIENV-&gt;describe_pending_exception(true);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIENV-&gt;clear_pending_exception();</span>
<span class="line-added">+   before_exit(thread);</span>
<span class="line-added">+   vm_exit(-1);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {</span>
<span class="line-added">+   JVMCI_EXCEPTION_CONTEXT</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool is_osr = entry_bci != InvocationEntryBci;</span>
<span class="line-added">+   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {</span>
<span class="line-added">+     // no OSR compilations during bootstrap - the compiler is just too slow at this point,</span>
<span class="line-added">+     // and we know that there are no endless loops</span>
<span class="line-added">+     compile_state-&gt;set_failure(true, &quot;No OSR during boostrap&quot;);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (JVMCI::shutdown_called()) {</span>
<span class="line-added">+     compile_state-&gt;set_failure(false, &quot;Avoiding compilation during shutdown&quot;);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   HandleMark hm;</span>
<span class="line-added">+   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);</span>
<span class="line-added">+   if (JVMCIENV-&gt;has_pending_exception()) {</span>
<span class="line-added">+     fatal_exception_in_compile(JVMCIENV, thread, &quot;Exception during HotSpotJVMCIRuntime initialization&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);</span>
<span class="line-added">+   if (JVMCIENV-&gt;has_pending_exception()) {</span>
<span class="line-added">+     JVMCIENV-&gt;describe_pending_exception(true);</span>
<span class="line-added">+     compile_state-&gt;set_failure(false, &quot;exception getting JVMCI wrapper method&quot;);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,</span>
<span class="line-added">+                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());</span>
<span class="line-added">+   if (!JVMCIENV-&gt;has_pending_exception()) {</span>
<span class="line-added">+     if (result_object.is_non_null()) {</span>
<span class="line-added">+       JVMCIObject failure_message = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_failureMessage(result_object);</span>
<span class="line-added">+       if (failure_message.is_non_null()) {</span>
<span class="line-added">+         // Copy failure reason into resource memory first ...</span>
<span class="line-added">+         const char* failure_reason = JVMCIENV-&gt;as_utf8_string(failure_message);</span>
<span class="line-added">+         // ... and then into the C heap.</span>
<span class="line-added">+         failure_reason = os::strdup(failure_reason, mtJVMCI);</span>
<span class="line-added">+         bool retryable = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_retry(result_object) != 0;</span>
<span class="line-added">+         compile_state-&gt;set_failure(retryable, failure_reason, true);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         if (compile_state-&gt;task()-&gt;code() == NULL) {</span>
<span class="line-added">+           compile_state-&gt;set_failure(true, &quot;no nmethod produced&quot;);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           compile_state-&gt;task()-&gt;set_num_inlined_bytecodes(JVMCIENV-&gt;get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));</span>
<span class="line-added">+           compiler-&gt;inc_methods_compiled();</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(false, &quot;JVMCICompiler.compileMethod should always return non-null&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // An uncaught exception here implies failure during compiler initialization.</span>
<span class="line-added">+     // The only sensible thing to do here is to exit the VM.</span>
<span class="line-added">+     fatal_exception_in_compile(JVMCIENV, thread, &quot;Exception during JVMCI compiler initialization&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (compiler-&gt;is_bootstrapping()) {</span>
<span class="line-added">+     compiler-&gt;set_bootstrap_compilation_request_handled();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------------------------------------------</span>
<span class="line-added">+ JVMCI::CodeInstallResult JVMCIRuntime::register_method(JVMCIEnv* JVMCIENV,</span>
<span class="line-added">+                                 const methodHandle&amp; method,</span>
<span class="line-added">+                                 nmethod*&amp; nm,</span>
<span class="line-added">+                                 int entry_bci,</span>
<span class="line-added">+                                 CodeOffsets* offsets,</span>
<span class="line-added">+                                 int orig_pc_offset,</span>
<span class="line-added">+                                 CodeBuffer* code_buffer,</span>
<span class="line-added">+                                 int frame_words,</span>
<span class="line-added">+                                 OopMapSet* oop_map_set,</span>
<span class="line-added">+                                 ExceptionHandlerTable* handler_table,</span>
<span class="line-added">+                                 ImplicitExceptionTable* implicit_exception_table,</span>
<span class="line-added">+                                 AbstractCompiler* compiler,</span>
<span class="line-added">+                                 DebugInformationRecorder* debug_info,</span>
<span class="line-added">+                                 Dependencies* dependencies,</span>
<span class="line-added">+                                 int compile_id,</span>
<span class="line-added">+                                 bool has_unsafe_access,</span>
<span class="line-added">+                                 bool has_wide_vector,</span>
<span class="line-added">+                                 JVMCIObject compiled_code,</span>
<span class="line-added">+                                 JVMCIObject nmethod_mirror,</span>
<span class="line-added">+                                 FailedSpeculation** failed_speculations,</span>
<span class="line-added">+                                 char* speculations,</span>
<span class="line-added">+                                 int speculations_len) {</span>
<span class="line-added">+   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-added">+   nm = NULL;</span>
<span class="line-added">+   int comp_level = CompLevel_full_optimization;</span>
<span class="line-added">+   char* failure_detail = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool install_default = JVMCIENV-&gt;get_HotSpotNmethod_isDefault(nmethod_mirror) != 0;</span>
<span class="line-added">+   assert(JVMCIENV-&gt;isa_HotSpotNmethod(nmethod_mirror), &quot;must be&quot;);</span>
<span class="line-added">+   JVMCIObject name = JVMCIENV-&gt;get_InstalledCode_name(nmethod_mirror);</span>
<span class="line-added">+   const char* nmethod_mirror_name = name.is_null() ? NULL : JVMCIENV-&gt;as_utf8_string(name);</span>
<span class="line-added">+   int nmethod_mirror_index;</span>
<span class="line-added">+   if (!install_default) {</span>
<span class="line-added">+     // Reserve or initialize mirror slot in the oops table.</span>
<span class="line-added">+     OopRecorder* oop_recorder = debug_info-&gt;oop_recorder();</span>
<span class="line-added">+     nmethod_mirror_index = oop_recorder-&gt;allocate_oop_index(nmethod_mirror.is_hotspot() ? nmethod_mirror.as_jobject() : NULL);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // A default HotSpotNmethod mirror is never tracked by the nmethod</span>
<span class="line-added">+     nmethod_mirror_index = -1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JVMCI::CodeInstallResult result;</span>
<span class="line-added">+   {</span>
<span class="line-added">+     // To prevent compile queue updates.</span>
<span class="line-added">+     MutexLocker locker(THREAD, MethodCompileQueue_lock);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Prevent SystemDictionary::add_to_hierarchy from running</span>
<span class="line-added">+     // and invalidating our dependencies until we install this method.</span>
<span class="line-added">+     MutexLocker ml(Compile_lock);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Encode the dependencies now, so we can check them right away.</span>
<span class="line-added">+     dependencies-&gt;encode_content_bytes();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Record the dependencies for the current compile in the log</span>
<span class="line-added">+     if (LogCompilation) {</span>
<span class="line-added">+       for (Dependencies::DepStream deps(dependencies); deps.next(); ) {</span>
<span class="line-added">+         deps.log_dependency();</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Check for {class loads, evolution, breakpoints} during compilation</span>
<span class="line-added">+     result = validate_compile_task_dependencies(dependencies, JVMCIENV-&gt;compile_state(), &amp;failure_detail);</span>
<span class="line-added">+     if (result != JVMCI::ok) {</span>
<span class="line-added">+       // While not a true deoptimization, it is a preemptive decompile.</span>
<span class="line-added">+       MethodData* mdp = method()-&gt;method_data();</span>
<span class="line-added">+       if (mdp != NULL) {</span>
<span class="line-added">+         mdp-&gt;inc_decompile_count();</span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+         if (mdp-&gt;decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {</span>
<span class="line-added">+           ResourceMark m;</span>
<span class="line-added">+           tty-&gt;print_cr(&quot;WARN: endless recompilation of %s. Method was set to not compilable.&quot;, method()-&gt;name_and_sig_as_C_string());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       // All buffers in the CodeBuffer are allocated in the CodeCache.</span>
<span class="line-added">+       // If the code buffer is created on each compile attempt</span>
<span class="line-added">+       // as in C2, then it must be freed.</span>
<span class="line-added">+       //code_buffer-&gt;free_blob();</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       nm =  nmethod::new_nmethod(method,</span>
<span class="line-added">+                                  compile_id,</span>
<span class="line-added">+                                  entry_bci,</span>
<span class="line-added">+                                  offsets,</span>
<span class="line-added">+                                  orig_pc_offset,</span>
<span class="line-added">+                                  debug_info, dependencies, code_buffer,</span>
<span class="line-added">+                                  frame_words, oop_map_set,</span>
<span class="line-added">+                                  handler_table, implicit_exception_table,</span>
<span class="line-added">+                                  compiler, comp_level,</span>
<span class="line-added">+                                  speculations, speculations_len,</span>
<span class="line-added">+                                  nmethod_mirror_index, nmethod_mirror_name, failed_speculations);</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+       // Free codeBlobs</span>
<span class="line-added">+       if (nm == NULL) {</span>
<span class="line-added">+         // The CodeCache is full.  Print out warning and disable compilation.</span>
<span class="line-added">+         {</span>
<span class="line-added">+           MutexUnlocker ml(Compile_lock);</span>
<span class="line-added">+           MutexUnlocker locker(MethodCompileQueue_lock);</span>
<span class="line-added">+           CompileBroker::handle_full_code_cache(CodeCache::get_code_blob_type(comp_level));</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         nm-&gt;set_has_unsafe_access(has_unsafe_access);</span>
<span class="line-added">+         nm-&gt;set_has_wide_vectors(has_wide_vector);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Record successful registration.</span>
<span class="line-added">+         // (Put nm into the task handle *before* publishing to the Java heap.)</span>
<span class="line-added">+         if (JVMCIENV-&gt;compile_state() != NULL) {</span>
<span class="line-added">+           JVMCIENV-&gt;compile_state()-&gt;task()-&gt;set_code(nm);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();</span>
<span class="line-added">+         assert(data != NULL, &quot;must be&quot;);</span>
<span class="line-added">+         if (install_default) {</span>
<span class="line-added">+           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == NULL, &quot;must be&quot;);</span>
<span class="line-added">+           if (entry_bci == InvocationEntryBci) {</span>
<span class="line-added">+             if (TieredCompilation) {</span>
<span class="line-added">+               // If there is an old version we&#39;re done with it</span>
<span class="line-added">+               CompiledMethod* old = method-&gt;code();</span>
<span class="line-added">+               if (TraceMethodReplacement &amp;&amp; old != NULL) {</span>
<span class="line-added">+                 ResourceMark rm;</span>
<span class="line-added">+                 char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-added">+                 tty-&gt;print_cr(&quot;Replacing method %s&quot;, method_name);</span>
<span class="line-added">+               }</span>
<span class="line-added">+               if (old != NULL ) {</span>
<span class="line-added">+                 old-&gt;make_not_entrant();</span>
<span class="line-added">+               }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             LogTarget(Info, nmethod, install) lt;</span>
<span class="line-added">+             if (lt.is_enabled()) {</span>
<span class="line-added">+               ResourceMark rm;</span>
<span class="line-added">+               char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-added">+               lt.print(&quot;Installing method (%d) %s [entry point: %p]&quot;,</span>
<span class="line-added">+                         comp_level, method_name, nm-&gt;entry_point());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // Allow the code to be executed</span>
<span class="line-added">+             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+             if (nm-&gt;make_in_use()) {</span>
<span class="line-added">+               method-&gt;set_code(method, nm);</span>
<span class="line-added">+             }</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+             LogTarget(Info, nmethod, install) lt;</span>
<span class="line-added">+             if (lt.is_enabled()) {</span>
<span class="line-added">+               ResourceMark rm;</span>
<span class="line-added">+               char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-added">+               lt.print(&quot;Installing osr method (%d) %s @ %d&quot;,</span>
<span class="line-added">+                         comp_level, method_name, entry_bci);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+             if (nm-&gt;make_in_use()) {</span>
<span class="line-added">+               InstanceKlass::cast(method-&gt;method_holder())-&gt;add_osr_nmethod(nm);</span>
<span class="line-added">+             }</span>
<span class="line-added">+           }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == HotSpotJVMCI::resolve(nmethod_mirror), &quot;must be&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       result = nm != NULL ? JVMCI::ok :JVMCI::cache_full;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // String creation must be done outside lock</span>
<span class="line-added">+   if (failure_detail != NULL) {</span>
<span class="line-added">+     // A failure to allocate the string is silently ignored.</span>
<span class="line-added">+     JVMCIObject message = JVMCIENV-&gt;create_string(failure_detail, JVMCIENV);</span>
<span class="line-added">+     JVMCIENV-&gt;set_HotSpotCompiledNmethod_installationFailureMessage(compiled_code, message);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // JVMTI -- compiled method notification (must be done outside lock)</span>
<span class="line-added">+   if (nm != NULL) {</span>
<span class="line-added">+     nm-&gt;post_compiled_method_load_event();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return result;</span>
  }
</pre>
<center><a href="jvmciJavaClasses.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciRuntime.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
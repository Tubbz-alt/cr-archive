<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciJavaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
<span class="line-modified">  25 #include &quot;jvm.h&quot;</span>
<span class="line-removed">  26 #include &quot;asm/codeBuffer.hpp&quot;</span>
<span class="line-removed">  27 #include &quot;classfile/javaClasses.inline.hpp&quot;</span>
<span class="line-removed">  28 #include &quot;code/codeCache.hpp&quot;</span>
<span class="line-removed">  29 #include &quot;code/compiledMethod.inline.hpp&quot;</span>
  30 #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-modified">  31 #include &quot;compiler/disassembler.hpp&quot;</span>
<span class="line-removed">  32 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
  33 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
<span class="line-modified">  34 #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
<span class="line-removed">  35 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
<span class="line-removed">  36 #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
  37 #include &quot;logging/log.hpp&quot;
<span class="line-removed">  38 #include &quot;memory/allocation.inline.hpp&quot;</span>
  39 #include &quot;memory/oopFactory.hpp&quot;
<span class="line-modified">  40 #include &quot;memory/resourceArea.hpp&quot;</span>



  41 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified">  42 #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
  43 #include &quot;runtime/biasedLocking.hpp&quot;


  44 #include &quot;runtime/frame.inline.hpp&quot;
<span class="line-removed">  45 #include &quot;runtime/handles.inline.hpp&quot;</span>
<span class="line-removed">  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;</span>
<span class="line-removed">  47 #include &quot;runtime/jniHandles.inline.hpp&quot;</span>
<span class="line-removed">  48 #include &quot;runtime/reflection.hpp&quot;</span>
  49 #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-removed">  50 #include &quot;runtime/threadSMR.hpp&quot;</span>
<span class="line-removed">  51 #include &quot;utilities/debug.hpp&quot;</span>
<span class="line-removed">  52 #include &quot;utilities/defaultStream.hpp&quot;</span>
<span class="line-removed">  53 #include &quot;utilities/macros.hpp&quot;</span>
  54 #if INCLUDE_G1GC
  55 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  56 #endif // INCLUDE_G1GC
  57 
<span class="line-removed">  58 #if defined(_MSC_VER)</span>
<span class="line-removed">  59 #define strtoll _strtoi64</span>
<span class="line-removed">  60 #endif</span>
<span class="line-removed">  61 </span>
<span class="line-removed">  62 jobject JVMCIRuntime::_HotSpotJVMCIRuntime_instance = NULL;</span>
<span class="line-removed">  63 bool JVMCIRuntime::_HotSpotJVMCIRuntime_initialized = false;</span>
<span class="line-removed">  64 bool JVMCIRuntime::_well_known_classes_initialized = false;</span>
<span class="line-removed">  65 JVMCIRuntime::CompLevelAdjustment JVMCIRuntime::_comp_level_adjustment = JVMCIRuntime::none;</span>
<span class="line-removed">  66 bool JVMCIRuntime::_shutdown_called = false;</span>
<span class="line-removed">  67 </span>
<span class="line-removed">  68 BasicType JVMCIRuntime::kindToBasicType(Handle kind, TRAPS) {</span>
<span class="line-removed">  69   if (kind.is_null()) {</span>
<span class="line-removed">  70     THROW_(vmSymbols::java_lang_NullPointerException(), T_ILLEGAL);</span>
<span class="line-removed">  71   }</span>
<span class="line-removed">  72   jchar ch = JavaKind::typeChar(kind);</span>
<span class="line-removed">  73   switch(ch) {</span>
<span class="line-removed">  74     case &#39;Z&#39;: return T_BOOLEAN;</span>
<span class="line-removed">  75     case &#39;B&#39;: return T_BYTE;</span>
<span class="line-removed">  76     case &#39;S&#39;: return T_SHORT;</span>
<span class="line-removed">  77     case &#39;C&#39;: return T_CHAR;</span>
<span class="line-removed">  78     case &#39;I&#39;: return T_INT;</span>
<span class="line-removed">  79     case &#39;F&#39;: return T_FLOAT;</span>
<span class="line-removed">  80     case &#39;J&#39;: return T_LONG;</span>
<span class="line-removed">  81     case &#39;D&#39;: return T_DOUBLE;</span>
<span class="line-removed">  82     case &#39;A&#39;: return T_OBJECT;</span>
<span class="line-removed">  83     case &#39;-&#39;: return T_ILLEGAL;</span>
<span class="line-removed">  84     default:</span>
<span class="line-removed">  85       JVMCI_ERROR_(T_ILLEGAL, &quot;unexpected Kind: %c&quot;, ch);</span>
<span class="line-removed">  86   }</span>
<span class="line-removed">  87 }</span>
<span class="line-removed">  88 </span>
  89 // Simple helper to see if the caller of a runtime stub which
  90 // entered the VM has been deoptimized
  91 
  92 static bool caller_is_deopted() {
  93   JavaThread* thread = JavaThread::current();
  94   RegisterMap reg_map(thread, false);
  95   frame runtime_frame = thread-&gt;last_frame();
  96   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  97   assert(caller_frame.is_compiled_frame(), &quot;must be compiled&quot;);
  98   return caller_frame.is_deoptimized_frame();
  99 }
 100 
 101 // Stress deoptimization
 102 static void deopt_caller() {
 103   if ( !caller_is_deopted()) {
 104     JavaThread* thread = JavaThread::current();
 105     RegisterMap reg_map(thread, false);
 106     frame runtime_frame = thread-&gt;last_frame();
 107     frame caller_frame = runtime_frame.sender(&amp;reg_map);
 108     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
</pre>
<hr />
<pre>
 135       _thread-&gt;set_in_retryable_allocation(false);
 136       JavaThread* THREAD = _thread;
 137       if (HAS_PENDING_EXCEPTION) {
 138         oop ex = PENDING_EXCEPTION;
 139         CLEAR_PENDING_EXCEPTION;
 140         oop retry_oome = Universe::out_of_memory_error_retry();
 141         if (ex-&gt;is_a(retry_oome-&gt;klass()) &amp;&amp; retry_oome != ex) {
 142           ResourceMark rm;
 143           fatal(&quot;Unexpected exception in scope of retryable allocation: &quot; INTPTR_FORMAT &quot; of type %s&quot;, p2i(ex), ex-&gt;klass()-&gt;external_name());
 144         }
 145         _thread-&gt;set_vm_result(NULL);
 146       }
 147     }
 148   }
 149 };
 150 
 151 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))
 152   JRT_BLOCK;
 153   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 154   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
<span class="line-modified"> 155   InstanceKlass* ik = InstanceKlass::cast(klass);</span>
 156   {
 157     RetryableAllocationMark ram(thread, null_on_fail);
<span class="line-modified"> 158     ik-&gt;check_valid_for_instantiation(true, CHECK);</span>
 159     oop obj;
 160     if (null_on_fail) {
<span class="line-modified"> 161       if (!ik-&gt;is_initialized()) {</span>
 162         // Cannot re-execute class initialization without side effects
 163         // so return without attempting the initialization
 164         return;
 165       }
 166     } else {
 167       // make sure klass is initialized
<span class="line-modified"> 168       ik-&gt;initialize(CHECK);</span>
 169     }
 170     // allocate instance and return via TLS
<span class="line-modified"> 171     obj = ik-&gt;allocate_instance(CHECK);</span>
 172     thread-&gt;set_vm_result(obj);
 173   }
 174   JRT_BLOCK_END;
 175   SharedRuntime::on_slowpath_allocation_exit(thread);
 176 JRT_END
 177 
 178 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* thread, Klass* array_klass, jint length, bool null_on_fail))
 179   JRT_BLOCK;
 180   // Note: no handle for klass needed since they are not used
 181   //       anymore after new_objArray() and no GC can happen before.
 182   //       (This may have to change if this code changes!)
 183   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);
 184   oop obj;
 185   if (array_klass-&gt;is_typeArray_klass()) {
 186     BasicType elt_type = TypeArrayKlass::cast(array_klass)-&gt;element_type();
 187     RetryableAllocationMark ram(thread, null_on_fail);
 188     obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 189   } else {
 190     Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
 191     Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();
</pre>
<hr />
<pre>
 273 // been deoptimized. If that is the case we return the deopt blob
 274 // unpack_with_exception entry instead. This makes life for the exception blob easier
 275 // because making that same check and diverting is painful from assembly language.
 276 JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, CompiledMethod*&amp; cm))
 277   // Reset method handle flag.
 278   thread-&gt;set_is_method_handle_return(false);
 279 
 280   Handle exception(thread, ex);
 281   cm = CodeCache::find_compiled(pc);
 282   assert(cm != NULL, &quot;this is not a compiled method&quot;);
 283   // Adjust the pc as needed/
 284   if (cm-&gt;is_deopt_pc(pc)) {
 285     RegisterMap map(thread, false);
 286     frame exception_frame = thread-&gt;last_frame().sender(&amp;map);
 287     // if the frame isn&#39;t deopted then pc must not correspond to the caller of last_frame
 288     assert(exception_frame.is_deoptimized_frame(), &quot;must be deopted&quot;);
 289     pc = exception_frame.pc();
 290   }
 291 #ifdef ASSERT
 292   assert(exception.not_null(), &quot;NULL exceptions should be handled by throw_exception&quot;);

 293   // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
 294   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
 295     if (ExitVMOnVerifyError) vm_exit(-1);
 296     ShouldNotReachHere();
 297   }
 298 #endif
 299 
 300   // Check the stack guard pages and reenable them if necessary and there is
 301   // enough space on the stack to do so.  Use fast exceptions only if the guard
 302   // pages are enabled.
 303   bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 304   if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 305 
 306   if (JvmtiExport::can_post_on_exceptions()) {
 307     // To ensure correct notification of exception catches and throws
 308     // we have to deoptimize here.  If we attempted to notify the
 309     // catches and throws during this exception lookup it&#39;s possible
 310     // we could deoptimize on the way out of the VM and end back in
 311     // the interpreter at the throw site.  This would result in double
 312     // notifications since the interpreter would also notify about
</pre>
<hr />
<pre>
 336   }
 337 
 338   // If the stack guard pages are enabled, check whether there is a handler in
 339   // the current method.  Otherwise (guard pages disabled), force an unwind and
 340   // skip the exception cache update (i.e., just leave continuation==NULL).
 341   address continuation = NULL;
 342   if (guard_pages_enabled) {
 343 
 344     // New exception handling mechanism can support inlined methods
 345     // with exception handlers since the mappings are from PC to PC
 346 
 347     // debugging support
 348     // tracing
 349     if (log_is_enabled(Info, exceptions)) {
 350       ResourceMark rm;
 351       stringStream tempst;
 352       assert(cm-&gt;method() != NULL, &quot;Unexpected null method()&quot;);
 353       tempst.print(&quot;compiled method &lt;%s&gt;\n&quot;
 354                    &quot; at PC&quot; INTPTR_FORMAT &quot; for thread &quot; INTPTR_FORMAT,
 355                    cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
<span class="line-modified"> 356       Exceptions::log_exception(exception, tempst);</span>
 357     }
 358     // for AbortVMOnException flag
 359     NOT_PRODUCT(Exceptions::debug_check_abort(exception));
 360 
 361     // Clear out the exception oop and pc since looking up an
 362     // exception handler can cause class loading, which might throw an
 363     // exception and those fields are expected to be clear during
 364     // normal bytecode execution.
 365     thread-&gt;clear_exception_oop_and_pc();
 366 
 367     bool recursive_exception = false;
 368     continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
 369     // If an exception was thrown during exception dispatch, the exception oop may have changed
 370     thread-&gt;set_exception_oop(exception());
 371     thread-&gt;set_exception_pc(pc);
 372 
<span class="line-modified"> 373     // the exception cache is used only by non-implicit exceptions</span>
<span class="line-modified"> 374     // Update the exception cache only when there didn&#39;t happen</span>
<span class="line-modified"> 375     // another exception during the computation of the compiled</span>
<span class="line-modified"> 376     // exception handler. Checking for exception oop equality is not</span>

 377     // sufficient because some exceptions are pre-allocated and reused.
 378     if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
 379       cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
 380     }
 381   }
 382 
 383   // Set flag if return address is a method handle call site.
 384   thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 385 
 386   if (log_is_enabled(Info, exceptions)) {
 387     ResourceMark rm;
 388     log_info(exceptions)(&quot;Thread &quot; PTR_FORMAT &quot; continuing at PC &quot; PTR_FORMAT
 389                          &quot; for exception thrown at PC &quot; PTR_FORMAT,
 390                          p2i(thread), p2i(continuation), p2i(pc));
 391   }
 392 
 393   return continuation;
 394 JRT_END
 395 
 396 // Enter this method from compiled code only if there is a Java exception handler
</pre>
<hr />
<pre>
 409     // Enter VM mode by calling the helper
 410     ResetNoHandleMark rnhm;
 411     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
 412   }
 413   // Back in JAVA, use no oops DON&#39;T safepoint
 414 
 415   // Now check to see if the compiled method we were called from is now deoptimized.
 416   // If so we must return to the deopt blob and deoptimize the nmethod
 417   if (cm != NULL &amp;&amp; caller_is_deopted()) {
 418     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 419   }
 420 
 421   assert(continuation != NULL, &quot;no handler found&quot;);
 422   return continuation;
 423 }
 424 
 425 JRT_ENTRY_NO_ASYNC(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 426   IF_TRACE_jvmci_3 {
 427     char type[O_BUFLEN];
 428     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
<span class="line-modified"> 429     markOop mark = obj-&gt;mark();</span>
<span class="line-modified"> 430     TRACE_jvmci_3(&quot;%s: entered locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, p2i(mark), p2i(lock));</span>
 431     tty-&gt;flush();
 432   }
<span class="line-removed"> 433 #ifdef ASSERT</span>
 434   if (PrintBiasedLockingStatistics) {
 435     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
 436   }
<span class="line-removed"> 437 #endif</span>
 438   Handle h_obj(thread, obj);
<span class="line-modified"> 439   if (UseBiasedLocking) {</span>
<span class="line-modified"> 440     // Retry fast entry if bias is revoked to avoid unnecessary inflation</span>
<span class="line-removed"> 441     ObjectSynchronizer::fast_enter(h_obj, lock, true, CHECK);</span>
<span class="line-removed"> 442   } else {</span>
<span class="line-removed"> 443     if (JVMCIUseFastLocking) {</span>
<span class="line-removed"> 444       // When using fast locking, the compiled code has already tried the fast case</span>
<span class="line-removed"> 445       ObjectSynchronizer::slow_enter(h_obj, lock, THREAD);</span>
<span class="line-removed"> 446     } else {</span>
<span class="line-removed"> 447       ObjectSynchronizer::fast_enter(h_obj, lock, false, THREAD);</span>
<span class="line-removed"> 448     }</span>
<span class="line-removed"> 449   }</span>
 450   TRACE_jvmci_3(&quot;%s: exiting locking slow with obj=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj));
 451 JRT_END
 452 
 453 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 454   assert(thread == JavaThread::current(), &quot;threads must correspond&quot;);
 455   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
 456   // monitorexit is non-blocking (leaf routine) =&gt; no exceptions can be thrown
 457   EXCEPTION_MARK;
 458 
<span class="line-modified"> 459 #ifdef DEBUG</span>
 460   if (!oopDesc::is_oop(obj)) {
 461     ResetNoHandleMark rhm;
 462     nmethod* method = thread-&gt;last_frame().cb()-&gt;as_nmethod_or_null();
 463     if (method != NULL) {
 464       tty-&gt;print_cr(&quot;ERROR in monitorexit in method %s wrong obj &quot; INTPTR_FORMAT, method-&gt;name(), p2i(obj));
 465     }
 466     thread-&gt;print_stack_on(tty);
 467     assert(false, &quot;invalid lock object pointer dected&quot;);
 468   }
 469 #endif
 470 
<span class="line-modified"> 471   if (JVMCIUseFastLocking) {</span>
<span class="line-removed"> 472     // When using fast locking, the compiled code has already tried the fast case</span>
<span class="line-removed"> 473     ObjectSynchronizer::slow_exit(obj, lock, THREAD);</span>
<span class="line-removed"> 474   } else {</span>
<span class="line-removed"> 475     ObjectSynchronizer::fast_exit(obj, lock, THREAD);</span>
<span class="line-removed"> 476   }</span>
 477   IF_TRACE_jvmci_3 {
 478     char type[O_BUFLEN];
 479     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
<span class="line-modified"> 480     TRACE_jvmci_3(&quot;%s: exited locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, p2i(obj-&gt;mark()), p2i(lock));</span>
 481     tty-&gt;flush();
 482   }
 483 JRT_END
 484 
 485 // Object.notify() fast path, caller does slow path
 486 JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))
 487 
 488   // Very few notify/notifyAll operations find any threads on the waitset, so
 489   // the dominant fast-path is to simply return.
 490   // Relatedly, it&#39;s critical that notify/notifyAll be fast in order to
 491   // reduce lock hold times.
 492   if (!SafepointSynchronize::is_synchronizing()) {
 493     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 494       return true;
 495     }
 496   }
 497   return false; // caller must perform slow path
 498 
 499 JRT_END
 500 
 501 // Object.notifyAll() fast path, caller does slow path
 502 JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))
 503 
 504   if (!SafepointSynchronize::is_synchronizing() ) {
 505     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
 506       return true;
 507     }
 508   }
 509   return false; // caller must perform slow path
 510 
 511 JRT_END
 512 
<span class="line-modified"> 513 JRT_ENTRY(void, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))</span>
<span class="line-modified"> 514   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);</span>

 515   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);


 516 JRT_END
 517 
<span class="line-modified"> 518 JRT_ENTRY(void, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))</span>

 519   ResourceMark rm(thread);
<span class="line-modified"> 520   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);</span>
 521   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());


 522 JRT_END
 523 
<span class="line-modified"> 524 JRT_ENTRY(void, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))</span>

 525   ResourceMark rm(thread);
 526   const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
<span class="line-modified"> 527   TempNewSymbol symbol = SymbolTable::new_symbol(exception, CHECK);</span>
 528   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);


 529 JRT_END
 530 
 531 JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
 532   ttyLocker ttyl;
 533 
 534   if (obj == NULL) {
 535     tty-&gt;print(&quot;NULL&quot;);
 536   } else if (oopDesc::is_oop_or_null(obj, true) &amp;&amp; (!as_string || !java_lang_String::is_instance(obj))) {
 537     if (oopDesc::is_oop_or_null(obj, true)) {
 538       char buf[O_BUFLEN];
 539       tty-&gt;print(&quot;%s@&quot; INTPTR_FORMAT, obj-&gt;klass()-&gt;name()-&gt;as_C_string(buf, O_BUFLEN), p2i(obj));
 540     } else {
 541       tty-&gt;print(INTPTR_FORMAT, p2i(obj));
 542     }
 543   } else {
 544     ResourceMark rm;
 545     assert(obj != NULL &amp;&amp; java_lang_String::is_instance(obj), &quot;must be&quot;);
 546     char *buf = java_lang_String::as_utf8_string(obj);
 547     tty-&gt;print_raw(buf);
 548   }
 549   if (newline) {
 550     tty-&gt;cr();
 551   }
 552 JRT_END
 553 
 554 #if INCLUDE_G1GC
 555 
 556 JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))
 557   G1ThreadLocalData::satb_mark_queue(thread).enqueue(obj);
 558 JRT_END
 559 
 560 JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))
 561   G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);
 562 JRT_END
 563 
 564 #endif // INCLUDE_G1GC
 565 
 566 JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
 567   bool ret = true;
<span class="line-modified"> 568   if(!Universe::heap()-&gt;is_in_closed_subset(parent)) {</span>
 569     tty-&gt;print_cr(&quot;Parent Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(parent));
 570     parent-&gt;print();
 571     ret=false;
 572   }
<span class="line-modified"> 573   if(!Universe::heap()-&gt;is_in_closed_subset(child)) {</span>
 574     tty-&gt;print_cr(&quot;Child Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(child));
 575     child-&gt;print();
 576     ret=false;
 577   }
 578   return (jint)ret;
 579 JRT_END
 580 
 581 JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* thread, jlong where, jlong format, jlong value))
 582   ResourceMark rm;
 583   const char *error_msg = where == 0L ? &quot;&lt;internal JVMCI error&gt;&quot; : (char*) (address) where;
 584   char *detail_msg = NULL;
 585   if (format != 0L) {
 586     const char* buf = (char*) (address) format;
 587     size_t detail_msg_length = strlen(buf) * 2;
 588     detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
 589     jio_snprintf(detail_msg, detail_msg_length, buf, value);
<span class="line-removed"> 590     report_vm_error(__FILE__, __LINE__, error_msg, &quot;%s&quot;, detail_msg);</span>
<span class="line-removed"> 591   } else {</span>
<span class="line-removed"> 592     report_vm_error(__FILE__, __LINE__, error_msg);</span>
 593   }

 594 JRT_END
 595 
 596 JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
 597   oop exception = thread-&gt;exception_oop();
 598   assert(exception != NULL, &quot;npe&quot;);
 599   thread-&gt;set_exception_oop(NULL);
 600   thread-&gt;set_exception_pc(0);
 601   return exception;
 602 JRT_END
 603 
 604 PRAGMA_DIAG_PUSH
 605 PRAGMA_FORMAT_NONLITERAL_IGNORED
 606 JRT_LEAF(void, JVMCIRuntime::log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3))
 607   ResourceMark rm;
 608   tty-&gt;print(format, v1, v2, v3);
 609 JRT_END
 610 PRAGMA_DIAG_POP
 611 
 612 static void decipher(jlong v, bool ignoreZero) {
 613   if (v != 0 || !ignoreZero) {
</pre>
<hr />
<pre>
 662   switch (typeChar) {
 663     case &#39;Z&#39;: tty-&gt;print(value == 0 ? &quot;false&quot; : &quot;true&quot;); break;
 664     case &#39;B&#39;: tty-&gt;print(&quot;%d&quot;, (jbyte) value); break;
 665     case &#39;C&#39;: tty-&gt;print(&quot;%c&quot;, (jchar) value); break;
 666     case &#39;S&#39;: tty-&gt;print(&quot;%d&quot;, (jshort) value); break;
 667     case &#39;I&#39;: tty-&gt;print(&quot;%d&quot;, (jint) value); break;
 668     case &#39;F&#39;: tty-&gt;print(&quot;%f&quot;, uu.f); break;
 669     case &#39;J&#39;: tty-&gt;print(JLONG_FORMAT, value); break;
 670     case &#39;D&#39;: tty-&gt;print(&quot;%lf&quot;, uu.d); break;
 671     default: assert(false, &quot;unknown typeChar&quot;); break;
 672   }
 673   if (newline) {
 674     tty-&gt;cr();
 675   }
 676 JRT_END
 677 
 678 JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
 679   return (jint) obj-&gt;identity_hash();
 680 JRT_END
 681 
<span class="line-modified"> 682 JRT_ENTRY(jboolean, JVMCIRuntime::thread_is_interrupted(JavaThread* thread, oopDesc* receiver, jboolean clear_interrupted))</span>
<span class="line-removed"> 683   Handle receiverHandle(thread, receiver);</span>
<span class="line-removed"> 684   // A nested ThreadsListHandle may require the Threads_lock which</span>
<span class="line-removed"> 685   // requires thread_in_vm which is why this method cannot be JRT_LEAF.</span>
<span class="line-removed"> 686   ThreadsListHandle tlh;</span>
<span class="line-removed"> 687 </span>
<span class="line-removed"> 688   JavaThread* receiverThread = java_lang_Thread::thread(receiverHandle());</span>
<span class="line-removed"> 689   if (receiverThread == NULL || (EnableThreadSMRExtraValidityChecks &amp;&amp; !tlh.includes(receiverThread))) {</span>
<span class="line-removed"> 690     // The other thread may exit during this process, which is ok so return false.</span>
<span class="line-removed"> 691     return JNI_FALSE;</span>
<span class="line-removed"> 692   } else {</span>
<span class="line-removed"> 693     return (jint) Thread::is_interrupted(receiverThread, clear_interrupted != 0);</span>
<span class="line-removed"> 694   }</span>
<span class="line-removed"> 695 JRT_END</span>
<span class="line-removed"> 696 </span>
<span class="line-removed"> 697 JRT_ENTRY(int, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))</span>
 698   deopt_caller();
<span class="line-modified"> 699   return value;</span>
 700 JRT_END
 701 
<span class="line-removed"> 702 void JVMCIRuntime::force_initialization(TRAPS) {</span>
<span class="line-removed"> 703   JVMCIRuntime::initialize_well_known_classes(CHECK);</span>
<span class="line-removed"> 704 </span>
<span class="line-removed"> 705   ResourceMark rm;</span>
<span class="line-removed"> 706   TempNewSymbol getCompiler = SymbolTable::new_symbol(&quot;getCompiler&quot;, CHECK);</span>
<span class="line-removed"> 707   TempNewSymbol sig = SymbolTable::new_symbol(&quot;()Ljdk/vm/ci/runtime/JVMCICompiler;&quot;, CHECK);</span>
<span class="line-removed"> 708   Handle jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(CHECK);</span>
<span class="line-removed"> 709   JavaValue result(T_OBJECT);</span>
<span class="line-removed"> 710   JavaCalls::call_virtual(&amp;result, jvmciRuntime, HotSpotJVMCIRuntime::klass(), getCompiler, sig, CHECK);</span>
<span class="line-removed"> 711 }</span>
 712 
 713 // private static JVMCIRuntime JVMCI.initializeRuntime()
<span class="line-modified"> 714 JVM_ENTRY(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))</span>

 715   if (!EnableJVMCI) {
<span class="line-modified"> 716     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVMCI is not enabled&quot;)</span>
 717   }
<span class="line-modified"> 718   JVMCIRuntime::initialize_HotSpotJVMCIRuntime(CHECK_NULL);</span>
<span class="line-modified"> 719   jobject ret = JVMCIRuntime::get_HotSpotJVMCIRuntime_jobject(CHECK_NULL);</span>
<span class="line-modified"> 720   return ret;</span>
 721 JVM_END
 722 
<span class="line-modified"> 723 Handle JVMCIRuntime::callStatic(const char* className, const char* methodName, const char* signature, JavaCallArguments* args, TRAPS) {</span>
<span class="line-modified"> 724   TempNewSymbol name = SymbolTable::new_symbol(className, CHECK_(Handle()));</span>
<span class="line-modified"> 725   Klass* klass = SystemDictionary::resolve_or_fail(name, true, CHECK_(Handle()));</span>
<span class="line-modified"> 726   TempNewSymbol runtime = SymbolTable::new_symbol(methodName, CHECK_(Handle()));</span>
<span class="line-modified"> 727   TempNewSymbol sig = SymbolTable::new_symbol(signature, CHECK_(Handle()));</span>
<span class="line-modified"> 728   JavaValue result(T_OBJECT);</span>
<span class="line-modified"> 729   if (args == NULL) {</span>
<span class="line-modified"> 730     JavaCalls::call_static(&amp;result, klass, runtime, sig, CHECK_(Handle()));</span>










 731   } else {
<span class="line-modified"> 732     JavaCalls::call_static(&amp;result, klass, runtime, sig, args, CHECK_(Handle()));</span>
 733   }
<span class="line-removed"> 734   return Handle(THREAD, (oop)result.get_jobject());</span>
 735 }
 736 
<span class="line-modified"> 737 Handle JVMCIRuntime::get_HotSpotJVMCIRuntime(TRAPS) {</span>
<span class="line-modified"> 738   initialize_JVMCI(CHECK_(Handle()));</span>
<span class="line-modified"> 739   return Handle(THREAD, JNIHandles::resolve_non_null(_HotSpotJVMCIRuntime_instance));</span>





 740 }
 741 
<span class="line-modified"> 742 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(TRAPS) {</span>
<span class="line-modified"> 743   guarantee(!_HotSpotJVMCIRuntime_initialized, &quot;cannot reinitialize HotSpotJVMCIRuntime&quot;);</span>
<span class="line-modified"> 744   JVMCIRuntime::initialize_well_known_classes(CHECK);</span>
<span class="line-modified"> 745   // This should only be called in the context of the JVMCI class being initialized</span>
<span class="line-modified"> 746   InstanceKlass* klass = SystemDictionary::JVMCI_klass();</span>
<span class="line-modified"> 747   guarantee(klass-&gt;is_being_initialized() &amp;&amp; klass-&gt;is_reentrant_initialization(THREAD),</span>
<span class="line-modified"> 748          &quot;HotSpotJVMCIRuntime initialization should only be triggered through JVMCI initialization&quot;);</span>
<span class="line-modified"> 749 </span>
<span class="line-modified"> 750   Handle result = callStatic(&quot;jdk/vm/ci/hotspot/HotSpotJVMCIRuntime&quot;,</span>
<span class="line-modified"> 751                              &quot;runtime&quot;,</span>
<span class="line-modified"> 752                              &quot;()Ljdk/vm/ci/hotspot/HotSpotJVMCIRuntime;&quot;, NULL, CHECK);</span>
<span class="line-modified"> 753   int adjustment = HotSpotJVMCIRuntime::compilationLevelAdjustment(result);</span>
<span class="line-modified"> 754   assert(adjustment &gt;= JVMCIRuntime::none &amp;&amp;</span>
<span class="line-modified"> 755          adjustment &lt;= JVMCIRuntime::by_full_signature,</span>
<span class="line-modified"> 756          &quot;compilation level adjustment out of bounds&quot;);</span>
<span class="line-modified"> 757   _comp_level_adjustment = (CompLevelAdjustment) adjustment;</span>
<span class="line-modified"> 758   _HotSpotJVMCIRuntime_initialized = true;</span>
<span class="line-modified"> 759   _HotSpotJVMCIRuntime_instance = JNIHandles::make_global(result);</span>
<span class="line-modified"> 760 }</span>
<span class="line-modified"> 761 </span>
<span class="line-modified"> 762 void JVMCIRuntime::initialize_JVMCI(TRAPS) {</span>
<span class="line-modified"> 763   if (JNIHandles::resolve(_HotSpotJVMCIRuntime_instance) == NULL) {</span>
<span class="line-modified"> 764     callStatic(&quot;jdk/vm/ci/runtime/JVMCI&quot;,</span>
<span class="line-modified"> 765                &quot;getRuntime&quot;,</span>
<span class="line-modified"> 766                &quot;()Ljdk/vm/ci/runtime/JVMCIRuntime;&quot;, NULL, CHECK);</span>
<span class="line-modified"> 767   }</span>
<span class="line-modified"> 768   assert(_HotSpotJVMCIRuntime_initialized == true, &quot;what?&quot;);</span>
<span class="line-modified"> 769 }</span>
<span class="line-modified"> 770 </span>
<span class="line-removed"> 771 bool JVMCIRuntime::can_initialize_JVMCI() {</span>
<span class="line-removed"> 772   // Initializing JVMCI requires the module system to be initialized past phase 3.</span>
<span class="line-removed"> 773   // The JVMCI API itself isn&#39;t available until phase 2 and ServiceLoader (which</span>
<span class="line-removed"> 774   // JVMCI initialization requires) isn&#39;t usable until after phase 3. Testing</span>
<span class="line-removed"> 775   // whether the system loader is initialized satisfies all these invariants.</span>
<span class="line-removed"> 776   if (SystemDictionary::java_system_loader() == NULL) {</span>
<span class="line-removed"> 777     return false;</span>
<span class="line-removed"> 778   }</span>
<span class="line-removed"> 779   assert(Universe::is_module_initialized(), &quot;must be&quot;);</span>
<span class="line-removed"> 780   return true;</span>
 781 }
 782 
<span class="line-modified"> 783 void JVMCIRuntime::initialize_well_known_classes(TRAPS) {</span>
<span class="line-modified"> 784   if (JVMCIRuntime::_well_known_classes_initialized == false) {</span>
<span class="line-modified"> 785     guarantee(can_initialize_JVMCI(), &quot;VM is not yet sufficiently booted to initialize JVMCI&quot;);</span>
<span class="line-modified"> 786     SystemDictionary::WKID scan = SystemDictionary::FIRST_JVMCI_WKID;</span>
<span class="line-modified"> 787     SystemDictionary::resolve_wk_klasses_through(SystemDictionary::LAST_JVMCI_WKID, scan, CHECK);</span>
<span class="line-modified"> 788     JVMCIJavaClasses::compute_offsets(CHECK);</span>
<span class="line-modified"> 789     JVMCIRuntime::_well_known_classes_initialized = true;</span>

















 790   }
 791 }
 792 
<span class="line-modified"> 793 void JVMCIRuntime::metadata_do(void f(Metadata*)) {</span>
<span class="line-modified"> 794   // For simplicity, the existence of HotSpotJVMCIMetaAccessContext in</span>
<span class="line-modified"> 795   // the SystemDictionary well known classes should ensure the other</span>
<span class="line-modified"> 796   // classes have already been loaded, so make sure their order in the</span>
<span class="line-modified"> 797   // table enforces that.</span>
<span class="line-modified"> 798   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotResolvedJavaMethodImpl) &lt;</span>
<span class="line-modified"> 799          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), &quot;must be loaded earlier&quot;);</span>
<span class="line-modified"> 800   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotConstantPool) &lt;</span>
<span class="line-removed"> 801          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), &quot;must be loaded earlier&quot;);</span>
<span class="line-removed"> 802   assert(SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotResolvedObjectTypeImpl) &lt;</span>
<span class="line-removed"> 803          SystemDictionary::WK_KLASS_ENUM_NAME(jdk_vm_ci_hotspot_HotSpotJVMCIMetaAccessContext), &quot;must be loaded earlier&quot;);</span>
 804 
<span class="line-modified"> 805   if (HotSpotJVMCIMetaAccessContext::klass() == NULL ||</span>
<span class="line-modified"> 806       !HotSpotJVMCIMetaAccessContext::klass()-&gt;is_linked()) {</span>
<span class="line-modified"> 807     // Nothing could be registered yet</span>







 808     return;
 809   }
 810 
<span class="line-modified"> 811   // WeakReference&lt;HotSpotJVMCIMetaAccessContext&gt;[]</span>
<span class="line-modified"> 812   objArrayOop allContexts = HotSpotJVMCIMetaAccessContext::allContexts();</span>
<span class="line-modified"> 813   if (allContexts == NULL) {</span>
 814     return;
 815   }
 816 
<span class="line-modified"> 817   // These must be loaded at this point but the linking state doesn&#39;t matter.</span>
<span class="line-modified"> 818   assert(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass() != NULL, &quot;must be loaded&quot;);</span>
<span class="line-modified"> 819   assert(SystemDictionary::HotSpotConstantPool_klass() != NULL, &quot;must be loaded&quot;);</span>
<span class="line-modified"> 820   assert(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass() != NULL, &quot;must be loaded&quot;);</span>
<span class="line-modified"> 821 </span>
<span class="line-modified"> 822   for (int i = 0; i &lt; allContexts-&gt;length(); i++) {</span>
<span class="line-modified"> 823     oop ref = allContexts-&gt;obj_at(i);</span>
<span class="line-modified"> 824     if (ref != NULL) {</span>
<span class="line-modified"> 825       oop referent = java_lang_ref_Reference::referent(ref);</span>
<span class="line-modified"> 826       if (referent != NULL) {</span>
<span class="line-modified"> 827         // Chunked Object[] with last element pointing to next chunk</span>
<span class="line-modified"> 828         objArrayOop metadataRoots = HotSpotJVMCIMetaAccessContext::metadataRoots(referent);</span>
<span class="line-modified"> 829         while (metadataRoots != NULL) {</span>
<span class="line-modified"> 830           for (int typeIndex = 0; typeIndex &lt; metadataRoots-&gt;length() - 1; typeIndex++) {</span>
<span class="line-modified"> 831             oop reference = metadataRoots-&gt;obj_at(typeIndex);</span>
<span class="line-modified"> 832             if (reference == NULL) {</span>
<span class="line-modified"> 833               continue;</span>
<span class="line-modified"> 834             }</span>
<span class="line-modified"> 835             oop metadataRoot = java_lang_ref_Reference::referent(reference);</span>
<span class="line-modified"> 836             if (metadataRoot == NULL) {</span>
<span class="line-modified"> 837               continue;</span>
<span class="line-modified"> 838             }</span>
<span class="line-modified"> 839             if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {</span>
<span class="line-modified"> 840               Method* method = CompilerToVM::asMethod(metadataRoot);</span>
<span class="line-removed"> 841               f(method);</span>
<span class="line-removed"> 842             } else if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {</span>
<span class="line-removed"> 843               ConstantPool* constantPool = CompilerToVM::asConstantPool(metadataRoot);</span>
<span class="line-removed"> 844               f(constantPool);</span>
<span class="line-removed"> 845             } else if (metadataRoot-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {</span>
<span class="line-removed"> 846               Klass* klass = CompilerToVM::asKlass(metadataRoot);</span>
<span class="line-removed"> 847               f(klass);</span>
<span class="line-removed"> 848             } else {</span>
<span class="line-removed"> 849               metadataRoot-&gt;print();</span>
<span class="line-removed"> 850               ShouldNotReachHere();</span>
<span class="line-removed"> 851             }</span>
<span class="line-removed"> 852           }</span>
<span class="line-removed"> 853           metadataRoots = (objArrayOop)metadataRoots-&gt;obj_at(metadataRoots-&gt;length() - 1);</span>
<span class="line-removed"> 854           assert(metadataRoots == NULL || metadataRoots-&gt;is_objArray(), &quot;wrong type&quot;);</span>
<span class="line-removed"> 855         }</span>
 856       }
 857     }













 858   }




 859 }
 860 
<span class="line-modified"> 861 // private static void CompilerToVM.registerNatives()</span>
<span class="line-modified"> 862 JVM_ENTRY(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))</span>
<span class="line-modified"> 863   if (!EnableJVMCI) {</span>
<span class="line-modified"> 864     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;JVMCI is not enabled&quot;);</span>


















 865   }

 866 
<span class="line-modified"> 867 #ifdef _LP64</span>
<span class="line-modified"> 868 #ifndef SPARC</span>
<span class="line-modified"> 869   uintptr_t heap_end = (uintptr_t) Universe::heap()-&gt;reserved_region().end();</span>
<span class="line-modified"> 870   uintptr_t allocation_end = heap_end + ((uintptr_t)16) * 1024 * 1024 * 1024;</span>
<span class="line-modified"> 871   guarantee(heap_end &lt; allocation_end, &quot;heap end too close to end of address space (might lead to erroneous TLAB allocations)&quot;);</span>
<span class="line-modified"> 872 #endif // !SPARC</span>
<span class="line-modified"> 873 #else</span>
<span class="line-modified"> 874   fatal(&quot;check TLAB allocation code for address space conflicts&quot;);</span>
<span class="line-modified"> 875 #endif // _LP64</span>



 876 
<span class="line-modified"> 877   JVMCIRuntime::initialize_well_known_classes(CHECK);</span>









 878 
 879   {


 880     ThreadToNativeFromVM trans(thread);
<span class="line-modified"> 881     env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count());</span>
















 882   }
 883 JVM_END
 884 
<span class="line-modified"> 885 void JVMCIRuntime::shutdown(TRAPS) {</span>
<span class="line-modified"> 886   if (_HotSpotJVMCIRuntime_instance != NULL) {</span>

 887     _shutdown_called = true;
<span class="line-modified"> 888     HandleMark hm(THREAD);</span>
<span class="line-modified"> 889     Handle receiver = get_HotSpotJVMCIRuntime(CHECK);</span>
<span class="line-modified"> 890     JavaValue result(T_VOID);</span>
<span class="line-modified"> 891     JavaCallArguments args;</span>
<span class="line-modified"> 892     args.push_oop(receiver);</span>
<span class="line-modified"> 893     JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::shutdown_method_name(), vmSymbols::void_method_signature(), &amp;args, CHECK);</span>
<span class="line-modified"> 894   }</span>
<span class="line-modified"> 895 }</span>
<span class="line-modified"> 896 </span>
<span class="line-modified"> 897 CompLevel JVMCIRuntime::adjust_comp_level_inner(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread) {</span>
<span class="line-modified"> 898   JVMCICompiler* compiler = JVMCICompiler::instance(false, thread);</span>
<span class="line-modified"> 899   if (compiler != NULL &amp;&amp; compiler-&gt;is_bootstrapping()) {</span>
<span class="line-modified"> 900     return level;</span>
<span class="line-modified"> 901   }</span>
<span class="line-modified"> 902   if (!is_HotSpotJVMCIRuntime_initialized() || _comp_level_adjustment == JVMCIRuntime::none) {</span>
<span class="line-modified"> 903     // JVMCI cannot participate in compilation scheduling until</span>
<span class="line-modified"> 904     // JVMCI is initialized and indicates it wants to participate.</span>
<span class="line-modified"> 905     return level;</span>
<span class="line-modified"> 906   }</span>
<span class="line-modified"> 907 </span>
<span class="line-modified"> 908 #define CHECK_RETURN THREAD); \</span>
<span class="line-modified"> 909   if (HAS_PENDING_EXCEPTION) { \</span>
<span class="line-modified"> 910     Handle exception(THREAD, PENDING_EXCEPTION); \</span>
<span class="line-modified"> 911     CLEAR_PENDING_EXCEPTION; \</span>
<span class="line-modified"> 912   \</span>
<span class="line-modified"> 913     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) { \</span>
<span class="line-modified"> 914       /* In the special case of ThreadDeath, we need to reset the */ \</span>
<span class="line-modified"> 915       /* pending async exception so that it is propagated.        */ \</span>
<span class="line-modified"> 916       thread-&gt;set_pending_async_exception(exception()); \</span>
<span class="line-modified"> 917       return level; \</span>
<span class="line-modified"> 918     } \</span>
<span class="line-modified"> 919     tty-&gt;print(&quot;Uncaught exception while adjusting compilation level: &quot;); \</span>
<span class="line-modified"> 920     java_lang_Throwable::print(exception(), tty); \</span>
<span class="line-modified"> 921     tty-&gt;cr(); \</span>
<span class="line-modified"> 922     java_lang_Throwable::print_stack_trace(exception, tty); \</span>
<span class="line-modified"> 923     if (HAS_PENDING_EXCEPTION) { \</span>
<span class="line-modified"> 924       CLEAR_PENDING_EXCEPTION; \</span>
<span class="line-modified"> 925     } \</span>
<span class="line-modified"> 926     return level; \</span>
<span class="line-modified"> 927   } \</span>
<span class="line-modified"> 928   (void)(0</span>
<span class="line-modified"> 929 </span>
<span class="line-modified"> 930 </span>
<span class="line-modified"> 931   Thread* THREAD = thread;</span>
<span class="line-modified"> 932   HandleMark hm;</span>
<span class="line-modified"> 933   Handle receiver = JVMCIRuntime::get_HotSpotJVMCIRuntime(CHECK_RETURN);</span>
<span class="line-removed"> 934   Handle name;</span>
<span class="line-removed"> 935   Handle sig;</span>
<span class="line-removed"> 936   if (_comp_level_adjustment == JVMCIRuntime::by_full_signature) {</span>
<span class="line-removed"> 937     name = java_lang_String::create_from_symbol(method-&gt;name(), CHECK_RETURN);</span>
<span class="line-removed"> 938     sig = java_lang_String::create_from_symbol(method-&gt;signature(), CHECK_RETURN);</span>
 939   } else {
<span class="line-modified"> 940     name = Handle();</span>
<span class="line-modified"> 941     sig = Handle();</span>
 942   }
 943 
<span class="line-modified"> 944   JavaValue result(T_INT);</span>
<span class="line-modified"> 945   JavaCallArguments args;</span>
<span class="line-modified"> 946   args.push_oop(receiver);</span>
<span class="line-modified"> 947   args.push_oop(Handle(THREAD, method-&gt;method_holder()-&gt;java_mirror()));</span>
<span class="line-modified"> 948   args.push_oop(name);</span>
<span class="line-modified"> 949   args.push_oop(sig);</span>
<span class="line-modified"> 950   args.push_int(is_osr);</span>
<span class="line-modified"> 951   args.push_int(level);</span>
<span class="line-modified"> 952   JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::adjustCompilationLevel_name(),</span>
<span class="line-modified"> 953                           vmSymbols::adjustCompilationLevel_signature(), &amp;args, CHECK_RETURN);</span>




 954 
<span class="line-modified"> 955   int comp_level = result.get_jint();</span>
<span class="line-modified"> 956   if (comp_level &lt; CompLevel_none || comp_level &gt; CompLevel_full_optimization) {</span>
<span class="line-modified"> 957     assert(false, &quot;compilation level out of bounds&quot;);</span>
<span class="line-removed"> 958     return level;</span>
 959   }
<span class="line-modified"> 960   return (CompLevel) comp_level;</span>
<span class="line-modified"> 961 #undef CHECK_RETURN</span>




 962 }
 963 
<span class="line-modified"> 964 void JVMCIRuntime::bootstrap_finished(TRAPS) {</span>
<span class="line-modified"> 965   HandleMark hm(THREAD);</span>
<span class="line-modified"> 966   Handle receiver = get_HotSpotJVMCIRuntime(CHECK);</span>
<span class="line-modified"> 967   JavaValue result(T_VOID);</span>
<span class="line-modified"> 968   JavaCallArguments args;</span>
<span class="line-modified"> 969   args.push_oop(receiver);</span>
<span class="line-modified"> 970   JavaCalls::call_special(&amp;result, receiver-&gt;klass(), vmSymbols::bootstrapFinished_method_name(), vmSymbols::void_method_signature(), &amp;args, CHECK);</span>



































































































































































































































































































































































































































































































































































































 971 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
<span class="line-modified">  25 #include &quot;classfile/symbolTable.hpp&quot;</span>




  26 #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-modified">  27 #include &quot;jvmci/jniAccessMark.inline.hpp&quot;</span>

  28 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
<span class="line-modified">  29 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>


  30 #include &quot;logging/log.hpp&quot;

  31 #include &quot;memory/oopFactory.hpp&quot;
<span class="line-modified">  32 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">  33 #include &quot;oops/constantPool.inline.hpp&quot;</span>
<span class="line-added">  34 #include &quot;oops/method.inline.hpp&quot;</span>
<span class="line-added">  35 #include &quot;oops/objArrayKlass.hpp&quot;</span>
  36 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified">  37 #include &quot;runtime/atomic.hpp&quot;</span>
  38 #include &quot;runtime/biasedLocking.hpp&quot;
<span class="line-added">  39 #include &quot;runtime/deoptimization.hpp&quot;</span>
<span class="line-added">  40 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
  41 #include &quot;runtime/frame.inline.hpp&quot;




  42 #include &quot;runtime/sharedRuntime.hpp&quot;




  43 #if INCLUDE_G1GC
  44 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  45 #endif // INCLUDE_G1GC
  46 































  47 // Simple helper to see if the caller of a runtime stub which
  48 // entered the VM has been deoptimized
  49 
  50 static bool caller_is_deopted() {
  51   JavaThread* thread = JavaThread::current();
  52   RegisterMap reg_map(thread, false);
  53   frame runtime_frame = thread-&gt;last_frame();
  54   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  55   assert(caller_frame.is_compiled_frame(), &quot;must be compiled&quot;);
  56   return caller_frame.is_deoptimized_frame();
  57 }
  58 
  59 // Stress deoptimization
  60 static void deopt_caller() {
  61   if ( !caller_is_deopted()) {
  62     JavaThread* thread = JavaThread::current();
  63     RegisterMap reg_map(thread, false);
  64     frame runtime_frame = thread-&gt;last_frame();
  65     frame caller_frame = runtime_frame.sender(&amp;reg_map);
  66     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
</pre>
<hr />
<pre>
  93       _thread-&gt;set_in_retryable_allocation(false);
  94       JavaThread* THREAD = _thread;
  95       if (HAS_PENDING_EXCEPTION) {
  96         oop ex = PENDING_EXCEPTION;
  97         CLEAR_PENDING_EXCEPTION;
  98         oop retry_oome = Universe::out_of_memory_error_retry();
  99         if (ex-&gt;is_a(retry_oome-&gt;klass()) &amp;&amp; retry_oome != ex) {
 100           ResourceMark rm;
 101           fatal(&quot;Unexpected exception in scope of retryable allocation: &quot; INTPTR_FORMAT &quot; of type %s&quot;, p2i(ex), ex-&gt;klass()-&gt;external_name());
 102         }
 103         _thread-&gt;set_vm_result(NULL);
 104       }
 105     }
 106   }
 107 };
 108 
 109 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))
 110   JRT_BLOCK;
 111   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 112   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
<span class="line-modified"> 113   InstanceKlass* h = InstanceKlass::cast(klass);</span>
 114   {
 115     RetryableAllocationMark ram(thread, null_on_fail);
<span class="line-modified"> 116     h-&gt;check_valid_for_instantiation(true, CHECK);</span>
 117     oop obj;
 118     if (null_on_fail) {
<span class="line-modified"> 119       if (!h-&gt;is_initialized()) {</span>
 120         // Cannot re-execute class initialization without side effects
 121         // so return without attempting the initialization
 122         return;
 123       }
 124     } else {
 125       // make sure klass is initialized
<span class="line-modified"> 126       h-&gt;initialize(CHECK);</span>
 127     }
 128     // allocate instance and return via TLS
<span class="line-modified"> 129     obj = h-&gt;allocate_instance(CHECK);</span>
 130     thread-&gt;set_vm_result(obj);
 131   }
 132   JRT_BLOCK_END;
 133   SharedRuntime::on_slowpath_allocation_exit(thread);
 134 JRT_END
 135 
 136 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* thread, Klass* array_klass, jint length, bool null_on_fail))
 137   JRT_BLOCK;
 138   // Note: no handle for klass needed since they are not used
 139   //       anymore after new_objArray() and no GC can happen before.
 140   //       (This may have to change if this code changes!)
 141   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);
 142   oop obj;
 143   if (array_klass-&gt;is_typeArray_klass()) {
 144     BasicType elt_type = TypeArrayKlass::cast(array_klass)-&gt;element_type();
 145     RetryableAllocationMark ram(thread, null_on_fail);
 146     obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 147   } else {
 148     Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
 149     Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();
</pre>
<hr />
<pre>
 231 // been deoptimized. If that is the case we return the deopt blob
 232 // unpack_with_exception entry instead. This makes life for the exception blob easier
 233 // because making that same check and diverting is painful from assembly language.
 234 JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, CompiledMethod*&amp; cm))
 235   // Reset method handle flag.
 236   thread-&gt;set_is_method_handle_return(false);
 237 
 238   Handle exception(thread, ex);
 239   cm = CodeCache::find_compiled(pc);
 240   assert(cm != NULL, &quot;this is not a compiled method&quot;);
 241   // Adjust the pc as needed/
 242   if (cm-&gt;is_deopt_pc(pc)) {
 243     RegisterMap map(thread, false);
 244     frame exception_frame = thread-&gt;last_frame().sender(&amp;map);
 245     // if the frame isn&#39;t deopted then pc must not correspond to the caller of last_frame
 246     assert(exception_frame.is_deoptimized_frame(), &quot;must be deopted&quot;);
 247     pc = exception_frame.pc();
 248   }
 249 #ifdef ASSERT
 250   assert(exception.not_null(), &quot;NULL exceptions should be handled by throw_exception&quot;);
<span class="line-added"> 251   assert(oopDesc::is_oop(exception()), &quot;just checking&quot;);</span>
 252   // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
 253   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
 254     if (ExitVMOnVerifyError) vm_exit(-1);
 255     ShouldNotReachHere();
 256   }
 257 #endif
 258 
 259   // Check the stack guard pages and reenable them if necessary and there is
 260   // enough space on the stack to do so.  Use fast exceptions only if the guard
 261   // pages are enabled.
 262   bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 263   if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 264 
 265   if (JvmtiExport::can_post_on_exceptions()) {
 266     // To ensure correct notification of exception catches and throws
 267     // we have to deoptimize here.  If we attempted to notify the
 268     // catches and throws during this exception lookup it&#39;s possible
 269     // we could deoptimize on the way out of the VM and end back in
 270     // the interpreter at the throw site.  This would result in double
 271     // notifications since the interpreter would also notify about
</pre>
<hr />
<pre>
 295   }
 296 
 297   // If the stack guard pages are enabled, check whether there is a handler in
 298   // the current method.  Otherwise (guard pages disabled), force an unwind and
 299   // skip the exception cache update (i.e., just leave continuation==NULL).
 300   address continuation = NULL;
 301   if (guard_pages_enabled) {
 302 
 303     // New exception handling mechanism can support inlined methods
 304     // with exception handlers since the mappings are from PC to PC
 305 
 306     // debugging support
 307     // tracing
 308     if (log_is_enabled(Info, exceptions)) {
 309       ResourceMark rm;
 310       stringStream tempst;
 311       assert(cm-&gt;method() != NULL, &quot;Unexpected null method()&quot;);
 312       tempst.print(&quot;compiled method &lt;%s&gt;\n&quot;
 313                    &quot; at PC&quot; INTPTR_FORMAT &quot; for thread &quot; INTPTR_FORMAT,
 314                    cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
<span class="line-modified"> 315       Exceptions::log_exception(exception, tempst.as_string());</span>
 316     }
 317     // for AbortVMOnException flag
 318     NOT_PRODUCT(Exceptions::debug_check_abort(exception));
 319 
 320     // Clear out the exception oop and pc since looking up an
 321     // exception handler can cause class loading, which might throw an
 322     // exception and those fields are expected to be clear during
 323     // normal bytecode execution.
 324     thread-&gt;clear_exception_oop_and_pc();
 325 
 326     bool recursive_exception = false;
 327     continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
 328     // If an exception was thrown during exception dispatch, the exception oop may have changed
 329     thread-&gt;set_exception_oop(exception());
 330     thread-&gt;set_exception_pc(pc);
 331 
<span class="line-modified"> 332     // The exception cache is used only for non-implicit exceptions</span>
<span class="line-modified"> 333     // Update the exception cache only when another exception did</span>
<span class="line-modified"> 334     // occur during the computation of the compiled exception handler</span>
<span class="line-modified"> 335     // (e.g., when loading the class of the catch type).</span>
<span class="line-added"> 336     // Checking for exception oop equality is not</span>
 337     // sufficient because some exceptions are pre-allocated and reused.
 338     if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
 339       cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
 340     }
 341   }
 342 
 343   // Set flag if return address is a method handle call site.
 344   thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 345 
 346   if (log_is_enabled(Info, exceptions)) {
 347     ResourceMark rm;
 348     log_info(exceptions)(&quot;Thread &quot; PTR_FORMAT &quot; continuing at PC &quot; PTR_FORMAT
 349                          &quot; for exception thrown at PC &quot; PTR_FORMAT,
 350                          p2i(thread), p2i(continuation), p2i(pc));
 351   }
 352 
 353   return continuation;
 354 JRT_END
 355 
 356 // Enter this method from compiled code only if there is a Java exception handler
</pre>
<hr />
<pre>
 369     // Enter VM mode by calling the helper
 370     ResetNoHandleMark rnhm;
 371     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
 372   }
 373   // Back in JAVA, use no oops DON&#39;T safepoint
 374 
 375   // Now check to see if the compiled method we were called from is now deoptimized.
 376   // If so we must return to the deopt blob and deoptimize the nmethod
 377   if (cm != NULL &amp;&amp; caller_is_deopted()) {
 378     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 379   }
 380 
 381   assert(continuation != NULL, &quot;no handler found&quot;);
 382   return continuation;
 383 }
 384 
 385 JRT_ENTRY_NO_ASYNC(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 386   IF_TRACE_jvmci_3 {
 387     char type[O_BUFLEN];
 388     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
<span class="line-modified"> 389     markWord mark = obj-&gt;mark();</span>
<span class="line-modified"> 390     TRACE_jvmci_3(&quot;%s: entered locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, mark.value(), p2i(lock));</span>
 391     tty-&gt;flush();
 392   }

 393   if (PrintBiasedLockingStatistics) {
 394     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
 395   }

 396   Handle h_obj(thread, obj);
<span class="line-modified"> 397   assert(oopDesc::is_oop(h_obj()), &quot;must be NULL or an object&quot;);</span>
<span class="line-modified"> 398   ObjectSynchronizer::enter(h_obj, lock, THREAD);</span>









 399   TRACE_jvmci_3(&quot;%s: exiting locking slow with obj=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj));
 400 JRT_END
 401 
 402 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 403   assert(thread == JavaThread::current(), &quot;threads must correspond&quot;);
 404   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
 405   // monitorexit is non-blocking (leaf routine) =&gt; no exceptions can be thrown
 406   EXCEPTION_MARK;
 407 
<span class="line-modified"> 408 #ifdef ASSERT</span>
 409   if (!oopDesc::is_oop(obj)) {
 410     ResetNoHandleMark rhm;
 411     nmethod* method = thread-&gt;last_frame().cb()-&gt;as_nmethod_or_null();
 412     if (method != NULL) {
 413       tty-&gt;print_cr(&quot;ERROR in monitorexit in method %s wrong obj &quot; INTPTR_FORMAT, method-&gt;name(), p2i(obj));
 414     }
 415     thread-&gt;print_stack_on(tty);
 416     assert(false, &quot;invalid lock object pointer dected&quot;);
 417   }
 418 #endif
 419 
<span class="line-modified"> 420   ObjectSynchronizer::exit(obj, lock, THREAD);</span>





 421   IF_TRACE_jvmci_3 {
 422     char type[O_BUFLEN];
 423     obj-&gt;klass()-&gt;name()-&gt;as_C_string(type, O_BUFLEN);
<span class="line-modified"> 424     TRACE_jvmci_3(&quot;%s: exited locking slow case with obj=&quot; INTPTR_FORMAT &quot;, type=%s, mark=&quot; INTPTR_FORMAT &quot;, lock=&quot; INTPTR_FORMAT, thread-&gt;name(), p2i(obj), type, obj-&gt;mark().value(), p2i(lock));</span>
 425     tty-&gt;flush();
 426   }
 427 JRT_END
 428 
 429 // Object.notify() fast path, caller does slow path
 430 JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))
 431 
 432   // Very few notify/notifyAll operations find any threads on the waitset, so
 433   // the dominant fast-path is to simply return.
 434   // Relatedly, it&#39;s critical that notify/notifyAll be fast in order to
 435   // reduce lock hold times.
 436   if (!SafepointSynchronize::is_synchronizing()) {
 437     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 438       return true;
 439     }
 440   }
 441   return false; // caller must perform slow path
 442 
 443 JRT_END
 444 
 445 // Object.notifyAll() fast path, caller does slow path
 446 JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))
 447 
 448   if (!SafepointSynchronize::is_synchronizing() ) {
 449     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
 450       return true;
 451     }
 452   }
 453   return false; // caller must perform slow path
 454 
 455 JRT_END
 456 
<span class="line-modified"> 457 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))</span>
<span class="line-modified"> 458   JRT_BLOCK;</span>
<span class="line-added"> 459   TempNewSymbol symbol = SymbolTable::new_symbol(exception);</span>
 460   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
<span class="line-added"> 461   JRT_BLOCK_END;</span>
<span class="line-added"> 462   return caller_is_deopted();</span>
 463 JRT_END
 464 
<span class="line-modified"> 465 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))</span>
<span class="line-added"> 466   JRT_BLOCK;</span>
 467   ResourceMark rm(thread);
<span class="line-modified"> 468   TempNewSymbol symbol = SymbolTable::new_symbol(exception);</span>
 469   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());
<span class="line-added"> 470   JRT_BLOCK_END;</span>
<span class="line-added"> 471   return caller_is_deopted();</span>
 472 JRT_END
 473 
<span class="line-modified"> 474 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))</span>
<span class="line-added"> 475   JRT_BLOCK;</span>
 476   ResourceMark rm(thread);
 477   const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
<span class="line-modified"> 478   TempNewSymbol symbol = SymbolTable::new_symbol(exception);</span>
 479   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
<span class="line-added"> 480   JRT_BLOCK_END;</span>
<span class="line-added"> 481   return caller_is_deopted();</span>
 482 JRT_END
 483 
 484 JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
 485   ttyLocker ttyl;
 486 
 487   if (obj == NULL) {
 488     tty-&gt;print(&quot;NULL&quot;);
 489   } else if (oopDesc::is_oop_or_null(obj, true) &amp;&amp; (!as_string || !java_lang_String::is_instance(obj))) {
 490     if (oopDesc::is_oop_or_null(obj, true)) {
 491       char buf[O_BUFLEN];
 492       tty-&gt;print(&quot;%s@&quot; INTPTR_FORMAT, obj-&gt;klass()-&gt;name()-&gt;as_C_string(buf, O_BUFLEN), p2i(obj));
 493     } else {
 494       tty-&gt;print(INTPTR_FORMAT, p2i(obj));
 495     }
 496   } else {
 497     ResourceMark rm;
 498     assert(obj != NULL &amp;&amp; java_lang_String::is_instance(obj), &quot;must be&quot;);
 499     char *buf = java_lang_String::as_utf8_string(obj);
 500     tty-&gt;print_raw(buf);
 501   }
 502   if (newline) {
 503     tty-&gt;cr();
 504   }
 505 JRT_END
 506 
 507 #if INCLUDE_G1GC
 508 
 509 JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))
 510   G1ThreadLocalData::satb_mark_queue(thread).enqueue(obj);
 511 JRT_END
 512 
 513 JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))
 514   G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);
 515 JRT_END
 516 
 517 #endif // INCLUDE_G1GC
 518 
 519 JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
 520   bool ret = true;
<span class="line-modified"> 521   if(!Universe::heap()-&gt;is_in(parent)) {</span>
 522     tty-&gt;print_cr(&quot;Parent Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(parent));
 523     parent-&gt;print();
 524     ret=false;
 525   }
<span class="line-modified"> 526   if(!Universe::heap()-&gt;is_in(child)) {</span>
 527     tty-&gt;print_cr(&quot;Child Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(child));
 528     child-&gt;print();
 529     ret=false;
 530   }
 531   return (jint)ret;
 532 JRT_END
 533 
 534 JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* thread, jlong where, jlong format, jlong value))
 535   ResourceMark rm;
 536   const char *error_msg = where == 0L ? &quot;&lt;internal JVMCI error&gt;&quot; : (char*) (address) where;
 537   char *detail_msg = NULL;
 538   if (format != 0L) {
 539     const char* buf = (char*) (address) format;
 540     size_t detail_msg_length = strlen(buf) * 2;
 541     detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
 542     jio_snprintf(detail_msg, detail_msg_length, buf, value);



 543   }
<span class="line-added"> 544   report_vm_error(__FILE__, __LINE__, error_msg, &quot;%s&quot;, detail_msg);</span>
 545 JRT_END
 546 
 547 JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
 548   oop exception = thread-&gt;exception_oop();
 549   assert(exception != NULL, &quot;npe&quot;);
 550   thread-&gt;set_exception_oop(NULL);
 551   thread-&gt;set_exception_pc(0);
 552   return exception;
 553 JRT_END
 554 
 555 PRAGMA_DIAG_PUSH
 556 PRAGMA_FORMAT_NONLITERAL_IGNORED
 557 JRT_LEAF(void, JVMCIRuntime::log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3))
 558   ResourceMark rm;
 559   tty-&gt;print(format, v1, v2, v3);
 560 JRT_END
 561 PRAGMA_DIAG_POP
 562 
 563 static void decipher(jlong v, bool ignoreZero) {
 564   if (v != 0 || !ignoreZero) {
</pre>
<hr />
<pre>
 613   switch (typeChar) {
 614     case &#39;Z&#39;: tty-&gt;print(value == 0 ? &quot;false&quot; : &quot;true&quot;); break;
 615     case &#39;B&#39;: tty-&gt;print(&quot;%d&quot;, (jbyte) value); break;
 616     case &#39;C&#39;: tty-&gt;print(&quot;%c&quot;, (jchar) value); break;
 617     case &#39;S&#39;: tty-&gt;print(&quot;%d&quot;, (jshort) value); break;
 618     case &#39;I&#39;: tty-&gt;print(&quot;%d&quot;, (jint) value); break;
 619     case &#39;F&#39;: tty-&gt;print(&quot;%f&quot;, uu.f); break;
 620     case &#39;J&#39;: tty-&gt;print(JLONG_FORMAT, value); break;
 621     case &#39;D&#39;: tty-&gt;print(&quot;%lf&quot;, uu.d); break;
 622     default: assert(false, &quot;unknown typeChar&quot;); break;
 623   }
 624   if (newline) {
 625     tty-&gt;cr();
 626   }
 627 JRT_END
 628 
 629 JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
 630   return (jint) obj-&gt;identity_hash();
 631 JRT_END
 632 
<span class="line-modified"> 633 JRT_ENTRY(jint, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))</span>















 634   deopt_caller();
<span class="line-modified"> 635   return (jint) value;</span>
 636 JRT_END
 637 










 638 
 639 // private static JVMCIRuntime JVMCI.initializeRuntime()
<span class="line-modified"> 640 JVM_ENTRY_NO_ENV(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))</span>
<span class="line-added"> 641   JNI_JVMCIENV(thread, env);</span>
 642   if (!EnableJVMCI) {
<span class="line-modified"> 643     JVMCI_THROW_MSG_NULL(InternalError, &quot;JVMCI is not enabled&quot;);</span>
 644   }
<span class="line-modified"> 645   JVMCIENV-&gt;runtime()-&gt;initialize_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 646   JVMCIObject runtime = JVMCIENV-&gt;runtime()-&gt;get_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 647   return JVMCIENV-&gt;get_jobject(runtime);</span>
 648 JVM_END
 649 
<span class="line-modified"> 650 void JVMCIRuntime::call_getCompiler(TRAPS) {</span>
<span class="line-modified"> 651   THREAD_JVMCIENV(JavaThread::current());</span>
<span class="line-modified"> 652   JVMCIObject jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_CHECK);</span>
<span class="line-modified"> 653   initialize(JVMCIENV);</span>
<span class="line-modified"> 654   JVMCIENV-&gt;call_HotSpotJVMCIRuntime_getCompiler(jvmciRuntime, JVMCI_CHECK);</span>
<span class="line-modified"> 655 }</span>
<span class="line-modified"> 656 </span>
<span class="line-modified"> 657 void JVMCINMethodData::initialize(</span>
<span class="line-added"> 658   int nmethod_mirror_index,</span>
<span class="line-added"> 659   const char* name,</span>
<span class="line-added"> 660   FailedSpeculation** failed_speculations)</span>
<span class="line-added"> 661 {</span>
<span class="line-added"> 662   _failed_speculations = failed_speculations;</span>
<span class="line-added"> 663   _nmethod_mirror_index = nmethod_mirror_index;</span>
<span class="line-added"> 664   if (name != NULL) {</span>
<span class="line-added"> 665     _has_name = true;</span>
<span class="line-added"> 666     char* dest = (char*) this-&gt;name();</span>
<span class="line-added"> 667     strcpy(dest, name);</span>
 668   } else {
<span class="line-modified"> 669     _has_name = false;</span>
 670   }

 671 }
 672 
<span class="line-modified"> 673 void JVMCINMethodData::add_failed_speculation(nmethod* nm, jlong speculation) {</span>
<span class="line-modified"> 674   uint index = (speculation &gt;&gt; 32) &amp; 0xFFFFFFFF;</span>
<span class="line-modified"> 675   int length = (int) speculation;</span>
<span class="line-added"> 676   if (index + length &gt; (uint) nm-&gt;speculations_size()) {</span>
<span class="line-added"> 677     fatal(INTPTR_FORMAT &quot;[index: %d, length: %d] out of bounds wrt encoded speculations of length %u&quot;, speculation, index, length, nm-&gt;speculations_size());</span>
<span class="line-added"> 678   }</span>
<span class="line-added"> 679   address data = nm-&gt;speculations_begin() + index;</span>
<span class="line-added"> 680   FailedSpeculation::add_failed_speculation(nm, _failed_speculations, data, length);</span>
 681 }
 682 
<span class="line-modified"> 683 oop JVMCINMethodData::get_nmethod_mirror(nmethod* nm, bool phantom_ref) {</span>
<span class="line-modified"> 684   if (_nmethod_mirror_index == -1) {</span>
<span class="line-modified"> 685     return NULL;</span>
<span class="line-modified"> 686   }</span>
<span class="line-modified"> 687   if (phantom_ref) {</span>
<span class="line-modified"> 688     return nm-&gt;oop_at_phantom(_nmethod_mirror_index);</span>
<span class="line-modified"> 689   } else {</span>
<span class="line-modified"> 690     return nm-&gt;oop_at(_nmethod_mirror_index);</span>
<span class="line-modified"> 691   }</span>
<span class="line-modified"> 692 }</span>
<span class="line-modified"> 693 </span>
<span class="line-modified"> 694 void JVMCINMethodData::set_nmethod_mirror(nmethod* nm, oop new_mirror) {</span>
<span class="line-modified"> 695   assert(_nmethod_mirror_index != -1, &quot;cannot set JVMCI mirror for nmethod&quot;);</span>
<span class="line-modified"> 696   oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);</span>
<span class="line-modified"> 697   assert(new_mirror != NULL, &quot;use clear_nmethod_mirror to clear the mirror&quot;);</span>
<span class="line-modified"> 698   assert(*addr == NULL, &quot;cannot overwrite non-null mirror&quot;);</span>
<span class="line-modified"> 699 </span>
<span class="line-modified"> 700   *addr = new_mirror;</span>
<span class="line-modified"> 701 </span>
<span class="line-modified"> 702   // Since we&#39;ve patched some oops in the nmethod,</span>
<span class="line-modified"> 703   // (re)register it with the heap.</span>
<span class="line-modified"> 704   Universe::heap()-&gt;register_nmethod(nm);</span>
<span class="line-modified"> 705 }</span>
<span class="line-modified"> 706 </span>
<span class="line-modified"> 707 void JVMCINMethodData::clear_nmethod_mirror(nmethod* nm) {</span>
<span class="line-modified"> 708   if (_nmethod_mirror_index != -1) {</span>
<span class="line-modified"> 709     oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);</span>
<span class="line-modified"> 710     *addr = NULL;</span>
<span class="line-modified"> 711   }</span>










 712 }
 713 
<span class="line-modified"> 714 void JVMCINMethodData::invalidate_nmethod_mirror(nmethod* nm) {</span>
<span class="line-modified"> 715   oop nmethod_mirror = get_nmethod_mirror(nm, /* phantom_ref */ false);</span>
<span class="line-modified"> 716   if (nmethod_mirror == NULL) {</span>
<span class="line-modified"> 717     return;</span>
<span class="line-modified"> 718   }</span>
<span class="line-modified"> 719 </span>
<span class="line-modified"> 720   // Update the values in the mirror if it still refers to nm.</span>
<span class="line-added"> 721   // We cannot use JVMCIObject to wrap the mirror as this is called</span>
<span class="line-added"> 722   // during GC, forbidding the creation of JNIHandles.</span>
<span class="line-added"> 723   JVMCIEnv* jvmciEnv = NULL;</span>
<span class="line-added"> 724   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);</span>
<span class="line-added"> 725   if (nm == current) {</span>
<span class="line-added"> 726     if (!nm-&gt;is_alive()) {</span>
<span class="line-added"> 727       // Break the link from the mirror to nm such that</span>
<span class="line-added"> 728       // future invocations via the mirror will result in</span>
<span class="line-added"> 729       // an InvalidInstalledCodeException.</span>
<span class="line-added"> 730       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);</span>
<span class="line-added"> 731       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);</span>
<span class="line-added"> 732     } else if (nm-&gt;is_not_entrant()) {</span>
<span class="line-added"> 733       // Zero the entry point so any new invocation will fail but keep</span>
<span class="line-added"> 734       // the address link around that so that existing activations can</span>
<span class="line-added"> 735       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).</span>
<span class="line-added"> 736       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);</span>
<span class="line-added"> 737     }</span>
 738   }
 739 }
 740 
<span class="line-modified"> 741 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {</span>
<span class="line-modified"> 742   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
<span class="line-modified"> 743     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {</span>
<span class="line-modified"> 744       JVMCI_THROW_MSG(InternalError, &quot;JVMCI has already been enabled in the JVMCI shared library&quot;);</span>
<span class="line-modified"> 745     }</span>
<span class="line-modified"> 746   }</span>
<span class="line-modified"> 747 </span>
<span class="line-modified"> 748   initialize(JVMCIENV);</span>



 749 
<span class="line-modified"> 750   // This should only be called in the context of the JVMCI class being initialized</span>
<span class="line-modified"> 751   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);</span>
<span class="line-modified"> 752 </span>
<span class="line-added"> 753   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);</span>
<span class="line-added"> 754 }</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {</span>
<span class="line-added"> 757   assert(this != NULL, &quot;sanity&quot;);</span>
<span class="line-added"> 758   // Check first without JVMCI_lock</span>
<span class="line-added"> 759   if (_initialized) {</span>
 760     return;
 761   }
 762 
<span class="line-modified"> 763   MutexLocker locker(JVMCI_lock);</span>
<span class="line-modified"> 764   // Check again under JVMCI_lock</span>
<span class="line-modified"> 765   if (_initialized) {</span>
 766     return;
 767   }
 768 
<span class="line-modified"> 769   while (_being_initialized) {</span>
<span class="line-modified"> 770     JVMCI_lock-&gt;wait();</span>
<span class="line-modified"> 771     if (_initialized) {</span>
<span class="line-modified"> 772       return;</span>
<span class="line-modified"> 773     }</span>
<span class="line-modified"> 774   }</span>
<span class="line-modified"> 775 </span>
<span class="line-modified"> 776   _being_initialized = true;</span>
<span class="line-modified"> 777 </span>
<span class="line-modified"> 778   {</span>
<span class="line-modified"> 779     MutexUnlocker unlock(JVMCI_lock);</span>
<span class="line-modified"> 780 </span>
<span class="line-modified"> 781     HandleMark hm;</span>
<span class="line-modified"> 782     ResourceMark rm;</span>
<span class="line-modified"> 783     JavaThread* THREAD = JavaThread::current();</span>
<span class="line-modified"> 784     if (JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-modified"> 785       HotSpotJVMCI::compute_offsets(CHECK_EXIT);</span>
<span class="line-modified"> 786     } else {</span>
<span class="line-modified"> 787       JNIAccessMark jni(JVMCIENV);</span>
<span class="line-modified"> 788 </span>
<span class="line-modified"> 789       JNIJVMCI::initialize_ids(jni.env());</span>
<span class="line-modified"> 790       if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-modified"> 791         jni()-&gt;ExceptionDescribe();</span>
<span class="line-modified"> 792         fatal(&quot;JNI exception during init&quot;);</span>















 793       }
 794     }
<span class="line-added"> 795     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added"> 796     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added"> 797     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added"> 798     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added"> 799     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added"> 800     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added"> 801     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added"> 802     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added"> 803     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));</span>
<span class="line-added"> 804 </span>
<span class="line-added"> 805     if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-added"> 806       JVMCIENV-&gt;copy_saved_properties();</span>
<span class="line-added"> 807     }</span>
 808   }
<span class="line-added"> 809 </span>
<span class="line-added"> 810   _initialized = true;</span>
<span class="line-added"> 811   _being_initialized = false;</span>
<span class="line-added"> 812   JVMCI_lock-&gt;notify_all();</span>
 813 }
 814 
<span class="line-modified"> 815 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {</span>
<span class="line-modified"> 816   Thread* THREAD = Thread::current();</span>
<span class="line-modified"> 817   // These primitive types are long lived and are created before the runtime is fully set up</span>
<span class="line-modified"> 818   // so skip registering them for scanning.</span>
<span class="line-added"> 819   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);</span>
<span class="line-added"> 820   if (JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-added"> 821     JavaValue result(T_OBJECT);</span>
<span class="line-added"> 822     JavaCallArguments args;</span>
<span class="line-added"> 823     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));</span>
<span class="line-added"> 824     args.push_int(type2char(type));</span>
<span class="line-added"> 825     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));</span>
<span class="line-added"> 826 </span>
<span class="line-added"> 827     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));</span>
<span class="line-added"> 828   } else {</span>
<span class="line-added"> 829     JNIAccessMark jni(JVMCIENV);</span>
<span class="line-added"> 830     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),</span>
<span class="line-added"> 831                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),</span>
<span class="line-added"> 832                                            mirror.as_jobject(), type2char(type));</span>
<span class="line-added"> 833     if (jni()-&gt;ExceptionCheck()) {</span>
<span class="line-added"> 834       return JVMCIObject();</span>
<span class="line-added"> 835     }</span>
<span class="line-added"> 836     return JVMCIENV-&gt;wrap(result);</span>
 837   }
<span class="line-added"> 838 }</span>
 839 
<span class="line-modified"> 840 void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {</span>
<span class="line-modified"> 841   if (!is_HotSpotJVMCIRuntime_initialized()) {</span>
<span class="line-modified"> 842     initialize(JVMCI_CHECK);</span>
<span class="line-modified"> 843     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);</span>
<span class="line-modified"> 844   }</span>
<span class="line-modified"> 845 }</span>
<span class="line-modified"> 846 </span>
<span class="line-modified"> 847 JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {</span>
<span class="line-modified"> 848   initialize(JVMCIENV);</span>
<span class="line-added"> 849   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));</span>
<span class="line-added"> 850   return _HotSpotJVMCIRuntime_instance;</span>
<span class="line-added"> 851 }</span>
 852 
<span class="line-modified"> 853 </span>
<span class="line-added"> 854 // private void CompilerToVM.registerNatives()</span>
<span class="line-added"> 855 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))</span>
<span class="line-added"> 856   JNI_JVMCIENV(thread, env);</span>
<span class="line-added"> 857 </span>
<span class="line-added"> 858   if (!EnableJVMCI) {</span>
<span class="line-added"> 859     JVMCI_THROW_MSG(InternalError, &quot;JVMCI is not enabled&quot;);</span>
<span class="line-added"> 860   }</span>
<span class="line-added"> 861 </span>
<span class="line-added"> 862   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);</span>
 863 
 864   {
<span class="line-added"> 865     ResourceMark rm;</span>
<span class="line-added"> 866     HandleMark hm(thread);</span>
 867     ThreadToNativeFromVM trans(thread);
<span class="line-modified"> 868 </span>
<span class="line-added"> 869     // Ensure _non_oop_bits is initialized</span>
<span class="line-added"> 870     Universe::non_oop_word();</span>
<span class="line-added"> 871 </span>
<span class="line-added"> 872     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {</span>
<span class="line-added"> 873       if (!env-&gt;ExceptionCheck()) {</span>
<span class="line-added"> 874         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {</span>
<span class="line-added"> 875           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {</span>
<span class="line-added"> 876             guarantee(false, &quot;Error registering JNI method %s%s&quot;, CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);</span>
<span class="line-added"> 877             break;</span>
<span class="line-added"> 878           }</span>
<span class="line-added"> 879         }</span>
<span class="line-added"> 880       } else {</span>
<span class="line-added"> 881         env-&gt;ExceptionDescribe();</span>
<span class="line-added"> 882       }</span>
<span class="line-added"> 883       guarantee(false, &quot;Failed registering CompilerToVM native methods&quot;);</span>
<span class="line-added"> 884     }</span>
 885   }
 886 JVM_END
 887 
<span class="line-modified"> 888 </span>
<span class="line-modified"> 889 void JVMCIRuntime::shutdown() {</span>
<span class="line-added"> 890   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
 891     _shutdown_called = true;
<span class="line-modified"> 892 </span>
<span class="line-modified"> 893     THREAD_JVMCIENV(JavaThread::current());</span>
<span class="line-modified"> 894     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);</span>
<span class="line-modified"> 895   }</span>
<span class="line-modified"> 896 }</span>
<span class="line-modified"> 897 </span>
<span class="line-modified"> 898 void JVMCIRuntime::bootstrap_finished(TRAPS) {</span>
<span class="line-modified"> 899   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
<span class="line-modified"> 900     THREAD_JVMCIENV(JavaThread::current());</span>
<span class="line-modified"> 901     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);</span>
<span class="line-modified"> 902   }</span>
<span class="line-modified"> 903 }</span>
<span class="line-modified"> 904 </span>
<span class="line-modified"> 905 void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {</span>
<span class="line-modified"> 906   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-modified"> 907     Handle exception(THREAD, PENDING_EXCEPTION);</span>
<span class="line-modified"> 908     const char* exception_file = THREAD-&gt;exception_file();</span>
<span class="line-modified"> 909     int exception_line = THREAD-&gt;exception_line();</span>
<span class="line-modified"> 910     CLEAR_PENDING_EXCEPTION;</span>
<span class="line-modified"> 911     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {</span>
<span class="line-modified"> 912       // Don&#39;t print anything if we are being killed.</span>
<span class="line-modified"> 913     } else {</span>
<span class="line-modified"> 914       java_lang_Throwable::print_stack_trace(exception, tty);</span>
<span class="line-modified"> 915 </span>
<span class="line-modified"> 916       // Clear and ignore any exceptions raised during printing</span>
<span class="line-modified"> 917       CLEAR_PENDING_EXCEPTION;</span>
<span class="line-modified"> 918     }</span>
<span class="line-modified"> 919     if (!clear) {</span>
<span class="line-modified"> 920       THREAD-&gt;set_pending_exception(exception(), exception_file, exception_line);</span>
<span class="line-modified"> 921     }</span>
<span class="line-modified"> 922   }</span>
<span class="line-modified"> 923 }</span>
<span class="line-modified"> 924 </span>
<span class="line-modified"> 925 </span>
<span class="line-modified"> 926 void JVMCIRuntime::exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message) {</span>
<span class="line-modified"> 927   JavaThread* THREAD = JavaThread::current();</span>
<span class="line-modified"> 928 </span>
<span class="line-modified"> 929   static volatile int report_error = 0;</span>
<span class="line-modified"> 930   if (!report_error &amp;&amp; Atomic::cmpxchg(&amp;report_error, 0, 1) == 0) {</span>
<span class="line-modified"> 931     // Only report an error once</span>
<span class="line-modified"> 932     tty-&gt;print_raw_cr(message);</span>
<span class="line-modified"> 933     if (JVMCIENV != NULL) {</span>
<span class="line-modified"> 934       JVMCIENV-&gt;describe_pending_exception(true);</span>
<span class="line-modified"> 935     } else {</span>
<span class="line-modified"> 936       describe_pending_hotspot_exception(THREAD, true);</span>
<span class="line-modified"> 937     }</span>





 938   } else {
<span class="line-modified"> 939     // Allow error reporting thread to print the stack trace.</span>
<span class="line-modified"> 940     THREAD-&gt;sleep(200);</span>
 941   }
 942 
<span class="line-modified"> 943   before_exit(THREAD);</span>
<span class="line-modified"> 944   vm_exit(-1);</span>
<span class="line-modified"> 945 }</span>
<span class="line-modified"> 946 </span>
<span class="line-modified"> 947 // ------------------------------------------------------------------</span>
<span class="line-modified"> 948 // Note: the logic of this method should mirror the logic of</span>
<span class="line-modified"> 949 // constantPoolOopDesc::verify_constant_pool_resolve.</span>
<span class="line-modified"> 950 bool JVMCIRuntime::check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass) {</span>
<span class="line-modified"> 951   if (accessing_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified"> 952     accessing_klass = ObjArrayKlass::cast(accessing_klass)-&gt;bottom_klass();</span>
<span class="line-added"> 953   }</span>
<span class="line-added"> 954   if (!accessing_klass-&gt;is_instance_klass()) {</span>
<span class="line-added"> 955     return true;</span>
<span class="line-added"> 956   }</span>
 957 
<span class="line-modified"> 958   if (resolved_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified"> 959     // Find the element klass, if this is an array.</span>
<span class="line-modified"> 960     resolved_klass = ObjArrayKlass::cast(resolved_klass)-&gt;bottom_klass();</span>

 961   }
<span class="line-modified"> 962   if (resolved_klass-&gt;is_instance_klass()) {</span>
<span class="line-modified"> 963     Reflection::VerifyClassAccessResults result =</span>
<span class="line-added"> 964       Reflection::verify_class_access(accessing_klass, InstanceKlass::cast(resolved_klass), true);</span>
<span class="line-added"> 965     return result == Reflection::ACCESS_OK;</span>
<span class="line-added"> 966   }</span>
<span class="line-added"> 967   return true;</span>
 968 }
 969 
<span class="line-modified"> 970 // ------------------------------------------------------------------</span>
<span class="line-modified"> 971 Klass* JVMCIRuntime::get_klass_by_name_impl(Klass*&amp; accessing_klass,</span>
<span class="line-modified"> 972                                           const constantPoolHandle&amp; cpool,</span>
<span class="line-modified"> 973                                           Symbol* sym,</span>
<span class="line-modified"> 974                                           bool require_local) {</span>
<span class="line-modified"> 975   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-modified"> 976 </span>
<span class="line-added"> 977   // Now we need to check the SystemDictionary</span>
<span class="line-added"> 978   if (sym-&gt;char_at(0) == JVM_SIGNATURE_CLASS &amp;&amp;</span>
<span class="line-added"> 979       sym-&gt;char_at(sym-&gt;utf8_length()-1) == JVM_SIGNATURE_ENDCLASS) {</span>
<span class="line-added"> 980     // This is a name from a signature.  Strip off the trimmings.</span>
<span class="line-added"> 981     // Call recursive to keep scope of strippedsym.</span>
<span class="line-added"> 982     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,</span>
<span class="line-added"> 983                                                         sym-&gt;utf8_length()-2);</span>
<span class="line-added"> 984     return get_klass_by_name_impl(accessing_klass, cpool, strippedsym, require_local);</span>
<span class="line-added"> 985   }</span>
<span class="line-added"> 986 </span>
<span class="line-added"> 987   Handle loader(THREAD, (oop)NULL);</span>
<span class="line-added"> 988   Handle domain(THREAD, (oop)NULL);</span>
<span class="line-added"> 989   if (accessing_klass != NULL) {</span>
<span class="line-added"> 990     loader = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-added"> 991     domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>
<span class="line-added"> 992   }</span>
<span class="line-added"> 993 </span>
<span class="line-added"> 994   Klass* found_klass;</span>
<span class="line-added"> 995   {</span>
<span class="line-added"> 996     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems</span>
<span class="line-added"> 997     MutexLocker ml(Compile_lock);</span>
<span class="line-added"> 998     if (!require_local) {</span>
<span class="line-added"> 999       found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, CHECK_NULL);</span>
<span class="line-added">1000     } else {</span>
<span class="line-added">1001       found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain, CHECK_NULL);</span>
<span class="line-added">1002     }</span>
<span class="line-added">1003   }</span>
<span class="line-added">1004 </span>
<span class="line-added">1005   // If we fail to find an array klass, look again for its element type.</span>
<span class="line-added">1006   // The element type may be available either locally or via constraints.</span>
<span class="line-added">1007   // In either case, if we can find the element type in the system dictionary,</span>
<span class="line-added">1008   // we must build an array type around it.  The CI requires array klasses</span>
<span class="line-added">1009   // to be loaded if their element klasses are loaded, except when memory</span>
<span class="line-added">1010   // is exhausted.</span>
<span class="line-added">1011   if (sym-&gt;char_at(0) == JVM_SIGNATURE_ARRAY &amp;&amp;</span>
<span class="line-added">1012       (sym-&gt;char_at(1) == JVM_SIGNATURE_ARRAY || sym-&gt;char_at(1) == JVM_SIGNATURE_CLASS)) {</span>
<span class="line-added">1013     // We have an unloaded array.</span>
<span class="line-added">1014     // Build it on the fly if the element class exists.</span>
<span class="line-added">1015     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,</span>
<span class="line-added">1016                                                      sym-&gt;utf8_length()-1);</span>
<span class="line-added">1017 </span>
<span class="line-added">1018     // Get element Klass recursively.</span>
<span class="line-added">1019     Klass* elem_klass =</span>
<span class="line-added">1020       get_klass_by_name_impl(accessing_klass,</span>
<span class="line-added">1021                              cpool,</span>
<span class="line-added">1022                              elem_sym,</span>
<span class="line-added">1023                              require_local);</span>
<span class="line-added">1024     if (elem_klass != NULL) {</span>
<span class="line-added">1025       // Now make an array for it</span>
<span class="line-added">1026       return elem_klass-&gt;array_klass(THREAD);</span>
<span class="line-added">1027     }</span>
<span class="line-added">1028   }</span>
<span class="line-added">1029 </span>
<span class="line-added">1030   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {</span>
<span class="line-added">1031     // Look inside the constant pool for pre-resolved class entries.</span>
<span class="line-added">1032     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {</span>
<span class="line-added">1033       if (cpool-&gt;tag_at(i).is_klass()) {</span>
<span class="line-added">1034         Klass*  kls = cpool-&gt;resolved_klass_at(i);</span>
<span class="line-added">1035         if (kls-&gt;name() == sym) {</span>
<span class="line-added">1036           return kls;</span>
<span class="line-added">1037         }</span>
<span class="line-added">1038       }</span>
<span class="line-added">1039     }</span>
<span class="line-added">1040   }</span>
<span class="line-added">1041 </span>
<span class="line-added">1042   return found_klass;</span>
<span class="line-added">1043 }</span>
<span class="line-added">1044 </span>
<span class="line-added">1045 // ------------------------------------------------------------------</span>
<span class="line-added">1046 Klass* JVMCIRuntime::get_klass_by_name(Klass* accessing_klass,</span>
<span class="line-added">1047                                   Symbol* klass_name,</span>
<span class="line-added">1048                                   bool require_local) {</span>
<span class="line-added">1049   ResourceMark rm;</span>
<span class="line-added">1050   constantPoolHandle cpool;</span>
<span class="line-added">1051   return get_klass_by_name_impl(accessing_klass,</span>
<span class="line-added">1052                                                  cpool,</span>
<span class="line-added">1053                                                  klass_name,</span>
<span class="line-added">1054                                                  require_local);</span>
<span class="line-added">1055 }</span>
<span class="line-added">1056 </span>
<span class="line-added">1057 // ------------------------------------------------------------------</span>
<span class="line-added">1058 // Implementation of get_klass_by_index.</span>
<span class="line-added">1059 Klass* JVMCIRuntime::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">1060                                         int index,</span>
<span class="line-added">1061                                         bool&amp; is_accessible,</span>
<span class="line-added">1062                                         Klass* accessor) {</span>
<span class="line-added">1063   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-added">1064   Klass* klass = ConstantPool::klass_at_if_loaded(cpool, index);</span>
<span class="line-added">1065   Symbol* klass_name = NULL;</span>
<span class="line-added">1066   if (klass == NULL) {</span>
<span class="line-added">1067     klass_name = cpool-&gt;klass_name_at(index);</span>
<span class="line-added">1068   }</span>
<span class="line-added">1069 </span>
<span class="line-added">1070   if (klass == NULL) {</span>
<span class="line-added">1071     // Not found in constant pool.  Use the name to do the lookup.</span>
<span class="line-added">1072     Klass* k = get_klass_by_name_impl(accessor,</span>
<span class="line-added">1073                                         cpool,</span>
<span class="line-added">1074                                         klass_name,</span>
<span class="line-added">1075                                         false);</span>
<span class="line-added">1076     // Calculate accessibility the hard way.</span>
<span class="line-added">1077     if (k == NULL) {</span>
<span class="line-added">1078       is_accessible = false;</span>
<span class="line-added">1079     } else if (k-&gt;class_loader() != accessor-&gt;class_loader() &amp;&amp;</span>
<span class="line-added">1080                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {</span>
<span class="line-added">1081       // Loaded only remotely.  Not linked yet.</span>
<span class="line-added">1082       is_accessible = false;</span>
<span class="line-added">1083     } else {</span>
<span class="line-added">1084       // Linked locally, and we must also check public/private, etc.</span>
<span class="line-added">1085       is_accessible = check_klass_accessibility(accessor, k);</span>
<span class="line-added">1086     }</span>
<span class="line-added">1087     if (!is_accessible) {</span>
<span class="line-added">1088       return NULL;</span>
<span class="line-added">1089     }</span>
<span class="line-added">1090     return k;</span>
<span class="line-added">1091   }</span>
<span class="line-added">1092 </span>
<span class="line-added">1093   // It is known to be accessible, since it was found in the constant pool.</span>
<span class="line-added">1094   is_accessible = true;</span>
<span class="line-added">1095   return klass;</span>
<span class="line-added">1096 }</span>
<span class="line-added">1097 </span>
<span class="line-added">1098 // ------------------------------------------------------------------</span>
<span class="line-added">1099 // Get a klass from the constant pool.</span>
<span class="line-added">1100 Klass* JVMCIRuntime::get_klass_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">1101                                    int index,</span>
<span class="line-added">1102                                    bool&amp; is_accessible,</span>
<span class="line-added">1103                                    Klass* accessor) {</span>
<span class="line-added">1104   ResourceMark rm;</span>
<span class="line-added">1105   Klass* result = get_klass_by_index_impl(cpool, index, is_accessible, accessor);</span>
<span class="line-added">1106   return result;</span>
<span class="line-added">1107 }</span>
<span class="line-added">1108 </span>
<span class="line-added">1109 // ------------------------------------------------------------------</span>
<span class="line-added">1110 // Implementation of get_field_by_index.</span>
<span class="line-added">1111 //</span>
<span class="line-added">1112 // Implementation note: the results of field lookups are cached</span>
<span class="line-added">1113 // in the accessor klass.</span>
<span class="line-added">1114 void JVMCIRuntime::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor&amp; field_desc,</span>
<span class="line-added">1115                                         int index) {</span>
<span class="line-added">1116   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-added">1117 </span>
<span class="line-added">1118   assert(klass-&gt;is_linked(), &quot;must be linked before using its constant-pool&quot;);</span>
<span class="line-added">1119 </span>
<span class="line-added">1120   constantPoolHandle cpool(thread, klass-&gt;constants());</span>
<span class="line-added">1121 </span>
<span class="line-added">1122   // Get the field&#39;s name, signature, and type.</span>
<span class="line-added">1123   Symbol* name  = cpool-&gt;name_ref_at(index);</span>
<span class="line-added">1124 </span>
<span class="line-added">1125   int nt_index = cpool-&gt;name_and_type_ref_index_at(index);</span>
<span class="line-added">1126   int sig_index = cpool-&gt;signature_ref_index_at(nt_index);</span>
<span class="line-added">1127   Symbol* signature = cpool-&gt;symbol_at(sig_index);</span>
<span class="line-added">1128 </span>
<span class="line-added">1129   // Get the field&#39;s declared holder.</span>
<span class="line-added">1130   int holder_index = cpool-&gt;klass_ref_index_at(index);</span>
<span class="line-added">1131   bool holder_is_accessible;</span>
<span class="line-added">1132   Klass* declared_holder = get_klass_by_index(cpool, holder_index,</span>
<span class="line-added">1133                                                holder_is_accessible,</span>
<span class="line-added">1134                                                klass);</span>
<span class="line-added">1135 </span>
<span class="line-added">1136   // The declared holder of this field may not have been loaded.</span>
<span class="line-added">1137   // Bail out with partial field information.</span>
<span class="line-added">1138   if (!holder_is_accessible) {</span>
<span class="line-added">1139     return;</span>
<span class="line-added">1140   }</span>
<span class="line-added">1141 </span>
<span class="line-added">1142 </span>
<span class="line-added">1143   // Perform the field lookup.</span>
<span class="line-added">1144   Klass*  canonical_holder =</span>
<span class="line-added">1145     InstanceKlass::cast(declared_holder)-&gt;find_field(name, signature, &amp;field_desc);</span>
<span class="line-added">1146   if (canonical_holder == NULL) {</span>
<span class="line-added">1147     return;</span>
<span class="line-added">1148   }</span>
<span class="line-added">1149 </span>
<span class="line-added">1150   assert(canonical_holder == field_desc.field_holder(), &quot;just checking&quot;);</span>
<span class="line-added">1151 }</span>
<span class="line-added">1152 </span>
<span class="line-added">1153 // ------------------------------------------------------------------</span>
<span class="line-added">1154 // Get a field by index from a klass&#39;s constant pool.</span>
<span class="line-added">1155 void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor&amp; fd, int index) {</span>
<span class="line-added">1156   ResourceMark rm;</span>
<span class="line-added">1157   return get_field_by_index_impl(accessor, fd, index);</span>
<span class="line-added">1158 }</span>
<span class="line-added">1159 </span>
<span class="line-added">1160 // ------------------------------------------------------------------</span>
<span class="line-added">1161 // Perform an appropriate method lookup based on accessor, holder,</span>
<span class="line-added">1162 // name, signature, and bytecode.</span>
<span class="line-added">1163 Method* JVMCIRuntime::lookup_method(InstanceKlass* accessor,</span>
<span class="line-added">1164                                     Klass*        holder,</span>
<span class="line-added">1165                                     Symbol*       name,</span>
<span class="line-added">1166                                     Symbol*       sig,</span>
<span class="line-added">1167                                     Bytecodes::Code bc,</span>
<span class="line-added">1168                                     constantTag   tag) {</span>
<span class="line-added">1169   // Accessibility checks are performed in JVMCIEnv::get_method_by_index_impl().</span>
<span class="line-added">1170   assert(check_klass_accessibility(accessor, holder), &quot;holder not accessible&quot;);</span>
<span class="line-added">1171 </span>
<span class="line-added">1172   Method* dest_method;</span>
<span class="line-added">1173   LinkInfo link_info(holder, name, sig, accessor, LinkInfo::needs_access_check, tag);</span>
<span class="line-added">1174   switch (bc) {</span>
<span class="line-added">1175   case Bytecodes::_invokestatic:</span>
<span class="line-added">1176     dest_method =</span>
<span class="line-added">1177       LinkResolver::resolve_static_call_or_null(link_info);</span>
<span class="line-added">1178     break;</span>
<span class="line-added">1179   case Bytecodes::_invokespecial:</span>
<span class="line-added">1180     dest_method =</span>
<span class="line-added">1181       LinkResolver::resolve_special_call_or_null(link_info);</span>
<span class="line-added">1182     break;</span>
<span class="line-added">1183   case Bytecodes::_invokeinterface:</span>
<span class="line-added">1184     dest_method =</span>
<span class="line-added">1185       LinkResolver::linktime_resolve_interface_method_or_null(link_info);</span>
<span class="line-added">1186     break;</span>
<span class="line-added">1187   case Bytecodes::_invokevirtual:</span>
<span class="line-added">1188     dest_method =</span>
<span class="line-added">1189       LinkResolver::linktime_resolve_virtual_method_or_null(link_info);</span>
<span class="line-added">1190     break;</span>
<span class="line-added">1191   default: ShouldNotReachHere();</span>
<span class="line-added">1192   }</span>
<span class="line-added">1193 </span>
<span class="line-added">1194   return dest_method;</span>
<span class="line-added">1195 }</span>
<span class="line-added">1196 </span>
<span class="line-added">1197 </span>
<span class="line-added">1198 // ------------------------------------------------------------------</span>
<span class="line-added">1199 Method* JVMCIRuntime::get_method_by_index_impl(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">1200                                                int index, Bytecodes::Code bc,</span>
<span class="line-added">1201                                                InstanceKlass* accessor) {</span>
<span class="line-added">1202   if (bc == Bytecodes::_invokedynamic) {</span>
<span class="line-added">1203     ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);</span>
<span class="line-added">1204     bool is_resolved = !cpce-&gt;is_f1_null();</span>
<span class="line-added">1205     if (is_resolved) {</span>
<span class="line-added">1206       // Get the invoker Method* from the constant pool.</span>
<span class="line-added">1207       // (The appendix argument, if any, will be noted in the method&#39;s signature.)</span>
<span class="line-added">1208       Method* adapter = cpce-&gt;f1_as_method();</span>
<span class="line-added">1209       return adapter;</span>
<span class="line-added">1210     }</span>
<span class="line-added">1211 </span>
<span class="line-added">1212     return NULL;</span>
<span class="line-added">1213   }</span>
<span class="line-added">1214 </span>
<span class="line-added">1215   int holder_index = cpool-&gt;klass_ref_index_at(index);</span>
<span class="line-added">1216   bool holder_is_accessible;</span>
<span class="line-added">1217   Klass* holder = get_klass_by_index_impl(cpool, holder_index, holder_is_accessible, accessor);</span>
<span class="line-added">1218 </span>
<span class="line-added">1219   // Get the method&#39;s name and signature.</span>
<span class="line-added">1220   Symbol* name_sym = cpool-&gt;name_ref_at(index);</span>
<span class="line-added">1221   Symbol* sig_sym  = cpool-&gt;signature_ref_at(index);</span>
<span class="line-added">1222 </span>
<span class="line-added">1223   if (cpool-&gt;has_preresolution()</span>
<span class="line-added">1224       || ((holder == SystemDictionary::MethodHandle_klass() || holder == SystemDictionary::VarHandle_klass()) &amp;&amp;</span>
<span class="line-added">1225           MethodHandles::is_signature_polymorphic_name(holder, name_sym))) {</span>
<span class="line-added">1226     // Short-circuit lookups for JSR 292-related call sites.</span>
<span class="line-added">1227     // That is, do not rely only on name-based lookups, because they may fail</span>
<span class="line-added">1228     // if the names are not resolvable in the boot class loader (7056328).</span>
<span class="line-added">1229     switch (bc) {</span>
<span class="line-added">1230     case Bytecodes::_invokevirtual:</span>
<span class="line-added">1231     case Bytecodes::_invokeinterface:</span>
<span class="line-added">1232     case Bytecodes::_invokespecial:</span>
<span class="line-added">1233     case Bytecodes::_invokestatic:</span>
<span class="line-added">1234       {</span>
<span class="line-added">1235         Method* m = ConstantPool::method_at_if_loaded(cpool, index);</span>
<span class="line-added">1236         if (m != NULL) {</span>
<span class="line-added">1237           return m;</span>
<span class="line-added">1238         }</span>
<span class="line-added">1239       }</span>
<span class="line-added">1240       break;</span>
<span class="line-added">1241     default:</span>
<span class="line-added">1242       break;</span>
<span class="line-added">1243     }</span>
<span class="line-added">1244   }</span>
<span class="line-added">1245 </span>
<span class="line-added">1246   if (holder_is_accessible) { // Our declared holder is loaded.</span>
<span class="line-added">1247     constantTag tag = cpool-&gt;tag_ref_at(index);</span>
<span class="line-added">1248     Method* m = lookup_method(accessor, holder, name_sym, sig_sym, bc, tag);</span>
<span class="line-added">1249     if (m != NULL) {</span>
<span class="line-added">1250       // We found the method.</span>
<span class="line-added">1251       return m;</span>
<span class="line-added">1252     }</span>
<span class="line-added">1253   }</span>
<span class="line-added">1254 </span>
<span class="line-added">1255   // Either the declared holder was not loaded, or the method could</span>
<span class="line-added">1256   // not be found.</span>
<span class="line-added">1257 </span>
<span class="line-added">1258   return NULL;</span>
<span class="line-added">1259 }</span>
<span class="line-added">1260 </span>
<span class="line-added">1261 // ------------------------------------------------------------------</span>
<span class="line-added">1262 InstanceKlass* JVMCIRuntime::get_instance_klass_for_declared_method_holder(Klass* method_holder) {</span>
<span class="line-added">1263   // For the case of &lt;array&gt;.clone(), the method holder can be an ArrayKlass*</span>
<span class="line-added">1264   // instead of an InstanceKlass*.  For that case simply pretend that the</span>
<span class="line-added">1265   // declared holder is Object.clone since that&#39;s where the call will bottom out.</span>
<span class="line-added">1266   if (method_holder-&gt;is_instance_klass()) {</span>
<span class="line-added">1267     return InstanceKlass::cast(method_holder);</span>
<span class="line-added">1268   } else if (method_holder-&gt;is_array_klass()) {</span>
<span class="line-added">1269     return SystemDictionary::Object_klass();</span>
<span class="line-added">1270   } else {</span>
<span class="line-added">1271     ShouldNotReachHere();</span>
<span class="line-added">1272   }</span>
<span class="line-added">1273   return NULL;</span>
<span class="line-added">1274 }</span>
<span class="line-added">1275 </span>
<span class="line-added">1276 </span>
<span class="line-added">1277 // ------------------------------------------------------------------</span>
<span class="line-added">1278 Method* JVMCIRuntime::get_method_by_index(const constantPoolHandle&amp; cpool,</span>
<span class="line-added">1279                                      int index, Bytecodes::Code bc,</span>
<span class="line-added">1280                                      InstanceKlass* accessor) {</span>
<span class="line-added">1281   ResourceMark rm;</span>
<span class="line-added">1282   return get_method_by_index_impl(cpool, index, bc, accessor);</span>
<span class="line-added">1283 }</span>
<span class="line-added">1284 </span>
<span class="line-added">1285 // ------------------------------------------------------------------</span>
<span class="line-added">1286 // Check for changes to the system dictionary during compilation</span>
<span class="line-added">1287 // class loads, evolution, breakpoints</span>
<span class="line-added">1288 JVMCI::CodeInstallResult JVMCIRuntime::validate_compile_task_dependencies(Dependencies* dependencies, JVMCICompileState* compile_state, char** failure_detail) {</span>
<span class="line-added">1289   // If JVMTI capabilities were enabled during compile, the compilation is invalidated.</span>
<span class="line-added">1290   if (compile_state != NULL &amp;&amp; compile_state-&gt;jvmti_state_changed()) {</span>
<span class="line-added">1291     *failure_detail = (char*) &quot;Jvmti state change during compilation invalidated dependencies&quot;;</span>
<span class="line-added">1292     return JVMCI::dependencies_failed;</span>
<span class="line-added">1293   }</span>
<span class="line-added">1294 </span>
<span class="line-added">1295   CompileTask* task = compile_state == NULL ? NULL : compile_state-&gt;task();</span>
<span class="line-added">1296   Dependencies::DepType result = dependencies-&gt;validate_dependencies(task, failure_detail);</span>
<span class="line-added">1297   if (result == Dependencies::end_marker) {</span>
<span class="line-added">1298     return JVMCI::ok;</span>
<span class="line-added">1299   }</span>
<span class="line-added">1300 </span>
<span class="line-added">1301   return JVMCI::dependencies_failed;</span>
<span class="line-added">1302 }</span>
<span class="line-added">1303 </span>
<span class="line-added">1304 // Reports a pending exception and exits the VM.</span>
<span class="line-added">1305 static void fatal_exception_in_compile(JVMCIEnv* JVMCIENV, JavaThread* thread, const char* msg) {</span>
<span class="line-added">1306   // Only report a fatal JVMCI compilation exception once</span>
<span class="line-added">1307   static volatile int report_init_failure = 0;</span>
<span class="line-added">1308   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(&amp;report_init_failure, 0, 1) == 0) {</span>
<span class="line-added">1309       tty-&gt;print_cr(&quot;%s:&quot;, msg);</span>
<span class="line-added">1310       JVMCIENV-&gt;describe_pending_exception(true);</span>
<span class="line-added">1311   }</span>
<span class="line-added">1312   JVMCIENV-&gt;clear_pending_exception();</span>
<span class="line-added">1313   before_exit(thread);</span>
<span class="line-added">1314   vm_exit(-1);</span>
<span class="line-added">1315 }</span>
<span class="line-added">1316 </span>
<span class="line-added">1317 void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {</span>
<span class="line-added">1318   JVMCI_EXCEPTION_CONTEXT</span>
<span class="line-added">1319 </span>
<span class="line-added">1320   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();</span>
<span class="line-added">1321 </span>
<span class="line-added">1322   bool is_osr = entry_bci != InvocationEntryBci;</span>
<span class="line-added">1323   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {</span>
<span class="line-added">1324     // no OSR compilations during bootstrap - the compiler is just too slow at this point,</span>
<span class="line-added">1325     // and we know that there are no endless loops</span>
<span class="line-added">1326     compile_state-&gt;set_failure(true, &quot;No OSR during boostrap&quot;);</span>
<span class="line-added">1327     return;</span>
<span class="line-added">1328   }</span>
<span class="line-added">1329   if (JVMCI::shutdown_called()) {</span>
<span class="line-added">1330     compile_state-&gt;set_failure(false, &quot;Avoiding compilation during shutdown&quot;);</span>
<span class="line-added">1331     return;</span>
<span class="line-added">1332   }</span>
<span class="line-added">1333 </span>
<span class="line-added">1334   HandleMark hm;</span>
<span class="line-added">1335   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);</span>
<span class="line-added">1336   if (JVMCIENV-&gt;has_pending_exception()) {</span>
<span class="line-added">1337     fatal_exception_in_compile(JVMCIENV, thread, &quot;Exception during HotSpotJVMCIRuntime initialization&quot;);</span>
<span class="line-added">1338   }</span>
<span class="line-added">1339   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);</span>
<span class="line-added">1340   if (JVMCIENV-&gt;has_pending_exception()) {</span>
<span class="line-added">1341     JVMCIENV-&gt;describe_pending_exception(true);</span>
<span class="line-added">1342     compile_state-&gt;set_failure(false, &quot;exception getting JVMCI wrapper method&quot;);</span>
<span class="line-added">1343     return;</span>
<span class="line-added">1344   }</span>
<span class="line-added">1345 </span>
<span class="line-added">1346   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,</span>
<span class="line-added">1347                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());</span>
<span class="line-added">1348   if (!JVMCIENV-&gt;has_pending_exception()) {</span>
<span class="line-added">1349     if (result_object.is_non_null()) {</span>
<span class="line-added">1350       JVMCIObject failure_message = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_failureMessage(result_object);</span>
<span class="line-added">1351       if (failure_message.is_non_null()) {</span>
<span class="line-added">1352         // Copy failure reason into resource memory first ...</span>
<span class="line-added">1353         const char* failure_reason = JVMCIENV-&gt;as_utf8_string(failure_message);</span>
<span class="line-added">1354         // ... and then into the C heap.</span>
<span class="line-added">1355         failure_reason = os::strdup(failure_reason, mtJVMCI);</span>
<span class="line-added">1356         bool retryable = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_retry(result_object) != 0;</span>
<span class="line-added">1357         compile_state-&gt;set_failure(retryable, failure_reason, true);</span>
<span class="line-added">1358       } else {</span>
<span class="line-added">1359         if (compile_state-&gt;task()-&gt;code() == NULL) {</span>
<span class="line-added">1360           compile_state-&gt;set_failure(true, &quot;no nmethod produced&quot;);</span>
<span class="line-added">1361         } else {</span>
<span class="line-added">1362           compile_state-&gt;task()-&gt;set_num_inlined_bytecodes(JVMCIENV-&gt;get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));</span>
<span class="line-added">1363           compiler-&gt;inc_methods_compiled();</span>
<span class="line-added">1364         }</span>
<span class="line-added">1365       }</span>
<span class="line-added">1366     } else {</span>
<span class="line-added">1367       assert(false, &quot;JVMCICompiler.compileMethod should always return non-null&quot;);</span>
<span class="line-added">1368     }</span>
<span class="line-added">1369   } else {</span>
<span class="line-added">1370     // An uncaught exception here implies failure during compiler initialization.</span>
<span class="line-added">1371     // The only sensible thing to do here is to exit the VM.</span>
<span class="line-added">1372     fatal_exception_in_compile(JVMCIENV, thread, &quot;Exception during JVMCI compiler initialization&quot;);</span>
<span class="line-added">1373   }</span>
<span class="line-added">1374   if (compiler-&gt;is_bootstrapping()) {</span>
<span class="line-added">1375     compiler-&gt;set_bootstrap_compilation_request_handled();</span>
<span class="line-added">1376   }</span>
<span class="line-added">1377 }</span>
<span class="line-added">1378 </span>
<span class="line-added">1379 </span>
<span class="line-added">1380 // ------------------------------------------------------------------</span>
<span class="line-added">1381 JVMCI::CodeInstallResult JVMCIRuntime::register_method(JVMCIEnv* JVMCIENV,</span>
<span class="line-added">1382                                 const methodHandle&amp; method,</span>
<span class="line-added">1383                                 nmethod*&amp; nm,</span>
<span class="line-added">1384                                 int entry_bci,</span>
<span class="line-added">1385                                 CodeOffsets* offsets,</span>
<span class="line-added">1386                                 int orig_pc_offset,</span>
<span class="line-added">1387                                 CodeBuffer* code_buffer,</span>
<span class="line-added">1388                                 int frame_words,</span>
<span class="line-added">1389                                 OopMapSet* oop_map_set,</span>
<span class="line-added">1390                                 ExceptionHandlerTable* handler_table,</span>
<span class="line-added">1391                                 ImplicitExceptionTable* implicit_exception_table,</span>
<span class="line-added">1392                                 AbstractCompiler* compiler,</span>
<span class="line-added">1393                                 DebugInformationRecorder* debug_info,</span>
<span class="line-added">1394                                 Dependencies* dependencies,</span>
<span class="line-added">1395                                 int compile_id,</span>
<span class="line-added">1396                                 bool has_unsafe_access,</span>
<span class="line-added">1397                                 bool has_wide_vector,</span>
<span class="line-added">1398                                 JVMCIObject compiled_code,</span>
<span class="line-added">1399                                 JVMCIObject nmethod_mirror,</span>
<span class="line-added">1400                                 FailedSpeculation** failed_speculations,</span>
<span class="line-added">1401                                 char* speculations,</span>
<span class="line-added">1402                                 int speculations_len) {</span>
<span class="line-added">1403   JVMCI_EXCEPTION_CONTEXT;</span>
<span class="line-added">1404   nm = NULL;</span>
<span class="line-added">1405   int comp_level = CompLevel_full_optimization;</span>
<span class="line-added">1406   char* failure_detail = NULL;</span>
<span class="line-added">1407 </span>
<span class="line-added">1408   bool install_default = JVMCIENV-&gt;get_HotSpotNmethod_isDefault(nmethod_mirror) != 0;</span>
<span class="line-added">1409   assert(JVMCIENV-&gt;isa_HotSpotNmethod(nmethod_mirror), &quot;must be&quot;);</span>
<span class="line-added">1410   JVMCIObject name = JVMCIENV-&gt;get_InstalledCode_name(nmethod_mirror);</span>
<span class="line-added">1411   const char* nmethod_mirror_name = name.is_null() ? NULL : JVMCIENV-&gt;as_utf8_string(name);</span>
<span class="line-added">1412   int nmethod_mirror_index;</span>
<span class="line-added">1413   if (!install_default) {</span>
<span class="line-added">1414     // Reserve or initialize mirror slot in the oops table.</span>
<span class="line-added">1415     OopRecorder* oop_recorder = debug_info-&gt;oop_recorder();</span>
<span class="line-added">1416     nmethod_mirror_index = oop_recorder-&gt;allocate_oop_index(nmethod_mirror.is_hotspot() ? nmethod_mirror.as_jobject() : NULL);</span>
<span class="line-added">1417   } else {</span>
<span class="line-added">1418     // A default HotSpotNmethod mirror is never tracked by the nmethod</span>
<span class="line-added">1419     nmethod_mirror_index = -1;</span>
<span class="line-added">1420   }</span>
<span class="line-added">1421 </span>
<span class="line-added">1422   JVMCI::CodeInstallResult result;</span>
<span class="line-added">1423   {</span>
<span class="line-added">1424     // To prevent compile queue updates.</span>
<span class="line-added">1425     MutexLocker locker(THREAD, MethodCompileQueue_lock);</span>
<span class="line-added">1426 </span>
<span class="line-added">1427     // Prevent SystemDictionary::add_to_hierarchy from running</span>
<span class="line-added">1428     // and invalidating our dependencies until we install this method.</span>
<span class="line-added">1429     MutexLocker ml(Compile_lock);</span>
<span class="line-added">1430 </span>
<span class="line-added">1431     // Encode the dependencies now, so we can check them right away.</span>
<span class="line-added">1432     dependencies-&gt;encode_content_bytes();</span>
<span class="line-added">1433 </span>
<span class="line-added">1434     // Record the dependencies for the current compile in the log</span>
<span class="line-added">1435     if (LogCompilation) {</span>
<span class="line-added">1436       for (Dependencies::DepStream deps(dependencies); deps.next(); ) {</span>
<span class="line-added">1437         deps.log_dependency();</span>
<span class="line-added">1438       }</span>
<span class="line-added">1439     }</span>
<span class="line-added">1440 </span>
<span class="line-added">1441     // Check for {class loads, evolution, breakpoints} during compilation</span>
<span class="line-added">1442     result = validate_compile_task_dependencies(dependencies, JVMCIENV-&gt;compile_state(), &amp;failure_detail);</span>
<span class="line-added">1443     if (result != JVMCI::ok) {</span>
<span class="line-added">1444       // While not a true deoptimization, it is a preemptive decompile.</span>
<span class="line-added">1445       MethodData* mdp = method()-&gt;method_data();</span>
<span class="line-added">1446       if (mdp != NULL) {</span>
<span class="line-added">1447         mdp-&gt;inc_decompile_count();</span>
<span class="line-added">1448 #ifdef ASSERT</span>
<span class="line-added">1449         if (mdp-&gt;decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {</span>
<span class="line-added">1450           ResourceMark m;</span>
<span class="line-added">1451           tty-&gt;print_cr(&quot;WARN: endless recompilation of %s. Method was set to not compilable.&quot;, method()-&gt;name_and_sig_as_C_string());</span>
<span class="line-added">1452         }</span>
<span class="line-added">1453 #endif</span>
<span class="line-added">1454       }</span>
<span class="line-added">1455 </span>
<span class="line-added">1456       // All buffers in the CodeBuffer are allocated in the CodeCache.</span>
<span class="line-added">1457       // If the code buffer is created on each compile attempt</span>
<span class="line-added">1458       // as in C2, then it must be freed.</span>
<span class="line-added">1459       //code_buffer-&gt;free_blob();</span>
<span class="line-added">1460     } else {</span>
<span class="line-added">1461       nm =  nmethod::new_nmethod(method,</span>
<span class="line-added">1462                                  compile_id,</span>
<span class="line-added">1463                                  entry_bci,</span>
<span class="line-added">1464                                  offsets,</span>
<span class="line-added">1465                                  orig_pc_offset,</span>
<span class="line-added">1466                                  debug_info, dependencies, code_buffer,</span>
<span class="line-added">1467                                  frame_words, oop_map_set,</span>
<span class="line-added">1468                                  handler_table, implicit_exception_table,</span>
<span class="line-added">1469                                  compiler, comp_level,</span>
<span class="line-added">1470                                  speculations, speculations_len,</span>
<span class="line-added">1471                                  nmethod_mirror_index, nmethod_mirror_name, failed_speculations);</span>
<span class="line-added">1472 </span>
<span class="line-added">1473 </span>
<span class="line-added">1474       // Free codeBlobs</span>
<span class="line-added">1475       if (nm == NULL) {</span>
<span class="line-added">1476         // The CodeCache is full.  Print out warning and disable compilation.</span>
<span class="line-added">1477         {</span>
<span class="line-added">1478           MutexUnlocker ml(Compile_lock);</span>
<span class="line-added">1479           MutexUnlocker locker(MethodCompileQueue_lock);</span>
<span class="line-added">1480           CompileBroker::handle_full_code_cache(CodeCache::get_code_blob_type(comp_level));</span>
<span class="line-added">1481         }</span>
<span class="line-added">1482       } else {</span>
<span class="line-added">1483         nm-&gt;set_has_unsafe_access(has_unsafe_access);</span>
<span class="line-added">1484         nm-&gt;set_has_wide_vectors(has_wide_vector);</span>
<span class="line-added">1485 </span>
<span class="line-added">1486         // Record successful registration.</span>
<span class="line-added">1487         // (Put nm into the task handle *before* publishing to the Java heap.)</span>
<span class="line-added">1488         if (JVMCIENV-&gt;compile_state() != NULL) {</span>
<span class="line-added">1489           JVMCIENV-&gt;compile_state()-&gt;task()-&gt;set_code(nm);</span>
<span class="line-added">1490         }</span>
<span class="line-added">1491 </span>
<span class="line-added">1492         JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();</span>
<span class="line-added">1493         assert(data != NULL, &quot;must be&quot;);</span>
<span class="line-added">1494         if (install_default) {</span>
<span class="line-added">1495           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == NULL, &quot;must be&quot;);</span>
<span class="line-added">1496           if (entry_bci == InvocationEntryBci) {</span>
<span class="line-added">1497             if (TieredCompilation) {</span>
<span class="line-added">1498               // If there is an old version we&#39;re done with it</span>
<span class="line-added">1499               CompiledMethod* old = method-&gt;code();</span>
<span class="line-added">1500               if (TraceMethodReplacement &amp;&amp; old != NULL) {</span>
<span class="line-added">1501                 ResourceMark rm;</span>
<span class="line-added">1502                 char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-added">1503                 tty-&gt;print_cr(&quot;Replacing method %s&quot;, method_name);</span>
<span class="line-added">1504               }</span>
<span class="line-added">1505               if (old != NULL ) {</span>
<span class="line-added">1506                 old-&gt;make_not_entrant();</span>
<span class="line-added">1507               }</span>
<span class="line-added">1508             }</span>
<span class="line-added">1509 </span>
<span class="line-added">1510             LogTarget(Info, nmethod, install) lt;</span>
<span class="line-added">1511             if (lt.is_enabled()) {</span>
<span class="line-added">1512               ResourceMark rm;</span>
<span class="line-added">1513               char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-added">1514               lt.print(&quot;Installing method (%d) %s [entry point: %p]&quot;,</span>
<span class="line-added">1515                         comp_level, method_name, nm-&gt;entry_point());</span>
<span class="line-added">1516             }</span>
<span class="line-added">1517             // Allow the code to be executed</span>
<span class="line-added">1518             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">1519             if (nm-&gt;make_in_use()) {</span>
<span class="line-added">1520               method-&gt;set_code(method, nm);</span>
<span class="line-added">1521             }</span>
<span class="line-added">1522           } else {</span>
<span class="line-added">1523             LogTarget(Info, nmethod, install) lt;</span>
<span class="line-added">1524             if (lt.is_enabled()) {</span>
<span class="line-added">1525               ResourceMark rm;</span>
<span class="line-added">1526               char *method_name = method-&gt;name_and_sig_as_C_string();</span>
<span class="line-added">1527               lt.print(&quot;Installing osr method (%d) %s @ %d&quot;,</span>
<span class="line-added">1528                         comp_level, method_name, entry_bci);</span>
<span class="line-added">1529             }</span>
<span class="line-added">1530             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">1531             if (nm-&gt;make_in_use()) {</span>
<span class="line-added">1532               InstanceKlass::cast(method-&gt;method_holder())-&gt;add_osr_nmethod(nm);</span>
<span class="line-added">1533             }</span>
<span class="line-added">1534           }</span>
<span class="line-added">1535         } else {</span>
<span class="line-added">1536           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == HotSpotJVMCI::resolve(nmethod_mirror), &quot;must be&quot;);</span>
<span class="line-added">1537         }</span>
<span class="line-added">1538       }</span>
<span class="line-added">1539       result = nm != NULL ? JVMCI::ok :JVMCI::cache_full;</span>
<span class="line-added">1540     }</span>
<span class="line-added">1541   }</span>
<span class="line-added">1542 </span>
<span class="line-added">1543   // String creation must be done outside lock</span>
<span class="line-added">1544   if (failure_detail != NULL) {</span>
<span class="line-added">1545     // A failure to allocate the string is silently ignored.</span>
<span class="line-added">1546     JVMCIObject message = JVMCIENV-&gt;create_string(failure_detail, JVMCIENV);</span>
<span class="line-added">1547     JVMCIENV-&gt;set_HotSpotCompiledNmethod_installationFailureMessage(compiled_code, message);</span>
<span class="line-added">1548   }</span>
<span class="line-added">1549 </span>
<span class="line-added">1550   // JVMTI -- compiled method notification (must be done outside lock)</span>
<span class="line-added">1551   if (nm != NULL) {</span>
<span class="line-added">1552     nm-&gt;post_compiled_method_load_event();</span>
<span class="line-added">1553   }</span>
<span class="line-added">1554 </span>
<span class="line-added">1555   return result;</span>
1556 }
</pre>
</td>
</tr>
</table>
<center><a href="jvmciJavaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
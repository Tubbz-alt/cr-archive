<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCompiler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCompilerToVM.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
<span class="line-modified">  25 #include &quot;ci/ciUtilities.inline.hpp&quot;</span>
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;


  27 #include &quot;code/scopeDesc.hpp&quot;
<span class="line-removed">  28 #include &quot;interpreter/linkResolver.hpp&quot;</span>
<span class="line-removed">  29 #include &quot;memory/oopFactory.hpp&quot;</span>
<span class="line-removed">  30 #include &quot;oops/cpCache.inline.hpp&quot;</span>
<span class="line-removed">  31 #include &quot;oops/generateOopMap.hpp&quot;</span>
<span class="line-removed">  32 #include &quot;oops/method.inline.hpp&quot;</span>
<span class="line-removed">  33 #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
<span class="line-removed">  34 #include &quot;oops/typeArrayOop.inline.hpp&quot;</span>
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;compiler/disassembler.hpp&quot;


  37 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  38 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  39 #include &quot;jvmci/jvmciRuntime.hpp&quot;










  40 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
<span class="line-removed">  41 #include &quot;runtime/flags/jvmFlag.hpp&quot;</span>
  42 #include &quot;runtime/frame.inline.hpp&quot;
<span class="line-removed">  43 #include &quot;runtime/handles.inline.hpp&quot;</span>
  44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  45 #include &quot;runtime/jniHandles.inline.hpp&quot;
  46 #include &quot;runtime/timerTrace.hpp&quot;
  47 #include &quot;runtime/vframe_hp.hpp&quot;
  48 
  49 JVMCIKlassHandle::JVMCIKlassHandle(Thread* thread, Klass* klass) {
  50   _thread = thread;
  51   _klass = klass;
  52   if (klass != NULL) {
  53     _holder = Handle(_thread, klass-&gt;klass_holder());
  54   }
  55 }
  56 
  57 JVMCIKlassHandle&amp; JVMCIKlassHandle::operator=(Klass* klass) {
  58   _klass = klass;
  59   if (klass != NULL) {
  60     _holder = Handle(_thread, klass-&gt;klass_holder());
  61   }
  62   return *this;
  63 }
  64 
<span class="line-modified">  65 void JNIHandleMark::push_jni_handle_block() {</span>
<span class="line-modified">  66   JavaThread* thread = JavaThread::current();</span>





  67   if (thread != NULL) {
  68     // Allocate a new block for JNI handles.
  69     // Inlined code from jni_PushLocalFrame()
<span class="line-modified">  70     JNIHandleBlock* java_handles = ((JavaThread*)thread)-&gt;active_handles();</span>
  71     JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
  72     assert(compile_handles != NULL &amp;&amp; java_handles != NULL, &quot;should not be NULL&quot;);
  73     compile_handles-&gt;set_pop_frame_link(java_handles);
  74     thread-&gt;set_active_handles(compile_handles);
  75   }
  76 }
  77 
<span class="line-modified">  78 void JNIHandleMark::pop_jni_handle_block() {</span>
<span class="line-removed">  79   JavaThread* thread = JavaThread::current();</span>
  80   if (thread != NULL) {
  81     // Release our JNI handle block
  82     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  83     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  84     thread-&gt;set_active_handles(java_handles);
  85     compile_handles-&gt;set_pop_frame_link(NULL);
  86     JNIHandleBlock::release_block(compile_handles, thread); // may block
  87   }
  88 }
  89 
<span class="line-modified">  90 // Entry to native method implementation that transitions current thread to &#39;_thread_in_vm&#39;.</span>
<span class="line-modified">  91 #define C2V_VMENTRY(result_type, name, signature) \</span>
<span class="line-modified">  92   JNIEXPORT result_type JNICALL c2v_ ## name signature { \</span>
<span class="line-modified">  93   TRACE_jvmci_1(&quot;CompilerToVM::&quot; #name); \</span>
<span class="line-modified">  94   TRACE_CALL(result_type, jvmci_ ## name signature) \</span>
<span class="line-modified">  95   JVMCI_VM_ENTRY_MARK; \</span>
<span class="line-modified">  96 </span>
<span class="line-modified">  97 #define C2V_END }</span>
<span class="line-removed">  98 </span>
<span class="line-removed">  99 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {</span>
<span class="line-removed"> 100   if (method() != NULL) {</span>
<span class="line-removed"> 101     JavaValue result(T_OBJECT);</span>
<span class="line-removed"> 102     JavaCallArguments args;</span>
<span class="line-removed"> 103     args.push_long((jlong) (address) method());</span>
<span class="line-removed"> 104     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);</span>
<span class="line-removed"> 105 </span>
<span class="line-removed"> 106     return (oop)result.get_jobject();</span>
 107   }
<span class="line-modified"> 108   return NULL;</span>
<span class="line-modified"> 109 }</span>
<span class="line-modified"> 110 </span>
<span class="line-modified"> 111 oop CompilerToVM::get_jvmci_type(JVMCIKlassHandle&amp; klass, TRAPS) {</span>
<span class="line-removed"> 112   if (!klass.is_null()) {</span>
<span class="line-removed"> 113     JavaValue result(T_OBJECT);</span>
<span class="line-removed"> 114     JavaCallArguments args;</span>
<span class="line-removed"> 115     args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));</span>
<span class="line-removed"> 116     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);</span>
<span class="line-removed"> 117 </span>
<span class="line-removed"> 118     return (oop)result.get_jobject();</span>
 119   }
<span class="line-modified"> 120   return NULL;</span>
<span class="line-modified"> 121 }</span>
 122 
 123 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 124   assert(_index &lt; _args-&gt;length(), &quot;out of bounds&quot;);
 125   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 126   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), &quot;arg type mismatch&quot;);
 127   return Handle(Thread::current(), arg);
 128 }
 129 
<span class="line-modified"> 130 jobjectArray readConfiguration0(JNIEnv *env, TRAPS);</span>

















 131 
<span class="line-modified"> 132 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))</span>
<span class="line-modified"> 133    jobjectArray config = readConfiguration0(env, CHECK_NULL);</span>
<span class="line-modified"> 134    return config;</span>
<span class="line-modified"> 135 C2V_END</span>
































 136 
<span class="line-modified"> 137 C2V_VMENTRY(jobject, getFlagValue, (JNIEnv *, jobject c2vm, jobject name_handle))</span>
<span class="line-modified"> 138 #define RETURN_BOXED_LONG(value) oop box; jvalue p; p.j = (jlong) (value); box = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);</span>
<span class="line-modified"> 139 #define RETURN_BOXED_DOUBLE(value) oop box; jvalue p; p.d = (jdouble) (value); box = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);</span>
<span class="line-modified"> 140   Handle name(THREAD, JNIHandles::resolve(name_handle));</span>

























 141   if (name.is_null()) {
<span class="line-modified"> 142     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
 143   }
<span class="line-modified"> 144   ResourceMark rm;</span>
<span class="line-modified"> 145   const char* cstring = java_lang_String::as_utf8_string(name());</span>
<span class="line-removed"> 146   JVMFlag* flag = JVMFlag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);</span>
 147   if (flag == NULL) {
 148     return c2vm;
 149   }
 150   if (flag-&gt;is_bool()) {
 151     jvalue prim;
 152     prim.z = flag-&gt;get_bool();
<span class="line-modified"> 153     oop box = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);</span>
<span class="line-modified"> 154     return JNIHandles::make_local(THREAD, box);</span>
 155   } else if (flag-&gt;is_ccstr()) {
<span class="line-modified"> 156     Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);</span>
<span class="line-modified"> 157     return JNIHandles::make_local(THREAD, value());</span>
 158   } else if (flag-&gt;is_intx()) {
 159     RETURN_BOXED_LONG(flag-&gt;get_intx());
 160   } else if (flag-&gt;is_int()) {
 161     RETURN_BOXED_LONG(flag-&gt;get_int());
 162   } else if (flag-&gt;is_uint()) {
 163     RETURN_BOXED_LONG(flag-&gt;get_uint());
 164   } else if (flag-&gt;is_uint64_t()) {
 165     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 166   } else if (flag-&gt;is_size_t()) {
 167     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 168   } else if (flag-&gt;is_uintx()) {
 169     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 170   } else if (flag-&gt;is_double()) {
 171     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 172   } else {
 173     JVMCI_ERROR_NULL(&quot;VM flag %s has unsupported type %s&quot;, flag-&gt;_name, flag-&gt;_type);
 174   }
 175 #undef RETURN_BOXED_LONG
 176 #undef RETURN_BOXED_DOUBLE
 177 C2V_END
 178 
<span class="line-modified"> 179 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 180   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
<span class="line-modified"> 181   ResourceMark rm;</span>











 182 
 183   int code_size = method-&gt;code_size();
<span class="line-modified"> 184   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);</span>
 185 
 186   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), &quot;Method&#39;s holder should be rewritten&quot;);
 187   // iterate over all bytecodes and replace non-Java bytecodes
 188 
 189   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 190     Bytecodes::Code code = s.code();
 191     Bytecodes::Code raw_code = s.raw_code();
 192     int bci = s.bci();
 193     int len = s.instruction_size();
 194 
 195     // Restore original byte code.
<span class="line-modified"> 196     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));</span>
 197     if (len &gt; 1) {
<span class="line-modified"> 198       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);</span>
 199     }
 200 
 201     if (len &gt; 1) {
 202       // Restore the big-endian constant pool indexes.
 203       // Cf. Rewriter::scan_method
 204       switch (code) {
 205         case Bytecodes::_getstatic:
 206         case Bytecodes::_putstatic:
 207         case Bytecodes::_getfield:
 208         case Bytecodes::_putfield:
 209         case Bytecodes::_invokevirtual:
 210         case Bytecodes::_invokespecial:
 211         case Bytecodes::_invokestatic:
 212         case Bytecodes::_invokeinterface:
 213         case Bytecodes::_invokehandle: {
<span class="line-modified"> 214           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));</span>
<span class="line-modified"> 215           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);</span>
 216           break;
 217         }
 218 
 219         case Bytecodes::_invokedynamic: {
<span class="line-modified"> 220           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));</span>
<span class="line-modified"> 221           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);</span>
 222           break;
 223         }
 224 
 225         default:
 226           break;
 227       }
 228 
 229       // Not all ldc byte code are rewritten.
 230       switch (raw_code) {
 231         case Bytecodes::_fast_aldc: {
<span class="line-modified"> 232           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;</span>
 233           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 234           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
<span class="line-modified"> 235           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);</span>
 236           break;
 237         }
 238 
 239         case Bytecodes::_fast_aldc_w: {
<span class="line-modified"> 240           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));</span>
 241           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 242           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
<span class="line-modified"> 243           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);</span>
 244           break;
 245         }
 246 
 247         default:
 248           break;
 249       }
 250     }
 251   }
 252 
<span class="line-modified"> 253   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);</span>


 254 C2V_END
 255 
<span class="line-modified"> 256 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 257   ResourceMark rm;</span>
<span class="line-removed"> 258   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
 259   return method-&gt;exception_table_length();
 260 C2V_END
 261 
<span class="line-modified"> 262 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 263   ResourceMark rm;</span>
<span class="line-removed"> 264   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
 265   if (method-&gt;exception_table_length() == 0) {
 266     return 0L;
 267   }
 268   return (jlong) (address) method-&gt;exception_table_start();
 269 C2V_END
 270 
<span class="line-modified"> 271 C2V_VMENTRY(jobject, asResolvedJavaMethod, (JNIEnv *, jobject, jobject executable_handle))</span>

 272   oop executable = JNIHandles::resolve(executable_handle);
 273   oop mirror = NULL;
 274   int slot = 0;
 275 
 276   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 277     mirror = java_lang_reflect_Constructor::clazz(executable);
 278     slot = java_lang_reflect_Constructor::slot(executable);
 279   } else {
 280     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 281     mirror = java_lang_reflect_Method::clazz(executable);
 282     slot = java_lang_reflect_Method::slot(executable);
 283   }
 284   Klass* holder = java_lang_Class::as_Klass(mirror);
<span class="line-modified"> 285   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);</span>
<span class="line-modified"> 286   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);</span>
<span class="line-modified"> 287   return JNIHandles::make_local(THREAD, result);</span>
 288 }
 289 
<span class="line-modified"> 290 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))</span>
<span class="line-modified"> 291   methodHandle method;</span>
<span class="line-modified"> 292   oop base_object = JNIHandles::resolve(base);</span>
<span class="line-modified"> 293   if (base_object == NULL) {</span>
 294     method = *((Method**)(offset));
<span class="line-modified"> 295   } else if (base_object-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {</span>
<span class="line-modified"> 296     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);</span>
<span class="line-modified"> 297   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {</span>
<span class="line-modified"> 298     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));</span>
<span class="line-modified"> 299   } else {</span>
<span class="line-modified"> 300     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-modified"> 301                 err_msg(&quot;Unexpected type: %s&quot;, base_object-&gt;klass()-&gt;external_name()));</span>


 302   }
<span class="line-modified"> 303   assert (method.is_null() || method-&gt;is_method(), &quot;invalid read&quot;);</span>
<span class="line-modified"> 304   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);</span>
<span class="line-modified"> 305   return JNIHandles::make_local(THREAD, result);</span>



 306 }
 307 
<span class="line-modified"> 308 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject object_handle))</span>
<span class="line-modified"> 309   constantPoolHandle cp;</span>
<span class="line-modified"> 310   oop object = JNIHandles::resolve(object_handle);</span>
<span class="line-modified"> 311   if (object == NULL) {</span>
<span class="line-modified"> 312     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
 313   }
<span class="line-modified"> 314   if (object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {</span>
<span class="line-modified"> 315     cp = CompilerToVM::asMethod(object)-&gt;constMethod()-&gt;constants();</span>
<span class="line-modified"> 316   } else if (object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {</span>
<span class="line-modified"> 317     cp = InstanceKlass::cast(CompilerToVM::asKlass(object))-&gt;constants();</span>
 318   } else {
<span class="line-modified"> 319     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-modified"> 320                 err_msg(&quot;Unexpected type: %s&quot;, object-&gt;klass()-&gt;external_name()));</span>
<span class="line-modified"> 321   }</span>
<span class="line-modified"> 322   assert(!cp.is_null(), &quot;npe&quot;);</span>
<span class="line-modified"> 323   JavaValue method_result(T_OBJECT);</span>
<span class="line-modified"> 324   JavaCallArguments args;</span>
<span class="line-modified"> 325   args.push_long((jlong) (address) cp());</span>
<span class="line-removed"> 326   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);</span>
<span class="line-removed"> 327   return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());</span>
 328 }
 329 
<span class="line-modified"> 330 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))</span>
 331   JVMCIKlassHandle klass(THREAD);
<span class="line-modified"> 332   oop base_object = JNIHandles::resolve(base);</span>
 333   jlong base_address = 0;
<span class="line-modified"> 334   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {</span>
<span class="line-modified"> 335     klass = base_object-&gt;klass();</span>






 336   } else if (!compressed) {
<span class="line-modified"> 337     if (base_object != NULL) {</span>
<span class="line-modified"> 338       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {</span>
<span class="line-modified"> 339         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);</span>
<span class="line-modified"> 340       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {</span>
<span class="line-modified"> 341         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);</span>
<span class="line-modified"> 342       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {</span>
<span class="line-modified"> 343         base_address = (jlong) CompilerToVM::asKlass(base_object);</span>
<span class="line-modified"> 344       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {</span>
<span class="line-modified"> 345         base_address = (jlong) (address) base_object;</span>
<span class="line-modified"> 346       } else {</span>
<span class="line-modified"> 347         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-modified"> 348                     err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;, base_object-&gt;klass()-&gt;external_name(), offset, compressed ? &quot;true&quot; : &quot;false&quot;));</span>




 349       }
 350     }
 351     klass = *((Klass**) (intptr_t) (base_address + offset));
 352   } else {
<span class="line-modified"> 353     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
 354                 err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;,
<span class="line-modified"> 355                         base_object != NULL ? base_object-&gt;klass()-&gt;external_name() : &quot;null&quot;,</span>
 356                         offset, compressed ? &quot;true&quot; : &quot;false&quot;));
 357   }
 358   assert (klass == NULL || klass-&gt;is_klass(), &quot;invalid read&quot;);
<span class="line-modified"> 359   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);</span>
<span class="line-modified"> 360   return JNIHandles::make_local(THREAD, result);</span>
 361 }
 362 
<span class="line-modified"> 363 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))</span>
<span class="line-modified"> 364   ResourceMark rm;</span>
<span class="line-modified"> 365   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
<span class="line-removed"> 366   Klass* holder = CompilerToVM::asKlass(jvmci_type);</span>
 367   if (holder-&gt;is_interface()) {
<span class="line-modified"> 368     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Interface %s should be handled in Java code&quot;, holder-&gt;external_name()));</span>



 369   }
 370 
 371   methodHandle ucm;
 372   {
 373     MutexLocker locker(Compile_lock);
<span class="line-modified"> 374     ucm = Dependencies::find_unique_concrete_method(holder, method());</span>
 375   }
<span class="line-modified"> 376   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);</span>
<span class="line-modified"> 377   return JNIHandles::make_local(THREAD, result);</span>
 378 C2V_END
 379 
<span class="line-modified"> 380 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))</span>
<span class="line-modified"> 381   Klass* klass = CompilerToVM::asKlass(jvmci_type);</span>
 382   if (!klass-&gt;is_interface()) {
 383     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 384         err_msg(&quot;Expected interface type, got %s&quot;, klass-&gt;external_name()));
 385   }
 386   InstanceKlass* iklass = InstanceKlass::cast(klass);
 387   JVMCIKlassHandle handle(THREAD);
 388   {
 389     // Need Compile_lock around implementor()
 390     MutexLocker locker(Compile_lock);
 391     handle = iklass-&gt;implementor();
 392   }
<span class="line-modified"> 393   oop implementor = CompilerToVM::get_jvmci_type(handle, CHECK_NULL);</span>
<span class="line-modified"> 394   return JNIHandles::make_local(THREAD, implementor);</span>
 395 C2V_END
 396 
<span class="line-modified"> 397 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 398   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
 399   return method-&gt;is_ignored_by_security_stack_walk();
 400 C2V_END
 401 
<span class="line-modified"> 402 C2V_VMENTRY(jboolean, isCompilable,(JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 403   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
<span class="line-modified"> 404   constantPoolHandle cp = method-&gt;constMethod()-&gt;constants();</span>
<span class="line-modified"> 405   assert(!cp.is_null(), &quot;npe&quot;);</span>
 406   // don&#39;t inline method when constant pool contains a CONSTANT_Dynamic
 407   return !method-&gt;is_not_compilable(CompLevel_full_optimization) &amp;&amp; !cp-&gt;has_dynamic_constant();
 408 C2V_END
 409 
<span class="line-modified"> 410 C2V_VMENTRY(jboolean, hasNeverInlineDirective,(JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 411   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
 412   return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 413 C2V_END
 414 
<span class="line-modified"> 415 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 416   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
 417   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 418 C2V_END
 419 
<span class="line-modified"> 420 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))</span>
<span class="line-modified"> 421   ResourceMark rm;</span>
<span class="line-modified"> 422   Handle name(THREAD, JNIHandles::resolve(jname));</span>
<span class="line-modified"> 423   Symbol* class_name = java_lang_String::as_symbol(name(), CHECK_0);</span>
<span class="line-modified"> 424   if (java_lang_String::length(name()) &lt;= 1) {</span>
<span class="line-modified"> 425     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Primitive type %s should be handled in Java code&quot;, class_name-&gt;as_C_string()));</span>

 426   }
 427 
 428   JVMCIKlassHandle resolved_klass(THREAD);
<span class="line-modified"> 429   if (JNIHandles::resolve(accessing_class) == NULL) {</span>
<span class="line-modified"> 430     THROW_0(vmSymbols::java_lang_NullPointerException());</span>









 431   }
<span class="line-removed"> 432   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));</span>
<span class="line-removed"> 433   Handle class_loader(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-removed"> 434   Handle protection_domain(THREAD, accessing_klass-&gt;protection_domain());</span>
 435 
 436   if (resolve) {
 437     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);



 438   } else {
<span class="line-modified"> 439     if (class_name-&gt;char_at(0) == &#39;L&#39; &amp;&amp;</span>
<span class="line-removed"> 440       class_name-&gt;char_at(class_name-&gt;utf8_length()-1) == &#39;;&#39;) {</span>
 441       // This is a name from a signature.  Strip off the trimmings.
 442       // Call recursive to keep scope of strippedsym.
<span class="line-modified"> 443       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,</span>
<span class="line-removed"> 444                                                           class_name-&gt;utf8_length()-2,</span>
<span class="line-removed"> 445                                                           CHECK_0);</span>
 446       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
<span class="line-modified"> 447     } else if (FieldType::is_array(class_name)) {</span>
<span class="line-modified"> 448       FieldArrayInfo fd;</span>
<span class="line-modified"> 449       // dimension and object_key in FieldArrayInfo are assigned as a side-effect</span>
<span class="line-modified"> 450       // of this call</span>
<span class="line-modified"> 451       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);</span>
<span class="line-removed"> 452       if (t == T_OBJECT) {</span>
<span class="line-removed"> 453         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),</span>
<span class="line-removed"> 454                                                             class_name-&gt;utf8_length()-2-fd.dimension(),</span>
<span class="line-removed"> 455                                                             CHECK_0);</span>
<span class="line-removed"> 456         // naked oop &quot;k&quot; is OK here -- we assign back into it</span>
 457         resolved_klass = SystemDictionary::find(strippedsym,
<span class="line-modified"> 458                                                              class_loader,</span>
<span class="line-modified"> 459                                                              protection_domain,</span>
<span class="line-modified"> 460                                                              CHECK_0);</span>
 461         if (!resolved_klass.is_null()) {
<span class="line-modified"> 462           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);</span>
 463         }
 464       } else {
<span class="line-modified"> 465         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(t))-&gt;array_klass(fd.dimension(), CHECK_0);</span>
 466       }


 467     }
 468   }
<span class="line-modified"> 469   oop result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);</span>
<span class="line-modified"> 470   return JNIHandles::make_local(THREAD, result);</span>
 471 C2V_END
 472 
<span class="line-modified"> 473 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 474   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
<span class="line-modified"> 475   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);</span>
<span class="line-modified"> 476   return JNIHandles::make_local(THREAD, result);</span>





















 477 C2V_END
 478 
<span class="line-modified"> 479 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 480   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>














 481   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
<span class="line-modified"> 482   return JNIHandles::make_local(THREAD, result);</span>
 483 C2V_END
 484 
<span class="line-modified"> 485 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 486   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
 487   return cp-&gt;name_and_type_ref_index_at(index);
 488 C2V_END
 489 
<span class="line-modified"> 490 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))</span>
<span class="line-modified"> 491   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
<span class="line-modified"> 492   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);</span>
<span class="line-modified"> 493   return JNIHandles::make_local(THREAD, sym());</span>
 494 C2V_END
 495 
<span class="line-modified"> 496 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))</span>
<span class="line-modified"> 497   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
<span class="line-modified"> 498   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);</span>
<span class="line-modified"> 499   return JNIHandles::make_local(THREAD, sym());</span>
 500 C2V_END
 501 
<span class="line-modified"> 502 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 503   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
 504   return cp-&gt;klass_ref_index_at(index);
 505 C2V_END
 506 
<span class="line-modified"> 507 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 508   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
 509   Klass* klass = cp-&gt;klass_at(index, CHECK_NULL);
 510   JVMCIKlassHandle resolved_klass(THREAD, klass);
 511   if (resolved_klass-&gt;is_instance_klass()) {
<span class="line-modified"> 512     InstanceKlass::cast(resolved_klass())-&gt;link_class_or_fail(THREAD);</span>




 513   }
<span class="line-modified"> 514   oop jvmci_type = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);</span>
<span class="line-modified"> 515   return JNIHandles::make_local(THREAD, jvmci_type);</span>
 516 C2V_END
 517 
<span class="line-modified"> 518 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))</span>
<span class="line-modified"> 519   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
 520   Klass* loading_klass = cp-&gt;pool_holder();
 521   bool is_accessible = false;
<span class="line-modified"> 522   JVMCIKlassHandle klass(THREAD, JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass));</span>
 523   Symbol* symbol = NULL;
<span class="line-modified"> 524   if (klass == NULL) {</span>
<span class="line-modified"> 525     symbol = cp-&gt;klass_name_at(index);</span>










 526   }
<span class="line-modified"> 527   oop result_oop;</span>
 528   if (!klass.is_null()) {
<span class="line-modified"> 529     result_oop = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);</span>
 530   } else {
<span class="line-modified"> 531     Handle result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);</span>
<span class="line-removed"> 532     result_oop = result();</span>
 533   }
<span class="line-modified"> 534   return JNIHandles::make_local(THREAD, result_oop);</span>
 535 C2V_END
 536 
<span class="line-modified"> 537 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 538   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
 539   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
<span class="line-modified"> 540   return JNIHandles::make_local(THREAD, appendix_oop);</span>
 541 C2V_END
 542 
<span class="line-modified"> 543 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))</span>
<span class="line-modified"> 544   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
 545   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 546   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
<span class="line-modified"> 547   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);</span>
<span class="line-modified"> 548   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);</span>
<span class="line-modified"> 549   return JNIHandles::make_local(THREAD, result);</span>
 550 C2V_END
 551 
<span class="line-modified"> 552 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 553   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
 554   return cp-&gt;remap_instruction_operand_from_cache(index);
 555 C2V_END
 556 
<span class="line-modified"> 557 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))</span>
<span class="line-modified"> 558   ResourceMark rm;</span>
<span class="line-removed"> 559   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
 560   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 561   fieldDescriptor fd;
<span class="line-modified"> 562   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);</span>

 563   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
<span class="line-modified"> 564   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);</span>
<span class="line-modified"> 565   if (info == NULL || info-&gt;length() != 3) {</span>
 566     JVMCI_ERROR_NULL(&quot;info must not be null and have a length of 3&quot;);
 567   }
<span class="line-modified"> 568   info-&gt;int_at_put(0, fd.access_flags().as_int());</span>
<span class="line-modified"> 569   info-&gt;int_at_put(1, fd.offset());</span>
<span class="line-modified"> 570   info-&gt;int_at_put(2, fd.index());</span>
 571   JVMCIKlassHandle handle(THREAD, fd.field_holder());
<span class="line-modified"> 572   oop field_holder = CompilerToVM::get_jvmci_type(handle, CHECK_NULL);</span>
<span class="line-modified"> 573   return JNIHandles::make_local(THREAD, field_holder);</span>
 574 C2V_END
 575 
<span class="line-modified"> 576 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))</span>
<span class="line-modified"> 577   ResourceMark rm;</span>
<span class="line-modified"> 578   Klass* klass = CompilerToVM::asKlass(jvmci_type);</span>
<span class="line-removed"> 579   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
 580   if (klass-&gt;is_interface()) {
<span class="line-modified"> 581     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Interface %s should be handled in Java code&quot;, klass-&gt;external_name()));</span>
 582   }
 583   if (!method-&gt;method_holder()-&gt;is_interface()) {
<span class="line-modified"> 584     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Method %s is not held by an interface, this case should be handled in Java code&quot;, method-&gt;name_and_sig_as_C_string()));</span>



 585   }
 586   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
<span class="line-modified"> 587     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Class %s must be linked&quot;, klass-&gt;external_name()));</span>
 588   }
 589   return LinkResolver::vtable_index_of_interface_method(klass, method);
 590 C2V_END
 591 
<span class="line-modified"> 592 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))</span>
<span class="line-modified"> 593   Klass* recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);</span>
<span class="line-modified"> 594   Klass* caller_klass = CompilerToVM::asKlass(caller_jvmci_type);</span>
<span class="line-modified"> 595   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
 596 
 597   Klass* resolved     = method-&gt;method_holder();
 598   Symbol* h_name      = method-&gt;name();
 599   Symbol* h_signature = method-&gt;signature();
 600 
 601   if (MethodHandles::is_signature_polymorphic_method(method())) {
 602       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 603       return NULL;
 604   }
 605 
 606   if (method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 607       resolved == SystemDictionary::Object_klass() &amp;&amp;
 608       recv_klass-&gt;is_array_klass()) {
 609     // Resolution of the clone method on arrays always returns Object.clone even though that method
 610     // has protected access.  There&#39;s some trickery in the access checking to make this all work out
 611     // so it&#39;s necessary to pass in the array class as the resolved class to properly trigger this.
 612     // Otherwise it&#39;s impossible to resolve the array clone methods through JVMCI.  See
 613     // LinkResolver::check_method_accessability for the matching logic.
 614     resolved = recv_klass;
 615   }
 616 
 617   LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
<span class="line-modified"> 618   methodHandle m;</span>
 619   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 620   // the vtable has not been setup, and the LinkResolver will fail.
 621   if (recv_klass-&gt;is_array_klass() ||
 622       (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
 623     if (resolved-&gt;is_interface()) {
 624       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 625     } else {
 626       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 627     }
 628   }
 629 
<span class="line-modified"> 630   if (m.is_null()) {</span>
 631     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 632     return NULL;
 633   }
 634 
<span class="line-modified"> 635   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);</span>
<span class="line-modified"> 636   return JNIHandles::make_local(THREAD, result);</span>
 637 C2V_END
 638 
<span class="line-modified"> 639 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))</span>
<span class="line-modified"> 640   Klass* klass = CompilerToVM::asKlass(jvmci_type);</span>
 641   assert(klass != NULL, &quot;method must not be called for primitive types&quot;);
 642   return Dependencies::find_finalizable_subclass(klass) != NULL;
 643 C2V_END
 644 
<span class="line-modified"> 645 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))</span>
<span class="line-modified"> 646   Klass* klass = CompilerToVM::asKlass(jvmci_type);</span>
 647   if (!klass-&gt;is_instance_klass()) {
 648     return NULL;
 649   }
 650   InstanceKlass* iklass = InstanceKlass::cast(klass);
<span class="line-modified"> 651   oop result = CompilerToVM::get_jvmci_method(iklass-&gt;class_initializer(), CHECK_NULL);</span>
<span class="line-modified"> 652   return JNIHandles::make_local(THREAD, result);</span>

 653 C2V_END
 654 
<span class="line-modified"> 655 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))</span>
 656   address target_addr = (address) addr;
 657   if (target_addr != 0x0) {
 658     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 659     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 660     return MAX2(ABS(off_low), ABS(off_high));
 661   }
 662   return -1;
 663 C2V_END
 664 
<span class="line-modified"> 665 C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv *, jobject,  jobject jvmci_method))</span>
<span class="line-modified"> 666   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
 667   method-&gt;set_not_c1_compilable();
 668   method-&gt;set_not_c2_compilable();
 669   method-&gt;set_dont_inline(true);
 670 C2V_END
 671 
<span class="line-modified"> 672 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))</span>
<span class="line-modified"> 673   ResourceMark rm;</span>
 674   HandleMark hm;
<span class="line-modified"> 675   JNIHandleMark jni_hm;</span>
 676 
<span class="line-modified"> 677   Handle target_handle(THREAD, JNIHandles::resolve(target));</span>
<span class="line-modified"> 678   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));</span>
 679   CodeBlob* cb = NULL;
<span class="line-modified"> 680   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));</span>
<span class="line-modified"> 681   Handle speculation_log_handle(THREAD, JNIHandles::resolve(speculation_log));</span>




 682 
 683   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
 684 
 685   TraceTime install_time(&quot;installCode&quot;, JVMCICompiler::codeInstallTimer());
<span class="line-modified"> 686   bool is_immutable_PIC = HotSpotCompiledCode::isImmutablePIC(compiled_code_handle) &gt; 0;</span>
<span class="line-modified"> 687   CodeInstaller installer(is_immutable_PIC);</span>
<span class="line-modified"> 688   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);</span>









 689 
 690   if (PrintCodeCacheOnCompilation) {
 691     stringStream s;
<span class="line-modified"> 692     // Dump code cache  into a buffer before locking the tty,</span>
 693     {
<span class="line-modified"> 694       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
 695       CodeCache::print_summary(&amp;s, false);
 696     }
 697     ttyLocker ttyl;
 698     tty-&gt;print_raw_cr(s.as_string());
 699   }
 700 
<span class="line-modified"> 701   if (result != JVMCIEnv::ok) {</span>
 702     assert(cb == NULL, &quot;should be&quot;);
 703   } else {
<span class="line-modified"> 704     if (installed_code_handle.not_null()) {</span>
<span class="line-modified"> 705       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), &quot;wrong type&quot;);</span>
<span class="line-modified"> 706       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);</span>
<span class="line-modified"> 707       {</span>
<span class="line-modified"> 708         // Ensure that all updates to the InstalledCode fields are consistent.</span>
<span class="line-modified"> 709         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified"> 710         InstalledCode::set_address(installed_code_handle, (jlong) cb);</span>
<span class="line-modified"> 711         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);</span>
<span class="line-removed"> 712         if (cb-&gt;is_nmethod()) {</span>
<span class="line-removed"> 713           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());</span>
<span class="line-removed"> 714         } else {</span>
<span class="line-removed"> 715           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());</span>
<span class="line-removed"> 716         }</span>
<span class="line-removed"> 717         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {</span>
<span class="line-removed"> 718           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());</span>
<span class="line-removed"> 719           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());</span>
<span class="line-removed"> 720           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());</span>
<span class="line-removed"> 721         }</span>
 722       }


 723     }
 724   }
 725   return result;
 726 C2V_END
 727 
<span class="line-modified"> 728 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))</span>
 729 #if INCLUDE_AOT
<span class="line-removed"> 730   ResourceMark rm;</span>
 731   HandleMark hm;

 732 
<span class="line-modified"> 733   Handle target_handle(THREAD, JNIHandles::resolve(target));</span>
<span class="line-modified"> 734   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));</span>
<span class="line-modified"> 735   Handle metadata_handle(THREAD, JNIHandles::resolve(metadata));</span>
 736 
 737   CodeMetadata code_metadata;
<span class="line-removed"> 738   CodeBlob *cb = NULL;</span>
<span class="line-removed"> 739   CodeInstaller installer(true /* immutable PIC compilation */);</span>
 740 
<span class="line-modified"> 741   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);</span>
<span class="line-modified"> 742   if (result != JVMCIEnv::ok) {</span>

 743     return result;
 744   }
 745 
 746   if (code_metadata.get_nr_pc_desc() &gt; 0) {
<span class="line-modified"> 747     typeArrayHandle pcArrayOop = oopFactory::new_byteArray_handle(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-modified"> 748     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());</span>
<span class="line-modified"> 749     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());</span>

 750   }
 751 
 752   if (code_metadata.get_scopes_size() &gt; 0) {
<span class="line-modified"> 753     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray_handle(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-modified"> 754     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());</span>
<span class="line-modified"> 755     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());</span>

 756   }
 757 
 758   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
<span class="line-modified"> 759   typeArrayHandle relocArrayOop = oopFactory::new_byteArray_handle((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-modified"> 760   if (reloc_buffer-&gt;size() &gt; 0) {</span>
<span class="line-modified"> 761     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());</span>
<span class="line-modified"> 762   }</span>
<span class="line-removed"> 763   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());</span>
 764 
 765   const OopMapSet* oopMapSet = installer.oopMapSet();
 766   {
 767     ResourceMark mark;
 768     ImmutableOopMapBuilder builder(oopMapSet);
<span class="line-modified"> 769     int oopmap_size = builder.heap_size();</span>
<span class="line-modified"> 770     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray_handle(oopmap_size, CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-modified"> 771     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));</span>
<span class="line-modified"> 772     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());</span>
 773   }
 774 
 775   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
 776 
 777   int nr_meta_refs = recorder-&gt;nr_meta_refs();
<span class="line-modified"> 778   objArrayOop metadataArray = oopFactory::new_objectArray(nr_meta_refs, CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-removed"> 779   objArrayHandle metadataArrayHandle(THREAD, metadataArray);</span>
 780   for (int i = 0; i &lt; nr_meta_refs; ++i) {
 781     jobject element = recorder-&gt;meta_element(i);
 782     if (element == NULL) {
<span class="line-modified"> 783       return JVMCIEnv::cache_full;</span>
 784     }
<span class="line-modified"> 785     metadataArrayHandle-&gt;obj_at_put(i, JNIHandles::resolve(element));</span>
 786   }
<span class="line-modified"> 787   HotSpotMetaData::set_metadata(metadata_handle, metadataArrayHandle());</span>
 788 
 789   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 790   int table_size = handler-&gt;size_in_bytes();
<span class="line-modified"> 791   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray_handle(table_size, CHECK_(JVMCIEnv::cache_full));</span>
<span class="line-removed"> 792 </span>
 793   if (table_size &gt; 0) {
<span class="line-modified"> 794     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));</span>
 795   }
<span class="line-modified"> 796   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());</span>








 797 
 798   return result;
 799 #else
<span class="line-modified"> 800   THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;unimplemented&quot;);</span>
 801 #endif
 802 C2V_END
 803 
<span class="line-modified"> 804 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))</span>
 805   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
 806   CompilerStatistics* stats = compiler-&gt;stats();
 807   stats-&gt;_standard.reset();
 808   stats-&gt;_osr.reset();
 809 C2V_END
 810 
<span class="line-modified"> 811 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))</span>
<span class="line-removed"> 812   ResourceMark rm;</span>
 813   HandleMark hm;
 814 
 815   if (installedCode == NULL) {
<span class="line-modified"> 816     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), &quot;installedCode is null&quot;);</span>
<span class="line-removed"> 817   }</span>
<span class="line-removed"> 818 </span>
<span class="line-removed"> 819   jlong codeBlob = InstalledCode::address(installedCode);</span>
<span class="line-removed"> 820   if (codeBlob == 0L) {</span>
<span class="line-removed"> 821     return NULL;</span>
 822   }
 823 
<span class="line-modified"> 824   CodeBlob* cb = (CodeBlob*) (address) codeBlob;</span>


 825   if (cb == NULL) {
 826     return NULL;
 827   }
 828 
 829   // We don&#39;t want the stringStream buffer to resize during disassembly as it
 830   // uses scoped resource memory. If a nested function called during disassembly uses
 831   // a ResourceMark and the buffer expands within the scope of the mark,
 832   // the buffer becomes garbage when that scope is exited. Experience shows that
 833   // the disassembled code is typically about 10x the code size so a fixed buffer
 834   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 835   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 836   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 837   stringStream st(buffer, bufferSize);
 838   if (cb-&gt;is_nmethod()) {
 839     nmethod* nm = (nmethod*) cb;
 840     if (!nm-&gt;is_alive()) {
 841       return NULL;
 842     }
 843   }
 844   Disassembler::decode(cb, &amp;st);
 845   if (st.size() &lt;= 0) {
 846     return NULL;
 847   }
 848 
<span class="line-modified"> 849   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);</span>
<span class="line-modified"> 850   return JNIHandles::make_local(THREAD, result());</span>
 851 C2V_END
 852 
<span class="line-modified"> 853 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))</span>
<span class="line-removed"> 854   ResourceMark rm;</span>
 855   HandleMark hm;
 856 
<span class="line-modified"> 857   methodHandle method = CompilerToVM::asMethod(jvmci_method);</span>
<span class="line-modified"> 858   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);</span>
<span class="line-modified"> 859   return JNIHandles::make_local(THREAD, element);</span>
 860 C2V_END
 861 
<span class="line-modified"> 862 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))</span>
<span class="line-modified"> 863   ResourceMark rm;</span>



 864   HandleMark hm;
 865 
<span class="line-modified"> 866   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);</span>
<span class="line-modified"> 867   if (nmethodValue == 0L) {</span>
<span class="line-modified"> 868     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());</span>


 869   }
<span class="line-modified"> 870   nmethod* nm = (nmethod*) (address) nmethodValue;</span>
<span class="line-removed"> 871   methodHandle mh = nm-&gt;method();</span>
 872   Symbol* signature = mh-&gt;signature();
 873   JavaCallArguments jca(mh-&gt;size_of_parameters());
 874 
 875   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
<span class="line-modified"> 876   JavaValue result(jap.get_ret_type());</span>
 877   jca.set_alternative_target(nm);
 878   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
 879 
<span class="line-modified"> 880   if (jap.get_ret_type() == T_VOID) {</span>
 881     return NULL;
<span class="line-modified"> 882   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {</span>
<span class="line-modified"> 883     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());</span>
 884   } else {
 885     jvalue *value = (jvalue *) result.get_value_addr();
 886     // Narrow the value down if required (Important on big endian machines)
<span class="line-modified"> 887     switch (jap.get_ret_type()) {</span>
 888       case T_BOOLEAN:
 889        value-&gt;z = (jboolean) value-&gt;i;
 890        break;
 891       case T_BYTE:
 892        value-&gt;b = (jbyte) value-&gt;i;
 893        break;
 894       case T_CHAR:
 895        value-&gt;c = (jchar) value-&gt;i;
 896        break;
 897       case T_SHORT:
 898        value-&gt;s = (jshort) value-&gt;i;
 899        break;
 900       default:
 901         break;
 902     }
<span class="line-modified"> 903     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);</span>
<span class="line-modified"> 904     return JNIHandles::make_local(THREAD, o);</span>
 905   }
 906 C2V_END
 907 
<span class="line-modified"> 908 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 909   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
 910   if (!method-&gt;has_linenumber_table()) {
 911     return NULL;
 912   }
 913   u2 num_entries = 0;
 914   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
 915   while (streamForSize.read_pair()) {
 916     num_entries++;
 917   }
 918 
 919   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
<span class="line-modified"> 920   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);</span>
 921 
 922   int i = 0;
 923   jlong value;
 924   while (stream.read_pair()) {
 925     value = ((long) stream.bci());
<span class="line-modified"> 926     result-&gt;long_at_put(i, value);</span>
 927     value = ((long) stream.line());
<span class="line-modified"> 928     result-&gt;long_at_put(i + 1, value);</span>
 929     i += 2;
 930   }
 931 
<span class="line-modified"> 932   return (jlongArray) JNIHandles::make_local(THREAD, result);</span>
 933 C2V_END
 934 
<span class="line-modified"> 935 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 936   ResourceMark rm;</span>
<span class="line-removed"> 937   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
 938   if (!method-&gt;has_localvariable_table()) {
 939     return 0;
 940   }
 941   return (jlong) (address) method-&gt;localvariable_table_start();
 942 C2V_END
 943 
<span class="line-modified"> 944 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 945   ResourceMark rm;</span>
<span class="line-removed"> 946   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
 947   return method-&gt;localvariable_table_length();
 948 C2V_END
 949 
<span class="line-modified"> 950 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 951   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
 952   MethodCounters* mcs = method-&gt;method_counters();
 953   if (mcs != NULL) {
 954     mcs-&gt;clear_counters();
 955   }
 956   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
 957 
 958   CompiledMethod* code = method-&gt;code();
 959   if (code != NULL) {
 960     code-&gt;make_not_entrant();
 961   }
 962 
 963   MethodData* method_data = method-&gt;method_data();
 964   if (method_data == NULL) {
 965     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
 966     method_data = MethodData::allocate(loader_data, method, CHECK);
 967     method-&gt;set_method_data(method_data);
 968   } else {
 969     method_data-&gt;initialize();
 970   }
 971 C2V_END
 972 
 973 
<span class="line-modified"> 974 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))</span>
<span class="line-modified"> 975   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));</span>
<span class="line-modified"> 976   nmethod::invalidate_installed_code(installed_code_handle, CHECK);</span>




















 977 C2V_END
 978 
<span class="line-modified"> 979 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))</span>
<span class="line-modified"> 980   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);</span>
<span class="line-removed"> 981   JavaThread::collect_counters(arrayOop);</span>
<span class="line-removed"> 982   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);</span>
 983 C2V_END
 984 
<span class="line-modified"> 985 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))</span>
 986   HandleMark hm;
<span class="line-modified"> 987   ResourceMark rm;</span>
<span class="line-modified"> 988   if (JNIHandles::resolve(jvmci_method) == NULL) {</span>
<span class="line-removed"> 989     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
 990   }
<span class="line-modified"> 991   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
 992   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
<span class="line-modified"> 993     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;Unexpected bci %d&quot;, entry_bci));</span>
 994   }
 995   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
 996 C2V_END
 997 
 998 
<span class="line-modified"> 999 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))</span>
<span class="line-modified">1000   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);</span>
1001   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1002 C2V_END
1003 
<span class="line-modified">1004 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))</span>
<span class="line-modified">1005   Method* method = CompilerToVM::asMethod(jvmci_method);</span>
1006   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1007 C2V_END
1008 
<span class="line-modified">1009 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))</span>
<span class="line-modified">1010   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);</span>
<span class="line-modified">1011   return JNIHandles::make_local(THREAD, sym());</span>
1012 C2V_END
1013 
<span class="line-modified">1014 bool matches(jobjectArray methods, Method* method) {</span>
1015   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1016 
1017   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1018     oop resolved = methods_oop-&gt;obj_at(i);
<span class="line-modified">1019     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {</span>
1020       return true;
1021     }
1022   }
1023   return false;
1024 }
1025 
1026 void call_interface(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
1027   CallInfo callinfo;
1028   Handle receiver = args-&gt;receiver();
1029   Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
1030   LinkInfo link_info(spec_klass, name, signature);
1031   LinkResolver::resolve_interface_call(
1032           callinfo, receiver, recvrKlass, link_info, true, CHECK);
<span class="line-modified">1033   methodHandle method = callinfo.selected_method();</span>
1034   assert(method.not_null(), &quot;should have thrown exception&quot;);
1035 
1036   // Invoke the method
1037   JavaCalls::call(result, method, args, CHECK);
1038 }
1039 
<span class="line-modified">1040 C2V_VMENTRY(jobject, iterateFrames, (JNIEnv*, jobject compilerToVM, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, jobject visitor_handle))</span>
<span class="line-removed">1041   ResourceMark rm;</span>
1042 
1043   if (!thread-&gt;has_last_Java_frame()) {
1044     return NULL;
1045   }
1046   Handle visitor(THREAD, JNIHandles::resolve_non_null(visitor_handle));
<span class="line-removed">1047   Handle frame_reference = HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);</span>
<span class="line-removed">1048   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);</span>
1049 
<span class="line-modified">1050   StackFrameStream fst(thread);</span>



1051 

1052   jobjectArray methods = initial_methods;
1053 
1054   int frame_number = 0;
1055   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1056 
1057   while (true) {
1058     // look for the given method
1059     bool realloc_called = false;
1060     while (true) {
1061       StackValueCollection* locals = NULL;
1062       if (vf-&gt;is_compiled_frame()) {
1063         // compiled method frame
1064         compiledVFrame* cvf = compiledVFrame::cast(vf);
<span class="line-modified">1065         if (methods == NULL || matches(methods, cvf-&gt;method())) {</span>
1066           if (initialSkip &gt; 0) {
1067             initialSkip--;
1068           } else {
1069             ScopeDesc* scope = cvf-&gt;scope();
1070             // native wrappers do not have a scope
1071             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1072               GrowableArray&lt;ScopeValue*&gt;* objects;
1073               if (!realloc_called) {
1074                 objects = scope-&gt;objects();
1075               } else {
1076                 // some object might already have been re-allocated, only reallocate the non-allocated ones
1077                 objects = new GrowableArray&lt;ScopeValue*&gt;(scope-&gt;objects()-&gt;length());
1078                 for (int i = 0; i &lt; scope-&gt;objects()-&gt;length(); i++) {
1079                   ObjectValue* sv = (ObjectValue*) scope-&gt;objects()-&gt;at(i);
1080                   if (sv-&gt;value().is_null()) {
1081                     objects-&gt;append(sv);
1082                   }
1083                 }
1084               }
<span class="line-modified">1085               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), objects, CHECK_NULL);</span>
1086               Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);
1087               realloc_called = true;
1088 
1089               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1090               assert(local_values != NULL, &quot;NULL locals&quot;);
1091               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1092               typeArrayHandle array(THREAD, array_oop);
1093               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1094                 ScopeValue* value = local_values-&gt;at(i);
1095                 if (value-&gt;is_object()) {
1096                   array-&gt;bool_at_put(i, true);
1097                 }
1098               }
<span class="line-modified">1099               HotSpotStackFrameReference::set_localIsVirtual(frame_reference, array());</span>
1100             } else {
<span class="line-modified">1101               HotSpotStackFrameReference::set_localIsVirtual(frame_reference, NULL);</span>
1102             }
1103 
1104             locals = cvf-&gt;locals();
<span class="line-modified">1105             HotSpotStackFrameReference::set_bci(frame_reference, cvf-&gt;bci());</span>
<span class="line-modified">1106             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);</span>
<span class="line-modified">1107             HotSpotStackFrameReference::set_method(frame_reference, method);</span>

1108           }
1109         }
1110       } else if (vf-&gt;is_interpreted_frame()) {
1111         // interpreted method frame
1112         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
<span class="line-modified">1113         if (methods == NULL || matches(methods, ivf-&gt;method())) {</span>
1114           if (initialSkip &gt; 0) {
1115             initialSkip--;
1116           } else {
1117             locals = ivf-&gt;locals();
<span class="line-modified">1118             HotSpotStackFrameReference::set_bci(frame_reference, ivf-&gt;bci());</span>
<span class="line-modified">1119             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);</span>
<span class="line-modified">1120             HotSpotStackFrameReference::set_method(frame_reference, method);</span>
<span class="line-modified">1121             HotSpotStackFrameReference::set_localIsVirtual(frame_reference, NULL);</span>

1122           }
1123         }
1124       }
1125 
1126       // locals != NULL means that we found a matching frame and result is already partially initialized
1127       if (locals != NULL) {
1128         methods = match_methods;
<span class="line-modified">1129         HotSpotStackFrameReference::set_compilerToVM(frame_reference, JNIHandles::resolve(compilerToVM));</span>
<span class="line-modified">1130         HotSpotStackFrameReference::set_stackPointer(frame_reference, (jlong) fst.current()-&gt;sp());</span>
<span class="line-modified">1131         HotSpotStackFrameReference::set_frameNumber(frame_reference, frame_number);</span>
1132 
1133         // initialize the locals array
1134         objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
1135         objArrayHandle array(THREAD, array_oop);
1136         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1137           StackValue* var = locals-&gt;at(i);
1138           if (var-&gt;type() == T_OBJECT) {
1139             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1140           }
1141         }
<span class="line-modified">1142         HotSpotStackFrameReference::set_locals(frame_reference, array());</span>
<span class="line-modified">1143         HotSpotStackFrameReference::set_objectsMaterialized(frame_reference, JNI_FALSE);</span>
1144 
1145         JavaValue result(T_OBJECT);
1146         JavaCallArguments args(visitor);
1147         args.push_oop(frame_reference);
<span class="line-modified">1148         call_interface(&amp;result, SystemDictionary::InspectedFrameVisitor_klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &amp;args, CHECK_NULL);</span>
1149         if (result.get_jobject() != NULL) {
1150           return JNIHandles::make_local(thread, (oop) result.get_jobject());
1151         }
1152         assert(initialSkip == 0, &quot;There should be no match before initialSkip == 0&quot;);
<span class="line-modified">1153         if (HotSpotStackFrameReference::objectsMaterialized(frame_reference) == JNI_TRUE) {</span>
1154           // the frame has been deoptimized, we need to re-synchronize the frame and vframe
<span class="line-modified">1155           intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(frame_reference);</span>
1156           fst = StackFrameStream(thread);
1157           while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1158             fst.next();
1159           }
1160           if (fst.current()-&gt;sp() != stack_pointer) {
1161             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found after deopt&quot;)
1162           }
1163           vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1164           if (!vf-&gt;is_compiled_frame()) {
1165             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)
1166           }
1167           for (int i = 0; i &lt; frame_number; i++) {
1168             if (vf-&gt;is_top()) {
1169               THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;vframe not found after deopt&quot;)
1170             }
1171             vf = vf-&gt;sender();
1172             assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1173           }
1174         }
<span class="line-modified">1175         frame_reference = HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);</span>
<span class="line-modified">1176         HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);</span>
1177       }
1178 
1179       if (vf-&gt;is_top()) {
1180         break;
1181       }
1182       frame_number++;
1183       vf = vf-&gt;sender();
1184     } // end of vframe loop
1185 
1186     if (fst.is_done()) {
1187       break;
1188     }
1189     fst.next();
1190     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1191     frame_number = 0;
1192   } // end of frame loop
1193 
1194   // the end was reached without finding a matching method
1195   return NULL;
1196 C2V_END
1197 
<span class="line-modified">1198 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">1199   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
1200   CallInfo callInfo;
1201   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1202   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1203   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1204 C2V_END
1205 
<span class="line-modified">1206 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">1207   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
1208   Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
1209   Symbol* name = cp-&gt;name_ref_at(index);
1210   if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
1211     CallInfo callInfo;
1212     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1213     ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1214     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1215   }
1216 C2V_END
1217 
<span class="line-modified">1218 C2V_VMENTRY(jint, isResolvedInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">1219   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);</span>
1220   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1221   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
1222     // MethodHandle.invoke* --&gt; LambdaForm?
1223     ResourceMark rm;
1224 
1225     LinkInfo link_info(cp, index, CATCH);
1226 
1227     Klass* resolved_klass = link_info.resolved_klass();
1228 
1229     Symbol* name_sym = cp-&gt;name_ref_at(index);
1230 
1231     vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), &quot;!&quot;);
1232     vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), &quot;!&quot;);
1233 
<span class="line-modified">1234     methodHandle adapter_method(cp_cache_entry-&gt;f1_as_method());</span>
1235 
1236     methodHandle resolved_method(adapter_method);
1237 
1238     // Can we treat it as a regular invokevirtual?
1239     if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
1240       vmassert(!resolved_method-&gt;is_static(),&quot;!&quot;);
1241       vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),&quot;!&quot;);
1242       vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), &quot;!&quot;);
1243       vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, &quot;!&quot;);
1244 
<span class="line-modified">1245       methodHandle m(LinkResolver::linktime_resolve_virtual_method_or_null(link_info));</span>
1246       vmassert(m == resolved_method, &quot;!!&quot;);
1247       return -1;
1248     }
1249 
1250     return Bytecodes::_invokevirtual;
1251   }
1252   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokedynamic)) {
1253     return Bytecodes::_invokedynamic;
1254   }
1255   return -1;
1256 C2V_END
1257 
1258 
<span class="line-modified">1259 C2V_VMENTRY(jobject, getSignaturePolymorphicHolders, (JNIEnv*, jobject))</span>
<span class="line-modified">1260   objArrayHandle holders = oopFactory::new_objArray_handle(SystemDictionary::String_klass(), 2, CHECK_NULL);</span>
<span class="line-modified">1261   Handle mh = java_lang_String::create_from_str(&quot;Ljava/lang/invoke/MethodHandle;&quot;, CHECK_NULL);</span>
<span class="line-modified">1262   Handle vh = java_lang_String::create_from_str(&quot;Ljava/lang/invoke/VarHandle;&quot;, CHECK_NULL);</span>
<span class="line-modified">1263   holders-&gt;obj_at_put(0, mh());</span>
<span class="line-modified">1264   holders-&gt;obj_at_put(1, vh());</span>
<span class="line-modified">1265   return JNIHandles::make_local(THREAD, holders());</span>
1266 C2V_END
1267 
<span class="line-modified">1268 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))</span>
1269   //see compute_recording_non_safepoints in debugInfroRec.cpp
1270   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1271     return true;
1272   }
1273   return DebugNonSafepoints;
1274 C2V_END
1275 
1276 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
<span class="line-modified">1277 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))</span>
<span class="line-modified">1278   ResourceMark rm;</span>
<span class="line-modified">1279 </span>
<span class="line-modified">1280   if (hs_frame == NULL) {</span>
<span class="line-removed">1281     THROW_MSG(vmSymbols::java_lang_NullPointerException(), &quot;stack frame is null&quot;)</span>
1282   }
1283 
<span class="line-modified">1284   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK);</span>


1285 
1286   // look for the given stack frame
<span class="line-modified">1287   StackFrameStream fst(thread);</span>
<span class="line-modified">1288   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);</span>
1289   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1290     fst.next();
1291   }
1292   if (fst.current()-&gt;sp() != stack_pointer) {
<span class="line-modified">1293     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found&quot;)</span>
1294   }
1295 
1296   if (invalidate) {
1297     if (!fst.current()-&gt;is_compiled_frame()) {
<span class="line-modified">1298       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)</span>
1299     }
1300     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), &quot;nmethod expected&quot;);
1301     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1302   }
<span class="line-modified">1303   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);</span>
1304   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1305   StackFrameStream fstAfterDeopt(thread);
1306   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1307     fstAfterDeopt.next();
1308   }
1309   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
<span class="line-modified">1310     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found after deopt&quot;)</span>
1311   }
1312 
1313   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1314   if (!vf-&gt;is_compiled_frame()) {
<span class="line-modified">1315     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)</span>
1316   }
1317 
1318   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1319   while (true) {
1320     assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1321     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1322     if (vf-&gt;is_top()) {
1323       break;
1324     }
1325     vf = vf-&gt;sender();
1326   }
1327 
<span class="line-modified">1328   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);</span>
1329   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
<span class="line-modified">1330     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;invalid frame number&quot;)</span>
1331   }
1332 
1333   // Reallocate the non-escaping objects and restore their fields.
1334   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,&quot;invalid scope&quot;);
1335   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1336 
1337   if (objects == NULL) {
1338     // no objects to materialize
1339     return;
1340   }
1341 
<span class="line-modified">1342   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, CHECK);</span>
1343   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1344 
1345   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1346     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1347 
1348     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1349     StackValueCollection* locals = cvf-&gt;locals();
1350     if (locals != NULL) {
1351       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1352         StackValue* var = locals-&gt;at(i2);
1353         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1354           jvalue val;
<span class="line-modified">1355           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();</span>
1356           cvf-&gt;update_local(T_OBJECT, i2, val);
1357         }
1358       }
1359     }
1360 
1361     GrowableArray&lt;ScopeValue*&gt;* scopeExpressions = cvf-&gt;scope()-&gt;expressions();
1362     StackValueCollection* expressions = cvf-&gt;expressions();
1363     if (expressions != NULL) {
1364       for (int i2 = 0; i2 &lt; expressions-&gt;size(); i2++) {
1365         StackValue* var = expressions-&gt;at(i2);
1366         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeExpressions-&gt;at(i2)-&gt;is_object()) {
1367           jvalue val;
<span class="line-modified">1368           val.l = (jobject) expressions-&gt;at(i2)-&gt;get_obj()();</span>
1369           cvf-&gt;update_stack(T_OBJECT, i2, val);
1370         }
1371       }
1372     }
1373 
1374     GrowableArray&lt;MonitorValue*&gt;* scopeMonitors = cvf-&gt;scope()-&gt;monitors();
1375     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
1376     if (monitors != NULL) {
1377       for (int i2 = 0; i2 &lt; monitors-&gt;length(); i2++) {
1378         cvf-&gt;update_monitor(i2, monitors-&gt;at(i2));
1379       }
1380     }
1381   }
1382 
1383   // all locals are materialized by now
<span class="line-modified">1384   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);</span>
<span class="line-removed">1385 </span>
1386   // update the locals array
<span class="line-modified">1387   objArrayHandle array(THREAD, HotSpotStackFrameReference::locals(hs_frame));</span>
1388   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1389   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1390     StackValue* var = locals-&gt;at(i);
1391     if (var-&gt;type() == T_OBJECT) {
<span class="line-modified">1392       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());</span>
1393     }
1394   }
<span class="line-modified">1395   HotSpotStackFrameReference::set_objectsMaterialized(hs_frame, JNI_TRUE);</span>
1396 C2V_END
1397 
<span class="line-modified">1398 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))</span>















































1399   if (bytes == NULL) {
<span class="line-modified">1400     THROW(vmSymbols::java_lang_NullPointerException());</span>



1401   }
<span class="line-modified">1402   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);</span>
1403 
1404   // Check if offset and length are non negative.
1405   if (offset &lt; 0 || length &lt; 0) {
<span class="line-modified">1406     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span>



1407   }
1408   // Check if the range is valid.
<span class="line-modified">1409   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {</span>
<span class="line-modified">1410     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());</span>




1411   }

1412   while (length &gt; 0) {
<span class="line-modified">1413     jbyte* start = array-&gt;byte_at_addr(offset);</span>
<span class="line-modified">1414     tty-&gt;write((char*) start, MIN2(length, (jint)O_BUFLEN));</span>

1415     length -= O_BUFLEN;
1416     offset += O_BUFLEN;
1417   }




1418 C2V_END
1419 
<span class="line-modified">1420 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))</span>
1421   tty-&gt;flush();
1422 C2V_END
1423 
<span class="line-modified">1424 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))</span>
<span class="line-modified">1425   ResourceMark rm;</span>
<span class="line-removed">1426   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);</span>
1427   ProfileData* profile_data = mdo-&gt;data_at(position);
1428   if (mdo-&gt;is_valid(profile_data)) {
1429     return profile_data-&gt;size_in_bytes();
1430   }
1431   DataLayout* data    = mdo-&gt;extra_data_base();
1432   DataLayout* end   = mdo-&gt;extra_data_limit();
1433   for (;; data = mdo-&gt;next_extra(data)) {
1434     assert(data &lt; end, &quot;moved past end of extra data&quot;);
1435     profile_data = data-&gt;data_in();
1436     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1437       return profile_data-&gt;size_in_bytes();
1438     }
1439   }
<span class="line-modified">1440   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;Invalid profile data position %d&quot;, position));</span>
1441 C2V_END
1442 
<span class="line-modified">1443 C2V_VMENTRY(jlong, getFingerprint, (JNIEnv*, jobject, jlong metaspace_klass))</span>
1444 #if INCLUDE_AOT
<span class="line-modified">1445   Klass *k = CompilerToVM::asKlass(metaspace_klass);</span>
1446   if (k-&gt;is_instance_klass()) {
1447     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1448   } else {
1449     return 0;
1450   }
1451 #else
<span class="line-modified">1452   THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;unimplemented&quot;);</span>
1453 #endif
1454 C2V_END
1455 
<span class="line-modified">1456 C2V_VMENTRY(jobject, getHostClass, (JNIEnv*, jobject, jobject jvmci_type))</span>
<span class="line-modified">1457   InstanceKlass* k = InstanceKlass::cast(CompilerToVM::asKlass(jvmci_type));</span>
1458   InstanceKlass* host = k-&gt;unsafe_anonymous_host();
1459   JVMCIKlassHandle handle(THREAD, host);
<span class="line-modified">1460   oop result = CompilerToVM::get_jvmci_type(handle, CHECK_NULL);</span>
<span class="line-modified">1461   return JNIHandles::make_local(THREAD, result);</span>
1462 C2V_END
1463 
<span class="line-modified">1464 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))</span>



































































1465   if (bytecode_frame_handle == NULL) {
<span class="line-modified">1466     THROW_0(vmSymbols::java_lang_NullPointerException());</span>
1467   }
1468 
<span class="line-modified">1469   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);</span>
<span class="line-modified">1470   oop bytecode_frame = top_bytecode_frame;</span>
1471   int size = 0;
1472   int callee_parameters = 0;
1473   int callee_locals = 0;
<span class="line-modified">1474   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));</span>
<span class="line-modified">1475   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);</span>
1476 
<span class="line-modified">1477   while (bytecode_frame != NULL) {</span>
<span class="line-modified">1478     int locks = BytecodeFrame::numLocks(bytecode_frame);</span>
<span class="line-modified">1479     int temps = BytecodeFrame::numStack(bytecode_frame);</span>
<span class="line-modified">1480     bool is_top_frame = (bytecode_frame == top_bytecode_frame);</span>
<span class="line-modified">1481     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));</span>
1482 
1483     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1484                                                                  temps + callee_parameters,
1485                                                                  extra_args,
1486                                                                  locks,
1487                                                                  callee_parameters,
1488                                                                  callee_locals,
1489                                                                  is_top_frame);
1490     size += frame_size;
1491 
1492     callee_parameters = method-&gt;size_of_parameters();
1493     callee_locals = method-&gt;max_locals();
1494     extra_args = 0;
<span class="line-modified">1495     bytecode_frame = BytecodePosition::caller(bytecode_frame);</span>
1496   }
1497   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1498 C2V_END
1499 
<span class="line-modified">1500 C2V_VMENTRY(void, compileToBytecode, (JNIEnv*, jobject, jobject lambda_form_handle))</span>
<span class="line-modified">1501   Handle lambda_form(THREAD, JNIHandles::resolve_non_null(lambda_form_handle));</span>
1502   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
<span class="line-modified">1503     TempNewSymbol compileToBytecode = SymbolTable::new_symbol(&quot;compileToBytecode&quot;, CHECK);</span>
1504     JavaValue result(T_VOID);
1505     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1506   } else {
<span class="line-modified">1507     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-modified">1508                 err_msg(&quot;Unexpected type: %s&quot;, lambda_form-&gt;klass()-&gt;external_name()));</span>
1509   }
1510 C2V_END
1511 
<span class="line-modified">1512 C2V_VMENTRY(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">1513   methodHandle m = CompilerToVM::asMethod(jvmci_method);</span>










































































































































































































































































































































































































































































































































































































































































































































1514   oop executable;
1515   if (m-&gt;is_initializer()) {
1516     if (m-&gt;is_static_initializer()) {
<span class="line-modified">1517       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
<span class="line-modified">1518         &quot;Cannot create java.lang.reflect.Method for class initializer&quot;);</span>
1519     }
1520     executable = Reflection::new_constructor(m, CHECK_NULL);
1521   } else {
1522     executable = Reflection::new_method(m, false, CHECK_NULL);
1523   }
<span class="line-modified">1524   return JNIHandles::make_local(thread, executable);</span>
1525 }
1526 
<span class="line-modified">1527 C2V_VMENTRY(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))</span>
<span class="line-modified">1528   Klass* klass = CompilerToVM::asKlass(jvmci_type);</span>

1529   if (!klass-&gt;is_instance_klass()) {
<span class="line-modified">1530     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
1531         err_msg(&quot;Expected non-primitive type, got %s&quot;, klass-&gt;external_name()));
1532   }
1533   InstanceKlass* iklass = InstanceKlass::cast(klass);
1534   Array&lt;u2&gt;* fields = iklass-&gt;fields();
<span class="line-modified">1535   if (index &lt; 0 || index &gt; fields-&gt;length()) {</span>
<span class="line-modified">1536     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),</span>
1537         err_msg(&quot;Field index %d out of bounds for %s&quot;, index, klass-&gt;external_name()));
1538   }
1539   fieldDescriptor fd(iklass, index);
1540   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
1541   return JNIHandles::make_local(env, reflected);
1542 }
1543 



































































1544 #define CC (char*)  /*cast a literal from (const char*)*/
1545 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1546 
1547 #define STRING                  &quot;Ljava/lang/String;&quot;
1548 #define OBJECT                  &quot;Ljava/lang/Object;&quot;
1549 #define CLASS                   &quot;Ljava/lang/Class;&quot;


1550 #define EXECUTABLE              &quot;Ljava/lang/reflect/Executable;&quot;
1551 #define STACK_TRACE_ELEMENT     &quot;Ljava/lang/StackTraceElement;&quot;
1552 #define INSTALLED_CODE          &quot;Ljdk/vm/ci/code/InstalledCode;&quot;
1553 #define TARGET_DESCRIPTION      &quot;Ljdk/vm/ci/code/TargetDescription;&quot;
1554 #define BYTECODE_FRAME          &quot;Ljdk/vm/ci/code/BytecodeFrame;&quot;

1555 #define INSPECTED_FRAME_VISITOR &quot;Ljdk/vm/ci/code/stack/InspectedFrameVisitor;&quot;
1556 #define RESOLVED_METHOD         &quot;Ljdk/vm/ci/meta/ResolvedJavaMethod;&quot;
1557 #define HS_RESOLVED_METHOD      &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;&quot;
1558 #define HS_RESOLVED_KLASS       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;&quot;




1559 #define HS_CONSTANT_POOL        &quot;Ljdk/vm/ci/hotspot/HotSpotConstantPool;&quot;
1560 #define HS_COMPILED_CODE        &quot;Ljdk/vm/ci/hotspot/HotSpotCompiledCode;&quot;
1561 #define HS_CONFIG               &quot;Ljdk/vm/ci/hotspot/HotSpotVMConfig;&quot;
1562 #define HS_METADATA             &quot;Ljdk/vm/ci/hotspot/HotSpotMetaData;&quot;
1563 #define HS_STACK_FRAME_REF      &quot;Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;&quot;
1564 #define HS_SPECULATION_LOG      &quot;Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;&quot;

1565 #define REFLECTION_EXECUTABLE   &quot;Ljava/lang/reflect/Executable;&quot;
1566 #define REFLECTION_FIELD        &quot;Ljava/lang/reflect/Field;&quot;
1567 #define METASPACE_METHOD_DATA   &quot;J&quot;
1568 
1569 JNINativeMethod CompilerToVM::methods[] = {
1570   {CC &quot;getBytecode&quot;,                                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[B&quot;,                                                      FN_PTR(getBytecode)},
1571   {CC &quot;getExceptionTableStart&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getExceptionTableStart)},
1572   {CC &quot;getExceptionTableLength&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getExceptionTableLength)},
1573   {CC &quot;findUniqueConcreteMethod&quot;,                     CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)&quot; HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1574   {CC &quot;getImplementor&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1575   {CC &quot;getStackTraceElement&quot;,                         CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)&quot; STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1576   {CC &quot;methodIsIgnoredBySecurityStackWalk&quot;,           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1577   {CC &quot;setNotInlinableOrCompilable&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(setNotInlinableOrCompilable)},
1578   {CC &quot;isCompilable&quot;,                                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(isCompilable)},
1579   {CC &quot;hasNeverInlineDirective&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(hasNeverInlineDirective)},
1580   {CC &quot;shouldInlineMethod&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(shouldInlineMethod)},
<span class="line-modified">1581   {CC &quot;lookupType&quot;,                                   CC &quot;(&quot; STRING CLASS &quot;Z)&quot; HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},</span>


1582   {CC &quot;lookupNameInPool&quot;,                             CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupNameInPool)},
1583   {CC &quot;lookupNameAndTypeRefIndexInPool&quot;,              CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1584   {CC &quot;lookupSignatureInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupSignatureInPool)},
1585   {CC &quot;lookupKlassRefIndexInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupKlassRefIndexInPool)},
1586   {CC &quot;lookupKlassInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)Ljava/lang/Object;&quot;,                                       FN_PTR(lookupKlassInPool)},
<span class="line-modified">1587   {CC &quot;lookupAppendixInPool&quot;,                         CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECT,                                                  FN_PTR(lookupAppendixInPool)},</span>
1588   {CC &quot;lookupMethodInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;IB)&quot; HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1589   {CC &quot;constantPoolRemapInstructionOperandFromCache&quot;, CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
<span class="line-modified">1590   {CC &quot;resolveConstantInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECT,                                                  FN_PTR(resolveConstantInPool)},</span>
<span class="line-removed">1591   {CC &quot;resolvePossiblyCachedConstantInPool&quot;,          CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},</span>
1592   {CC &quot;resolveTypeInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1593   {CC &quot;resolveFieldInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;I&quot; HS_RESOLVED_METHOD &quot;B[I)&quot; HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
1594   {CC &quot;resolveInvokeDynamicInPool&quot;,                   CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeDynamicInPool)},
1595   {CC &quot;resolveInvokeHandleInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeHandleInPool)},
1596   {CC &quot;isResolvedInvokeHandleInPool&quot;,                 CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(isResolvedInvokeHandleInPool)},
1597   {CC &quot;resolveMethod&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1598   {CC &quot;getSignaturePolymorphicHolders&quot;,               CC &quot;()[&quot; STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1599   {CC &quot;getVtableIndexForInterfaceMethod&quot;,             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)I&quot;,                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1600   {CC &quot;getClassInitializer&quot;,                          CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1601   {CC &quot;hasFinalizableSubclass&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(hasFinalizableSubclass)},
1602   {CC &quot;getMaxCallTargetOffset&quot;,                       CC &quot;(J)J&quot;,                                                                            FN_PTR(getMaxCallTargetOffset)},
1603   {CC &quot;asResolvedJavaMethod&quot;,                         CC &quot;(&quot; EXECUTABLE &quot;)&quot; HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
<span class="line-modified">1604   {CC &quot;getResolvedJavaMethod&quot;,                        CC &quot;(Ljava/lang/Object;J)&quot; HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},</span>
<span class="line-modified">1605   {CC &quot;getConstantPool&quot;,                              CC &quot;(Ljava/lang/Object;)&quot; HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},</span>
<span class="line-modified">1606   {CC &quot;getResolvedJavaType&quot;,                          CC &quot;(Ljava/lang/Object;JZ)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},</span>
1607   {CC &quot;readConfiguration&quot;,                            CC &quot;()[&quot; OBJECT,                                                                      FN_PTR(readConfiguration)},
<span class="line-modified">1608   {CC &quot;installCode&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG &quot;)I&quot;,    FN_PTR(installCode)},</span>
1609   {CC &quot;getMetadata&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA &quot;)I&quot;,                          FN_PTR(getMetadata)},
1610   {CC &quot;resetCompilationStatistics&quot;,                   CC &quot;()V&quot;,                                                                             FN_PTR(resetCompilationStatistics)},
1611   {CC &quot;disassembleCodeBlob&quot;,                          CC &quot;(&quot; INSTALLED_CODE &quot;)&quot; STRING,                                                     FN_PTR(disassembleCodeBlob)},
<span class="line-modified">1612   {CC &quot;executeInstalledCode&quot;,                         CC &quot;([&quot; OBJECT INSTALLED_CODE &quot;)&quot; OBJECT,                                             FN_PTR(executeInstalledCode)},</span>
1613   {CC &quot;getLineNumberTable&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[J&quot;,                                                      FN_PTR(getLineNumberTable)},
1614   {CC &quot;getLocalVariableTableStart&quot;,                   CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getLocalVariableTableStart)},
1615   {CC &quot;getLocalVariableTableLength&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getLocalVariableTableLength)},
1616   {CC &quot;reprofile&quot;,                                    CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(reprofile)},
<span class="line-modified">1617   {CC &quot;invalidateInstalledCode&quot;,                      CC &quot;(&quot; INSTALLED_CODE &quot;)V&quot;,                                                           FN_PTR(invalidateInstalledCode)},</span>

1618   {CC &quot;collectCounters&quot;,                              CC &quot;()[J&quot;,                                                                            FN_PTR(collectCounters)},


1619   {CC &quot;allocateCompileId&quot;,                            CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)I&quot;,                                                      FN_PTR(allocateCompileId)},
1620   {CC &quot;isMature&quot;,                                     CC &quot;(&quot; METASPACE_METHOD_DATA &quot;)Z&quot;,                                                    FN_PTR(isMature)},
1621   {CC &quot;hasCompiledCodeForOSR&quot;,                        CC &quot;(&quot; HS_RESOLVED_METHOD &quot;II)Z&quot;,                                                     FN_PTR(hasCompiledCodeForOSR)},
1622   {CC &quot;getSymbol&quot;,                                    CC &quot;(J)&quot; STRING,                                                                      FN_PTR(getSymbol)},
1623   {CC &quot;iterateFrames&quot;,                                CC &quot;([&quot; RESOLVED_METHOD &quot;[&quot; RESOLVED_METHOD &quot;I&quot; INSPECTED_FRAME_VISITOR &quot;)&quot; OBJECT,   FN_PTR(iterateFrames)},
1624   {CC &quot;materializeVirtualObjects&quot;,                    CC &quot;(&quot; HS_STACK_FRAME_REF &quot;Z)V&quot;,                                                      FN_PTR(materializeVirtualObjects)},
1625   {CC &quot;shouldDebugNonSafepoints&quot;,                     CC &quot;()Z&quot;,                                                                             FN_PTR(shouldDebugNonSafepoints)},
<span class="line-modified">1626   {CC &quot;writeDebugOutput&quot;,                             CC &quot;([BII)V&quot;,                                                                         FN_PTR(writeDebugOutput)},</span>
1627   {CC &quot;flushDebugOutput&quot;,                             CC &quot;()V&quot;,                                                                             FN_PTR(flushDebugOutput)},
1628   {CC &quot;methodDataProfileDataSize&quot;,                    CC &quot;(JI)I&quot;,                                                                           FN_PTR(methodDataProfileDataSize)},
1629   {CC &quot;getFingerprint&quot;,                               CC &quot;(J)J&quot;,                                                                            FN_PTR(getFingerprint)},
1630   {CC &quot;getHostClass&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
1631   {CC &quot;interpreterFrameSize&quot;,                         CC &quot;(&quot; BYTECODE_FRAME &quot;)I&quot;,                                                           FN_PTR(interpreterFrameSize)},
<span class="line-modified">1632   {CC &quot;compileToBytecode&quot;,                            CC &quot;(&quot; OBJECT &quot;)V&quot;,                                                                   FN_PTR(compileToBytecode)},</span>
1633   {CC &quot;getFlagValue&quot;,                                 CC &quot;(&quot; STRING &quot;)&quot; OBJECT,                                                             FN_PTR(getFlagValue)},






































1634   {CC &quot;asReflectionExecutable&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)&quot; REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
1635   {CC &quot;asReflectionField&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;I)&quot; REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},





1636 };
1637 
1638 int CompilerToVM::methods_count() {
1639   return sizeof(methods) / sizeof(JNINativeMethod);
1640 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
<span class="line-modified">  25 #include &quot;classfile/classLoaderData.inline.hpp&quot;</span>
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
<span class="line-added">  27 #include &quot;classfile/stringTable.hpp&quot;</span>
<span class="line-added">  28 #include &quot;classfile/symbolTable.hpp&quot;</span>
  29 #include &quot;code/scopeDesc.hpp&quot;







  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;compiler/disassembler.hpp&quot;
<span class="line-added">  32 #include &quot;interpreter/linkResolver.hpp&quot;</span>
<span class="line-added">  33 #include &quot;interpreter/bytecodeStream.hpp&quot;</span>
  34 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  35 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  36 #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="line-added">  37 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added">  38 #include &quot;logging/logTag.hpp&quot;</span>
<span class="line-added">  39 #include &quot;memory/oopFactory.hpp&quot;</span>
<span class="line-added">  40 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">  41 #include &quot;oops/constantPool.inline.hpp&quot;</span>
<span class="line-added">  42 #include &quot;oops/method.inline.hpp&quot;</span>
<span class="line-added">  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;</span>
<span class="line-added">  44 #include &quot;prims/nativeLookup.hpp&quot;</span>
<span class="line-added">  45 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">  46 #include &quot;runtime/deoptimization.hpp&quot;</span>
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;

  48 #include &quot;runtime/frame.inline.hpp&quot;

  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/jniHandles.inline.hpp&quot;
  51 #include &quot;runtime/timerTrace.hpp&quot;
  52 #include &quot;runtime/vframe_hp.hpp&quot;
  53 
  54 JVMCIKlassHandle::JVMCIKlassHandle(Thread* thread, Klass* klass) {
  55   _thread = thread;
  56   _klass = klass;
  57   if (klass != NULL) {
  58     _holder = Handle(_thread, klass-&gt;klass_holder());
  59   }
  60 }
  61 
  62 JVMCIKlassHandle&amp; JVMCIKlassHandle::operator=(Klass* klass) {
  63   _klass = klass;
  64   if (klass != NULL) {
  65     _holder = Handle(_thread, klass-&gt;klass_holder());
  66   }
  67   return *this;
  68 }
  69 
<span class="line-modified">  70 static void requireInHotSpot(const char* caller, JVMCI_TRAPS) {</span>
<span class="line-modified">  71   if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-added">  72     JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot call %s from JVMCI shared library&quot;, caller));</span>
<span class="line-added">  73   }</span>
<span class="line-added">  74 }</span>
<span class="line-added">  75 </span>
<span class="line-added">  76 void JNIHandleMark::push_jni_handle_block(JavaThread* thread) {</span>
  77   if (thread != NULL) {
  78     // Allocate a new block for JNI handles.
  79     // Inlined code from jni_PushLocalFrame()
<span class="line-modified">  80     JNIHandleBlock* java_handles = thread-&gt;active_handles();</span>
  81     JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
  82     assert(compile_handles != NULL &amp;&amp; java_handles != NULL, &quot;should not be NULL&quot;);
  83     compile_handles-&gt;set_pop_frame_link(java_handles);
  84     thread-&gt;set_active_handles(compile_handles);
  85   }
  86 }
  87 
<span class="line-modified">  88 void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {</span>

  89   if (thread != NULL) {
  90     // Release our JNI handle block
  91     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  92     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  93     thread-&gt;set_active_handles(java_handles);
  94     compile_handles-&gt;set_pop_frame_link(NULL);
  95     JNIHandleBlock::release_block(compile_handles, thread); // may block
  96   }
  97 }
  98 
<span class="line-modified">  99 class JVMCITraceMark : public StackObj {</span>
<span class="line-modified"> 100   const char* _msg;</span>
<span class="line-modified"> 101  public:</span>
<span class="line-modified"> 102   JVMCITraceMark(const char* msg) {</span>
<span class="line-modified"> 103     _msg = msg;</span>
<span class="line-modified"> 104     if (JVMCITraceLevel &gt;= 1) {</span>
<span class="line-modified"> 105       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Enter %s&quot;, p2i(JavaThread::current()), _msg);</span>
<span class="line-modified"> 106     }</span>









 107   }
<span class="line-modified"> 108   ~JVMCITraceMark() {</span>
<span class="line-modified"> 109     if (JVMCITraceLevel &gt;= 1) {</span>
<span class="line-modified"> 110       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Exit %s&quot;, p2i(JavaThread::current()), _msg);</span>
<span class="line-modified"> 111     }</span>







 112   }
<span class="line-modified"> 113 };</span>
<span class="line-modified"> 114 </span>
 115 
 116 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 117   assert(_index &lt; _args-&gt;length(), &quot;out of bounds&quot;);
 118   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 119   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), &quot;arg type mismatch&quot;);
 120   return Handle(Thread::current(), arg);
 121 }
 122 
<span class="line-modified"> 123 // Bring the JVMCI compiler thread into the VM state.</span>
<span class="line-added"> 124 #define JVMCI_VM_ENTRY_MARK                   \</span>
<span class="line-added"> 125   ThreadInVMfromNative __tiv(thread);         \</span>
<span class="line-added"> 126   ResetNoHandleMark rnhm;                     \</span>
<span class="line-added"> 127   HandleMarkCleaner __hm(thread);             \</span>
<span class="line-added"> 128   Thread* THREAD = thread;                    \</span>
<span class="line-added"> 129   debug_only(VMNativeEntryWrapper __vew;)</span>
<span class="line-added"> 130 </span>
<span class="line-added"> 131 // Native method block that transitions current thread to &#39;_thread_in_vm&#39;.</span>
<span class="line-added"> 132 #define C2V_BLOCK(result_type, name, signature)      \</span>
<span class="line-added"> 133   TRACE_CALL(result_type, jvmci_ ## name signature)  \</span>
<span class="line-added"> 134   JVMCI_VM_ENTRY_MARK;                               \</span>
<span class="line-added"> 135   ResourceMark rm;                                   \</span>
<span class="line-added"> 136   JNI_JVMCIENV(thread, env);</span>
<span class="line-added"> 137 </span>
<span class="line-added"> 138 static Thread* get_current_thread() {</span>
<span class="line-added"> 139   return Thread::current_or_null_safe();</span>
<span class="line-added"> 140 }</span>
 141 
<span class="line-modified"> 142 // Entry to native method implementation that transitions</span>
<span class="line-modified"> 143 // current thread to &#39;_thread_in_vm&#39;.</span>
<span class="line-modified"> 144 #define C2V_VMENTRY(result_type, name, signature)        \</span>
<span class="line-modified"> 145   JNIEXPORT result_type JNICALL c2v_ ## name signature { \</span>
<span class="line-added"> 146   Thread* base_thread = get_current_thread();            \</span>
<span class="line-added"> 147   if (base_thread == NULL) {                             \</span>
<span class="line-added"> 148     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \</span>
<span class="line-added"> 149         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \</span>
<span class="line-added"> 150     return;                                              \</span>
<span class="line-added"> 151   }                                                      \</span>
<span class="line-added"> 152   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-added"> 153   JavaThread* thread = (JavaThread*) base_thread;        \</span>
<span class="line-added"> 154   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \</span>
<span class="line-added"> 155   C2V_BLOCK(result_type, name, signature)</span>
<span class="line-added"> 156 </span>
<span class="line-added"> 157 #define C2V_VMENTRY_(result_type, name, signature, result) \</span>
<span class="line-added"> 158   JNIEXPORT result_type JNICALL c2v_ ## name signature { \</span>
<span class="line-added"> 159   Thread* base_thread = get_current_thread();            \</span>
<span class="line-added"> 160   if (base_thread == NULL) {                             \</span>
<span class="line-added"> 161     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \</span>
<span class="line-added"> 162         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \</span>
<span class="line-added"> 163     return result;                                       \</span>
<span class="line-added"> 164   }                                                      \</span>
<span class="line-added"> 165   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-added"> 166   JavaThread* thread = (JavaThread*) base_thread;        \</span>
<span class="line-added"> 167   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \</span>
<span class="line-added"> 168   C2V_BLOCK(result_type, name, signature)</span>
<span class="line-added"> 169 </span>
<span class="line-added"> 170 #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)</span>
<span class="line-added"> 171 #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)</span>
<span class="line-added"> 172 </span>
<span class="line-added"> 173 // Entry to native method implementation that does not transition</span>
<span class="line-added"> 174 // current thread to &#39;_thread_in_vm&#39;.</span>
<span class="line-added"> 175 #define C2V_VMENTRY_PREFIX(result_type, name, signature) \</span>
<span class="line-added"> 176   JNIEXPORT result_type JNICALL c2v_ ## name signature { \</span>
<span class="line-added"> 177   Thread* base_thread = get_current_thread();</span>
 178 
<span class="line-modified"> 179 #define C2V_END }</span>
<span class="line-modified"> 180 </span>
<span class="line-modified"> 181 #define JNI_THROW(caller, name, msg) do {                                         \</span>
<span class="line-modified"> 182     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \</span>
<span class="line-added"> 183     if (__throw_res != JNI_OK) {                                                  \</span>
<span class="line-added"> 184       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \</span>
<span class="line-added"> 185     }                                                                             \</span>
<span class="line-added"> 186     return;                                                                       \</span>
<span class="line-added"> 187   } while (0);</span>
<span class="line-added"> 188 </span>
<span class="line-added"> 189 #define JNI_THROW_(caller, name, msg, result) do {                                \</span>
<span class="line-added"> 190     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \</span>
<span class="line-added"> 191     if (__throw_res != JNI_OK) {                                                  \</span>
<span class="line-added"> 192       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \</span>
<span class="line-added"> 193     }                                                                             \</span>
<span class="line-added"> 194     return result;                                                                \</span>
<span class="line-added"> 195   } while (0)</span>
<span class="line-added"> 196 </span>
<span class="line-added"> 197 jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS);</span>
<span class="line-added"> 198 </span>
<span class="line-added"> 199 C2V_VMENTRY_NULL(jobjectArray, readConfiguration, (JNIEnv* env))</span>
<span class="line-added"> 200   jobjectArray config = readConfiguration0(env, JVMCI_CHECK_NULL);</span>
<span class="line-added"> 201   return config;</span>
<span class="line-added"> 202 }</span>
<span class="line-added"> 203 </span>
<span class="line-added"> 204 C2V_VMENTRY_NULL(jobject, getFlagValue, (JNIEnv* env, jobject c2vm, jobject name_handle))</span>
<span class="line-added"> 205 #define RETURN_BOXED_LONG(value) jvalue p; p.j = (jlong) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_LONG, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();</span>
<span class="line-added"> 206 #define RETURN_BOXED_DOUBLE(value) jvalue p; p.d = (jdouble) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_DOUBLE, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();</span>
<span class="line-added"> 207   JVMCIObject name = JVMCIENV-&gt;wrap(name_handle);</span>
 208   if (name.is_null()) {
<span class="line-modified"> 209     JVMCI_THROW_NULL(NullPointerException);</span>
 210   }
<span class="line-modified"> 211   const char* cstring = JVMCIENV-&gt;as_utf8_string(name);</span>
<span class="line-modified"> 212   const JVMFlag* flag = JVMFlag::find_declared_flag(cstring);</span>

 213   if (flag == NULL) {
 214     return c2vm;
 215   }
 216   if (flag-&gt;is_bool()) {
 217     jvalue prim;
 218     prim.z = flag-&gt;get_bool();
<span class="line-modified"> 219     JVMCIObject box = JVMCIENV-&gt;create_box(T_BOOLEAN, &amp;prim, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 220     return JVMCIENV-&gt;get_jobject(box);</span>
 221   } else if (flag-&gt;is_ccstr()) {
<span class="line-modified"> 222     JVMCIObject value = JVMCIENV-&gt;create_string(flag-&gt;get_ccstr(), JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 223     return JVMCIENV-&gt;get_jobject(value);</span>
 224   } else if (flag-&gt;is_intx()) {
 225     RETURN_BOXED_LONG(flag-&gt;get_intx());
 226   } else if (flag-&gt;is_int()) {
 227     RETURN_BOXED_LONG(flag-&gt;get_int());
 228   } else if (flag-&gt;is_uint()) {
 229     RETURN_BOXED_LONG(flag-&gt;get_uint());
 230   } else if (flag-&gt;is_uint64_t()) {
 231     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 232   } else if (flag-&gt;is_size_t()) {
 233     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 234   } else if (flag-&gt;is_uintx()) {
 235     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 236   } else if (flag-&gt;is_double()) {
 237     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 238   } else {
 239     JVMCI_ERROR_NULL(&quot;VM flag %s has unsupported type %s&quot;, flag-&gt;_name, flag-&gt;_type);
 240   }
 241 #undef RETURN_BOXED_LONG
 242 #undef RETURN_BOXED_DOUBLE
 243 C2V_END
 244 
<span class="line-modified"> 245 C2V_VMENTRY_NULL(jobject, getObjectAtAddress, (JNIEnv* env, jobject c2vm, jlong oop_address))</span>
<span class="line-modified"> 246   requireInHotSpot(&quot;getObjectAtAddress&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 247   if (oop_address == 0) {</span>
<span class="line-added"> 248     JVMCI_THROW_MSG_NULL(InternalError, &quot;Handle must be non-zero&quot;);</span>
<span class="line-added"> 249   }</span>
<span class="line-added"> 250   oop obj = *((oopDesc**) oop_address);</span>
<span class="line-added"> 251   if (obj != NULL) {</span>
<span class="line-added"> 252     oopDesc::verify(obj);</span>
<span class="line-added"> 253   }</span>
<span class="line-added"> 254   return JNIHandles::make_local(obj);</span>
<span class="line-added"> 255 C2V_END</span>
<span class="line-added"> 256 </span>
<span class="line-added"> 257 C2V_VMENTRY_NULL(jbyteArray, getBytecode, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-added"> 258   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
 259 
 260   int code_size = method-&gt;code_size();
<span class="line-modified"> 261   jbyte* reconstituted_code = NEW_RESOURCE_ARRAY(jbyte, code_size);</span>
 262 
 263   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), &quot;Method&#39;s holder should be rewritten&quot;);
 264   // iterate over all bytecodes and replace non-Java bytecodes
 265 
 266   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 267     Bytecodes::Code code = s.code();
 268     Bytecodes::Code raw_code = s.raw_code();
 269     int bci = s.bci();
 270     int len = s.instruction_size();
 271 
 272     // Restore original byte code.
<span class="line-modified"> 273     reconstituted_code[bci] =  (jbyte) (s.is_wide()? Bytecodes::_wide : code);</span>
 274     if (len &gt; 1) {
<span class="line-modified"> 275       memcpy(reconstituted_code + (bci + 1), s.bcp()+1, len-1);</span>
 276     }
 277 
 278     if (len &gt; 1) {
 279       // Restore the big-endian constant pool indexes.
 280       // Cf. Rewriter::scan_method
 281       switch (code) {
 282         case Bytecodes::_getstatic:
 283         case Bytecodes::_putstatic:
 284         case Bytecodes::_getfield:
 285         case Bytecodes::_putfield:
 286         case Bytecodes::_invokevirtual:
 287         case Bytecodes::_invokespecial:
 288         case Bytecodes::_invokestatic:
 289         case Bytecodes::_invokeinterface:
 290         case Bytecodes::_invokehandle: {
<span class="line-modified"> 291           int cp_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));</span>
<span class="line-modified"> 292           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);</span>
 293           break;
 294         }
 295 
 296         case Bytecodes::_invokedynamic: {
<span class="line-modified"> 297           int cp_index = Bytes::get_native_u4((address) reconstituted_code + (bci + 1));</span>
<span class="line-modified"> 298           Bytes::put_Java_u4((address) reconstituted_code + (bci + 1), (u4) cp_index);</span>
 299           break;
 300         }
 301 
 302         default:
 303           break;
 304       }
 305 
 306       // Not all ldc byte code are rewritten.
 307       switch (raw_code) {
 308         case Bytecodes::_fast_aldc: {
<span class="line-modified"> 309           int cpc_index = reconstituted_code[bci + 1] &amp; 0xff;</span>
 310           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 311           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
<span class="line-modified"> 312           reconstituted_code[bci + 1] = (jbyte) cp_index;</span>
 313           break;
 314         }
 315 
 316         case Bytecodes::_fast_aldc_w: {
<span class="line-modified"> 317           int cpc_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));</span>
 318           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 319           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
<span class="line-modified"> 320           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);</span>
 321           break;
 322         }
 323 
 324         default:
 325           break;
 326       }
 327     }
 328   }
 329 
<span class="line-modified"> 330   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);</span>
<span class="line-added"> 331   JVMCIENV-&gt;copy_bytes_from(reconstituted_code, result, 0, code_size);</span>
<span class="line-added"> 332   return JVMCIENV-&gt;get_jbyteArray(result);</span>
 333 C2V_END
 334 
<span class="line-modified"> 335 C2V_VMENTRY_0(jint, getExceptionTableLength, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 336   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>

 337   return method-&gt;exception_table_length();
 338 C2V_END
 339 
<span class="line-modified"> 340 C2V_VMENTRY_0(jlong, getExceptionTableStart, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 341   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>

 342   if (method-&gt;exception_table_length() == 0) {
 343     return 0L;
 344   }
 345   return (jlong) (address) method-&gt;exception_table_start();
 346 C2V_END
 347 
<span class="line-modified"> 348 C2V_VMENTRY_NULL(jobject, asResolvedJavaMethod, (JNIEnv* env, jobject, jobject executable_handle))</span>
<span class="line-added"> 349   requireInHotSpot(&quot;asResolvedJavaMethod&quot;, JVMCI_CHECK_NULL);</span>
 350   oop executable = JNIHandles::resolve(executable_handle);
 351   oop mirror = NULL;
 352   int slot = 0;
 353 
 354   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 355     mirror = java_lang_reflect_Constructor::clazz(executable);
 356     slot = java_lang_reflect_Constructor::slot(executable);
 357   } else {
 358     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 359     mirror = java_lang_reflect_Method::clazz(executable);
 360     slot = java_lang_reflect_Method::slot(executable);
 361   }
 362   Klass* holder = java_lang_Class::as_Klass(mirror);
<span class="line-modified"> 363   methodHandle method (THREAD, InstanceKlass::cast(holder)-&gt;method_with_idnum(slot));</span>
<span class="line-modified"> 364   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 365   return JVMCIENV-&gt;get_jobject(result);</span>
 366 }
 367 
<span class="line-modified"> 368 C2V_VMENTRY_NULL(jobject, getResolvedJavaMethod, (JNIEnv* env, jobject, jobject base, jlong offset))</span>
<span class="line-modified"> 369   Method* method;</span>
<span class="line-modified"> 370   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);</span>
<span class="line-modified"> 371   if (base_object.is_null()) {</span>
 372     method = *((Method**)(offset));
<span class="line-modified"> 373   } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {</span>
<span class="line-modified"> 374     Handle obj = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 375     if (obj-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {</span>
<span class="line-modified"> 376       method = (Method*) (intptr_t) obj-&gt;long_field(offset);</span>
<span class="line-modified"> 377     } else {</span>
<span class="line-modified"> 378       JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(&quot;Unexpected type: %s&quot;, obj-&gt;klass()-&gt;external_name()));</span>
<span class="line-modified"> 379     }</span>
<span class="line-added"> 380   } else if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {</span>
<span class="line-added"> 381     method = JVMCIENV-&gt;asMethod(base_object);</span>
 382   }
<span class="line-modified"> 383   if (method == NULL) {</span>
<span class="line-modified"> 384     JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base_object)));</span>
<span class="line-modified"> 385   }</span>
<span class="line-added"> 386   assert (method-&gt;is_method(), &quot;invalid read&quot;);</span>
<span class="line-added"> 387   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(methodHandle(THREAD, method), JVMCI_CHECK_NULL);</span>
<span class="line-added"> 388   return JVMCIENV-&gt;get_jobject(result);</span>
 389 }
 390 
<span class="line-modified"> 391 C2V_VMENTRY_NULL(jobject, getConstantPool, (JNIEnv* env, jobject, jobject object_handle))</span>
<span class="line-modified"> 392   ConstantPool* cp = NULL;</span>
<span class="line-modified"> 393   JVMCIObject object = JVMCIENV-&gt;wrap(object_handle);</span>
<span class="line-modified"> 394   if (object.is_null()) {</span>
<span class="line-modified"> 395     JVMCI_THROW_NULL(NullPointerException);</span>
 396   }
<span class="line-modified"> 397   if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(object)) {</span>
<span class="line-modified"> 398     cp = JVMCIENV-&gt;asMethod(object)-&gt;constMethod()-&gt;constants();</span>
<span class="line-modified"> 399   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(object)) {</span>
<span class="line-modified"> 400     cp = InstanceKlass::cast(JVMCIENV-&gt;asKlass(object))-&gt;constants();</span>
 401   } else {
<span class="line-modified"> 402     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
<span class="line-modified"> 403                 err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(object)));</span>
<span class="line-modified"> 404   }</span>
<span class="line-modified"> 405   assert(cp != NULL, &quot;npe&quot;);</span>
<span class="line-modified"> 406 </span>
<span class="line-modified"> 407   JVMCIObject result = JVMCIENV-&gt;get_jvmci_constant_pool(constantPoolHandle(THREAD, cp), JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 408   return JVMCIENV-&gt;get_jobject(result);</span>


 409 }
 410 
<span class="line-modified"> 411 C2V_VMENTRY_NULL(jobject, getResolvedJavaType0, (JNIEnv* env, jobject, jobject base, jlong offset, jboolean compressed))</span>
 412   JVMCIKlassHandle klass(THREAD);
<span class="line-modified"> 413   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);</span>
 414   jlong base_address = 0;
<span class="line-modified"> 415   if (base_object.is_non_null() &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {</span>
<span class="line-modified"> 416     // klass = JVMCIENV-&gt;unhandle(base_object)-&gt;klass();</span>
<span class="line-added"> 417     if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {</span>
<span class="line-added"> 418       Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);</span>
<span class="line-added"> 419       klass = base_oop-&gt;klass();</span>
<span class="line-added"> 420     } else {</span>
<span class="line-added"> 421       assert(false, &quot;What types are we actually expecting here?&quot;);</span>
<span class="line-added"> 422     }</span>
 423   } else if (!compressed) {
<span class="line-modified"> 424     if (base_object.is_non_null()) {</span>
<span class="line-modified"> 425       if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {</span>
<span class="line-modified"> 426         base_address = (intptr_t) JVMCIENV-&gt;asMethod(base_object);</span>
<span class="line-modified"> 427       } else if (JVMCIENV-&gt;isa_HotSpotConstantPool(base_object)) {</span>
<span class="line-modified"> 428         base_address = (intptr_t) JVMCIENV-&gt;asConstantPool(base_object);</span>
<span class="line-modified"> 429       } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {</span>
<span class="line-modified"> 430         base_address = (intptr_t) JVMCIENV-&gt;asKlass(base_object);</span>
<span class="line-modified"> 431       } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {</span>
<span class="line-modified"> 432         Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 433         if (base_oop-&gt;is_a(SystemDictionary::Class_klass())) {</span>
<span class="line-modified"> 434           base_address = cast_from_oop&lt;jlong&gt;(base_oop());</span>
<span class="line-modified"> 435         }</span>
<span class="line-added"> 436       }</span>
<span class="line-added"> 437       if (base_address == 0) {</span>
<span class="line-added"> 438         JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
<span class="line-added"> 439                     err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;, JVMCIENV-&gt;klass_name(base_object), offset, compressed ? &quot;true&quot; : &quot;false&quot;));</span>
 440       }
 441     }
 442     klass = *((Klass**) (intptr_t) (base_address + offset));
 443   } else {
<span class="line-modified"> 444     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
 445                 err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;,
<span class="line-modified"> 446                         base_object.is_non_null() ? JVMCIENV-&gt;klass_name(base_object) : &quot;null&quot;,</span>
 447                         offset, compressed ? &quot;true&quot; : &quot;false&quot;));
 448   }
 449   assert (klass == NULL || klass-&gt;is_klass(), &quot;invalid read&quot;);
<span class="line-modified"> 450   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 451   return JVMCIENV-&gt;get_jobject(result);</span>
 452 }
 453 
<span class="line-modified"> 454 C2V_VMENTRY_NULL(jobject, findUniqueConcreteMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))</span>
<span class="line-modified"> 455   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
<span class="line-modified"> 456   Klass* holder = JVMCIENV-&gt;asKlass(jvmci_type);</span>

 457   if (holder-&gt;is_interface()) {
<span class="line-modified"> 458     JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, holder-&gt;external_name()));</span>
<span class="line-added"> 459   }</span>
<span class="line-added"> 460   if (method-&gt;can_be_statically_bound()) {</span>
<span class="line-added"> 461     JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Effectively static method %s.%s should be handled in Java code&quot;, method-&gt;method_holder()-&gt;external_name(), method-&gt;external_name()));</span>
 462   }
 463 
 464   methodHandle ucm;
 465   {
 466     MutexLocker locker(Compile_lock);
<span class="line-modified"> 467     ucm = methodHandle(THREAD, Dependencies::find_unique_concrete_method(holder, method()));</span>
 468   }
<span class="line-modified"> 469   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(ucm, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 470   return JVMCIENV-&gt;get_jobject(result);</span>
 471 C2V_END
 472 
<span class="line-modified"> 473 C2V_VMENTRY_NULL(jobject, getImplementor, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-modified"> 474   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
 475   if (!klass-&gt;is_interface()) {
 476     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 477         err_msg(&quot;Expected interface type, got %s&quot;, klass-&gt;external_name()));
 478   }
 479   InstanceKlass* iklass = InstanceKlass::cast(klass);
 480   JVMCIKlassHandle handle(THREAD);
 481   {
 482     // Need Compile_lock around implementor()
 483     MutexLocker locker(Compile_lock);
 484     handle = iklass-&gt;implementor();
 485   }
<span class="line-modified"> 486   JVMCIObject implementor = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 487   return JVMCIENV-&gt;get_jobject(implementor);</span>
 488 C2V_END
 489 
<span class="line-modified"> 490 C2V_VMENTRY_0(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 491   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
 492   return method-&gt;is_ignored_by_security_stack_walk();
 493 C2V_END
 494 
<span class="line-modified"> 495 C2V_VMENTRY_0(jboolean, isCompilable,(JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 496   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
<span class="line-modified"> 497   ConstantPool* cp = method-&gt;constMethod()-&gt;constants();</span>
<span class="line-modified"> 498   assert(cp != NULL, &quot;npe&quot;);</span>
 499   // don&#39;t inline method when constant pool contains a CONSTANT_Dynamic
 500   return !method-&gt;is_not_compilable(CompLevel_full_optimization) &amp;&amp; !cp-&gt;has_dynamic_constant();
 501 C2V_END
 502 
<span class="line-modified"> 503 C2V_VMENTRY_0(jboolean, hasNeverInlineDirective,(JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 504   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
 505   return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 506 C2V_END
 507 
<span class="line-modified"> 508 C2V_VMENTRY_0(jboolean, shouldInlineMethod,(JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified"> 509   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
 510   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 511 C2V_END
 512 
<span class="line-modified"> 513 C2V_VMENTRY_NULL(jobject, lookupType, (JNIEnv* env, jobject, jstring jname, jclass accessing_class, jboolean resolve))</span>
<span class="line-modified"> 514   JVMCIObject name = JVMCIENV-&gt;wrap(jname);</span>
<span class="line-modified"> 515   const char* str = JVMCIENV-&gt;as_utf8_string(name);</span>
<span class="line-modified"> 516   TempNewSymbol class_name = SymbolTable::new_symbol(str);</span>
<span class="line-modified"> 517 </span>
<span class="line-modified"> 518   if (class_name-&gt;utf8_length() &lt;= 1) {</span>
<span class="line-added"> 519     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Primitive type %s should be handled in Java code&quot;, class_name-&gt;as_C_string()));</span>
 520   }
 521 
 522   JVMCIKlassHandle resolved_klass(THREAD);
<span class="line-modified"> 523   Klass* accessing_klass = NULL;</span>
<span class="line-modified"> 524   Handle class_loader;</span>
<span class="line-added"> 525   Handle protection_domain;</span>
<span class="line-added"> 526   if (accessing_class != NULL) {</span>
<span class="line-added"> 527     accessing_klass = JVMCIENV-&gt;asKlass(accessing_class);</span>
<span class="line-added"> 528     class_loader = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-added"> 529     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>
<span class="line-added"> 530   } else {</span>
<span class="line-added"> 531     // Use the System class loader</span>
<span class="line-added"> 532     class_loader = Handle(THREAD, SystemDictionary::java_system_loader());</span>
<span class="line-added"> 533     JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);</span>
 534   }



 535 
 536   if (resolve) {
 537     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
<span class="line-added"> 538     if (resolved_klass == NULL) {</span>
<span class="line-added"> 539       JVMCI_THROW_MSG_NULL(ClassNotFoundException, str);</span>
<span class="line-added"> 540     }</span>
 541   } else {
<span class="line-modified"> 542     if (Signature::has_envelope(class_name)) {</span>

 543       // This is a name from a signature.  Strip off the trimmings.
 544       // Call recursive to keep scope of strippedsym.
<span class="line-modified"> 545       TempNewSymbol strippedsym = Signature::strip_envelope(class_name);</span>


 546       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
<span class="line-modified"> 547     } else if (Signature::is_array(class_name)) {</span>
<span class="line-modified"> 548       SignatureStream ss(class_name, false);</span>
<span class="line-modified"> 549       int ndim = ss.skip_array_prefix();</span>
<span class="line-modified"> 550       if (ss.type() == T_OBJECT) {</span>
<span class="line-modified"> 551         Symbol* strippedsym = ss.as_symbol();</span>





 552         resolved_klass = SystemDictionary::find(strippedsym,
<span class="line-modified"> 553                                                 class_loader,</span>
<span class="line-modified"> 554                                                 protection_domain,</span>
<span class="line-modified"> 555                                                 CHECK_0);</span>
 556         if (!resolved_klass.is_null()) {
<span class="line-modified"> 557           resolved_klass = resolved_klass-&gt;array_klass(ndim, CHECK_0);</span>
 558         }
 559       } else {
<span class="line-modified"> 560         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(ss.type()))-&gt;array_klass(ndim, CHECK_0);</span>
 561       }
<span class="line-added"> 562     } else {</span>
<span class="line-added"> 563       resolved_klass = SystemDictionary::find(class_name, class_loader, protection_domain, CHECK_0);</span>
 564     }
 565   }
<span class="line-modified"> 566   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 567   return JVMCIENV-&gt;get_jobject(result);</span>
 568 C2V_END
 569 
<span class="line-modified"> 570 C2V_VMENTRY_NULL(jobject, getArrayType, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-modified"> 571   if (jvmci_type == NULL) {</span>
<span class="line-modified"> 572     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-modified"> 573   }</span>
<span class="line-added"> 574 </span>
<span class="line-added"> 575   JVMCIObject jvmci_type_object = JVMCIENV-&gt;wrap(jvmci_type);</span>
<span class="line-added"> 576   JVMCIKlassHandle array_klass(THREAD);</span>
<span class="line-added"> 577   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(jvmci_type_object)) {</span>
<span class="line-added"> 578     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(jvmci_type_object), JVMCI_CHECK_0);</span>
<span class="line-added"> 579     if (type == T_VOID) {</span>
<span class="line-added"> 580       return NULL;</span>
<span class="line-added"> 581     }</span>
<span class="line-added"> 582     array_klass = Universe::typeArrayKlassObj(type);</span>
<span class="line-added"> 583     if (array_klass == NULL) {</span>
<span class="line-added"> 584       JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;No array klass for primitive type %s&quot;, type2name(type)));</span>
<span class="line-added"> 585     }</span>
<span class="line-added"> 586   } else {</span>
<span class="line-added"> 587     Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
<span class="line-added"> 588     if (klass == NULL) {</span>
<span class="line-added"> 589       JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added"> 590     }</span>
<span class="line-added"> 591     array_klass = klass-&gt;array_klass(CHECK_NULL);</span>
<span class="line-added"> 592   }</span>
<span class="line-added"> 593   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(array_klass, JVMCI_CHECK_NULL);</span>
<span class="line-added"> 594   return JVMCIENV-&gt;get_jobject(result);</span>
 595 C2V_END
 596 
<span class="line-modified"> 597 C2V_VMENTRY_NULL(jobject, lookupClass, (JNIEnv* env, jobject, jclass mirror))</span>
<span class="line-modified"> 598   requireInHotSpot(&quot;lookupClass&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added"> 599   if (mirror == NULL) {</span>
<span class="line-added"> 600     return NULL;</span>
<span class="line-added"> 601   }</span>
<span class="line-added"> 602   JVMCIKlassHandle klass(THREAD);</span>
<span class="line-added"> 603   klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));</span>
<span class="line-added"> 604   if (klass == NULL) {</span>
<span class="line-added"> 605     JVMCI_THROW_MSG_NULL(IllegalArgumentException, &quot;Primitive classes are unsupported&quot;);</span>
<span class="line-added"> 606   }</span>
<span class="line-added"> 607   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);</span>
<span class="line-added"> 608   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added"> 609 }</span>
<span class="line-added"> 610 </span>
<span class="line-added"> 611 C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-added"> 612   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
 613   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
<span class="line-modified"> 614   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(result));</span>
 615 C2V_END
 616 
<span class="line-modified"> 617 C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 618   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
 619   return cp-&gt;name_and_type_ref_index_at(index);
 620 C2V_END
 621 
<span class="line-modified"> 622 C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))</span>
<span class="line-modified"> 623   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
<span class="line-modified"> 624   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;name_ref_at(which), JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 625   return JVMCIENV-&gt;get_jobject(sym);</span>
 626 C2V_END
 627 
<span class="line-modified"> 628 C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))</span>
<span class="line-modified"> 629   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
<span class="line-modified"> 630   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;signature_ref_at(which), JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 631   return JVMCIENV-&gt;get_jobject(sym);</span>
 632 C2V_END
 633 
<span class="line-modified"> 634 C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 635   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
 636   return cp-&gt;klass_ref_index_at(index);
 637 C2V_END
 638 
<span class="line-modified"> 639 C2V_VMENTRY_NULL(jobject, resolveTypeInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 640   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
 641   Klass* klass = cp-&gt;klass_at(index, CHECK_NULL);
 642   JVMCIKlassHandle resolved_klass(THREAD, klass);
 643   if (resolved_klass-&gt;is_instance_klass()) {
<span class="line-modified"> 644     InstanceKlass::cast(resolved_klass())-&gt;link_class(CHECK_NULL);</span>
<span class="line-added"> 645     if (!InstanceKlass::cast(resolved_klass())-&gt;is_linked()) {</span>
<span class="line-added"> 646       // link_class() should not return here if there is an issue.</span>
<span class="line-added"> 647       JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Class %s must be linked&quot;, resolved_klass()-&gt;external_name()));</span>
<span class="line-added"> 648     }</span>
 649   }
<span class="line-modified"> 650   JVMCIObject klassObject = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 651   return JVMCIENV-&gt;get_jobject(klassObject);</span>
 652 C2V_END
 653 
<span class="line-modified"> 654 C2V_VMENTRY_NULL(jobject, lookupKlassInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))</span>
<span class="line-modified"> 655   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
 656   Klass* loading_klass = cp-&gt;pool_holder();
 657   bool is_accessible = false;
<span class="line-modified"> 658   JVMCIKlassHandle klass(THREAD, JVMCIRuntime::get_klass_by_index(cp, index, is_accessible, loading_klass));</span>
 659   Symbol* symbol = NULL;
<span class="line-modified"> 660   if (klass.is_null()) {</span>
<span class="line-modified"> 661     constantTag tag = cp-&gt;tag_at(index);</span>
<span class="line-added"> 662     if (tag.is_klass()) {</span>
<span class="line-added"> 663       // The klass has been inserted into the constant pool</span>
<span class="line-added"> 664       // very recently.</span>
<span class="line-added"> 665       klass = cp-&gt;resolved_klass_at(index);</span>
<span class="line-added"> 666     } else if (tag.is_symbol()) {</span>
<span class="line-added"> 667       symbol = cp-&gt;symbol_at(index);</span>
<span class="line-added"> 668     } else {</span>
<span class="line-added"> 669       assert(cp-&gt;tag_at(index).is_unresolved_klass(), &quot;wrong tag&quot;);</span>
<span class="line-added"> 670       symbol = cp-&gt;klass_name_at(index);</span>
<span class="line-added"> 671     }</span>
 672   }
<span class="line-modified"> 673   JVMCIObject result;</span>
 674   if (!klass.is_null()) {
<span class="line-modified"> 675     result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);</span>
 676   } else {
<span class="line-modified"> 677     result = JVMCIENV-&gt;create_string(symbol, JVMCI_CHECK_NULL);</span>

 678   }
<span class="line-modified"> 679   return JVMCIENV-&gt;get_jobject(result);</span>
 680 C2V_END
 681 
<span class="line-modified"> 682 C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 683   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
 684   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
<span class="line-modified"> 685   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(appendix_oop));</span>
 686 C2V_END
 687 
<span class="line-modified"> 688 C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))</span>
<span class="line-modified"> 689   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
 690   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 691   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
<span class="line-modified"> 692   methodHandle method(THREAD, JVMCIRuntime::get_method_by_index(cp, index, bc, pool_holder));</span>
<span class="line-modified"> 693   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 694   return JVMCIENV-&gt;get_jobject(result);</span>
 695 C2V_END
 696 
<span class="line-modified"> 697 C2V_VMENTRY_0(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified"> 698   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
 699   return cp-&gt;remap_instruction_operand_from_cache(index);
 700 C2V_END
 701 
<span class="line-modified"> 702 C2V_VMENTRY_NULL(jobject, resolveFieldInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))</span>
<span class="line-modified"> 703   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>

 704   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 705   fieldDescriptor fd;
<span class="line-modified"> 706   methodHandle mh(THREAD, (jvmci_method != NULL) ? JVMCIENV-&gt;asMethod(jvmci_method) : NULL);</span>
<span class="line-added"> 707   LinkInfo link_info(cp, index, mh, CHECK_0);</span>
 708   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
<span class="line-modified"> 709   JVMCIPrimitiveArray info = JVMCIENV-&gt;wrap(info_handle);</span>
<span class="line-modified"> 710   if (info.is_null() || JVMCIENV-&gt;get_length(info) != 3) {</span>
 711     JVMCI_ERROR_NULL(&quot;info must not be null and have a length of 3&quot;);
 712   }
<span class="line-modified"> 713   JVMCIENV-&gt;put_int_at(info, 0, fd.access_flags().as_int());</span>
<span class="line-modified"> 714   JVMCIENV-&gt;put_int_at(info, 1, fd.offset());</span>
<span class="line-modified"> 715   JVMCIENV-&gt;put_int_at(info, 2, fd.index());</span>
 716   JVMCIKlassHandle handle(THREAD, fd.field_holder());
<span class="line-modified"> 717   JVMCIObject field_holder = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 718   return JVMCIENV-&gt;get_jobject(field_holder);</span>
 719 C2V_END
 720 
<span class="line-modified"> 721 C2V_VMENTRY_0(jint, getVtableIndexForInterfaceMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))</span>
<span class="line-modified"> 722   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
<span class="line-modified"> 723   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>

 724   if (klass-&gt;is_interface()) {
<span class="line-modified"> 725     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, klass-&gt;external_name()));</span>
 726   }
 727   if (!method-&gt;method_holder()-&gt;is_interface()) {
<span class="line-modified"> 728     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Method %s is not held by an interface, this case should be handled in Java code&quot;, method-&gt;name_and_sig_as_C_string()));</span>
<span class="line-added"> 729   }</span>
<span class="line-added"> 730   if (!klass-&gt;is_instance_klass()) {</span>
<span class="line-added"> 731     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be instance klass&quot;, klass-&gt;external_name()));</span>
 732   }
 733   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
<span class="line-modified"> 734     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be linked&quot;, klass-&gt;external_name()));</span>
 735   }
 736   return LinkResolver::vtable_index_of_interface_method(klass, method);
 737 C2V_END
 738 
<span class="line-modified"> 739 C2V_VMENTRY_NULL(jobject, resolveMethod, (JNIEnv* env, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))</span>
<span class="line-modified"> 740   Klass* recv_klass = JVMCIENV-&gt;asKlass(receiver_jvmci_type);</span>
<span class="line-modified"> 741   Klass* caller_klass = JVMCIENV-&gt;asKlass(caller_jvmci_type);</span>
<span class="line-modified"> 742   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
 743 
 744   Klass* resolved     = method-&gt;method_holder();
 745   Symbol* h_name      = method-&gt;name();
 746   Symbol* h_signature = method-&gt;signature();
 747 
 748   if (MethodHandles::is_signature_polymorphic_method(method())) {
 749       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 750       return NULL;
 751   }
 752 
 753   if (method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 754       resolved == SystemDictionary::Object_klass() &amp;&amp;
 755       recv_klass-&gt;is_array_klass()) {
 756     // Resolution of the clone method on arrays always returns Object.clone even though that method
 757     // has protected access.  There&#39;s some trickery in the access checking to make this all work out
 758     // so it&#39;s necessary to pass in the array class as the resolved class to properly trigger this.
 759     // Otherwise it&#39;s impossible to resolve the array clone methods through JVMCI.  See
 760     // LinkResolver::check_method_accessability for the matching logic.
 761     resolved = recv_klass;
 762   }
 763 
 764   LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
<span class="line-modified"> 765   Method* m = NULL;</span>
 766   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 767   // the vtable has not been setup, and the LinkResolver will fail.
 768   if (recv_klass-&gt;is_array_klass() ||
 769       (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
 770     if (resolved-&gt;is_interface()) {
 771       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 772     } else {
 773       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 774     }
 775   }
 776 
<span class="line-modified"> 777   if (m == NULL) {</span>
 778     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 779     return NULL;
 780   }
 781 
<span class="line-modified"> 782   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(methodHandle(THREAD, m), JVMCI_CHECK_NULL);</span>
<span class="line-modified"> 783   return JVMCIENV-&gt;get_jobject(result);</span>
 784 C2V_END
 785 
<span class="line-modified"> 786 C2V_VMENTRY_0(jboolean, hasFinalizableSubclass,(JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-modified"> 787   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
 788   assert(klass != NULL, &quot;method must not be called for primitive types&quot;);
 789   return Dependencies::find_finalizable_subclass(klass) != NULL;
 790 C2V_END
 791 
<span class="line-modified"> 792 C2V_VMENTRY_NULL(jobject, getClassInitializer, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-modified"> 793   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
 794   if (!klass-&gt;is_instance_klass()) {
 795     return NULL;
 796   }
 797   InstanceKlass* iklass = InstanceKlass::cast(klass);
<span class="line-modified"> 798   methodHandle clinit(THREAD, iklass-&gt;class_initializer());</span>
<span class="line-modified"> 799   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(clinit, JVMCI_CHECK_NULL);</span>
<span class="line-added"> 800   return JVMCIENV-&gt;get_jobject(result);</span>
 801 C2V_END
 802 
<span class="line-modified"> 803 C2V_VMENTRY_0(jlong, getMaxCallTargetOffset, (JNIEnv* env, jobject, jlong addr))</span>
 804   address target_addr = (address) addr;
 805   if (target_addr != 0x0) {
 806     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 807     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 808     return MAX2(ABS(off_low), ABS(off_high));
 809   }
 810   return -1;
 811 C2V_END
 812 
<span class="line-modified"> 813 C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv* env, jobject,  jobject jvmci_method))</span>
<span class="line-modified"> 814   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
 815   method-&gt;set_not_c1_compilable();
 816   method-&gt;set_not_c2_compilable();
 817   method-&gt;set_dont_inline(true);
 818 C2V_END
 819 
<span class="line-modified"> 820 C2V_VMENTRY_0(jint, installCode, (JNIEnv *env, jobject, jobject target, jobject compiled_code,</span>
<span class="line-modified"> 821             jobject installed_code, jlong failed_speculations_address, jbyteArray speculations_obj))</span>
 822   HandleMark hm;
<span class="line-modified"> 823   JNIHandleMark jni_hm(thread);</span>
 824 
<span class="line-modified"> 825   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);</span>
<span class="line-modified"> 826   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);</span>
 827   CodeBlob* cb = NULL;
<span class="line-modified"> 828   JVMCIObject installed_code_handle = JVMCIENV-&gt;wrap(installed_code);</span>
<span class="line-modified"> 829   JVMCIPrimitiveArray speculations_handle = JVMCIENV-&gt;wrap(speculations_obj);</span>
<span class="line-added"> 830 </span>
<span class="line-added"> 831   int speculations_len = JVMCIENV-&gt;get_length(speculations_handle);</span>
<span class="line-added"> 832   char* speculations = NEW_RESOURCE_ARRAY(char, speculations_len);</span>
<span class="line-added"> 833   JVMCIENV-&gt;copy_bytes_to(speculations_handle, (jbyte*) speculations, 0, speculations_len);</span>
 834 
 835   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
 836 
 837   TraceTime install_time(&quot;installCode&quot;, JVMCICompiler::codeInstallTimer());
<span class="line-modified"> 838   bool is_immutable_PIC = JVMCIENV-&gt;get_HotSpotCompiledCode_isImmutablePIC(compiled_code_handle) &gt; 0;</span>
<span class="line-modified"> 839 </span>
<span class="line-modified"> 840   CodeInstaller installer(JVMCIENV, is_immutable_PIC);</span>
<span class="line-added"> 841   JVMCI::CodeInstallResult result = installer.install(compiler,</span>
<span class="line-added"> 842       target_handle,</span>
<span class="line-added"> 843       compiled_code_handle,</span>
<span class="line-added"> 844       cb,</span>
<span class="line-added"> 845       installed_code_handle,</span>
<span class="line-added"> 846       (FailedSpeculation**)(address) failed_speculations_address,</span>
<span class="line-added"> 847       speculations,</span>
<span class="line-added"> 848       speculations_len,</span>
<span class="line-added"> 849       JVMCI_CHECK_0);</span>
 850 
 851   if (PrintCodeCacheOnCompilation) {
 852     stringStream s;
<span class="line-modified"> 853     // Dump code cache into a buffer before locking the tty,</span>
 854     {
<span class="line-modified"> 855       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
 856       CodeCache::print_summary(&amp;s, false);
 857     }
 858     ttyLocker ttyl;
 859     tty-&gt;print_raw_cr(s.as_string());
 860   }
 861 
<span class="line-modified"> 862   if (result != JVMCI::ok) {</span>
 863     assert(cb == NULL, &quot;should be&quot;);
 864   } else {
<span class="line-modified"> 865     if (installed_code_handle.is_non_null()) {</span>
<span class="line-modified"> 866       if (cb-&gt;is_nmethod()) {</span>
<span class="line-modified"> 867         assert(JVMCIENV-&gt;isa_HotSpotNmethod(installed_code_handle), &quot;wrong type&quot;);</span>
<span class="line-modified"> 868         // Clear the link to an old nmethod first</span>
<span class="line-modified"> 869         JVMCIObject nmethod_mirror = installed_code_handle;</span>
<span class="line-modified"> 870         JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK_0);</span>
<span class="line-modified"> 871       } else {</span>
<span class="line-modified"> 872         assert(JVMCIENV-&gt;isa_InstalledCode(installed_code_handle), &quot;wrong type&quot;);</span>










 873       }
<span class="line-added"> 874       // Initialize the link to the new code blob</span>
<span class="line-added"> 875       JVMCIENV-&gt;initialize_installed_code(installed_code_handle, cb, JVMCI_CHECK_0);</span>
 876     }
 877   }
 878   return result;
 879 C2V_END
 880 
<span class="line-modified"> 881 C2V_VMENTRY_0(jint, getMetadata, (JNIEnv *env, jobject, jobject target, jobject compiled_code, jobject metadata))</span>
 882 #if INCLUDE_AOT

 883   HandleMark hm;
<span class="line-added"> 884   assert(JVMCIENV-&gt;is_hotspot(), &quot;AOT code is executed only in HotSpot mode&quot;);</span>
 885 
<span class="line-modified"> 886   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);</span>
<span class="line-modified"> 887   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);</span>
<span class="line-modified"> 888   JVMCIObject metadata_handle = JVMCIENV-&gt;wrap(metadata);</span>
 889 
 890   CodeMetadata code_metadata;


 891 
<span class="line-modified"> 892   CodeInstaller installer(JVMCIENV, true /* immutable PIC compilation */);</span>
<span class="line-modified"> 893   JVMCI::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, JVMCI_CHECK_0);</span>
<span class="line-added"> 894   if (result != JVMCI::ok) {</span>
 895     return result;
 896   }
 897 
 898   if (code_metadata.get_nr_pc_desc() &gt; 0) {
<span class="line-modified"> 899     int size = sizeof(PcDesc) * code_metadata.get_nr_pc_desc();</span>
<span class="line-modified"> 900     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));</span>
<span class="line-modified"> 901     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_pc_desc(), array, 0, size);</span>
<span class="line-added"> 902     HotSpotJVMCI::HotSpotMetaData::set_pcDescBytes(JVMCIENV, metadata_handle, array);</span>
 903   }
 904 
 905   if (code_metadata.get_scopes_size() &gt; 0) {
<span class="line-modified"> 906     int size = code_metadata.get_scopes_size();</span>
<span class="line-modified"> 907     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));</span>
<span class="line-modified"> 908     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_scopes_desc(), array, 0, size);</span>
<span class="line-added"> 909     HotSpotJVMCI::HotSpotMetaData::set_scopesDescBytes(JVMCIENV, metadata_handle, array);</span>
 910   }
 911 
 912   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
<span class="line-modified"> 913   int size = (int) reloc_buffer-&gt;size();</span>
<span class="line-modified"> 914   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));</span>
<span class="line-modified"> 915   JVMCIENV-&gt;copy_bytes_from((jbyte*) reloc_buffer-&gt;begin(), array, 0, size);</span>
<span class="line-modified"> 916   HotSpotJVMCI::HotSpotMetaData::set_relocBytes(JVMCIENV, metadata_handle, array);</span>

 917 
 918   const OopMapSet* oopMapSet = installer.oopMapSet();
 919   {
 920     ResourceMark mark;
 921     ImmutableOopMapBuilder builder(oopMapSet);
<span class="line-modified"> 922     int size = builder.heap_size();</span>
<span class="line-modified"> 923     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));</span>
<span class="line-modified"> 924     builder.generate_into((address) HotSpotJVMCI::resolve(array)-&gt;byte_at_addr(0));</span>
<span class="line-modified"> 925     HotSpotJVMCI::HotSpotMetaData::set_oopMaps(JVMCIENV, metadata_handle, array);</span>
 926   }
 927 
 928   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
 929 
 930   int nr_meta_refs = recorder-&gt;nr_meta_refs();
<span class="line-modified"> 931   JVMCIObjectArray metadataArray = JVMCIENV-&gt;new_Object_array(nr_meta_refs, JVMCI_CHECK_(JVMCI::cache_full));</span>

 932   for (int i = 0; i &lt; nr_meta_refs; ++i) {
 933     jobject element = recorder-&gt;meta_element(i);
 934     if (element == NULL) {
<span class="line-modified"> 935       return JVMCI::cache_full;</span>
 936     }
<span class="line-modified"> 937     JVMCIENV-&gt;put_object_at(metadataArray, i, JVMCIENV-&gt;wrap(element));</span>
 938   }
<span class="line-modified"> 939   HotSpotJVMCI::HotSpotMetaData::set_metadata(JVMCIENV, metadata_handle, metadataArray);</span>
 940 
 941   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 942   int table_size = handler-&gt;size_in_bytes();
<span class="line-modified"> 943   JVMCIPrimitiveArray exceptionArray = JVMCIENV-&gt;new_byteArray(table_size, JVMCI_CHECK_(JVMCI::cache_full));</span>

 944   if (table_size &gt; 0) {
<span class="line-modified"> 945     handler-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(exceptionArray)-&gt;byte_at_addr(0));</span>
 946   }
<span class="line-modified"> 947   HotSpotJVMCI::HotSpotMetaData::set_exceptionBytes(JVMCIENV, metadata_handle, exceptionArray);</span>
<span class="line-added"> 948 </span>
<span class="line-added"> 949   ImplicitExceptionTable* implicit = code_metadata.get_implicit_exception_table();</span>
<span class="line-added"> 950   int implicit_table_size = implicit-&gt;size_in_bytes();</span>
<span class="line-added"> 951   JVMCIPrimitiveArray implicitExceptionArray = JVMCIENV-&gt;new_byteArray(implicit_table_size, JVMCI_CHECK_(JVMCI::cache_full));</span>
<span class="line-added"> 952   if (implicit_table_size &gt; 0) {</span>
<span class="line-added"> 953     implicit-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(implicitExceptionArray)-&gt;byte_at_addr(0), implicit_table_size);</span>
<span class="line-added"> 954   }</span>
<span class="line-added"> 955   HotSpotJVMCI::HotSpotMetaData::set_implicitExceptionBytes(JVMCIENV, metadata_handle, implicitExceptionArray);</span>
 956 
 957   return result;
 958 #else
<span class="line-modified"> 959   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);</span>
 960 #endif
 961 C2V_END
 962 
<span class="line-modified"> 963 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv* env, jobject))</span>
 964   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
 965   CompilerStatistics* stats = compiler-&gt;stats();
 966   stats-&gt;_standard.reset();
 967   stats-&gt;_osr.reset();
 968 C2V_END
 969 
<span class="line-modified"> 970 C2V_VMENTRY_NULL(jobject, disassembleCodeBlob, (JNIEnv* env, jobject, jobject installedCode))</span>

 971   HandleMark hm;
 972 
 973   if (installedCode == NULL) {
<span class="line-modified"> 974     JVMCI_THROW_MSG_NULL(NullPointerException, &quot;installedCode is null&quot;);</span>





 975   }
 976 
<span class="line-modified"> 977   JVMCIObject installedCodeObject = JVMCIENV-&gt;wrap(installedCode);</span>
<span class="line-added"> 978   nmethodLocker locker;</span>
<span class="line-added"> 979   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(installedCodeObject, locker);</span>
 980   if (cb == NULL) {
 981     return NULL;
 982   }
 983 
 984   // We don&#39;t want the stringStream buffer to resize during disassembly as it
 985   // uses scoped resource memory. If a nested function called during disassembly uses
 986   // a ResourceMark and the buffer expands within the scope of the mark,
 987   // the buffer becomes garbage when that scope is exited. Experience shows that
 988   // the disassembled code is typically about 10x the code size so a fixed buffer
 989   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 990   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 991   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 992   stringStream st(buffer, bufferSize);
 993   if (cb-&gt;is_nmethod()) {
 994     nmethod* nm = (nmethod*) cb;
 995     if (!nm-&gt;is_alive()) {
 996       return NULL;
 997     }
 998   }
 999   Disassembler::decode(cb, &amp;st);
1000   if (st.size() &lt;= 0) {
1001     return NULL;
1002   }
1003 
<span class="line-modified">1004   JVMCIObject result = JVMCIENV-&gt;create_string(st.as_string(), JVMCI_CHECK_NULL);</span>
<span class="line-modified">1005   return JVMCIENV-&gt;get_jobject(result);</span>
1006 C2V_END
1007 
<span class="line-modified">1008 C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, jobject jvmci_method, int bci))</span>

1009   HandleMark hm;
1010 
<span class="line-modified">1011   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
<span class="line-modified">1012   JVMCIObject element = JVMCIENV-&gt;new_StackTraceElement(method, bci, JVMCI_CHECK_NULL);</span>
<span class="line-modified">1013   return JVMCIENV-&gt;get_jobject(element);</span>
1014 C2V_END
1015 
<span class="line-modified">1016 C2V_VMENTRY_NULL(jobject, executeHotSpotNmethod, (JNIEnv* env, jobject, jobject args, jobject hs_nmethod))</span>
<span class="line-modified">1017   // The incoming arguments array would have to contain JavaConstants instead of regular objects</span>
<span class="line-added">1018   // and the return value would have to be wrapped as a JavaConstant.</span>
<span class="line-added">1019   requireInHotSpot(&quot;executeHotSpotNmethod&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">1020 </span>
1021   HandleMark hm;
1022 
<span class="line-modified">1023   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);</span>
<span class="line-modified">1024   nmethodLocker locker;</span>
<span class="line-modified">1025   nmethod* nm = JVMCIENV-&gt;get_nmethod(nmethod_mirror, locker);</span>
<span class="line-added">1026   if (nm == NULL) {</span>
<span class="line-added">1027     JVMCI_THROW_NULL(InvalidInstalledCodeException);</span>
1028   }
<span class="line-modified">1029   methodHandle mh(THREAD, nm-&gt;method());</span>

1030   Symbol* signature = mh-&gt;signature();
1031   JavaCallArguments jca(mh-&gt;size_of_parameters());
1032 
1033   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
<span class="line-modified">1034   JavaValue result(jap.return_type());</span>
1035   jca.set_alternative_target(nm);
1036   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1037 
<span class="line-modified">1038   if (jap.return_type() == T_VOID) {</span>
1039     return NULL;
<span class="line-modified">1040   } else if (is_reference_type(jap.return_type())) {</span>
<span class="line-modified">1041     return JNIHandles::make_local((oop) result.get_jobject());</span>
1042   } else {
1043     jvalue *value = (jvalue *) result.get_value_addr();
1044     // Narrow the value down if required (Important on big endian machines)
<span class="line-modified">1045     switch (jap.return_type()) {</span>
1046       case T_BOOLEAN:
1047        value-&gt;z = (jboolean) value-&gt;i;
1048        break;
1049       case T_BYTE:
1050        value-&gt;b = (jbyte) value-&gt;i;
1051        break;
1052       case T_CHAR:
1053        value-&gt;c = (jchar) value-&gt;i;
1054        break;
1055       case T_SHORT:
1056        value-&gt;s = (jshort) value-&gt;i;
1057        break;
1058       default:
1059         break;
1060     }
<span class="line-modified">1061     JVMCIObject o = JVMCIENV-&gt;create_box(jap.return_type(), value, JVMCI_CHECK_NULL);</span>
<span class="line-modified">1062     return JVMCIENV-&gt;get_jobject(o);</span>
1063   }
1064 C2V_END
1065 
<span class="line-modified">1066 C2V_VMENTRY_NULL(jlongArray, getLineNumberTable, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">1067   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
1068   if (!method-&gt;has_linenumber_table()) {
1069     return NULL;
1070   }
1071   u2 num_entries = 0;
1072   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1073   while (streamForSize.read_pair()) {
1074     num_entries++;
1075   }
1076 
1077   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
<span class="line-modified">1078   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(2 * num_entries, JVMCI_CHECK_NULL);</span>
1079 
1080   int i = 0;
1081   jlong value;
1082   while (stream.read_pair()) {
1083     value = ((long) stream.bci());
<span class="line-modified">1084     JVMCIENV-&gt;put_long_at(result, i, value);</span>
1085     value = ((long) stream.line());
<span class="line-modified">1086     JVMCIENV-&gt;put_long_at(result, i + 1, value);</span>
1087     i += 2;
1088   }
1089 
<span class="line-modified">1090   return (jlongArray) JVMCIENV-&gt;get_jobject(result);</span>
1091 C2V_END
1092 
<span class="line-modified">1093 C2V_VMENTRY_0(jlong, getLocalVariableTableStart, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">1094   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>

1095   if (!method-&gt;has_localvariable_table()) {
1096     return 0;
1097   }
1098   return (jlong) (address) method-&gt;localvariable_table_start();
1099 C2V_END
1100 
<span class="line-modified">1101 C2V_VMENTRY_0(jint, getLocalVariableTableLength, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">1102   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>

1103   return method-&gt;localvariable_table_length();
1104 C2V_END
1105 
<span class="line-modified">1106 C2V_VMENTRY(void, reprofile, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-modified">1107   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
1108   MethodCounters* mcs = method-&gt;method_counters();
1109   if (mcs != NULL) {
1110     mcs-&gt;clear_counters();
1111   }
1112   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1113 
1114   CompiledMethod* code = method-&gt;code();
1115   if (code != NULL) {
1116     code-&gt;make_not_entrant();
1117   }
1118 
1119   MethodData* method_data = method-&gt;method_data();
1120   if (method_data == NULL) {
1121     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1122     method_data = MethodData::allocate(loader_data, method, CHECK);
1123     method-&gt;set_method_data(method_data);
1124   } else {
1125     method_data-&gt;initialize();
1126   }
1127 C2V_END
1128 
1129 
<span class="line-modified">1130 C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod))</span>
<span class="line-modified">1131   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);</span>
<span class="line-modified">1132   JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK);</span>
<span class="line-added">1133 C2V_END</span>
<span class="line-added">1134 </span>
<span class="line-added">1135 C2V_VMENTRY_NULL(jobject, readUncompressedOop, (JNIEnv* env, jobject, jlong addr))</span>
<span class="line-added">1136   oop ret = RawAccess&lt;&gt;::oop_load((oop*)(address)addr);</span>
<span class="line-added">1137   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(ret));</span>
<span class="line-added">1138  C2V_END</span>
<span class="line-added">1139 </span>
<span class="line-added">1140 C2V_VMENTRY_NULL(jlongArray, collectCounters, (JNIEnv* env, jobject))</span>
<span class="line-added">1141   // Returns a zero length array if counters aren&#39;t enabled</span>
<span class="line-added">1142   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_longArray(JVMCICounterSize, JVMCI_CHECK_NULL);</span>
<span class="line-added">1143   if (JVMCICounterSize &gt; 0) {</span>
<span class="line-added">1144     jlong* temp_array = NEW_RESOURCE_ARRAY(jlong, JVMCICounterSize);</span>
<span class="line-added">1145     JavaThread::collect_counters(temp_array, JVMCICounterSize);</span>
<span class="line-added">1146     JVMCIENV-&gt;copy_longs_from(temp_array, array, 0, JVMCICounterSize);</span>
<span class="line-added">1147   }</span>
<span class="line-added">1148   return (jlongArray) JVMCIENV-&gt;get_jobject(array);</span>
<span class="line-added">1149 C2V_END</span>
<span class="line-added">1150 </span>
<span class="line-added">1151 C2V_VMENTRY_0(jint, getCountersSize, (JNIEnv* env, jobject))</span>
<span class="line-added">1152   return (jint) JVMCICounterSize;</span>
1153 C2V_END
1154 
<span class="line-modified">1155 C2V_VMENTRY(void, setCountersSize, (JNIEnv* env, jobject, jint new_size))</span>
<span class="line-modified">1156   JavaThread::resize_all_jvmci_counters(new_size);</span>


1157 C2V_END
1158 
<span class="line-modified">1159 C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci))</span>
1160   HandleMark hm;
<span class="line-modified">1161   if (jvmci_method == NULL) {</span>
<span class="line-modified">1162     JVMCI_THROW_0(NullPointerException);</span>

1163   }
<span class="line-modified">1164   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
1165   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
<span class="line-modified">1166     JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Unexpected bci %d&quot;, entry_bci));</span>
1167   }
1168   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1169 C2V_END
1170 
1171 
<span class="line-modified">1172 C2V_VMENTRY_0(jboolean, isMature, (JNIEnv* env, jobject, jlong metaspace_method_data))</span>
<span class="line-modified">1173   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);</span>
1174   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1175 C2V_END
1176 
<span class="line-modified">1177 C2V_VMENTRY_0(jboolean, hasCompiledCodeForOSR, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci, int comp_level))</span>
<span class="line-modified">1178   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);</span>
1179   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1180 C2V_END
1181 
<span class="line-modified">1182 C2V_VMENTRY_NULL(jobject, getSymbol, (JNIEnv* env, jobject, jlong symbol))</span>
<span class="line-modified">1183   JVMCIObject sym = JVMCIENV-&gt;create_string((Symbol*)(address)symbol, JVMCI_CHECK_NULL);</span>
<span class="line-modified">1184   return JVMCIENV-&gt;get_jobject(sym);</span>
1185 C2V_END
1186 
<span class="line-modified">1187 bool matches(jobjectArray methods, Method* method, JVMCIEnv* JVMCIENV) {</span>
1188   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1189 
1190   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1191     oop resolved = methods_oop-&gt;obj_at(i);
<span class="line-modified">1192     if ((resolved-&gt;klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; HotSpotJVMCI::asMethod(JVMCIENV, resolved) == method) {</span>
1193       return true;
1194     }
1195   }
1196   return false;
1197 }
1198 
1199 void call_interface(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
1200   CallInfo callinfo;
1201   Handle receiver = args-&gt;receiver();
1202   Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
1203   LinkInfo link_info(spec_klass, name, signature);
1204   LinkResolver::resolve_interface_call(
1205           callinfo, receiver, recvrKlass, link_info, true, CHECK);
<span class="line-modified">1206   methodHandle method(THREAD, callinfo.selected_method());</span>
1207   assert(method.not_null(), &quot;should have thrown exception&quot;);
1208 
1209   // Invoke the method
1210   JavaCalls::call(result, method, args, CHECK);
1211 }
1212 
<span class="line-modified">1213 C2V_VMENTRY_NULL(jobject, iterateFrames, (JNIEnv* env, jobject compilerToVM, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, jobject visitor_handle))</span>

1214 
1215   if (!thread-&gt;has_last_Java_frame()) {
1216     return NULL;
1217   }
1218   Handle visitor(THREAD, JNIHandles::resolve_non_null(visitor_handle));


1219 
<span class="line-modified">1220   requireInHotSpot(&quot;iterateFrames&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">1221 </span>
<span class="line-added">1222   HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);</span>
<span class="line-added">1223   Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);</span>
1224 
<span class="line-added">1225   StackFrameStream fst(thread);</span>
1226   jobjectArray methods = initial_methods;
1227 
1228   int frame_number = 0;
1229   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1230 
1231   while (true) {
1232     // look for the given method
1233     bool realloc_called = false;
1234     while (true) {
1235       StackValueCollection* locals = NULL;
1236       if (vf-&gt;is_compiled_frame()) {
1237         // compiled method frame
1238         compiledVFrame* cvf = compiledVFrame::cast(vf);
<span class="line-modified">1239         if (methods == NULL || matches(methods, cvf-&gt;method(), JVMCIENV)) {</span>
1240           if (initialSkip &gt; 0) {
1241             initialSkip--;
1242           } else {
1243             ScopeDesc* scope = cvf-&gt;scope();
1244             // native wrappers do not have a scope
1245             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1246               GrowableArray&lt;ScopeValue*&gt;* objects;
1247               if (!realloc_called) {
1248                 objects = scope-&gt;objects();
1249               } else {
1250                 // some object might already have been re-allocated, only reallocate the non-allocated ones
1251                 objects = new GrowableArray&lt;ScopeValue*&gt;(scope-&gt;objects()-&gt;length());
1252                 for (int i = 0; i &lt; scope-&gt;objects()-&gt;length(); i++) {
1253                   ObjectValue* sv = (ObjectValue*) scope-&gt;objects()-&gt;at(i);
1254                   if (sv-&gt;value().is_null()) {
1255                     objects-&gt;append(sv);
1256                   }
1257                 }
1258               }
<span class="line-modified">1259               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);</span>
1260               Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);
1261               realloc_called = true;
1262 
1263               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1264               assert(local_values != NULL, &quot;NULL locals&quot;);
1265               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1266               typeArrayHandle array(THREAD, array_oop);
1267               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1268                 ScopeValue* value = local_values-&gt;at(i);
1269                 if (value-&gt;is_object()) {
1270                   array-&gt;bool_at_put(i, true);
1271                 }
1272               }
<span class="line-modified">1273               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());</span>
1274             } else {
<span class="line-modified">1275               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);</span>
1276             }
1277 
1278             locals = cvf-&gt;locals();
<span class="line-modified">1279             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf-&gt;bci());</span>
<span class="line-modified">1280             methodHandle mh(THREAD, cvf-&gt;method());</span>
<span class="line-modified">1281             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);</span>
<span class="line-added">1282             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));</span>
1283           }
1284         }
1285       } else if (vf-&gt;is_interpreted_frame()) {
1286         // interpreted method frame
1287         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
<span class="line-modified">1288         if (methods == NULL || matches(methods, ivf-&gt;method(), JVMCIENV)) {</span>
1289           if (initialSkip &gt; 0) {
1290             initialSkip--;
1291           } else {
1292             locals = ivf-&gt;locals();
<span class="line-modified">1293             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf-&gt;bci());</span>
<span class="line-modified">1294             methodHandle mh(THREAD, ivf-&gt;method());</span>
<span class="line-modified">1295             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);</span>
<span class="line-modified">1296             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));</span>
<span class="line-added">1297             HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);</span>
1298           }
1299         }
1300       }
1301 
1302       // locals != NULL means that we found a matching frame and result is already partially initialized
1303       if (locals != NULL) {
1304         methods = match_methods;
<span class="line-modified">1305         HotSpotJVMCI::HotSpotStackFrameReference::set_compilerToVM(JVMCIENV, frame_reference(), JNIHandles::resolve(compilerToVM));</span>
<span class="line-modified">1306         HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) fst.current()-&gt;sp());</span>
<span class="line-modified">1307         HotSpotJVMCI::HotSpotStackFrameReference::set_frameNumber(JVMCIENV, frame_reference(), frame_number);</span>
1308 
1309         // initialize the locals array
1310         objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
1311         objArrayHandle array(THREAD, array_oop);
1312         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1313           StackValue* var = locals-&gt;at(i);
1314           if (var-&gt;type() == T_OBJECT) {
1315             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1316           }
1317         }
<span class="line-modified">1318         HotSpotJVMCI::HotSpotStackFrameReference::set_locals(JVMCIENV, frame_reference(), array());</span>
<span class="line-modified">1319         HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, frame_reference(), JNI_FALSE);</span>
1320 
1321         JavaValue result(T_OBJECT);
1322         JavaCallArguments args(visitor);
1323         args.push_oop(frame_reference);
<span class="line-modified">1324         call_interface(&amp;result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &amp;args, CHECK_NULL);</span>
1325         if (result.get_jobject() != NULL) {
1326           return JNIHandles::make_local(thread, (oop) result.get_jobject());
1327         }
1328         assert(initialSkip == 0, &quot;There should be no match before initialSkip == 0&quot;);
<span class="line-modified">1329         if (HotSpotJVMCI::HotSpotStackFrameReference::objectsMaterialized(JVMCIENV, frame_reference()) == JNI_TRUE) {</span>
1330           // the frame has been deoptimized, we need to re-synchronize the frame and vframe
<span class="line-modified">1331           intptr_t* stack_pointer = (intptr_t*) HotSpotJVMCI::HotSpotStackFrameReference::stackPointer(JVMCIENV, frame_reference());</span>
1332           fst = StackFrameStream(thread);
1333           while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1334             fst.next();
1335           }
1336           if (fst.current()-&gt;sp() != stack_pointer) {
1337             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found after deopt&quot;)
1338           }
1339           vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1340           if (!vf-&gt;is_compiled_frame()) {
1341             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)
1342           }
1343           for (int i = 0; i &lt; frame_number; i++) {
1344             if (vf-&gt;is_top()) {
1345               THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;vframe not found after deopt&quot;)
1346             }
1347             vf = vf-&gt;sender();
1348             assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1349           }
1350         }
<span class="line-modified">1351         frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);</span>
<span class="line-modified">1352         HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);</span>
1353       }
1354 
1355       if (vf-&gt;is_top()) {
1356         break;
1357       }
1358       frame_number++;
1359       vf = vf-&gt;sender();
1360     } // end of vframe loop
1361 
1362     if (fst.is_done()) {
1363       break;
1364     }
1365     fst.next();
1366     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1367     frame_number = 0;
1368   } // end of frame loop
1369 
1370   // the end was reached without finding a matching method
1371   return NULL;
1372 C2V_END
1373 
<span class="line-modified">1374 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">1375   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
1376   CallInfo callInfo;
1377   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1378   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1379   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1380 C2V_END
1381 
<span class="line-modified">1382 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">1383   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
1384   Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
1385   Symbol* name = cp-&gt;name_ref_at(index);
1386   if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
1387     CallInfo callInfo;
1388     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1389     ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1390     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1391   }
1392 C2V_END
1393 
<span class="line-modified">1394 C2V_VMENTRY_0(jint, isResolvedInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))</span>
<span class="line-modified">1395   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));</span>
1396   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1397   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
1398     // MethodHandle.invoke* --&gt; LambdaForm?
1399     ResourceMark rm;
1400 
1401     LinkInfo link_info(cp, index, CATCH);
1402 
1403     Klass* resolved_klass = link_info.resolved_klass();
1404 
1405     Symbol* name_sym = cp-&gt;name_ref_at(index);
1406 
1407     vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), &quot;!&quot;);
1408     vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), &quot;!&quot;);
1409 
<span class="line-modified">1410     methodHandle adapter_method(THREAD, cp_cache_entry-&gt;f1_as_method());</span>
1411 
1412     methodHandle resolved_method(adapter_method);
1413 
1414     // Can we treat it as a regular invokevirtual?
1415     if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
1416       vmassert(!resolved_method-&gt;is_static(),&quot;!&quot;);
1417       vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),&quot;!&quot;);
1418       vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), &quot;!&quot;);
1419       vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, &quot;!&quot;);
1420 
<span class="line-modified">1421       methodHandle m(THREAD, LinkResolver::linktime_resolve_virtual_method_or_null(link_info));</span>
1422       vmassert(m == resolved_method, &quot;!!&quot;);
1423       return -1;
1424     }
1425 
1426     return Bytecodes::_invokevirtual;
1427   }
1428   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokedynamic)) {
1429     return Bytecodes::_invokedynamic;
1430   }
1431   return -1;
1432 C2V_END
1433 
1434 
<span class="line-modified">1435 C2V_VMENTRY_NULL(jobject, getSignaturePolymorphicHolders, (JNIEnv* env, jobject))</span>
<span class="line-modified">1436   JVMCIObjectArray holders = JVMCIENV-&gt;new_String_array(2, JVMCI_CHECK_NULL);</span>
<span class="line-modified">1437   JVMCIObject mh = JVMCIENV-&gt;create_string(&quot;Ljava/lang/invoke/MethodHandle;&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-modified">1438   JVMCIObject vh = JVMCIENV-&gt;create_string(&quot;Ljava/lang/invoke/VarHandle;&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-modified">1439   JVMCIENV-&gt;put_object_at(holders, 0, mh);</span>
<span class="line-modified">1440   JVMCIENV-&gt;put_object_at(holders, 1, vh);</span>
<span class="line-modified">1441   return JVMCIENV-&gt;get_jobject(holders);</span>
1442 C2V_END
1443 
<span class="line-modified">1444 C2V_VMENTRY_0(jboolean, shouldDebugNonSafepoints, (JNIEnv* env, jobject))</span>
1445   //see compute_recording_non_safepoints in debugInfroRec.cpp
1446   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1447     return true;
1448   }
1449   return DebugNonSafepoints;
1450 C2V_END
1451 
1452 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
<span class="line-modified">1453 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv* env, jobject, jobject _hs_frame, bool invalidate))</span>
<span class="line-modified">1454   JVMCIObject hs_frame = JVMCIENV-&gt;wrap(_hs_frame);</span>
<span class="line-modified">1455   if (hs_frame.is_null()) {</span>
<span class="line-modified">1456     JVMCI_THROW_MSG(NullPointerException, &quot;stack frame is null&quot;);</span>

1457   }
1458 
<span class="line-modified">1459   requireInHotSpot(&quot;materializeVirtualObjects&quot;, JVMCI_CHECK);</span>
<span class="line-added">1460 </span>
<span class="line-added">1461   JVMCIENV-&gt;HotSpotStackFrameReference_initialize(JVMCI_CHECK);</span>
1462 
1463   // look for the given stack frame
<span class="line-modified">1464   StackFrameStream fst(thread, false);</span>
<span class="line-modified">1465   intptr_t* stack_pointer = (intptr_t*) JVMCIENV-&gt;get_HotSpotStackFrameReference_stackPointer(hs_frame);</span>
1466   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1467     fst.next();
1468   }
1469   if (fst.current()-&gt;sp() != stack_pointer) {
<span class="line-modified">1470     JVMCI_THROW_MSG(IllegalStateException, &quot;stack frame not found&quot;);</span>
1471   }
1472 
1473   if (invalidate) {
1474     if (!fst.current()-&gt;is_compiled_frame()) {
<span class="line-modified">1475       JVMCI_THROW_MSG(IllegalStateException, &quot;compiled stack frame expected&quot;);</span>
1476     }
1477     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), &quot;nmethod expected&quot;);
1478     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1479   }
<span class="line-modified">1480   Deoptimization::deoptimize(thread, *fst.current(), Deoptimization::Reason_none);</span>
1481   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1482   StackFrameStream fstAfterDeopt(thread);
1483   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1484     fstAfterDeopt.next();
1485   }
1486   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
<span class="line-modified">1487     JVMCI_THROW_MSG(IllegalStateException, &quot;stack frame not found after deopt&quot;);</span>
1488   }
1489 
1490   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1491   if (!vf-&gt;is_compiled_frame()) {
<span class="line-modified">1492     JVMCI_THROW_MSG(IllegalStateException, &quot;compiled stack frame expected&quot;);</span>
1493   }
1494 
1495   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1496   while (true) {
1497     assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1498     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1499     if (vf-&gt;is_top()) {
1500       break;
1501     }
1502     vf = vf-&gt;sender();
1503   }
1504 
<span class="line-modified">1505   int last_frame_number = JVMCIENV-&gt;get_HotSpotStackFrameReference_frameNumber(hs_frame);</span>
1506   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
<span class="line-modified">1507     JVMCI_THROW_MSG(IllegalStateException, &quot;invalid frame number&quot;);</span>
1508   }
1509 
1510   // Reallocate the non-escaping objects and restore their fields.
1511   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,&quot;invalid scope&quot;);
1512   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1513 
1514   if (objects == NULL) {
1515     // no objects to materialize
1516     return;
1517   }
1518 
<span class="line-modified">1519   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, CHECK);</span>
1520   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1521 
1522   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1523     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1524 
1525     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1526     StackValueCollection* locals = cvf-&gt;locals();
1527     if (locals != NULL) {
1528       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1529         StackValue* var = locals-&gt;at(i2);
1530         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1531           jvalue val;
<span class="line-modified">1532           val.l = cast_from_oop&lt;jobject&gt;(locals-&gt;at(i2)-&gt;get_obj()());</span>
1533           cvf-&gt;update_local(T_OBJECT, i2, val);
1534         }
1535       }
1536     }
1537 
1538     GrowableArray&lt;ScopeValue*&gt;* scopeExpressions = cvf-&gt;scope()-&gt;expressions();
1539     StackValueCollection* expressions = cvf-&gt;expressions();
1540     if (expressions != NULL) {
1541       for (int i2 = 0; i2 &lt; expressions-&gt;size(); i2++) {
1542         StackValue* var = expressions-&gt;at(i2);
1543         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeExpressions-&gt;at(i2)-&gt;is_object()) {
1544           jvalue val;
<span class="line-modified">1545           val.l = cast_from_oop&lt;jobject&gt;(expressions-&gt;at(i2)-&gt;get_obj()());</span>
1546           cvf-&gt;update_stack(T_OBJECT, i2, val);
1547         }
1548       }
1549     }
1550 
1551     GrowableArray&lt;MonitorValue*&gt;* scopeMonitors = cvf-&gt;scope()-&gt;monitors();
1552     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
1553     if (monitors != NULL) {
1554       for (int i2 = 0; i2 &lt; monitors-&gt;length(); i2++) {
1555         cvf-&gt;update_monitor(i2, monitors-&gt;at(i2));
1556       }
1557     }
1558   }
1559 
1560   // all locals are materialized by now
<span class="line-modified">1561   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);</span>

1562   // update the locals array
<span class="line-modified">1563   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);</span>
1564   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1565   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1566     StackValue* var = locals-&gt;at(i);
1567     if (var-&gt;type() == T_OBJECT) {
<span class="line-modified">1568       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));</span>
1569     }
1570   }
<span class="line-modified">1571   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);</span>
1572 C2V_END
1573 
<span class="line-modified">1574 // Creates a scope where the current thread is attached and detached</span>
<span class="line-added">1575 // from HotSpot if it wasn&#39;t already attached when entering the scope.</span>
<span class="line-added">1576 extern &quot;C&quot; void jio_printf(const char *fmt, ...);</span>
<span class="line-added">1577 class AttachDetach : public StackObj {</span>
<span class="line-added">1578  public:</span>
<span class="line-added">1579   bool _attached;</span>
<span class="line-added">1580   AttachDetach(JNIEnv* env, Thread* current_thread) {</span>
<span class="line-added">1581     if (current_thread == NULL) {</span>
<span class="line-added">1582       extern struct JavaVM_ main_vm;</span>
<span class="line-added">1583       JNIEnv* hotspotEnv;</span>
<span class="line-added">1584       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);</span>
<span class="line-added">1585       _attached = res == JNI_OK;</span>
<span class="line-added">1586       static volatile int report_attach_error = 0;</span>
<span class="line-added">1587       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {</span>
<span class="line-added">1588         // Only report an attach error once</span>
<span class="line-added">1589         jio_printf(&quot;Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n&quot;, res);</span>
<span class="line-added">1590       }</span>
<span class="line-added">1591     } else {</span>
<span class="line-added">1592       _attached = false;</span>
<span class="line-added">1593     }</span>
<span class="line-added">1594   }</span>
<span class="line-added">1595   ~AttachDetach() {</span>
<span class="line-added">1596     if (_attached &amp;&amp; get_current_thread() != NULL) {</span>
<span class="line-added">1597       extern struct JavaVM_ main_vm;</span>
<span class="line-added">1598       jint res = main_vm.DetachCurrentThread();</span>
<span class="line-added">1599       static volatile int report_detach_error = 0;</span>
<span class="line-added">1600       if (res != JNI_OK &amp;&amp; report_detach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_detach_error, 0, 1) == 0) {</span>
<span class="line-added">1601         // Only report an attach error once</span>
<span class="line-added">1602         jio_printf(&quot;Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\n&quot;, res);</span>
<span class="line-added">1603       }</span>
<span class="line-added">1604     }</span>
<span class="line-added">1605   }</span>
<span class="line-added">1606 };</span>
<span class="line-added">1607 </span>
<span class="line-added">1608 C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))</span>
<span class="line-added">1609   AttachDetach ad(env, base_thread);</span>
<span class="line-added">1610   bool use_tty = true;</span>
<span class="line-added">1611   if (base_thread == NULL) {</span>
<span class="line-added">1612     if (!ad._attached) {</span>
<span class="line-added">1613       // Can only use tty if the current thread is attached</span>
<span class="line-added">1614       return 0;</span>
<span class="line-added">1615     }</span>
<span class="line-added">1616     base_thread = get_current_thread();</span>
<span class="line-added">1617   }</span>
<span class="line-added">1618   JVMCITraceMark jtm(&quot;writeDebugOutput&quot;);</span>
<span class="line-added">1619   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);</span>
<span class="line-added">1620   JavaThread* thread = (JavaThread*) base_thread;</span>
<span class="line-added">1621   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))</span>
1622   if (bytes == NULL) {
<span class="line-modified">1623     if (can_throw) {</span>
<span class="line-added">1624       JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">1625     }</span>
<span class="line-added">1626     return -1;</span>
1627   }
<span class="line-modified">1628   JVMCIPrimitiveArray array = JVMCIENV-&gt;wrap(bytes);</span>
1629 
1630   // Check if offset and length are non negative.
1631   if (offset &lt; 0 || length &lt; 0) {
<span class="line-modified">1632     if (can_throw) {</span>
<span class="line-added">1633       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);</span>
<span class="line-added">1634     }</span>
<span class="line-added">1635     return -2;</span>
1636   }
1637   // Check if the range is valid.
<span class="line-modified">1638   int array_length = JVMCIENV-&gt;get_length(array);</span>
<span class="line-modified">1639   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array_length)) {</span>
<span class="line-added">1640     if (can_throw) {</span>
<span class="line-added">1641       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);</span>
<span class="line-added">1642     }</span>
<span class="line-added">1643     return -2;</span>
1644   }
<span class="line-added">1645   jbyte buffer[O_BUFLEN];</span>
1646   while (length &gt; 0) {
<span class="line-modified">1647     int copy_len = MIN2(length, (jint)O_BUFLEN);</span>
<span class="line-modified">1648     JVMCIENV-&gt;copy_bytes_to(array, buffer, offset, copy_len);</span>
<span class="line-added">1649     tty-&gt;write((char*) buffer, copy_len);</span>
1650     length -= O_BUFLEN;
1651     offset += O_BUFLEN;
1652   }
<span class="line-added">1653   if (flush) {</span>
<span class="line-added">1654     tty-&gt;flush();</span>
<span class="line-added">1655   }</span>
<span class="line-added">1656   return 0;</span>
1657 C2V_END
1658 
<span class="line-modified">1659 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv* env, jobject))</span>
1660   tty-&gt;flush();
1661 C2V_END
1662 
<span class="line-modified">1663 C2V_VMENTRY_0(jint, methodDataProfileDataSize, (JNIEnv* env, jobject, jlong metaspace_method_data, jint position))</span>
<span class="line-modified">1664   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);</span>

1665   ProfileData* profile_data = mdo-&gt;data_at(position);
1666   if (mdo-&gt;is_valid(profile_data)) {
1667     return profile_data-&gt;size_in_bytes();
1668   }
1669   DataLayout* data    = mdo-&gt;extra_data_base();
1670   DataLayout* end   = mdo-&gt;extra_data_limit();
1671   for (;; data = mdo-&gt;next_extra(data)) {
1672     assert(data &lt; end, &quot;moved past end of extra data&quot;);
1673     profile_data = data-&gt;data_in();
1674     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1675       return profile_data-&gt;size_in_bytes();
1676     }
1677   }
<span class="line-modified">1678   JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Invalid profile data position %d&quot;, position));</span>
1679 C2V_END
1680 
<span class="line-modified">1681 C2V_VMENTRY_0(jlong, getFingerprint, (JNIEnv* env, jobject, jlong metaspace_klass))</span>
1682 #if INCLUDE_AOT
<span class="line-modified">1683   Klass *k = (Klass*) (address) metaspace_klass;</span>
1684   if (k-&gt;is_instance_klass()) {
1685     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1686   } else {
1687     return 0;
1688   }
1689 #else
<span class="line-modified">1690   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);</span>
1691 #endif
1692 C2V_END
1693 
<span class="line-modified">1694 C2V_VMENTRY_NULL(jobject, getHostClass, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-modified">1695   InstanceKlass* k = InstanceKlass::cast(JVMCIENV-&gt;asKlass(jvmci_type));</span>
1696   InstanceKlass* host = k-&gt;unsafe_anonymous_host();
1697   JVMCIKlassHandle handle(THREAD, host);
<span class="line-modified">1698   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);</span>
<span class="line-modified">1699   return JVMCIENV-&gt;get_jobject(result);</span>
1700 C2V_END
1701 
<span class="line-modified">1702 C2V_VMENTRY_NULL(jobject, getInterfaces, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-added">1703   if (jvmci_type == NULL) {</span>
<span class="line-added">1704     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">1705   }</span>
<span class="line-added">1706 </span>
<span class="line-added">1707   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
<span class="line-added">1708   if (klass == NULL) {</span>
<span class="line-added">1709     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">1710   }</span>
<span class="line-added">1711   if (!klass-&gt;is_instance_klass()) {</span>
<span class="line-added">1712     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be instance klass&quot;, klass-&gt;external_name()));</span>
<span class="line-added">1713   }</span>
<span class="line-added">1714   InstanceKlass* iklass = InstanceKlass::cast(klass);</span>
<span class="line-added">1715 </span>
<span class="line-added">1716   // Regular instance klass, fill in all local interfaces</span>
<span class="line-added">1717   int size = iklass-&gt;local_interfaces()-&gt;length();</span>
<span class="line-added">1718   JVMCIObjectArray interfaces = JVMCIENV-&gt;new_HotSpotResolvedObjectTypeImpl_array(size, JVMCI_CHECK_NULL);</span>
<span class="line-added">1719   for (int index = 0; index &lt; size; index++) {</span>
<span class="line-added">1720     JVMCIKlassHandle klass(THREAD);</span>
<span class="line-added">1721     Klass* k = iklass-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-added">1722     klass = k;</span>
<span class="line-added">1723     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);</span>
<span class="line-added">1724     JVMCIENV-&gt;put_object_at(interfaces, index, type);</span>
<span class="line-added">1725   }</span>
<span class="line-added">1726   return JVMCIENV-&gt;get_jobject(interfaces);</span>
<span class="line-added">1727 C2V_END</span>
<span class="line-added">1728 </span>
<span class="line-added">1729 C2V_VMENTRY_NULL(jobject, getComponentType, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-added">1730   if (jvmci_type == NULL) {</span>
<span class="line-added">1731     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">1732   }</span>
<span class="line-added">1733 </span>
<span class="line-added">1734   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
<span class="line-added">1735   oop mirror = klass-&gt;java_mirror();</span>
<span class="line-added">1736   if (java_lang_Class::is_primitive(mirror) ||</span>
<span class="line-added">1737       !java_lang_Class::as_Klass(mirror)-&gt;is_array_klass()) {</span>
<span class="line-added">1738     return NULL;</span>
<span class="line-added">1739   }</span>
<span class="line-added">1740 </span>
<span class="line-added">1741   oop component_mirror = java_lang_Class::component_mirror(mirror);</span>
<span class="line-added">1742   if (component_mirror == NULL) {</span>
<span class="line-added">1743     return NULL;</span>
<span class="line-added">1744   }</span>
<span class="line-added">1745   Klass* component_klass = java_lang_Class::as_Klass(component_mirror);</span>
<span class="line-added">1746   if (component_klass != NULL) {</span>
<span class="line-added">1747     JVMCIKlassHandle klass_handle(THREAD);</span>
<span class="line-added">1748     klass_handle = component_klass;</span>
<span class="line-added">1749     JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);</span>
<span class="line-added">1750     return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">1751   }</span>
<span class="line-added">1752   BasicType type = java_lang_Class::primitive_type(component_mirror);</span>
<span class="line-added">1753   JVMCIObject result = JVMCIENV-&gt;get_jvmci_primitive_type(type);</span>
<span class="line-added">1754   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">1755 C2V_END</span>
<span class="line-added">1756 </span>
<span class="line-added">1757 C2V_VMENTRY(void, ensureInitialized, (JNIEnv* env, jobject, jobject jvmci_type))</span>
<span class="line-added">1758   if (jvmci_type == NULL) {</span>
<span class="line-added">1759     JVMCI_THROW(NullPointerException);</span>
<span class="line-added">1760   }</span>
<span class="line-added">1761 </span>
<span class="line-added">1762   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
<span class="line-added">1763   if (klass != NULL &amp;&amp; klass-&gt;should_be_initialized()) {</span>
<span class="line-added">1764     InstanceKlass* k = InstanceKlass::cast(klass);</span>
<span class="line-added">1765     k-&gt;initialize(CHECK);</span>
<span class="line-added">1766   }</span>
<span class="line-added">1767 C2V_END</span>
<span class="line-added">1768 </span>
<span class="line-added">1769 C2V_VMENTRY_0(jint, interpreterFrameSize, (JNIEnv* env, jobject, jobject bytecode_frame_handle))</span>
1770   if (bytecode_frame_handle == NULL) {
<span class="line-modified">1771     JVMCI_THROW_0(NullPointerException);</span>
1772   }
1773 
<span class="line-modified">1774   JVMCIObject top_bytecode_frame = JVMCIENV-&gt;wrap(bytecode_frame_handle);</span>
<span class="line-modified">1775   JVMCIObject bytecode_frame = top_bytecode_frame;</span>
1776   int size = 0;
1777   int callee_parameters = 0;
1778   int callee_locals = 0;
<span class="line-modified">1779   Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));</span>
<span class="line-modified">1780   int extra_args = method-&gt;max_stack() - JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);</span>
1781 
<span class="line-modified">1782   while (bytecode_frame.is_non_null()) {</span>
<span class="line-modified">1783     int locks = JVMCIENV-&gt;get_BytecodeFrame_numLocks(bytecode_frame);</span>
<span class="line-modified">1784     int temps = JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);</span>
<span class="line-modified">1785     bool is_top_frame = (JVMCIENV-&gt;equals(bytecode_frame, top_bytecode_frame));</span>
<span class="line-modified">1786     Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));</span>
1787 
1788     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1789                                                                  temps + callee_parameters,
1790                                                                  extra_args,
1791                                                                  locks,
1792                                                                  callee_parameters,
1793                                                                  callee_locals,
1794                                                                  is_top_frame);
1795     size += frame_size;
1796 
1797     callee_parameters = method-&gt;size_of_parameters();
1798     callee_locals = method-&gt;max_locals();
1799     extra_args = 0;
<span class="line-modified">1800     bytecode_frame = JVMCIENV-&gt;get_BytecodePosition_caller(bytecode_frame);</span>
1801   }
1802   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1803 C2V_END
1804 
<span class="line-modified">1805 C2V_VMENTRY(void, compileToBytecode, (JNIEnv* env, jobject, jobject lambda_form_handle))</span>
<span class="line-modified">1806   Handle lambda_form = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(lambda_form_handle), JVMCI_CHECK);</span>
1807   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
<span class="line-modified">1808     TempNewSymbol compileToBytecode = SymbolTable::new_symbol(&quot;compileToBytecode&quot;);</span>
1809     JavaValue result(T_VOID);
1810     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1811   } else {
<span class="line-modified">1812     JVMCI_THROW_MSG(IllegalArgumentException,</span>
<span class="line-modified">1813                     err_msg(&quot;Unexpected type: %s&quot;, lambda_form-&gt;klass()-&gt;external_name()))</span>
1814   }
1815 C2V_END
1816 
<span class="line-modified">1817 C2V_VMENTRY_0(jint, getIdentityHashCode, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-modified">1818   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);</span>
<span class="line-added">1819   return obj-&gt;identity_hash();</span>
<span class="line-added">1820 C2V_END</span>
<span class="line-added">1821 </span>
<span class="line-added">1822 C2V_VMENTRY_0(jboolean, isInternedString, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">1823   Handle str = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);</span>
<span class="line-added">1824   if (!java_lang_String::is_instance(str())) {</span>
<span class="line-added">1825     return false;</span>
<span class="line-added">1826   }</span>
<span class="line-added">1827   int len;</span>
<span class="line-added">1828   jchar* name = java_lang_String::as_unicode_string(str(), len, CHECK_0);</span>
<span class="line-added">1829   return (StringTable::lookup(name, len) != NULL);</span>
<span class="line-added">1830 C2V_END</span>
<span class="line-added">1831 </span>
<span class="line-added">1832 </span>
<span class="line-added">1833 C2V_VMENTRY_NULL(jobject, unboxPrimitive, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">1834   if (object == NULL) {</span>
<span class="line-added">1835     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">1836   }</span>
<span class="line-added">1837   Handle box = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);</span>
<span class="line-added">1838   BasicType type = java_lang_boxing_object::basic_type(box());</span>
<span class="line-added">1839   jvalue result;</span>
<span class="line-added">1840   if (java_lang_boxing_object::get_value(box(), &amp;result) == T_ILLEGAL) {</span>
<span class="line-added">1841     return NULL;</span>
<span class="line-added">1842   }</span>
<span class="line-added">1843   JVMCIObject boxResult = JVMCIENV-&gt;create_box(type, &amp;result, JVMCI_CHECK_NULL);</span>
<span class="line-added">1844   return JVMCIENV-&gt;get_jobject(boxResult);</span>
<span class="line-added">1845 C2V_END</span>
<span class="line-added">1846 </span>
<span class="line-added">1847 C2V_VMENTRY_NULL(jobject, boxPrimitive, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">1848   if (object == NULL) {</span>
<span class="line-added">1849     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">1850   }</span>
<span class="line-added">1851   JVMCIObject box = JVMCIENV-&gt;wrap(object);</span>
<span class="line-added">1852   BasicType type = JVMCIENV-&gt;get_box_type(box);</span>
<span class="line-added">1853   if (type == T_ILLEGAL) {</span>
<span class="line-added">1854     return NULL;</span>
<span class="line-added">1855   }</span>
<span class="line-added">1856   jvalue value = JVMCIENV-&gt;get_boxed_value(type, box);</span>
<span class="line-added">1857   JavaValue box_result(T_OBJECT);</span>
<span class="line-added">1858   JavaCallArguments jargs;</span>
<span class="line-added">1859   Klass* box_klass = NULL;</span>
<span class="line-added">1860   Symbol* box_signature = NULL;</span>
<span class="line-added">1861 #define BOX_CASE(bt, v, argtype, name)           \</span>
<span class="line-added">1862   case bt: \</span>
<span class="line-added">1863     jargs.push_##argtype(value.v); \</span>
<span class="line-added">1864     box_klass = SystemDictionary::name##_klass(); \</span>
<span class="line-added">1865     box_signature = vmSymbols::name##_valueOf_signature(); \</span>
<span class="line-added">1866     break</span>
<span class="line-added">1867 </span>
<span class="line-added">1868   switch (type) {</span>
<span class="line-added">1869     BOX_CASE(T_BOOLEAN, z, int, Boolean);</span>
<span class="line-added">1870     BOX_CASE(T_BYTE, b, int, Byte);</span>
<span class="line-added">1871     BOX_CASE(T_CHAR, c, int, Character);</span>
<span class="line-added">1872     BOX_CASE(T_SHORT, s, int, Short);</span>
<span class="line-added">1873     BOX_CASE(T_INT, i, int, Integer);</span>
<span class="line-added">1874     BOX_CASE(T_LONG, j, long, Long);</span>
<span class="line-added">1875     BOX_CASE(T_FLOAT, f, float, Float);</span>
<span class="line-added">1876     BOX_CASE(T_DOUBLE, d, double, Double);</span>
<span class="line-added">1877     default:</span>
<span class="line-added">1878       ShouldNotReachHere();</span>
<span class="line-added">1879   }</span>
<span class="line-added">1880 #undef BOX_CASE</span>
<span class="line-added">1881 </span>
<span class="line-added">1882   JavaCalls::call_static(&amp;box_result,</span>
<span class="line-added">1883                          box_klass,</span>
<span class="line-added">1884                          vmSymbols::valueOf_name(),</span>
<span class="line-added">1885                          box_signature, &amp;jargs, CHECK_NULL);</span>
<span class="line-added">1886   oop hotspot_box = (oop) box_result.get_jobject();</span>
<span class="line-added">1887   JVMCIObject result = JVMCIENV-&gt;get_object_constant(hotspot_box, false);</span>
<span class="line-added">1888   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">1889 C2V_END</span>
<span class="line-added">1890 </span>
<span class="line-added">1891 C2V_VMENTRY_NULL(jobjectArray, getDeclaredConstructors, (JNIEnv* env, jobject, jobject holder))</span>
<span class="line-added">1892   if (holder == NULL) {</span>
<span class="line-added">1893     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">1894   }</span>
<span class="line-added">1895   Klass* klass = JVMCIENV-&gt;asKlass(holder);</span>
<span class="line-added">1896   if (!klass-&gt;is_instance_klass()) {</span>
<span class="line-added">1897     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);</span>
<span class="line-added">1898     return JVMCIENV-&gt;get_jobjectArray(methods);</span>
<span class="line-added">1899   }</span>
<span class="line-added">1900 </span>
<span class="line-added">1901   InstanceKlass* iklass = InstanceKlass::cast(klass);</span>
<span class="line-added">1902   // Ensure class is linked</span>
<span class="line-added">1903   iklass-&gt;link_class(CHECK_NULL);</span>
<span class="line-added">1904 </span>
<span class="line-added">1905   GrowableArray&lt;Method*&gt; constructors_array;</span>
<span class="line-added">1906   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {</span>
<span class="line-added">1907     Method* m = iklass-&gt;methods()-&gt;at(i);</span>
<span class="line-added">1908     if (m-&gt;is_initializer() &amp;&amp; !m-&gt;is_static()) {</span>
<span class="line-added">1909       constructors_array.append(m);</span>
<span class="line-added">1910     }</span>
<span class="line-added">1911   }</span>
<span class="line-added">1912   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(constructors_array.length(), JVMCI_CHECK_NULL);</span>
<span class="line-added">1913   for (int i = 0; i &lt; constructors_array.length(); i++) {</span>
<span class="line-added">1914     methodHandle ctor(THREAD, constructors_array.at(i));</span>
<span class="line-added">1915     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(ctor, JVMCI_CHECK_NULL);</span>
<span class="line-added">1916     JVMCIENV-&gt;put_object_at(methods, i, method);</span>
<span class="line-added">1917   }</span>
<span class="line-added">1918   return JVMCIENV-&gt;get_jobjectArray(methods);</span>
<span class="line-added">1919 C2V_END</span>
<span class="line-added">1920 </span>
<span class="line-added">1921 C2V_VMENTRY_NULL(jobjectArray, getDeclaredMethods, (JNIEnv* env, jobject, jobject holder))</span>
<span class="line-added">1922   if (holder == NULL) {</span>
<span class="line-added">1923     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">1924   }</span>
<span class="line-added">1925   Klass* klass = JVMCIENV-&gt;asKlass(holder);</span>
<span class="line-added">1926   if (!klass-&gt;is_instance_klass()) {</span>
<span class="line-added">1927     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);</span>
<span class="line-added">1928     return JVMCIENV-&gt;get_jobjectArray(methods);</span>
<span class="line-added">1929   }</span>
<span class="line-added">1930 </span>
<span class="line-added">1931   InstanceKlass* iklass = InstanceKlass::cast(klass);</span>
<span class="line-added">1932   // Ensure class is linked</span>
<span class="line-added">1933   iklass-&gt;link_class(CHECK_NULL);</span>
<span class="line-added">1934 </span>
<span class="line-added">1935   GrowableArray&lt;Method*&gt; methods_array;</span>
<span class="line-added">1936   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {</span>
<span class="line-added">1937     Method* m = iklass-&gt;methods()-&gt;at(i);</span>
<span class="line-added">1938     if (!m-&gt;is_initializer() &amp;&amp; !m-&gt;is_overpass()) {</span>
<span class="line-added">1939       methods_array.append(m);</span>
<span class="line-added">1940     }</span>
<span class="line-added">1941   }</span>
<span class="line-added">1942   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(methods_array.length(), JVMCI_CHECK_NULL);</span>
<span class="line-added">1943   for (int i = 0; i &lt; methods_array.length(); i++) {</span>
<span class="line-added">1944     methodHandle mh(THREAD, methods_array.at(i));</span>
<span class="line-added">1945     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);</span>
<span class="line-added">1946     JVMCIENV-&gt;put_object_at(methods, i, method);</span>
<span class="line-added">1947   }</span>
<span class="line-added">1948   return JVMCIENV-&gt;get_jobjectArray(methods);</span>
<span class="line-added">1949 C2V_END</span>
<span class="line-added">1950 </span>
<span class="line-added">1951 C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject field, jboolean is_volatile))</span>
<span class="line-added">1952   if (object == NULL || field == NULL) {</span>
<span class="line-added">1953     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">1954   }</span>
<span class="line-added">1955   JVMCIObject field_object = JVMCIENV-&gt;wrap(field);</span>
<span class="line-added">1956   JVMCIObject java_type = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_type(field_object);</span>
<span class="line-added">1957   int modifiers = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_modifiers(field_object);</span>
<span class="line-added">1958   Klass* holder = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_holder(field_object));</span>
<span class="line-added">1959   if (!holder-&gt;is_instance_klass()) {</span>
<span class="line-added">1960     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Holder %s must be instance klass&quot;, holder-&gt;external_name()));</span>
<span class="line-added">1961   }</span>
<span class="line-added">1962   InstanceKlass* ik = InstanceKlass::cast(holder);</span>
<span class="line-added">1963   BasicType constant_type;</span>
<span class="line-added">1964   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(java_type)) {</span>
<span class="line-added">1965     constant_type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(java_type), JVMCI_CHECK_NULL);</span>
<span class="line-added">1966   } else {</span>
<span class="line-added">1967     constant_type = T_OBJECT;</span>
<span class="line-added">1968   }</span>
<span class="line-added">1969   int displacement = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_offset(field_object);</span>
<span class="line-added">1970   fieldDescriptor fd;</span>
<span class="line-added">1971   if (!ik-&gt;find_local_field_from_offset(displacement, (modifiers &amp; JVM_ACC_STATIC) != 0, &amp;fd)) {</span>
<span class="line-added">1972     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Can&#39;t find field with displacement %d&quot;, displacement));</span>
<span class="line-added">1973   }</span>
<span class="line-added">1974   JVMCIObject base = JVMCIENV-&gt;wrap(object);</span>
<span class="line-added">1975   Handle obj;</span>
<span class="line-added">1976   if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base)) {</span>
<span class="line-added">1977     obj = JVMCIENV-&gt;asConstant(base, JVMCI_CHECK_NULL);</span>
<span class="line-added">1978   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base)) {</span>
<span class="line-added">1979     Klass* klass = JVMCIENV-&gt;asKlass(base);</span>
<span class="line-added">1980     obj = Handle(THREAD, klass-&gt;java_mirror());</span>
<span class="line-added">1981   } else {</span>
<span class="line-added">1982     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
<span class="line-added">1983                          err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base)));</span>
<span class="line-added">1984   }</span>
<span class="line-added">1985   jlong value = 0;</span>
<span class="line-added">1986   JVMCIObject kind;</span>
<span class="line-added">1987   switch (constant_type) {</span>
<span class="line-added">1988     case T_OBJECT: {</span>
<span class="line-added">1989       oop object = is_volatile ? obj-&gt;obj_field_acquire(displacement) : obj-&gt;obj_field(displacement);</span>
<span class="line-added">1990       JVMCIObject result = JVMCIENV-&gt;get_object_constant(object);</span>
<span class="line-added">1991       if (result.is_null()) {</span>
<span class="line-added">1992         return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_JavaConstant_NULL_POINTER());</span>
<span class="line-added">1993       }</span>
<span class="line-added">1994       return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">1995     }</span>
<span class="line-added">1996     case T_FLOAT: {</span>
<span class="line-added">1997       float f = is_volatile ? obj-&gt;float_field_acquire(displacement) : obj-&gt;float_field(displacement);</span>
<span class="line-added">1998       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forFloat(f, JVMCI_CHECK_NULL);</span>
<span class="line-added">1999       return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">2000     }</span>
<span class="line-added">2001     case T_DOUBLE: {</span>
<span class="line-added">2002       double f = is_volatile ? obj-&gt;double_field_acquire(displacement) : obj-&gt;double_field(displacement);</span>
<span class="line-added">2003       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forDouble(f, JVMCI_CHECK_NULL);</span>
<span class="line-added">2004       return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">2005     }</span>
<span class="line-added">2006     case T_BOOLEAN: value = is_volatile ? obj-&gt;bool_field_acquire(displacement) : obj-&gt;bool_field(displacement); break;</span>
<span class="line-added">2007     case T_BYTE: value = is_volatile ? obj-&gt;byte_field_acquire(displacement) : obj-&gt;byte_field(displacement); break;</span>
<span class="line-added">2008     case T_SHORT: value = is_volatile ? obj-&gt;short_field_acquire(displacement) : obj-&gt;short_field(displacement); break;</span>
<span class="line-added">2009     case T_CHAR: value = is_volatile ? obj-&gt;char_field_acquire(displacement) : obj-&gt;char_field(displacement); break;</span>
<span class="line-added">2010     case T_INT: value = is_volatile ? obj-&gt;int_field_acquire(displacement) : obj-&gt;int_field(displacement); break;</span>
<span class="line-added">2011     case T_LONG: value = is_volatile ? obj-&gt;long_field_acquire(displacement) : obj-&gt;long_field(displacement); break;</span>
<span class="line-added">2012     default:</span>
<span class="line-added">2013       ShouldNotReachHere();</span>
<span class="line-added">2014   }</span>
<span class="line-added">2015   JVMCIObject result = JVMCIENV-&gt;call_PrimitiveConstant_forTypeChar(type2char(constant_type), value, JVMCI_CHECK_NULL);</span>
<span class="line-added">2016   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">2017 C2V_END</span>
<span class="line-added">2018 </span>
<span class="line-added">2019 C2V_VMENTRY_0(jboolean, isInstance, (JNIEnv* env, jobject, jobject holder, jobject object))</span>
<span class="line-added">2020   if (object == NULL || holder == NULL) {</span>
<span class="line-added">2021     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2022   }</span>
<span class="line-added">2023   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);</span>
<span class="line-added">2024   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));</span>
<span class="line-added">2025   return obj-&gt;is_a(klass);</span>
<span class="line-added">2026 C2V_END</span>
<span class="line-added">2027 </span>
<span class="line-added">2028 C2V_VMENTRY_0(jboolean, isAssignableFrom, (JNIEnv* env, jobject, jobject holder, jobject otherHolder))</span>
<span class="line-added">2029   if (holder == NULL || otherHolder == NULL) {</span>
<span class="line-added">2030     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2031   }</span>
<span class="line-added">2032   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));</span>
<span class="line-added">2033   Klass* otherKlass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(otherHolder));</span>
<span class="line-added">2034   return otherKlass-&gt;is_subtype_of(klass);</span>
<span class="line-added">2035 C2V_END</span>
<span class="line-added">2036 </span>
<span class="line-added">2037 C2V_VMENTRY_0(jboolean, isTrustedForIntrinsics, (JNIEnv* env, jobject, jobject holder))</span>
<span class="line-added">2038   if (holder == NULL) {</span>
<span class="line-added">2039     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2040   }</span>
<span class="line-added">2041   InstanceKlass* ik = InstanceKlass::cast(JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder)));</span>
<span class="line-added">2042   if (ik-&gt;class_loader_data()-&gt;is_boot_class_loader_data() || ik-&gt;class_loader_data()-&gt;is_platform_class_loader_data()) {</span>
<span class="line-added">2043     return true;</span>
<span class="line-added">2044   }</span>
<span class="line-added">2045   return false;</span>
<span class="line-added">2046 C2V_END</span>
<span class="line-added">2047 </span>
<span class="line-added">2048 C2V_VMENTRY_NULL(jobject, asJavaType, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">2049   if (object == NULL) {</span>
<span class="line-added">2050     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2051   }</span>
<span class="line-added">2052   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);</span>
<span class="line-added">2053   if (java_lang_Class::is_instance(obj())) {</span>
<span class="line-added">2054     if (java_lang_Class::is_primitive(obj())) {</span>
<span class="line-added">2055       JVMCIObject type = JVMCIENV-&gt;get_jvmci_primitive_type(java_lang_Class::primitive_type(obj()));</span>
<span class="line-added">2056       return JVMCIENV-&gt;get_jobject(type);</span>
<span class="line-added">2057     }</span>
<span class="line-added">2058     Klass* klass = java_lang_Class::as_Klass(obj());</span>
<span class="line-added">2059     JVMCIKlassHandle klass_handle(THREAD);</span>
<span class="line-added">2060     klass_handle = klass;</span>
<span class="line-added">2061     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);</span>
<span class="line-added">2062     return JVMCIENV-&gt;get_jobject(type);</span>
<span class="line-added">2063   }</span>
<span class="line-added">2064   return NULL;</span>
<span class="line-added">2065 C2V_END</span>
<span class="line-added">2066 </span>
<span class="line-added">2067 </span>
<span class="line-added">2068 C2V_VMENTRY_NULL(jobject, asString, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">2069   if (object == NULL) {</span>
<span class="line-added">2070     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2071   }</span>
<span class="line-added">2072   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);</span>
<span class="line-added">2073   const char* str = java_lang_String::as_utf8_string(obj());</span>
<span class="line-added">2074   JVMCIObject result = JVMCIENV-&gt;create_string(str, JVMCI_CHECK_NULL);</span>
<span class="line-added">2075   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">2076 C2V_END</span>
<span class="line-added">2077 </span>
<span class="line-added">2078 </span>
<span class="line-added">2079 C2V_VMENTRY_0(jboolean, equals, (JNIEnv* env, jobject, jobject x, jlong xHandle, jobject y, jlong yHandle))</span>
<span class="line-added">2080   if (x == NULL || y == NULL) {</span>
<span class="line-added">2081     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2082   }</span>
<span class="line-added">2083   return JVMCIENV-&gt;resolve_handle(xHandle) == JVMCIENV-&gt;resolve_handle(yHandle);</span>
<span class="line-added">2084 C2V_END</span>
<span class="line-added">2085 </span>
<span class="line-added">2086 C2V_VMENTRY_NULL(jobject, getJavaMirror, (JNIEnv* env, jobject, jobject object))</span>
<span class="line-added">2087   if (object == NULL) {</span>
<span class="line-added">2088     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2089   }</span>
<span class="line-added">2090   JVMCIObject base_object = JVMCIENV-&gt;wrap(object);</span>
<span class="line-added">2091   Handle mirror;</span>
<span class="line-added">2092   if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {</span>
<span class="line-added">2093     mirror = Handle(THREAD, JVMCIENV-&gt;asKlass(base_object)-&gt;java_mirror());</span>
<span class="line-added">2094   } else if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(base_object)) {</span>
<span class="line-added">2095     mirror = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_mirror(base_object), JVMCI_CHECK_NULL);</span>
<span class="line-added">2096   } else {</span>
<span class="line-added">2097     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
<span class="line-added">2098                          err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base_object)));</span>
<span class="line-added">2099  }</span>
<span class="line-added">2100   JVMCIObject result = JVMCIENV-&gt;get_object_constant(mirror());</span>
<span class="line-added">2101   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">2102 C2V_END</span>
<span class="line-added">2103 </span>
<span class="line-added">2104 </span>
<span class="line-added">2105 C2V_VMENTRY_0(jint, getArrayLength, (JNIEnv* env, jobject, jobject x))</span>
<span class="line-added">2106   if (x == NULL) {</span>
<span class="line-added">2107     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2108   }</span>
<span class="line-added">2109   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">2110   if (xobj-&gt;klass()-&gt;is_array_klass()) {</span>
<span class="line-added">2111     return arrayOop(xobj())-&gt;length();</span>
<span class="line-added">2112   }</span>
<span class="line-added">2113   return -1;</span>
<span class="line-added">2114  C2V_END</span>
<span class="line-added">2115 </span>
<span class="line-added">2116 </span>
<span class="line-added">2117 C2V_VMENTRY_NULL(jobject, readArrayElement, (JNIEnv* env, jobject, jobject x, int index))</span>
<span class="line-added">2118   if (x == NULL) {</span>
<span class="line-added">2119     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2120   }</span>
<span class="line-added">2121   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_NULL);</span>
<span class="line-added">2122   if (xobj-&gt;klass()-&gt;is_array_klass()) {</span>
<span class="line-added">2123     arrayOop array = arrayOop(xobj());</span>
<span class="line-added">2124     BasicType element_type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();</span>
<span class="line-added">2125     if (index &lt; 0 || index &gt;= array-&gt;length()) {</span>
<span class="line-added">2126       return NULL;</span>
<span class="line-added">2127     }</span>
<span class="line-added">2128     JVMCIObject result;</span>
<span class="line-added">2129 </span>
<span class="line-added">2130     if (element_type == T_OBJECT) {</span>
<span class="line-added">2131       result = JVMCIENV-&gt;get_object_constant(objArrayOop(xobj())-&gt;obj_at(index));</span>
<span class="line-added">2132       if (result.is_null()) {</span>
<span class="line-added">2133         result = JVMCIENV-&gt;get_JavaConstant_NULL_POINTER();</span>
<span class="line-added">2134       }</span>
<span class="line-added">2135     } else {</span>
<span class="line-added">2136       jvalue value;</span>
<span class="line-added">2137       switch (element_type) {</span>
<span class="line-added">2138         case T_DOUBLE:        value.d = typeArrayOop(xobj())-&gt;double_at(index);        break;</span>
<span class="line-added">2139         case T_FLOAT:         value.f = typeArrayOop(xobj())-&gt;float_at(index);         break;</span>
<span class="line-added">2140         case T_LONG:          value.j = typeArrayOop(xobj())-&gt;long_at(index);          break;</span>
<span class="line-added">2141         case T_INT:           value.i = typeArrayOop(xobj())-&gt;int_at(index);            break;</span>
<span class="line-added">2142         case T_SHORT:         value.s = typeArrayOop(xobj())-&gt;short_at(index);          break;</span>
<span class="line-added">2143         case T_CHAR:          value.c = typeArrayOop(xobj())-&gt;char_at(index);           break;</span>
<span class="line-added">2144         case T_BYTE:          value.b = typeArrayOop(xobj())-&gt;byte_at(index);           break;</span>
<span class="line-added">2145         case T_BOOLEAN:       value.z = typeArrayOop(xobj())-&gt;byte_at(index) &amp; 1;       break;</span>
<span class="line-added">2146         default:              ShouldNotReachHere();</span>
<span class="line-added">2147       }</span>
<span class="line-added">2148       result = JVMCIENV-&gt;create_box(element_type, &amp;value, JVMCI_CHECK_NULL);</span>
<span class="line-added">2149     }</span>
<span class="line-added">2150     assert(!result.is_null(), &quot;must have a value&quot;);</span>
<span class="line-added">2151     return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">2152   }</span>
<span class="line-added">2153   return NULL;;</span>
<span class="line-added">2154 C2V_END</span>
<span class="line-added">2155 </span>
<span class="line-added">2156 </span>
<span class="line-added">2157 C2V_VMENTRY_0(jint, arrayBaseOffset, (JNIEnv* env, jobject, jobject kind))</span>
<span class="line-added">2158   if (kind == NULL) {</span>
<span class="line-added">2159     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2160   }</span>
<span class="line-added">2161   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);</span>
<span class="line-added">2162   return arrayOopDesc::header_size(type) * HeapWordSize;</span>
<span class="line-added">2163 C2V_END</span>
<span class="line-added">2164 </span>
<span class="line-added">2165 C2V_VMENTRY_0(jint, arrayIndexScale, (JNIEnv* env, jobject, jobject kind))</span>
<span class="line-added">2166   if (kind == NULL) {</span>
<span class="line-added">2167     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2168   }</span>
<span class="line-added">2169   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);</span>
<span class="line-added">2170   return type2aelembytes(type);</span>
<span class="line-added">2171 C2V_END</span>
<span class="line-added">2172 </span>
<span class="line-added">2173 C2V_VMENTRY_0(jbyte, getByte, (JNIEnv* env, jobject, jobject x, long displacement))</span>
<span class="line-added">2174   if (x == NULL) {</span>
<span class="line-added">2175     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2176   }</span>
<span class="line-added">2177   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">2178   return xobj-&gt;byte_field(displacement);</span>
<span class="line-added">2179 }</span>
<span class="line-added">2180 </span>
<span class="line-added">2181 C2V_VMENTRY_0(jshort, getShort, (JNIEnv* env, jobject, jobject x, long displacement))</span>
<span class="line-added">2182   if (x == NULL) {</span>
<span class="line-added">2183     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2184   }</span>
<span class="line-added">2185   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">2186   return xobj-&gt;short_field(displacement);</span>
<span class="line-added">2187 }</span>
<span class="line-added">2188 </span>
<span class="line-added">2189 C2V_VMENTRY_0(jint, getInt, (JNIEnv* env, jobject, jobject x, long displacement))</span>
<span class="line-added">2190   if (x == NULL) {</span>
<span class="line-added">2191     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2192   }</span>
<span class="line-added">2193   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">2194   return xobj-&gt;int_field(displacement);</span>
<span class="line-added">2195 }</span>
<span class="line-added">2196 </span>
<span class="line-added">2197 C2V_VMENTRY_0(jlong, getLong, (JNIEnv* env, jobject, jobject x, long displacement))</span>
<span class="line-added">2198   if (x == NULL) {</span>
<span class="line-added">2199     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2200   }</span>
<span class="line-added">2201   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">2202   return xobj-&gt;long_field(displacement);</span>
<span class="line-added">2203 }</span>
<span class="line-added">2204 </span>
<span class="line-added">2205 C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))</span>
<span class="line-added">2206   if (x == NULL) {</span>
<span class="line-added">2207     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2208   }</span>
<span class="line-added">2209   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);</span>
<span class="line-added">2210   oop res = xobj-&gt;obj_field(displacement);</span>
<span class="line-added">2211   JVMCIObject result = JVMCIENV-&gt;get_object_constant(res);</span>
<span class="line-added">2212   return JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">2213 }</span>
<span class="line-added">2214 </span>
<span class="line-added">2215 C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))</span>
<span class="line-added">2216   jobject handle = (jobject)(address)h;</span>
<span class="line-added">2217   if (handle != NULL) {</span>
<span class="line-added">2218     JVMCI::destroy_global(handle);</span>
<span class="line-added">2219   }</span>
<span class="line-added">2220 }</span>
<span class="line-added">2221 </span>
<span class="line-added">2222 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {</span>
<span class="line-added">2223   if (!UseJVMCINativeLibrary) {</span>
<span class="line-added">2224     JVMCI_THROW_MSG(UnsupportedOperationException, &quot;JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)&quot;);</span>
<span class="line-added">2225   }</span>
<span class="line-added">2226 }</span>
<span class="line-added">2227 </span>
<span class="line-added">2228 static JavaVM* requireNativeLibraryJavaVM(const char* caller, JVMCI_TRAPS) {</span>
<span class="line-added">2229   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();</span>
<span class="line-added">2230   if (javaVM == NULL) {</span>
<span class="line-added">2231     JVMCI_THROW_MSG_NULL(IllegalStateException, err_msg(&quot;Require JVMCI shared library to be initialized in %s&quot;, caller));</span>
<span class="line-added">2232   }</span>
<span class="line-added">2233   return javaVM;</span>
<span class="line-added">2234 }</span>
<span class="line-added">2235 </span>
<span class="line-added">2236 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))</span>
<span class="line-added">2237   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);</span>
<span class="line-added">2238   requireInHotSpot(&quot;registerNativeMethods&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">2239   void* shared_library = JVMCIEnv::get_shared_library_handle();</span>
<span class="line-added">2240   if (shared_library == NULL) {</span>
<span class="line-added">2241     // Ensure the JVMCI shared library runtime is initialized.</span>
<span class="line-added">2242     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);</span>
<span class="line-added">2243     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;</span>
<span class="line-added">2244     HandleMark hm;</span>
<span class="line-added">2245     JVMCIRuntime* runtime = JVMCI::compiler_runtime();</span>
<span class="line-added">2246     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);</span>
<span class="line-added">2247     if (peerEnv-&gt;has_pending_exception()) {</span>
<span class="line-added">2248       peerEnv-&gt;describe_pending_exception(true);</span>
<span class="line-added">2249     }</span>
<span class="line-added">2250     shared_library = JVMCIEnv::get_shared_library_handle();</span>
<span class="line-added">2251     if (shared_library == NULL) {</span>
<span class="line-added">2252       JVMCI_THROW_MSG_0(InternalError, &quot;Error initializing JVMCI runtime&quot;);</span>
<span class="line-added">2253     }</span>
<span class="line-added">2254   }</span>
<span class="line-added">2255 </span>
<span class="line-added">2256   if (mirror == NULL) {</span>
<span class="line-added">2257     JVMCI_THROW_0(NullPointerException);</span>
<span class="line-added">2258   }</span>
<span class="line-added">2259   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));</span>
<span class="line-added">2260   if (klass == NULL || !klass-&gt;is_instance_klass()) {</span>
<span class="line-added">2261     JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;clazz is for primitive type&quot;);</span>
<span class="line-added">2262   }</span>
<span class="line-added">2263 </span>
<span class="line-added">2264   InstanceKlass* iklass = InstanceKlass::cast(klass);</span>
<span class="line-added">2265   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {</span>
<span class="line-added">2266     methodHandle method(THREAD, iklass-&gt;methods()-&gt;at(i));</span>
<span class="line-added">2267     if (method-&gt;is_native()) {</span>
<span class="line-added">2268 </span>
<span class="line-added">2269       // Compute argument size</span>
<span class="line-added">2270       int args_size = 1                             // JNIEnv</span>
<span class="line-added">2271                     + (method-&gt;is_static() ? 1 : 0) // class for static methods</span>
<span class="line-added">2272                     + method-&gt;size_of_parameters(); // actual parameters</span>
<span class="line-added">2273 </span>
<span class="line-added">2274       // 1) Try JNI short style</span>
<span class="line-added">2275       stringStream st;</span>
<span class="line-added">2276       char* pure_name = NativeLookup::pure_jni_name(method);</span>
<span class="line-added">2277       os::print_jni_name_prefix_on(&amp;st, args_size);</span>
<span class="line-added">2278       st.print_raw(pure_name);</span>
<span class="line-added">2279       os::print_jni_name_suffix_on(&amp;st, args_size);</span>
<span class="line-added">2280       char* jni_name = st.as_string();</span>
<span class="line-added">2281 </span>
<span class="line-added">2282       address entry = (address) os::dll_lookup(shared_library, jni_name);</span>
<span class="line-added">2283       if (entry == NULL) {</span>
<span class="line-added">2284         // 2) Try JNI long style</span>
<span class="line-added">2285         st.reset();</span>
<span class="line-added">2286         char* long_name = NativeLookup::long_jni_name(method);</span>
<span class="line-added">2287         os::print_jni_name_prefix_on(&amp;st, args_size);</span>
<span class="line-added">2288         st.print_raw(pure_name);</span>
<span class="line-added">2289         st.print_raw(long_name);</span>
<span class="line-added">2290         os::print_jni_name_suffix_on(&amp;st, args_size);</span>
<span class="line-added">2291         char* jni_long_name = st.as_string();</span>
<span class="line-added">2292         entry = (address) os::dll_lookup(shared_library, jni_long_name);</span>
<span class="line-added">2293         if (entry == NULL) {</span>
<span class="line-added">2294           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [neither %s nor %s exist in %s]&quot;,</span>
<span class="line-added">2295               method-&gt;name_and_sig_as_C_string(),</span>
<span class="line-added">2296               jni_name, jni_long_name, JVMCIEnv::get_shared_library_path()));</span>
<span class="line-added">2297         }</span>
<span class="line-added">2298       }</span>
<span class="line-added">2299 </span>
<span class="line-added">2300       if (method-&gt;has_native_function() &amp;&amp; entry != method-&gt;native_function()) {</span>
<span class="line-added">2301         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [cannot re-link from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT &quot;]&quot;,</span>
<span class="line-added">2302             method-&gt;name_and_sig_as_C_string(), p2i(method-&gt;native_function()), p2i(entry)));</span>
<span class="line-added">2303       }</span>
<span class="line-added">2304       method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting);</span>
<span class="line-added">2305       log_debug(jni, resolve)(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,</span>
<span class="line-added">2306                               method-&gt;method_holder()-&gt;external_name(),</span>
<span class="line-added">2307                               method-&gt;name()-&gt;as_C_string());</span>
<span class="line-added">2308     }</span>
<span class="line-added">2309   }</span>
<span class="line-added">2310 </span>
<span class="line-added">2311   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();</span>
<span class="line-added">2312   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(4, JVMCI_CHECK_NULL);</span>
<span class="line-added">2313   JVMCIENV-&gt;put_long_at(result, 0, (jlong) (address) javaVM);</span>
<span class="line-added">2314   JVMCIENV-&gt;put_long_at(result, 1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);</span>
<span class="line-added">2315   JVMCIENV-&gt;put_long_at(result, 2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);</span>
<span class="line-added">2316   JVMCIENV-&gt;put_long_at(result, 3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);</span>
<span class="line-added">2317   return (jlongArray) JVMCIENV-&gt;get_jobject(result);</span>
<span class="line-added">2318 }</span>
<span class="line-added">2319 </span>
<span class="line-added">2320 C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))</span>
<span class="line-added">2321   if (base_thread == NULL) {</span>
<span class="line-added">2322     // Called from unattached JVMCI shared library thread</span>
<span class="line-added">2323     return false;</span>
<span class="line-added">2324   }</span>
<span class="line-added">2325   JVMCITraceMark jtm(&quot;isCurrentThreadAttached&quot;);</span>
<span class="line-added">2326   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);</span>
<span class="line-added">2327   JavaThread* thread = (JavaThread*) base_thread;</span>
<span class="line-added">2328   if (thread-&gt;jni_environment() == env) {</span>
<span class="line-added">2329     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))</span>
<span class="line-added">2330     requireJVMCINativeLibrary(JVMCI_CHECK_0);</span>
<span class="line-added">2331     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;isCurrentThreadAttached&quot;, JVMCI_CHECK_0);</span>
<span class="line-added">2332     JNIEnv* peerEnv;</span>
<span class="line-added">2333     return javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK;</span>
<span class="line-added">2334   }</span>
<span class="line-added">2335   return true;</span>
<span class="line-added">2336 C2V_END</span>
<span class="line-added">2337 </span>
<span class="line-added">2338 C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))</span>
<span class="line-added">2339   if (base_thread == NULL) {</span>
<span class="line-added">2340     // Called from unattached JVMCI shared library thread</span>
<span class="line-added">2341     return 0L;</span>
<span class="line-added">2342   }</span>
<span class="line-added">2343   JVMCITraceMark jtm(&quot;getCurrentJavaThread&quot;);</span>
<span class="line-added">2344   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);</span>
<span class="line-added">2345   return (jlong) p2i(base_thread);</span>
<span class="line-added">2346 C2V_END</span>
<span class="line-added">2347 </span>
<span class="line-added">2348 C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))</span>
<span class="line-added">2349   if (base_thread == NULL) {</span>
<span class="line-added">2350     // Called from unattached JVMCI shared library thread</span>
<span class="line-added">2351     extern struct JavaVM_ main_vm;</span>
<span class="line-added">2352     JNIEnv* hotspotEnv;</span>
<span class="line-added">2353     jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**)&amp;hotspotEnv, NULL) :</span>
<span class="line-added">2354                            main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);</span>
<span class="line-added">2355     if (res != JNI_OK) {</span>
<span class="line-added">2356       JNI_THROW_(&quot;attachCurrentThread&quot;, InternalError, err_msg(&quot;Trying to attach thread returned %d&quot;, res), false);</span>
<span class="line-added">2357     }</span>
<span class="line-added">2358     return true;</span>
<span class="line-added">2359   }</span>
<span class="line-added">2360   JVMCITraceMark jtm(&quot;attachCurrentThread&quot;);</span>
<span class="line-added">2361   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-added">2362   JavaThread* thread = (JavaThread*) base_thread;</span>
<span class="line-added">2363   if (thread-&gt;jni_environment() == env) {</span>
<span class="line-added">2364     // Called from HotSpot</span>
<span class="line-added">2365     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))</span>
<span class="line-added">2366     requireJVMCINativeLibrary(JVMCI_CHECK_0);</span>
<span class="line-added">2367     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;attachCurrentThread&quot;, JVMCI_CHECK_0);</span>
<span class="line-added">2368     JavaVMAttachArgs attach_args;</span>
<span class="line-added">2369     attach_args.version = JNI_VERSION_1_2;</span>
<span class="line-added">2370     attach_args.name = thread-&gt;name();</span>
<span class="line-added">2371     attach_args.group = NULL;</span>
<span class="line-added">2372     JNIEnv* peerEnv;</span>
<span class="line-added">2373     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK) {</span>
<span class="line-added">2374       return false;</span>
<span class="line-added">2375     }</span>
<span class="line-added">2376     jint res = as_daemon ? javaVM-&gt;AttachCurrentThreadAsDaemon((void**)&amp;peerEnv, &amp;attach_args) :</span>
<span class="line-added">2377                            javaVM-&gt;AttachCurrentThread((void**)&amp;peerEnv, &amp;attach_args);</span>
<span class="line-added">2378     if (res == JNI_OK) {</span>
<span class="line-added">2379       guarantee(peerEnv != NULL, &quot;must be&quot;);</span>
<span class="line-added">2380       return true;</span>
<span class="line-added">2381     }</span>
<span class="line-added">2382     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, attach_args.name));</span>
<span class="line-added">2383   }</span>
<span class="line-added">2384   // Called from JVMCI shared library</span>
<span class="line-added">2385   return false;</span>
<span class="line-added">2386 C2V_END</span>
<span class="line-added">2387 </span>
<span class="line-added">2388 C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))</span>
<span class="line-added">2389   if (base_thread == NULL) {</span>
<span class="line-added">2390     // Called from unattached JVMCI shared library thread</span>
<span class="line-added">2391     JNI_THROW(&quot;detachCurrentThread&quot;, IllegalStateException, err_msg(&quot;Cannot detach non-attached thread&quot;));</span>
<span class="line-added">2392   }</span>
<span class="line-added">2393   JVMCITraceMark jtm(&quot;detachCurrentThread&quot;);</span>
<span class="line-added">2394   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\</span>
<span class="line-added">2395   JavaThread* thread = (JavaThread*) base_thread;</span>
<span class="line-added">2396   if (thread-&gt;jni_environment() == env) {</span>
<span class="line-added">2397     // Called from HotSpot</span>
<span class="line-added">2398     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))</span>
<span class="line-added">2399     requireJVMCINativeLibrary(JVMCI_CHECK);</span>
<span class="line-added">2400     requireInHotSpot(&quot;detachCurrentThread&quot;, JVMCI_CHECK);</span>
<span class="line-added">2401     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;detachCurrentThread&quot;, JVMCI_CHECK);</span>
<span class="line-added">2402     JNIEnv* peerEnv;</span>
<span class="line-added">2403     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) != JNI_OK) {</span>
<span class="line-added">2404       JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot detach non-attached thread: %s&quot;, thread-&gt;name()));</span>
<span class="line-added">2405     }</span>
<span class="line-added">2406     jint res = javaVM-&gt;DetachCurrentThread();</span>
<span class="line-added">2407     if (res != JNI_OK) {</span>
<span class="line-added">2408       JVMCI_THROW_MSG(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, thread-&gt;name()));</span>
<span class="line-added">2409     }</span>
<span class="line-added">2410   } else {</span>
<span class="line-added">2411     // Called from attached JVMCI shared library thread</span>
<span class="line-added">2412     extern struct JavaVM_ main_vm;</span>
<span class="line-added">2413     jint res = main_vm.DetachCurrentThread();</span>
<span class="line-added">2414     if (res != JNI_OK) {</span>
<span class="line-added">2415       JNI_THROW(&quot;detachCurrentThread&quot;, InternalError, err_msg(&quot;Cannot detach non-attached thread&quot;));</span>
<span class="line-added">2416     }</span>
<span class="line-added">2417   }</span>
<span class="line-added">2418 C2V_END</span>
<span class="line-added">2419 </span>
<span class="line-added">2420 C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))</span>
<span class="line-added">2421   requireJVMCINativeLibrary(JVMCI_CHECK_0);</span>
<span class="line-added">2422   if (obj_handle == NULL) {</span>
<span class="line-added">2423     return 0L;</span>
<span class="line-added">2424   }</span>
<span class="line-added">2425   JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV-&gt;is_hotspot(), __FILE__, __LINE__);</span>
<span class="line-added">2426   JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;</span>
<span class="line-added">2427   JVMCIEnv* thisEnv = JVMCIENV;</span>
<span class="line-added">2428 </span>
<span class="line-added">2429   JVMCIObject obj = thisEnv-&gt;wrap(obj_handle);</span>
<span class="line-added">2430   JVMCIObject result;</span>
<span class="line-added">2431   if (thisEnv-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {</span>
<span class="line-added">2432     methodHandle method(THREAD, thisEnv-&gt;asMethod(obj));</span>
<span class="line-added">2433     result = peerEnv-&gt;get_jvmci_method(method, JVMCI_CHECK_0);</span>
<span class="line-added">2434   } else if (thisEnv-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {</span>
<span class="line-added">2435     Klass* klass = thisEnv-&gt;asKlass(obj);</span>
<span class="line-added">2436     JVMCIKlassHandle klass_handle(THREAD);</span>
<span class="line-added">2437     klass_handle = klass;</span>
<span class="line-added">2438     result = peerEnv-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_0);</span>
<span class="line-added">2439   } else if (thisEnv-&gt;isa_HotSpotResolvedPrimitiveType(obj)) {</span>
<span class="line-added">2440     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(obj), JVMCI_CHECK_0);</span>
<span class="line-added">2441     result = peerEnv-&gt;get_jvmci_primitive_type(type);</span>
<span class="line-added">2442   } else if (thisEnv-&gt;isa_IndirectHotSpotObjectConstantImpl(obj) ||</span>
<span class="line-added">2443              thisEnv-&gt;isa_DirectHotSpotObjectConstantImpl(obj)) {</span>
<span class="line-added">2444     Handle constant = thisEnv-&gt;asConstant(obj, JVMCI_CHECK_0);</span>
<span class="line-added">2445     result = peerEnv-&gt;get_object_constant(constant());</span>
<span class="line-added">2446   } else if (thisEnv-&gt;isa_HotSpotNmethod(obj)) {</span>
<span class="line-added">2447     nmethodLocker locker;</span>
<span class="line-added">2448     nmethod* nm = JVMCIENV-&gt;get_nmethod(obj, locker);</span>
<span class="line-added">2449     if (nm != NULL) {</span>
<span class="line-added">2450       JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();</span>
<span class="line-added">2451       if (data != NULL) {</span>
<span class="line-added">2452         if (peerEnv-&gt;is_hotspot()) {</span>
<span class="line-added">2453           // Only the mirror in the HotSpot heap is accessible</span>
<span class="line-added">2454           // through JVMCINMethodData</span>
<span class="line-added">2455           oop nmethod_mirror = data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ true);</span>
<span class="line-added">2456           if (nmethod_mirror != NULL) {</span>
<span class="line-added">2457             result = HotSpotJVMCI::wrap(nmethod_mirror);</span>
<span class="line-added">2458           }</span>
<span class="line-added">2459         }</span>
<span class="line-added">2460       }</span>
<span class="line-added">2461     }</span>
<span class="line-added">2462     if (result.is_null()) {</span>
<span class="line-added">2463       JVMCIObject methodObject = thisEnv-&gt;get_HotSpotNmethod_method(obj);</span>
<span class="line-added">2464       methodHandle mh(THREAD, thisEnv-&gt;asMethod(methodObject));</span>
<span class="line-added">2465       jboolean isDefault = thisEnv-&gt;get_HotSpotNmethod_isDefault(obj);</span>
<span class="line-added">2466       jlong compileIdSnapshot = thisEnv-&gt;get_HotSpotNmethod_compileIdSnapshot(obj);</span>
<span class="line-added">2467       JVMCIObject name_string = thisEnv-&gt;get_InstalledCode_name(obj);</span>
<span class="line-added">2468       const char* cstring = name_string.is_null() ? NULL : thisEnv-&gt;as_utf8_string(name_string);</span>
<span class="line-added">2469       // Create a new HotSpotNmethod instance in the peer runtime</span>
<span class="line-added">2470       result = peerEnv-&gt;new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);</span>
<span class="line-added">2471       if (nm == NULL) {</span>
<span class="line-added">2472         // nmethod must have been unloaded</span>
<span class="line-added">2473       } else {</span>
<span class="line-added">2474         // Link the new HotSpotNmethod to the nmethod</span>
<span class="line-added">2475         peerEnv-&gt;initialize_installed_code(result, nm, JVMCI_CHECK_0);</span>
<span class="line-added">2476         // Only HotSpotNmethod instances in the HotSpot heap are tracked directly by the runtime.</span>
<span class="line-added">2477         if (peerEnv-&gt;is_hotspot()) {</span>
<span class="line-added">2478           JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();</span>
<span class="line-added">2479           if (data == NULL) {</span>
<span class="line-added">2480             JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;Cannot set HotSpotNmethod mirror for default nmethod&quot;);</span>
<span class="line-added">2481           }</span>
<span class="line-added">2482           if (data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) != NULL) {</span>
<span class="line-added">2483             JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;Cannot overwrite existing HotSpotNmethod mirror for nmethod&quot;);</span>
<span class="line-added">2484           }</span>
<span class="line-added">2485           oop nmethod_mirror = HotSpotJVMCI::resolve(result);</span>
<span class="line-added">2486           data-&gt;set_nmethod_mirror(nm, nmethod_mirror);</span>
<span class="line-added">2487         }</span>
<span class="line-added">2488       }</span>
<span class="line-added">2489     }</span>
<span class="line-added">2490   } else {</span>
<span class="line-added">2491     JVMCI_THROW_MSG_0(IllegalArgumentException,</span>
<span class="line-added">2492                 err_msg(&quot;Cannot translate object of type: %s&quot;, thisEnv-&gt;klass_name(obj)));</span>
<span class="line-added">2493   }</span>
<span class="line-added">2494   return (jlong) peerEnv-&gt;make_global(result).as_jobject();</span>
<span class="line-added">2495 }</span>
<span class="line-added">2496 </span>
<span class="line-added">2497 C2V_VMENTRY_NULL(jobject, unhand, (JNIEnv* env, jobject, jlong obj_handle))</span>
<span class="line-added">2498   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);</span>
<span class="line-added">2499   if (obj_handle == 0L) {</span>
<span class="line-added">2500     return NULL;</span>
<span class="line-added">2501   }</span>
<span class="line-added">2502   jobject global_handle = (jobject) obj_handle;</span>
<span class="line-added">2503   JVMCIObject global_handle_obj = JVMCIENV-&gt;wrap((jobject) obj_handle);</span>
<span class="line-added">2504   jobject result = JVMCIENV-&gt;make_local(global_handle_obj).as_jobject();</span>
<span class="line-added">2505 </span>
<span class="line-added">2506   JVMCIENV-&gt;destroy_global(global_handle_obj);</span>
<span class="line-added">2507   return result;</span>
<span class="line-added">2508 }</span>
<span class="line-added">2509 </span>
<span class="line-added">2510 C2V_VMENTRY(void, updateHotSpotNmethod, (JNIEnv* env, jobject, jobject code_handle))</span>
<span class="line-added">2511   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);</span>
<span class="line-added">2512   // Execute this operation for the side effect of updating the InstalledCode state</span>
<span class="line-added">2513   nmethodLocker locker;</span>
<span class="line-added">2514   JVMCIENV-&gt;get_nmethod(code, locker);</span>
<span class="line-added">2515 }</span>
<span class="line-added">2516 </span>
<span class="line-added">2517 C2V_VMENTRY_NULL(jbyteArray, getCode, (JNIEnv* env, jobject, jobject code_handle))</span>
<span class="line-added">2518   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);</span>
<span class="line-added">2519   nmethodLocker locker;</span>
<span class="line-added">2520   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(code, locker);</span>
<span class="line-added">2521   if (cb == NULL) {</span>
<span class="line-added">2522     return NULL;</span>
<span class="line-added">2523   }</span>
<span class="line-added">2524   int code_size = cb-&gt;code_size();</span>
<span class="line-added">2525   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);</span>
<span class="line-added">2526   JVMCIENV-&gt;copy_bytes_from((jbyte*) cb-&gt;code_begin(), result, 0, code_size);</span>
<span class="line-added">2527   return JVMCIENV-&gt;get_jbyteArray(result);</span>
<span class="line-added">2528 }</span>
<span class="line-added">2529 </span>
<span class="line-added">2530 C2V_VMENTRY_NULL(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-added">2531   requireInHotSpot(&quot;asReflectionExecutable&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">2532   methodHandle m(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
2533   oop executable;
2534   if (m-&gt;is_initializer()) {
2535     if (m-&gt;is_static_initializer()) {
<span class="line-modified">2536       JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
<span class="line-modified">2537           &quot;Cannot create java.lang.reflect.Method for class initializer&quot;);</span>
2538     }
2539     executable = Reflection::new_constructor(m, CHECK_NULL);
2540   } else {
2541     executable = Reflection::new_method(m, false, CHECK_NULL);
2542   }
<span class="line-modified">2543   return JNIHandles::make_local(THREAD, executable);</span>
2544 }
2545 
<span class="line-modified">2546 C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))</span>
<span class="line-modified">2547   requireInHotSpot(&quot;asReflectionField&quot;, JVMCI_CHECK_NULL);</span>
<span class="line-added">2548   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);</span>
2549   if (!klass-&gt;is_instance_klass()) {
<span class="line-modified">2550     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
2551         err_msg(&quot;Expected non-primitive type, got %s&quot;, klass-&gt;external_name()));
2552   }
2553   InstanceKlass* iklass = InstanceKlass::cast(klass);
2554   Array&lt;u2&gt;* fields = iklass-&gt;fields();
<span class="line-modified">2555   if (index &lt; 0 ||index &gt; fields-&gt;length()) {</span>
<span class="line-modified">2556     JVMCI_THROW_MSG_NULL(IllegalArgumentException,</span>
2557         err_msg(&quot;Field index %d out of bounds for %s&quot;, index, klass-&gt;external_name()));
2558   }
2559   fieldDescriptor fd(iklass, index);
2560   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2561   return JNIHandles::make_local(env, reflected);
2562 }
2563 
<span class="line-added">2564 C2V_VMENTRY_NULL(jobjectArray, getFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address, jobjectArray current))</span>
<span class="line-added">2565   FailedSpeculation* head = *((FailedSpeculation**)(address) failed_speculations_address);</span>
<span class="line-added">2566   int result_length = 0;</span>
<span class="line-added">2567   for (FailedSpeculation* fs = head; fs != NULL; fs = fs-&gt;next()) {</span>
<span class="line-added">2568     result_length++;</span>
<span class="line-added">2569   }</span>
<span class="line-added">2570   int current_length = 0;</span>
<span class="line-added">2571   JVMCIObjectArray current_array = NULL;</span>
<span class="line-added">2572   if (current != NULL) {</span>
<span class="line-added">2573     current_array = JVMCIENV-&gt;wrap(current);</span>
<span class="line-added">2574     current_length = JVMCIENV-&gt;get_length(current_array);</span>
<span class="line-added">2575     if (current_length == result_length) {</span>
<span class="line-added">2576       // No new failures</span>
<span class="line-added">2577       return current;</span>
<span class="line-added">2578     }</span>
<span class="line-added">2579   }</span>
<span class="line-added">2580   JVMCIObjectArray result = JVMCIENV-&gt;new_byte_array_array(result_length, JVMCI_CHECK_NULL);</span>
<span class="line-added">2581   int result_index = 0;</span>
<span class="line-added">2582   for (FailedSpeculation* fs = head; result_index &lt; result_length; fs = fs-&gt;next()) {</span>
<span class="line-added">2583     assert(fs != NULL, &quot;npe&quot;);</span>
<span class="line-added">2584     JVMCIPrimitiveArray entry;</span>
<span class="line-added">2585     if (result_index &lt; current_length) {</span>
<span class="line-added">2586       entry = (JVMCIPrimitiveArray) JVMCIENV-&gt;get_object_at(current_array, result_index);</span>
<span class="line-added">2587     } else {</span>
<span class="line-added">2588       entry = JVMCIENV-&gt;new_byteArray(fs-&gt;data_len(), JVMCI_CHECK_NULL);</span>
<span class="line-added">2589       JVMCIENV-&gt;copy_bytes_from((jbyte*) fs-&gt;data(), entry, 0, fs-&gt;data_len());</span>
<span class="line-added">2590     }</span>
<span class="line-added">2591     JVMCIENV-&gt;put_object_at(result, result_index++, entry);</span>
<span class="line-added">2592   }</span>
<span class="line-added">2593   return JVMCIENV-&gt;get_jobjectArray(result);</span>
<span class="line-added">2594 }</span>
<span class="line-added">2595 </span>
<span class="line-added">2596 C2V_VMENTRY_0(jlong, getFailedSpeculationsAddress, (JNIEnv* env, jobject, jobject jvmci_method))</span>
<span class="line-added">2597   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));</span>
<span class="line-added">2598   MethodData* method_data = method-&gt;method_data();</span>
<span class="line-added">2599   if (method_data == NULL) {</span>
<span class="line-added">2600     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();</span>
<span class="line-added">2601     method_data = MethodData::allocate(loader_data, method, CHECK_0);</span>
<span class="line-added">2602     method-&gt;set_method_data(method_data);</span>
<span class="line-added">2603   }</span>
<span class="line-added">2604   return (jlong) method_data-&gt;get_failed_speculations_address();</span>
<span class="line-added">2605 }</span>
<span class="line-added">2606 </span>
<span class="line-added">2607 C2V_VMENTRY(void, releaseFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address))</span>
<span class="line-added">2608   FailedSpeculation::free_failed_speculations((FailedSpeculation**)(address) failed_speculations_address);</span>
<span class="line-added">2609 }</span>
<span class="line-added">2610 </span>
<span class="line-added">2611 C2V_VMENTRY_0(jboolean, addFailedSpeculation, (JNIEnv* env, jobject, jlong failed_speculations_address, jbyteArray speculation_obj))</span>
<span class="line-added">2612   JVMCIPrimitiveArray speculation_handle = JVMCIENV-&gt;wrap(speculation_obj);</span>
<span class="line-added">2613   int speculation_len = JVMCIENV-&gt;get_length(speculation_handle);</span>
<span class="line-added">2614   char* speculation = NEW_RESOURCE_ARRAY(char, speculation_len);</span>
<span class="line-added">2615   JVMCIENV-&gt;copy_bytes_to(speculation_handle, (jbyte*) speculation, 0, speculation_len);</span>
<span class="line-added">2616   return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);</span>
<span class="line-added">2617 }</span>
<span class="line-added">2618 </span>
<span class="line-added">2619 C2V_VMENTRY(void, callSystemExit, (JNIEnv* env, jobject, jint status))</span>
<span class="line-added">2620   JavaValue result(T_VOID);</span>
<span class="line-added">2621   JavaCallArguments jargs(1);</span>
<span class="line-added">2622   jargs.push_int(status);</span>
<span class="line-added">2623   JavaCalls::call_static(&amp;result,</span>
<span class="line-added">2624                        SystemDictionary::System_klass(),</span>
<span class="line-added">2625                        vmSymbols::exit_method_name(),</span>
<span class="line-added">2626                        vmSymbols::int_void_signature(),</span>
<span class="line-added">2627                        &amp;jargs,</span>
<span class="line-added">2628                        CHECK);</span>
<span class="line-added">2629 }</span>
<span class="line-added">2630 </span>
2631 #define CC (char*)  /*cast a literal from (const char*)*/
2632 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
2633 
2634 #define STRING                  &quot;Ljava/lang/String;&quot;
2635 #define OBJECT                  &quot;Ljava/lang/Object;&quot;
2636 #define CLASS                   &quot;Ljava/lang/Class;&quot;
<span class="line-added">2637 #define OBJECTCONSTANT          &quot;Ljdk/vm/ci/hotspot/HotSpotObjectConstantImpl;&quot;</span>
<span class="line-added">2638 #define HANDLECONSTANT          &quot;Ljdk/vm/ci/hotspot/IndirectHotSpotObjectConstantImpl;&quot;</span>
2639 #define EXECUTABLE              &quot;Ljava/lang/reflect/Executable;&quot;
2640 #define STACK_TRACE_ELEMENT     &quot;Ljava/lang/StackTraceElement;&quot;
2641 #define INSTALLED_CODE          &quot;Ljdk/vm/ci/code/InstalledCode;&quot;
2642 #define TARGET_DESCRIPTION      &quot;Ljdk/vm/ci/code/TargetDescription;&quot;
2643 #define BYTECODE_FRAME          &quot;Ljdk/vm/ci/code/BytecodeFrame;&quot;
<span class="line-added">2644 #define JAVACONSTANT            &quot;Ljdk/vm/ci/meta/JavaConstant;&quot;</span>
2645 #define INSPECTED_FRAME_VISITOR &quot;Ljdk/vm/ci/code/stack/InspectedFrameVisitor;&quot;
2646 #define RESOLVED_METHOD         &quot;Ljdk/vm/ci/meta/ResolvedJavaMethod;&quot;
2647 #define HS_RESOLVED_METHOD      &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;&quot;
2648 #define HS_RESOLVED_KLASS       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;&quot;
<span class="line-added">2649 #define HS_RESOLVED_TYPE        &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaType;&quot;</span>
<span class="line-added">2650 #define HS_RESOLVED_FIELD       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaField;&quot;</span>
<span class="line-added">2651 #define HS_INSTALLED_CODE       &quot;Ljdk/vm/ci/hotspot/HotSpotInstalledCode;&quot;</span>
<span class="line-added">2652 #define HS_NMETHOD              &quot;Ljdk/vm/ci/hotspot/HotSpotNmethod;&quot;</span>
2653 #define HS_CONSTANT_POOL        &quot;Ljdk/vm/ci/hotspot/HotSpotConstantPool;&quot;
2654 #define HS_COMPILED_CODE        &quot;Ljdk/vm/ci/hotspot/HotSpotCompiledCode;&quot;
2655 #define HS_CONFIG               &quot;Ljdk/vm/ci/hotspot/HotSpotVMConfig;&quot;
2656 #define HS_METADATA             &quot;Ljdk/vm/ci/hotspot/HotSpotMetaData;&quot;
2657 #define HS_STACK_FRAME_REF      &quot;Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;&quot;
2658 #define HS_SPECULATION_LOG      &quot;Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;&quot;
<span class="line-added">2659 #define METASPACE_OBJECT        &quot;Ljdk/vm/ci/hotspot/MetaspaceObject;&quot;</span>
2660 #define REFLECTION_EXECUTABLE   &quot;Ljava/lang/reflect/Executable;&quot;
2661 #define REFLECTION_FIELD        &quot;Ljava/lang/reflect/Field;&quot;
2662 #define METASPACE_METHOD_DATA   &quot;J&quot;
2663 
2664 JNINativeMethod CompilerToVM::methods[] = {
2665   {CC &quot;getBytecode&quot;,                                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[B&quot;,                                                      FN_PTR(getBytecode)},
2666   {CC &quot;getExceptionTableStart&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getExceptionTableStart)},
2667   {CC &quot;getExceptionTableLength&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getExceptionTableLength)},
2668   {CC &quot;findUniqueConcreteMethod&quot;,                     CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)&quot; HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
2669   {CC &quot;getImplementor&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
2670   {CC &quot;getStackTraceElement&quot;,                         CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)&quot; STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
2671   {CC &quot;methodIsIgnoredBySecurityStackWalk&quot;,           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
2672   {CC &quot;setNotInlinableOrCompilable&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(setNotInlinableOrCompilable)},
2673   {CC &quot;isCompilable&quot;,                                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(isCompilable)},
2674   {CC &quot;hasNeverInlineDirective&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(hasNeverInlineDirective)},
2675   {CC &quot;shouldInlineMethod&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(shouldInlineMethod)},
<span class="line-modified">2676   {CC &quot;lookupType&quot;,                                   CC &quot;(&quot; STRING HS_RESOLVED_KLASS &quot;Z)&quot; HS_RESOLVED_TYPE,                                FN_PTR(lookupType)},</span>
<span class="line-added">2677   {CC &quot;getArrayType&quot;,                                 CC &quot;(&quot; HS_RESOLVED_TYPE &quot;)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getArrayType)},</span>
<span class="line-added">2678   {CC &quot;lookupClass&quot;,                                  CC &quot;(&quot; CLASS &quot;)&quot; HS_RESOLVED_TYPE,                                                    FN_PTR(lookupClass)},</span>
2679   {CC &quot;lookupNameInPool&quot;,                             CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupNameInPool)},
2680   {CC &quot;lookupNameAndTypeRefIndexInPool&quot;,              CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
2681   {CC &quot;lookupSignatureInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupSignatureInPool)},
2682   {CC &quot;lookupKlassRefIndexInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupKlassRefIndexInPool)},
2683   {CC &quot;lookupKlassInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)Ljava/lang/Object;&quot;,                                       FN_PTR(lookupKlassInPool)},
<span class="line-modified">2684   {CC &quot;lookupAppendixInPool&quot;,                         CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECTCONSTANT,                                          FN_PTR(lookupAppendixInPool)},</span>
2685   {CC &quot;lookupMethodInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;IB)&quot; HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
2686   {CC &quot;constantPoolRemapInstructionOperandFromCache&quot;, CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
<span class="line-modified">2687   {CC &quot;resolvePossiblyCachedConstantInPool&quot;,          CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECTCONSTANT,                                          FN_PTR(resolvePossiblyCachedConstantInPool)},</span>

2688   {CC &quot;resolveTypeInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
2689   {CC &quot;resolveFieldInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;I&quot; HS_RESOLVED_METHOD &quot;B[I)&quot; HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
2690   {CC &quot;resolveInvokeDynamicInPool&quot;,                   CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeDynamicInPool)},
2691   {CC &quot;resolveInvokeHandleInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeHandleInPool)},
2692   {CC &quot;isResolvedInvokeHandleInPool&quot;,                 CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(isResolvedInvokeHandleInPool)},
2693   {CC &quot;resolveMethod&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
2694   {CC &quot;getSignaturePolymorphicHolders&quot;,               CC &quot;()[&quot; STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
2695   {CC &quot;getVtableIndexForInterfaceMethod&quot;,             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)I&quot;,                                     FN_PTR(getVtableIndexForInterfaceMethod)},
2696   {CC &quot;getClassInitializer&quot;,                          CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
2697   {CC &quot;hasFinalizableSubclass&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(hasFinalizableSubclass)},
2698   {CC &quot;getMaxCallTargetOffset&quot;,                       CC &quot;(J)J&quot;,                                                                            FN_PTR(getMaxCallTargetOffset)},
2699   {CC &quot;asResolvedJavaMethod&quot;,                         CC &quot;(&quot; EXECUTABLE &quot;)&quot; HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
<span class="line-modified">2700   {CC &quot;getResolvedJavaMethod&quot;,                        CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},</span>
<span class="line-modified">2701   {CC &quot;getConstantPool&quot;,                              CC &quot;(&quot; METASPACE_OBJECT &quot;)&quot; HS_CONSTANT_POOL,                                         FN_PTR(getConstantPool)},</span>
<span class="line-modified">2702   {CC &quot;getResolvedJavaType0&quot;,                         CC &quot;(Ljava/lang/Object;JZ)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType0)},</span>
2703   {CC &quot;readConfiguration&quot;,                            CC &quot;()[&quot; OBJECT,                                                                      FN_PTR(readConfiguration)},
<span class="line-modified">2704   {CC &quot;installCode&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE &quot;J[B)I&quot;,                    FN_PTR(installCode)},</span>
2705   {CC &quot;getMetadata&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA &quot;)I&quot;,                          FN_PTR(getMetadata)},
2706   {CC &quot;resetCompilationStatistics&quot;,                   CC &quot;()V&quot;,                                                                             FN_PTR(resetCompilationStatistics)},
2707   {CC &quot;disassembleCodeBlob&quot;,                          CC &quot;(&quot; INSTALLED_CODE &quot;)&quot; STRING,                                                     FN_PTR(disassembleCodeBlob)},
<span class="line-modified">2708   {CC &quot;executeHotSpotNmethod&quot;,                        CC &quot;([&quot; OBJECT HS_NMETHOD &quot;)&quot; OBJECT,                                                 FN_PTR(executeHotSpotNmethod)},</span>
2709   {CC &quot;getLineNumberTable&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[J&quot;,                                                      FN_PTR(getLineNumberTable)},
2710   {CC &quot;getLocalVariableTableStart&quot;,                   CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getLocalVariableTableStart)},
2711   {CC &quot;getLocalVariableTableLength&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getLocalVariableTableLength)},
2712   {CC &quot;reprofile&quot;,                                    CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(reprofile)},
<span class="line-modified">2713   {CC &quot;invalidateHotSpotNmethod&quot;,                     CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(invalidateHotSpotNmethod)},</span>
<span class="line-added">2714   {CC &quot;readUncompressedOop&quot;,                          CC &quot;(J)&quot; OBJECTCONSTANT,                                                              FN_PTR(readUncompressedOop)},</span>
2715   {CC &quot;collectCounters&quot;,                              CC &quot;()[J&quot;,                                                                            FN_PTR(collectCounters)},
<span class="line-added">2716   {CC &quot;getCountersSize&quot;,                              CC &quot;()I&quot;,                                                                             FN_PTR(getCountersSize)},</span>
<span class="line-added">2717   {CC &quot;setCountersSize&quot;,                              CC &quot;(I)V&quot;,                                                                            FN_PTR(setCountersSize)},</span>
2718   {CC &quot;allocateCompileId&quot;,                            CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)I&quot;,                                                      FN_PTR(allocateCompileId)},
2719   {CC &quot;isMature&quot;,                                     CC &quot;(&quot; METASPACE_METHOD_DATA &quot;)Z&quot;,                                                    FN_PTR(isMature)},
2720   {CC &quot;hasCompiledCodeForOSR&quot;,                        CC &quot;(&quot; HS_RESOLVED_METHOD &quot;II)Z&quot;,                                                     FN_PTR(hasCompiledCodeForOSR)},
2721   {CC &quot;getSymbol&quot;,                                    CC &quot;(J)&quot; STRING,                                                                      FN_PTR(getSymbol)},
2722   {CC &quot;iterateFrames&quot;,                                CC &quot;([&quot; RESOLVED_METHOD &quot;[&quot; RESOLVED_METHOD &quot;I&quot; INSPECTED_FRAME_VISITOR &quot;)&quot; OBJECT,   FN_PTR(iterateFrames)},
2723   {CC &quot;materializeVirtualObjects&quot;,                    CC &quot;(&quot; HS_STACK_FRAME_REF &quot;Z)V&quot;,                                                      FN_PTR(materializeVirtualObjects)},
2724   {CC &quot;shouldDebugNonSafepoints&quot;,                     CC &quot;()Z&quot;,                                                                             FN_PTR(shouldDebugNonSafepoints)},
<span class="line-modified">2725   {CC &quot;writeDebugOutput&quot;,                             CC &quot;([BIIZZ)I&quot;,                                                                       FN_PTR(writeDebugOutput)},</span>
2726   {CC &quot;flushDebugOutput&quot;,                             CC &quot;()V&quot;,                                                                             FN_PTR(flushDebugOutput)},
2727   {CC &quot;methodDataProfileDataSize&quot;,                    CC &quot;(JI)I&quot;,                                                                           FN_PTR(methodDataProfileDataSize)},
2728   {CC &quot;getFingerprint&quot;,                               CC &quot;(J)J&quot;,                                                                            FN_PTR(getFingerprint)},
2729   {CC &quot;getHostClass&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
2730   {CC &quot;interpreterFrameSize&quot;,                         CC &quot;(&quot; BYTECODE_FRAME &quot;)I&quot;,                                                           FN_PTR(interpreterFrameSize)},
<span class="line-modified">2731   {CC &quot;compileToBytecode&quot;,                            CC &quot;(&quot; OBJECTCONSTANT &quot;)V&quot;,                                                           FN_PTR(compileToBytecode)},</span>
2732   {CC &quot;getFlagValue&quot;,                                 CC &quot;(&quot; STRING &quot;)&quot; OBJECT,                                                             FN_PTR(getFlagValue)},
<span class="line-added">2733   {CC &quot;getObjectAtAddress&quot;,                           CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(getObjectAtAddress)},</span>
<span class="line-added">2734   {CC &quot;getInterfaces&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; HS_RESOLVED_KLASS,                                      FN_PTR(getInterfaces)},</span>
<span class="line-added">2735   {CC &quot;getComponentType&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_TYPE,                                        FN_PTR(getComponentType)},</span>
<span class="line-added">2736   {CC &quot;ensureInitialized&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)V&quot;,                                                        FN_PTR(ensureInitialized)},</span>
<span class="line-added">2737   {CC &quot;getIdentityHashCode&quot;,                          CC &quot;(&quot; OBJECTCONSTANT &quot;)I&quot;,                                                           FN_PTR(getIdentityHashCode)},</span>
<span class="line-added">2738   {CC &quot;isInternedString&quot;,                             CC &quot;(&quot; OBJECTCONSTANT &quot;)Z&quot;,                                                           FN_PTR(isInternedString)},</span>
<span class="line-added">2739   {CC &quot;unboxPrimitive&quot;,                               CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; OBJECT,                                                     FN_PTR(unboxPrimitive)},</span>
<span class="line-added">2740   {CC &quot;boxPrimitive&quot;,                                 CC &quot;(&quot; OBJECT &quot;)&quot; OBJECTCONSTANT,                                                     FN_PTR(boxPrimitive)},</span>
<span class="line-added">2741   {CC &quot;getDeclaredConstructors&quot;,                      CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; RESOLVED_METHOD,                                        FN_PTR(getDeclaredConstructors)},</span>
<span class="line-added">2742   {CC &quot;getDeclaredMethods&quot;,                           CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; RESOLVED_METHOD,                                        FN_PTR(getDeclaredMethods)},</span>
<span class="line-added">2743   {CC &quot;readFieldValue&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_FIELD &quot;Z)&quot; JAVACONSTANT,                         FN_PTR(readFieldValue)},</span>
<span class="line-added">2744   {CC &quot;readFieldValue&quot;,                               CC &quot;(&quot; OBJECTCONSTANT HS_RESOLVED_FIELD &quot;Z)&quot; JAVACONSTANT,                            FN_PTR(readFieldValue)},</span>
<span class="line-added">2745   {CC &quot;isInstance&quot;,                                   CC &quot;(&quot; HS_RESOLVED_KLASS OBJECTCONSTANT &quot;)Z&quot;,                                         FN_PTR(isInstance)},</span>
<span class="line-added">2746   {CC &quot;isAssignableFrom&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_KLASS &quot;)Z&quot;,                                      FN_PTR(isAssignableFrom)},</span>
<span class="line-added">2747   {CC &quot;isTrustedForIntrinsics&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(isTrustedForIntrinsics)},</span>
<span class="line-added">2748   {CC &quot;asJavaType&quot;,                                   CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; HS_RESOLVED_TYPE,                                           FN_PTR(asJavaType)},</span>
<span class="line-added">2749   {CC &quot;asString&quot;,                                     CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; STRING,                                                     FN_PTR(asString)},</span>
<span class="line-added">2750   {CC &quot;equals&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J&quot; OBJECTCONSTANT &quot;J)Z&quot;,                                       FN_PTR(equals)},</span>
<span class="line-added">2751   {CC &quot;getJavaMirror&quot;,                                CC &quot;(&quot; HS_RESOLVED_TYPE &quot;)&quot; OBJECTCONSTANT,                                           FN_PTR(getJavaMirror)},</span>
<span class="line-added">2752   {CC &quot;getArrayLength&quot;,                               CC &quot;(&quot; OBJECTCONSTANT &quot;)I&quot;,                                                           FN_PTR(getArrayLength)},</span>
<span class="line-added">2753   {CC &quot;readArrayElement&quot;,                             CC &quot;(&quot; OBJECTCONSTANT &quot;I)Ljava/lang/Object;&quot;,                                         FN_PTR(readArrayElement)},</span>
<span class="line-added">2754   {CC &quot;arrayBaseOffset&quot;,                              CC &quot;(Ljdk/vm/ci/meta/JavaKind;)I&quot;,                                                    FN_PTR(arrayBaseOffset)},</span>
<span class="line-added">2755   {CC &quot;arrayIndexScale&quot;,                              CC &quot;(Ljdk/vm/ci/meta/JavaKind;)I&quot;,                                                    FN_PTR(arrayIndexScale)},</span>
<span class="line-added">2756   {CC &quot;getByte&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)B&quot;,                                                          FN_PTR(getByte)},</span>
<span class="line-added">2757   {CC &quot;getShort&quot;,                                     CC &quot;(&quot; OBJECTCONSTANT &quot;J)S&quot;,                                                          FN_PTR(getShort)},</span>
<span class="line-added">2758   {CC &quot;getInt&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J)I&quot;,                                                          FN_PTR(getInt)},</span>
<span class="line-added">2759   {CC &quot;getLong&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)J&quot;,                                                          FN_PTR(getLong)},</span>
<span class="line-added">2760   {CC &quot;getObject&quot;,                                    CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; OBJECTCONSTANT,                                            FN_PTR(getObject)},</span>
<span class="line-added">2761   {CC &quot;deleteGlobalHandle&quot;,                           CC &quot;(J)V&quot;,                                                                            FN_PTR(deleteGlobalHandle)},</span>
<span class="line-added">2762   {CC &quot;registerNativeMethods&quot;,                        CC &quot;(&quot; CLASS &quot;)[J&quot;,                                                                   FN_PTR(registerNativeMethods)},</span>
<span class="line-added">2763   {CC &quot;isCurrentThreadAttached&quot;,                      CC &quot;()Z&quot;,                                                                             FN_PTR(isCurrentThreadAttached)},</span>
<span class="line-added">2764   {CC &quot;getCurrentJavaThread&quot;,                         CC &quot;()J&quot;,                                                                             FN_PTR(getCurrentJavaThread)},</span>
<span class="line-added">2765   {CC &quot;attachCurrentThread&quot;,                          CC &quot;(Z)Z&quot;,                                                                            FN_PTR(attachCurrentThread)},</span>
<span class="line-added">2766   {CC &quot;detachCurrentThread&quot;,                          CC &quot;()V&quot;,                                                                             FN_PTR(detachCurrentThread)},</span>
<span class="line-added">2767   {CC &quot;translate&quot;,                                    CC &quot;(&quot; OBJECT &quot;)J&quot;,                                                                   FN_PTR(translate)},</span>
<span class="line-added">2768   {CC &quot;unhand&quot;,                                       CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(unhand)},</span>
<span class="line-added">2769   {CC &quot;updateHotSpotNmethod&quot;,                         CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(updateHotSpotNmethod)},</span>
<span class="line-added">2770   {CC &quot;getCode&quot;,                                      CC &quot;(&quot; HS_INSTALLED_CODE &quot;)[B&quot;,                                                       FN_PTR(getCode)},</span>
2771   {CC &quot;asReflectionExecutable&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)&quot; REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
2772   {CC &quot;asReflectionField&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;I)&quot; REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},
<span class="line-added">2773   {CC &quot;getFailedSpeculations&quot;,                        CC &quot;(J[[B)[[B&quot;,                                                                       FN_PTR(getFailedSpeculations)},</span>
<span class="line-added">2774   {CC &quot;getFailedSpeculationsAddress&quot;,                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getFailedSpeculationsAddress)},</span>
<span class="line-added">2775   {CC &quot;releaseFailedSpeculations&quot;,                    CC &quot;(J)V&quot;,                                                                            FN_PTR(releaseFailedSpeculations)},</span>
<span class="line-added">2776   {CC &quot;addFailedSpeculation&quot;,                         CC &quot;(J[B)Z&quot;,                                                                          FN_PTR(addFailedSpeculation)},</span>
<span class="line-added">2777   {CC &quot;callSystemExit&quot;,                               CC &quot;(I)V&quot;,                                                                            FN_PTR(callSystemExit)},</span>
2778 };
2779 
2780 int CompilerToVM::methods_count() {
2781   return sizeof(methods) / sizeof(JNINativeMethod);
2782 }
</pre>
</td>
</tr>
</table>
<center><a href="jvmciCompiler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciCompilerToVM.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
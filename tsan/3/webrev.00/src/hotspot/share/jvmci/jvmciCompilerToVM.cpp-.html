<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;ci/ciUtilities.inline.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;code/scopeDesc.hpp&quot;
  28 #include &quot;interpreter/linkResolver.hpp&quot;
  29 #include &quot;memory/oopFactory.hpp&quot;
  30 #include &quot;oops/cpCache.inline.hpp&quot;
  31 #include &quot;oops/generateOopMap.hpp&quot;
  32 #include &quot;oops/method.inline.hpp&quot;
  33 #include &quot;oops/objArrayOop.inline.hpp&quot;
  34 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;compiler/disassembler.hpp&quot;
  37 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  38 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  39 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  40 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  41 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  42 #include &quot;runtime/frame.inline.hpp&quot;
  43 #include &quot;runtime/handles.inline.hpp&quot;
  44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  45 #include &quot;runtime/jniHandles.inline.hpp&quot;
  46 #include &quot;runtime/timerTrace.hpp&quot;
  47 #include &quot;runtime/vframe_hp.hpp&quot;
  48 
  49 JVMCIKlassHandle::JVMCIKlassHandle(Thread* thread, Klass* klass) {
  50   _thread = thread;
  51   _klass = klass;
  52   if (klass != NULL) {
  53     _holder = Handle(_thread, klass-&gt;klass_holder());
  54   }
  55 }
  56 
  57 JVMCIKlassHandle&amp; JVMCIKlassHandle::operator=(Klass* klass) {
  58   _klass = klass;
  59   if (klass != NULL) {
  60     _holder = Handle(_thread, klass-&gt;klass_holder());
  61   }
  62   return *this;
  63 }
  64 
  65 void JNIHandleMark::push_jni_handle_block() {
  66   JavaThread* thread = JavaThread::current();
  67   if (thread != NULL) {
  68     // Allocate a new block for JNI handles.
  69     // Inlined code from jni_PushLocalFrame()
  70     JNIHandleBlock* java_handles = ((JavaThread*)thread)-&gt;active_handles();
  71     JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
  72     assert(compile_handles != NULL &amp;&amp; java_handles != NULL, &quot;should not be NULL&quot;);
  73     compile_handles-&gt;set_pop_frame_link(java_handles);
  74     thread-&gt;set_active_handles(compile_handles);
  75   }
  76 }
  77 
  78 void JNIHandleMark::pop_jni_handle_block() {
  79   JavaThread* thread = JavaThread::current();
  80   if (thread != NULL) {
  81     // Release our JNI handle block
  82     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  83     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  84     thread-&gt;set_active_handles(java_handles);
  85     compile_handles-&gt;set_pop_frame_link(NULL);
  86     JNIHandleBlock::release_block(compile_handles, thread); // may block
  87   }
  88 }
  89 
  90 // Entry to native method implementation that transitions current thread to &#39;_thread_in_vm&#39;.
  91 #define C2V_VMENTRY(result_type, name, signature) \
  92   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
  93   TRACE_jvmci_1(&quot;CompilerToVM::&quot; #name); \
  94   TRACE_CALL(result_type, jvmci_ ## name signature) \
  95   JVMCI_VM_ENTRY_MARK; \
  96 
  97 #define C2V_END }
  98 
  99 oop CompilerToVM::get_jvmci_method(const methodHandle&amp; method, TRAPS) {
 100   if (method() != NULL) {
 101     JavaValue result(T_OBJECT);
 102     JavaCallArguments args;
 103     args.push_long((jlong) (address) method());
 104     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedJavaMethodImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::method_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 105 
 106     return (oop)result.get_jobject();
 107   }
 108   return NULL;
 109 }
 110 
 111 oop CompilerToVM::get_jvmci_type(JVMCIKlassHandle&amp; klass, TRAPS) {
 112   if (!klass.is_null()) {
 113     JavaValue result(T_OBJECT);
 114     JavaCallArguments args;
 115     args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
 116     JavaCalls::call_static(&amp;result, SystemDictionary::HotSpotResolvedObjectTypeImpl_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::klass_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 117 
 118     return (oop)result.get_jobject();
 119   }
 120   return NULL;
 121 }
 122 
 123 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 124   assert(_index &lt; _args-&gt;length(), &quot;out of bounds&quot;);
 125   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 126   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), &quot;arg type mismatch&quot;);
 127   return Handle(Thread::current(), arg);
 128 }
 129 
 130 jobjectArray readConfiguration0(JNIEnv *env, TRAPS);
 131 
 132 C2V_VMENTRY(jobjectArray, readConfiguration, (JNIEnv *env))
 133    jobjectArray config = readConfiguration0(env, CHECK_NULL);
 134    return config;
 135 C2V_END
 136 
 137 C2V_VMENTRY(jobject, getFlagValue, (JNIEnv *, jobject c2vm, jobject name_handle))
 138 #define RETURN_BOXED_LONG(value) oop box; jvalue p; p.j = (jlong) (value); box = java_lang_boxing_object::create(T_LONG, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);
 139 #define RETURN_BOXED_DOUBLE(value) oop box; jvalue p; p.d = (jdouble) (value); box = java_lang_boxing_object::create(T_DOUBLE, &amp;p, CHECK_NULL); return JNIHandles::make_local(THREAD, box);
 140   Handle name(THREAD, JNIHandles::resolve(name_handle));
 141   if (name.is_null()) {
 142     THROW_0(vmSymbols::java_lang_NullPointerException());
 143   }
 144   ResourceMark rm;
 145   const char* cstring = java_lang_String::as_utf8_string(name());
 146   JVMFlag* flag = JVMFlag::find_flag(cstring, strlen(cstring), /* allow_locked */ true, /* return_flag */ true);
 147   if (flag == NULL) {
 148     return c2vm;
 149   }
 150   if (flag-&gt;is_bool()) {
 151     jvalue prim;
 152     prim.z = flag-&gt;get_bool();
 153     oop box = java_lang_boxing_object::create(T_BOOLEAN, &amp;prim, CHECK_NULL);
 154     return JNIHandles::make_local(THREAD, box);
 155   } else if (flag-&gt;is_ccstr()) {
 156     Handle value = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_NULL);
 157     return JNIHandles::make_local(THREAD, value());
 158   } else if (flag-&gt;is_intx()) {
 159     RETURN_BOXED_LONG(flag-&gt;get_intx());
 160   } else if (flag-&gt;is_int()) {
 161     RETURN_BOXED_LONG(flag-&gt;get_int());
 162   } else if (flag-&gt;is_uint()) {
 163     RETURN_BOXED_LONG(flag-&gt;get_uint());
 164   } else if (flag-&gt;is_uint64_t()) {
 165     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 166   } else if (flag-&gt;is_size_t()) {
 167     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 168   } else if (flag-&gt;is_uintx()) {
 169     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 170   } else if (flag-&gt;is_double()) {
 171     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 172   } else {
 173     JVMCI_ERROR_NULL(&quot;VM flag %s has unsupported type %s&quot;, flag-&gt;_name, flag-&gt;_type);
 174   }
 175 #undef RETURN_BOXED_LONG
 176 #undef RETURN_BOXED_DOUBLE
 177 C2V_END
 178 
 179 C2V_VMENTRY(jbyteArray, getBytecode, (JNIEnv *, jobject, jobject jvmci_method))
 180   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 181   ResourceMark rm;
 182 
 183   int code_size = method-&gt;code_size();
 184   typeArrayOop reconstituted_code = oopFactory::new_byteArray(code_size, CHECK_NULL);
 185 
 186   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), &quot;Method&#39;s holder should be rewritten&quot;);
 187   // iterate over all bytecodes and replace non-Java bytecodes
 188 
 189   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 190     Bytecodes::Code code = s.code();
 191     Bytecodes::Code raw_code = s.raw_code();
 192     int bci = s.bci();
 193     int len = s.instruction_size();
 194 
 195     // Restore original byte code.
 196     reconstituted_code-&gt;byte_at_put(bci, (jbyte) (s.is_wide()? Bytecodes::_wide : code));
 197     if (len &gt; 1) {
 198       memcpy(reconstituted_code-&gt;byte_at_addr(bci + 1), s.bcp()+1, len-1);
 199     }
 200 
 201     if (len &gt; 1) {
 202       // Restore the big-endian constant pool indexes.
 203       // Cf. Rewriter::scan_method
 204       switch (code) {
 205         case Bytecodes::_getstatic:
 206         case Bytecodes::_putstatic:
 207         case Bytecodes::_getfield:
 208         case Bytecodes::_putfield:
 209         case Bytecodes::_invokevirtual:
 210         case Bytecodes::_invokespecial:
 211         case Bytecodes::_invokestatic:
 212         case Bytecodes::_invokeinterface:
 213         case Bytecodes::_invokehandle: {
 214           int cp_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 215           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 216           break;
 217         }
 218 
 219         case Bytecodes::_invokedynamic: {
 220           int cp_index = Bytes::get_native_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 221           Bytes::put_Java_u4((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u4) cp_index);
 222           break;
 223         }
 224 
 225         default:
 226           break;
 227       }
 228 
 229       // Not all ldc byte code are rewritten.
 230       switch (raw_code) {
 231         case Bytecodes::_fast_aldc: {
 232           int cpc_index = reconstituted_code-&gt;byte_at(bci + 1) &amp; 0xff;
 233           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 234           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
 235           reconstituted_code-&gt;byte_at_put(bci + 1, (jbyte) cp_index);
 236           break;
 237         }
 238 
 239         case Bytecodes::_fast_aldc_w: {
 240           int cpc_index = Bytes::get_native_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1));
 241           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 242           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
 243           Bytes::put_Java_u2((address) reconstituted_code-&gt;byte_at_addr(bci + 1), (u2) cp_index);
 244           break;
 245         }
 246 
 247         default:
 248           break;
 249       }
 250     }
 251   }
 252 
 253   return (jbyteArray) JNIHandles::make_local(THREAD, reconstituted_code);
 254 C2V_END
 255 
 256 C2V_VMENTRY(jint, getExceptionTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 257   ResourceMark rm;
 258   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 259   return method-&gt;exception_table_length();
 260 C2V_END
 261 
 262 C2V_VMENTRY(jlong, getExceptionTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 263   ResourceMark rm;
 264   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 265   if (method-&gt;exception_table_length() == 0) {
 266     return 0L;
 267   }
 268   return (jlong) (address) method-&gt;exception_table_start();
 269 C2V_END
 270 
 271 C2V_VMENTRY(jobject, asResolvedJavaMethod, (JNIEnv *, jobject, jobject executable_handle))
 272   oop executable = JNIHandles::resolve(executable_handle);
 273   oop mirror = NULL;
 274   int slot = 0;
 275 
 276   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 277     mirror = java_lang_reflect_Constructor::clazz(executable);
 278     slot = java_lang_reflect_Constructor::slot(executable);
 279   } else {
 280     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 281     mirror = java_lang_reflect_Method::clazz(executable);
 282     slot = java_lang_reflect_Method::slot(executable);
 283   }
 284   Klass* holder = java_lang_Class::as_Klass(mirror);
 285   methodHandle method = InstanceKlass::cast(holder)-&gt;method_with_idnum(slot);
 286   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 287   return JNIHandles::make_local(THREAD, result);
 288 }
 289 
 290 C2V_VMENTRY(jobject, getResolvedJavaMethod, (JNIEnv *, jobject, jobject base, jlong offset))
 291   methodHandle method;
 292   oop base_object = JNIHandles::resolve(base);
 293   if (base_object == NULL) {
 294     method = *((Method**)(offset));
 295   } else if (base_object-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {
 296     method = (Method*) (intptr_t) base_object-&gt;long_field(offset);
 297   } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 298     method = *((Method**)(HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object) + offset));
 299   } else {
 300     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 301                 err_msg(&quot;Unexpected type: %s&quot;, base_object-&gt;klass()-&gt;external_name()));
 302   }
 303   assert (method.is_null() || method-&gt;is_method(), &quot;invalid read&quot;);
 304   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 305   return JNIHandles::make_local(THREAD, result);
 306 }
 307 
 308 C2V_VMENTRY(jobject, getConstantPool, (JNIEnv *, jobject, jobject object_handle))
 309   constantPoolHandle cp;
 310   oop object = JNIHandles::resolve(object_handle);
 311   if (object == NULL) {
 312     THROW_0(vmSymbols::java_lang_NullPointerException());
 313   }
 314   if (object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 315     cp = CompilerToVM::asMethod(object)-&gt;constMethod()-&gt;constants();
 316   } else if (object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 317     cp = InstanceKlass::cast(CompilerToVM::asKlass(object))-&gt;constants();
 318   } else {
 319     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 320                 err_msg(&quot;Unexpected type: %s&quot;, object-&gt;klass()-&gt;external_name()));
 321   }
 322   assert(!cp.is_null(), &quot;npe&quot;);
 323   JavaValue method_result(T_OBJECT);
 324   JavaCallArguments args;
 325   args.push_long((jlong) (address) cp());
 326   JavaCalls::call_static(&amp;method_result, SystemDictionary::HotSpotConstantPool_klass(), vmSymbols::fromMetaspace_name(), vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, CHECK_NULL);
 327   return JNIHandles::make_local(THREAD, (oop)method_result.get_jobject());
 328 }
 329 
 330 C2V_VMENTRY(jobject, getResolvedJavaType, (JNIEnv *, jobject, jobject base, jlong offset, jboolean compressed))
 331   JVMCIKlassHandle klass(THREAD);
 332   oop base_object = JNIHandles::resolve(base);
 333   jlong base_address = 0;
 334   if (base_object != NULL &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 335     klass = base_object-&gt;klass();
 336   } else if (!compressed) {
 337     if (base_object != NULL) {
 338       if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedJavaMethodImpl_klass())) {
 339         base_address = HotSpotResolvedJavaMethodImpl::metaspaceMethod(base_object);
 340       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotConstantPool_klass())) {
 341         base_address = HotSpotConstantPool::metaspaceConstantPool(base_object);
 342       } else if (base_object-&gt;is_a(SystemDictionary::HotSpotResolvedObjectTypeImpl_klass())) {
 343         base_address = (jlong) CompilerToVM::asKlass(base_object);
 344       } else if (base_object-&gt;is_a(SystemDictionary::Class_klass())) {
 345         base_address = (jlong) (address) base_object;
 346       } else {
 347         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 348                     err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;, base_object-&gt;klass()-&gt;external_name(), offset, compressed ? &quot;true&quot; : &quot;false&quot;));
 349       }
 350     }
 351     klass = *((Klass**) (intptr_t) (base_address + offset));
 352   } else {
 353     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 354                 err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;,
 355                         base_object != NULL ? base_object-&gt;klass()-&gt;external_name() : &quot;null&quot;,
 356                         offset, compressed ? &quot;true&quot; : &quot;false&quot;));
 357   }
 358   assert (klass == NULL || klass-&gt;is_klass(), &quot;invalid read&quot;);
 359   oop result = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 360   return JNIHandles::make_local(THREAD, result);
 361 }
 362 
 363 C2V_VMENTRY(jobject, findUniqueConcreteMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 364   ResourceMark rm;
 365   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 366   Klass* holder = CompilerToVM::asKlass(jvmci_type);
 367   if (holder-&gt;is_interface()) {
 368     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Interface %s should be handled in Java code&quot;, holder-&gt;external_name()));
 369   }
 370 
 371   methodHandle ucm;
 372   {
 373     MutexLocker locker(Compile_lock);
 374     ucm = Dependencies::find_unique_concrete_method(holder, method());
 375   }
 376   oop result = CompilerToVM::get_jvmci_method(ucm, CHECK_NULL);
 377   return JNIHandles::make_local(THREAD, result);
 378 C2V_END
 379 
 380 C2V_VMENTRY(jobject, getImplementor, (JNIEnv *, jobject, jobject jvmci_type))
 381   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 382   if (!klass-&gt;is_interface()) {
 383     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 384         err_msg(&quot;Expected interface type, got %s&quot;, klass-&gt;external_name()));
 385   }
 386   InstanceKlass* iklass = InstanceKlass::cast(klass);
 387   JVMCIKlassHandle handle(THREAD);
 388   {
 389     // Need Compile_lock around implementor()
 390     MutexLocker locker(Compile_lock);
 391     handle = iklass-&gt;implementor();
 392   }
 393   oop implementor = CompilerToVM::get_jvmci_type(handle, CHECK_NULL);
 394   return JNIHandles::make_local(THREAD, implementor);
 395 C2V_END
 396 
 397 C2V_VMENTRY(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv *, jobject, jobject jvmci_method))
 398   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 399   return method-&gt;is_ignored_by_security_stack_walk();
 400 C2V_END
 401 
 402 C2V_VMENTRY(jboolean, isCompilable,(JNIEnv *, jobject, jobject jvmci_method))
 403   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 404   constantPoolHandle cp = method-&gt;constMethod()-&gt;constants();
 405   assert(!cp.is_null(), &quot;npe&quot;);
 406   // don&#39;t inline method when constant pool contains a CONSTANT_Dynamic
 407   return !method-&gt;is_not_compilable(CompLevel_full_optimization) &amp;&amp; !cp-&gt;has_dynamic_constant();
 408 C2V_END
 409 
 410 C2V_VMENTRY(jboolean, hasNeverInlineDirective,(JNIEnv *, jobject, jobject jvmci_method))
 411   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 412   return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 413 C2V_END
 414 
 415 C2V_VMENTRY(jboolean, shouldInlineMethod,(JNIEnv *, jobject, jobject jvmci_method))
 416   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 417   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 418 C2V_END
 419 
 420 C2V_VMENTRY(jobject, lookupType, (JNIEnv*, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 421   ResourceMark rm;
 422   Handle name(THREAD, JNIHandles::resolve(jname));
 423   Symbol* class_name = java_lang_String::as_symbol(name(), CHECK_0);
 424   if (java_lang_String::length(name()) &lt;= 1) {
 425     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Primitive type %s should be handled in Java code&quot;, class_name-&gt;as_C_string()));
 426   }
 427 
 428   JVMCIKlassHandle resolved_klass(THREAD);
 429   if (JNIHandles::resolve(accessing_class) == NULL) {
 430     THROW_0(vmSymbols::java_lang_NullPointerException());
 431   }
 432   Klass* accessing_klass = java_lang_Class::as_Klass(JNIHandles::resolve(accessing_class));
 433   Handle class_loader(THREAD, accessing_klass-&gt;class_loader());
 434   Handle protection_domain(THREAD, accessing_klass-&gt;protection_domain());
 435 
 436   if (resolve) {
 437     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 438   } else {
 439     if (class_name-&gt;char_at(0) == &#39;L&#39; &amp;&amp;
 440       class_name-&gt;char_at(class_name-&gt;utf8_length()-1) == &#39;;&#39;) {
 441       // This is a name from a signature.  Strip off the trimmings.
 442       // Call recursive to keep scope of strippedsym.
 443       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,
 444                                                           class_name-&gt;utf8_length()-2,
 445                                                           CHECK_0);
 446       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
 447     } else if (FieldType::is_array(class_name)) {
 448       FieldArrayInfo fd;
 449       // dimension and object_key in FieldArrayInfo are assigned as a side-effect
 450       // of this call
 451       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);
 452       if (t == T_OBJECT) {
 453         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),
 454                                                             class_name-&gt;utf8_length()-2-fd.dimension(),
 455                                                             CHECK_0);
 456         // naked oop &quot;k&quot; is OK here -- we assign back into it
 457         resolved_klass = SystemDictionary::find(strippedsym,
 458                                                              class_loader,
 459                                                              protection_domain,
 460                                                              CHECK_0);
 461         if (!resolved_klass.is_null()) {
 462           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);
 463         }
 464       } else {
 465         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(t))-&gt;array_klass(fd.dimension(), CHECK_0);
 466       }
 467     }
 468   }
 469   oop result = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 470   return JNIHandles::make_local(THREAD, result);
 471 C2V_END
 472 
 473 C2V_VMENTRY(jobject, resolveConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 474   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 475   oop result = cp-&gt;resolve_constant_at(index, CHECK_NULL);
 476   return JNIHandles::make_local(THREAD, result);
 477 C2V_END
 478 
 479 C2V_VMENTRY(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 480   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 481   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 482   return JNIHandles::make_local(THREAD, result);
 483 C2V_END
 484 
 485 C2V_VMENTRY(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 486   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 487   return cp-&gt;name_and_type_ref_index_at(index);
 488 C2V_END
 489 
 490 C2V_VMENTRY(jobject, lookupNameInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 491   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 492   Handle sym = java_lang_String::create_from_symbol(cp-&gt;name_ref_at(which), CHECK_NULL);
 493   return JNIHandles::make_local(THREAD, sym());
 494 C2V_END
 495 
 496 C2V_VMENTRY(jobject, lookupSignatureInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint which))
 497   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 498   Handle sym = java_lang_String::create_from_symbol(cp-&gt;signature_ref_at(which), CHECK_NULL);
 499   return JNIHandles::make_local(THREAD, sym());
 500 C2V_END
 501 
 502 C2V_VMENTRY(jint, lookupKlassRefIndexInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 503   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 504   return cp-&gt;klass_ref_index_at(index);
 505 C2V_END
 506 
 507 C2V_VMENTRY(jobject, resolveTypeInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 508   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 509   Klass* klass = cp-&gt;klass_at(index, CHECK_NULL);
 510   JVMCIKlassHandle resolved_klass(THREAD, klass);
 511   if (resolved_klass-&gt;is_instance_klass()) {
 512     InstanceKlass::cast(resolved_klass())-&gt;link_class_or_fail(THREAD);
 513   }
 514   oop jvmci_type = CompilerToVM::get_jvmci_type(resolved_klass, CHECK_NULL);
 515   return JNIHandles::make_local(THREAD, jvmci_type);
 516 C2V_END
 517 
 518 C2V_VMENTRY(jobject, lookupKlassInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 519   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 520   Klass* loading_klass = cp-&gt;pool_holder();
 521   bool is_accessible = false;
 522   JVMCIKlassHandle klass(THREAD, JVMCIEnv::get_klass_by_index(cp, index, is_accessible, loading_klass));
 523   Symbol* symbol = NULL;
 524   if (klass == NULL) {
 525     symbol = cp-&gt;klass_name_at(index);
 526   }
 527   oop result_oop;
 528   if (!klass.is_null()) {
 529     result_oop = CompilerToVM::get_jvmci_type(klass, CHECK_NULL);
 530   } else {
 531     Handle result = java_lang_String::create_from_symbol(symbol, CHECK_NULL);
 532     result_oop = result();
 533   }
 534   return JNIHandles::make_local(THREAD, result_oop);
 535 C2V_END
 536 
 537 C2V_VMENTRY(jobject, lookupAppendixInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 538   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 539   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 540   return JNIHandles::make_local(THREAD, appendix_oop);
 541 C2V_END
 542 
 543 C2V_VMENTRY(jobject, lookupMethodInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 544   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 545   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 546   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 547   methodHandle method = JVMCIEnv::get_method_by_index(cp, index, bc, pool_holder);
 548   oop result = CompilerToVM::get_jvmci_method(method, CHECK_NULL);
 549   return JNIHandles::make_local(THREAD, result);
 550 C2V_END
 551 
 552 C2V_VMENTRY(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
 553   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 554   return cp-&gt;remap_instruction_operand_from_cache(index);
 555 C2V_END
 556 
 557 C2V_VMENTRY(jobject, resolveFieldInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 558   ResourceMark rm;
 559   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
 560   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 561   fieldDescriptor fd;
 562   LinkInfo link_info(cp, index, (jvmci_method != NULL) ? CompilerToVM::asMethod(jvmci_method) : NULL, CHECK_0);
 563   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 564   typeArrayOop info = (typeArrayOop) JNIHandles::resolve(info_handle);
 565   if (info == NULL || info-&gt;length() != 3) {
 566     JVMCI_ERROR_NULL(&quot;info must not be null and have a length of 3&quot;);
 567   }
 568   info-&gt;int_at_put(0, fd.access_flags().as_int());
 569   info-&gt;int_at_put(1, fd.offset());
 570   info-&gt;int_at_put(2, fd.index());
 571   JVMCIKlassHandle handle(THREAD, fd.field_holder());
 572   oop field_holder = CompilerToVM::get_jvmci_type(handle, CHECK_NULL);
 573   return JNIHandles::make_local(THREAD, field_holder);
 574 C2V_END
 575 
 576 C2V_VMENTRY(jint, getVtableIndexForInterfaceMethod, (JNIEnv *, jobject, jobject jvmci_type, jobject jvmci_method))
 577   ResourceMark rm;
 578   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 579   Method* method = CompilerToVM::asMethod(jvmci_method);
 580   if (klass-&gt;is_interface()) {
 581     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Interface %s should be handled in Java code&quot;, klass-&gt;external_name()));
 582   }
 583   if (!method-&gt;method_holder()-&gt;is_interface()) {
 584     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Method %s is not held by an interface, this case should be handled in Java code&quot;, method-&gt;name_and_sig_as_C_string()));
 585   }
 586   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 587     THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(&quot;Class %s must be linked&quot;, klass-&gt;external_name()));
 588   }
 589   return LinkResolver::vtable_index_of_interface_method(klass, method);
 590 C2V_END
 591 
 592 C2V_VMENTRY(jobject, resolveMethod, (JNIEnv *, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 593   Klass* recv_klass = CompilerToVM::asKlass(receiver_jvmci_type);
 594   Klass* caller_klass = CompilerToVM::asKlass(caller_jvmci_type);
 595   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 596 
 597   Klass* resolved     = method-&gt;method_holder();
 598   Symbol* h_name      = method-&gt;name();
 599   Symbol* h_signature = method-&gt;signature();
 600 
 601   if (MethodHandles::is_signature_polymorphic_method(method())) {
 602       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 603       return NULL;
 604   }
 605 
 606   if (method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 607       resolved == SystemDictionary::Object_klass() &amp;&amp;
 608       recv_klass-&gt;is_array_klass()) {
 609     // Resolution of the clone method on arrays always returns Object.clone even though that method
 610     // has protected access.  There&#39;s some trickery in the access checking to make this all work out
 611     // so it&#39;s necessary to pass in the array class as the resolved class to properly trigger this.
 612     // Otherwise it&#39;s impossible to resolve the array clone methods through JVMCI.  See
 613     // LinkResolver::check_method_accessability for the matching logic.
 614     resolved = recv_klass;
 615   }
 616 
 617   LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
 618   methodHandle m;
 619   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 620   // the vtable has not been setup, and the LinkResolver will fail.
 621   if (recv_klass-&gt;is_array_klass() ||
 622       (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
 623     if (resolved-&gt;is_interface()) {
 624       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 625     } else {
 626       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 627     }
 628   }
 629 
 630   if (m.is_null()) {
 631     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 632     return NULL;
 633   }
 634 
 635   oop result = CompilerToVM::get_jvmci_method(m, CHECK_NULL);
 636   return JNIHandles::make_local(THREAD, result);
 637 C2V_END
 638 
 639 C2V_VMENTRY(jboolean, hasFinalizableSubclass,(JNIEnv *, jobject, jobject jvmci_type))
 640   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 641   assert(klass != NULL, &quot;method must not be called for primitive types&quot;);
 642   return Dependencies::find_finalizable_subclass(klass) != NULL;
 643 C2V_END
 644 
 645 C2V_VMENTRY(jobject, getClassInitializer, (JNIEnv *, jobject, jobject jvmci_type))
 646   Klass* klass = CompilerToVM::asKlass(jvmci_type);
 647   if (!klass-&gt;is_instance_klass()) {
 648     return NULL;
 649   }
 650   InstanceKlass* iklass = InstanceKlass::cast(klass);
 651   oop result = CompilerToVM::get_jvmci_method(iklass-&gt;class_initializer(), CHECK_NULL);
 652   return JNIHandles::make_local(THREAD, result);
 653 C2V_END
 654 
 655 C2V_VMENTRY(jlong, getMaxCallTargetOffset, (JNIEnv*, jobject, jlong addr))
 656   address target_addr = (address) addr;
 657   if (target_addr != 0x0) {
 658     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 659     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 660     return MAX2(ABS(off_low), ABS(off_high));
 661   }
 662   return -1;
 663 C2V_END
 664 
 665 C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv *, jobject,  jobject jvmci_method))
 666   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 667   method-&gt;set_not_c1_compilable();
 668   method-&gt;set_not_c2_compilable();
 669   method-&gt;set_dont_inline(true);
 670 C2V_END
 671 
 672 C2V_VMENTRY(jint, installCode, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject installed_code, jobject speculation_log))
 673   ResourceMark rm;
 674   HandleMark hm;
 675   JNIHandleMark jni_hm;
 676 
 677   Handle target_handle(THREAD, JNIHandles::resolve(target));
 678   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));
 679   CodeBlob* cb = NULL;
 680   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));
 681   Handle speculation_log_handle(THREAD, JNIHandles::resolve(speculation_log));
 682 
 683   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
 684 
 685   TraceTime install_time(&quot;installCode&quot;, JVMCICompiler::codeInstallTimer());
 686   bool is_immutable_PIC = HotSpotCompiledCode::isImmutablePIC(compiled_code_handle) &gt; 0;
 687   CodeInstaller installer(is_immutable_PIC);
 688   JVMCIEnv::CodeInstallResult result = installer.install(compiler, target_handle, compiled_code_handle, cb, installed_code_handle, speculation_log_handle, CHECK_0);
 689 
 690   if (PrintCodeCacheOnCompilation) {
 691     stringStream s;
 692     // Dump code cache  into a buffer before locking the tty,
 693     {
 694       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 695       CodeCache::print_summary(&amp;s, false);
 696     }
 697     ttyLocker ttyl;
 698     tty-&gt;print_raw_cr(s.as_string());
 699   }
 700 
 701   if (result != JVMCIEnv::ok) {
 702     assert(cb == NULL, &quot;should be&quot;);
 703   } else {
 704     if (installed_code_handle.not_null()) {
 705       assert(installed_code_handle-&gt;is_a(InstalledCode::klass()), &quot;wrong type&quot;);
 706       nmethod::invalidate_installed_code(installed_code_handle, CHECK_0);
 707       {
 708         // Ensure that all updates to the InstalledCode fields are consistent.
 709         MutexLockerEx pl(Patching_lock, Mutex::_no_safepoint_check_flag);
 710         InstalledCode::set_address(installed_code_handle, (jlong) cb);
 711         InstalledCode::set_version(installed_code_handle, InstalledCode::version(installed_code_handle) + 1);
 712         if (cb-&gt;is_nmethod()) {
 713           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;as_nmethod_or_null()-&gt;verified_entry_point());
 714         } else {
 715           InstalledCode::set_entryPoint(installed_code_handle, (jlong) cb-&gt;code_begin());
 716         }
 717         if (installed_code_handle-&gt;is_a(HotSpotInstalledCode::klass())) {
 718           HotSpotInstalledCode::set_size(installed_code_handle, cb-&gt;size());
 719           HotSpotInstalledCode::set_codeStart(installed_code_handle, (jlong) cb-&gt;code_begin());
 720           HotSpotInstalledCode::set_codeSize(installed_code_handle, cb-&gt;code_size());
 721         }
 722       }
 723     }
 724   }
 725   return result;
 726 C2V_END
 727 
 728 C2V_VMENTRY(jint, getMetadata, (JNIEnv *jniEnv, jobject, jobject target, jobject compiled_code, jobject metadata))
 729 #if INCLUDE_AOT
 730   ResourceMark rm;
 731   HandleMark hm;
 732 
 733   Handle target_handle(THREAD, JNIHandles::resolve(target));
 734   Handle compiled_code_handle(THREAD, JNIHandles::resolve(compiled_code));
 735   Handle metadata_handle(THREAD, JNIHandles::resolve(metadata));
 736 
 737   CodeMetadata code_metadata;
 738   CodeBlob *cb = NULL;
 739   CodeInstaller installer(true /* immutable PIC compilation */);
 740 
 741   JVMCIEnv::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, CHECK_0);
 742   if (result != JVMCIEnv::ok) {
 743     return result;
 744   }
 745 
 746   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 747     typeArrayHandle pcArrayOop = oopFactory::new_byteArray_handle(sizeof(PcDesc) * code_metadata.get_nr_pc_desc(), CHECK_(JVMCIEnv::cache_full));
 748     memcpy(pcArrayOop-&gt;byte_at_addr(0), code_metadata.get_pc_desc(), sizeof(PcDesc) * code_metadata.get_nr_pc_desc());
 749     HotSpotMetaData::set_pcDescBytes(metadata_handle, pcArrayOop());
 750   }
 751 
 752   if (code_metadata.get_scopes_size() &gt; 0) {
 753     typeArrayHandle scopesArrayOop = oopFactory::new_byteArray_handle(code_metadata.get_scopes_size(), CHECK_(JVMCIEnv::cache_full));
 754     memcpy(scopesArrayOop-&gt;byte_at_addr(0), code_metadata.get_scopes_desc(), code_metadata.get_scopes_size());
 755     HotSpotMetaData::set_scopesDescBytes(metadata_handle, scopesArrayOop());
 756   }
 757 
 758   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
 759   typeArrayHandle relocArrayOop = oopFactory::new_byteArray_handle((int) reloc_buffer-&gt;size(), CHECK_(JVMCIEnv::cache_full));
 760   if (reloc_buffer-&gt;size() &gt; 0) {
 761     memcpy(relocArrayOop-&gt;byte_at_addr(0), reloc_buffer-&gt;begin(), reloc_buffer-&gt;size());
 762   }
 763   HotSpotMetaData::set_relocBytes(metadata_handle, relocArrayOop());
 764 
 765   const OopMapSet* oopMapSet = installer.oopMapSet();
 766   {
 767     ResourceMark mark;
 768     ImmutableOopMapBuilder builder(oopMapSet);
 769     int oopmap_size = builder.heap_size();
 770     typeArrayHandle oopMapArrayHandle = oopFactory::new_byteArray_handle(oopmap_size, CHECK_(JVMCIEnv::cache_full));
 771     builder.generate_into((address) oopMapArrayHandle-&gt;byte_at_addr(0));
 772     HotSpotMetaData::set_oopMaps(metadata_handle, oopMapArrayHandle());
 773   }
 774 
 775   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
 776 
 777   int nr_meta_refs = recorder-&gt;nr_meta_refs();
 778   objArrayOop metadataArray = oopFactory::new_objectArray(nr_meta_refs, CHECK_(JVMCIEnv::cache_full));
 779   objArrayHandle metadataArrayHandle(THREAD, metadataArray);
 780   for (int i = 0; i &lt; nr_meta_refs; ++i) {
 781     jobject element = recorder-&gt;meta_element(i);
 782     if (element == NULL) {
 783       return JVMCIEnv::cache_full;
 784     }
 785     metadataArrayHandle-&gt;obj_at_put(i, JNIHandles::resolve(element));
 786   }
 787   HotSpotMetaData::set_metadata(metadata_handle, metadataArrayHandle());
 788 
 789   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 790   int table_size = handler-&gt;size_in_bytes();
 791   typeArrayHandle exceptionArrayOop = oopFactory::new_byteArray_handle(table_size, CHECK_(JVMCIEnv::cache_full));
 792 
 793   if (table_size &gt; 0) {
 794     handler-&gt;copy_bytes_to((address) exceptionArrayOop-&gt;byte_at_addr(0));
 795   }
 796   HotSpotMetaData::set_exceptionBytes(metadata_handle, exceptionArrayOop());
 797 
 798   return result;
 799 #else
 800   THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;unimplemented&quot;);
 801 #endif
 802 C2V_END
 803 
 804 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv *jniEnv, jobject))
 805   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
 806   CompilerStatistics* stats = compiler-&gt;stats();
 807   stats-&gt;_standard.reset();
 808   stats-&gt;_osr.reset();
 809 C2V_END
 810 
 811 C2V_VMENTRY(jobject, disassembleCodeBlob, (JNIEnv *jniEnv, jobject, jobject installedCode))
 812   ResourceMark rm;
 813   HandleMark hm;
 814 
 815   if (installedCode == NULL) {
 816     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(), &quot;installedCode is null&quot;);
 817   }
 818 
 819   jlong codeBlob = InstalledCode::address(installedCode);
 820   if (codeBlob == 0L) {
 821     return NULL;
 822   }
 823 
 824   CodeBlob* cb = (CodeBlob*) (address) codeBlob;
 825   if (cb == NULL) {
 826     return NULL;
 827   }
 828 
 829   // We don&#39;t want the stringStream buffer to resize during disassembly as it
 830   // uses scoped resource memory. If a nested function called during disassembly uses
 831   // a ResourceMark and the buffer expands within the scope of the mark,
 832   // the buffer becomes garbage when that scope is exited. Experience shows that
 833   // the disassembled code is typically about 10x the code size so a fixed buffer
 834   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 835   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 836   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 837   stringStream st(buffer, bufferSize);
 838   if (cb-&gt;is_nmethod()) {
 839     nmethod* nm = (nmethod*) cb;
 840     if (!nm-&gt;is_alive()) {
 841       return NULL;
 842     }
 843   }
 844   Disassembler::decode(cb, &amp;st);
 845   if (st.size() &lt;= 0) {
 846     return NULL;
 847   }
 848 
 849   Handle result = java_lang_String::create_from_platform_dependent_str(st.as_string(), CHECK_NULL);
 850   return JNIHandles::make_local(THREAD, result());
 851 C2V_END
 852 
 853 C2V_VMENTRY(jobject, getStackTraceElement, (JNIEnv*, jobject, jobject jvmci_method, int bci))
 854   ResourceMark rm;
 855   HandleMark hm;
 856 
 857   methodHandle method = CompilerToVM::asMethod(jvmci_method);
 858   oop element = java_lang_StackTraceElement::create(method, bci, CHECK_NULL);
 859   return JNIHandles::make_local(THREAD, element);
 860 C2V_END
 861 
 862 C2V_VMENTRY(jobject, executeInstalledCode, (JNIEnv*, jobject, jobject args, jobject hotspotInstalledCode))
 863   ResourceMark rm;
 864   HandleMark hm;
 865 
 866   jlong nmethodValue = InstalledCode::address(hotspotInstalledCode);
 867   if (nmethodValue == 0L) {
 868     THROW_NULL(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
 869   }
 870   nmethod* nm = (nmethod*) (address) nmethodValue;
 871   methodHandle mh = nm-&gt;method();
 872   Symbol* signature = mh-&gt;signature();
 873   JavaCallArguments jca(mh-&gt;size_of_parameters());
 874 
 875   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
 876   JavaValue result(jap.get_ret_type());
 877   jca.set_alternative_target(nm);
 878   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
 879 
 880   if (jap.get_ret_type() == T_VOID) {
 881     return NULL;
 882   } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {
 883     return JNIHandles::make_local(THREAD, (oop) result.get_jobject());
 884   } else {
 885     jvalue *value = (jvalue *) result.get_value_addr();
 886     // Narrow the value down if required (Important on big endian machines)
 887     switch (jap.get_ret_type()) {
 888       case T_BOOLEAN:
 889        value-&gt;z = (jboolean) value-&gt;i;
 890        break;
 891       case T_BYTE:
 892        value-&gt;b = (jbyte) value-&gt;i;
 893        break;
 894       case T_CHAR:
 895        value-&gt;c = (jchar) value-&gt;i;
 896        break;
 897       case T_SHORT:
 898        value-&gt;s = (jshort) value-&gt;i;
 899        break;
 900       default:
 901         break;
 902     }
 903     oop o = java_lang_boxing_object::create(jap.get_ret_type(), value, CHECK_NULL);
 904     return JNIHandles::make_local(THREAD, o);
 905   }
 906 C2V_END
 907 
 908 C2V_VMENTRY(jlongArray, getLineNumberTable, (JNIEnv *, jobject, jobject jvmci_method))
 909   Method* method = CompilerToVM::asMethod(jvmci_method);
 910   if (!method-&gt;has_linenumber_table()) {
 911     return NULL;
 912   }
 913   u2 num_entries = 0;
 914   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
 915   while (streamForSize.read_pair()) {
 916     num_entries++;
 917   }
 918 
 919   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
 920   typeArrayOop result = oopFactory::new_longArray(2 * num_entries, CHECK_NULL);
 921 
 922   int i = 0;
 923   jlong value;
 924   while (stream.read_pair()) {
 925     value = ((long) stream.bci());
 926     result-&gt;long_at_put(i, value);
 927     value = ((long) stream.line());
 928     result-&gt;long_at_put(i + 1, value);
 929     i += 2;
 930   }
 931 
 932   return (jlongArray) JNIHandles::make_local(THREAD, result);
 933 C2V_END
 934 
 935 C2V_VMENTRY(jlong, getLocalVariableTableStart, (JNIEnv *, jobject, jobject jvmci_method))
 936   ResourceMark rm;
 937   Method* method = CompilerToVM::asMethod(jvmci_method);
 938   if (!method-&gt;has_localvariable_table()) {
 939     return 0;
 940   }
 941   return (jlong) (address) method-&gt;localvariable_table_start();
 942 C2V_END
 943 
 944 C2V_VMENTRY(jint, getLocalVariableTableLength, (JNIEnv *, jobject, jobject jvmci_method))
 945   ResourceMark rm;
 946   Method* method = CompilerToVM::asMethod(jvmci_method);
 947   return method-&gt;localvariable_table_length();
 948 C2V_END
 949 
 950 C2V_VMENTRY(void, reprofile, (JNIEnv*, jobject, jobject jvmci_method))
 951   Method* method = CompilerToVM::asMethod(jvmci_method);
 952   MethodCounters* mcs = method-&gt;method_counters();
 953   if (mcs != NULL) {
 954     mcs-&gt;clear_counters();
 955   }
 956   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
 957 
 958   CompiledMethod* code = method-&gt;code();
 959   if (code != NULL) {
 960     code-&gt;make_not_entrant();
 961   }
 962 
 963   MethodData* method_data = method-&gt;method_data();
 964   if (method_data == NULL) {
 965     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
 966     method_data = MethodData::allocate(loader_data, method, CHECK);
 967     method-&gt;set_method_data(method_data);
 968   } else {
 969     method_data-&gt;initialize();
 970   }
 971 C2V_END
 972 
 973 
 974 C2V_VMENTRY(void, invalidateInstalledCode, (JNIEnv*, jobject, jobject installed_code))
 975   Handle installed_code_handle(THREAD, JNIHandles::resolve(installed_code));
 976   nmethod::invalidate_installed_code(installed_code_handle, CHECK);
 977 C2V_END
 978 
 979 C2V_VMENTRY(jlongArray, collectCounters, (JNIEnv*, jobject))
 980   typeArrayOop arrayOop = oopFactory::new_longArray(JVMCICounterSize, CHECK_NULL);
 981   JavaThread::collect_counters(arrayOop);
 982   return (jlongArray) JNIHandles::make_local(THREAD, arrayOop);
 983 C2V_END
 984 
 985 C2V_VMENTRY(int, allocateCompileId, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci))
 986   HandleMark hm;
 987   ResourceMark rm;
 988   if (JNIHandles::resolve(jvmci_method) == NULL) {
 989     THROW_0(vmSymbols::java_lang_NullPointerException());
 990   }
 991   Method* method = CompilerToVM::asMethod(jvmci_method);
 992   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
 993     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;Unexpected bci %d&quot;, entry_bci));
 994   }
 995   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
 996 C2V_END
 997 
 998 
 999 C2V_VMENTRY(jboolean, isMature, (JNIEnv*, jobject, jlong metaspace_method_data))
1000   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1001   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1002 C2V_END
1003 
1004 C2V_VMENTRY(jboolean, hasCompiledCodeForOSR, (JNIEnv*, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1005   Method* method = CompilerToVM::asMethod(jvmci_method);
1006   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1007 C2V_END
1008 
1009 C2V_VMENTRY(jobject, getSymbol, (JNIEnv*, jobject, jlong symbol))
1010   Handle sym = java_lang_String::create_from_symbol((Symbol*)(address)symbol, CHECK_NULL);
1011   return JNIHandles::make_local(THREAD, sym());
1012 C2V_END
1013 
1014 bool matches(jobjectArray methods, Method* method) {
1015   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1016 
1017   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1018     oop resolved = methods_oop-&gt;obj_at(i);
1019     if (resolved-&gt;is_a(HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; CompilerToVM::asMethod(resolved) == method) {
1020       return true;
1021     }
1022   }
1023   return false;
1024 }
1025 
1026 void call_interface(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
1027   CallInfo callinfo;
1028   Handle receiver = args-&gt;receiver();
1029   Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
1030   LinkInfo link_info(spec_klass, name, signature);
1031   LinkResolver::resolve_interface_call(
1032           callinfo, receiver, recvrKlass, link_info, true, CHECK);
1033   methodHandle method = callinfo.selected_method();
1034   assert(method.not_null(), &quot;should have thrown exception&quot;);
1035 
1036   // Invoke the method
1037   JavaCalls::call(result, method, args, CHECK);
1038 }
1039 
1040 C2V_VMENTRY(jobject, iterateFrames, (JNIEnv*, jobject compilerToVM, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, jobject visitor_handle))
1041   ResourceMark rm;
1042 
1043   if (!thread-&gt;has_last_Java_frame()) {
1044     return NULL;
1045   }
1046   Handle visitor(THREAD, JNIHandles::resolve_non_null(visitor_handle));
1047   Handle frame_reference = HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1048   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1049 
1050   StackFrameStream fst(thread);
1051 
1052   jobjectArray methods = initial_methods;
1053 
1054   int frame_number = 0;
1055   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1056 
1057   while (true) {
1058     // look for the given method
1059     bool realloc_called = false;
1060     while (true) {
1061       StackValueCollection* locals = NULL;
1062       if (vf-&gt;is_compiled_frame()) {
1063         // compiled method frame
1064         compiledVFrame* cvf = compiledVFrame::cast(vf);
1065         if (methods == NULL || matches(methods, cvf-&gt;method())) {
1066           if (initialSkip &gt; 0) {
1067             initialSkip--;
1068           } else {
1069             ScopeDesc* scope = cvf-&gt;scope();
1070             // native wrappers do not have a scope
1071             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1072               GrowableArray&lt;ScopeValue*&gt;* objects;
1073               if (!realloc_called) {
1074                 objects = scope-&gt;objects();
1075               } else {
1076                 // some object might already have been re-allocated, only reallocate the non-allocated ones
1077                 objects = new GrowableArray&lt;ScopeValue*&gt;(scope-&gt;objects()-&gt;length());
1078                 for (int i = 0; i &lt; scope-&gt;objects()-&gt;length(); i++) {
1079                   ObjectValue* sv = (ObjectValue*) scope-&gt;objects()-&gt;at(i);
1080                   if (sv-&gt;value().is_null()) {
1081                     objects-&gt;append(sv);
1082                   }
1083                 }
1084               }
1085               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), objects, CHECK_NULL);
1086               Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);
1087               realloc_called = true;
1088 
1089               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1090               assert(local_values != NULL, &quot;NULL locals&quot;);
1091               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1092               typeArrayHandle array(THREAD, array_oop);
1093               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1094                 ScopeValue* value = local_values-&gt;at(i);
1095                 if (value-&gt;is_object()) {
1096                   array-&gt;bool_at_put(i, true);
1097                 }
1098               }
1099               HotSpotStackFrameReference::set_localIsVirtual(frame_reference, array());
1100             } else {
1101               HotSpotStackFrameReference::set_localIsVirtual(frame_reference, NULL);
1102             }
1103 
1104             locals = cvf-&gt;locals();
1105             HotSpotStackFrameReference::set_bci(frame_reference, cvf-&gt;bci());
1106             oop method = CompilerToVM::get_jvmci_method(cvf-&gt;method(), CHECK_NULL);
1107             HotSpotStackFrameReference::set_method(frame_reference, method);
1108           }
1109         }
1110       } else if (vf-&gt;is_interpreted_frame()) {
1111         // interpreted method frame
1112         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1113         if (methods == NULL || matches(methods, ivf-&gt;method())) {
1114           if (initialSkip &gt; 0) {
1115             initialSkip--;
1116           } else {
1117             locals = ivf-&gt;locals();
1118             HotSpotStackFrameReference::set_bci(frame_reference, ivf-&gt;bci());
1119             oop method = CompilerToVM::get_jvmci_method(ivf-&gt;method(), CHECK_NULL);
1120             HotSpotStackFrameReference::set_method(frame_reference, method);
1121             HotSpotStackFrameReference::set_localIsVirtual(frame_reference, NULL);
1122           }
1123         }
1124       }
1125 
1126       // locals != NULL means that we found a matching frame and result is already partially initialized
1127       if (locals != NULL) {
1128         methods = match_methods;
1129         HotSpotStackFrameReference::set_compilerToVM(frame_reference, JNIHandles::resolve(compilerToVM));
1130         HotSpotStackFrameReference::set_stackPointer(frame_reference, (jlong) fst.current()-&gt;sp());
1131         HotSpotStackFrameReference::set_frameNumber(frame_reference, frame_number);
1132 
1133         // initialize the locals array
1134         objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
1135         objArrayHandle array(THREAD, array_oop);
1136         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1137           StackValue* var = locals-&gt;at(i);
1138           if (var-&gt;type() == T_OBJECT) {
1139             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1140           }
1141         }
1142         HotSpotStackFrameReference::set_locals(frame_reference, array());
1143         HotSpotStackFrameReference::set_objectsMaterialized(frame_reference, JNI_FALSE);
1144 
1145         JavaValue result(T_OBJECT);
1146         JavaCallArguments args(visitor);
1147         args.push_oop(frame_reference);
1148         call_interface(&amp;result, SystemDictionary::InspectedFrameVisitor_klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &amp;args, CHECK_NULL);
1149         if (result.get_jobject() != NULL) {
1150           return JNIHandles::make_local(thread, (oop) result.get_jobject());
1151         }
1152         assert(initialSkip == 0, &quot;There should be no match before initialSkip == 0&quot;);
1153         if (HotSpotStackFrameReference::objectsMaterialized(frame_reference) == JNI_TRUE) {
1154           // the frame has been deoptimized, we need to re-synchronize the frame and vframe
1155           intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(frame_reference);
1156           fst = StackFrameStream(thread);
1157           while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1158             fst.next();
1159           }
1160           if (fst.current()-&gt;sp() != stack_pointer) {
1161             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found after deopt&quot;)
1162           }
1163           vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1164           if (!vf-&gt;is_compiled_frame()) {
1165             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)
1166           }
1167           for (int i = 0; i &lt; frame_number; i++) {
1168             if (vf-&gt;is_top()) {
1169               THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;vframe not found after deopt&quot;)
1170             }
1171             vf = vf-&gt;sender();
1172             assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1173           }
1174         }
1175         frame_reference = HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1176         HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1177       }
1178 
1179       if (vf-&gt;is_top()) {
1180         break;
1181       }
1182       frame_number++;
1183       vf = vf-&gt;sender();
1184     } // end of vframe loop
1185 
1186     if (fst.is_done()) {
1187       break;
1188     }
1189     fst.next();
1190     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1191     frame_number = 0;
1192   } // end of frame loop
1193 
1194   // the end was reached without finding a matching method
1195   return NULL;
1196 C2V_END
1197 
1198 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1199   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1200   CallInfo callInfo;
1201   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1202   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1203   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1204 C2V_END
1205 
1206 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1207   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1208   Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
1209   Symbol* name = cp-&gt;name_ref_at(index);
1210   if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
1211     CallInfo callInfo;
1212     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1213     ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1214     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1215   }
1216 C2V_END
1217 
1218 C2V_VMENTRY(jint, isResolvedInvokeHandleInPool, (JNIEnv*, jobject, jobject jvmci_constant_pool, jint index))
1219   constantPoolHandle cp = CompilerToVM::asConstantPool(jvmci_constant_pool);
1220   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1221   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
1222     // MethodHandle.invoke* --&gt; LambdaForm?
1223     ResourceMark rm;
1224 
1225     LinkInfo link_info(cp, index, CATCH);
1226 
1227     Klass* resolved_klass = link_info.resolved_klass();
1228 
1229     Symbol* name_sym = cp-&gt;name_ref_at(index);
1230 
1231     vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), &quot;!&quot;);
1232     vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), &quot;!&quot;);
1233 
1234     methodHandle adapter_method(cp_cache_entry-&gt;f1_as_method());
1235 
1236     methodHandle resolved_method(adapter_method);
1237 
1238     // Can we treat it as a regular invokevirtual?
1239     if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
1240       vmassert(!resolved_method-&gt;is_static(),&quot;!&quot;);
1241       vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),&quot;!&quot;);
1242       vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), &quot;!&quot;);
1243       vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, &quot;!&quot;);
1244 
1245       methodHandle m(LinkResolver::linktime_resolve_virtual_method_or_null(link_info));
1246       vmassert(m == resolved_method, &quot;!!&quot;);
1247       return -1;
1248     }
1249 
1250     return Bytecodes::_invokevirtual;
1251   }
1252   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokedynamic)) {
1253     return Bytecodes::_invokedynamic;
1254   }
1255   return -1;
1256 C2V_END
1257 
1258 
1259 C2V_VMENTRY(jobject, getSignaturePolymorphicHolders, (JNIEnv*, jobject))
1260   objArrayHandle holders = oopFactory::new_objArray_handle(SystemDictionary::String_klass(), 2, CHECK_NULL);
1261   Handle mh = java_lang_String::create_from_str(&quot;Ljava/lang/invoke/MethodHandle;&quot;, CHECK_NULL);
1262   Handle vh = java_lang_String::create_from_str(&quot;Ljava/lang/invoke/VarHandle;&quot;, CHECK_NULL);
1263   holders-&gt;obj_at_put(0, mh());
1264   holders-&gt;obj_at_put(1, vh());
1265   return JNIHandles::make_local(THREAD, holders());
1266 C2V_END
1267 
1268 C2V_VMENTRY(jboolean, shouldDebugNonSafepoints, (JNIEnv*, jobject))
1269   //see compute_recording_non_safepoints in debugInfroRec.cpp
1270   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1271     return true;
1272   }
1273   return DebugNonSafepoints;
1274 C2V_END
1275 
1276 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1277 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv*, jobject, jobject hs_frame, bool invalidate))
1278   ResourceMark rm;
1279 
1280   if (hs_frame == NULL) {
1281     THROW_MSG(vmSymbols::java_lang_NullPointerException(), &quot;stack frame is null&quot;)
1282   }
1283 
1284   HotSpotStackFrameReference::klass()-&gt;initialize(CHECK);
1285 
1286   // look for the given stack frame
1287   StackFrameStream fst(thread);
1288   intptr_t* stack_pointer = (intptr_t*) HotSpotStackFrameReference::stackPointer(hs_frame);
1289   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1290     fst.next();
1291   }
1292   if (fst.current()-&gt;sp() != stack_pointer) {
1293     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found&quot;)
1294   }
1295 
1296   if (invalidate) {
1297     if (!fst.current()-&gt;is_compiled_frame()) {
1298       THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)
1299     }
1300     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), &quot;nmethod expected&quot;);
1301     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1302   }
1303   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1304   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1305   StackFrameStream fstAfterDeopt(thread);
1306   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1307     fstAfterDeopt.next();
1308   }
1309   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1310     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found after deopt&quot;)
1311   }
1312 
1313   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1314   if (!vf-&gt;is_compiled_frame()) {
1315     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)
1316   }
1317 
1318   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1319   while (true) {
1320     assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1321     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1322     if (vf-&gt;is_top()) {
1323       break;
1324     }
1325     vf = vf-&gt;sender();
1326   }
1327 
1328   int last_frame_number = HotSpotStackFrameReference::frameNumber(hs_frame);
1329   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1330     THROW_MSG(vmSymbols::java_lang_IllegalStateException(), &quot;invalid frame number&quot;)
1331   }
1332 
1333   // Reallocate the non-escaping objects and restore their fields.
1334   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,&quot;invalid scope&quot;);
1335   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1336 
1337   if (objects == NULL) {
1338     // no objects to materialize
1339     return;
1340   }
1341 
1342   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), objects, CHECK);
1343   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1344 
1345   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1346     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1347 
1348     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1349     StackValueCollection* locals = cvf-&gt;locals();
1350     if (locals != NULL) {
1351       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1352         StackValue* var = locals-&gt;at(i2);
1353         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1354           jvalue val;
1355           val.l = (jobject) locals-&gt;at(i2)-&gt;get_obj()();
1356           cvf-&gt;update_local(T_OBJECT, i2, val);
1357         }
1358       }
1359     }
1360 
1361     GrowableArray&lt;ScopeValue*&gt;* scopeExpressions = cvf-&gt;scope()-&gt;expressions();
1362     StackValueCollection* expressions = cvf-&gt;expressions();
1363     if (expressions != NULL) {
1364       for (int i2 = 0; i2 &lt; expressions-&gt;size(); i2++) {
1365         StackValue* var = expressions-&gt;at(i2);
1366         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeExpressions-&gt;at(i2)-&gt;is_object()) {
1367           jvalue val;
1368           val.l = (jobject) expressions-&gt;at(i2)-&gt;get_obj()();
1369           cvf-&gt;update_stack(T_OBJECT, i2, val);
1370         }
1371       }
1372     }
1373 
1374     GrowableArray&lt;MonitorValue*&gt;* scopeMonitors = cvf-&gt;scope()-&gt;monitors();
1375     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
1376     if (monitors != NULL) {
1377       for (int i2 = 0; i2 &lt; monitors-&gt;length(); i2++) {
1378         cvf-&gt;update_monitor(i2, monitors-&gt;at(i2));
1379       }
1380     }
1381   }
1382 
1383   // all locals are materialized by now
1384   HotSpotStackFrameReference::set_localIsVirtual(hs_frame, NULL);
1385 
1386   // update the locals array
1387   objArrayHandle array(THREAD, HotSpotStackFrameReference::locals(hs_frame));
1388   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1389   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1390     StackValue* var = locals-&gt;at(i);
1391     if (var-&gt;type() == T_OBJECT) {
1392       array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1393     }
1394   }
1395   HotSpotStackFrameReference::set_objectsMaterialized(hs_frame, JNI_TRUE);
1396 C2V_END
1397 
1398 C2V_VMENTRY(void, writeDebugOutput, (JNIEnv*, jobject, jbyteArray bytes, jint offset, jint length))
1399   if (bytes == NULL) {
1400     THROW(vmSymbols::java_lang_NullPointerException());
1401   }
1402   typeArrayOop array = (typeArrayOop) JNIHandles::resolve(bytes);
1403 
1404   // Check if offset and length are non negative.
1405   if (offset &lt; 0 || length &lt; 0) {
1406     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1407   }
1408   // Check if the range is valid.
1409   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array-&gt;length())) {
1410     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
1411   }
1412   while (length &gt; 0) {
1413     jbyte* start = array-&gt;byte_at_addr(offset);
1414     tty-&gt;write((char*) start, MIN2(length, (jint)O_BUFLEN));
1415     length -= O_BUFLEN;
1416     offset += O_BUFLEN;
1417   }
1418 C2V_END
1419 
1420 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv*, jobject))
1421   tty-&gt;flush();
1422 C2V_END
1423 
1424 C2V_VMENTRY(int, methodDataProfileDataSize, (JNIEnv*, jobject, jlong metaspace_method_data, jint position))
1425   ResourceMark rm;
1426   MethodData* mdo = CompilerToVM::asMethodData(metaspace_method_data);
1427   ProfileData* profile_data = mdo-&gt;data_at(position);
1428   if (mdo-&gt;is_valid(profile_data)) {
1429     return profile_data-&gt;size_in_bytes();
1430   }
1431   DataLayout* data    = mdo-&gt;extra_data_base();
1432   DataLayout* end   = mdo-&gt;extra_data_limit();
1433   for (;; data = mdo-&gt;next_extra(data)) {
1434     assert(data &lt; end, &quot;moved past end of extra data&quot;);
1435     profile_data = data-&gt;data_in();
1436     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1437       return profile_data-&gt;size_in_bytes();
1438     }
1439   }
1440   THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;Invalid profile data position %d&quot;, position));
1441 C2V_END
1442 
1443 C2V_VMENTRY(jlong, getFingerprint, (JNIEnv*, jobject, jlong metaspace_klass))
1444 #if INCLUDE_AOT
1445   Klass *k = CompilerToVM::asKlass(metaspace_klass);
1446   if (k-&gt;is_instance_klass()) {
1447     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1448   } else {
1449     return 0;
1450   }
1451 #else
1452   THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;unimplemented&quot;);
1453 #endif
1454 C2V_END
1455 
1456 C2V_VMENTRY(jobject, getHostClass, (JNIEnv*, jobject, jobject jvmci_type))
1457   InstanceKlass* k = InstanceKlass::cast(CompilerToVM::asKlass(jvmci_type));
1458   InstanceKlass* host = k-&gt;unsafe_anonymous_host();
1459   JVMCIKlassHandle handle(THREAD, host);
1460   oop result = CompilerToVM::get_jvmci_type(handle, CHECK_NULL);
1461   return JNIHandles::make_local(THREAD, result);
1462 C2V_END
1463 
1464 C2V_VMENTRY(int, interpreterFrameSize, (JNIEnv*, jobject, jobject bytecode_frame_handle))
1465   if (bytecode_frame_handle == NULL) {
1466     THROW_0(vmSymbols::java_lang_NullPointerException());
1467   }
1468 
1469   oop top_bytecode_frame = JNIHandles::resolve_non_null(bytecode_frame_handle);
1470   oop bytecode_frame = top_bytecode_frame;
1471   int size = 0;
1472   int callee_parameters = 0;
1473   int callee_locals = 0;
1474   Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1475   int extra_args = method-&gt;max_stack() - BytecodeFrame::numStack(bytecode_frame);
1476 
1477   while (bytecode_frame != NULL) {
1478     int locks = BytecodeFrame::numLocks(bytecode_frame);
1479     int temps = BytecodeFrame::numStack(bytecode_frame);
1480     bool is_top_frame = (bytecode_frame == top_bytecode_frame);
1481     Method* method = getMethodFromHotSpotMethod(BytecodePosition::method(bytecode_frame));
1482 
1483     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1484                                                                  temps + callee_parameters,
1485                                                                  extra_args,
1486                                                                  locks,
1487                                                                  callee_parameters,
1488                                                                  callee_locals,
1489                                                                  is_top_frame);
1490     size += frame_size;
1491 
1492     callee_parameters = method-&gt;size_of_parameters();
1493     callee_locals = method-&gt;max_locals();
1494     extra_args = 0;
1495     bytecode_frame = BytecodePosition::caller(bytecode_frame);
1496   }
1497   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1498 C2V_END
1499 
1500 C2V_VMENTRY(void, compileToBytecode, (JNIEnv*, jobject, jobject lambda_form_handle))
1501   Handle lambda_form(THREAD, JNIHandles::resolve_non_null(lambda_form_handle));
1502   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1503     TempNewSymbol compileToBytecode = SymbolTable::new_symbol(&quot;compileToBytecode&quot;, CHECK);
1504     JavaValue result(T_VOID);
1505     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1506   } else {
1507     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1508                 err_msg(&quot;Unexpected type: %s&quot;, lambda_form-&gt;klass()-&gt;external_name()));
1509   }
1510 C2V_END
1511 
1512 C2V_VMENTRY(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))
1513   methodHandle m = CompilerToVM::asMethod(jvmci_method);
1514   oop executable;
1515   if (m-&gt;is_initializer()) {
1516     if (m-&gt;is_static_initializer()) {
1517       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1518         &quot;Cannot create java.lang.reflect.Method for class initializer&quot;);
1519     }
1520     executable = Reflection::new_constructor(m, CHECK_NULL);
1521   } else {
1522     executable = Reflection::new_method(m, false, CHECK_NULL);
1523   }
1524   return JNIHandles::make_local(thread, executable);
1525 }
1526 
1527 C2V_VMENTRY(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))
1528   Klass* klass = CompilerToVM::asKlass(jvmci_type);
1529   if (!klass-&gt;is_instance_klass()) {
1530     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1531         err_msg(&quot;Expected non-primitive type, got %s&quot;, klass-&gt;external_name()));
1532   }
1533   InstanceKlass* iklass = InstanceKlass::cast(klass);
1534   Array&lt;u2&gt;* fields = iklass-&gt;fields();
1535   if (index &lt; 0 || index &gt; fields-&gt;length()) {
1536     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1537         err_msg(&quot;Field index %d out of bounds for %s&quot;, index, klass-&gt;external_name()));
1538   }
1539   fieldDescriptor fd(iklass, index);
1540   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
1541   return JNIHandles::make_local(env, reflected);
1542 }
1543 
1544 #define CC (char*)  /*cast a literal from (const char*)*/
1545 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
1546 
1547 #define STRING                  &quot;Ljava/lang/String;&quot;
1548 #define OBJECT                  &quot;Ljava/lang/Object;&quot;
1549 #define CLASS                   &quot;Ljava/lang/Class;&quot;
1550 #define EXECUTABLE              &quot;Ljava/lang/reflect/Executable;&quot;
1551 #define STACK_TRACE_ELEMENT     &quot;Ljava/lang/StackTraceElement;&quot;
1552 #define INSTALLED_CODE          &quot;Ljdk/vm/ci/code/InstalledCode;&quot;
1553 #define TARGET_DESCRIPTION      &quot;Ljdk/vm/ci/code/TargetDescription;&quot;
1554 #define BYTECODE_FRAME          &quot;Ljdk/vm/ci/code/BytecodeFrame;&quot;
1555 #define INSPECTED_FRAME_VISITOR &quot;Ljdk/vm/ci/code/stack/InspectedFrameVisitor;&quot;
1556 #define RESOLVED_METHOD         &quot;Ljdk/vm/ci/meta/ResolvedJavaMethod;&quot;
1557 #define HS_RESOLVED_METHOD      &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;&quot;
1558 #define HS_RESOLVED_KLASS       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;&quot;
1559 #define HS_CONSTANT_POOL        &quot;Ljdk/vm/ci/hotspot/HotSpotConstantPool;&quot;
1560 #define HS_COMPILED_CODE        &quot;Ljdk/vm/ci/hotspot/HotSpotCompiledCode;&quot;
1561 #define HS_CONFIG               &quot;Ljdk/vm/ci/hotspot/HotSpotVMConfig;&quot;
1562 #define HS_METADATA             &quot;Ljdk/vm/ci/hotspot/HotSpotMetaData;&quot;
1563 #define HS_STACK_FRAME_REF      &quot;Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;&quot;
1564 #define HS_SPECULATION_LOG      &quot;Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;&quot;
1565 #define REFLECTION_EXECUTABLE   &quot;Ljava/lang/reflect/Executable;&quot;
1566 #define REFLECTION_FIELD        &quot;Ljava/lang/reflect/Field;&quot;
1567 #define METASPACE_METHOD_DATA   &quot;J&quot;
1568 
1569 JNINativeMethod CompilerToVM::methods[] = {
1570   {CC &quot;getBytecode&quot;,                                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[B&quot;,                                                      FN_PTR(getBytecode)},
1571   {CC &quot;getExceptionTableStart&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getExceptionTableStart)},
1572   {CC &quot;getExceptionTableLength&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getExceptionTableLength)},
1573   {CC &quot;findUniqueConcreteMethod&quot;,                     CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)&quot; HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
1574   {CC &quot;getImplementor&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
1575   {CC &quot;getStackTraceElement&quot;,                         CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)&quot; STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
1576   {CC &quot;methodIsIgnoredBySecurityStackWalk&quot;,           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
1577   {CC &quot;setNotInlinableOrCompilable&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(setNotInlinableOrCompilable)},
1578   {CC &quot;isCompilable&quot;,                                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(isCompilable)},
1579   {CC &quot;hasNeverInlineDirective&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(hasNeverInlineDirective)},
1580   {CC &quot;shouldInlineMethod&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(shouldInlineMethod)},
1581   {CC &quot;lookupType&quot;,                                   CC &quot;(&quot; STRING CLASS &quot;Z)&quot; HS_RESOLVED_KLASS,                                           FN_PTR(lookupType)},
1582   {CC &quot;lookupNameInPool&quot;,                             CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupNameInPool)},
1583   {CC &quot;lookupNameAndTypeRefIndexInPool&quot;,              CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
1584   {CC &quot;lookupSignatureInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupSignatureInPool)},
1585   {CC &quot;lookupKlassRefIndexInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupKlassRefIndexInPool)},
1586   {CC &quot;lookupKlassInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)Ljava/lang/Object;&quot;,                                       FN_PTR(lookupKlassInPool)},
1587   {CC &quot;lookupAppendixInPool&quot;,                         CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECT,                                                  FN_PTR(lookupAppendixInPool)},
1588   {CC &quot;lookupMethodInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;IB)&quot; HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
1589   {CC &quot;constantPoolRemapInstructionOperandFromCache&quot;, CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
1590   {CC &quot;resolveConstantInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECT,                                                  FN_PTR(resolveConstantInPool)},
1591   {CC &quot;resolvePossiblyCachedConstantInPool&quot;,          CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECT,                                                  FN_PTR(resolvePossiblyCachedConstantInPool)},
1592   {CC &quot;resolveTypeInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
1593   {CC &quot;resolveFieldInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;I&quot; HS_RESOLVED_METHOD &quot;B[I)&quot; HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
1594   {CC &quot;resolveInvokeDynamicInPool&quot;,                   CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeDynamicInPool)},
1595   {CC &quot;resolveInvokeHandleInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeHandleInPool)},
1596   {CC &quot;isResolvedInvokeHandleInPool&quot;,                 CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(isResolvedInvokeHandleInPool)},
1597   {CC &quot;resolveMethod&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
1598   {CC &quot;getSignaturePolymorphicHolders&quot;,               CC &quot;()[&quot; STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
1599   {CC &quot;getVtableIndexForInterfaceMethod&quot;,             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)I&quot;,                                     FN_PTR(getVtableIndexForInterfaceMethod)},
1600   {CC &quot;getClassInitializer&quot;,                          CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
1601   {CC &quot;hasFinalizableSubclass&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(hasFinalizableSubclass)},
1602   {CC &quot;getMaxCallTargetOffset&quot;,                       CC &quot;(J)J&quot;,                                                                            FN_PTR(getMaxCallTargetOffset)},
1603   {CC &quot;asResolvedJavaMethod&quot;,                         CC &quot;(&quot; EXECUTABLE &quot;)&quot; HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
1604   {CC &quot;getResolvedJavaMethod&quot;,                        CC &quot;(Ljava/lang/Object;J)&quot; HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
1605   {CC &quot;getConstantPool&quot;,                              CC &quot;(Ljava/lang/Object;)&quot; HS_CONSTANT_POOL,                                           FN_PTR(getConstantPool)},
1606   {CC &quot;getResolvedJavaType&quot;,                          CC &quot;(Ljava/lang/Object;JZ)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType)},
1607   {CC &quot;readConfiguration&quot;,                            CC &quot;()[&quot; OBJECT,                                                                      FN_PTR(readConfiguration)},
1608   {CC &quot;installCode&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE HS_SPECULATION_LOG &quot;)I&quot;,    FN_PTR(installCode)},
1609   {CC &quot;getMetadata&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA &quot;)I&quot;,                          FN_PTR(getMetadata)},
1610   {CC &quot;resetCompilationStatistics&quot;,                   CC &quot;()V&quot;,                                                                             FN_PTR(resetCompilationStatistics)},
1611   {CC &quot;disassembleCodeBlob&quot;,                          CC &quot;(&quot; INSTALLED_CODE &quot;)&quot; STRING,                                                     FN_PTR(disassembleCodeBlob)},
1612   {CC &quot;executeInstalledCode&quot;,                         CC &quot;([&quot; OBJECT INSTALLED_CODE &quot;)&quot; OBJECT,                                             FN_PTR(executeInstalledCode)},
1613   {CC &quot;getLineNumberTable&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[J&quot;,                                                      FN_PTR(getLineNumberTable)},
1614   {CC &quot;getLocalVariableTableStart&quot;,                   CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getLocalVariableTableStart)},
1615   {CC &quot;getLocalVariableTableLength&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getLocalVariableTableLength)},
1616   {CC &quot;reprofile&quot;,                                    CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(reprofile)},
1617   {CC &quot;invalidateInstalledCode&quot;,                      CC &quot;(&quot; INSTALLED_CODE &quot;)V&quot;,                                                           FN_PTR(invalidateInstalledCode)},
1618   {CC &quot;collectCounters&quot;,                              CC &quot;()[J&quot;,                                                                            FN_PTR(collectCounters)},
1619   {CC &quot;allocateCompileId&quot;,                            CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)I&quot;,                                                      FN_PTR(allocateCompileId)},
1620   {CC &quot;isMature&quot;,                                     CC &quot;(&quot; METASPACE_METHOD_DATA &quot;)Z&quot;,                                                    FN_PTR(isMature)},
1621   {CC &quot;hasCompiledCodeForOSR&quot;,                        CC &quot;(&quot; HS_RESOLVED_METHOD &quot;II)Z&quot;,                                                     FN_PTR(hasCompiledCodeForOSR)},
1622   {CC &quot;getSymbol&quot;,                                    CC &quot;(J)&quot; STRING,                                                                      FN_PTR(getSymbol)},
1623   {CC &quot;iterateFrames&quot;,                                CC &quot;([&quot; RESOLVED_METHOD &quot;[&quot; RESOLVED_METHOD &quot;I&quot; INSPECTED_FRAME_VISITOR &quot;)&quot; OBJECT,   FN_PTR(iterateFrames)},
1624   {CC &quot;materializeVirtualObjects&quot;,                    CC &quot;(&quot; HS_STACK_FRAME_REF &quot;Z)V&quot;,                                                      FN_PTR(materializeVirtualObjects)},
1625   {CC &quot;shouldDebugNonSafepoints&quot;,                     CC &quot;()Z&quot;,                                                                             FN_PTR(shouldDebugNonSafepoints)},
1626   {CC &quot;writeDebugOutput&quot;,                             CC &quot;([BII)V&quot;,                                                                         FN_PTR(writeDebugOutput)},
1627   {CC &quot;flushDebugOutput&quot;,                             CC &quot;()V&quot;,                                                                             FN_PTR(flushDebugOutput)},
1628   {CC &quot;methodDataProfileDataSize&quot;,                    CC &quot;(JI)I&quot;,                                                                           FN_PTR(methodDataProfileDataSize)},
1629   {CC &quot;getFingerprint&quot;,                               CC &quot;(J)J&quot;,                                                                            FN_PTR(getFingerprint)},
1630   {CC &quot;getHostClass&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
1631   {CC &quot;interpreterFrameSize&quot;,                         CC &quot;(&quot; BYTECODE_FRAME &quot;)I&quot;,                                                           FN_PTR(interpreterFrameSize)},
1632   {CC &quot;compileToBytecode&quot;,                            CC &quot;(&quot; OBJECT &quot;)V&quot;,                                                                   FN_PTR(compileToBytecode)},
1633   {CC &quot;getFlagValue&quot;,                                 CC &quot;(&quot; STRING &quot;)&quot; OBJECT,                                                             FN_PTR(getFlagValue)},
1634   {CC &quot;asReflectionExecutable&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)&quot; REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
1635   {CC &quot;asReflectionField&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;I)&quot; REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},
1636 };
1637 
1638 int CompilerToVM::methods_count() {
1639   return sizeof(methods) / sizeof(JNINativeMethod);
1640 }
    </pre>
  </body>
</html>
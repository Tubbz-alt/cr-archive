<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/handshake.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="handles.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="handshake.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/handshake.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;logging/logStream.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;

 29 #include &quot;runtime/handshake.hpp&quot;
 30 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-removed"> 31 #include &quot;runtime/orderAccess.hpp&quot;</span>
 32 #include &quot;runtime/osThread.hpp&quot;
 33 #include &quot;runtime/semaphore.inline.hpp&quot;
 34 #include &quot;runtime/task.hpp&quot;
<span class="line-removed"> 35 #include &quot;runtime/timerTrace.hpp&quot;</span>
 36 #include &quot;runtime/thread.hpp&quot;
 37 #include &quot;runtime/vmThread.hpp&quot;
 38 #include &quot;utilities/formatBuffer.hpp&quot;
 39 #include &quot;utilities/preserveException.hpp&quot;
 40 
 41 class HandshakeOperation: public StackObj {
 42 public:
 43   virtual void do_handshake(JavaThread* thread) = 0;
 44 };
 45 
 46 class HandshakeThreadsOperation: public HandshakeOperation {
 47   static Semaphore _done;
<span class="line-modified"> 48   ThreadClosure* _thread_cl;</span>
<span class="line-modified"> 49 </span>
 50 public:
<span class="line-modified"> 51   HandshakeThreadsOperation(ThreadClosure* cl) : _thread_cl(cl) {}</span>
 52   void do_handshake(JavaThread* thread);
 53   bool thread_has_completed() { return _done.trywait(); }


 54 
 55 #ifdef ASSERT
 56   void check_state() {
 57     assert(!_done.trywait(), &quot;Must be zero&quot;);
 58   }
 59 #endif
 60 };
 61 
 62 Semaphore HandshakeThreadsOperation::_done(0);
 63 
 64 class VM_Handshake: public VM_Operation {
 65   const jlong _handshake_timeout;
 66  public:
 67   bool evaluate_at_safepoint() const { return false; }
 68 
<span class="line-removed"> 69   bool evaluate_concurrently() const { return false; }</span>
<span class="line-removed"> 70 </span>
 71  protected:
 72   HandshakeThreadsOperation* const _op;
 73 
 74   VM_Handshake(HandshakeThreadsOperation* op) :
 75       _handshake_timeout(TimeHelper::millis_to_counter(HandshakeTimeout)), _op(op) {}
 76 
 77   void set_handshake(JavaThread* target) {
 78     target-&gt;set_handshake_operation(_op);
 79   }
 80 
 81   // This method returns true for threads completed their operation
 82   // and true for threads canceled their operation.
 83   // A cancellation can happen if the thread is exiting.
 84   bool poll_for_completed_thread() { return _op-&gt;thread_has_completed(); }
 85 
 86   bool handshake_has_timed_out(jlong start_time);
 87   static void handle_timeout();
 88 };
 89 
 90 bool VM_Handshake::handshake_has_timed_out(jlong start_time) {
 91   // Check if handshake operation has timed out
 92   if (_handshake_timeout &gt; 0) {
 93     return os::elapsed_counter() &gt;= (start_time + _handshake_timeout);
 94   }
 95   return false;
 96 }
 97 
 98 void VM_Handshake::handle_timeout() {
 99   LogStreamHandle(Warning, handshake) log_stream;
100   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {
101     if (thr-&gt;has_handshake()) {
102       log_stream.print(&quot;Thread &quot; PTR_FORMAT &quot; has not cleared its handshake op&quot;, p2i(thr));
103       thr-&gt;print_thread_state_on(&amp;log_stream);
104     }
105   }
106   log_stream.flush();
107   fatal(&quot;Handshake operation timed out&quot;);
108 }
109 












110 class VM_HandshakeOneThread: public VM_Handshake {
111   JavaThread* _target;
<span class="line-removed">112   bool _thread_alive;</span>
113  public:
114   VM_HandshakeOneThread(HandshakeThreadsOperation* op, JavaThread* target) :
<span class="line-modified">115     VM_Handshake(op), _target(target), _thread_alive(false) {}</span>
116 
117   void doit() {
118     DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-modified">119     TraceTime timer(&quot;Performing single-target operation (vmoperation doit)&quot;, TRACETIME_LOG(Info, handshake));</span>




120 
121     ThreadsListHandle tlh;
122     if (tlh.includes(_target)) {
123       set_handshake(_target);
<span class="line-removed">124       _thread_alive = true;</span>
125     } else {

126       return;
127     }
128 
<span class="line-modified">129     log_trace(handshake)(&quot;Thread signaled, begin processing by VMThtread&quot;);</span>
<span class="line-modified">130     jlong start_time = os::elapsed_counter();</span>

131     do {
<span class="line-modified">132       if (handshake_has_timed_out(start_time)) {</span>
133         handle_timeout();
134       }
<span class="line-modified">135 </span>
<span class="line-removed">136       // We need to re-think this with SMR ThreadsList.</span>
<span class="line-removed">137       // There is an assumption in the code that the Threads_lock should be</span>
<span class="line-removed">138       // locked during certain phases.</span>
<span class="line-removed">139       {</span>
<span class="line-removed">140         MutexLockerEx ml(Threads_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">141         _target-&gt;handshake_process_by_vmthread();</span>
<span class="line-removed">142       }</span>
143     } while (!poll_for_completed_thread());
144     DEBUG_ONLY(_op-&gt;check_state();)

145   }
146 
147   VMOp_Type type() const { return VMOp_HandshakeOneThread; }
148 
<span class="line-modified">149   bool thread_alive() const { return _thread_alive; }</span>
150 };
151 
152 class VM_HandshakeAllThreads: public VM_Handshake {
153  public:
154   VM_HandshakeAllThreads(HandshakeThreadsOperation* op) : VM_Handshake(op) {}
155 
156   void doit() {
157     DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-modified">158     TraceTime timer(&quot;Performing operation (vmoperation doit)&quot;, TRACETIME_LOG(Info, handshake));</span>





159 
160     JavaThreadIteratorWithHandle jtiwh;
161     int number_of_threads_issued = 0;
162     for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
163       set_handshake(thr);
164       number_of_threads_issued++;
165     }
166 
167     if (number_of_threads_issued &lt; 1) {
<span class="line-modified">168       log_debug(handshake)(&quot;No threads to handshake.&quot;);</span>
169       return;
170     }
171 
<span class="line-modified">172     log_debug(handshake)(&quot;Threads signaled, begin processing blocked threads by VMThtread&quot;);</span>
173     const jlong start_time = os::elapsed_counter();
174     int number_of_threads_completed = 0;
175     do {
176       // Check if handshake operation has timed out
177       if (handshake_has_timed_out(start_time)) {
178         handle_timeout();
179       }
180 
181       // Have VM thread perform the handshake operation for blocked threads.
182       // Observing a blocked state may of course be transient but the processing is guarded
183       // by semaphores and we optimistically begin by working on the blocked threads
<span class="line-modified">184       {</span>
<span class="line-modified">185           // We need to re-think this with SMR ThreadsList.</span>
<span class="line-modified">186           // There is an assumption in the code that the Threads_lock should</span>
<span class="line-modified">187           // be locked during certain phases.</span>
<span class="line-modified">188           jtiwh.rewind();</span>
<span class="line-modified">189           MutexLockerEx ml(Threads_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">190           for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {</span>
<span class="line-removed">191             // A new thread on the ThreadsList will not have an operation,</span>
<span class="line-removed">192             // hence it is skipped in handshake_process_by_vmthread.</span>
<span class="line-removed">193             thr-&gt;handshake_process_by_vmthread();</span>
<span class="line-removed">194           }</span>
195       }
<span class="line-removed">196 </span>
197       while (poll_for_completed_thread()) {
198         // Includes canceled operations by exiting threads.
199         number_of_threads_completed++;
200       }
201 
202     } while (number_of_threads_issued &gt; number_of_threads_completed);
203     assert(number_of_threads_issued == number_of_threads_completed, &quot;Must be the same&quot;);
204     DEBUG_ONLY(_op-&gt;check_state();)


205   }
206 
207   VMOp_Type type() const { return VMOp_HandshakeAllThreads; }
208 };
209 
210 class VM_HandshakeFallbackOperation : public VM_Operation {
<span class="line-modified">211   ThreadClosure* _thread_cl;</span>
212   Thread* _target_thread;
213   bool _all_threads;
<span class="line-modified">214   bool _thread_alive;</span>
215 public:
<span class="line-modified">216   VM_HandshakeFallbackOperation(ThreadClosure* cl) :</span>
<span class="line-modified">217       _thread_cl(cl), _target_thread(NULL), _all_threads(true), _thread_alive(true) {}</span>
<span class="line-modified">218   VM_HandshakeFallbackOperation(ThreadClosure* cl, Thread* target) :</span>
<span class="line-modified">219       _thread_cl(cl), _target_thread(target), _all_threads(false), _thread_alive(false) {}</span>
220 
221   void doit() {

222     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
223       if (_all_threads || t == _target_thread) {
224         if (t == _target_thread) {
<span class="line-modified">225           _thread_alive = true;</span>
226         }
<span class="line-modified">227         _thread_cl-&gt;do_thread(t);</span>
228       }
229     }
230   }
231 
232   VMOp_Type type() const { return VMOp_HandshakeFallback; }
<span class="line-modified">233   bool thread_alive() const { return _thread_alive; }</span>
234 };
235 
236 void HandshakeThreadsOperation::do_handshake(JavaThread* thread) {
<span class="line-modified">237   ResourceMark rm;</span>
<span class="line-modified">238   FormatBufferResource message(&quot;Operation for thread &quot; PTR_FORMAT &quot;, is_vm_thread: %s&quot;,</span>
<span class="line-modified">239                                p2i(thread), BOOL_TO_STR(Thread::current()-&gt;is_VM_thread()));</span>
<span class="line-modified">240   TraceTime timer(message, TRACETIME_LOG(Debug, handshake, task));</span>
241 
242   // Only actually execute the operation for non terminated threads.
243   if (!thread-&gt;is_terminated()) {
<span class="line-modified">244     _thread_cl-&gt;do_thread(thread);</span>







245   }
246 
247   // Use the semaphore to inform the VM thread that we have completed the operation
248   _done.signal();


249 }
250 
<span class="line-modified">251 void Handshake::execute(ThreadClosure* thread_cl) {</span>
<span class="line-modified">252   if (ThreadLocalHandshakes) {</span>
253     HandshakeThreadsOperation cto(thread_cl);
254     VM_HandshakeAllThreads handshake(&amp;cto);
255     VMThread::execute(&amp;handshake);
256   } else {
257     VM_HandshakeFallbackOperation op(thread_cl);
258     VMThread::execute(&amp;op);
259   }
260 }
261 
<span class="line-modified">262 bool Handshake::execute(ThreadClosure* thread_cl, JavaThread* target) {</span>
<span class="line-modified">263   if (ThreadLocalHandshakes) {</span>
264     HandshakeThreadsOperation cto(thread_cl);
265     VM_HandshakeOneThread handshake(&amp;cto, target);
266     VMThread::execute(&amp;handshake);
<span class="line-modified">267     return handshake.thread_alive();</span>
268   } else {
269     VM_HandshakeFallbackOperation op(thread_cl, target);
270     VMThread::execute(&amp;op);
<span class="line-modified">271     return op.thread_alive();</span>
272   }
273 }
274 
<span class="line-modified">275 HandshakeState::HandshakeState() : _operation(NULL), _semaphore(1), _thread_in_process_handshake(false) {}</span>


276 
277 void HandshakeState::set_operation(JavaThread* target, HandshakeOperation* op) {
278   _operation = op;
279   SafepointMechanism::arm_local_poll_release(target);
280 }
281 
282 void HandshakeState::clear_handshake(JavaThread* target) {
283   _operation = NULL;
<span class="line-modified">284   SafepointMechanism::disarm_local_poll_release(target);</span>
285 }
286 
287 void HandshakeState::process_self_inner(JavaThread* thread) {
288   assert(Thread::current() == thread, &quot;should call from thread&quot;);
289   assert(!thread-&gt;is_terminated(), &quot;should not be a terminated thread&quot;);


290 
<span class="line-modified">291   ThreadInVMForHandshake tivm(thread);</span>
<span class="line-modified">292   if (!_semaphore.trywait()) {</span>
<span class="line-modified">293     _semaphore.wait_with_safepoint_check(thread);</span>
<span class="line-modified">294   }</span>
<span class="line-modified">295   HandshakeOperation* op = OrderAccess::load_acquire(&amp;_operation);</span>
<span class="line-modified">296   if (op != NULL) {</span>
<span class="line-modified">297     HandleMark hm(thread);</span>
<span class="line-modified">298     CautiouslyPreserveExceptionMark pem(thread);</span>
<span class="line-modified">299     // Disarm before execute the operation</span>
<span class="line-modified">300     clear_handshake(thread);</span>
<span class="line-modified">301     op-&gt;do_handshake(thread);</span>
<span class="line-modified">302   }</span>
<span class="line-modified">303   _semaphore.signal();</span>


304 }
305 
306 bool HandshakeState::vmthread_can_process_handshake(JavaThread* target) {
307   // handshake_safe may only be called with polls armed.
308   // VM thread controls this by first claiming the handshake via claim_handshake_for_vmthread.
309   return SafepointSynchronize::handshake_safe(target);
310 }
311 
312 static bool possibly_vmthread_can_process_handshake(JavaThread* target) {
<span class="line-removed">313   // An externally suspended thread cannot be resumed while the</span>
<span class="line-removed">314   // Threads_lock is held so it is safe.</span>
315   // Note that this method is allowed to produce false positives.
<span class="line-removed">316   assert(Threads_lock-&gt;owned_by_self(), &quot;Not holding Threads_lock.&quot;);</span>
317   if (target-&gt;is_ext_suspended()) {
318     return true;
319   }
320   if (target-&gt;is_terminated()) {
321     return true;
322   }
323   switch (target-&gt;thread_state()) {
324   case _thread_in_native:
325     // native threads are safe if they have no java stack or have walkable stack
326     return !target-&gt;has_last_Java_frame() || target-&gt;frame_anchor()-&gt;walkable();
327 
328   case _thread_blocked:
329     return true;
330 
331   default:
332     return false;
333   }
334 }
335 
336 bool HandshakeState::claim_handshake_for_vmthread() {
337   if (!_semaphore.trywait()) {
338     return false;
339   }
340   if (has_operation()) {
341     return true;
342   }
343   _semaphore.signal();
344   return false;
345 }
346 
<span class="line-modified">347 void HandshakeState::process_by_vmthread(JavaThread* target) {</span>
348   assert(Thread::current()-&gt;is_VM_thread(), &quot;should call from vm thread&quot;);
<span class="line-removed">349   // Threads_lock must be held here, but that is assert()ed in</span>
<span class="line-removed">350   // possibly_vmthread_can_process_handshake().</span>
351 
352   if (!has_operation()) {
353     // JT has already cleared its handshake
<span class="line-modified">354     return;</span>
355   }
356 
357   if (!possibly_vmthread_can_process_handshake(target)) {
358     // JT is observed in an unsafe state, it must notice the handshake itself
<span class="line-modified">359     return;</span>
360   }
361 
362   // Claim the semaphore if there still an operation to be executed.
363   if (!claim_handshake_for_vmthread()) {
<span class="line-modified">364     return;</span>
365   }
366 
367   // If we own the semaphore at this point and while owning the semaphore
368   // can observe a safe state the thread cannot possibly continue without
369   // getting caught by the semaphore.

370   if (vmthread_can_process_handshake(target)) {
371     guarantee(!_semaphore.trywait(), &quot;we should already own the semaphore&quot;);


372     _operation-&gt;do_handshake(target);

373     // Disarm after VM thread have executed the operation.
374     clear_handshake(target);
<span class="line-modified">375     // Release the thread</span>
376   }
377 

378   _semaphore.signal();


379 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;logging/logStream.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 29 #include &quot;runtime/atomic.hpp&quot;</span>
 30 #include &quot;runtime/handshake.hpp&quot;
 31 #include &quot;runtime/interfaceSupport.inline.hpp&quot;

 32 #include &quot;runtime/osThread.hpp&quot;
 33 #include &quot;runtime/semaphore.inline.hpp&quot;
 34 #include &quot;runtime/task.hpp&quot;

 35 #include &quot;runtime/thread.hpp&quot;
 36 #include &quot;runtime/vmThread.hpp&quot;
 37 #include &quot;utilities/formatBuffer.hpp&quot;
 38 #include &quot;utilities/preserveException.hpp&quot;
 39 
 40 class HandshakeOperation: public StackObj {
 41 public:
 42   virtual void do_handshake(JavaThread* thread) = 0;
 43 };
 44 
 45 class HandshakeThreadsOperation: public HandshakeOperation {
 46   static Semaphore _done;
<span class="line-modified"> 47   HandshakeClosure* _handshake_cl;</span>
<span class="line-modified"> 48   bool _executed;</span>
 49 public:
<span class="line-modified"> 50   HandshakeThreadsOperation(HandshakeClosure* cl) : _handshake_cl(cl), _executed(false) {}</span>
 51   void do_handshake(JavaThread* thread);
 52   bool thread_has_completed() { return _done.trywait(); }
<span class="line-added"> 53   bool executed() const { return _executed; }</span>
<span class="line-added"> 54   const char* name() { return _handshake_cl-&gt;name(); }</span>
 55 
 56 #ifdef ASSERT
 57   void check_state() {
 58     assert(!_done.trywait(), &quot;Must be zero&quot;);
 59   }
 60 #endif
 61 };
 62 
 63 Semaphore HandshakeThreadsOperation::_done(0);
 64 
 65 class VM_Handshake: public VM_Operation {
 66   const jlong _handshake_timeout;
 67  public:
 68   bool evaluate_at_safepoint() const { return false; }
 69 


 70  protected:
 71   HandshakeThreadsOperation* const _op;
 72 
 73   VM_Handshake(HandshakeThreadsOperation* op) :
 74       _handshake_timeout(TimeHelper::millis_to_counter(HandshakeTimeout)), _op(op) {}
 75 
 76   void set_handshake(JavaThread* target) {
 77     target-&gt;set_handshake_operation(_op);
 78   }
 79 
 80   // This method returns true for threads completed their operation
 81   // and true for threads canceled their operation.
 82   // A cancellation can happen if the thread is exiting.
 83   bool poll_for_completed_thread() { return _op-&gt;thread_has_completed(); }
 84 
 85   bool handshake_has_timed_out(jlong start_time);
 86   static void handle_timeout();
 87 };
 88 
 89 bool VM_Handshake::handshake_has_timed_out(jlong start_time) {
 90   // Check if handshake operation has timed out
 91   if (_handshake_timeout &gt; 0) {
 92     return os::elapsed_counter() &gt;= (start_time + _handshake_timeout);
 93   }
 94   return false;
 95 }
 96 
 97 void VM_Handshake::handle_timeout() {
 98   LogStreamHandle(Warning, handshake) log_stream;
 99   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {
100     if (thr-&gt;has_handshake()) {
101       log_stream.print(&quot;Thread &quot; PTR_FORMAT &quot; has not cleared its handshake op&quot;, p2i(thr));
102       thr-&gt;print_thread_state_on(&amp;log_stream);
103     }
104   }
105   log_stream.flush();
106   fatal(&quot;Handshake operation timed out&quot;);
107 }
108 
<span class="line-added">109 static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int vmt_executed, const char* extra = NULL) {</span>
<span class="line-added">110   if (start_time_ns != 0) {</span>
<span class="line-added">111     jlong completion_time = os::javaTimeNanos() - start_time_ns;</span>
<span class="line-added">112     log_info(handshake)(&quot;Handshake \&quot;%s\&quot;, Targeted threads: %d, Executed by targeted threads: %d, Total completion time: &quot; JLONG_FORMAT &quot; ns%s%s&quot;,</span>
<span class="line-added">113                         name, targets,</span>
<span class="line-added">114                         targets - vmt_executed,</span>
<span class="line-added">115                         completion_time,</span>
<span class="line-added">116                         extra != NULL ? &quot;, &quot; : &quot;&quot;,</span>
<span class="line-added">117                         extra != NULL ? extra : &quot;&quot;);</span>
<span class="line-added">118   }</span>
<span class="line-added">119 }</span>
<span class="line-added">120 </span>
121 class VM_HandshakeOneThread: public VM_Handshake {
122   JavaThread* _target;

123  public:
124   VM_HandshakeOneThread(HandshakeThreadsOperation* op, JavaThread* target) :
<span class="line-modified">125     VM_Handshake(op), _target(target) {}</span>
126 
127   void doit() {
128     DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-modified">129 </span>
<span class="line-added">130     jlong start_time_ns = 0;</span>
<span class="line-added">131     if (log_is_enabled(Info, handshake)) {</span>
<span class="line-added">132       start_time_ns = os::javaTimeNanos();</span>
<span class="line-added">133     }</span>
134 
135     ThreadsListHandle tlh;
136     if (tlh.includes(_target)) {
137       set_handshake(_target);

138     } else {
<span class="line-added">139       log_handshake_info(start_time_ns, _op-&gt;name(), 0, 0, &quot;(thread dead)&quot;);</span>
140       return;
141     }
142 
<span class="line-modified">143     log_trace(handshake)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; signaled, begin attempt to process by VMThtread&quot;, p2i(_target));</span>
<span class="line-modified">144     jlong timeout_start_time = os::elapsed_counter();</span>
<span class="line-added">145     bool by_vm_thread = false;</span>
146     do {
<span class="line-modified">147       if (handshake_has_timed_out(timeout_start_time)) {</span>
148         handle_timeout();
149       }
<span class="line-modified">150       by_vm_thread = _target-&gt;handshake_try_process_by_vmThread();</span>







151     } while (!poll_for_completed_thread());
152     DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-added">153     log_handshake_info(start_time_ns, _op-&gt;name(), 1, by_vm_thread ? 1 : 0);</span>
154   }
155 
156   VMOp_Type type() const { return VMOp_HandshakeOneThread; }
157 
<span class="line-modified">158   bool executed() const { return _op-&gt;executed(); }</span>
159 };
160 
161 class VM_HandshakeAllThreads: public VM_Handshake {
162  public:
163   VM_HandshakeAllThreads(HandshakeThreadsOperation* op) : VM_Handshake(op) {}
164 
165   void doit() {
166     DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-modified">167 </span>
<span class="line-added">168     jlong start_time_ns = 0;</span>
<span class="line-added">169     if (log_is_enabled(Info, handshake)) {</span>
<span class="line-added">170       start_time_ns = os::javaTimeNanos();</span>
<span class="line-added">171     }</span>
<span class="line-added">172     int handshake_executed_by_vm_thread = 0;</span>
173 
174     JavaThreadIteratorWithHandle jtiwh;
175     int number_of_threads_issued = 0;
176     for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
177       set_handshake(thr);
178       number_of_threads_issued++;
179     }
180 
181     if (number_of_threads_issued &lt; 1) {
<span class="line-modified">182       log_handshake_info(start_time_ns, _op-&gt;name(), 0, 0);</span>
183       return;
184     }
185 
<span class="line-modified">186     log_trace(handshake)(&quot;Threads signaled, begin processing blocked threads by VMThread&quot;);</span>
187     const jlong start_time = os::elapsed_counter();
188     int number_of_threads_completed = 0;
189     do {
190       // Check if handshake operation has timed out
191       if (handshake_has_timed_out(start_time)) {
192         handle_timeout();
193       }
194 
195       // Have VM thread perform the handshake operation for blocked threads.
196       // Observing a blocked state may of course be transient but the processing is guarded
197       // by semaphores and we optimistically begin by working on the blocked threads
<span class="line-modified">198       jtiwh.rewind();</span>
<span class="line-modified">199       for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {</span>
<span class="line-modified">200         // A new thread on the ThreadsList will not have an operation,</span>
<span class="line-modified">201         // hence it is skipped in handshake_process_by_vmthread.</span>
<span class="line-modified">202         if (thr-&gt;handshake_try_process_by_vmThread()) {</span>
<span class="line-modified">203           handshake_executed_by_vm_thread++;</span>
<span class="line-modified">204         }</span>




205       }

206       while (poll_for_completed_thread()) {
207         // Includes canceled operations by exiting threads.
208         number_of_threads_completed++;
209       }
210 
211     } while (number_of_threads_issued &gt; number_of_threads_completed);
212     assert(number_of_threads_issued == number_of_threads_completed, &quot;Must be the same&quot;);
213     DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-added">214 </span>
<span class="line-added">215     log_handshake_info(start_time_ns, _op-&gt;name(), number_of_threads_issued, handshake_executed_by_vm_thread);</span>
216   }
217 
218   VMOp_Type type() const { return VMOp_HandshakeAllThreads; }
219 };
220 
221 class VM_HandshakeFallbackOperation : public VM_Operation {
<span class="line-modified">222   HandshakeClosure* _handshake_cl;</span>
223   Thread* _target_thread;
224   bool _all_threads;
<span class="line-modified">225   bool _executed;</span>
226 public:
<span class="line-modified">227   VM_HandshakeFallbackOperation(HandshakeClosure* cl) :</span>
<span class="line-modified">228       _handshake_cl(cl), _target_thread(NULL), _all_threads(true), _executed(false) {}</span>
<span class="line-modified">229   VM_HandshakeFallbackOperation(HandshakeClosure* cl, Thread* target) :</span>
<span class="line-modified">230       _handshake_cl(cl), _target_thread(target), _all_threads(false), _executed(false) {}</span>
231 
232   void doit() {
<span class="line-added">233     log_trace(handshake)(&quot;VMThread executing VM_HandshakeFallbackOperation, operation: %s&quot;, name());</span>
234     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
235       if (_all_threads || t == _target_thread) {
236         if (t == _target_thread) {
<span class="line-modified">237           _executed = true;</span>
238         }
<span class="line-modified">239         _handshake_cl-&gt;do_thread(t);</span>
240       }
241     }
242   }
243 
244   VMOp_Type type() const { return VMOp_HandshakeFallback; }
<span class="line-modified">245   bool executed() const { return _executed; }</span>
246 };
247 
248 void HandshakeThreadsOperation::do_handshake(JavaThread* thread) {
<span class="line-modified">249   jlong start_time_ns = 0;</span>
<span class="line-modified">250   if (log_is_enabled(Debug, handshake, task)) {</span>
<span class="line-modified">251     start_time_ns = os::javaTimeNanos();</span>
<span class="line-modified">252   }</span>
253 
254   // Only actually execute the operation for non terminated threads.
255   if (!thread-&gt;is_terminated()) {
<span class="line-modified">256     _handshake_cl-&gt;do_thread(thread);</span>
<span class="line-added">257     _executed = true;</span>
<span class="line-added">258   }</span>
<span class="line-added">259 </span>
<span class="line-added">260   if (start_time_ns != 0) {</span>
<span class="line-added">261     jlong completion_time = os::javaTimeNanos() - start_time_ns;</span>
<span class="line-added">262     log_debug(handshake, task)(&quot;Operation: %s for thread &quot; PTR_FORMAT &quot;, is_vm_thread: %s, completed in &quot; JLONG_FORMAT &quot; ns&quot;,</span>
<span class="line-added">263                                name(), p2i(thread), BOOL_TO_STR(Thread::current()-&gt;is_VM_thread()), completion_time);</span>
264   }
265 
266   // Use the semaphore to inform the VM thread that we have completed the operation
267   _done.signal();
<span class="line-added">268 </span>
<span class="line-added">269   // It is no longer safe to refer to &#39;this&#39; as the VMThread may have destroyed this operation</span>
270 }
271 
<span class="line-modified">272 void Handshake::execute(HandshakeClosure* thread_cl) {</span>
<span class="line-modified">273   if (SafepointMechanism::uses_thread_local_poll()) {</span>
274     HandshakeThreadsOperation cto(thread_cl);
275     VM_HandshakeAllThreads handshake(&amp;cto);
276     VMThread::execute(&amp;handshake);
277   } else {
278     VM_HandshakeFallbackOperation op(thread_cl);
279     VMThread::execute(&amp;op);
280   }
281 }
282 
<span class="line-modified">283 bool Handshake::execute(HandshakeClosure* thread_cl, JavaThread* target) {</span>
<span class="line-modified">284   if (SafepointMechanism::uses_thread_local_poll()) {</span>
285     HandshakeThreadsOperation cto(thread_cl);
286     VM_HandshakeOneThread handshake(&amp;cto, target);
287     VMThread::execute(&amp;handshake);
<span class="line-modified">288     return handshake.executed();</span>
289   } else {
290     VM_HandshakeFallbackOperation op(thread_cl, target);
291     VMThread::execute(&amp;op);
<span class="line-modified">292     return op.executed();</span>
293   }
294 }
295 
<span class="line-modified">296 HandshakeState::HandshakeState() : _operation(NULL), _semaphore(1), _thread_in_process_handshake(false) {</span>
<span class="line-added">297   DEBUG_ONLY(_vmthread_processing_handshake = false;)</span>
<span class="line-added">298 }</span>
299 
300 void HandshakeState::set_operation(JavaThread* target, HandshakeOperation* op) {
301   _operation = op;
302   SafepointMechanism::arm_local_poll_release(target);
303 }
304 
305 void HandshakeState::clear_handshake(JavaThread* target) {
306   _operation = NULL;
<span class="line-modified">307   SafepointMechanism::disarm_if_needed(target, true /* release */);</span>
308 }
309 
310 void HandshakeState::process_self_inner(JavaThread* thread) {
311   assert(Thread::current() == thread, &quot;should call from thread&quot;);
312   assert(!thread-&gt;is_terminated(), &quot;should not be a terminated thread&quot;);
<span class="line-added">313   assert(thread-&gt;thread_state() != _thread_blocked, &quot;should not be in a blocked state&quot;);</span>
<span class="line-added">314   assert(thread-&gt;thread_state() != _thread_in_native, &quot;should not be in native&quot;);</span>
315 
<span class="line-modified">316   do {</span>
<span class="line-modified">317     ThreadInVMForHandshake tivm(thread);</span>
<span class="line-modified">318     if (!_semaphore.trywait()) {</span>
<span class="line-modified">319       _semaphore.wait_with_safepoint_check(thread);</span>
<span class="line-modified">320     }</span>
<span class="line-modified">321     HandshakeOperation* op = Atomic::load_acquire(&amp;_operation);</span>
<span class="line-modified">322     if (op != NULL) {</span>
<span class="line-modified">323       HandleMark hm(thread);</span>
<span class="line-modified">324       CautiouslyPreserveExceptionMark pem(thread);</span>
<span class="line-modified">325       // Disarm before execute the operation</span>
<span class="line-modified">326       clear_handshake(thread);</span>
<span class="line-modified">327       op-&gt;do_handshake(thread);</span>
<span class="line-modified">328     }</span>
<span class="line-added">329     _semaphore.signal();</span>
<span class="line-added">330   } while (has_operation());</span>
331 }
332 
333 bool HandshakeState::vmthread_can_process_handshake(JavaThread* target) {
334   // handshake_safe may only be called with polls armed.
335   // VM thread controls this by first claiming the handshake via claim_handshake_for_vmthread.
336   return SafepointSynchronize::handshake_safe(target);
337 }
338 
339 static bool possibly_vmthread_can_process_handshake(JavaThread* target) {


340   // Note that this method is allowed to produce false positives.

341   if (target-&gt;is_ext_suspended()) {
342     return true;
343   }
344   if (target-&gt;is_terminated()) {
345     return true;
346   }
347   switch (target-&gt;thread_state()) {
348   case _thread_in_native:
349     // native threads are safe if they have no java stack or have walkable stack
350     return !target-&gt;has_last_Java_frame() || target-&gt;frame_anchor()-&gt;walkable();
351 
352   case _thread_blocked:
353     return true;
354 
355   default:
356     return false;
357   }
358 }
359 
360 bool HandshakeState::claim_handshake_for_vmthread() {
361   if (!_semaphore.trywait()) {
362     return false;
363   }
364   if (has_operation()) {
365     return true;
366   }
367   _semaphore.signal();
368   return false;
369 }
370 
<span class="line-modified">371 bool HandshakeState::try_process_by_vmThread(JavaThread* target) {</span>
372   assert(Thread::current()-&gt;is_VM_thread(), &quot;should call from vm thread&quot;);


373 
374   if (!has_operation()) {
375     // JT has already cleared its handshake
<span class="line-modified">376     return false;</span>
377   }
378 
379   if (!possibly_vmthread_can_process_handshake(target)) {
380     // JT is observed in an unsafe state, it must notice the handshake itself
<span class="line-modified">381     return false;</span>
382   }
383 
384   // Claim the semaphore if there still an operation to be executed.
385   if (!claim_handshake_for_vmthread()) {
<span class="line-modified">386     return false;</span>
387   }
388 
389   // If we own the semaphore at this point and while owning the semaphore
390   // can observe a safe state the thread cannot possibly continue without
391   // getting caught by the semaphore.
<span class="line-added">392   bool executed = false;</span>
393   if (vmthread_can_process_handshake(target)) {
394     guarantee(!_semaphore.trywait(), &quot;we should already own the semaphore&quot;);
<span class="line-added">395     log_trace(handshake)(&quot;Processing handshake by VMThtread&quot;);</span>
<span class="line-added">396     DEBUG_ONLY(_vmthread_processing_handshake = true;)</span>
397     _operation-&gt;do_handshake(target);
<span class="line-added">398     DEBUG_ONLY(_vmthread_processing_handshake = false;)</span>
399     // Disarm after VM thread have executed the operation.
400     clear_handshake(target);
<span class="line-modified">401     executed = true;</span>
402   }
403 
<span class="line-added">404   // Release the thread</span>
405   _semaphore.signal();
<span class="line-added">406 </span>
<span class="line-added">407   return executed;</span>
408 }
</pre>
</td>
</tr>
</table>
<center><a href="handles.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="handshake.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
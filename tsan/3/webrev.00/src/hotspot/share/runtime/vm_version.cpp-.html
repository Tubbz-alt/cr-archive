<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/vm_version.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;logging/logStream.hpp&quot;
 28 #include &quot;memory/universe.hpp&quot;
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;runtime/arguments.hpp&quot;
 31 #include &quot;runtime/vm_version.hpp&quot;
 32 
 33 const char* Abstract_VM_Version::_s_vm_release = Abstract_VM_Version::vm_release();
 34 const char* Abstract_VM_Version::_s_internal_vm_info_string = Abstract_VM_Version::internal_vm_info_string();
 35 
 36 uint64_t Abstract_VM_Version::_features = 0;
 37 const char* Abstract_VM_Version::_features_string = &quot;&quot;;
 38 
 39 bool Abstract_VM_Version::_supports_cx8 = false;
 40 bool Abstract_VM_Version::_supports_atomic_getset4 = false;
 41 bool Abstract_VM_Version::_supports_atomic_getset8 = false;
 42 bool Abstract_VM_Version::_supports_atomic_getadd4 = false;
 43 bool Abstract_VM_Version::_supports_atomic_getadd8 = false;
 44 unsigned int Abstract_VM_Version::_logical_processors_per_package = 1U;
 45 unsigned int Abstract_VM_Version::_L1_data_cache_line_size = 0;
 46 
 47 #ifndef HOTSPOT_VERSION_STRING
 48   #error HOTSPOT_VERSION_STRING must be defined
 49 #endif
 50 
 51 #ifndef VERSION_FEATURE
 52   #error VERSION_FEATURE must be defined
 53 #endif
 54 #ifndef VERSION_INTERIM
 55   #error VERSION_INTERIM must be defined
 56 #endif
 57 #ifndef VERSION_UPDATE
 58   #error VERSION_UPDATE must be defined
 59 #endif
 60 #ifndef VERSION_PATCH
 61   #error VERSION_PATCH must be defined
 62 #endif
 63 #ifndef VERSION_BUILD
 64   #error VERSION_BUILD must be defined
 65 #endif
 66 
 67 #ifndef VERSION_STRING
 68   #error VERSION_STRING must be defined
 69 #endif
 70 
 71 #ifndef DEBUG_LEVEL
 72   #error DEBUG_LEVEL must be defined
 73 #endif
 74 
 75 #define VM_RELEASE HOTSPOT_VERSION_STRING
 76 
 77 // HOTSPOT_VERSION_STRING equals the JDK VERSION_STRING (unless overridden
 78 // in a standalone build).
 79 int Abstract_VM_Version::_vm_major_version = VERSION_FEATURE;
 80 int Abstract_VM_Version::_vm_minor_version = VERSION_INTERIM;
 81 int Abstract_VM_Version::_vm_security_version = VERSION_UPDATE;
 82 int Abstract_VM_Version::_vm_patch_version = VERSION_PATCH;
 83 int Abstract_VM_Version::_vm_build_number = VERSION_BUILD;
 84 
 85 #if defined(_LP64)
 86   #define VMLP &quot;64-Bit &quot;
 87 #else
 88   #define VMLP &quot;&quot;
 89 #endif
 90 
 91 #ifndef VMTYPE
 92   #ifdef TIERED
 93     #define VMTYPE &quot;Server&quot;
 94   #else // TIERED
 95   #ifdef ZERO
 96     #define VMTYPE &quot;Zero&quot;
 97   #else // ZERO
 98      #define VMTYPE COMPILER1_PRESENT(&quot;Client&quot;)   \
 99                     COMPILER2_PRESENT(&quot;Server&quot;)
100   #endif // ZERO
101   #endif // TIERED
102 #endif
103 
104 #ifndef HOTSPOT_VM_DISTRO
105   #error HOTSPOT_VM_DISTRO must be defined
106 #endif
107 #define VMNAME HOTSPOT_VM_DISTRO &quot; &quot; VMLP VMTYPE &quot; VM&quot;
108 
109 const char* Abstract_VM_Version::vm_name() {
110   return VMNAME;
111 }
112 
113 
114 const char* Abstract_VM_Version::vm_vendor() {
115 #ifdef VENDOR
116   return VENDOR;
117 #else
118   return &quot;Oracle Corporation&quot;;
119 #endif
120 }
121 
122 
123 const char* Abstract_VM_Version::vm_info_string() {
124   switch (Arguments::mode()) {
125     case Arguments::_int:
126       return UseSharedSpaces ? &quot;interpreted mode, sharing&quot; : &quot;interpreted mode&quot;;
127     case Arguments::_mixed:
128       if (UseSharedSpaces) {
129         if (UseAOT) {
130           return &quot;mixed mode, aot, sharing&quot;;
131 #ifdef TIERED
132         } else if(is_client_compilation_mode_vm()) {
133           return &quot;mixed mode, emulated-client, sharing&quot;;
134 #endif
135         } else {
136           return &quot;mixed mode, sharing&quot;;
137          }
138       } else {
139         if (UseAOT) {
140           return &quot;mixed mode, aot&quot;;
141 #ifdef TIERED
142         } else if(is_client_compilation_mode_vm()) {
143           return &quot;mixed mode, emulated-client&quot;;
144 #endif
145         } else {
146           return &quot;mixed mode&quot;;
147         }
148       }
149     case Arguments::_comp:
150 #ifdef TIERED
151       if (is_client_compilation_mode_vm()) {
152          return UseSharedSpaces ? &quot;compiled mode, emulated-client, sharing&quot; : &quot;compiled mode, emulated-client&quot;;
153       }
154 #endif
155       return UseSharedSpaces ? &quot;compiled mode, sharing&quot;    : &quot;compiled mode&quot;;
156   };
157   ShouldNotReachHere();
158   return &quot;&quot;;
159 }
160 
161 // NOTE: do *not* use stringStream. this function is called by
162 //       fatal error handler. if the crash is in native thread,
163 //       stringStream cannot get resource allocated and will SEGV.
164 const char* Abstract_VM_Version::vm_release() {
165   return VM_RELEASE;
166 }
167 
168 // NOTE: do *not* use stringStream. this function is called by
169 //       fatal error handlers. if the crash is in native thread,
170 //       stringStream cannot get resource allocated and will SEGV.
171 const char* Abstract_VM_Version::jre_release_version() {
172   return VERSION_STRING;
173 }
174 
175 #define OS       LINUX_ONLY(&quot;linux&quot;)             \
176                  WINDOWS_ONLY(&quot;windows&quot;)         \
177                  SOLARIS_ONLY(&quot;solaris&quot;)         \
178                  AIX_ONLY(&quot;aix&quot;)                 \
179                  BSD_ONLY(&quot;bsd&quot;)
180 
181 #ifndef CPU
182 #ifdef ZERO
183 #define CPU      ZERO_LIBARCH
184 #elif defined(PPC64)
185 #if defined(VM_LITTLE_ENDIAN)
186 #define CPU      &quot;ppc64le&quot;
187 #else
188 #define CPU      &quot;ppc64&quot;
189 #endif // PPC64
190 #else
191 #define CPU      AARCH64_ONLY(&quot;aarch64&quot;)         \
192                  AMD64_ONLY(&quot;amd64&quot;)             \
193                  IA32_ONLY(&quot;x86&quot;)                \
194                  IA64_ONLY(&quot;ia64&quot;)               \
195                  S390_ONLY(&quot;s390&quot;)               \
196                  SPARC_ONLY(&quot;sparc&quot;)
197 #endif // !ZERO
198 #endif // !CPU
199 
200 const char *Abstract_VM_Version::vm_platform_string() {
201   return OS &quot;-&quot; CPU;
202 }
203 
204 const char* Abstract_VM_Version::internal_vm_info_string() {
205   #ifndef HOTSPOT_BUILD_USER
206     #define HOTSPOT_BUILD_USER unknown
207   #endif
208 
209   #ifndef HOTSPOT_BUILD_COMPILER
210     #ifdef _MSC_VER
211       #if _MSC_VER == 1600
212         #define HOTSPOT_BUILD_COMPILER &quot;MS VC++ 10.0 (VS2010)&quot;
213       #elif _MSC_VER == 1700
214         #define HOTSPOT_BUILD_COMPILER &quot;MS VC++ 11.0 (VS2012)&quot;
215       #elif _MSC_VER == 1800
216         #define HOTSPOT_BUILD_COMPILER &quot;MS VC++ 12.0 (VS2013)&quot;
217       #elif _MSC_VER == 1900
218         #define HOTSPOT_BUILD_COMPILER &quot;MS VC++ 14.0 (VS2015)&quot;
219       #elif _MSC_VER == 1911
220         #define HOTSPOT_BUILD_COMPILER &quot;MS VC++ 15.3 (VS2017)&quot;
221       #elif _MSC_VER == 1912
222         #define HOTSPOT_BUILD_COMPILER &quot;MS VC++ 15.5 (VS2017)&quot;
223       #elif _MSC_VER == 1913
224         #define HOTSPOT_BUILD_COMPILER &quot;MS VC++ 15.6 (VS2017)&quot;
225       #elif _MSC_VER == 1914
226         #define HOTSPOT_BUILD_COMPILER &quot;MS VC++ 15.7 (VS2017)&quot;
227       #elif _MSC_VER == 1915
228         #define HOTSPOT_BUILD_COMPILER &quot;MS VC++ 15.8 (VS2017)&quot;
229       #else
230         #define HOTSPOT_BUILD_COMPILER &quot;unknown MS VC++:&quot; XSTR(_MSC_VER)
231       #endif
232     #elif defined(__SUNPRO_CC)
233       #if __SUNPRO_CC == 0x580
234         #define HOTSPOT_BUILD_COMPILER &quot;Workshop 5.8&quot;
235       #elif __SUNPRO_CC == 0x590
236         #define HOTSPOT_BUILD_COMPILER &quot;Workshop 5.9&quot;
237       #elif __SUNPRO_CC == 0x5100
238         #define HOTSPOT_BUILD_COMPILER &quot;Sun Studio 12u1&quot;
239       #elif __SUNPRO_CC == 0x5120
240         #define HOTSPOT_BUILD_COMPILER &quot;Sun Studio 12u3&quot;
241       #elif __SUNPRO_CC == 0x5130
242         #define HOTSPOT_BUILD_COMPILER &quot;Sun Studio 12u4&quot;
243       #else
244         #define HOTSPOT_BUILD_COMPILER &quot;unknown Workshop:&quot; XSTR(__SUNPRO_CC)
245       #endif
246     #elif defined(__clang_version__)
247         #define HOTSPOT_BUILD_COMPILER &quot;clang &quot; __VERSION__
248     #elif defined(__GNUC__)
249         #define HOTSPOT_BUILD_COMPILER &quot;gcc &quot; __VERSION__
250     #elif defined(__IBMCPP__)
251         #define HOTSPOT_BUILD_COMPILER &quot;xlC &quot; XSTR(__IBMCPP__)
252 
253     #else
254       #define HOTSPOT_BUILD_COMPILER &quot;unknown compiler&quot;
255     #endif
256   #endif
257 
258   #ifndef FLOAT_ARCH
259     #if defined(__SOFTFP__)
260       #define FLOAT_ARCH_STR &quot;-sflt&quot;
261     #else
262       #define FLOAT_ARCH_STR &quot;&quot;
263     #endif
264   #else
265     #define FLOAT_ARCH_STR XSTR(FLOAT_ARCH)
266   #endif
267 
268   #define INTERNAL_VERSION_SUFFIX VM_RELEASE &quot;)&quot; \
269          &quot; for &quot; OS &quot;-&quot; CPU FLOAT_ARCH_STR \
270          &quot; JRE (&quot; VERSION_STRING &quot;), built on &quot; __DATE__ &quot; &quot; __TIME__ \
271          &quot; by &quot; XSTR(HOTSPOT_BUILD_USER) &quot; with &quot; HOTSPOT_BUILD_COMPILER
272 
273   return strcmp(DEBUG_LEVEL, &quot;release&quot;) == 0
274       ? VMNAME &quot; (&quot; INTERNAL_VERSION_SUFFIX
275       : VMNAME &quot; (&quot; DEBUG_LEVEL &quot; &quot; INTERNAL_VERSION_SUFFIX;
276 }
277 
278 const char *Abstract_VM_Version::vm_build_user() {
279   return HOTSPOT_BUILD_USER;
280 }
281 
282 const char *Abstract_VM_Version::jdk_debug_level() {
283   return DEBUG_LEVEL;
284 }
285 
286 const char *Abstract_VM_Version::printable_jdk_debug_level() {
287   // Debug level is not printed for &quot;release&quot; builds
288   return strcmp(DEBUG_LEVEL, &quot;release&quot;) == 0 ? &quot;&quot; : DEBUG_LEVEL &quot; &quot;;
289 }
290 
291 unsigned int Abstract_VM_Version::jvm_version() {
292   return ((Abstract_VM_Version::vm_major_version() &amp; 0xFF) &lt;&lt; 24) |
293          ((Abstract_VM_Version::vm_minor_version() &amp; 0xFF) &lt;&lt; 16) |
294          ((Abstract_VM_Version::vm_security_version() &amp; 0xFF) &lt;&lt; 8) |
295          (Abstract_VM_Version::vm_build_number() &amp; 0xFF);
296 }
297 
298 
299 void VM_Version_init() {
300   VM_Version::initialize();
301 
302   if (log_is_enabled(Info, os, cpu)) {
303     char buf[1024];
304     ResourceMark rm;
305     LogStream ls(Log(os, cpu)::info());
306     os::print_cpu_info(&amp;ls, buf, sizeof(buf));
307   }
308 }
    </pre>
  </body>
</html>
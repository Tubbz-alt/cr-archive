<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/vmOperations.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vmOperations.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/vmOperations.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,18 ***</span>
  
  // Note: When new VM_XXX comes up, add &#39;XXX&#39; to the template table.
  #define VM_OPS_DO(template)                       \
    template(None)                                  \
    template(Cleanup)                               \
<span class="line-removed">-   template(ThreadStop)                            \</span>
    template(ThreadDump)                            \
    template(PrintThreads)                          \
    template(FindDeadlocks)                         \
    template(ClearICs)                              \
    template(ForceSafepoint)                        \
    template(ForceAsyncSafepoint)                   \
<span class="line-removed">-   template(Deoptimize)                            \</span>
    template(DeoptimizeFrame)                       \
    template(DeoptimizeAll)                         \
    template(ZombieAll)                             \
    template(Verify)                                \
    template(PrintJNI)                              \
<span class="line-new-header">--- 40,16 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,23 ***</span>
    template(GenCollectFull)                        \
    template(GenCollectFullConcurrent)              \
    template(GenCollectForAllocation)               \
    template(ParallelGCFailedAllocation)            \
    template(ParallelGCSystemGC)                    \
<span class="line-removed">-   template(CMS_Initial_Mark)                      \</span>
<span class="line-removed">-   template(CMS_Final_Remark)                      \</span>
    template(G1CollectForAllocation)                \
    template(G1CollectFull)                         \
    template(G1Concurrent)                          \
    template(ZMarkStart)                            \
    template(ZMarkEnd)                              \
    template(ZRelocateStart)                        \
    template(HandshakeOneThread)                    \
    template(HandshakeAllThreads)                   \
    template(HandshakeFallback)                     \
    template(EnableBiasedLocking)                   \
<span class="line-removed">-   template(RevokeBias)                            \</span>
    template(BulkRevokeBias)                        \
    template(PopulateDumpSharedSpace)               \
    template(JNIFunctionTableCopier)                \
    template(RedefineClasses)                       \
    template(UpdateForPopTopFrame)                  \
<span class="line-new-header">--- 60,22 ---</span>
    template(GenCollectFull)                        \
    template(GenCollectFullConcurrent)              \
    template(GenCollectForAllocation)               \
    template(ParallelGCFailedAllocation)            \
    template(ParallelGCSystemGC)                    \
    template(G1CollectForAllocation)                \
    template(G1CollectFull)                         \
    template(G1Concurrent)                          \
<span class="line-added">+   template(G1TryInitiateConcMark)                 \</span>
    template(ZMarkStart)                            \
    template(ZMarkEnd)                              \
    template(ZRelocateStart)                        \
<span class="line-added">+   template(ZVerify)                               \</span>
    template(HandshakeOneThread)                    \
    template(HandshakeAllThreads)                   \
    template(HandshakeFallback)                     \
    template(EnableBiasedLocking)                   \
    template(BulkRevokeBias)                        \
    template(PopulateDumpSharedSpace)               \
    template(JNIFunctionTableCopier)                \
    template(RedefineClasses)                       \
    template(UpdateForPopTopFrame)                  \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,10 ***</span>
<span class="line-new-header">--- 109,11 ---</span>
    template(ShenandoahDegeneratedGC)               \
    template(Exit)                                  \
    template(LinuxDllLoad)                          \
    template(RotateGCLog)                           \
    template(WhiteBoxOperation)                     \
<span class="line-added">+   template(JVMCIResizeCounters)                   \</span>
    template(ClassLoaderStatsOperation)             \
    template(ClassLoaderHierarchyOperation)         \
    template(DumpHashtable)                         \
    template(DumpTouchedMethods)                    \
    template(MarkActiveNMethods)                    \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,46 ***</span>
    template(ThreadsSuspendJVMTI)                   \
    template(ICBufferFull)                          \
    template(ScavengeMonitors)                      \
    template(PrintMetadata)                         \
    template(GTestExecuteAtSafepoint)               \
  
<span class="line-modified">! class VM_Operation: public CHeapObj&lt;mtInternal&gt; {</span>
   public:
<span class="line-removed">-   enum Mode {</span>
<span class="line-removed">-     _safepoint,       // blocking,        safepoint, vm_op C-heap allocated</span>
<span class="line-removed">-     _no_safepoint,    // blocking,     no safepoint, vm_op C-Heap allocated</span>
<span class="line-removed">-     _concurrent,      // non-blocking, no safepoint, vm_op C-Heap allocated</span>
<span class="line-removed">-     _async_safepoint  // non-blocking,    safepoint, vm_op C-Heap allocated</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
    enum VMOp_Type {
      VM_OPS_DO(VM_OP_ENUM)
      VMOp_Terminating
    };
  
   private:
    Thread*         _calling_thread;
<span class="line-modified">!   ThreadPriority  _priority;</span>
<span class="line-removed">-   long            _timestamp;</span>
    VM_Operation*   _next;
    VM_Operation*   _prev;
  
    // The VM operation name array
    static const char* _names[];
  
   public:
<span class="line-modified">!   VM_Operation()  { _calling_thread = NULL; _next = NULL; _prev = NULL; }</span>
<span class="line-removed">-   virtual ~VM_Operation() {}</span>
  
    // VM operation support (used by VM thread)
    Thread* calling_thread() const                 { return _calling_thread; }
<span class="line-modified">!   ThreadPriority priority()                      { return _priority; }</span>
<span class="line-removed">-   void set_calling_thread(Thread* thread, ThreadPriority priority);</span>
  
<span class="line-modified">!   long timestamp() const              { return _timestamp; }</span>
<span class="line-modified">!   void set_timestamp(long timestamp)  { _timestamp = timestamp; }</span>
  
    // Called by VM thread - does in turn invoke doit(). Do not override this
    void evaluate();
  
    // evaluate() is called by the VMThread and in turn calls doit().
<span class="line-new-header">--- 123,37 ---</span>
    template(ThreadsSuspendJVMTI)                   \
    template(ICBufferFull)                          \
    template(ScavengeMonitors)                      \
    template(PrintMetadata)                         \
    template(GTestExecuteAtSafepoint)               \
<span class="line-added">+   template(JFROldObject)                          \</span>
  
<span class="line-modified">! class VM_Operation : public StackObj {</span>
   public:
    enum VMOp_Type {
      VM_OPS_DO(VM_OP_ENUM)
      VMOp_Terminating
    };
  
   private:
    Thread*         _calling_thread;
<span class="line-modified">!   uint64_t        _timestamp;</span>
    VM_Operation*   _next;
    VM_Operation*   _prev;
  
    // The VM operation name array
    static const char* _names[];
  
   public:
<span class="line-modified">!   VM_Operation() : _calling_thread(NULL), _timestamp(0),  _next(NULL), _prev(NULL) {}</span>
  
    // VM operation support (used by VM thread)
    Thread* calling_thread() const                 { return _calling_thread; }
<span class="line-modified">!   void set_calling_thread(Thread* thread);</span>
  
<span class="line-modified">!   uint64_t timestamp() const              { return _timestamp; }</span>
<span class="line-modified">!   void set_timestamp(uint64_t timestamp)  { _timestamp = timestamp; }</span>
  
    // Called by VM thread - does in turn invoke doit(). Do not override this
    void evaluate();
  
    // evaluate() is called by the VMThread and in turn calls doit().
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,45 ***</span>
    // If doit_prologue() returns true the VM operation will proceed, and
    // doit_epilogue() will be called by the JavaThread once the VM operation
    // completes. If doit_prologue() returns false the VM operation is cancelled.
    virtual void doit()                            = 0;
    virtual bool doit_prologue()                   { return true; };
<span class="line-modified">!   virtual void doit_epilogue()                   {}; // Note: Not called if mode is: _concurrent</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Type test</span>
<span class="line-removed">-   virtual bool is_methodCompiler() const         { return false; }</span>
  
    // Linking
    VM_Operation *next() const                     { return _next; }
    VM_Operation *prev() const                     { return _prev; }
    void set_next(VM_Operation *next)              { _next = next; }
    void set_prev(VM_Operation *prev)              { _prev = prev; }
  
    // Configuration. Override these appropriately in subclasses.
    virtual VMOp_Type type() const = 0;
<span class="line-removed">-   virtual Mode evaluation_mode() const            { return _safepoint; }</span>
    virtual bool allow_nested_vm_operations() const { return false; }
<span class="line-removed">-   virtual bool is_cheap_allocated() const         { return false; }</span>
<span class="line-removed">-   virtual void oops_do(OopClosure* f)              { /* do nothing */ };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // CAUTION: &lt;don&#39;t hang yourself with following rope&gt;</span>
<span class="line-removed">-   // If you override these methods, make sure that the evaluation</span>
<span class="line-removed">-   // of these methods is race-free and non-blocking, since these</span>
<span class="line-removed">-   // methods may be evaluated either by the mutators or by the</span>
<span class="line-removed">-   // vm thread, either concurrently with mutators or with the mutators</span>
<span class="line-removed">-   // stopped. In other words, taking locks is verboten, and if there</span>
<span class="line-removed">-   // are any races in evaluating the conditions, they&#39;d better be benign.</span>
<span class="line-removed">-   virtual bool evaluate_at_safepoint() const {</span>
<span class="line-removed">-     return evaluation_mode() == _safepoint  ||</span>
<span class="line-removed">-            evaluation_mode() == _async_safepoint;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   virtual bool evaluate_concurrently() const {</span>
<span class="line-removed">-     return evaluation_mode() == _concurrent ||</span>
<span class="line-removed">-            evaluation_mode() == _async_safepoint;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   static const char* mode_to_string(Mode mode);</span>
  
    // Debugging
    virtual void print_on_error(outputStream* st) const;
    virtual const char* name() const  { return _names[type()]; }
    static const char* name(int type) {
<span class="line-new-header">--- 163,25 ---</span>
    // If doit_prologue() returns true the VM operation will proceed, and
    // doit_epilogue() will be called by the JavaThread once the VM operation
    // completes. If doit_prologue() returns false the VM operation is cancelled.
    virtual void doit()                            = 0;
    virtual bool doit_prologue()                   { return true; };
<span class="line-modified">!   virtual void doit_epilogue()                   {};</span>
  
    // Linking
    VM_Operation *next() const                     { return _next; }
    VM_Operation *prev() const                     { return _prev; }
    void set_next(VM_Operation *next)              { _next = next; }
    void set_prev(VM_Operation *prev)              { _prev = prev; }
  
    // Configuration. Override these appropriately in subclasses.
    virtual VMOp_Type type() const = 0;
    virtual bool allow_nested_vm_operations() const { return false; }
  
<span class="line-modified">!   // An operation can either be done inside a safepoint</span>
<span class="line-added">+   // or concurrently with Java threads running.</span>
<span class="line-added">+   virtual bool evaluate_at_safepoint() const { return true; }</span>
  
    // Debugging
    virtual void print_on_error(outputStream* st) const;
    virtual const char* name() const  { return _names[type()]; }
    static const char* name(int type) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,36 ***</span>
   public:
    VMOp_Type type() const { return VMOp_Cleanup; }
    void doit() {};
  };
  
<span class="line-removed">- class VM_ThreadStop: public VM_Operation {</span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   oop     _thread;        // The Thread that the Throwable is thrown against</span>
<span class="line-removed">-   oop     _throwable;     // The Throwable thrown at the target Thread</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   // All oops are passed as JNI handles, since there is no guarantee that a GC might happen before the</span>
<span class="line-removed">-   // VM operation is executed.</span>
<span class="line-removed">-   VM_ThreadStop(oop thread, oop throwable) {</span>
<span class="line-removed">-     _thread    = thread;</span>
<span class="line-removed">-     _throwable = throwable;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   VMOp_Type type() const                         { return VMOp_ThreadStop; }</span>
<span class="line-removed">-   oop target_thread() const                      { return _thread; }</span>
<span class="line-removed">-   oop throwable() const                          { return _throwable;}</span>
<span class="line-removed">-   void doit();</span>
<span class="line-removed">-   // We deoptimize if top-most frame is compiled - this might require a C2I adapter to be generated</span>
<span class="line-removed">-   bool allow_nested_vm_operations() const        { return true; }</span>
<span class="line-removed">-   Mode evaluation_mode() const                   { return _async_safepoint; }</span>
<span class="line-removed">-   bool is_cheap_allocated() const                { return true; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // GC support</span>
<span class="line-removed">-   void oops_do(OopClosure* f) {</span>
<span class="line-removed">-     f-&gt;do_oop(&amp;_thread); f-&gt;do_oop(&amp;_throwable);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  class VM_ClearICs: public VM_Operation {
   private:
    bool _preserve_static_stubs;
   public:
    VM_ClearICs(bool preserve_static_stubs) { _preserve_static_stubs = preserve_static_stubs; }
<span class="line-new-header">--- 206,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,18 ***</span>
  class VM_ICBufferFull: public VM_ForceSafepoint {
   public:
    VMOp_Type type() const { return VMOp_ICBufferFull; }
  };
  
<span class="line-removed">- // empty asynchronous vm op, when forcing a safepoint to scavenge monitors</span>
<span class="line-removed">- class VM_ScavengeMonitors: public VM_ForceSafepoint {</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   VMOp_Type type() const                         { return VMOp_ScavengeMonitors; }</span>
<span class="line-removed">-   Mode evaluation_mode() const                   { return _async_safepoint; }</span>
<span class="line-removed">-   bool is_cheap_allocated() const                { return true; }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  // Base class for invoking parts of a gtest in a safepoint.
  // Derived classes provide the doit method.
  // Typically also need to transition the gtest thread from native to VM.
  class VM_GTestExecuteAtSafepoint: public VM_Operation {
   public:
<span class="line-new-header">--- 240,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,18 ***</span>
  
   protected:
    VM_GTestExecuteAtSafepoint() {}
  };
  
<span class="line-removed">- class VM_Deoptimize: public VM_Operation {</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   VM_Deoptimize() {}</span>
<span class="line-removed">-   VMOp_Type type() const                        { return VMOp_Deoptimize; }</span>
<span class="line-removed">-   void doit();</span>
<span class="line-removed">-   bool allow_nested_vm_operations() const        { return true; }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  class VM_MarkActiveNMethods: public VM_Operation {
   public:
    VM_MarkActiveNMethods() {}
    VMOp_Type type() const                         { return VMOp_MarkActiveNMethods; }
    void doit();
<span class="line-new-header">--- 251,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 506,11 ***</span>
    outputStream* _out;
  
   public:
    VM_PrintCompileQueue(outputStream* st) : _out(st) {}
    VMOp_Type type() const { return VMOp_PrintCompileQueue; }
<span class="line-removed">-   Mode evaluation_mode() const { return _safepoint; }</span>
    void doit();
  };
  
  #if INCLUDE_SERVICES
  class VM_PrintClassHierarchy: public VM_Operation {
<span class="line-new-header">--- 433,10 ---</span>
</pre>
<center><a href="vmOperations.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/thread.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="thread.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,10 ***</span>
<span class="line-new-header">--- 46,11 ---</span>
  #include &quot;runtime/threadLocalStorage.hpp&quot;
  #include &quot;runtime/threadStatisticalInfo.hpp&quot;
  #include &quot;runtime/unhandledOops.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/exceptions.hpp&quot;
<span class="line-added">+ #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
  #ifdef ZERO
  # include &quot;stack_zero.hpp&quot;
  #endif
  #if INCLUDE_JFR
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,10 ***</span>
<span class="line-new-header">--- 61,11 ---</span>
  class SafeThreadsListPtr;
  class ThreadSafepointState;
  class ThreadsList;
  class ThreadsSMRSupport;
  
<span class="line-added">+ class JvmtiRawMonitor;</span>
  class JvmtiThreadState;
  class ThreadStatistics;
  class ConcurrentLocksDump;
  class ParkEvent;
  class Parker;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,15 ***</span>
  class javaVFrame;
  
  class DeoptResourceMark;
  class jvmtiDeferredLocalVariableSet;
  
<span class="line-removed">- class GCTaskQueue;</span>
  class ThreadClosure;
  class ICRefillVerifier;
  class IdealGraphPrinter;
  
  class Metadata;
  class ResourceArea;
  
  DEBUG_ONLY(class ResourceMark;)
  
<span class="line-new-header">--- 83,17 ---</span>
  class javaVFrame;
  
  class DeoptResourceMark;
  class jvmtiDeferredLocalVariableSet;
  
  class ThreadClosure;
  class ICRefillVerifier;
  class IdealGraphPrinter;
  
<span class="line-added">+ class JVMCIEnv;</span>
<span class="line-added">+ class JVMCIPrimitiveArray;</span>
<span class="line-added">+ </span>
  class Metadata;
  class ResourceArea;
  
  DEBUG_ONLY(class ResourceMark;)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,11 ***</span>
  //     - NamedThread
  //       - VMThread
  //       - ConcurrentGCThread
  //       - WorkerThread
  //         - GangWorker
<span class="line-removed">- //         - GCTaskThread</span>
  //     - WatcherThread
  //     - JfrThreadSampler
  //
  // All Thread subclasses must be either JavaThread or NonJavaThread.
  // This means !t-&gt;is_Java_thread() iff t is a NonJavaThread, or t is
<span class="line-new-header">--- 107,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,11 ***</span>
    friend class JVMCIVMStructs;
   private:
  
  #ifndef USE_LIBRARY_BASED_TLS_ONLY
    // Current thread is maintained as a thread-local variable
<span class="line-modified">!   static THREAD_LOCAL_DECL Thread* _thr_current;</span>
  #endif
  
    // Thread local data area available to the GC. The internal
    // structure and contents of this data area is GC-specific.
    // Only GC and GC barrier code should access this data area.
<span class="line-new-header">--- 142,11 ---</span>
    friend class JVMCIVMStructs;
   private:
  
  #ifndef USE_LIBRARY_BASED_TLS_ONLY
    // Current thread is maintained as a thread-local variable
<span class="line-modified">!   static THREAD_LOCAL Thread* _thr_current;</span>
  #endif
  
    // Thread local data area available to the GC. The internal
    // structure and contents of this data area is GC-specific.
    // Only GC and GC barrier code should access this data area.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 284,11 ***</span>
      // NOTE: avoid using the sign-bit as cc generates different test code
      //       when the sign-bit is used, and sometimes incorrectly - see CR 6398077
  
      _external_suspend       = 0x20000000U, // thread is asked to self suspend
      _ext_suspended          = 0x40000000U, // thread has self-suspended
<span class="line-removed">-     _deopt_suspend          = 0x10000000U, // thread needs to self suspend for deopt</span>
  
      _has_async_exception    = 0x00000001U, // there is a pending async exception
      _critical_native_unlock = 0x00000002U, // Must call back to unlock JNI critical lock
  
      _trace_flag             = 0x00000004U  // call tracing backend
<span class="line-new-header">--- 287,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 336,13 ***</span>
    JNIHandleBlock* _free_handle_block;
  
    // Point to the last handle mark
    HandleMark* _last_handle_mark;
  
<span class="line-modified">!   // The parity of the last strong_roots iteration in which this thread was</span>
<span class="line-modified">!   // claimed as a task.</span>
<span class="line-removed">-   int _oops_do_parity;</span>
  
    // Support for GlobalCounter
   private:
    volatile uintx _rcu_counter;
   public:
<span class="line-new-header">--- 338,12 ---</span>
    JNIHandleBlock* _free_handle_block;
  
    // Point to the last handle mark
    HandleMark* _last_handle_mark;
  
<span class="line-modified">!   // Claim value for parallel iteration over threads.</span>
<span class="line-modified">!   uintx _threads_do_token;</span>
  
    // Support for GlobalCounter
   private:
    volatile uintx _rcu_counter;
   public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 364,33 ***</span>
    }
  
    void set_missed_ic_stub_refill_verifier(ICRefillVerifier* verifier) {
      _missed_ic_stub_refill_verifier = verifier;
    }
<span class="line-modified">! #endif</span>
  
   private:
  
<span class="line-modified">!   // debug support for checking if code does allow safepoints or not</span>
<span class="line-modified">!   // GC points in the VM can happen because of allocation, invoking a VM operation, or blocking on</span>
    // mutex, or blocking on an object synchronizer (Java locking).
<span class="line-modified">!   // If !allow_safepoint(), then an assertion failure will happen in any of the above cases</span>
<span class="line-modified">!   // If !allow_allocation(), then an assertion failure will happen during allocation</span>
<span class="line-removed">-   // (Hence, !allow_safepoint() =&gt; !allow_allocation()).</span>
    //
<span class="line-modified">!   // The two classes NoSafepointVerifier and No_Allocation_Verifier are used to set these counters.</span>
    //
<span class="line-modified">!   NOT_PRODUCT(int _allow_safepoint_count;)      // If 0, thread allow a safepoint to happen</span>
<span class="line-removed">-   debug_only(int _allow_allocation_count;)     // If 0, the thread is allowed to allocate oops.</span>
  
    // Used by SkipGCALot class.
    NOT_PRODUCT(bool _skip_gcalot;)               // Should we elide gc-a-lot?
  
<span class="line-modified">!   friend class NoAllocVerifier;</span>
    friend class NoSafepointVerifier;
    friend class PauseNoSafepointVerifier;
<span class="line-removed">-   friend class GCLocker;</span>
  
    volatile void* _polling_page;                 // Thread local polling page
  
    ThreadLocalAllocBuffer _tlab;                 // Thread-local eden
    jlong _allocated_bytes;                       // Cumulative number of bytes allocated on
<span class="line-new-header">--- 365,31 ---</span>
    }
  
    void set_missed_ic_stub_refill_verifier(ICRefillVerifier* verifier) {
      _missed_ic_stub_refill_verifier = verifier;
    }
<span class="line-modified">! #endif // ASSERT</span>
  
   private:
  
<span class="line-modified">!   // Debug support for checking if code allows safepoints or not.</span>
<span class="line-modified">!   // Safepoints in the VM can happen because of allocation, invoking a VM operation, or blocking on</span>
    // mutex, or blocking on an object synchronizer (Java locking).
<span class="line-modified">!   // If _no_safepoint_count is non-zero, then an assertion failure will happen in any of</span>
<span class="line-modified">!   // the above cases.</span>
    //
<span class="line-modified">!   // The class NoSafepointVerifier is used to set this counter.</span>
    //
<span class="line-modified">!   NOT_PRODUCT(int _no_safepoint_count;)         // If 0, thread allow a safepoint to happen</span>
  
<span class="line-added">+  private:</span>
    // Used by SkipGCALot class.
    NOT_PRODUCT(bool _skip_gcalot;)               // Should we elide gc-a-lot?
  
<span class="line-modified">!   friend class GCLocker;</span>
    friend class NoSafepointVerifier;
    friend class PauseNoSafepointVerifier;
  
    volatile void* _polling_page;                 // Thread local polling page
  
    ThreadLocalAllocBuffer _tlab;                 // Thread-local eden
    jlong _allocated_bytes;                       // Cumulative number of bytes allocated on
</pre>
<hr />
<pre>
<span class="line-old-header">*** 405,21 ***</span>
    int   _vm_operation_completed_count;          // VM_Operation support
  
    ObjectMonitor* _current_pending_monitor;      // ObjectMonitor this thread
                                                  // is waiting to lock
    bool _current_pending_monitor_is_from_java;   // locking is from Java code
  
    // ObjectMonitor on which this thread called Object.wait()
    ObjectMonitor* _current_waiting_monitor;
  
<span class="line-modified">!   // Private thread-local objectmonitor list - a simple cache organized as a SLL.</span>
   public:
<span class="line-modified">!   ObjectMonitor* omFreeList;</span>
<span class="line-modified">!   int omFreeCount;                              // length of omFreeList</span>
<span class="line-modified">!   int omFreeProvision;                          // reload chunk size</span>
<span class="line-modified">!   ObjectMonitor* omInUseList;                   // SLL to track monitors in circulation</span>
<span class="line-modified">!   int omInUseCount;                             // length of omInUseList</span>
  
  #ifdef ASSERT
   private:
    volatile uint64_t _visited_for_critical_count;
  
<span class="line-new-header">--- 404,24 ---</span>
    int   _vm_operation_completed_count;          // VM_Operation support
  
    ObjectMonitor* _current_pending_monitor;      // ObjectMonitor this thread
                                                  // is waiting to lock
    bool _current_pending_monitor_is_from_java;   // locking is from Java code
<span class="line-added">+   JvmtiRawMonitor* _current_pending_raw_monitor; // JvmtiRawMonitor this thread</span>
<span class="line-added">+                                                  // is waiting to lock</span>
<span class="line-added">+ </span>
  
    // ObjectMonitor on which this thread called Object.wait()
    ObjectMonitor* _current_waiting_monitor;
  
<span class="line-modified">!   // Per-thread ObjectMonitor lists:</span>
   public:
<span class="line-modified">!   ObjectMonitor* om_free_list;                  // SLL of free ObjectMonitors</span>
<span class="line-modified">!   int om_free_count;                            // # on om_free_list</span>
<span class="line-modified">!   int om_free_provision;                        // # to try to allocate next</span>
<span class="line-modified">!   ObjectMonitor* om_in_use_list;                // SLL of in-use ObjectMonitors</span>
<span class="line-modified">!   int om_in_use_count;                          // # on om_in_use_list</span>
  
  #ifdef ASSERT
   private:
    volatile uint64_t _visited_for_critical_count;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 477,10 ***</span>
<span class="line-new-header">--- 479,11 ---</span>
    // Testers
    virtual bool is_VM_thread()       const            { return false; }
    virtual bool is_Java_thread()     const            { return false; }
    virtual bool is_Compiler_thread() const            { return false; }
    virtual bool is_Code_cache_sweeper_thread() const  { return false; }
<span class="line-added">+   virtual bool is_service_thread() const             { return false; }</span>
    virtual bool is_hidden_from_external_view() const  { return false; }
    virtual bool is_jvmti_agent_thread() const         { return false; }
    // True iff the thread can perform GC operations at a safepoint.
    // Generally will be true only of VM thread and parallel GC WorkGang
    // threads.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 491,10 ***</span>
<span class="line-new-header">--- 494,14 ---</span>
    virtual bool is_Worker_thread() const              { return false; }
  
    // Can this thread make Java upcalls
    virtual bool can_call_java() const                 { return false; }
  
<span class="line-added">+   // Is this a JavaThread that is on the VM&#39;s current ThreadsList?</span>
<span class="line-added">+   // If so it must participate in the safepoint protocol.</span>
<span class="line-added">+   virtual bool is_active_Java_thread() const         { return false; }</span>
<span class="line-added">+ </span>
    // Casts
    virtual WorkerThread* as_Worker_thread() const     { return NULL; }
  
    virtual char* name() const { return (char*)&quot;Unknown thread&quot;; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 511,19 ***</span>
    static void check_for_dangling_thread_pointer(Thread *thread);
  #endif
    static void set_priority(Thread* thread, ThreadPriority priority);
    static ThreadPriority get_priority(const Thread* const thread);
    static void start(Thread* thread);
<span class="line-removed">-   static void interrupt(Thread* thr);</span>
<span class="line-removed">-   static bool is_interrupted(Thread* thr, bool clear_interrupted);</span>
  
    void set_native_thread_name(const char *name) {
      assert(Thread::current() == this, &quot;set_native_thread_name can only be called on the current thread&quot;);
      os::set_native_thread_name(name);
    }
  
<span class="line-removed">-   ObjectMonitor** omInUseList_addr()             { return (ObjectMonitor **)&amp;omInUseList; }</span>
    Monitor* SR_lock() const                       { return _SR_lock; }
  
    bool has_async_exception() const { return (_suspend_flags &amp; _has_async_exception) != 0; }
  
    inline void set_suspend_flag(SuspendFlags f);
<span class="line-new-header">--- 518,16 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 639,49 ***</span>
    }
    void set_current_waiting_monitor(ObjectMonitor* monitor) {
      _current_waiting_monitor = monitor;
    }
  
    // GC support
    // Apply &quot;f-&gt;do_oop&quot; to all root oops in &quot;this&quot;.
    //   Used by JavaThread::oops_do.
    // Apply &quot;cf-&gt;do_code_blob&quot; (if !NULL) to all code blobs active in frames
    virtual void oops_do(OopClosure* f, CodeBlobClosure* cf);
  
<span class="line-modified">!   // Handles the parallel case for the method below.</span>
   private:
<span class="line-modified">!   bool claim_oops_do_par_case(int collection_parity);</span>
   public:
<span class="line-modified">!   // Requires that &quot;collection_parity&quot; is that of the current roots</span>
<span class="line-modified">!   // iteration.  If &quot;is_par&quot; is false, sets the parity of &quot;this&quot; to</span>
<span class="line-modified">!   // &quot;collection_parity&quot;, and returns &quot;true&quot;.  If &quot;is_par&quot; is true,</span>
<span class="line-modified">!   // uses an atomic instruction to set the current threads parity to</span>
<span class="line-modified">!   // &quot;collection_parity&quot;, if it is not already.  Returns &quot;true&quot; iff the</span>
    // calling thread does the update, this indicates that the calling thread
<span class="line-modified">!   // has claimed the thread&#39;s stack as a root group in the current</span>
<span class="line-modified">!   // collection.</span>
<span class="line-removed">-   bool claim_oops_do(bool is_par, int collection_parity) {</span>
      if (!is_par) {
<span class="line-modified">!       _oops_do_parity = collection_parity;</span>
        return true;
      } else {
<span class="line-modified">!       return claim_oops_do_par_case(collection_parity);</span>
      }
    }
  
    // jvmtiRedefineClasses support
    void metadata_handles_do(void f(Metadata*));
  
    // Used by fast lock support
    virtual bool is_lock_owned(address adr) const;
  
<span class="line-modified">!   // Check if address is in the stack of the thread (not just for locks).</span>
<span class="line-modified">!   // Warning: the method can only be used on the running thread</span>
    bool is_in_stack(address adr) const;
<span class="line-modified">!   // Check if address is in the usable part of the stack (excludes protected</span>
<span class="line-modified">!   // guard pages)</span>
<span class="line-modified">!   bool is_in_usable_stack(address adr) const;</span>
  
    // Sets this thread as starting thread. Returns failure if thread
    // creation fails due to lack of memory, too many threads etc.
    bool set_as_starting_thread();
  
<span class="line-new-header">--- 643,61 ---</span>
    }
    void set_current_waiting_monitor(ObjectMonitor* monitor) {
      _current_waiting_monitor = monitor;
    }
  
<span class="line-added">+   // For tracking the Jvmti raw monitor the thread is pending on.</span>
<span class="line-added">+   JvmtiRawMonitor* current_pending_raw_monitor() {</span>
<span class="line-added">+     return _current_pending_raw_monitor;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   void set_current_pending_raw_monitor(JvmtiRawMonitor* monitor) {</span>
<span class="line-added">+     _current_pending_raw_monitor = monitor;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // GC support
    // Apply &quot;f-&gt;do_oop&quot; to all root oops in &quot;this&quot;.
    //   Used by JavaThread::oops_do.
    // Apply &quot;cf-&gt;do_code_blob&quot; (if !NULL) to all code blobs active in frames
    virtual void oops_do(OopClosure* f, CodeBlobClosure* cf);
  
<span class="line-modified">!   // Handles the parallel case for claim_threads_do.</span>
   private:
<span class="line-modified">!   bool claim_par_threads_do(uintx claim_token);</span>
   public:
<span class="line-modified">!   // Requires that &quot;claim_token&quot; is that of the current iteration.</span>
<span class="line-modified">!   // If &quot;is_par&quot; is false, sets the token of &quot;this&quot; to</span>
<span class="line-modified">!   // &quot;claim_token&quot;, and returns &quot;true&quot;.  If &quot;is_par&quot; is true,</span>
<span class="line-modified">!   // uses an atomic instruction to set the current thread&#39;s token to</span>
<span class="line-modified">!   // &quot;claim_token&quot;, if it is not already.  Returns &quot;true&quot; iff the</span>
    // calling thread does the update, this indicates that the calling thread
<span class="line-modified">!   // has claimed the thread in the current iteration.</span>
<span class="line-modified">!   bool claim_threads_do(bool is_par, uintx claim_token) {</span>
      if (!is_par) {
<span class="line-modified">!       _threads_do_token = claim_token;</span>
        return true;
      } else {
<span class="line-modified">!       return claim_par_threads_do(claim_token);</span>
      }
    }
  
<span class="line-added">+   uintx threads_do_token() const { return _threads_do_token; }</span>
<span class="line-added">+ </span>
    // jvmtiRedefineClasses support
    void metadata_handles_do(void f(Metadata*));
  
    // Used by fast lock support
    virtual bool is_lock_owned(address adr) const;
  
<span class="line-modified">!   // Check if address is in the live stack of this thread (not just for locks).</span>
<span class="line-modified">!   // Warning: can only be called by the current thread on itself.</span>
    bool is_in_stack(address adr) const;
<span class="line-modified">! </span>
<span class="line-modified">!   // Check if address in the stack mapped to this thread. Used mainly in</span>
<span class="line-modified">!   // error reporting (so has to include guard zone) and frame printing.</span>
<span class="line-added">+   bool on_local_stack(address adr) const {</span>
<span class="line-added">+     return (_stack_base &gt; adr &amp;&amp; adr &gt;= stack_end());</span>
<span class="line-added">+   }</span>
  
    // Sets this thread as starting thread. Returns failure if thread
    // creation fails due to lack of memory, too many threads etc.
    bool set_as_starting_thread();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 699,11 ***</span>
    GrowableArray&lt;Metadata*&gt;* _metadata_handles;
  
    // Support for stack overflow handling, get_thread, etc.
    address          _stack_base;
    size_t           _stack_size;
<span class="line-removed">-   uintptr_t        _self_raw_id;      // used by get_thread (mutable)</span>
    int              _lgrp_id;
  
    volatile void** polling_page_addr() { return &amp;_polling_page; }
  
   public:
<span class="line-new-header">--- 715,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 714,53 ***</span>
    void    set_stack_size(size_t size)  { _stack_size = size; }
    address stack_end()  const           { return stack_base() - stack_size(); }
    void    record_stack_base_and_size();
    void    register_thread_stack_with_NMT() NOT_NMT_RETURN;
  
<span class="line-removed">-   bool    on_local_stack(address adr) const {</span>
<span class="line-removed">-     // QQQ this has knowledge of direction, ought to be a stack method</span>
<span class="line-removed">-     return (_stack_base &gt;= adr &amp;&amp; adr &gt;= stack_end());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   uintptr_t self_raw_id()                    { return _self_raw_id; }</span>
<span class="line-removed">-   void      set_self_raw_id(uintptr_t value) { _self_raw_id = value; }</span>
<span class="line-removed">- </span>
    int     lgrp_id() const        { return _lgrp_id; }
    void    set_lgrp_id(int value) { _lgrp_id = value; }
  
    // Printing
    void print_on(outputStream* st, bool print_extended_info) const;
    virtual void print_on(outputStream* st) const { print_on(st, false); }
<span class="line-modified">!   void print() const { print_on(tty); }</span>
    virtual void print_on_error(outputStream* st, char* buf, int buflen) const;
    void print_value_on(outputStream* st) const;
  
    // Debug-only code
  #ifdef ASSERT
   private:
    // Deadlock detection support for Mutex locks. List of locks own by thread.
<span class="line-modified">!   Monitor* _owned_locks;</span>
    // Mutex::set_owner_implementation is the only place where _owned_locks is modified,
    // thus the friendship
    friend class Mutex;
    friend class Monitor;
  
   public:
    void print_owned_locks_on(outputStream* st) const;
    void print_owned_locks() const                 { print_owned_locks_on(tty);    }
<span class="line-modified">!   Monitor* owned_locks() const                   { return _owned_locks;          }</span>
    bool owns_locks() const                        { return owned_locks() != NULL; }
<span class="line-removed">-   bool owns_locks_but_compiled_lock() const;</span>
<span class="line-removed">-   int oops_do_parity() const                     { return _oops_do_parity; }</span>
  
    // Deadlock detection
<span class="line-removed">-   bool allow_allocation()                        { return _allow_allocation_count == 0; }</span>
    ResourceMark* current_resource_mark()          { return _current_resource_mark; }
    void set_current_resource_mark(ResourceMark* rm) { _current_resource_mark = rm; }
<span class="line-modified">! #endif</span>
  
<span class="line-modified">!   void check_for_valid_safepoint_state(bool potential_vm_operation) PRODUCT_RETURN;</span>
  
   private:
    volatile int _jvmti_env_iteration_count;
  
   public:
<span class="line-new-header">--- 729,45 ---</span>
    void    set_stack_size(size_t size)  { _stack_size = size; }
    address stack_end()  const           { return stack_base() - stack_size(); }
    void    record_stack_base_and_size();
    void    register_thread_stack_with_NMT() NOT_NMT_RETURN;
  
    int     lgrp_id() const        { return _lgrp_id; }
    void    set_lgrp_id(int value) { _lgrp_id = value; }
  
    // Printing
    void print_on(outputStream* st, bool print_extended_info) const;
    virtual void print_on(outputStream* st) const { print_on(st, false); }
<span class="line-modified">!   void print() const;</span>
    virtual void print_on_error(outputStream* st, char* buf, int buflen) const;
    void print_value_on(outputStream* st) const;
  
    // Debug-only code
  #ifdef ASSERT
   private:
    // Deadlock detection support for Mutex locks. List of locks own by thread.
<span class="line-modified">!   Mutex* _owned_locks;</span>
    // Mutex::set_owner_implementation is the only place where _owned_locks is modified,
    // thus the friendship
    friend class Mutex;
    friend class Monitor;
  
   public:
    void print_owned_locks_on(outputStream* st) const;
    void print_owned_locks() const                 { print_owned_locks_on(tty);    }
<span class="line-modified">!   Mutex* owned_locks() const                     { return _owned_locks;          }</span>
    bool owns_locks() const                        { return owned_locks() != NULL; }
  
    // Deadlock detection
    ResourceMark* current_resource_mark()          { return _current_resource_mark; }
    void set_current_resource_mark(ResourceMark* rm) { _current_resource_mark = rm; }
<span class="line-modified">! #endif // ASSERT</span>
  
<span class="line-modified">!   // These functions check conditions on a JavaThread before possibly going to a safepoint,</span>
<span class="line-added">+   // including NoSafepointVerifier.</span>
<span class="line-added">+   void check_for_valid_safepoint_state() NOT_DEBUG_RETURN;</span>
<span class="line-added">+   void check_possible_safepoint() NOT_DEBUG_RETURN;</span>
  
   private:
    volatile int _jvmti_env_iteration_count;
  
   public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 788,12 ***</span>
    JFR_ONLY(DEFINE_THREAD_LOCAL_OFFSET_JFR;)
  
   public:
    volatile intptr_t _Stalled;
    volatile int _TypeTag;
<span class="line-modified">!   ParkEvent * _ParkEvent;                     // for synchronized()</span>
<span class="line-removed">-   ParkEvent * _SleepEvent;                    // for Thread.sleep</span>
    ParkEvent * _MuxEvent;                      // for low-level muxAcquire-muxRelease
    int NativeSyncRecursion;                    // diagnostic
  
    volatile int _OnTrap;                       // Resume-at IP delta
    jint _hashStateW;                           // Marsaglia Shift-XOR thread-local RNG
<span class="line-new-header">--- 795,11 ---</span>
    JFR_ONLY(DEFINE_THREAD_LOCAL_OFFSET_JFR;)
  
   public:
    volatile intptr_t _Stalled;
    volatile int _TypeTag;
<span class="line-modified">!   ParkEvent * _ParkEvent;                     // for Object monitors and JVMTI raw monitors</span>
    ParkEvent * _MuxEvent;                      // for low-level muxAcquire-muxRelease
    int NativeSyncRecursion;                    // diagnostic
  
    volatile int _OnTrap;                       // Resume-at IP delta
    jint _hashStateW;                           // Marsaglia Shift-XOR thread-local RNG
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,11 ***</span>
    // and native monitor-mutex infrastructure.
    // Not for general synchronization use.
    static void SpinAcquire(volatile int * Lock, const char * Name);
    static void SpinRelease(volatile int * Lock);
    static void muxAcquire(volatile intptr_t * Lock, const char * Name);
<span class="line-removed">-   static void muxAcquireW(volatile intptr_t * Lock, ParkEvent * ev);</span>
    static void muxRelease(volatile intptr_t * Lock);
  };
  
  // Inline implementation of Thread::current()
  inline Thread* Thread::current() {
<span class="line-new-header">--- 811,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 866,13 ***</span>
  // must be no safepoint checks in that scope.
  class NonJavaThread::Iterator : public StackObj {
    uint _protect_enter;
    NonJavaThread* _current;
  
<span class="line-modified">!   // Noncopyable.</span>
<span class="line-removed">-   Iterator(const Iterator&amp;);</span>
<span class="line-removed">-   Iterator&amp; operator=(const Iterator&amp;);</span>
  
  public:
    Iterator();
    ~Iterator();
  
<span class="line-new-header">--- 871,11 ---</span>
  // must be no safepoint checks in that scope.
  class NonJavaThread::Iterator : public StackObj {
    uint _protect_enter;
    NonJavaThread* _current;
  
<span class="line-modified">!   NONCOPYABLE(Iterator);</span>
  
  public:
    Iterator();
    ~Iterator();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 980,11 ***</span>
  class JavaThread: public Thread {
    friend class VMStructs;
    friend class JVMCIVMStructs;
    friend class WhiteBox;
   private:
<span class="line-removed">-   JavaThread*    _next;                          // The next thread in the Threads list</span>
    bool           _on_thread_list;                // Is set when this JavaThread is added to the Threads list
    oop            _threadObj;                     // The Java level thread object
  
  #ifdef ASSERT
   private:
<span class="line-new-header">--- 983,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1015,12 ***</span>
    JNIEnv        _jni_environment;
  
    // Deopt support
    DeoptResourceMark*  _deopt_mark;               // Holds special ResourceMark for deoptimization
  
<span class="line-removed">-   intptr_t*      _must_deopt_id;                 // id of frame that needs to be deopted once we</span>
<span class="line-removed">-                                                  // transition out of native</span>
    CompiledMethod*       _deopt_nmethod;         // CompiledMethod that is currently being deoptimized
    vframeArray*  _vframe_array_head;              // Holds the heap of the active vframeArrays
    vframeArray*  _vframe_array_last;              // Holds last vFrameArray we popped
    // Because deoptimization is lazy we must save jvmti requests to set locals
    // in compiled frames until we deoptimize and we have an interpreter frame.
<span class="line-new-header">--- 1017,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1126,20 ***</span>
    bool      _pending_monitorenter;
  
    // Specifies if the DeoptReason for the last uncommon trap was Reason_transfer_to_interpreter
    bool      _pending_transfer_to_interpreter;
  
<span class="line-removed">-   // Guard for re-entrant call to JVMCIRuntime::adjust_comp_level</span>
<span class="line-removed">-   bool      _adjusting_comp_level;</span>
<span class="line-removed">- </span>
    // True if in a runtime call from compiled code that will deoptimize
    // and re-execute a failed heap allocation in the interpreter.
    bool      _in_retryable_allocation;
  
    // An id of a speculation that JVMCI compiled code can use to further describe and
    // uniquely identify the  speculative optimization guarded by the uncommon trap
<span class="line-modified">!   long       _pending_failed_speculation;</span>
  
    // These fields are mutually exclusive in terms of live ranges.
    union {
      // Communicates the pc at which the most recent implicit exception occurred
      // from the signal handler to a deoptimization stub.
<span class="line-new-header">--- 1126,17 ---</span>
    bool      _pending_monitorenter;
  
    // Specifies if the DeoptReason for the last uncommon trap was Reason_transfer_to_interpreter
    bool      _pending_transfer_to_interpreter;
  
    // True if in a runtime call from compiled code that will deoptimize
    // and re-execute a failed heap allocation in the interpreter.
    bool      _in_retryable_allocation;
  
    // An id of a speculation that JVMCI compiled code can use to further describe and
    // uniquely identify the  speculative optimization guarded by the uncommon trap
<span class="line-modified">!   jlong     _pending_failed_speculation;</span>
  
    // These fields are mutually exclusive in terms of live ranges.
    union {
      // Communicates the pc at which the most recent implicit exception occurred
      // from the signal handler to a deoptimization stub.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1152,11 ***</span>
    // Support for high precision, thread sensitive counters in JVMCI compiled code.
    jlong*    _jvmci_counters;
  
   public:
    static jlong* _jvmci_old_thread_counters;
<span class="line-modified">!   static void collect_counters(typeArrayOop array);</span>
   private:
  #endif // INCLUDE_JVMCI
  
    StackGuardState  _stack_guard_state;
  
<span class="line-new-header">--- 1149,14 ---</span>
    // Support for high precision, thread sensitive counters in JVMCI compiled code.
    jlong*    _jvmci_counters;
  
   public:
    static jlong* _jvmci_old_thread_counters;
<span class="line-modified">!   static void collect_counters(jlong* array, int length);</span>
<span class="line-added">+   void resize_counters(int current_size, int new_size);</span>
<span class="line-added">+   static void resize_all_jvmci_counters(int new_size);</span>
<span class="line-added">+ </span>
   private:
  #endif // INCLUDE_JVMCI
  
    StackGuardState  _stack_guard_state;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1191,21 ***</span>
    // and during exception propagation, pop the top
    // _frames_to_pop_failed_realloc frames, the ones that reference
    // failed reallocations.
    int _frames_to_pop_failed_realloc;
  
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-   int _jmp_ring_index;</span>
<span class="line-removed">-   struct {</span>
<span class="line-removed">-     // We use intptr_t instead of address so debugger doesn&#39;t try and display strings</span>
<span class="line-removed">-     intptr_t _target;</span>
<span class="line-removed">-     intptr_t _instruction;</span>
<span class="line-removed">-     const char*  _file;</span>
<span class="line-removed">-     int _line;</span>
<span class="line-removed">-   }   _jmp_ring[jump_ring_buffer_size];</span>
<span class="line-removed">- #endif // PRODUCT</span>
<span class="line-removed">- </span>
    friend class VMThread;
    friend class ThreadWaitTransition;
    friend class VM_Exit;
  
    void initialize();                             // Initialized the instance variables
<span class="line-new-header">--- 1191,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1217,11 ***</span>
    ~JavaThread();
  
  #ifdef ASSERT
    // verify this JavaThread hasn&#39;t be published in the Threads::list yet
    void verify_not_published();
<span class="line-modified">! #endif</span>
  
    //JNI functiontable getter/setter for JVMTI jni function table interception API.
    void set_jni_functions(struct JNINativeInterface_* functionTable) {
      _jni_environment.functions = functionTable;
    }
<span class="line-new-header">--- 1206,11 ---</span>
    ~JavaThread();
  
  #ifdef ASSERT
    // verify this JavaThread hasn&#39;t be published in the Threads::list yet
    void verify_not_published();
<span class="line-modified">! #endif // ASSERT</span>
  
    //JNI functiontable getter/setter for JVMTI jni function table interception API.
    void set_jni_functions(struct JNINativeInterface_* functionTable) {
      _jni_environment.functions = functionTable;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1241,27 ***</span>
      normal_exit,
      jni_detach
    };
    void exit(bool destroy_vm, ExitType exit_type = normal_exit);
  
<span class="line-modified">!   void cleanup_failed_attach_current_thread();</span>
  
    // Testers
    virtual bool is_Java_thread() const            { return true;  }
    virtual bool can_call_java() const             { return true; }
  
<span class="line-modified">!   // Thread chain operations</span>
<span class="line-modified">!   JavaThread* next() const                       { return _next; }</span>
<span class="line-modified">!   void set_next(JavaThread* p)                   { _next = p; }</span>
  
    // Thread oop. threadObj() can be NULL for initial JavaThread
    // (or for threads attached via JNI)
    oop threadObj() const                          { return _threadObj; }
    void set_threadObj(oop p)                      { _threadObj = p; }
  
<span class="line-removed">-   ThreadPriority java_priority() const;          // Read from threadObj()</span>
<span class="line-removed">- </span>
    // Prepare thread and add to priority queue.  If a priority is
    // not specified, use the priority of the thread object. Threads_lock
    // must be held while this function is called.
    void prepare(jobject jni_thread, ThreadPriority prio=NoPriority);
  
<span class="line-new-header">--- 1230,25 ---</span>
      normal_exit,
      jni_detach
    };
    void exit(bool destroy_vm, ExitType exit_type = normal_exit);
  
<span class="line-modified">!   void cleanup_failed_attach_current_thread(bool is_daemon);</span>
  
    // Testers
    virtual bool is_Java_thread() const            { return true;  }
    virtual bool can_call_java() const             { return true; }
  
<span class="line-modified">!   virtual bool is_active_Java_thread() const {</span>
<span class="line-modified">!     return on_thread_list() &amp;&amp; !is_terminated();</span>
<span class="line-modified">!   }</span>
  
    // Thread oop. threadObj() can be NULL for initial JavaThread
    // (or for threads attached via JNI)
    oop threadObj() const                          { return _threadObj; }
    void set_threadObj(oop p)                      { _threadObj = p; }
  
    // Prepare thread and add to priority queue.  If a priority is
    // not specified, use the priority of the thread object. Threads_lock
    // must be held while this function is called.
    void prepare(jobject jni_thread, ThreadPriority prio=NoPriority);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1287,10 ***</span>
<span class="line-new-header">--- 1274,11 ---</span>
    address last_Java_pc(void)                     { return _anchor.last_Java_pc(); }
  
    // Safepoint support
    inline JavaThreadState thread_state() const;
    inline void set_thread_state(JavaThreadState s);
<span class="line-added">+   inline void set_thread_state_fence(JavaThreadState s);  // fence after setting thread state</span>
    inline ThreadSafepointState* safepoint_state() const;
    inline void set_safepoint_state(ThreadSafepointState* state);
    inline bool is_at_poll_safepoint();
  
    // JavaThread termination and lifecycle support:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1336,24 ***</span>
  
    void handshake_process_by_self() {
      _handshake.process_by_self(this);
    }
  
<span class="line-modified">!   void handshake_process_by_vmthread() {</span>
<span class="line-modified">!     _handshake.process_by_vmthread(this);</span>
    }
  
    // Suspend/resume support for JavaThread
   private:
    inline void set_ext_suspended();
    inline void clear_ext_suspended();
  
   public:
<span class="line-modified">!   void java_suspend();</span>
<span class="line-modified">!   void java_resume();</span>
<span class="line-modified">!   int  java_suspend_self();</span>
  
    void check_and_wait_while_suspended() {
      assert(JavaThread::current() == this, &quot;sanity check&quot;);
  
      bool do_self_suspend;
      do {
<span class="line-new-header">--- 1324,36 ---</span>
  
    void handshake_process_by_self() {
      _handshake.process_by_self(this);
    }
  
<span class="line-modified">!   bool handshake_try_process_by_vmThread() {</span>
<span class="line-modified">!     return _handshake.try_process_by_vmThread(this);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+   bool is_vmthread_processing_handshake() const {</span>
<span class="line-added">+     return _handshake.is_vmthread_processing_handshake();</span>
    }
<span class="line-added">+ #endif</span>
  
    // Suspend/resume support for JavaThread
   private:
    inline void set_ext_suspended();
    inline void clear_ext_suspended();
  
   public:
<span class="line-modified">!   void java_suspend(); // higher-level suspension logic called by the public APIs</span>
<span class="line-modified">!   void java_resume();  // higher-level resume logic called by the public APIs</span>
<span class="line-modified">!   int  java_suspend_self(); // low-level self-suspension mechanics</span>
<span class="line-added">+ </span>
<span class="line-added">+  private:</span>
<span class="line-added">+   // mid-level wrapper around java_suspend_self to set up correct state and</span>
<span class="line-added">+   // check for a pending safepoint at the end</span>
<span class="line-added">+   void java_suspend_self_with_safepoint_check();</span>
  
<span class="line-added">+  public:</span>
    void check_and_wait_while_suspended() {
      assert(JavaThread::current() == this, &quot;sanity check&quot;);
  
      bool do_self_suspend;
      do {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1375,11 ***</span>
    // block.
    static void check_special_condition_for_native_trans_and_transition(JavaThread *thread);
  
    bool is_ext_suspend_completed(bool called_by_wait, int delay, uint32_t *bits);
    bool is_ext_suspend_completed_with_lock(uint32_t *bits) {
<span class="line-modified">!     MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      // Warning: is_ext_suspend_completed() may temporarily drop the
      // SR_lock to allow the thread to reach a stable thread state if
      // it is currently in a transient thread state.
      return is_ext_suspend_completed(false /* !called_by_wait */,
                                      SuspendRetryDelay, bits);
<span class="line-new-header">--- 1375,11 ---</span>
    // block.
    static void check_special_condition_for_native_trans_and_transition(JavaThread *thread);
  
    bool is_ext_suspend_completed(bool called_by_wait, int delay, uint32_t *bits);
    bool is_ext_suspend_completed_with_lock(uint32_t *bits) {
<span class="line-modified">!     MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      // Warning: is_ext_suspend_completed() may temporarily drop the
      // SR_lock to allow the thread to reach a stable thread state if
      // it is currently in a transient thread state.
      return is_ext_suspend_completed(false /* !called_by_wait */,
                                      SuspendRetryDelay, bits);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1397,39 ***</span>
    bool is_thread_fully_suspended(bool wait_for_suspend, uint32_t *bits);
  
    inline void set_external_suspend();
    inline void clear_external_suspend();
  
<span class="line-removed">-   inline void set_deopt_suspend();</span>
<span class="line-removed">-   inline void clear_deopt_suspend();</span>
<span class="line-removed">-   bool is_deopt_suspend()         { return (_suspend_flags &amp; _deopt_suspend) != 0; }</span>
<span class="line-removed">- </span>
    bool is_external_suspend() const {
      return (_suspend_flags &amp; _external_suspend) != 0;
    }
    // Whenever a thread transitions from native to vm/java it must suspend
    // if external|deopt suspend is present.
    bool is_suspend_after_native() const {
<span class="line-modified">!     return (_suspend_flags &amp; (_external_suspend | _deopt_suspend)) != 0;</span>
    }
  
    // external suspend request is completed
    bool is_ext_suspended() const {
      return (_suspend_flags &amp; _ext_suspended) != 0;
    }
  
    bool is_external_suspend_with_lock() const {
<span class="line-modified">!     MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      return is_external_suspend();
    }
  
    // Special method to handle a pending external suspend request
    // when a suspend equivalent condition lifts.
    bool handle_special_suspend_equivalent_condition() {
      assert(is_suspend_equivalent(),
             &quot;should only be called in a suspend equivalence condition&quot;);
<span class="line-modified">!     MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      bool ret = is_external_suspend();
      if (!ret) {
        // not about to self-suspend so clear suspend equivalence
        clear_suspend_equivalent();
      }
<span class="line-new-header">--- 1397,35 ---</span>
    bool is_thread_fully_suspended(bool wait_for_suspend, uint32_t *bits);
  
    inline void set_external_suspend();
    inline void clear_external_suspend();
  
    bool is_external_suspend() const {
      return (_suspend_flags &amp; _external_suspend) != 0;
    }
    // Whenever a thread transitions from native to vm/java it must suspend
    // if external|deopt suspend is present.
    bool is_suspend_after_native() const {
<span class="line-modified">!     return (_suspend_flags &amp; (_external_suspend JFR_ONLY(| _trace_flag))) != 0;</span>
    }
  
    // external suspend request is completed
    bool is_ext_suspended() const {
      return (_suspend_flags &amp; _ext_suspended) != 0;
    }
  
    bool is_external_suspend_with_lock() const {
<span class="line-modified">!     MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      return is_external_suspend();
    }
  
    // Special method to handle a pending external suspend request
    // when a suspend equivalent condition lifts.
    bool handle_special_suspend_equivalent_condition() {
      assert(is_suspend_equivalent(),
             &quot;should only be called in a suspend equivalence condition&quot;);
<span class="line-modified">!     MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      bool ret = is_external_suspend();
      if (!ret) {
        // not about to self-suspend so clear suspend equivalence
        clear_suspend_equivalent();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1442,11 ***</span>
      return ret;
    }
  
    // utility methods to see if we are doing some kind of suspension
    bool is_being_ext_suspended() const            {
<span class="line-modified">!     MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      return is_ext_suspended() || is_external_suspend();
    }
  
    bool is_suspend_equivalent() const             { return _suspend_equivalent; }
  
<span class="line-new-header">--- 1438,11 ---</span>
      return ret;
    }
  
    // utility methods to see if we are doing some kind of suspension
    bool is_being_ext_suspended() const            {
<span class="line-modified">!     MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      return is_ext_suspended() || is_external_suspend();
    }
  
    bool is_suspend_equivalent() const             { return _suspend_equivalent; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1510,14 ***</span>
    // The special resourceMark used during deoptimization
  
    void set_deopt_mark(DeoptResourceMark* value)  { _deopt_mark = value; }
    DeoptResourceMark* deopt_mark(void)            { return _deopt_mark; }
  
<span class="line-removed">-   intptr_t* must_deopt_id()                      { return _must_deopt_id; }</span>
<span class="line-removed">-   void     set_must_deopt_id(intptr_t* id)       { _must_deopt_id = id; }</span>
<span class="line-removed">-   void     clear_must_deopt_id()                 { _must_deopt_id = NULL; }</span>
<span class="line-removed">- </span>
    void set_deopt_compiled_method(CompiledMethod* nm)  { _deopt_nmethod = nm; }
    CompiledMethod* deopt_compiled_method()        { return _deopt_nmethod; }
  
    Method*    callee_target() const               { return _callee_target; }
    void set_callee_target  (Method* x)          { _callee_target   = x; }
<span class="line-new-header">--- 1506,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1532,17 ***</span>
    MemRegion deferred_card_mark() const           { return _deferred_card_mark; }
    void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }
  
  #if INCLUDE_JVMCI
    int  pending_deoptimization() const             { return _pending_deoptimization; }
<span class="line-modified">!   long pending_failed_speculation() const         { return _pending_failed_speculation; }</span>
<span class="line-removed">-   bool adjusting_comp_level() const               { return _adjusting_comp_level; }</span>
<span class="line-removed">-   void set_adjusting_comp_level(bool b)           { _adjusting_comp_level = b; }</span>
    bool has_pending_monitorenter() const           { return _pending_monitorenter; }
    void set_pending_monitorenter(bool b)           { _pending_monitorenter = b; }
    void set_pending_deoptimization(int reason)     { _pending_deoptimization = reason; }
<span class="line-modified">!   void set_pending_failed_speculation(long failed_speculation) { _pending_failed_speculation = failed_speculation; }</span>
    void set_pending_transfer_to_interpreter(bool b) { _pending_transfer_to_interpreter = b; }
    void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, &quot;must be&quot;); _jvmci._alternate_call_target = a; }
    void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, &quot;must be&quot;); _jvmci._implicit_exception_pc = a; }
  
    virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }
<span class="line-new-header">--- 1524,15 ---</span>
    MemRegion deferred_card_mark() const           { return _deferred_card_mark; }
    void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }
  
  #if INCLUDE_JVMCI
    int  pending_deoptimization() const             { return _pending_deoptimization; }
<span class="line-modified">!   jlong pending_failed_speculation() const        { return _pending_failed_speculation; }</span>
    bool has_pending_monitorenter() const           { return _pending_monitorenter; }
    void set_pending_monitorenter(bool b)           { _pending_monitorenter = b; }
    void set_pending_deoptimization(int reason)     { _pending_deoptimization = reason; }
<span class="line-modified">!   void set_pending_failed_speculation(jlong failed_speculation) { _pending_failed_speculation = failed_speculation; }</span>
    void set_pending_transfer_to_interpreter(bool b) { _pending_transfer_to_interpreter = b; }
    void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, &quot;must be&quot;); _jvmci._alternate_call_target = a; }
    void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, &quot;must be&quot;); _jvmci._implicit_exception_pc = a; }
  
    virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1738,25 ***</span>
    void set_stack_overflow_limit() {
      _stack_overflow_limit =
        stack_end() + MAX2(JavaThread::stack_guard_zone_size(), JavaThread::stack_shadow_zone_size());
    }
  
    // Misc. accessors/mutators
    void set_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = true; }
    void clr_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = false; }
    bool do_not_unlock(void)                       { return _do_not_unlock_if_synchronized; }
  
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-   void record_jump(address target, address instr, const char* file, int line);</span>
<span class="line-removed">- #endif // PRODUCT</span>
<span class="line-removed">- </span>
    // For assembly stub generation
    static ByteSize threadObj_offset()             { return byte_offset_of(JavaThread, _threadObj); }
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-   static ByteSize jmp_ring_index_offset()        { return byte_offset_of(JavaThread, _jmp_ring_index); }</span>
<span class="line-removed">-   static ByteSize jmp_ring_offset()              { return byte_offset_of(JavaThread, _jmp_ring); }</span>
<span class="line-removed">- #endif // PRODUCT</span>
    static ByteSize jni_environment_offset()       { return byte_offset_of(JavaThread, _jni_environment); }
    static ByteSize pending_jni_exception_check_fn_offset() {
      return byte_offset_of(JavaThread, _pending_jni_exception_check_fn);
    }
    static ByteSize last_Java_sp_offset() {
<span class="line-new-header">--- 1728,22 ---</span>
    void set_stack_overflow_limit() {
      _stack_overflow_limit =
        stack_end() + MAX2(JavaThread::stack_guard_zone_size(), JavaThread::stack_shadow_zone_size());
    }
  
<span class="line-added">+   // Check if address is in the usable part of the stack (excludes protected</span>
<span class="line-added">+   // guard pages). Can be applied to any thread and is an approximation for</span>
<span class="line-added">+   // using is_in_stack when the query has to happen from another thread.</span>
<span class="line-added">+   bool is_in_usable_stack(address adr) const;</span>
<span class="line-added">+ </span>
    // Misc. accessors/mutators
    void set_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = true; }
    void clr_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = false; }
    bool do_not_unlock(void)                       { return _do_not_unlock_if_synchronized; }
  
    // For assembly stub generation
    static ByteSize threadObj_offset()             { return byte_offset_of(JavaThread, _threadObj); }
    static ByteSize jni_environment_offset()       { return byte_offset_of(JavaThread, _jni_environment); }
    static ByteSize pending_jni_exception_check_fn_offset() {
      return byte_offset_of(JavaThread, _pending_jni_exception_check_fn);
    }
    static ByteSize last_Java_sp_offset() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1793,10 ***</span>
<span class="line-new-header">--- 1780,11 ---</span>
  
    static ByteSize do_not_unlock_if_synchronized_offset() { return byte_offset_of(JavaThread, _do_not_unlock_if_synchronized); }
    static ByteSize should_post_on_exceptions_flag_offset() {
      return byte_offset_of(JavaThread, _should_post_on_exceptions_flag);
    }
<span class="line-added">+   static ByteSize doing_unsafe_access_offset() { return byte_offset_of(JavaThread, _doing_unsafe_access); }</span>
  
    // Returns the jni environment for this thread
    JNIEnv* jni_environment()                      { return &amp;_jni_environment; }
  
    static JavaThread* thread_from_jni_environment(JNIEnv* env) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1864,30 ***</span>
  
    // Sweeper operations
    virtual void nmethods_do(CodeBlobClosure* cf);
  
    // RedefineClasses Support
<span class="line-modified">!   void metadata_do(void f(Metadata*));</span>
  
    // Misc. operations
    char* name() const { return (char*)get_thread_name(); }
    void print_on(outputStream* st, bool print_extended_info) const;
    void print_on(outputStream* st) const { print_on(st, false); }
<span class="line-modified">!   void print_value();</span>
    void print_thread_state_on(outputStream*) const      PRODUCT_RETURN;
<span class="line-removed">-   void print_thread_state() const                      PRODUCT_RETURN;</span>
    void print_on_error(outputStream* st, char* buf, int buflen) const;
    void print_name_on_error(outputStream* st, char* buf, int buflen) const;
    void verify();
    const char* get_thread_name() const;
   protected:
    // factor out low-level mechanics for use in both normal and error cases
    virtual const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;
   public:
<span class="line-removed">-   const char* get_threadgroup_name() const;</span>
<span class="line-removed">-   const char* get_parent_name() const;</span>
<span class="line-removed">- </span>
    // Accessing frames
    frame last_frame() {
      _anchor.make_walkable(this);
      return pd_last_frame();
    }
<span class="line-new-header">--- 1852,29 ---</span>
  
    // Sweeper operations
    virtual void nmethods_do(CodeBlobClosure* cf);
  
    // RedefineClasses Support
<span class="line-modified">!   void metadata_do(MetadataClosure* f);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Debug method asserting thread states are correct during a handshake operation.</span>
<span class="line-added">+   DEBUG_ONLY(void verify_states_for_handshake();)</span>
  
    // Misc. operations
    char* name() const { return (char*)get_thread_name(); }
    void print_on(outputStream* st, bool print_extended_info) const;
    void print_on(outputStream* st) const { print_on(st, false); }
<span class="line-modified">!   void print() const;</span>
    void print_thread_state_on(outputStream*) const      PRODUCT_RETURN;
    void print_on_error(outputStream* st, char* buf, int buflen) const;
    void print_name_on_error(outputStream* st, char* buf, int buflen) const;
    void verify();
    const char* get_thread_name() const;
   protected:
    // factor out low-level mechanics for use in both normal and error cases
    virtual const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;
   public:
    // Accessing frames
    frame last_frame() {
      _anchor.make_walkable(this);
      return pd_last_frame();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1903,26 ***</span>
  
    // Print stack traces in various internal formats
    void trace_stack()                             PRODUCT_RETURN;
    void trace_stack_from(vframe* start_vf)        PRODUCT_RETURN;
    void trace_frames()                            PRODUCT_RETURN;
<span class="line-removed">-   void trace_oops()                              PRODUCT_RETURN;</span>
  
    // Print an annotated view of the stack frames
    void print_frame_layout(int depth = 0, bool validate_only = false) NOT_DEBUG_RETURN;
    void validate_frame_layout() {
      print_frame_layout(0, true);
    }
  
<span class="line-removed">-   // Returns the number of stack frames on the stack</span>
<span class="line-removed">-   int depth() const;</span>
<span class="line-removed">- </span>
    // Function for testing deoptimization
    void deoptimize();
    void make_zombies();
  
<span class="line-modified">!   void deoptimized_wrt_marked_nmethods();</span>
  
   public:
    // Returns the running thread as a JavaThread
    static inline JavaThread* current();
  
<span class="line-new-header">--- 1890,22 ---</span>
  
    // Print stack traces in various internal formats
    void trace_stack()                             PRODUCT_RETURN;
    void trace_stack_from(vframe* start_vf)        PRODUCT_RETURN;
    void trace_frames()                            PRODUCT_RETURN;
  
    // Print an annotated view of the stack frames
    void print_frame_layout(int depth = 0, bool validate_only = false) NOT_DEBUG_RETURN;
    void validate_frame_layout() {
      print_frame_layout(0, true);
    }
  
    // Function for testing deoptimization
    void deoptimize();
    void make_zombies();
  
<span class="line-modified">!   void deoptimize_marked_methods();</span>
  
   public:
    // Returns the running thread as a JavaThread
    static inline JavaThread* current();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2057,22 ***</span>
    }
  
    // Machine dependent stuff
  #include OS_CPU_HEADER(thread)
  
<span class="line-removed">-  public:</span>
<span class="line-removed">-   void set_blocked_on_compilation(bool value) {</span>
<span class="line-removed">-     _blocked_on_compilation = value;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool blocked_on_compilation() {</span>
<span class="line-removed">-     return _blocked_on_compilation;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-  protected:</span>
<span class="line-removed">-   bool         _blocked_on_compilation;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
    // JSR166 per-thread parker
   private:
    Parker*    _parker;
   public:
    Parker*     parker() { return _parker; }
<span class="line-new-header">--- 2040,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2096,10 ***</span>
<span class="line-new-header">--- 2067,19 ---</span>
    InstanceKlass* class_to_be_initialized() const;
  
  private:
    InstanceKlass* _class_to_be_initialized;
  
<span class="line-added">+   // java.lang.Thread.sleep support</span>
<span class="line-added">+   ParkEvent * _SleepEvent;</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   bool sleep(jlong millis);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // java.lang.Thread interruption support</span>
<span class="line-added">+   void interrupt();</span>
<span class="line-added">+   bool is_interrupted(bool clear_interrupted);</span>
<span class="line-added">+ </span>
  };
  
  // Inline implementation of JavaThread::current
  inline JavaThread* JavaThread::current() {
    Thread* thread = Thread::current();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2208,15 ***</span>
  // The active thread queue. It also keeps track of the current used
  // thread priorities.
  class Threads: AllStatic {
    friend class VMStructs;
   private:
<span class="line-removed">-   static JavaThread* _thread_list;</span>
    static int         _number_of_threads;
    static int         _number_of_non_daemon_threads;
    static int         _return_code;
<span class="line-modified">!   static int         _thread_claim_parity;</span>
  #ifdef ASSERT
    static bool        _vm_complete;
  #endif
  
    static void initialize_java_lang_classes(JavaThread* main_thread, TRAPS);
<span class="line-new-header">--- 2188,14 ---</span>
  // The active thread queue. It also keeps track of the current used
  // thread priorities.
  class Threads: AllStatic {
    friend class VMStructs;
   private:
    static int         _number_of_threads;
    static int         _number_of_non_daemon_threads;
    static int         _return_code;
<span class="line-modified">!   static uintx       _thread_claim_token;</span>
  #ifdef ASSERT
    static bool        _vm_complete;
  #endif
  
    static void initialize_java_lang_classes(JavaThread* main_thread, TRAPS);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2225,11 ***</span>
   public:
    // Thread management
    // force_daemon is a concession to JNI, where we may need to add a
    // thread to the thread list before allocating its thread object
    static void add(JavaThread* p, bool force_daemon = false);
<span class="line-modified">!   static void remove(JavaThread* p);</span>
    static void non_java_threads_do(ThreadClosure* tc);
    static void java_threads_do(ThreadClosure* tc);
    static void java_threads_and_vm_thread_do(ThreadClosure* tc);
    static void threads_do(ThreadClosure* tc);
    static void possibly_parallel_threads_do(bool is_par, ThreadClosure* tc);
<span class="line-new-header">--- 2204,11 ---</span>
   public:
    // Thread management
    // force_daemon is a concession to JNI, where we may need to add a
    // thread to the thread list before allocating its thread object
    static void add(JavaThread* p, bool force_daemon = false);
<span class="line-modified">!   static void remove(JavaThread* p, bool is_daemon);</span>
    static void non_java_threads_do(ThreadClosure* tc);
    static void java_threads_do(ThreadClosure* tc);
    static void java_threads_and_vm_thread_do(ThreadClosure* tc);
    static void threads_do(ThreadClosure* tc);
    static void possibly_parallel_threads_do(bool is_par, ThreadClosure* tc);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2245,45 ***</span>
    // Includes JNI_VERSION_1_1
    static jboolean is_supported_jni_version_including_1_1(jint version);
    // Does not include JNI_VERSION_1_1
    static jboolean is_supported_jni_version(jint version);
  
<span class="line-modified">!   // The &quot;thread claim parity&quot; provides a way for threads to be claimed</span>
    // by parallel worker tasks.
    //
<span class="line-modified">!   // Each thread contains a &quot;parity&quot; field. A task will claim the</span>
<span class="line-modified">!   // thread only if its parity field is the same as the global parity,</span>
<span class="line-modified">!   // which is updated by calling change_thread_claim_parity().</span>
    //
<span class="line-modified">!   // For this to work change_thread_claim_parity() needs to be called</span>
    // exactly once in sequential code before starting parallel tasks
    // that should claim threads.
    //
<span class="line-modified">!   // New threads get their parity set to 0 and change_thread_claim_parity()</span>
<span class="line-modified">!   // never sets the global parity to 0.</span>
<span class="line-modified">!   static int thread_claim_parity() { return _thread_claim_parity; }</span>
<span class="line-modified">!   static void change_thread_claim_parity();</span>
    static void assert_all_threads_claimed() NOT_DEBUG_RETURN;
  
    // Apply &quot;f-&gt;do_oop&quot; to all root oops in all threads.
    // This version may only be called by sequential code.
    static void oops_do(OopClosure* f, CodeBlobClosure* cf);
    // This version may be called by sequential or parallel code.
    static void possibly_parallel_oops_do(bool is_par, OopClosure* f, CodeBlobClosure* cf);
  
<span class="line-removed">-   // Apply &quot;f-&gt;do_oop&quot; to roots in all threads that</span>
<span class="line-removed">-   // are part of compiled frames</span>
<span class="line-removed">-   static void compiled_frame_oops_do(OopClosure* f, CodeBlobClosure* cf);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static void convert_hcode_pointers();</span>
<span class="line-removed">-   static void restore_hcode_pointers();</span>
<span class="line-removed">- </span>
    // Sweeper
    static void nmethods_do(CodeBlobClosure* cf);
  
    // RedefineClasses support
<span class="line-modified">!   static void metadata_do(void f(Metadata*));</span>
    static void metadata_handles_do(void f(Metadata*));
  
  #ifdef ASSERT
    static bool is_vm_complete() { return _vm_complete; }
  #endif // ASSERT
<span class="line-new-header">--- 2224,40 ---</span>
    // Includes JNI_VERSION_1_1
    static jboolean is_supported_jni_version_including_1_1(jint version);
    // Does not include JNI_VERSION_1_1
    static jboolean is_supported_jni_version(jint version);
  
<span class="line-modified">!   // The &quot;thread claim token&quot; provides a way for threads to be claimed</span>
    // by parallel worker tasks.
    //
<span class="line-modified">!   // Each thread contains a &quot;token&quot; field. A task will claim the</span>
<span class="line-modified">!   // thread only if its token is different from the global token,</span>
<span class="line-modified">!   // which is updated by calling change_thread_claim_token().  When</span>
<span class="line-added">+   // a thread is claimed, it&#39;s token is set to the global token value</span>
<span class="line-added">+   // so other threads in the same iteration pass won&#39;t claim it.</span>
    //
<span class="line-modified">!   // For this to work change_thread_claim_token() needs to be called</span>
    // exactly once in sequential code before starting parallel tasks
    // that should claim threads.
    //
<span class="line-modified">!   // New threads get their token set to 0 and change_thread_claim_token()</span>
<span class="line-modified">!   // never sets the global token to 0.</span>
<span class="line-modified">!   static uintx thread_claim_token() { return _thread_claim_token; }</span>
<span class="line-modified">!   static void change_thread_claim_token();</span>
    static void assert_all_threads_claimed() NOT_DEBUG_RETURN;
  
    // Apply &quot;f-&gt;do_oop&quot; to all root oops in all threads.
    // This version may only be called by sequential code.
    static void oops_do(OopClosure* f, CodeBlobClosure* cf);
    // This version may be called by sequential or parallel code.
    static void possibly_parallel_oops_do(bool is_par, OopClosure* f, CodeBlobClosure* cf);
  
    // Sweeper
    static void nmethods_do(CodeBlobClosure* cf);
  
    // RedefineClasses support
<span class="line-modified">!   static void metadata_do(MetadataClosure* f);</span>
    static void metadata_handles_do(void f(Metadata*));
  
  #ifdef ASSERT
    static bool is_vm_complete() { return _vm_complete; }
  #endif // ASSERT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2313,17 ***</span>
    // Number of non-daemon threads on the active threads list
    static int number_of_non_daemon_threads()      { return _number_of_non_daemon_threads; }
  
    // Deoptimizes all frames tied to marked nmethods
    static void deoptimized_wrt_marked_nmethods();
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  
<span class="line-modified">! // Thread iterator</span>
<span class="line-removed">- class ThreadClosure: public StackObj {</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   virtual void do_thread(Thread* thread) = 0;</span>
  };
  
  class SignalHandlerMark: public StackObj {
   private:
    Thread* _thread;
<span class="line-new-header">--- 2287,12 ---</span>
    // Number of non-daemon threads on the active threads list
    static int number_of_non_daemon_threads()      { return _number_of_non_daemon_threads; }
  
    // Deoptimizes all frames tied to marked nmethods
    static void deoptimized_wrt_marked_nmethods();
  
<span class="line-modified">!   struct Test;                  // For private gtest access.</span>
  };
  
  class SignalHandlerMark: public StackObj {
   private:
    Thread* _thread;
</pre>
<center><a href="thread.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
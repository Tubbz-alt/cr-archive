<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/runtime/perfMemory.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_PERFMEMORY_HPP
 26 #define SHARE_RUNTIME_PERFMEMORY_HPP
 27 
 28 #include &quot;runtime/globals.hpp&quot;
 29 #include &quot;utilities/exceptions.hpp&quot;
 30 
 31 /*
 32  * PerfData Version Constants
 33  *   - Major Version - change whenever the structure of PerfDataEntry changes
 34  *   - Minor Version - change whenever the data within the PerfDataEntry
 35  *                     structure changes. for example, new unit or variability
 36  *                     values are added or new PerfData subtypes are added.
 37  */
 38 #define PERFDATA_MAJOR_VERSION 2
 39 #define PERFDATA_MINOR_VERSION 0
 40 
 41 /* Byte order of the PerfData memory region. The byte order is exposed in
 42  * the PerfData memory region as the data in the memory region may have
 43  * been generated by a little endian JVM implementation. Tracking the byte
 44  * order in the PerfData memory region allows Java applications to adapt
 45  * to the native byte order for monitoring purposes. This indicator is
 46  * also useful when a snapshot of the PerfData memory region is shipped
 47  * to a machine with a native byte order different from that of the
 48  * originating machine.
 49  */
 50 #define PERFDATA_BIG_ENDIAN     0
 51 #define PERFDATA_LITTLE_ENDIAN  1
 52 
 53 /*
 54  * The PerfDataPrologue structure is known by the PerfDataBuffer Java class
 55  * libraries that read the PerfData memory region. The size and the position
 56  * of the fields must be changed along with their counterparts in the
 57  * PerfDataBuffer Java class. The first four bytes of this structure
 58  * should never change, or compatibility problems between the monitoring
 59  * applications and HotSpot VMs will result. The reserved fields are
 60  * available for future enhancements.
 61  */
 62 typedef struct {
 63   jint   magic;              // magic number - 0xcafec0c0
 64   jbyte  byte_order;         // byte order of the buffer
 65   jbyte  major_version;      // major and minor version numbers
 66   jbyte  minor_version;
 67   jbyte  accessible;         // ready to access
 68   jint   used;               // number of PerfData memory bytes used
 69   jint   overflow;           // number of bytes of overflow
 70   jlong  mod_time_stamp;     // time stamp of last structural modification
 71   jint   entry_offset;       // offset of the first PerfDataEntry
 72   jint   num_entries;        // number of allocated PerfData entries
 73 } PerfDataPrologue;
 74 
 75 /* The PerfDataEntry structure defines the fixed portion of an entry
 76  * in the PerfData memory region. The PerfDataBuffer Java libraries
 77  * are aware of this structure and need to be changed when this
 78  * structure changes.
 79  */
 80 typedef struct {
 81 
 82   jint entry_length;      // entry length in bytes
 83   jint name_offset;       // offset of the data item name
 84   jint vector_length;     // length of the vector. If 0, then scalar
 85   jbyte data_type;        // type of the data item -
 86                           // &#39;B&#39;,&#39;Z&#39;,&#39;J&#39;,&#39;I&#39;,&#39;S&#39;,&#39;C&#39;,&#39;D&#39;,&#39;F&#39;,&#39;V&#39;,&#39;L&#39;,&#39;[&#39;
 87   jbyte flags;            // flags indicating misc attributes
 88   jbyte data_units;       // unit of measure for the data type
 89   jbyte data_variability; // variability classification of data type
 90   jint  data_offset;      // offset of the data item
 91 
 92 /*
 93   body of PerfData memory entry is variable length
 94 
 95   jbyte[name_length] data_name;        // name of the data item
 96   jbyte[pad_length] data_pad;          // alignment of data item
 97   j&lt;data_type&gt;[data_length] data_item; // array of appropriate types.
 98                                        // data_length is &gt; 1 only when the
 99                                        // data_type is T_ARRAY.
100 */
101 } PerfDataEntry;
102 
103 // Prefix of performance data file.
104 extern const char PERFDATA_NAME[];
105 
106 // UINT_CHARS contains the number of characters holding a process id
107 // (i.e. pid). pid is defined as unsigned &quot;int&quot; so the maximum possible pid value
108 // would be 2^32 - 1 (4294967295) which can be represented as a 10 characters
109 // string.
110 static const size_t UINT_CHARS = 10;
111 
112 /* the PerfMemory class manages creation, destruction,
113  * and allocation of the PerfData region.
114  */
115 class PerfMemory : AllStatic {
116     friend class VMStructs;
117     friend class PerfMemoryTest;
118   private:
119     static char*  _start;
120     static char*  _end;
121     static char*  _top;
122     static size_t _capacity;
123     static PerfDataPrologue*  _prologue;
124     static int    _initialized;
125     static bool   _destroyed;
126 
127     static void create_memory_region(size_t sizep);
128     static void delete_memory_region();
129 
130   public:
131     enum PerfMemoryMode {
132       PERF_MODE_RO = 0,
133       PERF_MODE_RW = 1
134     };
135 
136     static char* alloc(size_t size);
137     static char* start() { return _start; }
138     static char* end() { return _end; }
139     static size_t used() { return (size_t) (_top - _start); }
140     static size_t capacity() { return _capacity; }
141     static bool is_initialized();
142     static bool is_destroyed() { return _destroyed; }
143     static bool is_usable() { return is_initialized() &amp;&amp; !is_destroyed(); }
144     static bool contains(char* addr) {
145       return ((_start != NULL) &amp;&amp; (addr &gt;= _start) &amp;&amp; (addr &lt; _end));
146     }
147     static void mark_updated();
148 
149     // methods for attaching to and detaching from the PerfData
150     // memory segment of another JVM process on the same system.
151     static void attach(const char* user, int vmid, PerfMemoryMode mode,
152                        char** addrp, size_t* size, TRAPS);
153     static void detach(char* addr, size_t bytes, TRAPS);
154 
155     static void initialize();
156     static void destroy();
157     static void set_accessible(bool value) {
158       if (UsePerfData) {
159         _prologue-&gt;accessible = value;
160       }
161     }
162 
163     // returns the complete file path of hsperfdata.
164     // the caller is expected to free the allocated memory.
165     static char* get_perfdata_file_path();
166 };
167 
168 void perfMemory_init();
169 void perfMemory_exit();
170 
171 #endif // SHARE_RUNTIME_PERFMEMORY_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/mutex.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memprofiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutex.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/mutex.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 28 #include &quot;runtime/mutex.hpp&quot;
 29 #include &quot;runtime/osThread.hpp&quot;
 30 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
 31 #include &quot;runtime/thread.inline.hpp&quot;
 32 #include &quot;utilities/events.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 














 35 
<span class="line-modified"> 36 void Monitor::lock(Thread * self) {</span>
<span class="line-modified"> 37   // Ensure that the Monitor requires/allows safepoint checks.</span>
<span class="line-modified"> 38   assert(_safepoint_check_required != Monitor::_safepoint_check_never,</span>
<span class="line-modified"> 39          &quot;This lock should never have a safepoint check: %s&quot;, name());</span>

 40 
<span class="line-modified"> 41 #ifdef CHECK_UNHANDLED_OOPS</span>
<span class="line-modified"> 42   // Clear unhandled oops in JavaThreads so we get a crash right away.</span>
<span class="line-modified"> 43   if (self-&gt;is_Java_thread()) {</span>
<span class="line-modified"> 44     self-&gt;clear_unhandled_oops();</span>


 45   }
<span class="line-modified"> 46 #endif // CHECK_UNHANDLED_OOPS</span>
 47 
<span class="line-modified"> 48   DEBUG_ONLY(check_prelock_state(self, StrictSafepointChecks));</span>
<span class="line-modified"> 49   assert(_owner != self, &quot;invariant&quot;);</span>





 50 
<span class="line-modified"> 51   Monitor* in_flight_monitor = NULL;</span>

 52   DEBUG_ONLY(int retry_cnt = 0;)
<span class="line-modified"> 53   while (!_lock.try_lock()) {</span>
<span class="line-modified"> 54     // The lock is contended</span>
<span class="line-modified"> 55 </span>
<span class="line-removed"> 56   #ifdef ASSERT</span>
<span class="line-removed"> 57     check_block_state(self);</span>
 58     if (retry_cnt++ &gt; 3) {
<span class="line-modified"> 59       log_trace(vmmonitor)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; on %d attempt trying to acquire vmmonitor %s&quot;, p2i(self), retry_cnt, _name);</span>
 60     }
<span class="line-modified"> 61   #endif // ASSERT</span>
 62 
<span class="line-modified"> 63     if (self-&gt;is_Java_thread()) {</span>

 64       assert(rank() &gt; Mutex::special, &quot;Potential deadlock with special or lesser rank mutex&quot;);
<span class="line-modified"> 65       { ThreadBlockInVMWithDeadlockCheck tbivmdc((JavaThread *) self, &amp;in_flight_monitor);</span>
<span class="line-modified"> 66         in_flight_monitor = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
 67         _lock.lock();
 68       }
<span class="line-modified"> 69       if (in_flight_monitor != NULL) {</span>
 70         // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck
 71         break;
 72       }
 73     } else {
 74       _lock.lock();
 75       break;
 76     }











 77   }
 78 
 79   assert_owner(NULL);
 80   set_owner(self);
 81 }
 82 
<span class="line-modified"> 83 void Monitor::lock() {</span>
<span class="line-modified"> 84   this-&gt;lock(Thread::current());</span>
 85 }
 86 
 87 // Lock without safepoint check - a degenerate variant of lock() for use by
 88 // JavaThreads when it is known to be safe to not check for a safepoint when
 89 // acquiring this lock. If the thread blocks acquiring the lock it is not
 90 // safepoint-safe and so will prevent a safepoint from being reached. If used
 91 // in the wrong way this can lead to a deadlock with the safepoint code.
 92 
<span class="line-modified"> 93 void Monitor::lock_without_safepoint_check(Thread * self) {</span>
<span class="line-modified"> 94   // Ensure that the Monitor does not require safepoint checks.</span>
<span class="line-removed"> 95   assert(_safepoint_check_required != Monitor::_safepoint_check_always,</span>
<span class="line-removed"> 96          &quot;This lock should always have a safepoint check: %s&quot;, name());</span>
 97   assert(_owner != self, &quot;invariant&quot;);
 98   _lock.lock();
 99   assert_owner(NULL);
100   set_owner(self);
101 }
102 
<span class="line-modified">103 void Monitor::lock_without_safepoint_check() {</span>
104   lock_without_safepoint_check(Thread::current());
105 }
106 
107 
108 // Returns true if thread succeeds in grabbing the lock, otherwise false.
109 
<span class="line-modified">110 bool Monitor::try_lock() {</span>
111   Thread * const self = Thread::current();
<span class="line-modified">112   DEBUG_ONLY(check_prelock_state(self, false);)</span>
<span class="line-modified">113 </span>

114   if (_lock.try_lock()) {
115     assert_owner(NULL);
116     set_owner(self);
117     return true;
118   }
119   return false;
120 }
121 
<span class="line-modified">122 void Monitor::release_for_safepoint() {</span>
123   assert_owner(NULL);
124   _lock.unlock();
125 }
126 
<span class="line-modified">127 void Monitor::unlock() {</span>
<span class="line-modified">128   assert_owner(Thread::current());</span>
129   set_owner(NULL);
130   _lock.unlock();
131 }
132 
133 void Monitor::notify() {
<span class="line-modified">134   assert_owner(Thread::current());</span>
135   _lock.notify();
136 }
137 
138 void Monitor::notify_all() {
<span class="line-modified">139   assert_owner(Thread::current());</span>
140   _lock.notify_all();
141 }
142 
<span class="line-modified">143 bool Monitor::wait(bool no_safepoint_check, long timeout,</span>
<span class="line-modified">144                    bool as_suspend_equivalent) {</span>
<span class="line-modified">145   // Make sure safepoint checking is used properly.</span>
<span class="line-removed">146   assert(!(_safepoint_check_required == Monitor::_safepoint_check_never &amp;&amp; no_safepoint_check == false),</span>
<span class="line-removed">147          &quot;This lock should never have a safepoint check: %s&quot;, name());</span>
<span class="line-removed">148   assert(!(_safepoint_check_required == Monitor::_safepoint_check_always &amp;&amp; no_safepoint_check == true),</span>
<span class="line-removed">149          &quot;This lock should always have a safepoint check: %s&quot;, name());</span>
<span class="line-removed">150 </span>
<span class="line-removed">151   // timeout is in milliseconds - with zero meaning never timeout</span>
<span class="line-removed">152   assert(timeout &gt;= 0, &quot;negative timeout&quot;);</span>
<span class="line-removed">153 </span>
<span class="line-removed">154   Thread * const self = Thread::current();</span>
<span class="line-removed">155   assert_owner(self);</span>
<span class="line-removed">156 </span>
<span class="line-removed">157   // as_suspend_equivalent logically implies !no_safepoint_check</span>
<span class="line-removed">158   guarantee(!as_suspend_equivalent || !no_safepoint_check, &quot;invariant&quot;);</span>
<span class="line-removed">159   // !no_safepoint_check logically implies java_thread</span>
<span class="line-removed">160   guarantee(no_safepoint_check || self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">161 </span>
<span class="line-removed">162   #ifdef ASSERT</span>
<span class="line-removed">163   Monitor * least = get_least_ranked_lock_besides_this(self-&gt;owned_locks());</span>
164   assert(least != this, &quot;Specification of get_least_... call above&quot;);
165   if (least != NULL &amp;&amp; least-&gt;rank() &lt;= special) {
166     ::tty-&gt;print(&quot;Attempting to wait on monitor %s/%d while holding&quot;
167                &quot; lock %s/%d -- possible deadlock&quot;,
168                name(), rank(), least-&gt;name(), least-&gt;rank());
169     assert(false, &quot;Shouldn&#39;t block(wait) while holding a lock of rank special&quot;);
170   }
<span class="line-modified">171   #endif // ASSERT</span>










172 
<span class="line-removed">173   int wait_status;</span>
174   // conceptually set the owner to NULL in anticipation of
175   // abdicating the lock in wait
176   set_owner(NULL);
<span class="line-modified">177   if (no_safepoint_check) {</span>
<span class="line-modified">178     wait_status = _lock.wait(timeout);</span>
<span class="line-removed">179     set_owner(self);</span>
<span class="line-removed">180   } else {</span>
<span class="line-removed">181     assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">182     JavaThread *jt = (JavaThread *)self;</span>
<span class="line-removed">183     Monitor* in_flight_monitor = NULL;</span>
<span class="line-removed">184 </span>
<span class="line-removed">185     {</span>
<span class="line-removed">186       ThreadBlockInVMWithDeadlockCheck tbivmdc(jt, &amp;in_flight_monitor);</span>
<span class="line-removed">187       OSThreadWaitState osts(self-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-removed">188       if (as_suspend_equivalent) {</span>
<span class="line-removed">189         jt-&gt;set_suspend_equivalent();</span>
<span class="line-removed">190         // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-removed">191         // java_suspend_self()</span>
<span class="line-removed">192       }</span>
193 
<span class="line-modified">194       wait_status = _lock.wait(timeout);</span>
<span class="line-modified">195       in_flight_monitor = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">196 </span>
<span class="line-modified">197       // were we externally suspended while we were waiting?</span>
<span class="line-modified">198       if (as_suspend_equivalent &amp;&amp; jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">199         // Our event wait has finished and we own the lock, but</span>
<span class="line-modified">200         // while we were waiting another thread suspended us. We don&#39;t</span>
<span class="line-modified">201         // want to hold the lock while suspended because that</span>
<span class="line-modified">202         // would surprise the thread that suspended us.</span>
<span class="line-modified">203         _lock.unlock();</span>
<span class="line-modified">204         jt-&gt;java_suspend_self();</span>
<span class="line-modified">205         _lock.lock();</span>
<span class="line-modified">206       }</span>




















207     }
208 
<span class="line-modified">209     if (in_flight_monitor != NULL) {</span>
<span class="line-modified">210       // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">211       assert_owner(NULL);</span>
<span class="line-modified">212       // Conceptually reestablish ownership of the lock.</span>
<span class="line-modified">213       set_owner(self);</span>
<span class="line-modified">214     } else {</span>
<span class="line-modified">215       lock(self);</span>





216     }
217   }
<span class="line-removed">218   return wait_status != 0;          // return true IFF timeout</span>
<span class="line-removed">219 }</span>
<span class="line-removed">220 </span>
221 
<span class="line-modified">222 // Temporary JVM_RawMonitor* support.</span>
<span class="line-modified">223 // Yet another degenerate version of Monitor::lock() or lock_without_safepoint_check()</span>
<span class="line-modified">224 // jvm_raw_lock() and _unlock() can be called by non-Java threads via JVM_RawMonitorEnter.</span>
<span class="line-modified">225 // There&#39;s no expectation that JVM_RawMonitors will interoperate properly with the native</span>
<span class="line-modified">226 // Mutex-Monitor constructs.  We happen to implement JVM_RawMonitors in terms of</span>
<span class="line-modified">227 // native Mutex-Monitors simply as a matter of convenience.</span>


228 
<span class="line-modified">229 void Monitor::jvm_raw_lock() {</span>
<span class="line-removed">230   _lock.lock();</span>
<span class="line-removed">231   assert_owner(NULL);</span>
232 }
233 
<span class="line-modified">234 void Monitor::jvm_raw_unlock() {</span>
235   assert_owner(NULL);
<span class="line-removed">236   _lock.unlock();</span>
237 }
238 
<span class="line-modified">239 Monitor::~Monitor() {</span>
<span class="line-modified">240   assert_owner(NULL);</span>

241 }
242 
<span class="line-modified">243 void Monitor::ClearMonitor(Monitor * m, const char *name) {</span>
<span class="line-modified">244   m-&gt;_owner             = NULL;</span>

245   if (name == NULL) {
<span class="line-modified">246     strcpy(m-&gt;_name, &quot;UNKNOWN&quot;);</span>
247   } else {
<span class="line-modified">248     strncpy(m-&gt;_name, name, MONITOR_NAME_LEN - 1);</span>
<span class="line-modified">249     m-&gt;_name[MONITOR_NAME_LEN - 1] = &#39;\0&#39;;</span>
250   }
<span class="line-removed">251 }</span>
<span class="line-removed">252 </span>
<span class="line-removed">253 Monitor::Monitor() {</span>
<span class="line-removed">254   assert(os::mutex_init_done(), &quot;Too early!&quot;);</span>
<span class="line-removed">255   ClearMonitor(this);</span>
<span class="line-removed">256 }</span>
<span class="line-removed">257 </span>
<span class="line-removed">258 Monitor::Monitor(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-removed">259                  SafepointCheckRequired safepoint_check_required) {</span>
<span class="line-removed">260   assert(os::mutex_init_done(), &quot;Too early!&quot;);</span>
<span class="line-removed">261   ClearMonitor(this, name);</span>
262 #ifdef ASSERT
263   _allow_vm_block  = allow_vm_block;
264   _rank            = Rank;
<span class="line-modified">265   NOT_PRODUCT(_safepoint_check_required = safepoint_check_required;)</span>
<span class="line-removed">266 #endif</span>
<span class="line-removed">267 }</span>
268 
<span class="line-modified">269 Mutex::Mutex(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-modified">270              SafepointCheckRequired safepoint_check_required) {</span>
<span class="line-modified">271   ClearMonitor((Monitor *) this, name);</span>
<span class="line-modified">272 #ifdef ASSERT</span>
<span class="line-modified">273   _allow_vm_block   = allow_vm_block;</span>
<span class="line-removed">274   _rank             = Rank;</span>
<span class="line-removed">275   NOT_PRODUCT(_safepoint_check_required = safepoint_check_required;)</span>
276 #endif
277 }
278 
<span class="line-modified">279 bool Monitor::owned_by_self() const {</span>




280   return _owner == Thread::current();
281 }
282 
<span class="line-modified">283 void Monitor::print_on_error(outputStream* st) const {</span>
284   st-&gt;print(&quot;[&quot; PTR_FORMAT, p2i(this));
285   st-&gt;print(&quot;] %s&quot;, _name);
286   st-&gt;print(&quot; - owner thread: &quot; PTR_FORMAT, p2i(_owner));
287 }
288 
289 // ----------------------------------------------------------------------------------
290 // Non-product code
291 
292 #ifndef PRODUCT
<span class="line-modified">293 void Monitor::print_on(outputStream* st) const {</span>
<span class="line-modified">294   st-&gt;print_cr(&quot;Mutex: [&quot; PTR_FORMAT &quot;] %s - owner: &quot; PTR_FORMAT,</span>
<span class="line-modified">295                p2i(this), _name, p2i(_owner));</span>














296 }
297 #endif
298 
<span class="line-removed">299 #ifndef PRODUCT</span>
300 #ifdef ASSERT
<span class="line-modified">301 </span>
<span class="line-removed">302 void Monitor::assert_owner(Thread * expected) {</span>
303   const char* msg = &quot;invalid owner&quot;;
304   if (expected == NULL) {
305     msg = &quot;should be un-owned&quot;;
306   }
307   else if (expected == Thread::current()) {
308     msg = &quot;should be owned by current thread&quot;;
309   }
310   assert(_owner == expected,
311          &quot;%s: owner=&quot; INTPTR_FORMAT &quot;, should be=&quot; INTPTR_FORMAT,
312          msg, p2i(_owner), p2i(expected));
313 }
314 
<span class="line-modified">315 Monitor * Monitor::get_least_ranked_lock(Monitor * locks) {</span>
<span class="line-modified">316   Monitor *res, *tmp;</span>
317   for (res = tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
318     if (tmp-&gt;rank() &lt; res-&gt;rank()) {
319       res = tmp;
320     }
321   }
322   if (!SafepointSynchronize::is_at_safepoint()) {
323     // In this case, we expect the held locks to be
324     // in increasing rank order (modulo any native ranks)
325     for (tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
326       if (tmp-&gt;next() != NULL) {
327         assert(tmp-&gt;rank() == Mutex::native ||
328                tmp-&gt;rank() &lt;= tmp-&gt;next()-&gt;rank(), &quot;mutex rank anomaly?&quot;);
329       }
330     }
331   }
332   return res;
333 }
334 
<span class="line-modified">335 Monitor* Monitor::get_least_ranked_lock_besides_this(Monitor* locks) {</span>
<span class="line-modified">336   Monitor *res, *tmp;</span>
337   for (res = NULL, tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
338     if (tmp != this &amp;&amp; (res == NULL || tmp-&gt;rank() &lt; res-&gt;rank())) {
339       res = tmp;
340     }
341   }
342   if (!SafepointSynchronize::is_at_safepoint()) {
343     // In this case, we expect the held locks to be
344     // in increasing rank order (modulo any native ranks)
345     for (tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
346       if (tmp-&gt;next() != NULL) {
347         assert(tmp-&gt;rank() == Mutex::native ||
348                tmp-&gt;rank() &lt;= tmp-&gt;next()-&gt;rank(), &quot;mutex rank anomaly?&quot;);
349       }
350     }
351   }
352   return res;
353 }
354 
<span class="line-modified">355 </span>
<span class="line-removed">356 bool Monitor::contains(Monitor* locks, Monitor * lock) {</span>
357   for (; locks != NULL; locks = locks-&gt;next()) {
358     if (locks == lock) {
359       return true;
360     }
361   }
362   return false;
363 }
<span class="line-modified">364 #endif</span>
















365 
366 // Called immediately after lock acquisition or release as a diagnostic
367 // to track the lock-set of the thread and test for rank violations that
368 // might indicate exposure to deadlock.
369 // Rather like an EventListener for _owner (:&gt;).
370 
<span class="line-modified">371 void Monitor::set_owner_implementation(Thread *new_owner) {</span>
372   // This function is solely responsible for maintaining
373   // and checking the invariant that threads and locks
374   // are in a 1/N relation, with some some locks unowned.
375   // It uses the Mutex::_owner, Mutex::_next, and
376   // Thread::_owned_locks fields, and no other function
377   // changes those fields.
378   // It is illegal to set the mutex from one non-NULL
379   // owner to another--it must be owned by NULL as an
380   // intermediate state.
381 
382   if (new_owner != NULL) {
383     // the thread is acquiring this lock
384 
385     assert(new_owner == Thread::current(), &quot;Should I be doing this?&quot;);
386     assert(_owner == NULL, &quot;setting the owner thread of an already owned mutex&quot;);
387     _owner = new_owner; // set the owner
388 
389     // link &quot;this&quot; into the owned locks list
390 
<span class="line-modified">391 #ifdef ASSERT  // Thread::_owned_locks is under the same ifdef</span>
<span class="line-removed">392     Monitor* locks = get_least_ranked_lock(new_owner-&gt;owned_locks());</span>
393     // Mutex::set_owner_implementation is a friend of Thread
394 
395     assert(this-&gt;rank() &gt;= 0, &quot;bad lock rank&quot;);
396 
397     // Deadlock avoidance rules require us to acquire Mutexes only in
398     // a global total order. For example m1 is the lowest ranked mutex
399     // that the thread holds and m2 is the mutex the thread is trying
400     // to acquire, then deadlock avoidance rules require that the rank
401     // of m2 be less than the rank of m1.
402     // The rank Mutex::native  is an exception in that it is not subject
403     // to the verification rules.
404     if (this-&gt;rank() != Mutex::native &amp;&amp;
405         this-&gt;rank() != Mutex::suspend_resume &amp;&amp;
406         locks != NULL &amp;&amp; locks-&gt;rank() &lt;= this-&gt;rank() &amp;&amp;
407         !SafepointSynchronize::is_at_safepoint()) {
408       new_owner-&gt;print_owned_locks();
409       fatal(&quot;acquiring lock %s/%d out of order with lock %s/%d -- &quot;
410             &quot;possible deadlock&quot;, this-&gt;name(), this-&gt;rank(),
411             locks-&gt;name(), locks-&gt;rank());
412     }
413 
414     this-&gt;_next = new_owner-&gt;_owned_locks;
415     new_owner-&gt;_owned_locks = this;
<span class="line-modified">416 #endif</span>


417 
418   } else {
419     // the thread is releasing this lock
420 
421     Thread* old_owner = _owner;
<span class="line-modified">422     DEBUG_ONLY(_last_owner = old_owner;)</span>
423 
424     assert(old_owner != NULL, &quot;removing the owner thread of an unowned mutex&quot;);
425     assert(old_owner == Thread::current(), &quot;removing the owner thread of an unowned mutex&quot;);
426 
427     _owner = NULL; // set the owner
428 
<span class="line-modified">429 #ifdef ASSERT</span>
<span class="line-removed">430     Monitor *locks = old_owner-&gt;owned_locks();</span>
431 
432     // remove &quot;this&quot; from the owned locks list
433 
<span class="line-modified">434     Monitor *prev = NULL;</span>
435     bool found = false;
436     for (; locks != NULL; prev = locks, locks = locks-&gt;next()) {
437       if (locks == this) {
438         found = true;
439         break;
440       }
441     }
442     assert(found, &quot;Removing a lock not owned&quot;);
443     if (prev == NULL) {
444       old_owner-&gt;_owned_locks = _next;
445     } else {
446       prev-&gt;_next = _next;
447     }
448     _next = NULL;
<span class="line-removed">449 #endif</span>
<span class="line-removed">450   }</span>
<span class="line-removed">451 }</span>
<span class="line-removed">452 </span>
<span class="line-removed">453 </span>
<span class="line-removed">454 // Factored out common sanity checks for locking mutex&#39;es. Used by lock() and try_lock()</span>
<span class="line-removed">455 void Monitor::check_prelock_state(Thread *thread, bool safepoint_check) {</span>
<span class="line-removed">456   if (safepoint_check) {</span>
<span class="line-removed">457     assert((!thread-&gt;is_Java_thread() || ((JavaThread *)thread)-&gt;thread_state() == _thread_in_vm)</span>
<span class="line-removed">458            || rank() == Mutex::special, &quot;wrong thread state for using locks&quot;);</span>
<span class="line-removed">459     if (thread-&gt;is_VM_thread() &amp;&amp; !allow_vm_block()) {</span>
<span class="line-removed">460       fatal(&quot;VM thread using lock %s (not allowed to block on)&quot;, name());</span>
<span class="line-removed">461     }</span>
<span class="line-removed">462     DEBUG_ONLY(if (rank() != Mutex::special) \</span>
<span class="line-removed">463                thread-&gt;check_for_valid_safepoint_state(false);)</span>
<span class="line-removed">464   }</span>
<span class="line-removed">465   assert(!os::ThreadCrashProtection::is_crash_protected(thread),</span>
<span class="line-removed">466          &quot;locking not allowed when crash protection is set&quot;);</span>
<span class="line-removed">467 }</span>
468 
<span class="line-modified">469 void Monitor::check_block_state(Thread *thread) {</span>
<span class="line-modified">470   if (!_allow_vm_block &amp;&amp; thread-&gt;is_VM_thread()) {</span>
<span class="line-removed">471     warning(&quot;VM thread blocked on lock&quot;);</span>
<span class="line-removed">472     print();</span>
<span class="line-removed">473     BREAKPOINT;</span>
474   }
<span class="line-removed">475   assert(_owner != thread, &quot;deadlock: blocking on monitor owned by current thread&quot;);</span>
476 }
<span class="line-modified">477 </span>
<span class="line-removed">478 #endif // PRODUCT</span>
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 28 #include &quot;runtime/mutex.hpp&quot;
 29 #include &quot;runtime/osThread.hpp&quot;
 30 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
 31 #include &quot;runtime/thread.inline.hpp&quot;
 32 #include &quot;utilities/events.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 
<span class="line-added"> 35 #ifdef ASSERT</span>
<span class="line-added"> 36 void Mutex::check_block_state(Thread* thread) {</span>
<span class="line-added"> 37   if (!_allow_vm_block &amp;&amp; thread-&gt;is_VM_thread()) {</span>
<span class="line-added"> 38     // JavaThreads are checked to make sure that they do not hold _allow_vm_block locks during operations</span>
<span class="line-added"> 39     // that could safepoint.  Make sure the vm thread never uses locks with _allow_vm_block == false.</span>
<span class="line-added"> 40     fatal(&quot;VM thread could block on lock that may be held by a JavaThread during safepoint: %s&quot;, name());</span>
<span class="line-added"> 41   }</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43   assert(!os::ThreadCrashProtection::is_crash_protected(thread),</span>
<span class="line-added"> 44          &quot;locking not allowed when crash protection is set&quot;);</span>
<span class="line-added"> 45 }</span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47 void Mutex::check_safepoint_state(Thread* thread) {</span>
<span class="line-added"> 48   check_block_state(thread);</span>
 49 
<span class="line-modified"> 50   // If the JavaThread checks for safepoint, verify that the lock wasn&#39;t created with safepoint_check_never.</span>
<span class="line-modified"> 51   if (thread-&gt;is_active_Java_thread()) {</span>
<span class="line-modified"> 52     assert(_safepoint_check_required != _safepoint_check_never,</span>
<span class="line-modified"> 53            &quot;This lock should %s have a safepoint check for Java threads: %s&quot;,</span>
<span class="line-added"> 54            _safepoint_check_required ? &quot;always&quot; : &quot;never&quot;, name());</span>
 55 
<span class="line-modified"> 56     // Also check NoSafepointVerifier, and thread state is _thread_in_vm</span>
<span class="line-modified"> 57     thread-&gt;check_for_valid_safepoint_state();</span>
<span class="line-modified"> 58   } else {</span>
<span class="line-modified"> 59     // If initialized with safepoint_check_never, a NonJavaThread should never ask to safepoint check either.</span>
<span class="line-added"> 60     assert(_safepoint_check_required != _safepoint_check_never,</span>
<span class="line-added"> 61            &quot;NonJavaThread should not check for safepoint&quot;);</span>
 62   }
<span class="line-modified"> 63 }</span>
 64 
<span class="line-modified"> 65 void Mutex::check_no_safepoint_state(Thread* thread) {</span>
<span class="line-modified"> 66   check_block_state(thread);</span>
<span class="line-added"> 67   assert(!thread-&gt;is_active_Java_thread() || _safepoint_check_required != _safepoint_check_always,</span>
<span class="line-added"> 68          &quot;This lock should %s have a safepoint check for Java threads: %s&quot;,</span>
<span class="line-added"> 69          _safepoint_check_required ? &quot;always&quot; : &quot;never&quot;, name());</span>
<span class="line-added"> 70 }</span>
<span class="line-added"> 71 #endif // ASSERT</span>
 72 
<span class="line-modified"> 73 void Mutex::lock_contended(Thread* self) {</span>
<span class="line-added"> 74   Mutex *in_flight_mutex = NULL;</span>
 75   DEBUG_ONLY(int retry_cnt = 0;)
<span class="line-modified"> 76   bool is_active_Java_thread = self-&gt;is_active_Java_thread();</span>
<span class="line-modified"> 77   do {</span>
<span class="line-modified"> 78     #ifdef ASSERT</span>


 79     if (retry_cnt++ &gt; 3) {
<span class="line-modified"> 80       log_trace(vmmutex)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; on %d attempt trying to acquire vmmutex %s&quot;, p2i(self), retry_cnt, _name);</span>
 81     }
<span class="line-modified"> 82     #endif // ASSERT</span>
 83 
<span class="line-modified"> 84     // Is it a JavaThread participating in the safepoint protocol.</span>
<span class="line-added"> 85     if (is_active_Java_thread) {</span>
 86       assert(rank() &gt; Mutex::special, &quot;Potential deadlock with special or lesser rank mutex&quot;);
<span class="line-modified"> 87       { ThreadBlockInVMWithDeadlockCheck tbivmdc((JavaThread *) self, &amp;in_flight_mutex);</span>
<span class="line-modified"> 88         in_flight_mutex = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
 89         _lock.lock();
 90       }
<span class="line-modified"> 91       if (in_flight_mutex != NULL) {</span>
 92         // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck
 93         break;
 94       }
 95     } else {
 96       _lock.lock();
 97       break;
 98     }
<span class="line-added"> 99   } while (!_lock.try_lock());</span>
<span class="line-added">100 }</span>
<span class="line-added">101 </span>
<span class="line-added">102 void Mutex::lock(Thread* self) {</span>
<span class="line-added">103   check_safepoint_state(self);</span>
<span class="line-added">104 </span>
<span class="line-added">105   assert(_owner != self, &quot;invariant&quot;);</span>
<span class="line-added">106 </span>
<span class="line-added">107   if (!_lock.try_lock()) {</span>
<span class="line-added">108     // The lock is contended, use contended slow-path function to lock</span>
<span class="line-added">109     lock_contended(self);</span>
110   }
111 
112   assert_owner(NULL);
113   set_owner(self);
114 }
115 
<span class="line-modified">116 void Mutex::lock() {</span>
<span class="line-modified">117   lock(Thread::current());</span>
118 }
119 
120 // Lock without safepoint check - a degenerate variant of lock() for use by
121 // JavaThreads when it is known to be safe to not check for a safepoint when
122 // acquiring this lock. If the thread blocks acquiring the lock it is not
123 // safepoint-safe and so will prevent a safepoint from being reached. If used
124 // in the wrong way this can lead to a deadlock with the safepoint code.
125 
<span class="line-modified">126 void Mutex::lock_without_safepoint_check(Thread * self) {</span>
<span class="line-modified">127   check_no_safepoint_state(self);</span>


128   assert(_owner != self, &quot;invariant&quot;);
129   _lock.lock();
130   assert_owner(NULL);
131   set_owner(self);
132 }
133 
<span class="line-modified">134 void Mutex::lock_without_safepoint_check() {</span>
135   lock_without_safepoint_check(Thread::current());
136 }
137 
138 
139 // Returns true if thread succeeds in grabbing the lock, otherwise false.
140 
<span class="line-modified">141 bool Mutex::try_lock() {</span>
142   Thread * const self = Thread::current();
<span class="line-modified">143   // Some safepoint_check_always locks use try_lock, so cannot check</span>
<span class="line-modified">144   // safepoint state, but can check blocking state.</span>
<span class="line-added">145   check_block_state(self);</span>
146   if (_lock.try_lock()) {
147     assert_owner(NULL);
148     set_owner(self);
149     return true;
150   }
151   return false;
152 }
153 
<span class="line-modified">154 void Mutex::release_for_safepoint() {</span>
155   assert_owner(NULL);
156   _lock.unlock();
157 }
158 
<span class="line-modified">159 void Mutex::unlock() {</span>
<span class="line-modified">160   DEBUG_ONLY(assert_owner(Thread::current()));</span>
161   set_owner(NULL);
162   _lock.unlock();
163 }
164 
165 void Monitor::notify() {
<span class="line-modified">166   DEBUG_ONLY(assert_owner(Thread::current()));</span>
167   _lock.notify();
168 }
169 
170 void Monitor::notify_all() {
<span class="line-modified">171   DEBUG_ONLY(assert_owner(Thread::current()));</span>
172   _lock.notify_all();
173 }
174 
<span class="line-modified">175 #ifdef ASSERT</span>
<span class="line-modified">176 void Monitor::assert_wait_lock_state(Thread* self) {</span>
<span class="line-modified">177   Mutex* least = get_least_ranked_lock_besides_this(self-&gt;owned_locks());</span>


















178   assert(least != this, &quot;Specification of get_least_... call above&quot;);
179   if (least != NULL &amp;&amp; least-&gt;rank() &lt;= special) {
180     ::tty-&gt;print(&quot;Attempting to wait on monitor %s/%d while holding&quot;
181                &quot; lock %s/%d -- possible deadlock&quot;,
182                name(), rank(), least-&gt;name(), least-&gt;rank());
183     assert(false, &quot;Shouldn&#39;t block(wait) while holding a lock of rank special&quot;);
184   }
<span class="line-modified">185 }</span>
<span class="line-added">186 #endif // ASSERT</span>
<span class="line-added">187 </span>
<span class="line-added">188 bool Monitor::wait_without_safepoint_check(long timeout) {</span>
<span class="line-added">189   Thread* const self = Thread::current();</span>
<span class="line-added">190 </span>
<span class="line-added">191   // timeout is in milliseconds - with zero meaning never timeout</span>
<span class="line-added">192   assert(timeout &gt;= 0, &quot;negative timeout&quot;);</span>
<span class="line-added">193 </span>
<span class="line-added">194   assert_owner(self);</span>
<span class="line-added">195   assert_wait_lock_state(self);</span>
196 

197   // conceptually set the owner to NULL in anticipation of
198   // abdicating the lock in wait
199   set_owner(NULL);
<span class="line-modified">200   // Check safepoint state after resetting owner and possible NSV.</span>
<span class="line-modified">201   check_no_safepoint_state(self);</span>














202 
<span class="line-modified">203   int wait_status = _lock.wait(timeout);</span>
<span class="line-modified">204   set_owner(self);</span>
<span class="line-modified">205   return wait_status != 0;          // return true IFF timeout</span>
<span class="line-modified">206 }</span>
<span class="line-modified">207 </span>
<span class="line-modified">208 bool Monitor::wait(long timeout, bool as_suspend_equivalent) {</span>
<span class="line-modified">209   Thread* const self = Thread::current();</span>
<span class="line-modified">210 </span>
<span class="line-modified">211   // timeout is in milliseconds - with zero meaning never timeout</span>
<span class="line-modified">212   assert(timeout &gt;= 0, &quot;negative timeout&quot;);</span>
<span class="line-modified">213 </span>
<span class="line-modified">214   assert_owner(self);</span>
<span class="line-modified">215 </span>
<span class="line-added">216   // Safepoint checking logically implies an active JavaThread.</span>
<span class="line-added">217   guarantee(self-&gt;is_active_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-added">218   assert_wait_lock_state(self);</span>
<span class="line-added">219 </span>
<span class="line-added">220   int wait_status;</span>
<span class="line-added">221   // conceptually set the owner to NULL in anticipation of</span>
<span class="line-added">222   // abdicating the lock in wait</span>
<span class="line-added">223   set_owner(NULL);</span>
<span class="line-added">224   // Check safepoint state after resetting owner and possible NSV.</span>
<span class="line-added">225   check_safepoint_state(self);</span>
<span class="line-added">226   JavaThread *jt = (JavaThread *)self;</span>
<span class="line-added">227   Mutex* in_flight_mutex = NULL;</span>
<span class="line-added">228 </span>
<span class="line-added">229   {</span>
<span class="line-added">230     ThreadBlockInVMWithDeadlockCheck tbivmdc(jt, &amp;in_flight_mutex);</span>
<span class="line-added">231     OSThreadWaitState osts(self-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-added">232     if (as_suspend_equivalent) {</span>
<span class="line-added">233       jt-&gt;set_suspend_equivalent();</span>
<span class="line-added">234       // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-added">235       // java_suspend_self()</span>
236     }
237 
<span class="line-modified">238     wait_status = _lock.wait(timeout);</span>
<span class="line-modified">239     in_flight_mutex = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">240 </span>
<span class="line-modified">241     // were we externally suspended while we were waiting?</span>
<span class="line-modified">242     if (as_suspend_equivalent &amp;&amp; jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">243       // Our event wait has finished and we own the lock, but</span>
<span class="line-modified">244       // while we were waiting another thread suspended us. We don&#39;t</span>
<span class="line-added">245       // want to hold the lock while suspended because that</span>
<span class="line-added">246       // would surprise the thread that suspended us.</span>
<span class="line-added">247       _lock.unlock();</span>
<span class="line-added">248       jt-&gt;java_suspend_self();</span>
<span class="line-added">249       _lock.lock();</span>
250     }
251   }



252 
<span class="line-modified">253   if (in_flight_mutex != NULL) {</span>
<span class="line-modified">254     // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">255     assert_owner(NULL);</span>
<span class="line-modified">256     // Conceptually reestablish ownership of the lock.</span>
<span class="line-modified">257     set_owner(self);</span>
<span class="line-modified">258   } else {</span>
<span class="line-added">259     lock(self);</span>
<span class="line-added">260   }</span>
261 
<span class="line-modified">262   return wait_status != 0;          // return true IFF timeout</span>


263 }
264 
<span class="line-modified">265 Mutex::~Mutex() {</span>
266   assert_owner(NULL);

267 }
268 
<span class="line-modified">269 // Only Threads_lock, Heap_lock and SR_lock may be safepoint_check_sometimes.</span>
<span class="line-modified">270 bool is_sometimes_ok(const char* name) {</span>
<span class="line-added">271   return (strcmp(name, &quot;Threads_lock&quot;) == 0 || strcmp(name, &quot;Heap_lock&quot;) == 0 || strcmp(name, &quot;SR_lock&quot;) == 0);</span>
272 }
273 
<span class="line-modified">274 Mutex::Mutex(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-modified">275              SafepointCheckRequired safepoint_check_required) : _owner(NULL) {</span>
<span class="line-added">276   assert(os::mutex_init_done(), &quot;Too early!&quot;);</span>
277   if (name == NULL) {
<span class="line-modified">278     strcpy(_name, &quot;UNKNOWN&quot;);</span>
279   } else {
<span class="line-modified">280     strncpy(_name, name, MUTEX_NAME_LEN - 1);</span>
<span class="line-modified">281     _name[MUTEX_NAME_LEN - 1] = &#39;\0&#39;;</span>
282   }











283 #ifdef ASSERT
284   _allow_vm_block  = allow_vm_block;
285   _rank            = Rank;
<span class="line-modified">286   _safepoint_check_required = safepoint_check_required;</span>


287 
<span class="line-modified">288   assert(_safepoint_check_required != _safepoint_check_sometimes || is_sometimes_ok(name),</span>
<span class="line-modified">289          &quot;Lock has _safepoint_check_sometimes %s&quot;, name);</span>
<span class="line-modified">290 </span>
<span class="line-modified">291   assert(_rank &gt; special || _safepoint_check_required == _safepoint_check_never,</span>
<span class="line-modified">292          &quot;Special locks or below should never safepoint&quot;);</span>


293 #endif
294 }
295 
<span class="line-modified">296 Monitor::Monitor(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-added">297              SafepointCheckRequired safepoint_check_required) :</span>
<span class="line-added">298   Mutex(Rank, name, allow_vm_block, safepoint_check_required) {}</span>
<span class="line-added">299 </span>
<span class="line-added">300 bool Mutex::owned_by_self() const {</span>
301   return _owner == Thread::current();
302 }
303 
<span class="line-modified">304 void Mutex::print_on_error(outputStream* st) const {</span>
305   st-&gt;print(&quot;[&quot; PTR_FORMAT, p2i(this));
306   st-&gt;print(&quot;] %s&quot;, _name);
307   st-&gt;print(&quot; - owner thread: &quot; PTR_FORMAT, p2i(_owner));
308 }
309 
310 // ----------------------------------------------------------------------------------
311 // Non-product code
312 
313 #ifndef PRODUCT
<span class="line-modified">314 const char* print_safepoint_check(Mutex::SafepointCheckRequired safepoint_check) {</span>
<span class="line-modified">315   switch (safepoint_check) {</span>
<span class="line-modified">316   case Mutex::_safepoint_check_never:     return &quot;safepoint_check_never&quot;;</span>
<span class="line-added">317   case Mutex::_safepoint_check_sometimes: return &quot;safepoint_check_sometimes&quot;;</span>
<span class="line-added">318   case Mutex::_safepoint_check_always:    return &quot;safepoint_check_always&quot;;</span>
<span class="line-added">319   default: return &quot;&quot;;</span>
<span class="line-added">320   }</span>
<span class="line-added">321 }</span>
<span class="line-added">322 </span>
<span class="line-added">323 void Mutex::print_on(outputStream* st) const {</span>
<span class="line-added">324   st-&gt;print(&quot;Mutex: [&quot; PTR_FORMAT &quot;] %s - owner: &quot; PTR_FORMAT,</span>
<span class="line-added">325             p2i(this), _name, p2i(_owner));</span>
<span class="line-added">326   if (_allow_vm_block) {</span>
<span class="line-added">327     st-&gt;print(&quot;%s&quot;, &quot; allow_vm_block&quot;);</span>
<span class="line-added">328   }</span>
<span class="line-added">329   st-&gt;print(&quot; %s&quot;, print_safepoint_check(_safepoint_check_required));</span>
<span class="line-added">330   st-&gt;cr();</span>
331 }
332 #endif
333 

334 #ifdef ASSERT
<span class="line-modified">335 void Mutex::assert_owner(Thread * expected) {</span>

336   const char* msg = &quot;invalid owner&quot;;
337   if (expected == NULL) {
338     msg = &quot;should be un-owned&quot;;
339   }
340   else if (expected == Thread::current()) {
341     msg = &quot;should be owned by current thread&quot;;
342   }
343   assert(_owner == expected,
344          &quot;%s: owner=&quot; INTPTR_FORMAT &quot;, should be=&quot; INTPTR_FORMAT,
345          msg, p2i(_owner), p2i(expected));
346 }
347 
<span class="line-modified">348 Mutex* Mutex::get_least_ranked_lock(Mutex* locks) {</span>
<span class="line-modified">349   Mutex *res, *tmp;</span>
350   for (res = tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
351     if (tmp-&gt;rank() &lt; res-&gt;rank()) {
352       res = tmp;
353     }
354   }
355   if (!SafepointSynchronize::is_at_safepoint()) {
356     // In this case, we expect the held locks to be
357     // in increasing rank order (modulo any native ranks)
358     for (tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
359       if (tmp-&gt;next() != NULL) {
360         assert(tmp-&gt;rank() == Mutex::native ||
361                tmp-&gt;rank() &lt;= tmp-&gt;next()-&gt;rank(), &quot;mutex rank anomaly?&quot;);
362       }
363     }
364   }
365   return res;
366 }
367 
<span class="line-modified">368 Mutex* Mutex::get_least_ranked_lock_besides_this(Mutex* locks) {</span>
<span class="line-modified">369   Mutex *res, *tmp;</span>
370   for (res = NULL, tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
371     if (tmp != this &amp;&amp; (res == NULL || tmp-&gt;rank() &lt; res-&gt;rank())) {
372       res = tmp;
373     }
374   }
375   if (!SafepointSynchronize::is_at_safepoint()) {
376     // In this case, we expect the held locks to be
377     // in increasing rank order (modulo any native ranks)
378     for (tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
379       if (tmp-&gt;next() != NULL) {
380         assert(tmp-&gt;rank() == Mutex::native ||
381                tmp-&gt;rank() &lt;= tmp-&gt;next()-&gt;rank(), &quot;mutex rank anomaly?&quot;);
382       }
383     }
384   }
385   return res;
386 }
387 
<span class="line-modified">388 bool Mutex::contains(Mutex* locks, Mutex* lock) {</span>

389   for (; locks != NULL; locks = locks-&gt;next()) {
390     if (locks == lock) {
391       return true;
392     }
393   }
394   return false;
395 }
<span class="line-modified">396 </span>
<span class="line-added">397 // NSV implied with locking allow_vm_block or !safepoint_check locks.</span>
<span class="line-added">398 void Mutex::no_safepoint_verifier(Thread* thread, bool enable) {</span>
<span class="line-added">399   // The tty_lock is special because it is released for the safepoint by</span>
<span class="line-added">400   // the safepoint mechanism.</span>
<span class="line-added">401   if (this == tty_lock) {</span>
<span class="line-added">402     return;</span>
<span class="line-added">403   }</span>
<span class="line-added">404 </span>
<span class="line-added">405   if (_allow_vm_block) {</span>
<span class="line-added">406     if (enable) {</span>
<span class="line-added">407       thread-&gt;_no_safepoint_count++;</span>
<span class="line-added">408     } else {</span>
<span class="line-added">409       thread-&gt;_no_safepoint_count--;</span>
<span class="line-added">410     }</span>
<span class="line-added">411   }</span>
<span class="line-added">412 }</span>
413 
414 // Called immediately after lock acquisition or release as a diagnostic
415 // to track the lock-set of the thread and test for rank violations that
416 // might indicate exposure to deadlock.
417 // Rather like an EventListener for _owner (:&gt;).
418 
<span class="line-modified">419 void Mutex::set_owner_implementation(Thread *new_owner) {</span>
420   // This function is solely responsible for maintaining
421   // and checking the invariant that threads and locks
422   // are in a 1/N relation, with some some locks unowned.
423   // It uses the Mutex::_owner, Mutex::_next, and
424   // Thread::_owned_locks fields, and no other function
425   // changes those fields.
426   // It is illegal to set the mutex from one non-NULL
427   // owner to another--it must be owned by NULL as an
428   // intermediate state.
429 
430   if (new_owner != NULL) {
431     // the thread is acquiring this lock
432 
433     assert(new_owner == Thread::current(), &quot;Should I be doing this?&quot;);
434     assert(_owner == NULL, &quot;setting the owner thread of an already owned mutex&quot;);
435     _owner = new_owner; // set the owner
436 
437     // link &quot;this&quot; into the owned locks list
438 
<span class="line-modified">439     Mutex* locks = get_least_ranked_lock(new_owner-&gt;owned_locks());</span>

440     // Mutex::set_owner_implementation is a friend of Thread
441 
442     assert(this-&gt;rank() &gt;= 0, &quot;bad lock rank&quot;);
443 
444     // Deadlock avoidance rules require us to acquire Mutexes only in
445     // a global total order. For example m1 is the lowest ranked mutex
446     // that the thread holds and m2 is the mutex the thread is trying
447     // to acquire, then deadlock avoidance rules require that the rank
448     // of m2 be less than the rank of m1.
449     // The rank Mutex::native  is an exception in that it is not subject
450     // to the verification rules.
451     if (this-&gt;rank() != Mutex::native &amp;&amp;
452         this-&gt;rank() != Mutex::suspend_resume &amp;&amp;
453         locks != NULL &amp;&amp; locks-&gt;rank() &lt;= this-&gt;rank() &amp;&amp;
454         !SafepointSynchronize::is_at_safepoint()) {
455       new_owner-&gt;print_owned_locks();
456       fatal(&quot;acquiring lock %s/%d out of order with lock %s/%d -- &quot;
457             &quot;possible deadlock&quot;, this-&gt;name(), this-&gt;rank(),
458             locks-&gt;name(), locks-&gt;rank());
459     }
460 
461     this-&gt;_next = new_owner-&gt;_owned_locks;
462     new_owner-&gt;_owned_locks = this;
<span class="line-modified">463 </span>
<span class="line-added">464     // NSV implied with locking allow_vm_block flag.</span>
<span class="line-added">465     no_safepoint_verifier(new_owner, true);</span>
466 
467   } else {
468     // the thread is releasing this lock
469 
470     Thread* old_owner = _owner;
<span class="line-modified">471     _last_owner = old_owner;</span>
472 
473     assert(old_owner != NULL, &quot;removing the owner thread of an unowned mutex&quot;);
474     assert(old_owner == Thread::current(), &quot;removing the owner thread of an unowned mutex&quot;);
475 
476     _owner = NULL; // set the owner
477 
<span class="line-modified">478     Mutex* locks = old_owner-&gt;owned_locks();</span>

479 
480     // remove &quot;this&quot; from the owned locks list
481 
<span class="line-modified">482     Mutex* prev = NULL;</span>
483     bool found = false;
484     for (; locks != NULL; prev = locks, locks = locks-&gt;next()) {
485       if (locks == this) {
486         found = true;
487         break;
488       }
489     }
490     assert(found, &quot;Removing a lock not owned&quot;);
491     if (prev == NULL) {
492       old_owner-&gt;_owned_locks = _next;
493     } else {
494       prev-&gt;_next = _next;
495     }
496     _next = NULL;



















497 
<span class="line-modified">498     // ~NSV implied with locking allow_vm_block flag.</span>
<span class="line-modified">499     no_safepoint_verifier(old_owner, false);</span>



500   }

501 }
<span class="line-modified">502 #endif // ASSERT</span>

</pre>
</td>
</tr>
</table>
<center><a href="memprofiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutex.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/runtime/threadHeapSampler.cpp b/src/hotspot/share/runtime/threadHeapSampler.cpp
--- a/src/hotspot/share/runtime/threadHeapSampler.cpp
+++ b/src/hotspot/share/runtime/threadHeapSampler.cpp
@@ -22,12 +22,12 @@
  * questions.
  *
  */
 
 #include "precompiled.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/handles.inline.hpp"
-#include "runtime/orderAccess.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/threadHeapSampler.hpp"
 
 // Cheap random number generator.
 uint64_t ThreadHeapSampler::_rnd;
@@ -119,15 +119,10 @@
     _bytes_until_sample = 0;
     return;
   }
 
   pick_next_geometric_sample();
-
-  // Try to correct sample size by removing extra space from last allocation.
-  if (overflowed_bytes > 0 && _bytes_until_sample > overflowed_bytes) {
-    _bytes_until_sample -= overflowed_bytes;
-  }
 }
 
 void ThreadHeapSampler::check_for_sampling(oop obj, size_t allocation_size, size_t bytes_since_allocation) {
   size_t total_allocated_bytes = bytes_since_allocation + allocation_size;
 
@@ -142,11 +137,11 @@
   size_t overflow_bytes = total_allocated_bytes - _bytes_until_sample;
   pick_next_sample(overflow_bytes);
 }
 
 int ThreadHeapSampler::get_sampling_interval() {
-  return OrderAccess::load_acquire(&_sampling_interval);
+  return Atomic::load_acquire(&_sampling_interval);
 }
 
 void ThreadHeapSampler::set_sampling_interval(int sampling_interval) {
-  OrderAccess::release_store(&_sampling_interval, sampling_interval);
+  Atomic::release_store(&_sampling_interval, sampling_interval);
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/rframe.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_RFRAME_HPP
 26 #define SHARE_RUNTIME_RFRAME_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/frame.hpp&quot;
 30 
 31 // rframes (&quot;recompiler frames&quot;) decorate stack frames with some extra information
 32 // needed by the recompiler.  The recompiler views the stack (at the time of recompilation)
 33 // as a list of rframes.
 34 
 35 class RFrame : public ResourceObj {
 36  protected:
 37   const frame _fr;                  // my frame
 38   JavaThread* const _thread;        // thread where frame resides.
 39   RFrame* _caller;                  // caller / callee rframes (or NULL)
 40   RFrame*const _callee;
 41   const int _num;                   // stack frame number (0 = most recent)
 42   int _invocations;                 // current invocation estimate (for this frame)
 43                                     // (i.e., how often was this frame called)
 44   int _distance;                    // recompilation search &quot;distance&quot; (measured in # of interpreted frames)
 45 
 46   RFrame(frame fr, JavaThread* thread, RFrame*const callee);
 47   virtual void init() = 0;          // compute invocations, loopDepth, etc.
 48   void print(const char* name);
 49 
 50  public:
 51 
 52   static RFrame* new_RFrame(frame fr, JavaThread* thread, RFrame*const callee);
 53 
 54   virtual bool is_interpreted() const     { return false; }
 55   virtual bool is_compiled() const        { return false; }
 56   int distance() const                    { return _distance; }
 57   void set_distance(int d);
 58   int invocations() const                 { return _invocations; }
 59   int num() const                         { return _num; }
 60   frame fr() const                        { return _fr; }
 61   JavaThread* thread() const              { return _thread; }
 62   virtual int cost() const = 0;           // estimated inlining cost (size)
 63   virtual Method* top_method() const  = 0;
 64   virtual javaVFrame* top_vframe() const = 0;
 65   virtual nmethod* nm() const             { ShouldNotCallThis(); return NULL; }
 66 
 67   RFrame* caller();
 68   RFrame* callee() const                  { return _callee; }
 69   RFrame* parent() const;                 // rframe containing lexical scope (if any)
 70   virtual void print()                    = 0;
 71 
 72   static int computeSends(Method* m);
 73   static int computeSends(nmethod* nm);
 74   static int computeCumulSends(Method* m);
 75   static int computeCumulSends(nmethod* nm);
 76 };
 77 
 78 class CompiledRFrame : public RFrame {    // frame containing a compiled method
 79  protected:
 80   nmethod*    _nm;
 81   javaVFrame* _vf;                        // top vframe; may be NULL (for most recent frame)
 82   Method* _method;                        // top method
 83 
 84   CompiledRFrame(frame fr, JavaThread* thread, RFrame*const  callee);
 85   void init();
 86   friend class RFrame;
 87 
 88  public:
 89   CompiledRFrame(frame fr, JavaThread* thread); // for nmethod triggering its counter (callee == NULL)
 90   bool is_compiled() const                 { return true; }
 91   Method* top_method() const               { return _method; }
 92   javaVFrame* top_vframe() const           { return _vf; }
 93   nmethod* nm() const                      { return _nm; }
 94   int cost() const;
 95   void print();
 96 };
 97 
 98 class InterpretedRFrame : public RFrame {    // interpreter frame
 99  protected:
100   javaVFrame* _vf;                           // may be NULL (for most recent frame)
101   Method* _method;
102 
103   InterpretedRFrame(frame fr, JavaThread* thread, RFrame*const  callee);
104   void init();
105   friend class RFrame;
106 
107  public:
108   InterpretedRFrame(frame fr, JavaThread* thread, Method* m); // constructor for method triggering its invocation counter
109   bool is_interpreted() const                { return true; }
110   Method* top_method() const                 { return _method; }
111   javaVFrame* top_vframe() const             { return _vf; }
112   int cost() const;
113   void print();
114 };
115 
116 // treat deoptimized frames as interpreted
117 class DeoptimizedRFrame : public InterpretedRFrame {
118  protected:
119   DeoptimizedRFrame(frame fr, JavaThread* thread, RFrame*const  callee);
120   friend class RFrame;
121  public:
122   void print();
123 };
124 
125 #endif // SHARE_RUNTIME_RFRAME_HPP
    </pre>
  </body>
</html>
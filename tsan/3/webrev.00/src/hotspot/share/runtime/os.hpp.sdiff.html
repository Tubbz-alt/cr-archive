<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/os.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="osThread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/os.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  30 #include &quot;metaprogramming/isRegisteredEnum.hpp&quot;
  31 #include &quot;metaprogramming/integralConstant.hpp&quot;
  32 #include &quot;runtime/extendedPC.hpp&quot;
  33 #include &quot;utilities/exceptions.hpp&quot;
  34 #include &quot;utilities/ostream.hpp&quot;
  35 #include &quot;utilities/macros.hpp&quot;
  36 #ifndef _WINDOWS
  37 # include &lt;setjmp.h&gt;
  38 #endif
  39 #ifdef __APPLE__
  40 # include &lt;mach/mach_time.h&gt;
  41 #endif
  42 
  43 class AgentLibrary;
  44 class frame;
  45 
  46 // os defines the interface to operating system; this includes traditional
  47 // OS services (time, I/O) as well as other functionality with system-
  48 // dependent code.
  49 
<span class="line-removed">  50 typedef void (*dll_func)(...);</span>
<span class="line-removed">  51 </span>
  52 class Thread;
  53 class JavaThread;
  54 class NativeCallStack;
  55 class methodHandle;
  56 class OSThread;
  57 class Mutex;
  58 
  59 template&lt;class E&gt; class GrowableArray;
  60 
  61 // %%%%% Moved ThreadState, START_FN, OSThread to new osThread.hpp. -- Rose
  62 
  63 // Platform-independent error return values from OS functions
  64 enum OSReturn {
  65   OS_OK         =  0,        // Operation was successful
  66   OS_ERR        = -1,        // Operation failed
  67   OS_INTRPT     = -2,        // Operation was interrupted
  68   OS_TIMEOUT    = -3,        // Operation timed out
  69   OS_NOMEM      = -5,        // Operation failed for lack of memory
  70   OS_NORESOURCE = -6         // Operation failed for lack of nonmemory resource
  71 };
</pre>
<hr />
<pre>
 150 
 151   // Get summary strings for system information in buffer provided
 152   static void  get_summary_cpu_info(char* buf, size_t buflen);
 153   static void  get_summary_os_info(char* buf, size_t buflen);
 154 
 155   static void initialize_initial_active_processor_count();
 156 
 157   LINUX_ONLY(static void pd_init_container_support();)
 158 
 159  public:
 160   static void init(void);                      // Called before command line parsing
 161 
 162   static void init_container_support() {       // Called during command line parsing.
 163      LINUX_ONLY(pd_init_container_support();)
 164   }
 165 
 166   static void init_before_ergo(void);          // Called after command line parsing
 167                                                // before VM ergonomics processing.
 168   static jint init_2(void);                    // Called after command line parsing
 169                                                // and VM ergonomics processing
<span class="line-removed"> 170   static void init_globals(void) {             // Called from init_globals() in init.cpp</span>
<span class="line-removed"> 171     init_globals_ext();</span>
<span class="line-removed"> 172   }</span>
<span class="line-removed"> 173 </span>
<span class="line-removed"> 174   // File names are case-insensitive on windows only</span>
<span class="line-removed"> 175   // Override me as needed</span>
<span class="line-removed"> 176   static int    file_name_strncmp(const char* s1, const char* s2, size_t num);</span>
 177 
 178   // unset environment variable
 179   static bool unsetenv(const char* name);
 180 
 181   static bool have_special_privileges();
 182 
 183   static jlong  javaTimeMillis();
 184   static jlong  javaTimeNanos();
 185   static void   javaTimeNanos_info(jvmtiTimerInfo *info_ptr);
 186   static void   javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos);
 187   static void   run_periodic_checks();
 188   static bool   supports_monotonic_clock();
 189 
 190   // Returns the elapsed time in seconds since the vm started.
 191   static double elapsedTime();
 192 
 193   // Returns real time in seconds since an arbitrary point
 194   // in the past.
 195   static bool getTimesSecs(double* process_real_time,
 196                            double* process_user_time,
 197                            double* process_system_time);
 198 
 199   // Interface to the performance counter
 200   static jlong elapsed_counter();
 201   static jlong elapsed_frequency();
 202 
 203   // The &quot;virtual time&quot; of a thread is the amount of time a thread has
 204   // actually run.  The first function indicates whether the OS supports
<span class="line-modified"> 205   // this functionality for the current thread, and if so:</span>
<span class="line-modified"> 206   //   * the second enables vtime tracking (if that is required).</span>
<span class="line-removed"> 207   //   * the third tells whether vtime is enabled.</span>
<span class="line-removed"> 208   //   * the fourth returns the elapsed virtual time for the current</span>
<span class="line-removed"> 209   //     thread.</span>
 210   static bool supports_vtime();
<span class="line-removed"> 211   static bool enable_vtime();</span>
<span class="line-removed"> 212   static bool vtime_enabled();</span>
 213   static double elapsedVTime();
 214 
 215   // Return current local time in a string (YYYY-MM-DD HH:MM:SS).
 216   // It is MT safe, but not async-safe, as reading time zone
 217   // information may require a lock on some platforms.
 218   static char*      local_time_string(char *buf, size_t buflen);
 219   static struct tm* localtime_pd     (const time_t* clock, struct tm*  res);
 220   static struct tm* gmtime_pd        (const time_t* clock, struct tm*  res);
 221   // Fill in buffer with current local time as an ISO-8601 string.
 222   // E.g., YYYY-MM-DDThh:mm:ss.mmm+zzzz.
 223   // Returns buffer, or NULL if it failed.
 224   static char* iso8601_time(char* buffer, size_t buffer_length, bool utc = false);
 225 
 226   // Interface for detecting multiprocessor system
 227   static inline bool is_MP() {
 228     // During bootstrap if _processor_count is not yet initialized
 229     // we claim to be MP as that is safest. If any platform has a
 230     // stub generator that might be triggered in this phase and for
 231     // which being declared MP when in fact not, is a problem - then
 232     // the bootstrap routine for the stub generator needs to check
</pre>
<hr />
<pre>
 244   // The returned value is guaranteed to be between 0 and (os::processor_count() - 1).
 245   static uint processor_id();
 246 
 247   // number of CPUs
 248   static int processor_count() {
 249     return _processor_count;
 250   }
 251   static void set_processor_count(int count) { _processor_count = count; }
 252 
 253   // Returns the number of CPUs this process is currently allowed to run on.
 254   // Note that on some OSes this can change dynamically.
 255   static int active_processor_count();
 256 
 257   // At startup the number of active CPUs this process is allowed to run on.
 258   // This value does not change dynamically. May be different from active_processor_count().
 259   static int initial_active_processor_count() {
 260     assert(_initial_active_processor_count &gt; 0, &quot;Initial active processor count not set yet.&quot;);
 261     return _initial_active_processor_count;
 262   }
 263 
<span class="line-removed"> 264   // Bind processes to processors.</span>
<span class="line-removed"> 265   //     This is a two step procedure:</span>
<span class="line-removed"> 266   //     first you generate a distribution of processes to processors,</span>
<span class="line-removed"> 267   //     then you bind processes according to that distribution.</span>
<span class="line-removed"> 268   // Compute a distribution for number of processes to processors.</span>
<span class="line-removed"> 269   //    Stores the processor id&#39;s into the distribution array argument.</span>
<span class="line-removed"> 270   //    Returns true if it worked, false if it didn&#39;t.</span>
<span class="line-removed"> 271   static bool distribute_processes(uint length, uint* distribution);</span>
 272   // Binds the current process to a processor.
 273   //    Returns true if it worked, false if it didn&#39;t.
 274   static bool bind_to_processor(uint processor_id);
 275 
 276   // Give a name to the current thread.
 277   static void set_native_thread_name(const char *name);
 278 
 279   // Interface for stack banging (predetect possible stack overflow for
 280   // exception processing)  There are guard pages, and above that shadow
 281   // pages for stack overflow checking.
 282   static bool uses_stack_guard_pages();
 283   static bool must_commit_stack_guard_pages();
 284   static void map_stack_shadow_pages(address sp);
 285   static bool stack_shadow_pages_available(Thread *thread, const methodHandle&amp; method, address sp);
 286 
 287   // Find committed memory region within specified range (start, start + size),
 288   // return true if found any
 289   static bool committed_in_range(address start, size_t size, address&amp; committed_start, size_t&amp; committed_size);
 290 
 291   // OS interface to Virtual Memory
</pre>
<hr />
<pre>
 379 
 380   static char*  map_memory(int fd, const char* file_name, size_t file_offset,
 381                            char *addr, size_t bytes, bool read_only = false,
 382                            bool allow_exec = false);
 383   static char*  remap_memory(int fd, const char* file_name, size_t file_offset,
 384                              char *addr, size_t bytes, bool read_only,
 385                              bool allow_exec);
 386   static bool   unmap_memory(char *addr, size_t bytes);
 387   static void   free_memory(char *addr, size_t bytes, size_t alignment_hint);
 388   static void   realign_memory(char *addr, size_t bytes, size_t alignment_hint);
 389 
 390   // NUMA-specific interface
 391   static bool   numa_has_static_binding();
 392   static bool   numa_has_group_homing();
 393   static void   numa_make_local(char *addr, size_t bytes, int lgrp_hint);
 394   static void   numa_make_global(char *addr, size_t bytes);
 395   static size_t numa_get_groups_num();
 396   static size_t numa_get_leaf_groups(int *ids, size_t size);
 397   static bool   numa_topology_changed();
 398   static int    numa_get_group_id();

 399 
 400   // Page manipulation
 401   struct page_info {
 402     size_t size;
 403     int lgrp_id;
 404   };
 405   static bool   get_page_info(char *start, page_info* info);
 406   static char*  scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found);
 407 
 408   static char*  non_memory_address_word();
 409   // reserve, commit and pin the entire memory region
 410   static char*  reserve_memory_special(size_t size, size_t alignment,
 411                                        char* addr, bool executable);
 412   static bool   release_memory_special(char* addr, size_t bytes);
 413   static void   large_page_init();
 414   static size_t large_page_size();
 415   static bool   can_commit_large_page_memory();
 416   static bool   can_execute_large_page_memory();
 417 
 418   // OS interface to polling page
</pre>
<hr />
<pre>
 454   static bool is_primordial_thread(void)
 455 #if defined(_WINDOWS) || defined(BSD)
 456     // No way to identify the primordial thread.
 457     { return false; }
 458 #else
 459   ;
 460 #endif
 461 
 462   static bool create_attached_thread(JavaThread* thread);
 463   static void pd_start_thread(Thread* thread);
 464   static void start_thread(Thread* thread);
 465 
 466   // Returns true if successful.
 467   static bool signal_thread(Thread* thread, int sig, const char* reason);
 468 
 469   static void free_thread(OSThread* osthread);
 470 
 471   // thread id on Linux/64bit is 64bit, on Windows and Solaris, it&#39;s 32bit
 472   static intx current_thread_id();
 473   static int current_process_id();
<span class="line-modified"> 474   static int sleep(Thread* thread, jlong ms, bool interruptable);</span>
<span class="line-modified"> 475   // Short standalone OS sleep suitable for slow path spin loop.</span>
<span class="line-modified"> 476   // Ignores Thread.interrupt() (so keep it short).</span>
<span class="line-modified"> 477   // ms = 0, will sleep for the least amount of time allowed by the OS.</span>

 478   static void naked_short_sleep(jlong ms);
 479   static void naked_short_nanosleep(jlong ns);
<span class="line-modified"> 480   static void infinite_sleep(); // never returns, use with CAUTION</span>




 481   static void naked_yield () ;
 482   static OSReturn set_priority(Thread* thread, ThreadPriority priority);
 483   static OSReturn get_priority(const Thread* const thread, ThreadPriority&amp; priority);
 484 
<span class="line-removed"> 485   static void interrupt(Thread* thread);</span>
<span class="line-removed"> 486   static bool is_interrupted(Thread* thread, bool clear_interrupted);</span>
<span class="line-removed"> 487 </span>
 488   static int pd_self_suspend_thread(Thread* thread);
 489 
 490   static ExtendedPC fetch_frame_from_context(const void* ucVoid, intptr_t** sp, intptr_t** fp);
 491   static frame      fetch_frame_from_context(const void* ucVoid);
 492   static frame      fetch_frame_from_ucontext(Thread* thread, void* ucVoid);
 493 
 494   static void breakpoint();
 495   static bool start_debugging(char *buf, int buflen);
 496 
 497   static address current_stack_pointer();
 498   static address current_stack_base();
 499   static size_t current_stack_size();
 500 
 501   static void verify_stack_alignment() PRODUCT_RETURN;
 502 
 503   static bool message_box(const char* title, const char* message);
<span class="line-removed"> 504   static char* do_you_want_to_debug(const char* message);</span>
 505 
 506   // run cmd in a separate process and return its exit code; or -1 on failures
 507   static int fork_and_exec(char *cmd, bool use_vfork_if_available = false);
 508 
 509   // Call ::exit() on all platforms but Windows
 510   static void exit(int num);
 511 
 512   // Terminate the VM, but don&#39;t exit the process
 513   static void shutdown();
 514 
 515   // Terminate with an error.  Default is to generate a core file on platforms
 516   // that support such things.  This calls shutdown() and then aborts.
 517   static void abort(bool dump_core, void *siginfo, const void *context);
 518   static void abort(bool dump_core = true);
 519 
 520   // Die immediately, no exit hook, no abort hook, no cleanup.




 521   static void die();
 522 
 523   // File i/o operations
<span class="line-removed"> 524   static const int default_file_open_flags();</span>
 525   static int open(const char *path, int oflag, int mode);
 526   static FILE* open(int fd, const char* mode);
 527   static FILE* fopen(const char* path, const char* mode);
 528   static int close(int fd);
 529   static jlong lseek(int fd, jlong offset, int whence);
 530   // This function, on Windows, canonicalizes a given path (see os_windows.cpp for details).
 531   // On Posix, this function is a noop: it does not change anything and just returns
 532   // the input pointer.
 533   static char* native_path(char *path);
 534   static int ftruncate(int fd, jlong length);
 535   static int fsync(int fd);
 536   static int available(int fd, jlong *bytes);
 537   static int get_fileno(FILE* fp);
 538   static void flockfile(FILE* fp);
 539   static void funlockfile(FILE* fp);
 540 
 541   static int compare_file_modified_times(const char* file1, const char* file2);
 542 


 543   //File i/o operations
 544 
 545   static ssize_t read(int fd, void *buf, unsigned int nBytes);
 546   static ssize_t read_at(int fd, void *buf, unsigned int nBytes, jlong offset);
 547   static size_t write(int fd, const void *buf, unsigned int nBytes);
 548 
 549   // Reading directories.
 550   static DIR*           opendir(const char* dirname);
 551   static struct dirent* readdir(DIR* dirp);
 552   static int            closedir(DIR* dirp);
 553 
 554   // Dynamic library extension
 555   static const char*    dll_file_extension();
 556 
 557   static const char*    get_temp_directory();
 558   static const char*    get_current_directory(char *buf, size_t buflen);
 559 
 560   // Builds the platform-specific name of a library.
 561   // Returns false if the buffer is too small.
 562   static bool           dll_build_name(char* buffer, size_t size,
</pre>
<hr />
<pre>
 574   // to buf. Distance from its base address is optionally returned as offset.
 575   // If function name is not found, buf[0] is set to &#39;\0&#39; and offset is
 576   // set to -1 (if offset is non-NULL).
 577   static bool dll_address_to_function_name(address addr, char* buf,
 578                                            int buflen, int* offset,
 579                                            bool demangle = true);
 580 
 581   // Locate DLL/DSO. On success, full path of the library is copied to
 582   // buf, and offset is optionally set to be the distance between addr
 583   // and the library&#39;s base address. On failure, buf[0] is set to &#39;\0&#39;
 584   // and offset is set to -1 (if offset is non-NULL).
 585   static bool dll_address_to_library_name(address addr, char* buf,
 586                                           int buflen, int* offset);
 587 
 588   // Find out whether the pc is in the static code for jvm.dll/libjvm.so.
 589   static bool address_is_in_vm(address addr);
 590 
 591   // Loads .dll/.so and
 592   // in case of error it checks if .dll/.so was built for the
 593   // same architecture as HotSpot is running on

 594   static void* dll_load(const char *name, char *ebuf, int ebuflen);
 595 
 596   // lookup symbol in a shared library
 597   static void* dll_lookup(void* handle, const char* name);
 598 
 599   // Unload library
 600   static void  dll_unload(void *lib);
 601 
 602   // Callback for loaded module information
 603   // Input parameters:
 604   //    char*     module_file_name,
 605   //    address   module_base_addr,
 606   //    address   module_top_addr,
 607   //    void*     param
 608   typedef int (*LoadedModulesCallbackFunc)(const char *, address, address, void *);
 609 
 610   static int get_loaded_modules_info(LoadedModulesCallbackFunc callback, void *param);
 611 
 612   // Return the handle of this process
 613   static void* get_default_process_handle();
</pre>
<hr />
<pre>
 629   static bool get_host_name(char* buf, size_t buflen);
 630 
 631   // Print out system information; they are called by fatal error handler.
 632   // Output format may be different on different platforms.
 633   static void print_os_info(outputStream* st);
 634   static void print_os_info_brief(outputStream* st);
 635   static void print_cpu_info(outputStream* st, char* buf, size_t buflen);
 636   static void pd_print_cpu_info(outputStream* st, char* buf, size_t buflen);
 637   static void print_summary_info(outputStream* st, char* buf, size_t buflen);
 638   static void print_memory_info(outputStream* st);
 639   static void print_dll_info(outputStream* st);
 640   static void print_environment_variables(outputStream* st, const char** env_list);
 641   static void print_context(outputStream* st, const void* context);
 642   static void print_register_info(outputStream* st, const void* context);
 643   static bool signal_sent_by_kill(const void* siginfo);
 644   static void print_siginfo(outputStream* st, const void* siginfo);
 645   static void print_signal_handlers(outputStream* st, char* buf, size_t buflen);
 646   static void print_date_and_time(outputStream* st, char* buf, size_t buflen);
 647   static void print_instructions(outputStream* st, address pc, int unitsize);
 648 



 649   static void print_location(outputStream* st, intptr_t x, bool verbose = false);
 650   static size_t lasterror(char *buf, size_t len);
 651   static int get_last_error();
 652 
 653   // Replacement for strerror().
 654   // Will return the english description of the error (e.g. &quot;File not found&quot;, as
 655   //  suggested in the POSIX standard.
 656   // Will return &quot;Unknown error&quot; for an unknown errno value.
 657   // Will not attempt to localize the returned string.
 658   // Will always return a valid string which is a static constant.
 659   // Will not change the value of errno.
 660   static const char* strerror(int e);
 661 
 662   // Will return the literalized version of the given errno (e.g. &quot;EINVAL&quot;
 663   //  for EINVAL).
 664   // Will return &quot;Unknown error&quot; for an unknown errno value.
 665   // Will always return a valid string which is a static constant.
 666   // Will not change the value of errno.
 667   static const char* errno_name(int e);
 668 
<span class="line-removed"> 669   // Determines whether the calling process is being debugged by a user-mode debugger.</span>
<span class="line-removed"> 670   static bool is_debugger_attached();</span>
<span class="line-removed"> 671 </span>
 672   // wait for a key press if PauseAtExit is set
 673   static void wait_for_keypress_at_exit(void);
 674 
 675   // The following two functions are used by fatal error handler to trace
 676   // native (C) frames. They are not part of frame.hpp/frame.cpp because
 677   // frame.hpp/cpp assume thread is JavaThread, and also because different
 678   // OS/compiler may have different convention or provide different API to
 679   // walk C frames.
 680   //
 681   // We don&#39;t attempt to become a debugger, so we only follow frames if that
 682   // does not require a lookup in the unwind table, which is part of the binary
 683   // file but may be unsafe to read after a fatal error. So on x86, we can
 684   // only walk stack if %ebp is used as frame pointer; on ia64, it&#39;s not
 685   // possible to walk C stack without having the unwind table.
 686   static bool is_first_C_frame(frame *fr);
 687   static frame get_sender_for_C_frame(frame *fr);
 688 
 689   // return current frame. pc() and sp() are set to NULL on failure.
 690   static frame      current_frame();
 691 
</pre>
<hr />
<pre>
 717 
 718   // IO operations on binary files
 719   static int create_binary_file(const char* path, bool rewrite_existing);
 720   static jlong current_file_offset(int fd);
 721   static jlong seek_to_file_offset(int fd, jlong offset);
 722 
 723   // Retrieve native stack frames.
 724   // Parameter:
 725   //   stack:  an array to storage stack pointers.
 726   //   frames: size of above array.
 727   //   toSkip: number of stack frames to skip at the beginning.
 728   // Return: number of stack frames captured.
 729   static int get_native_stack(address* stack, int size, int toSkip = 0);
 730 
 731   // General allocation (must be MT-safe)
 732   static void* malloc  (size_t size, MEMFLAGS flags, const NativeCallStack&amp; stack);
 733   static void* malloc  (size_t size, MEMFLAGS flags);
 734   static void* realloc (void *memblock, size_t size, MEMFLAGS flag, const NativeCallStack&amp; stack);
 735   static void* realloc (void *memblock, size_t size, MEMFLAGS flag);
 736 

 737   static void  free    (void *memblock);
 738   static char* strdup(const char *, MEMFLAGS flags = mtInternal);  // Like strdup
 739   // Like strdup, but exit VM when strdup() returns NULL
 740   static char* strdup_check_oom(const char*, MEMFLAGS flags = mtInternal);
 741 
 742 #ifndef PRODUCT
 743   static julong num_mallocs;         // # of calls to malloc/realloc
 744   static julong alloc_bytes;         // # of bytes allocated
 745   static julong num_frees;           // # of calls to free
 746   static julong free_bytes;          // # of bytes freed
 747 #endif
 748 
 749   // SocketInterface (ex HPI SocketInterface )
 750   static int socket(int domain, int type, int protocol);
 751   static int socket_close(int fd);
 752   static int recv(int fd, char* buf, size_t nBytes, uint flags);
 753   static int send(int fd, char* buf, size_t nBytes, uint flags);
 754   static int raw_send(int fd, char* buf, size_t nBytes, uint flags);
 755   static int connect(int fd, struct sockaddr* him, socklen_t len);
 756   static struct hostent* get_host_by_name(char* name);
</pre>
<hr />
<pre>
 801   //
 802   // If user_sys_cpu_time is true, user+sys time is returned.
 803   // Otherwise, only user time is returned
 804   static jlong current_thread_cpu_time(bool user_sys_cpu_time);
 805   static jlong thread_cpu_time(Thread* t, bool user_sys_cpu_time);
 806 
 807   // Return a bunch of info about the timers.
 808   // Note that the returned info for these two functions may be different
 809   // on some platforms
 810   static void current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr);
 811   static void thread_cpu_time_info(jvmtiTimerInfo *info_ptr);
 812 
 813   static bool is_thread_cpu_time_supported();
 814 
 815   // System loadavg support.  Returns -1 if load average cannot be obtained.
 816   static int loadavg(double loadavg[], int nelem);
 817 
 818   // Amount beyond the callee frame size that we bang the stack.
 819   static int extra_bang_size_in_bytes();
 820 
<span class="line-modified"> 821   static char** split_path(const char* path, int* n);</span>
 822 
<span class="line-modified"> 823   // Extensions</span>
<span class="line-modified"> 824 #include &quot;runtime/os_ext.hpp&quot;</span>
 825 
 826  public:
 827   class CrashProtectionCallback : public StackObj {
 828   public:
 829     virtual void call() = 0;
 830   };
 831 
 832   // Platform dependent stuff
 833 #ifndef _WINDOWS
 834 # include &quot;os_posix.hpp&quot;
 835 #endif
 836 #include OS_CPU_HEADER(os)
 837 #include OS_HEADER(os)
 838 
 839 #ifndef OS_NATIVE_THREAD_CREATION_FAILED_MSG
 840 #define OS_NATIVE_THREAD_CREATION_FAILED_MSG &quot;unable to create native thread: possibly out of memory or process/resource limits reached&quot;
 841 #endif
 842 
 843  public:
 844 #ifndef PLATFORM_PRINT_NATIVE_STACK
</pre>
<hr />
<pre>
 946     State cancel_suspend() {
 947       return switch_state(SR_SUSPEND_REQUEST, SR_RUNNING);
 948     }
 949 
 950     State suspended() {
 951       return switch_state(SR_SUSPEND_REQUEST, SR_SUSPENDED);
 952     }
 953 
 954     State request_wakeup() {
 955       return switch_state(SR_SUSPENDED, SR_WAKEUP_REQUEST);
 956     }
 957 
 958     State running() {
 959       return switch_state(SR_WAKEUP_REQUEST, SR_RUNNING);
 960     }
 961 
 962     bool is_running() const {
 963       return _state == SR_RUNNING;
 964     }
 965 
<span class="line-removed"> 966     bool is_suspend_request() const {</span>
<span class="line-removed"> 967       return _state == SR_SUSPEND_REQUEST;</span>
<span class="line-removed"> 968     }</span>
<span class="line-removed"> 969 </span>
 970     bool is_suspended() const {
 971       return _state == SR_SUSPENDED;
 972     }
 973   };
 974 #endif // !WINDOWS
 975 
 976 
 977  protected:
 978   static volatile unsigned int _rand_seed;    // seed for random number generator
 979   static int _processor_count;                // number of processors
 980   static int _initial_active_processor_count; // number of active processors during initialization.
 981 
 982   static char* format_boot_path(const char* format_string,
 983                                 const char* home,
 984                                 int home_len,
 985                                 char fileSep,
 986                                 char pathSep);
 987   static bool set_boot_path(char fileSep, char pathSep);
 988 
 989 };
</pre>
</td>
<td>
<hr />
<pre>
  30 #include &quot;metaprogramming/isRegisteredEnum.hpp&quot;
  31 #include &quot;metaprogramming/integralConstant.hpp&quot;
  32 #include &quot;runtime/extendedPC.hpp&quot;
  33 #include &quot;utilities/exceptions.hpp&quot;
  34 #include &quot;utilities/ostream.hpp&quot;
  35 #include &quot;utilities/macros.hpp&quot;
  36 #ifndef _WINDOWS
  37 # include &lt;setjmp.h&gt;
  38 #endif
  39 #ifdef __APPLE__
  40 # include &lt;mach/mach_time.h&gt;
  41 #endif
  42 
  43 class AgentLibrary;
  44 class frame;
  45 
  46 // os defines the interface to operating system; this includes traditional
  47 // OS services (time, I/O) as well as other functionality with system-
  48 // dependent code.
  49 


  50 class Thread;
  51 class JavaThread;
  52 class NativeCallStack;
  53 class methodHandle;
  54 class OSThread;
  55 class Mutex;
  56 
  57 template&lt;class E&gt; class GrowableArray;
  58 
  59 // %%%%% Moved ThreadState, START_FN, OSThread to new osThread.hpp. -- Rose
  60 
  61 // Platform-independent error return values from OS functions
  62 enum OSReturn {
  63   OS_OK         =  0,        // Operation was successful
  64   OS_ERR        = -1,        // Operation failed
  65   OS_INTRPT     = -2,        // Operation was interrupted
  66   OS_TIMEOUT    = -3,        // Operation timed out
  67   OS_NOMEM      = -5,        // Operation failed for lack of memory
  68   OS_NORESOURCE = -6         // Operation failed for lack of nonmemory resource
  69 };
</pre>
<hr />
<pre>
 148 
 149   // Get summary strings for system information in buffer provided
 150   static void  get_summary_cpu_info(char* buf, size_t buflen);
 151   static void  get_summary_os_info(char* buf, size_t buflen);
 152 
 153   static void initialize_initial_active_processor_count();
 154 
 155   LINUX_ONLY(static void pd_init_container_support();)
 156 
 157  public:
 158   static void init(void);                      // Called before command line parsing
 159 
 160   static void init_container_support() {       // Called during command line parsing.
 161      LINUX_ONLY(pd_init_container_support();)
 162   }
 163 
 164   static void init_before_ergo(void);          // Called after command line parsing
 165                                                // before VM ergonomics processing.
 166   static jint init_2(void);                    // Called after command line parsing
 167                                                // and VM ergonomics processing







 168 
 169   // unset environment variable
 170   static bool unsetenv(const char* name);
 171 
 172   static bool have_special_privileges();
 173 
 174   static jlong  javaTimeMillis();
 175   static jlong  javaTimeNanos();
 176   static void   javaTimeNanos_info(jvmtiTimerInfo *info_ptr);
 177   static void   javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos);
 178   static void   run_periodic_checks();
 179   static bool   supports_monotonic_clock();
 180 
 181   // Returns the elapsed time in seconds since the vm started.
 182   static double elapsedTime();
 183 
 184   // Returns real time in seconds since an arbitrary point
 185   // in the past.
 186   static bool getTimesSecs(double* process_real_time,
 187                            double* process_user_time,
 188                            double* process_system_time);
 189 
 190   // Interface to the performance counter
 191   static jlong elapsed_counter();
 192   static jlong elapsed_frequency();
 193 
 194   // The &quot;virtual time&quot; of a thread is the amount of time a thread has
 195   // actually run.  The first function indicates whether the OS supports
<span class="line-modified"> 196   // this functionality for the current thread, and if so the second</span>
<span class="line-modified"> 197   // returns the elapsed virtual time for the current thread.</span>



 198   static bool supports_vtime();


 199   static double elapsedVTime();
 200 
 201   // Return current local time in a string (YYYY-MM-DD HH:MM:SS).
 202   // It is MT safe, but not async-safe, as reading time zone
 203   // information may require a lock on some platforms.
 204   static char*      local_time_string(char *buf, size_t buflen);
 205   static struct tm* localtime_pd     (const time_t* clock, struct tm*  res);
 206   static struct tm* gmtime_pd        (const time_t* clock, struct tm*  res);
 207   // Fill in buffer with current local time as an ISO-8601 string.
 208   // E.g., YYYY-MM-DDThh:mm:ss.mmm+zzzz.
 209   // Returns buffer, or NULL if it failed.
 210   static char* iso8601_time(char* buffer, size_t buffer_length, bool utc = false);
 211 
 212   // Interface for detecting multiprocessor system
 213   static inline bool is_MP() {
 214     // During bootstrap if _processor_count is not yet initialized
 215     // we claim to be MP as that is safest. If any platform has a
 216     // stub generator that might be triggered in this phase and for
 217     // which being declared MP when in fact not, is a problem - then
 218     // the bootstrap routine for the stub generator needs to check
</pre>
<hr />
<pre>
 230   // The returned value is guaranteed to be between 0 and (os::processor_count() - 1).
 231   static uint processor_id();
 232 
 233   // number of CPUs
 234   static int processor_count() {
 235     return _processor_count;
 236   }
 237   static void set_processor_count(int count) { _processor_count = count; }
 238 
 239   // Returns the number of CPUs this process is currently allowed to run on.
 240   // Note that on some OSes this can change dynamically.
 241   static int active_processor_count();
 242 
 243   // At startup the number of active CPUs this process is allowed to run on.
 244   // This value does not change dynamically. May be different from active_processor_count().
 245   static int initial_active_processor_count() {
 246     assert(_initial_active_processor_count &gt; 0, &quot;Initial active processor count not set yet.&quot;);
 247     return _initial_active_processor_count;
 248   }
 249 








 250   // Binds the current process to a processor.
 251   //    Returns true if it worked, false if it didn&#39;t.
 252   static bool bind_to_processor(uint processor_id);
 253 
 254   // Give a name to the current thread.
 255   static void set_native_thread_name(const char *name);
 256 
 257   // Interface for stack banging (predetect possible stack overflow for
 258   // exception processing)  There are guard pages, and above that shadow
 259   // pages for stack overflow checking.
 260   static bool uses_stack_guard_pages();
 261   static bool must_commit_stack_guard_pages();
 262   static void map_stack_shadow_pages(address sp);
 263   static bool stack_shadow_pages_available(Thread *thread, const methodHandle&amp; method, address sp);
 264 
 265   // Find committed memory region within specified range (start, start + size),
 266   // return true if found any
 267   static bool committed_in_range(address start, size_t size, address&amp; committed_start, size_t&amp; committed_size);
 268 
 269   // OS interface to Virtual Memory
</pre>
<hr />
<pre>
 357 
 358   static char*  map_memory(int fd, const char* file_name, size_t file_offset,
 359                            char *addr, size_t bytes, bool read_only = false,
 360                            bool allow_exec = false);
 361   static char*  remap_memory(int fd, const char* file_name, size_t file_offset,
 362                              char *addr, size_t bytes, bool read_only,
 363                              bool allow_exec);
 364   static bool   unmap_memory(char *addr, size_t bytes);
 365   static void   free_memory(char *addr, size_t bytes, size_t alignment_hint);
 366   static void   realign_memory(char *addr, size_t bytes, size_t alignment_hint);
 367 
 368   // NUMA-specific interface
 369   static bool   numa_has_static_binding();
 370   static bool   numa_has_group_homing();
 371   static void   numa_make_local(char *addr, size_t bytes, int lgrp_hint);
 372   static void   numa_make_global(char *addr, size_t bytes);
 373   static size_t numa_get_groups_num();
 374   static size_t numa_get_leaf_groups(int *ids, size_t size);
 375   static bool   numa_topology_changed();
 376   static int    numa_get_group_id();
<span class="line-added"> 377   static int    numa_get_group_id_for_address(const void* address);</span>
 378 
 379   // Page manipulation
 380   struct page_info {
 381     size_t size;
 382     int lgrp_id;
 383   };
 384   static bool   get_page_info(char *start, page_info* info);
 385   static char*  scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found);
 386 
 387   static char*  non_memory_address_word();
 388   // reserve, commit and pin the entire memory region
 389   static char*  reserve_memory_special(size_t size, size_t alignment,
 390                                        char* addr, bool executable);
 391   static bool   release_memory_special(char* addr, size_t bytes);
 392   static void   large_page_init();
 393   static size_t large_page_size();
 394   static bool   can_commit_large_page_memory();
 395   static bool   can_execute_large_page_memory();
 396 
 397   // OS interface to polling page
</pre>
<hr />
<pre>
 433   static bool is_primordial_thread(void)
 434 #if defined(_WINDOWS) || defined(BSD)
 435     // No way to identify the primordial thread.
 436     { return false; }
 437 #else
 438   ;
 439 #endif
 440 
 441   static bool create_attached_thread(JavaThread* thread);
 442   static void pd_start_thread(Thread* thread);
 443   static void start_thread(Thread* thread);
 444 
 445   // Returns true if successful.
 446   static bool signal_thread(Thread* thread, int sig, const char* reason);
 447 
 448   static void free_thread(OSThread* osthread);
 449 
 450   // thread id on Linux/64bit is 64bit, on Windows and Solaris, it&#39;s 32bit
 451   static intx current_thread_id();
 452   static int current_process_id();
<span class="line-modified"> 453 </span>
<span class="line-modified"> 454   // Short standalone OS sleep routines suitable for slow path spin loop.</span>
<span class="line-modified"> 455   // Ignores safepoints/suspension/Thread.interrupt() (so keep it short).</span>
<span class="line-modified"> 456   // ms/ns = 0, will sleep for the least amount of time allowed by the OS.</span>
<span class="line-added"> 457   // Maximum sleep time is just under 1 second.</span>
 458   static void naked_short_sleep(jlong ms);
 459   static void naked_short_nanosleep(jlong ns);
<span class="line-modified"> 460   // Longer standalone OS sleep routine - a convenience wrapper around</span>
<span class="line-added"> 461   // multiple calls to naked_short_sleep. Only for use by non-JavaThreads.</span>
<span class="line-added"> 462   static void naked_sleep(jlong millis);</span>
<span class="line-added"> 463   // Never returns, use with CAUTION</span>
<span class="line-added"> 464   static void infinite_sleep();</span>
 465   static void naked_yield () ;
 466   static OSReturn set_priority(Thread* thread, ThreadPriority priority);
 467   static OSReturn get_priority(const Thread* const thread, ThreadPriority&amp; priority);
 468 



 469   static int pd_self_suspend_thread(Thread* thread);
 470 
 471   static ExtendedPC fetch_frame_from_context(const void* ucVoid, intptr_t** sp, intptr_t** fp);
 472   static frame      fetch_frame_from_context(const void* ucVoid);
 473   static frame      fetch_frame_from_ucontext(Thread* thread, void* ucVoid);
 474 
 475   static void breakpoint();
 476   static bool start_debugging(char *buf, int buflen);
 477 
 478   static address current_stack_pointer();
 479   static address current_stack_base();
 480   static size_t current_stack_size();
 481 
 482   static void verify_stack_alignment() PRODUCT_RETURN;
 483 
 484   static bool message_box(const char* title, const char* message);

 485 
 486   // run cmd in a separate process and return its exit code; or -1 on failures
 487   static int fork_and_exec(char *cmd, bool use_vfork_if_available = false);
 488 
 489   // Call ::exit() on all platforms but Windows
 490   static void exit(int num);
 491 
 492   // Terminate the VM, but don&#39;t exit the process
 493   static void shutdown();
 494 
 495   // Terminate with an error.  Default is to generate a core file on platforms
 496   // that support such things.  This calls shutdown() and then aborts.
 497   static void abort(bool dump_core, void *siginfo, const void *context);
 498   static void abort(bool dump_core = true);
 499 
 500   // Die immediately, no exit hook, no abort hook, no cleanup.
<span class="line-added"> 501   // Dump a core file, if possible, for debugging. os::abort() is the</span>
<span class="line-added"> 502   // preferred means to abort the VM on error. os::die() should only</span>
<span class="line-added"> 503   // be called if something has gone badly wrong. CreateCoredumpOnCrash</span>
<span class="line-added"> 504   // is intentionally not honored by this function.</span>
 505   static void die();
 506 
 507   // File i/o operations

 508   static int open(const char *path, int oflag, int mode);
 509   static FILE* open(int fd, const char* mode);
 510   static FILE* fopen(const char* path, const char* mode);
 511   static int close(int fd);
 512   static jlong lseek(int fd, jlong offset, int whence);
 513   // This function, on Windows, canonicalizes a given path (see os_windows.cpp for details).
 514   // On Posix, this function is a noop: it does not change anything and just returns
 515   // the input pointer.
 516   static char* native_path(char *path);
 517   static int ftruncate(int fd, jlong length);
 518   static int fsync(int fd);
 519   static int available(int fd, jlong *bytes);
 520   static int get_fileno(FILE* fp);
 521   static void flockfile(FILE* fp);
 522   static void funlockfile(FILE* fp);
 523 
 524   static int compare_file_modified_times(const char* file1, const char* file2);
 525 
<span class="line-added"> 526   static bool same_files(const char* file1, const char* file2);</span>
<span class="line-added"> 527 </span>
 528   //File i/o operations
 529 
 530   static ssize_t read(int fd, void *buf, unsigned int nBytes);
 531   static ssize_t read_at(int fd, void *buf, unsigned int nBytes, jlong offset);
 532   static size_t write(int fd, const void *buf, unsigned int nBytes);
 533 
 534   // Reading directories.
 535   static DIR*           opendir(const char* dirname);
 536   static struct dirent* readdir(DIR* dirp);
 537   static int            closedir(DIR* dirp);
 538 
 539   // Dynamic library extension
 540   static const char*    dll_file_extension();
 541 
 542   static const char*    get_temp_directory();
 543   static const char*    get_current_directory(char *buf, size_t buflen);
 544 
 545   // Builds the platform-specific name of a library.
 546   // Returns false if the buffer is too small.
 547   static bool           dll_build_name(char* buffer, size_t size,
</pre>
<hr />
<pre>
 559   // to buf. Distance from its base address is optionally returned as offset.
 560   // If function name is not found, buf[0] is set to &#39;\0&#39; and offset is
 561   // set to -1 (if offset is non-NULL).
 562   static bool dll_address_to_function_name(address addr, char* buf,
 563                                            int buflen, int* offset,
 564                                            bool demangle = true);
 565 
 566   // Locate DLL/DSO. On success, full path of the library is copied to
 567   // buf, and offset is optionally set to be the distance between addr
 568   // and the library&#39;s base address. On failure, buf[0] is set to &#39;\0&#39;
 569   // and offset is set to -1 (if offset is non-NULL).
 570   static bool dll_address_to_library_name(address addr, char* buf,
 571                                           int buflen, int* offset);
 572 
 573   // Find out whether the pc is in the static code for jvm.dll/libjvm.so.
 574   static bool address_is_in_vm(address addr);
 575 
 576   // Loads .dll/.so and
 577   // in case of error it checks if .dll/.so was built for the
 578   // same architecture as HotSpot is running on
<span class="line-added"> 579   // in case of an error NULL is returned and an error message is stored in ebuf</span>
 580   static void* dll_load(const char *name, char *ebuf, int ebuflen);
 581 
 582   // lookup symbol in a shared library
 583   static void* dll_lookup(void* handle, const char* name);
 584 
 585   // Unload library
 586   static void  dll_unload(void *lib);
 587 
 588   // Callback for loaded module information
 589   // Input parameters:
 590   //    char*     module_file_name,
 591   //    address   module_base_addr,
 592   //    address   module_top_addr,
 593   //    void*     param
 594   typedef int (*LoadedModulesCallbackFunc)(const char *, address, address, void *);
 595 
 596   static int get_loaded_modules_info(LoadedModulesCallbackFunc callback, void *param);
 597 
 598   // Return the handle of this process
 599   static void* get_default_process_handle();
</pre>
<hr />
<pre>
 615   static bool get_host_name(char* buf, size_t buflen);
 616 
 617   // Print out system information; they are called by fatal error handler.
 618   // Output format may be different on different platforms.
 619   static void print_os_info(outputStream* st);
 620   static void print_os_info_brief(outputStream* st);
 621   static void print_cpu_info(outputStream* st, char* buf, size_t buflen);
 622   static void pd_print_cpu_info(outputStream* st, char* buf, size_t buflen);
 623   static void print_summary_info(outputStream* st, char* buf, size_t buflen);
 624   static void print_memory_info(outputStream* st);
 625   static void print_dll_info(outputStream* st);
 626   static void print_environment_variables(outputStream* st, const char** env_list);
 627   static void print_context(outputStream* st, const void* context);
 628   static void print_register_info(outputStream* st, const void* context);
 629   static bool signal_sent_by_kill(const void* siginfo);
 630   static void print_siginfo(outputStream* st, const void* siginfo);
 631   static void print_signal_handlers(outputStream* st, char* buf, size_t buflen);
 632   static void print_date_and_time(outputStream* st, char* buf, size_t buflen);
 633   static void print_instructions(outputStream* st, address pc, int unitsize);
 634 
<span class="line-added"> 635   // helper for output of seconds in days , hours and months</span>
<span class="line-added"> 636   static void print_dhm(outputStream* st, const char* startStr, long sec);</span>
<span class="line-added"> 637 </span>
 638   static void print_location(outputStream* st, intptr_t x, bool verbose = false);
 639   static size_t lasterror(char *buf, size_t len);
 640   static int get_last_error();
 641 
 642   // Replacement for strerror().
 643   // Will return the english description of the error (e.g. &quot;File not found&quot;, as
 644   //  suggested in the POSIX standard.
 645   // Will return &quot;Unknown error&quot; for an unknown errno value.
 646   // Will not attempt to localize the returned string.
 647   // Will always return a valid string which is a static constant.
 648   // Will not change the value of errno.
 649   static const char* strerror(int e);
 650 
 651   // Will return the literalized version of the given errno (e.g. &quot;EINVAL&quot;
 652   //  for EINVAL).
 653   // Will return &quot;Unknown error&quot; for an unknown errno value.
 654   // Will always return a valid string which is a static constant.
 655   // Will not change the value of errno.
 656   static const char* errno_name(int e);
 657 



 658   // wait for a key press if PauseAtExit is set
 659   static void wait_for_keypress_at_exit(void);
 660 
 661   // The following two functions are used by fatal error handler to trace
 662   // native (C) frames. They are not part of frame.hpp/frame.cpp because
 663   // frame.hpp/cpp assume thread is JavaThread, and also because different
 664   // OS/compiler may have different convention or provide different API to
 665   // walk C frames.
 666   //
 667   // We don&#39;t attempt to become a debugger, so we only follow frames if that
 668   // does not require a lookup in the unwind table, which is part of the binary
 669   // file but may be unsafe to read after a fatal error. So on x86, we can
 670   // only walk stack if %ebp is used as frame pointer; on ia64, it&#39;s not
 671   // possible to walk C stack without having the unwind table.
 672   static bool is_first_C_frame(frame *fr);
 673   static frame get_sender_for_C_frame(frame *fr);
 674 
 675   // return current frame. pc() and sp() are set to NULL on failure.
 676   static frame      current_frame();
 677 
</pre>
<hr />
<pre>
 703 
 704   // IO operations on binary files
 705   static int create_binary_file(const char* path, bool rewrite_existing);
 706   static jlong current_file_offset(int fd);
 707   static jlong seek_to_file_offset(int fd, jlong offset);
 708 
 709   // Retrieve native stack frames.
 710   // Parameter:
 711   //   stack:  an array to storage stack pointers.
 712   //   frames: size of above array.
 713   //   toSkip: number of stack frames to skip at the beginning.
 714   // Return: number of stack frames captured.
 715   static int get_native_stack(address* stack, int size, int toSkip = 0);
 716 
 717   // General allocation (must be MT-safe)
 718   static void* malloc  (size_t size, MEMFLAGS flags, const NativeCallStack&amp; stack);
 719   static void* malloc  (size_t size, MEMFLAGS flags);
 720   static void* realloc (void *memblock, size_t size, MEMFLAGS flag, const NativeCallStack&amp; stack);
 721   static void* realloc (void *memblock, size_t size, MEMFLAGS flag);
 722 
<span class="line-added"> 723   // handles NULL pointers</span>
 724   static void  free    (void *memblock);
 725   static char* strdup(const char *, MEMFLAGS flags = mtInternal);  // Like strdup
 726   // Like strdup, but exit VM when strdup() returns NULL
 727   static char* strdup_check_oom(const char*, MEMFLAGS flags = mtInternal);
 728 
 729 #ifndef PRODUCT
 730   static julong num_mallocs;         // # of calls to malloc/realloc
 731   static julong alloc_bytes;         // # of bytes allocated
 732   static julong num_frees;           // # of calls to free
 733   static julong free_bytes;          // # of bytes freed
 734 #endif
 735 
 736   // SocketInterface (ex HPI SocketInterface )
 737   static int socket(int domain, int type, int protocol);
 738   static int socket_close(int fd);
 739   static int recv(int fd, char* buf, size_t nBytes, uint flags);
 740   static int send(int fd, char* buf, size_t nBytes, uint flags);
 741   static int raw_send(int fd, char* buf, size_t nBytes, uint flags);
 742   static int connect(int fd, struct sockaddr* him, socklen_t len);
 743   static struct hostent* get_host_by_name(char* name);
</pre>
<hr />
<pre>
 788   //
 789   // If user_sys_cpu_time is true, user+sys time is returned.
 790   // Otherwise, only user time is returned
 791   static jlong current_thread_cpu_time(bool user_sys_cpu_time);
 792   static jlong thread_cpu_time(Thread* t, bool user_sys_cpu_time);
 793 
 794   // Return a bunch of info about the timers.
 795   // Note that the returned info for these two functions may be different
 796   // on some platforms
 797   static void current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr);
 798   static void thread_cpu_time_info(jvmtiTimerInfo *info_ptr);
 799 
 800   static bool is_thread_cpu_time_supported();
 801 
 802   // System loadavg support.  Returns -1 if load average cannot be obtained.
 803   static int loadavg(double loadavg[], int nelem);
 804 
 805   // Amount beyond the callee frame size that we bang the stack.
 806   static int extra_bang_size_in_bytes();
 807 
<span class="line-modified"> 808   static char** split_path(const char* path, size_t* elements, size_t file_name_length);</span>
 809 
<span class="line-modified"> 810   // support for mapping non-volatile memory using MAP_SYNC</span>
<span class="line-modified"> 811   static bool supports_map_sync();</span>
 812 
 813  public:
 814   class CrashProtectionCallback : public StackObj {
 815   public:
 816     virtual void call() = 0;
 817   };
 818 
 819   // Platform dependent stuff
 820 #ifndef _WINDOWS
 821 # include &quot;os_posix.hpp&quot;
 822 #endif
 823 #include OS_CPU_HEADER(os)
 824 #include OS_HEADER(os)
 825 
 826 #ifndef OS_NATIVE_THREAD_CREATION_FAILED_MSG
 827 #define OS_NATIVE_THREAD_CREATION_FAILED_MSG &quot;unable to create native thread: possibly out of memory or process/resource limits reached&quot;
 828 #endif
 829 
 830  public:
 831 #ifndef PLATFORM_PRINT_NATIVE_STACK
</pre>
<hr />
<pre>
 933     State cancel_suspend() {
 934       return switch_state(SR_SUSPEND_REQUEST, SR_RUNNING);
 935     }
 936 
 937     State suspended() {
 938       return switch_state(SR_SUSPEND_REQUEST, SR_SUSPENDED);
 939     }
 940 
 941     State request_wakeup() {
 942       return switch_state(SR_SUSPENDED, SR_WAKEUP_REQUEST);
 943     }
 944 
 945     State running() {
 946       return switch_state(SR_WAKEUP_REQUEST, SR_RUNNING);
 947     }
 948 
 949     bool is_running() const {
 950       return _state == SR_RUNNING;
 951     }
 952 




 953     bool is_suspended() const {
 954       return _state == SR_SUSPENDED;
 955     }
 956   };
 957 #endif // !WINDOWS
 958 
 959 
 960  protected:
 961   static volatile unsigned int _rand_seed;    // seed for random number generator
 962   static int _processor_count;                // number of processors
 963   static int _initial_active_processor_count; // number of active processors during initialization.
 964 
 965   static char* format_boot_path(const char* format_string,
 966                                 const char* home,
 967                                 int home_len,
 968                                 char fileSep,
 969                                 char pathSep);
 970   static bool set_boot_path(char fileSep, char pathSep);
 971 
 972 };
</pre>
</td>
</tr>
</table>
<center><a href="os.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="osThread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/reflection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="perfMemory.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/reflection.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  75       }
  76     }
  77   }
  78   if (caller != NULL) {
  79     const char * from = caller-&gt;external_name();
  80     const char * to = to_class-&gt;external_name();
  81     // print in a single call to reduce interleaving between threads
  82     if (source_file != NULL) {
  83       log_debug(class, resolve)(&quot;%s %s %s:%d (reflection)&quot;, from, to, source_file, line_number);
  84     } else {
  85       log_debug(class, resolve)(&quot;%s %s (reflection)&quot;, from, to);
  86     }
  87   }
  88 }
  89 
  90 
  91 oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
  92   if (type == T_VOID) {
  93     return NULL;
  94   }
<span class="line-modified">  95   if (type == T_OBJECT || type == T_ARRAY) {</span>
  96     // regular objects are not boxed
  97     return (oop) value-&gt;l;
  98   }
  99   oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
 100   if (result == NULL) {
 101     THROW_(vmSymbols::java_lang_IllegalArgumentException(), result);
 102   }
 103   return result;
 104 }
 105 
 106 
 107 BasicType Reflection::unbox_for_primitive(oop box, jvalue* value, TRAPS) {
 108   if (box == NULL) {
 109     THROW_(vmSymbols::java_lang_IllegalArgumentException(), T_ILLEGAL);
 110   }
 111   return java_lang_boxing_object::get_value(box, value);
 112 }
 113 
 114 BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
 115   // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
<span class="line-modified"> 116   value-&gt;l = (jobject) box;</span>
 117   return T_OBJECT;
 118 }
 119 
 120 
 121 void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
 122   assert(wide_type != current_type, &quot;widen should not be called with identical types&quot;);
 123   switch (wide_type) {
 124     case T_BOOLEAN:
 125     case T_BYTE:
 126     case T_CHAR:
 127       break;  // fail
 128     case T_SHORT:
 129       switch (current_type) {
 130         case T_BYTE:
 131           value-&gt;s = (jshort) value-&gt;b;
 132           return;
 133         default:
 134           break;
 135       }
 136       break;  // fail
</pre>
<hr />
<pre>
 207           return;
 208         case T_LONG:
 209           value-&gt;d = (jdouble) value-&gt;j;
 210           return;
 211         default:
 212           break;
 213       }
 214       break;  // fail
 215     default:
 216       break;  // fail
 217   }
 218   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
 219 }
 220 
 221 
 222 BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
 223   if (!a-&gt;is_within_bounds(index)) {
 224     THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
 225   }
 226   if (a-&gt;is_objArray()) {
<span class="line-modified"> 227     value-&gt;l = (jobject) objArrayOop(a)-&gt;obj_at(index);</span>
 228     return T_OBJECT;
 229   } else {
 230     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 231     BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 232     switch (type) {
 233       case T_BOOLEAN:
 234         value-&gt;z = typeArrayOop(a)-&gt;bool_at(index);
 235         break;
 236       case T_CHAR:
 237         value-&gt;c = typeArrayOop(a)-&gt;char_at(index);
 238         break;
 239       case T_FLOAT:
 240         value-&gt;f = typeArrayOop(a)-&gt;float_at(index);
 241         break;
 242       case T_DOUBLE:
 243         value-&gt;d = typeArrayOop(a)-&gt;double_at(index);
 244         break;
 245       case T_BYTE:
 246         value-&gt;b = typeArrayOop(a)-&gt;byte_at(index);
 247         break;
</pre>
<hr />
<pre>
 739     }
 740   }
 741 
 742   // &#39;inner&#39; not declared as an inner klass in outer
 743   ResourceMark rm(THREAD);
 744   Exceptions::fthrow(
 745     THREAD_AND_LOCATION,
 746     vmSymbols::java_lang_IncompatibleClassChangeError(),
 747     &quot;%s and %s disagree on InnerClasses attribute&quot;,
 748     outer-&gt;external_name(),
 749     inner-&gt;external_name()
 750   );
 751 }
 752 
 753 // Utility method converting a single SignatureStream element into java.lang.Class instance
 754 static oop get_mirror_from_signature(const methodHandle&amp; method,
 755                                      SignatureStream* ss,
 756                                      TRAPS) {
 757 
 758 
<span class="line-modified"> 759   if (T_OBJECT == ss-&gt;type() || T_ARRAY == ss-&gt;type()) {</span>
<span class="line-modified"> 760     Symbol* name = ss-&gt;as_symbol(CHECK_NULL);</span>
 761     oop loader = method-&gt;method_holder()-&gt;class_loader();
 762     oop protection_domain = method-&gt;method_holder()-&gt;protection_domain();
 763     const Klass* k = SystemDictionary::resolve_or_fail(name,
 764                                                        Handle(THREAD, loader),
 765                                                        Handle(THREAD, protection_domain),
 766                                                        true,
 767                                                        CHECK_NULL);
 768     if (log_is_enabled(Debug, class, resolve)) {
 769       trace_class_resolution(k);
 770     }
 771     return k-&gt;java_mirror();
 772   }
 773 
 774   assert(ss-&gt;type() != T_VOID || ss-&gt;at_return_type(),
 775     &quot;T_VOID should only appear as return type&quot;);
 776 
 777   return java_lang_Class::primitive_mirror(ss-&gt;type());
 778 }
 779 
 780 static objArrayHandle get_parameter_types(const methodHandle&amp; method,
</pre>
<hr />
<pre>
 791   SignatureStream ss(signature);
 792   while (!ss.at_return_type()) {
 793     oop mirror = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 794     mirrors-&gt;obj_at_put(index++, mirror);
 795     ss.next();
 796   }
 797   assert(index == parameter_count, &quot;invalid parameter count&quot;);
 798   if (return_type != NULL) {
 799     // Collect return type as well
 800     assert(ss.at_return_type(), &quot;return type should be present&quot;);
 801     *return_type = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 802   }
 803   return mirrors;
 804 }
 805 
 806 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 807   return method-&gt;resolved_checked_exceptions(THREAD);
 808 }
 809 
 810 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {

 811   // Basic types
<span class="line-modified"> 812   BasicType type = vmSymbols::signature_type(signature);</span>
 813   if (type != T_OBJECT) {
 814     return Handle(THREAD, Universe::java_mirror(type));
 815   }
 816 
 817   Klass* result =
 818     SystemDictionary::resolve_or_fail(signature,
 819                                       Handle(THREAD, k-&gt;class_loader()),
 820                                       Handle(THREAD, k-&gt;protection_domain()),
 821                                       true, CHECK_(Handle()));
 822 
 823   if (log_is_enabled(Debug, class, resolve)) {
 824     trace_class_resolution(result);
 825   }
 826 
 827   oop nt = result-&gt;java_mirror();
 828   return Handle(THREAD, nt);
 829 }
 830 
 831 
 832 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
</pre>
<hr />
<pre>
 961   java_lang_reflect_Parameter::set_index(rh(), index);
 962   return rh();
 963 }
 964 
 965 
 966 static methodHandle resolve_interface_call(InstanceKlass* klass,
 967                                            const methodHandle&amp; method,
 968                                            Klass* recv_klass,
 969                                            Handle receiver,
 970                                            TRAPS) {
 971 
 972   assert(!method.is_null() , &quot;method should not be null&quot;);
 973 
 974   CallInfo info;
 975   Symbol*  signature  = method-&gt;signature();
 976   Symbol*  name       = method-&gt;name();
 977   LinkResolver::resolve_interface_call(info, receiver, recv_klass,
 978                                        LinkInfo(klass, name, signature),
 979                                        true,
 980                                        CHECK_(methodHandle()));
<span class="line-modified"> 981   return info.selected_method();</span>
 982 }
 983 
 984 // Conversion
 985 static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
 986   assert(java_lang_Class::is_primitive(basic_type_mirror),
 987     &quot;just checking&quot;);
 988   return java_lang_Class::primitive_type(basic_type_mirror);
 989 }
 990 
 991 // Narrowing of basic types. Used to create correct jvalues for
 992 // boolean, byte, char and short return return values from interpreter
 993 // which are returned as ints. Throws IllegalArgumentException.
 994 static void narrow(jvalue* value, BasicType narrow_type, TRAPS) {
 995   switch (narrow_type) {
 996   case T_BOOLEAN:
 997     value-&gt;z = (jboolean) (value-&gt;i &amp; 1);
 998     return;
 999   case T_BYTE:
1000     value-&gt;b = (jbyte)value-&gt;i;
1001     return;
</pre>
<hr />
<pre>
1068             JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1069           }
1070           JavaCallArguments args(Handle(THREAD, resolution_exception));
1071           THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1072                       vmSymbols::throwable_void_signature(),
1073                       &amp;args);
1074         }
1075       }  else {
1076         // if the method can be overridden, we resolve using the vtable index.
1077         assert(!reflected_method-&gt;has_itable_index(), &quot;&quot;);
1078         int index = reflected_method-&gt;vtable_index();
1079         method = reflected_method;
1080         if (index != Method::nonvirtual_vtable_index) {
1081           method = methodHandle(THREAD, target_klass-&gt;method_at_vtable(index));
1082         }
1083         if (!method.is_null()) {
1084           // Check for abstract methods as well
1085           if (method-&gt;is_abstract()) {
1086             // new default: 6531596
1087             ResourceMark rm(THREAD);




1088             Handle h_origexception = Exceptions::new_exception(THREAD,
<span class="line-modified">1089               vmSymbols::java_lang_AbstractMethodError(),</span>
<span class="line-removed">1090               Method::name_and_sig_as_C_string(target_klass,</span>
<span class="line-removed">1091               method-&gt;name(),</span>
<span class="line-removed">1092               method-&gt;signature()));</span>
1093             JavaCallArguments args(h_origexception);
1094             THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1095               vmSymbols::throwable_void_signature(),
1096               &amp;args);
1097           }
1098         }
1099       }
1100     }
1101   }
1102 
1103   // I believe this is a ShouldNotGetHere case which requires
1104   // an internal vtable bug. If you ever get this please let Karen know.
1105   if (method.is_null()) {
1106     ResourceMark rm(THREAD);
<span class="line-modified">1107     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(),</span>
<span class="line-modified">1108                 Method::name_and_sig_as_C_string(klass,</span>
<span class="line-modified">1109                 reflected_method-&gt;name(),</span>
<span class="line-modified">1110                 reflected_method-&gt;signature()));</span>



1111   }
1112 
1113   assert(ptypes-&gt;is_objArray(), &quot;just checking&quot;);
1114   int args_len = args.is_null() ? 0 : args-&gt;length();
1115   // Check number of arguments
1116   if (ptypes-&gt;length() != args_len) {
1117     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1118                 &quot;wrong number of arguments&quot;);
1119   }
1120 
1121   // Create object to contain parameters for the JavaCall
1122   JavaCallArguments java_args(method-&gt;size_of_parameters());
1123 
1124   if (!is_static) {
1125     java_args.push_oop(receiver);
1126   }
1127 
1128   for (int i = 0; i &lt; args_len; i++) {
1129     oop type_mirror = ptypes-&gt;obj_at(i);
1130     oop arg = args-&gt;obj_at(i);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  75       }
  76     }
  77   }
  78   if (caller != NULL) {
  79     const char * from = caller-&gt;external_name();
  80     const char * to = to_class-&gt;external_name();
  81     // print in a single call to reduce interleaving between threads
  82     if (source_file != NULL) {
  83       log_debug(class, resolve)(&quot;%s %s %s:%d (reflection)&quot;, from, to, source_file, line_number);
  84     } else {
  85       log_debug(class, resolve)(&quot;%s %s (reflection)&quot;, from, to);
  86     }
  87   }
  88 }
  89 
  90 
  91 oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
  92   if (type == T_VOID) {
  93     return NULL;
  94   }
<span class="line-modified">  95   if (is_reference_type(type)) {</span>
  96     // regular objects are not boxed
  97     return (oop) value-&gt;l;
  98   }
  99   oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
 100   if (result == NULL) {
 101     THROW_(vmSymbols::java_lang_IllegalArgumentException(), result);
 102   }
 103   return result;
 104 }
 105 
 106 
 107 BasicType Reflection::unbox_for_primitive(oop box, jvalue* value, TRAPS) {
 108   if (box == NULL) {
 109     THROW_(vmSymbols::java_lang_IllegalArgumentException(), T_ILLEGAL);
 110   }
 111   return java_lang_boxing_object::get_value(box, value);
 112 }
 113 
 114 BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
 115   // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
<span class="line-modified"> 116   value-&gt;l = cast_from_oop&lt;jobject&gt;(box);</span>
 117   return T_OBJECT;
 118 }
 119 
 120 
 121 void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
 122   assert(wide_type != current_type, &quot;widen should not be called with identical types&quot;);
 123   switch (wide_type) {
 124     case T_BOOLEAN:
 125     case T_BYTE:
 126     case T_CHAR:
 127       break;  // fail
 128     case T_SHORT:
 129       switch (current_type) {
 130         case T_BYTE:
 131           value-&gt;s = (jshort) value-&gt;b;
 132           return;
 133         default:
 134           break;
 135       }
 136       break;  // fail
</pre>
<hr />
<pre>
 207           return;
 208         case T_LONG:
 209           value-&gt;d = (jdouble) value-&gt;j;
 210           return;
 211         default:
 212           break;
 213       }
 214       break;  // fail
 215     default:
 216       break;  // fail
 217   }
 218   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
 219 }
 220 
 221 
 222 BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
 223   if (!a-&gt;is_within_bounds(index)) {
 224     THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
 225   }
 226   if (a-&gt;is_objArray()) {
<span class="line-modified"> 227     value-&gt;l = cast_from_oop&lt;jobject&gt;(objArrayOop(a)-&gt;obj_at(index));</span>
 228     return T_OBJECT;
 229   } else {
 230     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 231     BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 232     switch (type) {
 233       case T_BOOLEAN:
 234         value-&gt;z = typeArrayOop(a)-&gt;bool_at(index);
 235         break;
 236       case T_CHAR:
 237         value-&gt;c = typeArrayOop(a)-&gt;char_at(index);
 238         break;
 239       case T_FLOAT:
 240         value-&gt;f = typeArrayOop(a)-&gt;float_at(index);
 241         break;
 242       case T_DOUBLE:
 243         value-&gt;d = typeArrayOop(a)-&gt;double_at(index);
 244         break;
 245       case T_BYTE:
 246         value-&gt;b = typeArrayOop(a)-&gt;byte_at(index);
 247         break;
</pre>
<hr />
<pre>
 739     }
 740   }
 741 
 742   // &#39;inner&#39; not declared as an inner klass in outer
 743   ResourceMark rm(THREAD);
 744   Exceptions::fthrow(
 745     THREAD_AND_LOCATION,
 746     vmSymbols::java_lang_IncompatibleClassChangeError(),
 747     &quot;%s and %s disagree on InnerClasses attribute&quot;,
 748     outer-&gt;external_name(),
 749     inner-&gt;external_name()
 750   );
 751 }
 752 
 753 // Utility method converting a single SignatureStream element into java.lang.Class instance
 754 static oop get_mirror_from_signature(const methodHandle&amp; method,
 755                                      SignatureStream* ss,
 756                                      TRAPS) {
 757 
 758 
<span class="line-modified"> 759   if (is_reference_type(ss-&gt;type())) {</span>
<span class="line-modified"> 760     Symbol* name = ss-&gt;as_symbol();</span>
 761     oop loader = method-&gt;method_holder()-&gt;class_loader();
 762     oop protection_domain = method-&gt;method_holder()-&gt;protection_domain();
 763     const Klass* k = SystemDictionary::resolve_or_fail(name,
 764                                                        Handle(THREAD, loader),
 765                                                        Handle(THREAD, protection_domain),
 766                                                        true,
 767                                                        CHECK_NULL);
 768     if (log_is_enabled(Debug, class, resolve)) {
 769       trace_class_resolution(k);
 770     }
 771     return k-&gt;java_mirror();
 772   }
 773 
 774   assert(ss-&gt;type() != T_VOID || ss-&gt;at_return_type(),
 775     &quot;T_VOID should only appear as return type&quot;);
 776 
 777   return java_lang_Class::primitive_mirror(ss-&gt;type());
 778 }
 779 
 780 static objArrayHandle get_parameter_types(const methodHandle&amp; method,
</pre>
<hr />
<pre>
 791   SignatureStream ss(signature);
 792   while (!ss.at_return_type()) {
 793     oop mirror = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 794     mirrors-&gt;obj_at_put(index++, mirror);
 795     ss.next();
 796   }
 797   assert(index == parameter_count, &quot;invalid parameter count&quot;);
 798   if (return_type != NULL) {
 799     // Collect return type as well
 800     assert(ss.at_return_type(), &quot;return type should be present&quot;);
 801     *return_type = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 802   }
 803   return mirrors;
 804 }
 805 
 806 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 807   return method-&gt;resolved_checked_exceptions(THREAD);
 808 }
 809 
 810 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
<span class="line-added"> 811   SignatureStream ss(signature, false);</span>
 812   // Basic types
<span class="line-modified"> 813   BasicType type = ss.is_reference() ? T_OBJECT : ss.type();</span>
 814   if (type != T_OBJECT) {
 815     return Handle(THREAD, Universe::java_mirror(type));
 816   }
 817 
 818   Klass* result =
 819     SystemDictionary::resolve_or_fail(signature,
 820                                       Handle(THREAD, k-&gt;class_loader()),
 821                                       Handle(THREAD, k-&gt;protection_domain()),
 822                                       true, CHECK_(Handle()));
 823 
 824   if (log_is_enabled(Debug, class, resolve)) {
 825     trace_class_resolution(result);
 826   }
 827 
 828   oop nt = result-&gt;java_mirror();
 829   return Handle(THREAD, nt);
 830 }
 831 
 832 
 833 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
</pre>
<hr />
<pre>
 962   java_lang_reflect_Parameter::set_index(rh(), index);
 963   return rh();
 964 }
 965 
 966 
 967 static methodHandle resolve_interface_call(InstanceKlass* klass,
 968                                            const methodHandle&amp; method,
 969                                            Klass* recv_klass,
 970                                            Handle receiver,
 971                                            TRAPS) {
 972 
 973   assert(!method.is_null() , &quot;method should not be null&quot;);
 974 
 975   CallInfo info;
 976   Symbol*  signature  = method-&gt;signature();
 977   Symbol*  name       = method-&gt;name();
 978   LinkResolver::resolve_interface_call(info, receiver, recv_klass,
 979                                        LinkInfo(klass, name, signature),
 980                                        true,
 981                                        CHECK_(methodHandle()));
<span class="line-modified"> 982   return methodHandle(THREAD, info.selected_method());</span>
 983 }
 984 
 985 // Conversion
 986 static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
 987   assert(java_lang_Class::is_primitive(basic_type_mirror),
 988     &quot;just checking&quot;);
 989   return java_lang_Class::primitive_type(basic_type_mirror);
 990 }
 991 
 992 // Narrowing of basic types. Used to create correct jvalues for
 993 // boolean, byte, char and short return return values from interpreter
 994 // which are returned as ints. Throws IllegalArgumentException.
 995 static void narrow(jvalue* value, BasicType narrow_type, TRAPS) {
 996   switch (narrow_type) {
 997   case T_BOOLEAN:
 998     value-&gt;z = (jboolean) (value-&gt;i &amp; 1);
 999     return;
1000   case T_BYTE:
1001     value-&gt;b = (jbyte)value-&gt;i;
1002     return;
</pre>
<hr />
<pre>
1069             JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1070           }
1071           JavaCallArguments args(Handle(THREAD, resolution_exception));
1072           THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1073                       vmSymbols::throwable_void_signature(),
1074                       &amp;args);
1075         }
1076       }  else {
1077         // if the method can be overridden, we resolve using the vtable index.
1078         assert(!reflected_method-&gt;has_itable_index(), &quot;&quot;);
1079         int index = reflected_method-&gt;vtable_index();
1080         method = reflected_method;
1081         if (index != Method::nonvirtual_vtable_index) {
1082           method = methodHandle(THREAD, target_klass-&gt;method_at_vtable(index));
1083         }
1084         if (!method.is_null()) {
1085           // Check for abstract methods as well
1086           if (method-&gt;is_abstract()) {
1087             // new default: 6531596
1088             ResourceMark rm(THREAD);
<span class="line-added">1089             stringStream ss;</span>
<span class="line-added">1090             ss.print(&quot;&#39;&quot;);</span>
<span class="line-added">1091             Method::print_external_name(&amp;ss, target_klass, method-&gt;name(), method-&gt;signature());</span>
<span class="line-added">1092             ss.print(&quot;&#39;&quot;);</span>
1093             Handle h_origexception = Exceptions::new_exception(THREAD,
<span class="line-modified">1094               vmSymbols::java_lang_AbstractMethodError(), ss.as_string());</span>



1095             JavaCallArguments args(h_origexception);
1096             THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1097               vmSymbols::throwable_void_signature(),
1098               &amp;args);
1099           }
1100         }
1101       }
1102     }
1103   }
1104 
1105   // I believe this is a ShouldNotGetHere case which requires
1106   // an internal vtable bug. If you ever get this please let Karen know.
1107   if (method.is_null()) {
1108     ResourceMark rm(THREAD);
<span class="line-modified">1109     stringStream ss;</span>
<span class="line-modified">1110     ss.print(&quot;&#39;&quot;);</span>
<span class="line-modified">1111     Method::print_external_name(&amp;ss, klass,</span>
<span class="line-modified">1112                                      reflected_method-&gt;name(),</span>
<span class="line-added">1113                                      reflected_method-&gt;signature());</span>
<span class="line-added">1114     ss.print(&quot;&#39;&quot;);</span>
<span class="line-added">1115     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());</span>
1116   }
1117 
1118   assert(ptypes-&gt;is_objArray(), &quot;just checking&quot;);
1119   int args_len = args.is_null() ? 0 : args-&gt;length();
1120   // Check number of arguments
1121   if (ptypes-&gt;length() != args_len) {
1122     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1123                 &quot;wrong number of arguments&quot;);
1124   }
1125 
1126   // Create object to contain parameters for the JavaCall
1127   JavaCallArguments java_args(method-&gt;size_of_parameters());
1128 
1129   if (!is_static) {
1130     java_args.push_oop(receiver);
1131   }
1132 
1133   for (int i = 0; i &lt; args_len; i++) {
1134     oop type_mirror = ptypes-&gt;obj_at(i);
1135     oop arg = args-&gt;obj_at(i);
</pre>
</td>
</tr>
</table>
<center><a href="perfMemory.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/interfaceSupport.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
 26 #define SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
 27 
 28 #include &quot;runtime/handles.inline.hpp&quot;
 29 #include &quot;runtime/mutexLocker.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/os.hpp&quot;
 32 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
 33 #include &quot;runtime/safepointVerifiers.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #include &quot;runtime/vmOperations.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 #include &quot;utilities/preserveException.hpp&quot;
 39 
 40 // Wrapper for all entry points to the virtual machine.
 41 
 42 // InterfaceSupport provides functionality used by the VM_LEAF_BASE and
 43 // VM_ENTRY_BASE macros. These macros are used to guard entry points into
 44 // the VM and perform checks upon leave of the VM.
 45 
 46 
 47 class InterfaceSupport: AllStatic {
 48 # ifdef ASSERT
 49  public:
 50   static long _scavenge_alot_counter;
 51   static long _fullgc_alot_counter;
 52   static long _number_of_calls;
 53   static long _fullgc_alot_invocation;
 54 
 55   // Helper methods used to implement +ScavengeALot and +FullGCALot
 56   static void check_gc_alot() { if (ScavengeALot || FullGCALot) gc_alot(); }
 57   static void gc_alot();
 58 
 59   static void walk_stack_from(vframe* start_vf);
 60   static void walk_stack();
 61 
 62   static void zombieAll();
 63   static void deoptimizeAll();
 64   static void stress_derived_pointers();
 65   static void verify_stack();
 66   static void verify_last_frame();
 67 # endif
 68 
 69  public:
 70   static void serialize_thread_state_with_handler(JavaThread* thread) {
 71     serialize_thread_state_internal(thread, true);
 72   }
 73 
 74   // Should only call this if we know that we have a proper SEH set up.
 75   static void serialize_thread_state(JavaThread* thread) {
 76     serialize_thread_state_internal(thread, false);
 77   }
 78 
 79  private:
 80   static void serialize_thread_state_internal(JavaThread* thread, bool needs_exception_handler) {
 81     // Make sure new state is seen by VM thread
 82     OrderAccess::fence();
 83   }
 84 };
 85 
 86 
 87 // Basic class for all thread transition classes.
 88 
 89 class ThreadStateTransition : public StackObj {
 90  protected:
 91   JavaThread* _thread;
 92  public:
 93   ThreadStateTransition(JavaThread *thread) {
 94     _thread = thread;
 95     assert(thread != NULL &amp;&amp; thread-&gt;is_Java_thread(), &quot;must be Java thread&quot;);
 96   }
 97 
 98   // Change threadstate in a manner, so safepoint can detect changes.
 99   // Time-critical: called on exit from every runtime routine
100   static inline void transition(JavaThread *thread, JavaThreadState from, JavaThreadState to) {
101     assert(from != _thread_in_Java, &quot;use transition_from_java&quot;);
102     assert(from != _thread_in_native, &quot;use transition_from_native&quot;);
103     assert((from &amp; 1) == 0 &amp;&amp; (to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
104     assert(thread-&gt;thread_state() == from, &quot;coming from wrong thread state&quot;);
105     // Change to transition state
106     thread-&gt;set_thread_state((JavaThreadState)(from + 1));
107 
108     InterfaceSupport::serialize_thread_state(thread);
109 
110     SafepointMechanism::block_if_requested(thread);
111     thread-&gt;set_thread_state(to);
112 
113     CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)
114   }
115 
116   // transition_and_fence must be used on any thread state transition
117   // where there might not be a Java call stub on the stack, in
118   // particular on Windows where the Structured Exception Handler is
119   // set up in the call stub.
120   static inline void transition_and_fence(JavaThread *thread, JavaThreadState from, JavaThreadState to) {
121     assert(thread-&gt;thread_state() == from, &quot;coming from wrong thread state&quot;);
122     assert((from &amp; 1) == 0 &amp;&amp; (to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
123     // Change to transition state
124     thread-&gt;set_thread_state((JavaThreadState)(from + 1));
125 
126     InterfaceSupport::serialize_thread_state_with_handler(thread);
127 
128     SafepointMechanism::block_if_requested(thread);
129     thread-&gt;set_thread_state(to);
130 
131     CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)
132   }
133 
134   // Same as above, but assumes from = _thread_in_Java. This is simpler, since we
135   // never block on entry to the VM. This will break the code, since e.g. preserve arguments
136   // have not been setup.
137   static inline void transition_from_java(JavaThread *thread, JavaThreadState to) {
138     assert(thread-&gt;thread_state() == _thread_in_Java, &quot;coming from wrong thread state&quot;);
139     thread-&gt;set_thread_state(to);
140   }
141 
142   static inline void transition_from_native(JavaThread *thread, JavaThreadState to) {
143     assert((to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
144     assert(thread-&gt;thread_state() == _thread_in_native, &quot;coming from wrong thread state&quot;);
145     // Change to transition state
146     thread-&gt;set_thread_state(_thread_in_native_trans);
147 
148     InterfaceSupport::serialize_thread_state_with_handler(thread);
149 
150     // We never install asynchronous exceptions when coming (back) in
151     // to the runtime from native code because the runtime is not set
152     // up to handle exceptions floating around at arbitrary points.
153     if (SafepointMechanism::should_block(thread) || thread-&gt;is_suspend_after_native()) {
154       JavaThread::check_safepoint_and_suspend_for_native_trans(thread);
155 
156       // Clear unhandled oops anywhere where we could block, even if we don&#39;t.
157       CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)
158     }
159 
160     thread-&gt;set_thread_state(to);
161   }
162  protected:
163    void trans(JavaThreadState from, JavaThreadState to)  { transition(_thread, from, to); }
164    void trans_from_java(JavaThreadState to)              { transition_from_java(_thread, to); }
165    void trans_from_native(JavaThreadState to)            { transition_from_native(_thread, to); }
166    void trans_and_fence(JavaThreadState from, JavaThreadState to) { transition_and_fence(_thread, from, to); }
167 };
168 
169 class ThreadInVMForHandshake : public ThreadStateTransition {
170   const JavaThreadState _original_state;
171 
172   void transition_back() {
173     // This can be invoked from transition states and must return to the original state properly
174     assert(_thread-&gt;thread_state() == _thread_in_vm, &quot;should only call when leaving VM after handshake&quot;);
175     _thread-&gt;set_thread_state(_thread_in_vm_trans);
176 
177     InterfaceSupport::serialize_thread_state(_thread);
178 
179     SafepointMechanism::block_if_requested(_thread);
180 
181     _thread-&gt;set_thread_state(_original_state);
182   }
183 
184  public:
185 
186   ThreadInVMForHandshake(JavaThread* thread) : ThreadStateTransition(thread),
187       _original_state(thread-&gt;thread_state()) {
188 
189     if (thread-&gt;has_last_Java_frame()) {
190       thread-&gt;frame_anchor()-&gt;make_walkable(thread);
191     }
192 
193     thread-&gt;set_thread_state(_thread_in_vm);
194   }
195 
196   ~ThreadInVMForHandshake() {
197     transition_back();
198   }
199 
200 };
201 
202 class ThreadInVMfromJava : public ThreadStateTransition {
203  public:
204   ThreadInVMfromJava(JavaThread* thread) : ThreadStateTransition(thread) {
205     trans_from_java(_thread_in_vm);
206   }
207   ~ThreadInVMfromJava()  {
208     if (_thread-&gt;stack_yellow_reserved_zone_disabled()) {
209       _thread-&gt;enable_stack_yellow_reserved_zone();
210     }
211     trans(_thread_in_vm, _thread_in_Java);
212     // Check for pending. async. exceptions or suspends.
213     if (_thread-&gt;has_special_runtime_exit_condition()) _thread-&gt;handle_special_runtime_exit_condition();
214   }
215 };
216 
217 
218 class ThreadInVMfromUnknown {
219  private:
220   JavaThread* _thread;
221  public:
222   ThreadInVMfromUnknown() : _thread(NULL) {
223     Thread* t = Thread::current();
224     if (t-&gt;is_Java_thread()) {
225       JavaThread* t2 = (JavaThread*) t;
226       if (t2-&gt;thread_state() == _thread_in_native) {
227         _thread = t2;
228         ThreadStateTransition::transition_from_native(t2, _thread_in_vm);
229         // Used to have a HandleMarkCleaner but that is dangerous as
230         // it could free a handle in our (indirect, nested) caller.
231         // We expect any handles will be short lived and figure we
232         // don&#39;t need an actual HandleMark.
233       }
234     }
235   }
236   ~ThreadInVMfromUnknown()  {
237     if (_thread) {
238       ThreadStateTransition::transition_and_fence(_thread, _thread_in_vm, _thread_in_native);
239     }
240   }
241 };
242 
243 
244 class ThreadInVMfromNative : public ThreadStateTransition {
245  public:
246   ThreadInVMfromNative(JavaThread* thread) : ThreadStateTransition(thread) {
247     trans_from_native(_thread_in_vm);
248   }
249   ~ThreadInVMfromNative() {
250     trans_and_fence(_thread_in_vm, _thread_in_native);
251   }
252 };
253 
254 
255 class ThreadToNativeFromVM : public ThreadStateTransition {
256  public:
257   ThreadToNativeFromVM(JavaThread *thread) : ThreadStateTransition(thread) {
258     // We are leaving the VM at this point and going directly to native code.
259     // Block, if we are in the middle of a safepoint synchronization.
260     assert(!thread-&gt;owns_locks(), &quot;must release all locks when leaving VM&quot;);
261     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
262     trans_and_fence(_thread_in_vm, _thread_in_native);
263     // Check for pending. async. exceptions or suspends.
264     if (_thread-&gt;has_special_runtime_exit_condition()) _thread-&gt;handle_special_runtime_exit_condition(false);
265   }
266 
267   ~ThreadToNativeFromVM() {
268     trans_from_native(_thread_in_vm);
269     assert(!_thread-&gt;is_pending_jni_exception_check(), &quot;Pending JNI Exception Check&quot;);
270     // We don&#39;t need to clear_walkable because it will happen automagically when we return to java
271   }
272 };
273 
274 
275 class ThreadBlockInVM : public ThreadStateTransition {
276  public:
277   ThreadBlockInVM(JavaThread *thread)
278   : ThreadStateTransition(thread) {
279     // Once we are blocked vm expects stack to be walkable
280     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
281     trans_and_fence(_thread_in_vm, _thread_blocked);
282   }
283   ~ThreadBlockInVM() {
284     trans_and_fence(_thread_blocked, _thread_in_vm);
285     // We don&#39;t need to clear_walkable because it will happen automagically when we return to java
286   }
287 };
288 
289 // Unlike ThreadBlockInVM, this class is designed to avoid certain deadlock scenarios while making
290 // transitions inside class Monitor in cases where we need to block for a safepoint or handshake. It
291 // receives an extra argument compared to ThreadBlockInVM, the address of a pointer to the monitor we
292 // are trying to acquire. This will be used to access and release the monitor if needed to avoid
293 // said deadlocks.
294 // It works like ThreadBlockInVM but differs from it in two ways:
295 // - When transitioning in (constructor), it checks for safepoints without blocking, i.e., calls
296 //   back if needed to allow a pending safepoint to continue but does not block in it.
297 // - When transitioning back (destructor), if there is a pending safepoint or handshake it releases
298 //   the monitor that is only partially acquired.
299 class ThreadBlockInVMWithDeadlockCheck : public ThreadStateTransition {
300  private:
301   Monitor** _in_flight_monitor_adr;
302 
303   void release_monitor() {
304     assert(_in_flight_monitor_adr != NULL, &quot;_in_flight_monitor_adr should have been set on constructor&quot;);
305     Monitor* in_flight_monitor = *_in_flight_monitor_adr;
306     if (in_flight_monitor != NULL) {
307       in_flight_monitor-&gt;release_for_safepoint();
308       *_in_flight_monitor_adr = NULL;
309     }
310   }
311  public:
312   ThreadBlockInVMWithDeadlockCheck(JavaThread* thread, Monitor** in_flight_monitor_adr)
313   : ThreadStateTransition(thread), _in_flight_monitor_adr(in_flight_monitor_adr) {
314     // Once we are blocked vm expects stack to be walkable
315     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
316 
317     // All unsafe states are treated the same by the VMThread
318     // so we can skip the _thread_in_vm_trans state here. Since
319     // we don&#39;t read poll, it&#39;s enough to order the stores.
320     OrderAccess::storestore();
321 
322     thread-&gt;set_thread_state(_thread_blocked);
323 
324     CHECK_UNHANDLED_OOPS_ONLY(_thread-&gt;clear_unhandled_oops();)
325   }
326   ~ThreadBlockInVMWithDeadlockCheck() {
327     // Change to transition state
328     _thread-&gt;set_thread_state((JavaThreadState)(_thread_blocked_trans));
329 
330     InterfaceSupport::serialize_thread_state_with_handler(_thread);
331 
332     if (SafepointMechanism::should_block(_thread)) {
333       release_monitor();
334       SafepointMechanism::block_if_requested(_thread);
335     }
336 
337     _thread-&gt;set_thread_state(_thread_in_vm);
338     CHECK_UNHANDLED_OOPS_ONLY(_thread-&gt;clear_unhandled_oops();)
339   }
340 };
341 
342 
343 // This special transition class is only used to prevent asynchronous exceptions
344 // from being installed on vm exit in situations where we can&#39;t tolerate them.
345 // See bugs: 4324348, 4854693, 4998314, 5040492, 5050705.
346 class ThreadInVMfromJavaNoAsyncException : public ThreadStateTransition {
347  public:
348   ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread) {
349     trans_from_java(_thread_in_vm);
350   }
351   ~ThreadInVMfromJavaNoAsyncException()  {
352     if (_thread-&gt;stack_yellow_reserved_zone_disabled()) {
353       _thread-&gt;enable_stack_yellow_reserved_zone();
354     }
355     trans(_thread_in_vm, _thread_in_Java);
356     // NOTE: We do not check for pending. async. exceptions.
357     // If we did and moved the pending async exception over into the
358     // pending exception field, we would need to deopt (currently C2
359     // only). However, to do so would require that we transition back
360     // to the _thread_in_vm state. Instead we postpone the handling of
361     // the async exception.
362 
363 
364     // Check for pending. suspends only.
365     if (_thread-&gt;has_special_runtime_exit_condition())
366       _thread-&gt;handle_special_runtime_exit_condition(false);
367   }
368 };
369 
370 // Debug class instantiated in JRT_ENTRY and ITR_ENTRY macro.
371 // Can be used to verify properties on enter/exit of the VM.
372 
373 #ifdef ASSERT
374 class VMEntryWrapper {
375  public:
376   VMEntryWrapper();
377   ~VMEntryWrapper();
378 };
379 
380 
381 class VMNativeEntryWrapper {
382  public:
383   VMNativeEntryWrapper() {
384     if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();
385   }
386 
387   ~VMNativeEntryWrapper() {
388     if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();
389   }
390 };
391 
392 #endif
393 
394 
395 // VM-internal runtime interface support
396 
397 // Definitions for JRT (Java (Compiler/Shared) Runtime)
398 
399 // JRT_LEAF currently can be called from either _thread_in_Java or
400 // _thread_in_native mode. In _thread_in_native, it is ok
401 // for another thread to trigger GC. The rest of the JRT_LEAF
402 // rules apply.
403 class JRTLeafVerifier : public NoSafepointVerifier {
404   static bool should_verify_GC();
405  public:
406 #ifdef ASSERT
407   JRTLeafVerifier();
408   ~JRTLeafVerifier();
409 #else
410   JRTLeafVerifier() {}
411   ~JRTLeafVerifier() {}
412 #endif
413 };
414 
415 #ifdef ASSERT
416 
417 class RuntimeHistogramElement : public HistogramElement {
418   public:
419    RuntimeHistogramElement(const char* name);
420 };
421 
422 #define TRACE_CALL(result_type, header)                            \
423   InterfaceSupport::_number_of_calls++;                            \
424   if (CountRuntimeCalls) {                                         \
425     static RuntimeHistogramElement* e = new RuntimeHistogramElement(#header); \
426     if (e != NULL) e-&gt;increment_count();                           \
427   }
428 #else
429 #define TRACE_CALL(result_type, header)                            \
430   /* do nothing */
431 #endif
432 
433 
434 // LEAF routines do not lock, GC or throw exceptions
435 
436 #define VM_LEAF_BASE(result_type, header)                            \
437   TRACE_CALL(result_type, header)                                    \
438   debug_only(NoHandleMark __hm;)                                     \
439   os::verify_stack_alignment();                                      \
440   /* begin of body */
441 
442 #define VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)         \
443   TRACE_CALL(result_type, header)                                    \
444   debug_only(ResetNoHandleMark __rnhm;)                              \
445   HandleMarkCleaner __hm(thread);                                    \
446   Thread* THREAD = thread;                                           \
447   os::verify_stack_alignment();                                      \
448   /* begin of body */
449 
450 
451 // ENTRY routines may lock, GC and throw exceptions
452 
453 #define VM_ENTRY_BASE(result_type, header, thread)                   \
454   TRACE_CALL(result_type, header)                                    \
455   HandleMarkCleaner __hm(thread);                                    \
456   Thread* THREAD = thread;                                           \
457   os::verify_stack_alignment();                                      \
458   /* begin of body */
459 
460 
461 // QUICK_ENTRY routines behave like ENTRY but without a handle mark
462 
463 #define VM_QUICK_ENTRY_BASE(result_type, header, thread)             \
464   TRACE_CALL(result_type, header)                                    \
465   debug_only(NoHandleMark __hm;)                                     \
466   Thread* THREAD = thread;                                           \
467   os::verify_stack_alignment();                                      \
468   /* begin of body */
469 
470 
471 // Definitions for IRT (Interpreter Runtime)
472 // (thread is an argument passed in to all these routines)
473 
474 #define IRT_ENTRY(result_type, header)                               \
475   result_type header {                                               \
476     ThreadInVMfromJava __tiv(thread);                                \
477     VM_ENTRY_BASE(result_type, header, thread)                       \
478     debug_only(VMEntryWrapper __vew;)
479 
480 
481 #define IRT_LEAF(result_type, header)                                \
482   result_type header {                                               \
483     VM_LEAF_BASE(result_type, header)                                \
484     debug_only(NoSafepointVerifier __nspv(true);)
485 
486 
487 #define IRT_ENTRY_NO_ASYNC(result_type, header)                      \
488   result_type header {                                               \
489     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
490     VM_ENTRY_BASE(result_type, header, thread)                       \
491     debug_only(VMEntryWrapper __vew;)
492 
493 #define IRT_END }
494 
495 #define JRT_ENTRY(result_type, header)                               \
496   result_type header {                                               \
497     ThreadInVMfromJava __tiv(thread);                                \
498     VM_ENTRY_BASE(result_type, header, thread)                       \
499     debug_only(VMEntryWrapper __vew;)
500 
501 
502 #define JRT_LEAF(result_type, header)                                \
503   result_type header {                                               \
504   VM_LEAF_BASE(result_type, header)                                  \
505   debug_only(JRTLeafVerifier __jlv;)
506 
507 
508 #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
509   result_type header {                                               \
510     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
511     VM_ENTRY_BASE(result_type, header, thread)                       \
512     debug_only(VMEntryWrapper __vew;)
513 
514 // Same as JRT Entry but allows for return value after the safepoint
515 // to get back into Java from the VM
516 #define JRT_BLOCK_ENTRY(result_type, header)                         \
517   result_type header {                                               \
518     TRACE_CALL(result_type, header)                                  \
519     HandleMarkCleaner __hm(thread);
520 
521 #define JRT_BLOCK                                                    \
522     {                                                                \
523     ThreadInVMfromJava __tiv(thread);                                \
524     Thread* THREAD = thread;                                         \
525     debug_only(VMEntryWrapper __vew;)
526 
527 #define JRT_BLOCK_NO_ASYNC                                           \
528     {                                                                \
529     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
530     Thread* THREAD = thread;                                         \
531     debug_only(VMEntryWrapper __vew;)
532 
533 #define JRT_BLOCK_END }
534 
535 #define JRT_END }
536 
537 // Definitions for JNI
538 
539 #define JNI_ENTRY(result_type, header)                               \
540     JNI_ENTRY_NO_PRESERVE(result_type, header)                       \
541     WeakPreserveExceptionMark __wem(thread);
542 
543 #define JNI_ENTRY_NO_PRESERVE(result_type, header)                   \
544 extern &quot;C&quot; {                                                         \
545   result_type JNICALL header {                                       \
546     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
547     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \
548     ThreadInVMfromNative __tiv(thread);                              \
549     debug_only(VMNativeEntryWrapper __vew;)                          \
550     VM_ENTRY_BASE(result_type, header, thread)
551 
552 
553 // Ensure that the VMNativeEntryWrapper constructor, which can cause
554 // a GC, is called outside the NoHandleMark (set via VM_QUICK_ENTRY_BASE).
555 #define JNI_QUICK_ENTRY(result_type, header)                         \
556 extern &quot;C&quot; {                                                         \
557   result_type JNICALL header {                                       \
558     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
559     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \
560     ThreadInVMfromNative __tiv(thread);                              \
561     debug_only(VMNativeEntryWrapper __vew;)                          \
562     VM_QUICK_ENTRY_BASE(result_type, header, thread)
563 
564 
565 #define JNI_LEAF(result_type, header)                                \
566 extern &quot;C&quot; {                                                         \
567   result_type JNICALL header {                                       \
568     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
569     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \
570     VM_LEAF_BASE(result_type, header)
571 
572 
573 // Close the routine and the extern &quot;C&quot;
574 #define JNI_END } }
575 
576 
577 
578 // Definitions for JVM
579 
580 #define JVM_ENTRY(result_type, header)                               \
581 extern &quot;C&quot; {                                                         \
582   result_type JNICALL header {                                       \
583     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
584     ThreadInVMfromNative __tiv(thread);                              \
585     debug_only(VMNativeEntryWrapper __vew;)                          \
586     VM_ENTRY_BASE(result_type, header, thread)
587 
588 
589 #define JVM_ENTRY_NO_ENV(result_type, header)                        \
590 extern &quot;C&quot; {                                                         \
591   result_type JNICALL header {                                       \
592     JavaThread* thread = JavaThread::current();                      \
593     ThreadInVMfromNative __tiv(thread);                              \
594     debug_only(VMNativeEntryWrapper __vew;)                          \
595     VM_ENTRY_BASE(result_type, header, thread)
596 
597 
598 #define JVM_QUICK_ENTRY(result_type, header)                         \
599 extern &quot;C&quot; {                                                         \
600   result_type JNICALL header {                                       \
601     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
602     ThreadInVMfromNative __tiv(thread);                              \
603     debug_only(VMNativeEntryWrapper __vew;)                          \
604     VM_QUICK_ENTRY_BASE(result_type, header, thread)
605 
606 
607 #define JVM_LEAF(result_type, header)                                \
608 extern &quot;C&quot; {                                                         \
609   result_type JNICALL header {                                       \
610     VM_Exit::block_if_vm_exited();                                   \
611     VM_LEAF_BASE(result_type, header)
612 
613 
614 #define JVM_ENTRY_FROM_LEAF(env, result_type, header)                \
615   { {                                                                \
616     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
617     ThreadInVMfromNative __tiv(thread);                              \
618     debug_only(VMNativeEntryWrapper __vew;)                          \
619     VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)
620 
621 
622 #define JVM_END } }
623 
624 #endif // SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
    </pre>
  </body>
</html>
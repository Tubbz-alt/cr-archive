<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/vmOperations.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vframe_hp.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/vmOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,15 ***</span>
<span class="line-new-header">--- 25,18 ---</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/collectedHeap.hpp&quot;</span>
  #include &quot;gc/shared/isGCActiveMark.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
<span class="line-added">+ #include &quot;logging/logConfiguration.hpp&quot;</span>
  #include &quot;memory/heapInspection.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,17 ***</span>
  #define VM_OP_NAME_INITIALIZE(name) #name,
  
  const char* VM_Operation::_names[VM_Operation::VMOp_Terminating] = \
    { VM_OPS_DO(VM_OP_NAME_INITIALIZE) };
  
<span class="line-modified">! void VM_Operation::set_calling_thread(Thread* thread, ThreadPriority priority) {</span>
    _calling_thread = thread;
<span class="line-removed">-   assert(MinPriority &lt;= priority &amp;&amp; priority &lt;= MaxPriority, &quot;sanity check&quot;);</span>
<span class="line-removed">-   _priority = priority;</span>
  }
  
<span class="line-removed">- </span>
  void VM_Operation::evaluate() {
    ResourceMark rm;
    LogTarget(Debug, vmoperation) lt;
    if (lt.is_enabled()) {
      LogStream ls(lt);
<span class="line-new-header">--- 49,14 ---</span>
  #define VM_OP_NAME_INITIALIZE(name) #name,
  
  const char* VM_Operation::_names[VM_Operation::VMOp_Terminating] = \
    { VM_OPS_DO(VM_OP_NAME_INITIALIZE) };
  
<span class="line-modified">! void VM_Operation::set_calling_thread(Thread* thread) {</span>
    _calling_thread = thread;
  }
  
  void VM_Operation::evaluate() {
    ResourceMark rm;
    LogTarget(Debug, vmoperation) lt;
    if (lt.is_enabled()) {
      LogStream ls(lt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,64 ***</span>
      print_on_error(&amp;ls);
      ls.cr();
    }
  }
  
<span class="line-removed">- const char* VM_Operation::mode_to_string(Mode mode) {</span>
<span class="line-removed">-   switch(mode) {</span>
<span class="line-removed">-     case _safepoint      : return &quot;safepoint&quot;;</span>
<span class="line-removed">-     case _no_safepoint   : return &quot;no safepoint&quot;;</span>
<span class="line-removed">-     case _concurrent     : return &quot;concurrent&quot;;</span>
<span class="line-removed">-     case _async_safepoint: return &quot;async safepoint&quot;;</span>
<span class="line-removed">-     default              : return &quot;unknown&quot;;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
  // Called by fatal error handler.
  void VM_Operation::print_on_error(outputStream* st) const {
    st-&gt;print(&quot;VM_Operation (&quot; PTR_FORMAT &quot;): &quot;, p2i(this));
    st-&gt;print(&quot;%s&quot;, name());
  
<span class="line-modified">!   const char* mode = mode_to_string(evaluation_mode());</span>
<span class="line-removed">-   st-&gt;print(&quot;, mode: %s&quot;, mode);</span>
  
    if (calling_thread()) {
      st-&gt;print(&quot;, requested by thread &quot; PTR_FORMAT, p2i(calling_thread()));
    }
  }
  
<span class="line-removed">- void VM_ThreadStop::doit() {</span>
<span class="line-removed">-   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at a safepoint&quot;);</span>
<span class="line-removed">-   ThreadsListHandle tlh;</span>
<span class="line-removed">-   JavaThread* target = java_lang_Thread::thread(target_thread());</span>
<span class="line-removed">-   // Note that this now allows multiple ThreadDeath exceptions to be</span>
<span class="line-removed">-   // thrown at a thread.</span>
<span class="line-removed">-   if (target != NULL &amp;&amp; (!EnableThreadSMRExtraValidityChecks || tlh.includes(target))) {</span>
<span class="line-removed">-     // The target thread has run and has not exited yet.</span>
<span class="line-removed">-     target-&gt;send_thread_stop(throwable());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void VM_ClearICs::doit() {
    if (_preserve_static_stubs) {
      CodeCache::cleanup_inline_caches();
    } else {
      CodeCache::clear_inline_caches();
    }
  }
  
<span class="line-removed">- void VM_Deoptimize::doit() {</span>
<span class="line-removed">-   // We do not want any GCs to happen while we are in the middle of this VM operation</span>
<span class="line-removed">-   ResourceMark rm;</span>
<span class="line-removed">-   DeoptimizationMarker dm;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Deoptimize all activations depending on marked nmethods</span>
<span class="line-removed">-   Deoptimization::deoptimize_dependents();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Make the dependent methods not entrant</span>
<span class="line-removed">-   CodeCache::make_marked_nmethods_not_entrant();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void VM_MarkActiveNMethods::doit() {
    NMethodSweeper::mark_active_nmethods();
  }
  
  VM_DeoptimizeFrame::VM_DeoptimizeFrame(JavaThread* thread, intptr_t* id, int reason) {
<span class="line-new-header">--- 71,30 ---</span>
      print_on_error(&amp;ls);
      ls.cr();
    }
  }
  
  // Called by fatal error handler.
  void VM_Operation::print_on_error(outputStream* st) const {
    st-&gt;print(&quot;VM_Operation (&quot; PTR_FORMAT &quot;): &quot;, p2i(this));
    st-&gt;print(&quot;%s&quot;, name());
  
<span class="line-modified">!   st-&gt;print(&quot;, mode: %s&quot;, evaluate_at_safepoint() ? &quot;safepoint&quot; : &quot;no safepoint&quot;);</span>
  
    if (calling_thread()) {
      st-&gt;print(&quot;, requested by thread &quot; PTR_FORMAT, p2i(calling_thread()));
    }
  }
  
  void VM_ClearICs::doit() {
    if (_preserve_static_stubs) {
      CodeCache::cleanup_inline_caches();
    } else {
      CodeCache::clear_inline_caches();
    }
  }
  
  void VM_MarkActiveNMethods::doit() {
    NMethodSweeper::mark_active_nmethods();
  }
  
  VM_DeoptimizeFrame::VM_DeoptimizeFrame(JavaThread* thread, intptr_t* id, int reason) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,16 ***</span>
        if (thread-&gt;has_last_Java_frame()) {
          if (tcount++ == tnum)  {
          tcount = 0;
            int fcount = 0;
            // Deoptimize some selected frames.
<span class="line-modified">!           // Biased llocking wants a updated register map</span>
<span class="line-removed">-           for(StackFrameStream fst(thread, UseBiasedLocking); !fst.is_done(); fst.next()) {</span>
              if (fst.current()-&gt;can_be_deoptimized()) {
                if (fcount++ == fnum) {
                  fcount = 0;
<span class="line-modified">!                 Deoptimization::deoptimize(thread, *fst.current(), fst.register_map());</span>
                }
              }
            }
          }
        }
<span class="line-new-header">--- 132,15 ---</span>
        if (thread-&gt;has_last_Java_frame()) {
          if (tcount++ == tnum)  {
          tcount = 0;
            int fcount = 0;
            // Deoptimize some selected frames.
<span class="line-modified">!           for(StackFrameStream fst(thread, false); !fst.is_done(); fst.next()) {</span>
              if (fst.current()-&gt;can_be_deoptimized()) {
                if (fcount++ == fnum) {
                  fcount = 0;
<span class="line-modified">!                 Deoptimization::deoptimize(thread, *fst.current());</span>
                }
              }
            }
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,11 ***</span>
<span class="line-new-header">--- 398,24 ---</span>
      jtiwh.rewind();
      for (; JavaThread *thr = jtiwh.next(); ) {
        if (thr!=thr_cur &amp;&amp; thr-&gt;thread_state() == _thread_in_native) {
          num_active++;
          if (thr-&gt;is_Compiler_thread()) {
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+           CompilerThread* ct = (CompilerThread*) thr;</span>
<span class="line-added">+           if (ct-&gt;compiler() == NULL || !ct-&gt;compiler()-&gt;is_jvmci()) {</span>
<span class="line-added">+             num_active_compiler_thread++;</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+             // A JVMCI compiler thread never accesses VM data structures</span>
<span class="line-added">+             // while in _thread_in_native state so there&#39;s no need to wait</span>
<span class="line-added">+             // for it and potentially add a 300 millisecond delay to VM</span>
<span class="line-added">+             // shutdown.</span>
<span class="line-added">+             num_active--;</span>
<span class="line-added">+           }</span>
<span class="line-added">+ #else</span>
            num_active_compiler_thread++;
<span class="line-added">+ #endif</span>
          }
        }
      }
  
      if (num_active == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 448,16 ***</span>
         return num_active;
      }
  
      attempts++;
  
<span class="line-modified">!     MutexLockerEx ml(&amp;timer, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!     timer.wait(Mutex::_no_safepoint_check_flag, 10);</span>
    }
  }
  
  void VM_Exit::doit() {
    CompileBroker::set_should_block();
  
    // Wait for a short period for threads in native to block. Any thread
    // still executing native code after the wait will be stopped at
    // native==&gt;Java/VM barriers.
<span class="line-new-header">--- 426,26 ---</span>
         return num_active;
      }
  
      attempts++;
  
<span class="line-modified">!     MonitorLocker ml(&amp;timer, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!     ml.wait(10);</span>
    }
  }
  
  void VM_Exit::doit() {
<span class="line-added">+ </span>
<span class="line-added">+   if (VerifyBeforeExit) {</span>
<span class="line-added">+     HandleMark hm(VMThread::vm_thread());</span>
<span class="line-added">+     // Among other things, this ensures that Eden top is correct.</span>
<span class="line-added">+     Universe::heap()-&gt;prepare_for_verify();</span>
<span class="line-added">+     // Silent verification so as not to pollute normal output,</span>
<span class="line-added">+     // unless we really asked for it.</span>
<span class="line-added">+     Universe::verify();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    CompileBroker::set_should_block();
  
    // Wait for a short period for threads in native to block. Any thread
    // still executing native code after the wait will be stopped at
    // native==&gt;Java/VM barriers.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 465,14 ***</span>
<span class="line-new-header">--- 453,21 ---</span>
    // running in native; the other 6% are quiescent within 250ms (Ultra 80).
    wait_for_threads_in_native_to_block();
  
    set_vm_exited();
  
<span class="line-added">+   // We&#39;d like to call IdealGraphPrinter::clean_up() to finalize the</span>
<span class="line-added">+   // XML logging, but we can&#39;t safely do that here. The logic to make</span>
<span class="line-added">+   // XML termination logging safe is tied to the termination of the</span>
<span class="line-added">+   // VMThread, and it doesn&#39;t terminate on this exit path. See 8222534.</span>
<span class="line-added">+ </span>
    // cleanup globals resources before exiting. exit_globals() currently
    // cleans up outputStream resources and PerfMemory resources.
    exit_globals();
  
<span class="line-added">+   LogConfiguration::finalize();</span>
<span class="line-added">+ </span>
    // Check for exit hook
    exit_hook_t exit_hook = Arguments::exit_hook();
    if (exit_hook != NULL) {
      // exit hook should exit.
      exit_hook(_exit_code);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 487,11 ***</span>
  void VM_Exit::wait_if_vm_exited() {
    if (_vm_exited &amp;&amp;
        Thread::current_or_null() != _shutdown_thread) {
      // _vm_exited is set at safepoint, and the Threads_lock is never released
      // we will block here until the process dies
<span class="line-modified">!     Threads_lock-&gt;lock_without_safepoint_check();</span>
      ShouldNotReachHere();
    }
  }
  
  void VM_PrintCompileQueue::doit() {
<span class="line-new-header">--- 482,11 ---</span>
  void VM_Exit::wait_if_vm_exited() {
    if (_vm_exited &amp;&amp;
        Thread::current_or_null() != _shutdown_thread) {
      // _vm_exited is set at safepoint, and the Threads_lock is never released
      // we will block here until the process dies
<span class="line-modified">!     Threads_lock-&gt;lock();</span>
      ShouldNotReachHere();
    }
  }
  
  void VM_PrintCompileQueue::doit() {
</pre>
<center><a href="vframe_hp.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/mutex.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 28 #include &quot;runtime/mutex.hpp&quot;
 29 #include &quot;runtime/osThread.hpp&quot;
 30 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
 31 #include &quot;runtime/thread.inline.hpp&quot;
 32 #include &quot;utilities/events.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 
<a name="1" id="anc1"></a>













 35 
<a name="2" id="anc2"></a><span class="line-modified"> 36 void Monitor::lock(Thread * self) {</span>
<span class="line-modified"> 37   // Ensure that the Monitor requires/allows safepoint checks.</span>
<span class="line-modified"> 38   assert(_safepoint_check_required != Monitor::_safepoint_check_never,</span>
<span class="line-modified"> 39          &quot;This lock should never have a safepoint check: %s&quot;, name());</span>

 40 
<a name="3" id="anc3"></a><span class="line-modified"> 41 #ifdef CHECK_UNHANDLED_OOPS</span>
<span class="line-modified"> 42   // Clear unhandled oops in JavaThreads so we get a crash right away.</span>
<span class="line-modified"> 43   if (self-&gt;is_Java_thread()) {</span>
<span class="line-modified"> 44     self-&gt;clear_unhandled_oops();</span>


 45   }
<a name="4" id="anc4"></a><span class="line-modified"> 46 #endif // CHECK_UNHANDLED_OOPS</span>
 47 
<a name="5" id="anc5"></a><span class="line-modified"> 48   DEBUG_ONLY(check_prelock_state(self, StrictSafepointChecks));</span>
<span class="line-modified"> 49   assert(_owner != self, &quot;invariant&quot;);</span>





 50 
<a name="6" id="anc6"></a><span class="line-modified"> 51   Monitor* in_flight_monitor = NULL;</span>

 52   DEBUG_ONLY(int retry_cnt = 0;)
<a name="7" id="anc7"></a><span class="line-modified"> 53   while (!_lock.try_lock()) {</span>
<span class="line-modified"> 54     // The lock is contended</span>
<span class="line-modified"> 55 </span>
<span class="line-removed"> 56   #ifdef ASSERT</span>
<span class="line-removed"> 57     check_block_state(self);</span>
 58     if (retry_cnt++ &gt; 3) {
<a name="8" id="anc8"></a><span class="line-modified"> 59       log_trace(vmmonitor)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; on %d attempt trying to acquire vmmonitor %s&quot;, p2i(self), retry_cnt, _name);</span>
 60     }
<a name="9" id="anc9"></a><span class="line-modified"> 61   #endif // ASSERT</span>
 62 
<a name="10" id="anc10"></a><span class="line-modified"> 63     if (self-&gt;is_Java_thread()) {</span>

 64       assert(rank() &gt; Mutex::special, &quot;Potential deadlock with special or lesser rank mutex&quot;);
<a name="11" id="anc11"></a><span class="line-modified"> 65       { ThreadBlockInVMWithDeadlockCheck tbivmdc((JavaThread *) self, &amp;in_flight_monitor);</span>
<span class="line-modified"> 66         in_flight_monitor = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
 67         _lock.lock();
 68       }
<a name="12" id="anc12"></a><span class="line-modified"> 69       if (in_flight_monitor != NULL) {</span>
 70         // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck
 71         break;
 72       }
 73     } else {
 74       _lock.lock();
 75       break;
 76     }
<a name="13" id="anc13"></a>










 77   }
 78 
 79   assert_owner(NULL);
 80   set_owner(self);
 81 }
 82 
<a name="14" id="anc14"></a><span class="line-modified"> 83 void Monitor::lock() {</span>
<span class="line-modified"> 84   this-&gt;lock(Thread::current());</span>
 85 }
 86 
 87 // Lock without safepoint check - a degenerate variant of lock() for use by
 88 // JavaThreads when it is known to be safe to not check for a safepoint when
 89 // acquiring this lock. If the thread blocks acquiring the lock it is not
 90 // safepoint-safe and so will prevent a safepoint from being reached. If used
 91 // in the wrong way this can lead to a deadlock with the safepoint code.
 92 
<a name="15" id="anc15"></a><span class="line-modified"> 93 void Monitor::lock_without_safepoint_check(Thread * self) {</span>
<span class="line-modified"> 94   // Ensure that the Monitor does not require safepoint checks.</span>
<span class="line-removed"> 95   assert(_safepoint_check_required != Monitor::_safepoint_check_always,</span>
<span class="line-removed"> 96          &quot;This lock should always have a safepoint check: %s&quot;, name());</span>
 97   assert(_owner != self, &quot;invariant&quot;);
 98   _lock.lock();
 99   assert_owner(NULL);
100   set_owner(self);
101 }
102 
<a name="16" id="anc16"></a><span class="line-modified">103 void Monitor::lock_without_safepoint_check() {</span>
104   lock_without_safepoint_check(Thread::current());
105 }
106 
107 
108 // Returns true if thread succeeds in grabbing the lock, otherwise false.
109 
<a name="17" id="anc17"></a><span class="line-modified">110 bool Monitor::try_lock() {</span>
111   Thread * const self = Thread::current();
<a name="18" id="anc18"></a><span class="line-modified">112   DEBUG_ONLY(check_prelock_state(self, false);)</span>
<span class="line-modified">113 </span>

114   if (_lock.try_lock()) {
115     assert_owner(NULL);
116     set_owner(self);
117     return true;
118   }
119   return false;
120 }
121 
<a name="19" id="anc19"></a><span class="line-modified">122 void Monitor::release_for_safepoint() {</span>
123   assert_owner(NULL);
124   _lock.unlock();
125 }
126 
<a name="20" id="anc20"></a><span class="line-modified">127 void Monitor::unlock() {</span>
<span class="line-modified">128   assert_owner(Thread::current());</span>
129   set_owner(NULL);
130   _lock.unlock();
131 }
132 
133 void Monitor::notify() {
<a name="21" id="anc21"></a><span class="line-modified">134   assert_owner(Thread::current());</span>
135   _lock.notify();
136 }
137 
138 void Monitor::notify_all() {
<a name="22" id="anc22"></a><span class="line-modified">139   assert_owner(Thread::current());</span>
140   _lock.notify_all();
141 }
142 
<a name="23" id="anc23"></a><span class="line-modified">143 bool Monitor::wait(bool no_safepoint_check, long timeout,</span>
<span class="line-modified">144                    bool as_suspend_equivalent) {</span>
<span class="line-modified">145   // Make sure safepoint checking is used properly.</span>
<span class="line-removed">146   assert(!(_safepoint_check_required == Monitor::_safepoint_check_never &amp;&amp; no_safepoint_check == false),</span>
<span class="line-removed">147          &quot;This lock should never have a safepoint check: %s&quot;, name());</span>
<span class="line-removed">148   assert(!(_safepoint_check_required == Monitor::_safepoint_check_always &amp;&amp; no_safepoint_check == true),</span>
<span class="line-removed">149          &quot;This lock should always have a safepoint check: %s&quot;, name());</span>
<span class="line-removed">150 </span>
<span class="line-removed">151   // timeout is in milliseconds - with zero meaning never timeout</span>
<span class="line-removed">152   assert(timeout &gt;= 0, &quot;negative timeout&quot;);</span>
<span class="line-removed">153 </span>
<span class="line-removed">154   Thread * const self = Thread::current();</span>
<span class="line-removed">155   assert_owner(self);</span>
<span class="line-removed">156 </span>
<span class="line-removed">157   // as_suspend_equivalent logically implies !no_safepoint_check</span>
<span class="line-removed">158   guarantee(!as_suspend_equivalent || !no_safepoint_check, &quot;invariant&quot;);</span>
<span class="line-removed">159   // !no_safepoint_check logically implies java_thread</span>
<span class="line-removed">160   guarantee(no_safepoint_check || self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">161 </span>
<span class="line-removed">162   #ifdef ASSERT</span>
<span class="line-removed">163   Monitor * least = get_least_ranked_lock_besides_this(self-&gt;owned_locks());</span>
164   assert(least != this, &quot;Specification of get_least_... call above&quot;);
165   if (least != NULL &amp;&amp; least-&gt;rank() &lt;= special) {
166     ::tty-&gt;print(&quot;Attempting to wait on monitor %s/%d while holding&quot;
167                &quot; lock %s/%d -- possible deadlock&quot;,
168                name(), rank(), least-&gt;name(), least-&gt;rank());
169     assert(false, &quot;Shouldn&#39;t block(wait) while holding a lock of rank special&quot;);
170   }
<a name="24" id="anc24"></a><span class="line-modified">171   #endif // ASSERT</span>










172 
<a name="25" id="anc25"></a><span class="line-removed">173   int wait_status;</span>
174   // conceptually set the owner to NULL in anticipation of
175   // abdicating the lock in wait
176   set_owner(NULL);
<a name="26" id="anc26"></a><span class="line-modified">177   if (no_safepoint_check) {</span>
<span class="line-modified">178     wait_status = _lock.wait(timeout);</span>
<span class="line-removed">179     set_owner(self);</span>
<span class="line-removed">180   } else {</span>
<span class="line-removed">181     assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">182     JavaThread *jt = (JavaThread *)self;</span>
<span class="line-removed">183     Monitor* in_flight_monitor = NULL;</span>
<span class="line-removed">184 </span>
<span class="line-removed">185     {</span>
<span class="line-removed">186       ThreadBlockInVMWithDeadlockCheck tbivmdc(jt, &amp;in_flight_monitor);</span>
<span class="line-removed">187       OSThreadWaitState osts(self-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-removed">188       if (as_suspend_equivalent) {</span>
<span class="line-removed">189         jt-&gt;set_suspend_equivalent();</span>
<span class="line-removed">190         // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-removed">191         // java_suspend_self()</span>
<span class="line-removed">192       }</span>
193 
<a name="27" id="anc27"></a><span class="line-modified">194       wait_status = _lock.wait(timeout);</span>
<span class="line-modified">195       in_flight_monitor = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">196 </span>
<span class="line-modified">197       // were we externally suspended while we were waiting?</span>
<span class="line-modified">198       if (as_suspend_equivalent &amp;&amp; jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">199         // Our event wait has finished and we own the lock, but</span>
<span class="line-modified">200         // while we were waiting another thread suspended us. We don&#39;t</span>
<span class="line-modified">201         // want to hold the lock while suspended because that</span>
<span class="line-modified">202         // would surprise the thread that suspended us.</span>
<span class="line-modified">203         _lock.unlock();</span>
<span class="line-modified">204         jt-&gt;java_suspend_self();</span>
<span class="line-modified">205         _lock.lock();</span>
<span class="line-modified">206       }</span>




















207     }
208 
<a name="28" id="anc28"></a><span class="line-modified">209     if (in_flight_monitor != NULL) {</span>
<span class="line-modified">210       // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">211       assert_owner(NULL);</span>
<span class="line-modified">212       // Conceptually reestablish ownership of the lock.</span>
<span class="line-modified">213       set_owner(self);</span>
<span class="line-modified">214     } else {</span>
<span class="line-modified">215       lock(self);</span>





216     }
217   }
<a name="29" id="anc29"></a><span class="line-removed">218   return wait_status != 0;          // return true IFF timeout</span>
<span class="line-removed">219 }</span>
<span class="line-removed">220 </span>
221 
<a name="30" id="anc30"></a><span class="line-modified">222 // Temporary JVM_RawMonitor* support.</span>
<span class="line-modified">223 // Yet another degenerate version of Monitor::lock() or lock_without_safepoint_check()</span>
<span class="line-modified">224 // jvm_raw_lock() and _unlock() can be called by non-Java threads via JVM_RawMonitorEnter.</span>
<span class="line-modified">225 // There&#39;s no expectation that JVM_RawMonitors will interoperate properly with the native</span>
<span class="line-modified">226 // Mutex-Monitor constructs.  We happen to implement JVM_RawMonitors in terms of</span>
<span class="line-modified">227 // native Mutex-Monitors simply as a matter of convenience.</span>


228 
<a name="31" id="anc31"></a><span class="line-modified">229 void Monitor::jvm_raw_lock() {</span>
<span class="line-removed">230   _lock.lock();</span>
<span class="line-removed">231   assert_owner(NULL);</span>
232 }
233 
<a name="32" id="anc32"></a><span class="line-modified">234 void Monitor::jvm_raw_unlock() {</span>
235   assert_owner(NULL);
<a name="33" id="anc33"></a><span class="line-removed">236   _lock.unlock();</span>
237 }
238 
<a name="34" id="anc34"></a><span class="line-modified">239 Monitor::~Monitor() {</span>
<span class="line-modified">240   assert_owner(NULL);</span>

241 }
242 
<a name="35" id="anc35"></a><span class="line-modified">243 void Monitor::ClearMonitor(Monitor * m, const char *name) {</span>
<span class="line-modified">244   m-&gt;_owner             = NULL;</span>

245   if (name == NULL) {
<a name="36" id="anc36"></a><span class="line-modified">246     strcpy(m-&gt;_name, &quot;UNKNOWN&quot;);</span>
247   } else {
<a name="37" id="anc37"></a><span class="line-modified">248     strncpy(m-&gt;_name, name, MONITOR_NAME_LEN - 1);</span>
<span class="line-modified">249     m-&gt;_name[MONITOR_NAME_LEN - 1] = &#39;\0&#39;;</span>
250   }
<a name="38" id="anc38"></a><span class="line-removed">251 }</span>
<span class="line-removed">252 </span>
<span class="line-removed">253 Monitor::Monitor() {</span>
<span class="line-removed">254   assert(os::mutex_init_done(), &quot;Too early!&quot;);</span>
<span class="line-removed">255   ClearMonitor(this);</span>
<span class="line-removed">256 }</span>
<span class="line-removed">257 </span>
<span class="line-removed">258 Monitor::Monitor(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-removed">259                  SafepointCheckRequired safepoint_check_required) {</span>
<span class="line-removed">260   assert(os::mutex_init_done(), &quot;Too early!&quot;);</span>
<span class="line-removed">261   ClearMonitor(this, name);</span>
262 #ifdef ASSERT
263   _allow_vm_block  = allow_vm_block;
264   _rank            = Rank;
<a name="39" id="anc39"></a><span class="line-modified">265   NOT_PRODUCT(_safepoint_check_required = safepoint_check_required;)</span>
<span class="line-removed">266 #endif</span>
<span class="line-removed">267 }</span>
268 
<a name="40" id="anc40"></a><span class="line-modified">269 Mutex::Mutex(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-modified">270              SafepointCheckRequired safepoint_check_required) {</span>
<span class="line-modified">271   ClearMonitor((Monitor *) this, name);</span>
<span class="line-modified">272 #ifdef ASSERT</span>
<span class="line-modified">273   _allow_vm_block   = allow_vm_block;</span>
<span class="line-removed">274   _rank             = Rank;</span>
<span class="line-removed">275   NOT_PRODUCT(_safepoint_check_required = safepoint_check_required;)</span>
276 #endif
277 }
278 
<a name="41" id="anc41"></a><span class="line-modified">279 bool Monitor::owned_by_self() const {</span>




280   return _owner == Thread::current();
281 }
282 
<a name="42" id="anc42"></a><span class="line-modified">283 void Monitor::print_on_error(outputStream* st) const {</span>
284   st-&gt;print(&quot;[&quot; PTR_FORMAT, p2i(this));
285   st-&gt;print(&quot;] %s&quot;, _name);
286   st-&gt;print(&quot; - owner thread: &quot; PTR_FORMAT, p2i(_owner));
287 }
288 
289 // ----------------------------------------------------------------------------------
290 // Non-product code
291 
292 #ifndef PRODUCT
<a name="43" id="anc43"></a><span class="line-modified">293 void Monitor::print_on(outputStream* st) const {</span>
<span class="line-modified">294   st-&gt;print_cr(&quot;Mutex: [&quot; PTR_FORMAT &quot;] %s - owner: &quot; PTR_FORMAT,</span>
<span class="line-modified">295                p2i(this), _name, p2i(_owner));</span>














296 }
297 #endif
298 
<a name="44" id="anc44"></a><span class="line-removed">299 #ifndef PRODUCT</span>
300 #ifdef ASSERT
<a name="45" id="anc45"></a><span class="line-modified">301 </span>
<span class="line-removed">302 void Monitor::assert_owner(Thread * expected) {</span>
303   const char* msg = &quot;invalid owner&quot;;
304   if (expected == NULL) {
305     msg = &quot;should be un-owned&quot;;
306   }
307   else if (expected == Thread::current()) {
308     msg = &quot;should be owned by current thread&quot;;
309   }
310   assert(_owner == expected,
311          &quot;%s: owner=&quot; INTPTR_FORMAT &quot;, should be=&quot; INTPTR_FORMAT,
312          msg, p2i(_owner), p2i(expected));
313 }
314 
<a name="46" id="anc46"></a><span class="line-modified">315 Monitor * Monitor::get_least_ranked_lock(Monitor * locks) {</span>
<span class="line-modified">316   Monitor *res, *tmp;</span>
317   for (res = tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
318     if (tmp-&gt;rank() &lt; res-&gt;rank()) {
319       res = tmp;
320     }
321   }
322   if (!SafepointSynchronize::is_at_safepoint()) {
323     // In this case, we expect the held locks to be
324     // in increasing rank order (modulo any native ranks)
325     for (tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
326       if (tmp-&gt;next() != NULL) {
327         assert(tmp-&gt;rank() == Mutex::native ||
328                tmp-&gt;rank() &lt;= tmp-&gt;next()-&gt;rank(), &quot;mutex rank anomaly?&quot;);
329       }
330     }
331   }
332   return res;
333 }
334 
<a name="47" id="anc47"></a><span class="line-modified">335 Monitor* Monitor::get_least_ranked_lock_besides_this(Monitor* locks) {</span>
<span class="line-modified">336   Monitor *res, *tmp;</span>
337   for (res = NULL, tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
338     if (tmp != this &amp;&amp; (res == NULL || tmp-&gt;rank() &lt; res-&gt;rank())) {
339       res = tmp;
340     }
341   }
342   if (!SafepointSynchronize::is_at_safepoint()) {
343     // In this case, we expect the held locks to be
344     // in increasing rank order (modulo any native ranks)
345     for (tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
346       if (tmp-&gt;next() != NULL) {
347         assert(tmp-&gt;rank() == Mutex::native ||
348                tmp-&gt;rank() &lt;= tmp-&gt;next()-&gt;rank(), &quot;mutex rank anomaly?&quot;);
349       }
350     }
351   }
352   return res;
353 }
354 
<a name="48" id="anc48"></a><span class="line-modified">355 </span>
<span class="line-removed">356 bool Monitor::contains(Monitor* locks, Monitor * lock) {</span>
357   for (; locks != NULL; locks = locks-&gt;next()) {
358     if (locks == lock) {
359       return true;
360     }
361   }
362   return false;
363 }
<a name="49" id="anc49"></a><span class="line-modified">364 #endif</span>
















365 
366 // Called immediately after lock acquisition or release as a diagnostic
367 // to track the lock-set of the thread and test for rank violations that
368 // might indicate exposure to deadlock.
369 // Rather like an EventListener for _owner (:&gt;).
370 
<a name="50" id="anc50"></a><span class="line-modified">371 void Monitor::set_owner_implementation(Thread *new_owner) {</span>
372   // This function is solely responsible for maintaining
373   // and checking the invariant that threads and locks
374   // are in a 1/N relation, with some some locks unowned.
375   // It uses the Mutex::_owner, Mutex::_next, and
376   // Thread::_owned_locks fields, and no other function
377   // changes those fields.
378   // It is illegal to set the mutex from one non-NULL
379   // owner to another--it must be owned by NULL as an
380   // intermediate state.
381 
382   if (new_owner != NULL) {
383     // the thread is acquiring this lock
384 
385     assert(new_owner == Thread::current(), &quot;Should I be doing this?&quot;);
386     assert(_owner == NULL, &quot;setting the owner thread of an already owned mutex&quot;);
387     _owner = new_owner; // set the owner
388 
389     // link &quot;this&quot; into the owned locks list
390 
<a name="51" id="anc51"></a><span class="line-modified">391 #ifdef ASSERT  // Thread::_owned_locks is under the same ifdef</span>
<span class="line-removed">392     Monitor* locks = get_least_ranked_lock(new_owner-&gt;owned_locks());</span>
393     // Mutex::set_owner_implementation is a friend of Thread
394 
395     assert(this-&gt;rank() &gt;= 0, &quot;bad lock rank&quot;);
396 
397     // Deadlock avoidance rules require us to acquire Mutexes only in
398     // a global total order. For example m1 is the lowest ranked mutex
399     // that the thread holds and m2 is the mutex the thread is trying
400     // to acquire, then deadlock avoidance rules require that the rank
401     // of m2 be less than the rank of m1.
402     // The rank Mutex::native  is an exception in that it is not subject
403     // to the verification rules.
404     if (this-&gt;rank() != Mutex::native &amp;&amp;
405         this-&gt;rank() != Mutex::suspend_resume &amp;&amp;
406         locks != NULL &amp;&amp; locks-&gt;rank() &lt;= this-&gt;rank() &amp;&amp;
407         !SafepointSynchronize::is_at_safepoint()) {
408       new_owner-&gt;print_owned_locks();
409       fatal(&quot;acquiring lock %s/%d out of order with lock %s/%d -- &quot;
410             &quot;possible deadlock&quot;, this-&gt;name(), this-&gt;rank(),
411             locks-&gt;name(), locks-&gt;rank());
412     }
413 
414     this-&gt;_next = new_owner-&gt;_owned_locks;
415     new_owner-&gt;_owned_locks = this;
<a name="52" id="anc52"></a><span class="line-modified">416 #endif</span>


417 
418   } else {
419     // the thread is releasing this lock
420 
421     Thread* old_owner = _owner;
<a name="53" id="anc53"></a><span class="line-modified">422     DEBUG_ONLY(_last_owner = old_owner;)</span>
423 
424     assert(old_owner != NULL, &quot;removing the owner thread of an unowned mutex&quot;);
425     assert(old_owner == Thread::current(), &quot;removing the owner thread of an unowned mutex&quot;);
426 
427     _owner = NULL; // set the owner
428 
<a name="54" id="anc54"></a><span class="line-modified">429 #ifdef ASSERT</span>
<span class="line-removed">430     Monitor *locks = old_owner-&gt;owned_locks();</span>
431 
432     // remove &quot;this&quot; from the owned locks list
433 
<a name="55" id="anc55"></a><span class="line-modified">434     Monitor *prev = NULL;</span>
435     bool found = false;
436     for (; locks != NULL; prev = locks, locks = locks-&gt;next()) {
437       if (locks == this) {
438         found = true;
439         break;
440       }
441     }
442     assert(found, &quot;Removing a lock not owned&quot;);
443     if (prev == NULL) {
444       old_owner-&gt;_owned_locks = _next;
445     } else {
446       prev-&gt;_next = _next;
447     }
448     _next = NULL;
<a name="56" id="anc56"></a><span class="line-removed">449 #endif</span>
<span class="line-removed">450   }</span>
<span class="line-removed">451 }</span>
<span class="line-removed">452 </span>
<span class="line-removed">453 </span>
<span class="line-removed">454 // Factored out common sanity checks for locking mutex&#39;es. Used by lock() and try_lock()</span>
<span class="line-removed">455 void Monitor::check_prelock_state(Thread *thread, bool safepoint_check) {</span>
<span class="line-removed">456   if (safepoint_check) {</span>
<span class="line-removed">457     assert((!thread-&gt;is_Java_thread() || ((JavaThread *)thread)-&gt;thread_state() == _thread_in_vm)</span>
<span class="line-removed">458            || rank() == Mutex::special, &quot;wrong thread state for using locks&quot;);</span>
<span class="line-removed">459     if (thread-&gt;is_VM_thread() &amp;&amp; !allow_vm_block()) {</span>
<span class="line-removed">460       fatal(&quot;VM thread using lock %s (not allowed to block on)&quot;, name());</span>
<span class="line-removed">461     }</span>
<span class="line-removed">462     DEBUG_ONLY(if (rank() != Mutex::special) \</span>
<span class="line-removed">463                thread-&gt;check_for_valid_safepoint_state(false);)</span>
<span class="line-removed">464   }</span>
<span class="line-removed">465   assert(!os::ThreadCrashProtection::is_crash_protected(thread),</span>
<span class="line-removed">466          &quot;locking not allowed when crash protection is set&quot;);</span>
<span class="line-removed">467 }</span>
468 
<a name="57" id="anc57"></a><span class="line-modified">469 void Monitor::check_block_state(Thread *thread) {</span>
<span class="line-modified">470   if (!_allow_vm_block &amp;&amp; thread-&gt;is_VM_thread()) {</span>
<span class="line-removed">471     warning(&quot;VM thread blocked on lock&quot;);</span>
<span class="line-removed">472     print();</span>
<span class="line-removed">473     BREAKPOINT;</span>
474   }
<a name="58" id="anc58"></a><span class="line-removed">475   assert(_owner != thread, &quot;deadlock: blocking on monitor owned by current thread&quot;);</span>
476 }
<a name="59" id="anc59"></a><span class="line-modified">477 </span>
<span class="line-removed">478 #endif // PRODUCT</span>
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/objectMonitor.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="objectMonitor.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objectMonitor.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/objectMonitor.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,10 +25,11 @@</span>
  #ifndef SHARE_RUNTIME_OBJECTMONITOR_HPP
  #define SHARE_RUNTIME_OBJECTMONITOR_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/padded.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/park.hpp&quot;
  #include &quot;runtime/perfData.hpp&quot;
  
  class ObjectMonitor;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -40,19 +41,17 @@</span>
  // See next_waiter(), first_waiter(), etc.
  
  class ObjectWaiter : public StackObj {
   public:
    enum TStates { TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ };
<span class="udiff-line-modified-removed">-   enum Sorted  { PREPEND, APPEND, SORTED };</span>
<span class="udiff-line-modified-removed">-   ObjectWaiter * volatile _next;</span>
<span class="udiff-line-removed">-   ObjectWaiter * volatile _prev;</span>
<span class="udiff-line-modified-added">+   ObjectWaiter* volatile _next;</span>
<span class="udiff-line-modified-added">+   ObjectWaiter* volatile _prev;</span>
    Thread*       _thread;
    jlong         _notifier_tid;
    ParkEvent *   _event;
    volatile int  _notified;
    volatile TStates TState;
<span class="udiff-line-removed">-   Sorted        _Sorted;           // List placement disposition</span>
    bool          _active;           // Contention monitoring is enabled
   public:
    ObjectWaiter(Thread* thread);
  
    void wait_reenter_begin(ObjectMonitor *mon);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,18 +64,14 @@</span>
  // contention or use of Object.wait().
  //
  // WARNING: This is a very sensitive and fragile class. DO NOT make any
  // changes unless you are fully aware of the underlying semantics.
  //
<span class="udiff-line-removed">- // Class JvmtiRawMonitor currently inherits from ObjectMonitor so</span>
<span class="udiff-line-removed">- // changes in this class must be careful to not break JvmtiRawMonitor.</span>
<span class="udiff-line-removed">- // These two subsystems should be separated.</span>
<span class="udiff-line-removed">- //</span>
  // ObjectMonitor Layout Overview/Highlights/Restrictions:
  //
  // - The _header field must be at offset 0 because the displaced header
<span class="udiff-line-modified-removed">- //   from markOop is stored there. We do not want markOop.hpp to include</span>
<span class="udiff-line-modified-added">+ //   from markWord is stored there. We do not want markWord.hpp to include</span>
  //   ObjectMonitor.hpp to avoid exposing ObjectMonitor everywhere. This
  //   means that ObjectMonitor cannot inherit from any other class nor can
  //   it use any virtual member functions. This restriction is critical to
  //   the proper functioning of the VM.
  // - The _header and _owner fields should be separated by enough space
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123,53 +118,59 @@</span>
  //
  //   - The _recursions field should be of type int, or int32_t but not
  //     intptr_t. There&#39;s no reason to use a 64-bit type for this field
  //     in a 64-bit JVM.
  
<span class="udiff-line-modified-removed">- class ObjectMonitor {</span>
<span class="udiff-line-modified-removed">-  public:</span>
<span class="udiff-line-modified-removed">-   enum {</span>
<span class="udiff-line-modified-removed">-     OM_OK,                    // no error</span>
<span class="udiff-line-modified-removed">-     OM_SYSTEM_ERROR,          // operating system error</span>
<span class="udiff-line-removed">-     OM_ILLEGAL_MONITOR_STATE, // IllegalMonitorStateException</span>
<span class="udiff-line-removed">-     OM_INTERRUPTED,           // Thread.interrupt()</span>
<span class="udiff-line-removed">-     OM_TIMED_OUT              // Object.wait() timed out</span>
<span class="udiff-line-removed">-   };</span>
<span class="udiff-line-modified-added">+ #ifndef OM_CACHE_LINE_SIZE</span>
<span class="udiff-line-modified-added">+ // Use DEFAULT_CACHE_LINE_SIZE if not already specified for</span>
<span class="udiff-line-modified-added">+ // the current build platform.</span>
<span class="udiff-line-modified-added">+ #define OM_CACHE_LINE_SIZE DEFAULT_CACHE_LINE_SIZE</span>
<span class="udiff-line-modified-added">+ #endif</span>
  
<span class="udiff-line-modified-removed">-  private:</span>
<span class="udiff-line-modified-added">+ class ObjectMonitor {</span>
    friend class ObjectSynchronizer;
    friend class ObjectWaiter;
    friend class VMStructs;
<span class="udiff-line-added">+   JVMCI_ONLY(friend class JVMCIVMStructs;)</span>
  
<span class="udiff-line-modified-removed">-   volatile markOop   _header;       // displaced object header word - mark</span>
<span class="udiff-line-modified-removed">-   void*     volatile _object;       // backward object pointer - strong root</span>
<span class="udiff-line-modified-removed">-  public:</span>
<span class="udiff-line-modified-removed">-   ObjectMonitor*     FreeNext;      // Free list linkage</span>
<span class="udiff-line-modified-added">+   // The sync code expects the header field to be at offset zero (0).</span>
<span class="udiff-line-modified-added">+   // Enforced by the assert() in header_addr().</span>
<span class="udiff-line-modified-added">+   volatile markWord _header;        // displaced object header word - mark</span>
<span class="udiff-line-modified-added">+   void* volatile _object;           // backward object pointer - strong root</span>
   private:
<span class="udiff-line-modified-removed">-   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE,</span>
<span class="udiff-line-modified-removed">-                         sizeof(volatile markOop) + sizeof(void * volatile) +</span>
<span class="udiff-line-modified-removed">-                         sizeof(ObjectMonitor *));</span>
<span class="udiff-line-modified-removed">-  protected:                         // protected for JvmtiRawMonitor</span>
<span class="udiff-line-modified-removed">-   void *  volatile _owner;          // pointer to owning thread OR BasicLock</span>
<span class="udiff-line-modified-added">+   // Separate _header and _owner on different cache lines since both can</span>
<span class="udiff-line-modified-added">+   // have busy multi-threaded access. _header and _object are set at</span>
<span class="udiff-line-modified-added">+   // initial inflation and _object doesn&#39;t change until deflation so</span>
<span class="udiff-line-modified-added">+   // _object is a good choice to share the cache line with _header.</span>
<span class="udiff-line-modified-added">+   DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE,</span>
<span class="udiff-line-added">+                         sizeof(volatile markWord) + sizeof(void* volatile));</span>
<span class="udiff-line-added">+   void* volatile _owner;            // pointer to owning thread OR BasicLock</span>
    volatile jlong _previous_owner_tid;  // thread id of the previous owner of the monitor
<span class="udiff-line-modified-removed">-   volatile intptr_t  _recursions;   // recursion count, 0 for first entry</span>
<span class="udiff-line-modified-removed">-   ObjectWaiter * volatile _EntryList; // Threads blocked on entry or reentry.</span>
<span class="udiff-line-modified-added">+   // Separate _owner and _next_om on different cache lines since</span>
<span class="udiff-line-modified-added">+   // both can have busy multi-threaded access. _previous_owner_tid is only</span>
<span class="udiff-line-added">+   // changed by ObjectMonitor::exit() so it is a good choice to share the</span>
<span class="udiff-line-added">+   // cache line with _owner.</span>
<span class="udiff-line-added">+   DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(void* volatile) +</span>
<span class="udiff-line-added">+                         sizeof(volatile jlong));</span>
<span class="udiff-line-added">+   ObjectMonitor* _next_om;          // Next ObjectMonitor* linkage</span>
<span class="udiff-line-added">+   volatile intx _recursions;        // recursion count, 0 for first entry</span>
<span class="udiff-line-added">+   ObjectWaiter* volatile _EntryList;  // Threads blocked on entry or reentry.</span>
                                        // The list is actually composed of WaitNodes,
                                        // acting as proxies for Threads.
<span class="udiff-line-modified-removed">-  private:</span>
<span class="udiff-line-modified-removed">-   ObjectWaiter * volatile _cxq;     // LL of recently-arrived threads blocked on entry.</span>
<span class="udiff-line-modified-removed">-   Thread * volatile _succ;          // Heir presumptive thread - used for futile wakeup throttling</span>
<span class="udiff-line-modified-removed">-   Thread * volatile _Responsible;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   ObjectWaiter* volatile _cxq;      // LL of recently-arrived threads blocked on entry.</span>
<span class="udiff-line-modified-added">+   Thread* volatile _succ;           // Heir presumptive thread - used for futile wakeup throttling</span>
<span class="udiff-line-modified-added">+   Thread* volatile _Responsible;</span>
  
    volatile int _Spinner;            // for exit-&gt;spinner handoff optimization
    volatile int _SpinDuration;
  
<span class="udiff-line-modified-removed">-   volatile jint  _count;            // reference count to prevent reclamation/deflation</span>
<span class="udiff-line-modified-removed">-                                     // at stop-the-world time. See ObjectSynchronizer::deflate_monitor().</span>
<span class="udiff-line-modified-removed">-                                     // _count is approximately |_WaitSet| + |_EntryList|</span>
<span class="udiff-line-modified-added">+   volatile jint  _contentions;      // Number of active contentions in enter(). It is used by is_busy()</span>
<span class="udiff-line-modified-added">+                                     // along with other fields to determine if an ObjectMonitor can be</span>
<span class="udiff-line-modified-added">+                                     // deflated. See ObjectSynchronizer::deflate_monitor().</span>
   protected:
<span class="udiff-line-modified-removed">-   ObjectWaiter * volatile _WaitSet; // LL of threads wait()ing on the monitor</span>
<span class="udiff-line-modified-added">+   ObjectWaiter* volatile _WaitSet;  // LL of threads wait()ing on the monitor</span>
    volatile jint  _waiters;          // number of waiting threads
   private:
    volatile int _WaitSetLock;        // protects Wait Queue - simple spinlock
  
   public:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -198,24 +199,23 @@</span>
    static int Knob_SpinLimit;
  
    void* operator new (size_t size) throw();
    void* operator new[] (size_t size) throw();
    void operator delete(void* p);
<span class="udiff-line-modified-removed">-   void operator delete[] (void *p);</span>
<span class="udiff-line-modified-added">+   void operator delete[] (void* p);</span>
  
    // TODO-FIXME: the &quot;offset&quot; routines should return a type of off_t instead of int ...
    // ByteSize would also be an appropriate type.
    static int header_offset_in_bytes()      { return offset_of(ObjectMonitor, _header); }
    static int object_offset_in_bytes()      { return offset_of(ObjectMonitor, _object); }
    static int owner_offset_in_bytes()       { return offset_of(ObjectMonitor, _owner); }
<span class="udiff-line-removed">-   static int count_offset_in_bytes()       { return offset_of(ObjectMonitor, _count); }</span>
    static int recursions_offset_in_bytes()  { return offset_of(ObjectMonitor, _recursions); }
    static int cxq_offset_in_bytes()         { return offset_of(ObjectMonitor, _cxq); }
    static int succ_offset_in_bytes()        { return offset_of(ObjectMonitor, _succ); }
    static int EntryList_offset_in_bytes()   { return offset_of(ObjectMonitor, _EntryList); }
  
<span class="udiff-line-modified-removed">-   // ObjectMonitor references can be ORed with markOopDesc::monitor_value</span>
<span class="udiff-line-modified-added">+   // ObjectMonitor references can be ORed with markWord::monitor_value</span>
    // as part of the ObjectMonitor tagging mechanism. When we combine an
    // ObjectMonitor reference with an offset, we need to remove the tag
    // value in order to generate the proper address.
    //
    // We can either adjust the ObjectMonitor reference and then add the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -223,58 +223,74 @@</span>
    // reference. The latter avoids an AGI (Address Generation Interlock)
    // stall so the helper macro adjusts the offset value that is returned
    // to the ObjectMonitor reference manipulation code:
    //
    #define OM_OFFSET_NO_MONITOR_VALUE_TAG(f) \
<span class="udiff-line-modified-removed">-     ((ObjectMonitor::f ## _offset_in_bytes()) - markOopDesc::monitor_value)</span>
<span class="udiff-line-modified-added">+     ((ObjectMonitor::f ## _offset_in_bytes()) - markWord::monitor_value)</span>
  
<span class="udiff-line-modified-removed">-   markOop   header() const;</span>
<span class="udiff-line-modified-removed">-   volatile markOop* header_addr();</span>
<span class="udiff-line-modified-removed">-   void      set_header(markOop hdr);</span>
<span class="udiff-line-modified-added">+   markWord           header() const;</span>
<span class="udiff-line-modified-added">+   volatile markWord* header_addr();</span>
<span class="udiff-line-modified-added">+   void               set_header(markWord hdr);</span>
  
    intptr_t is_busy() const {
<span class="udiff-line-removed">-     // TODO-FIXME: merge _count and _waiters.</span>
      // TODO-FIXME: assert _owner == null implies _recursions = 0
<span class="udiff-line-modified-removed">-     // TODO-FIXME: assert _WaitSet != null implies _count &gt; 0</span>
<span class="udiff-line-removed">-     return _count|_waiters|intptr_t(_owner)|intptr_t(_cxq)|intptr_t(_EntryList);</span>
<span class="udiff-line-modified-added">+     return _contentions|_waiters|intptr_t(_owner)|intptr_t(_cxq)|intptr_t(_EntryList);</span>
    }
<span class="udiff-line-added">+   const char* is_busy_to_string(stringStream* ss);</span>
  
    intptr_t  is_entered(Thread* current) const;
  
    void*     owner() const;
<span class="udiff-line-modified-removed">-   void      set_owner(void* owner);</span>
<span class="udiff-line-modified-added">+   // Clear _owner field; current value must match old_value.</span>
<span class="udiff-line-added">+   void      release_clear_owner(void* old_value);</span>
<span class="udiff-line-added">+   // Simply set _owner field to new_value; current value must match old_value.</span>
<span class="udiff-line-added">+   void      set_owner_from(void* old_value, void* new_value);</span>
<span class="udiff-line-added">+   // Simply set _owner field to self; current value must match basic_lock_p.</span>
<span class="udiff-line-added">+   void      set_owner_from_BasicLock(void* basic_lock_p, Thread* self);</span>
<span class="udiff-line-added">+   // Try to set _owner field to new_value if the current value matches</span>
<span class="udiff-line-added">+   // old_value, using Atomic::cmpxchg(). Otherwise, does not change the</span>
<span class="udiff-line-added">+   // _owner field. Returns the prior value of the _owner field.</span>
<span class="udiff-line-added">+   void*     try_set_owner_from(void* old_value, void* new_value);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ObjectMonitor* next_om() const;</span>
<span class="udiff-line-added">+   // Simply set _next_om field to new_value.</span>
<span class="udiff-line-added">+   void set_next_om(ObjectMonitor* new_value);</span>
<span class="udiff-line-added">+   // Try to set _next_om field to new_value if the current value matches</span>
<span class="udiff-line-added">+   // old_value, using Atomic::cmpxchg(). Otherwise, does not change the</span>
<span class="udiff-line-added">+   // _next_om field. Returns the prior value of the _next_om field.</span>
<span class="udiff-line-added">+   ObjectMonitor* try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value);</span>
  
    jint      waiters() const;
  
<span class="udiff-line-removed">-   jint      count() const;</span>
<span class="udiff-line-removed">-   void      set_count(jint count);</span>
    jint      contentions() const;
<span class="udiff-line-modified-removed">-   intptr_t  recursions() const                                         { return _recursions; }</span>
<span class="udiff-line-modified-added">+   intx      recursions() const                                         { return _recursions; }</span>
  
    // JVM/TI GetObjectMonitorUsage() needs this:
    ObjectWaiter* first_waiter()                                         { return _WaitSet; }
    ObjectWaiter* next_waiter(ObjectWaiter* o)                           { return o-&gt;_next; }
    Thread* thread_of_waiter(ObjectWaiter* o)                            { return o-&gt;_thread; }
  
   protected:
    // We don&#39;t typically expect or want the ctors or dtors to run.
    // normal ObjectMonitors are type-stable and immortal.
<span class="udiff-line-modified-removed">-   ObjectMonitor() { ::memset((void *)this, 0, sizeof(*this)); }</span>
<span class="udiff-line-modified-added">+   ObjectMonitor() { ::memset((void*)this, 0, sizeof(*this)); }</span>
  
    ~ObjectMonitor() {
      // TODO: Add asserts ...
      // _cxq == 0 _succ == NULL _owner == NULL _waiters == 0
<span class="udiff-line-modified-removed">-     // _count == 0 _EntryList  == NULL etc</span>
<span class="udiff-line-modified-added">+     // _contentions == 0 _EntryList  == NULL etc</span>
    }
  
   private:
    void Recycle() {
      // TODO: add stronger asserts ...
      // _cxq == 0 _succ == NULL _owner == NULL _waiters == 0
<span class="udiff-line-modified-removed">-     // _count == 0 EntryList  == NULL</span>
<span class="udiff-line-modified-added">+     // _contentions == 0 EntryList  == NULL</span>
      // _recursions == 0 _WaitSet == NULL
<span class="udiff-line-modified-removed">-     assert(((is_busy()|_recursions) == 0), &quot;freeing inuse monitor&quot;);</span>
<span class="udiff-line-modified-added">+     DEBUG_ONLY(stringStream ss;)</span>
<span class="udiff-line-added">+     assert((is_busy() | _recursions) == 0, &quot;freeing in-use monitor: %s, &quot;</span>
<span class="udiff-line-added">+            &quot;recursions=&quot; INTX_FORMAT, is_busy_to_string(&amp;ss), _recursions);</span>
      _succ          = NULL;
      _EntryList     = NULL;
      _cxq           = NULL;
      _WaitSet       = NULL;
      _recursions    = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -284,35 +300,42 @@</span>
  
    void*     object() const;
    void*     object_addr();
    void      set_object(void* obj);
  
<span class="udiff-line-modified-removed">-   bool      check(TRAPS);       // true if the thread owns the monitor.</span>
<span class="udiff-line-modified-removed">-   void      check_slow(TRAPS);</span>
<span class="udiff-line-modified-added">+   // Returns true if the specified thread owns the ObjectMonitor. Otherwise</span>
<span class="udiff-line-modified-added">+   // returns false and throws IllegalMonitorStateException (IMSE).</span>
<span class="udiff-line-added">+   bool      check_owner(Thread* THREAD);</span>
    void      clear();
  
    void      enter(TRAPS);
    void      exit(bool not_suspended, TRAPS);
    void      wait(jlong millis, bool interruptable, TRAPS);
    void      notify(TRAPS);
    void      notifyAll(TRAPS);
  
<span class="udiff-line-added">+   void      print() const;</span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+   void      print_debug_style_on(outputStream* st) const;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   void      print_on(outputStream* st) const;</span>
<span class="udiff-line-added">+ </span>
  // Use the following at your own risk
<span class="udiff-line-modified-removed">-   intptr_t  complete_exit(TRAPS);</span>
<span class="udiff-line-modified-removed">-   void      reenter(intptr_t recursions, TRAPS);</span>
<span class="udiff-line-modified-added">+   intx      complete_exit(TRAPS);</span>
<span class="udiff-line-modified-added">+   void      reenter(intx recursions, TRAPS);</span>
  
   private:
<span class="udiff-line-modified-removed">-   void      AddWaiter(ObjectWaiter * waiter);</span>
<span class="udiff-line-modified-removed">-   void      INotify(Thread * Self);</span>
<span class="udiff-line-modified-removed">-   ObjectWaiter * DequeueWaiter();</span>
<span class="udiff-line-modified-removed">-   void      DequeueSpecificWaiter(ObjectWaiter * waiter);</span>
<span class="udiff-line-modified-added">+   void      AddWaiter(ObjectWaiter* waiter);</span>
<span class="udiff-line-modified-added">+   void      INotify(Thread* self);</span>
<span class="udiff-line-modified-added">+   ObjectWaiter* DequeueWaiter();</span>
<span class="udiff-line-modified-added">+   void      DequeueSpecificWaiter(ObjectWaiter* waiter);</span>
    void      EnterI(TRAPS);
<span class="udiff-line-modified-removed">-   void      ReenterI(Thread * Self, ObjectWaiter * SelfNode);</span>
<span class="udiff-line-modified-removed">-   void      UnlinkAfterAcquire(Thread * Self, ObjectWaiter * SelfNode);</span>
<span class="udiff-line-modified-removed">-   int       TryLock(Thread * Self);</span>
<span class="udiff-line-modified-removed">-   int       NotRunnable(Thread * Self, Thread * Owner);</span>
<span class="udiff-line-modified-removed">-   int       TrySpin(Thread * Self);</span>
<span class="udiff-line-modified-removed">-   void      ExitEpilog(Thread * Self, ObjectWaiter * Wakee);</span>
<span class="udiff-line-modified-removed">-   bool      ExitSuspendEquivalent(JavaThread * Self);</span>
<span class="udiff-line-modified-added">+   void      ReenterI(Thread* self, ObjectWaiter* self_node);</span>
<span class="udiff-line-modified-added">+   void      UnlinkAfterAcquire(Thread* self, ObjectWaiter* self_node);</span>
<span class="udiff-line-modified-added">+   int       TryLock(Thread* self);</span>
<span class="udiff-line-modified-added">+   int       NotRunnable(Thread* self, Thread * Owner);</span>
<span class="udiff-line-modified-added">+   int       TrySpin(Thread* self);</span>
<span class="udiff-line-modified-added">+   void      ExitEpilog(Thread* self, ObjectWaiter* Wakee);</span>
<span class="udiff-line-modified-added">+   bool      ExitSuspendEquivalent(JavaThread* self);</span>
  };
  
  #endif // SHARE_RUNTIME_OBJECTMONITOR_HPP
</pre>
<center><a href="objectMonitor.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objectMonitor.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/thread.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="thread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadHeapSampler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_THREAD_INLINE_HPP
 26 #define SHARE_RUNTIME_THREAD_INLINE_HPP
 27 
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/globals.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/os.inline.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 
 35 inline void Thread::set_suspend_flag(SuspendFlags f) {
 36   uint32_t flags;
 37   do {
 38     flags = _suspend_flags;
 39   }
<span class="line-modified"> 40   while (Atomic::cmpxchg((flags | f), &amp;_suspend_flags, flags) != flags);</span>
 41 }
 42 inline void Thread::clear_suspend_flag(SuspendFlags f) {
 43   uint32_t flags;
 44   do {
 45     flags = _suspend_flags;
 46   }
<span class="line-modified"> 47   while (Atomic::cmpxchg((flags &amp; ~f), &amp;_suspend_flags, flags) != flags);</span>
 48 }
 49 
 50 inline void Thread::set_has_async_exception() {
 51   set_suspend_flag(_has_async_exception);
 52 }
 53 inline void Thread::clear_has_async_exception() {
 54   clear_suspend_flag(_has_async_exception);
 55 }
 56 inline void Thread::set_critical_native_unlock() {
 57   set_suspend_flag(_critical_native_unlock);
 58 }
 59 inline void Thread::clear_critical_native_unlock() {
 60   clear_suspend_flag(_critical_native_unlock);
 61 }
 62 inline void Thread::set_trace_flag() {
 63   set_suspend_flag(_trace_flag);
 64 }
 65 inline void Thread::clear_trace_flag() {
 66   clear_suspend_flag(_trace_flag);
 67 }
 68 
 69 inline jlong Thread::cooked_allocated_bytes() {
<span class="line-modified"> 70   jlong allocated_bytes = OrderAccess::load_acquire(&amp;_allocated_bytes);</span>
 71   if (UseTLAB) {
 72     size_t used_bytes = tlab().used_bytes();
 73     if (used_bytes &lt;= ThreadLocalAllocBuffer::max_size_in_bytes()) {
 74       // Comparing used_bytes with the maximum allowed size will ensure
 75       // that we don&#39;t add the used bytes from a semi-initialized TLAB
 76       // ending up with incorrect values. There is still a race between
 77       // incrementing _allocated_bytes and clearing the TLAB, that might
 78       // cause double counting in rare cases.
 79       return allocated_bytes + used_bytes;
 80     }
 81   }
 82   return allocated_bytes;
 83 }
 84 
 85 inline ThreadsList* Thread::cmpxchg_threads_hazard_ptr(ThreadsList* exchange_value, ThreadsList* compare_value) {
<span class="line-modified"> 86   return (ThreadsList*)Atomic::cmpxchg(exchange_value, &amp;_threads_hazard_ptr, compare_value);</span>
 87 }
 88 
 89 inline ThreadsList* Thread::get_threads_hazard_ptr() {
<span class="line-modified"> 90   return (ThreadsList*)OrderAccess::load_acquire(&amp;_threads_hazard_ptr);</span>
 91 }
 92 
 93 inline void Thread::set_threads_hazard_ptr(ThreadsList* new_list) {
<span class="line-modified"> 94   OrderAccess::release_store_fence(&amp;_threads_hazard_ptr, new_list);</span>
 95 }
 96 
 97 inline void JavaThread::set_ext_suspended() {
 98   set_suspend_flag (_ext_suspended);
 99 }
100 inline void JavaThread::clear_ext_suspended() {
101   clear_suspend_flag(_ext_suspended);
102 }
103 
104 inline void JavaThread::set_external_suspend() {
105   set_suspend_flag(_external_suspend);
106 }
107 inline void JavaThread::clear_external_suspend() {
108   clear_suspend_flag(_external_suspend);
109 }
110 
<span class="line-removed">111 inline void JavaThread::set_deopt_suspend() {</span>
<span class="line-removed">112   set_suspend_flag(_deopt_suspend);</span>
<span class="line-removed">113 }</span>
<span class="line-removed">114 inline void JavaThread::clear_deopt_suspend() {</span>
<span class="line-removed">115   clear_suspend_flag(_deopt_suspend);</span>
<span class="line-removed">116 }</span>
<span class="line-removed">117 </span>
118 inline void JavaThread::set_pending_async_exception(oop e) {
119   _pending_async_exception = e;
120   _special_runtime_exit_condition = _async_exception;
121   set_has_async_exception();
122 }
123 
124 inline JavaThreadState JavaThread::thread_state() const    {
125 #if defined(PPC64) || defined (AARCH64)
126   // Use membars when accessing volatile _thread_state. See
127   // Threads::create_vm() for size checks.
<span class="line-modified">128   return (JavaThreadState) OrderAccess::load_acquire((volatile jint*)&amp;_thread_state);</span>
129 #else
130   return _thread_state;
131 #endif
132 }
133 
134 inline void JavaThread::set_thread_state(JavaThreadState s) {


135 #if defined(PPC64) || defined (AARCH64)
136   // Use membars when accessing volatile _thread_state. See
137   // Threads::create_vm() for size checks.
<span class="line-modified">138   OrderAccess::release_store((volatile jint*)&amp;_thread_state, (jint)s);</span>
139 #else
140   _thread_state = s;
141 #endif
142 }
143 





144 ThreadSafepointState* JavaThread::safepoint_state() const  {
145   return _safepoint_state;
146 }
147 
148 void JavaThread::set_safepoint_state(ThreadSafepointState *state) {
149   _safepoint_state = state;
150 }
151 
152 bool JavaThread::is_at_poll_safepoint() {
153   return _safepoint_state-&gt;is_at_poll_safepoint();
154 }
155 
156 void JavaThread::enter_critical() {
157   assert(Thread::current() == this ||
158          (Thread::current()-&gt;is_VM_thread() &amp;&amp;
159          SafepointSynchronize::is_synchronizing()),
160          &quot;this must be current thread or synchronizing&quot;);
161   _jni_active_critical++;
162 }
163 
</pre>
<hr />
<pre>
185     low_addr = stack_end();
186   } else {
187     low_addr = stack_reserved_zone_base();
188   }
189   return cur_sp &gt; low_addr ? cur_sp - low_addr : 0;
190 }
191 
192 inline bool JavaThread::stack_guards_enabled() {
193 #ifdef ASSERT
194   if (os::uses_stack_guard_pages() &amp;&amp;
195       !(DisablePrimordialThreadGuardPages &amp;&amp; os::is_primordial_thread())) {
196     assert(_stack_guard_state != stack_guard_unused, &quot;guard pages must be in use&quot;);
197   }
198 #endif
199   return _stack_guard_state == stack_guard_enabled;
200 }
201 
202 // The release make sure this store is done after storing the handshake
203 // operation or global state
204 inline void JavaThread::set_polling_page_release(void* poll_value) {
<span class="line-modified">205   OrderAccess::release_store(polling_page_addr(), poll_value);</span>
206 }
207 
208 // Caller is responsible for using a memory barrier if needed.
209 inline void JavaThread::set_polling_page(void* poll_value) {
210   *polling_page_addr() = poll_value;
211 }
212 
213 // The aqcquire make sure reading of polling page is done before
214 // the reading the handshake operation or the global state
215 inline volatile void* JavaThread::get_polling_page() {
<span class="line-modified">216   return OrderAccess::load_acquire(polling_page_addr());</span>
217 }
218 
219 inline bool JavaThread::is_exiting() const {
220   // Use load-acquire so that setting of _terminated by
221   // JavaThread::exit() is seen more quickly.
222   TerminatedTypes l_terminated = (TerminatedTypes)
<span class="line-modified">223       OrderAccess::load_acquire((volatile jint *) &amp;_terminated);</span>
224   return l_terminated == _thread_exiting || check_is_terminated(l_terminated);
225 }
226 
227 inline bool JavaThread::is_terminated() const {
228   // Use load-acquire so that setting of _terminated by
229   // JavaThread::exit() is seen more quickly.
230   TerminatedTypes l_terminated = (TerminatedTypes)
<span class="line-modified">231       OrderAccess::load_acquire((volatile jint *) &amp;_terminated);</span>
232   return check_is_terminated(l_terminated);
233 }
234 
235 inline void JavaThread::set_terminated(TerminatedTypes t) {
236   // use release-store so the setting of _terminated is seen more quickly
<span class="line-modified">237   OrderAccess::release_store((volatile jint *) &amp;_terminated, (jint) t);</span>
238 }
239 
240 // special for Threads::remove() which is static:
241 inline void JavaThread::set_terminated_value() {
242   // use release-store so the setting of _terminated is seen more quickly
<span class="line-modified">243   OrderAccess::release_store((volatile jint *) &amp;_terminated, (jint) _thread_terminated);</span>
244 }
245 
246 // Allow tracking of class initialization monitor use
247 inline void JavaThread::set_class_to_be_initialized(InstanceKlass* k) {
248   assert((k == NULL &amp;&amp; _class_to_be_initialized != NULL) ||
249          (k != NULL &amp;&amp; _class_to_be_initialized == NULL), &quot;incorrect usage&quot;);
250   assert(this == Thread::current(), &quot;Only the current thread can set this field&quot;);
251   _class_to_be_initialized = k;
252 }
253 
254 inline InstanceKlass* JavaThread::class_to_be_initialized() const {
255   return _class_to_be_initialized;
256 }
257 
258 #endif // SHARE_RUNTIME_THREAD_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_THREAD_INLINE_HPP
 26 #define SHARE_RUNTIME_THREAD_INLINE_HPP
 27 
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/globals.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/os.inline.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 
 35 inline void Thread::set_suspend_flag(SuspendFlags f) {
 36   uint32_t flags;
 37   do {
 38     flags = _suspend_flags;
 39   }
<span class="line-modified"> 40   while (Atomic::cmpxchg(&amp;_suspend_flags, flags, (flags | f)) != flags);</span>
 41 }
 42 inline void Thread::clear_suspend_flag(SuspendFlags f) {
 43   uint32_t flags;
 44   do {
 45     flags = _suspend_flags;
 46   }
<span class="line-modified"> 47   while (Atomic::cmpxchg(&amp;_suspend_flags, flags, (flags &amp; ~f)) != flags);</span>
 48 }
 49 
 50 inline void Thread::set_has_async_exception() {
 51   set_suspend_flag(_has_async_exception);
 52 }
 53 inline void Thread::clear_has_async_exception() {
 54   clear_suspend_flag(_has_async_exception);
 55 }
 56 inline void Thread::set_critical_native_unlock() {
 57   set_suspend_flag(_critical_native_unlock);
 58 }
 59 inline void Thread::clear_critical_native_unlock() {
 60   clear_suspend_flag(_critical_native_unlock);
 61 }
 62 inline void Thread::set_trace_flag() {
 63   set_suspend_flag(_trace_flag);
 64 }
 65 inline void Thread::clear_trace_flag() {
 66   clear_suspend_flag(_trace_flag);
 67 }
 68 
 69 inline jlong Thread::cooked_allocated_bytes() {
<span class="line-modified"> 70   jlong allocated_bytes = Atomic::load_acquire(&amp;_allocated_bytes);</span>
 71   if (UseTLAB) {
 72     size_t used_bytes = tlab().used_bytes();
 73     if (used_bytes &lt;= ThreadLocalAllocBuffer::max_size_in_bytes()) {
 74       // Comparing used_bytes with the maximum allowed size will ensure
 75       // that we don&#39;t add the used bytes from a semi-initialized TLAB
 76       // ending up with incorrect values. There is still a race between
 77       // incrementing _allocated_bytes and clearing the TLAB, that might
 78       // cause double counting in rare cases.
 79       return allocated_bytes + used_bytes;
 80     }
 81   }
 82   return allocated_bytes;
 83 }
 84 
 85 inline ThreadsList* Thread::cmpxchg_threads_hazard_ptr(ThreadsList* exchange_value, ThreadsList* compare_value) {
<span class="line-modified"> 86   return (ThreadsList*)Atomic::cmpxchg(&amp;_threads_hazard_ptr, compare_value, exchange_value);</span>
 87 }
 88 
 89 inline ThreadsList* Thread::get_threads_hazard_ptr() {
<span class="line-modified"> 90   return (ThreadsList*)Atomic::load_acquire(&amp;_threads_hazard_ptr);</span>
 91 }
 92 
 93 inline void Thread::set_threads_hazard_ptr(ThreadsList* new_list) {
<span class="line-modified"> 94   Atomic::release_store_fence(&amp;_threads_hazard_ptr, new_list);</span>
 95 }
 96 
 97 inline void JavaThread::set_ext_suspended() {
 98   set_suspend_flag (_ext_suspended);
 99 }
100 inline void JavaThread::clear_ext_suspended() {
101   clear_suspend_flag(_ext_suspended);
102 }
103 
104 inline void JavaThread::set_external_suspend() {
105   set_suspend_flag(_external_suspend);
106 }
107 inline void JavaThread::clear_external_suspend() {
108   clear_suspend_flag(_external_suspend);
109 }
110 







111 inline void JavaThread::set_pending_async_exception(oop e) {
112   _pending_async_exception = e;
113   _special_runtime_exit_condition = _async_exception;
114   set_has_async_exception();
115 }
116 
117 inline JavaThreadState JavaThread::thread_state() const    {
118 #if defined(PPC64) || defined (AARCH64)
119   // Use membars when accessing volatile _thread_state. See
120   // Threads::create_vm() for size checks.
<span class="line-modified">121   return (JavaThreadState) Atomic::load_acquire((volatile jint*)&amp;_thread_state);</span>
122 #else
123   return _thread_state;
124 #endif
125 }
126 
127 inline void JavaThread::set_thread_state(JavaThreadState s) {
<span class="line-added">128   assert(current_or_null() == NULL || current_or_null() == this,</span>
<span class="line-added">129          &quot;state change should only be called by the current thread&quot;);</span>
130 #if defined(PPC64) || defined (AARCH64)
131   // Use membars when accessing volatile _thread_state. See
132   // Threads::create_vm() for size checks.
<span class="line-modified">133   Atomic::release_store((volatile jint*)&amp;_thread_state, (jint)s);</span>
134 #else
135   _thread_state = s;
136 #endif
137 }
138 
<span class="line-added">139 inline void JavaThread::set_thread_state_fence(JavaThreadState s) {</span>
<span class="line-added">140   set_thread_state(s);</span>
<span class="line-added">141   OrderAccess::fence();</span>
<span class="line-added">142 }</span>
<span class="line-added">143 </span>
144 ThreadSafepointState* JavaThread::safepoint_state() const  {
145   return _safepoint_state;
146 }
147 
148 void JavaThread::set_safepoint_state(ThreadSafepointState *state) {
149   _safepoint_state = state;
150 }
151 
152 bool JavaThread::is_at_poll_safepoint() {
153   return _safepoint_state-&gt;is_at_poll_safepoint();
154 }
155 
156 void JavaThread::enter_critical() {
157   assert(Thread::current() == this ||
158          (Thread::current()-&gt;is_VM_thread() &amp;&amp;
159          SafepointSynchronize::is_synchronizing()),
160          &quot;this must be current thread or synchronizing&quot;);
161   _jni_active_critical++;
162 }
163 
</pre>
<hr />
<pre>
185     low_addr = stack_end();
186   } else {
187     low_addr = stack_reserved_zone_base();
188   }
189   return cur_sp &gt; low_addr ? cur_sp - low_addr : 0;
190 }
191 
192 inline bool JavaThread::stack_guards_enabled() {
193 #ifdef ASSERT
194   if (os::uses_stack_guard_pages() &amp;&amp;
195       !(DisablePrimordialThreadGuardPages &amp;&amp; os::is_primordial_thread())) {
196     assert(_stack_guard_state != stack_guard_unused, &quot;guard pages must be in use&quot;);
197   }
198 #endif
199   return _stack_guard_state == stack_guard_enabled;
200 }
201 
202 // The release make sure this store is done after storing the handshake
203 // operation or global state
204 inline void JavaThread::set_polling_page_release(void* poll_value) {
<span class="line-modified">205   Atomic::release_store(polling_page_addr(), poll_value);</span>
206 }
207 
208 // Caller is responsible for using a memory barrier if needed.
209 inline void JavaThread::set_polling_page(void* poll_value) {
210   *polling_page_addr() = poll_value;
211 }
212 
213 // The aqcquire make sure reading of polling page is done before
214 // the reading the handshake operation or the global state
215 inline volatile void* JavaThread::get_polling_page() {
<span class="line-modified">216   return Atomic::load_acquire(polling_page_addr());</span>
217 }
218 
219 inline bool JavaThread::is_exiting() const {
220   // Use load-acquire so that setting of _terminated by
221   // JavaThread::exit() is seen more quickly.
222   TerminatedTypes l_terminated = (TerminatedTypes)
<span class="line-modified">223       Atomic::load_acquire((volatile jint *) &amp;_terminated);</span>
224   return l_terminated == _thread_exiting || check_is_terminated(l_terminated);
225 }
226 
227 inline bool JavaThread::is_terminated() const {
228   // Use load-acquire so that setting of _terminated by
229   // JavaThread::exit() is seen more quickly.
230   TerminatedTypes l_terminated = (TerminatedTypes)
<span class="line-modified">231       Atomic::load_acquire((volatile jint *) &amp;_terminated);</span>
232   return check_is_terminated(l_terminated);
233 }
234 
235 inline void JavaThread::set_terminated(TerminatedTypes t) {
236   // use release-store so the setting of _terminated is seen more quickly
<span class="line-modified">237   Atomic::release_store((volatile jint *) &amp;_terminated, (jint) t);</span>
238 }
239 
240 // special for Threads::remove() which is static:
241 inline void JavaThread::set_terminated_value() {
242   // use release-store so the setting of _terminated is seen more quickly
<span class="line-modified">243   Atomic::release_store((volatile jint *) &amp;_terminated, (jint) _thread_terminated);</span>
244 }
245 
246 // Allow tracking of class initialization monitor use
247 inline void JavaThread::set_class_to_be_initialized(InstanceKlass* k) {
248   assert((k == NULL &amp;&amp; _class_to_be_initialized != NULL) ||
249          (k != NULL &amp;&amp; _class_to_be_initialized == NULL), &quot;incorrect usage&quot;);
250   assert(this == Thread::current(), &quot;Only the current thread can set this field&quot;);
251   _class_to_be_initialized = k;
252 }
253 
254 inline InstanceKlass* JavaThread::class_to_be_initialized() const {
255   return _class_to_be_initialized;
256 }
257 
258 #endif // SHARE_RUNTIME_THREAD_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="thread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadHeapSampler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
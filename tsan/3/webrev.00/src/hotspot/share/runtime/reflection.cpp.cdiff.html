<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/reflection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="perfMemory.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocator.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/reflection.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,11 ***</span>
  
  oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
    if (type == T_VOID) {
      return NULL;
    }
<span class="line-modified">!   if (type == T_OBJECT || type == T_ARRAY) {</span>
      // regular objects are not boxed
      return (oop) value-&gt;l;
    }
    oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
    if (result == NULL) {
<span class="line-new-header">--- 90,11 ---</span>
  
  oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
    if (type == T_VOID) {
      return NULL;
    }
<span class="line-modified">!   if (is_reference_type(type)) {</span>
      // regular objects are not boxed
      return (oop) value-&gt;l;
    }
    oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
    if (result == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,11 ***</span>
    return java_lang_boxing_object::get_value(box, value);
  }
  
  BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
    // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
<span class="line-modified">!   value-&gt;l = (jobject) box;</span>
    return T_OBJECT;
  }
  
  
  void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
<span class="line-new-header">--- 111,11 ---</span>
    return java_lang_boxing_object::get_value(box, value);
  }
  
  BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
    // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
<span class="line-modified">!   value-&gt;l = cast_from_oop&lt;jobject&gt;(box);</span>
    return T_OBJECT;
  }
  
  
  void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,11 ***</span>
  BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
    if (!a-&gt;is_within_bounds(index)) {
      THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
    }
    if (a-&gt;is_objArray()) {
<span class="line-modified">!     value-&gt;l = (jobject) objArrayOop(a)-&gt;obj_at(index);</span>
      return T_OBJECT;
    } else {
      assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
      BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
      switch (type) {
<span class="line-new-header">--- 222,11 ---</span>
  BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
    if (!a-&gt;is_within_bounds(index)) {
      THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
    }
    if (a-&gt;is_objArray()) {
<span class="line-modified">!     value-&gt;l = cast_from_oop&lt;jobject&gt;(objArrayOop(a)-&gt;obj_at(index));</span>
      return T_OBJECT;
    } else {
      assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
      BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
      switch (type) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 754,12 ***</span>
  static oop get_mirror_from_signature(const methodHandle&amp; method,
                                       SignatureStream* ss,
                                       TRAPS) {
  
  
<span class="line-modified">!   if (T_OBJECT == ss-&gt;type() || T_ARRAY == ss-&gt;type()) {</span>
<span class="line-modified">!     Symbol* name = ss-&gt;as_symbol(CHECK_NULL);</span>
      oop loader = method-&gt;method_holder()-&gt;class_loader();
      oop protection_domain = method-&gt;method_holder()-&gt;protection_domain();
      const Klass* k = SystemDictionary::resolve_or_fail(name,
                                                         Handle(THREAD, loader),
                                                         Handle(THREAD, protection_domain),
<span class="line-new-header">--- 754,12 ---</span>
  static oop get_mirror_from_signature(const methodHandle&amp; method,
                                       SignatureStream* ss,
                                       TRAPS) {
  
  
<span class="line-modified">!   if (is_reference_type(ss-&gt;type())) {</span>
<span class="line-modified">!     Symbol* name = ss-&gt;as_symbol();</span>
      oop loader = method-&gt;method_holder()-&gt;class_loader();
      oop protection_domain = method-&gt;method_holder()-&gt;protection_domain();
      const Klass* k = SystemDictionary::resolve_or_fail(name,
                                                         Handle(THREAD, loader),
                                                         Handle(THREAD, protection_domain),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 806,12 ***</span>
  static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
    return method-&gt;resolved_checked_exceptions(THREAD);
  }
  
  static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
    // Basic types
<span class="line-modified">!   BasicType type = vmSymbols::signature_type(signature);</span>
    if (type != T_OBJECT) {
      return Handle(THREAD, Universe::java_mirror(type));
    }
  
    Klass* result =
<span class="line-new-header">--- 806,13 ---</span>
  static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
    return method-&gt;resolved_checked_exceptions(THREAD);
  }
  
  static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
<span class="line-added">+   SignatureStream ss(signature, false);</span>
    // Basic types
<span class="line-modified">!   BasicType type = ss.is_reference() ? T_OBJECT : ss.type();</span>
    if (type != T_OBJECT) {
      return Handle(THREAD, Universe::java_mirror(type));
    }
  
    Klass* result =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 976,11 ***</span>
    Symbol*  name       = method-&gt;name();
    LinkResolver::resolve_interface_call(info, receiver, recv_klass,
                                         LinkInfo(klass, name, signature),
                                         true,
                                         CHECK_(methodHandle()));
<span class="line-modified">!   return info.selected_method();</span>
  }
  
  // Conversion
  static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
    assert(java_lang_Class::is_primitive(basic_type_mirror),
<span class="line-new-header">--- 977,11 ---</span>
    Symbol*  name       = method-&gt;name();
    LinkResolver::resolve_interface_call(info, receiver, recv_klass,
                                         LinkInfo(klass, name, signature),
                                         true,
                                         CHECK_(methodHandle()));
<span class="line-modified">!   return methodHandle(THREAD, info.selected_method());</span>
  }
  
  // Conversion
  static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
    assert(java_lang_Class::is_primitive(basic_type_mirror),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1083,15 ***</span>
          if (!method.is_null()) {
            // Check for abstract methods as well
            if (method-&gt;is_abstract()) {
              // new default: 6531596
              ResourceMark rm(THREAD);
              Handle h_origexception = Exceptions::new_exception(THREAD,
<span class="line-modified">!               vmSymbols::java_lang_AbstractMethodError(),</span>
<span class="line-removed">-               Method::name_and_sig_as_C_string(target_klass,</span>
<span class="line-removed">-               method-&gt;name(),</span>
<span class="line-removed">-               method-&gt;signature()));</span>
              JavaCallArguments args(h_origexception);
              THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
                vmSymbols::throwable_void_signature(),
                &amp;args);
            }
<span class="line-new-header">--- 1084,16 ---</span>
          if (!method.is_null()) {
            // Check for abstract methods as well
            if (method-&gt;is_abstract()) {
              // new default: 6531596
              ResourceMark rm(THREAD);
<span class="line-added">+             stringStream ss;</span>
<span class="line-added">+             ss.print(&quot;&#39;&quot;);</span>
<span class="line-added">+             Method::print_external_name(&amp;ss, target_klass, method-&gt;name(), method-&gt;signature());</span>
<span class="line-added">+             ss.print(&quot;&#39;&quot;);</span>
              Handle h_origexception = Exceptions::new_exception(THREAD,
<span class="line-modified">!               vmSymbols::java_lang_AbstractMethodError(), ss.as_string());</span>
              JavaCallArguments args(h_origexception);
              THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
                vmSymbols::throwable_void_signature(),
                &amp;args);
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1102,14 ***</span>
  
    // I believe this is a ShouldNotGetHere case which requires
    // an internal vtable bug. If you ever get this please let Karen know.
    if (method.is_null()) {
      ResourceMark rm(THREAD);
<span class="line-modified">!     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(),</span>
<span class="line-modified">!                 Method::name_and_sig_as_C_string(klass,</span>
<span class="line-modified">!                 reflected_method-&gt;name(),</span>
<span class="line-modified">!                 reflected_method-&gt;signature()));</span>
    }
  
    assert(ptypes-&gt;is_objArray(), &quot;just checking&quot;);
    int args_len = args.is_null() ? 0 : args-&gt;length();
    // Check number of arguments
<span class="line-new-header">--- 1104,17 ---</span>
  
    // I believe this is a ShouldNotGetHere case which requires
    // an internal vtable bug. If you ever get this please let Karen know.
    if (method.is_null()) {
      ResourceMark rm(THREAD);
<span class="line-modified">!     stringStream ss;</span>
<span class="line-modified">!     ss.print(&quot;&#39;&quot;);</span>
<span class="line-modified">!     Method::print_external_name(&amp;ss, klass,</span>
<span class="line-modified">!                                      reflected_method-&gt;name(),</span>
<span class="line-added">+                                      reflected_method-&gt;signature());</span>
<span class="line-added">+     ss.print(&quot;&#39;&quot;);</span>
<span class="line-added">+     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());</span>
    }
  
    assert(ptypes-&gt;is_objArray(), &quot;just checking&quot;);
    int args_len = args.is_null() ? 0 : args-&gt;length();
    // Check number of arguments
</pre>
<center><a href="perfMemory.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="relocator.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
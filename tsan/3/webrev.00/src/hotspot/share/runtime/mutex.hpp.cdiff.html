<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/mutex.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mutex.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutexLocker.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/mutex.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,23 ***</span>
  #ifndef SHARE_RUNTIME_MUTEX_HPP
  #define SHARE_RUNTIME_MUTEX_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
<span class="line-removed">- #include &quot;utilities/histogram.hpp&quot;</span>
<span class="line-removed">- </span>
  
  // A Mutex/Monitor is a simple wrapper around a native lock plus condition
  // variable that supports lock ownership tracking, lock ranking for deadlock
  // detection and coordinates with the safepoint protocol.
  
<span class="line-modified">! // The default length of monitor name was originally chosen to be 64 to avoid</span>
<span class="line-modified">! // false sharing. Now, PaddedMonitor is available for this purpose.</span>
<span class="line-modified">! // TODO: Check if _name[MONITOR_NAME_LEN] should better get replaced by const char*.</span>
<span class="line-modified">! static const int MONITOR_NAME_LEN = 64;</span>
  
<span class="line-modified">! class Monitor : public CHeapObj&lt;mtSynchronizer&gt; {</span>
  
   public:
    // A special lock: Is a lock where you are guaranteed not to block while you are
    // holding it, i.e., no vm operation can happen, taking other (blocking) locks, etc.
    // The rank &#39;access&#39; is similar to &#39;special&#39; and has the same restrictions on usage.
<span class="line-new-header">--- 25,21 ---</span>
  #ifndef SHARE_RUNTIME_MUTEX_HPP
  #define SHARE_RUNTIME_MUTEX_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  
  // A Mutex/Monitor is a simple wrapper around a native lock plus condition
  // variable that supports lock ownership tracking, lock ranking for deadlock
  // detection and coordinates with the safepoint protocol.
  
<span class="line-modified">! // The default length of mutex name was originally chosen to be 64 to avoid</span>
<span class="line-modified">! // false sharing. Now, PaddedMutex and PaddedMonitor are available for this purpose.</span>
<span class="line-modified">! // TODO: Check if _name[MUTEX_NAME_LEN] should better get replaced by const char*.</span>
<span class="line-modified">! static const int MUTEX_NAME_LEN = 64;</span>
  
<span class="line-modified">! class Mutex : public CHeapObj&lt;mtSynchronizer&gt; {</span>
  
   public:
    // A special lock: Is a lock where you are guaranteed not to block while you are
    // holding it, i.e., no vm operation can happen, taking other (blocking) locks, etc.
    // The rank &#39;access&#39; is similar to &#39;special&#39; and has the same restrictions on usage.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,195 ***</span>
    // Since memory accesses should be able to be performed pretty much anywhere
    // in the code, that requires locks required for performing accesses being
    // inherently a bit more special than even locks of the &#39;special&#39; rank.
    // NOTE: It is critical that the rank &#39;special&#39; be the lowest (earliest)
    // (except for &quot;event&quot; and &quot;access&quot;) for the deadlock detection to work correctly.
<span class="line-modified">!   // The rank native is only for use in Mutex&#39;s created by JVM_RawMonitorCreate,</span>
<span class="line-modified">!   // which being external to the VM are not subject to deadlock detection.</span>
    // While at a safepoint no mutexes of rank safepoint are held by any thread.
    // The rank named &quot;leaf&quot; is probably historical (and should
    // be changed) -- mutexes of this rank aren&#39;t really leaf mutexes
    // at all.
    enum lock_types {
         event,
         access         = event          +   1,
         tty            = access         +   2,
<span class="line-modified">!        special        = tty            +   1,</span>
         suspend_resume = special        +   1,
<span class="line-modified">!        vmweak         = suspend_resume +   2,</span>
<span class="line-modified">!        leaf           = vmweak         +   2,</span>
         safepoint      = leaf           +  10,
         barrier        = safepoint      +   1,
         nonleaf        = barrier        +   1,
         max_nonleaf    = nonleaf        + 900,
         native         = max_nonleaf    +   1
    };
  
   protected:                              // Monitor-Mutex metadata
    Thread * volatile _owner;              // The owner of the lock
    os::PlatformMonitor _lock;             // Native monitor implementation
<span class="line-modified">!   char _name[MONITOR_NAME_LEN];          // Name of mutex/monitor</span>
  
    // Debugging fields for naming, deadlock detection, etc. (some only used in debug mode)
  #ifndef PRODUCT
<span class="line-modified">!   bool      _allow_vm_block;</span>
<span class="line-modified">!   DEBUG_ONLY(int _rank;)                 // rank (to avoid/detect potential deadlocks)</span>
<span class="line-modified">!   DEBUG_ONLY(Monitor * _next;)           // Used by a Thread to link up owned locks</span>
<span class="line-modified">!   DEBUG_ONLY(Thread* _last_owner;)       // the last thread to own the lock</span>
<span class="line-modified">!   DEBUG_ONLY(static bool contains(Monitor * locks, Monitor * lock);)</span>
<span class="line-modified">!   DEBUG_ONLY(static Monitor * get_least_ranked_lock(Monitor * locks);)</span>
<span class="line-modified">!   DEBUG_ONLY(Monitor * get_least_ranked_lock_besides_this(Monitor * locks);)</span>
<span class="line-modified">! #endif</span>
<span class="line-modified">! </span>
<span class="line-modified">!   void set_owner_implementation(Thread* owner)                        PRODUCT_RETURN;</span>
<span class="line-modified">!   void check_prelock_state     (Thread* thread, bool safepoint_check) PRODUCT_RETURN;</span>
<span class="line-modified">!   void check_block_state       (Thread* thread)                       PRODUCT_RETURN;</span>
    void assert_owner            (Thread* expected)                     NOT_DEBUG_RETURN;
  
   public:
    enum {
<span class="line-removed">-     _no_safepoint_check_flag    = true,</span>
      _allow_vm_block_flag        = true,
      _as_suspend_equivalent_flag = true
    };
  
<span class="line-modified">!   // Locks can be acquired with or without safepoint check.</span>
<span class="line-modified">!   // Monitor::lock and Monitor::lock_without_safepoint_check</span>
<span class="line-modified">!   // checks these flags when acquiring a lock to ensure</span>
<span class="line-modified">!   // consistent checking for each lock.</span>
<span class="line-modified">!   // A few existing locks will sometimes have a safepoint check and</span>
<span class="line-modified">!   // sometimes not, but these locks are set up in such a way to avoid deadlocks.</span>
<span class="line-modified">!   // Note: monitors that may be shared between JavaThreads and the VMThread</span>
<span class="line-modified">!   // should never encounter a safepoint check whilst they are held, else a</span>
<span class="line-modified">!   // deadlock with the VMThread can occur.</span>
    enum SafepointCheckRequired {
<span class="line-modified">!     _safepoint_check_never,       // Monitors with this value will cause errors</span>
<span class="line-modified">!                                   // when acquired with a safepoint check.</span>
<span class="line-modified">!     _safepoint_check_sometimes,   // Certain locks are called sometimes with and</span>
<span class="line-modified">!                                   // sometimes without safepoint checks. These</span>
                                    // locks will not produce errors when locked.
<span class="line-modified">!     _safepoint_check_always       // Causes error if locked without a safepoint</span>
<span class="line-modified">!                                   // check.</span>
    };
  
    NOT_PRODUCT(SafepointCheckRequired _safepoint_check_required;)
  
<span class="line-removed">-  protected:</span>
<span class="line-removed">-    static void ClearMonitor (Monitor * m, const char* name = NULL) ;</span>
<span class="line-removed">-    Monitor() ;</span>
<span class="line-removed">- </span>
   public:
<span class="line-modified">!   Monitor(int rank, const char *name, bool allow_vm_block = false,</span>
<span class="line-modified">!           SafepointCheckRequired safepoint_check_required = _safepoint_check_always);</span>
<span class="line-modified">!   ~Monitor();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Wait until monitor is notified (or times out).</span>
<span class="line-removed">-   // Defaults are to make safepoint checks, wait time is forever (i.e.,</span>
<span class="line-removed">-   // zero), and not a suspend-equivalent condition. Returns true if wait</span>
<span class="line-removed">-   // times out; otherwise returns false.</span>
<span class="line-removed">-   bool wait(bool no_safepoint_check = !_no_safepoint_check_flag,</span>
<span class="line-removed">-             long timeout = 0,</span>
<span class="line-removed">-             bool as_suspend_equivalent = !_as_suspend_equivalent_flag);</span>
<span class="line-removed">-   void notify();</span>
<span class="line-removed">-   void notify_all();</span>
<span class="line-removed">- </span>
  
    void lock(); // prints out warning if VM thread blocks
    void lock(Thread *thread); // overloaded with current thread
    void unlock();
    bool is_locked() const                     { return _owner != NULL; }
  
    bool try_lock(); // Like lock(), but unblocking. It returns false instead
  
    void release_for_safepoint();
  
    // Lock without safepoint check. Should ONLY be used by safepoint code and other code
    // that is guaranteed not to block while running inside the VM.
    void lock_without_safepoint_check();
<span class="line-modified">!   void lock_without_safepoint_check (Thread * Self) ;</span>
  
    // Current owner - not not MT-safe. Can only be used to guarantee that
    // the current running thread owns the lock
    Thread* owner() const         { return _owner; }
    bool owned_by_self() const;
  
<span class="line-removed">-   // Support for JVM_RawMonitorEnter &amp; JVM_RawMonitorExit. These can be called by</span>
<span class="line-removed">-   // non-Java thread. (We should really have a RawMonitor abstraction)</span>
<span class="line-removed">-   void jvm_raw_lock();</span>
<span class="line-removed">-   void jvm_raw_unlock();</span>
    const char *name() const                  { return _name; }
  
    void print_on_error(outputStream* st) const;
  
    #ifndef PRODUCT
      void print_on(outputStream* st) const;
      void print() const                      { print_on(::tty); }
<span class="line-removed">-     DEBUG_ONLY(int    rank() const          { return _rank; })</span>
<span class="line-removed">-     bool   allow_vm_block()                 { return _allow_vm_block; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     DEBUG_ONLY(Monitor *next()  const         { return _next; })</span>
<span class="line-removed">-     DEBUG_ONLY(void   set_next(Monitor *next) { _next = next; })</span>
    #endif
  
<span class="line-modified">!   void set_owner(Thread* owner) {</span>
<span class="line-modified">!   #ifndef PRODUCT</span>
<span class="line-modified">!     set_owner_implementation(owner);</span>
<span class="line-removed">-     DEBUG_ONLY(void verify_Monitor(Thread* thr);)</span>
<span class="line-removed">-   #else</span>
<span class="line-removed">-     _owner = owner;</span>
<span class="line-removed">-   #endif</span>
<span class="line-removed">-   }</span>
  
  };
  
<span class="line-modified">! class PaddedMonitor : public Monitor {</span>
<span class="line-modified">!   enum {</span>
<span class="line-removed">-     CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Monitor),</span>
<span class="line-removed">-     PADDING_LEN = CACHE_LINE_PADDING &gt; 0 ? CACHE_LINE_PADDING : 1</span>
<span class="line-removed">-   };</span>
<span class="line-removed">-   char _padding[PADDING_LEN];</span>
   public:
<span class="line-modified">!   PaddedMonitor(int rank, const char *name, bool allow_vm_block = false,</span>
<span class="line-removed">-                SafepointCheckRequired safepoint_check_required = _safepoint_check_always) :</span>
<span class="line-removed">-     Monitor(rank, name, allow_vm_block, safepoint_check_required) {};</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Normally we&#39;d expect Monitor to extend Mutex in the sense that a monitor</span>
<span class="line-removed">- // constructed from pthreads primitives might extend a mutex by adding</span>
<span class="line-removed">- // a condvar and some extra metadata.  In fact this was the case until J2SE7.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // Currently, however, the base object is a monitor.  Monitor contains all the</span>
<span class="line-removed">- // logic for wait(), notify(), etc.   Mutex extends monitor and restricts the</span>
<span class="line-removed">- // visibility of wait(), notify(), and notify_all().</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // Another viable alternative would have been to have Monitor extend Mutex and</span>
<span class="line-removed">- // implement all the normal mutex and wait()-notify() logic in Mutex base class.</span>
<span class="line-removed">- // The wait()-notify() facility would be exposed via special protected member functions</span>
<span class="line-removed">- // (e.g., _Wait() and _Notify()) in Mutex.  Monitor would extend Mutex and expose wait()</span>
<span class="line-removed">- // as a call to _Wait().  That is, the public wait() would be a wrapper for the protected</span>
<span class="line-removed">- // _Wait().</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // An even better alternative is to simply eliminate Mutex:: and use Monitor:: instead.</span>
<span class="line-removed">- // After all, monitors are sufficient for Java-level synchronization.   At one point in time</span>
<span class="line-removed">- // there may have been some benefit to having distinct mutexes and monitors, but that time</span>
<span class="line-removed">- // has past.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- </span>
<span class="line-removed">- class Mutex : public Monitor {      // degenerate Monitor</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-    Mutex(int rank, const char *name, bool allow_vm_block = false,</span>
           SafepointCheckRequired safepoint_check_required = _safepoint_check_always);
<span class="line-modified">!   // default destructor</span>
<span class="line-modified">!  private:</span>
<span class="line-modified">!    void notify ()    { ShouldNotReachHere(); }</span>
<span class="line-modified">!    void notify_all() { ShouldNotReachHere(); }</span>
<span class="line-modified">!    bool wait (bool no_safepoint_check, long timeout, bool as_suspend_equivalent) {</span>
<span class="line-modified">!      ShouldNotReachHere() ;</span>
<span class="line-modified">!      return false ;</span>
<span class="line-modified">!    }</span>
  };
  
  class PaddedMutex : public Mutex {
    enum {
      CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Mutex),
      PADDING_LEN = CACHE_LINE_PADDING &gt; 0 ? CACHE_LINE_PADDING : 1
    };
<span class="line-new-header">--- 50,164 ---</span>
    // Since memory accesses should be able to be performed pretty much anywhere
    // in the code, that requires locks required for performing accesses being
    // inherently a bit more special than even locks of the &#39;special&#39; rank.
    // NOTE: It is critical that the rank &#39;special&#39; be the lowest (earliest)
    // (except for &quot;event&quot; and &quot;access&quot;) for the deadlock detection to work correctly.
<span class="line-modified">!   // The rank native was only for use in Mutexes created by JVM_RawMonitorCreate,</span>
<span class="line-modified">!   // which being external to the VM are not subject to deadlock detection,</span>
<span class="line-added">+   // however it has now been used by other locks that don&#39;t fit into the</span>
<span class="line-added">+   // deadlock detection scheme.</span>
    // While at a safepoint no mutexes of rank safepoint are held by any thread.
    // The rank named &quot;leaf&quot; is probably historical (and should
    // be changed) -- mutexes of this rank aren&#39;t really leaf mutexes
    // at all.
    enum lock_types {
         event,
         access         = event          +   1,
         tty            = access         +   2,
<span class="line-modified">!        special        = tty            +   2,</span>
         suspend_resume = special        +   1,
<span class="line-modified">!        oopstorage     = suspend_resume +   2,</span>
<span class="line-modified">!        leaf           = oopstorage     +   2,</span>
         safepoint      = leaf           +  10,
         barrier        = safepoint      +   1,
         nonleaf        = barrier        +   1,
         max_nonleaf    = nonleaf        + 900,
         native         = max_nonleaf    +   1
    };
  
   protected:                              // Monitor-Mutex metadata
    Thread * volatile _owner;              // The owner of the lock
    os::PlatformMonitor _lock;             // Native monitor implementation
<span class="line-modified">!   char _name[MUTEX_NAME_LEN];            // Name of mutex/monitor</span>
  
    // Debugging fields for naming, deadlock detection, etc. (some only used in debug mode)
  #ifndef PRODUCT
<span class="line-modified">!   bool    _allow_vm_block;</span>
<span class="line-modified">!   int     _rank;                 // rank (to avoid/detect potential deadlocks)</span>
<span class="line-modified">!   Mutex*  _next;                 // Used by a Thread to link up owned locks</span>
<span class="line-modified">!   Thread* _last_owner;           // the last thread to own the lock</span>
<span class="line-modified">!   static bool contains(Mutex* locks, Mutex* lock);</span>
<span class="line-modified">!   static Mutex* get_least_ranked_lock(Mutex* locks);</span>
<span class="line-modified">!   Mutex* get_least_ranked_lock_besides_this(Mutex* locks);</span>
<span class="line-modified">! #endif  // ASSERT</span>
<span class="line-modified">! </span>
<span class="line-modified">!   void set_owner_implementation(Thread* owner)                        NOT_DEBUG({ _owner = owner;});</span>
<span class="line-modified">!   void check_block_state       (Thread* thread)                       NOT_DEBUG_RETURN;</span>
<span class="line-modified">!   void check_safepoint_state   (Thread* thread)                       NOT_DEBUG_RETURN;</span>
<span class="line-added">+   void check_no_safepoint_state(Thread* thread)                       NOT_DEBUG_RETURN;</span>
    void assert_owner            (Thread* expected)                     NOT_DEBUG_RETURN;
<span class="line-added">+   void no_safepoint_verifier   (Thread* thread, bool enable)          NOT_DEBUG_RETURN;</span>
  
   public:
    enum {
      _allow_vm_block_flag        = true,
      _as_suspend_equivalent_flag = true
    };
  
<span class="line-modified">!   // Locks can be acquired with or without a safepoint check. NonJavaThreads do not follow</span>
<span class="line-modified">!   // the safepoint protocol when acquiring locks.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Each lock can be acquired by only JavaThreads, only NonJavaThreads, or shared between</span>
<span class="line-modified">!   // Java and NonJavaThreads. When the lock is initialized with _safepoint_check_always,</span>
<span class="line-modified">!   // that means that whenever the lock is acquired by a JavaThread, it will verify that</span>
<span class="line-modified">!   // it is done with a safepoint check. In corollary, when the lock is initialized with</span>
<span class="line-modified">!   // _safepoint_check_never, that means that whenever the lock is acquired by a JavaThread</span>
<span class="line-modified">!   // it will verify that it is done without a safepoint check.</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+   // There are a couple of existing locks that will sometimes have a safepoint check and</span>
<span class="line-added">+   // sometimes not when acquired by a JavaThread, but these locks are set up carefully</span>
<span class="line-added">+   // to avoid deadlocks. TODO: Fix these locks and remove _safepoint_check_sometimes.</span>
<span class="line-added">+ </span>
<span class="line-added">+   // TODO: Locks that are shared between JavaThreads and NonJavaThreads</span>
<span class="line-added">+   // should never encounter a safepoint check while they are held, or else a</span>
<span class="line-added">+   // deadlock can occur. We should check this by noting which</span>
<span class="line-added">+   // locks are shared, and walk held locks during safepoint checking.</span>
<span class="line-added">+ </span>
<span class="line-added">+   enum SafepointCheckFlag {</span>
<span class="line-added">+     _safepoint_check_flag,</span>
<span class="line-added">+     _no_safepoint_check_flag</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
    enum SafepointCheckRequired {
<span class="line-modified">!     _safepoint_check_never,       // Mutexes with this value will cause errors</span>
<span class="line-modified">!                                   // when acquired by a JavaThread with a safepoint check.</span>
<span class="line-modified">!     _safepoint_check_sometimes,   // A couple of special locks are acquired by JavaThreads sometimes</span>
<span class="line-modified">!                                   // with and sometimes without safepoint checks. These</span>
                                    // locks will not produce errors when locked.
<span class="line-modified">!     _safepoint_check_always       // Mutexes with this value will cause errors</span>
<span class="line-modified">!                                   // when acquired by a JavaThread without a safepoint check.</span>
    };
  
    NOT_PRODUCT(SafepointCheckRequired _safepoint_check_required;)
  
   public:
<span class="line-modified">!   Mutex(int rank, const char *name, bool allow_vm_block = false,</span>
<span class="line-modified">!         SafepointCheckRequired safepoint_check_required = _safepoint_check_always);</span>
<span class="line-modified">!   ~Mutex();</span>
  
    void lock(); // prints out warning if VM thread blocks
    void lock(Thread *thread); // overloaded with current thread
    void unlock();
    bool is_locked() const                     { return _owner != NULL; }
  
    bool try_lock(); // Like lock(), but unblocking. It returns false instead
<span class="line-added">+  private:</span>
<span class="line-added">+   void lock_contended(Thread *thread); // contended slow-path</span>
<span class="line-added">+  public:</span>
  
    void release_for_safepoint();
  
    // Lock without safepoint check. Should ONLY be used by safepoint code and other code
    // that is guaranteed not to block while running inside the VM.
    void lock_without_safepoint_check();
<span class="line-modified">!   void lock_without_safepoint_check(Thread* self);</span>
  
    // Current owner - not not MT-safe. Can only be used to guarantee that
    // the current running thread owns the lock
    Thread* owner() const         { return _owner; }
    bool owned_by_self() const;
  
    const char *name() const                  { return _name; }
  
    void print_on_error(outputStream* st) const;
  
    #ifndef PRODUCT
      void print_on(outputStream* st) const;
      void print() const                      { print_on(::tty); }
    #endif
<span class="line-added">+   #ifdef ASSERT</span>
<span class="line-added">+     int    rank() const          { return _rank; }</span>
<span class="line-added">+     bool   allow_vm_block()      { return _allow_vm_block; }</span>
  
<span class="line-modified">!     Mutex *next()  const         { return _next; }</span>
<span class="line-modified">!     void   set_next(Mutex *next) { _next = next; }</span>
<span class="line-modified">!   #endif // ASSERT</span>
  
<span class="line-added">+   void set_owner(Thread* owner)             { set_owner_implementation(owner); }</span>
  };
  
<span class="line-modified">! class Monitor : public Mutex {</span>
<span class="line-modified">!   void assert_wait_lock_state  (Thread* self)                         NOT_DEBUG_RETURN;</span>
   public:
<span class="line-modified">!    Monitor(int rank, const char *name, bool allow_vm_block = false,</span>
           SafepointCheckRequired safepoint_check_required = _safepoint_check_always);
<span class="line-modified">!    // default destructor</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Wait until monitor is notified (or times out).</span>
<span class="line-modified">!   // Defaults are to make safepoint checks, wait time is forever (i.e.,</span>
<span class="line-modified">!   // zero), and not a suspend-equivalent condition. Returns true if wait</span>
<span class="line-modified">!   // times out; otherwise returns false.</span>
<span class="line-modified">!   bool wait(long timeout = 0,</span>
<span class="line-modified">!             bool as_suspend_equivalent = !_as_suspend_equivalent_flag);</span>
<span class="line-added">+   bool wait_without_safepoint_check(long timeout = 0);</span>
<span class="line-added">+   void notify();</span>
<span class="line-added">+   void notify_all();</span>
  };
  
<span class="line-added">+ </span>
  class PaddedMutex : public Mutex {
    enum {
      CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Mutex),
      PADDING_LEN = CACHE_LINE_PADDING &gt; 0 ? CACHE_LINE_PADDING : 1
    };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 249,6 ***</span>
<span class="line-new-header">--- 216,18 ---</span>
    PaddedMutex(int rank, const char *name, bool allow_vm_block = false,
                SafepointCheckRequired safepoint_check_required = _safepoint_check_always) :
      Mutex(rank, name, allow_vm_block, safepoint_check_required) {};
  };
  
<span class="line-added">+ class PaddedMonitor : public Monitor {</span>
<span class="line-added">+   enum {</span>
<span class="line-added">+     CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Monitor),</span>
<span class="line-added">+     PADDING_LEN = CACHE_LINE_PADDING &gt; 0 ? CACHE_LINE_PADDING : 1</span>
<span class="line-added">+   };</span>
<span class="line-added">+   char _padding[PADDING_LEN];</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   PaddedMonitor(int rank, const char *name, bool allow_vm_block = false,</span>
<span class="line-added">+                SafepointCheckRequired safepoint_check_required = _safepoint_check_always) :</span>
<span class="line-added">+     Monitor(rank, name, allow_vm_block, safepoint_check_required) {};</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  #endif // SHARE_RUNTIME_MUTEX_HPP
</pre>
<center><a href="mutex.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutexLocker.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
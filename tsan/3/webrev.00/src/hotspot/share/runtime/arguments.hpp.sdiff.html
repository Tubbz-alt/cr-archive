<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/arguments.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="atomic.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/arguments.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
305   // Note: since --patch-module is a module name/path pair, the
306   // system boot class path string no longer contains the &quot;prefix&quot;
307   // to the boot class path base piece as it did when
308   // -Xbootclasspath/p was supported.
309   static PathString *_system_boot_class_path;
310 
311   // Set if a modular java runtime image is present vs. a build with exploded modules
312   static bool _has_jimage;
313 
314   // temporary: to emit warning if the default ext dirs are not empty.
315   // remove this variable when the warning is no longer needed.
316   static char* _ext_dirs;
317 
318   // java.vendor.url.bug, bug reporting URL for fatal errors.
319   static const char* _java_vendor_url_bug;
320 
321   // sun.java.launcher, private property to provide information about
322   // java launcher
323   static const char* _sun_java_launcher;
324 
<span class="line-removed">325   // sun.java.launcher.pid, private property</span>
<span class="line-removed">326   static int    _sun_java_launcher_pid;</span>
<span class="line-removed">327 </span>
328   // was this VM created via the -XXaltjvm=&lt;path&gt; option
329   static bool   _sun_java_launcher_is_altjvm;
330 
331   // Option flags
332   static const char*  _gc_log_filename;
333   // Value of the conservative maximum heap alignment needed
334   static size_t  _conservative_max_heap_alignment;
335 
<span class="line-removed">336   static size_t  _min_heap_size;</span>
<span class="line-removed">337 </span>
338   // -Xrun arguments
339   static AgentLibraryList _libraryList;
340   static void add_init_library(const char* name, char* options);
341 
342   // -agentlib and -agentpath arguments
343   static AgentLibraryList _agentList;
344   static void add_init_agent(const char* name, char* options, bool absolute_path);
345   static void add_instrument_agent(const char* name, char* options, bool absolute_path);
346 
347   // Late-binding agents not started via arguments
348   static void add_loaded_agent(AgentLibrary *agentLib);
349 
350   // Operation modi
351   static Mode _mode;
352   static void set_mode_flags(Mode mode);
353   static bool _java_compiler;
354   static void set_java_compiler(bool arg) { _java_compiler = arg; }
355   static bool java_compiler()   { return _java_compiler; }
356 
357   // -Xdebug flag
</pre>
<hr />
<pre>
413   static jint parse_options_environment_variable(const char* name, ScopedVMInitArgs* vm_args);
414   static jint parse_java_tool_options_environment_variable(ScopedVMInitArgs* vm_args);
415   static jint parse_java_options_environment_variable(ScopedVMInitArgs* vm_args);
416   static jint parse_vm_options_file(const char* file_name, ScopedVMInitArgs* vm_args);
417   static jint parse_options_buffer(const char* name, char* buffer, const size_t buf_len, ScopedVMInitArgs* vm_args);
418   static jint parse_xss(const JavaVMOption* option, const char* tail, intx* out_ThreadStackSize);
419   static jint insert_vm_options_file(const JavaVMInitArgs* args,
420                                      const char* vm_options_file,
421                                      const int vm_options_file_pos,
422                                      ScopedVMInitArgs* vm_options_file_args,
423                                      ScopedVMInitArgs* args_out);
424   static bool args_contains_vm_options_file_arg(const JavaVMInitArgs* args);
425   static jint expand_vm_options_as_needed(const JavaVMInitArgs* args_in,
426                                           ScopedVMInitArgs* mod_args,
427                                           JavaVMInitArgs** args_out);
428   static jint match_special_option_and_act(const JavaVMInitArgs* args,
429                                            ScopedVMInitArgs* args_out);
430 
431   static bool handle_deprecated_print_gc_flags();
432 
<span class="line-modified">433   static void handle_extra_cms_flags(const char* msg);</span>
<span class="line-modified">434 </span>
<span class="line-removed">435   static jint parse_vm_init_args(const JavaVMInitArgs *java_tool_options_args,</span>
436                                  const JavaVMInitArgs *java_options_args,
437                                  const JavaVMInitArgs *cmd_line_args);
438   static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlag::Flags origin);
439   static jint finalize_vm_init_args(bool patch_mod_javabase);
440   static bool is_bad_option(const JavaVMOption* option, jboolean ignore, const char* option_type);
441 
442   static bool is_bad_option(const JavaVMOption* option, jboolean ignore) {
443     return is_bad_option(option, ignore, NULL);
444   }
445 
446   static void describe_range_error(ArgsRange errcode);
447   static ArgsRange check_memory_size(julong size, julong min_size, julong max_size);
448   static ArgsRange parse_memory_size(const char* s, julong* long_arg,
449                                      julong min_size, julong max_size = max_uintx);
450   // Parse a string for a unsigned integer.  Returns true if value
451   // is an unsigned integer greater than or equal to the minimum
452   // parameter passed and returns the value in uintx_arg.  Returns
453   // false otherwise, with uintx_arg undefined.
454   static bool parse_uintx(const char* value, uintx* uintx_arg,
455                           uintx min_size);
</pre>
<hr />
<pre>
469   static const char* removed_develop_logging_flag_name(const char* name);
470 #endif // PRODUCT
471 
472   // Returns 1 if the flag is deprecated (and not yet obsolete or expired).
473   //     In this case the &#39;version&#39; buffer is filled in with the version number when
474   //     the flag became deprecated.
475   // Returns -1 if the flag is expired or obsolete.
476   // Returns 0 otherwise.
477   static int is_deprecated_flag(const char* flag_name, JDK_Version* version);
478 
479   // Return the real name for the flag passed on the command line (either an alias name or &quot;flag_name&quot;).
480   static const char* real_flag_name(const char *flag_name);
481 
482   // Return the &quot;real&quot; name for option arg if arg is an alias, and print a warning if arg is deprecated.
483   // Return NULL if the arg has expired.
484   static const char* handle_aliases_and_deprecation(const char* arg, bool warn);
485   static bool lookup_logging_aliases(const char* arg, char* buffer);
486   static AliasedLoggingFlag catch_logging_aliases(const char* name, bool on);
487 
488   static char*  SharedArchivePath;






489 
490  public:
491   // Parses the arguments, first phase
492   static jint parse(const JavaVMInitArgs* args);
493   // Apply ergonomics
494   static jint apply_ergo();
495   // Adjusts the arguments after the OS have adjusted the arguments
496   static jint adjust_after_os();
497 
498   // Check for consistency in the selection of the garbage collector.
499   static bool check_gc_consistency();        // Check user-selected gc
500   // Check consistency or otherwise of VM argument settings
501   static bool check_vm_args_consistency();
502   // Used by os_solaris
503   static bool process_settings_file(const char* file_name, bool should_exist, jboolean ignore_unrecognized);
504 
505   static size_t conservative_max_heap_alignment() { return _conservative_max_heap_alignment; }
506   // Return the maximum size a heap with compressed oops can take
507   static size_t max_heap_for_compressed_oops();
508 
</pre>
<hr />
<pre>
528   }
529   // convenient methods to obtain / print jvm_flags and jvm_args
530   static const char* jvm_flags()           { return build_resource_string(_jvm_flags_array, _num_jvm_flags); }
531   static const char* jvm_args()            { return build_resource_string(_jvm_args_array, _num_jvm_args); }
532   static void print_jvm_flags_on(outputStream* st);
533   static void print_jvm_args_on(outputStream* st);
534 
535   // -Dkey=value flags
536   static SystemProperty*  system_properties()   { return _system_properties; }
537   static const char*    get_property(const char* key);
538 
539   // -Djava.vendor.url.bug
540   static const char* java_vendor_url_bug()  { return _java_vendor_url_bug; }
541 
542   // -Dsun.java.launcher
543   static const char* sun_java_launcher()    { return _sun_java_launcher; }
544   // Was VM created by a Java launcher?
545   static bool created_by_java_launcher();
546   // -Dsun.java.launcher.is_altjvm
547   static bool sun_java_launcher_is_altjvm();
<span class="line-removed">548   // -Dsun.java.launcher.pid</span>
<span class="line-removed">549   static int sun_java_launcher_pid()        { return _sun_java_launcher_pid; }</span>
<span class="line-removed">550 </span>
<span class="line-removed">551   // -Xms</span>
<span class="line-removed">552   static size_t min_heap_size()             { return _min_heap_size; }</span>
<span class="line-removed">553   static void  set_min_heap_size(size_t v)  { _min_heap_size = v;  }</span>
554 
555   // -Xrun
556   static AgentLibrary* libraries()          { return _libraryList.first(); }
557   static bool init_libraries_at_startup()   { return !_libraryList.is_empty(); }
558   static void convert_library_to_agent(AgentLibrary* lib)
559                                             { _libraryList.remove(lib);
560                                               _agentList.add(lib); }
561 
562   // -agentlib -agentpath
563   static AgentLibrary* agents()             { return _agentList.first(); }
564   static bool init_agents_at_startup()      { return !_agentList.is_empty(); }
565 
566   // abort, exit, vfprintf hooks
567   static abort_hook_t    abort_hook()       { return _abort_hook; }
568   static exit_hook_t     exit_hook()        { return _exit_hook; }
569   static vfprintf_hook_t vfprintf_hook()    { return _vfprintf_hook; }
570 
571   static const char* GetSharedArchivePath() { return SharedArchivePath; }
<span class="line-modified">572 </span>

573   // Java launcher properties
574   static void process_sun_java_launcher_properties(JavaVMInitArgs* args);
575 
576   // System properties
577   static void init_system_properties();
578 
579   // Update/Initialize System properties after JDK version number is known
580   static void init_version_specific_system_properties();
581 
582   // Update VM info property - called after argument parsing
583   static void update_vm_info_property(const char* vm_info) {
584     _vm_info-&gt;set_value(vm_info);
585   }
586 
587   // Property List manipulation
588   static void PropertyList_add(SystemProperty *element);
589   static void PropertyList_add(SystemProperty** plist, SystemProperty *element);
590   static void PropertyList_add(SystemProperty** plist, const char* k, const char* v, bool writeable, bool internal);
591 
592   static void PropertyList_unique_add(SystemProperty** plist, const char* k, const char* v,
</pre>
<hr />
<pre>
614     assert(get_sysclasspath() == NULL, &quot;System boot class path previously set&quot;);
615     _system_boot_class_path-&gt;set_value(value);
616     _has_jimage = has_jimage;
617   }
618   static void append_sysclasspath(const char *value) {
619     _system_boot_class_path-&gt;append_value(value);
620     _jdk_boot_class_path_append-&gt;append_value(value);
621   }
622 
623   static GrowableArray&lt;ModulePatchPath*&gt;* get_patch_mod_prefix() { return _patch_mod_prefix; }
624   static char* get_sysclasspath() { return _system_boot_class_path-&gt;value(); }
625   static char* get_jdk_boot_class_path_append() { return _jdk_boot_class_path_append-&gt;value(); }
626   static bool has_jimage() { return _has_jimage; }
627 
628   static char* get_java_home()    { return _java_home-&gt;value(); }
629   static char* get_dll_dir()      { return _sun_boot_library_path-&gt;value(); }
630   static char* get_ext_dirs()     { return _ext_dirs;  }
631   static char* get_appclasspath() { return _java_class_path-&gt;value(); }
632   static void  fix_appclasspath();
633 
<span class="line-modified">634   static char* get_default_shared_archive_path();</span>

635 
636   // Operation modi
637   static Mode mode()                        { return _mode; }
638   static bool is_interpreter_only() { return mode() == _int; }
639 
640   // preview features
641   static void set_enable_preview() { _enable_preview = true; }
642   static bool enable_preview() { return _enable_preview; }
643 
644   // Utility: copies src into buf, replacing &quot;%%&quot; with &quot;%&quot; and &quot;%p&quot; with pid.
645   static bool copy_expand_pid(const char* src, size_t srclen, char* buf, size_t buflen);
646 
647   static void check_unsupported_dumping_properties() NOT_CDS_RETURN;
648 
649   static bool check_unsupported_cds_runtime_properties() NOT_CDS_RETURN0;
650 
651   static bool atojulong(const char *s, julong* result);










652 };
653 
654 // Disable options not supported in this release, with a warning if they
655 // were explicitly requested on the command-line
656 #define UNSUPPORTED_OPTION(opt)                          \
657 do {                                                     \
658   if (opt) {                                             \
659     if (FLAG_IS_CMDLINE(opt)) {                          \
660       warning(&quot;-XX:+&quot; #opt &quot; not supported in this VM&quot;); \
661     }                                                    \
662     FLAG_SET_DEFAULT(opt, false);                        \
663   }                                                      \
664 } while(0)
665 
666 // similar to UNSUPPORTED_OPTION but sets flag to NULL
667 #define UNSUPPORTED_OPTION_NULL(opt)                     \
668 do {                                                     \
669   if (opt) {                                             \
670     if (FLAG_IS_CMDLINE(opt)) {                          \
671       warning(&quot;-XX flag &quot; #opt &quot; not supported in this VM&quot;); \
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
305   // Note: since --patch-module is a module name/path pair, the
306   // system boot class path string no longer contains the &quot;prefix&quot;
307   // to the boot class path base piece as it did when
308   // -Xbootclasspath/p was supported.
309   static PathString *_system_boot_class_path;
310 
311   // Set if a modular java runtime image is present vs. a build with exploded modules
312   static bool _has_jimage;
313 
314   // temporary: to emit warning if the default ext dirs are not empty.
315   // remove this variable when the warning is no longer needed.
316   static char* _ext_dirs;
317 
318   // java.vendor.url.bug, bug reporting URL for fatal errors.
319   static const char* _java_vendor_url_bug;
320 
321   // sun.java.launcher, private property to provide information about
322   // java launcher
323   static const char* _sun_java_launcher;
324 



325   // was this VM created via the -XXaltjvm=&lt;path&gt; option
326   static bool   _sun_java_launcher_is_altjvm;
327 
328   // Option flags
329   static const char*  _gc_log_filename;
330   // Value of the conservative maximum heap alignment needed
331   static size_t  _conservative_max_heap_alignment;
332 


333   // -Xrun arguments
334   static AgentLibraryList _libraryList;
335   static void add_init_library(const char* name, char* options);
336 
337   // -agentlib and -agentpath arguments
338   static AgentLibraryList _agentList;
339   static void add_init_agent(const char* name, char* options, bool absolute_path);
340   static void add_instrument_agent(const char* name, char* options, bool absolute_path);
341 
342   // Late-binding agents not started via arguments
343   static void add_loaded_agent(AgentLibrary *agentLib);
344 
345   // Operation modi
346   static Mode _mode;
347   static void set_mode_flags(Mode mode);
348   static bool _java_compiler;
349   static void set_java_compiler(bool arg) { _java_compiler = arg; }
350   static bool java_compiler()   { return _java_compiler; }
351 
352   // -Xdebug flag
</pre>
<hr />
<pre>
408   static jint parse_options_environment_variable(const char* name, ScopedVMInitArgs* vm_args);
409   static jint parse_java_tool_options_environment_variable(ScopedVMInitArgs* vm_args);
410   static jint parse_java_options_environment_variable(ScopedVMInitArgs* vm_args);
411   static jint parse_vm_options_file(const char* file_name, ScopedVMInitArgs* vm_args);
412   static jint parse_options_buffer(const char* name, char* buffer, const size_t buf_len, ScopedVMInitArgs* vm_args);
413   static jint parse_xss(const JavaVMOption* option, const char* tail, intx* out_ThreadStackSize);
414   static jint insert_vm_options_file(const JavaVMInitArgs* args,
415                                      const char* vm_options_file,
416                                      const int vm_options_file_pos,
417                                      ScopedVMInitArgs* vm_options_file_args,
418                                      ScopedVMInitArgs* args_out);
419   static bool args_contains_vm_options_file_arg(const JavaVMInitArgs* args);
420   static jint expand_vm_options_as_needed(const JavaVMInitArgs* args_in,
421                                           ScopedVMInitArgs* mod_args,
422                                           JavaVMInitArgs** args_out);
423   static jint match_special_option_and_act(const JavaVMInitArgs* args,
424                                            ScopedVMInitArgs* args_out);
425 
426   static bool handle_deprecated_print_gc_flags();
427 
<span class="line-modified">428   static jint parse_vm_init_args(const JavaVMInitArgs *vm_options_args,</span>
<span class="line-modified">429                                  const JavaVMInitArgs *java_tool_options_args,</span>

430                                  const JavaVMInitArgs *java_options_args,
431                                  const JavaVMInitArgs *cmd_line_args);
432   static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlag::Flags origin);
433   static jint finalize_vm_init_args(bool patch_mod_javabase);
434   static bool is_bad_option(const JavaVMOption* option, jboolean ignore, const char* option_type);
435 
436   static bool is_bad_option(const JavaVMOption* option, jboolean ignore) {
437     return is_bad_option(option, ignore, NULL);
438   }
439 
440   static void describe_range_error(ArgsRange errcode);
441   static ArgsRange check_memory_size(julong size, julong min_size, julong max_size);
442   static ArgsRange parse_memory_size(const char* s, julong* long_arg,
443                                      julong min_size, julong max_size = max_uintx);
444   // Parse a string for a unsigned integer.  Returns true if value
445   // is an unsigned integer greater than or equal to the minimum
446   // parameter passed and returns the value in uintx_arg.  Returns
447   // false otherwise, with uintx_arg undefined.
448   static bool parse_uintx(const char* value, uintx* uintx_arg,
449                           uintx min_size);
</pre>
<hr />
<pre>
463   static const char* removed_develop_logging_flag_name(const char* name);
464 #endif // PRODUCT
465 
466   // Returns 1 if the flag is deprecated (and not yet obsolete or expired).
467   //     In this case the &#39;version&#39; buffer is filled in with the version number when
468   //     the flag became deprecated.
469   // Returns -1 if the flag is expired or obsolete.
470   // Returns 0 otherwise.
471   static int is_deprecated_flag(const char* flag_name, JDK_Version* version);
472 
473   // Return the real name for the flag passed on the command line (either an alias name or &quot;flag_name&quot;).
474   static const char* real_flag_name(const char *flag_name);
475 
476   // Return the &quot;real&quot; name for option arg if arg is an alias, and print a warning if arg is deprecated.
477   // Return NULL if the arg has expired.
478   static const char* handle_aliases_and_deprecation(const char* arg, bool warn);
479   static bool lookup_logging_aliases(const char* arg, char* buffer);
480   static AliasedLoggingFlag catch_logging_aliases(const char* name, bool on);
481 
482   static char*  SharedArchivePath;
<span class="line-added">483   static char*  SharedDynamicArchivePath;</span>
<span class="line-added">484   static size_t _SharedBaseAddress; // The default value specified in globals.hpp</span>
<span class="line-added">485   static int num_archives(const char* archive_path) NOT_CDS_RETURN_(0);</span>
<span class="line-added">486   static void extract_shared_archive_paths(const char* archive_path,</span>
<span class="line-added">487                                          char** base_archive_path,</span>
<span class="line-added">488                                          char** top_archive_path) NOT_CDS_RETURN;</span>
489 
490  public:
491   // Parses the arguments, first phase
492   static jint parse(const JavaVMInitArgs* args);
493   // Apply ergonomics
494   static jint apply_ergo();
495   // Adjusts the arguments after the OS have adjusted the arguments
496   static jint adjust_after_os();
497 
498   // Check for consistency in the selection of the garbage collector.
499   static bool check_gc_consistency();        // Check user-selected gc
500   // Check consistency or otherwise of VM argument settings
501   static bool check_vm_args_consistency();
502   // Used by os_solaris
503   static bool process_settings_file(const char* file_name, bool should_exist, jboolean ignore_unrecognized);
504 
505   static size_t conservative_max_heap_alignment() { return _conservative_max_heap_alignment; }
506   // Return the maximum size a heap with compressed oops can take
507   static size_t max_heap_for_compressed_oops();
508 
</pre>
<hr />
<pre>
528   }
529   // convenient methods to obtain / print jvm_flags and jvm_args
530   static const char* jvm_flags()           { return build_resource_string(_jvm_flags_array, _num_jvm_flags); }
531   static const char* jvm_args()            { return build_resource_string(_jvm_args_array, _num_jvm_args); }
532   static void print_jvm_flags_on(outputStream* st);
533   static void print_jvm_args_on(outputStream* st);
534 
535   // -Dkey=value flags
536   static SystemProperty*  system_properties()   { return _system_properties; }
537   static const char*    get_property(const char* key);
538 
539   // -Djava.vendor.url.bug
540   static const char* java_vendor_url_bug()  { return _java_vendor_url_bug; }
541 
542   // -Dsun.java.launcher
543   static const char* sun_java_launcher()    { return _sun_java_launcher; }
544   // Was VM created by a Java launcher?
545   static bool created_by_java_launcher();
546   // -Dsun.java.launcher.is_altjvm
547   static bool sun_java_launcher_is_altjvm();






548 
549   // -Xrun
550   static AgentLibrary* libraries()          { return _libraryList.first(); }
551   static bool init_libraries_at_startup()   { return !_libraryList.is_empty(); }
552   static void convert_library_to_agent(AgentLibrary* lib)
553                                             { _libraryList.remove(lib);
554                                               _agentList.add(lib); }
555 
556   // -agentlib -agentpath
557   static AgentLibrary* agents()             { return _agentList.first(); }
558   static bool init_agents_at_startup()      { return !_agentList.is_empty(); }
559 
560   // abort, exit, vfprintf hooks
561   static abort_hook_t    abort_hook()       { return _abort_hook; }
562   static exit_hook_t     exit_hook()        { return _exit_hook; }
563   static vfprintf_hook_t vfprintf_hook()    { return _vfprintf_hook; }
564 
565   static const char* GetSharedArchivePath() { return SharedArchivePath; }
<span class="line-modified">566   static const char* GetSharedDynamicArchivePath() { return SharedDynamicArchivePath; }</span>
<span class="line-added">567   static size_t default_SharedBaseAddress() { return _SharedBaseAddress; }</span>
568   // Java launcher properties
569   static void process_sun_java_launcher_properties(JavaVMInitArgs* args);
570 
571   // System properties
572   static void init_system_properties();
573 
574   // Update/Initialize System properties after JDK version number is known
575   static void init_version_specific_system_properties();
576 
577   // Update VM info property - called after argument parsing
578   static void update_vm_info_property(const char* vm_info) {
579     _vm_info-&gt;set_value(vm_info);
580   }
581 
582   // Property List manipulation
583   static void PropertyList_add(SystemProperty *element);
584   static void PropertyList_add(SystemProperty** plist, SystemProperty *element);
585   static void PropertyList_add(SystemProperty** plist, const char* k, const char* v, bool writeable, bool internal);
586 
587   static void PropertyList_unique_add(SystemProperty** plist, const char* k, const char* v,
</pre>
<hr />
<pre>
609     assert(get_sysclasspath() == NULL, &quot;System boot class path previously set&quot;);
610     _system_boot_class_path-&gt;set_value(value);
611     _has_jimage = has_jimage;
612   }
613   static void append_sysclasspath(const char *value) {
614     _system_boot_class_path-&gt;append_value(value);
615     _jdk_boot_class_path_append-&gt;append_value(value);
616   }
617 
618   static GrowableArray&lt;ModulePatchPath*&gt;* get_patch_mod_prefix() { return _patch_mod_prefix; }
619   static char* get_sysclasspath() { return _system_boot_class_path-&gt;value(); }
620   static char* get_jdk_boot_class_path_append() { return _jdk_boot_class_path_append-&gt;value(); }
621   static bool has_jimage() { return _has_jimage; }
622 
623   static char* get_java_home()    { return _java_home-&gt;value(); }
624   static char* get_dll_dir()      { return _sun_boot_library_path-&gt;value(); }
625   static char* get_ext_dirs()     { return _ext_dirs;  }
626   static char* get_appclasspath() { return _java_class_path-&gt;value(); }
627   static void  fix_appclasspath();
628 
<span class="line-modified">629   static char* get_default_shared_archive_path() NOT_CDS_RETURN_(NULL);</span>
<span class="line-added">630   static bool  init_shared_archive_paths() NOT_CDS_RETURN_(false);</span>
631 
632   // Operation modi
633   static Mode mode()                        { return _mode; }
634   static bool is_interpreter_only() { return mode() == _int; }
635 
636   // preview features
637   static void set_enable_preview() { _enable_preview = true; }
638   static bool enable_preview() { return _enable_preview; }
639 
640   // Utility: copies src into buf, replacing &quot;%%&quot; with &quot;%&quot; and &quot;%p&quot; with pid.
641   static bool copy_expand_pid(const char* src, size_t srclen, char* buf, size_t buflen);
642 
643   static void check_unsupported_dumping_properties() NOT_CDS_RETURN;
644 
645   static bool check_unsupported_cds_runtime_properties() NOT_CDS_RETURN0;
646 
647   static bool atojulong(const char *s, julong* result);
<span class="line-added">648 </span>
<span class="line-added">649   static bool has_jfr_option() NOT_JFR_RETURN_(false);</span>
<span class="line-added">650 </span>
<span class="line-added">651   static bool is_dumping_archive() { return DumpSharedSpaces || DynamicDumpSharedSpaces; }</span>
<span class="line-added">652 </span>
<span class="line-added">653   static void assert_is_dumping_archive() {</span>
<span class="line-added">654     assert(Arguments::is_dumping_archive(), &quot;dump time only&quot;);</span>
<span class="line-added">655   }</span>
<span class="line-added">656 </span>
<span class="line-added">657   DEBUG_ONLY(static bool verify_special_jvm_flags(bool check_globals);)</span>
658 };
659 
660 // Disable options not supported in this release, with a warning if they
661 // were explicitly requested on the command-line
662 #define UNSUPPORTED_OPTION(opt)                          \
663 do {                                                     \
664   if (opt) {                                             \
665     if (FLAG_IS_CMDLINE(opt)) {                          \
666       warning(&quot;-XX:+&quot; #opt &quot; not supported in this VM&quot;); \
667     }                                                    \
668     FLAG_SET_DEFAULT(opt, false);                        \
669   }                                                      \
670 } while(0)
671 
672 // similar to UNSUPPORTED_OPTION but sets flag to NULL
673 #define UNSUPPORTED_OPTION_NULL(opt)                     \
674 do {                                                     \
675   if (opt) {                                             \
676     if (FLAG_IS_CMDLINE(opt)) {                          \
677       warning(&quot;-XX flag &quot; #opt &quot; not supported in this VM&quot;); \
</pre>
</td>
</tr>
</table>
<center><a href="arguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="atomic.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
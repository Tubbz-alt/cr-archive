<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/safepoint.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_SAFEPOINT_HPP
 26 #define SHARE_RUNTIME_SAFEPOINT_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/os.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 #include &quot;runtime/vmOperations.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 #include &quot;utilities/waitBarrier.hpp&quot;
 34 
 35 //
 36 // Safepoint synchronization
 37 ////
 38 // The VMThread uses the SafepointSynchronize::begin/end
 39 // methods to enter/exit a safepoint region. The begin method will roll
 40 // all JavaThreads forward to a safepoint.
 41 //
 42 // JavaThreads must use the ThreadSafepointState abstraction (defined in
 43 // thread.hpp) to indicate that that they are at a safepoint.
 44 //
 45 // The Mutex/Condition variable and ObjectLocker classes calls the enter/
 46 // exit safepoint methods, when a thread is blocked/restarted. Hence, all mutex exter/
 47 // exit points *must* be at a safepoint.
 48 
 49 class ThreadSafepointState;
 50 
<a name="2" id="anc2"></a><span class="line-added"> 51 class SafepointStateTracker {</span>
<span class="line-added"> 52   uint64_t _safepoint_id;</span>
<span class="line-added"> 53   bool     _at_safepoint;</span>
<span class="line-added"> 54 public:</span>
<span class="line-added"> 55   SafepointStateTracker(uint64_t safepoint_id, bool at_safepoint);</span>
<span class="line-added"> 56   bool safepoint_state_changed();</span>
<span class="line-added"> 57 };</span>
<span class="line-added"> 58 </span>
 59 //
 60 // Implements roll-forward to safepoint (safepoint synchronization)
 61 //
 62 class SafepointSynchronize : AllStatic {
 63  public:
 64   enum SynchronizeState {
 65       _not_synchronized = 0,                   // Threads not synchronized at a safepoint. Keep this value 0.
 66       _synchronizing    = 1,                   // Synchronizing in progress
 67       _synchronized     = 2                    // All Java threads are running in native, blocked in OS or stopped at safepoint.
 68                                                // VM thread and any NonJavaThread may be running.
 69   };
 70 
 71   // The enums are listed in the order of the tasks when done serially.
 72   enum SafepointCleanupTasks {
 73     SAFEPOINT_CLEANUP_DEFLATE_MONITORS,
 74     SAFEPOINT_CLEANUP_UPDATE_INLINE_CACHES,
 75     SAFEPOINT_CLEANUP_COMPILATION_POLICY,
 76     SAFEPOINT_CLEANUP_SYMBOL_TABLE_REHASH,
 77     SAFEPOINT_CLEANUP_STRING_TABLE_REHASH,
<a name="3" id="anc3"></a>
 78     SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE,
<a name="4" id="anc4"></a><span class="line-added"> 79     SAFEPOINT_CLEANUP_REQUEST_OOPSTORAGE_CLEANUP,</span>
 80     // Leave this one last.
 81     SAFEPOINT_CLEANUP_NUM_TASKS
 82   };
 83 
 84  private:
 85   friend class SafepointMechanism;
 86   friend class ThreadSafepointState;
 87   friend class HandshakeState;
<a name="5" id="anc5"></a><span class="line-added"> 88   friend class SafepointStateTracker;</span>
 89 
 90   // Threads might read this flag directly, without acquiring the Threads_lock:
 91   static volatile SynchronizeState _state;
 92   // Number of threads we are waiting for to block:
 93   static int              _waiting_to_block;
 94   // Counts the number of active critical natives during the safepoint:
 95   static int              _current_jni_active_count;
 96 
 97   // This counter is used for fast versions of jni_Get&lt;Primitive&gt;Field.
 98   // An even value means there are no ongoing safepoint operations.
 99   // The counter is incremented ONLY at the beginning and end of each
100   // safepoint.
101   static volatile uint64_t _safepoint_counter;
102 
<a name="6" id="anc6"></a><span class="line-added">103   // A change in this counter or a change in the result of</span>
<span class="line-added">104   // is_at_safepoint() are used by SafepointStateTracker::</span>
<span class="line-added">105   // safepoint_state_changed() to determine its answer.</span>
<span class="line-added">106   static uint64_t _safepoint_id;</span>
<span class="line-added">107 </span>
108   // JavaThreads that need to block for the safepoint will stop on the
109   // _wait_barrier, where they can quickly be started again.
110   static WaitBarrier* _wait_barrier;
<a name="7" id="anc7"></a>
111   static julong       _coalesced_vmop_count;     // coalesced vmop count
112 
<a name="8" id="anc8"></a>







113   // For debug long safepoint
114   static void print_safepoint_timeout();
115 
116   // Helper methods for safepoint procedure:
117   static void arm_safepoint();
118   static int synchronize_threads(jlong safepoint_limit_time, int nof_threads, int* initial_running);
119   static void disarm_safepoint();
120   static void increment_jni_active_count();
121   static void decrement_waiting_to_block();
<a name="9" id="anc9"></a><span class="line-added">122   static bool thread_not_running(ThreadSafepointState *cur_state);</span>
123 
124   // Used in safepoint_safe to do a stable load of the thread state.
125   static bool try_stable_load_state(JavaThreadState *state,
126                                     JavaThread *thread,
127                                     uint64_t safepoint_count);
128 
129   // Called when a thread voluntarily blocks
130   static void block(JavaThread *thread);
131 
132   // Called from VMThread during handshakes.
133   // If true the VMThread may safely process the handshake operation for the JavaThread.
134   static bool handshake_safe(JavaThread *thread);
135 
<a name="10" id="anc10"></a><span class="line-added">136   static uint64_t safepoint_counter()             { return _safepoint_counter; }</span>
<span class="line-added">137 </span>
138 public:
139 
140   static void init(Thread* vmthread);
141 
142   // Roll all threads forward to safepoint. Must be called by the VMThread.
143   static void begin();
144   static void end();                    // Start all suspended threads again...
145 
146   // The value for a not set safepoint id.
147   static const uint64_t InactiveSafepointCounter;
148 
149   // Query
150   static bool is_at_safepoint()                   { return _state == _synchronized; }
151   static bool is_synchronizing()                  { return _state == _synchronizing; }
<a name="11" id="anc11"></a><span class="line-modified">152 </span>
<span class="line-modified">153   static uint64_t safepoint_id() {</span>
<span class="line-added">154     return _safepoint_id;</span>
<span class="line-added">155   }</span>
<span class="line-added">156 </span>
<span class="line-added">157   static SafepointStateTracker safepoint_state_tracker() {</span>
<span class="line-added">158     return SafepointStateTracker(safepoint_id(), is_at_safepoint());</span>
<span class="line-added">159   }</span>
<span class="line-added">160 </span>
161   // Exception handling for page polling
162   static void handle_polling_page_exception(JavaThread *thread);
163 
164   static bool is_cleanup_needed();
<a name="12" id="anc12"></a><span class="line-added">165   static bool is_forced_cleanup_needed();</span>
166   static void do_cleanup_tasks();
167 
168   static void set_is_at_safepoint()             { _state = _synchronized; }
169   static void set_is_not_at_safepoint()         { _state = _not_synchronized; }
170 
171   // Assembly support
172   static address address_of_state()             { return (address)&amp;_state; }
173 
174   // Only used for making sure that no safepoint has happened in
175   // JNI_FastGetField. Therefore only the low 32-bits are needed
176   // even if this is a 64-bit counter.
177   static address safepoint_counter_addr() {
178 #ifdef VM_LITTLE_ENDIAN
179     return (address)&amp;_safepoint_counter;
180 #else /* BIG */
181     // Return pointer to the 32 LSB:
182     return (address) (((uint32_t*)(&amp;_safepoint_counter)) + 1);
183 #endif
184   }
185 };
186 
187 // Some helper assert macros for safepoint checks.
188 
189 #define assert_at_safepoint()                                           \
190   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;)
191 
192 #define assert_at_safepoint_msg(...)                                    \
193   assert(SafepointSynchronize::is_at_safepoint(), __VA_ARGS__)
194 
195 #define assert_not_at_safepoint()                                       \
196   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;)
197 
198 #define assert_not_at_safepoint_msg(...)                                \
199   assert(!SafepointSynchronize::is_at_safepoint(), __VA_ARGS__)
200 
201 // State class for a thread suspended at a safepoint
202 class ThreadSafepointState: public CHeapObj&lt;mtThread&gt; {
203  private:
204   // At polling page safepoint (NOT a poll return safepoint):
205   volatile bool                   _at_poll_safepoint;
206   JavaThread*                     _thread;
207   bool                            _safepoint_safe;
208   volatile uint64_t               _safepoint_id;
<a name="13" id="anc13"></a>
209 
210   ThreadSafepointState*           _next;
211 
212   void account_safe_thread();
213 
214  public:
215   ThreadSafepointState(JavaThread *thread);
216 
217   // Linked list support:
218   ThreadSafepointState* get_next() const { return _next; }
219   void set_next(ThreadSafepointState* value) { _next = value; }
220   ThreadSafepointState** next_ptr() { return &amp;_next; }
221 
222   // examine/restart
223   void examine_state_of_thread(uint64_t safepoint_count);
224   void restart();
225 
226   // Query
227   JavaThread*  thread() const         { return _thread; }
228   bool         is_running() const     { return !_safepoint_safe; }
229 
230   uint64_t get_safepoint_id() const;
231   void     reset_safepoint_id();
232   void     set_safepoint_id(uint64_t sid);
233 
<a name="14" id="anc14"></a>

234   // Support for safepoint timeout (debugging)
235   bool is_at_poll_safepoint()           { return _at_poll_safepoint; }
236   void set_at_poll_safepoint(bool val)  { _at_poll_safepoint = val; }
237 
238   void handle_polling_page_exception();
239 
240   // debugging
241   void print_on(outputStream* st) const;
<a name="15" id="anc15"></a>
242 
243   // Initialize
244   static void create(JavaThread *thread);
245   static void destroy(JavaThread *thread);
246 };
247 
248 class SafepointTracing : public AllStatic {
249 private:
250   // Absolute
251   static jlong _last_safepoint_begin_time_ns;
252   static jlong _last_safepoint_sync_time_ns;
253   static jlong _last_safepoint_cleanup_time_ns;
254   static jlong _last_safepoint_end_time_ns;
<a name="16" id="anc16"></a><span class="line-modified">255 </span>

256   // Relative
257   static jlong _last_app_time_ns;
258 
259   static int _nof_threads;
260   static int _nof_running;
261   static int _page_trap;
262 
263   static VM_Operation::VMOp_Type _current_type;
264   static jlong     _max_sync_time;
265   static jlong     _max_vmop_time;
266   static uint64_t  _op_count[VM_Operation::VMOp_Terminating];
267 
268   static void statistics_log();
269 
270 public:
271   static void init();
272 
273   static void begin(VM_Operation::VMOp_Type type);
274   static void synchronized(int nof_threads, int nof_running, int traps);
275   static void cleanup();
276   static void end();
277 
278   static void statistics_exit_log();
279 
280   static jlong time_since_last_safepoint_ms() {
<a name="17" id="anc17"></a><span class="line-modified">281     return nanos_to_millis(os::javaTimeNanos() - _last_safepoint_end_time_ns);</span>
282   }
283 
<a name="18" id="anc18"></a><span class="line-modified">284   static jlong end_of_last_safepoint_ms() {</span>
<span class="line-modified">285     return nanos_to_millis(_last_safepoint_end_time_ns);</span>
286   }
287 
288   static jlong start_of_safepoint() {
289     return _last_safepoint_begin_time_ns;
290   }
291 };
292 
293 #endif // SHARE_RUNTIME_SAFEPOINT_HPP
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
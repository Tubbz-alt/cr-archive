diff a/src/hotspot/share/runtime/threadSMR.inline.hpp b/src/hotspot/share/runtime/threadSMR.inline.hpp
--- a/src/hotspot/share/runtime/threadSMR.inline.hpp
+++ b/src/hotspot/share/runtime/threadSMR.inline.hpp
@@ -24,10 +24,11 @@
 
 #ifndef SHARE_RUNTIME_THREADSMR_INLINE_HPP
 #define SHARE_RUNTIME_THREADSMR_INLINE_HPP
 
 #include "runtime/atomic.hpp"
+#include "memory/iterator.hpp"
 #include "runtime/prefetch.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 
 // Devirtualize known thread closure types.
@@ -54,11 +55,11 @@
 
 // These three inlines are private to ThreadsSMRSupport, but
 // they are called by public inline update_tlh_stats() below:
 
 inline void ThreadsSMRSupport::add_tlh_times(uint add_value) {
-  Atomic::add(add_value, &_tlh_times);
+  Atomic::add(&_tlh_times, add_value);
 }
 
 inline void ThreadsSMRSupport::inc_tlh_cnt() {
   Atomic::inc(&_tlh_cnt);
 }
@@ -68,23 +69,23 @@
     uint cur_value = _tlh_time_max;
     if (new_value <= cur_value) {
       // No need to update max value so we're done.
       break;
     }
-    if (Atomic::cmpxchg(new_value, &_tlh_time_max, cur_value) == cur_value) {
+    if (Atomic::cmpxchg(&_tlh_time_max, cur_value, new_value) == cur_value) {
       // Updated max value so we're done. Otherwise try it all again.
       break;
     }
   }
 }
 
 inline ThreadsList* ThreadsSMRSupport::get_java_thread_list() {
-  return (ThreadsList*)OrderAccess::load_acquire(&_java_thread_list);
+  return (ThreadsList*)Atomic::load_acquire(&_java_thread_list);
 }
 
 inline bool ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(JavaThread *thread) {
-  MutexLockerEx ml(Threads_lock->owned_by_self() ? NULL : Threads_lock);
+  MutexLocker ml(Threads_lock->owned_by_self() ? NULL : Threads_lock);
   return is_a_protected_JavaThread(thread);
 }
 
 inline void ThreadsSMRSupport::update_tlh_stats(uint millis) {
   ThreadsSMRSupport::inc_tlh_cnt();

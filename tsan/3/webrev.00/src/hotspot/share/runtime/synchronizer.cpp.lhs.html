<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/vmSymbols.hpp&quot;
  27 #include &quot;logging/log.hpp&quot;
  28 #include &quot;logging/logStream.hpp&quot;
  29 #include &quot;jfr/jfrEvents.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;memory/metaspaceShared.hpp&quot;
  32 #include &quot;memory/padded.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified">  34 #include &quot;oops/markOop.hpp&quot;</span>

  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;runtime/atomic.hpp&quot;
  37 #include &quot;runtime/biasedLocking.hpp&quot;
  38 #include &quot;runtime/handles.inline.hpp&quot;
  39 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  40 #include &quot;runtime/mutexLocker.hpp&quot;
  41 #include &quot;runtime/objectMonitor.hpp&quot;
  42 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  43 #include &quot;runtime/osThread.hpp&quot;
  44 #include &quot;runtime/safepointVerifiers.hpp&quot;
  45 #include &quot;runtime/sharedRuntime.hpp&quot;
  46 #include &quot;runtime/stubRoutines.hpp&quot;
  47 #include &quot;runtime/synchronizer.hpp&quot;
  48 #include &quot;runtime/thread.inline.hpp&quot;
  49 #include &quot;runtime/timer.hpp&quot;
  50 #include &quot;runtime/vframe.hpp&quot;
  51 #include &quot;runtime/vmThread.hpp&quot;
  52 #include &quot;utilities/align.hpp&quot;
  53 #include &quot;utilities/dtrace.hpp&quot;
  54 #include &quot;utilities/events.hpp&quot;
  55 #include &quot;utilities/preserveException.hpp&quot;
  56 
  57 // The &quot;core&quot; versions of monitor enter and exit reside in this file.
  58 // The interpreter and compilers contain specialized transliterated
  59 // variants of the enter-exit fast-path operations.  See i486.ad fast_lock(),
  60 // for instance.  If you make changes here, make sure to modify the
  61 // interpreter, and both C1 and C2 fast-path inline locking code emission.
  62 //
  63 // -----------------------------------------------------------------------------
  64 
  65 #ifdef DTRACE_ENABLED
  66 
  67 // Only bother with this argument setup if dtrace is available
  68 // TODO-FIXME: probes should not fire when caller is _blocked.  assert() accordingly.
  69 
  70 #define DTRACE_MONITOR_PROBE_COMMON(obj, thread)                           \
  71   char* bytes = NULL;                                                      \
  72   int len = 0;                                                             \
  73   jlong jtid = SharedRuntime::get_java_tid(thread);                        \
  74   Symbol* klassname = ((oop)(obj))-&gt;klass()-&gt;name();                       \
  75   if (klassname != NULL) {                                                 \
  76     bytes = (char*)klassname-&gt;bytes();                                     \
  77     len = klassname-&gt;utf8_length();                                        \
  78   }
  79 
  80 #define DTRACE_MONITOR_WAIT_PROBE(monitor, obj, thread, millis)            \
  81   {                                                                        \
  82     if (DTraceMonitorProbes) {                                             \
  83       DTRACE_MONITOR_PROBE_COMMON(obj, thread);                            \
  84       HOTSPOT_MONITOR_WAIT(jtid,                                           \
  85                            (uintptr_t)(monitor), bytes, len, (millis));    \
  86     }                                                                      \
  87   }
  88 
  89 #define HOTSPOT_MONITOR_PROBE_notify HOTSPOT_MONITOR_NOTIFY
  90 #define HOTSPOT_MONITOR_PROBE_notifyAll HOTSPOT_MONITOR_NOTIFYALL
  91 #define HOTSPOT_MONITOR_PROBE_waited HOTSPOT_MONITOR_WAITED
  92 
  93 #define DTRACE_MONITOR_PROBE(probe, monitor, obj, thread)                  \
  94   {                                                                        \
  95     if (DTraceMonitorProbes) {                                             \
  96       DTRACE_MONITOR_PROBE_COMMON(obj, thread);                            \
  97       HOTSPOT_MONITOR_PROBE_##probe(jtid, /* probe = waited */             \
  98                                     (uintptr_t)(monitor), bytes, len);     \
  99     }                                                                      \
 100   }
 101 
 102 #else //  ndef DTRACE_ENABLED
 103 
 104 #define DTRACE_MONITOR_WAIT_PROBE(obj, thread, millis, mon)    {;}
 105 #define DTRACE_MONITOR_PROBE(probe, obj, thread, mon)          {;}
 106 
 107 #endif // ndef DTRACE_ENABLED
 108 
 109 // This exists only as a workaround of dtrace bug 6254741
 110 int dtrace_waited_probe(ObjectMonitor* monitor, Handle obj, Thread* thr) {
 111   DTRACE_MONITOR_PROBE(waited, monitor, obj(), thr);
 112   return 0;
 113 }
 114 
 115 #define NINFLATIONLOCKS 256
 116 static volatile intptr_t gInflationLocks[NINFLATIONLOCKS];
 117 
 118 // global list of blocks of monitors
<a name="3" id="anc3"></a><span class="line-modified"> 119 PaddedEnd&lt;ObjectMonitor&gt; * volatile ObjectSynchronizer::gBlockList = NULL;</span>
<span class="line-modified"> 120 // global monitor free list</span>
<span class="line-modified"> 121 ObjectMonitor * volatile ObjectSynchronizer::gFreeList  = NULL;</span>
<span class="line-modified"> 122 // global monitor in-use list, for moribund threads,</span>
<span class="line-modified"> 123 // monitors they inflated need to be scanned for deflation</span>
<span class="line-modified"> 124 ObjectMonitor * volatile ObjectSynchronizer::gOmInUseList  = NULL;</span>
<span class="line-modified"> 125 // count of entries in gOmInUseList</span>
<span class="line-modified"> 126 int ObjectSynchronizer::gOmInUseCount = 0;</span>
<span class="line-modified"> 127 </span>
<span class="line-modified"> 128 static volatile intptr_t gListLock = 0;      // protects global monitor lists</span>
<span class="line-modified"> 129 static volatile int gMonitorFreeCount  = 0;  // # on gFreeList</span>
<span class="line-modified"> 130 static volatile int gMonitorPopulation = 0;  // # Extant -- in circulation</span>















 131 
 132 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 133 
 134 
<a name="4" id="anc4"></a>












































































































































































































































 135 // =====================&gt; Quick functions
 136 
 137 // The quick_* forms are special fast-path variants used to improve
 138 // performance.  In the simplest case, a &quot;quick_*&quot; implementation could
 139 // simply return false, in which case the caller will perform the necessary
 140 // state transitions and call the slow-path form.
 141 // The fast-path is designed to handle frequently arising cases in an efficient
 142 // manner and is just a degenerate &quot;optimistic&quot; variant of the slow-path.
 143 // returns true  -- to indicate the call was satisfied.
 144 // returns false -- to indicate the call needs the services of the slow-path.
 145 // A no-loitering ordinance is in effect for code in the quick_* family
 146 // operators: safepoints or indefinite blocking (blocking that might span a
 147 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 148 // entry.
 149 //
 150 // Consider: An interesting optimization is to have the JIT recognize the
 151 // following common idiom:
 152 //   synchronized (someobj) { .... ; notify(); }
 153 // That is, we find a notify() or notifyAll() call that immediately precedes
 154 // the monitorexit operation.  In that case the JIT could fuse the operations
 155 // into a single notifyAndExit() runtime primitive.
 156 
<a name="5" id="anc5"></a><span class="line-modified"> 157 bool ObjectSynchronizer::quick_notify(oopDesc * obj, Thread * self, bool all) {</span>
 158   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 159   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 160   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 161   NoSafepointVerifier nsv;
 162   if (obj == NULL) return false;  // slow-path for invalid obj
<a name="6" id="anc6"></a><span class="line-modified"> 163   const markOop mark = obj-&gt;mark();</span>
 164 
<a name="7" id="anc7"></a><span class="line-modified"> 165   if (mark-&gt;has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
 166     // Degenerate notify
 167     // stack-locked by caller so by definition the implied waitset is empty.
 168     return true;
 169   }
 170 
<a name="8" id="anc8"></a><span class="line-modified"> 171   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 172     ObjectMonitor * const mon = mark-&gt;monitor();</span>
<span class="line-modified"> 173     assert(oopDesc::equals((oop) mon-&gt;object(), obj), &quot;invariant&quot;);</span>
 174     if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
 175 
 176     if (mon-&gt;first_waiter() != NULL) {
 177       // We have one or more waiters. Since this is an inflated monitor
 178       // that we own, we can transfer one or more threads from the waitset
 179       // to the entrylist here and now, avoiding the slow-path.
 180       if (all) {
 181         DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
 182       } else {
 183         DTRACE_MONITOR_PROBE(notify, mon, obj, self);
 184       }
<a name="9" id="anc9"></a><span class="line-modified"> 185       int tally = 0;</span>
 186       do {
 187         mon-&gt;INotify(self);
<a name="10" id="anc10"></a><span class="line-modified"> 188         ++tally;</span>
 189       } while (mon-&gt;first_waiter() != NULL &amp;&amp; all);
<a name="11" id="anc11"></a><span class="line-modified"> 190       OM_PERFDATA_OP(Notifications, inc(tally));</span>
 191     }
 192     return true;
 193   }
 194 
 195   // biased locking and any other IMS exception states take the slow-path
 196   return false;
 197 }
 198 
 199 
 200 // The LockNode emitted directly at the synchronization site would have
 201 // been too big if it were to have included support for the cases of inflated
 202 // recursive enter and exit, so they go here instead.
 203 // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
 204 // quick_enter() as our thread state remains _in_Java.
 205 
<a name="12" id="anc12"></a><span class="line-modified"> 206 bool ObjectSynchronizer::quick_enter(oop obj, Thread * Self,</span>
 207                                      BasicLock * lock) {
 208   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<a name="13" id="anc13"></a><span class="line-modified"> 209   assert(Self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-modified"> 210   assert(((JavaThread *) Self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);</span>
 211   NoSafepointVerifier nsv;
 212   if (obj == NULL) return false;       // Need to throw NPE
<a name="14" id="anc14"></a><span class="line-modified"> 213   const markOop mark = obj-&gt;mark();</span>
 214 
<a name="15" id="anc15"></a><span class="line-modified"> 215   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 216     ObjectMonitor * const m = mark-&gt;monitor();</span>
<span class="line-modified"> 217     assert(oopDesc::equals((oop) m-&gt;object(), obj), &quot;invariant&quot;);</span>
<span class="line-modified"> 218     Thread * const owner = (Thread *) m-&gt;_owner;</span>
 219 
 220     // Lock contention and Transactional Lock Elision (TLE) diagnostics
 221     // and observability
 222     // Case: light contention possibly amenable to TLE
 223     // Case: TLE inimical operations such as nested/recursive synchronization
 224 
<a name="16" id="anc16"></a><span class="line-modified"> 225     if (owner == Self) {</span>
 226       m-&gt;_recursions++;
 227       return true;
 228     }
 229 
 230     // This Java Monitor is inflated so obj&#39;s header will never be
 231     // displaced to this thread&#39;s BasicLock. Make the displaced header
 232     // non-NULL so this BasicLock is not seen as recursive nor as
 233     // being locked. We do this unconditionally so that this thread&#39;s
 234     // BasicLock cannot be mis-interpreted by any stack walkers. For
 235     // performance reasons, stack walkers generally first check for
 236     // Biased Locking in the object&#39;s header, the second check is for
 237     // stack-locking in the object&#39;s header, the third check is for
 238     // recursive stack-locking in the displaced header in the BasicLock,
 239     // and last are the inflated Java Monitor (ObjectMonitor) checks.
<a name="17" id="anc17"></a><span class="line-modified"> 240     lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span>
 241 
<a name="18" id="anc18"></a><span class="line-modified"> 242     if (owner == NULL &amp;&amp; Atomic::replace_if_null(Self, &amp;(m-&gt;_owner))) {</span>
 243       assert(m-&gt;_recursions == 0, &quot;invariant&quot;);
<a name="19" id="anc19"></a><span class="line-removed"> 244       assert(m-&gt;_owner == Self, &quot;invariant&quot;);</span>
 245       return true;
 246     }
 247   }
 248 
 249   // Note that we could inflate in quick_enter.
 250   // This is likely a useful optimization
 251   // Critically, in quick_enter() we must not:
 252   // -- perform bias revocation, or
 253   // -- block indefinitely, or
 254   // -- reach a safepoint
 255 
 256   return false;        // revert to slow-path
 257 }
 258 
 259 // -----------------------------------------------------------------------------
<a name="20" id="anc20"></a><span class="line-modified"> 260 //  Fast Monitor Enter/Exit</span>
<span class="line-modified"> 261 // This the fast monitor enter. The interpreter and compiler use</span>
<span class="line-modified"> 262 // some assembly copies of this code. Make sure update those code</span>
<span class="line-modified"> 263 // if the following function is changed. The implementation is</span>
<span class="line-modified"> 264 // extremely sensitive to race condition. Be careful.</span>
<span class="line-modified"> 265 </span>
<span class="line-removed"> 266 void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock,</span>
<span class="line-removed"> 267                                     bool attempt_rebias, TRAPS) {</span>
 268   if (UseBiasedLocking) {
 269     if (!SafepointSynchronize::is_at_safepoint()) {
<a name="21" id="anc21"></a><span class="line-modified"> 270       BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span>
<span class="line-removed"> 271       if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) {</span>
<span class="line-removed"> 272         return;</span>
<span class="line-removed"> 273       }</span>
 274     } else {
<a name="22" id="anc22"></a><span class="line-removed"> 275       assert(!attempt_rebias, &quot;can not rebias toward VM thread&quot;);</span>
 276       BiasedLocking::revoke_at_safepoint(obj);
 277     }
<a name="23" id="anc23"></a><span class="line-removed"> 278     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 279   }
 280 
<a name="24" id="anc24"></a><span class="line-modified"> 281   slow_enter(obj, lock, THREAD);</span>
























 282 }
 283 
<a name="25" id="anc25"></a><span class="line-modified"> 284 void ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) {</span>
<span class="line-modified"> 285   markOop mark = object-&gt;mark();</span>
 286   // We cannot check for Biased Locking if we are racing an inflation.
<a name="26" id="anc26"></a><span class="line-modified"> 287   assert(mark == markOopDesc::INFLATING() ||</span>
<span class="line-modified"> 288          !mark-&gt;has_bias_pattern(), &quot;should not see bias pattern here&quot;);</span>
 289 
<a name="27" id="anc27"></a><span class="line-modified"> 290   markOop dhw = lock-&gt;displaced_header();</span>
<span class="line-modified"> 291   if (dhw == NULL) {</span>
 292     // If the displaced header is NULL, then this exit matches up with
 293     // a recursive enter. No real work to do here except for diagnostics.
 294 #ifndef PRODUCT
<a name="28" id="anc28"></a><span class="line-modified"> 295     if (mark != markOopDesc::INFLATING()) {</span>
 296       // Only do diagnostics if we are not racing an inflation. Simply
 297       // exiting a recursive enter of a Java Monitor that is being
 298       // inflated is safe; see the has_monitor() comment below.
<a name="29" id="anc29"></a><span class="line-modified"> 299       assert(!mark-&gt;is_neutral(), &quot;invariant&quot;);</span>
<span class="line-modified"> 300       assert(!mark-&gt;has_locker() ||</span>
<span class="line-modified"> 301              THREAD-&gt;is_lock_owned((address)mark-&gt;locker()), &quot;invariant&quot;);</span>
<span class="line-modified"> 302       if (mark-&gt;has_monitor()) {</span>
 303         // The BasicLock&#39;s displaced_header is marked as a recursive
 304         // enter and we have an inflated Java Monitor (ObjectMonitor).
 305         // This is a special case where the Java Monitor was inflated
 306         // after this thread entered the stack-lock recursively. When a
 307         // Java Monitor is inflated, we cannot safely walk the Java
 308         // Monitor owner&#39;s stack and update the BasicLocks because a
 309         // Java Monitor can be asynchronously inflated by a thread that
 310         // does not own the Java Monitor.
<a name="30" id="anc30"></a><span class="line-modified"> 311         ObjectMonitor * m = mark-&gt;monitor();</span>
 312         assert(((oop)(m-&gt;object()))-&gt;mark() == mark, &quot;invariant&quot;);
 313         assert(m-&gt;is_entered(THREAD), &quot;invariant&quot;);
 314       }
 315     }
 316 #endif
 317     return;
 318   }
 319 
<a name="31" id="anc31"></a><span class="line-modified"> 320   if (mark == (markOop) lock) {</span>
 321     // If the object is stack-locked by the current thread, try to
 322     // swing the displaced header from the BasicLock back to the mark.
<a name="32" id="anc32"></a><span class="line-modified"> 323     assert(dhw-&gt;is_neutral(), &quot;invariant&quot;);</span>
 324     if (object-&gt;cas_set_mark(dhw, mark) == mark) {
 325       return;
 326     }
 327   }
 328 
 329   // We have to take the slow-path of possible inflation and then exit.
 330   inflate(THREAD, object, inflate_cause_vm_internal)-&gt;exit(true, THREAD);
 331 }
 332 
<a name="33" id="anc33"></a><span class="line-removed"> 333 // -----------------------------------------------------------------------------</span>
<span class="line-removed"> 334 // Interpreter/Compiler Slow Case</span>
<span class="line-removed"> 335 // This routine is used to handle interpreter/compiler slow case</span>
<span class="line-removed"> 336 // We don&#39;t need to use fast path here, because it must have been</span>
<span class="line-removed"> 337 // failed in the interpreter/compiler code.</span>
<span class="line-removed"> 338 void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {</span>
<span class="line-removed"> 339   markOop mark = obj-&gt;mark();</span>
<span class="line-removed"> 340   assert(!mark-&gt;has_bias_pattern(), &quot;should not see bias pattern here&quot;);</span>
<span class="line-removed"> 341 </span>
<span class="line-removed"> 342   if (mark-&gt;is_neutral()) {</span>
<span class="line-removed"> 343     // Anticipate successful CAS -- the ST of the displaced mark must</span>
<span class="line-removed"> 344     // be visible &lt;= the ST performed by the CAS.</span>
<span class="line-removed"> 345     lock-&gt;set_displaced_header(mark);</span>
<span class="line-removed"> 346     if (mark == obj()-&gt;cas_set_mark((markOop) lock, mark)) {</span>
<span class="line-removed"> 347       return;</span>
<span class="line-removed"> 348     }</span>
<span class="line-removed"> 349     // Fall through to inflate() ...</span>
<span class="line-removed"> 350   } else if (mark-&gt;has_locker() &amp;&amp;</span>
<span class="line-removed"> 351              THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
<span class="line-removed"> 352     assert(lock != mark-&gt;locker(), &quot;must not re-lock the same lock&quot;);</span>
<span class="line-removed"> 353     assert(lock != (BasicLock*)obj-&gt;mark(), &quot;don&#39;t relock with same BasicLock&quot;);</span>
<span class="line-removed"> 354     lock-&gt;set_displaced_header(NULL);</span>
<span class="line-removed"> 355     return;</span>
<span class="line-removed"> 356   }</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358   // The object header will never be displaced to this lock,</span>
<span class="line-removed"> 359   // so it does not matter what the value is, except that it</span>
<span class="line-removed"> 360   // must be non-zero to avoid looking like a re-entrant lock,</span>
<span class="line-removed"> 361   // and must not look locked either.</span>
<span class="line-removed"> 362   lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span>
<span class="line-removed"> 363   inflate(THREAD, obj(), inflate_cause_monitor_enter)-&gt;enter(THREAD);</span>
<span class="line-removed"> 364 }</span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366 // This routine is used to handle interpreter/compiler slow case</span>
<span class="line-removed"> 367 // We don&#39;t need to use fast path here, because it must have</span>
<span class="line-removed"> 368 // failed in the interpreter/compiler code. Simply use the heavy</span>
<span class="line-removed"> 369 // weight monitor should be ok, unless someone find otherwise.</span>
<span class="line-removed"> 370 void ObjectSynchronizer::slow_exit(oop object, BasicLock* lock, TRAPS) {</span>
<span class="line-removed"> 371   fast_exit(object, lock, THREAD);</span>
<span class="line-removed"> 372 }</span>
<span class="line-removed"> 373 </span>
 374 // -----------------------------------------------------------------------------
 375 // Class Loader  support to workaround deadlocks on the class loader lock objects
 376 // Also used by GC
 377 // complete_exit()/reenter() are used to wait on a nested lock
 378 // i.e. to give up an outer lock completely and then re-enter
 379 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 380 //  1) complete_exit lock1 - saving recursion count
 381 //  2) wait on lock2
 382 //  3) when notified on lock2, unlock lock2
 383 //  4) reenter lock1 with original recursion count
 384 //  5) lock lock2
 385 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 386 // NOTE(TSAN): We cannot instrument complete_exit/reenter in ObjectSynchronizer
 387 //             in a manner similar to wait and waitUninterruptibly, because
 388 //             (1) recursion count stored by inflated monitor is different from
 389 //             the absolute recursion count tracked by Tsan, and (2) in the
 390 //             general case, we cannot merely store Tsan&#39;s recursion count
 391 //             once: we must track it for *each invocation* of complete_exit.
 392 //             Hence, the best place to instrument for Tsan is at the call site
 393 //             for complete_exit/reenter. Luckily, there is only one call site.
<a name="34" id="anc34"></a><span class="line-modified"> 394 intptr_t ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {</span>
 395   if (UseBiasedLocking) {
<a name="35" id="anc35"></a><span class="line-modified"> 396     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 397     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 398   }
 399 
 400   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 401 
 402   return monitor-&gt;complete_exit(THREAD);
 403 }
 404 
 405 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
<a name="36" id="anc36"></a><span class="line-modified"> 406 void ObjectSynchronizer::reenter(Handle obj, intptr_t recursion, TRAPS) {</span>
 407   if (UseBiasedLocking) {
<a name="37" id="anc37"></a><span class="line-modified"> 408     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 409     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 410   }
 411 
 412   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 413 
<a name="38" id="anc38"></a><span class="line-modified"> 414   monitor-&gt;reenter(recursion, THREAD);</span>
 415 }
 416 // -----------------------------------------------------------------------------
 417 // JNI locks on java objects
 418 // NOTE: must use heavy weight monitor to handle jni monitor enter
 419 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 420   // the current locking is from JNI instead of Java code
 421   if (UseBiasedLocking) {
<a name="39" id="anc39"></a><span class="line-modified"> 422     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 423     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 424   }
 425   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 426   inflate(THREAD, obj(), inflate_cause_jni_enter)-&gt;enter(THREAD);
 427   THREAD-&gt;set_current_pending_monitor_is_from_java(true);
 428   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(THREAD, obj()));
 429 }
 430 
 431 // NOTE: must use heavy weight monitor to handle jni monitor exit
 432 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
 433   if (UseBiasedLocking) {
 434     Handle h_obj(THREAD, obj);
<a name="40" id="anc40"></a><span class="line-modified"> 435     BiasedLocking::revoke_and_rebias(h_obj, false, THREAD);</span>
 436     obj = h_obj();
 437   }
<a name="41" id="anc41"></a><span class="line-modified"> 438   assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 439 
 440   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
<a name="42" id="anc42"></a><span class="line-modified"> 441   // If this thread has locked the object, exit the monitor.  Note:  can&#39;t use</span>
<span class="line-modified"> 442   // monitor-&gt;check(CHECK); must exit even if an exception is pending.</span>
<span class="line-modified"> 443   if (monitor-&gt;check(THREAD)) {</span>

 444     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(THREAD, obj));
 445     monitor-&gt;exit(true, THREAD);
 446   }
 447 }
 448 
 449 // -----------------------------------------------------------------------------
 450 // Internal VM locks on java objects
 451 // standard constructor, allows locking failures
<a name="43" id="anc43"></a><span class="line-modified"> 452 ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool doLock) {</span>
<span class="line-modified"> 453   _dolock = doLock;</span>
 454   _thread = thread;
<a name="44" id="anc44"></a><span class="line-modified"> 455   debug_only(if (StrictSafepointChecks) _thread-&gt;check_for_valid_safepoint_state(false);)</span>
 456   _obj = obj;
 457 
 458   if (_dolock) {
<a name="45" id="anc45"></a><span class="line-modified"> 459     ObjectSynchronizer::fast_enter(_obj, &amp;_lock, false, _thread);</span>
 460     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));
 461   }
 462 }
 463 
 464 ObjectLocker::~ObjectLocker() {
 465   if (_dolock) {
 466     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));
<a name="46" id="anc46"></a><span class="line-modified"> 467     ObjectSynchronizer::fast_exit(_obj(), &amp;_lock, _thread);</span>
 468   }
 469 }
 470 
 471 
 472 // -----------------------------------------------------------------------------
 473 //  Wait/Notify/NotifyAll
 474 // NOTE: must use heavy weight monitor to handle wait()
 475 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
 476   if (UseBiasedLocking) {
<a name="47" id="anc47"></a><span class="line-modified"> 477     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 478     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 479   }
 480   if (millis &lt; 0) {
 481     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 482   }
 483   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 484 
 485   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
 486 
 487   TSAN_ONLY(int tsan_rec = 0;)
 488   TSAN_RUNTIME_ONLY(
 489     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());
 490     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);
 491   );
 492 
 493   monitor-&gt;wait(millis, true, THREAD);
 494 
 495   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));
 496 
 497   // This dummy call is in place to get around dtrace bug 6254741.  Once
 498   // that&#39;s fixed we can uncomment the following line, remove the call
 499   // and change this function back into a &quot;void&quot; func.
 500   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 501   return dtrace_waited_probe(monitor, obj, THREAD);
 502 }
 503 
<a name="48" id="anc48"></a><span class="line-modified"> 504 void ObjectSynchronizer::waitUninterruptibly(Handle obj, jlong millis, TRAPS) {</span>
 505   if (UseBiasedLocking) {
<a name="49" id="anc49"></a><span class="line-modified"> 506     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 507     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 508   }
 509   if (millis &lt; 0) {
 510     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 511   }
 512   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 513   TSAN_ONLY(int tsan_rec;)
 514   TSAN_RUNTIME_ONLY(
 515     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());
 516     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);
 517   );
 518   monitor-&gt;wait(millis, false, THREAD);
 519   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));
 520 }
 521 
 522 void ObjectSynchronizer::notify(Handle obj, TRAPS) {
 523   if (UseBiasedLocking) {
<a name="50" id="anc50"></a><span class="line-modified"> 524     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 525     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 526   }
 527 
<a name="51" id="anc51"></a><span class="line-modified"> 528   markOop mark = obj-&gt;mark();</span>
<span class="line-modified"> 529   if (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
 530     return;
 531   }
 532   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notify(THREAD);
 533 }
 534 
 535 // NOTE: see comment of notify()
 536 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
 537   if (UseBiasedLocking) {
<a name="52" id="anc52"></a><span class="line-modified"> 538     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 539     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 540   }
 541 
<a name="53" id="anc53"></a><span class="line-modified"> 542   markOop mark = obj-&gt;mark();</span>
<span class="line-modified"> 543   if (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
 544     return;
 545   }
 546   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notifyAll(THREAD);
 547 }
 548 
 549 // -----------------------------------------------------------------------------
 550 // Hash Code handling
 551 //
 552 // Performance concern:
 553 // OrderAccess::storestore() calls release() which at one time stored 0
 554 // into the global volatile OrderAccess::dummy variable. This store was
 555 // unnecessary for correctness. Many threads storing into a common location
 556 // causes considerable cache migration or &quot;sloshing&quot; on large SMP systems.
 557 // As such, I avoided using OrderAccess::storestore(). In some cases
 558 // OrderAccess::fence() -- which incurs local latency on the executing
 559 // processor -- is a better choice as it scales on SMP systems.
 560 //
 561 // See http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot for
 562 // a discussion of coherency costs. Note that all our current reference
 563 // platforms provide strong ST-ST order, so the issue is moot on IA32,
 564 // x64, and SPARC.
 565 //
 566 // As a general policy we use &quot;volatile&quot; to control compiler-based reordering
 567 // and explicit fences (barriers) to control for architectural reordering
 568 // performed by the CPU(s) or platform.
 569 
 570 struct SharedGlobals {
<a name="54" id="anc54"></a><span class="line-modified"> 571   char         _pad_prefix[DEFAULT_CACHE_LINE_SIZE];</span>
 572   // These are highly shared mostly-read variables.
 573   // To avoid false-sharing they need to be the sole occupants of a cache line.
<a name="55" id="anc55"></a><span class="line-modified"> 574   volatile int stwRandom;</span>
<span class="line-modified"> 575   volatile int stwCycle;</span>
<span class="line-modified"> 576   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int) * 2);</span>
 577   // Hot RW variable -- Sequester to avoid false-sharing
<a name="56" id="anc56"></a><span class="line-modified"> 578   volatile int hcSequence;</span>
<span class="line-modified"> 579   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int));</span>
 580 };
 581 
 582 static SharedGlobals GVars;
<a name="57" id="anc57"></a><span class="line-modified"> 583 static int MonitorScavengeThreshold = 1000000;</span>
<span class="line-removed"> 584 static volatile int ForceMonitorScavenge = 0; // Scavenge required and pending</span>
 585 
<a name="58" id="anc58"></a><span class="line-modified"> 586 static markOop ReadStableMark(oop obj) {</span>
<span class="line-modified"> 587   markOop mark = obj-&gt;mark();</span>
<span class="line-modified"> 588   if (!mark-&gt;is_being_inflated()) {</span>
 589     return mark;       // normal fast-path return
 590   }
 591 
 592   int its = 0;
 593   for (;;) {
<a name="59" id="anc59"></a><span class="line-modified"> 594     markOop mark = obj-&gt;mark();</span>
<span class="line-modified"> 595     if (!mark-&gt;is_being_inflated()) {</span>
 596       return mark;    // normal fast-path return
 597     }
 598 
 599     // The object is being inflated by some other thread.
<a name="60" id="anc60"></a><span class="line-modified"> 600     // The caller of ReadStableMark() must wait for inflation to complete.</span>
 601     // Avoid live-lock
 602     // TODO: consider calling SafepointSynchronize::do_call_back() while
 603     // spinning to see if there&#39;s a safepoint pending.  If so, immediately
 604     // yielding or blocking would be appropriate.  Avoid spinning while
 605     // there is a safepoint pending.
 606     // TODO: add inflation contention performance counters.
 607     // TODO: restrict the aggregate number of spinners.
 608 
 609     ++its;
 610     if (its &gt; 10000 || !os::is_MP()) {
 611       if (its &amp; 1) {
 612         os::naked_yield();
 613       } else {
 614         // Note that the following code attenuates the livelock problem but is not
 615         // a complete remedy.  A more complete solution would require that the inflating
 616         // thread hold the associated inflation lock.  The following code simply restricts
 617         // the number of spinners to at most one.  We&#39;ll have N-2 threads blocked
 618         // on the inflationlock, 1 thread holding the inflation lock and using
 619         // a yield/park strategy, and 1 thread in the midst of inflation.
 620         // A more refined approach would be to change the encoding of INFLATING
 621         // to allow encapsulation of a native thread pointer.  Threads waiting for
 622         // inflation to complete would use CAS to push themselves onto a singly linked
 623         // list rooted at the markword.  Once enqueued, they&#39;d loop, checking a per-thread flag
 624         // and calling park().  When inflation was complete the thread that accomplished inflation
 625         // would detach the list and set the markword to inflated with a single CAS and
 626         // then for each thread on the list, set the flag and unpark() the thread.
 627         // This is conceptually similar to muxAcquire-muxRelease, except that muxRelease
 628         // wakes at most one thread whereas we need to wake the entire list.
 629         int ix = (cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 5) &amp; (NINFLATIONLOCKS-1);
 630         int YieldThenBlock = 0;
 631         assert(ix &gt;= 0 &amp;&amp; ix &lt; NINFLATIONLOCKS, &quot;invariant&quot;);
 632         assert((NINFLATIONLOCKS &amp; (NINFLATIONLOCKS-1)) == 0, &quot;invariant&quot;);
 633         Thread::muxAcquire(gInflationLocks + ix, &quot;gInflationLock&quot;);
<a name="61" id="anc61"></a><span class="line-modified"> 634         while (obj-&gt;mark() == markOopDesc::INFLATING()) {</span>
 635           // Beware: NakedYield() is advisory and has almost no effect on some platforms
<a name="62" id="anc62"></a><span class="line-modified"> 636           // so we periodically call Self-&gt;_ParkEvent-&gt;park(1).</span>
 637           // We use a mixed spin/yield/block mechanism.
 638           if ((YieldThenBlock++) &gt;= 16) {
 639             Thread::current()-&gt;_ParkEvent-&gt;park(1);
 640           } else {
 641             os::naked_yield();
 642           }
 643         }
 644         Thread::muxRelease(gInflationLocks + ix);
 645       }
 646     } else {
 647       SpinPause();       // SMP-polite spinning
 648     }
 649   }
 650 }
 651 
 652 // hashCode() generation :
 653 //
 654 // Possibilities:
<a name="63" id="anc63"></a><span class="line-modified"> 655 // * MD5Digest of {obj,stwRandom}</span>
<span class="line-modified"> 656 // * CRC32 of {obj,stwRandom} or any linear-feedback shift register function.</span>
 657 // * A DES- or AES-style SBox[] mechanism
 658 // * One of the Phi-based schemes, such as:
 659 //   2654435761 = 2^32 * Phi (golden ratio)
<a name="64" id="anc64"></a><span class="line-modified"> 660 //   HashCodeValue = ((uintptr_t(obj) &gt;&gt; 3) * 2654435761) ^ GVars.stwRandom ;</span>
 661 // * A variation of Marsaglia&#39;s shift-xor RNG scheme.
<a name="65" id="anc65"></a><span class="line-modified"> 662 // * (obj ^ stwRandom) is appealing, but can result</span>
 663 //   in undesirable regularity in the hashCode values of adjacent objects
 664 //   (objects allocated back-to-back, in particular).  This could potentially
 665 //   result in hashtable collisions and reduced hashtable efficiency.
 666 //   There are simple ways to &quot;diffuse&quot; the middle address bits over the
 667 //   generated hashCode values:
 668 
<a name="66" id="anc66"></a><span class="line-modified"> 669 static inline intptr_t get_next_hash(Thread * Self, oop obj) {</span>
 670   intptr_t value = 0;
 671   if (hashCode == 0) {
 672     // This form uses global Park-Miller RNG.
 673     // On MP system we&#39;ll have lots of RW access to a global, so the
 674     // mechanism induces lots of coherency traffic.
 675     value = os::random();
 676   } else if (hashCode == 1) {
 677     // This variation has the property of being stable (idempotent)
 678     // between STW operations.  This can be useful in some of the 1-0
 679     // synchronization schemes.
<a name="67" id="anc67"></a><span class="line-modified"> 680     intptr_t addrBits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3;</span>
<span class="line-modified"> 681     value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom;</span>
 682   } else if (hashCode == 2) {
 683     value = 1;            // for sensitivity testing
 684   } else if (hashCode == 3) {
<a name="68" id="anc68"></a><span class="line-modified"> 685     value = ++GVars.hcSequence;</span>
 686   } else if (hashCode == 4) {
 687     value = cast_from_oop&lt;intptr_t&gt;(obj);
 688   } else {
 689     // Marsaglia&#39;s xor-shift scheme with thread-specific state
 690     // This is probably the best overall implementation -- we&#39;ll
 691     // likely make this the default in future releases.
<a name="69" id="anc69"></a><span class="line-modified"> 692     unsigned t = Self-&gt;_hashStateX;</span>
 693     t ^= (t &lt;&lt; 11);
<a name="70" id="anc70"></a><span class="line-modified"> 694     Self-&gt;_hashStateX = Self-&gt;_hashStateY;</span>
<span class="line-modified"> 695     Self-&gt;_hashStateY = Self-&gt;_hashStateZ;</span>
<span class="line-modified"> 696     Self-&gt;_hashStateZ = Self-&gt;_hashStateW;</span>
<span class="line-modified"> 697     unsigned v = Self-&gt;_hashStateW;</span>
 698     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
<a name="71" id="anc71"></a><span class="line-modified"> 699     Self-&gt;_hashStateW = v;</span>
 700     value = v;
 701   }
 702 
<a name="72" id="anc72"></a><span class="line-modified"> 703   value &amp;= markOopDesc::hash_mask;</span>
 704   if (value == 0) value = 0xBAD;
<a name="73" id="anc73"></a><span class="line-modified"> 705   assert(value != markOopDesc::no_hash, &quot;invariant&quot;);</span>
 706   return value;
 707 }
 708 
<a name="74" id="anc74"></a><span class="line-modified"> 709 intptr_t ObjectSynchronizer::FastHashCode(Thread * Self, oop obj) {</span>
 710   if (UseBiasedLocking) {
 711     // NOTE: many places throughout the JVM do not expect a safepoint
 712     // to be taken here, in particular most operations on perm gen
 713     // objects. However, we only ever bias Java instances and all of
 714     // the call sites of identity_hash that might revoke biases have
 715     // been checked to make sure they can handle a safepoint. The
 716     // added check of the bias pattern is to avoid useless calls to
 717     // thread-local storage.
<a name="75" id="anc75"></a><span class="line-modified"> 718     if (obj-&gt;mark()-&gt;has_bias_pattern()) {</span>
 719       // Handle for oop obj in case of STW safepoint
<a name="76" id="anc76"></a><span class="line-modified"> 720       Handle hobj(Self, obj);</span>
 721       // Relaxing assertion for bug 6320749.
 722       assert(Universe::verify_in_progress() ||
 723              !SafepointSynchronize::is_at_safepoint(),
 724              &quot;biases should not be seen by VM thread here&quot;);
<a name="77" id="anc77"></a><span class="line-modified"> 725       BiasedLocking::revoke_and_rebias(hobj, false, JavaThread::current());</span>
 726       obj = hobj();
<a name="78" id="anc78"></a><span class="line-modified"> 727       assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 728     }
 729   }
 730 
 731   // hashCode() is a heap mutator ...
 732   // Relaxing assertion for bug 6320749.
 733   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
 734          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 735   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
<a name="79" id="anc79"></a><span class="line-modified"> 736          Self-&gt;is_Java_thread() , &quot;invariant&quot;);</span>
 737   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
<a name="80" id="anc80"></a><span class="line-modified"> 738          ((JavaThread *)Self)-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);</span>
 739 
 740   ObjectMonitor* monitor = NULL;
<a name="81" id="anc81"></a><span class="line-modified"> 741   markOop temp, test;</span>
 742   intptr_t hash;
<a name="82" id="anc82"></a><span class="line-modified"> 743   markOop mark = ReadStableMark(obj);</span>
 744 
 745   // object should remain ineligible for biased locking
<a name="83" id="anc83"></a><span class="line-modified"> 746   assert(!mark-&gt;has_bias_pattern(), &quot;invariant&quot;);</span>
 747 
<a name="84" id="anc84"></a><span class="line-modified"> 748   if (mark-&gt;is_neutral()) {</span>
<span class="line-modified"> 749     hash = mark-&gt;hash();              // this is a normal header</span>
<span class="line-modified"> 750     if (hash != 0) {                  // if it has hash, just return it</span>
 751       return hash;
 752     }
<a name="85" id="anc85"></a><span class="line-modified"> 753     hash = get_next_hash(Self, obj);  // allocate a new hash code</span>
<span class="line-modified"> 754     temp = mark-&gt;copy_set_hash(hash); // merge the hash code into header</span>
<span class="line-modified"> 755     // use (machine word version) atomic operation to install the hash</span>
 756     test = obj-&gt;cas_set_mark(temp, mark);
<a name="86" id="anc86"></a><span class="line-modified"> 757     if (test == mark) {</span>
 758       return hash;
 759     }
<a name="87" id="anc87"></a><span class="line-modified"> 760     // If atomic operation failed, we must inflate the header</span>
<span class="line-modified"> 761     // into heavy weight monitor. We could add more code here</span>
<span class="line-modified"> 762     // for fast path, but it does not worth the complexity.</span>
<span class="line-modified"> 763   } else if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 764     monitor = mark-&gt;monitor();</span>

 765     temp = monitor-&gt;header();
<a name="88" id="anc88"></a><span class="line-modified"> 766     assert(temp-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)temp));</span>
<span class="line-modified"> 767     hash = temp-&gt;hash();</span>
<span class="line-modified"> 768     if (hash != 0) {</span>
 769       return hash;
 770     }
<a name="89" id="anc89"></a><span class="line-modified"> 771     // Skip to the following code to reduce code size</span>
<span class="line-modified"> 772   } else if (Self-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
<span class="line-modified"> 773     temp = mark-&gt;displaced_mark_helper(); // this is a lightweight monitor owned</span>
<span class="line-modified"> 774     assert(temp-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)temp));</span>
<span class="line-modified"> 775     hash = temp-&gt;hash();              // by current thread, check if the displaced</span>
<span class="line-modified"> 776     if (hash != 0) {                  // header contains hash code</span>



 777       return hash;
 778     }
 779     // WARNING:
<a name="90" id="anc90"></a><span class="line-modified"> 780     //   The displaced header is strictly immutable.</span>
<span class="line-modified"> 781     // It can NOT be changed in ANY cases. So we have</span>
<span class="line-modified"> 782     // to inflate the header into heavyweight monitor</span>
<span class="line-modified"> 783     // even the current thread owns the lock. The reason</span>
<span class="line-modified"> 784     // is the BasicLock (stack slot) will be asynchronously</span>
<span class="line-modified"> 785     // read by other threads during the inflate() function.</span>
<span class="line-modified"> 786     // Any change to stack may not propagate to other threads</span>
<span class="line-modified"> 787     // correctly.</span>
<span class="line-modified"> 788   }</span>
<span class="line-modified"> 789 </span>
<span class="line-modified"> 790   // Inflate the monitor to set hash code</span>
<span class="line-modified"> 791   monitor = inflate(Self, obj, inflate_cause_hash_code);</span>
<span class="line-removed"> 792   // Load displaced header and check it has hash code</span>
 793   mark = monitor-&gt;header();
<a name="91" id="anc91"></a><span class="line-modified"> 794   assert(mark-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)mark));</span>
<span class="line-modified"> 795   hash = mark-&gt;hash();</span>
<span class="line-modified"> 796   if (hash == 0) {</span>
<span class="line-modified"> 797     hash = get_next_hash(Self, obj);</span>
<span class="line-modified"> 798     temp = mark-&gt;copy_set_hash(hash); // merge hash code into header</span>
<span class="line-modified"> 799     assert(temp-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)temp));</span>
<span class="line-modified"> 800     test = Atomic::cmpxchg(temp, monitor-&gt;header_addr(), mark);</span>

 801     if (test != mark) {
<a name="92" id="anc92"></a><span class="line-modified"> 802       // The only update to the header in the monitor (outside GC)</span>
<span class="line-modified"> 803       // is install the hash code. If someone add new usage of</span>
<span class="line-modified"> 804       // displaced header, please update this code</span>
<span class="line-modified"> 805       hash = test-&gt;hash();</span>
<span class="line-modified"> 806       assert(test-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)test));</span>
<span class="line-modified"> 807       assert(hash != 0, &quot;Trivial unexpected object/monitor header usage.&quot;);</span>


 808     }
 809   }
<a name="93" id="anc93"></a><span class="line-modified"> 810   // We finally get the hash</span>
 811   return hash;
 812 }
 813 
 814 // Deprecated -- use FastHashCode() instead.
 815 
 816 intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) {
 817   return FastHashCode(Thread::current(), obj());
 818 }
 819 
 820 
 821 bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
 822                                                    Handle h_obj) {
 823   if (UseBiasedLocking) {
<a name="94" id="anc94"></a><span class="line-modified"> 824     BiasedLocking::revoke_and_rebias(h_obj, false, thread);</span>
<span class="line-modified"> 825     assert(!h_obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 826   }
 827 
 828   assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
 829   oop obj = h_obj();
 830 
<a name="95" id="anc95"></a><span class="line-modified"> 831   markOop mark = ReadStableMark(obj);</span>
 832 
 833   // Uncontended case, header points to stack
<a name="96" id="anc96"></a><span class="line-modified"> 834   if (mark-&gt;has_locker()) {</span>
<span class="line-modified"> 835     return thread-&gt;is_lock_owned((address)mark-&gt;locker());</span>
 836   }
 837   // Contended case, header points to ObjectMonitor (tagged pointer)
<a name="97" id="anc97"></a><span class="line-modified"> 838   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 839     ObjectMonitor* monitor = mark-&gt;monitor();</span>
 840     return monitor-&gt;is_entered(thread) != 0;
 841   }
 842   // Unlocked case, header in place
<a name="98" id="anc98"></a><span class="line-modified"> 843   assert(mark-&gt;is_neutral(), &quot;sanity check&quot;);</span>
 844   return false;
 845 }
 846 
 847 // Be aware of this method could revoke bias of the lock object.
 848 // This method queries the ownership of the lock handle specified by &#39;h_obj&#39;.
 849 // If the current thread owns the lock, it returns owner_self. If no
 850 // thread owns the lock, it returns owner_none. Otherwise, it will return
 851 // owner_other.
 852 ObjectSynchronizer::LockOwnership ObjectSynchronizer::query_lock_ownership
 853 (JavaThread *self, Handle h_obj) {
 854   // The caller must beware this method can revoke bias, and
 855   // revocation can result in a safepoint.
 856   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 857   assert(self-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);
 858 
 859   // Possible mark states: neutral, biased, stack-locked, inflated
 860 
<a name="99" id="anc99"></a><span class="line-modified"> 861   if (UseBiasedLocking &amp;&amp; h_obj()-&gt;mark()-&gt;has_bias_pattern()) {</span>
 862     // CASE: biased
<a name="100" id="anc100"></a><span class="line-modified"> 863     BiasedLocking::revoke_and_rebias(h_obj, false, self);</span>
<span class="line-modified"> 864     assert(!h_obj-&gt;mark()-&gt;has_bias_pattern(),</span>
 865            &quot;biases should be revoked by now&quot;);
 866   }
 867 
 868   assert(self == JavaThread::current(), &quot;Can only be called on current thread&quot;);
 869   oop obj = h_obj();
<a name="101" id="anc101"></a><span class="line-modified"> 870   markOop mark = ReadStableMark(obj);</span>
 871 
 872   // CASE: stack-locked.  Mark points to a BasicLock on the owner&#39;s stack.
<a name="102" id="anc102"></a><span class="line-modified"> 873   if (mark-&gt;has_locker()) {</span>
<span class="line-modified"> 874     return self-&gt;is_lock_owned((address)mark-&gt;locker()) ?</span>
 875       owner_self : owner_other;
 876   }
 877 
 878   // CASE: inflated. Mark (tagged pointer) points to an ObjectMonitor.
 879   // The Object:ObjectMonitor relationship is stable as long as we&#39;re
 880   // not at a safepoint.
<a name="103" id="anc103"></a><span class="line-modified"> 881   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 882     void * owner = mark-&gt;monitor()-&gt;_owner;</span>
 883     if (owner == NULL) return owner_none;
 884     return (owner == self ||
 885             self-&gt;is_lock_owned((address)owner)) ? owner_self : owner_other;
 886   }
 887 
 888   // CASE: neutral
<a name="104" id="anc104"></a><span class="line-modified"> 889   assert(mark-&gt;is_neutral(), &quot;sanity check&quot;);</span>
 890   return owner_none;           // it&#39;s unlocked
 891 }
 892 
 893 // FIXME: jvmti should call this
 894 JavaThread* ObjectSynchronizer::get_lock_owner(ThreadsList * t_list, Handle h_obj) {
 895   if (UseBiasedLocking) {
 896     if (SafepointSynchronize::is_at_safepoint()) {
 897       BiasedLocking::revoke_at_safepoint(h_obj);
 898     } else {
<a name="105" id="anc105"></a><span class="line-modified"> 899       BiasedLocking::revoke_and_rebias(h_obj, false, JavaThread::current());</span>
 900     }
<a name="106" id="anc106"></a><span class="line-modified"> 901     assert(!h_obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 902   }
 903 
 904   oop obj = h_obj();
 905   address owner = NULL;
 906 
<a name="107" id="anc107"></a><span class="line-modified"> 907   markOop mark = ReadStableMark(obj);</span>
 908 
 909   // Uncontended case, header points to stack
<a name="108" id="anc108"></a><span class="line-modified"> 910   if (mark-&gt;has_locker()) {</span>
<span class="line-modified"> 911     owner = (address) mark-&gt;locker();</span>
 912   }
 913 
 914   // Contended case, header points to ObjectMonitor (tagged pointer)
<a name="109" id="anc109"></a><span class="line-modified"> 915   else if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 916     ObjectMonitor* monitor = mark-&gt;monitor();</span>
 917     assert(monitor != NULL, &quot;monitor should be non-null&quot;);
 918     owner = (address) monitor-&gt;owner();
 919   }
 920 
 921   if (owner != NULL) {
 922     // owning_thread_from_monitor_owner() may also return NULL here
 923     return Threads::owning_thread_from_monitor_owner(t_list, owner);
 924   }
 925 
 926   // Unlocked case, header in place
 927   // Cannot have assertion since this object may have been
 928   // locked by another thread when reaching here.
<a name="110" id="anc110"></a><span class="line-modified"> 929   // assert(mark-&gt;is_neutral(), &quot;sanity check&quot;);</span>
 930 
 931   return NULL;
 932 }
 933 
 934 // Visitors ...
 935 
 936 void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure) {
<a name="111" id="anc111"></a><span class="line-modified"> 937   PaddedEnd&lt;ObjectMonitor&gt; * block = OrderAccess::load_acquire(&amp;gBlockList);</span>
 938   while (block != NULL) {
 939     assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
 940     for (int i = _BLOCKSIZE - 1; i &gt; 0; i--) {
 941       ObjectMonitor* mid = (ObjectMonitor *)(block + i);
 942       oop object = (oop)mid-&gt;object();
 943       if (object != NULL) {
<a name="112" id="anc112"></a>
 944         closure-&gt;do_monitor(mid);
 945       }
 946     }
<a name="113" id="anc113"></a><span class="line-modified"> 947     block = (PaddedEnd&lt;ObjectMonitor&gt; *)block-&gt;FreeNext;</span>


 948   }
 949 }
 950 
<a name="114" id="anc114"></a><span class="line-removed"> 951 // Get the next block in the block list.</span>
<span class="line-removed"> 952 static inline PaddedEnd&lt;ObjectMonitor&gt;* next(PaddedEnd&lt;ObjectMonitor&gt;* block) {</span>
<span class="line-removed"> 953   assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);</span>
<span class="line-removed"> 954   block = (PaddedEnd&lt;ObjectMonitor&gt;*) block-&gt;FreeNext;</span>
<span class="line-removed"> 955   assert(block == NULL || block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);</span>
<span class="line-removed"> 956   return block;</span>
<span class="line-removed"> 957 }</span>
<span class="line-removed"> 958 </span>
 959 static bool monitors_used_above_threshold() {
<a name="115" id="anc115"></a><span class="line-modified"> 960   if (gMonitorPopulation == 0) {</span>

 961     return false;
 962   }
<a name="116" id="anc116"></a><span class="line-modified"> 963   int monitors_used = gMonitorPopulation - gMonitorFreeCount;</span>
<span class="line-modified"> 964   int monitor_usage = (monitors_used * 100LL) / gMonitorPopulation;</span>
<span class="line-modified"> 965   return monitor_usage &gt; MonitorUsedDeflationThreshold;</span>










 966 }
 967 
 968 bool ObjectSynchronizer::is_cleanup_needed() {
<a name="117" id="anc117"></a><span class="line-modified"> 969   if (MonitorUsedDeflationThreshold &gt; 0) {</span>
<span class="line-modified"> 970     return monitors_used_above_threshold();</span>









 971   }
 972   return false;
 973 }
 974 
 975 void ObjectSynchronizer::oops_do(OopClosure* f) {
 976   // We only scan the global used list here (for moribund threads), and
 977   // the thread-local monitors in Thread::oops_do().
 978   global_used_oops_do(f);
 979 }
 980 
 981 void ObjectSynchronizer::global_used_oops_do(OopClosure* f) {
 982   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<a name="118" id="anc118"></a><span class="line-modified"> 983   list_oops_do(gOmInUseList, f);</span>
 984 }
 985 
 986 void ObjectSynchronizer::thread_local_used_oops_do(Thread* thread, OopClosure* f) {
 987   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<a name="119" id="anc119"></a><span class="line-modified"> 988   list_oops_do(thread-&gt;omInUseList, f);</span>
 989 }
 990 
 991 void ObjectSynchronizer::list_oops_do(ObjectMonitor* list, OopClosure* f) {
 992   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<a name="120" id="anc120"></a><span class="line-modified"> 993   ObjectMonitor* mid;</span>
<span class="line-modified"> 994   for (mid = list; mid != NULL; mid = mid-&gt;FreeNext) {</span>

 995     if (mid-&gt;object() != NULL) {
 996       f-&gt;do_oop((oop*)mid-&gt;object_addr());
 997     }
 998   }
 999 }
1000 
1001 
1002 // -----------------------------------------------------------------------------
1003 // ObjectMonitor Lifecycle
1004 // -----------------------
<a name="121" id="anc121"></a><span class="line-modified">1005 // Inflation unlinks monitors from the global gFreeList and</span>
<span class="line-modified">1006 // associates them with objects.  Deflation -- which occurs at</span>
<span class="line-modified">1007 // STW-time -- disassociates idle monitors from objects.  Such</span>
<span class="line-modified">1008 // scavenged monitors are returned to the gFreeList.</span>
<span class="line-removed">1009 //</span>
<span class="line-removed">1010 // The global list is protected by gListLock.  All the critical sections</span>
<span class="line-removed">1011 // are short and operate in constant-time.</span>
1012 //
1013 // ObjectMonitors reside in type-stable memory (TSM) and are immortal.
1014 //
1015 // Lifecycle:
<a name="122" id="anc122"></a><span class="line-modified">1016 // --   unassigned and on the global free list</span>
<span class="line-modified">1017 // --   unassigned and on a thread&#39;s private omFreeList</span>
1018 // --   assigned to an object.  The object is inflated and the mark refers
<a name="123" id="anc123"></a><span class="line-modified">1019 //      to the objectmonitor.</span>
1020 
1021 
1022 // Constraining monitor pool growth via MonitorBound ...
1023 //
<a name="124" id="anc124"></a>

1024 // The monitor pool is grow-only.  We scavenge at STW safepoint-time, but the
1025 // the rate of scavenging is driven primarily by GC.  As such,  we can find
1026 // an inordinate number of monitors in circulation.
1027 // To avoid that scenario we can artificially induce a STW safepoint
1028 // if the pool appears to be growing past some reasonable bound.
1029 // Generally we favor time in space-time tradeoffs, but as there&#39;s no
1030 // natural back-pressure on the # of extant monitors we need to impose some
1031 // type of limit.  Beware that if MonitorBound is set to too low a value
1032 // we could just loop. In addition, if MonitorBound is set to a low value
1033 // we&#39;ll incur more safepoints, which are harmful to performance.
1034 // See also: GuaranteedSafepointInterval
1035 //
<a name="125" id="anc125"></a><span class="line-modified">1036 // The current implementation uses asynchronous VM operations.</span>




1037 
<a name="126" id="anc126"></a><span class="line-modified">1038 static void InduceScavenge(Thread * Self, const char * Whence) {</span>
1039   // Induce STW safepoint to trim monitors
1040   // Ultimately, this results in a call to deflate_idle_monitors() in the near future.
<a name="127" id="anc127"></a><span class="line-modified">1041   // More precisely, trigger an asynchronous STW safepoint as the number</span>
1042   // of active monitors passes the specified threshold.
1043   // TODO: assert thread state is reasonable
1044 
<a name="128" id="anc128"></a><span class="line-modified">1045   if (ForceMonitorScavenge == 0 &amp;&amp; Atomic::xchg (1, &amp;ForceMonitorScavenge) == 0) {</span>
<span class="line-modified">1046     // Induce a &#39;null&#39; safepoint to scavenge monitors</span>
<span class="line-removed">1047     // Must VM_Operation instance be heap allocated as the op will be enqueue and posted</span>
<span class="line-removed">1048     // to the VMthread and have a lifespan longer than that of this activation record.</span>
<span class="line-removed">1049     // The VMThread will delete the op when completed.</span>
<span class="line-removed">1050     VMThread::execute(new VM_ScavengeMonitors());</span>
1051   }
1052 }
1053 
<a name="129" id="anc129"></a><span class="line-modified">1054 ObjectMonitor* ObjectSynchronizer::omAlloc(Thread * Self) {</span>
1055   // A large MAXPRIVATE value reduces both list lock contention
1056   // and list coherency traffic, but also tends to increase the
<a name="130" id="anc130"></a><span class="line-modified">1057   // number of objectMonitors in circulation as well as the STW</span>
1058   // scavenge costs.  As usual, we lean toward time in space-time
1059   // tradeoffs.
1060   const int MAXPRIVATE = 1024;
<a name="131" id="anc131"></a>


1061   for (;;) {
<a name="132" id="anc132"></a><span class="line-modified">1062     ObjectMonitor * m;</span>
1063 
<a name="133" id="anc133"></a><span class="line-modified">1064     // 1: try to allocate from the thread&#39;s local omFreeList.</span>
1065     // Threads will attempt to allocate first from their local list, then
<a name="134" id="anc134"></a><span class="line-modified">1066     // from the global list, and only after those attempts fail will the thread</span>
<span class="line-modified">1067     // attempt to instantiate new monitors.   Thread-local free lists take</span>
<span class="line-modified">1068     // heat off the gListLock and improve allocation latency, as well as reducing</span>
<span class="line-modified">1069     // coherency traffic on the shared global list.</span>
<span class="line-modified">1070     m = Self-&gt;omFreeList;</span>
1071     if (m != NULL) {
<a name="135" id="anc135"></a><span class="line-removed">1072       Self-&gt;omFreeList = m-&gt;FreeNext;</span>
<span class="line-removed">1073       Self-&gt;omFreeCount--;</span>
1074       guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<a name="136" id="anc136"></a><span class="line-modified">1075       m-&gt;FreeNext = Self-&gt;omInUseList;</span>
<span class="line-removed">1076       Self-&gt;omInUseList = m;</span>
<span class="line-removed">1077       Self-&gt;omInUseCount++;</span>
1078       return m;
1079     }
1080 
<a name="137" id="anc137"></a><span class="line-modified">1081     // 2: try to allocate from the global gFreeList</span>
<span class="line-removed">1082     // CONSIDER: use muxTry() instead of muxAcquire().</span>
<span class="line-removed">1083     // If the muxTry() fails then drop immediately into case 3.</span>
1084     // If we&#39;re using thread-local free lists then try
1085     // to reprovision the caller&#39;s free list.
<a name="138" id="anc138"></a><span class="line-modified">1086     if (gFreeList != NULL) {</span>
<span class="line-modified">1087       // Reprovision the thread&#39;s omFreeList.</span>
1088       // Use bulk transfers to reduce the allocation rate and heat
1089       // on various locks.
<a name="139" id="anc139"></a><span class="line-modified">1090       Thread::muxAcquire(&amp;gListLock, &quot;omAlloc(1)&quot;);</span>
<span class="line-modified">1091       for (int i = Self-&gt;omFreeProvision; --i &gt;= 0 &amp;&amp; gFreeList != NULL;) {</span>
<span class="line-modified">1092         gMonitorFreeCount--;</span>
<span class="line-modified">1093         ObjectMonitor * take = gFreeList;</span>
<span class="line-modified">1094         gFreeList = take-&gt;FreeNext;</span>
1095         guarantee(take-&gt;object() == NULL, &quot;invariant&quot;);
<a name="140" id="anc140"></a><span class="line-removed">1096         guarantee(!take-&gt;is_busy(), &quot;invariant&quot;);</span>
1097         take-&gt;Recycle();
<a name="141" id="anc141"></a><span class="line-modified">1098         omRelease(Self, take, false);</span>
1099       }
<a name="142" id="anc142"></a><span class="line-modified">1100       Thread::muxRelease(&amp;gListLock);</span>
<span class="line-modified">1101       Self-&gt;omFreeProvision += 1 + (Self-&gt;omFreeProvision/2);</span>
<span class="line-removed">1102       if (Self-&gt;omFreeProvision &gt; MAXPRIVATE) Self-&gt;omFreeProvision = MAXPRIVATE;</span>
1103 
<a name="143" id="anc143"></a><span class="line-modified">1104       const int mx = MonitorBound;</span>
<span class="line-modified">1105       if (mx &gt; 0 &amp;&amp; (gMonitorPopulation-gMonitorFreeCount) &gt; mx) {</span>
<span class="line-modified">1106         // We can&#39;t safely induce a STW safepoint from omAlloc() as our thread</span>

1107         // state may not be appropriate for such activities and callers may hold
1108         // naked oops, so instead we defer the action.
<a name="144" id="anc144"></a><span class="line-modified">1109         InduceScavenge(Self, &quot;omAlloc&quot;);</span>
1110       }
1111       continue;
1112     }
1113 
1114     // 3: allocate a block of new ObjectMonitors
1115     // Both the local and global free lists are empty -- resort to malloc().
<a name="145" id="anc145"></a><span class="line-modified">1116     // In the current implementation objectMonitors are TSM - immortal.</span>
1117     // Ideally, we&#39;d write &quot;new ObjectMonitor[_BLOCKSIZE], but we want
1118     // each ObjectMonitor to start at the beginning of a cache line,
1119     // so we use align_up().
1120     // A better solution would be to use C++ placement-new.
1121     // BEWARE: As it stands currently, we don&#39;t run the ctors!
1122     assert(_BLOCKSIZE &gt; 1, &quot;invariant&quot;);
<a name="146" id="anc146"></a><span class="line-modified">1123     size_t neededsize = sizeof(PaddedEnd&lt;ObjectMonitor&gt;) * _BLOCKSIZE;</span>
<span class="line-modified">1124     PaddedEnd&lt;ObjectMonitor&gt; * temp;</span>
<span class="line-modified">1125     size_t aligned_size = neededsize + (DEFAULT_CACHE_LINE_SIZE - 1);</span>
<span class="line-modified">1126     void* real_malloc_addr = (void *)NEW_C_HEAP_ARRAY(char, aligned_size,</span>
<span class="line-modified">1127                                                       mtInternal);</span>
<span class="line-removed">1128     temp = (PaddedEnd&lt;ObjectMonitor&gt; *)</span>
<span class="line-removed">1129              align_up(real_malloc_addr, DEFAULT_CACHE_LINE_SIZE);</span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131     // NOTE: (almost) no way to recover if allocation failed.</span>
<span class="line-removed">1132     // We might be able to induce a STW safepoint and scavenge enough</span>
<span class="line-removed">1133     // objectMonitors to permit progress.</span>
<span class="line-removed">1134     if (temp == NULL) {</span>
<span class="line-removed">1135       vm_exit_out_of_memory(neededsize, OOM_MALLOC_ERROR,</span>
<span class="line-removed">1136                             &quot;Allocate ObjectMonitors&quot;);</span>
<span class="line-removed">1137     }</span>
1138     (void)memset((void *) temp, 0, neededsize);
1139 
1140     // Format the block.
1141     // initialize the linked list, each monitor points to its next
1142     // forming the single linked free list, the very first monitor
1143     // will points to next block, which forms the block list.
<a name="147" id="anc147"></a><span class="line-modified">1144     // The trick of using the 1st element in the block as gBlockList</span>
1145     // linkage should be reconsidered.  A better implementation would
1146     // look like: class Block { Block * next; int N; ObjectMonitor Body [N] ; }
1147 
1148     for (int i = 1; i &lt; _BLOCKSIZE; i++) {
<a name="148" id="anc148"></a><span class="line-modified">1149       temp[i].FreeNext = (ObjectMonitor *)&amp;temp[i+1];</span>
1150     }
1151 
1152     // terminate the last monitor as the end of list
<a name="149" id="anc149"></a><span class="line-modified">1153     temp[_BLOCKSIZE - 1].FreeNext = NULL;</span>
1154 
1155     // Element [0] is reserved for global list linkage
1156     temp[0].set_object(CHAINMARKER);
1157 
1158     // Consider carving out this thread&#39;s current request from the
1159     // block in hand.  This avoids some lock traffic and redundant
1160     // list activity.
1161 
<a name="150" id="anc150"></a><span class="line-modified">1162     // Acquire the gListLock to manipulate gBlockList and gFreeList.</span>
<span class="line-removed">1163     // An Oyama-Taura-Yonezawa scheme might be more efficient.</span>
<span class="line-removed">1164     Thread::muxAcquire(&amp;gListLock, &quot;omAlloc(2)&quot;);</span>
<span class="line-removed">1165     gMonitorPopulation += _BLOCKSIZE-1;</span>
<span class="line-removed">1166     gMonitorFreeCount += _BLOCKSIZE-1;</span>
<span class="line-removed">1167 </span>
<span class="line-removed">1168     // Add the new block to the list of extant blocks (gBlockList).</span>
<span class="line-removed">1169     // The very first objectMonitor in a block is reserved and dedicated.</span>
<span class="line-removed">1170     // It serves as blocklist &quot;next&quot; linkage.</span>
<span class="line-removed">1171     temp[0].FreeNext = gBlockList;</span>
<span class="line-removed">1172     // There are lock-free uses of gBlockList so make sure that</span>
<span class="line-removed">1173     // the previous stores happen before we update gBlockList.</span>
<span class="line-removed">1174     OrderAccess::release_store(&amp;gBlockList, temp);</span>
<span class="line-removed">1175 </span>
<span class="line-removed">1176     // Add the new string of objectMonitors to the global free list</span>
<span class="line-removed">1177     temp[_BLOCKSIZE - 1].FreeNext = gFreeList;</span>
<span class="line-removed">1178     gFreeList = temp + 1;</span>
<span class="line-removed">1179     Thread::muxRelease(&amp;gListLock);</span>
1180   }
1181 }
1182 
<a name="151" id="anc151"></a><span class="line-modified">1183 // Place &quot;m&quot; on the caller&#39;s private per-thread omFreeList.</span>
1184 // In practice there&#39;s no need to clamp or limit the number of
<a name="152" id="anc152"></a><span class="line-modified">1185 // monitors on a thread&#39;s omFreeList as the only time we&#39;ll call</span>
<span class="line-modified">1186 // omRelease is to return a monitor to the free list after a CAS</span>
<span class="line-modified">1187 // attempt failed.  This doesn&#39;t allow unbounded #s of monitors to</span>
1188 // accumulate on a thread&#39;s free list.
1189 //
1190 // Key constraint: all ObjectMonitors on a thread&#39;s free list and the global
1191 // free list must have their object field set to null. This prevents the
<a name="153" id="anc153"></a><span class="line-modified">1192 // scavenger -- deflate_monitor_list() -- from reclaiming them.</span>

1193 
<a name="154" id="anc154"></a><span class="line-modified">1194 void ObjectSynchronizer::omRelease(Thread * Self, ObjectMonitor * m,</span>
<span class="line-modified">1195                                    bool fromPerThreadAlloc) {</span>
<span class="line-modified">1196   guarantee(m-&gt;header() == NULL, &quot;invariant&quot;);</span>
1197   guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<a name="155" id="anc155"></a><span class="line-modified">1198   guarantee(((m-&gt;is_busy()|m-&gt;_recursions) == 0), &quot;freeing in-use monitor&quot;);</span>
<span class="line-modified">1199   // Remove from omInUseList</span>
<span class="line-modified">1200   if (fromPerThreadAlloc) {</span>
<span class="line-modified">1201     ObjectMonitor* cur_mid_in_use = NULL;</span>
<span class="line-modified">1202     bool extracted = false;</span>
<span class="line-modified">1203     for (ObjectMonitor* mid = Self-&gt;omInUseList; mid != NULL; cur_mid_in_use = mid, mid = mid-&gt;FreeNext) {</span>
<span class="line-modified">1204       if (m == mid) {</span>
<span class="line-modified">1205         // extract from per-thread in-use list</span>
<span class="line-modified">1206         if (mid == Self-&gt;omInUseList) {</span>
<span class="line-modified">1207           Self-&gt;omInUseList = mid-&gt;FreeNext;</span>
<span class="line-modified">1208         } else if (cur_mid_in_use != NULL) {</span>
<span class="line-modified">1209           cur_mid_in_use-&gt;FreeNext = mid-&gt;FreeNext; // maintain the current thread in-use list</span>

















































1210         }
<a name="156" id="anc156"></a><span class="line-removed">1211         extracted = true;</span>
<span class="line-removed">1212         Self-&gt;omInUseCount--;</span>
<span class="line-removed">1213         break;</span>
1214       }
1215     }
<a name="157" id="anc157"></a><span class="line-modified">1216     assert(extracted, &quot;Should have extracted from in-use list&quot;);</span>













1217   }
1218 
<a name="158" id="anc158"></a><span class="line-modified">1219   // FreeNext is used for both omInUseList and omFreeList, so clear old before setting new</span>
<span class="line-removed">1220   m-&gt;FreeNext = Self-&gt;omFreeList;</span>
<span class="line-removed">1221   Self-&gt;omFreeList = m;</span>
<span class="line-removed">1222   Self-&gt;omFreeCount++;</span>
1223 }
1224 
<a name="159" id="anc159"></a><span class="line-modified">1225 // Return the monitors of a moribund thread&#39;s local free list to</span>
<span class="line-modified">1226 // the global free list.  Typically a thread calls omFlush() when</span>
<span class="line-modified">1227 // it&#39;s dying.  We could also consider having the VM thread steal</span>
<span class="line-removed">1228 // monitors from threads that have not run java code over a few</span>
<span class="line-removed">1229 // consecutive STW safepoints.  Relatedly, we might decay</span>
<span class="line-removed">1230 // omFreeProvision at STW safepoints.</span>
<span class="line-removed">1231 //</span>
<span class="line-removed">1232 // Also return the monitors of a moribund thread&#39;s omInUseList to</span>
<span class="line-removed">1233 // a global gOmInUseList under the global list lock so these</span>
<span class="line-removed">1234 // will continue to be scanned.</span>
1235 //
<a name="160" id="anc160"></a><span class="line-modified">1236 // We currently call omFlush() from Threads::remove() _before the thread</span>
<span class="line-modified">1237 // has been excised from the thread list and is no longer a mutator.</span>
<span class="line-modified">1238 // This means that omFlush() cannot run concurrently with a safepoint and</span>
<span class="line-modified">1239 // interleave with the deflate_idle_monitors scavenge operator. In particular,</span>
<span class="line-modified">1240 // this ensures that the thread&#39;s monitors are scanned by a GC safepoint,</span>
<span class="line-modified">1241 // either via Thread::oops_do() (if safepoint happens before omFlush()) or via</span>
<span class="line-modified">1242 // ObjectSynchronizer::oops_do() (if it happens after omFlush() and the thread&#39;s</span>
<span class="line-modified">1243 // monitors have been transferred to the global in-use list).</span>
<span class="line-modified">1244 </span>
<span class="line-modified">1245 void ObjectSynchronizer::omFlush(Thread * Self) {</span>
<span class="line-modified">1246   ObjectMonitor * list = Self-&gt;omFreeList;  // Null-terminated SLL</span>
<span class="line-modified">1247   ObjectMonitor * tail = NULL;</span>
<span class="line-modified">1248   int tally = 0;</span>
<span class="line-modified">1249   if (list != NULL) {</span>
<span class="line-modified">1250     ObjectMonitor * s;</span>
<span class="line-modified">1251     // The thread is going away, the per-thread free monitors</span>
<span class="line-modified">1252     // are freed via set_owner(NULL)</span>
<span class="line-modified">1253     // Link them to tail, which will be linked into the global free list</span>
<span class="line-modified">1254     // gFreeList below, under the gListLock</span>
<span class="line-modified">1255     for (s = list; s != NULL; s = s-&gt;FreeNext) {</span>
<span class="line-modified">1256       tally++;</span>
<span class="line-modified">1257       tail = s;</span>
<span class="line-modified">1258       guarantee(s-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1259       guarantee(!s-&gt;is_busy(), &quot;invariant&quot;);</span>
<span class="line-modified">1260       s-&gt;set_owner(NULL);   // redundant but good hygiene</span>

















1261     }
<a name="161" id="anc161"></a><span class="line-modified">1262     guarantee(tail != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1263     assert(Self-&gt;omFreeCount == tally, &quot;free-count off&quot;);</span>
<span class="line-modified">1264     Self-&gt;omFreeList = NULL;</span>
<span class="line-modified">1265     Self-&gt;omFreeCount = 0;</span>
<span class="line-modified">1266   }</span>
<span class="line-modified">1267 </span>
<span class="line-modified">1268   ObjectMonitor * inUseList = Self-&gt;omInUseList;</span>
<span class="line-modified">1269   ObjectMonitor * inUseTail = NULL;</span>
<span class="line-modified">1270   int inUseTally = 0;</span>
<span class="line-modified">1271   if (inUseList != NULL) {</span>
<span class="line-modified">1272     ObjectMonitor *cur_om;</span>
<span class="line-modified">1273     // The thread is going away, however the omInUseList inflated</span>
<span class="line-modified">1274     // monitors may still be in-use by other threads.</span>
<span class="line-modified">1275     // Link them to inUseTail, which will be linked into the global in-use list</span>
<span class="line-modified">1276     // gOmInUseList below, under the gListLock</span>
<span class="line-modified">1277     for (cur_om = inUseList; cur_om != NULL; cur_om = cur_om-&gt;FreeNext) {</span>
<span class="line-modified">1278       inUseTail = cur_om;</span>
<span class="line-modified">1279       inUseTally++;</span>






















1280     }
<a name="162" id="anc162"></a><span class="line-modified">1281     guarantee(inUseTail != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1282     assert(Self-&gt;omInUseCount == inUseTally, &quot;in-use count off&quot;);</span>
<span class="line-modified">1283     Self-&gt;omInUseList = NULL;</span>
<span class="line-modified">1284     Self-&gt;omInUseCount = 0;</span>



1285   }
1286 
<a name="163" id="anc163"></a><span class="line-modified">1287   Thread::muxAcquire(&amp;gListLock, &quot;omFlush&quot;);</span>
<span class="line-modified">1288   if (tail != NULL) {</span>
<span class="line-removed">1289     tail-&gt;FreeNext = gFreeList;</span>
<span class="line-removed">1290     gFreeList = list;</span>
<span class="line-removed">1291     gMonitorFreeCount += tally;</span>
1292   }
1293 
<a name="164" id="anc164"></a><span class="line-modified">1294   if (inUseTail != NULL) {</span>
<span class="line-modified">1295     inUseTail-&gt;FreeNext = gOmInUseList;</span>
<span class="line-removed">1296     gOmInUseList = inUseList;</span>
<span class="line-removed">1297     gOmInUseCount += inUseTally;</span>
1298   }
1299 
<a name="165" id="anc165"></a><span class="line-modified">1300   Thread::muxRelease(&amp;gListLock);</span>













1301 }
1302 
1303 static void post_monitor_inflate_event(EventJavaMonitorInflate* event,
1304                                        const oop obj,
1305                                        ObjectSynchronizer::InflateCause cause) {
1306   assert(event != NULL, &quot;invariant&quot;);
1307   assert(event-&gt;should_commit(), &quot;invariant&quot;);
1308   event-&gt;set_monitorClass(obj-&gt;klass());
1309   event-&gt;set_address((uintptr_t)(void*)obj);
1310   event-&gt;set_cause((u1)cause);
1311   event-&gt;commit();
1312 }
1313 
1314 // Fast path code shared by multiple functions
1315 void ObjectSynchronizer::inflate_helper(oop obj) {
<a name="166" id="anc166"></a><span class="line-modified">1316   markOop mark = obj-&gt;mark();</span>
<span class="line-modified">1317   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">1318     assert(ObjectSynchronizer::verify_objmon_isinpool(mark-&gt;monitor()), &quot;monitor is invalid&quot;);</span>
<span class="line-modified">1319     assert(mark-&gt;monitor()-&gt;header()-&gt;is_neutral(), &quot;monitor must record a good object header&quot;);</span>
1320     return;
1321   }
1322   inflate(Thread::current(), obj, inflate_cause_vm_internal);
1323 }
1324 
<a name="167" id="anc167"></a><span class="line-modified">1325 ObjectMonitor* ObjectSynchronizer::inflate(Thread * Self,</span>
<span class="line-modified">1326                                            oop object,</span>
<span class="line-removed">1327                                            const InflateCause cause) {</span>
1328   // Inflate mutates the heap ...
1329   // Relaxing assertion for bug 6320749.
1330   assert(Universe::verify_in_progress() ||
1331          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1332 
1333   EventJavaMonitorInflate event;
1334 
1335   for (;;) {
<a name="168" id="anc168"></a><span class="line-modified">1336     const markOop mark = object-&gt;mark();</span>
<span class="line-modified">1337     assert(!mark-&gt;has_bias_pattern(), &quot;invariant&quot;);</span>
1338 
1339     // The mark can be in one of the following states:
1340     // *  Inflated     - just return
1341     // *  Stack-locked - coerce it to inflated
1342     // *  INFLATING    - busy wait for conversion to complete
1343     // *  Neutral      - aggressively inflate the object.
1344     // *  BIASED       - Illegal.  We should never see this
1345 
1346     // CASE: inflated
<a name="169" id="anc169"></a><span class="line-modified">1347     if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">1348       ObjectMonitor * inf = mark-&gt;monitor();</span>
<span class="line-modified">1349       markOop dmw = inf-&gt;header();</span>
<span class="line-modified">1350       assert(dmw-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)dmw));</span>
<span class="line-modified">1351       assert(oopDesc::equals((oop) inf-&gt;object(), object), &quot;invariant&quot;);</span>
1352       assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
1353       return inf;
1354     }
1355 
1356     // CASE: inflation in progress - inflating over a stack-lock.
1357     // Some other thread is converting from stack-locked to inflated.
1358     // Only that thread can complete inflation -- other threads must wait.
1359     // The INFLATING value is transient.
1360     // Currently, we spin/yield/park and poll the markword, waiting for inflation to finish.
1361     // We could always eliminate polling by parking the thread on some auxiliary list.
<a name="170" id="anc170"></a><span class="line-modified">1362     if (mark == markOopDesc::INFLATING()) {</span>
<span class="line-modified">1363       ReadStableMark(object);</span>
1364       continue;
1365     }
1366 
1367     // CASE: stack-locked
1368     // Could be stack-locked either by this thread or by some other thread.
1369     //
1370     // Note that we allocate the objectmonitor speculatively, _before_ attempting
1371     // to install INFLATING into the mark word.  We originally installed INFLATING,
1372     // allocated the objectmonitor, and then finally STed the address of the
1373     // objectmonitor into the mark.  This was correct, but artificially lengthened
1374     // the interval in which INFLATED appeared in the mark, thus increasing
1375     // the odds of inflation contention.
1376     //
1377     // We now use per-thread private objectmonitor free lists.
1378     // These list are reprovisioned from the global free list outside the
1379     // critical INFLATING...ST interval.  A thread can transfer
1380     // multiple objectmonitors en-mass from the global free list to its local free list.
1381     // This reduces coherency traffic and lock contention on the global free list.
<a name="171" id="anc171"></a><span class="line-modified">1382     // Using such local free lists, it doesn&#39;t matter if the omAlloc() call appears</span>
1383     // before or after the CAS(INFLATING) operation.
<a name="172" id="anc172"></a><span class="line-modified">1384     // See the comments in omAlloc().</span>
1385 
1386     LogStreamHandle(Trace, monitorinflation) lsh;
1387 
<a name="173" id="anc173"></a><span class="line-modified">1388     if (mark-&gt;has_locker()) {</span>
<span class="line-modified">1389       ObjectMonitor * m = omAlloc(Self);</span>
1390       // Optimistically prepare the objectmonitor - anticipate successful CAS
1391       // We do this before the CAS in order to minimize the length of time
1392       // in which INFLATING appears in the mark.
1393       m-&gt;Recycle();
1394       m-&gt;_Responsible  = NULL;
<a name="174" id="anc174"></a><span class="line-removed">1395       m-&gt;_recursions   = 0;</span>
1396       m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;   // Consider: maintain by type/class
1397 
<a name="175" id="anc175"></a><span class="line-modified">1398       markOop cmp = object-&gt;cas_set_mark(markOopDesc::INFLATING(), mark);</span>
1399       if (cmp != mark) {
<a name="176" id="anc176"></a><span class="line-modified">1400         omRelease(Self, m, true);</span>
1401         continue;       // Interference -- just retry
1402       }
1403 
1404       // We&#39;ve successfully installed INFLATING (0) into the mark-word.
1405       // This is the only case where 0 will appear in a mark-word.
1406       // Only the singular thread that successfully swings the mark-word
1407       // to 0 can perform (or more precisely, complete) inflation.
1408       //
1409       // Why do we CAS a 0 into the mark-word instead of just CASing the
1410       // mark-word from the stack-locked value directly to the new inflated state?
1411       // Consider what happens when a thread unlocks a stack-locked object.
1412       // It attempts to use CAS to swing the displaced header value from the
<a name="177" id="anc177"></a><span class="line-modified">1413       // on-stack basiclock back into the object header.  Recall also that the</span>
<span class="line-modified">1414       // header value (hashcode, etc) can reside in (a) the object header, or</span>
1415       // (b) a displaced header associated with the stack-lock, or (c) a displaced
<a name="178" id="anc178"></a><span class="line-modified">1416       // header in an objectMonitor.  The inflate() routine must copy the header</span>
<span class="line-modified">1417       // value from the basiclock on the owner&#39;s stack to the objectMonitor, all</span>
1418       // the while preserving the hashCode stability invariants.  If the owner
1419       // decides to release the lock while the value is 0, the unlock will fail
1420       // and control will eventually pass from slow_exit() to inflate.  The owner
1421       // will then spin, waiting for the 0 value to disappear.   Put another way,
1422       // the 0 causes the owner to stall if the owner happens to try to
<a name="179" id="anc179"></a><span class="line-modified">1423       // drop the lock (restoring the header from the basiclock to the object)</span>
1424       // while inflation is in-progress.  This protocol avoids races that might
1425       // would otherwise permit hashCode values to change or &quot;flicker&quot; for an object.
<a name="180" id="anc180"></a><span class="line-modified">1426       // Critically, while object-&gt;mark is 0 mark-&gt;displaced_mark_helper() is stable.</span>
1427       // 0 serves as a &quot;BUSY&quot; inflate-in-progress indicator.
1428 
1429 
1430       // fetch the displaced mark from the owner&#39;s stack.
1431       // The owner can&#39;t die or unwind past the lock while our INFLATING
1432       // object is in the mark.  Furthermore the owner can&#39;t complete
1433       // an unlock on the object, either.
<a name="181" id="anc181"></a><span class="line-modified">1434       markOop dmw = mark-&gt;displaced_mark_helper();</span>
<span class="line-modified">1435       assert(dmw-&gt;is_neutral(), &quot;invariant&quot;);</span>


1436 
1437       // Setup monitor fields to proper values -- prepare the monitor
1438       m-&gt;set_header(dmw);
1439 
<a name="182" id="anc182"></a><span class="line-modified">1440       // Optimization: if the mark-&gt;locker stack address is associated</span>
<span class="line-modified">1441       // with this thread we could simply set m-&gt;_owner = Self.</span>
1442       // Note that a thread can inflate an object
1443       // that it has stack-locked -- as might happen in wait() -- directly
1444       // with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.
<a name="183" id="anc183"></a><span class="line-modified">1445       m-&gt;set_owner(mark-&gt;locker());</span>
1446       m-&gt;set_object(object);
1447       // TODO-FIXME: assert BasicLock-&gt;dhw != 0.
1448 
1449       // Must preserve store ordering. The monitor state must
1450       // be stable at the time of publishing the monitor address.
<a name="184" id="anc184"></a><span class="line-modified">1451       guarantee(object-&gt;mark() == markOopDesc::INFLATING(), &quot;invariant&quot;);</span>
<span class="line-modified">1452       object-&gt;release_set_mark(markOopDesc::encode(m));</span>
1453 
1454       // Hopefully the performance counters are allocated on distinct cache lines
1455       // to avoid false sharing on MP systems ...
1456       OM_PERFDATA_OP(Inflations, inc());
1457       if (log_is_enabled(Trace, monitorinflation)) {
<a name="185" id="anc185"></a><span class="line-modified">1458         ResourceMark rm(Self);</span>
1459         lsh.print_cr(&quot;inflate(has_locker): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
1460                      INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
<a name="186" id="anc186"></a><span class="line-modified">1461                      p2i(object-&gt;mark()), object-&gt;klass()-&gt;external_name());</span>
1462       }
1463       if (event.should_commit()) {
1464         post_monitor_inflate_event(&amp;event, object, cause);
1465       }
1466       return m;
1467     }
1468 
1469     // CASE: neutral
1470     // TODO-FIXME: for entry we currently inflate and then try to CAS _owner.
1471     // If we know we&#39;re inflating for entry it&#39;s better to inflate by swinging a
<a name="187" id="anc187"></a><span class="line-modified">1472     // pre-locked objectMonitor pointer into the object header.   A successful</span>
1473     // CAS inflates the object *and* confers ownership to the inflating thread.
1474     // In the current implementation we use a 2-step mechanism where we CAS()
<a name="188" id="anc188"></a><span class="line-modified">1475     // to inflate and then CAS() again to try to swing _owner from NULL to Self.</span>
<span class="line-modified">1476     // An inflateTry() method that we could call from fast_enter() and slow_enter()</span>
<span class="line-removed">1477     // would be useful.</span>
1478 
<a name="189" id="anc189"></a><span class="line-modified">1479     assert(mark-&gt;is_neutral(), &quot;invariant&quot;);</span>
<span class="line-modified">1480     ObjectMonitor * m = omAlloc(Self);</span>


1481     // prepare m for installation - set monitor to initial state
1482     m-&gt;Recycle();
1483     m-&gt;set_header(mark);
<a name="190" id="anc190"></a><span class="line-removed">1484     m-&gt;set_owner(NULL);</span>
1485     m-&gt;set_object(object);
<a name="191" id="anc191"></a><span class="line-removed">1486     m-&gt;_recursions   = 0;</span>
1487     m-&gt;_Responsible  = NULL;
1488     m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;       // consider: keep metastats by type/class
1489 
<a name="192" id="anc192"></a><span class="line-modified">1490     if (object-&gt;cas_set_mark(markOopDesc::encode(m), mark) != mark) {</span>
<span class="line-modified">1491       m-&gt;set_header(NULL);</span>
1492       m-&gt;set_object(NULL);
1493       m-&gt;Recycle();
<a name="193" id="anc193"></a><span class="line-modified">1494       omRelease(Self, m, true);</span>
1495       m = NULL;
1496       continue;
1497       // interference - the markword changed - just retry.
1498       // The state-transitions are one-way, so there&#39;s no chance of
1499       // live-lock -- &quot;Inflated&quot; is an absorbing state.
1500     }
1501 
1502     // Hopefully the performance counters are allocated on distinct
1503     // cache lines to avoid false sharing on MP systems ...
1504     OM_PERFDATA_OP(Inflations, inc());
1505     if (log_is_enabled(Trace, monitorinflation)) {
<a name="194" id="anc194"></a><span class="line-modified">1506       ResourceMark rm(Self);</span>
1507       lsh.print_cr(&quot;inflate(neutral): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
1508                    INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
<a name="195" id="anc195"></a><span class="line-modified">1509                    p2i(object-&gt;mark()), object-&gt;klass()-&gt;external_name());</span>
1510     }
1511     if (event.should_commit()) {
1512       post_monitor_inflate_event(&amp;event, object, cause);
1513     }
1514     return m;
1515   }
1516 }
1517 
1518 
<a name="196" id="anc196"></a><span class="line-modified">1519 // We create a list of in-use monitors for each thread.</span>
1520 //
1521 // deflate_thread_local_monitors() scans a single thread&#39;s in-use list, while
1522 // deflate_idle_monitors() scans only a global list of in-use monitors which
<a name="197" id="anc197"></a><span class="line-modified">1523 // is populated only as a thread dies (see omFlush()).</span>
1524 //
1525 // These operations are called at all safepoints, immediately after mutators
1526 // are stopped, but before any objects have moved. Collectively they traverse
1527 // the population of in-use monitors, deflating where possible. The scavenged
<a name="198" id="anc198"></a><span class="line-modified">1528 // monitors are returned to the monitor free list.</span>
1529 //
1530 // Beware that we scavenge at *every* stop-the-world point. Having a large
1531 // number of monitors in-use could negatively impact performance. We also want
1532 // to minimize the total # of monitors in circulation, as they incur a small
1533 // footprint penalty.
1534 //
1535 // Perversely, the heap size -- and thus the STW safepoint rate --
1536 // typically drives the scavenge rate.  Large heaps can mean infrequent GC,
<a name="199" id="anc199"></a><span class="line-modified">1537 // which in turn can mean large(r) numbers of objectmonitors in circulation.</span>
1538 // This is an unfortunate aspect of this design.
1539 
1540 // Deflate a single monitor if not in-use
1541 // Return true if deflated, false if in-use
1542 bool ObjectSynchronizer::deflate_monitor(ObjectMonitor* mid, oop obj,
<a name="200" id="anc200"></a><span class="line-modified">1543                                          ObjectMonitor** freeHeadp,</span>
<span class="line-modified">1544                                          ObjectMonitor** freeTailp) {</span>
1545   bool deflated;
1546   // Normal case ... The monitor is associated with obj.
<a name="201" id="anc201"></a><span class="line-modified">1547   guarantee(obj-&gt;mark() == markOopDesc::encode(mid), &quot;invariant&quot;);</span>
<span class="line-modified">1548   guarantee(mid == obj-&gt;mark()-&gt;monitor(), &quot;invariant&quot;);</span>
<span class="line-modified">1549   guarantee(mid-&gt;header()-&gt;is_neutral(), &quot;invariant&quot;);</span>






1550 
1551   if (mid-&gt;is_busy()) {
<a name="202" id="anc202"></a>
1552     deflated = false;
1553   } else {
1554     // Deflate the monitor if it is no longer being used
1555     // It&#39;s idle - scavenge and return to the global free list
1556     // plain old deflation ...
1557     if (log_is_enabled(Trace, monitorinflation)) {
1558       ResourceMark rm;
1559       log_trace(monitorinflation)(&quot;deflate_monitor: &quot;
<a name="203" id="anc203"></a><span class="line-modified">1560                                   &quot;object=&quot; INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;,</span>
<span class="line-modified">1561                                   p2i(obj), p2i(obj-&gt;mark()),</span>
<span class="line-modified">1562                                   obj-&gt;klass()-&gt;external_name());</span>
1563     }
1564 
1565     // Restore the header back to obj
<a name="204" id="anc204"></a><span class="line-modified">1566     obj-&gt;release_set_mark(mid-&gt;header());</span>
1567     mid-&gt;clear();
1568 
<a name="205" id="anc205"></a><span class="line-modified">1569     assert(mid-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1570 </span>
<span class="line-modified">1571     // Move the object to the working free list defined by freeHeadp, freeTailp</span>
<span class="line-modified">1572     if (*freeHeadp == NULL) *freeHeadp = mid;</span>
<span class="line-modified">1573     if (*freeTailp != NULL) {</span>
<span class="line-modified">1574       ObjectMonitor * prevtail = *freeTailp;</span>
<span class="line-modified">1575       assert(prevtail-&gt;FreeNext == NULL, &quot;cleaned up deflated?&quot;);</span>
<span class="line-modified">1576       prevtail-&gt;FreeNext = mid;</span>











1577     }
<a name="206" id="anc206"></a><span class="line-modified">1578     *freeTailp = mid;</span>




1579     deflated = true;
1580   }
1581   return deflated;
1582 }
1583 
<a name="207" id="anc207"></a><span class="line-modified">1584 // Walk a given monitor list, and deflate idle monitors</span>
<span class="line-modified">1585 // The given list could be a per-thread list or a global list</span>
<span class="line-removed">1586 // Caller acquires gListLock as needed.</span>
1587 //
1588 // In the case of parallel processing of thread local monitor lists,
1589 // work is done by Threads::parallel_threads_do() which ensures that
1590 // each Java thread is processed by exactly one worker thread, and
1591 // thus avoid conflicts that would arise when worker threads would
1592 // process the same monitor lists concurrently.
1593 //
1594 // See also ParallelSPCleanupTask and
1595 // SafepointSynchronize::do_cleanup_tasks() in safepoint.cpp and
1596 // Threads::parallel_java_threads_do() in thread.cpp.
<a name="208" id="anc208"></a><span class="line-modified">1597 int ObjectSynchronizer::deflate_monitor_list(ObjectMonitor** listHeadp,</span>
<span class="line-modified">1598                                              ObjectMonitor** freeHeadp,</span>
<span class="line-modified">1599                                              ObjectMonitor** freeTailp) {</span>
<span class="line-modified">1600   ObjectMonitor* mid;</span>
<span class="line-removed">1601   ObjectMonitor* next;</span>
1602   ObjectMonitor* cur_mid_in_use = NULL;
<a name="209" id="anc209"></a>

1603   int deflated_count = 0;
1604 
<a name="210" id="anc210"></a><span class="line-modified">1605   for (mid = *listHeadp; mid != NULL;) {</span>




1606     oop obj = (oop) mid-&gt;object();
<a name="211" id="anc211"></a><span class="line-modified">1607     if (obj != NULL &amp;&amp; deflate_monitor(mid, obj, freeHeadp, freeTailp)) {</span>
<span class="line-modified">1608       // if deflate_monitor succeeded,</span>
<span class="line-modified">1609       // extract from per-thread in-use list</span>
<span class="line-modified">1610       if (mid == *listHeadp) {</span>
<span class="line-modified">1611         *listHeadp = mid-&gt;FreeNext;</span>
<span class="line-modified">1612       } else if (cur_mid_in_use != NULL) {</span>
<span class="line-modified">1613         cur_mid_in_use-&gt;FreeNext = mid-&gt;FreeNext; // maintain the current thread in-use list</span>



1614       }
<a name="212" id="anc212"></a><span class="line-modified">1615       next = mid-&gt;FreeNext;</span>
<span class="line-removed">1616       mid-&gt;FreeNext = NULL;  // This mid is current tail in the freeHeadp list</span>
<span class="line-removed">1617       mid = next;</span>
1618       deflated_count++;
<a name="213" id="anc213"></a>


1619     } else {
1620       cur_mid_in_use = mid;
<a name="214" id="anc214"></a><span class="line-removed">1621       mid = mid-&gt;FreeNext;</span>
1622     }
1623   }
1624   return deflated_count;
1625 }
1626 
1627 void ObjectSynchronizer::prepare_deflate_idle_monitors(DeflateMonitorCounters* counters) {
<a name="215" id="anc215"></a><span class="line-modified">1628   counters-&gt;nInuse = 0;              // currently associated with objects</span>
<span class="line-modified">1629   counters-&gt;nInCirculation = 0;      // extant</span>
<span class="line-modified">1630   counters-&gt;nScavenged = 0;          // reclaimed (global and per-thread)</span>
<span class="line-modified">1631   counters-&gt;perThreadScavenged = 0;  // per-thread scavenge total</span>
<span class="line-modified">1632   counters-&gt;perThreadTimes = 0.0;    // per-thread scavenge times</span>
1633 }
1634 
1635 void ObjectSynchronizer::deflate_idle_monitors(DeflateMonitorCounters* counters) {
1636   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
1637   bool deflated = false;
1638 
<a name="216" id="anc216"></a><span class="line-modified">1639   ObjectMonitor * freeHeadp = NULL;  // Local SLL of scavenged monitors</span>
<span class="line-modified">1640   ObjectMonitor * freeTailp = NULL;</span>
1641   elapsedTimer timer;
1642 
1643   if (log_is_enabled(Info, monitorinflation)) {
1644     timer.start();
1645   }
1646 
<a name="217" id="anc217"></a><span class="line-removed">1647   // Prevent omFlush from changing mids in Thread dtor&#39;s during deflation</span>
<span class="line-removed">1648   // And in case the vm thread is acquiring a lock during a safepoint</span>
<span class="line-removed">1649   // See e.g. 6320749</span>
<span class="line-removed">1650   Thread::muxAcquire(&amp;gListLock, &quot;deflate_idle_monitors&quot;);</span>
<span class="line-removed">1651 </span>
1652   // Note: the thread-local monitors lists get deflated in
1653   // a separate pass. See deflate_thread_local_monitors().
1654 
<a name="218" id="anc218"></a><span class="line-modified">1655   // For moribund threads, scan gOmInUseList</span>
1656   int deflated_count = 0;
<a name="219" id="anc219"></a><span class="line-modified">1657   if (gOmInUseList) {</span>
<span class="line-modified">1658     counters-&gt;nInCirculation += gOmInUseCount;</span>
<span class="line-modified">1659     deflated_count = deflate_monitor_list((ObjectMonitor **)&amp;gOmInUseList, &amp;freeHeadp, &amp;freeTailp);</span>
<span class="line-modified">1660     gOmInUseCount -= deflated_count;</span>
<span class="line-modified">1661     counters-&gt;nScavenged += deflated_count;</span>
<span class="line-modified">1662     counters-&gt;nInuse += gOmInUseCount;</span>
<span class="line-modified">1663   }</span>
<span class="line-modified">1664 </span>
<span class="line-modified">1665   // Move the scavenged monitors back to the global free list.</span>
<span class="line-modified">1666   if (freeHeadp != NULL) {</span>
<span class="line-modified">1667     guarantee(freeTailp != NULL &amp;&amp; counters-&gt;nScavenged &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">1668     assert(freeTailp-&gt;FreeNext == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1669     // constant-time list splice - prepend scavenged segment to gFreeList</span>
<span class="line-modified">1670     freeTailp-&gt;FreeNext = gFreeList;</span>
<span class="line-modified">1671     gFreeList = freeHeadp;</span>
<span class="line-modified">1672   }</span>
<span class="line-modified">1673   Thread::muxRelease(&amp;gListLock);</span>





1674   timer.stop();
1675 
1676   LogStreamHandle(Debug, monitorinflation) lsh_debug;
1677   LogStreamHandle(Info, monitorinflation) lsh_info;
<a name="220" id="anc220"></a><span class="line-modified">1678   LogStream * ls = NULL;</span>
1679   if (log_is_enabled(Debug, monitorinflation)) {
1680     ls = &amp;lsh_debug;
1681   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {
1682     ls = &amp;lsh_info;
1683   }
1684   if (ls != NULL) {
1685     ls-&gt;print_cr(&quot;deflating global idle monitors, %3.7f secs, %d monitors&quot;, timer.seconds(), deflated_count);
1686   }
1687 }
1688 
1689 void ObjectSynchronizer::finish_deflate_idle_monitors(DeflateMonitorCounters* counters) {
1690   // Report the cumulative time for deflating each thread&#39;s idle
1691   // monitors. Note: if the work is split among more than one
1692   // worker thread, then the reported time will likely be more
1693   // than a beginning to end measurement of the phase.
<a name="221" id="anc221"></a><span class="line-modified">1694   log_info(safepoint, cleanup)(&quot;deflating per-thread idle monitors, %3.7f secs, monitors=%d&quot;, counters-&gt;perThreadTimes, counters-&gt;perThreadScavenged);</span>
<span class="line-removed">1695 </span>
<span class="line-removed">1696   LogStreamHandle(Debug, monitorinflation) lsh_debug;</span>
<span class="line-removed">1697   LogStreamHandle(Info, monitorinflation) lsh_info;</span>
<span class="line-removed">1698   LogStream * ls = NULL;</span>
<span class="line-removed">1699   if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="line-removed">1700     ls = &amp;lsh_debug;</span>
<span class="line-removed">1701   } else if (counters-&gt;perThreadScavenged != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {</span>
<span class="line-removed">1702     ls = &amp;lsh_info;</span>
<span class="line-removed">1703   }</span>
<span class="line-removed">1704   if (ls != NULL) {</span>
<span class="line-removed">1705     ls-&gt;print_cr(&quot;deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, counters-&gt;perThreadTimes, counters-&gt;perThreadScavenged);</span>
<span class="line-removed">1706   }</span>
<span class="line-removed">1707 </span>
<span class="line-removed">1708   gMonitorFreeCount += counters-&gt;nScavenged;</span>
1709 
1710   if (log_is_enabled(Debug, monitorinflation)) {
1711     // exit_globals()&#39;s call to audit_and_print_stats() is done
<a name="222" id="anc222"></a><span class="line-modified">1712     // at the Info level.</span>
1713     ObjectSynchronizer::audit_and_print_stats(false /* on_exit */);
<a name="223" id="anc223"></a>





1714   }
1715 
<a name="224" id="anc224"></a><span class="line-modified">1716   ForceMonitorScavenge = 0;    // Reset</span>
1717 
<a name="225" id="anc225"></a><span class="line-modified">1718   OM_PERFDATA_OP(Deflations, inc(counters-&gt;nScavenged));</span>
<span class="line-modified">1719   OM_PERFDATA_OP(MonExtant, set_value(counters-&gt;nInCirculation));</span>
1720 
<a name="226" id="anc226"></a><span class="line-modified">1721   GVars.stwRandom = os::random();</span>
<span class="line-modified">1722   GVars.stwCycle++;</span>
1723 }
1724 
1725 void ObjectSynchronizer::deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters) {
1726   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
1727 
<a name="227" id="anc227"></a><span class="line-modified">1728   ObjectMonitor * freeHeadp = NULL;  // Local SLL of scavenged monitors</span>
<span class="line-modified">1729   ObjectMonitor * freeTailp = NULL;</span>
1730   elapsedTimer timer;
1731 
1732   if (log_is_enabled(Info, safepoint, cleanup) ||
1733       log_is_enabled(Info, monitorinflation)) {
1734     timer.start();
1735   }
1736 
<a name="228" id="anc228"></a><span class="line-modified">1737   int deflated_count = deflate_monitor_list(thread-&gt;omInUseList_addr(), &amp;freeHeadp, &amp;freeTailp);</span>
<span class="line-modified">1738 </span>
<span class="line-removed">1739   timer.stop();</span>
1740 
<a name="229" id="anc229"></a><span class="line-modified">1741   Thread::muxAcquire(&amp;gListLock, &quot;deflate_thread_local_monitors&quot;);</span>

1742 
<a name="230" id="anc230"></a><span class="line-modified">1743   // Adjust counters</span>
<span class="line-modified">1744   counters-&gt;nInCirculation += thread-&gt;omInUseCount;</span>
<span class="line-modified">1745   thread-&gt;omInUseCount -= deflated_count;</span>
<span class="line-modified">1746   counters-&gt;nScavenged += deflated_count;</span>
<span class="line-modified">1747   counters-&gt;nInuse += thread-&gt;omInUseCount;</span>
<span class="line-modified">1748   counters-&gt;perThreadScavenged += deflated_count;</span>
<span class="line-modified">1749   // For now, we only care about cumulative per-thread deflation time.</span>
<span class="line-modified">1750   counters-&gt;perThreadTimes += timer.seconds();</span>



1751 
<a name="231" id="anc231"></a><span class="line-modified">1752   // Move the scavenged monitors back to the global free list.</span>
<span class="line-modified">1753   if (freeHeadp != NULL) {</span>
<span class="line-removed">1754     guarantee(freeTailp != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">1755     assert(freeTailp-&gt;FreeNext == NULL, &quot;invariant&quot;);</span>
1756 
<a name="232" id="anc232"></a><span class="line-modified">1757     // constant-time list splice - prepend scavenged segment to gFreeList</span>
<span class="line-modified">1758     freeTailp-&gt;FreeNext = gFreeList;</span>
<span class="line-modified">1759     gFreeList = freeHeadp;</span>







1760   }
<a name="233" id="anc233"></a><span class="line-removed">1761   Thread::muxRelease(&amp;gListLock);</span>
1762 }
1763 
1764 // Monitor cleanup on JavaThread::exit
1765 
1766 // Iterate through monitor cache and attempt to release thread&#39;s monitors
1767 // Gives up on a particular monitor if an exception occurs, but continues
1768 // the overall iteration, swallowing the exception.
1769 class ReleaseJavaMonitorsClosure: public MonitorClosure {
1770  private:
1771   TRAPS;
1772 
1773  public:
1774   ReleaseJavaMonitorsClosure(Thread* thread) : THREAD(thread) {}
1775   void do_monitor(ObjectMonitor* mid) {
1776     if (mid-&gt;owner() == THREAD) {
1777       // Note well -- this occurs ONLY on thread exit, and is a last ditch
1778       // effort to release all locks. Hence, we don&#39;t need to record tsan&#39;s
1779       // recursion count -- it will never be locked again.
1780       TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_unlock(THREAD, (oop)mid-&gt;object()));
1781       (void)mid-&gt;complete_exit(CHECK);
1782     }
1783   }
1784 };
1785 
1786 // Release all inflated monitors owned by THREAD.  Lightweight monitors are
1787 // ignored.  This is meant to be called during JNI thread detach which assumes
1788 // all remaining monitors are heavyweight.  All exceptions are swallowed.
1789 // Scanning the extant monitor list can be time consuming.
1790 // A simple optimization is to add a per-thread flag that indicates a thread
1791 // called jni_monitorenter() during its lifetime.
1792 //
1793 // Instead of No_Savepoint_Verifier it might be cheaper to
1794 // use an idiom of the form:
1795 //   auto int tmp = SafepointSynchronize::_safepoint_counter ;
1796 //   &lt;code that must not run at safepoint&gt;
1797 //   guarantee (((tmp ^ _safepoint_counter) | (tmp &amp; 1)) == 0) ;
1798 // Since the tests are extremely cheap we could leave them enabled
1799 // for normal product builds.
1800 
1801 void ObjectSynchronizer::release_monitors_owned_by_thread(TRAPS) {
1802   assert(THREAD == JavaThread::current(), &quot;must be current Java thread&quot;);
1803   NoSafepointVerifier nsv;
1804   ReleaseJavaMonitorsClosure rjmc(THREAD);
<a name="234" id="anc234"></a><span class="line-removed">1805   Thread::muxAcquire(&amp;gListLock, &quot;release_monitors_owned_by_thread&quot;);</span>
1806   ObjectSynchronizer::monitors_iterate(&amp;rjmc);
<a name="235" id="anc235"></a><span class="line-removed">1807   Thread::muxRelease(&amp;gListLock);</span>
1808   THREAD-&gt;clear_pending_exception();
1809 }
1810 
1811 const char* ObjectSynchronizer::inflate_cause_name(const InflateCause cause) {
1812   switch (cause) {
1813     case inflate_cause_vm_internal:    return &quot;VM Internal&quot;;
1814     case inflate_cause_monitor_enter:  return &quot;Monitor Enter&quot;;
1815     case inflate_cause_wait:           return &quot;Monitor Wait&quot;;
1816     case inflate_cause_notify:         return &quot;Monitor Notify&quot;;
1817     case inflate_cause_hash_code:      return &quot;Monitor Hash Code&quot;;
1818     case inflate_cause_jni_enter:      return &quot;JNI Monitor Enter&quot;;
1819     case inflate_cause_jni_exit:       return &quot;JNI Monitor Exit&quot;;
1820     default:
1821       ShouldNotReachHere();
1822   }
1823   return &quot;Unknown&quot;;
1824 }
1825 
1826 //------------------------------------------------------------------------------
1827 // Debugging code
1828 
1829 u_char* ObjectSynchronizer::get_gvars_addr() {
1830   return (u_char*)&amp;GVars;
1831 }
1832 
<a name="236" id="anc236"></a><span class="line-modified">1833 u_char* ObjectSynchronizer::get_gvars_hcSequence_addr() {</span>
<span class="line-modified">1834   return (u_char*)&amp;GVars.hcSequence;</span>
1835 }
1836 
1837 size_t ObjectSynchronizer::get_gvars_size() {
1838   return sizeof(SharedGlobals);
1839 }
1840 
<a name="237" id="anc237"></a><span class="line-modified">1841 u_char* ObjectSynchronizer::get_gvars_stwRandom_addr() {</span>
<span class="line-modified">1842   return (u_char*)&amp;GVars.stwRandom;</span>
1843 }
1844 
<a name="238" id="anc238"></a>











1845 void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {
1846   assert(on_exit || SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1847 
1848   LogStreamHandle(Debug, monitorinflation) lsh_debug;
1849   LogStreamHandle(Info, monitorinflation) lsh_info;
1850   LogStreamHandle(Trace, monitorinflation) lsh_trace;
<a name="239" id="anc239"></a><span class="line-modified">1851   LogStream * ls = NULL;</span>
1852   if (log_is_enabled(Trace, monitorinflation)) {
1853     ls = &amp;lsh_trace;
1854   } else if (log_is_enabled(Debug, monitorinflation)) {
1855     ls = &amp;lsh_debug;
1856   } else if (log_is_enabled(Info, monitorinflation)) {
1857     ls = &amp;lsh_info;
1858   }
1859   assert(ls != NULL, &quot;sanity check&quot;);
1860 
<a name="240" id="anc240"></a><span class="line-removed">1861   if (!on_exit) {</span>
<span class="line-removed">1862     // Not at VM exit so grab the global list lock.</span>
<span class="line-removed">1863     Thread::muxAcquire(&amp;gListLock, &quot;audit_and_print_stats&quot;);</span>
<span class="line-removed">1864   }</span>
<span class="line-removed">1865 </span>
1866   // Log counts for the global and per-thread monitor lists:
<a name="241" id="anc241"></a><span class="line-modified">1867   int chkMonitorPopulation = log_monitor_list_counts(ls);</span>
1868   int error_cnt = 0;
1869 
1870   ls-&gt;print_cr(&quot;Checking global lists:&quot;);
1871 
<a name="242" id="anc242"></a><span class="line-modified">1872   // Check gMonitorPopulation:</span>
<span class="line-modified">1873   if (gMonitorPopulation == chkMonitorPopulation) {</span>
<span class="line-modified">1874      ls-&gt;print_cr(&quot;gMonitorPopulation=%d equals chkMonitorPopulation=%d&quot;,</span>
<span class="line-modified">1875                   gMonitorPopulation, chkMonitorPopulation);</span>
1876   } else {
<a name="243" id="anc243"></a><span class="line-modified">1877      ls-&gt;print_cr(&quot;ERROR: gMonitorPopulation=%d is not equal to &quot;</span>
<span class="line-modified">1878                   &quot;chkMonitorPopulation=%d&quot;, gMonitorPopulation,</span>
<span class="line-modified">1879                   chkMonitorPopulation);</span>
<span class="line-modified">1880      error_cnt++;</span>




1881   }
1882 
<a name="244" id="anc244"></a><span class="line-modified">1883   // Check gOmInUseList and gOmInUseCount:</span>
1884   chk_global_in_use_list_and_count(ls, &amp;error_cnt);
1885 
<a name="245" id="anc245"></a><span class="line-modified">1886   // Check gFreeList and gMonitorFreeCount:</span>
1887   chk_global_free_list_and_count(ls, &amp;error_cnt);
1888 
<a name="246" id="anc246"></a><span class="line-removed">1889   if (!on_exit) {</span>
<span class="line-removed">1890     Thread::muxRelease(&amp;gListLock);</span>
<span class="line-removed">1891   }</span>
<span class="line-removed">1892 </span>
1893   ls-&gt;print_cr(&quot;Checking per-thread lists:&quot;);
1894 
1895   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<a name="247" id="anc247"></a><span class="line-modified">1896     // Check omInUseList and omInUseCount:</span>
1897     chk_per_thread_in_use_list_and_count(jt, ls, &amp;error_cnt);
1898 
<a name="248" id="anc248"></a><span class="line-modified">1899     // Check omFreeList and omFreeCount:</span>
1900     chk_per_thread_free_list_and_count(jt, ls, &amp;error_cnt);
1901   }
1902 
1903   if (error_cnt == 0) {
1904     ls-&gt;print_cr(&quot;No errors found in monitor list checks.&quot;);
1905   } else {
1906     log_error(monitorinflation)(&quot;found monitor list errors: error_cnt=%d&quot;, error_cnt);
1907   }
1908 
1909   if ((on_exit &amp;&amp; log_is_enabled(Info, monitorinflation)) ||
1910       (!on_exit &amp;&amp; log_is_enabled(Trace, monitorinflation))) {
1911     // When exiting this log output is at the Info level. When called
1912     // at a safepoint, this log output is at the Trace level since
1913     // there can be a lot of it.
<a name="249" id="anc249"></a><span class="line-modified">1914     log_in_use_monitor_details(ls, on_exit);</span>
1915   }
1916 
1917   ls-&gt;flush();
1918 
1919   guarantee(error_cnt == 0, &quot;ERROR: found monitor list errors: error_cnt=%d&quot;, error_cnt);
1920 }
1921 
1922 // Check a free monitor entry; log any errors.
<a name="250" id="anc250"></a><span class="line-modified">1923 void ObjectSynchronizer::chk_free_entry(JavaThread * jt, ObjectMonitor * n,</span>
1924                                         outputStream * out, int *error_cnt_p) {
<a name="251" id="anc251"></a>
1925   if (n-&gt;is_busy()) {
1926     if (jt != NULL) {
1927       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
<a name="252" id="anc252"></a><span class="line-modified">1928                     &quot;: free per-thread monitor must not be busy.&quot;, p2i(jt),</span>
<span class="line-modified">1929                     p2i(n));</span>
1930     } else {
1931       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
<a name="253" id="anc253"></a><span class="line-modified">1932                     &quot;must not be busy.&quot;, p2i(n));</span>
1933     }
1934     *error_cnt_p = *error_cnt_p + 1;
1935   }
<a name="254" id="anc254"></a><span class="line-modified">1936   if (n-&gt;header() != NULL) {</span>
1937     if (jt != NULL) {
1938       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
1939                     &quot;: free per-thread monitor must have NULL _header &quot;
1940                     &quot;field: _header=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
<a name="255" id="anc255"></a><span class="line-modified">1941                     p2i(n-&gt;header()));</span>
1942     } else {
1943       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
1944                     &quot;must have NULL _header field: _header=&quot; INTPTR_FORMAT,
<a name="256" id="anc256"></a><span class="line-modified">1945                     p2i(n), p2i(n-&gt;header()));</span>
1946     }
1947     *error_cnt_p = *error_cnt_p + 1;
1948   }
1949   if (n-&gt;object() != NULL) {
1950     if (jt != NULL) {
1951       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
1952                     &quot;: free per-thread monitor must have NULL _object &quot;
1953                     &quot;field: _object=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
1954                     p2i(n-&gt;object()));
1955     } else {
1956       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
1957                     &quot;must have NULL _object field: _object=&quot; INTPTR_FORMAT,
1958                     p2i(n), p2i(n-&gt;object()));
1959     }
1960     *error_cnt_p = *error_cnt_p + 1;
1961   }
1962 }
1963 
<a name="257" id="anc257"></a>

















1964 // Check the global free list and count; log the results of the checks.
1965 void ObjectSynchronizer::chk_global_free_list_and_count(outputStream * out,
1966                                                         int *error_cnt_p) {
<a name="258" id="anc258"></a><span class="line-modified">1967   int chkMonitorFreeCount = 0;</span>
<span class="line-modified">1968   for (ObjectMonitor * n = gFreeList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">1969     chk_free_entry(NULL /* jt */, n, out, error_cnt_p);</span>
<span class="line-modified">1970     chkMonitorFreeCount++;</span>
<span class="line-modified">1971   }</span>
<span class="line-modified">1972   if (gMonitorFreeCount == chkMonitorFreeCount) {</span>
<span class="line-modified">1973     out-&gt;print_cr(&quot;gMonitorFreeCount=%d equals chkMonitorFreeCount=%d&quot;,</span>
<span class="line-modified">1974                   gMonitorFreeCount, chkMonitorFreeCount);</span>










1975   } else {
<a name="259" id="anc259"></a><span class="line-modified">1976     out-&gt;print_cr(&quot;ERROR: gMonitorFreeCount=%d is not equal to &quot;</span>
<span class="line-modified">1977                   &quot;chkMonitorFreeCount=%d&quot;, gMonitorFreeCount,</span>
<span class="line-modified">1978                   chkMonitorFreeCount);</span>
<span class="line-modified">1979     *error_cnt_p = *error_cnt_p + 1;</span>



1980   }
1981 }
1982 
1983 // Check the global in-use list and count; log the results of the checks.
1984 void ObjectSynchronizer::chk_global_in_use_list_and_count(outputStream * out,
1985                                                           int *error_cnt_p) {
<a name="260" id="anc260"></a><span class="line-modified">1986   int chkOmInUseCount = 0;</span>
<span class="line-modified">1987   for (ObjectMonitor * n = gOmInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">1988     chk_in_use_entry(NULL /* jt */, n, out, error_cnt_p);</span>
<span class="line-modified">1989     chkOmInUseCount++;</span>
<span class="line-modified">1990   }</span>
<span class="line-modified">1991   if (gOmInUseCount == chkOmInUseCount) {</span>
<span class="line-modified">1992     out-&gt;print_cr(&quot;gOmInUseCount=%d equals chkOmInUseCount=%d&quot;, gOmInUseCount,</span>
<span class="line-modified">1993                   chkOmInUseCount);</span>










1994   } else {
<a name="261" id="anc261"></a><span class="line-modified">1995     out-&gt;print_cr(&quot;ERROR: gOmInUseCount=%d is not equal to chkOmInUseCount=%d&quot;,</span>
<span class="line-modified">1996                   gOmInUseCount, chkOmInUseCount);</span>
<span class="line-modified">1997     *error_cnt_p = *error_cnt_p + 1;</span>


1998   }
1999 }
2000 
2001 // Check an in-use monitor entry; log any errors.
<a name="262" id="anc262"></a><span class="line-modified">2002 void ObjectSynchronizer::chk_in_use_entry(JavaThread * jt, ObjectMonitor * n,</span>
2003                                           outputStream * out, int *error_cnt_p) {
<a name="263" id="anc263"></a><span class="line-modified">2004   if (n-&gt;header() == NULL) {</span>
2005     if (jt != NULL) {
2006       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2007                     &quot;: in-use per-thread monitor must have non-NULL _header &quot;
2008                     &quot;field.&quot;, p2i(jt), p2i(n));
2009     } else {
2010       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global monitor &quot;
2011                     &quot;must have non-NULL _header field.&quot;, p2i(n));
2012     }
2013     *error_cnt_p = *error_cnt_p + 1;
2014   }
2015   if (n-&gt;object() == NULL) {
2016     if (jt != NULL) {
2017       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2018                     &quot;: in-use per-thread monitor must have non-NULL _object &quot;
2019                     &quot;field.&quot;, p2i(jt), p2i(n));
2020     } else {
2021       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global monitor &quot;
2022                     &quot;must have non-NULL _object field.&quot;, p2i(n));
2023     }
2024     *error_cnt_p = *error_cnt_p + 1;
2025   }
2026   const oop obj = (oop)n-&gt;object();
<a name="264" id="anc264"></a><span class="line-modified">2027   const markOop mark = obj-&gt;mark();</span>
<span class="line-modified">2028   if (!mark-&gt;has_monitor()) {</span>
2029     if (jt != NULL) {
2030       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2031                     &quot;: in-use per-thread monitor&#39;s object does not think &quot;
2032                     &quot;it has a monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
<a name="265" id="anc265"></a><span class="line-modified">2033                     INTPTR_FORMAT,  p2i(jt), p2i(n), p2i((address)obj),</span>
<span class="line-removed">2034                     p2i((address)mark));</span>
2035     } else {
2036       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
2037                     &quot;monitor&#39;s object does not think it has a monitor: obj=&quot;
2038                     INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT, p2i(n),
<a name="266" id="anc266"></a><span class="line-modified">2039                     p2i((address)obj), p2i((address)mark));</span>
2040     }
2041     *error_cnt_p = *error_cnt_p + 1;
2042   }
<a name="267" id="anc267"></a><span class="line-modified">2043   ObjectMonitor * const obj_mon = mark-&gt;monitor();</span>
2044   if (n != obj_mon) {
2045     if (jt != NULL) {
2046       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2047                     &quot;: in-use per-thread monitor&#39;s object does not refer &quot;
2048                     &quot;to the same monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
2049                     INTPTR_FORMAT &quot;, obj_mon=&quot; INTPTR_FORMAT, p2i(jt),
<a name="268" id="anc268"></a><span class="line-modified">2050                     p2i(n), p2i((address)obj), p2i((address)mark),</span>
<span class="line-removed">2051                     p2i((address)obj_mon));</span>
2052     } else {
2053       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
2054                     &quot;monitor&#39;s object does not refer to the same monitor: obj=&quot;
2055                     INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT &quot;, obj_mon=&quot;
<a name="269" id="anc269"></a><span class="line-modified">2056                     INTPTR_FORMAT, p2i(n), p2i((address)obj),</span>
<span class="line-removed">2057                     p2i((address)mark), p2i((address)obj_mon));</span>
2058     }
2059     *error_cnt_p = *error_cnt_p + 1;
2060   }
2061 }
2062 
2063 // Check the thread&#39;s free list and count; log the results of the checks.
2064 void ObjectSynchronizer::chk_per_thread_free_list_and_count(JavaThread *jt,
2065                                                             outputStream * out,
2066                                                             int *error_cnt_p) {
<a name="270" id="anc270"></a><span class="line-modified">2067   int chkOmFreeCount = 0;</span>
<span class="line-modified">2068   for (ObjectMonitor * n = jt-&gt;omFreeList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">2069     chk_free_entry(jt, n, out, error_cnt_p);</span>
<span class="line-modified">2070     chkOmFreeCount++;</span>
<span class="line-modified">2071   }</span>
<span class="line-modified">2072   if (jt-&gt;omFreeCount == chkOmFreeCount) {</span>
<span class="line-modified">2073     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: omFreeCount=%d equals &quot;</span>
<span class="line-modified">2074                   &quot;chkOmFreeCount=%d&quot;, p2i(jt), jt-&gt;omFreeCount, chkOmFreeCount);</span>










2075   } else {
<a name="271" id="anc271"></a><span class="line-modified">2076     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: omFreeCount=%d is not &quot;</span>
<span class="line-modified">2077                   &quot;equal to chkOmFreeCount=%d&quot;, p2i(jt), jt-&gt;omFreeCount,</span>
<span class="line-modified">2078                   chkOmFreeCount);</span>
2079     *error_cnt_p = *error_cnt_p + 1;
2080   }
2081 }
2082 
2083 // Check the thread&#39;s in-use list and count; log the results of the checks.
2084 void ObjectSynchronizer::chk_per_thread_in_use_list_and_count(JavaThread *jt,
2085                                                               outputStream * out,
2086                                                               int *error_cnt_p) {
<a name="272" id="anc272"></a><span class="line-modified">2087   int chkOmInUseCount = 0;</span>
<span class="line-modified">2088   for (ObjectMonitor * n = jt-&gt;omInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">2089     chk_in_use_entry(jt, n, out, error_cnt_p);</span>
<span class="line-modified">2090     chkOmInUseCount++;</span>
<span class="line-modified">2091   }</span>
<span class="line-modified">2092   if (jt-&gt;omInUseCount == chkOmInUseCount) {</span>
<span class="line-modified">2093     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: omInUseCount=%d equals &quot;</span>
<span class="line-modified">2094                   &quot;chkOmInUseCount=%d&quot;, p2i(jt), jt-&gt;omInUseCount,</span>
<span class="line-modified">2095                   chkOmInUseCount);</span>










2096   } else {
<a name="273" id="anc273"></a><span class="line-modified">2097     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: omInUseCount=%d is not &quot;</span>
<span class="line-modified">2098                   &quot;equal to chkOmInUseCount=%d&quot;, p2i(jt), jt-&gt;omInUseCount,</span>
<span class="line-modified">2099                   chkOmInUseCount);</span>
2100     *error_cnt_p = *error_cnt_p + 1;
2101   }
2102 }
2103 
2104 // Log details about ObjectMonitors on the in-use lists. The &#39;BHL&#39;
2105 // flags indicate why the entry is in-use, &#39;object&#39; and &#39;object type&#39;
2106 // indicate the associated object and its type.
<a name="274" id="anc274"></a><span class="line-modified">2107 void ObjectSynchronizer::log_in_use_monitor_details(outputStream * out,</span>
<span class="line-modified">2108                                                     bool on_exit) {</span>
<span class="line-modified">2109   if (!on_exit) {</span>
<span class="line-removed">2110     // Not at VM exit so grab the global list lock.</span>
<span class="line-removed">2111     Thread::muxAcquire(&amp;gListLock, &quot;log_in_use_monitor_details&quot;);</span>
<span class="line-removed">2112   }</span>
<span class="line-removed">2113 </span>
<span class="line-removed">2114   if (gOmInUseCount &gt; 0) {</span>
2115     out-&gt;print_cr(&quot;In-use global monitor info:&quot;);
<a name="275" id="anc275"></a><span class="line-modified">2116     out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hashcode, L -&gt; lock status)&quot;);</span>
2117     out-&gt;print_cr(&quot;%18s  %s  %18s  %18s&quot;,
2118                   &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
2119     out-&gt;print_cr(&quot;==================  ===  ==================  ==================&quot;);
<a name="276" id="anc276"></a><span class="line-modified">2120     for (ObjectMonitor * n = gOmInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">2121       const oop obj = (oop) n-&gt;object();</span>
<span class="line-modified">2122       const markOop mark = n-&gt;header();</span>
<span class="line-modified">2123       ResourceMark rm;</span>
<span class="line-modified">2124       out-&gt;print_cr(INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT &quot;  %s&quot;, p2i(n),</span>
<span class="line-modified">2125                     n-&gt;is_busy() != 0, mark-&gt;hash() != 0, n-&gt;owner() != NULL,</span>
<span class="line-modified">2126                     p2i(obj), obj-&gt;klass()-&gt;external_name());</span>
<span class="line-modified">2127     }</span>
<span class="line-modified">2128   }</span>






2129 
<a name="277" id="anc277"></a><span class="line-modified">2130   if (!on_exit) {</span>
<span class="line-modified">2131     Thread::muxRelease(&amp;gListLock);</span>




2132   }
2133 
2134   out-&gt;print_cr(&quot;In-use per-thread monitor info:&quot;);
<a name="278" id="anc278"></a><span class="line-modified">2135   out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hashcode, L -&gt; lock status)&quot;);</span>
2136   out-&gt;print_cr(&quot;%18s  %18s  %s  %18s  %18s&quot;,
2137                 &quot;jt&quot;, &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
2138   out-&gt;print_cr(&quot;==================  ==================  ===  ==================  ==================&quot;);
2139   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<a name="279" id="anc279"></a><span class="line-modified">2140     for (ObjectMonitor * n = jt-&gt;omInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">2141       const oop obj = (oop) n-&gt;object();</span>
<span class="line-modified">2142       const markOop mark = n-&gt;header();</span>
<span class="line-modified">2143       ResourceMark rm;</span>
<span class="line-modified">2144       out-&gt;print_cr(INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT</span>
<span class="line-modified">2145                     &quot;  %s&quot;, p2i(jt), p2i(n), n-&gt;is_busy() != 0,</span>
<span class="line-modified">2146                     mark-&gt;hash() != 0, n-&gt;owner() != NULL, p2i(obj),</span>
<span class="line-modified">2147                     obj-&gt;klass()-&gt;external_name());</span>














2148     }
2149   }
2150 
2151   out-&gt;flush();
2152 }
2153 
2154 // Log counts for the global and per-thread monitor lists and return
2155 // the population count.
2156 int ObjectSynchronizer::log_monitor_list_counts(outputStream * out) {
<a name="280" id="anc280"></a><span class="line-modified">2157   int popCount = 0;</span>
2158   out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
2159                 &quot;Global Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Total&quot;);
2160   out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
<a name="281" id="anc281"></a><span class="line-modified">2161   out-&gt;print_cr(&quot;%18s  %10d  %10d  %10d&quot;, &quot;&quot;,</span>
<span class="line-modified">2162                 gOmInUseCount, gMonitorFreeCount, gMonitorPopulation);</span>
<span class="line-modified">2163   popCount += gOmInUseCount + gMonitorFreeCount;</span>


2164 
2165   out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
2166                 &quot;Per-Thread Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Provision&quot;);
2167   out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
2168 
2169   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<a name="282" id="anc282"></a>

2170     out-&gt;print_cr(INTPTR_FORMAT &quot;  %10d  %10d  %10d&quot;, p2i(jt),
<a name="283" id="anc283"></a><span class="line-modified">2171                   jt-&gt;omInUseCount, jt-&gt;omFreeCount, jt-&gt;omFreeProvision);</span>
<span class="line-modified">2172     popCount += jt-&gt;omInUseCount + jt-&gt;omFreeCount;</span>
2173   }
<a name="284" id="anc284"></a><span class="line-modified">2174   return popCount;</span>
2175 }
2176 
2177 #ifndef PRODUCT
2178 
2179 // Check if monitor belongs to the monitor cache
2180 // The list is grow-only so it&#39;s *relatively* safe to traverse
2181 // the list of extant blocks without taking a lock.
2182 
2183 int ObjectSynchronizer::verify_objmon_isinpool(ObjectMonitor *monitor) {
<a name="285" id="anc285"></a><span class="line-modified">2184   PaddedEnd&lt;ObjectMonitor&gt; * block = OrderAccess::load_acquire(&amp;gBlockList);</span>
2185   while (block != NULL) {
2186     assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
2187     if (monitor &gt; &amp;block[0] &amp;&amp; monitor &lt; &amp;block[_BLOCKSIZE]) {
2188       address mon = (address)monitor;
2189       address blk = (address)block;
2190       size_t diff = mon - blk;
<a name="286" id="anc286"></a><span class="line-modified">2191       assert((diff % sizeof(PaddedEnd&lt;ObjectMonitor&gt;)) == 0, &quot;must be aligned&quot;);</span>
2192       return 1;
2193     }
<a name="287" id="anc287"></a><span class="line-modified">2194     block = (PaddedEnd&lt;ObjectMonitor&gt; *)block-&gt;FreeNext;</span>


2195   }
2196   return 0;
2197 }
2198 
2199 #endif
<a name="288" id="anc288"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="288" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/os.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="osThread.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/os.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -45,12 +45,10 @@</span>
  
  // os defines the interface to operating system; this includes traditional
  // OS services (time, I/O) as well as other functionality with system-
  // dependent code.
  
<span class="udiff-line-removed">- typedef void (*dll_func)(...);</span>
<span class="udiff-line-removed">- </span>
  class Thread;
  class JavaThread;
  class NativeCallStack;
  class methodHandle;
  class OSThread;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -165,17 +163,10 @@</span>
  
    static void init_before_ergo(void);          // Called after command line parsing
                                                 // before VM ergonomics processing.
    static jint init_2(void);                    // Called after command line parsing
                                                 // and VM ergonomics processing
<span class="udiff-line-removed">-   static void init_globals(void) {             // Called from init_globals() in init.cpp</span>
<span class="udiff-line-removed">-     init_globals_ext();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // File names are case-insensitive on windows only</span>
<span class="udiff-line-removed">-   // Override me as needed</span>
<span class="udiff-line-removed">-   static int    file_name_strncmp(const char* s1, const char* s2, size_t num);</span>
  
    // unset environment variable
    static bool unsetenv(const char* name);
  
    static bool have_special_privileges();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -200,18 +191,13 @@</span>
    static jlong elapsed_counter();
    static jlong elapsed_frequency();
  
    // The &quot;virtual time&quot; of a thread is the amount of time a thread has
    // actually run.  The first function indicates whether the OS supports
<span class="udiff-line-modified-removed">-   // this functionality for the current thread, and if so:</span>
<span class="udiff-line-modified-removed">-   //   * the second enables vtime tracking (if that is required).</span>
<span class="udiff-line-removed">-   //   * the third tells whether vtime is enabled.</span>
<span class="udiff-line-removed">-   //   * the fourth returns the elapsed virtual time for the current</span>
<span class="udiff-line-removed">-   //     thread.</span>
<span class="udiff-line-modified-added">+   // this functionality for the current thread, and if so the second</span>
<span class="udiff-line-modified-added">+   // returns the elapsed virtual time for the current thread.</span>
    static bool supports_vtime();
<span class="udiff-line-removed">-   static bool enable_vtime();</span>
<span class="udiff-line-removed">-   static bool vtime_enabled();</span>
    static double elapsedVTime();
  
    // Return current local time in a string (YYYY-MM-DD HH:MM:SS).
    // It is MT safe, but not async-safe, as reading time zone
    // information may require a lock on some platforms.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -259,18 +245,10 @@</span>
    static int initial_active_processor_count() {
      assert(_initial_active_processor_count &gt; 0, &quot;Initial active processor count not set yet.&quot;);
      return _initial_active_processor_count;
    }
  
<span class="udiff-line-removed">-   // Bind processes to processors.</span>
<span class="udiff-line-removed">-   //     This is a two step procedure:</span>
<span class="udiff-line-removed">-   //     first you generate a distribution of processes to processors,</span>
<span class="udiff-line-removed">-   //     then you bind processes according to that distribution.</span>
<span class="udiff-line-removed">-   // Compute a distribution for number of processes to processors.</span>
<span class="udiff-line-removed">-   //    Stores the processor id&#39;s into the distribution array argument.</span>
<span class="udiff-line-removed">-   //    Returns true if it worked, false if it didn&#39;t.</span>
<span class="udiff-line-removed">-   static bool distribute_processes(uint length, uint* distribution);</span>
    // Binds the current process to a processor.
    //    Returns true if it worked, false if it didn&#39;t.
    static bool bind_to_processor(uint processor_id);
  
    // Give a name to the current thread.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -394,10 +372,11 @@</span>
    static void   numa_make_global(char *addr, size_t bytes);
    static size_t numa_get_groups_num();
    static size_t numa_get_leaf_groups(int *ids, size_t size);
    static bool   numa_topology_changed();
    static int    numa_get_group_id();
<span class="udiff-line-added">+   static int    numa_get_group_id_for_address(const void* address);</span>
  
    // Page manipulation
    struct page_info {
      size_t size;
      int lgrp_id;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -469,24 +448,26 @@</span>
    static void free_thread(OSThread* osthread);
  
    // thread id on Linux/64bit is 64bit, on Windows and Solaris, it&#39;s 32bit
    static intx current_thread_id();
    static int current_process_id();
<span class="udiff-line-modified-removed">-   static int sleep(Thread* thread, jlong ms, bool interruptable);</span>
<span class="udiff-line-modified-removed">-   // Short standalone OS sleep suitable for slow path spin loop.</span>
<span class="udiff-line-modified-removed">-   // Ignores Thread.interrupt() (so keep it short).</span>
<span class="udiff-line-modified-removed">-   // ms = 0, will sleep for the least amount of time allowed by the OS.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Short standalone OS sleep routines suitable for slow path spin loop.</span>
<span class="udiff-line-modified-added">+   // Ignores safepoints/suspension/Thread.interrupt() (so keep it short).</span>
<span class="udiff-line-modified-added">+   // ms/ns = 0, will sleep for the least amount of time allowed by the OS.</span>
<span class="udiff-line-added">+   // Maximum sleep time is just under 1 second.</span>
    static void naked_short_sleep(jlong ms);
    static void naked_short_nanosleep(jlong ns);
<span class="udiff-line-modified-removed">-   static void infinite_sleep(); // never returns, use with CAUTION</span>
<span class="udiff-line-modified-added">+   // Longer standalone OS sleep routine - a convenience wrapper around</span>
<span class="udiff-line-added">+   // multiple calls to naked_short_sleep. Only for use by non-JavaThreads.</span>
<span class="udiff-line-added">+   static void naked_sleep(jlong millis);</span>
<span class="udiff-line-added">+   // Never returns, use with CAUTION</span>
<span class="udiff-line-added">+   static void infinite_sleep();</span>
    static void naked_yield () ;
    static OSReturn set_priority(Thread* thread, ThreadPriority priority);
    static OSReturn get_priority(const Thread* const thread, ThreadPriority&amp; priority);
  
<span class="udiff-line-removed">-   static void interrupt(Thread* thread);</span>
<span class="udiff-line-removed">-   static bool is_interrupted(Thread* thread, bool clear_interrupted);</span>
<span class="udiff-line-removed">- </span>
    static int pd_self_suspend_thread(Thread* thread);
  
    static ExtendedPC fetch_frame_from_context(const void* ucVoid, intptr_t** sp, intptr_t** fp);
    static frame      fetch_frame_from_context(const void* ucVoid);
    static frame      fetch_frame_from_ucontext(Thread* thread, void* ucVoid);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -499,11 +480,10 @@</span>
    static size_t current_stack_size();
  
    static void verify_stack_alignment() PRODUCT_RETURN;
  
    static bool message_box(const char* title, const char* message);
<span class="udiff-line-removed">-   static char* do_you_want_to_debug(const char* message);</span>
  
    // run cmd in a separate process and return its exit code; or -1 on failures
    static int fork_and_exec(char *cmd, bool use_vfork_if_available = false);
  
    // Call ::exit() on all platforms but Windows
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -516,14 +496,17 @@</span>
    // that support such things.  This calls shutdown() and then aborts.
    static void abort(bool dump_core, void *siginfo, const void *context);
    static void abort(bool dump_core = true);
  
    // Die immediately, no exit hook, no abort hook, no cleanup.
<span class="udiff-line-added">+   // Dump a core file, if possible, for debugging. os::abort() is the</span>
<span class="udiff-line-added">+   // preferred means to abort the VM on error. os::die() should only</span>
<span class="udiff-line-added">+   // be called if something has gone badly wrong. CreateCoredumpOnCrash</span>
<span class="udiff-line-added">+   // is intentionally not honored by this function.</span>
    static void die();
  
    // File i/o operations
<span class="udiff-line-removed">-   static const int default_file_open_flags();</span>
    static int open(const char *path, int oflag, int mode);
    static FILE* open(int fd, const char* mode);
    static FILE* fopen(const char* path, const char* mode);
    static int close(int fd);
    static jlong lseek(int fd, jlong offset, int whence);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -538,10 +521,12 @@</span>
    static void flockfile(FILE* fp);
    static void funlockfile(FILE* fp);
  
    static int compare_file_modified_times(const char* file1, const char* file2);
  
<span class="udiff-line-added">+   static bool same_files(const char* file1, const char* file2);</span>
<span class="udiff-line-added">+ </span>
    //File i/o operations
  
    static ssize_t read(int fd, void *buf, unsigned int nBytes);
    static ssize_t read_at(int fd, void *buf, unsigned int nBytes, jlong offset);
    static size_t write(int fd, const void *buf, unsigned int nBytes);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -589,10 +574,11 @@</span>
    static bool address_is_in_vm(address addr);
  
    // Loads .dll/.so and
    // in case of error it checks if .dll/.so was built for the
    // same architecture as HotSpot is running on
<span class="udiff-line-added">+   // in case of an error NULL is returned and an error message is stored in ebuf</span>
    static void* dll_load(const char *name, char *ebuf, int ebuflen);
  
    // lookup symbol in a shared library
    static void* dll_lookup(void* handle, const char* name);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -644,10 +630,13 @@</span>
    static void print_siginfo(outputStream* st, const void* siginfo);
    static void print_signal_handlers(outputStream* st, char* buf, size_t buflen);
    static void print_date_and_time(outputStream* st, char* buf, size_t buflen);
    static void print_instructions(outputStream* st, address pc, int unitsize);
  
<span class="udiff-line-added">+   // helper for output of seconds in days , hours and months</span>
<span class="udiff-line-added">+   static void print_dhm(outputStream* st, const char* startStr, long sec);</span>
<span class="udiff-line-added">+ </span>
    static void print_location(outputStream* st, intptr_t x, bool verbose = false);
    static size_t lasterror(char *buf, size_t len);
    static int get_last_error();
  
    // Replacement for strerror().
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -664,13 +653,10 @@</span>
    // Will return &quot;Unknown error&quot; for an unknown errno value.
    // Will always return a valid string which is a static constant.
    // Will not change the value of errno.
    static const char* errno_name(int e);
  
<span class="udiff-line-removed">-   // Determines whether the calling process is being debugged by a user-mode debugger.</span>
<span class="udiff-line-removed">-   static bool is_debugger_attached();</span>
<span class="udiff-line-removed">- </span>
    // wait for a key press if PauseAtExit is set
    static void wait_for_keypress_at_exit(void);
  
    // The following two functions are used by fatal error handler to trace
    // native (C) frames. They are not part of frame.hpp/frame.cpp because
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -732,10 +718,11 @@</span>
    static void* malloc  (size_t size, MEMFLAGS flags, const NativeCallStack&amp; stack);
    static void* malloc  (size_t size, MEMFLAGS flags);
    static void* realloc (void *memblock, size_t size, MEMFLAGS flag, const NativeCallStack&amp; stack);
    static void* realloc (void *memblock, size_t size, MEMFLAGS flag);
  
<span class="udiff-line-added">+   // handles NULL pointers</span>
    static void  free    (void *memblock);
    static char* strdup(const char *, MEMFLAGS flags = mtInternal);  // Like strdup
    // Like strdup, but exit VM when strdup() returns NULL
    static char* strdup_check_oom(const char*, MEMFLAGS flags = mtInternal);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -816,14 +803,14 @@</span>
    static int loadavg(double loadavg[], int nelem);
  
    // Amount beyond the callee frame size that we bang the stack.
    static int extra_bang_size_in_bytes();
  
<span class="udiff-line-modified-removed">-   static char** split_path(const char* path, int* n);</span>
<span class="udiff-line-modified-added">+   static char** split_path(const char* path, size_t* elements, size_t file_name_length);</span>
  
<span class="udiff-line-modified-removed">-   // Extensions</span>
<span class="udiff-line-modified-removed">- #include &quot;runtime/os_ext.hpp&quot;</span>
<span class="udiff-line-modified-added">+   // support for mapping non-volatile memory using MAP_SYNC</span>
<span class="udiff-line-modified-added">+   static bool supports_map_sync();</span>
  
   public:
    class CrashProtectionCallback : public StackObj {
    public:
      virtual void call() = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -961,14 +948,10 @@</span>
  
      bool is_running() const {
        return _state == SR_RUNNING;
      }
  
<span class="udiff-line-removed">-     bool is_suspend_request() const {</span>
<span class="udiff-line-removed">-       return _state == SR_SUSPEND_REQUEST;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      bool is_suspended() const {
        return _state == SR_SUSPENDED;
      }
    };
  #endif // !WINDOWS
</pre>
<center><a href="os.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="osThread.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
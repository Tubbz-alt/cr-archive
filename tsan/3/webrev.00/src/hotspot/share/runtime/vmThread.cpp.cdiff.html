<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/vmThread.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vmStructs.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmThread.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/vmThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,13 ***</span>
<span class="line-new-header">--- 29,15 ---</span>
  #include &quot;jfr/support/jfrThreadId.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;logging/logConfiguration.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/verifyOopClosure.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,21 ***</span>
  #include &quot;utilities/dtrace.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
  #include &quot;utilities/xmlstream.hpp&quot;
  
  VMOperationQueue::VMOperationQueue() {
    // The queue is a circular doubled-linked list, which always contains
    // one element (i.e., one element means empty).
    for(int i = 0; i &lt; nof_priorities; i++) {
      _queue_length[i] = 0;
      _queue_counter = 0;
<span class="line-modified">!     _queue[i] = new VM_None(&quot;QueueHead&quot;);</span>
      _queue[i]-&gt;set_next(_queue[i]);
      _queue[i]-&gt;set_prev(_queue[i]);
    }
<span class="line-removed">-   _drain_list = NULL;</span>
  }
  
  
  bool VMOperationQueue::queue_empty(int prio) {
    // It is empty if there is exactly one element
<span class="line-new-header">--- 48,22 ---</span>
  #include &quot;utilities/dtrace.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
  #include &quot;utilities/xmlstream.hpp&quot;
  
<span class="line-added">+ VM_QueueHead VMOperationQueue::_queue_head[VMOperationQueue::nof_priorities];</span>
<span class="line-added">+ </span>
  VMOperationQueue::VMOperationQueue() {
    // The queue is a circular doubled-linked list, which always contains
    // one element (i.e., one element means empty).
    for(int i = 0; i &lt; nof_priorities; i++) {
      _queue_length[i] = 0;
      _queue_counter = 0;
<span class="line-modified">!     _queue[i] = &amp;_queue_head[i];</span>
      _queue[i]-&gt;set_next(_queue[i]);
      _queue[i]-&gt;set_prev(_queue[i]);
    }
  }
  
  
  bool VMOperationQueue::queue_empty(int prio) {
    // It is empty if there is exactly one element
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,16 ***</span>
    n-&gt;set_next(q-&gt;next());
    q-&gt;next()-&gt;set_prev(n);
    q-&gt;set_next(n);
  }
  
<span class="line-modified">! void VMOperationQueue::queue_add_front(int prio, VM_Operation *op) {</span>
<span class="line-removed">-   _queue_length[prio]++;</span>
<span class="line-removed">-   insert(_queue[prio]-&gt;next(), op);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void VMOperationQueue::queue_add_back(int prio, VM_Operation *op) {</span>
    _queue_length[prio]++;
    insert(_queue[prio]-&gt;prev(), op);
  }
  
  
<span class="line-new-header">--- 80,11 ---</span>
    n-&gt;set_next(q-&gt;next());
    q-&gt;next()-&gt;set_prev(n);
    q-&gt;set_next(n);
  }
  
<span class="line-modified">! void VMOperationQueue::queue_add(int prio, VM_Operation *op) {</span>
    _queue_length[prio]++;
    insert(_queue[prio]-&gt;prev(), op);
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,44 ***</span>
    assert(len == length, &quot;drain lost some ops&quot;);
  #endif
    return r;
  }
  
<span class="line-removed">- void VMOperationQueue::queue_oops_do(int queue, OopClosure* f) {</span>
<span class="line-removed">-   VM_Operation* cur = _queue[queue];</span>
<span class="line-removed">-   cur = cur-&gt;next();</span>
<span class="line-removed">-   while (cur != _queue[queue]) {</span>
<span class="line-removed">-     cur-&gt;oops_do(f);</span>
<span class="line-removed">-     cur = cur-&gt;next();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void VMOperationQueue::drain_list_oops_do(OopClosure* f) {</span>
<span class="line-removed">-   VM_Operation* cur = _drain_list;</span>
<span class="line-removed">-   while (cur != NULL) {</span>
<span class="line-removed">-     cur-&gt;oops_do(f);</span>
<span class="line-removed">-     cur = cur-&gt;next();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //-----------------------------------------------------------------
  // High-level interface
<span class="line-modified">! bool VMOperationQueue::add(VM_Operation *op) {</span>
  
    HOTSPOT_VMOPS_REQUEST(
                     (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">!                    op-&gt;evaluation_mode());</span>
  
    // Encapsulates VM queue policy. Currently, that
    // only involves putting them on the right list
<span class="line-modified">!   if (op-&gt;evaluate_at_safepoint()) {</span>
<span class="line-removed">-     queue_add_back(SafepointPriority, op);</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   queue_add_back(MediumPriority, op);</span>
<span class="line-removed">-   return true;</span>
  }
  
  VM_Operation* VMOperationQueue::remove_next() {
    // Assuming VMOperation queue is two-level priority queue. If there are
    // more than two priorities, we need a different scheduling algorithm.
<span class="line-new-header">--- 125,21 ---</span>
    assert(len == length, &quot;drain lost some ops&quot;);
  #endif
    return r;
  }
  
  //-----------------------------------------------------------------
  // High-level interface
<span class="line-modified">! void VMOperationQueue::add(VM_Operation *op) {</span>
  
    HOTSPOT_VMOPS_REQUEST(
                     (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">!                    op-&gt;evaluate_at_safepoint() ? 0 : 1);</span>
  
    // Encapsulates VM queue policy. Currently, that
    // only involves putting them on the right list
<span class="line-modified">!   queue_add(op-&gt;evaluate_at_safepoint() ? SafepointPriority : MediumPriority, op);</span>
  }
  
  VM_Operation* VMOperationQueue::remove_next() {
    // Assuming VMOperation queue is two-level priority queue. If there are
    // more than two priorities, we need a different scheduling algorithm.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,42 ***</span>
    }
  
    return queue_remove_front(queue_empty(high_prio) ? low_prio : high_prio);
  }
  
<span class="line-removed">- void VMOperationQueue::oops_do(OopClosure* f) {</span>
<span class="line-removed">-   for(int i = 0; i &lt; nof_priorities; i++) {</span>
<span class="line-removed">-     queue_oops_do(i, f);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   drain_list_oops_do(f);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //------------------------------------------------------------------------------------------------------------------
  // Timeout machinery
  
  void VMOperationTimeoutTask::task() {
    assert(AbortVMOnVMOperationTimeout, &quot;only if enabled&quot;);
    if (is_armed()) {
<span class="line-modified">!     jlong delay = (os::javaTimeMillis() - _arm_time);</span>
      if (delay &gt; AbortVMOnVMOperationTimeoutDelay) {
        fatal(&quot;VM operation took too long: &quot; JLONG_FORMAT &quot; ms (timeout: &quot; INTX_FORMAT &quot; ms)&quot;,
              delay, AbortVMOnVMOperationTimeoutDelay);
      }
    }
  }
  
  bool VMOperationTimeoutTask::is_armed() {
<span class="line-modified">!   return OrderAccess::load_acquire(&amp;_armed) != 0;</span>
  }
  
  void VMOperationTimeoutTask::arm() {
<span class="line-modified">!   _arm_time = os::javaTimeMillis();</span>
<span class="line-modified">!   OrderAccess::release_store_fence(&amp;_armed, 1);</span>
  }
  
  void VMOperationTimeoutTask::disarm() {
<span class="line-modified">!   OrderAccess::release_store_fence(&amp;_armed, 0);</span>
  }
  
  //------------------------------------------------------------------------------------------------------------------
  // Implementation of VMThread stuff
  
<span class="line-new-header">--- 159,35 ---</span>
    }
  
    return queue_remove_front(queue_empty(high_prio) ? low_prio : high_prio);
  }
  
  //------------------------------------------------------------------------------------------------------------------
  // Timeout machinery
  
  void VMOperationTimeoutTask::task() {
    assert(AbortVMOnVMOperationTimeout, &quot;only if enabled&quot;);
    if (is_armed()) {
<span class="line-modified">!     jlong delay = nanos_to_millis(os::javaTimeNanos() - _arm_time);</span>
      if (delay &gt; AbortVMOnVMOperationTimeoutDelay) {
        fatal(&quot;VM operation took too long: &quot; JLONG_FORMAT &quot; ms (timeout: &quot; INTX_FORMAT &quot; ms)&quot;,
              delay, AbortVMOnVMOperationTimeoutDelay);
      }
    }
  }
  
  bool VMOperationTimeoutTask::is_armed() {
<span class="line-modified">!   return Atomic::load_acquire(&amp;_armed) != 0;</span>
  }
  
  void VMOperationTimeoutTask::arm() {
<span class="line-modified">!   _arm_time = os::javaTimeNanos();</span>
<span class="line-modified">!   Atomic::release_store_fence(&amp;_armed, 1);</span>
  }
  
  void VMOperationTimeoutTask::disarm() {
<span class="line-modified">!   Atomic::release_store_fence(&amp;_armed, 0);</span>
  }
  
  //------------------------------------------------------------------------------------------------------------------
  // Implementation of VMThread stuff
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,13 ***</span>
      // VM thread to enter any lock at Safepoint as long as its _owner is NULL.
      // If that happens after _terminate_lock-&gt;wait() has unset _owner
      // but before it actually drops the lock and waits, the notification below
      // may get lost and we will have a hang. To avoid this, we need to use
      // Mutex::lock_without_safepoint_check().
<span class="line-modified">!     MutexLockerEx ml(_terminate_lock, Mutex::_no_safepoint_check_flag);</span>
      _terminated = true;
<span class="line-modified">!     _terminate_lock-&gt;notify();</span>
    }
  
    // We are now racing with the VM termination being carried out in
    // another thread, so we don&#39;t &quot;delete this&quot;. Numerous threads don&#39;t
    // get deleted when the VM terminates
<span class="line-new-header">--- 308,13 ---</span>
      // VM thread to enter any lock at Safepoint as long as its _owner is NULL.
      // If that happens after _terminate_lock-&gt;wait() has unset _owner
      // but before it actually drops the lock and waits, the notification below
      // may get lost and we will have a hang. To avoid this, we need to use
      // Mutex::lock_without_safepoint_check().
<span class="line-modified">!     MonitorLocker ml(_terminate_lock, Mutex::_no_safepoint_check_flag);</span>
      _terminated = true;
<span class="line-modified">!     ml.notify();</span>
    }
  
    // We are now racing with the VM termination being carried out in
    // another thread, so we don&#39;t &quot;delete this&quot;. Numerous threads don&#39;t
    // get deleted when the VM terminates
</pre>
<hr />
<pre>
<span class="line-old-header">*** 357,13 ***</span>
  // Notify the VMThread that the last non-daemon JavaThread has terminated,
  // and wait until operation is performed.
  void VMThread::wait_for_vm_thread_exit() {
    assert(Thread::current()-&gt;is_Java_thread(), &quot;Should be a JavaThread&quot;);
    assert(((JavaThread*)Thread::current())-&gt;is_terminated(), &quot;Should be terminated&quot;);
<span class="line-modified">!   { MutexLockerEx mu(VMOperationQueue_lock, Mutex::_no_safepoint_check_flag);</span>
      _should_terminate = true;
<span class="line-modified">!     VMOperationQueue_lock-&gt;notify();</span>
    }
  
    // Note: VM thread leaves at Safepoint. We are not stopped by Safepoint
    // because this thread has been removed from the threads list. But anything
    // that could get blocked by Safepoint should not be used after this point,
<span class="line-new-header">--- 325,13 ---</span>
  // Notify the VMThread that the last non-daemon JavaThread has terminated,
  // and wait until operation is performed.
  void VMThread::wait_for_vm_thread_exit() {
    assert(Thread::current()-&gt;is_Java_thread(), &quot;Should be a JavaThread&quot;);
    assert(((JavaThread*)Thread::current())-&gt;is_terminated(), &quot;Should be terminated&quot;);
<span class="line-modified">!   { MonitorLocker mu(VMOperationQueue_lock, Mutex::_no_safepoint_check_flag);</span>
      _should_terminate = true;
<span class="line-modified">!     mu.notify();</span>
    }
  
    // Note: VM thread leaves at Safepoint. We are not stopped by Safepoint
    // because this thread has been removed from the threads list. But anything
    // that could get blocked by Safepoint should not be used after this point,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 371,87 ***</span>
  
    // Wait until VM thread is terminated
    // Note: it should be OK to use Terminator_lock here. But this is called
    // at a very delicate time (VM shutdown) and we are operating in non- VM
    // thread at Safepoint. It&#39;s safer to not share lock with other threads.
<span class="line-modified">!   { MutexLockerEx ml(_terminate_lock, Mutex::_no_safepoint_check_flag);</span>
      while(!VMThread::is_terminated()) {
<span class="line-modified">!         _terminate_lock-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
      }
    }
  }
  
  static void post_vm_operation_event(EventExecuteVMOperation* event, VM_Operation* op) {
    assert(event != NULL, &quot;invariant&quot;);
    assert(event-&gt;should_commit(), &quot;invariant&quot;);
    assert(op != NULL, &quot;invariant&quot;);
<span class="line-removed">-   const bool is_concurrent = op-&gt;evaluate_concurrently();</span>
    const bool evaluate_at_safepoint = op-&gt;evaluate_at_safepoint();
    event-&gt;set_operation(op-&gt;type());
    event-&gt;set_safepoint(evaluate_at_safepoint);
<span class="line-modified">!   event-&gt;set_blocking(!is_concurrent);</span>
<span class="line-modified">!   // Only write caller thread information for non-concurrent vm operations.</span>
<span class="line-modified">!   // For concurrent vm operations, the thread id is set to 0 indicating thread is unknown.</span>
<span class="line-removed">-   // This is because the caller thread could have exited already.</span>
<span class="line-removed">-   event-&gt;set_caller(is_concurrent ? 0 : JFR_THREAD_ID(op-&gt;calling_thread()));</span>
<span class="line-removed">-   event-&gt;set_safepointId(evaluate_at_safepoint ? SafepointSynchronize::safepoint_counter() : 0);</span>
    event-&gt;commit();
  }
  
  void VMThread::evaluate_operation(VM_Operation* op) {
    ResourceMark rm;
  
    {
      PerfTraceTime vm_op_timer(perf_accumulated_vm_operation_time());
      HOTSPOT_VMOPS_BEGIN(
                       (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">!                      op-&gt;evaluation_mode());</span>
  
      EventExecuteVMOperation event;
      op-&gt;evaluate();
      if (event.should_commit()) {
        post_vm_operation_event(&amp;event, op);
      }
  
      HOTSPOT_VMOPS_END(
                       (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">!                      op-&gt;evaluation_mode());</span>
    }
  
<span class="line-removed">-   // Last access of info in _cur_vm_operation!</span>
<span class="line-removed">-   bool c_heap_allocated = op-&gt;is_cheap_allocated();</span>
<span class="line-removed">- </span>
    // Mark as completed
<span class="line-modified">!   if (!op-&gt;evaluate_concurrently()) {</span>
<span class="line-removed">-     op-&gt;calling_thread()-&gt;increment_vm_operation_completed_count();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // It is unsafe to access the _cur_vm_operation after the &#39;increment_vm_operation_completed_count&#39; call,</span>
<span class="line-removed">-   // since if it is stack allocated the calling thread might have deallocated</span>
<span class="line-removed">-   if (c_heap_allocated) {</span>
<span class="line-removed">-     delete _cur_vm_operation;</span>
<span class="line-removed">-   }</span>
  }
  
  static VM_None    safepointALot_op(&quot;SafepointALot&quot;);
  static VM_Cleanup cleanup_op;
  
<span class="line-modified">! VM_Operation* VMThread::no_op_safepoint(bool check_time) {</span>
<span class="line-modified">!   if (SafepointALot) {</span>
<span class="line-modified">!     return &amp;safepointALot_op;</span>
    }
<span class="line-modified">!   if (!SafepointSynchronize::is_cleanup_needed()) {</span>
<span class="line-modified">!     return NULL;</span>
    }
<span class="line-modified">!   if (check_time) {</span>
<span class="line-modified">!     long interval_ms = SafepointTracing::time_since_last_safepoint_ms();</span>
<span class="line-modified">!     bool max_time_exceeded = GuaranteedSafepointInterval != 0 &amp;&amp;</span>
<span class="line-modified">!                              (interval_ms &gt; GuaranteedSafepointInterval);</span>
<span class="line-modified">!     if (!max_time_exceeded) {</span>
<span class="line-modified">!       return NULL;</span>
<span class="line-modified">!     }</span>
    }
<span class="line-modified">!   return &amp;cleanup_op;</span>
  }
  
  void VMThread::loop() {
    assert(_cur_vm_operation == NULL, &quot;no current one should be executing&quot;);
  
<span class="line-new-header">--- 339,93 ---</span>
  
    // Wait until VM thread is terminated
    // Note: it should be OK to use Terminator_lock here. But this is called
    // at a very delicate time (VM shutdown) and we are operating in non- VM
    // thread at Safepoint. It&#39;s safer to not share lock with other threads.
<span class="line-modified">!   { MonitorLocker ml(_terminate_lock, Mutex::_no_safepoint_check_flag);</span>
      while(!VMThread::is_terminated()) {
<span class="line-modified">!       ml.wait();</span>
      }
    }
  }
  
  static void post_vm_operation_event(EventExecuteVMOperation* event, VM_Operation* op) {
    assert(event != NULL, &quot;invariant&quot;);
    assert(event-&gt;should_commit(), &quot;invariant&quot;);
    assert(op != NULL, &quot;invariant&quot;);
    const bool evaluate_at_safepoint = op-&gt;evaluate_at_safepoint();
    event-&gt;set_operation(op-&gt;type());
    event-&gt;set_safepoint(evaluate_at_safepoint);
<span class="line-modified">!   event-&gt;set_blocking(true);</span>
<span class="line-modified">!   event-&gt;set_caller(JFR_THREAD_ID(op-&gt;calling_thread()));</span>
<span class="line-modified">!   event-&gt;set_safepointId(evaluate_at_safepoint ? SafepointSynchronize::safepoint_id() : 0);</span>
    event-&gt;commit();
  }
  
  void VMThread::evaluate_operation(VM_Operation* op) {
    ResourceMark rm;
  
    {
      PerfTraceTime vm_op_timer(perf_accumulated_vm_operation_time());
      HOTSPOT_VMOPS_BEGIN(
                       (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">!                      op-&gt;evaluate_at_safepoint() ? 0 : 1);</span>
  
      EventExecuteVMOperation event;
      op-&gt;evaluate();
      if (event.should_commit()) {
        post_vm_operation_event(&amp;event, op);
      }
  
      HOTSPOT_VMOPS_END(
                       (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">!                      op-&gt;evaluate_at_safepoint() ? 0 : 1);</span>
    }
  
    // Mark as completed
<span class="line-modified">!   op-&gt;calling_thread()-&gt;increment_vm_operation_completed_count();</span>
  }
  
  static VM_None    safepointALot_op(&quot;SafepointALot&quot;);
  static VM_Cleanup cleanup_op;
  
<span class="line-modified">! class HandshakeALotClosure : public HandshakeClosure {</span>
<span class="line-modified">!  public:</span>
<span class="line-modified">!   HandshakeALotClosure() : HandshakeClosure(&quot;HandshakeALot&quot;) {}</span>
<span class="line-added">+   void do_thread(Thread* thread) {</span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+     assert(thread-&gt;is_Java_thread(), &quot;must be&quot;);</span>
<span class="line-added">+     JavaThread* jt = (JavaThread*)thread;</span>
<span class="line-added">+     jt-&gt;verify_states_for_handshake();</span>
<span class="line-added">+ #endif</span>
    }
<span class="line-modified">! };</span>
<span class="line-modified">! </span>
<span class="line-added">+ void VMThread::check_for_forced_cleanup() {</span>
<span class="line-added">+   MonitorLocker mq(VMOperationQueue_lock,  Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   mq.notify();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ VM_Operation* VMThread::no_op_safepoint() {</span>
<span class="line-added">+   // Check for handshakes first since we may need to return a VMop.</span>
<span class="line-added">+   if (HandshakeALot) {</span>
<span class="line-added">+     HandshakeALotClosure hal_cl;</span>
<span class="line-added">+     Handshake::execute(&amp;hal_cl);</span>
    }
<span class="line-modified">!   // Check for a cleanup before SafepointALot to keep stats correct.</span>
<span class="line-modified">!   long interval_ms = SafepointTracing::time_since_last_safepoint_ms();</span>
<span class="line-modified">!   bool max_time_exceeded = GuaranteedSafepointInterval != 0 &amp;&amp;</span>
<span class="line-modified">!                            (interval_ms &gt;= GuaranteedSafepointInterval);</span>
<span class="line-modified">!   if ((max_time_exceeded &amp;&amp; SafepointSynchronize::is_cleanup_needed()) ||</span>
<span class="line-modified">!       SafepointSynchronize::is_forced_cleanup_needed()) {</span>
<span class="line-modified">!     return &amp;cleanup_op;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (SafepointALot) {</span>
<span class="line-added">+     return &amp;safepointALot_op;</span>
    }
<span class="line-modified">!   // Nothing to be done.</span>
<span class="line-added">+   return NULL;</span>
  }
  
  void VMThread::loop() {
    assert(_cur_vm_operation == NULL, &quot;no current one should be executing&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 461,51 ***</span>
      VM_Operation* safepoint_ops = NULL;
      //
      // Wait for VM operation
      //
      // use no_safepoint_check to get lock without attempting to &quot;sneak&quot;
<span class="line-modified">!     { MutexLockerEx mu_queue(VMOperationQueue_lock,</span>
                               Mutex::_no_safepoint_check_flag);
  
        // Look for new operation
        assert(_cur_vm_operation == NULL, &quot;no current one should be executing&quot;);
        _cur_vm_operation = _vm_queue-&gt;remove_next();
  
        // Stall time tracking code
<span class="line-modified">!       if (PrintVMQWaitTime &amp;&amp; _cur_vm_operation != NULL &amp;&amp;</span>
<span class="line-modified">!           !_cur_vm_operation-&gt;evaluate_concurrently()) {</span>
<span class="line-removed">-         long stall = os::javaTimeMillis() - _cur_vm_operation-&gt;timestamp();</span>
          if (stall &gt; 0)
<span class="line-modified">!           tty-&gt;print_cr(&quot;%s stall: %ld&quot;,  _cur_vm_operation-&gt;name(), stall);</span>
        }
  
        while (!should_terminate() &amp;&amp; _cur_vm_operation == NULL) {
          // wait with a timeout to guarantee safepoints at regular intervals
<span class="line-modified">!         bool timedout =</span>
<span class="line-modified">!           VMOperationQueue_lock-&gt;wait(Mutex::_no_safepoint_check_flag,</span>
<span class="line-removed">-                                       GuaranteedSafepointInterval);</span>
  
          // Support for self destruction
          if ((SelfDestructTimer != 0) &amp;&amp; !VMError::is_error_reported() &amp;&amp;
              (os::elapsedTime() &gt; (double)SelfDestructTimer * 60.0)) {
            tty-&gt;print_cr(&quot;VM self-destructed&quot;);
            exit(-1);
          }
  
<span class="line-modified">!         if (timedout &amp;&amp; (_cur_vm_operation = VMThread::no_op_safepoint(false)) != NULL) {</span>
<span class="line-modified">!           MutexUnlockerEx mul(VMOperationQueue_lock,</span>
<span class="line-modified">!                               Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!           // Force a safepoint since we have not had one for at least</span>
<span class="line-modified">!           // &#39;GuaranteedSafepointInterval&#39; milliseconds.  This will run all</span>
<span class="line-modified">!           // the clean-up processing that needs to be done regularly at a</span>
<span class="line-modified">!           // safepoint</span>
<span class="line-modified">!           SafepointSynchronize::begin();</span>
<span class="line-modified">!           #ifdef ASSERT</span>
              if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();
<span class="line-modified">!           #endif</span>
<span class="line-modified">!           SafepointSynchronize::end();</span>
<span class="line-modified">!           _cur_vm_operation = NULL;</span>
          }
          _cur_vm_operation = _vm_queue-&gt;remove_next();
  
          // If we are at a safepoint we will evaluate all the operations that
          // follow that also require a safepoint
<span class="line-new-header">--- 435,55 ---</span>
      VM_Operation* safepoint_ops = NULL;
      //
      // Wait for VM operation
      //
      // use no_safepoint_check to get lock without attempting to &quot;sneak&quot;
<span class="line-modified">!     { MonitorLocker mu_queue(VMOperationQueue_lock,</span>
                               Mutex::_no_safepoint_check_flag);
  
        // Look for new operation
        assert(_cur_vm_operation == NULL, &quot;no current one should be executing&quot;);
        _cur_vm_operation = _vm_queue-&gt;remove_next();
  
        // Stall time tracking code
<span class="line-modified">!       if (PrintVMQWaitTime &amp;&amp; _cur_vm_operation != NULL) {</span>
<span class="line-modified">!         jlong stall = nanos_to_millis(os::javaTimeNanos() - _cur_vm_operation-&gt;timestamp());</span>
          if (stall &gt; 0)
<span class="line-modified">!           tty-&gt;print_cr(&quot;%s stall: &quot; JLONG_FORMAT,  _cur_vm_operation-&gt;name(), stall);</span>
        }
  
        while (!should_terminate() &amp;&amp; _cur_vm_operation == NULL) {
          // wait with a timeout to guarantee safepoints at regular intervals
<span class="line-modified">!         // (if there is cleanup work to do)</span>
<span class="line-modified">!         (void)mu_queue.wait(GuaranteedSafepointInterval);</span>
  
          // Support for self destruction
          if ((SelfDestructTimer != 0) &amp;&amp; !VMError::is_error_reported() &amp;&amp;
              (os::elapsedTime() &gt; (double)SelfDestructTimer * 60.0)) {
            tty-&gt;print_cr(&quot;VM self-destructed&quot;);
            exit(-1);
          }
  
<span class="line-modified">!         // If the queue contains a safepoint VM op,</span>
<span class="line-modified">!         // clean up will be done so we can skip this part.</span>
<span class="line-modified">!         if (!_vm_queue-&gt;peek_at_safepoint_priority()) {</span>
<span class="line-modified">! </span>
<span class="line-modified">!           // Have to unlock VMOperationQueue_lock just in case no_op_safepoint()</span>
<span class="line-modified">!           // has to do a handshake when HandshakeALot is enabled.</span>
<span class="line-modified">!           MutexUnlocker mul(VMOperationQueue_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!           if ((_cur_vm_operation = VMThread::no_op_safepoint()) != NULL) {</span>
<span class="line-modified">!             // Force a safepoint since we have not had one for at least</span>
<span class="line-added">+             // &#39;GuaranteedSafepointInterval&#39; milliseconds and we need to clean</span>
<span class="line-added">+             // something. This will run all the clean-up processing that needs</span>
<span class="line-added">+             // to be done at a safepoint.</span>
<span class="line-added">+             SafepointSynchronize::begin();</span>
<span class="line-added">+             #ifdef ASSERT</span>
              if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();
<span class="line-modified">!             #endif</span>
<span class="line-modified">!             SafepointSynchronize::end();</span>
<span class="line-modified">!             _cur_vm_operation = NULL;</span>
<span class="line-added">+           }</span>
          }
          _cur_vm_operation = _vm_queue-&gt;remove_next();
  
          // If we are at a safepoint we will evaluate all the operations that
          // follow that also require a safepoint
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,12 ***</span>
        // If we are at a safepoint we will evaluate all the operations that
        // follow that also require a safepoint
        if (_cur_vm_operation-&gt;evaluate_at_safepoint()) {
          log_debug(vmthread)(&quot;Evaluating safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());
  
<span class="line-removed">-         _vm_queue-&gt;set_drain_list(safepoint_ops); // ensure ops can be scanned</span>
<span class="line-removed">- </span>
          SafepointSynchronize::begin();
  
          if (_timeout_task != NULL) {
            _timeout_task-&gt;arm();
          }
<span class="line-new-header">--- 507,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 544,15 ***</span>
          // the queue until there are none left
          do {
            _cur_vm_operation = safepoint_ops;
            if (_cur_vm_operation != NULL) {
              do {
                log_debug(vmthread)(&quot;Evaluating coalesced safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());
                // evaluate_operation deletes the op object so we have
                // to grab the next op now
                VM_Operation* next = _cur_vm_operation-&gt;next();
<span class="line-removed">-               _vm_queue-&gt;set_drain_list(next);</span>
                evaluate_operation(_cur_vm_operation);
                _cur_vm_operation = next;
                _coalesced_count++;
              } while (_cur_vm_operation != NULL);
            }
<span class="line-new-header">--- 520,15 ---</span>
          // the queue until there are none left
          do {
            _cur_vm_operation = safepoint_ops;
            if (_cur_vm_operation != NULL) {
              do {
<span class="line-added">+               EventMark em(&quot;Executing coalesced safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());</span>
                log_debug(vmthread)(&quot;Evaluating coalesced safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());
                // evaluate_operation deletes the op object so we have
                // to grab the next op now
                VM_Operation* next = _cur_vm_operation-&gt;next();
                evaluate_operation(_cur_vm_operation);
                _cur_vm_operation = next;
                _coalesced_count++;
              } while (_cur_vm_operation != NULL);
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 566,20 ***</span>
            // that simply means the op will wait for the next major cycle of the
            // VMThread - just as it would if the GC thread lost the race for
            // the lock.
            if (_vm_queue-&gt;peek_at_safepoint_priority()) {
              // must hold lock while draining queue
<span class="line-modified">!             MutexLockerEx mu_queue(VMOperationQueue_lock,</span>
<span class="line-modified">!                                      Mutex::_no_safepoint_check_flag);</span>
              safepoint_ops = _vm_queue-&gt;drain_at_safepoint_priority();
            } else {
              safepoint_ops = NULL;
            }
          } while(safepoint_ops != NULL);
  
<span class="line-removed">-         _vm_queue-&gt;set_drain_list(NULL);</span>
<span class="line-removed">- </span>
          if (_timeout_task != NULL) {
            _timeout_task-&gt;disarm();
          }
  
          // Complete safepoint synchronization
<span class="line-new-header">--- 542,18 ---</span>
            // that simply means the op will wait for the next major cycle of the
            // VMThread - just as it would if the GC thread lost the race for
            // the lock.
            if (_vm_queue-&gt;peek_at_safepoint_priority()) {
              // must hold lock while draining queue
<span class="line-modified">!             MutexLocker mu_queue(VMOperationQueue_lock,</span>
<span class="line-modified">!                                  Mutex::_no_safepoint_check_flag);</span>
              safepoint_ops = _vm_queue-&gt;drain_at_safepoint_priority();
            } else {
              safepoint_ops = NULL;
            }
          } while(safepoint_ops != NULL);
  
          if (_timeout_task != NULL) {
            _timeout_task-&gt;disarm();
          }
  
          // Complete safepoint synchronization
</pre>
<hr />
<pre>
<span class="line-old-header">*** 606,25 ***</span>
          _cur_vm_operation = NULL;
        }
      }
  
      //
<span class="line-modified">!     //  Notify (potential) waiting Java thread(s) - lock without safepoint</span>
<span class="line-modified">!     //  check so that sneaking is not possible</span>
<span class="line-modified">!     { MutexLockerEx mu(VMOperationRequest_lock,</span>
<span class="line-removed">-                        Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">-       VMOperationRequest_lock-&gt;notify_all();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // We want to make sure that we get to a safepoint regularly.</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     if ((_cur_vm_operation = VMThread::no_op_safepoint(false)) != NULL) {</span>
<span class="line-removed">-       HandleMark hm(VMThread::vm_thread());</span>
<span class="line-removed">-       SafepointSynchronize::begin();</span>
<span class="line-removed">-       SafepointSynchronize::end();</span>
<span class="line-removed">-       _cur_vm_operation = NULL;</span>
      }
    }
  }
  
  // A SkipGCALot object is used to elide the usual effect of gc-a-lot
<span class="line-new-header">--- 580,13 ---</span>
          _cur_vm_operation = NULL;
        }
      }
  
      //
<span class="line-modified">!     //  Notify (potential) waiting Java thread(s)</span>
<span class="line-modified">!     { MonitorLocker mu(VMOperationRequest_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!       mu.notify_all();</span>
      }
    }
  }
  
  // A SkipGCALot object is used to elide the usual effect of gc-a-lot
</pre>
<hr />
<pre>
<span class="line-old-header">*** 656,65 ***</span>
    Thread* t = Thread::current();
  
    if (!t-&gt;is_VM_thread()) {
      SkipGCALot sgcalot(t);    // avoid re-entrant attempts to gc-a-lot
      // JavaThread or WatcherThread
<span class="line-modified">!     bool concurrent = op-&gt;evaluate_concurrently();</span>
<span class="line-removed">-     // only blocking VM operations need to verify the caller&#39;s safepoint state:</span>
<span class="line-removed">-     if (!concurrent) {</span>
<span class="line-removed">-       t-&gt;check_for_valid_safepoint_state(true);</span>
<span class="line-removed">-     }</span>
  
      // New request from Java thread, evaluate prologue
      if (!op-&gt;doit_prologue()) {
        return;   // op was cancelled
      }
  
      // Setup VM_operations for execution
<span class="line-modified">!     op-&gt;set_calling_thread(t, Thread::get_priority(t));</span>
  
<span class="line-modified">!     // It does not make sense to execute the epilogue, if the VM operation object is getting</span>
<span class="line-modified">!     // deallocated by the VM thread.</span>
<span class="line-removed">-     bool execute_epilog = !op-&gt;is_cheap_allocated();</span>
<span class="line-removed">-     assert(!concurrent || op-&gt;is_cheap_allocated(), &quot;concurrent =&gt; cheap_allocated&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Get ticket number for non-concurrent VM operations</span>
<span class="line-removed">-     int ticket = 0;</span>
<span class="line-removed">-     if (!concurrent) {</span>
<span class="line-removed">-       ticket = t-&gt;vm_operation_ticket();</span>
<span class="line-removed">-     }</span>
  
      // Add VM operation to list of waiting threads. We are guaranteed not to block while holding the
      // VMOperationQueue_lock, so we can block without a safepoint check. This allows vm operation requests
      // to be queued up during a safepoint synchronization.
      {
<span class="line-modified">!       VMOperationQueue_lock-&gt;lock_without_safepoint_check();</span>
        log_debug(vmthread)(&quot;Adding VM operation: %s&quot;, op-&gt;name());
<span class="line-modified">!       bool ok = _vm_queue-&gt;add(op);</span>
<span class="line-modified">!       op-&gt;set_timestamp(os::javaTimeMillis());</span>
<span class="line-modified">!       VMOperationQueue_lock-&gt;notify();</span>
<span class="line-removed">-       VMOperationQueue_lock-&gt;unlock();</span>
<span class="line-removed">-       // VM_Operation got skipped</span>
<span class="line-removed">-       if (!ok) {</span>
<span class="line-removed">-         assert(concurrent, &quot;can only skip concurrent tasks&quot;);</span>
<span class="line-removed">-         if (op-&gt;is_cheap_allocated()) delete op;</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-       }</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     if (!concurrent) {</span>
<span class="line-removed">-       // Wait for completion of request (non-concurrent)</span>
        // Note: only a JavaThread triggers the safepoint check when locking
<span class="line-modified">!       MutexLocker mu(VMOperationRequest_lock);</span>
        while(t-&gt;vm_operation_completed_count() &lt; ticket) {
<span class="line-modified">!         VMOperationRequest_lock-&gt;wait(!t-&gt;is_Java_thread());</span>
        }
      }
<span class="line-modified">! </span>
<span class="line-removed">-     if (execute_epilog) {</span>
<span class="line-removed">-       op-&gt;doit_epilogue();</span>
<span class="line-removed">-     }</span>
    } else {
      // invoked by VM thread; usually nested VM operation
      assert(t-&gt;is_VM_thread(), &quot;must be a VM thread&quot;);
      VM_Operation* prev_vm_operation = vm_operation();
      if (prev_vm_operation != NULL) {
<span class="line-new-header">--- 618,43 ---</span>
    Thread* t = Thread::current();
  
    if (!t-&gt;is_VM_thread()) {
      SkipGCALot sgcalot(t);    // avoid re-entrant attempts to gc-a-lot
      // JavaThread or WatcherThread
<span class="line-modified">!     t-&gt;check_for_valid_safepoint_state();</span>
  
      // New request from Java thread, evaluate prologue
      if (!op-&gt;doit_prologue()) {
        return;   // op was cancelled
      }
  
      // Setup VM_operations for execution
<span class="line-modified">!     op-&gt;set_calling_thread(t);</span>
  
<span class="line-modified">!     // Get ticket number for the VM operation</span>
<span class="line-modified">!     int ticket = t-&gt;vm_operation_ticket();</span>
  
      // Add VM operation to list of waiting threads. We are guaranteed not to block while holding the
      // VMOperationQueue_lock, so we can block without a safepoint check. This allows vm operation requests
      // to be queued up during a safepoint synchronization.
      {
<span class="line-modified">!       MonitorLocker ml(VMOperationQueue_lock, Mutex::_no_safepoint_check_flag);</span>
        log_debug(vmthread)(&quot;Adding VM operation: %s&quot;, op-&gt;name());
<span class="line-modified">!       _vm_queue-&gt;add(op);</span>
<span class="line-modified">!       op-&gt;set_timestamp(os::javaTimeNanos());</span>
<span class="line-modified">!       ml.notify();</span>
      }
<span class="line-modified">!     {</span>
<span class="line-modified">!       // Wait for completion of request</span>
        // Note: only a JavaThread triggers the safepoint check when locking
<span class="line-modified">!       MonitorLocker ml(VMOperationRequest_lock,</span>
<span class="line-added">+                        t-&gt;is_Java_thread() ? Mutex::_safepoint_check_flag : Mutex::_no_safepoint_check_flag);</span>
        while(t-&gt;vm_operation_completed_count() &lt; ticket) {
<span class="line-modified">!         ml.wait();</span>
        }
      }
<span class="line-modified">!     op-&gt;doit_epilogue();</span>
    } else {
      // invoked by VM thread; usually nested VM operation
      assert(t-&gt;is_VM_thread(), &quot;must be a VM thread&quot;);
      VM_Operation* prev_vm_operation = vm_operation();
      if (prev_vm_operation != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 722,11 ***</span>
        // does not allow nested scavenges or compiles.
        if (!prev_vm_operation-&gt;allow_nested_vm_operations()) {
          fatal(&quot;Nested VM operation %s requested by operation %s&quot;,
                op-&gt;name(), vm_operation()-&gt;name());
        }
<span class="line-modified">!       op-&gt;set_calling_thread(prev_vm_operation-&gt;calling_thread(), prev_vm_operation-&gt;priority());</span>
      }
  
      EventMark em(&quot;Executing %s VM operation: %s&quot;, prev_vm_operation ? &quot;nested&quot; : &quot;&quot;, op-&gt;name());
  
      // Release all internal handles after operation is evaluated
<span class="line-new-header">--- 662,11 ---</span>
        // does not allow nested scavenges or compiles.
        if (!prev_vm_operation-&gt;allow_nested_vm_operations()) {
          fatal(&quot;Nested VM operation %s requested by operation %s&quot;,
                op-&gt;name(), vm_operation()-&gt;name());
        }
<span class="line-modified">!       op-&gt;set_calling_thread(prev_vm_operation-&gt;calling_thread());</span>
      }
  
      EventMark em(&quot;Executing %s VM operation: %s&quot;, prev_vm_operation ? &quot;nested&quot; : &quot;&quot;, op-&gt;name());
  
      // Release all internal handles after operation is evaluated
</pre>
<hr />
<pre>
<span class="line-old-header">*** 739,48 ***</span>
        SafepointSynchronize::end();
      } else {
        op-&gt;evaluate();
      }
  
<span class="line-removed">-     // Free memory if needed</span>
<span class="line-removed">-     if (op-&gt;is_cheap_allocated()) delete op;</span>
<span class="line-removed">- </span>
      _cur_vm_operation = prev_vm_operation;
    }
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- void VMThread::oops_do(OopClosure* f, CodeBlobClosure* cf) {</span>
<span class="line-removed">-   Thread::oops_do(f, cf);</span>
<span class="line-removed">-   _vm_queue-&gt;oops_do(f);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- //------------------------------------------------------------------------------------------------------------------</span>
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">- </span>
<span class="line-removed">- void VMOperationQueue::verify_queue(int prio) {</span>
<span class="line-removed">-   // Check that list is correctly linked</span>
<span class="line-removed">-   int length = _queue_length[prio];</span>
<span class="line-removed">-   VM_Operation *cur = _queue[prio];</span>
<span class="line-removed">-   int i;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Check forward links</span>
<span class="line-removed">-   for(i = 0; i &lt; length; i++) {</span>
<span class="line-removed">-     cur = cur-&gt;next();</span>
<span class="line-removed">-     assert(cur != _queue[prio], &quot;list to short (forward)&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert(cur-&gt;next() == _queue[prio], &quot;list to long (forward)&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Check backwards links</span>
<span class="line-removed">-   cur = _queue[prio];</span>
<span class="line-removed">-   for(i = 0; i &lt; length; i++) {</span>
<span class="line-removed">-     cur = cur-&gt;prev();</span>
<span class="line-removed">-     assert(cur != _queue[prio], &quot;list to short (backwards)&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert(cur-&gt;prev() == _queue[prio], &quot;list to long (backwards)&quot;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  void VMThread::verify() {
    oops_do(&amp;VerifyOopClosure::verify_oop, NULL);
  }
<span class="line-new-header">--- 679,12 ---</span>
</pre>
<center><a href="vmStructs.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmThread.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
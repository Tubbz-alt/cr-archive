<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/safepoint.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="safepoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepointMechanism.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/safepoint.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 31 #include &quot;runtime/vmOperations.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 #include &quot;utilities/waitBarrier.hpp&quot;
 34 
 35 //
 36 // Safepoint synchronization
 37 ////
 38 // The VMThread uses the SafepointSynchronize::begin/end
 39 // methods to enter/exit a safepoint region. The begin method will roll
 40 // all JavaThreads forward to a safepoint.
 41 //
 42 // JavaThreads must use the ThreadSafepointState abstraction (defined in
 43 // thread.hpp) to indicate that that they are at a safepoint.
 44 //
 45 // The Mutex/Condition variable and ObjectLocker classes calls the enter/
 46 // exit safepoint methods, when a thread is blocked/restarted. Hence, all mutex exter/
 47 // exit points *must* be at a safepoint.
 48 
 49 class ThreadSafepointState;
 50 








 51 //
 52 // Implements roll-forward to safepoint (safepoint synchronization)
 53 //
 54 class SafepointSynchronize : AllStatic {
 55  public:
 56   enum SynchronizeState {
 57       _not_synchronized = 0,                   // Threads not synchronized at a safepoint. Keep this value 0.
 58       _synchronizing    = 1,                   // Synchronizing in progress
 59       _synchronized     = 2                    // All Java threads are running in native, blocked in OS or stopped at safepoint.
 60                                                // VM thread and any NonJavaThread may be running.
 61   };
 62 
 63   // The enums are listed in the order of the tasks when done serially.
 64   enum SafepointCleanupTasks {
 65     SAFEPOINT_CLEANUP_DEFLATE_MONITORS,
 66     SAFEPOINT_CLEANUP_UPDATE_INLINE_CACHES,
 67     SAFEPOINT_CLEANUP_COMPILATION_POLICY,
 68     SAFEPOINT_CLEANUP_SYMBOL_TABLE_REHASH,
 69     SAFEPOINT_CLEANUP_STRING_TABLE_REHASH,
<span class="line-removed"> 70     SAFEPOINT_CLEANUP_CLD_PURGE,</span>
 71     SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE,

 72     // Leave this one last.
 73     SAFEPOINT_CLEANUP_NUM_TASKS
 74   };
 75 
 76  private:
 77   friend class SafepointMechanism;
 78   friend class ThreadSafepointState;
 79   friend class HandshakeState;

 80 
 81   // Threads might read this flag directly, without acquiring the Threads_lock:
 82   static volatile SynchronizeState _state;
 83   // Number of threads we are waiting for to block:
 84   static int              _waiting_to_block;
 85   // Counts the number of active critical natives during the safepoint:
 86   static int              _current_jni_active_count;
 87 
 88   // This counter is used for fast versions of jni_Get&lt;Primitive&gt;Field.
 89   // An even value means there are no ongoing safepoint operations.
 90   // The counter is incremented ONLY at the beginning and end of each
 91   // safepoint.
 92   static volatile uint64_t _safepoint_counter;
 93 





 94   // JavaThreads that need to block for the safepoint will stop on the
 95   // _wait_barrier, where they can quickly be started again.
 96   static WaitBarrier* _wait_barrier;
<span class="line-removed"> 97   static long         _end_of_last_safepoint;     // Time of last safepoint in milliseconds</span>
 98   static julong       _coalesced_vmop_count;     // coalesced vmop count
 99 
<span class="line-removed">100   // Statistics</span>
<span class="line-removed">101   static void begin_statistics(int nof_threads, int nof_running);</span>
<span class="line-removed">102   static void update_statistics_on_spin_end();</span>
<span class="line-removed">103   static void update_statistics_on_sync_end(jlong end_time);</span>
<span class="line-removed">104   static void update_statistics_on_cleanup_end(jlong end_time);</span>
<span class="line-removed">105   static void end_statistics(jlong end_time);</span>
<span class="line-removed">106   static void print_statistics();</span>
<span class="line-removed">107 </span>
108   // For debug long safepoint
109   static void print_safepoint_timeout();
110 
111   // Helper methods for safepoint procedure:
112   static void arm_safepoint();
113   static int synchronize_threads(jlong safepoint_limit_time, int nof_threads, int* initial_running);
114   static void disarm_safepoint();
115   static void increment_jni_active_count();
116   static void decrement_waiting_to_block();

117 
118   // Used in safepoint_safe to do a stable load of the thread state.
119   static bool try_stable_load_state(JavaThreadState *state,
120                                     JavaThread *thread,
121                                     uint64_t safepoint_count);
122 
123   // Called when a thread voluntarily blocks
124   static void block(JavaThread *thread);
125 
126   // Called from VMThread during handshakes.
127   // If true the VMThread may safely process the handshake operation for the JavaThread.
128   static bool handshake_safe(JavaThread *thread);
129 


130 public:
131 
132   static void init(Thread* vmthread);
133 
134   // Roll all threads forward to safepoint. Must be called by the VMThread.
135   static void begin();
136   static void end();                    // Start all suspended threads again...
137 
138   // The value for a not set safepoint id.
139   static const uint64_t InactiveSafepointCounter;
140 
141   // Query
142   static bool is_at_safepoint()                   { return _state == _synchronized; }
143   static bool is_synchronizing()                  { return _state == _synchronizing; }
<span class="line-modified">144   static uint64_t safepoint_counter()             { return _safepoint_counter; }</span>
<span class="line-modified">145   static bool is_same_safepoint(uint64_t counter) { return (SafepointSynchronize::safepoint_counter() - counter) &lt; 2; }</span>







146   // Exception handling for page polling
147   static void handle_polling_page_exception(JavaThread *thread);
148 
149   static bool is_cleanup_needed();

150   static void do_cleanup_tasks();
151 
152   static void set_is_at_safepoint()             { _state = _synchronized; }
153   static void set_is_not_at_safepoint()         { _state = _not_synchronized; }
154 
155   // Assembly support
156   static address address_of_state()             { return (address)&amp;_state; }
157 
158   // Only used for making sure that no safepoint has happened in
159   // JNI_FastGetField. Therefore only the low 32-bits are needed
160   // even if this is a 64-bit counter.
161   static address safepoint_counter_addr() {
162 #ifdef VM_LITTLE_ENDIAN
163     return (address)&amp;_safepoint_counter;
164 #else /* BIG */
165     // Return pointer to the 32 LSB:
166     return (address) (((uint32_t*)(&amp;_safepoint_counter)) + 1);
167 #endif
168   }
169 };
</pre>
<hr />
<pre>
173 #define assert_at_safepoint()                                           \
174   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;)
175 
176 #define assert_at_safepoint_msg(...)                                    \
177   assert(SafepointSynchronize::is_at_safepoint(), __VA_ARGS__)
178 
179 #define assert_not_at_safepoint()                                       \
180   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;)
181 
182 #define assert_not_at_safepoint_msg(...)                                \
183   assert(!SafepointSynchronize::is_at_safepoint(), __VA_ARGS__)
184 
185 // State class for a thread suspended at a safepoint
186 class ThreadSafepointState: public CHeapObj&lt;mtThread&gt; {
187  private:
188   // At polling page safepoint (NOT a poll return safepoint):
189   volatile bool                   _at_poll_safepoint;
190   JavaThread*                     _thread;
191   bool                            _safepoint_safe;
192   volatile uint64_t               _safepoint_id;
<span class="line-removed">193   JavaThreadState                 _orig_thread_state;</span>
194 
195   ThreadSafepointState*           _next;
196 
197   void account_safe_thread();
198 
199  public:
200   ThreadSafepointState(JavaThread *thread);
201 
202   // Linked list support:
203   ThreadSafepointState* get_next() const { return _next; }
204   void set_next(ThreadSafepointState* value) { _next = value; }
205   ThreadSafepointState** next_ptr() { return &amp;_next; }
206 
207   // examine/restart
208   void examine_state_of_thread(uint64_t safepoint_count);
209   void restart();
210 
211   // Query
212   JavaThread*  thread() const         { return _thread; }
213   bool         is_running() const     { return !_safepoint_safe; }
214 
215   uint64_t get_safepoint_id() const;
216   void     reset_safepoint_id();
217   void     set_safepoint_id(uint64_t sid);
218 
<span class="line-removed">219   JavaThreadState orig_thread_state() const { return _orig_thread_state; }</span>
<span class="line-removed">220 </span>
221   // Support for safepoint timeout (debugging)
222   bool is_at_poll_safepoint()           { return _at_poll_safepoint; }
223   void set_at_poll_safepoint(bool val)  { _at_poll_safepoint = val; }
224 
225   void handle_polling_page_exception();
226 
227   // debugging
228   void print_on(outputStream* st) const;
<span class="line-removed">229   void print() const                        { print_on(tty); }</span>
230 
231   // Initialize
232   static void create(JavaThread *thread);
233   static void destroy(JavaThread *thread);
234 };
235 
236 class SafepointTracing : public AllStatic {
237 private:
238   // Absolute
239   static jlong _last_safepoint_begin_time_ns;
240   static jlong _last_safepoint_sync_time_ns;
241   static jlong _last_safepoint_cleanup_time_ns;
242   static jlong _last_safepoint_end_time_ns;
<span class="line-modified">243   // amount of ms since epoch</span>
<span class="line-removed">244   static jlong _last_safepoint_end_time_epoch_ms;</span>
245   // Relative
246   static jlong _last_app_time_ns;
247 
248   static int _nof_threads;
249   static int _nof_running;
250   static int _page_trap;
251 
252   static VM_Operation::VMOp_Type _current_type;
253   static jlong     _max_sync_time;
254   static jlong     _max_vmop_time;
255   static uint64_t  _op_count[VM_Operation::VMOp_Terminating];
256 
257   static void statistics_log();
258 
259 public:
260   static void init();
261 
262   static void begin(VM_Operation::VMOp_Type type);
263   static void synchronized(int nof_threads, int nof_running, int traps);
264   static void cleanup();
265   static void end();
266 
267   static void statistics_exit_log();
268 
269   static jlong time_since_last_safepoint_ms() {
<span class="line-modified">270     return (os::javaTimeNanos() - _last_safepoint_end_time_ns) / (NANOUNITS / MILLIUNITS);</span>
271   }
272 
<span class="line-modified">273   static jlong end_of_last_safepoint_epoch_ms() {</span>
<span class="line-modified">274     return _last_safepoint_end_time_epoch_ms;</span>
275   }
276 
277   static jlong start_of_safepoint() {
278     return _last_safepoint_begin_time_ns;
279   }
280 };
281 
282 #endif // SHARE_RUNTIME_SAFEPOINT_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 31 #include &quot;runtime/vmOperations.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 #include &quot;utilities/waitBarrier.hpp&quot;
 34 
 35 //
 36 // Safepoint synchronization
 37 ////
 38 // The VMThread uses the SafepointSynchronize::begin/end
 39 // methods to enter/exit a safepoint region. The begin method will roll
 40 // all JavaThreads forward to a safepoint.
 41 //
 42 // JavaThreads must use the ThreadSafepointState abstraction (defined in
 43 // thread.hpp) to indicate that that they are at a safepoint.
 44 //
 45 // The Mutex/Condition variable and ObjectLocker classes calls the enter/
 46 // exit safepoint methods, when a thread is blocked/restarted. Hence, all mutex exter/
 47 // exit points *must* be at a safepoint.
 48 
 49 class ThreadSafepointState;
 50 
<span class="line-added"> 51 class SafepointStateTracker {</span>
<span class="line-added"> 52   uint64_t _safepoint_id;</span>
<span class="line-added"> 53   bool     _at_safepoint;</span>
<span class="line-added"> 54 public:</span>
<span class="line-added"> 55   SafepointStateTracker(uint64_t safepoint_id, bool at_safepoint);</span>
<span class="line-added"> 56   bool safepoint_state_changed();</span>
<span class="line-added"> 57 };</span>
<span class="line-added"> 58 </span>
 59 //
 60 // Implements roll-forward to safepoint (safepoint synchronization)
 61 //
 62 class SafepointSynchronize : AllStatic {
 63  public:
 64   enum SynchronizeState {
 65       _not_synchronized = 0,                   // Threads not synchronized at a safepoint. Keep this value 0.
 66       _synchronizing    = 1,                   // Synchronizing in progress
 67       _synchronized     = 2                    // All Java threads are running in native, blocked in OS or stopped at safepoint.
 68                                                // VM thread and any NonJavaThread may be running.
 69   };
 70 
 71   // The enums are listed in the order of the tasks when done serially.
 72   enum SafepointCleanupTasks {
 73     SAFEPOINT_CLEANUP_DEFLATE_MONITORS,
 74     SAFEPOINT_CLEANUP_UPDATE_INLINE_CACHES,
 75     SAFEPOINT_CLEANUP_COMPILATION_POLICY,
 76     SAFEPOINT_CLEANUP_SYMBOL_TABLE_REHASH,
 77     SAFEPOINT_CLEANUP_STRING_TABLE_REHASH,

 78     SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE,
<span class="line-added"> 79     SAFEPOINT_CLEANUP_REQUEST_OOPSTORAGE_CLEANUP,</span>
 80     // Leave this one last.
 81     SAFEPOINT_CLEANUP_NUM_TASKS
 82   };
 83 
 84  private:
 85   friend class SafepointMechanism;
 86   friend class ThreadSafepointState;
 87   friend class HandshakeState;
<span class="line-added"> 88   friend class SafepointStateTracker;</span>
 89 
 90   // Threads might read this flag directly, without acquiring the Threads_lock:
 91   static volatile SynchronizeState _state;
 92   // Number of threads we are waiting for to block:
 93   static int              _waiting_to_block;
 94   // Counts the number of active critical natives during the safepoint:
 95   static int              _current_jni_active_count;
 96 
 97   // This counter is used for fast versions of jni_Get&lt;Primitive&gt;Field.
 98   // An even value means there are no ongoing safepoint operations.
 99   // The counter is incremented ONLY at the beginning and end of each
100   // safepoint.
101   static volatile uint64_t _safepoint_counter;
102 
<span class="line-added">103   // A change in this counter or a change in the result of</span>
<span class="line-added">104   // is_at_safepoint() are used by SafepointStateTracker::</span>
<span class="line-added">105   // safepoint_state_changed() to determine its answer.</span>
<span class="line-added">106   static uint64_t _safepoint_id;</span>
<span class="line-added">107 </span>
108   // JavaThreads that need to block for the safepoint will stop on the
109   // _wait_barrier, where they can quickly be started again.
110   static WaitBarrier* _wait_barrier;

111   static julong       _coalesced_vmop_count;     // coalesced vmop count
112 








113   // For debug long safepoint
114   static void print_safepoint_timeout();
115 
116   // Helper methods for safepoint procedure:
117   static void arm_safepoint();
118   static int synchronize_threads(jlong safepoint_limit_time, int nof_threads, int* initial_running);
119   static void disarm_safepoint();
120   static void increment_jni_active_count();
121   static void decrement_waiting_to_block();
<span class="line-added">122   static bool thread_not_running(ThreadSafepointState *cur_state);</span>
123 
124   // Used in safepoint_safe to do a stable load of the thread state.
125   static bool try_stable_load_state(JavaThreadState *state,
126                                     JavaThread *thread,
127                                     uint64_t safepoint_count);
128 
129   // Called when a thread voluntarily blocks
130   static void block(JavaThread *thread);
131 
132   // Called from VMThread during handshakes.
133   // If true the VMThread may safely process the handshake operation for the JavaThread.
134   static bool handshake_safe(JavaThread *thread);
135 
<span class="line-added">136   static uint64_t safepoint_counter()             { return _safepoint_counter; }</span>
<span class="line-added">137 </span>
138 public:
139 
140   static void init(Thread* vmthread);
141 
142   // Roll all threads forward to safepoint. Must be called by the VMThread.
143   static void begin();
144   static void end();                    // Start all suspended threads again...
145 
146   // The value for a not set safepoint id.
147   static const uint64_t InactiveSafepointCounter;
148 
149   // Query
150   static bool is_at_safepoint()                   { return _state == _synchronized; }
151   static bool is_synchronizing()                  { return _state == _synchronizing; }
<span class="line-modified">152 </span>
<span class="line-modified">153   static uint64_t safepoint_id() {</span>
<span class="line-added">154     return _safepoint_id;</span>
<span class="line-added">155   }</span>
<span class="line-added">156 </span>
<span class="line-added">157   static SafepointStateTracker safepoint_state_tracker() {</span>
<span class="line-added">158     return SafepointStateTracker(safepoint_id(), is_at_safepoint());</span>
<span class="line-added">159   }</span>
<span class="line-added">160 </span>
161   // Exception handling for page polling
162   static void handle_polling_page_exception(JavaThread *thread);
163 
164   static bool is_cleanup_needed();
<span class="line-added">165   static bool is_forced_cleanup_needed();</span>
166   static void do_cleanup_tasks();
167 
168   static void set_is_at_safepoint()             { _state = _synchronized; }
169   static void set_is_not_at_safepoint()         { _state = _not_synchronized; }
170 
171   // Assembly support
172   static address address_of_state()             { return (address)&amp;_state; }
173 
174   // Only used for making sure that no safepoint has happened in
175   // JNI_FastGetField. Therefore only the low 32-bits are needed
176   // even if this is a 64-bit counter.
177   static address safepoint_counter_addr() {
178 #ifdef VM_LITTLE_ENDIAN
179     return (address)&amp;_safepoint_counter;
180 #else /* BIG */
181     // Return pointer to the 32 LSB:
182     return (address) (((uint32_t*)(&amp;_safepoint_counter)) + 1);
183 #endif
184   }
185 };
</pre>
<hr />
<pre>
189 #define assert_at_safepoint()                                           \
190   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;)
191 
192 #define assert_at_safepoint_msg(...)                                    \
193   assert(SafepointSynchronize::is_at_safepoint(), __VA_ARGS__)
194 
195 #define assert_not_at_safepoint()                                       \
196   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;)
197 
198 #define assert_not_at_safepoint_msg(...)                                \
199   assert(!SafepointSynchronize::is_at_safepoint(), __VA_ARGS__)
200 
201 // State class for a thread suspended at a safepoint
202 class ThreadSafepointState: public CHeapObj&lt;mtThread&gt; {
203  private:
204   // At polling page safepoint (NOT a poll return safepoint):
205   volatile bool                   _at_poll_safepoint;
206   JavaThread*                     _thread;
207   bool                            _safepoint_safe;
208   volatile uint64_t               _safepoint_id;

209 
210   ThreadSafepointState*           _next;
211 
212   void account_safe_thread();
213 
214  public:
215   ThreadSafepointState(JavaThread *thread);
216 
217   // Linked list support:
218   ThreadSafepointState* get_next() const { return _next; }
219   void set_next(ThreadSafepointState* value) { _next = value; }
220   ThreadSafepointState** next_ptr() { return &amp;_next; }
221 
222   // examine/restart
223   void examine_state_of_thread(uint64_t safepoint_count);
224   void restart();
225 
226   // Query
227   JavaThread*  thread() const         { return _thread; }
228   bool         is_running() const     { return !_safepoint_safe; }
229 
230   uint64_t get_safepoint_id() const;
231   void     reset_safepoint_id();
232   void     set_safepoint_id(uint64_t sid);
233 


234   // Support for safepoint timeout (debugging)
235   bool is_at_poll_safepoint()           { return _at_poll_safepoint; }
236   void set_at_poll_safepoint(bool val)  { _at_poll_safepoint = val; }
237 
238   void handle_polling_page_exception();
239 
240   // debugging
241   void print_on(outputStream* st) const;

242 
243   // Initialize
244   static void create(JavaThread *thread);
245   static void destroy(JavaThread *thread);
246 };
247 
248 class SafepointTracing : public AllStatic {
249 private:
250   // Absolute
251   static jlong _last_safepoint_begin_time_ns;
252   static jlong _last_safepoint_sync_time_ns;
253   static jlong _last_safepoint_cleanup_time_ns;
254   static jlong _last_safepoint_end_time_ns;
<span class="line-modified">255 </span>

256   // Relative
257   static jlong _last_app_time_ns;
258 
259   static int _nof_threads;
260   static int _nof_running;
261   static int _page_trap;
262 
263   static VM_Operation::VMOp_Type _current_type;
264   static jlong     _max_sync_time;
265   static jlong     _max_vmop_time;
266   static uint64_t  _op_count[VM_Operation::VMOp_Terminating];
267 
268   static void statistics_log();
269 
270 public:
271   static void init();
272 
273   static void begin(VM_Operation::VMOp_Type type);
274   static void synchronized(int nof_threads, int nof_running, int traps);
275   static void cleanup();
276   static void end();
277 
278   static void statistics_exit_log();
279 
280   static jlong time_since_last_safepoint_ms() {
<span class="line-modified">281     return nanos_to_millis(os::javaTimeNanos() - _last_safepoint_end_time_ns);</span>
282   }
283 
<span class="line-modified">284   static jlong end_of_last_safepoint_ms() {</span>
<span class="line-modified">285     return nanos_to_millis(_last_safepoint_end_time_ns);</span>
286   }
287 
288   static jlong start_of_safepoint() {
289     return _last_safepoint_begin_time_ns;
290   }
291 };
292 
293 #endif // SHARE_RUNTIME_SAFEPOINT_HPP
</pre>
</td>
</tr>
</table>
<center><a href="safepoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepointMechanism.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
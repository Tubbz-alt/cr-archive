<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/orderAccess.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="objectMonitor.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/orderAccess.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_ORDERACCESS_HPP
 26 #define SHARE_RUNTIME_ORDERACCESS_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
<span class="line-removed"> 29 #include &quot;runtime/atomic.hpp&quot;</span>
 30 #include &quot;utilities/macros.hpp&quot;
 31 
 32 //                Memory Access Ordering Model
 33 //
 34 // This interface is based on the JSR-133 Cookbook for Compiler Writers.
 35 //
 36 // In the following, the terms &#39;previous&#39;, &#39;subsequent&#39;, &#39;before&#39;,
 37 // &#39;after&#39;, &#39;preceding&#39; and &#39;succeeding&#39; refer to program order.  The
 38 // terms &#39;down&#39; and &#39;below&#39; refer to forward load or store motion
 39 // relative to program order, while &#39;up&#39; and &#39;above&#39; refer to backward
 40 // motion.
 41 //
 42 // We define four primitive memory barrier operations.
 43 //
 44 // LoadLoad:   Load1(s); LoadLoad; Load2
 45 //
 46 // Ensures that Load1 completes (obtains the value it loads from memory)
 47 // before Load2 and any subsequent load operations.  Loads before Load1
 48 // may *not* float below Load2 and any subsequent load operations.
 49 //
</pre>
<hr />
<pre>
214 // Either of these alternatives is a pain, so no current machine we know of
215 // has incoherent caches.
216 //
217 // If loadload didn&#39;t have these properties, the store-release sequence for
218 // publishing a shared data structure wouldn&#39;t work, because a processor
219 // trying to read data newly published by another processor might go to
220 // its own incoherent caches to satisfy the read instead of to the newly
221 // written shared memory.
222 //
223 //
224 //                NOTE WELL!!
225 //
226 //                A Note on MutexLocker and Friends
227 //
228 // See mutexLocker.hpp.  We assume throughout the VM that MutexLocker&#39;s
229 // and friends&#39; constructors do a fence, a lock and an acquire *in that
230 // order*.  And that their destructors do a release and unlock, in *that*
231 // order.  If their implementations change such that these assumptions
232 // are violated, a whole lot of code will break.
233 
<span class="line-modified">234 enum ScopedFenceType {</span>
<span class="line-removed">235     X_ACQUIRE</span>
<span class="line-removed">236   , RELEASE_X</span>
<span class="line-removed">237   , RELEASE_X_FENCE</span>
<span class="line-removed">238 };</span>
<span class="line-removed">239 </span>
<span class="line-removed">240 template &lt;ScopedFenceType T&gt;</span>
<span class="line-removed">241 class ScopedFenceGeneral: public StackObj {</span>
<span class="line-removed">242  public:</span>
<span class="line-removed">243   void prefix() {}</span>
<span class="line-removed">244   void postfix() {}</span>
<span class="line-removed">245 };</span>
<span class="line-removed">246 </span>
<span class="line-removed">247 template &lt;ScopedFenceType T&gt;</span>
<span class="line-removed">248 class ScopedFence : public ScopedFenceGeneral&lt;T&gt; {</span>
<span class="line-removed">249   void *const _field;</span>
<span class="line-removed">250  public:</span>
<span class="line-removed">251   ScopedFence(void *const field) : _field(field) { prefix(); }</span>
<span class="line-removed">252   ~ScopedFence() { postfix(); }</span>
<span class="line-removed">253   void prefix() { ScopedFenceGeneral&lt;T&gt;::prefix(); }</span>
<span class="line-removed">254   void postfix() { ScopedFenceGeneral&lt;T&gt;::postfix(); }</span>
<span class="line-removed">255 };</span>
<span class="line-removed">256 </span>
<span class="line-removed">257 class OrderAccess : private Atomic {</span>
258  public:
259   // barriers
260   static void     loadload();
261   static void     storestore();
262   static void     loadstore();
263   static void     storeload();
264 
265   static void     acquire();
266   static void     release();
267   static void     fence();
268 
<span class="line-modified">269   template &lt;typename T&gt;</span>
<span class="line-modified">270   static T        load_acquire(const volatile T* p);</span>
<span class="line-removed">271 </span>
<span class="line-removed">272   template &lt;typename T, typename D&gt;</span>
<span class="line-removed">273   static void     release_store(volatile D* p, T v);</span>
<span class="line-removed">274 </span>
<span class="line-removed">275   template &lt;typename T, typename D&gt;</span>
<span class="line-removed">276   static void     release_store_fence(volatile D* p, T v);</span>
<span class="line-removed">277 </span>
<span class="line-removed">278  private:</span>
279   // This is a helper that invokes the StubRoutines::fence_entry()
280   // routine if it exists, It should only be used by platforms that
281   // don&#39;t have another way to do the inline assembly.
282   static void StubRoutines_fence();
<span class="line-removed">283 </span>
<span class="line-removed">284   // Give platforms a variation point to specialize.</span>
<span class="line-removed">285   template&lt;size_t byte_size, ScopedFenceType type&gt; struct PlatformOrderedStore;</span>
<span class="line-removed">286   template&lt;size_t byte_size, ScopedFenceType type&gt; struct PlatformOrderedLoad;</span>
<span class="line-removed">287 </span>
<span class="line-removed">288   template&lt;typename FieldType, ScopedFenceType FenceType&gt;</span>
<span class="line-removed">289   static void ordered_store(volatile FieldType* p, FieldType v);</span>
<span class="line-removed">290 </span>
<span class="line-removed">291   template&lt;typename FieldType, ScopedFenceType FenceType&gt;</span>
<span class="line-removed">292   static FieldType ordered_load(const volatile FieldType* p);</span>
<span class="line-removed">293 };</span>
<span class="line-removed">294 </span>
<span class="line-removed">295 // The following methods can be specialized using simple template specialization</span>
<span class="line-removed">296 // in the platform specific files for optimization purposes. Otherwise the</span>
<span class="line-removed">297 // generalized variant is used.</span>
<span class="line-removed">298 </span>
<span class="line-removed">299 template&lt;size_t byte_size, ScopedFenceType type&gt;</span>
<span class="line-removed">300 struct OrderAccess::PlatformOrderedStore {</span>
<span class="line-removed">301   template &lt;typename T&gt;</span>
<span class="line-removed">302   void operator()(T v, volatile T* p) const {</span>
<span class="line-removed">303     ordered_store&lt;T, type&gt;(p, v);</span>
<span class="line-removed">304   }</span>
<span class="line-removed">305 };</span>
<span class="line-removed">306 </span>
<span class="line-removed">307 template&lt;size_t byte_size, ScopedFenceType type&gt;</span>
<span class="line-removed">308 struct OrderAccess::PlatformOrderedLoad {</span>
<span class="line-removed">309   template &lt;typename T&gt;</span>
<span class="line-removed">310   T operator()(const volatile T* p) const {</span>
<span class="line-removed">311     return ordered_load&lt;T, type&gt;(p);</span>
<span class="line-removed">312   }</span>
313 };
314 
315 #include OS_CPU_HEADER(orderAccess)
316 
<span class="line-removed">317 template&lt;&gt; inline void ScopedFenceGeneral&lt;X_ACQUIRE&gt;::postfix()       { OrderAccess::acquire(); }</span>
<span class="line-removed">318 template&lt;&gt; inline void ScopedFenceGeneral&lt;RELEASE_X&gt;::prefix()        { OrderAccess::release(); }</span>
<span class="line-removed">319 template&lt;&gt; inline void ScopedFenceGeneral&lt;RELEASE_X_FENCE&gt;::prefix()  { OrderAccess::release(); }</span>
<span class="line-removed">320 template&lt;&gt; inline void ScopedFenceGeneral&lt;RELEASE_X_FENCE&gt;::postfix() { OrderAccess::fence();   }</span>
<span class="line-removed">321 </span>
<span class="line-removed">322 </span>
<span class="line-removed">323 template &lt;typename FieldType, ScopedFenceType FenceType&gt;</span>
<span class="line-removed">324 inline void OrderAccess::ordered_store(volatile FieldType* p, FieldType v) {</span>
<span class="line-removed">325   ScopedFence&lt;FenceType&gt; f((void*)p);</span>
<span class="line-removed">326   Atomic::store(v, p);</span>
<span class="line-removed">327 }</span>
<span class="line-removed">328 </span>
<span class="line-removed">329 template &lt;typename FieldType, ScopedFenceType FenceType&gt;</span>
<span class="line-removed">330 inline FieldType OrderAccess::ordered_load(const volatile FieldType* p) {</span>
<span class="line-removed">331   ScopedFence&lt;FenceType&gt; f((void*)p);</span>
<span class="line-removed">332   return Atomic::load(p);</span>
<span class="line-removed">333 }</span>
<span class="line-removed">334 </span>
<span class="line-removed">335 template &lt;typename T&gt;</span>
<span class="line-removed">336 inline T OrderAccess::load_acquire(const volatile T* p) {</span>
<span class="line-removed">337   return LoadImpl&lt;T, PlatformOrderedLoad&lt;sizeof(T), X_ACQUIRE&gt; &gt;()(p);</span>
<span class="line-removed">338 }</span>
<span class="line-removed">339 </span>
<span class="line-removed">340 template &lt;typename T, typename D&gt;</span>
<span class="line-removed">341 inline void OrderAccess::release_store(volatile D* p, T v) {</span>
<span class="line-removed">342   StoreImpl&lt;T, D, PlatformOrderedStore&lt;sizeof(D), RELEASE_X&gt; &gt;()(v, p);</span>
<span class="line-removed">343 }</span>
<span class="line-removed">344 </span>
<span class="line-removed">345 template &lt;typename T, typename D&gt;</span>
<span class="line-removed">346 inline void OrderAccess::release_store_fence(volatile D* p, T v) {</span>
<span class="line-removed">347   StoreImpl&lt;T, D, PlatformOrderedStore&lt;sizeof(D), RELEASE_X_FENCE&gt; &gt;()(v, p);</span>
<span class="line-removed">348 }</span>
349 #endif // SHARE_RUNTIME_ORDERACCESS_HPP
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_ORDERACCESS_HPP
 26 #define SHARE_RUNTIME_ORDERACCESS_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;

 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 //                Memory Access Ordering Model
 32 //
 33 // This interface is based on the JSR-133 Cookbook for Compiler Writers.
 34 //
 35 // In the following, the terms &#39;previous&#39;, &#39;subsequent&#39;, &#39;before&#39;,
 36 // &#39;after&#39;, &#39;preceding&#39; and &#39;succeeding&#39; refer to program order.  The
 37 // terms &#39;down&#39; and &#39;below&#39; refer to forward load or store motion
 38 // relative to program order, while &#39;up&#39; and &#39;above&#39; refer to backward
 39 // motion.
 40 //
 41 // We define four primitive memory barrier operations.
 42 //
 43 // LoadLoad:   Load1(s); LoadLoad; Load2
 44 //
 45 // Ensures that Load1 completes (obtains the value it loads from memory)
 46 // before Load2 and any subsequent load operations.  Loads before Load1
 47 // may *not* float below Load2 and any subsequent load operations.
 48 //
</pre>
<hr />
<pre>
213 // Either of these alternatives is a pain, so no current machine we know of
214 // has incoherent caches.
215 //
216 // If loadload didn&#39;t have these properties, the store-release sequence for
217 // publishing a shared data structure wouldn&#39;t work, because a processor
218 // trying to read data newly published by another processor might go to
219 // its own incoherent caches to satisfy the read instead of to the newly
220 // written shared memory.
221 //
222 //
223 //                NOTE WELL!!
224 //
225 //                A Note on MutexLocker and Friends
226 //
227 // See mutexLocker.hpp.  We assume throughout the VM that MutexLocker&#39;s
228 // and friends&#39; constructors do a fence, a lock and an acquire *in that
229 // order*.  And that their destructors do a release and unlock, in *that*
230 // order.  If their implementations change such that these assumptions
231 // are violated, a whole lot of code will break.
232 
<span class="line-modified">233 class OrderAccess : public AllStatic {</span>























234  public:
235   // barriers
236   static void     loadload();
237   static void     storestore();
238   static void     loadstore();
239   static void     storeload();
240 
241   static void     acquire();
242   static void     release();
243   static void     fence();
244 
<span class="line-modified">245   static void     cross_modify_fence();</span>
<span class="line-modified">246 private:</span>








247   // This is a helper that invokes the StubRoutines::fence_entry()
248   // routine if it exists, It should only be used by platforms that
249   // don&#39;t have another way to do the inline assembly.
250   static void StubRoutines_fence();






























251 };
252 
253 #include OS_CPU_HEADER(orderAccess)
254 
































255 #endif // SHARE_RUNTIME_ORDERACCESS_HPP
</pre>
</td>
</tr>
</table>
<center><a href="objectMonitor.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
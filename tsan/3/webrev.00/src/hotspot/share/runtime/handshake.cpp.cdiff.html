<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/handshake.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="handles.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="handshake.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/handshake.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,17 ***</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;runtime/handshake.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/osThread.hpp&quot;
  #include &quot;runtime/semaphore.inline.hpp&quot;
  #include &quot;runtime/task.hpp&quot;
<span class="line-removed">- #include &quot;runtime/timerTrace.hpp&quot;</span>
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;utilities/formatBuffer.hpp&quot;
  #include &quot;utilities/preserveException.hpp&quot;
  
<span class="line-new-header">--- 24,16 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/handshake.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/osThread.hpp&quot;
  #include &quot;runtime/semaphore.inline.hpp&quot;
  #include &quot;runtime/task.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;utilities/formatBuffer.hpp&quot;
  #include &quot;utilities/preserveException.hpp&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,16 ***</span>
    virtual void do_handshake(JavaThread* thread) = 0;
  };
  
  class HandshakeThreadsOperation: public HandshakeOperation {
    static Semaphore _done;
<span class="line-modified">!   ThreadClosure* _thread_cl;</span>
<span class="line-modified">! </span>
  public:
<span class="line-modified">!   HandshakeThreadsOperation(ThreadClosure* cl) : _thread_cl(cl) {}</span>
    void do_handshake(JavaThread* thread);
    bool thread_has_completed() { return _done.trywait(); }
  
  #ifdef ASSERT
    void check_state() {
      assert(!_done.trywait(), &quot;Must be zero&quot;);
    }
<span class="line-new-header">--- 42,18 ---</span>
    virtual void do_handshake(JavaThread* thread) = 0;
  };
  
  class HandshakeThreadsOperation: public HandshakeOperation {
    static Semaphore _done;
<span class="line-modified">!   HandshakeClosure* _handshake_cl;</span>
<span class="line-modified">!   bool _executed;</span>
  public:
<span class="line-modified">!   HandshakeThreadsOperation(HandshakeClosure* cl) : _handshake_cl(cl), _executed(false) {}</span>
    void do_handshake(JavaThread* thread);
    bool thread_has_completed() { return _done.trywait(); }
<span class="line-added">+   bool executed() const { return _executed; }</span>
<span class="line-added">+   const char* name() { return _handshake_cl-&gt;name(); }</span>
  
  #ifdef ASSERT
    void check_state() {
      assert(!_done.trywait(), &quot;Must be zero&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,12 ***</span>
  class VM_Handshake: public VM_Operation {
    const jlong _handshake_timeout;
   public:
    bool evaluate_at_safepoint() const { return false; }
  
<span class="line-removed">-   bool evaluate_concurrently() const { return false; }</span>
<span class="line-removed">- </span>
   protected:
    HandshakeThreadsOperation* const _op;
  
    VM_Handshake(HandshakeThreadsOperation* op) :
        _handshake_timeout(TimeHelper::millis_to_counter(HandshakeTimeout)), _op(op) {}
<span class="line-new-header">--- 65,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,73 ***</span>
    }
    log_stream.flush();
    fatal(&quot;Handshake operation timed out&quot;);
  }
  
  class VM_HandshakeOneThread: public VM_Handshake {
    JavaThread* _target;
<span class="line-removed">-   bool _thread_alive;</span>
   public:
    VM_HandshakeOneThread(HandshakeThreadsOperation* op, JavaThread* target) :
<span class="line-modified">!     VM_Handshake(op), _target(target), _thread_alive(false) {}</span>
  
    void doit() {
      DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-modified">!     TraceTime timer(&quot;Performing single-target operation (vmoperation doit)&quot;, TRACETIME_LOG(Info, handshake));</span>
  
      ThreadsListHandle tlh;
      if (tlh.includes(_target)) {
        set_handshake(_target);
<span class="line-removed">-       _thread_alive = true;</span>
      } else {
        return;
      }
  
<span class="line-modified">!     log_trace(handshake)(&quot;Thread signaled, begin processing by VMThtread&quot;);</span>
<span class="line-modified">!     jlong start_time = os::elapsed_counter();</span>
      do {
<span class="line-modified">!       if (handshake_has_timed_out(start_time)) {</span>
          handle_timeout();
        }
<span class="line-modified">! </span>
<span class="line-removed">-       // We need to re-think this with SMR ThreadsList.</span>
<span class="line-removed">-       // There is an assumption in the code that the Threads_lock should be</span>
<span class="line-removed">-       // locked during certain phases.</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         MutexLockerEx ml(Threads_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">-         _target-&gt;handshake_process_by_vmthread();</span>
<span class="line-removed">-       }</span>
      } while (!poll_for_completed_thread());
      DEBUG_ONLY(_op-&gt;check_state();)
    }
  
    VMOp_Type type() const { return VMOp_HandshakeOneThread; }
  
<span class="line-modified">!   bool thread_alive() const { return _thread_alive; }</span>
  };
  
  class VM_HandshakeAllThreads: public VM_Handshake {
   public:
    VM_HandshakeAllThreads(HandshakeThreadsOperation* op) : VM_Handshake(op) {}
  
    void doit() {
      DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-modified">!     TraceTime timer(&quot;Performing operation (vmoperation doit)&quot;, TRACETIME_LOG(Info, handshake));</span>
  
      JavaThreadIteratorWithHandle jtiwh;
      int number_of_threads_issued = 0;
      for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
        set_handshake(thr);
        number_of_threads_issued++;
      }
  
      if (number_of_threads_issued &lt; 1) {
<span class="line-modified">!       log_debug(handshake)(&quot;No threads to handshake.&quot;);</span>
        return;
      }
  
<span class="line-modified">!     log_debug(handshake)(&quot;Threads signaled, begin processing blocked threads by VMThtread&quot;);</span>
      const jlong start_time = os::elapsed_counter();
      int number_of_threads_completed = 0;
      do {
        // Check if handshake operation has timed out
        if (handshake_has_timed_out(start_time)) {
<span class="line-new-header">--- 104,88 ---</span>
    }
    log_stream.flush();
    fatal(&quot;Handshake operation timed out&quot;);
  }
  
<span class="line-added">+ static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int vmt_executed, const char* extra = NULL) {</span>
<span class="line-added">+   if (start_time_ns != 0) {</span>
<span class="line-added">+     jlong completion_time = os::javaTimeNanos() - start_time_ns;</span>
<span class="line-added">+     log_info(handshake)(&quot;Handshake \&quot;%s\&quot;, Targeted threads: %d, Executed by targeted threads: %d, Total completion time: &quot; JLONG_FORMAT &quot; ns%s%s&quot;,</span>
<span class="line-added">+                         name, targets,</span>
<span class="line-added">+                         targets - vmt_executed,</span>
<span class="line-added">+                         completion_time,</span>
<span class="line-added">+                         extra != NULL ? &quot;, &quot; : &quot;&quot;,</span>
<span class="line-added">+                         extra != NULL ? extra : &quot;&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class VM_HandshakeOneThread: public VM_Handshake {
    JavaThread* _target;
   public:
    VM_HandshakeOneThread(HandshakeThreadsOperation* op, JavaThread* target) :
<span class="line-modified">!     VM_Handshake(op), _target(target) {}</span>
  
    void doit() {
      DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-modified">! </span>
<span class="line-added">+     jlong start_time_ns = 0;</span>
<span class="line-added">+     if (log_is_enabled(Info, handshake)) {</span>
<span class="line-added">+       start_time_ns = os::javaTimeNanos();</span>
<span class="line-added">+     }</span>
  
      ThreadsListHandle tlh;
      if (tlh.includes(_target)) {
        set_handshake(_target);
      } else {
<span class="line-added">+       log_handshake_info(start_time_ns, _op-&gt;name(), 0, 0, &quot;(thread dead)&quot;);</span>
        return;
      }
  
<span class="line-modified">!     log_trace(handshake)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; signaled, begin attempt to process by VMThtread&quot;, p2i(_target));</span>
<span class="line-modified">!     jlong timeout_start_time = os::elapsed_counter();</span>
<span class="line-added">+     bool by_vm_thread = false;</span>
      do {
<span class="line-modified">!       if (handshake_has_timed_out(timeout_start_time)) {</span>
          handle_timeout();
        }
<span class="line-modified">!       by_vm_thread = _target-&gt;handshake_try_process_by_vmThread();</span>
      } while (!poll_for_completed_thread());
      DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-added">+     log_handshake_info(start_time_ns, _op-&gt;name(), 1, by_vm_thread ? 1 : 0);</span>
    }
  
    VMOp_Type type() const { return VMOp_HandshakeOneThread; }
  
<span class="line-modified">!   bool executed() const { return _op-&gt;executed(); }</span>
  };
  
  class VM_HandshakeAllThreads: public VM_Handshake {
   public:
    VM_HandshakeAllThreads(HandshakeThreadsOperation* op) : VM_Handshake(op) {}
  
    void doit() {
      DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-modified">! </span>
<span class="line-added">+     jlong start_time_ns = 0;</span>
<span class="line-added">+     if (log_is_enabled(Info, handshake)) {</span>
<span class="line-added">+       start_time_ns = os::javaTimeNanos();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     int handshake_executed_by_vm_thread = 0;</span>
  
      JavaThreadIteratorWithHandle jtiwh;
      int number_of_threads_issued = 0;
      for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
        set_handshake(thr);
        number_of_threads_issued++;
      }
  
      if (number_of_threads_issued &lt; 1) {
<span class="line-modified">!       log_handshake_info(start_time_ns, _op-&gt;name(), 0, 0);</span>
        return;
      }
  
<span class="line-modified">!     log_trace(handshake)(&quot;Threads signaled, begin processing blocked threads by VMThread&quot;);</span>
      const jlong start_time = os::elapsed_counter();
      int number_of_threads_completed = 0;
      do {
        // Check if handshake operation has timed out
        if (handshake_has_timed_out(start_time)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 179,143 ***</span>
        }
  
        // Have VM thread perform the handshake operation for blocked threads.
        // Observing a blocked state may of course be transient but the processing is guarded
        // by semaphores and we optimistically begin by working on the blocked threads
<span class="line-modified">!       {</span>
<span class="line-modified">!           // We need to re-think this with SMR ThreadsList.</span>
<span class="line-modified">!           // There is an assumption in the code that the Threads_lock should</span>
<span class="line-modified">!           // be locked during certain phases.</span>
<span class="line-modified">!           jtiwh.rewind();</span>
<span class="line-modified">!           MutexLockerEx ml(Threads_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!           for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {</span>
<span class="line-removed">-             // A new thread on the ThreadsList will not have an operation,</span>
<span class="line-removed">-             // hence it is skipped in handshake_process_by_vmthread.</span>
<span class="line-removed">-             thr-&gt;handshake_process_by_vmthread();</span>
<span class="line-removed">-           }</span>
        }
<span class="line-removed">- </span>
        while (poll_for_completed_thread()) {
          // Includes canceled operations by exiting threads.
          number_of_threads_completed++;
        }
  
      } while (number_of_threads_issued &gt; number_of_threads_completed);
      assert(number_of_threads_issued == number_of_threads_completed, &quot;Must be the same&quot;);
      DEBUG_ONLY(_op-&gt;check_state();)
    }
  
    VMOp_Type type() const { return VMOp_HandshakeAllThreads; }
  };
  
  class VM_HandshakeFallbackOperation : public VM_Operation {
<span class="line-modified">!   ThreadClosure* _thread_cl;</span>
    Thread* _target_thread;
    bool _all_threads;
<span class="line-modified">!   bool _thread_alive;</span>
  public:
<span class="line-modified">!   VM_HandshakeFallbackOperation(ThreadClosure* cl) :</span>
<span class="line-modified">!       _thread_cl(cl), _target_thread(NULL), _all_threads(true), _thread_alive(true) {}</span>
<span class="line-modified">!   VM_HandshakeFallbackOperation(ThreadClosure* cl, Thread* target) :</span>
<span class="line-modified">!       _thread_cl(cl), _target_thread(target), _all_threads(false), _thread_alive(false) {}</span>
  
    void doit() {
      for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
        if (_all_threads || t == _target_thread) {
          if (t == _target_thread) {
<span class="line-modified">!           _thread_alive = true;</span>
          }
<span class="line-modified">!         _thread_cl-&gt;do_thread(t);</span>
        }
      }
    }
  
    VMOp_Type type() const { return VMOp_HandshakeFallback; }
<span class="line-modified">!   bool thread_alive() const { return _thread_alive; }</span>
  };
  
  void HandshakeThreadsOperation::do_handshake(JavaThread* thread) {
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   FormatBufferResource message(&quot;Operation for thread &quot; PTR_FORMAT &quot;, is_vm_thread: %s&quot;,</span>
<span class="line-modified">!                                p2i(thread), BOOL_TO_STR(Thread::current()-&gt;is_VM_thread()));</span>
<span class="line-modified">!   TraceTime timer(message, TRACETIME_LOG(Debug, handshake, task));</span>
  
    // Only actually execute the operation for non terminated threads.
    if (!thread-&gt;is_terminated()) {
<span class="line-modified">!     _thread_cl-&gt;do_thread(thread);</span>
    }
  
    // Use the semaphore to inform the VM thread that we have completed the operation
    _done.signal();
  }
  
<span class="line-modified">! void Handshake::execute(ThreadClosure* thread_cl) {</span>
<span class="line-modified">!   if (ThreadLocalHandshakes) {</span>
      HandshakeThreadsOperation cto(thread_cl);
      VM_HandshakeAllThreads handshake(&amp;cto);
      VMThread::execute(&amp;handshake);
    } else {
      VM_HandshakeFallbackOperation op(thread_cl);
      VMThread::execute(&amp;op);
    }
  }
  
<span class="line-modified">! bool Handshake::execute(ThreadClosure* thread_cl, JavaThread* target) {</span>
<span class="line-modified">!   if (ThreadLocalHandshakes) {</span>
      HandshakeThreadsOperation cto(thread_cl);
      VM_HandshakeOneThread handshake(&amp;cto, target);
      VMThread::execute(&amp;handshake);
<span class="line-modified">!     return handshake.thread_alive();</span>
    } else {
      VM_HandshakeFallbackOperation op(thread_cl, target);
      VMThread::execute(&amp;op);
<span class="line-modified">!     return op.thread_alive();</span>
    }
  }
  
<span class="line-modified">! HandshakeState::HandshakeState() : _operation(NULL), _semaphore(1), _thread_in_process_handshake(false) {}</span>
  
  void HandshakeState::set_operation(JavaThread* target, HandshakeOperation* op) {
    _operation = op;
    SafepointMechanism::arm_local_poll_release(target);
  }
  
  void HandshakeState::clear_handshake(JavaThread* target) {
    _operation = NULL;
<span class="line-modified">!   SafepointMechanism::disarm_local_poll_release(target);</span>
  }
  
  void HandshakeState::process_self_inner(JavaThread* thread) {
    assert(Thread::current() == thread, &quot;should call from thread&quot;);
    assert(!thread-&gt;is_terminated(), &quot;should not be a terminated thread&quot;);
  
<span class="line-modified">!   ThreadInVMForHandshake tivm(thread);</span>
<span class="line-modified">!   if (!_semaphore.trywait()) {</span>
<span class="line-modified">!     _semaphore.wait_with_safepoint_check(thread);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   HandshakeOperation* op = OrderAccess::load_acquire(&amp;_operation);</span>
<span class="line-modified">!   if (op != NULL) {</span>
<span class="line-modified">!     HandleMark hm(thread);</span>
<span class="line-modified">!     CautiouslyPreserveExceptionMark pem(thread);</span>
<span class="line-modified">!     // Disarm before execute the operation</span>
<span class="line-modified">!     clear_handshake(thread);</span>
<span class="line-modified">!     op-&gt;do_handshake(thread);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   _semaphore.signal();</span>
  }
  
  bool HandshakeState::vmthread_can_process_handshake(JavaThread* target) {
    // handshake_safe may only be called with polls armed.
    // VM thread controls this by first claiming the handshake via claim_handshake_for_vmthread.
    return SafepointSynchronize::handshake_safe(target);
  }
  
  static bool possibly_vmthread_can_process_handshake(JavaThread* target) {
<span class="line-removed">-   // An externally suspended thread cannot be resumed while the</span>
<span class="line-removed">-   // Threads_lock is held so it is safe.</span>
    // Note that this method is allowed to produce false positives.
<span class="line-removed">-   assert(Threads_lock-&gt;owned_by_self(), &quot;Not holding Threads_lock.&quot;);</span>
    if (target-&gt;is_ext_suspended()) {
      return true;
    }
    if (target-&gt;is_terminated()) {
      return true;
<span class="line-new-header">--- 193,153 ---</span>
        }
  
        // Have VM thread perform the handshake operation for blocked threads.
        // Observing a blocked state may of course be transient but the processing is guarded
        // by semaphores and we optimistically begin by working on the blocked threads
<span class="line-modified">!       jtiwh.rewind();</span>
<span class="line-modified">!       for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {</span>
<span class="line-modified">!         // A new thread on the ThreadsList will not have an operation,</span>
<span class="line-modified">!         // hence it is skipped in handshake_process_by_vmthread.</span>
<span class="line-modified">!         if (thr-&gt;handshake_try_process_by_vmThread()) {</span>
<span class="line-modified">!           handshake_executed_by_vm_thread++;</span>
<span class="line-modified">!         }</span>
        }
        while (poll_for_completed_thread()) {
          // Includes canceled operations by exiting threads.
          number_of_threads_completed++;
        }
  
      } while (number_of_threads_issued &gt; number_of_threads_completed);
      assert(number_of_threads_issued == number_of_threads_completed, &quot;Must be the same&quot;);
      DEBUG_ONLY(_op-&gt;check_state();)
<span class="line-added">+ </span>
<span class="line-added">+     log_handshake_info(start_time_ns, _op-&gt;name(), number_of_threads_issued, handshake_executed_by_vm_thread);</span>
    }
  
    VMOp_Type type() const { return VMOp_HandshakeAllThreads; }
  };
  
  class VM_HandshakeFallbackOperation : public VM_Operation {
<span class="line-modified">!   HandshakeClosure* _handshake_cl;</span>
    Thread* _target_thread;
    bool _all_threads;
<span class="line-modified">!   bool _executed;</span>
  public:
<span class="line-modified">!   VM_HandshakeFallbackOperation(HandshakeClosure* cl) :</span>
<span class="line-modified">!       _handshake_cl(cl), _target_thread(NULL), _all_threads(true), _executed(false) {}</span>
<span class="line-modified">!   VM_HandshakeFallbackOperation(HandshakeClosure* cl, Thread* target) :</span>
<span class="line-modified">!       _handshake_cl(cl), _target_thread(target), _all_threads(false), _executed(false) {}</span>
  
    void doit() {
<span class="line-added">+     log_trace(handshake)(&quot;VMThread executing VM_HandshakeFallbackOperation, operation: %s&quot;, name());</span>
      for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
        if (_all_threads || t == _target_thread) {
          if (t == _target_thread) {
<span class="line-modified">!           _executed = true;</span>
          }
<span class="line-modified">!         _handshake_cl-&gt;do_thread(t);</span>
        }
      }
    }
  
    VMOp_Type type() const { return VMOp_HandshakeFallback; }
<span class="line-modified">!   bool executed() const { return _executed; }</span>
  };
  
  void HandshakeThreadsOperation::do_handshake(JavaThread* thread) {
<span class="line-modified">!   jlong start_time_ns = 0;</span>
<span class="line-modified">!   if (log_is_enabled(Debug, handshake, task)) {</span>
<span class="line-modified">!     start_time_ns = os::javaTimeNanos();</span>
<span class="line-modified">!   }</span>
  
    // Only actually execute the operation for non terminated threads.
    if (!thread-&gt;is_terminated()) {
<span class="line-modified">!     _handshake_cl-&gt;do_thread(thread);</span>
<span class="line-added">+     _executed = true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (start_time_ns != 0) {</span>
<span class="line-added">+     jlong completion_time = os::javaTimeNanos() - start_time_ns;</span>
<span class="line-added">+     log_debug(handshake, task)(&quot;Operation: %s for thread &quot; PTR_FORMAT &quot;, is_vm_thread: %s, completed in &quot; JLONG_FORMAT &quot; ns&quot;,</span>
<span class="line-added">+                                name(), p2i(thread), BOOL_TO_STR(Thread::current()-&gt;is_VM_thread()), completion_time);</span>
    }
  
    // Use the semaphore to inform the VM thread that we have completed the operation
    _done.signal();
<span class="line-added">+ </span>
<span class="line-added">+   // It is no longer safe to refer to &#39;this&#39; as the VMThread may have destroyed this operation</span>
  }
  
<span class="line-modified">! void Handshake::execute(HandshakeClosure* thread_cl) {</span>
<span class="line-modified">!   if (SafepointMechanism::uses_thread_local_poll()) {</span>
      HandshakeThreadsOperation cto(thread_cl);
      VM_HandshakeAllThreads handshake(&amp;cto);
      VMThread::execute(&amp;handshake);
    } else {
      VM_HandshakeFallbackOperation op(thread_cl);
      VMThread::execute(&amp;op);
    }
  }
  
<span class="line-modified">! bool Handshake::execute(HandshakeClosure* thread_cl, JavaThread* target) {</span>
<span class="line-modified">!   if (SafepointMechanism::uses_thread_local_poll()) {</span>
      HandshakeThreadsOperation cto(thread_cl);
      VM_HandshakeOneThread handshake(&amp;cto, target);
      VMThread::execute(&amp;handshake);
<span class="line-modified">!     return handshake.executed();</span>
    } else {
      VM_HandshakeFallbackOperation op(thread_cl, target);
      VMThread::execute(&amp;op);
<span class="line-modified">!     return op.executed();</span>
    }
  }
  
<span class="line-modified">! HandshakeState::HandshakeState() : _operation(NULL), _semaphore(1), _thread_in_process_handshake(false) {</span>
<span class="line-added">+   DEBUG_ONLY(_vmthread_processing_handshake = false;)</span>
<span class="line-added">+ }</span>
  
  void HandshakeState::set_operation(JavaThread* target, HandshakeOperation* op) {
    _operation = op;
    SafepointMechanism::arm_local_poll_release(target);
  }
  
  void HandshakeState::clear_handshake(JavaThread* target) {
    _operation = NULL;
<span class="line-modified">!   SafepointMechanism::disarm_if_needed(target, true /* release */);</span>
  }
  
  void HandshakeState::process_self_inner(JavaThread* thread) {
    assert(Thread::current() == thread, &quot;should call from thread&quot;);
    assert(!thread-&gt;is_terminated(), &quot;should not be a terminated thread&quot;);
<span class="line-added">+   assert(thread-&gt;thread_state() != _thread_blocked, &quot;should not be in a blocked state&quot;);</span>
<span class="line-added">+   assert(thread-&gt;thread_state() != _thread_in_native, &quot;should not be in native&quot;);</span>
  
<span class="line-modified">!   do {</span>
<span class="line-modified">!     ThreadInVMForHandshake tivm(thread);</span>
<span class="line-modified">!     if (!_semaphore.trywait()) {</span>
<span class="line-modified">!       _semaphore.wait_with_safepoint_check(thread);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     HandshakeOperation* op = Atomic::load_acquire(&amp;_operation);</span>
<span class="line-modified">!     if (op != NULL) {</span>
<span class="line-modified">!       HandleMark hm(thread);</span>
<span class="line-modified">!       CautiouslyPreserveExceptionMark pem(thread);</span>
<span class="line-modified">!       // Disarm before execute the operation</span>
<span class="line-modified">!       clear_handshake(thread);</span>
<span class="line-modified">!       op-&gt;do_handshake(thread);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+     _semaphore.signal();</span>
<span class="line-added">+   } while (has_operation());</span>
  }
  
  bool HandshakeState::vmthread_can_process_handshake(JavaThread* target) {
    // handshake_safe may only be called with polls armed.
    // VM thread controls this by first claiming the handshake via claim_handshake_for_vmthread.
    return SafepointSynchronize::handshake_safe(target);
  }
  
  static bool possibly_vmthread_can_process_handshake(JavaThread* target) {
    // Note that this method is allowed to produce false positives.
    if (target-&gt;is_ext_suspended()) {
      return true;
    }
    if (target-&gt;is_terminated()) {
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 342,38 ***</span>
    }
    _semaphore.signal();
    return false;
  }
  
<span class="line-modified">! void HandshakeState::process_by_vmthread(JavaThread* target) {</span>
    assert(Thread::current()-&gt;is_VM_thread(), &quot;should call from vm thread&quot;);
<span class="line-removed">-   // Threads_lock must be held here, but that is assert()ed in</span>
<span class="line-removed">-   // possibly_vmthread_can_process_handshake().</span>
  
    if (!has_operation()) {
      // JT has already cleared its handshake
<span class="line-modified">!     return;</span>
    }
  
    if (!possibly_vmthread_can_process_handshake(target)) {
      // JT is observed in an unsafe state, it must notice the handshake itself
<span class="line-modified">!     return;</span>
    }
  
    // Claim the semaphore if there still an operation to be executed.
    if (!claim_handshake_for_vmthread()) {
<span class="line-modified">!     return;</span>
    }
  
    // If we own the semaphore at this point and while owning the semaphore
    // can observe a safe state the thread cannot possibly continue without
    // getting caught by the semaphore.
    if (vmthread_can_process_handshake(target)) {
      guarantee(!_semaphore.trywait(), &quot;we should already own the semaphore&quot;);
      _operation-&gt;do_handshake(target);
      // Disarm after VM thread have executed the operation.
      clear_handshake(target);
<span class="line-modified">!     // Release the thread</span>
    }
  
    _semaphore.signal();
  }
<span class="line-new-header">--- 366,43 ---</span>
    }
    _semaphore.signal();
    return false;
  }
  
<span class="line-modified">! bool HandshakeState::try_process_by_vmThread(JavaThread* target) {</span>
    assert(Thread::current()-&gt;is_VM_thread(), &quot;should call from vm thread&quot;);
  
    if (!has_operation()) {
      // JT has already cleared its handshake
<span class="line-modified">!     return false;</span>
    }
  
    if (!possibly_vmthread_can_process_handshake(target)) {
      // JT is observed in an unsafe state, it must notice the handshake itself
<span class="line-modified">!     return false;</span>
    }
  
    // Claim the semaphore if there still an operation to be executed.
    if (!claim_handshake_for_vmthread()) {
<span class="line-modified">!     return false;</span>
    }
  
    // If we own the semaphore at this point and while owning the semaphore
    // can observe a safe state the thread cannot possibly continue without
    // getting caught by the semaphore.
<span class="line-added">+   bool executed = false;</span>
    if (vmthread_can_process_handshake(target)) {
      guarantee(!_semaphore.trywait(), &quot;we should already own the semaphore&quot;);
<span class="line-added">+     log_trace(handshake)(&quot;Processing handshake by VMThtread&quot;);</span>
<span class="line-added">+     DEBUG_ONLY(_vmthread_processing_handshake = true;)</span>
      _operation-&gt;do_handshake(target);
<span class="line-added">+     DEBUG_ONLY(_vmthread_processing_handshake = false;)</span>
      // Disarm after VM thread have executed the operation.
      clear_handshake(target);
<span class="line-modified">!     executed = true;</span>
    }
  
<span class="line-added">+   // Release the thread</span>
    _semaphore.signal();
<span class="line-added">+ </span>
<span class="line-added">+   return executed;</span>
  }
</pre>
<center><a href="handles.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="handshake.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
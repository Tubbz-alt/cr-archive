<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/relocator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/stackMapTableFormat.hpp&quot;
 27 #include &quot;interpreter/bytecodes.hpp&quot;
 28 #include &quot;memory/metadataFactory.hpp&quot;
 29 #include &quot;memory/oopFactory.hpp&quot;
 30 #include &quot;memory/universe.hpp&quot;
 31 #include &quot;oops/method.inline.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/relocator.hpp&quot;
 35 
 36 #define MAX_METHOD_LENGTH  65535
 37 
 38 #define MAX_SHORT ((1 &lt;&lt; 15) - 1)
 39 #define MIN_SHORT (- (1 &lt;&lt; 15))
 40 
 41 // Encapsulates a code change request. There are 3 types.
 42 // General instruction, jump instruction, and table/lookup switches
 43 //
 44 class ChangeItem : public ResourceObj {
 45   int _bci;
 46  public:
 47    ChangeItem(int bci) { _bci = bci; }
 48    virtual bool handle_code_change(Relocator *r) = 0;
 49 
 50    // type info
 51    virtual bool is_widen()      { return false; }
 52    virtual bool is_jump_widen() { return false; }
 53    virtual bool is_switch_pad() { return false; }
 54 
 55    // accessors
 56    int bci()    { return _bci; }
 57    void relocate(int break_bci, int delta) { if (_bci &gt; break_bci) { _bci += delta; } }
 58 
 59    virtual bool adjust(int bci, int delta) { return false; }
 60 
 61    // debug
 62    virtual void print() = 0;
 63 };
 64 
 65 class ChangeWiden : public ChangeItem {
 66   int              _new_ilen;    // New length of instruction at bci
 67   u_char*          _inst_buffer; // New bytecodes
 68  public:
 69   ChangeWiden(int bci, int new_ilen, u_char* inst_buffer) : ChangeItem(bci) {
 70     _new_ilen = new_ilen;
 71     _inst_buffer = inst_buffer;
 72   }
 73 
 74   // Callback to do instruction
 75   bool handle_code_change(Relocator *r) { return r-&gt;handle_widen(bci(), _new_ilen, _inst_buffer); };
 76 
 77   bool is_widen()              { return true; }
 78 
 79   void print()                 { tty-&gt;print_cr(&quot;ChangeWiden. bci: %d   New_ilen: %d&quot;, bci(), _new_ilen); }
 80 };
 81 
 82 class ChangeJumpWiden : public ChangeItem {
 83   int _delta;  // New length of instruction at bci
 84  public:
 85   ChangeJumpWiden(int bci, int delta) : ChangeItem(bci) { _delta = delta; }
 86 
 87   // Callback to do instruction
 88   bool handle_code_change(Relocator *r) { return r-&gt;handle_jump_widen(bci(), _delta); };
 89 
 90   bool is_jump_widen()         { return true; }
 91 
 92   // If the bci matches, adjust the delta in the change jump request.
 93   bool adjust(int jump_bci, int delta) {
 94     if (bci() == jump_bci) {
 95       if (_delta &gt; 0)
 96         _delta += delta;
 97       else
 98         _delta -= delta;
 99       return true;
100     }
101     return false;
102   }
103 
104   void print()                 { tty-&gt;print_cr(&quot;ChangeJumpWiden. bci: %d   Delta: %d&quot;, bci(), _delta); }
105 };
106 
107 class ChangeSwitchPad : public ChangeItem {
108   int  _padding;
109   bool _is_lookup_switch;
110  public:
111    ChangeSwitchPad(int bci, int padding, bool is_lookup_switch) : ChangeItem(bci) {
112      _padding = padding;
113      _is_lookup_switch = is_lookup_switch;
114    }
115 
116    // Callback to do instruction
117    bool handle_code_change(Relocator *r) { return r-&gt;handle_switch_pad(bci(), _padding, _is_lookup_switch); };
118 
119    bool is_switch_pad()        { return true; }
120    int  padding()              { return _padding;  }
121    bool is_lookup_switch()     { return _is_lookup_switch; }
122 
123    void print()                { tty-&gt;print_cr(&quot;ChangeSwitchPad. bci: %d   Padding: %d  IsLookupSwitch: %d&quot;, bci(), _padding, _is_lookup_switch); }
124 };
125 
126 //-----------------------------------------------------------------------------------------------------------
127 // Relocator code
128 
129 Relocator::Relocator(const methodHandle&amp; m, RelocatorListener* listener) {
130   set_method(m);
131   set_code_length(method()-&gt;code_size());
132   set_code_array(NULL);
133   // Allocate code array and copy bytecodes
134   if (!expand_code_array(0)) {
135     // Should have at least MAX_METHOD_LENGTH available or the verifier
136     // would have failed.
137     ShouldNotReachHere();
138   }
139   set_compressed_line_number_table(NULL);
140   set_compressed_line_number_table_size(0);
141   _listener = listener;
142 }
143 
144 // size is the new size of the instruction at bci. Hence, if size is less than the current
145 // instruction size, we will shrink the code.
146 methodHandle Relocator::insert_space_at(int bci, int size, u_char inst_buffer[], TRAPS) {
147   _changes = new GrowableArray&lt;ChangeItem*&gt; (10);
148   _changes-&gt;push(new ChangeWiden(bci, size, inst_buffer));
149 
150   if (TraceRelocator) {
151     tty-&gt;print_cr(&quot;Space at: %d Size: %d&quot;, bci, size);
152     _method-&gt;print();
153     _method-&gt;print_codes();
154     tty-&gt;print_cr(&quot;-------------------------------------------------&quot;);
155   }
156 
157   if (!handle_code_changes()) return methodHandle();
158 
159     // Construct the new method
160   methodHandle new_method = Method::clone_with_new_data(method(),
161                               code_array(), code_length(),
162                               compressed_line_number_table(),
163                               compressed_line_number_table_size(),
164                               CHECK_(methodHandle()));
165 
166   // Deallocate the old Method* from metadata
167   ClassLoaderData* loader_data = method()-&gt;method_holder()-&gt;class_loader_data();
168   loader_data-&gt;add_to_deallocate_list(method()());
169 
170     set_method(new_method);
171 
172   if (TraceRelocator) {
173     tty-&gt;print_cr(&quot;-------------------------------------------------&quot;);
174     tty-&gt;print_cr(&quot;new method&quot;);
175     _method-&gt;print_codes();
176   }
177 
178   return new_method;
179 }
180 
181 
182 bool Relocator::handle_code_changes() {
183   assert(_changes != NULL, &quot;changes vector must be initialized&quot;);
184 
185   while (!_changes-&gt;is_empty()) {
186     // Inv: everything is aligned.
187     ChangeItem* ci = _changes-&gt;first();
188 
189     if (TraceRelocator) {
190       ci-&gt;print();
191     }
192 
193     // Execute operation
194     if (!ci-&gt;handle_code_change(this)) return false;
195 
196     // Shuffle items up
197     for (int index = 1; index &lt; _changes-&gt;length(); index++) {
198       _changes-&gt;at_put(index-1, _changes-&gt;at(index));
199     }
200     _changes-&gt;pop();
201   }
202   return true;
203 }
204 
205 
206 bool Relocator::is_opcode_lookupswitch(Bytecodes::Code bc) {
207   switch (bc) {
208     case Bytecodes::_tableswitch:       return false;
209     case Bytecodes::_lookupswitch:                   // not rewritten on ia64
210     case Bytecodes::_fast_linearswitch:              // rewritten _lookupswitch
211     case Bytecodes::_fast_binaryswitch: return true; // rewritten _lookupswitch
212     default: ShouldNotReachHere();
213   }
214   return true; // dummy
215 }
216 
217 // We need a special instruction size method, since lookupswitches and tableswitches might not be
218 // properly aligned during relocation
219 int Relocator::rc_instr_len(int bci) {
220   Bytecodes::Code bc= code_at(bci);
221   switch (bc) {
222     // In the case of switch instructions, see if we have the original
223     // padding recorded.
224     case Bytecodes::_tableswitch:
225     case Bytecodes::_lookupswitch:
226     case Bytecodes::_fast_linearswitch:
227     case Bytecodes::_fast_binaryswitch:
228     {
229       int pad = get_orig_switch_pad(bci, is_opcode_lookupswitch(bc));
230       if (pad == -1) {
231         return instruction_length_at(bci);
232       }
233       // Otherwise, depends on the switch type.
234       switch (bc) {
235         case Bytecodes::_tableswitch: {
236           int lo = int_at(bci + 1 + pad + 4 * 1);
237           int hi = int_at(bci + 1 + pad + 4 * 2);
238           int n = hi - lo + 1;
239           return 1 + pad + 4*(3 + n);
240         }
241         case Bytecodes::_lookupswitch:
242         case Bytecodes::_fast_linearswitch:
243         case Bytecodes::_fast_binaryswitch: {
244           int npairs = int_at(bci + 1 + pad + 4 * 1);
245           return 1 + pad + 4*(2 + 2*npairs);
246         }
247         default:
248           ShouldNotReachHere();
249       }
250     }
251     default:
252       break;
253   }
254   return instruction_length_at(bci);
255 }
256 
257 // If a change item is recorded for &quot;pc&quot;, with type &quot;ct&quot;, returns the
258 // associated padding, else -1.
259 int Relocator::get_orig_switch_pad(int bci, bool is_lookup_switch) {
260   for (int k = 0; k &lt; _changes-&gt;length(); k++) {
261     ChangeItem* ci = _changes-&gt;at(k);
262     if (ci-&gt;is_switch_pad()) {
263       ChangeSwitchPad* csp = (ChangeSwitchPad*)ci;
264       if (csp-&gt;is_lookup_switch() == is_lookup_switch &amp;&amp; csp-&gt;bci() == bci) {
265         return csp-&gt;padding();
266       }
267     }
268   }
269   return -1;
270 }
271 
272 
273 // Push a ChangeJumpWiden if it doesn&#39;t already exist on the work queue,
274 // otherwise adjust the item already there by delta.  The calculation for
275 // new_delta is wrong for this because it uses the offset stored in the
276 // code stream itself which wasn&#39;t fixed when item was pushed on the work queue.
277 void Relocator::push_jump_widen(int bci, int delta, int new_delta) {
278   for (int j = 0; j &lt; _changes-&gt;length(); j++) {
279     ChangeItem* ci = _changes-&gt;at(j);
280     if (ci-&gt;adjust(bci, delta)) return;
281   }
282   _changes-&gt;push(new ChangeJumpWiden(bci, new_delta));
283 }
284 
285 
286 // The current instruction of &quot;c&quot; is a jump; one of its offset starts
287 // at &quot;offset&quot; and is a short if &quot;isShort&quot; is &quot;TRUE&quot;,
288 // and an integer otherwise.  If the jump crosses &quot;breakPC&quot;, change
289 // the span of the jump by &quot;delta&quot;.
290 void Relocator::change_jump(int bci, int offset, bool is_short, int break_bci, int delta) {
291   int bci_delta = (is_short) ? short_at(offset) : int_at(offset);
292   int targ = bci + bci_delta;
293 
294   if ((bci &lt;= break_bci &amp;&amp; targ &gt;  break_bci) ||
295       (bci &gt;  break_bci &amp;&amp; targ &lt;= break_bci)) {
296     int new_delta;
297     if (bci_delta &gt; 0)
298       new_delta = bci_delta + delta;
299     else
300       new_delta = bci_delta - delta;
301 
302     if (is_short &amp;&amp; ((new_delta &gt; MAX_SHORT) || new_delta &lt; MIN_SHORT)) {
303       push_jump_widen(bci, delta, new_delta);
304     } else if (is_short) {
305       short_at_put(offset, new_delta);
306     } else {
307       int_at_put(offset, new_delta);
308     }
309   }
310 }
311 
312 
313 // Changes all jumps crossing &quot;break_bci&quot; by &quot;delta&quot;.  May enqueue things
314 // on &quot;rc-&gt;changes&quot;
315 void Relocator::change_jumps(int break_bci, int delta) {
316   int bci = 0;
317   Bytecodes::Code bc;
318   // Now, adjust any affected instructions.
319   while (bci &lt; code_length()) {
320     switch (bc= code_at(bci)) {
321       case Bytecodes::_ifeq:
322       case Bytecodes::_ifne:
323       case Bytecodes::_iflt:
324       case Bytecodes::_ifge:
325       case Bytecodes::_ifgt:
326       case Bytecodes::_ifle:
327       case Bytecodes::_if_icmpeq:
328       case Bytecodes::_if_icmpne:
329       case Bytecodes::_if_icmplt:
330       case Bytecodes::_if_icmpge:
331       case Bytecodes::_if_icmpgt:
332       case Bytecodes::_if_icmple:
333       case Bytecodes::_if_acmpeq:
334       case Bytecodes::_if_acmpne:
335       case Bytecodes::_ifnull:
336       case Bytecodes::_ifnonnull:
337       case Bytecodes::_goto:
338       case Bytecodes::_jsr:
339         change_jump(bci, bci+1, true, break_bci, delta);
340         break;
341       case Bytecodes::_goto_w:
342       case Bytecodes::_jsr_w:
343         change_jump(bci, bci+1, false, break_bci, delta);
344         break;
345       case Bytecodes::_tableswitch:
346       case Bytecodes::_lookupswitch:
347       case Bytecodes::_fast_linearswitch:
348       case Bytecodes::_fast_binaryswitch: {
349         int recPad = get_orig_switch_pad(bci, (bc != Bytecodes::_tableswitch));
350         int oldPad = (recPad != -1) ? recPad : align(bci+1) - (bci+1);
351         if (bci &gt; break_bci) {
352           int new_bci = bci + delta;
353           int newPad = align(new_bci+1) - (new_bci+1);
354           // Do we need to check the padding?
355           if (newPad != oldPad) {
356             if (recPad == -1) {
357               _changes-&gt;push(new ChangeSwitchPad(bci, oldPad, (bc != Bytecodes::_tableswitch)));
358             }
359           }
360         }
361 
362         // Then the rest, which depend on the kind of switch.
363         switch (bc) {
364           case Bytecodes::_tableswitch: {
365             change_jump(bci, bci +1 + oldPad, false, break_bci, delta);
366             // We cannot use the Bytecode_tableswitch abstraction, since the padding might not be correct.
367             int lo = int_at(bci + 1 + oldPad + 4 * 1);
368             int hi = int_at(bci + 1 + oldPad + 4 * 2);
369             int n = hi - lo + 1;
370             for (int k = 0; k &lt; n; k++) {
371               change_jump(bci, bci +1 + oldPad + 4*(k+3), false, break_bci, delta);
372             }
373             // Special next-bci calculation here...
374             bci += 1 + oldPad + (n+3)*4;
375             continue;
376           }
377           case Bytecodes::_lookupswitch:
378           case Bytecodes::_fast_linearswitch:
379           case Bytecodes::_fast_binaryswitch: {
380             change_jump(bci, bci +1 + oldPad, false, break_bci, delta);
381             // We cannot use the Bytecode_lookupswitch abstraction, since the padding might not be correct.
382             int npairs = int_at(bci + 1 + oldPad + 4 * 1);
383             for (int k = 0; k &lt; npairs; k++) {
384               change_jump(bci, bci + 1 + oldPad + 4*(2 + 2*k + 1), false, break_bci, delta);
385             }
386             /* Special next-bci calculation here... */
387             bci += 1 + oldPad + (2 + (npairs*2))*4;
388             continue;
389           }
390           default:
391             ShouldNotReachHere();
392         }
393       }
394       default:
395         break;
396     }
397     bci += rc_instr_len(bci);
398   }
399 }
400 
401 // The width of instruction at &quot;pc&quot; is changing by &quot;delta&quot;.  Adjust the
402 // exception table, if any, of &quot;rc-&gt;mb&quot;.
403 void Relocator::adjust_exception_table(int bci, int delta) {
404   ExceptionTable table(_method());
405   for (int index = 0; index &lt; table.length(); index ++) {
406     if (table.start_pc(index) &gt; bci) {
407       table.set_start_pc(index, table.start_pc(index) + delta);
408       table.set_end_pc(index, table.end_pc(index) + delta);
409     } else if (bci &lt; table.end_pc(index)) {
410       table.set_end_pc(index, table.end_pc(index) + delta);
411     }
412     if (table.handler_pc(index) &gt; bci)
413       table.set_handler_pc(index, table.handler_pc(index) + delta);
414   }
415 }
416 
417 
418 // The width of instruction at &quot;bci&quot; is changing by &quot;delta&quot;.  Adjust the line number table.
419 void Relocator::adjust_line_no_table(int bci, int delta) {
420   if (method()-&gt;has_linenumber_table()) {
421     CompressedLineNumberReadStream  reader(method()-&gt;compressed_linenumber_table());
422     CompressedLineNumberWriteStream writer(64);  // plenty big for most line number tables
423     while (reader.read_pair()) {
424       int adjustment = (reader.bci() &gt; bci) ? delta : 0;
425       writer.write_pair(reader.bci() + adjustment, reader.line());
426     }
427     writer.write_terminator();
428     set_compressed_line_number_table(writer.buffer());
429     set_compressed_line_number_table_size(writer.position());
430   }
431 }
432 
433 
434 // The width of instruction at &quot;bci&quot; is changing by &quot;delta&quot;.  Adjust the local variable table.
435 void Relocator::adjust_local_var_table(int bci, int delta) {
436   int localvariable_table_length = method()-&gt;localvariable_table_length();
437   if (localvariable_table_length &gt; 0) {
438     LocalVariableTableElement* table = method()-&gt;localvariable_table_start();
439     for (int i = 0; i &lt; localvariable_table_length; i++) {
440       u2 current_bci = table[i].start_bci;
441       if (current_bci &gt; bci) {
442         table[i].start_bci = current_bci + delta;
443       } else {
444         u2 current_length = table[i].length;
445         if (current_bci + current_length &gt; bci) {
446           table[i].length = current_length + delta;
447         }
448       }
449     }
450   }
451 }
452 
453 // Create a new array, copying the src array but adding a hole at
454 // the specified location
455 static Array&lt;u1&gt;* insert_hole_at(ClassLoaderData* loader_data,
456     size_t where, int hole_sz, Array&lt;u1&gt;* src) {
457   Thread* THREAD = Thread::current();
458   Array&lt;u1&gt;* dst =
459       MetadataFactory::new_array&lt;u1&gt;(loader_data, src-&gt;length() + hole_sz, 0, CHECK_NULL);
460 
461   address src_addr = (address)src-&gt;adr_at(0);
462   address dst_addr = (address)dst-&gt;adr_at(0);
463 
464   memcpy(dst_addr, src_addr, where);
465   memcpy(dst_addr + where + hole_sz,
466          src_addr + where, src-&gt;length() - where);
467   return dst;
468 }
469 
470 // The width of instruction at &quot;bci&quot; is changing by &quot;delta&quot;.  Adjust the stack
471 // map frames.
472 void Relocator::adjust_stack_map_table(int bci, int delta) {
473   if (method()-&gt;has_stackmap_table()) {
474     Array&lt;u1&gt;* data = method()-&gt;stackmap_data();
475     // The data in the array is a classfile representation of the stackmap table
476     stack_map_table* sm_table =
477         stack_map_table::at((address)data-&gt;adr_at(0));
478 
479     int count = sm_table-&gt;number_of_entries();
480     stack_map_frame* frame = sm_table-&gt;entries();
481     int bci_iter = -1;
482     bool offset_adjusted = false; // only need to adjust one offset
483 
484     for (int i = 0; i &lt; count; ++i) {
485       int offset_delta = frame-&gt;offset_delta();
486       bci_iter += offset_delta;
487 
488       if (!offset_adjusted &amp;&amp; bci_iter &gt; bci) {
489         int new_offset_delta = offset_delta + delta;
490 
491         if (frame-&gt;is_valid_offset(new_offset_delta)) {
492           frame-&gt;set_offset_delta(new_offset_delta);
493         } else {
494           assert(frame-&gt;is_same_frame() ||
495                  frame-&gt;is_same_locals_1_stack_item_frame(),
496                  &quot;Frame must be one of the compressed forms&quot;);
497           // The new delta exceeds the capacity of the &#39;same_frame&#39; or
498           // &#39;same_frame_1_stack_item_frame&#39; frame types.  We need to
499           // convert these frames to the extended versions, but the extended
500           // version is bigger and requires more room.  So we allocate a
501           // new array and copy the data, being sure to leave u2-sized hole
502           // right after the &#39;frame_type&#39; for the new offset field.
503           //
504           // We can safely ignore the reverse situation as a small delta
505           // can still be used in an extended version of the frame.
506 
507           size_t frame_offset = (address)frame - (address)data-&gt;adr_at(0);
508 
509           ClassLoaderData* loader_data = method()-&gt;method_holder()-&gt;class_loader_data();
510           Array&lt;u1&gt;* new_data = insert_hole_at(loader_data, frame_offset + 1, 2, data);
511           if (new_data == NULL) {
512             return; // out-of-memory?
513           }
514           // Deallocate old data
515           MetadataFactory::free_array&lt;u1&gt;(loader_data, data);
516           data = new_data;
517 
518           address frame_addr = (address)(data-&gt;adr_at(0) + frame_offset);
519           frame = stack_map_frame::at(frame_addr);
520 
521 
522           // Now convert the frames in place
523           if (frame-&gt;is_same_frame()) {
524             same_frame_extended::create_at(frame_addr, new_offset_delta);
525           } else {
526             same_locals_1_stack_item_extended::create_at(
527               frame_addr, new_offset_delta, NULL);
528             // the verification_info_type should already be at the right spot
529           }
530         }
531         offset_adjusted = true; // needs to be done only once, since subsequent
532                                 // values are offsets from the current
533       }
534 
535       // The stack map frame may contain verification types, if so we need to
536       // check and update any Uninitialized type&#39;s bci (no matter where it is).
537       int number_of_types = frame-&gt;number_of_types();
538       verification_type_info* types = frame-&gt;types();
539 
540       for (int i = 0; i &lt; number_of_types; ++i) {
541         if (types-&gt;is_uninitialized() &amp;&amp; types-&gt;bci() &gt; bci) {
542           types-&gt;set_bci(types-&gt;bci() + delta);
543         }
544         types = types-&gt;next();
545       }
546 
547       // Full frame has stack values too
548       full_frame* ff = frame-&gt;as_full_frame();
549       if (ff != NULL) {
550         address eol = (address)types;
551         number_of_types = ff-&gt;stack_slots(eol);
552         types = ff-&gt;stack(eol);
553         for (int i = 0; i &lt; number_of_types; ++i) {
554           if (types-&gt;is_uninitialized() &amp;&amp; types-&gt;bci() &gt; bci) {
555             types-&gt;set_bci(types-&gt;bci() + delta);
556           }
557           types = types-&gt;next();
558         }
559       }
560 
561       frame = frame-&gt;next();
562     }
563 
564     method()-&gt;set_stackmap_data(data); // in case it has changed
565   }
566 }
567 
568 
569 bool Relocator::expand_code_array(int delta) {
570   int length = MAX2(code_length() + delta, code_length() * (100+code_slop_pct()) / 100);
571 
572   if (length &gt; MAX_METHOD_LENGTH) {
573     if (delta == 0 &amp;&amp; code_length() &lt;= MAX_METHOD_LENGTH) {
574       length = MAX_METHOD_LENGTH;
575     } else {
576       return false;
577     }
578   }
579 
580   unsigned char* new_code_array = NEW_RESOURCE_ARRAY(unsigned char, length);
581   if (!new_code_array) return false;
582 
583   // Expanding current array
584   if (code_array() != NULL) {
585     memcpy(new_code_array, code_array(), code_length());
586   } else {
587     // Initial copy. Copy directly from Method*
588     memcpy(new_code_array, method()-&gt;code_base(), code_length());
589   }
590 
591   set_code_array(new_code_array);
592   set_code_array_length(length);
593 
594   return true;
595 }
596 
597 
598 // The instruction at &quot;bci&quot;, whose size is &quot;ilen&quot;, is changing size by
599 // &quot;delta&quot;.  Reallocate, move code, recalculate jumps, and enqueue
600 // change items as necessary.
601 bool Relocator::relocate_code(int bci, int ilen, int delta) {
602   int next_bci = bci + ilen;
603   if (delta &gt; 0 &amp;&amp; code_length() + delta &gt; code_array_length())  {
604     // Expand allocated code space, if necessary.
605     if (!expand_code_array(delta)) {
606           return false;
607     }
608   }
609 
610   // We require 4-byte alignment of code arrays.
611   assert(((intptr_t)code_array() &amp; 3) == 0, &quot;check code alignment&quot;);
612   // Change jumps before doing the copying; this routine requires aligned switches.
613   change_jumps(bci, delta);
614 
615   // In case we have shrunken a tableswitch/lookupswitch statement, we store the last
616   // bytes that get overwritten. We have to copy the bytes after the change_jumps method
617   // has been called, since it is likely to update last offset in a tableswitch/lookupswitch
618   assert(delta &gt;= -3, &quot;We cannot overwrite more than 3 bytes.&quot;);
619   if (delta &lt; 0 &amp;&amp; delta &gt;= -3) {
620     memcpy(_overwrite, addr_at(bci + ilen + delta), -delta);
621   }
622 
623   memmove(addr_at(next_bci + delta), addr_at(next_bci), code_length() - next_bci);
624   set_code_length(code_length() + delta);
625   // Also adjust exception tables...
626   adjust_exception_table(bci, delta);
627   // Line number tables...
628   adjust_line_no_table(bci, delta);
629   // And local variable table...
630   adjust_local_var_table(bci, delta);
631 
632   // Adjust stack maps
633   adjust_stack_map_table(bci, delta);
634 
635   // Relocate the pending change stack...
636   for (int j = 0; j &lt; _changes-&gt;length(); j++) {
637     ChangeItem* ci = _changes-&gt;at(j);
638     ci-&gt;relocate(bci, delta);
639   }
640 
641   // Notify any listeners about code relocation
642   notify(bci, delta, code_length());
643 
644   return true;
645 }
646 
647 // relocate a general instruction. Called by ChangeWiden class
648 bool Relocator::handle_widen(int bci, int new_ilen, u_char inst_buffer[]) {
649   int ilen = rc_instr_len(bci);
650   if (!relocate_code(bci, ilen, new_ilen - ilen))
651     return false;
652 
653   // Insert new bytecode(s)
654   for(int k = 0; k &lt; new_ilen; k++) {
655     code_at_put(bci + k, (Bytecodes::Code)inst_buffer[k]);
656   }
657 
658   return true;
659 }
660 
661 // handle jump_widen instruction. Called be ChangeJumpWiden class
662 bool Relocator::handle_jump_widen(int bci, int delta) {
663   int ilen = rc_instr_len(bci);
664 
665   Bytecodes::Code bc = code_at(bci);
666   switch (bc) {
667     case Bytecodes::_ifeq:
668     case Bytecodes::_ifne:
669     case Bytecodes::_iflt:
670     case Bytecodes::_ifge:
671     case Bytecodes::_ifgt:
672     case Bytecodes::_ifle:
673     case Bytecodes::_if_icmpeq:
674     case Bytecodes::_if_icmpne:
675     case Bytecodes::_if_icmplt:
676     case Bytecodes::_if_icmpge:
677     case Bytecodes::_if_icmpgt:
678     case Bytecodes::_if_icmple:
679     case Bytecodes::_if_acmpeq:
680     case Bytecodes::_if_acmpne:
681     case Bytecodes::_ifnull:
682     case Bytecodes::_ifnonnull: {
683       const int goto_length   = Bytecodes::length_for(Bytecodes::_goto);
684 
685       // If &#39;if&#39; points to the next bytecode after goto, it&#39;s already handled.
686       // it shouldn&#39;t be.
687       assert (short_at(bci+1) != ilen+goto_length, &quot;if relocation already handled&quot;);
688       assert(ilen == 3, &quot;check length&quot;);
689 
690       // Convert to 0 if &lt;cond&gt; goto 6
691       //            3 _goto 11
692       //            6 _goto_w &lt;wide delta offset&gt;
693       //            11 &lt;else code&gt;
694       const int goto_w_length = Bytecodes::length_for(Bytecodes::_goto_w);
695       const int add_bci = goto_length + goto_w_length;
696 
697       if (!relocate_code(bci, 3, /*delta*/add_bci)) return false;
698 
699       // if bytecode points to goto_w instruction
700       short_at_put(bci + 1, ilen + goto_length);
701 
702       int cbci = bci + ilen;
703       // goto around
704       code_at_put(cbci, Bytecodes::_goto);
705       short_at_put(cbci + 1, add_bci);
706       // goto_w &lt;wide delta&gt;
707       cbci = cbci + goto_length;
708       code_at_put(cbci, Bytecodes::_goto_w);
709       if (delta &gt; 0) {
710         delta += 2;                 // goto_w is 2 bytes more than &quot;if&quot; code
711       } else {
712         delta -= ilen+goto_length;  // branch starts at goto_w offset
713       }
714       int_at_put(cbci + 1, delta);
715       break;
716 
717       }
718     case Bytecodes::_goto:
719     case Bytecodes::_jsr:
720       assert(ilen == 3, &quot;check length&quot;);
721 
722       if (!relocate_code(bci, 3, 2)) return false;
723       if (bc == Bytecodes::_goto)
724         code_at_put(bci, Bytecodes::_goto_w);
725       else
726         code_at_put(bci, Bytecodes::_jsr_w);
727 
728       // If it&#39;s a forward jump, add 2 for the widening.
729       if (delta &gt; 0) delta += 2;
730       int_at_put(bci + 1, delta);
731       break;
732 
733     default: ShouldNotReachHere();
734   }
735 
736   return true;
737 }
738 
739 // handle lookup/table switch instructions.  Called be ChangeSwitchPad class
740 bool Relocator::handle_switch_pad(int bci, int old_pad, bool is_lookup_switch) {
741   int ilen = rc_instr_len(bci);
742   int new_pad = align(bci+1) - (bci+1);
743   int pad_delta = new_pad - old_pad;
744   if (pad_delta != 0) {
745     int len;
746     if (!is_lookup_switch) {
747       int low  = int_at(bci+1+old_pad+4);
748       int high = int_at(bci+1+old_pad+8);
749       len = high-low+1 + 3; // 3 for default, hi, lo.
750     } else {
751       int npairs = int_at(bci+1+old_pad+4);
752       len = npairs*2 + 2; // 2 for default, npairs.
753     }
754     // Because &quot;relocateCode&quot; does a &quot;changeJumps&quot; loop,
755     // which parses instructions to determine their length,
756     // we need to call that before messing with the current
757     // instruction.  Since it may also overwrite the current
758     // instruction when moving down, remember the possibly
759     // overwritten part.
760 
761     // Move the code following the instruction...
762     if (!relocate_code(bci, ilen, pad_delta)) return false;
763 
764     if (pad_delta &lt; 0) {
765       // Move the shrunken instruction down.
766       memmove(addr_at(bci + 1 + new_pad),
767               addr_at(bci + 1 + old_pad),
768               len * 4 + pad_delta);
769       memmove(addr_at(bci + 1 + new_pad + len*4 + pad_delta),
770               _overwrite, -pad_delta);
771     } else {
772       assert(pad_delta &gt; 0, &quot;check&quot;);
773       // Move the expanded instruction up.
774       memmove(addr_at(bci +1 + new_pad),
775               addr_at(bci +1 + old_pad),
776               len * 4);
777       memset(addr_at(bci + 1), 0, new_pad); // pad must be 0
778     }
779   }
780   return true;
781 }
    </pre>
  </body>
</html>
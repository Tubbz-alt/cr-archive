diff a/src/hotspot/share/runtime/task.cpp b/src/hotspot/share/runtime/task.cpp
--- a/src/hotspot/share/runtime/task.cpp
+++ b/src/hotspot/share/runtime/task.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -35,11 +35,11 @@
 void PeriodicTask::real_time_tick(int delay_time) {
   assert(Thread::current()->is_Watcher_thread(), "must be WatcherThread");
 
   // The WatcherThread does not participate in the safepoint protocol
   // for the PeriodicTask_lock because it is not a JavaThread.
-  MutexLockerEx ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);
   int orig_num_tasks = _num_tasks;
 
   for(int index = 0; index < _num_tasks; index++) {
     _tasks[index]->execute_if_pending(delay_time);
     if (_num_tasks < orig_num_tasks) { // task dis-enrolled itself
@@ -82,12 +82,11 @@
 void PeriodicTask::enroll() {
   // Follow normal safepoint aware lock enter protocol if the caller does
   // not already own the PeriodicTask_lock. Otherwise, we don't try to
   // enter it again because VM internal Mutexes do not support recursion.
   //
-  MutexLockerEx ml(PeriodicTask_lock->owned_by_self() ? NULL
-                                                      : PeriodicTask_lock);
+  MutexLocker ml(PeriodicTask_lock->owned_by_self() ? NULL : PeriodicTask_lock);
 
   if (_num_tasks == PeriodicTask::max_tasks) {
     fatal("Overflow in PeriodicTask table");
   } else {
     _tasks[_num_tasks++] = this;
@@ -105,12 +104,11 @@
 void PeriodicTask::disenroll() {
   // Follow normal safepoint aware lock enter protocol if the caller does
   // not already own the PeriodicTask_lock. Otherwise, we don't try to
   // enter it again because VM internal Mutexes do not support recursion.
   //
-  MutexLockerEx ml(PeriodicTask_lock->owned_by_self() ? NULL
-                                                      : PeriodicTask_lock);
+  MutexLocker ml(PeriodicTask_lock->owned_by_self() ? NULL : PeriodicTask_lock);
 
   int index;
   for(index = 0; index < _num_tasks && _tasks[index] != this; index++)
     ;
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sweeper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubRoutines.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sweeper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/compiledIC.hpp&quot;
 28 #include &quot;code/icBuffer.hpp&quot;
 29 #include &quot;code/nmethod.hpp&quot;
 30 #include &quot;compiler/compileBroker.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;gc/shared/workgroup.hpp&quot;
 33 #include &quot;jfr/jfrEvents.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;memory/universe.hpp&quot;
 39 #include &quot;oops/method.hpp&quot;
<span class="line-removed"> 40 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-removed"> 41 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
 42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 43 #include &quot;runtime/handshake.hpp&quot;
 44 #include &quot;runtime/mutexLocker.hpp&quot;
 45 #include &quot;runtime/orderAccess.hpp&quot;
 46 #include &quot;runtime/os.hpp&quot;
 47 #include &quot;runtime/sweeper.hpp&quot;
 48 #include &quot;runtime/thread.inline.hpp&quot;
 49 #include &quot;runtime/vmOperations.hpp&quot;
 50 #include &quot;runtime/vmThread.hpp&quot;
 51 #include &quot;utilities/events.hpp&quot;
 52 #include &quot;utilities/xmlstream.hpp&quot;
 53 
 54 #ifdef ASSERT
 55 
 56 #define SWEEP(nm) record_sweep(nm, __LINE__)
 57 // Sweeper logging code
 58 class SweeperRecord {
 59  public:
 60   int traversal;
 61   int compile_id;
</pre>
<hr />
<pre>
182 public:
183   virtual void do_code_blob(CodeBlob* cb) {
184     assert(cb-&gt;is_nmethod(), &quot;CodeBlob should be nmethod&quot;);
185     nmethod* nm = (nmethod*)cb;
186     nm-&gt;set_hotness_counter(NMethodSweeper::hotness_counter_reset_val());
187   }
188 };
189 static SetHotnessClosure set_hotness_closure;
190 
191 
192 int NMethodSweeper::hotness_counter_reset_val() {
193   if (_hotness_counter_reset_val == 0) {
194     _hotness_counter_reset_val = (ReservedCodeCacheSize &lt; M) ? 1 : (ReservedCodeCacheSize / M) * 2;
195   }
196   return _hotness_counter_reset_val;
197 }
198 bool NMethodSweeper::wait_for_stack_scanning() {
199   return _current.end();
200 }
201 
<span class="line-modified">202 class NMethodMarkingThreadClosure : public ThreadClosure {</span>
203 private:
204   CodeBlobClosure* _cl;
205 public:
<span class="line-modified">206   NMethodMarkingThreadClosure(CodeBlobClosure* cl) : _cl(cl) {}</span>
207   void do_thread(Thread* thread) {
208     if (thread-&gt;is_Java_thread() &amp;&amp; ! thread-&gt;is_Code_cache_sweeper_thread()) {
209       JavaThread* jt = (JavaThread*) thread;
210       jt-&gt;nmethods_do(_cl);
211     }
212   }
213 };
214 
215 class NMethodMarkingTask : public AbstractGangTask {
216 private:
<span class="line-modified">217   NMethodMarkingThreadClosure* _cl;</span>
218 public:
<span class="line-modified">219   NMethodMarkingTask(NMethodMarkingThreadClosure* cl) :</span>
220     AbstractGangTask(&quot;Parallel NMethod Marking&quot;),
221     _cl(cl) {
<span class="line-modified">222     Threads::change_thread_claim_parity();</span>
223   }
224 
225   ~NMethodMarkingTask() {
226     Threads::assert_all_threads_claimed();
227   }
228 
229   void work(uint worker_id) {
230     Threads::possibly_parallel_threads_do(true, _cl);
231   }
232 };
233 
234 /**
235   * Scans the stacks of all Java threads and marks activations of not-entrant methods.
236   * No need to synchronize access, since &#39;mark_active_nmethods&#39; is always executed at a
237   * safepoint.
238   */
239 void NMethodSweeper::mark_active_nmethods() {
240   CodeBlobClosure* cl = prepare_mark_active_nmethods();
241   if (cl != NULL) {
242     WorkGang* workers = Universe::heap()-&gt;get_safepoint_workers();
243     if (workers != NULL) {
<span class="line-modified">244       NMethodMarkingThreadClosure tcl(cl);</span>
245       NMethodMarkingTask task(&amp;tcl);
246       workers-&gt;run_task(&amp;task);
247     } else {
248       Threads::nmethods_do(cl);
249     }
250   }
251 }
252 
253 CodeBlobClosure* NMethodSweeper::prepare_mark_active_nmethods() {
254 #ifdef ASSERT
<span class="line-modified">255   if (ThreadLocalHandshakes) {</span>
256     assert(Thread::current()-&gt;is_Code_cache_sweeper_thread(), &quot;must be executed under CodeCache_lock and in sweeper thread&quot;);
257     assert_lock_strong(CodeCache_lock);
258   } else {
259     assert(SafepointSynchronize::is_at_safepoint(), &quot;must be executed at a safepoint&quot;);
260   }
261 #endif
262 
263   // If we do not want to reclaim not-entrant or zombie methods there is no need
264   // to scan stacks
265   if (!MethodFlushing) {
266     return NULL;
267   }
268 
269   // Increase time so that we can estimate when to invoke the sweeper again.
270   _time_counter++;
271 
272   // Check for restart
273   assert(_current.method() == NULL, &quot;should only happen between sweeper cycles&quot;);
274   assert(wait_for_stack_scanning(), &quot;should only happen between sweeper cycles&quot;);
275 
</pre>
<hr />
<pre>
302   if (_current.method() != NULL) {
303     if (_current.method()-&gt;is_nmethod()) {
304       assert(CodeCache::find_blob_unsafe(_current.method()) == _current.method(), &quot;Sweeper nmethod cached state invalid&quot;);
305     } else if (_current.method()-&gt;is_aot()) {
306       assert(CodeCache::find_blob_unsafe(_current.method()-&gt;code_begin()) == _current.method(), &quot;Sweeper AOT method cached state invalid&quot;);
307     } else {
308       ShouldNotReachHere();
309     }
310   }
311 
312   return &amp;set_hotness_closure;
313 }
314 
315 /**
316   * This function triggers a VM operation that does stack scanning of active
317   * methods. Stack scanning is mandatory for the sweeper to make progress.
318   */
319 void NMethodSweeper::do_stack_scanning() {
320   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
321   if (wait_for_stack_scanning()) {
<span class="line-modified">322     if (ThreadLocalHandshakes) {</span>
323       CodeBlobClosure* code_cl;
324       {
<span class="line-modified">325         MutexLockerEx ccl(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
326         code_cl = prepare_mark_active_nmethods();
327       }
328       if (code_cl != NULL) {
<span class="line-modified">329         NMethodMarkingThreadClosure tcl(code_cl);</span>
<span class="line-modified">330         Handshake::execute(&amp;tcl);</span>
331       }
332     } else {
333       VM_MarkActiveNMethods op;
334       VMThread::execute(&amp;op);
335     }
336   }
337 }
338 
339 void NMethodSweeper::sweeper_loop() {
340   bool timeout;
341   while (true) {
342     {
343       ThreadBlockInVM tbivm(JavaThread::current());
<span class="line-modified">344       MutexLockerEx waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
345       const long wait_time = 60*60*24 * 1000;
<span class="line-modified">346       timeout = CodeCache_lock-&gt;wait(Mutex::_no_safepoint_check_flag, wait_time);</span>
347     }
348     if (!timeout) {
349       possibly_sweep();
350     }
351   }
352 }
353 
354 /**
355   * Wakes up the sweeper thread to possibly sweep.
356   */
357 void NMethodSweeper::notify(int code_blob_type) {
358   // Makes sure that we do not invoke the sweeper too often during startup.
359   double start_threshold = 100.0 / (double)StartAggressiveSweepingAt;
360   double aggressive_sweep_threshold = MIN2(start_threshold, 1.1);
361   if (CodeCache::reverse_free_ratio(code_blob_type) &gt;= aggressive_sweep_threshold) {
362     assert_locked_or_safepoint(CodeCache_lock);
363     CodeCache_lock-&gt;notify();
364   }
365 }
366 
367 /**
368   * Wakes up the sweeper thread and forces a sweep. Blocks until it finished.
369   */
370 void NMethodSweeper::force_sweep() {
371   ThreadBlockInVM tbivm(JavaThread::current());
<span class="line-modified">372   MutexLockerEx waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
373   // Request forced sweep
374   _force_sweep = true;
375   while (_force_sweep) {
376     // Notify sweeper that we want to force a sweep and wait for completion.
377     // In case a sweep currently takes place we timeout and try again because
378     // we want to enforce a full sweep.
379     CodeCache_lock-&gt;notify();
<span class="line-modified">380     CodeCache_lock-&gt;wait(Mutex::_no_safepoint_check_flag, 1000);</span>
381   }
382 }
383 
384 /**
385  * Handle a safepoint request
386  */
387 void NMethodSweeper::handle_safepoint_request() {
388   JavaThread* thread = JavaThread::current();
389   if (SafepointMechanism::should_block(thread)) {
390     if (PrintMethodFlushing &amp;&amp; Verbose) {
391       tty-&gt;print_cr(&quot;### Sweep at %d out of %d, yielding to safepoint&quot;, _seen, CodeCache::nmethod_count());
392     }
<span class="line-modified">393     MutexUnlockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
394 
395     ThreadBlockInVM tbivm(thread);
396     thread-&gt;java_suspend_self();
397   }
398 }
399 
400 /**
401  * This function invokes the sweeper if at least one of the three conditions is met:
402  *    (1) The code cache is getting full
403  *    (2) There are sufficient state changes in/since the last sweep.
404  *    (3) We have not been sweeping for &#39;some time&#39;
405  */
406 void NMethodSweeper::possibly_sweep() {
407   assert(JavaThread::current()-&gt;thread_state() == _thread_in_vm, &quot;must run in vm mode&quot;);
408   // If there was no state change while nmethod sweeping, &#39;should_sweep&#39; will be false.
409   // This is one of the two places where should_sweep can be set to true. The general
410   // idea is as follows: If there is enough free space in the code cache, there is no
411   // need to invoke the sweeper. The following formula (which determines whether to invoke
412   // the sweeper or not) depends on the assumption that for larger ReservedCodeCacheSizes
413   // we need less frequent sweeps than for smaller ReservedCodecCacheSizes. Furthermore,
</pre>
<hr />
<pre>
458     sweep_code_cache();
459   }
460 
461   // We are done with sweeping the code cache once.
462   _total_nof_code_cache_sweeps++;
463   _last_sweep = _time_counter;
464   // Reset flag; temporarily disables sweeper
465   _should_sweep = false;
466   // If there was enough state change, &#39;possibly_enable_sweeper()&#39;
467   // sets &#39;_should_sweep&#39; to true
468   possibly_enable_sweeper();
469   // Reset _bytes_changed only if there was enough state change. _bytes_changed
470   // can further increase by calls to &#39;report_state_change&#39;.
471   if (_should_sweep) {
472     _bytes_changed = 0;
473   }
474 
475   if (forced) {
476     // Notify requester that forced sweep finished
477     assert(_force_sweep, &quot;Should be a forced sweep&quot;);
<span class="line-modified">478     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
479     _force_sweep = false;
480     CodeCache_lock-&gt;notify();
481   }
482 }
483 
484 static void post_sweep_event(EventSweepCodeCache* event,
485                              const Ticks&amp; start,
486                              const Ticks&amp; end,
487                              s4 traversals,
488                              int swept,
489                              int flushed,
490                              int zombified) {
491   assert(event != NULL, &quot;invariant&quot;);
492   assert(event-&gt;should_commit(), &quot;invariant&quot;);
493   event-&gt;set_starttime(start);
494   event-&gt;set_endtime(end);
495   event-&gt;set_sweepId(traversals);
496   event-&gt;set_sweptCount(swept);
497   event-&gt;set_flushedCount(flushed);
498   event-&gt;set_zombifiedCount(zombified);
</pre>
<hr />
<pre>
502 void NMethodSweeper::sweep_code_cache() {
503   ResourceMark rm;
504   Ticks sweep_start_counter = Ticks::now();
505 
506   log_debug(codecache, sweep, start)(&quot;CodeCache flushing&quot;);
507 
508   int flushed_count                = 0;
509   int zombified_count              = 0;
510   int flushed_c2_count     = 0;
511 
512   if (PrintMethodFlushing &amp;&amp; Verbose) {
513     tty-&gt;print_cr(&quot;### Sweep at %d out of %d&quot;, _seen, CodeCache::nmethod_count());
514   }
515 
516   int swept_count = 0;
517   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be in safepoint when we get here&quot;);
518   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
519 
520   int freed_memory = 0;
521   {
<span class="line-modified">522     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
523 
524     while (!_current.end()) {
525       swept_count++;
526       // Since we will give up the CodeCache_lock, always skip ahead
527       // to the next nmethod.  Other blobs can be deleted by other
528       // threads but nmethods are only reclaimed by the sweeper.
529       CompiledMethod* nm = _current.method();
530       _current.next();
531 
532       // Now ready to process nmethod and give up CodeCache_lock
533       {
<span class="line-modified">534         MutexUnlockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
535         // Save information before potentially flushing the nmethod
536         // Only flushing nmethods so size only matters for them.
537         int size = nm-&gt;is_nmethod() ? ((nmethod*)nm)-&gt;total_size() : 0;
538         bool is_c2_method = nm-&gt;is_compiled_by_c2();
539         bool is_osr = nm-&gt;is_osr_method();
540         int compile_id = nm-&gt;compile_id();
541         intptr_t address = p2i(nm);
542         const char* state_before = nm-&gt;state();
543         const char* state_after = &quot;&quot;;
544 
545         MethodStateChange type = process_compiled_method(nm);
546         switch (type) {
547           case Flushed:
548             state_after = &quot;flushed&quot;;
549             freed_memory += size;
550             ++flushed_count;
551             if (is_c2_method) {
552               ++flushed_c2_count;
553             }
554             break;
</pre>
<hr />
<pre>
559           case None:
560             break;
561           default:
562            ShouldNotReachHere();
563         }
564         if (PrintMethodFlushing &amp;&amp; Verbose &amp;&amp; type != None) {
565           tty-&gt;print_cr(&quot;### %s nmethod %3d/&quot; PTR_FORMAT &quot; (%s) %s&quot;, is_osr ? &quot;osr&quot; : &quot;&quot;, compile_id, address, state_before, state_after);
566         }
567       }
568 
569       _seen++;
570       handle_safepoint_request();
571     }
572   }
573 
574   assert(_current.end(), &quot;must have scanned the whole cache&quot;);
575 
576   const Ticks sweep_end_counter = Ticks::now();
577   const Tickspan sweep_time = sweep_end_counter - sweep_start_counter;
578   {
<span class="line-modified">579     MutexLockerEx mu(NMethodSweeperStats_lock, Mutex::_no_safepoint_check_flag);</span>
580     _total_time_sweeping  += sweep_time;
581     _total_time_this_sweep += sweep_time;
582     _peak_sweep_fraction_time = MAX2(sweep_time, _peak_sweep_fraction_time);
583     _total_flushed_size += freed_memory;
584     _total_nof_methods_reclaimed += flushed_count;
585     _total_nof_c2_methods_reclaimed += flushed_c2_count;
586     _peak_sweep_time = MAX2(_peak_sweep_time, _total_time_this_sweep);
587   }
588 
589   EventSweepCodeCache event(UNTIMED);
590   if (event.should_commit()) {
591     post_sweep_event(&amp;event, sweep_start_counter, sweep_end_counter, (s4)_traversals, swept_count, flushed_count, zombified_count);
592   }
593 
594 #ifdef ASSERT
595   if(PrintMethodFlushing) {
596     tty-&gt;print_cr(&quot;### sweeper:      sweep time(&quot; JLONG_FORMAT &quot;): &quot;, sweep_time.value());
597   }
598 #endif
599 
</pre>
<hr />
<pre>
682       SWEEP(cm);
683     }
684     return result;
685   }
686 
687   if (cm-&gt;is_zombie()) {
688     // All inline caches that referred to this nmethod were cleaned in the
689     // previous sweeper cycle. Now flush the nmethod from the code cache.
690     assert(!cm-&gt;is_locked_by_vm(), &quot;must not flush locked Compiled Methods&quot;);
691     cm-&gt;flush();
692     assert(result == None, &quot;sanity&quot;);
693     result = Flushed;
694   } else if (cm-&gt;is_not_entrant()) {
695     // If there are no current activations of this method on the
696     // stack we can safely convert it to a zombie method
697     OrderAccess::loadload(); // _stack_traversal_mark and _state
698     if (cm-&gt;can_convert_to_zombie()) {
699       // Code cache state change is tracked in make_zombie()
700       cm-&gt;make_zombie();
701       SWEEP(cm);
<span class="line-modified">702       // The nmethod may have been locked by JVMTI after being made zombie (see</span>
<span class="line-modified">703       // JvmtiDeferredEvent::compiled_method_unload_event()). If so, we cannot</span>
<span class="line-modified">704       // flush the osr nmethod directly but have to wait for a later sweeper cycle.</span>
<span class="line-removed">705       if (cm-&gt;is_osr_method() &amp;&amp; !cm-&gt;is_locked_by_vm()) {</span>
<span class="line-removed">706         // No inline caches will ever point to osr methods, so we can just remove it.</span>
<span class="line-removed">707         // Make sure that we unregistered the nmethod with the heap and flushed all</span>
<span class="line-removed">708         // dependencies before removing the nmethod (done in make_zombie()).</span>
<span class="line-removed">709         assert(cm-&gt;is_zombie(), &quot;nmethod must be unregistered&quot;);</span>
<span class="line-removed">710         cm-&gt;flush();</span>
<span class="line-removed">711         assert(result == None, &quot;sanity&quot;);</span>
<span class="line-removed">712         result = Flushed;</span>
<span class="line-removed">713       } else {</span>
<span class="line-removed">714         assert(result == None, &quot;sanity&quot;);</span>
<span class="line-removed">715         result = MadeZombie;</span>
<span class="line-removed">716         assert(cm-&gt;is_zombie(), &quot;nmethod must be zombie&quot;);</span>
<span class="line-removed">717       }</span>
718     } else {
719       // Still alive, clean up its inline caches
720       cm-&gt;cleanup_inline_caches(false);
721       SWEEP(cm);
722     }
723   } else if (cm-&gt;is_unloaded()) {
724     // Code is unloaded, so there are no activations on the stack.
<span class="line-modified">725     // Convert the nmethod to zombie or flush it directly in the OSR case.</span>
<span class="line-modified">726     if (cm-&gt;is_osr_method()) {</span>
<span class="line-modified">727       SWEEP(cm);</span>
<span class="line-modified">728       // No inline caches will ever point to osr methods, so we can just remove it</span>
<span class="line-modified">729       cm-&gt;flush();</span>
<span class="line-modified">730       assert(result == None, &quot;sanity&quot;);</span>
<span class="line-removed">731       result = Flushed;</span>
<span class="line-removed">732     } else {</span>
<span class="line-removed">733       // Code cache state change is tracked in make_zombie()</span>
<span class="line-removed">734       cm-&gt;make_zombie();</span>
<span class="line-removed">735       SWEEP(cm);</span>
<span class="line-removed">736       assert(result == None, &quot;sanity&quot;);</span>
<span class="line-removed">737       result = MadeZombie;</span>
<span class="line-removed">738     }</span>
739   } else {
740     if (cm-&gt;is_nmethod()) {
741       possibly_flush((nmethod*)cm);
742     }
743     // Clean inline caches that point to zombie/non-entrant/unloaded nmethods
744     cm-&gt;cleanup_inline_caches(false);
745     SWEEP(cm);
746   }
747   return result;
748 }
749 
750 
751 void NMethodSweeper::possibly_flush(nmethod* nm) {
752   if (UseCodeCacheFlushing) {
753     if (!nm-&gt;is_locked_by_vm() &amp;&amp; !nm-&gt;is_native_method() &amp;&amp; !nm-&gt;is_not_installed() &amp;&amp; !nm-&gt;is_unloading()) {
754       bool make_not_entrant = false;
755 
756       // Do not make native methods not-entrant
757       nm-&gt;dec_hotness_counter();
758       // Get the initial value of the hotness counter. This value depends on the
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/compiledIC.hpp&quot;
 28 #include &quot;code/icBuffer.hpp&quot;
 29 #include &quot;code/nmethod.hpp&quot;
 30 #include &quot;compiler/compileBroker.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;gc/shared/workgroup.hpp&quot;
 33 #include &quot;jfr/jfrEvents.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;memory/universe.hpp&quot;
 39 #include &quot;oops/method.hpp&quot;


 40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 41 #include &quot;runtime/handshake.hpp&quot;
 42 #include &quot;runtime/mutexLocker.hpp&quot;
 43 #include &quot;runtime/orderAccess.hpp&quot;
 44 #include &quot;runtime/os.hpp&quot;
 45 #include &quot;runtime/sweeper.hpp&quot;
 46 #include &quot;runtime/thread.inline.hpp&quot;
 47 #include &quot;runtime/vmOperations.hpp&quot;
 48 #include &quot;runtime/vmThread.hpp&quot;
 49 #include &quot;utilities/events.hpp&quot;
 50 #include &quot;utilities/xmlstream.hpp&quot;
 51 
 52 #ifdef ASSERT
 53 
 54 #define SWEEP(nm) record_sweep(nm, __LINE__)
 55 // Sweeper logging code
 56 class SweeperRecord {
 57  public:
 58   int traversal;
 59   int compile_id;
</pre>
<hr />
<pre>
180 public:
181   virtual void do_code_blob(CodeBlob* cb) {
182     assert(cb-&gt;is_nmethod(), &quot;CodeBlob should be nmethod&quot;);
183     nmethod* nm = (nmethod*)cb;
184     nm-&gt;set_hotness_counter(NMethodSweeper::hotness_counter_reset_val());
185   }
186 };
187 static SetHotnessClosure set_hotness_closure;
188 
189 
190 int NMethodSweeper::hotness_counter_reset_val() {
191   if (_hotness_counter_reset_val == 0) {
192     _hotness_counter_reset_val = (ReservedCodeCacheSize &lt; M) ? 1 : (ReservedCodeCacheSize / M) * 2;
193   }
194   return _hotness_counter_reset_val;
195 }
196 bool NMethodSweeper::wait_for_stack_scanning() {
197   return _current.end();
198 }
199 
<span class="line-modified">200 class NMethodMarkingClosure : public HandshakeClosure {</span>
201 private:
202   CodeBlobClosure* _cl;
203 public:
<span class="line-modified">204   NMethodMarkingClosure(CodeBlobClosure* cl) : HandshakeClosure(&quot;NMethodMarking&quot;), _cl(cl) {}</span>
205   void do_thread(Thread* thread) {
206     if (thread-&gt;is_Java_thread() &amp;&amp; ! thread-&gt;is_Code_cache_sweeper_thread()) {
207       JavaThread* jt = (JavaThread*) thread;
208       jt-&gt;nmethods_do(_cl);
209     }
210   }
211 };
212 
213 class NMethodMarkingTask : public AbstractGangTask {
214 private:
<span class="line-modified">215   NMethodMarkingClosure* _cl;</span>
216 public:
<span class="line-modified">217   NMethodMarkingTask(NMethodMarkingClosure* cl) :</span>
218     AbstractGangTask(&quot;Parallel NMethod Marking&quot;),
219     _cl(cl) {
<span class="line-modified">220     Threads::change_thread_claim_token();</span>
221   }
222 
223   ~NMethodMarkingTask() {
224     Threads::assert_all_threads_claimed();
225   }
226 
227   void work(uint worker_id) {
228     Threads::possibly_parallel_threads_do(true, _cl);
229   }
230 };
231 
232 /**
233   * Scans the stacks of all Java threads and marks activations of not-entrant methods.
234   * No need to synchronize access, since &#39;mark_active_nmethods&#39; is always executed at a
235   * safepoint.
236   */
237 void NMethodSweeper::mark_active_nmethods() {
238   CodeBlobClosure* cl = prepare_mark_active_nmethods();
239   if (cl != NULL) {
240     WorkGang* workers = Universe::heap()-&gt;get_safepoint_workers();
241     if (workers != NULL) {
<span class="line-modified">242       NMethodMarkingClosure tcl(cl);</span>
243       NMethodMarkingTask task(&amp;tcl);
244       workers-&gt;run_task(&amp;task);
245     } else {
246       Threads::nmethods_do(cl);
247     }
248   }
249 }
250 
251 CodeBlobClosure* NMethodSweeper::prepare_mark_active_nmethods() {
252 #ifdef ASSERT
<span class="line-modified">253   if (SafepointMechanism::uses_thread_local_poll()) {</span>
254     assert(Thread::current()-&gt;is_Code_cache_sweeper_thread(), &quot;must be executed under CodeCache_lock and in sweeper thread&quot;);
255     assert_lock_strong(CodeCache_lock);
256   } else {
257     assert(SafepointSynchronize::is_at_safepoint(), &quot;must be executed at a safepoint&quot;);
258   }
259 #endif
260 
261   // If we do not want to reclaim not-entrant or zombie methods there is no need
262   // to scan stacks
263   if (!MethodFlushing) {
264     return NULL;
265   }
266 
267   // Increase time so that we can estimate when to invoke the sweeper again.
268   _time_counter++;
269 
270   // Check for restart
271   assert(_current.method() == NULL, &quot;should only happen between sweeper cycles&quot;);
272   assert(wait_for_stack_scanning(), &quot;should only happen between sweeper cycles&quot;);
273 
</pre>
<hr />
<pre>
300   if (_current.method() != NULL) {
301     if (_current.method()-&gt;is_nmethod()) {
302       assert(CodeCache::find_blob_unsafe(_current.method()) == _current.method(), &quot;Sweeper nmethod cached state invalid&quot;);
303     } else if (_current.method()-&gt;is_aot()) {
304       assert(CodeCache::find_blob_unsafe(_current.method()-&gt;code_begin()) == _current.method(), &quot;Sweeper AOT method cached state invalid&quot;);
305     } else {
306       ShouldNotReachHere();
307     }
308   }
309 
310   return &amp;set_hotness_closure;
311 }
312 
313 /**
314   * This function triggers a VM operation that does stack scanning of active
315   * methods. Stack scanning is mandatory for the sweeper to make progress.
316   */
317 void NMethodSweeper::do_stack_scanning() {
318   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
319   if (wait_for_stack_scanning()) {
<span class="line-modified">320     if (SafepointMechanism::uses_thread_local_poll()) {</span>
321       CodeBlobClosure* code_cl;
322       {
<span class="line-modified">323         MutexLocker ccl(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
324         code_cl = prepare_mark_active_nmethods();
325       }
326       if (code_cl != NULL) {
<span class="line-modified">327         NMethodMarkingClosure nm_cl(code_cl);</span>
<span class="line-modified">328         Handshake::execute(&amp;nm_cl);</span>
329       }
330     } else {
331       VM_MarkActiveNMethods op;
332       VMThread::execute(&amp;op);
333     }
334   }
335 }
336 
337 void NMethodSweeper::sweeper_loop() {
338   bool timeout;
339   while (true) {
340     {
341       ThreadBlockInVM tbivm(JavaThread::current());
<span class="line-modified">342       MonitorLocker waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
343       const long wait_time = 60*60*24 * 1000;
<span class="line-modified">344       timeout = waiter.wait(wait_time);</span>
345     }
346     if (!timeout) {
347       possibly_sweep();
348     }
349   }
350 }
351 
352 /**
353   * Wakes up the sweeper thread to possibly sweep.
354   */
355 void NMethodSweeper::notify(int code_blob_type) {
356   // Makes sure that we do not invoke the sweeper too often during startup.
357   double start_threshold = 100.0 / (double)StartAggressiveSweepingAt;
358   double aggressive_sweep_threshold = MIN2(start_threshold, 1.1);
359   if (CodeCache::reverse_free_ratio(code_blob_type) &gt;= aggressive_sweep_threshold) {
360     assert_locked_or_safepoint(CodeCache_lock);
361     CodeCache_lock-&gt;notify();
362   }
363 }
364 
365 /**
366   * Wakes up the sweeper thread and forces a sweep. Blocks until it finished.
367   */
368 void NMethodSweeper::force_sweep() {
369   ThreadBlockInVM tbivm(JavaThread::current());
<span class="line-modified">370   MonitorLocker waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
371   // Request forced sweep
372   _force_sweep = true;
373   while (_force_sweep) {
374     // Notify sweeper that we want to force a sweep and wait for completion.
375     // In case a sweep currently takes place we timeout and try again because
376     // we want to enforce a full sweep.
377     CodeCache_lock-&gt;notify();
<span class="line-modified">378     waiter.wait(1000);</span>
379   }
380 }
381 
382 /**
383  * Handle a safepoint request
384  */
385 void NMethodSweeper::handle_safepoint_request() {
386   JavaThread* thread = JavaThread::current();
387   if (SafepointMechanism::should_block(thread)) {
388     if (PrintMethodFlushing &amp;&amp; Verbose) {
389       tty-&gt;print_cr(&quot;### Sweep at %d out of %d, yielding to safepoint&quot;, _seen, CodeCache::nmethod_count());
390     }
<span class="line-modified">391     MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
392 
393     ThreadBlockInVM tbivm(thread);
394     thread-&gt;java_suspend_self();
395   }
396 }
397 
398 /**
399  * This function invokes the sweeper if at least one of the three conditions is met:
400  *    (1) The code cache is getting full
401  *    (2) There are sufficient state changes in/since the last sweep.
402  *    (3) We have not been sweeping for &#39;some time&#39;
403  */
404 void NMethodSweeper::possibly_sweep() {
405   assert(JavaThread::current()-&gt;thread_state() == _thread_in_vm, &quot;must run in vm mode&quot;);
406   // If there was no state change while nmethod sweeping, &#39;should_sweep&#39; will be false.
407   // This is one of the two places where should_sweep can be set to true. The general
408   // idea is as follows: If there is enough free space in the code cache, there is no
409   // need to invoke the sweeper. The following formula (which determines whether to invoke
410   // the sweeper or not) depends on the assumption that for larger ReservedCodeCacheSizes
411   // we need less frequent sweeps than for smaller ReservedCodecCacheSizes. Furthermore,
</pre>
<hr />
<pre>
456     sweep_code_cache();
457   }
458 
459   // We are done with sweeping the code cache once.
460   _total_nof_code_cache_sweeps++;
461   _last_sweep = _time_counter;
462   // Reset flag; temporarily disables sweeper
463   _should_sweep = false;
464   // If there was enough state change, &#39;possibly_enable_sweeper()&#39;
465   // sets &#39;_should_sweep&#39; to true
466   possibly_enable_sweeper();
467   // Reset _bytes_changed only if there was enough state change. _bytes_changed
468   // can further increase by calls to &#39;report_state_change&#39;.
469   if (_should_sweep) {
470     _bytes_changed = 0;
471   }
472 
473   if (forced) {
474     // Notify requester that forced sweep finished
475     assert(_force_sweep, &quot;Should be a forced sweep&quot;);
<span class="line-modified">476     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
477     _force_sweep = false;
478     CodeCache_lock-&gt;notify();
479   }
480 }
481 
482 static void post_sweep_event(EventSweepCodeCache* event,
483                              const Ticks&amp; start,
484                              const Ticks&amp; end,
485                              s4 traversals,
486                              int swept,
487                              int flushed,
488                              int zombified) {
489   assert(event != NULL, &quot;invariant&quot;);
490   assert(event-&gt;should_commit(), &quot;invariant&quot;);
491   event-&gt;set_starttime(start);
492   event-&gt;set_endtime(end);
493   event-&gt;set_sweepId(traversals);
494   event-&gt;set_sweptCount(swept);
495   event-&gt;set_flushedCount(flushed);
496   event-&gt;set_zombifiedCount(zombified);
</pre>
<hr />
<pre>
500 void NMethodSweeper::sweep_code_cache() {
501   ResourceMark rm;
502   Ticks sweep_start_counter = Ticks::now();
503 
504   log_debug(codecache, sweep, start)(&quot;CodeCache flushing&quot;);
505 
506   int flushed_count                = 0;
507   int zombified_count              = 0;
508   int flushed_c2_count     = 0;
509 
510   if (PrintMethodFlushing &amp;&amp; Verbose) {
511     tty-&gt;print_cr(&quot;### Sweep at %d out of %d&quot;, _seen, CodeCache::nmethod_count());
512   }
513 
514   int swept_count = 0;
515   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be in safepoint when we get here&quot;);
516   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
517 
518   int freed_memory = 0;
519   {
<span class="line-modified">520     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
521 
522     while (!_current.end()) {
523       swept_count++;
524       // Since we will give up the CodeCache_lock, always skip ahead
525       // to the next nmethod.  Other blobs can be deleted by other
526       // threads but nmethods are only reclaimed by the sweeper.
527       CompiledMethod* nm = _current.method();
528       _current.next();
529 
530       // Now ready to process nmethod and give up CodeCache_lock
531       {
<span class="line-modified">532         MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
533         // Save information before potentially flushing the nmethod
534         // Only flushing nmethods so size only matters for them.
535         int size = nm-&gt;is_nmethod() ? ((nmethod*)nm)-&gt;total_size() : 0;
536         bool is_c2_method = nm-&gt;is_compiled_by_c2();
537         bool is_osr = nm-&gt;is_osr_method();
538         int compile_id = nm-&gt;compile_id();
539         intptr_t address = p2i(nm);
540         const char* state_before = nm-&gt;state();
541         const char* state_after = &quot;&quot;;
542 
543         MethodStateChange type = process_compiled_method(nm);
544         switch (type) {
545           case Flushed:
546             state_after = &quot;flushed&quot;;
547             freed_memory += size;
548             ++flushed_count;
549             if (is_c2_method) {
550               ++flushed_c2_count;
551             }
552             break;
</pre>
<hr />
<pre>
557           case None:
558             break;
559           default:
560            ShouldNotReachHere();
561         }
562         if (PrintMethodFlushing &amp;&amp; Verbose &amp;&amp; type != None) {
563           tty-&gt;print_cr(&quot;### %s nmethod %3d/&quot; PTR_FORMAT &quot; (%s) %s&quot;, is_osr ? &quot;osr&quot; : &quot;&quot;, compile_id, address, state_before, state_after);
564         }
565       }
566 
567       _seen++;
568       handle_safepoint_request();
569     }
570   }
571 
572   assert(_current.end(), &quot;must have scanned the whole cache&quot;);
573 
574   const Ticks sweep_end_counter = Ticks::now();
575   const Tickspan sweep_time = sweep_end_counter - sweep_start_counter;
576   {
<span class="line-modified">577     MutexLocker mu(NMethodSweeperStats_lock, Mutex::_no_safepoint_check_flag);</span>
578     _total_time_sweeping  += sweep_time;
579     _total_time_this_sweep += sweep_time;
580     _peak_sweep_fraction_time = MAX2(sweep_time, _peak_sweep_fraction_time);
581     _total_flushed_size += freed_memory;
582     _total_nof_methods_reclaimed += flushed_count;
583     _total_nof_c2_methods_reclaimed += flushed_c2_count;
584     _peak_sweep_time = MAX2(_peak_sweep_time, _total_time_this_sweep);
585   }
586 
587   EventSweepCodeCache event(UNTIMED);
588   if (event.should_commit()) {
589     post_sweep_event(&amp;event, sweep_start_counter, sweep_end_counter, (s4)_traversals, swept_count, flushed_count, zombified_count);
590   }
591 
592 #ifdef ASSERT
593   if(PrintMethodFlushing) {
594     tty-&gt;print_cr(&quot;### sweeper:      sweep time(&quot; JLONG_FORMAT &quot;): &quot;, sweep_time.value());
595   }
596 #endif
597 
</pre>
<hr />
<pre>
680       SWEEP(cm);
681     }
682     return result;
683   }
684 
685   if (cm-&gt;is_zombie()) {
686     // All inline caches that referred to this nmethod were cleaned in the
687     // previous sweeper cycle. Now flush the nmethod from the code cache.
688     assert(!cm-&gt;is_locked_by_vm(), &quot;must not flush locked Compiled Methods&quot;);
689     cm-&gt;flush();
690     assert(result == None, &quot;sanity&quot;);
691     result = Flushed;
692   } else if (cm-&gt;is_not_entrant()) {
693     // If there are no current activations of this method on the
694     // stack we can safely convert it to a zombie method
695     OrderAccess::loadload(); // _stack_traversal_mark and _state
696     if (cm-&gt;can_convert_to_zombie()) {
697       // Code cache state change is tracked in make_zombie()
698       cm-&gt;make_zombie();
699       SWEEP(cm);
<span class="line-modified">700       assert(result == None, &quot;sanity&quot;);</span>
<span class="line-modified">701       result = MadeZombie;</span>
<span class="line-modified">702       assert(cm-&gt;is_zombie(), &quot;nmethod must be zombie&quot;);</span>













703     } else {
704       // Still alive, clean up its inline caches
705       cm-&gt;cleanup_inline_caches(false);
706       SWEEP(cm);
707     }
708   } else if (cm-&gt;is_unloaded()) {
709     // Code is unloaded, so there are no activations on the stack.
<span class="line-modified">710     // Convert the nmethod to zombie.</span>
<span class="line-modified">711     // Code cache state change is tracked in make_zombie()</span>
<span class="line-modified">712     cm-&gt;make_zombie();</span>
<span class="line-modified">713     SWEEP(cm);</span>
<span class="line-modified">714     assert(result == None, &quot;sanity&quot;);</span>
<span class="line-modified">715     result = MadeZombie;</span>








716   } else {
717     if (cm-&gt;is_nmethod()) {
718       possibly_flush((nmethod*)cm);
719     }
720     // Clean inline caches that point to zombie/non-entrant/unloaded nmethods
721     cm-&gt;cleanup_inline_caches(false);
722     SWEEP(cm);
723   }
724   return result;
725 }
726 
727 
728 void NMethodSweeper::possibly_flush(nmethod* nm) {
729   if (UseCodeCacheFlushing) {
730     if (!nm-&gt;is_locked_by_vm() &amp;&amp; !nm-&gt;is_native_method() &amp;&amp; !nm-&gt;is_not_installed() &amp;&amp; !nm-&gt;is_unloading()) {
731       bool make_not_entrant = false;
732 
733       // Do not make native methods not-entrant
734       nm-&gt;dec_hotness_counter();
735       // Get the initial value of the hotness counter. This value depends on the
</pre>
</td>
</tr>
</table>
<center><a href="stubRoutines.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
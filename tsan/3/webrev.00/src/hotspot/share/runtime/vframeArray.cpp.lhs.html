<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/vframeArray.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/vmSymbols.hpp&quot;
 27 #include &quot;code/vmreg.inline.hpp&quot;
 28 #include &quot;interpreter/bytecode.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;oops/methodData.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;prims/jvmtiThreadState.hpp&quot;
 36 #include &quot;runtime/frame.inline.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/monitorChunk.hpp&quot;
 39 #include &quot;runtime/sharedRuntime.hpp&quot;
 40 #include &quot;runtime/vframe.hpp&quot;
 41 #include &quot;runtime/vframeArray.hpp&quot;
 42 #include &quot;runtime/vframe_hp.hpp&quot;
 43 #include &quot;utilities/copy.hpp&quot;
 44 #include &quot;utilities/events.hpp&quot;
 45 #ifdef COMPILER2
 46 #include &quot;opto/runtime.hpp&quot;
 47 #endif
 48 
 49 int vframeArrayElement:: bci(void) const { return (_bci == SynchronizationEntryBCI ? 0 : _bci); }
 50 
 51 void vframeArrayElement::free_monitors(JavaThread* jt) {
 52   if (_monitors != NULL) {
 53      MonitorChunk* chunk = _monitors;
 54      _monitors = NULL;
 55      jt-&gt;remove_monitor_chunk(chunk);
 56      delete chunk;
 57   }
 58 }
 59 
 60 void vframeArrayElement::fill_in(compiledVFrame* vf, bool realloc_failures) {
 61 
 62 // Copy the information from the compiled vframe to the
 63 // interpreter frame we will be creating to replace vf
 64 
 65   _method = vf-&gt;method();
 66   _bci    = vf-&gt;raw_bci();
 67   _reexecute = vf-&gt;should_reexecute();
 68 #ifdef ASSERT
 69   _removed_monitors = false;
 70 #endif
 71 
 72   int index;
 73 
 74   // Get the monitors off-stack
 75 
 76   GrowableArray&lt;MonitorInfo*&gt;* list = vf-&gt;monitors();
 77   if (list-&gt;is_empty()) {
 78     _monitors = NULL;
 79   } else {
 80 
 81     // Allocate monitor chunk
 82     _monitors = new MonitorChunk(list-&gt;length());
 83     vf-&gt;thread()-&gt;add_monitor_chunk(_monitors);
 84 
 85     // Migrate the BasicLocks from the stack to the monitor chunk
 86     for (index = 0; index &lt; list-&gt;length(); index++) {
 87       MonitorInfo* monitor = list-&gt;at(index);
 88       assert(!monitor-&gt;owner_is_scalar_replaced() || realloc_failures, &quot;object should be reallocated already&quot;);
 89       BasicObjectLock* dest = _monitors-&gt;at(index);
 90       if (monitor-&gt;owner_is_scalar_replaced()) {
 91         dest-&gt;set_obj(NULL);
 92       } else {
 93         assert(monitor-&gt;owner() == NULL || (!monitor-&gt;owner()-&gt;is_unlocked() &amp;&amp; !monitor-&gt;owner()-&gt;has_bias_pattern()), &quot;object must be null or locked, and unbiased&quot;);
 94         dest-&gt;set_obj(monitor-&gt;owner());
 95         monitor-&gt;lock()-&gt;move_to(monitor-&gt;owner(), dest-&gt;lock());
 96       }
 97     }
 98   }
 99 
100   // Convert the vframe locals and expressions to off stack
101   // values. Because we will not gc all oops can be converted to
102   // intptr_t (i.e. a stack slot) and we are fine. This is
103   // good since we are inside a HandleMark and the oops in our
104   // collection would go away between packing them here and
105   // unpacking them in unpack_on_stack.
106 
107   // First the locals go off-stack
108 
109   // FIXME this seems silly it creates a StackValueCollection
110   // in order to get the size to then copy them and
111   // convert the types to intptr_t size slots. Seems like it
112   // could do it in place... Still uses less memory than the
113   // old way though
114 
115   StackValueCollection *locs = vf-&gt;locals();
116   _locals = new StackValueCollection(locs-&gt;size());
117   for(index = 0; index &lt; locs-&gt;size(); index++) {
118     StackValue* value = locs-&gt;at(index);
119     switch(value-&gt;type()) {
120       case T_OBJECT:
121         assert(!value-&gt;obj_is_scalar_replaced() || realloc_failures, &quot;object should be reallocated already&quot;);
122         // preserve object type
123         _locals-&gt;add( new StackValue(cast_from_oop&lt;intptr_t&gt;((value-&gt;get_obj()())), T_OBJECT ));
124         break;
125       case T_CONFLICT:
126         // A dead local.  Will be initialized to null/zero.
127         _locals-&gt;add( new StackValue());
128         break;
129       case T_INT:
130         _locals-&gt;add( new StackValue(value-&gt;get_int()));
131         break;
132       default:
133         ShouldNotReachHere();
134     }
135   }
136 
137   // Now the expressions off-stack
138   // Same silliness as above
139 
140   StackValueCollection *exprs = vf-&gt;expressions();
141   _expressions = new StackValueCollection(exprs-&gt;size());
142   for(index = 0; index &lt; exprs-&gt;size(); index++) {
143     StackValue* value = exprs-&gt;at(index);
144     switch(value-&gt;type()) {
145       case T_OBJECT:
146         assert(!value-&gt;obj_is_scalar_replaced() || realloc_failures, &quot;object should be reallocated already&quot;);
147         // preserve object type
148         _expressions-&gt;add( new StackValue(cast_from_oop&lt;intptr_t&gt;((value-&gt;get_obj()())), T_OBJECT ));
149         break;
150       case T_CONFLICT:
151         // A dead stack element.  Will be initialized to null/zero.
152         // This can occur when the compiler emits a state in which stack
153         // elements are known to be dead (because of an imminent exception).
154         _expressions-&gt;add( new StackValue());
155         break;
156       case T_INT:
157         _expressions-&gt;add( new StackValue(value-&gt;get_int()));
158         break;
159       default:
160         ShouldNotReachHere();
161     }
162   }
163 }
164 
165 int unpack_counter = 0;
166 
167 void vframeArrayElement::unpack_on_stack(int caller_actual_parameters,
168                                          int callee_parameters,
169                                          int callee_locals,
170                                          frame* caller,
171                                          bool is_top_frame,
172                                          bool is_bottom_frame,
173                                          int exec_mode) {
174   JavaThread* thread = (JavaThread*) Thread::current();
175 
176   bool realloc_failure_exception = thread-&gt;frames_to_pop_failed_realloc() &gt; 0;
177 
178   // Look at bci and decide on bcp and continuation pc
179   address bcp;
180   // C++ interpreter doesn&#39;t need a pc since it will figure out what to do when it
181   // begins execution
182   address pc;
183   bool use_next_mdp = false; // true if we should use the mdp associated with the next bci
184                              // rather than the one associated with bcp
185   if (raw_bci() == SynchronizationEntryBCI) {
186     // We are deoptimizing while hanging in prologue code for synchronized method
187     bcp = method()-&gt;bcp_from(0); // first byte code
188     pc  = Interpreter::deopt_entry(vtos, 0); // step = 0 since we don&#39;t skip current bytecode
189   } else if (should_reexecute()) { //reexecute this bytecode
190     assert(is_top_frame, &quot;reexecute allowed only for the top frame&quot;);
191     bcp = method()-&gt;bcp_from(bci());
192     pc  = Interpreter::deopt_reexecute_entry(method(), bcp);
193   } else {
194     bcp = method()-&gt;bcp_from(bci());
195     pc  = Interpreter::deopt_continue_after_entry(method(), bcp, callee_parameters, is_top_frame);
196     use_next_mdp = true;
197   }
198   assert(Bytecodes::is_defined(*bcp), &quot;must be a valid bytecode&quot;);
199 
200   // Monitorenter and pending exceptions:
201   //
202   // For Compiler2, there should be no pending exception when deoptimizing at monitorenter
203   // because there is no safepoint at the null pointer check (it is either handled explicitly
204   // or prior to the monitorenter) and asynchronous exceptions are not made &quot;pending&quot; by the
205   // runtime interface for the slow case (see JRT_ENTRY_FOR_MONITORENTER).  If an asynchronous
206   // exception was processed, the bytecode pointer would have to be extended one bytecode beyond
207   // the monitorenter to place it in the proper exception range.
208   //
209   // For Compiler1, deoptimization can occur while throwing a NullPointerException at monitorenter,
210   // in which case bcp should point to the monitorenter since it is within the exception&#39;s range.
211   //
212   // For realloc failure exception we just pop frames, skip the guarantee.
213 
214   assert(*bcp != Bytecodes::_monitorenter || is_top_frame, &quot;a _monitorenter must be a top frame&quot;);
215   assert(thread-&gt;deopt_compiled_method() != NULL, &quot;compiled method should be known&quot;);
216   guarantee(realloc_failure_exception || !(thread-&gt;deopt_compiled_method()-&gt;is_compiled_by_c2() &amp;&amp;
217               *bcp == Bytecodes::_monitorenter             &amp;&amp;
218               exec_mode == Deoptimization::Unpack_exception),
219             &quot;shouldn&#39;t get exception during monitorenter&quot;);
220 
221   int popframe_preserved_args_size_in_bytes = 0;
222   int popframe_preserved_args_size_in_words = 0;
223   if (is_top_frame) {
224     JvmtiThreadState *state = thread-&gt;jvmti_thread_state();
225     if (JvmtiExport::can_pop_frame() &amp;&amp;
226         (thread-&gt;has_pending_popframe() || thread-&gt;popframe_forcing_deopt_reexecution())) {
227       if (thread-&gt;has_pending_popframe()) {
228         // Pop top frame after deoptimization
229 #ifndef CC_INTERP
230         pc = Interpreter::remove_activation_preserving_args_entry();
231 #else
232         // Do an uncommon trap type entry. c++ interpreter will know
233         // to pop frame and preserve the args
234         pc = Interpreter::deopt_entry(vtos, 0);
235         use_next_mdp = false;
236 #endif
237       } else {
238         // Reexecute invoke in top frame
239         pc = Interpreter::deopt_entry(vtos, 0);
240         use_next_mdp = false;
241         popframe_preserved_args_size_in_bytes = in_bytes(thread-&gt;popframe_preserved_args_size());
242         // Note: the PopFrame-related extension of the expression stack size is done in
243         // Deoptimization::fetch_unroll_info_helper
244         popframe_preserved_args_size_in_words = in_words(thread-&gt;popframe_preserved_args_size_in_words());
245       }
246     } else if (!realloc_failure_exception &amp;&amp; JvmtiExport::can_force_early_return() &amp;&amp; state != NULL &amp;&amp; state-&gt;is_earlyret_pending()) {
247       // Force early return from top frame after deoptimization
248 #ifndef CC_INTERP
249       pc = Interpreter::remove_activation_early_entry(state-&gt;earlyret_tos());
250 #endif
251     } else {
252       if (realloc_failure_exception &amp;&amp; JvmtiExport::can_force_early_return() &amp;&amp; state != NULL &amp;&amp; state-&gt;is_earlyret_pending()) {
253         state-&gt;clr_earlyret_pending();
254         state-&gt;set_earlyret_oop(NULL);
255         state-&gt;clr_earlyret_value();
256       }
257       // Possibly override the previous pc computation of the top (youngest) frame
258       switch (exec_mode) {
259       case Deoptimization::Unpack_deopt:
260         // use what we&#39;ve got
261         break;
262       case Deoptimization::Unpack_exception:
263         // exception is pending
264         pc = SharedRuntime::raw_exception_handler_for_return_address(thread, pc);
265         // [phh] We&#39;re going to end up in some handler or other, so it doesn&#39;t
266         // matter what mdp we point to.  See exception_handler_for_exception()
267         // in interpreterRuntime.cpp.
268         break;
269       case Deoptimization::Unpack_uncommon_trap:
270       case Deoptimization::Unpack_reexecute:
271         // redo last byte code
272         pc  = Interpreter::deopt_entry(vtos, 0);
273         use_next_mdp = false;
274         break;
275       default:
276         ShouldNotReachHere();
277       }
278     }
279   }
280 
281   // Setup the interpreter frame
282 
283   assert(method() != NULL, &quot;method must exist&quot;);
284   int temps = expressions()-&gt;size();
285 
286   int locks = monitors() == NULL ? 0 : monitors()-&gt;number_of_monitors();
287 
288   Interpreter::layout_activation(method(),
289                                  temps + callee_parameters,
290                                  popframe_preserved_args_size_in_words,
291                                  locks,
292                                  caller_actual_parameters,
293                                  callee_parameters,
294                                  callee_locals,
295                                  caller,
296                                  iframe(),
297                                  is_top_frame,
298                                  is_bottom_frame);
299 
300   // Update the pc in the frame object and overwrite the temporary pc
301   // we placed in the skeletal frame now that we finally know the
302   // exact interpreter address we should use.
303 
304   _frame.patch_pc(thread, pc);
305 
306   assert (!method()-&gt;is_synchronized() || locks &gt; 0 || _removed_monitors || raw_bci() == SynchronizationEntryBCI, &quot;synchronized methods must have monitors&quot;);
307 
308   BasicObjectLock* top = iframe()-&gt;interpreter_frame_monitor_begin();
309   for (int index = 0; index &lt; locks; index++) {
310     top = iframe()-&gt;previous_monitor_in_interpreter_frame(top);
311     BasicObjectLock* src = _monitors-&gt;at(index);
312     top-&gt;set_obj(src-&gt;obj());
313     src-&gt;lock()-&gt;move_to(src-&gt;obj(), top-&gt;lock());
314   }
315   if (ProfileInterpreter) {
316     iframe()-&gt;interpreter_frame_set_mdp(0); // clear out the mdp.
317   }
318   iframe()-&gt;interpreter_frame_set_bcp(bcp);
319   if (ProfileInterpreter) {
320     MethodData* mdo = method()-&gt;method_data();
321     if (mdo != NULL) {
322       int bci = iframe()-&gt;interpreter_frame_bci();
323       if (use_next_mdp) ++bci;
324       address mdp = mdo-&gt;bci_to_dp(bci);
325       iframe()-&gt;interpreter_frame_set_mdp(mdp);
326     }
327   }
328 
329   if (PrintDeoptimizationDetails) {
330     tty-&gt;print_cr(&quot;Expressions size: %d&quot;, expressions()-&gt;size());
331   }
332 
333   // Unpack expression stack
334   // If this is an intermediate frame (i.e. not top frame) then this
335   // only unpacks the part of the expression stack not used by callee
336   // as parameters. The callee parameters are unpacked as part of the
337   // callee locals.
338   int i;
339   for(i = 0; i &lt; expressions()-&gt;size(); i++) {
340     StackValue *value = expressions()-&gt;at(i);
341     intptr_t*   addr  = iframe()-&gt;interpreter_frame_expression_stack_at(i);
342     switch(value-&gt;type()) {
343       case T_INT:
344         *addr = value-&gt;get_int();
345 #ifndef PRODUCT
346         if (PrintDeoptimizationDetails) {
347           tty-&gt;print_cr(&quot;Reconstructed expression %d (INT): %d&quot;, i, (int)(*addr));
348         }
349 #endif
350         break;
351       case T_OBJECT:
352         *addr = value-&gt;get_int(T_OBJECT);
353 #ifndef PRODUCT
354         if (PrintDeoptimizationDetails) {
355           tty-&gt;print(&quot;Reconstructed expression %d (OBJECT): &quot;, i);
356           oop o = (oop)(address)(*addr);
357           if (o == NULL) {
358             tty-&gt;print_cr(&quot;NULL&quot;);
359           } else {
360             ResourceMark rm;
361             tty-&gt;print_raw_cr(o-&gt;klass()-&gt;name()-&gt;as_C_string());
362           }
363         }
364 #endif
365         break;
366       case T_CONFLICT:
367         // A dead stack slot.  Initialize to null in case it is an oop.
368         *addr = NULL_WORD;
369         break;
370       default:
371         ShouldNotReachHere();
372     }
373   }
374 
375 
376   // Unpack the locals
377   for(i = 0; i &lt; locals()-&gt;size(); i++) {
378     StackValue *value = locals()-&gt;at(i);
379     intptr_t* addr  = iframe()-&gt;interpreter_frame_local_at(i);
380     switch(value-&gt;type()) {
381       case T_INT:
382         *addr = value-&gt;get_int();
383 #ifndef PRODUCT
384         if (PrintDeoptimizationDetails) {
385           tty-&gt;print_cr(&quot;Reconstructed local %d (INT): %d&quot;, i, (int)(*addr));
386         }
387 #endif
388         break;
389       case T_OBJECT:
390         *addr = value-&gt;get_int(T_OBJECT);
391 #ifndef PRODUCT
392         if (PrintDeoptimizationDetails) {
393           tty-&gt;print(&quot;Reconstructed local %d (OBJECT): &quot;, i);
394           oop o = (oop)(address)(*addr);
395           if (o == NULL) {
396             tty-&gt;print_cr(&quot;NULL&quot;);
397           } else {
398             ResourceMark rm;
399             tty-&gt;print_raw_cr(o-&gt;klass()-&gt;name()-&gt;as_C_string());
400           }
401         }
402 #endif
403         break;
404       case T_CONFLICT:
405         // A dead location. If it is an oop then we need a NULL to prevent GC from following it
406         *addr = NULL_WORD;
407         break;
408       default:
409         ShouldNotReachHere();
410     }
411   }
412 
413   if (is_top_frame &amp;&amp; JvmtiExport::can_pop_frame() &amp;&amp; thread-&gt;popframe_forcing_deopt_reexecution()) {
414     // An interpreted frame was popped but it returns to a deoptimized
415     // frame. The incoming arguments to the interpreted activation
416     // were preserved in thread-local storage by the
417     // remove_activation_preserving_args_entry in the interpreter; now
418     // we put them back into the just-unpacked interpreter frame.
419     // Note that this assumes that the locals arena grows toward lower
420     // addresses.
421     if (popframe_preserved_args_size_in_words != 0) {
422       void* saved_args = thread-&gt;popframe_preserved_args();
423       assert(saved_args != NULL, &quot;must have been saved by interpreter&quot;);
424 #ifdef ASSERT
425       assert(popframe_preserved_args_size_in_words &lt;=
426              iframe()-&gt;interpreter_frame_expression_stack_size()*Interpreter::stackElementWords,
427              &quot;expression stack size should have been extended&quot;);
428 #endif // ASSERT
429       int top_element = iframe()-&gt;interpreter_frame_expression_stack_size()-1;
430       intptr_t* base;
431       if (frame::interpreter_frame_expression_stack_direction() &lt; 0) {
432         base = iframe()-&gt;interpreter_frame_expression_stack_at(top_element);
433       } else {
434         base = iframe()-&gt;interpreter_frame_expression_stack();
435       }
436       Copy::conjoint_jbytes(saved_args,
437                             base,
438                             popframe_preserved_args_size_in_bytes);
439       thread-&gt;popframe_free_preserved_args();
440     }
441   }
442 
443 #ifndef PRODUCT
444   if (PrintDeoptimizationDetails) {
445     ttyLocker ttyl;
446     tty-&gt;print_cr(&quot;[%d Interpreted Frame]&quot;, ++unpack_counter);
447     iframe()-&gt;print_on(tty);
448     RegisterMap map(thread);
449     vframe* f = vframe::new_vframe(iframe(), &amp;map, thread);
450     f-&gt;print();
451 
452     tty-&gt;print_cr(&quot;locals size     %d&quot;, locals()-&gt;size());
453     tty-&gt;print_cr(&quot;expression size %d&quot;, expressions()-&gt;size());
454 
455     method()-&gt;print_value();
456     tty-&gt;cr();
457     // method()-&gt;print_codes();
458   } else if (TraceDeoptimization) {
459     tty-&gt;print(&quot;     &quot;);
460     method()-&gt;print_value();
461     Bytecodes::Code code = Bytecodes::java_code_at(method(), bcp);
462     int bci = method()-&gt;bci_from(bcp);
463     tty-&gt;print(&quot; - %s&quot;, Bytecodes::name(code));
464     tty-&gt;print(&quot; @ bci %d &quot;, bci);
465     tty-&gt;print_cr(&quot;sp = &quot; PTR_FORMAT, p2i(iframe()-&gt;sp()));
466   }
467 #endif // PRODUCT
468 
469   // The expression stack and locals are in the resource area don&#39;t leave
470   // a dangling pointer in the vframeArray we leave around for debug
471   // purposes
472 
473   _locals = _expressions = NULL;
474 
475 }
476 
477 int vframeArrayElement::on_stack_size(int callee_parameters,
478                                       int callee_locals,
479                                       bool is_top_frame,
480                                       int popframe_extra_stack_expression_els) const {
481   assert(method()-&gt;max_locals() == locals()-&gt;size(), &quot;just checking&quot;);
482   int locks = monitors() == NULL ? 0 : monitors()-&gt;number_of_monitors();
483   int temps = expressions()-&gt;size();
484   return Interpreter::size_activation(method()-&gt;max_stack(),
485                                       temps + callee_parameters,
486                                       popframe_extra_stack_expression_els,
487                                       locks,
488                                       callee_parameters,
489                                       callee_locals,
490                                       is_top_frame);
491 }
492 
493 
494 intptr_t* vframeArray::unextended_sp() const {
495   return _original.unextended_sp();
496 }
497 
498 vframeArray* vframeArray::allocate(JavaThread* thread, int frame_size, GrowableArray&lt;compiledVFrame*&gt;* chunk,
499                                    RegisterMap *reg_map, frame sender, frame caller, frame self,
500                                    bool realloc_failures) {
501 
502   // Allocate the vframeArray
503   vframeArray * result = (vframeArray*) AllocateHeap(sizeof(vframeArray) + // fixed part
504                                                      sizeof(vframeArrayElement) * (chunk-&gt;length() - 1), // variable part
505                                                      mtCompiler);
506   result-&gt;_frames = chunk-&gt;length();
507   result-&gt;_owner_thread = thread;
508   result-&gt;_sender = sender;
509   result-&gt;_caller = caller;
510   result-&gt;_original = self;
511   result-&gt;set_unroll_block(NULL); // initialize it
512   result-&gt;fill_in(thread, frame_size, chunk, reg_map, realloc_failures);
513   return result;
514 }
515 
516 void vframeArray::fill_in(JavaThread* thread,
517                           int frame_size,
518                           GrowableArray&lt;compiledVFrame*&gt;* chunk,
519                           const RegisterMap *reg_map,
520                           bool realloc_failures) {
521   // Set owner first, it is used when adding monitor chunks
522 
523   _frame_size = frame_size;
524   for(int i = 0; i &lt; chunk-&gt;length(); i++) {
525     element(i)-&gt;fill_in(chunk-&gt;at(i), realloc_failures);
526   }
527 
528   // Copy registers for callee-saved registers
529   if (reg_map != NULL) {
530     for(int i = 0; i &lt; RegisterMap::reg_count; i++) {
531 #ifdef AMD64
532       // The register map has one entry for every int (32-bit value), so
533       // 64-bit physical registers have two entries in the map, one for
534       // each half.  Ignore the high halves of 64-bit registers, just like
535       // frame::oopmapreg_to_location does.
536       //
537       // [phh] FIXME: this is a temporary hack!  This code *should* work
538       // correctly w/o this hack, possibly by changing RegisterMap::pd_location
539       // in frame_amd64.cpp and the values of the phantom high half registers
540       // in amd64.ad.
541       //      if (VMReg::Name(i) &lt; SharedInfo::stack0 &amp;&amp; is_even(i)) {
542         intptr_t* src = (intptr_t*) reg_map-&gt;location(VMRegImpl::as_VMReg(i));
543         _callee_registers[i] = src != NULL ? *src : NULL_WORD;
544         //      } else {
545         //      jint* src = (jint*) reg_map-&gt;location(VMReg::Name(i));
546         //      _callee_registers[i] = src != NULL ? *src : NULL_WORD;
547         //      }
548 #else
549       jint* src = (jint*) reg_map-&gt;location(VMRegImpl::as_VMReg(i));
550       _callee_registers[i] = src != NULL ? *src : NULL_WORD;
551 #endif
552       if (src == NULL) {
553         set_location_valid(i, false);
554       } else {
555         set_location_valid(i, true);
556         jint* dst = (jint*) register_location(i);
557         *dst = *src;
558       }
559     }
560   }
561 }
562 
563 void vframeArray::unpack_to_stack(frame &amp;unpack_frame, int exec_mode, int caller_actual_parameters) {
564   // stack picture
565   //   unpack_frame
566   //   [new interpreter frames ] (frames are skeletal but walkable)
567   //   caller_frame
568   //
569   //  This routine fills in the missing data for the skeletal interpreter frames
570   //  in the above picture.
571 
572   // Find the skeletal interpreter frames to unpack into
573   JavaThread* THREAD = JavaThread::current();
574   RegisterMap map(THREAD, false);
575   // Get the youngest frame we will unpack (last to be unpacked)
576   frame me = unpack_frame.sender(&amp;map);
577   int index;
578   for (index = 0; index &lt; frames(); index++ ) {
579     *element(index)-&gt;iframe() = me;
580     // Get the caller frame (possibly skeletal)
581     me = me.sender(&amp;map);
582   }
583 
584   // Do the unpacking of interpreter frames; the frame at index 0 represents the top activation, so it has no callee
585   // Unpack the frames from the oldest (frames() -1) to the youngest (0)
586   frame* caller_frame = &amp;me;
587   for (index = frames() - 1; index &gt;= 0 ; index--) {
588     vframeArrayElement* elem = element(index);  // caller
589     int callee_parameters, callee_locals;
590     if (index == 0) {
591       callee_parameters = callee_locals = 0;
592     } else {
<a name="3" id="anc3"></a><span class="line-modified">593       methodHandle caller = elem-&gt;method();</span>
<span class="line-modified">594       methodHandle callee = element(index - 1)-&gt;method();</span>
595       Bytecode_invoke inv(caller, elem-&gt;bci());
596       // invokedynamic instructions don&#39;t have a class but obviously don&#39;t have a MemberName appendix.
597       // NOTE:  Use machinery here that avoids resolving of any kind.
598       const bool has_member_arg =
599           !inv.is_invokedynamic() &amp;&amp; MethodHandles::has_member_arg(inv.klass(), inv.name());
600       callee_parameters = callee-&gt;size_of_parameters() + (has_member_arg ? 1 : 0);
601       callee_locals     = callee-&gt;max_locals();
602     }
603     elem-&gt;unpack_on_stack(caller_actual_parameters,
604                           callee_parameters,
605                           callee_locals,
606                           caller_frame,
607                           index == 0,
608                           index == frames() - 1,
609                           exec_mode);
610     if (index == frames() - 1) {
611       Deoptimization::unwind_callee_save_values(elem-&gt;iframe(), this);
612     }
613     caller_frame = elem-&gt;iframe();
614     caller_actual_parameters = callee_parameters;
615   }
616   deallocate_monitor_chunks();
617 }
618 
619 void vframeArray::deallocate_monitor_chunks() {
620   JavaThread* jt = JavaThread::current();
621   for (int index = 0; index &lt; frames(); index++ ) {
622      element(index)-&gt;free_monitors(jt);
623   }
624 }
625 
626 #ifndef PRODUCT
627 
628 bool vframeArray::structural_compare(JavaThread* thread, GrowableArray&lt;compiledVFrame*&gt;* chunk) {
629   if (owner_thread() != thread) return false;
630   int index = 0;
631 #if 0 // FIXME can&#39;t do this comparison
632 
633   // Compare only within vframe array.
634   for (deoptimizedVFrame* vf = deoptimizedVFrame::cast(vframe_at(first_index())); vf; vf = vf-&gt;deoptimized_sender_or_null()) {
635     if (index &gt;= chunk-&gt;length() || !vf-&gt;structural_compare(chunk-&gt;at(index))) return false;
636     index++;
637   }
638   if (index != chunk-&gt;length()) return false;
639 #endif
640 
641   return true;
642 }
643 
644 #endif
645 
646 address vframeArray::register_location(int i) const {
647   assert(0 &lt;= i &amp;&amp; i &lt; RegisterMap::reg_count, &quot;index out of bounds&quot;);
648   return (address) &amp; _callee_registers[i];
649 }
650 
651 
652 #ifndef PRODUCT
653 
654 // Printing
655 
656 // Note: we cannot have print_on as const, as we allocate inside the method
657 void vframeArray::print_on_2(outputStream* st)  {
658   st-&gt;print_cr(&quot; - sp: &quot; INTPTR_FORMAT, p2i(sp()));
659   st-&gt;print(&quot; - thread: &quot;);
660   Thread::current()-&gt;print();
661   st-&gt;print_cr(&quot; - frame size: %d&quot;, frame_size());
662   for (int index = 0; index &lt; frames() ; index++ ) {
663     element(index)-&gt;print(st);
664   }
665 }
666 
667 void vframeArrayElement::print(outputStream* st) {
668   st-&gt;print_cr(&quot; - interpreter_frame -&gt; sp: &quot; INTPTR_FORMAT, p2i(iframe()-&gt;sp()));
669 }
670 
671 void vframeArray::print_value_on(outputStream* st) const {
672   st-&gt;print_cr(&quot;vframeArray [%d] &quot;, frames());
673 }
674 
675 
676 #endif
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
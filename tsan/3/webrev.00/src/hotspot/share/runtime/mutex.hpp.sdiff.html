<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/mutex.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mutex.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutexLocker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/mutex.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_MUTEX_HPP
 26 #define SHARE_RUNTIME_MUTEX_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/os.hpp&quot;
<span class="line-removed"> 30 #include &quot;utilities/histogram.hpp&quot;</span>
<span class="line-removed"> 31 </span>
 32 
 33 // A Mutex/Monitor is a simple wrapper around a native lock plus condition
 34 // variable that supports lock ownership tracking, lock ranking for deadlock
 35 // detection and coordinates with the safepoint protocol.
 36 
<span class="line-modified"> 37 // The default length of monitor name was originally chosen to be 64 to avoid</span>
<span class="line-modified"> 38 // false sharing. Now, PaddedMonitor is available for this purpose.</span>
<span class="line-modified"> 39 // TODO: Check if _name[MONITOR_NAME_LEN] should better get replaced by const char*.</span>
<span class="line-modified"> 40 static const int MONITOR_NAME_LEN = 64;</span>
 41 
<span class="line-modified"> 42 class Monitor : public CHeapObj&lt;mtSynchronizer&gt; {</span>
 43 
 44  public:
 45   // A special lock: Is a lock where you are guaranteed not to block while you are
 46   // holding it, i.e., no vm operation can happen, taking other (blocking) locks, etc.
 47   // The rank &#39;access&#39; is similar to &#39;special&#39; and has the same restrictions on usage.
 48   // It is reserved for locks that may be required in order to perform memory accesses
 49   // that require special barriers, e.g. SATB GC barriers, that in turn uses locks.
 50   // The rank &#39;tty&#39; is also similar to &#39;special&#39; and has the same restrictions.
 51   // It is reserved for the tty_lock.
 52   // Since memory accesses should be able to be performed pretty much anywhere
 53   // in the code, that requires locks required for performing accesses being
 54   // inherently a bit more special than even locks of the &#39;special&#39; rank.
 55   // NOTE: It is critical that the rank &#39;special&#39; be the lowest (earliest)
 56   // (except for &quot;event&quot; and &quot;access&quot;) for the deadlock detection to work correctly.
<span class="line-modified"> 57   // The rank native is only for use in Mutex&#39;s created by JVM_RawMonitorCreate,</span>
<span class="line-modified"> 58   // which being external to the VM are not subject to deadlock detection.</span>


 59   // While at a safepoint no mutexes of rank safepoint are held by any thread.
 60   // The rank named &quot;leaf&quot; is probably historical (and should
 61   // be changed) -- mutexes of this rank aren&#39;t really leaf mutexes
 62   // at all.
 63   enum lock_types {
 64        event,
 65        access         = event          +   1,
 66        tty            = access         +   2,
<span class="line-modified"> 67        special        = tty            +   1,</span>
 68        suspend_resume = special        +   1,
<span class="line-modified"> 69        vmweak         = suspend_resume +   2,</span>
<span class="line-modified"> 70        leaf           = vmweak         +   2,</span>
 71        safepoint      = leaf           +  10,
 72        barrier        = safepoint      +   1,
 73        nonleaf        = barrier        +   1,
 74        max_nonleaf    = nonleaf        + 900,
 75        native         = max_nonleaf    +   1
 76   };
 77 
 78  protected:                              // Monitor-Mutex metadata
 79   Thread * volatile _owner;              // The owner of the lock
 80   os::PlatformMonitor _lock;             // Native monitor implementation
<span class="line-modified"> 81   char _name[MONITOR_NAME_LEN];          // Name of mutex/monitor</span>
 82 
 83   // Debugging fields for naming, deadlock detection, etc. (some only used in debug mode)
 84 #ifndef PRODUCT
<span class="line-modified"> 85   bool      _allow_vm_block;</span>
<span class="line-modified"> 86   DEBUG_ONLY(int _rank;)                 // rank (to avoid/detect potential deadlocks)</span>
<span class="line-modified"> 87   DEBUG_ONLY(Monitor * _next;)           // Used by a Thread to link up owned locks</span>
<span class="line-modified"> 88   DEBUG_ONLY(Thread* _last_owner;)       // the last thread to own the lock</span>
<span class="line-modified"> 89   DEBUG_ONLY(static bool contains(Monitor * locks, Monitor * lock);)</span>
<span class="line-modified"> 90   DEBUG_ONLY(static Monitor * get_least_ranked_lock(Monitor * locks);)</span>
<span class="line-modified"> 91   DEBUG_ONLY(Monitor * get_least_ranked_lock_besides_this(Monitor * locks);)</span>
<span class="line-modified"> 92 #endif</span>
<span class="line-modified"> 93 </span>
<span class="line-modified"> 94   void set_owner_implementation(Thread* owner)                        PRODUCT_RETURN;</span>
<span class="line-modified"> 95   void check_prelock_state     (Thread* thread, bool safepoint_check) PRODUCT_RETURN;</span>
<span class="line-modified"> 96   void check_block_state       (Thread* thread)                       PRODUCT_RETURN;</span>

 97   void assert_owner            (Thread* expected)                     NOT_DEBUG_RETURN;

 98 
 99  public:
100   enum {
<span class="line-removed">101     _no_safepoint_check_flag    = true,</span>
102     _allow_vm_block_flag        = true,
103     _as_suspend_equivalent_flag = true
104   };
105 
<span class="line-modified">106   // Locks can be acquired with or without safepoint check.</span>
<span class="line-modified">107   // Monitor::lock and Monitor::lock_without_safepoint_check</span>
<span class="line-modified">108   // checks these flags when acquiring a lock to ensure</span>
<span class="line-modified">109   // consistent checking for each lock.</span>
<span class="line-modified">110   // A few existing locks will sometimes have a safepoint check and</span>
<span class="line-modified">111   // sometimes not, but these locks are set up in such a way to avoid deadlocks.</span>
<span class="line-modified">112   // Note: monitors that may be shared between JavaThreads and the VMThread</span>
<span class="line-modified">113   // should never encounter a safepoint check whilst they are held, else a</span>
<span class="line-modified">114   // deadlock with the VMThread can occur.</span>
















115   enum SafepointCheckRequired {
<span class="line-modified">116     _safepoint_check_never,       // Monitors with this value will cause errors</span>
<span class="line-modified">117                                   // when acquired with a safepoint check.</span>
<span class="line-modified">118     _safepoint_check_sometimes,   // Certain locks are called sometimes with and</span>
<span class="line-modified">119                                   // sometimes without safepoint checks. These</span>
120                                   // locks will not produce errors when locked.
<span class="line-modified">121     _safepoint_check_always       // Causes error if locked without a safepoint</span>
<span class="line-modified">122                                   // check.</span>
123   };
124 
125   NOT_PRODUCT(SafepointCheckRequired _safepoint_check_required;)
126 
<span class="line-removed">127  protected:</span>
<span class="line-removed">128    static void ClearMonitor (Monitor * m, const char* name = NULL) ;</span>
<span class="line-removed">129    Monitor() ;</span>
<span class="line-removed">130 </span>
131  public:
<span class="line-modified">132   Monitor(int rank, const char *name, bool allow_vm_block = false,</span>
<span class="line-modified">133           SafepointCheckRequired safepoint_check_required = _safepoint_check_always);</span>
<span class="line-modified">134   ~Monitor();</span>
<span class="line-removed">135 </span>
<span class="line-removed">136   // Wait until monitor is notified (or times out).</span>
<span class="line-removed">137   // Defaults are to make safepoint checks, wait time is forever (i.e.,</span>
<span class="line-removed">138   // zero), and not a suspend-equivalent condition. Returns true if wait</span>
<span class="line-removed">139   // times out; otherwise returns false.</span>
<span class="line-removed">140   bool wait(bool no_safepoint_check = !_no_safepoint_check_flag,</span>
<span class="line-removed">141             long timeout = 0,</span>
<span class="line-removed">142             bool as_suspend_equivalent = !_as_suspend_equivalent_flag);</span>
<span class="line-removed">143   void notify();</span>
<span class="line-removed">144   void notify_all();</span>
<span class="line-removed">145 </span>
146 
147   void lock(); // prints out warning if VM thread blocks
148   void lock(Thread *thread); // overloaded with current thread
149   void unlock();
150   bool is_locked() const                     { return _owner != NULL; }
151 
152   bool try_lock(); // Like lock(), but unblocking. It returns false instead



153 
154   void release_for_safepoint();
155 
156   // Lock without safepoint check. Should ONLY be used by safepoint code and other code
157   // that is guaranteed not to block while running inside the VM.
158   void lock_without_safepoint_check();
<span class="line-modified">159   void lock_without_safepoint_check (Thread * Self) ;</span>
160 
161   // Current owner - not not MT-safe. Can only be used to guarantee that
162   // the current running thread owns the lock
163   Thread* owner() const         { return _owner; }
164   bool owned_by_self() const;
165 
<span class="line-removed">166   // Support for JVM_RawMonitorEnter &amp; JVM_RawMonitorExit. These can be called by</span>
<span class="line-removed">167   // non-Java thread. (We should really have a RawMonitor abstraction)</span>
<span class="line-removed">168   void jvm_raw_lock();</span>
<span class="line-removed">169   void jvm_raw_unlock();</span>
170   const char *name() const                  { return _name; }
171 
172   void print_on_error(outputStream* st) const;
173 
174   #ifndef PRODUCT
175     void print_on(outputStream* st) const;
176     void print() const                      { print_on(::tty); }
<span class="line-removed">177     DEBUG_ONLY(int    rank() const          { return _rank; })</span>
<span class="line-removed">178     bool   allow_vm_block()                 { return _allow_vm_block; }</span>
<span class="line-removed">179 </span>
<span class="line-removed">180     DEBUG_ONLY(Monitor *next()  const         { return _next; })</span>
<span class="line-removed">181     DEBUG_ONLY(void   set_next(Monitor *next) { _next = next; })</span>
182   #endif



183 
<span class="line-modified">184   void set_owner(Thread* owner) {</span>
<span class="line-modified">185   #ifndef PRODUCT</span>
<span class="line-modified">186     set_owner_implementation(owner);</span>
<span class="line-removed">187     DEBUG_ONLY(void verify_Monitor(Thread* thr);)</span>
<span class="line-removed">188   #else</span>
<span class="line-removed">189     _owner = owner;</span>
<span class="line-removed">190   #endif</span>
<span class="line-removed">191   }</span>
192 

193 };
194 
<span class="line-modified">195 class PaddedMonitor : public Monitor {</span>
<span class="line-modified">196   enum {</span>
<span class="line-removed">197     CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Monitor),</span>
<span class="line-removed">198     PADDING_LEN = CACHE_LINE_PADDING &gt; 0 ? CACHE_LINE_PADDING : 1</span>
<span class="line-removed">199   };</span>
<span class="line-removed">200   char _padding[PADDING_LEN];</span>
201  public:
<span class="line-modified">202   PaddedMonitor(int rank, const char *name, bool allow_vm_block = false,</span>
<span class="line-removed">203                SafepointCheckRequired safepoint_check_required = _safepoint_check_always) :</span>
<span class="line-removed">204     Monitor(rank, name, allow_vm_block, safepoint_check_required) {};</span>
<span class="line-removed">205 };</span>
<span class="line-removed">206 </span>
<span class="line-removed">207 // Normally we&#39;d expect Monitor to extend Mutex in the sense that a monitor</span>
<span class="line-removed">208 // constructed from pthreads primitives might extend a mutex by adding</span>
<span class="line-removed">209 // a condvar and some extra metadata.  In fact this was the case until J2SE7.</span>
<span class="line-removed">210 //</span>
<span class="line-removed">211 // Currently, however, the base object is a monitor.  Monitor contains all the</span>
<span class="line-removed">212 // logic for wait(), notify(), etc.   Mutex extends monitor and restricts the</span>
<span class="line-removed">213 // visibility of wait(), notify(), and notify_all().</span>
<span class="line-removed">214 //</span>
<span class="line-removed">215 // Another viable alternative would have been to have Monitor extend Mutex and</span>
<span class="line-removed">216 // implement all the normal mutex and wait()-notify() logic in Mutex base class.</span>
<span class="line-removed">217 // The wait()-notify() facility would be exposed via special protected member functions</span>
<span class="line-removed">218 // (e.g., _Wait() and _Notify()) in Mutex.  Monitor would extend Mutex and expose wait()</span>
<span class="line-removed">219 // as a call to _Wait().  That is, the public wait() would be a wrapper for the protected</span>
<span class="line-removed">220 // _Wait().</span>
<span class="line-removed">221 //</span>
<span class="line-removed">222 // An even better alternative is to simply eliminate Mutex:: and use Monitor:: instead.</span>
<span class="line-removed">223 // After all, monitors are sufficient for Java-level synchronization.   At one point in time</span>
<span class="line-removed">224 // there may have been some benefit to having distinct mutexes and monitors, but that time</span>
<span class="line-removed">225 // has past.</span>
<span class="line-removed">226 //</span>
<span class="line-removed">227 </span>
<span class="line-removed">228 class Mutex : public Monitor {      // degenerate Monitor</span>
<span class="line-removed">229  public:</span>
<span class="line-removed">230    Mutex(int rank, const char *name, bool allow_vm_block = false,</span>
231          SafepointCheckRequired safepoint_check_required = _safepoint_check_always);
<span class="line-modified">232   // default destructor</span>
<span class="line-modified">233  private:</span>
<span class="line-modified">234    void notify ()    { ShouldNotReachHere(); }</span>
<span class="line-modified">235    void notify_all() { ShouldNotReachHere(); }</span>
<span class="line-modified">236    bool wait (bool no_safepoint_check, long timeout, bool as_suspend_equivalent) {</span>
<span class="line-modified">237      ShouldNotReachHere() ;</span>
<span class="line-modified">238      return false ;</span>
<span class="line-modified">239    }</span>



240 };
241 

242 class PaddedMutex : public Mutex {
243   enum {
244     CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Mutex),
245     PADDING_LEN = CACHE_LINE_PADDING &gt; 0 ? CACHE_LINE_PADDING : 1
246   };
247   char _padding[PADDING_LEN];
248 public:
249   PaddedMutex(int rank, const char *name, bool allow_vm_block = false,
250               SafepointCheckRequired safepoint_check_required = _safepoint_check_always) :
251     Mutex(rank, name, allow_vm_block, safepoint_check_required) {};
252 };
253 












254 #endif // SHARE_RUNTIME_MUTEX_HPP
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_MUTEX_HPP
 26 #define SHARE_RUNTIME_MUTEX_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/os.hpp&quot;


 30 
 31 // A Mutex/Monitor is a simple wrapper around a native lock plus condition
 32 // variable that supports lock ownership tracking, lock ranking for deadlock
 33 // detection and coordinates with the safepoint protocol.
 34 
<span class="line-modified"> 35 // The default length of mutex name was originally chosen to be 64 to avoid</span>
<span class="line-modified"> 36 // false sharing. Now, PaddedMutex and PaddedMonitor are available for this purpose.</span>
<span class="line-modified"> 37 // TODO: Check if _name[MUTEX_NAME_LEN] should better get replaced by const char*.</span>
<span class="line-modified"> 38 static const int MUTEX_NAME_LEN = 64;</span>
 39 
<span class="line-modified"> 40 class Mutex : public CHeapObj&lt;mtSynchronizer&gt; {</span>
 41 
 42  public:
 43   // A special lock: Is a lock where you are guaranteed not to block while you are
 44   // holding it, i.e., no vm operation can happen, taking other (blocking) locks, etc.
 45   // The rank &#39;access&#39; is similar to &#39;special&#39; and has the same restrictions on usage.
 46   // It is reserved for locks that may be required in order to perform memory accesses
 47   // that require special barriers, e.g. SATB GC barriers, that in turn uses locks.
 48   // The rank &#39;tty&#39; is also similar to &#39;special&#39; and has the same restrictions.
 49   // It is reserved for the tty_lock.
 50   // Since memory accesses should be able to be performed pretty much anywhere
 51   // in the code, that requires locks required for performing accesses being
 52   // inherently a bit more special than even locks of the &#39;special&#39; rank.
 53   // NOTE: It is critical that the rank &#39;special&#39; be the lowest (earliest)
 54   // (except for &quot;event&quot; and &quot;access&quot;) for the deadlock detection to work correctly.
<span class="line-modified"> 55   // The rank native was only for use in Mutexes created by JVM_RawMonitorCreate,</span>
<span class="line-modified"> 56   // which being external to the VM are not subject to deadlock detection,</span>
<span class="line-added"> 57   // however it has now been used by other locks that don&#39;t fit into the</span>
<span class="line-added"> 58   // deadlock detection scheme.</span>
 59   // While at a safepoint no mutexes of rank safepoint are held by any thread.
 60   // The rank named &quot;leaf&quot; is probably historical (and should
 61   // be changed) -- mutexes of this rank aren&#39;t really leaf mutexes
 62   // at all.
 63   enum lock_types {
 64        event,
 65        access         = event          +   1,
 66        tty            = access         +   2,
<span class="line-modified"> 67        special        = tty            +   2,</span>
 68        suspend_resume = special        +   1,
<span class="line-modified"> 69        oopstorage     = suspend_resume +   2,</span>
<span class="line-modified"> 70        leaf           = oopstorage     +   2,</span>
 71        safepoint      = leaf           +  10,
 72        barrier        = safepoint      +   1,
 73        nonleaf        = barrier        +   1,
 74        max_nonleaf    = nonleaf        + 900,
 75        native         = max_nonleaf    +   1
 76   };
 77 
 78  protected:                              // Monitor-Mutex metadata
 79   Thread * volatile _owner;              // The owner of the lock
 80   os::PlatformMonitor _lock;             // Native monitor implementation
<span class="line-modified"> 81   char _name[MUTEX_NAME_LEN];            // Name of mutex/monitor</span>
 82 
 83   // Debugging fields for naming, deadlock detection, etc. (some only used in debug mode)
 84 #ifndef PRODUCT
<span class="line-modified"> 85   bool    _allow_vm_block;</span>
<span class="line-modified"> 86   int     _rank;                 // rank (to avoid/detect potential deadlocks)</span>
<span class="line-modified"> 87   Mutex*  _next;                 // Used by a Thread to link up owned locks</span>
<span class="line-modified"> 88   Thread* _last_owner;           // the last thread to own the lock</span>
<span class="line-modified"> 89   static bool contains(Mutex* locks, Mutex* lock);</span>
<span class="line-modified"> 90   static Mutex* get_least_ranked_lock(Mutex* locks);</span>
<span class="line-modified"> 91   Mutex* get_least_ranked_lock_besides_this(Mutex* locks);</span>
<span class="line-modified"> 92 #endif  // ASSERT</span>
<span class="line-modified"> 93 </span>
<span class="line-modified"> 94   void set_owner_implementation(Thread* owner)                        NOT_DEBUG({ _owner = owner;});</span>
<span class="line-modified"> 95   void check_block_state       (Thread* thread)                       NOT_DEBUG_RETURN;</span>
<span class="line-modified"> 96   void check_safepoint_state   (Thread* thread)                       NOT_DEBUG_RETURN;</span>
<span class="line-added"> 97   void check_no_safepoint_state(Thread* thread)                       NOT_DEBUG_RETURN;</span>
 98   void assert_owner            (Thread* expected)                     NOT_DEBUG_RETURN;
<span class="line-added"> 99   void no_safepoint_verifier   (Thread* thread, bool enable)          NOT_DEBUG_RETURN;</span>
100 
101  public:
102   enum {

103     _allow_vm_block_flag        = true,
104     _as_suspend_equivalent_flag = true
105   };
106 
<span class="line-modified">107   // Locks can be acquired with or without a safepoint check. NonJavaThreads do not follow</span>
<span class="line-modified">108   // the safepoint protocol when acquiring locks.</span>
<span class="line-modified">109 </span>
<span class="line-modified">110   // Each lock can be acquired by only JavaThreads, only NonJavaThreads, or shared between</span>
<span class="line-modified">111   // Java and NonJavaThreads. When the lock is initialized with _safepoint_check_always,</span>
<span class="line-modified">112   // that means that whenever the lock is acquired by a JavaThread, it will verify that</span>
<span class="line-modified">113   // it is done with a safepoint check. In corollary, when the lock is initialized with</span>
<span class="line-modified">114   // _safepoint_check_never, that means that whenever the lock is acquired by a JavaThread</span>
<span class="line-modified">115   // it will verify that it is done without a safepoint check.</span>
<span class="line-added">116 </span>
<span class="line-added">117 </span>
<span class="line-added">118   // There are a couple of existing locks that will sometimes have a safepoint check and</span>
<span class="line-added">119   // sometimes not when acquired by a JavaThread, but these locks are set up carefully</span>
<span class="line-added">120   // to avoid deadlocks. TODO: Fix these locks and remove _safepoint_check_sometimes.</span>
<span class="line-added">121 </span>
<span class="line-added">122   // TODO: Locks that are shared between JavaThreads and NonJavaThreads</span>
<span class="line-added">123   // should never encounter a safepoint check while they are held, or else a</span>
<span class="line-added">124   // deadlock can occur. We should check this by noting which</span>
<span class="line-added">125   // locks are shared, and walk held locks during safepoint checking.</span>
<span class="line-added">126 </span>
<span class="line-added">127   enum SafepointCheckFlag {</span>
<span class="line-added">128     _safepoint_check_flag,</span>
<span class="line-added">129     _no_safepoint_check_flag</span>
<span class="line-added">130   };</span>
<span class="line-added">131 </span>
132   enum SafepointCheckRequired {
<span class="line-modified">133     _safepoint_check_never,       // Mutexes with this value will cause errors</span>
<span class="line-modified">134                                   // when acquired by a JavaThread with a safepoint check.</span>
<span class="line-modified">135     _safepoint_check_sometimes,   // A couple of special locks are acquired by JavaThreads sometimes</span>
<span class="line-modified">136                                   // with and sometimes without safepoint checks. These</span>
137                                   // locks will not produce errors when locked.
<span class="line-modified">138     _safepoint_check_always       // Mutexes with this value will cause errors</span>
<span class="line-modified">139                                   // when acquired by a JavaThread without a safepoint check.</span>
140   };
141 
142   NOT_PRODUCT(SafepointCheckRequired _safepoint_check_required;)
143 




144  public:
<span class="line-modified">145   Mutex(int rank, const char *name, bool allow_vm_block = false,</span>
<span class="line-modified">146         SafepointCheckRequired safepoint_check_required = _safepoint_check_always);</span>
<span class="line-modified">147   ~Mutex();</span>











148 
149   void lock(); // prints out warning if VM thread blocks
150   void lock(Thread *thread); // overloaded with current thread
151   void unlock();
152   bool is_locked() const                     { return _owner != NULL; }
153 
154   bool try_lock(); // Like lock(), but unblocking. It returns false instead
<span class="line-added">155  private:</span>
<span class="line-added">156   void lock_contended(Thread *thread); // contended slow-path</span>
<span class="line-added">157  public:</span>
158 
159   void release_for_safepoint();
160 
161   // Lock without safepoint check. Should ONLY be used by safepoint code and other code
162   // that is guaranteed not to block while running inside the VM.
163   void lock_without_safepoint_check();
<span class="line-modified">164   void lock_without_safepoint_check(Thread* self);</span>
165 
166   // Current owner - not not MT-safe. Can only be used to guarantee that
167   // the current running thread owns the lock
168   Thread* owner() const         { return _owner; }
169   bool owned_by_self() const;
170 




171   const char *name() const                  { return _name; }
172 
173   void print_on_error(outputStream* st) const;
174 
175   #ifndef PRODUCT
176     void print_on(outputStream* st) const;
177     void print() const                      { print_on(::tty); }





178   #endif
<span class="line-added">179   #ifdef ASSERT</span>
<span class="line-added">180     int    rank() const          { return _rank; }</span>
<span class="line-added">181     bool   allow_vm_block()      { return _allow_vm_block; }</span>
182 
<span class="line-modified">183     Mutex *next()  const         { return _next; }</span>
<span class="line-modified">184     void   set_next(Mutex *next) { _next = next; }</span>
<span class="line-modified">185   #endif // ASSERT</span>





186 
<span class="line-added">187   void set_owner(Thread* owner)             { set_owner_implementation(owner); }</span>
188 };
189 
<span class="line-modified">190 class Monitor : public Mutex {</span>
<span class="line-modified">191   void assert_wait_lock_state  (Thread* self)                         NOT_DEBUG_RETURN;</span>




192  public:
<span class="line-modified">193    Monitor(int rank, const char *name, bool allow_vm_block = false,</span>




























194          SafepointCheckRequired safepoint_check_required = _safepoint_check_always);
<span class="line-modified">195    // default destructor</span>
<span class="line-modified">196 </span>
<span class="line-modified">197   // Wait until monitor is notified (or times out).</span>
<span class="line-modified">198   // Defaults are to make safepoint checks, wait time is forever (i.e.,</span>
<span class="line-modified">199   // zero), and not a suspend-equivalent condition. Returns true if wait</span>
<span class="line-modified">200   // times out; otherwise returns false.</span>
<span class="line-modified">201   bool wait(long timeout = 0,</span>
<span class="line-modified">202             bool as_suspend_equivalent = !_as_suspend_equivalent_flag);</span>
<span class="line-added">203   bool wait_without_safepoint_check(long timeout = 0);</span>
<span class="line-added">204   void notify();</span>
<span class="line-added">205   void notify_all();</span>
206 };
207 
<span class="line-added">208 </span>
209 class PaddedMutex : public Mutex {
210   enum {
211     CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Mutex),
212     PADDING_LEN = CACHE_LINE_PADDING &gt; 0 ? CACHE_LINE_PADDING : 1
213   };
214   char _padding[PADDING_LEN];
215 public:
216   PaddedMutex(int rank, const char *name, bool allow_vm_block = false,
217               SafepointCheckRequired safepoint_check_required = _safepoint_check_always) :
218     Mutex(rank, name, allow_vm_block, safepoint_check_required) {};
219 };
220 
<span class="line-added">221 class PaddedMonitor : public Monitor {</span>
<span class="line-added">222   enum {</span>
<span class="line-added">223     CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Monitor),</span>
<span class="line-added">224     PADDING_LEN = CACHE_LINE_PADDING &gt; 0 ? CACHE_LINE_PADDING : 1</span>
<span class="line-added">225   };</span>
<span class="line-added">226   char _padding[PADDING_LEN];</span>
<span class="line-added">227  public:</span>
<span class="line-added">228   PaddedMonitor(int rank, const char *name, bool allow_vm_block = false,</span>
<span class="line-added">229                SafepointCheckRequired safepoint_check_required = _safepoint_check_always) :</span>
<span class="line-added">230     Monitor(rank, name, allow_vm_block, safepoint_check_required) {};</span>
<span class="line-added">231 };</span>
<span class="line-added">232 </span>
233 #endif // SHARE_RUNTIME_MUTEX_HPP
</pre>
</td>
</tr>
</table>
<center><a href="mutex.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutexLocker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
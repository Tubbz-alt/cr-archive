<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/runtime/abstract_vm_version.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_ABSTRACT_VM_VERSION_HPP
 26 #define SHARE_RUNTIME_ABSTRACT_VM_VERSION_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;  // For declaration of class AllStatic
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 
 31 typedef enum {
 32   NoDetectedVirtualization,
 33   XenHVM,
 34   KVM,
 35   VMWare,
 36   HyperV,
 37   PowerVM, // on AIX or Linux ppc64(le)
 38   PowerFullPartitionMode, // on Linux ppc64(le)
 39   PowerKVM
 40 } VirtualizationType;
 41 
 42 class outputStream;
 43 
 44 // Abstract_VM_Version provides information about the VM.
 45 
 46 class Abstract_VM_Version: AllStatic {
 47   friend class VMStructs;
 48   friend class JVMCIVMStructs;
 49 
 50  protected:
 51   static const char*  _s_vm_release;
 52   static const char*  _s_internal_vm_info_string;
 53 
 54   // CPU feature flags.
 55   static uint64_t _features;
 56   static const char* _features_string;
 57 
 58   // These are set by machine-dependent initializations
 59   static bool         _supports_cx8;
 60   static bool         _supports_atomic_getset4;
 61   static bool         _supports_atomic_getset8;
 62   static bool         _supports_atomic_getadd4;
 63   static bool         _supports_atomic_getadd8;
 64   static unsigned int _logical_processors_per_package;
 65   static unsigned int _L1_data_cache_line_size;
 66   static int          _vm_major_version;
 67   static int          _vm_minor_version;
 68   static int          _vm_security_version;
 69   static int          _vm_patch_version;
 70   static int          _vm_build_number;
 71   static unsigned int _data_cache_line_flush_size;
 72 
 73   static VirtualizationType _detected_virtualization;
 74 
 75  public:
 76   // Called as part of the runtime services initialization which is
 77   // called from the management module initialization (via init_globals())
 78   // after argument parsing and attaching of the main thread has
 79   // occurred.  Examines a variety of the hardware capabilities of
 80   // the platform to determine which features can be used to execute the
 81   // program.
 82   static void initialize() { }
 83 
 84   // This allows for early initialization of VM_Version information
 85   // that may be needed later in the initialization sequence but before
 86   // full VM_Version initialization is possible. It can not depend on any
 87   // other part of the VM being initialized when called. Platforms that
 88   // need to specialize this define VM_Version::early_initialize().
 89   static void early_initialize() { }
 90 
 91   // Called to initialize VM variables needing initialization
 92   // after command line parsing. Platforms that need to specialize
 93   // this should define VM_Version::init_before_ergo().
 94   static void init_before_ergo() {}
 95 
 96   // Name
 97   static const char* vm_name();
 98   // Vendor
 99   static const char* vm_vendor();
100   // VM version information string printed by launcher (java -version)
101   static const char* vm_info_string();
102   static const char* vm_release();
103   static const char* vm_platform_string();
104   static const char* vm_build_user();
105 
106   static int vm_major_version()               { return _vm_major_version; }
107   static int vm_minor_version()               { return _vm_minor_version; }
108   static int vm_security_version()            { return _vm_security_version; }
109   static int vm_patch_version()               { return _vm_patch_version; }
110   static int vm_build_number()                { return _vm_build_number; }
111 
112   // Gets the jvm_version_info.jvm_version
113   static unsigned int jvm_version();
114 
115   // Internal version providing additional build information
116   static const char* internal_vm_info_string();
117   static const char* jre_release_version();
118   static const char* jdk_debug_level();
119   static const char* printable_jdk_debug_level();
120 
121   static uint64_t features() {
122     return _features;
123   }
124 
125   static const char* features_string() {
126     return _features_string;
127   }
128 
129   static VirtualizationType get_detected_virtualization() {
130     return _detected_virtualization;
131   }
132 
133   // platforms that need to specialize this
134   // define VM_Version::print_platform_virtualization_info()
135   static void print_platform_virtualization_info(outputStream*) { }
136 
137   // does HW support an 8-byte compare-exchange operation?
138   static bool supports_cx8()  {
139 #ifdef SUPPORTS_NATIVE_CX8
140     return true;
141 #else
142     return _supports_cx8;
143 #endif
144   }
145   // does HW support atomic get-and-set or atomic get-and-add?  Used
146   // to guide intrinsification decisions for Unsafe atomic ops
147   static bool supports_atomic_getset4()  {return _supports_atomic_getset4;}
148   static bool supports_atomic_getset8()  {return _supports_atomic_getset8;}
149   static bool supports_atomic_getadd4()  {return _supports_atomic_getadd4;}
150   static bool supports_atomic_getadd8()  {return _supports_atomic_getadd8;}
151 
152   static unsigned int logical_processors_per_package() {
153     return _logical_processors_per_package;
154   }
155 
156   static unsigned int L1_data_cache_line_size() {
157     return _L1_data_cache_line_size;
158   }
159 
160   // the size in bytes of a data cache line flushed by a flush
161   // operation which should be a power of two or zero if cache line
162   // writeback is not supported by the current os_cpu combination
163   static unsigned int data_cache_line_flush_size() {
164     return _data_cache_line_flush_size;
165   }
166 
167   // returns true if and only if cache line writeback is supported
168   static bool supports_data_cache_line_flush() {
169     return _data_cache_line_flush_size != 0;
170   }
171 
172   // ARCH specific policy for the BiasedLocking
173   static bool use_biased_locking()  { return true; }
174 
175   // Number of page sizes efficiently supported by the hardware.  Most chips now
176   // support two sizes, thus this default implementation.  Processor-specific
177   // subclasses should define new versions to hide this one as needed.  Note
178   // that the O/S may support more sizes, but at most this many are used.
179   static uint page_size_count() { return 2; }
180 
181   // Denominator for computing default ParallelGCThreads for machines with
182   // a large number of cores.
183   static uint parallel_worker_threads_denominator() { return 8; }
184 
185   // Does this CPU support spin wait instruction?
186   static bool supports_on_spin_wait() { return false; }
187 
188   // Does platform support fast class initialization checks for static methods?
189   static bool supports_fast_class_init_checks() { return false; }
190 
191   static bool print_matching_lines_from_file(const char* filename, outputStream* st, const char* keywords_to_match[]);
192 };
193 
194 #endif // SHARE_RUNTIME_ABSTRACT_VM_VERSION_HPP
    </pre>
  </body>
</html>
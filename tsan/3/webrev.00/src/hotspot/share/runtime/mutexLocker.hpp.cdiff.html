<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/mutexLocker.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mutexLocker.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objectMonitor.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/mutexLocker.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,27 ***</span>
  #include &quot;runtime/mutex.hpp&quot;
  
  // Mutexes used in the VM.
  
  extern Mutex*   Patching_lock;                   // a lock used to guard code patching of compiled code
  extern Monitor* SystemDictionary_lock;           // a lock on the system dictionary
  extern Mutex*   ProtectionDomainSet_lock;        // a lock on the pd_set list in the system dictionary
  extern Mutex*   SharedDictionary_lock;           // a lock on the CDS shared dictionary
  extern Mutex*   Module_lock;                     // a lock on module and package related data structures
  extern Mutex*   CompiledIC_lock;                 // a lock used to guard compiled IC patching and access
  extern Mutex*   InlineCacheBuffer_lock;          // a lock used to guard the InlineCacheBuffer
  extern Mutex*   VMStatistic_lock;                // a lock used to guard statistics count increment
<span class="line-removed">- extern Mutex*   JNIGlobalAlloc_lock;             // JNI global storage allocate list lock</span>
<span class="line-removed">- extern Mutex*   JNIGlobalActive_lock;            // JNI global storage active list lock</span>
<span class="line-removed">- extern Mutex*   JNIWeakAlloc_lock;               // JNI weak storage allocate list lock</span>
<span class="line-removed">- extern Mutex*   JNIWeakActive_lock;              // JNI weak storage active list lock</span>
<span class="line-removed">- extern Mutex*   StringTableWeakAlloc_lock;       // StringTable weak storage allocate list lock</span>
<span class="line-removed">- extern Mutex*   StringTableWeakActive_lock;      // STringTable weak storage active list lock</span>
  extern Mutex*   JNIHandleBlockFreeList_lock;     // a lock on the JNI handle block free list
<span class="line-removed">- extern Mutex*   VMWeakAlloc_lock;                // VM Weak Handles storage allocate list lock</span>
<span class="line-removed">- extern Mutex*   VMWeakActive_lock;               // VM Weak Handles storage active list lock</span>
<span class="line-removed">- extern Mutex*   ResolvedMethodTable_lock;        // a lock on the ResolvedMethodTable updates</span>
  extern Mutex*   JmethodIdCreation_lock;          // a lock on creating JNI method identifiers
  extern Mutex*   JfieldIdCreation_lock;           // a lock on creating JNI static field identifiers
  extern Monitor* JNICritical_lock;                // a lock used while entering and exiting JNI critical regions, allows GC to sometimes get in
  extern Mutex*   JvmtiThreadState_lock;           // a lock on modification of JVMTI thread data
  extern Monitor* Heap_lock;                       // a lock on the heap
<span class="line-new-header">--- 30,19 ---</span>
  #include &quot;runtime/mutex.hpp&quot;
  
  // Mutexes used in the VM.
  
  extern Mutex*   Patching_lock;                   // a lock used to guard code patching of compiled code
<span class="line-added">+ extern Mutex*   CompiledMethod_lock;             // a lock used to guard a compiled method and OSR queues</span>
  extern Monitor* SystemDictionary_lock;           // a lock on the system dictionary
  extern Mutex*   ProtectionDomainSet_lock;        // a lock on the pd_set list in the system dictionary
  extern Mutex*   SharedDictionary_lock;           // a lock on the CDS shared dictionary
  extern Mutex*   Module_lock;                     // a lock on module and package related data structures
  extern Mutex*   CompiledIC_lock;                 // a lock used to guard compiled IC patching and access
  extern Mutex*   InlineCacheBuffer_lock;          // a lock used to guard the InlineCacheBuffer
  extern Mutex*   VMStatistic_lock;                // a lock used to guard statistics count increment
  extern Mutex*   JNIHandleBlockFreeList_lock;     // a lock on the JNI handle block free list
  extern Mutex*   JmethodIdCreation_lock;          // a lock on creating JNI method identifiers
  extern Mutex*   JfieldIdCreation_lock;           // a lock on creating JNI static field identifiers
  extern Monitor* JNICritical_lock;                // a lock used while entering and exiting JNI critical regions, allows GC to sometimes get in
  extern Mutex*   JvmtiThreadState_lock;           // a lock on modification of JVMTI thread data
  extern Monitor* Heap_lock;                       // a lock on the heap
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,29 ***</span>
  extern Mutex*   SignatureHandlerLibrary_lock;    // a lock on the SignatureHandlerLibrary
  extern Mutex*   VtableStubs_lock;                // a lock on the VtableStubs
  extern Mutex*   SymbolArena_lock;                // a lock on the symbol table arena
  extern Monitor* StringDedupQueue_lock;           // a lock on the string deduplication queue
  extern Mutex*   StringDedupTable_lock;           // a lock on the string deduplication table
<span class="line-modified">! extern Monitor* CodeCache_lock;                  // a lock on the CodeCache, rank is special, use MutexLockerEx</span>
  extern Mutex*   MethodData_lock;                 // a lock on installation of method data
  extern Mutex*   TouchedMethodLog_lock;           // a lock on allocation of LogExecutedMethods info
  extern Mutex*   RetData_lock;                    // a lock on installation of RetData inside method data
<span class="line-removed">- extern Mutex*   DerivedPointerTableGC_lock;      // a lock to protect the derived pointer table</span>
  extern Monitor* CGCPhaseManager_lock;            // a lock to protect a concurrent GC&#39;s phase management
  extern Monitor* VMOperationQueue_lock;           // a lock on queue of vm_operations waiting to execute
  extern Monitor* VMOperationRequest_lock;         // a lock on Threads waiting for a vm_operation to terminate
  extern Monitor* Threads_lock;                    // a lock on the Threads table of active Java threads
                                                   // (also used by Safepoints too to block threads creation/destruction)
  extern Mutex*   NonJavaThreadsList_lock;         // a lock on the NonJavaThreads list
  extern Monitor* CGC_lock;                        // used for coordination between
                                                   // fore- &amp; background GC threads.
  extern Monitor* STS_lock;                        // used for joining/leaving SuspendibleThreadSet.
  extern Monitor* FullGCCount_lock;                // in support of &quot;concurrent&quot; full gc
<span class="line-modified">! extern Monitor* SATB_Q_CBL_mon;                  // Protects SATB Q</span>
<span class="line-removed">-                                                  // completed buffer queue.</span>
<span class="line-removed">- extern Monitor* DirtyCardQ_CBL_mon;              // Protects dirty card Q</span>
<span class="line-removed">-                                                  // completed buffer queue.</span>
  extern Mutex*   Shared_DirtyCardQ_lock;          // Lock protecting dirty card
                                                   // queue shared by
                                                   // non-Java threads.
  extern Mutex*   MarkStackFreeList_lock;          // Protects access to the global mark stack free list.
  extern Mutex*   MarkStackChunkList_lock;         // Protects access to the global mark stack chunk list.
<span class="line-new-header">--- 51,26 ---</span>
  extern Mutex*   SignatureHandlerLibrary_lock;    // a lock on the SignatureHandlerLibrary
  extern Mutex*   VtableStubs_lock;                // a lock on the VtableStubs
  extern Mutex*   SymbolArena_lock;                // a lock on the symbol table arena
  extern Monitor* StringDedupQueue_lock;           // a lock on the string deduplication queue
  extern Mutex*   StringDedupTable_lock;           // a lock on the string deduplication table
<span class="line-modified">! extern Monitor* CodeCache_lock;                  // a lock on the CodeCache, rank is special</span>
  extern Mutex*   MethodData_lock;                 // a lock on installation of method data
  extern Mutex*   TouchedMethodLog_lock;           // a lock on allocation of LogExecutedMethods info
  extern Mutex*   RetData_lock;                    // a lock on installation of RetData inside method data
  extern Monitor* CGCPhaseManager_lock;            // a lock to protect a concurrent GC&#39;s phase management
  extern Monitor* VMOperationQueue_lock;           // a lock on queue of vm_operations waiting to execute
  extern Monitor* VMOperationRequest_lock;         // a lock on Threads waiting for a vm_operation to terminate
  extern Monitor* Threads_lock;                    // a lock on the Threads table of active Java threads
                                                   // (also used by Safepoints too to block threads creation/destruction)
  extern Mutex*   NonJavaThreadsList_lock;         // a lock on the NonJavaThreads list
<span class="line-added">+ extern Mutex*   NonJavaThreadsListSync_lock;     // a lock for NonJavaThreads list synchronization</span>
  extern Monitor* CGC_lock;                        // used for coordination between
                                                   // fore- &amp; background GC threads.
  extern Monitor* STS_lock;                        // used for joining/leaving SuspendibleThreadSet.
  extern Monitor* FullGCCount_lock;                // in support of &quot;concurrent&quot; full gc
<span class="line-modified">! extern Monitor* G1OldGCCount_lock;               // in support of &quot;concurrent&quot; full gc</span>
  extern Mutex*   Shared_DirtyCardQ_lock;          // Lock protecting dirty card
                                                   // queue shared by
                                                   // non-Java threads.
  extern Mutex*   MarkStackFreeList_lock;          // Protects access to the global mark stack free list.
  extern Mutex*   MarkStackChunkList_lock;         // Protects access to the global mark stack chunk list.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,15 ***</span>
  extern Mutex*   CompileTaskAlloc_lock;           // a lock held when CompileTasks are allocated
  extern Mutex*   CompileStatistics_lock;          // a lock held when updating compilation statistics
  extern Mutex*   DirectivesStack_lock;            // a lock held when mutating the dirstack and ref counting directives
  extern Mutex*   MultiArray_lock;                 // a lock used to guard allocation of multi-dim arrays
  extern Monitor* Terminator_lock;                 // a lock used to guard termination of the vm
  extern Monitor* BeforeExit_lock;                 // a lock used to guard cleanups and shutdown hooks
  extern Monitor* Notify_lock;                     // a lock used to synchronize the start-up of the vm
  extern Mutex*   ProfilePrint_lock;               // a lock used to serialize the printing of profiles
  extern Mutex*   ExceptionCache_lock;             // a lock used to synchronize exception cache updates
<span class="line-removed">- extern Mutex*   OsrList_lock;                    // a lock used to serialize access to OSR queues</span>
  extern Mutex*   NMethodSweeperStats_lock;        // a lock used to serialize access to sweeper statistics
  
  #ifndef PRODUCT
  extern Mutex*   FullGCALot_lock;                 // a lock to make FullGCALot MT safe
  #endif // PRODUCT
<span class="line-new-header">--- 83,15 ---</span>
  extern Mutex*   CompileTaskAlloc_lock;           // a lock held when CompileTasks are allocated
  extern Mutex*   CompileStatistics_lock;          // a lock held when updating compilation statistics
  extern Mutex*   DirectivesStack_lock;            // a lock held when mutating the dirstack and ref counting directives
  extern Mutex*   MultiArray_lock;                 // a lock used to guard allocation of multi-dim arrays
  extern Monitor* Terminator_lock;                 // a lock used to guard termination of the vm
<span class="line-added">+ extern Monitor* InitCompleted_lock;              // a lock used to signal threads waiting on init completed</span>
  extern Monitor* BeforeExit_lock;                 // a lock used to guard cleanups and shutdown hooks
  extern Monitor* Notify_lock;                     // a lock used to synchronize the start-up of the vm
  extern Mutex*   ProfilePrint_lock;               // a lock used to serialize the printing of profiles
  extern Mutex*   ExceptionCache_lock;             // a lock used to synchronize exception cache updates
  extern Mutex*   NMethodSweeperStats_lock;        // a lock used to serialize access to sweeper statistics
  
  #ifndef PRODUCT
  extern Mutex*   FullGCALot_lock;                 // a lock to make FullGCALot MT safe
  #endif // PRODUCT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,30 ***</span>
  extern Mutex*   Debug3_lock;
  
  extern Mutex*   RawMonitor_lock;
  extern Mutex*   PerfDataMemAlloc_lock;           // a lock on the allocator for PerfData memory for performance data
  extern Mutex*   PerfDataManager_lock;            // a long on access to PerfDataManager resources
<span class="line-removed">- extern Mutex*   ParkerFreeList_lock;</span>
  extern Mutex*   OopMapCacheAlloc_lock;           // protects allocation of oop_map caches
  
  extern Mutex*   FreeList_lock;                   // protects the free region list during safepoints
  extern Mutex*   OldSets_lock;                    // protects the old region sets
  extern Monitor* RootRegionScan_lock;             // used to notify that the CM threads have finished scanning the IM snapshot regions
  
  extern Mutex*   Management_lock;                 // a lock used to serialize JVM management
  extern Monitor* Service_lock;                    // a lock used for service thread operation
  extern Monitor* PeriodicTask_lock;               // protects the periodic task structure
  extern Monitor* RedefineClasses_lock;            // locks classes from parallel redefinition
  extern Monitor* ThreadsSMRDelete_lock;           // Used by ThreadsSMRSupport to take pressure off the Threads_lock
  extern Mutex*   SharedDecoder_lock;              // serializes access to the decoder during normal (not error reporting) use
  extern Mutex*   DCmdFactory_lock;                // serialize access to DCmdFactory information
  #if INCLUDE_NMT
  extern Mutex*   NMTQuery_lock;                   // serialize NMT Dcmd queries
  #endif
<span class="line-modified">! #if INCLUDE_CDS &amp;&amp; INCLUDE_JVMTI</span>
  extern Mutex*   CDSClassFileStream_lock;         // FileMapInfo::open_stream_for_jvmti
  #endif
  #if INCLUDE_JFR
  extern Mutex*   JfrStacktrace_lock;              // used to guard access to the JFR stacktrace table
  extern Monitor* JfrMsg_lock;                     // protects JFR messaging
  extern Mutex*   JfrBuffer_lock;                  // protects JFR buffer operations
  extern Mutex*   JfrStream_lock;                  // protects JFR stream access
<span class="line-new-header">--- 100,35 ---</span>
  extern Mutex*   Debug3_lock;
  
  extern Mutex*   RawMonitor_lock;
  extern Mutex*   PerfDataMemAlloc_lock;           // a lock on the allocator for PerfData memory for performance data
  extern Mutex*   PerfDataManager_lock;            // a long on access to PerfDataManager resources
  extern Mutex*   OopMapCacheAlloc_lock;           // protects allocation of oop_map caches
  
  extern Mutex*   FreeList_lock;                   // protects the free region list during safepoints
  extern Mutex*   OldSets_lock;                    // protects the old region sets
  extern Monitor* RootRegionScan_lock;             // used to notify that the CM threads have finished scanning the IM snapshot regions
  
  extern Mutex*   Management_lock;                 // a lock used to serialize JVM management
  extern Monitor* Service_lock;                    // a lock used for service thread operation
<span class="line-added">+ extern Monitor* Notification_lock;               // a lock used for notification thread operation</span>
  extern Monitor* PeriodicTask_lock;               // protects the periodic task structure
  extern Monitor* RedefineClasses_lock;            // locks classes from parallel redefinition
<span class="line-added">+ extern Mutex*   Verify_lock;                     // synchronize initialization of verify library</span>
  extern Monitor* ThreadsSMRDelete_lock;           // Used by ThreadsSMRSupport to take pressure off the Threads_lock
<span class="line-added">+ extern Mutex*   ThreadIdTableCreate_lock;        // Used by ThreadIdTable to lazily create the thread id table</span>
  extern Mutex*   SharedDecoder_lock;              // serializes access to the decoder during normal (not error reporting) use
  extern Mutex*   DCmdFactory_lock;                // serialize access to DCmdFactory information
  #if INCLUDE_NMT
  extern Mutex*   NMTQuery_lock;                   // serialize NMT Dcmd queries
  #endif
<span class="line-modified">! #if INCLUDE_CDS</span>
<span class="line-added">+ #if INCLUDE_JVMTI</span>
  extern Mutex*   CDSClassFileStream_lock;         // FileMapInfo::open_stream_for_jvmti
  #endif
<span class="line-added">+ extern Mutex*   DumpTimeTable_lock;              // SystemDictionaryShared::find_or_allocate_info_for</span>
<span class="line-added">+ #endif // INCLUDE_CDS</span>
  #if INCLUDE_JFR
  extern Mutex*   JfrStacktrace_lock;              // used to guard access to the JFR stacktrace table
  extern Monitor* JfrMsg_lock;                     // protects JFR messaging
  extern Mutex*   JfrBuffer_lock;                  // protects JFR buffer operations
  extern Mutex*   JfrStream_lock;                  // protects JFR stream access
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,13 ***</span>
  
  extern Mutex*   MetaspaceExpand_lock;            // protects Metaspace virtualspace and chunk expansions
  extern Mutex*   ClassLoaderDataGraph_lock;       // protects CLDG list, needed for concurrent unloading
  
  
<span class="line-modified">! extern Monitor* CodeHeapStateAnalytics_lock;     // lock print functions against concurrent analyze functions.</span>
                                                   // Only used locally in PrintCodeCacheLayout processing.
  
  // A MutexLocker provides mutual exclusion with respect to a given mutex
  // for the scope which contains the locker.  The lock is an OS lock, not
  // an object lock, and the two do not interoperate.  Do not use Mutex-based
  // locks to lock on Java objects, because they will not be respected if a
  // that object is locked using the Java locking mechanism.
<span class="line-new-header">--- 144,19 ---</span>
  
  extern Mutex*   MetaspaceExpand_lock;            // protects Metaspace virtualspace and chunk expansions
  extern Mutex*   ClassLoaderDataGraph_lock;       // protects CLDG list, needed for concurrent unloading
  
  
<span class="line-modified">! extern Mutex*   CodeHeapStateAnalytics_lock;     // lock print functions against concurrent analyze functions.</span>
                                                   // Only used locally in PrintCodeCacheLayout processing.
  
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+ extern Monitor* JVMCI_lock;                      // Monitor to control initialization of JVMCI</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ extern Mutex* tty_lock;                          // lock to synchronize output.</span>
<span class="line-added">+ </span>
  // A MutexLocker provides mutual exclusion with respect to a given mutex
  // for the scope which contains the locker.  The lock is an OS lock, not
  // an object lock, and the two do not interoperate.  Do not use Mutex-based
  // locks to lock on Java objects, because they will not be respected if a
  // that object is locked using the Java locking mechanism.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,176 ***</span>
  // by fatal error handler.
  void print_owned_locks_on_error(outputStream* st);
  
  char *lock_name(Mutex *mutex);
  
<span class="line-modified">! class MutexLocker: StackObj {</span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   Monitor * _mutex;</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   MutexLocker(Monitor * mutex) {</span>
<span class="line-removed">-     assert(mutex-&gt;rank() != Mutex::special,</span>
<span class="line-removed">-       &quot;Special ranked mutex should only use MutexLockerEx&quot;);</span>
<span class="line-removed">-     _mutex = mutex;</span>
<span class="line-removed">-     _mutex-&gt;lock();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Overloaded constructor passing current thread</span>
<span class="line-removed">-   MutexLocker(Monitor * mutex, Thread *thread) {</span>
<span class="line-removed">-     assert(mutex-&gt;rank() != Mutex::special,</span>
<span class="line-removed">-       &quot;Special ranked mutex should only use MutexLockerEx&quot;);</span>
<span class="line-removed">-     _mutex = mutex;</span>
<span class="line-removed">-     _mutex-&gt;lock(thread);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ~MutexLocker() {</span>
<span class="line-removed">-     _mutex-&gt;unlock();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- // for debugging: check that we&#39;re already owning this lock (or are at a safepoint)</span>
  #ifdef ASSERT
<span class="line-modified">! void assert_locked_or_safepoint(const Monitor * lock);</span>
<span class="line-modified">! void assert_locked_or_safepoint_weak(const Monitor * lock);</span>
<span class="line-modified">! void assert_lock_strong(const Monitor * lock);</span>
  #else
  #define assert_locked_or_safepoint(lock)
  #define assert_locked_or_safepoint_weak(lock)
  #define assert_lock_strong(lock)
  #endif
  
<span class="line-modified">! // A MutexLockerEx behaves like a MutexLocker when its constructor is</span>
<span class="line-modified">! // called with a Mutex.  Unlike a MutexLocker, its constructor can also be</span>
<span class="line-modified">! // called with NULL, in which case the MutexLockerEx is a no-op.  There</span>
<span class="line-removed">- // is also a corresponding MutexUnlockerEx.  We want to keep the</span>
<span class="line-removed">- // basic MutexLocker as fast as possible.  MutexLockerEx can also lock</span>
<span class="line-removed">- // without safepoint check.</span>
<span class="line-removed">- </span>
<span class="line-removed">- class MutexLockerEx: public StackObj {</span>
   private:
<span class="line-removed">-   Monitor * _mutex;</span>
   public:
<span class="line-modified">!   MutexLockerEx(Monitor * mutex, bool no_safepoint_check = !Mutex::_no_safepoint_check_flag) {</span>
<span class="line-modified">!     _mutex = mutex;</span>
      if (_mutex != NULL) {
<span class="line-modified">!       assert(mutex-&gt;rank() &gt; Mutex::special || no_safepoint_check,</span>
<span class="line-modified">!         &quot;Mutexes with rank special or lower should not do safepoint checks&quot;);</span>
<span class="line-modified">!       if (no_safepoint_check)</span>
          _mutex-&gt;lock_without_safepoint_check();
<span class="line-modified">!       else</span>
          _mutex-&gt;lock();
      }
    }
  
<span class="line-modified">!   ~MutexLockerEx() {</span>
      if (_mutex != NULL) {
        _mutex-&gt;unlock();
      }
    }
  };
  
<span class="line-modified">! // A MonitorLockerEx is like a MutexLockerEx above, except it takes</span>
<span class="line-modified">! // a possibly null Monitor, and allows wait/notify as well which are</span>
<span class="line-modified">! // delegated to the underlying Monitor.</span>
  
<span class="line-modified">! class MonitorLockerEx: public MutexLockerEx {</span>
<span class="line-modified">!  private:</span>
<span class="line-modified">!   Monitor * _monitor;</span>
   public:
<span class="line-modified">!   MonitorLockerEx(Monitor* monitor,</span>
<span class="line-modified">!                   bool no_safepoint_check = !Mutex::_no_safepoint_check_flag):</span>
<span class="line-removed">-     MutexLockerEx(monitor, no_safepoint_check),</span>
<span class="line-removed">-     _monitor(monitor) {</span>
      // Superclass constructor did locking
    }
  
<span class="line-modified">!   ~MonitorLockerEx() {</span>
<span class="line-modified">!     #ifdef ASSERT</span>
<span class="line-modified">!       if (_monitor != NULL) {</span>
<span class="line-modified">!         assert_lock_strong(_monitor);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     #endif  // ASSERT</span>
<span class="line-removed">-     // Superclass destructor will do unlocking</span>
    }
  
<span class="line-modified">!   bool wait(bool no_safepoint_check = !Mutex::_no_safepoint_check_flag,</span>
<span class="line-removed">-             long timeout = 0,</span>
              bool as_suspend_equivalent = !Mutex::_as_suspend_equivalent_flag) {
<span class="line-modified">!     if (_monitor != NULL) {</span>
<span class="line-modified">!       return _monitor-&gt;wait(no_safepoint_check, timeout, as_suspend_equivalent);</span>
      }
      return false;
    }
  
    void notify_all() {
<span class="line-modified">!     if (_monitor != NULL) {</span>
<span class="line-removed">-       _monitor-&gt;notify_all();</span>
<span class="line-removed">-     }</span>
    }
  
    void notify() {
<span class="line-modified">!     if (_monitor != NULL) {</span>
<span class="line-removed">-       _monitor-&gt;notify();</span>
<span class="line-removed">-     }</span>
    }
  };
  
  
<span class="line-removed">- </span>
  // A GCMutexLocker is usually initialized with a mutex that is
  // automatically acquired in order to do GC.  The function that
  // synchronizes using a GCMutexLocker may be called both during and between
  // GC&#39;s.  Thus, it must acquire the mutex if GC is not in progress, but not
  // if GC is in progress (since the mutex is already held on its behalf.)
  
  class GCMutexLocker: public StackObj {
  private:
<span class="line-modified">!   Monitor * _mutex;</span>
    bool _locked;
  public:
<span class="line-modified">!   GCMutexLocker(Monitor * mutex);</span>
    ~GCMutexLocker() { if (_locked) _mutex-&gt;unlock(); }
  };
  
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  // A MutexUnlocker temporarily exits a previously
  // entered mutex for the scope which contains the unlocker.
  
  class MutexUnlocker: StackObj {
   private:
<span class="line-modified">!   Monitor * _mutex;</span>
<span class="line-removed">- </span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   MutexUnlocker(Monitor * mutex) {</span>
<span class="line-removed">-     _mutex = mutex;</span>
<span class="line-removed">-     _mutex-&gt;unlock();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ~MutexUnlocker() {</span>
<span class="line-removed">-     _mutex-&gt;lock();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- // A MutexUnlockerEx temporarily exits a previously</span>
<span class="line-removed">- // entered mutex for the scope which contains the unlocker.</span>
<span class="line-removed">- </span>
<span class="line-removed">- class MutexUnlockerEx: StackObj {</span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   Monitor * _mutex;</span>
    bool _no_safepoint_check;
  
   public:
<span class="line-modified">!   MutexUnlockerEx(Monitor * mutex, bool no_safepoint_check = !Mutex::_no_safepoint_check_flag) {</span>
<span class="line-modified">!     _mutex = mutex;</span>
<span class="line-modified">!     _no_safepoint_check = no_safepoint_check;</span>
      _mutex-&gt;unlock();
    }
  
<span class="line-modified">!   ~MutexUnlockerEx() {</span>
<span class="line-modified">!     if (_no_safepoint_check == Mutex::_no_safepoint_check_flag) {</span>
        _mutex-&gt;lock_without_safepoint_check();
      } else {
        _mutex-&gt;lock();
      }
    }
<span class="line-new-header">--- 173,136 ---</span>
  // by fatal error handler.
  void print_owned_locks_on_error(outputStream* st);
  
  char *lock_name(Mutex *mutex);
  
<span class="line-modified">! // for debugging: check that we&#39;re already owning this lock (or are at a safepoint / handshake)</span>
  #ifdef ASSERT
<span class="line-modified">! void assert_locked_or_safepoint(const Mutex* lock);</span>
<span class="line-modified">! void assert_locked_or_safepoint_weak(const Mutex* lock);</span>
<span class="line-modified">! void assert_lock_strong(const Mutex* lock);</span>
<span class="line-added">+ void assert_locked_or_safepoint_or_handshake(const Mutex* lock, const JavaThread* thread);</span>
  #else
  #define assert_locked_or_safepoint(lock)
  #define assert_locked_or_safepoint_weak(lock)
  #define assert_lock_strong(lock)
<span class="line-added">+ #define assert_locked_or_safepoint_or_handshake(lock, thread)</span>
  #endif
  
<span class="line-modified">! class MutexLocker: public StackObj {</span>
<span class="line-modified">!  protected:</span>
<span class="line-modified">!   Mutex* _mutex;</span>
   private:
   public:
<span class="line-modified">!   MutexLocker(Mutex* mutex, Mutex::SafepointCheckFlag flag = Mutex::_safepoint_check_flag) :</span>
<span class="line-modified">!     _mutex(mutex) {</span>
<span class="line-added">+     bool no_safepoint_check = flag == Mutex::_no_safepoint_check_flag;</span>
      if (_mutex != NULL) {
<span class="line-modified">!       assert(_mutex-&gt;rank() &gt; Mutex::special || no_safepoint_check,</span>
<span class="line-modified">!              &quot;Mutexes with rank special or lower should not do safepoint checks&quot;);</span>
<span class="line-modified">!       if (no_safepoint_check) {</span>
          _mutex-&gt;lock_without_safepoint_check();
<span class="line-modified">!       } else {</span>
          _mutex-&gt;lock();
<span class="line-added">+       }</span>
      }
    }
  
<span class="line-modified">!   MutexLocker(Thread* thread, Mutex* mutex, Mutex::SafepointCheckFlag flag = Mutex::_safepoint_check_flag) :</span>
<span class="line-added">+     _mutex(mutex) {</span>
<span class="line-added">+     bool no_safepoint_check = flag == Mutex::_no_safepoint_check_flag;</span>
<span class="line-added">+     if (_mutex != NULL) {</span>
<span class="line-added">+       assert(_mutex-&gt;rank() &gt; Mutex::special || no_safepoint_check,</span>
<span class="line-added">+              &quot;Mutexes with rank special or lower should not do safepoint checks&quot;);</span>
<span class="line-added">+       if (no_safepoint_check) {</span>
<span class="line-added">+         _mutex-&gt;lock_without_safepoint_check(thread);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         _mutex-&gt;lock(thread);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~MutexLocker() {</span>
      if (_mutex != NULL) {
<span class="line-added">+       assert_lock_strong(_mutex);</span>
        _mutex-&gt;unlock();
      }
    }
  };
  
<span class="line-modified">! // A MonitorLocker is like a MutexLocker above, except it allows</span>
<span class="line-modified">! // wait/notify as well which are delegated to the underlying Monitor.</span>
<span class="line-modified">! // It also disallows NULL.</span>
  
<span class="line-modified">! class MonitorLocker: public MutexLocker {</span>
<span class="line-modified">!   Mutex::SafepointCheckFlag _flag;</span>
<span class="line-modified">!   Monitor* _monitor;</span>
   public:
<span class="line-modified">!   MonitorLocker(Monitor* monitor, Mutex::SafepointCheckFlag flag = Mutex::_safepoint_check_flag) :</span>
<span class="line-modified">!     MutexLocker(monitor, flag), _flag(flag), _monitor(monitor) {</span>
      // Superclass constructor did locking
<span class="line-added">+     assert(_monitor != NULL, &quot;NULL monitor not allowed&quot;);</span>
    }
  
<span class="line-modified">!   MonitorLocker(Thread* thread, Monitor* monitor, Mutex::SafepointCheckFlag flag = Mutex::_safepoint_check_flag) :</span>
<span class="line-modified">!     MutexLocker(thread, monitor, flag), _flag(flag), _monitor(monitor)  {</span>
<span class="line-modified">!     // Superclass constructor did locking</span>
<span class="line-modified">!     assert(_monitor != NULL, &quot;NULL monitor not allowed&quot;);</span>
    }
  
<span class="line-modified">!   bool wait(long timeout = 0,</span>
              bool as_suspend_equivalent = !Mutex::_as_suspend_equivalent_flag) {
<span class="line-modified">!     if (_flag == Mutex::_safepoint_check_flag) {</span>
<span class="line-modified">!       return _monitor-&gt;wait(timeout, as_suspend_equivalent);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       return _monitor-&gt;wait_without_safepoint_check(timeout);</span>
      }
      return false;
    }
  
    void notify_all() {
<span class="line-modified">!     _monitor-&gt;notify_all();</span>
    }
  
    void notify() {
<span class="line-modified">!     _monitor-&gt;notify();</span>
    }
  };
  
  
  // A GCMutexLocker is usually initialized with a mutex that is
  // automatically acquired in order to do GC.  The function that
  // synchronizes using a GCMutexLocker may be called both during and between
  // GC&#39;s.  Thus, it must acquire the mutex if GC is not in progress, but not
  // if GC is in progress (since the mutex is already held on its behalf.)
  
  class GCMutexLocker: public StackObj {
  private:
<span class="line-modified">!   Mutex* _mutex;</span>
    bool _locked;
  public:
<span class="line-modified">!   GCMutexLocker(Mutex* mutex);</span>
    ~GCMutexLocker() { if (_locked) _mutex-&gt;unlock(); }
  };
  
  // A MutexUnlocker temporarily exits a previously
  // entered mutex for the scope which contains the unlocker.
  
  class MutexUnlocker: StackObj {
   private:
<span class="line-modified">!   Mutex* _mutex;</span>
    bool _no_safepoint_check;
  
   public:
<span class="line-modified">!   MutexUnlocker(Mutex* mutex, Mutex::SafepointCheckFlag flag = Mutex::_safepoint_check_flag) :</span>
<span class="line-modified">!     _mutex(mutex),</span>
<span class="line-modified">!     _no_safepoint_check(flag) {</span>
      _mutex-&gt;unlock();
    }
  
<span class="line-modified">!   ~MutexUnlocker() {</span>
<span class="line-modified">!     if (_no_safepoint_check) {</span>
        _mutex-&gt;lock_without_safepoint_check();
      } else {
        _mutex-&gt;lock();
      }
    }
</pre>
<center><a href="mutexLocker.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objectMonitor.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/runtime/orderAccess.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_ORDERACCESS_HPP
 26 #define SHARE_RUNTIME_ORDERACCESS_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 //                Memory Access Ordering Model
 32 //
 33 // This interface is based on the JSR-133 Cookbook for Compiler Writers.
 34 //
 35 // In the following, the terms &#39;previous&#39;, &#39;subsequent&#39;, &#39;before&#39;,
 36 // &#39;after&#39;, &#39;preceding&#39; and &#39;succeeding&#39; refer to program order.  The
 37 // terms &#39;down&#39; and &#39;below&#39; refer to forward load or store motion
 38 // relative to program order, while &#39;up&#39; and &#39;above&#39; refer to backward
 39 // motion.
 40 //
 41 // We define four primitive memory barrier operations.
 42 //
 43 // LoadLoad:   Load1(s); LoadLoad; Load2
 44 //
 45 // Ensures that Load1 completes (obtains the value it loads from memory)
 46 // before Load2 and any subsequent load operations.  Loads before Load1
 47 // may *not* float below Load2 and any subsequent load operations.
 48 //
 49 // StoreStore: Store1(s); StoreStore; Store2
 50 //
 51 // Ensures that Store1 completes (the effect on memory of Store1 is made
 52 // visible to other processors) before Store2 and any subsequent store
 53 // operations.  Stores before Store1 may *not* float below Store2 and any
 54 // subsequent store operations.
 55 //
 56 // LoadStore:  Load1(s); LoadStore; Store2
 57 //
 58 // Ensures that Load1 completes before Store2 and any subsequent store
 59 // operations.  Loads before Load1 may *not* float below Store2 and any
 60 // subsequent store operations.
 61 //
 62 // StoreLoad:  Store1(s); StoreLoad; Load2
 63 //
 64 // Ensures that Store1 completes before Load2 and any subsequent load
 65 // operations.  Stores before Store1 may *not* float below Load2 and any
 66 // subsequent load operations.
 67 //
 68 // We define two further barriers: acquire and release.
 69 //
 70 // Conceptually, acquire/release semantics form unidirectional and
 71 // asynchronous barriers w.r.t. a synchronizing load(X) and store(X) pair.
 72 // They should always be used in pairs to publish (release store) and
 73 // access (load acquire) some implicitly understood shared data between
 74 // threads in a relatively cheap fashion not requiring storeload. If not
 75 // used in such a pair, it is advised to use a membar instead:
 76 // acquire/release only make sense as pairs.
 77 //
 78 // T1: access_shared_data
 79 // T1: ]release
 80 // T1: (...)
 81 // T1: store(X)
 82 //
 83 // T2: load(X)
 84 // T2: (...)
 85 // T2: acquire[
 86 // T2: access_shared_data
 87 //
 88 // It is guaranteed that if T2: load(X) synchronizes with (observes the
 89 // value written by) T1: store(X), then the memory accesses before the T1:
 90 // ]release happen before the memory accesses after the T2: acquire[.
 91 //
 92 // Total Store Order (TSO) machines can be seen as machines issuing a
 93 // release store for each store and a load acquire for each load. Therefore
 94 // there is an inherent resemblence between TSO and acquire/release
 95 // semantics. TSO can be seen as an abstract machine where loads are
 96 // executed immediately when encountered (hence loadload reordering not
 97 // happening) but enqueues stores in a FIFO queue
 98 // for asynchronous serialization (neither storestore or loadstore
 99 // reordering happening). The only reordering happening is storeload due to
100 // the queue asynchronously serializing stores (yet in order).
101 //
102 // Acquire/release semantics essentially exploits this asynchronicity: when
103 // the load(X) acquire[ observes the store of ]release store(X), the
104 // accesses before the release must have happened before the accesses after
105 // acquire.
106 //
107 // The API offers both stand-alone acquire() and release() as well as bound
108 // load_acquire() and release_store(). It is guaranteed that these are
109 // semantically equivalent w.r.t. the defined model. However, since
110 // stand-alone acquire()/release() does not know which previous
111 // load/subsequent store is considered the synchronizing load/store, they
112 // may be more conservative in implementations. We advise using the bound
113 // variants whenever possible.
114 //
115 // Finally, we define a &quot;fence&quot; operation, as a bidirectional barrier.
116 // It guarantees that any memory access preceding the fence is not
117 // reordered w.r.t. any memory accesses subsequent to the fence in program
118 // order. This may be used to prevent sequences of loads from floating up
119 // above sequences of stores.
120 //
121 // The following table shows the implementations on some architectures:
122 //
123 //                       Constraint     x86          sparc TSO          ppc
124 // ---------------------------------------------------------------------------
125 // fence                 LoadStore  |   lock         membar #StoreLoad  sync
126 //                       StoreStore |   addl 0,(sp)
127 //                       LoadLoad   |
128 //                       StoreLoad
129 //
130 // release               LoadStore  |                                   lwsync
131 //                       StoreStore
132 //
133 // acquire               LoadLoad   |                                   lwsync
134 //                       LoadStore
135 //
136 // release_store                        &lt;store&gt;      &lt;store&gt;            lwsync
137 //                                                                      &lt;store&gt;
138 //
139 // release_store_fence                  xchg         &lt;store&gt;            lwsync
140 //                                                   membar #StoreLoad  &lt;store&gt;
141 //                                                                      sync
142 //
143 //
144 // load_acquire                         &lt;load&gt;       &lt;load&gt;             &lt;load&gt;
145 //                                                                      lwsync
146 //
147 // Ordering a load relative to preceding stores requires a StoreLoad,
148 // which implies a membar #StoreLoad between the store and load under
149 // sparc-TSO. On x86, we use explicitly locked add.
150 //
151 // Conventional usage is to issue a load_acquire for ordered loads.  Use
152 // release_store for ordered stores when you care only that prior stores
153 // are visible before the release_store, but don&#39;t care exactly when the
154 // store associated with the release_store becomes visible.  Use
155 // release_store_fence to update values like the thread state, where we
156 // don&#39;t want the current thread to continue until all our prior memory
157 // accesses (including the new thread state) are visible to other threads.
158 // This is equivalent to the volatile semantics of the Java Memory Model.
159 //
160 //                    C++ Volatile Semantics
161 //
162 // C++ volatile semantics prevent compiler re-ordering between
163 // volatile memory accesses. However, reordering between non-volatile
164 // and volatile memory accesses is in general undefined. For compiler
165 // reordering constraints taking non-volatile memory accesses into
166 // consideration, a compiler barrier has to be used instead.  Some
167 // compiler implementations may choose to enforce additional
168 // constraints beyond those required by the language. Note also that
169 // both volatile semantics and compiler barrier do not prevent
170 // hardware reordering.
171 //
172 //                os::is_MP Considered Redundant
173 //
174 // Callers of this interface do not need to test os::is_MP() before
175 // issuing an operation. The test is taken care of by the implementation
176 // of the interface (depending on the vm version and platform, the test
177 // may or may not be actually done by the implementation).
178 //
179 //
180 //                A Note on Memory Ordering and Cache Coherency
181 //
182 // Cache coherency and memory ordering are orthogonal concepts, though they
183 // interact.  E.g., all existing itanium machines are cache-coherent, but
184 // the hardware can freely reorder loads wrt other loads unless it sees a
185 // load-acquire instruction.  All existing sparc machines are cache-coherent
186 // and, unlike itanium, TSO guarantees that the hardware orders loads wrt
187 // loads and stores, and stores wrt to each other.
188 //
189 // Consider the implementation of loadload.  *If* your platform *isn&#39;t*
190 // cache-coherent, then loadload must not only prevent hardware load
191 // instruction reordering, but it must *also* ensure that subsequent
192 // loads from addresses that could be written by other processors (i.e.,
193 // that are broadcast by other processors) go all the way to the first
194 // level of memory shared by those processors and the one issuing
195 // the loadload.
196 //
197 // So if we have a MP that has, say, a per-processor D$ that doesn&#39;t see
198 // writes by other processors, and has a shared E$ that does, the loadload
199 // barrier would have to make sure that either
200 //
201 // 1. cache lines in the issuing processor&#39;s D$ that contained data from
202 // addresses that could be written by other processors are invalidated, so
203 // subsequent loads from those addresses go to the E$, (it could do this
204 // by tagging such cache lines as &#39;shared&#39;, though how to tell the hardware
205 // to do the tagging is an interesting problem), or
206 //
207 // 2. there never are such cache lines in the issuing processor&#39;s D$, which
208 // means all references to shared data (however identified: see above)
209 // bypass the D$ (i.e., are satisfied from the E$).
210 //
211 // If your machine doesn&#39;t have an E$, substitute &#39;main memory&#39; for &#39;E$&#39;.
212 //
213 // Either of these alternatives is a pain, so no current machine we know of
214 // has incoherent caches.
215 //
216 // If loadload didn&#39;t have these properties, the store-release sequence for
217 // publishing a shared data structure wouldn&#39;t work, because a processor
218 // trying to read data newly published by another processor might go to
219 // its own incoherent caches to satisfy the read instead of to the newly
220 // written shared memory.
221 //
222 //
223 //                NOTE WELL!!
224 //
225 //                A Note on MutexLocker and Friends
226 //
227 // See mutexLocker.hpp.  We assume throughout the VM that MutexLocker&#39;s
228 // and friends&#39; constructors do a fence, a lock and an acquire *in that
229 // order*.  And that their destructors do a release and unlock, in *that*
230 // order.  If their implementations change such that these assumptions
231 // are violated, a whole lot of code will break.
232 
233 class OrderAccess : public AllStatic {
234  public:
235   // barriers
236   static void     loadload();
237   static void     storestore();
238   static void     loadstore();
239   static void     storeload();
240 
241   static void     acquire();
242   static void     release();
243   static void     fence();
244 
245   static void     cross_modify_fence();
246 private:
247   // This is a helper that invokes the StubRoutines::fence_entry()
248   // routine if it exists, It should only be used by platforms that
249   // don&#39;t have another way to do the inline assembly.
250   static void StubRoutines_fence();
251 };
252 
253 #include OS_CPU_HEADER(orderAccess)
254 
255 #endif // SHARE_RUNTIME_ORDERACCESS_HPP
    </pre>
  </body>
</html>
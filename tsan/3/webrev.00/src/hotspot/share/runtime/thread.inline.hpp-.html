<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/thread.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_THREAD_INLINE_HPP
 26 #define SHARE_RUNTIME_THREAD_INLINE_HPP
 27 
 28 #include &quot;runtime/atomic.hpp&quot;
 29 #include &quot;runtime/globals.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/os.inline.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 
 35 inline void Thread::set_suspend_flag(SuspendFlags f) {
 36   uint32_t flags;
 37   do {
 38     flags = _suspend_flags;
 39   }
 40   while (Atomic::cmpxchg((flags | f), &amp;_suspend_flags, flags) != flags);
 41 }
 42 inline void Thread::clear_suspend_flag(SuspendFlags f) {
 43   uint32_t flags;
 44   do {
 45     flags = _suspend_flags;
 46   }
 47   while (Atomic::cmpxchg((flags &amp; ~f), &amp;_suspend_flags, flags) != flags);
 48 }
 49 
 50 inline void Thread::set_has_async_exception() {
 51   set_suspend_flag(_has_async_exception);
 52 }
 53 inline void Thread::clear_has_async_exception() {
 54   clear_suspend_flag(_has_async_exception);
 55 }
 56 inline void Thread::set_critical_native_unlock() {
 57   set_suspend_flag(_critical_native_unlock);
 58 }
 59 inline void Thread::clear_critical_native_unlock() {
 60   clear_suspend_flag(_critical_native_unlock);
 61 }
 62 inline void Thread::set_trace_flag() {
 63   set_suspend_flag(_trace_flag);
 64 }
 65 inline void Thread::clear_trace_flag() {
 66   clear_suspend_flag(_trace_flag);
 67 }
 68 
 69 inline jlong Thread::cooked_allocated_bytes() {
 70   jlong allocated_bytes = OrderAccess::load_acquire(&amp;_allocated_bytes);
 71   if (UseTLAB) {
 72     size_t used_bytes = tlab().used_bytes();
 73     if (used_bytes &lt;= ThreadLocalAllocBuffer::max_size_in_bytes()) {
 74       // Comparing used_bytes with the maximum allowed size will ensure
 75       // that we don&#39;t add the used bytes from a semi-initialized TLAB
 76       // ending up with incorrect values. There is still a race between
 77       // incrementing _allocated_bytes and clearing the TLAB, that might
 78       // cause double counting in rare cases.
 79       return allocated_bytes + used_bytes;
 80     }
 81   }
 82   return allocated_bytes;
 83 }
 84 
 85 inline ThreadsList* Thread::cmpxchg_threads_hazard_ptr(ThreadsList* exchange_value, ThreadsList* compare_value) {
 86   return (ThreadsList*)Atomic::cmpxchg(exchange_value, &amp;_threads_hazard_ptr, compare_value);
 87 }
 88 
 89 inline ThreadsList* Thread::get_threads_hazard_ptr() {
 90   return (ThreadsList*)OrderAccess::load_acquire(&amp;_threads_hazard_ptr);
 91 }
 92 
 93 inline void Thread::set_threads_hazard_ptr(ThreadsList* new_list) {
 94   OrderAccess::release_store_fence(&amp;_threads_hazard_ptr, new_list);
 95 }
 96 
 97 inline void JavaThread::set_ext_suspended() {
 98   set_suspend_flag (_ext_suspended);
 99 }
100 inline void JavaThread::clear_ext_suspended() {
101   clear_suspend_flag(_ext_suspended);
102 }
103 
104 inline void JavaThread::set_external_suspend() {
105   set_suspend_flag(_external_suspend);
106 }
107 inline void JavaThread::clear_external_suspend() {
108   clear_suspend_flag(_external_suspend);
109 }
110 
111 inline void JavaThread::set_deopt_suspend() {
112   set_suspend_flag(_deopt_suspend);
113 }
114 inline void JavaThread::clear_deopt_suspend() {
115   clear_suspend_flag(_deopt_suspend);
116 }
117 
118 inline void JavaThread::set_pending_async_exception(oop e) {
119   _pending_async_exception = e;
120   _special_runtime_exit_condition = _async_exception;
121   set_has_async_exception();
122 }
123 
124 inline JavaThreadState JavaThread::thread_state() const    {
125 #if defined(PPC64) || defined (AARCH64)
126   // Use membars when accessing volatile _thread_state. See
127   // Threads::create_vm() for size checks.
128   return (JavaThreadState) OrderAccess::load_acquire((volatile jint*)&amp;_thread_state);
129 #else
130   return _thread_state;
131 #endif
132 }
133 
134 inline void JavaThread::set_thread_state(JavaThreadState s) {
135 #if defined(PPC64) || defined (AARCH64)
136   // Use membars when accessing volatile _thread_state. See
137   // Threads::create_vm() for size checks.
138   OrderAccess::release_store((volatile jint*)&amp;_thread_state, (jint)s);
139 #else
140   _thread_state = s;
141 #endif
142 }
143 
144 ThreadSafepointState* JavaThread::safepoint_state() const  {
145   return _safepoint_state;
146 }
147 
148 void JavaThread::set_safepoint_state(ThreadSafepointState *state) {
149   _safepoint_state = state;
150 }
151 
152 bool JavaThread::is_at_poll_safepoint() {
153   return _safepoint_state-&gt;is_at_poll_safepoint();
154 }
155 
156 void JavaThread::enter_critical() {
157   assert(Thread::current() == this ||
158          (Thread::current()-&gt;is_VM_thread() &amp;&amp;
159          SafepointSynchronize::is_synchronizing()),
160          &quot;this must be current thread or synchronizing&quot;);
161   _jni_active_critical++;
162 }
163 
164 inline void JavaThread::set_done_attaching_via_jni() {
165   _jni_attach_state = _attached_via_jni;
166   OrderAccess::fence();
167 }
168 
169 inline bool JavaThread::stack_guard_zone_unused() {
170   return _stack_guard_state == stack_guard_unused;
171 }
172 
173 inline bool JavaThread::stack_yellow_reserved_zone_disabled() {
174   return _stack_guard_state == stack_guard_yellow_reserved_disabled;
175 }
176 
177 inline bool JavaThread::stack_reserved_zone_disabled() {
178   return _stack_guard_state == stack_guard_reserved_disabled;
179 }
180 
181 inline size_t JavaThread::stack_available(address cur_sp) {
182   // This code assumes java stacks grow down
183   address low_addr; // Limit on the address for deepest stack depth
184   if (_stack_guard_state == stack_guard_unused) {
185     low_addr = stack_end();
186   } else {
187     low_addr = stack_reserved_zone_base();
188   }
189   return cur_sp &gt; low_addr ? cur_sp - low_addr : 0;
190 }
191 
192 inline bool JavaThread::stack_guards_enabled() {
193 #ifdef ASSERT
194   if (os::uses_stack_guard_pages() &amp;&amp;
195       !(DisablePrimordialThreadGuardPages &amp;&amp; os::is_primordial_thread())) {
196     assert(_stack_guard_state != stack_guard_unused, &quot;guard pages must be in use&quot;);
197   }
198 #endif
199   return _stack_guard_state == stack_guard_enabled;
200 }
201 
202 // The release make sure this store is done after storing the handshake
203 // operation or global state
204 inline void JavaThread::set_polling_page_release(void* poll_value) {
205   OrderAccess::release_store(polling_page_addr(), poll_value);
206 }
207 
208 // Caller is responsible for using a memory barrier if needed.
209 inline void JavaThread::set_polling_page(void* poll_value) {
210   *polling_page_addr() = poll_value;
211 }
212 
213 // The aqcquire make sure reading of polling page is done before
214 // the reading the handshake operation or the global state
215 inline volatile void* JavaThread::get_polling_page() {
216   return OrderAccess::load_acquire(polling_page_addr());
217 }
218 
219 inline bool JavaThread::is_exiting() const {
220   // Use load-acquire so that setting of _terminated by
221   // JavaThread::exit() is seen more quickly.
222   TerminatedTypes l_terminated = (TerminatedTypes)
223       OrderAccess::load_acquire((volatile jint *) &amp;_terminated);
224   return l_terminated == _thread_exiting || check_is_terminated(l_terminated);
225 }
226 
227 inline bool JavaThread::is_terminated() const {
228   // Use load-acquire so that setting of _terminated by
229   // JavaThread::exit() is seen more quickly.
230   TerminatedTypes l_terminated = (TerminatedTypes)
231       OrderAccess::load_acquire((volatile jint *) &amp;_terminated);
232   return check_is_terminated(l_terminated);
233 }
234 
235 inline void JavaThread::set_terminated(TerminatedTypes t) {
236   // use release-store so the setting of _terminated is seen more quickly
237   OrderAccess::release_store((volatile jint *) &amp;_terminated, (jint) t);
238 }
239 
240 // special for Threads::remove() which is static:
241 inline void JavaThread::set_terminated_value() {
242   // use release-store so the setting of _terminated is seen more quickly
243   OrderAccess::release_store((volatile jint *) &amp;_terminated, (jint) _thread_terminated);
244 }
245 
246 // Allow tracking of class initialization monitor use
247 inline void JavaThread::set_class_to_be_initialized(InstanceKlass* k) {
248   assert((k == NULL &amp;&amp; _class_to_be_initialized != NULL) ||
249          (k != NULL &amp;&amp; _class_to_be_initialized == NULL), &quot;incorrect usage&quot;);
250   assert(this == Thread::current(), &quot;Only the current thread can set this field&quot;);
251   _class_to_be_initialized = k;
252 }
253 
254 inline InstanceKlass* JavaThread::class_to_be_initialized() const {
255   return _class_to_be_initialized;
256 }
257 
258 #endif // SHARE_RUNTIME_THREAD_INLINE_HPP
    </pre>
  </body>
</html>
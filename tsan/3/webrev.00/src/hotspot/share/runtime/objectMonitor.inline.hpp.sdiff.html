<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/objectMonitor.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="objectMonitor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="orderAccess.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/objectMonitor.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
 26 #define SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
 27 



 28 inline intptr_t ObjectMonitor::is_entered(TRAPS) const {
 29   if (THREAD == _owner || THREAD-&gt;is_lock_owned((address) _owner)) {
 30     return 1;
 31   }
 32   return 0;
 33 }
 34 
<span class="line-modified"> 35 inline markOop ObjectMonitor::header() const {</span>
<span class="line-modified"> 36   return _header;</span>
 37 }
 38 
<span class="line-modified"> 39 inline volatile markOop* ObjectMonitor::header_addr() {</span>
 40   assert((intptr_t)this == (intptr_t)&amp;_header, &quot;sync code expects this&quot;);
 41   return &amp;_header;
 42 }
 43 
<span class="line-modified"> 44 inline void ObjectMonitor::set_header(markOop hdr) {</span>
<span class="line-modified"> 45   _header = hdr;</span>
<span class="line-removed"> 46 }</span>
<span class="line-removed"> 47 </span>
<span class="line-removed"> 48 inline jint ObjectMonitor::count() const {</span>
<span class="line-removed"> 49   return _count;</span>
 50 }
 51 
 52 inline jint ObjectMonitor::waiters() const {
 53   return _waiters;
 54 }
 55 
 56 inline void* ObjectMonitor::owner() const {
 57   return _owner;
 58 }
 59 
 60 inline void ObjectMonitor::clear() {
<span class="line-modified"> 61   assert(_header != NULL, &quot;Fatal logic error in ObjectMonitor header!&quot;);</span>
<span class="line-modified"> 62   assert(_count == 0, &quot;Fatal logic error in ObjectMonitor count!&quot;);</span>
<span class="line-modified"> 63   assert(_waiters == 0, &quot;Fatal logic error in ObjectMonitor waiters!&quot;);</span>
<span class="line-modified"> 64   assert(_recursions == 0, &quot;Fatal logic error in ObjectMonitor recursions!&quot;);</span>
<span class="line-modified"> 65   assert(_object != NULL, &quot;Fatal logic error in ObjectMonitor object!&quot;);</span>
<span class="line-modified"> 66   assert(_owner == NULL, &quot;Fatal logic error in ObjectMonitor owner!&quot;);</span>
<span class="line-modified"> 67 </span>
<span class="line-modified"> 68   _header = NULL;</span>
 69   _object = NULL;
 70 }
 71 
 72 inline void* ObjectMonitor::object() const {
 73   return _object;
 74 }
 75 
 76 inline void* ObjectMonitor::object_addr() {
 77   return (void *)(&amp;_object);
 78 }
 79 
 80 inline void ObjectMonitor::set_object(void* obj) {
 81   _object = obj;
 82 }
 83 
<span class="line-modified"> 84 inline bool ObjectMonitor::check(TRAPS) {</span>
<span class="line-modified"> 85   if (THREAD != _owner) {</span>
<span class="line-modified"> 86     if (THREAD-&gt;is_lock_owned((address) _owner)) {</span>
<span class="line-modified"> 87       _owner = THREAD;  // regain ownership of inflated monitor</span>
<span class="line-modified"> 88       assert (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="line-modified"> 89     } else {</span>
<span class="line-modified"> 90       check_slow(THREAD);</span>
<span class="line-modified"> 91       return false;</span>
<span class="line-modified"> 92     }</span>












































 93   }
<span class="line-modified"> 94   return true;</span>
 95 }
 96 
<span class="line-modified"> 97 // return number of threads contending for this monitor</span>
<span class="line-modified"> 98 inline jint ObjectMonitor::contentions() const {</span>
<span class="line-modified"> 99   return _count;</span>








100 }
101 
<span class="line-modified">102 // Do NOT set _count = 0. There is a race such that _count could</span>
<span class="line-modified">103 // be set while inflating prior to setting _owner</span>
<span class="line-modified">104 // Just use Atomic::inc/dec and assert 0 when monitor put on free list</span>
<span class="line-modified">105 inline void ObjectMonitor::set_owner(void* owner) {</span>
<span class="line-modified">106   _owner = owner;</span>
<span class="line-removed">107   _recursions = 0;</span>
108 }
109 
110 #endif // SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
 26 #define SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
 27 
<span class="line-added"> 28 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added"> 29 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added"> 30 </span>
 31 inline intptr_t ObjectMonitor::is_entered(TRAPS) const {
 32   if (THREAD == _owner || THREAD-&gt;is_lock_owned((address) _owner)) {
 33     return 1;
 34   }
 35   return 0;
 36 }
 37 
<span class="line-modified"> 38 inline markWord ObjectMonitor::header() const {</span>
<span class="line-modified"> 39   return Atomic::load(&amp;_header);</span>
 40 }
 41 
<span class="line-modified"> 42 inline volatile markWord* ObjectMonitor::header_addr() {</span>
 43   assert((intptr_t)this == (intptr_t)&amp;_header, &quot;sync code expects this&quot;);
 44   return &amp;_header;
 45 }
 46 
<span class="line-modified"> 47 inline void ObjectMonitor::set_header(markWord hdr) {</span>
<span class="line-modified"> 48   Atomic::store(&amp;_header, hdr);</span>




 49 }
 50 
 51 inline jint ObjectMonitor::waiters() const {
 52   return _waiters;
 53 }
 54 
 55 inline void* ObjectMonitor::owner() const {
 56   return _owner;
 57 }
 58 
 59 inline void ObjectMonitor::clear() {
<span class="line-modified"> 60   assert(Atomic::load(&amp;_header).value() != 0, &quot;must be non-zero&quot;);</span>
<span class="line-modified"> 61   assert(_contentions == 0, &quot;must be 0: contentions=%d&quot;, _contentions);</span>
<span class="line-modified"> 62   assert(_waiters == 0, &quot;must be 0: waiters=%d&quot;, _waiters);</span>
<span class="line-modified"> 63   assert(_recursions == 0, &quot;must be 0: recursions=&quot; INTX_FORMAT, _recursions);</span>
<span class="line-modified"> 64   assert(_object != NULL, &quot;must be non-NULL&quot;);</span>
<span class="line-modified"> 65   assert(_owner == NULL, &quot;must be NULL: owner=&quot; INTPTR_FORMAT, p2i(_owner));</span>
<span class="line-modified"> 66 </span>
<span class="line-modified"> 67   Atomic::store(&amp;_header, markWord::zero());</span>
 68   _object = NULL;
 69 }
 70 
 71 inline void* ObjectMonitor::object() const {
 72   return _object;
 73 }
 74 
 75 inline void* ObjectMonitor::object_addr() {
 76   return (void *)(&amp;_object);
 77 }
 78 
 79 inline void ObjectMonitor::set_object(void* obj) {
 80   _object = obj;
 81 }
 82 
<span class="line-modified"> 83 // return number of threads contending for this monitor</span>
<span class="line-modified"> 84 inline jint ObjectMonitor::contentions() const {</span>
<span class="line-modified"> 85   return _contentions;</span>
<span class="line-modified"> 86 }</span>
<span class="line-modified"> 87 </span>
<span class="line-modified"> 88 // Clear _owner field; current value must match old_value.</span>
<span class="line-modified"> 89 inline void ObjectMonitor::release_clear_owner(void* old_value) {</span>
<span class="line-modified"> 90   DEBUG_ONLY(void* prev = Atomic::load(&amp;_owner);)</span>
<span class="line-modified"> 91   assert(prev == old_value, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-added"> 92          &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(old_value));</span>
<span class="line-added"> 93   Atomic::release_store(&amp;_owner, (void*)NULL);</span>
<span class="line-added"> 94   log_trace(monitorinflation, owner)(&quot;release_clear_owner(): mid=&quot;</span>
<span class="line-added"> 95                                      INTPTR_FORMAT &quot;, old_value=&quot; INTPTR_FORMAT,</span>
<span class="line-added"> 96                                      p2i(this), p2i(old_value));</span>
<span class="line-added"> 97 }</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99 // Simply set _owner field to new_value; current value must match old_value.</span>
<span class="line-added">100 // (Simple means no memory sync needed.)</span>
<span class="line-added">101 inline void ObjectMonitor::set_owner_from(void* old_value, void* new_value) {</span>
<span class="line-added">102   DEBUG_ONLY(void* prev = Atomic::load(&amp;_owner);)</span>
<span class="line-added">103   assert(prev == old_value, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-added">104          &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(old_value));</span>
<span class="line-added">105   Atomic::store(&amp;_owner, new_value);</span>
<span class="line-added">106   log_trace(monitorinflation, owner)(&quot;set_owner_from(): mid=&quot;</span>
<span class="line-added">107                                      INTPTR_FORMAT &quot;, old_value=&quot; INTPTR_FORMAT</span>
<span class="line-added">108                                      &quot;, new_value=&quot; INTPTR_FORMAT, p2i(this),</span>
<span class="line-added">109                                      p2i(old_value), p2i(new_value));</span>
<span class="line-added">110 }</span>
<span class="line-added">111 </span>
<span class="line-added">112 // Simply set _owner field to self; current value must match basic_lock_p.</span>
<span class="line-added">113 inline void ObjectMonitor::set_owner_from_BasicLock(void* basic_lock_p, Thread* self) {</span>
<span class="line-added">114   DEBUG_ONLY(void* prev = Atomic::load(&amp;_owner);)</span>
<span class="line-added">115   assert(prev == basic_lock_p, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="line-added">116          &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(basic_lock_p));</span>
<span class="line-added">117   // Non-null owner field to non-null owner field is safe without</span>
<span class="line-added">118   // cmpxchg() as long as all readers can tolerate either flavor.</span>
<span class="line-added">119   Atomic::store(&amp;_owner, self);</span>
<span class="line-added">120   log_trace(monitorinflation, owner)(&quot;set_owner_from_BasicLock(): mid=&quot;</span>
<span class="line-added">121                                      INTPTR_FORMAT &quot;, basic_lock_p=&quot;</span>
<span class="line-added">122                                      INTPTR_FORMAT &quot;, new_value=&quot; INTPTR_FORMAT,</span>
<span class="line-added">123                                      p2i(this), p2i(basic_lock_p), p2i(self));</span>
<span class="line-added">124 }</span>
<span class="line-added">125 </span>
<span class="line-added">126 // Try to set _owner field to new_value if the current value matches</span>
<span class="line-added">127 // old_value. Otherwise, does not change the _owner field. Returns</span>
<span class="line-added">128 // the prior value of the _owner field.</span>
<span class="line-added">129 inline void* ObjectMonitor::try_set_owner_from(void* old_value, void* new_value) {</span>
<span class="line-added">130   void* prev = Atomic::cmpxchg(&amp;_owner, old_value, new_value);</span>
<span class="line-added">131   if (prev == old_value) {</span>
<span class="line-added">132     log_trace(monitorinflation, owner)(&quot;try_set_owner_from(): mid=&quot;</span>
<span class="line-added">133                                        INTPTR_FORMAT &quot;, prev=&quot; INTPTR_FORMAT</span>
<span class="line-added">134                                        &quot;, new=&quot; INTPTR_FORMAT, p2i(this),</span>
<span class="line-added">135                                        p2i(prev), p2i(new_value));</span>
136   }
<span class="line-modified">137   return prev;</span>
138 }
139 
<span class="line-modified">140 // The _next_om field can be concurrently read and modified so we</span>
<span class="line-modified">141 // use Atomic operations to disable compiler optimizations that</span>
<span class="line-modified">142 // might try to elide loading and/or storing this field.</span>
<span class="line-added">143 </span>
<span class="line-added">144 inline ObjectMonitor* ObjectMonitor::next_om() const {</span>
<span class="line-added">145   return Atomic::load(&amp;_next_om);</span>
<span class="line-added">146 }</span>
<span class="line-added">147 </span>
<span class="line-added">148 // Simply set _next_om field to new_value.</span>
<span class="line-added">149 inline void ObjectMonitor::set_next_om(ObjectMonitor* new_value) {</span>
<span class="line-added">150   Atomic::store(&amp;_next_om, new_value);</span>
151 }
152 
<span class="line-modified">153 // Try to set _next_om field to new_value if the current value matches</span>
<span class="line-modified">154 // old_value. Otherwise, does not change the _next_om field. Returns</span>
<span class="line-modified">155 // the prior value of the _next_om field.</span>
<span class="line-modified">156 inline ObjectMonitor* ObjectMonitor::try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value) {</span>
<span class="line-modified">157   return Atomic::cmpxchg(&amp;_next_om, old_value, new_value);</span>

158 }
159 
160 #endif // SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="objectMonitor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="orderAccess.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
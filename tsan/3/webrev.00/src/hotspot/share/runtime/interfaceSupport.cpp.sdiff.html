<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/interfaceSupport.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="init.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interfaceSupport.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/interfaceSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;

 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/frame.inline.hpp&quot;
 32 #include &quot;runtime/handles.inline.hpp&quot;
 33 #include &quot;runtime/init.hpp&quot;
 34 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-removed"> 35 #include &quot;runtime/orderAccess.hpp&quot;</span>
 36 #include &quot;runtime/os.inline.hpp&quot;
 37 #include &quot;runtime/thread.inline.hpp&quot;
 38 #include &quot;runtime/safepointVerifiers.hpp&quot;
 39 #include &quot;runtime/vframe.hpp&quot;
 40 #include &quot;runtime/vmThread.hpp&quot;
 41 #include &quot;utilities/preserveException.hpp&quot;
 42 
 43 // Implementation of InterfaceSupport
 44 
 45 #ifdef ASSERT
 46 VMEntryWrapper::VMEntryWrapper() {
 47   if (VerifyLastFrame) {
 48     InterfaceSupport::verify_last_frame();
 49   }
 50 }
 51 
 52 VMEntryWrapper::~VMEntryWrapper() {
 53   InterfaceSupport::check_gc_alot();
 54   if (WalkStackALot) {
 55     InterfaceSupport::walk_stack();
 56   }
<span class="line-removed"> 57 #ifdef COMPILER2</span>
<span class="line-removed"> 58   // This option is not used by Compiler 1</span>
<span class="line-removed"> 59   if (StressDerivedPointers) {</span>
<span class="line-removed"> 60     InterfaceSupport::stress_derived_pointers();</span>
<span class="line-removed"> 61   }</span>
<span class="line-removed"> 62 #endif</span>
 63   if (DeoptimizeALot || DeoptimizeRandom) {
 64     InterfaceSupport::deoptimizeAll();
 65   }
 66   if (ZombieALot) {
 67     InterfaceSupport::zombieAll();
 68   }
 69   // do verification AFTER potential deoptimization
 70   if (VerifyStack) {
 71     InterfaceSupport::verify_stack();
 72   }
 73 }
 74 








 75 long InterfaceSupport::_number_of_calls       = 0;
 76 long InterfaceSupport::_scavenge_alot_counter = 1;
 77 long InterfaceSupport::_fullgc_alot_counter   = 1;
 78 long InterfaceSupport::_fullgc_alot_invocation = 0;
 79 
 80 Histogram* RuntimeHistogram;
 81 
 82 RuntimeHistogramElement::RuntimeHistogramElement(const char* elementName) {
 83   static volatile int RuntimeHistogram_lock = 0;
 84   _name = elementName;
 85   uintx count = 0;
 86 
<span class="line-modified"> 87   while (Atomic::cmpxchg(1, &amp;RuntimeHistogram_lock, 0) != 0) {</span>
<span class="line-modified"> 88     while (OrderAccess::load_acquire(&amp;RuntimeHistogram_lock) != 0) {</span>
 89       count +=1;
 90       if ( (WarnOnStalledSpinLock &gt; 0)
 91         &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 92         warning(&quot;RuntimeHistogram_lock seems to be stalled&quot;);
 93       }
 94     }
 95   }
 96 
 97   if (RuntimeHistogram == NULL) {
 98     RuntimeHistogram = new Histogram(&quot;VM Runtime Call Counts&quot;,200);
 99   }
100 
101   RuntimeHistogram-&gt;add_element(this);
102   Atomic::dec(&amp;RuntimeHistogram_lock);
103 }
104 
105 void InterfaceSupport::gc_alot() {
106   Thread *thread = Thread::current();
107   if (!thread-&gt;is_Java_thread()) return; // Avoid concurrent calls
108   // Check for new, not quite initialized thread. A thread in new mode cannot initiate a GC.
</pre>
<hr />
<pre>
208 void InterfaceSupport::deoptimizeAll() {
209   // This method is called by all threads when a thread make
210   // transition to VM state (for example, runtime calls).
211   // Divide number of calls by number of threads to avoid
212   // dependence of DeoptimizeAll events frequency on number of threads.
213   int value = deoptimizeAllCounter / Threads::number_of_threads();
214   if (is_init_completed()) {
215     if (DeoptimizeALot &amp;&amp; value &gt; DeoptimizeALotInterval) {
216       deoptimizeAllCounter = 0;
217       VM_DeoptimizeAll op;
218       VMThread::execute(&amp;op);
219     } else if (DeoptimizeRandom &amp;&amp; (value &amp; 0x1F) == (os::random() &amp; 0x1F)) {
220       VM_DeoptimizeAll op;
221       VMThread::execute(&amp;op);
222     }
223   }
224   deoptimizeAllCounter++;
225 }
226 
227 
<span class="line-removed">228 void InterfaceSupport::stress_derived_pointers() {</span>
<span class="line-removed">229 #ifdef COMPILER2</span>
<span class="line-removed">230   JavaThread *thread = JavaThread::current();</span>
<span class="line-removed">231   if (!is_init_completed()) return;</span>
<span class="line-removed">232   ResourceMark rm(thread);</span>
<span class="line-removed">233   bool found = false;</span>
<span class="line-removed">234   for (StackFrameStream sfs(thread); !sfs.is_done() &amp;&amp; !found; sfs.next()) {</span>
<span class="line-removed">235     CodeBlob* cb = sfs.current()-&gt;cb();</span>
<span class="line-removed">236     if (cb != NULL &amp;&amp; cb-&gt;oop_maps() ) {</span>
<span class="line-removed">237       // Find oopmap for current method</span>
<span class="line-removed">238       const ImmutableOopMap* map = cb-&gt;oop_map_for_return_address(sfs.current()-&gt;pc());</span>
<span class="line-removed">239       assert(map != NULL, &quot;no oopmap found for pc&quot;);</span>
<span class="line-removed">240       found = map-&gt;has_derived_pointer();</span>
<span class="line-removed">241     }</span>
<span class="line-removed">242   }</span>
<span class="line-removed">243   if (found) {</span>
<span class="line-removed">244     // $$$ Not sure what to do here.</span>
<span class="line-removed">245     /*</span>
<span class="line-removed">246     Scavenge::invoke(0);</span>
<span class="line-removed">247     */</span>
<span class="line-removed">248   }</span>
<span class="line-removed">249 #endif</span>
<span class="line-removed">250 }</span>
<span class="line-removed">251 </span>
<span class="line-removed">252 </span>
253 void InterfaceSupport::verify_stack() {
254   JavaThread* thread = JavaThread::current();
255   ResourceMark rm(thread);
256   // disabled because it throws warnings that oop maps should only be accessed
257   // in VM thread or during debugging
258 
259   if (!thread-&gt;has_pending_exception()) {
260     // verification does not work if there are pending exceptions
261     StackFrameStream sfs(thread);
262     CodeBlob* cb = sfs.current()-&gt;cb();
263       // In case of exceptions we might not have a runtime_stub on
264       // top of stack, hence, all callee-saved registers are not going
265       // to be setup correctly, hence, we cannot do stack verify
266     if (cb != NULL &amp;&amp; !(cb-&gt;is_runtime_stub() || cb-&gt;is_uncommon_trap_stub())) return;
267 
268     for (; !sfs.is_done(); sfs.next()) {
269       sfs.current()-&gt;verify(sfs.register_map());
270     }
271   }
272 }
</pre>
<hr />
<pre>
274 
275 void InterfaceSupport::verify_last_frame() {
276   JavaThread* thread = JavaThread::current();
277   ResourceMark rm(thread);
278   RegisterMap reg_map(thread);
279   frame fr = thread-&gt;last_frame();
280   fr.verify(&amp;reg_map);
281 }
282 
283 
284 #endif // ASSERT
285 
286 
287 void InterfaceSupport_init() {
288 #ifdef ASSERT
289   if (ScavengeALot || FullGCALot) {
290     srand(ScavengeALotInterval * FullGCALotInterval);
291   }
292 #endif
293 }
<span class="line-removed">294 </span>
<span class="line-removed">295 #ifdef ASSERT</span>
<span class="line-removed">296 // JRT_LEAF rules:</span>
<span class="line-removed">297 // A JRT_LEAF method may not interfere with safepointing by</span>
<span class="line-removed">298 //   1) acquiring or blocking on a Mutex or JavaLock - checked</span>
<span class="line-removed">299 //   2) allocating heap memory - checked</span>
<span class="line-removed">300 //   3) executing a VM operation - checked</span>
<span class="line-removed">301 //   4) executing a system call (including malloc) that could block or grab a lock</span>
<span class="line-removed">302 //   5) invoking GC</span>
<span class="line-removed">303 //   6) reaching a safepoint</span>
<span class="line-removed">304 //   7) running too long</span>
<span class="line-removed">305 // Nor may any method it calls.</span>
<span class="line-removed">306 JRTLeafVerifier::JRTLeafVerifier()</span>
<span class="line-removed">307   : NoSafepointVerifier(true, JRTLeafVerifier::should_verify_GC())</span>
<span class="line-removed">308 {</span>
<span class="line-removed">309 }</span>
<span class="line-removed">310 </span>
<span class="line-removed">311 JRTLeafVerifier::~JRTLeafVerifier()</span>
<span class="line-removed">312 {</span>
<span class="line-removed">313 }</span>
<span class="line-removed">314 </span>
<span class="line-removed">315 bool JRTLeafVerifier::should_verify_GC() {</span>
<span class="line-removed">316   switch (JavaThread::current()-&gt;thread_state()) {</span>
<span class="line-removed">317   case _thread_in_Java:</span>
<span class="line-removed">318     // is in a leaf routine, there must be no safepoint.</span>
<span class="line-removed">319     return true;</span>
<span class="line-removed">320   case _thread_in_native:</span>
<span class="line-removed">321     // A native thread is not subject to safepoints.</span>
<span class="line-removed">322     // Even while it is in a leaf routine, GC is ok</span>
<span class="line-removed">323     return false;</span>
<span class="line-removed">324   default:</span>
<span class="line-removed">325     // Leaf routines cannot be called from other contexts.</span>
<span class="line-removed">326     ShouldNotReachHere();</span>
<span class="line-removed">327     return false;</span>
<span class="line-removed">328   }</span>
<span class="line-removed">329 }</span>
<span class="line-removed">330 #endif // ASSERT</span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 30 #include &quot;memory/universe.hpp&quot;</span>
 31 #include &quot;runtime/atomic.hpp&quot;
 32 #include &quot;runtime/frame.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/init.hpp&quot;
 35 #include &quot;runtime/interfaceSupport.inline.hpp&quot;

 36 #include &quot;runtime/os.inline.hpp&quot;
 37 #include &quot;runtime/thread.inline.hpp&quot;
 38 #include &quot;runtime/safepointVerifiers.hpp&quot;
 39 #include &quot;runtime/vframe.hpp&quot;
 40 #include &quot;runtime/vmThread.hpp&quot;
 41 #include &quot;utilities/preserveException.hpp&quot;
 42 
 43 // Implementation of InterfaceSupport
 44 
 45 #ifdef ASSERT
 46 VMEntryWrapper::VMEntryWrapper() {
 47   if (VerifyLastFrame) {
 48     InterfaceSupport::verify_last_frame();
 49   }
 50 }
 51 
 52 VMEntryWrapper::~VMEntryWrapper() {
 53   InterfaceSupport::check_gc_alot();
 54   if (WalkStackALot) {
 55     InterfaceSupport::walk_stack();
 56   }






 57   if (DeoptimizeALot || DeoptimizeRandom) {
 58     InterfaceSupport::deoptimizeAll();
 59   }
 60   if (ZombieALot) {
 61     InterfaceSupport::zombieAll();
 62   }
 63   // do verification AFTER potential deoptimization
 64   if (VerifyStack) {
 65     InterfaceSupport::verify_stack();
 66   }
 67 }
 68 
<span class="line-added"> 69 VMNativeEntryWrapper::VMNativeEntryWrapper() {</span>
<span class="line-added"> 70   if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();</span>
<span class="line-added"> 71 }</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73 VMNativeEntryWrapper::~VMNativeEntryWrapper() {</span>
<span class="line-added"> 74   if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();</span>
<span class="line-added"> 75 }</span>
<span class="line-added"> 76 </span>
 77 long InterfaceSupport::_number_of_calls       = 0;
 78 long InterfaceSupport::_scavenge_alot_counter = 1;
 79 long InterfaceSupport::_fullgc_alot_counter   = 1;
 80 long InterfaceSupport::_fullgc_alot_invocation = 0;
 81 
 82 Histogram* RuntimeHistogram;
 83 
 84 RuntimeHistogramElement::RuntimeHistogramElement(const char* elementName) {
 85   static volatile int RuntimeHistogram_lock = 0;
 86   _name = elementName;
 87   uintx count = 0;
 88 
<span class="line-modified"> 89   while (Atomic::cmpxchg(&amp;RuntimeHistogram_lock, 0, 1) != 0) {</span>
<span class="line-modified"> 90     while (Atomic::load_acquire(&amp;RuntimeHistogram_lock) != 0) {</span>
 91       count +=1;
 92       if ( (WarnOnStalledSpinLock &gt; 0)
 93         &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 94         warning(&quot;RuntimeHistogram_lock seems to be stalled&quot;);
 95       }
 96     }
 97   }
 98 
 99   if (RuntimeHistogram == NULL) {
100     RuntimeHistogram = new Histogram(&quot;VM Runtime Call Counts&quot;,200);
101   }
102 
103   RuntimeHistogram-&gt;add_element(this);
104   Atomic::dec(&amp;RuntimeHistogram_lock);
105 }
106 
107 void InterfaceSupport::gc_alot() {
108   Thread *thread = Thread::current();
109   if (!thread-&gt;is_Java_thread()) return; // Avoid concurrent calls
110   // Check for new, not quite initialized thread. A thread in new mode cannot initiate a GC.
</pre>
<hr />
<pre>
210 void InterfaceSupport::deoptimizeAll() {
211   // This method is called by all threads when a thread make
212   // transition to VM state (for example, runtime calls).
213   // Divide number of calls by number of threads to avoid
214   // dependence of DeoptimizeAll events frequency on number of threads.
215   int value = deoptimizeAllCounter / Threads::number_of_threads();
216   if (is_init_completed()) {
217     if (DeoptimizeALot &amp;&amp; value &gt; DeoptimizeALotInterval) {
218       deoptimizeAllCounter = 0;
219       VM_DeoptimizeAll op;
220       VMThread::execute(&amp;op);
221     } else if (DeoptimizeRandom &amp;&amp; (value &amp; 0x1F) == (os::random() &amp; 0x1F)) {
222       VM_DeoptimizeAll op;
223       VMThread::execute(&amp;op);
224     }
225   }
226   deoptimizeAllCounter++;
227 }
228 
229 

























230 void InterfaceSupport::verify_stack() {
231   JavaThread* thread = JavaThread::current();
232   ResourceMark rm(thread);
233   // disabled because it throws warnings that oop maps should only be accessed
234   // in VM thread or during debugging
235 
236   if (!thread-&gt;has_pending_exception()) {
237     // verification does not work if there are pending exceptions
238     StackFrameStream sfs(thread);
239     CodeBlob* cb = sfs.current()-&gt;cb();
240       // In case of exceptions we might not have a runtime_stub on
241       // top of stack, hence, all callee-saved registers are not going
242       // to be setup correctly, hence, we cannot do stack verify
243     if (cb != NULL &amp;&amp; !(cb-&gt;is_runtime_stub() || cb-&gt;is_uncommon_trap_stub())) return;
244 
245     for (; !sfs.is_done(); sfs.next()) {
246       sfs.current()-&gt;verify(sfs.register_map());
247     }
248   }
249 }
</pre>
<hr />
<pre>
251 
252 void InterfaceSupport::verify_last_frame() {
253   JavaThread* thread = JavaThread::current();
254   ResourceMark rm(thread);
255   RegisterMap reg_map(thread);
256   frame fr = thread-&gt;last_frame();
257   fr.verify(&amp;reg_map);
258 }
259 
260 
261 #endif // ASSERT
262 
263 
264 void InterfaceSupport_init() {
265 #ifdef ASSERT
266   if (ScavengeALot || FullGCALot) {
267     srand(ScavengeALotInterval * FullGCALotInterval);
268   }
269 #endif
270 }





































</pre>
</td>
</tr>
</table>
<center><a href="init.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interfaceSupport.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
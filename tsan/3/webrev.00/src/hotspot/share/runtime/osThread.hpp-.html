<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/osThread.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_OSTHREAD_HPP
 26 #define SHARE_RUNTIME_OSTHREAD_HPP
 27 
 28 #include &quot;runtime/frame.hpp&quot;
 29 #include &quot;runtime/handles.hpp&quot;
 30 #include &quot;runtime/javaFrameAnchor.hpp&quot;
 31 #include &quot;runtime/objectMonitor.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 
 34 // The OSThread class holds OS-specific thread information.  It is equivalent
 35 // to the sys_thread_t structure of the classic JVM implementation.
 36 
 37 // The thread states represented by the ThreadState values are platform-specific
 38 // and are likely to be only approximate, because most OSes don&#39;t give you access
 39 // to precise thread state information.
 40 
 41 // Note: the ThreadState is legacy code and is not correctly implemented.
 42 // Uses of ThreadState need to be replaced by the state in the JavaThread.
 43 
 44 enum ThreadState {
 45   ALLOCATED,                    // Memory has been allocated but not initialized
 46   INITIALIZED,                  // The thread has been initialized but yet started
 47   RUNNABLE,                     // Has been started and is runnable, but not necessarily running
 48   MONITOR_WAIT,                 // Waiting on a contended monitor lock
 49   CONDVAR_WAIT,                 // Waiting on a condition variable
 50   OBJECT_WAIT,                  // Waiting on an Object.wait() call
 51   BREAKPOINTED,                 // Suspended at breakpoint
 52   SLEEPING,                     // Thread.sleep()
 53   ZOMBIE                        // All done, but not reclaimed yet
 54 };
 55 
 56 typedef int (*OSThreadStartFunc)(void*);
 57 
 58 class OSThread: public CHeapObj&lt;mtThread&gt; {
 59   friend class VMStructs;
 60   friend class JVMCIVMStructs;
 61  private:
 62   OSThreadStartFunc _start_proc;  // Thread start routine
 63   void* _start_parm;              // Thread start routine parameter
 64   volatile ThreadState _state;    // Thread state *hint*
 65   volatile jint _interrupted;     // Thread.isInterrupted state
 66 
 67   // Note:  _interrupted must be jint, so that Java intrinsics can access it.
 68   // The value stored there must be either 0 or 1.  It must be possible
 69   // for Java to emulate Thread.currentThread().isInterrupted() by performing
 70   // the double indirection Thread::current()-&gt;_osthread-&gt;_interrupted.
 71 
 72   // Methods
 73  public:
 74   void set_state(ThreadState state)                { _state = state; }
 75   ThreadState get_state()                          { return _state; }
 76 
 77   OSThread(OSThreadStartFunc start_proc, void* start_parm);
 78   ~OSThread();
 79 
 80   // Accessors
 81   OSThreadStartFunc start_proc() const              { return _start_proc; }
 82   void set_start_proc(OSThreadStartFunc start_proc) { _start_proc = start_proc; }
 83   void* start_parm() const                          { return _start_parm; }
 84   void set_start_parm(void* start_parm)             { _start_parm = start_parm; }
 85 
 86   volatile bool interrupted() const                 { return _interrupted != 0; }
 87   void set_interrupted(bool z)                      { _interrupted = z ? 1 : 0; }
 88 
 89   // Printing
 90   void print_on(outputStream* st) const;
 91   void print() const                                { print_on(tty); }
 92 
 93   // For java intrinsics:
 94   static ByteSize interrupted_offset()            { return byte_offset_of(OSThread, _interrupted); }
 95 
 96   // Platform dependent stuff
 97 #include OS_HEADER(osThread)
 98 
 99  public:
100   static ByteSize thread_id_offset()              { return byte_offset_of(OSThread, _thread_id); }
101   static size_t thread_id_size()                  { return sizeof(thread_id_t); }
102 
103   thread_id_t thread_id() const                   { return _thread_id; }
104 
105   void set_thread_id(thread_id_t id)              { _thread_id = id; }
106 
107  private:
108   // _thread_id is kernel thread id (similar to LWP id on Solaris). Each
109   // thread has a unique thread_id (BsdThreads or NPTL). It can be used
110   // to access /proc.
111   thread_id_t _thread_id;
112 };
113 
114 
115 // Utility class for use with condition variables:
116 class OSThreadWaitState : public StackObj {
117   OSThread*   _osthread;
118   ThreadState _old_state;
119  public:
120   OSThreadWaitState(OSThread* osthread, bool is_object_wait) {
121     _osthread  = osthread;
122     _old_state = osthread-&gt;get_state();
123     if (is_object_wait) {
124       osthread-&gt;set_state(OBJECT_WAIT);
125     } else {
126       osthread-&gt;set_state(CONDVAR_WAIT);
127     }
128   }
129   ~OSThreadWaitState() {
130     _osthread-&gt;set_state(_old_state);
131   }
132 };
133 
134 
135 // Utility class for use with contended monitors:
136 class OSThreadContendState : public StackObj {
137   OSThread*   _osthread;
138   ThreadState _old_state;
139  public:
140   OSThreadContendState(OSThread* osthread) {
141     _osthread  = osthread;
142     _old_state = osthread-&gt;get_state();
143     osthread-&gt;set_state(MONITOR_WAIT);
144   }
145   ~OSThreadContendState() {
146     _osthread-&gt;set_state(_old_state);
147   }
148 };
149 
150 #endif // SHARE_RUNTIME_OSTHREAD_HPP
    </pre>
  </body>
</html>
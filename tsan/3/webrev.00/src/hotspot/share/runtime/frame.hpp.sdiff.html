<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/frame.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="frame.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/frame.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
361   oop* oopmapreg_to_location(VMReg reg, const RegisterMap* reg_map) const;
362 
363   // Oops-do&#39;s
364   void oops_compiled_arguments_do(Symbol* signature, bool has_receiver, bool has_appendix, const RegisterMap* reg_map, OopClosure* f);
365   void oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache = true);
366 
367  private:
368   void oops_interpreted_arguments_do(Symbol* signature, bool has_receiver, OopClosure* f);
369 
370   // Iteration of oops
371   void oops_do_internal(OopClosure* f, CodeBlobClosure* cf, RegisterMap* map, bool use_interpreter_oop_map_cache);
372   void oops_entry_do(OopClosure* f, const RegisterMap* map);
373   void oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* map);
374   int adjust_offset(Method* method, int index); // helper for above fn
375  public:
376   // Memory management
377   void oops_do(OopClosure* f, CodeBlobClosure* cf, RegisterMap* map) { oops_do_internal(f, cf, map, true); }
378   void nmethods_do(CodeBlobClosure* cf);
379 
380   // RedefineClasses support for finding live interpreted methods on the stack
<span class="line-modified">381   void metadata_do(void f(Metadata*));</span>
382 
383   // Verification
384   void verify(const RegisterMap* map);
385   static bool verify_return_pc(address x);
386   // Usage:
387   // assert(frame::verify_return_pc(return_address), &quot;must be a return pc&quot;);
388 
389   NOT_PRODUCT(void pd_ps();)  // platform dependent frame printing
390 
391 #include CPU_HEADER(frame)
392 
393 };
394 
395 #ifndef PRODUCT
396 // A simple class to describe a location on the stack
397 class FrameValue {
398  public:
399   intptr_t* location;
400   char* description;
401   int owner;
</pre>
</td>
<td>
<hr />
<pre>
361   oop* oopmapreg_to_location(VMReg reg, const RegisterMap* reg_map) const;
362 
363   // Oops-do&#39;s
364   void oops_compiled_arguments_do(Symbol* signature, bool has_receiver, bool has_appendix, const RegisterMap* reg_map, OopClosure* f);
365   void oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache = true);
366 
367  private:
368   void oops_interpreted_arguments_do(Symbol* signature, bool has_receiver, OopClosure* f);
369 
370   // Iteration of oops
371   void oops_do_internal(OopClosure* f, CodeBlobClosure* cf, RegisterMap* map, bool use_interpreter_oop_map_cache);
372   void oops_entry_do(OopClosure* f, const RegisterMap* map);
373   void oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* map);
374   int adjust_offset(Method* method, int index); // helper for above fn
375  public:
376   // Memory management
377   void oops_do(OopClosure* f, CodeBlobClosure* cf, RegisterMap* map) { oops_do_internal(f, cf, map, true); }
378   void nmethods_do(CodeBlobClosure* cf);
379 
380   // RedefineClasses support for finding live interpreted methods on the stack
<span class="line-modified">381   void metadata_do(MetadataClosure* f);</span>
382 
383   // Verification
384   void verify(const RegisterMap* map);
385   static bool verify_return_pc(address x);
386   // Usage:
387   // assert(frame::verify_return_pc(return_address), &quot;must be a return pc&quot;);
388 
389   NOT_PRODUCT(void pd_ps();)  // platform dependent frame printing
390 
391 #include CPU_HEADER(frame)
392 
393 };
394 
395 #ifndef PRODUCT
396 // A simple class to describe a location on the stack
397 class FrameValue {
398  public:
399   intptr_t* location;
400   char* description;
401   int owner;
</pre>
</td>
</tr>
</table>
<center><a href="frame.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
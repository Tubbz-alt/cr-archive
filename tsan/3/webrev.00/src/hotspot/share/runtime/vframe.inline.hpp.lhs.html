<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/vframe.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_VFRAME_INLINE_HPP
 26 #define SHARE_RUNTIME_VFRAME_INLINE_HPP
 27 
 28 #include &quot;runtime/frame.inline.hpp&quot;
<a name="1" id="anc1"></a>
 29 #include &quot;runtime/vframe.hpp&quot;
 30 
 31 inline vframeStreamCommon::vframeStreamCommon(JavaThread* thread) : _reg_map(thread, false) {
 32   _thread = thread;
 33 }
 34 
 35 inline intptr_t* vframeStreamCommon::frame_id() const        { return _frame.id(); }
 36 
 37 inline bool vframeStreamCommon::is_interpreted_frame() const { return _frame.is_interpreted_frame(); }
 38 
 39 inline bool vframeStreamCommon::is_entry_frame() const       { return _frame.is_entry_frame(); }
 40 
 41 inline void vframeStreamCommon::next() {
 42   // handle frames with inlining
 43   if (_mode == compiled_mode    &amp;&amp; fill_in_compiled_inlined_sender()) return;
 44 
 45   // handle general case
 46   do {
 47     _prev_frame = _frame;
 48     _frame = _frame.sender(&amp;_reg_map);
 49   } while (!fill_from_frame());
 50 }
 51 
 52 inline vframeStream::vframeStream(JavaThread* thread, bool stop_at_java_call_stub)
 53   : vframeStreamCommon(thread) {
 54   _stop_at_java_call_stub = stop_at_java_call_stub;
 55 
 56   if (!thread-&gt;has_last_Java_frame()) {
 57     _mode = at_end_mode;
 58     return;
 59   }
 60 
 61   _frame = _thread-&gt;last_frame();
 62   while (!fill_from_frame()) {
 63     _prev_frame = _frame;
 64     _frame = _frame.sender(&amp;_reg_map);
 65   }
 66 }
 67 
 68 inline bool vframeStreamCommon::fill_in_compiled_inlined_sender() {
 69   if (_sender_decode_offset == DebugInformationRecorder::serialized_null) {
 70     return false;
 71   }
 72   fill_from_compiled_frame(_sender_decode_offset);
 73   ++_vframe_id;
 74   return true;
 75 }
 76 
 77 
 78 inline void vframeStreamCommon::fill_from_compiled_frame(int decode_offset) {
 79   _mode = compiled_mode;
 80   _decode_offset = decode_offset;
 81 
 82   // Range check to detect ridiculous offsets.
 83   if (decode_offset == DebugInformationRecorder::serialized_null ||
 84       decode_offset &lt; 0 ||
 85       decode_offset &gt;= nm()-&gt;scopes_data_size()) {
 86     // 6379830 AsyncGetCallTrace sometimes feeds us wild frames.
 87     // If we read nmethod::scopes_data at serialized_null (== 0)
 88     // or if read some at other invalid offset, invalid values will be decoded.
 89     // Based on these values, invalid heap locations could be referenced
 90     // that could lead to crashes in product mode.
 91     // Therefore, do not use the decode offset if invalid, but fill the frame
 92     // as it were a native compiled frame (no Java-level assumptions).
 93 #ifdef ASSERT
 94     if (WizardMode) {
 95       ttyLocker ttyl;
 96       tty-&gt;print_cr(&quot;Error in fill_from_frame: pc_desc for &quot;
 97                     INTPTR_FORMAT &quot; not found or invalid at %d&quot;,
 98                     p2i(_frame.pc()), decode_offset);
 99       nm()-&gt;print();
100       nm()-&gt;method()-&gt;print_codes();
101       nm()-&gt;print_code();
102       nm()-&gt;print_pcs();
103     }
104     found_bad_method_frame();
105 #endif
106     // Provide a cheap fallback in product mode.  (See comment above.)
107     fill_from_compiled_native_frame();
108     return;
109   }
110 
111   // Decode first part of scopeDesc
112   DebugInfoReadStream buffer(nm(), decode_offset);
113   _sender_decode_offset = buffer.read_int();
114   _method               = buffer.read_method();
115   _bci                  = buffer.read_bci();
116 
117   assert(_method-&gt;is_method(), &quot;checking type of decoded method&quot;);
118 }
119 
120 // The native frames are handled specially. We do not rely on ScopeDesc info
121 // since the pc might not be exact due to the _last_native_pc trick.
122 inline void vframeStreamCommon::fill_from_compiled_native_frame() {
123   _mode = compiled_mode;
124   _sender_decode_offset = DebugInformationRecorder::serialized_null;
125   _decode_offset = DebugInformationRecorder::serialized_null;
126   _vframe_id = 0;
127   _method = nm()-&gt;method();
128   _bci = 0;
129 }
130 
131 inline bool vframeStreamCommon::fill_from_frame() {
132   // Interpreted frame
133   if (_frame.is_interpreted_frame()) {
134     fill_from_interpreter_frame();
135     return true;
136   }
137 
138   // Compiled frame
139 
140   if (cb() != NULL &amp;&amp; cb()-&gt;is_compiled()) {
141     if (nm()-&gt;is_native_method()) {
142       // Do not rely on scopeDesc since the pc might be unprecise due to the _last_native_pc trick.
143       fill_from_compiled_native_frame();
144     } else {
145       PcDesc* pc_desc = nm()-&gt;pc_desc_at(_frame.pc());
146       int decode_offset;
147       if (pc_desc == NULL) {
148         // Should not happen, but let fill_from_compiled_frame handle it.
149 
150         // If we are trying to walk the stack of a thread that is not
151         // at a safepoint (like AsyncGetCallTrace would do) then this is an
152         // acceptable result. [ This is assuming that safe_for_sender
153         // is so bullet proof that we can trust the frames it produced. ]
154         //
155         // So if we see that the thread is not safepoint safe
156         // then simply produce the method and a bci of zero
157         // and skip the possibility of decoding any inlining that
158         // may be present. That is far better than simply stopping (or
159         // asserting. If however the thread is safepoint safe this
160         // is the sign of a compiler bug  and we&#39;ll let
161         // fill_from_compiled_frame handle it.
162 
163 
164         JavaThreadState state = _thread-&gt;thread_state();
165 
166         // in_Java should be good enough to test safepoint safety
167         // if state were say in_Java_trans then we&#39;d expect that
168         // the pc would have already been slightly adjusted to
169         // one that would produce a pcDesc since the trans state
170         // would be one that might in fact anticipate a safepoint
171 
172         if (state == _thread_in_Java ) {
173           // This will get a method a zero bci and no inlining.
174           // Might be nice to have a unique bci to signify this
175           // particular case but for now zero will do.
176 
177           fill_from_compiled_native_frame();
178 
179           // There is something to be said for setting the mode to
180           // at_end_mode to prevent trying to walk further up the
181           // stack. There is evidence that if we walk any further
182           // that we could produce a bad stack chain. However until
183           // we see evidence that allowing this causes us to find
184           // frames bad enough to cause segv&#39;s or assertion failures
185           // we don&#39;t do it as while we may get a bad call chain the
186           // probability is much higher (several magnitudes) that we
187           // get good data.
188 
189           return true;
190         }
191         decode_offset = DebugInformationRecorder::serialized_null;
192       } else {
193         decode_offset = pc_desc-&gt;scope_decode_offset();
194       }
195       fill_from_compiled_frame(decode_offset);
196       _vframe_id = 0;
197     }
198     return true;
199   }
200 
201   // End of stack?
202   if (_frame.is_first_frame() || (_stop_at_java_call_stub &amp;&amp; _frame.is_entry_frame())) {
203     _mode = at_end_mode;
204     return true;
205   }
206 
207   return false;
208 }
209 
210 
211 inline void vframeStreamCommon::fill_from_interpreter_frame() {
212   Method* method = _frame.interpreter_frame_method();
213   address   bcp    = _frame.interpreter_frame_bcp();
214   int       bci    = method-&gt;validate_bci_from_bcp(bcp);
215   // 6379830 AsyncGetCallTrace sometimes feeds us wild frames.
216   // AsyncGetCallTrace interrupts the VM asynchronously. As a result
217   // it is possible to access an interpreter frame for which
218   // no Java-level information is yet available (e.g., becasue
219   // the frame was being created when the VM interrupted it).
220   // In this scenario, pretend that the interpreter is at the point
221   // of entering the method.
222   if (bci &lt; 0) {
223     DEBUG_ONLY(found_bad_method_frame();)
224     bci = 0;
225   }
226   _mode   = interpreted_mode;
227   _method = method;
228   _bci    = bci;
229 }
230 
231 #endif // SHARE_RUNTIME_VFRAME_INLINE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
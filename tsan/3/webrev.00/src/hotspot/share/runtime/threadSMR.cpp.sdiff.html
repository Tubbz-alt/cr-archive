<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/threadSMR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="threadHeapSampler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadSMR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/threadSMR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;logging/logStream.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;

  28 #include &quot;runtime/jniHandles.inline.hpp&quot;


  29 #include &quot;runtime/thread.inline.hpp&quot;
  30 #include &quot;runtime/threadSMR.inline.hpp&quot;
  31 #include &quot;runtime/vmOperations.hpp&quot;

  32 #include &quot;services/threadService.hpp&quot;
  33 #include &quot;utilities/copy.hpp&quot;
  34 #include &quot;utilities/globalDefinitions.hpp&quot;
  35 #include &quot;utilities/ostream.hpp&quot;

  36 #include &quot;utilities/resourceHash.hpp&quot;
  37 #include &quot;utilities/vmError.hpp&quot;
  38 
  39 // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
  40 // -XX:+EnableThreadSMRStatistics:
  41 
  42 // # of parallel threads in _delete_lock-&gt;wait().
  43 // Impl note: Hard to imagine &gt; 64K waiting threads so this could be 16-bit,
  44 // but there is no nice 16-bit _FORMAT support.
  45 uint                  ThreadsSMRSupport::_delete_lock_wait_cnt = 0;
  46 
  47 // Max # of parallel threads in _delete_lock-&gt;wait().
  48 // Impl note: See _delete_lock_wait_cnt note.
  49 uint                  ThreadsSMRSupport::_delete_lock_wait_max = 0;
  50 
  51 // Flag to indicate when an _delete_lock-&gt;notify() is needed.
  52 // Impl note: See _delete_lock_wait_cnt note.
  53 volatile uint         ThreadsSMRSupport::_delete_notify = 0;
  54 
  55 // # of threads deleted over VM lifetime.
</pre>
<hr />
<pre>
 112 // loop for correctness.
 113 volatile uint         ThreadsSMRSupport::_tlh_time_max = 0;
 114 
 115 // Cumulative time in millis to delete ThreadsListHandles.
 116 // Impl note: Atomically added to over VM lifetime so use unsigned for more
 117 // range. Unsigned 64-bit would be more future proof, but 64-bit atomic inc
 118 // isn&#39;t available everywhere (or is it?).
 119 volatile uint         ThreadsSMRSupport::_tlh_times = 0;
 120 
 121 ThreadsList*          ThreadsSMRSupport::_to_delete_list = NULL;
 122 
 123 // # of parallel ThreadsLists on the to-delete list.
 124 // Impl note: Hard to imagine &gt; 64K ThreadsLists needing to be deleted so
 125 // this could be 16-bit, but there is no nice 16-bit _FORMAT support.
 126 uint                  ThreadsSMRSupport::_to_delete_list_cnt = 0;
 127 
 128 // Max # of parallel ThreadsLists on the to-delete list.
 129 // Impl note: See _to_delete_list_cnt note.
 130 uint                  ThreadsSMRSupport::_to_delete_list_max = 0;
 131 
<span class="line-removed"> 132 </span>
 133 // &#39;inline&#39; functions first so the definitions are before first use:
 134 
 135 inline void ThreadsSMRSupport::add_deleted_thread_times(uint add_value) {
<span class="line-modified"> 136   Atomic::add(add_value, &amp;_deleted_thread_times);</span>
 137 }
 138 
 139 inline void ThreadsSMRSupport::inc_deleted_thread_cnt() {
 140   Atomic::inc(&amp;_deleted_thread_cnt);
 141 }
 142 
 143 inline void ThreadsSMRSupport::inc_java_thread_list_alloc_cnt() {
 144   _java_thread_list_alloc_cnt++;
 145 }
 146 
 147 inline bool ThreadsSMRSupport::is_bootstrap_list(ThreadsList* list) {
 148   return list == &amp;_bootstrap_list;
 149 }
 150 
 151 inline void ThreadsSMRSupport::update_deleted_thread_time_max(uint new_value) {
 152   while (true) {
 153     uint cur_value = _deleted_thread_time_max;
 154     if (new_value &lt;= cur_value) {
 155       // No need to update max value so we&#39;re done.
 156       break;
 157     }
<span class="line-modified"> 158     if (Atomic::cmpxchg(new_value, &amp;_deleted_thread_time_max, cur_value) == cur_value) {</span>
 159       // Updated max value so we&#39;re done. Otherwise try it all again.
 160       break;
 161     }
 162   }
 163 }
 164 
 165 inline void ThreadsSMRSupport::update_java_thread_list_max(uint new_value) {
 166   if (new_value &gt; _java_thread_list_max) {
 167     _java_thread_list_max = new_value;
 168   }
 169 }
 170 
 171 inline ThreadsList* ThreadsSMRSupport::xchg_java_thread_list(ThreadsList* new_list) {
<span class="line-modified"> 172   return (ThreadsList*)Atomic::xchg(new_list, &amp;_java_thread_list);</span>
 173 }
 174 
 175 // Hash table of pointers found by a scan. Used for collecting hazard
 176 // pointers (ThreadsList references). Also used for collecting JavaThreads
 177 // that are indirectly referenced by hazard ptrs. An instance of this
 178 // class only contains one type of pointer.
 179 //
 180 class ThreadScanHashtable : public CHeapObj&lt;mtThread&gt; {
 181  private:
 182   static bool ptr_equals(void * const&amp; s1, void * const&amp; s2) {
 183     return s1 == s2;
 184   }
 185 
 186   static unsigned int ptr_hash(void * const&amp; s1) {
 187     // 2654435761 = 2^32 * Phi (golden ratio)
 188     return (unsigned int)(((uint32_t)(uintptr_t)s1) * 2654435761u);
 189   }
 190 
 191   int _table_size;
 192   // ResourceHashtable SIZE is specified at compile time so our
</pre>
<hr />
<pre>
 510   // wide Thread-SMR delete_lock.
 511   if (ThreadsSMRSupport::delete_notify()) {
 512     // An exiting thread might be waiting in smr_delete(); we need to
 513     // check with delete_lock to be sure.
 514     ThreadsSMRSupport::release_stable_list_wake_up(_has_ref_count);
 515   }
 516 }
 517 
 518 // Verify that the stable hazard ptr used to safely keep threads
 519 // alive is scanned by threads_do() which is a key piece of honoring
 520 // the Thread-SMR protocol.
 521 void SafeThreadsListPtr::verify_hazard_ptr_scanned() {
 522 #ifdef ASSERT
 523   assert(_list != NULL, &quot;_list must not be NULL&quot;);
 524 
 525   if (ThreadsSMRSupport::is_bootstrap_list(_list)) {
 526     // We are early in VM bootstrapping so nothing to do here.
 527     return;
 528   }
 529 
















 530   // The closure will attempt to verify that the calling thread can
 531   // be found by threads_do() on the specified ThreadsList. If it
 532   // is successful, then the specified ThreadsList was acquired as
 533   // a stable hazard ptr by the calling thread in a way that honored
 534   // the Thread-SMR protocol.
 535   //
 536   // If the calling thread cannot be found by threads_do() and if
 537   // it is not the shutdown thread, then the calling thread is not
 538   // honoring the Thread-SMR ptotocol. This means that the specified
 539   // ThreadsList is not a stable hazard ptr and can be freed by
 540   // another thread from the to-be-deleted list at any time.
 541   //
<span class="line-removed"> 542   // Note: The shutdown thread has removed itself from the Threads</span>
<span class="line-removed"> 543   // list and is safe to have a waiver from this check because</span>
<span class="line-removed"> 544   // VM_Exit::_shutdown_thread is not set until after the VMThread</span>
<span class="line-removed"> 545   // has started the final safepoint which holds the Threads_lock</span>
<span class="line-removed"> 546   // for the remainder of the VM&#39;s life.</span>
<span class="line-removed"> 547   //</span>
 548   VerifyHazardPtrThreadClosure cl(_thread);
 549   ThreadsSMRSupport::threads_do(&amp;cl, _list);
 550 
 551   // If the calling thread is not honoring the Thread-SMR protocol,
 552   // then we will either crash in threads_do() above because &#39;threads&#39;
 553   // was freed by another thread or we will fail the assert() below.
 554   // In either case, we won&#39;t get past this point with a badly placed
 555   // ThreadsListHandle.
 556 
<span class="line-modified"> 557   assert(cl.found() || _thread == VM_Exit::shutdown_thread(), &quot;Acquired a ThreadsList snapshot from a thread not recognized by the Thread-SMR protocol.&quot;);</span>
 558 #endif
 559 }
 560 
 561 // &#39;entries + 1&#39; so we always have at least one entry.
 562 ThreadsList::ThreadsList(int entries) :
 563   _length(entries),
 564   _next_list(NULL),
 565   _threads(NEW_C_HEAP_ARRAY(JavaThread*, entries + 1, mtThread)),
 566   _nested_handle_cnt(0)
 567 {
 568   *(JavaThread**)(_threads + entries) = NULL;  // Make sure the extra entry is NULL.
 569 }
 570 
 571 ThreadsList::~ThreadsList() {
 572   FREE_C_HEAP_ARRAY(JavaThread*, _threads);
 573 }
 574 
 575 // Add a JavaThread to a ThreadsList. The returned ThreadsList is a
 576 // new copy of the specified ThreadsList with the specified JavaThread
 577 // appended to the end.
 578 ThreadsList *ThreadsList::add_thread(ThreadsList *list, JavaThread *java_thread) {
 579   const uint index = list-&gt;_length;
 580   const uint new_length = index + 1;
 581   const uint head_length = index;
 582   ThreadsList *const new_list = new ThreadsList(new_length);
 583 
 584   if (head_length &gt; 0) {
 585     Copy::disjoint_words((HeapWord*)list-&gt;_threads, (HeapWord*)new_list-&gt;_threads, head_length);
 586   }
 587   *(JavaThread**)(new_list-&gt;_threads + index) = java_thread;
 588 
 589   return new_list;
 590 }
 591 
 592 void ThreadsList::dec_nested_handle_cnt() {
<span class="line-modified"> 593   // The decrement needs to be MO_ACQ_REL. At the moment, the Atomic::dec</span>
<span class="line-removed"> 594   // backend on PPC does not yet conform to these requirements. Therefore</span>
<span class="line-removed"> 595   // the decrement is simulated with an Atomic::sub(1, &amp;addr).</span>
<span class="line-removed"> 596   // Without this MO_ACQ_REL Atomic::dec simulation, the nested SMR mechanism</span>
<span class="line-removed"> 597   // is not generally safe to use.</span>
<span class="line-removed"> 598   Atomic::sub(1, &amp;_nested_handle_cnt);</span>
 599 }
 600 
 601 int ThreadsList::find_index_of_JavaThread(JavaThread *target) {
 602   if (target == NULL) {
 603     return -1;
 604   }
 605   for (uint i = 0; i &lt; length(); i++) {
 606     if (target == thread_at(i)) {
 607       return (int)i;
 608     }
 609   }
 610   return -1;
 611 }
 612 
 613 JavaThread* ThreadsList::find_JavaThread_from_java_tid(jlong java_tid) const {
<span class="line-modified"> 614   for (uint i = 0; i &lt; length(); i++) {</span>
<span class="line-modified"> 615     JavaThread* thread = thread_at(i);</span>
<span class="line-modified"> 616     oop tobj = thread-&gt;threadObj();</span>
<span class="line-modified"> 617     // Ignore the thread if it hasn&#39;t run yet, has exited</span>
<span class="line-modified"> 618     // or is starting to exit.</span>
<span class="line-modified"> 619     if (tobj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp;</span>
<span class="line-modified"> 620         java_tid == java_lang_Thread::thread_id(tobj)) {</span>
<span class="line-modified"> 621       // found a match</span>
<span class="line-modified"> 622       return thread;</span>










 623     }


 624   }
 625   return NULL;
 626 }
 627 
 628 void ThreadsList::inc_nested_handle_cnt() {
<span class="line-modified"> 629   // The increment needs to be MO_SEQ_CST. At the moment, the Atomic::inc</span>
<span class="line-removed"> 630   // backend on PPC does not yet conform to these requirements. Therefore</span>
<span class="line-removed"> 631   // the increment is simulated with a load phi; cas phi + 1; loop.</span>
<span class="line-removed"> 632   // Without this MO_SEQ_CST Atomic::inc simulation, the nested SMR mechanism</span>
<span class="line-removed"> 633   // is not generally safe to use.</span>
<span class="line-removed"> 634   intx sample = OrderAccess::load_acquire(&amp;_nested_handle_cnt);</span>
<span class="line-removed"> 635   for (;;) {</span>
<span class="line-removed"> 636     if (Atomic::cmpxchg(sample + 1, &amp;_nested_handle_cnt, sample) == sample) {</span>
<span class="line-removed"> 637       return;</span>
<span class="line-removed"> 638     } else {</span>
<span class="line-removed"> 639       sample = OrderAccess::load_acquire(&amp;_nested_handle_cnt);</span>
<span class="line-removed"> 640     }</span>
<span class="line-removed"> 641   }</span>
 642 }
 643 
 644 bool ThreadsList::includes(const JavaThread * const p) const {
 645   if (p == NULL) {
 646     return false;
 647   }
 648   for (uint i = 0; i &lt; length(); i++) {
 649     if (thread_at(i) == p) {
 650       return true;
 651     }
 652   }
 653   return false;
 654 }
 655 
 656 // Remove a JavaThread from a ThreadsList. The returned ThreadsList is a
 657 // new copy of the specified ThreadsList with the specified JavaThread
 658 // removed.
 659 ThreadsList *ThreadsList::remove_thread(ThreadsList* list, JavaThread* java_thread) {
 660   assert(list-&gt;_length &gt; 0, &quot;sanity&quot;);
 661 
</pre>
<hr />
<pre>
 738     }
 739   }
 740 
 741   // Return a live JavaThread that is &quot;protected&quot; by the
 742   // ThreadsListHandle in the caller.
 743   *jt_pp = java_thread;
 744   return true;
 745 }
 746 
 747 void ThreadsSMRSupport::add_thread(JavaThread *thread){
 748   ThreadsList *new_list = ThreadsList::add_thread(get_java_thread_list(), thread);
 749   if (EnableThreadSMRStatistics) {
 750     inc_java_thread_list_alloc_cnt();
 751     update_java_thread_list_max(new_list-&gt;length());
 752   }
 753   // Initial _java_thread_list will not generate a &quot;Threads::add&quot; mesg.
 754   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::add: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
 755 
 756   ThreadsList *old_list = xchg_java_thread_list(new_list);
 757   free_list(old_list);




 758 }
 759 
 760 // set_delete_notify() and clear_delete_notify() are called
 761 // under the protection of the delete_lock, but we also use an
 762 // Atomic operation to ensure the memory update is seen earlier than
 763 // when the delete_lock is dropped.
 764 //
 765 void ThreadsSMRSupport::clear_delete_notify() {
 766   Atomic::dec(&amp;_delete_notify);
 767 }
 768 
 769 bool ThreadsSMRSupport::delete_notify() {
 770   // Use load_acquire() in order to see any updates to _delete_notify
 771   // earlier than when delete_lock is grabbed.
<span class="line-modified"> 772   return (OrderAccess::load_acquire(&amp;_delete_notify) != 0);</span>
 773 }
 774 
 775 // Safely free a ThreadsList after a Threads::add() or Threads::remove().
 776 // The specified ThreadsList may not get deleted during this call if it
 777 // is still in-use (referenced by a hazard ptr). Other ThreadsLists
 778 // in the chain may get deleted by this call if they are no longer in-use.
 779 void ThreadsSMRSupport::free_list(ThreadsList* threads) {
 780   assert_locked_or_safepoint(Threads_lock);
 781 
 782   if (is_bootstrap_list(threads)) {
 783     // The bootstrap list cannot be freed and is empty so
 784     // it does not need to be scanned. Nothing to do here.
 785     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::free_list: bootstrap ThreadsList=&quot; INTPTR_FORMAT &quot; is no longer in use.&quot;, os::current_thread_id(), p2i(threads));
 786     return;
 787   }
 788 
 789   threads-&gt;set_next_list(_to_delete_list);
 790   _to_delete_list = threads;
 791   if (EnableThreadSMRStatistics) {
 792     _to_delete_list_cnt++;
 793     if (_to_delete_list_cnt &gt; _to_delete_list_max) {
 794       _to_delete_list_max = _to_delete_list_cnt;
 795     }
 796   }
 797 
 798   // Hash table size should be first power of two higher than twice the length of the ThreadsList
 799   int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
<span class="line-modified"> 800   hash_table_size--;</span>
<span class="line-removed"> 801   hash_table_size |= hash_table_size &gt;&gt; 1;</span>
<span class="line-removed"> 802   hash_table_size |= hash_table_size &gt;&gt; 2;</span>
<span class="line-removed"> 803   hash_table_size |= hash_table_size &gt;&gt; 4;</span>
<span class="line-removed"> 804   hash_table_size |= hash_table_size &gt;&gt; 8;</span>
<span class="line-removed"> 805   hash_table_size |= hash_table_size &gt;&gt; 16;</span>
<span class="line-removed"> 806   hash_table_size++;</span>
 807 
 808   // Gather a hash table of the current hazard ptrs:
 809   ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
 810   ScanHazardPtrGatherThreadsListClosure scan_cl(scan_table);
 811   threads_do(&amp;scan_cl);
 812   OrderAccess::acquire(); // Must order reads of hazard ptr before reads of
 813                           // nested reference counters
 814 
 815   // Walk through the linked list of pending freeable ThreadsLists
 816   // and free the ones that are not referenced from hazard ptrs.
 817   ThreadsList* current = _to_delete_list;
 818   ThreadsList* prev = NULL;
 819   ThreadsList* next = NULL;
 820   bool threads_is_freed = false;
 821   while (current != NULL) {
 822     next = current-&gt;next_list();
 823     if (!scan_table-&gt;has_entry((void*)current) &amp;&amp; current-&gt;_nested_handle_cnt == 0) {
 824       // This ThreadsList is not referenced by a hazard ptr.
 825       if (prev != NULL) {
 826         prev-&gt;set_next_list(next);
</pre>
<hr />
<pre>
 843   }
 844 
 845   if (!threads_is_freed) {
 846     // Only report &quot;is not freed&quot; on the original call to
 847     // free_list() for this ThreadsList.
 848     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::free_list: threads=&quot; INTPTR_FORMAT &quot; is not freed.&quot;, os::current_thread_id(), p2i(threads));
 849   }
 850 
 851   delete scan_table;
 852 }
 853 
 854 // Return true if the specified JavaThread is protected by a hazard
 855 // pointer (ThreadsList reference). Otherwise, returns false.
 856 //
 857 bool ThreadsSMRSupport::is_a_protected_JavaThread(JavaThread *thread) {
 858   assert_locked_or_safepoint(Threads_lock);
 859 
 860   // Hash table size should be first power of two higher than twice
 861   // the length of the Threads list.
 862   int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
<span class="line-modified"> 863   hash_table_size--;</span>
<span class="line-removed"> 864   hash_table_size |= hash_table_size &gt;&gt; 1;</span>
<span class="line-removed"> 865   hash_table_size |= hash_table_size &gt;&gt; 2;</span>
<span class="line-removed"> 866   hash_table_size |= hash_table_size &gt;&gt; 4;</span>
<span class="line-removed"> 867   hash_table_size |= hash_table_size &gt;&gt; 8;</span>
<span class="line-removed"> 868   hash_table_size |= hash_table_size &gt;&gt; 16;</span>
<span class="line-removed"> 869   hash_table_size++;</span>
 870 
 871   // Gather a hash table of the JavaThreads indirectly referenced by
 872   // hazard ptrs.
 873   ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
 874   ScanHazardPtrGatherProtectedThreadsClosure scan_cl(scan_table);
 875   threads_do(&amp;scan_cl);
 876   OrderAccess::acquire(); // Must order reads of hazard ptr before reads of
 877                           // nested reference counters
 878 
 879   // Walk through the linked list of pending freeable ThreadsLists
 880   // and include the ones that are currently in use by a nested
 881   // ThreadsListHandle in the search set.
 882   ThreadsList* current = _to_delete_list;
 883   while (current != NULL) {
 884     if (current-&gt;_nested_handle_cnt != 0) {
 885       // &#39;current&#39; is in use by a nested ThreadsListHandle so the hazard
 886       // ptr is protecting all the JavaThreads on that ThreadsList.
 887       AddThreadHazardPointerThreadClosure add_cl(scan_table);
 888       current-&gt;threads_do(&amp;add_cl);
 889     }
</pre>
<hr />
<pre>
 895     thread_is_protected = true;
 896   }
 897   delete scan_table;
 898   return thread_is_protected;
 899 }
 900 
 901 // Wake up portion of the release stable ThreadsList protocol;
 902 // uses the delete_lock().
 903 //
 904 void ThreadsSMRSupport::release_stable_list_wake_up(bool is_nested) {
 905   const char* log_str = is_nested ? &quot;nested hazard ptr&quot; : &quot;regular hazard ptr&quot;;
 906 
 907   // Note: delete_lock is held in smr_delete() for the entire
 908   // hazard ptr search so that we do not lose this notify() if
 909   // the exiting thread has to wait. That code path also holds
 910   // Threads_lock (which was grabbed before delete_lock) so that
 911   // threads_do() can be called. This means the system can&#39;t start a
 912   // safepoint which means this thread can&#39;t take too long to get to
 913   // a safepoint because of being blocked on delete_lock.
 914   //
<span class="line-modified"> 915   MonitorLockerEx ml(ThreadsSMRSupport::delete_lock(), Monitor::_no_safepoint_check_flag);</span>
 916   if (ThreadsSMRSupport::delete_notify()) {
 917     // Notify any exiting JavaThreads that are waiting in smr_delete()
 918     // that we&#39;ve released a ThreadsList.
 919     ml.notify_all();
 920     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::release_stable_list notified %s&quot;, os::current_thread_id(), log_str);
 921   }
 922 }
 923 
 924 void ThreadsSMRSupport::remove_thread(JavaThread *thread) {




 925   ThreadsList *new_list = ThreadsList::remove_thread(ThreadsSMRSupport::get_java_thread_list(), thread);
 926   if (EnableThreadSMRStatistics) {
 927     ThreadsSMRSupport::inc_java_thread_list_alloc_cnt();
 928     // This list is smaller so no need to check for a &quot;longest&quot; update.
 929   }
 930 
 931   // Final _java_thread_list will not generate a &quot;Threads::remove&quot; mesg.
 932   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::remove: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
 933 
 934   ThreadsList *old_list = ThreadsSMRSupport::xchg_java_thread_list(new_list);
 935   ThreadsSMRSupport::free_list(old_list);
 936 }
 937 
 938 // See note for clear_delete_notify().
 939 //
 940 void ThreadsSMRSupport::set_delete_notify() {
 941   Atomic::inc(&amp;_delete_notify);
 942 }
 943 
 944 // Safely delete a JavaThread when it is no longer in use by a
 945 // ThreadsListHandle.
 946 //
 947 void ThreadsSMRSupport::smr_delete(JavaThread *thread) {
 948   assert(!Threads_lock-&gt;owned_by_self(), &quot;sanity&quot;);
 949 
 950   bool has_logged_once = false;
 951   elapsedTimer timer;
 952   if (EnableThreadSMRStatistics) {
 953     timer.start();
 954   }
 955 
 956   while (true) {
 957     {
<span class="line-modified"> 958       // No safepoint check because this JavaThread is not on the</span>
<span class="line-modified"> 959       // Threads list.</span>
<span class="line-modified"> 960       MutexLockerEx ml(Threads_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified"> 961       // Cannot use a MonitorLockerEx helper here because we have</span>
 962       // to drop the Threads_lock first if we wait.
 963       ThreadsSMRSupport::delete_lock()-&gt;lock_without_safepoint_check();
 964       // Set the delete_notify flag after we grab delete_lock
 965       // and before we scan hazard ptrs because we&#39;re doing
 966       // double-check locking in release_stable_list().
 967       ThreadsSMRSupport::set_delete_notify();
 968 
 969       if (!is_a_protected_JavaThread(thread)) {
 970         // This is the common case.
 971         ThreadsSMRSupport::clear_delete_notify();
 972         ThreadsSMRSupport::delete_lock()-&gt;unlock();
 973         break;
 974       }
 975       if (!has_logged_once) {
 976         has_logged_once = true;
 977         log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: thread=&quot; INTPTR_FORMAT &quot; is not deleted.&quot;, os::current_thread_id(), p2i(thread));
 978         if (log_is_enabled(Debug, os, thread)) {
 979           ScanHazardPtrPrintMatchingThreadsClosure scan_cl(thread);
 980           threads_do(&amp;scan_cl);
 981           ThreadsList* current = _to_delete_list;
 982           while (current != NULL) {
 983             if (current-&gt;_nested_handle_cnt != 0 &amp;&amp; current-&gt;includes(thread)) {
 984               log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: found nested hazard pointer to thread=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(thread));
 985             }
 986             current = current-&gt;next_list();
 987           }
 988         }
 989       }
 990     } // We have to drop the Threads_lock to wait or delete the thread
 991 
 992     if (EnableThreadSMRStatistics) {
 993       _delete_lock_wait_cnt++;
 994       if (_delete_lock_wait_cnt &gt; _delete_lock_wait_max) {
 995         _delete_lock_wait_max = _delete_lock_wait_cnt;
 996       }
 997     }
 998     // Wait for a release_stable_list() call before we check again. No
 999     // safepoint check, no timeout, and not as suspend equivalent flag
1000     // because this JavaThread is not on the Threads list.
<span class="line-modified">1001     ThreadsSMRSupport::delete_lock()-&gt;wait(Mutex::_no_safepoint_check_flag, 0,</span>
<span class="line-removed">1002                                      !Mutex::_as_suspend_equivalent_flag);</span>
1003     if (EnableThreadSMRStatistics) {
1004       _delete_lock_wait_cnt--;
1005     }
1006 
1007     ThreadsSMRSupport::clear_delete_notify();
1008     ThreadsSMRSupport::delete_lock()-&gt;unlock();
1009     // Retry the whole scenario.
1010   }
1011 
1012   delete thread;
1013   if (EnableThreadSMRStatistics) {
1014     timer.stop();
1015     uint millis = (uint)timer.milliseconds();
1016     ThreadsSMRSupport::inc_deleted_thread_cnt();
1017     ThreadsSMRSupport::add_deleted_thread_times(millis);
1018     ThreadsSMRSupport::update_deleted_thread_time_max(millis);
1019   }
1020 
1021   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: thread=&quot; INTPTR_FORMAT &quot; is deleted.&quot;, os::current_thread_id(), p2i(thread));
1022 }
</pre>
<hr />
<pre>
1074       current = current-&gt;previous();
1075     }
1076     while (current != NULL) {
1077       current-&gt;print_on(st);
1078       current = current-&gt;previous();
1079     }
1080   }
1081 }
1082 
1083 // Print Threads class SMR info.
1084 void ThreadsSMRSupport::print_info_on(outputStream* st) {
1085   // Only grab the Threads_lock if we don&#39;t already own it and if we
1086   // are not reporting an error.
1087   // Note: Not grabbing the Threads_lock during error reporting is
1088   // dangerous because the data structures we want to print can be
1089   // freed concurrently. However, grabbing the Threads_lock during
1090   // error reporting can be equally dangerous since this thread might
1091   // block during error reporting or a nested error could leave the
1092   // Threads_lock held. The classic no win scenario.
1093   //
<span class="line-modified">1094   MutexLockerEx ml((Threads_lock-&gt;owned_by_self() || VMError::is_error_reported()) ? NULL : Threads_lock);</span>
1095 
1096   st-&gt;print_cr(&quot;Threads class SMR info:&quot;);
1097   st-&gt;print_cr(&quot;_java_thread_list=&quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1098                &quot;elements={&quot;, p2i(_java_thread_list),
1099                _java_thread_list-&gt;length());
1100   print_info_elements_on(st, _java_thread_list);
1101   st-&gt;print_cr(&quot;}&quot;);
1102   if (_to_delete_list != NULL) {
1103     st-&gt;print_cr(&quot;_to_delete_list=&quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1104                  &quot;elements={&quot;, p2i(_to_delete_list),
1105                  _to_delete_list-&gt;length());
1106     print_info_elements_on(st, _to_delete_list);
1107     st-&gt;print_cr(&quot;}&quot;);
1108     for (ThreadsList *t_list = _to_delete_list-&gt;next_list();
1109          t_list != NULL; t_list = t_list-&gt;next_list()) {
1110       st-&gt;print(&quot;next-&gt; &quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1111                 &quot;elements={&quot;, p2i(t_list), t_list-&gt;length());
1112       print_info_elements_on(st, t_list);
1113       st-&gt;print_cr(&quot;}&quot;);
1114     }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;logging/logStream.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added">  28 #include &quot;runtime/atomic.hpp&quot;</span>
  29 #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-added">  30 #include &quot;runtime/orderAccess.hpp&quot;</span>
<span class="line-added">  31 #include &quot;runtime/sharedRuntime.hpp&quot;</span>
  32 #include &quot;runtime/thread.inline.hpp&quot;
  33 #include &quot;runtime/threadSMR.inline.hpp&quot;
  34 #include &quot;runtime/vmOperations.hpp&quot;
<span class="line-added">  35 #include &quot;services/threadIdTable.hpp&quot;</span>
  36 #include &quot;services/threadService.hpp&quot;
  37 #include &quot;utilities/copy.hpp&quot;
  38 #include &quot;utilities/globalDefinitions.hpp&quot;
  39 #include &quot;utilities/ostream.hpp&quot;
<span class="line-added">  40 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  41 #include &quot;utilities/resourceHash.hpp&quot;
  42 #include &quot;utilities/vmError.hpp&quot;
  43 
  44 // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
  45 // -XX:+EnableThreadSMRStatistics:
  46 
  47 // # of parallel threads in _delete_lock-&gt;wait().
  48 // Impl note: Hard to imagine &gt; 64K waiting threads so this could be 16-bit,
  49 // but there is no nice 16-bit _FORMAT support.
  50 uint                  ThreadsSMRSupport::_delete_lock_wait_cnt = 0;
  51 
  52 // Max # of parallel threads in _delete_lock-&gt;wait().
  53 // Impl note: See _delete_lock_wait_cnt note.
  54 uint                  ThreadsSMRSupport::_delete_lock_wait_max = 0;
  55 
  56 // Flag to indicate when an _delete_lock-&gt;notify() is needed.
  57 // Impl note: See _delete_lock_wait_cnt note.
  58 volatile uint         ThreadsSMRSupport::_delete_notify = 0;
  59 
  60 // # of threads deleted over VM lifetime.
</pre>
<hr />
<pre>
 117 // loop for correctness.
 118 volatile uint         ThreadsSMRSupport::_tlh_time_max = 0;
 119 
 120 // Cumulative time in millis to delete ThreadsListHandles.
 121 // Impl note: Atomically added to over VM lifetime so use unsigned for more
 122 // range. Unsigned 64-bit would be more future proof, but 64-bit atomic inc
 123 // isn&#39;t available everywhere (or is it?).
 124 volatile uint         ThreadsSMRSupport::_tlh_times = 0;
 125 
 126 ThreadsList*          ThreadsSMRSupport::_to_delete_list = NULL;
 127 
 128 // # of parallel ThreadsLists on the to-delete list.
 129 // Impl note: Hard to imagine &gt; 64K ThreadsLists needing to be deleted so
 130 // this could be 16-bit, but there is no nice 16-bit _FORMAT support.
 131 uint                  ThreadsSMRSupport::_to_delete_list_cnt = 0;
 132 
 133 // Max # of parallel ThreadsLists on the to-delete list.
 134 // Impl note: See _to_delete_list_cnt note.
 135 uint                  ThreadsSMRSupport::_to_delete_list_max = 0;
 136 

 137 // &#39;inline&#39; functions first so the definitions are before first use:
 138 
 139 inline void ThreadsSMRSupport::add_deleted_thread_times(uint add_value) {
<span class="line-modified"> 140   Atomic::add(&amp;_deleted_thread_times, add_value);</span>
 141 }
 142 
 143 inline void ThreadsSMRSupport::inc_deleted_thread_cnt() {
 144   Atomic::inc(&amp;_deleted_thread_cnt);
 145 }
 146 
 147 inline void ThreadsSMRSupport::inc_java_thread_list_alloc_cnt() {
 148   _java_thread_list_alloc_cnt++;
 149 }
 150 
 151 inline bool ThreadsSMRSupport::is_bootstrap_list(ThreadsList* list) {
 152   return list == &amp;_bootstrap_list;
 153 }
 154 
 155 inline void ThreadsSMRSupport::update_deleted_thread_time_max(uint new_value) {
 156   while (true) {
 157     uint cur_value = _deleted_thread_time_max;
 158     if (new_value &lt;= cur_value) {
 159       // No need to update max value so we&#39;re done.
 160       break;
 161     }
<span class="line-modified"> 162     if (Atomic::cmpxchg(&amp;_deleted_thread_time_max, cur_value, new_value) == cur_value) {</span>
 163       // Updated max value so we&#39;re done. Otherwise try it all again.
 164       break;
 165     }
 166   }
 167 }
 168 
 169 inline void ThreadsSMRSupport::update_java_thread_list_max(uint new_value) {
 170   if (new_value &gt; _java_thread_list_max) {
 171     _java_thread_list_max = new_value;
 172   }
 173 }
 174 
 175 inline ThreadsList* ThreadsSMRSupport::xchg_java_thread_list(ThreadsList* new_list) {
<span class="line-modified"> 176   return (ThreadsList*)Atomic::xchg(&amp;_java_thread_list, new_list);</span>
 177 }
 178 
 179 // Hash table of pointers found by a scan. Used for collecting hazard
 180 // pointers (ThreadsList references). Also used for collecting JavaThreads
 181 // that are indirectly referenced by hazard ptrs. An instance of this
 182 // class only contains one type of pointer.
 183 //
 184 class ThreadScanHashtable : public CHeapObj&lt;mtThread&gt; {
 185  private:
 186   static bool ptr_equals(void * const&amp; s1, void * const&amp; s2) {
 187     return s1 == s2;
 188   }
 189 
 190   static unsigned int ptr_hash(void * const&amp; s1) {
 191     // 2654435761 = 2^32 * Phi (golden ratio)
 192     return (unsigned int)(((uint32_t)(uintptr_t)s1) * 2654435761u);
 193   }
 194 
 195   int _table_size;
 196   // ResourceHashtable SIZE is specified at compile time so our
</pre>
<hr />
<pre>
 514   // wide Thread-SMR delete_lock.
 515   if (ThreadsSMRSupport::delete_notify()) {
 516     // An exiting thread might be waiting in smr_delete(); we need to
 517     // check with delete_lock to be sure.
 518     ThreadsSMRSupport::release_stable_list_wake_up(_has_ref_count);
 519   }
 520 }
 521 
 522 // Verify that the stable hazard ptr used to safely keep threads
 523 // alive is scanned by threads_do() which is a key piece of honoring
 524 // the Thread-SMR protocol.
 525 void SafeThreadsListPtr::verify_hazard_ptr_scanned() {
 526 #ifdef ASSERT
 527   assert(_list != NULL, &quot;_list must not be NULL&quot;);
 528 
 529   if (ThreadsSMRSupport::is_bootstrap_list(_list)) {
 530     // We are early in VM bootstrapping so nothing to do here.
 531     return;
 532   }
 533 
<span class="line-added"> 534   if ( _thread == VM_Exit::shutdown_thread()) {</span>
<span class="line-added"> 535     // The shutdown thread has removed itself from the Threads</span>
<span class="line-added"> 536     // list and is safe to have a waiver from this check because</span>
<span class="line-added"> 537     // VM_Exit::_shutdown_thread is not set until after the VMThread</span>
<span class="line-added"> 538     // has started the final safepoint which holds the Threads_lock</span>
<span class="line-added"> 539     // for the remainder of the VM&#39;s life.</span>
<span class="line-added"> 540     return;</span>
<span class="line-added"> 541   }</span>
<span class="line-added"> 542 </span>
<span class="line-added"> 543   if (VMError::is_error_reported() &amp;&amp;</span>
<span class="line-added"> 544       VMError::get_first_error_tid() == os::current_thread_id()) {</span>
<span class="line-added"> 545     // If there is an error reported by this thread it may use ThreadsList even</span>
<span class="line-added"> 546     // if it&#39;s unsafe.</span>
<span class="line-added"> 547     return;</span>
<span class="line-added"> 548   }</span>
<span class="line-added"> 549 </span>
 550   // The closure will attempt to verify that the calling thread can
 551   // be found by threads_do() on the specified ThreadsList. If it
 552   // is successful, then the specified ThreadsList was acquired as
 553   // a stable hazard ptr by the calling thread in a way that honored
 554   // the Thread-SMR protocol.
 555   //
 556   // If the calling thread cannot be found by threads_do() and if
 557   // it is not the shutdown thread, then the calling thread is not
 558   // honoring the Thread-SMR ptotocol. This means that the specified
 559   // ThreadsList is not a stable hazard ptr and can be freed by
 560   // another thread from the to-be-deleted list at any time.
 561   //






 562   VerifyHazardPtrThreadClosure cl(_thread);
 563   ThreadsSMRSupport::threads_do(&amp;cl, _list);
 564 
 565   // If the calling thread is not honoring the Thread-SMR protocol,
 566   // then we will either crash in threads_do() above because &#39;threads&#39;
 567   // was freed by another thread or we will fail the assert() below.
 568   // In either case, we won&#39;t get past this point with a badly placed
 569   // ThreadsListHandle.
 570 
<span class="line-modified"> 571   assert(cl.found(), &quot;Acquired a ThreadsList snapshot from a thread not recognized by the Thread-SMR protocol.&quot;);</span>
 572 #endif
 573 }
 574 
 575 // &#39;entries + 1&#39; so we always have at least one entry.
 576 ThreadsList::ThreadsList(int entries) :
 577   _length(entries),
 578   _next_list(NULL),
 579   _threads(NEW_C_HEAP_ARRAY(JavaThread*, entries + 1, mtThread)),
 580   _nested_handle_cnt(0)
 581 {
 582   *(JavaThread**)(_threads + entries) = NULL;  // Make sure the extra entry is NULL.
 583 }
 584 
 585 ThreadsList::~ThreadsList() {
 586   FREE_C_HEAP_ARRAY(JavaThread*, _threads);
 587 }
 588 
 589 // Add a JavaThread to a ThreadsList. The returned ThreadsList is a
 590 // new copy of the specified ThreadsList with the specified JavaThread
 591 // appended to the end.
 592 ThreadsList *ThreadsList::add_thread(ThreadsList *list, JavaThread *java_thread) {
 593   const uint index = list-&gt;_length;
 594   const uint new_length = index + 1;
 595   const uint head_length = index;
 596   ThreadsList *const new_list = new ThreadsList(new_length);
 597 
 598   if (head_length &gt; 0) {
 599     Copy::disjoint_words((HeapWord*)list-&gt;_threads, (HeapWord*)new_list-&gt;_threads, head_length);
 600   }
 601   *(JavaThread**)(new_list-&gt;_threads + index) = java_thread;
 602 
 603   return new_list;
 604 }
 605 
 606 void ThreadsList::dec_nested_handle_cnt() {
<span class="line-modified"> 607   Atomic::dec(&amp;_nested_handle_cnt);</span>





 608 }
 609 
 610 int ThreadsList::find_index_of_JavaThread(JavaThread *target) {
 611   if (target == NULL) {
 612     return -1;
 613   }
 614   for (uint i = 0; i &lt; length(); i++) {
 615     if (target == thread_at(i)) {
 616       return (int)i;
 617     }
 618   }
 619   return -1;
 620 }
 621 
 622 JavaThread* ThreadsList::find_JavaThread_from_java_tid(jlong java_tid) const {
<span class="line-modified"> 623   ThreadIdTable::lazy_initialize(this);</span>
<span class="line-modified"> 624   JavaThread* thread = ThreadIdTable::find_thread_by_tid(java_tid);</span>
<span class="line-modified"> 625   if (thread == NULL) {</span>
<span class="line-modified"> 626     // If the thread is not found in the table find it</span>
<span class="line-modified"> 627     // with a linear search and add to the table.</span>
<span class="line-modified"> 628     for (uint i = 0; i &lt; length(); i++) {</span>
<span class="line-modified"> 629       thread = thread_at(i);</span>
<span class="line-modified"> 630       oop tobj = thread-&gt;threadObj();</span>
<span class="line-modified"> 631       // Ignore the thread if it hasn&#39;t run yet, has exited</span>
<span class="line-added"> 632       // or is starting to exit.</span>
<span class="line-added"> 633       if (tobj != NULL &amp;&amp; java_tid == java_lang_Thread::thread_id(tobj)) {</span>
<span class="line-added"> 634         MutexLocker ml(Threads_lock);</span>
<span class="line-added"> 635         // Must be inside the lock to ensure that we don&#39;t add a thread to the table</span>
<span class="line-added"> 636         // that has just passed the removal point in ThreadsSMRSupport::remove_thread()</span>
<span class="line-added"> 637         if (!thread-&gt;is_exiting()) {</span>
<span class="line-added"> 638           ThreadIdTable::add_thread(java_tid, thread);</span>
<span class="line-added"> 639           return thread;</span>
<span class="line-added"> 640         }</span>
<span class="line-added"> 641       }</span>
 642     }
<span class="line-added"> 643   } else if (!thread-&gt;is_exiting()) {</span>
<span class="line-added"> 644     return thread;</span>
 645   }
 646   return NULL;
 647 }
 648 
 649 void ThreadsList::inc_nested_handle_cnt() {
<span class="line-modified"> 650   Atomic::inc(&amp;_nested_handle_cnt);</span>












 651 }
 652 
 653 bool ThreadsList::includes(const JavaThread * const p) const {
 654   if (p == NULL) {
 655     return false;
 656   }
 657   for (uint i = 0; i &lt; length(); i++) {
 658     if (thread_at(i) == p) {
 659       return true;
 660     }
 661   }
 662   return false;
 663 }
 664 
 665 // Remove a JavaThread from a ThreadsList. The returned ThreadsList is a
 666 // new copy of the specified ThreadsList with the specified JavaThread
 667 // removed.
 668 ThreadsList *ThreadsList::remove_thread(ThreadsList* list, JavaThread* java_thread) {
 669   assert(list-&gt;_length &gt; 0, &quot;sanity&quot;);
 670 
</pre>
<hr />
<pre>
 747     }
 748   }
 749 
 750   // Return a live JavaThread that is &quot;protected&quot; by the
 751   // ThreadsListHandle in the caller.
 752   *jt_pp = java_thread;
 753   return true;
 754 }
 755 
 756 void ThreadsSMRSupport::add_thread(JavaThread *thread){
 757   ThreadsList *new_list = ThreadsList::add_thread(get_java_thread_list(), thread);
 758   if (EnableThreadSMRStatistics) {
 759     inc_java_thread_list_alloc_cnt();
 760     update_java_thread_list_max(new_list-&gt;length());
 761   }
 762   // Initial _java_thread_list will not generate a &quot;Threads::add&quot; mesg.
 763   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::add: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
 764 
 765   ThreadsList *old_list = xchg_java_thread_list(new_list);
 766   free_list(old_list);
<span class="line-added"> 767   if (ThreadIdTable::is_initialized()) {</span>
<span class="line-added"> 768     jlong tid = SharedRuntime::get_java_tid(thread);</span>
<span class="line-added"> 769     ThreadIdTable::add_thread(tid, thread);</span>
<span class="line-added"> 770   }</span>
 771 }
 772 
 773 // set_delete_notify() and clear_delete_notify() are called
 774 // under the protection of the delete_lock, but we also use an
 775 // Atomic operation to ensure the memory update is seen earlier than
 776 // when the delete_lock is dropped.
 777 //
 778 void ThreadsSMRSupport::clear_delete_notify() {
 779   Atomic::dec(&amp;_delete_notify);
 780 }
 781 
 782 bool ThreadsSMRSupport::delete_notify() {
 783   // Use load_acquire() in order to see any updates to _delete_notify
 784   // earlier than when delete_lock is grabbed.
<span class="line-modified"> 785   return (Atomic::load_acquire(&amp;_delete_notify) != 0);</span>
 786 }
 787 
 788 // Safely free a ThreadsList after a Threads::add() or Threads::remove().
 789 // The specified ThreadsList may not get deleted during this call if it
 790 // is still in-use (referenced by a hazard ptr). Other ThreadsLists
 791 // in the chain may get deleted by this call if they are no longer in-use.
 792 void ThreadsSMRSupport::free_list(ThreadsList* threads) {
 793   assert_locked_or_safepoint(Threads_lock);
 794 
 795   if (is_bootstrap_list(threads)) {
 796     // The bootstrap list cannot be freed and is empty so
 797     // it does not need to be scanned. Nothing to do here.
 798     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::free_list: bootstrap ThreadsList=&quot; INTPTR_FORMAT &quot; is no longer in use.&quot;, os::current_thread_id(), p2i(threads));
 799     return;
 800   }
 801 
 802   threads-&gt;set_next_list(_to_delete_list);
 803   _to_delete_list = threads;
 804   if (EnableThreadSMRStatistics) {
 805     _to_delete_list_cnt++;
 806     if (_to_delete_list_cnt &gt; _to_delete_list_max) {
 807       _to_delete_list_max = _to_delete_list_cnt;
 808     }
 809   }
 810 
 811   // Hash table size should be first power of two higher than twice the length of the ThreadsList
 812   int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
<span class="line-modified"> 813   hash_table_size = round_up_power_of_2(hash_table_size);</span>






 814 
 815   // Gather a hash table of the current hazard ptrs:
 816   ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
 817   ScanHazardPtrGatherThreadsListClosure scan_cl(scan_table);
 818   threads_do(&amp;scan_cl);
 819   OrderAccess::acquire(); // Must order reads of hazard ptr before reads of
 820                           // nested reference counters
 821 
 822   // Walk through the linked list of pending freeable ThreadsLists
 823   // and free the ones that are not referenced from hazard ptrs.
 824   ThreadsList* current = _to_delete_list;
 825   ThreadsList* prev = NULL;
 826   ThreadsList* next = NULL;
 827   bool threads_is_freed = false;
 828   while (current != NULL) {
 829     next = current-&gt;next_list();
 830     if (!scan_table-&gt;has_entry((void*)current) &amp;&amp; current-&gt;_nested_handle_cnt == 0) {
 831       // This ThreadsList is not referenced by a hazard ptr.
 832       if (prev != NULL) {
 833         prev-&gt;set_next_list(next);
</pre>
<hr />
<pre>
 850   }
 851 
 852   if (!threads_is_freed) {
 853     // Only report &quot;is not freed&quot; on the original call to
 854     // free_list() for this ThreadsList.
 855     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::free_list: threads=&quot; INTPTR_FORMAT &quot; is not freed.&quot;, os::current_thread_id(), p2i(threads));
 856   }
 857 
 858   delete scan_table;
 859 }
 860 
 861 // Return true if the specified JavaThread is protected by a hazard
 862 // pointer (ThreadsList reference). Otherwise, returns false.
 863 //
 864 bool ThreadsSMRSupport::is_a_protected_JavaThread(JavaThread *thread) {
 865   assert_locked_or_safepoint(Threads_lock);
 866 
 867   // Hash table size should be first power of two higher than twice
 868   // the length of the Threads list.
 869   int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
<span class="line-modified"> 870   hash_table_size = round_up_power_of_2(hash_table_size);</span>






 871 
 872   // Gather a hash table of the JavaThreads indirectly referenced by
 873   // hazard ptrs.
 874   ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
 875   ScanHazardPtrGatherProtectedThreadsClosure scan_cl(scan_table);
 876   threads_do(&amp;scan_cl);
 877   OrderAccess::acquire(); // Must order reads of hazard ptr before reads of
 878                           // nested reference counters
 879 
 880   // Walk through the linked list of pending freeable ThreadsLists
 881   // and include the ones that are currently in use by a nested
 882   // ThreadsListHandle in the search set.
 883   ThreadsList* current = _to_delete_list;
 884   while (current != NULL) {
 885     if (current-&gt;_nested_handle_cnt != 0) {
 886       // &#39;current&#39; is in use by a nested ThreadsListHandle so the hazard
 887       // ptr is protecting all the JavaThreads on that ThreadsList.
 888       AddThreadHazardPointerThreadClosure add_cl(scan_table);
 889       current-&gt;threads_do(&amp;add_cl);
 890     }
</pre>
<hr />
<pre>
 896     thread_is_protected = true;
 897   }
 898   delete scan_table;
 899   return thread_is_protected;
 900 }
 901 
 902 // Wake up portion of the release stable ThreadsList protocol;
 903 // uses the delete_lock().
 904 //
 905 void ThreadsSMRSupport::release_stable_list_wake_up(bool is_nested) {
 906   const char* log_str = is_nested ? &quot;nested hazard ptr&quot; : &quot;regular hazard ptr&quot;;
 907 
 908   // Note: delete_lock is held in smr_delete() for the entire
 909   // hazard ptr search so that we do not lose this notify() if
 910   // the exiting thread has to wait. That code path also holds
 911   // Threads_lock (which was grabbed before delete_lock) so that
 912   // threads_do() can be called. This means the system can&#39;t start a
 913   // safepoint which means this thread can&#39;t take too long to get to
 914   // a safepoint because of being blocked on delete_lock.
 915   //
<span class="line-modified"> 916   MonitorLocker ml(ThreadsSMRSupport::delete_lock(), Monitor::_no_safepoint_check_flag);</span>
 917   if (ThreadsSMRSupport::delete_notify()) {
 918     // Notify any exiting JavaThreads that are waiting in smr_delete()
 919     // that we&#39;ve released a ThreadsList.
 920     ml.notify_all();
 921     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::release_stable_list notified %s&quot;, os::current_thread_id(), log_str);
 922   }
 923 }
 924 
 925 void ThreadsSMRSupport::remove_thread(JavaThread *thread) {
<span class="line-added"> 926   if (ThreadIdTable::is_initialized()) {</span>
<span class="line-added"> 927     jlong tid = SharedRuntime::get_java_tid(thread);</span>
<span class="line-added"> 928     ThreadIdTable::remove_thread(tid);</span>
<span class="line-added"> 929   }</span>
 930   ThreadsList *new_list = ThreadsList::remove_thread(ThreadsSMRSupport::get_java_thread_list(), thread);
 931   if (EnableThreadSMRStatistics) {
 932     ThreadsSMRSupport::inc_java_thread_list_alloc_cnt();
 933     // This list is smaller so no need to check for a &quot;longest&quot; update.
 934   }
 935 
 936   // Final _java_thread_list will not generate a &quot;Threads::remove&quot; mesg.
 937   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::remove: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
 938 
 939   ThreadsList *old_list = ThreadsSMRSupport::xchg_java_thread_list(new_list);
 940   ThreadsSMRSupport::free_list(old_list);
 941 }
 942 
 943 // See note for clear_delete_notify().
 944 //
 945 void ThreadsSMRSupport::set_delete_notify() {
 946   Atomic::inc(&amp;_delete_notify);
 947 }
 948 
 949 // Safely delete a JavaThread when it is no longer in use by a
 950 // ThreadsListHandle.
 951 //
 952 void ThreadsSMRSupport::smr_delete(JavaThread *thread) {
 953   assert(!Threads_lock-&gt;owned_by_self(), &quot;sanity&quot;);
 954 
 955   bool has_logged_once = false;
 956   elapsedTimer timer;
 957   if (EnableThreadSMRStatistics) {
 958     timer.start();
 959   }
 960 
 961   while (true) {
 962     {
<span class="line-modified"> 963       // Will not make a safepoint check because this JavaThread</span>
<span class="line-modified"> 964       // is not on the current ThreadsList.</span>
<span class="line-modified"> 965       MutexLocker ml(Threads_lock);</span>
<span class="line-modified"> 966       // Cannot use a MonitorLocker helper here because we have</span>
 967       // to drop the Threads_lock first if we wait.
 968       ThreadsSMRSupport::delete_lock()-&gt;lock_without_safepoint_check();
 969       // Set the delete_notify flag after we grab delete_lock
 970       // and before we scan hazard ptrs because we&#39;re doing
 971       // double-check locking in release_stable_list().
 972       ThreadsSMRSupport::set_delete_notify();
 973 
 974       if (!is_a_protected_JavaThread(thread)) {
 975         // This is the common case.
 976         ThreadsSMRSupport::clear_delete_notify();
 977         ThreadsSMRSupport::delete_lock()-&gt;unlock();
 978         break;
 979       }
 980       if (!has_logged_once) {
 981         has_logged_once = true;
 982         log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: thread=&quot; INTPTR_FORMAT &quot; is not deleted.&quot;, os::current_thread_id(), p2i(thread));
 983         if (log_is_enabled(Debug, os, thread)) {
 984           ScanHazardPtrPrintMatchingThreadsClosure scan_cl(thread);
 985           threads_do(&amp;scan_cl);
 986           ThreadsList* current = _to_delete_list;
 987           while (current != NULL) {
 988             if (current-&gt;_nested_handle_cnt != 0 &amp;&amp; current-&gt;includes(thread)) {
 989               log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: found nested hazard pointer to thread=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(thread));
 990             }
 991             current = current-&gt;next_list();
 992           }
 993         }
 994       }
 995     } // We have to drop the Threads_lock to wait or delete the thread
 996 
 997     if (EnableThreadSMRStatistics) {
 998       _delete_lock_wait_cnt++;
 999       if (_delete_lock_wait_cnt &gt; _delete_lock_wait_max) {
1000         _delete_lock_wait_max = _delete_lock_wait_cnt;
1001       }
1002     }
1003     // Wait for a release_stable_list() call before we check again. No
1004     // safepoint check, no timeout, and not as suspend equivalent flag
1005     // because this JavaThread is not on the Threads list.
<span class="line-modified">1006     ThreadsSMRSupport::delete_lock()-&gt;wait_without_safepoint_check();</span>

1007     if (EnableThreadSMRStatistics) {
1008       _delete_lock_wait_cnt--;
1009     }
1010 
1011     ThreadsSMRSupport::clear_delete_notify();
1012     ThreadsSMRSupport::delete_lock()-&gt;unlock();
1013     // Retry the whole scenario.
1014   }
1015 
1016   delete thread;
1017   if (EnableThreadSMRStatistics) {
1018     timer.stop();
1019     uint millis = (uint)timer.milliseconds();
1020     ThreadsSMRSupport::inc_deleted_thread_cnt();
1021     ThreadsSMRSupport::add_deleted_thread_times(millis);
1022     ThreadsSMRSupport::update_deleted_thread_time_max(millis);
1023   }
1024 
1025   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: thread=&quot; INTPTR_FORMAT &quot; is deleted.&quot;, os::current_thread_id(), p2i(thread));
1026 }
</pre>
<hr />
<pre>
1078       current = current-&gt;previous();
1079     }
1080     while (current != NULL) {
1081       current-&gt;print_on(st);
1082       current = current-&gt;previous();
1083     }
1084   }
1085 }
1086 
1087 // Print Threads class SMR info.
1088 void ThreadsSMRSupport::print_info_on(outputStream* st) {
1089   // Only grab the Threads_lock if we don&#39;t already own it and if we
1090   // are not reporting an error.
1091   // Note: Not grabbing the Threads_lock during error reporting is
1092   // dangerous because the data structures we want to print can be
1093   // freed concurrently. However, grabbing the Threads_lock during
1094   // error reporting can be equally dangerous since this thread might
1095   // block during error reporting or a nested error could leave the
1096   // Threads_lock held. The classic no win scenario.
1097   //
<span class="line-modified">1098   MutexLocker ml((Threads_lock-&gt;owned_by_self() || VMError::is_error_reported()) ? NULL : Threads_lock);</span>
1099 
1100   st-&gt;print_cr(&quot;Threads class SMR info:&quot;);
1101   st-&gt;print_cr(&quot;_java_thread_list=&quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1102                &quot;elements={&quot;, p2i(_java_thread_list),
1103                _java_thread_list-&gt;length());
1104   print_info_elements_on(st, _java_thread_list);
1105   st-&gt;print_cr(&quot;}&quot;);
1106   if (_to_delete_list != NULL) {
1107     st-&gt;print_cr(&quot;_to_delete_list=&quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1108                  &quot;elements={&quot;, p2i(_to_delete_list),
1109                  _to_delete_list-&gt;length());
1110     print_info_elements_on(st, _to_delete_list);
1111     st-&gt;print_cr(&quot;}&quot;);
1112     for (ThreadsList *t_list = _to_delete_list-&gt;next_list();
1113          t_list != NULL; t_list = t_list-&gt;next_list()) {
1114       st-&gt;print(&quot;next-&gt; &quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1115                 &quot;elements={&quot;, p2i(t_list), t_list-&gt;length());
1116       print_info_elements_on(st, t_list);
1117       st-&gt;print_cr(&quot;}&quot;);
1118     }
</pre>
</td>
</tr>
</table>
<center><a href="threadHeapSampler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadSMR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/thread.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="task.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,10 ***</span>
<span class="line-new-header">--- 22,11 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jvm.h&quot;
<span class="line-added">+ #include &quot;aot/aotLoader.hpp&quot;</span>
  #include &quot;classfile/classLoader.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,10 ***</span>
<span class="line-new-header">--- 45,11 ---</span>
  #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logConfiguration.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;memory/metaspaceShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,11 ***</span>
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
<span class="line-removed">- #include &quot;runtime/flags/jvmFlagWriteableList.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/handshake.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
<span class="line-new-header">--- 66,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,10 ***</span>
<span class="line-new-header">--- 85,11 ---</span>
  #include &quot;runtime/osThread.hpp&quot;
  #include &quot;runtime/prefetch.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
<span class="line-added">+ #include &quot;runtime/serviceThread.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/statSampler.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/sweeper.hpp&quot;
  #include &quot;runtime/task.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,13 ***</span>
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/preserveException.hpp&quot;
  #include &quot;utilities/singleWriterSynchronizer.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
  #if INCLUDE_JVMCI
<span class="line-modified">! #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
<span class="line-modified">! #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
<span class="line-removed">- #include &quot;logging/logHandle.hpp&quot;</span>
  #endif
  #ifdef COMPILER1
  #include &quot;c1/c1_Compiler.hpp&quot;
  #endif
  #ifdef COMPILER2
<span class="line-new-header">--- 117,12 ---</span>
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/preserveException.hpp&quot;
  #include &quot;utilities/singleWriterSynchronizer.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
  #if INCLUDE_JVMCI
<span class="line-modified">! #include &quot;jvmci/jvmci.hpp&quot;</span>
<span class="line-modified">! #include &quot;jvmci/jvmciEnv.hpp&quot;</span>
  #endif
  #ifdef COMPILER1
  #include &quot;c1/c1_Compiler.hpp&quot;
  #endif
  #ifdef COMPILER2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,18 ***</span>
  
  #endif // ndef DTRACE_ENABLED
  
  #ifndef USE_LIBRARY_BASED_TLS_ONLY
  // Current thread is maintained as a thread-local variable
<span class="line-modified">! THREAD_LOCAL_DECL Thread* Thread::_thr_current = NULL;</span>
  #endif
  
  // ======= Thread ========
  // Support for forcing alignment of thread objects for biased locking
  void* Thread::allocate(size_t size, bool throw_excpt, MEMFLAGS flags) {
    if (UseBiasedLocking) {
<span class="line-modified">!     const int alignment = markOopDesc::biased_lock_alignment;</span>
      size_t aligned_size = size + (alignment - sizeof(intptr_t));
      void* real_malloc_addr = throw_excpt? AllocateHeap(aligned_size, flags, CURRENT_PC)
                                            : AllocateHeap(aligned_size, flags, CURRENT_PC,
                                                           AllocFailStrategy::RETURN_NULL);
      void* aligned_addr     = align_up(real_malloc_addr, alignment);
<span class="line-new-header">--- 165,18 ---</span>
  
  #endif // ndef DTRACE_ENABLED
  
  #ifndef USE_LIBRARY_BASED_TLS_ONLY
  // Current thread is maintained as a thread-local variable
<span class="line-modified">! THREAD_LOCAL Thread* Thread::_thr_current = NULL;</span>
  #endif
  
  // ======= Thread ========
  // Support for forcing alignment of thread objects for biased locking
  void* Thread::allocate(size_t size, bool throw_excpt, MEMFLAGS flags) {
    if (UseBiasedLocking) {
<span class="line-modified">!     const size_t alignment = markWord::biased_lock_alignment;</span>
      size_t aligned_size = size + (alignment - sizeof(intptr_t));
      void* real_malloc_addr = throw_excpt? AllocateHeap(aligned_size, flags, CURRENT_PC)
                                            : AllocateHeap(aligned_size, flags, CURRENT_PC,
                                                           AllocFailStrategy::RETURN_NULL);
      void* aligned_addr     = align_up(real_malloc_addr, alignment);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,11 ***</span>
    DEBUG_ONLY(_run_state = PRE_CALL_RUN;)
  
    // stack and get_thread
    set_stack_base(NULL);
    set_stack_size(0);
<span class="line-removed">-   set_self_raw_id(0);</span>
    set_lgrp_id(-1);
    DEBUG_ONLY(clear_suspendible_thread();)
  
    // allocated data structures
    set_osthread(NULL);
<span class="line-new-header">--- 222,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,38 ***</span>
    set_active_handles(NULL);
    set_free_handle_block(NULL);
    set_last_handle_mark(NULL);
    DEBUG_ONLY(_missed_ic_stub_refill_verifier = NULL);
  
<span class="line-modified">!   // This initial value ==&gt; never claimed.</span>
<span class="line-modified">!   _oops_do_parity = 0;</span>
    _threads_hazard_ptr = NULL;
    _threads_list_ptr = NULL;
    _nested_threads_hazard_ptr_cnt = 0;
    _rcu_counter = 0;
  
    // the handle mark links itself to last_handle_mark
    new HandleMark(this);
  
    // plain initialization
    debug_only(_owned_locks = NULL;)
<span class="line-modified">!   debug_only(_allow_allocation_count = 0;)</span>
<span class="line-removed">-   NOT_PRODUCT(_allow_safepoint_count = 0;)</span>
    NOT_PRODUCT(_skip_gcalot = false;)
    _jvmti_env_iteration_count = 0;
    set_allocated_bytes(0);
    _vm_operation_started_count = 0;
    _vm_operation_completed_count = 0;
    _current_pending_monitor = NULL;
    _current_pending_monitor_is_from_java = true;
    _current_waiting_monitor = NULL;
    _num_nested_signal = 0;
<span class="line-modified">!   omFreeList = NULL;</span>
<span class="line-modified">!   omFreeCount = 0;</span>
<span class="line-modified">!   omFreeProvision = 32;</span>
<span class="line-modified">!   omInUseList = NULL;</span>
<span class="line-modified">!   omInUseCount = 0;</span>
  
  #ifdef ASSERT
    _visited_for_critical_count = false;
  #endif
  
<span class="line-new-header">--- 236,38 ---</span>
    set_active_handles(NULL);
    set_free_handle_block(NULL);
    set_last_handle_mark(NULL);
    DEBUG_ONLY(_missed_ic_stub_refill_verifier = NULL);
  
<span class="line-modified">!   // Initial value of zero ==&gt; never claimed.</span>
<span class="line-modified">!   _threads_do_token = 0;</span>
    _threads_hazard_ptr = NULL;
    _threads_list_ptr = NULL;
    _nested_threads_hazard_ptr_cnt = 0;
    _rcu_counter = 0;
  
    // the handle mark links itself to last_handle_mark
    new HandleMark(this);
  
    // plain initialization
    debug_only(_owned_locks = NULL;)
<span class="line-modified">!   NOT_PRODUCT(_no_safepoint_count = 0;)</span>
    NOT_PRODUCT(_skip_gcalot = false;)
    _jvmti_env_iteration_count = 0;
    set_allocated_bytes(0);
    _vm_operation_started_count = 0;
    _vm_operation_completed_count = 0;
    _current_pending_monitor = NULL;
    _current_pending_monitor_is_from_java = true;
    _current_waiting_monitor = NULL;
<span class="line-added">+   _current_pending_raw_monitor = NULL;</span>
    _num_nested_signal = 0;
<span class="line-modified">!   om_free_list = NULL;</span>
<span class="line-modified">!   om_free_count = 0;</span>
<span class="line-modified">!   om_free_provision = 32;</span>
<span class="line-modified">!   om_in_use_list = NULL;</span>
<span class="line-modified">!   om_in_use_count = 0;</span>
  
  #ifdef ASSERT
    _visited_for_critical_count = false;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,23 ***</span>
    // CONSIDER: instead of using a fixed set of purpose-dedicated ParkEvents
    // we might instead use a stack of ParkEvents that we could provision on-demand.
    // The stack would act as a cache to avoid calls to ParkEvent::Allocate()
    // and ::Release()
    _ParkEvent   = ParkEvent::Allocate(this);
<span class="line-removed">-   _SleepEvent  = ParkEvent::Allocate(this);</span>
    _MuxEvent    = ParkEvent::Allocate(this);
  
  #ifdef CHECK_UNHANDLED_OOPS
    if (CheckUnhandledOops) {
      _unhandled_oops = new UnhandledOops(this);
    }
  #endif // CHECK_UNHANDLED_OOPS
  #ifdef ASSERT
    if (UseBiasedLocking) {
<span class="line-modified">!     assert((((uintptr_t) this) &amp; (markOopDesc::biased_lock_alignment - 1)) == 0, &quot;forced alignment of thread object failed&quot;);</span>
      assert(this == _real_malloc_address ||
<span class="line-modified">!            this == align_up(_real_malloc_address, (int)markOopDesc::biased_lock_alignment),</span>
             &quot;bug in forced alignment of thread objects&quot;);
    }
  #endif // ASSERT
  
    // Notify the barrier set that a thread is being created. The initial
<span class="line-new-header">--- 291,22 ---</span>
    // CONSIDER: instead of using a fixed set of purpose-dedicated ParkEvents
    // we might instead use a stack of ParkEvents that we could provision on-demand.
    // The stack would act as a cache to avoid calls to ParkEvent::Allocate()
    // and ::Release()
    _ParkEvent   = ParkEvent::Allocate(this);
    _MuxEvent    = ParkEvent::Allocate(this);
  
  #ifdef CHECK_UNHANDLED_OOPS
    if (CheckUnhandledOops) {
      _unhandled_oops = new UnhandledOops(this);
    }
  #endif // CHECK_UNHANDLED_OOPS
  #ifdef ASSERT
    if (UseBiasedLocking) {
<span class="line-modified">!     assert(is_aligned(this, markWord::biased_lock_alignment), &quot;forced alignment of thread object failed&quot;);</span>
      assert(this == _real_malloc_address ||
<span class="line-modified">!            this == align_up(_real_malloc_address, markWord::biased_lock_alignment),</span>
             &quot;bug in forced alignment of thread objects&quot;);
    }
  #endif // ASSERT
  
    // Notify the barrier set that a thread is being created. The initial
</pre>
<hr />
<pre>
<span class="line-old-header">*** 386,11 ***</span>
  
    JFR_ONLY(Jfr::on_thread_start(this);)
  
    log_debug(os, thread)(&quot;Thread &quot; UINTX_FORMAT &quot; stack dimensions: &quot;
      PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; (&quot; SIZE_FORMAT &quot;k).&quot;,
<span class="line-modified">!     os::current_thread_id(), p2i(stack_base() - stack_size()),</span>
      p2i(stack_base()), stack_size()/1024);
  
    // Perform &lt;ChildClass&gt; initialization actions
    DEBUG_ONLY(_run_state = PRE_RUN;)
    this-&gt;pre_run();
<span class="line-new-header">--- 385,11 ---</span>
  
    JFR_ONLY(Jfr::on_thread_start(this);)
  
    log_debug(os, thread)(&quot;Thread &quot; UINTX_FORMAT &quot; stack dimensions: &quot;
      PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; (&quot; SIZE_FORMAT &quot;k).&quot;,
<span class="line-modified">!     os::current_thread_id(), p2i(stack_end()),</span>
      p2i(stack_base()), stack_size()/1024);
  
    // Perform &lt;ChildClass&gt; initialization actions
    DEBUG_ONLY(_run_state = PRE_RUN;)
    this-&gt;pre_run();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 456,11 ***</span>
    assert(last_handle_mark() == NULL, &quot;check we have reached the end&quot;);
  
    // It&#39;s possible we can encounter a null _ParkEvent, etc., in stillborn threads.
    // We NULL out the fields for good hygiene.
    ParkEvent::Release(_ParkEvent); _ParkEvent   = NULL;
<span class="line-removed">-   ParkEvent::Release(_SleepEvent); _SleepEvent  = NULL;</span>
    ParkEvent::Release(_MuxEvent); _MuxEvent    = NULL;
  
    delete handle_area();
    delete metadata_handles();
  
<span class="line-new-header">--- 455,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 525,14 ***</span>
      }
      os::start_thread(thread);
    }
  }
  
<span class="line-modified">! // Enqueue a VM_Operation to do the job for us - sometime later</span>
  void Thread::send_async_exception(oop java_thread, oop java_throwable) {
<span class="line-modified">!   VM_ThreadStop* vm_stop = new VM_ThreadStop(java_thread, java_throwable);</span>
<span class="line-modified">!   VMThread::execute(vm_stop);</span>
  }
  
  
  // Check if an external suspend request has completed (or has been
  // cancelled). Returns true if the thread is externally suspended and
<span class="line-new-header">--- 523,29 ---</span>
      }
      os::start_thread(thread);
    }
  }
  
<span class="line-modified">! class InstallAsyncExceptionClosure : public HandshakeClosure {</span>
<span class="line-added">+   Handle _throwable; // The Throwable thrown at the target Thread</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   InstallAsyncExceptionClosure(Handle throwable) : HandshakeClosure(&quot;InstallAsyncException&quot;), _throwable(throwable) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+   void do_thread(Thread* thr) {</span>
<span class="line-added">+     JavaThread* target = (JavaThread*)thr;</span>
<span class="line-added">+     // Note that this now allows multiple ThreadDeath exceptions to be</span>
<span class="line-added">+     // thrown at a thread.</span>
<span class="line-added">+     // The target thread has run and has not exited yet.</span>
<span class="line-added">+     target-&gt;send_thread_stop(_throwable());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  void Thread::send_async_exception(oop java_thread, oop java_throwable) {
<span class="line-modified">!   Handle throwable(Thread::current(), java_throwable);</span>
<span class="line-modified">!   JavaThread* target = java_lang_Thread::thread(java_thread);</span>
<span class="line-added">+   InstallAsyncExceptionClosure vm_stop(throwable);</span>
<span class="line-added">+   Handshake::execute(&amp;vm_stop, target);</span>
  }
  
  
  // Check if an external suspend request has completed (or has been
  // cancelled). Returns true if the thread is externally suspended and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 716,11 ***</span>
          // safepoint requests from the VMThread
  
          // temporarily drops SR_lock while doing wait with safepoint check
          // (if we&#39;re a JavaThread - the WatcherThread can also call this)
          // and increase delay with each retry
<span class="line-modified">!         SR_lock()-&gt;wait(!Thread::current()-&gt;is_Java_thread(), i * delay);</span>
  
          // check the actual thread state instead of what we saved above
          if (thread_state() != _thread_in_native_trans) {
            // the thread has transitioned to another thread state so
            // try all the checks (except this one) one more time.
<span class="line-new-header">--- 729,15 ---</span>
          // safepoint requests from the VMThread
  
          // temporarily drops SR_lock while doing wait with safepoint check
          // (if we&#39;re a JavaThread - the WatcherThread can also call this)
          // and increase delay with each retry
<span class="line-modified">!         if (Thread::current()-&gt;is_Java_thread()) {</span>
<span class="line-added">+           SR_lock()-&gt;wait(i * delay);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           SR_lock()-&gt;wait_without_safepoint_check(i * delay);</span>
<span class="line-added">+         }</span>
  
          // check the actual thread state instead of what we saved above
          if (thread_state() != _thread_in_native_trans) {
            // the thread has transitioned to another thread state so
            // try all the checks (except this one) one more time.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 757,11 ***</span>
    // each retry loop. This allows the caller to make use of any
    // unused bits for their own marking purposes.
    reset_bits = *bits;
  
    {
<span class="line-modified">!     MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      is_suspended = is_ext_suspend_completed(true /* called_by_wait */,
                                              delay, bits);
      pending = is_external_suspend();
    }
    // must release SR_lock to allow suspension to complete
<span class="line-new-header">--- 774,11 ---</span>
    // each retry loop. This allows the caller to make use of any
    // unused bits for their own marking purposes.
    reset_bits = *bits;
  
    {
<span class="line-modified">!     MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      is_suspended = is_ext_suspend_completed(true /* called_by_wait */,
                                              delay, bits);
      pending = is_external_suspend();
    }
    // must release SR_lock to allow suspension to complete
</pre>
<hr />
<pre>
<span class="line-old-header">*** 788,14 ***</span>
      // on the SR_lock below provides a much more predictable scale up for
      // the delay. It also provides a simple/direct point to check for any
      // safepoint requests from the VMThread
  
      {
<span class="line-modified">!       MutexLocker ml(SR_lock());</span>
        // wait with safepoint check (if we&#39;re a JavaThread - the WatcherThread
        // can also call this)  and increase delay with each retry
<span class="line-modified">!       SR_lock()-&gt;wait(!Thread::current()-&gt;is_Java_thread(), i * delay);</span>
  
        is_suspended = is_ext_suspend_completed(true /* called_by_wait */,
                                                delay, bits);
  
        // It is possible for the external suspend request to be cancelled
<span class="line-new-header">--- 805,16 ---</span>
      // on the SR_lock below provides a much more predictable scale up for
      // the delay. It also provides a simple/direct point to check for any
      // safepoint requests from the VMThread
  
      {
<span class="line-modified">!       Thread* t = Thread::current();</span>
<span class="line-added">+       MonitorLocker ml(SR_lock(),</span>
<span class="line-added">+                        t-&gt;is_Java_thread() ? Mutex::_safepoint_check_flag : Mutex::_no_safepoint_check_flag);</span>
        // wait with safepoint check (if we&#39;re a JavaThread - the WatcherThread
        // can also call this)  and increase delay with each retry
<span class="line-modified">!       ml.wait(i * delay);</span>
  
        is_suspended = is_ext_suspend_completed(true /* called_by_wait */,
                                                delay, bits);
  
        // It is possible for the external suspend request to be cancelled
</pre>
<hr />
<pre>
<span class="line-old-header">*** 852,51 ***</span>
    }
  
    return true;
  }
  
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">- void JavaThread::record_jump(address target, address instr, const char* file,</span>
<span class="line-removed">-                              int line) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // This should not need to be atomic as the only way for simultaneous</span>
<span class="line-removed">-   // updates is via interrupts. Even then this should be rare or non-existent</span>
<span class="line-removed">-   // and we don&#39;t care that much anyway.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int index = _jmp_ring_index;</span>
<span class="line-removed">-   _jmp_ring_index = (index + 1) &amp; (jump_ring_buffer_size - 1);</span>
<span class="line-removed">-   _jmp_ring[index]._target = (intptr_t) target;</span>
<span class="line-removed">-   _jmp_ring[index]._instruction = (intptr_t) instr;</span>
<span class="line-removed">-   _jmp_ring[index]._file = file;</span>
<span class="line-removed">-   _jmp_ring[index]._line = line;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif // PRODUCT</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Thread::interrupt(Thread* thread) {</span>
<span class="line-removed">-   debug_only(check_for_dangling_thread_pointer(thread);)</span>
<span class="line-removed">-   os::interrupt(thread);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Thread::is_interrupted(Thread* thread, bool clear_interrupted) {</span>
<span class="line-removed">-   debug_only(check_for_dangling_thread_pointer(thread);)</span>
<span class="line-removed">-   // Note:  If clear_interrupted==false, this simply fetches and</span>
<span class="line-removed">-   // returns the value of the field osthread()-&gt;interrupted().</span>
<span class="line-removed">-   return os::is_interrupted(thread, clear_interrupted);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  // GC Support
<span class="line-modified">! bool Thread::claim_oops_do_par_case(int strong_roots_parity) {</span>
<span class="line-modified">!   int thread_parity = _oops_do_parity;</span>
<span class="line-modified">!   if (thread_parity != strong_roots_parity) {</span>
<span class="line-modified">!     jint res = Atomic::cmpxchg(strong_roots_parity, &amp;_oops_do_parity, thread_parity);</span>
<span class="line-modified">!     if (res == thread_parity) {</span>
        return true;
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       guarantee(res == strong_roots_parity, &quot;Or else what?&quot;);</span>
<span class="line-removed">-       return false;</span>
      }
    }
    return false;
  }
  
  void Thread::oops_do(OopClosure* f, CodeBlobClosure* cf) {
<span class="line-new-header">--- 871,19 ---</span>
    }
  
    return true;
  }
  
  // GC Support
<span class="line-modified">! bool Thread::claim_par_threads_do(uintx claim_token) {</span>
<span class="line-modified">!   uintx token = _threads_do_token;</span>
<span class="line-modified">!   if (token != claim_token) {</span>
<span class="line-modified">!     uintx res = Atomic::cmpxchg(&amp;_threads_do_token, token, claim_token);</span>
<span class="line-modified">!     if (res == token) {</span>
        return true;
      }
<span class="line-added">+     guarantee(res == claim_token, &quot;invariant&quot;);</span>
    }
    return false;
  }
  
  void Thread::oops_do(OopClosure* f, CodeBlobClosure* cf) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 948,10 ***</span>
<span class="line-new-header">--- 935,12 ---</span>
    ThreadsSMRSupport::print_info_on(this, st);
    st-&gt;print(&quot; &quot;);
    debug_only(if (WizardMode) print_owned_locks_on(st);)
  }
  
<span class="line-added">+ void Thread::print() const { print_on(tty); }</span>
<span class="line-added">+ </span>
  // Thread::print_on_error() is called by fatal error handler. Don&#39;t use
  // any lock or allocate memory.
  void Thread::print_on_error(outputStream* st, char* buf, int buflen) const {
    assert(!(is_Compiler_thread() || is_Java_thread()), &quot;Can&#39;t call name() here if it allocates&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 982,11 ***</span>
    st-&gt;print(INTPTR_FORMAT, p2i(this));   // print address
  }
  
  #ifdef ASSERT
  void Thread::print_owned_locks_on(outputStream* st) const {
<span class="line-modified">!   Monitor *cur = _owned_locks;</span>
    if (cur == NULL) {
      st-&gt;print(&quot; (no locks) &quot;);
    } else {
      st-&gt;print_cr(&quot; Locks owned:&quot;);
      while (cur) {
<span class="line-new-header">--- 971,11 ---</span>
    st-&gt;print(INTPTR_FORMAT, p2i(this));   // print address
  }
  
  #ifdef ASSERT
  void Thread::print_owned_locks_on(outputStream* st) const {
<span class="line-modified">!   Mutex* cur = _owned_locks;</span>
    if (cur == NULL) {
      st-&gt;print(&quot; (no locks) &quot;);
    } else {
      st-&gt;print_cr(&quot; Locks owned:&quot;);
      while (cur) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 994,83 ***</span>
        cur = cur-&gt;next();
      }
    }
  }
  
<span class="line-modified">! static int ref_use_count  = 0;</span>
  
<span class="line-modified">! bool Thread::owns_locks_but_compiled_lock() const {</span>
<span class="line-modified">!   for (Monitor *cur = _owned_locks; cur; cur = cur-&gt;next()) {</span>
<span class="line-modified">!     if (cur != Compile_lock) return true;</span>
    }
<span class="line-modified">!   return false;</span>
  }
  
  
<span class="line-modified">! #endif</span>
<span class="line-modified">! </span>
<span class="line-modified">! #ifndef PRODUCT</span>
  
<span class="line-modified">! // The flag: potential_vm_operation notifies if this particular safepoint state could potentially</span>
<span class="line-removed">- // invoke the vm-thread (e.g., an oop allocation). In that case, we also have to make sure that</span>
<span class="line-removed">- // no locks which allow_vm_block&#39;s are held</span>
<span class="line-removed">- void Thread::check_for_valid_safepoint_state(bool potential_vm_operation) {</span>
<span class="line-removed">-   // Check if current thread is allowed to block at a safepoint</span>
<span class="line-removed">-   if (!(_allow_safepoint_count == 0)) {</span>
<span class="line-removed">-     fatal(&quot;Possible safepoint reached by thread that does not allow it&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (is_Java_thread() &amp;&amp; ((JavaThread*)this)-&gt;thread_state() != _thread_in_vm) {</span>
      fatal(&quot;LEAF method calling lock?&quot;);
    }
  
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   if (potential_vm_operation &amp;&amp; is_Java_thread()</span>
<span class="line-removed">-       &amp;&amp; !Universe::is_bootstrapping()) {</span>
<span class="line-removed">-     // Make sure we do not hold any locks that the VM thread also uses.</span>
<span class="line-removed">-     // This could potentially lead to deadlocks</span>
<span class="line-removed">-     for (Monitor *cur = _owned_locks; cur; cur = cur-&gt;next()) {</span>
<span class="line-removed">-       // Threads_lock is special, since the safepoint synchronization will not start before this is</span>
<span class="line-removed">-       // acquired. Hence, a JavaThread cannot be holding it at a safepoint. So is VMOperationRequest_lock,</span>
<span class="line-removed">-       // since it is used to transfer control between JavaThreads and the VMThread</span>
<span class="line-removed">-       // Do not *exclude* any locks unless you are absolutely sure it is correct. Ask someone else first!</span>
<span class="line-removed">-       if ((cur-&gt;allow_vm_block() &amp;&amp;</span>
<span class="line-removed">-            cur != Threads_lock &amp;&amp;</span>
<span class="line-removed">-            cur != Compile_lock &amp;&amp;               // Temporary: should not be necessary when we get separate compilation</span>
<span class="line-removed">-            cur != VMOperationRequest_lock &amp;&amp;</span>
<span class="line-removed">-            cur != VMOperationQueue_lock) ||</span>
<span class="line-removed">-            cur-&gt;rank() == Mutex::special) {</span>
<span class="line-removed">-         fatal(&quot;Thread holding lock at safepoint that vm can block on: %s&quot;, cur-&gt;name());</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    if (GCALotAtAllSafepoints) {
      // We could enter a safepoint here and thus have a gc
      InterfaceSupport::check_gc_alot();
    }
<span class="line-removed">- #endif</span>
  }
<span class="line-modified">! #endif</span>
  
  bool Thread::is_in_stack(address adr) const {
    assert(Thread::current() == this, &quot;is_in_stack can only be called from current thread&quot;);
    address end = os::current_stack_pointer();
<span class="line-modified">!   // Allow non Java threads to call this without stack_base</span>
<span class="line-removed">-   if (_stack_base == NULL) return true;</span>
<span class="line-removed">-   if (stack_base() &gt;= adr &amp;&amp; adr &gt;= end) return true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Thread::is_in_usable_stack(address adr) const {</span>
<span class="line-removed">-   size_t stack_guard_size = os::uses_stack_guard_pages() ? JavaThread::stack_guard_zone_size() : 0;</span>
<span class="line-removed">-   size_t usable_stack_size = _stack_size - stack_guard_size;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return ((adr &lt; stack_base()) &amp;&amp; (adr &gt;= stack_base() - usable_stack_size));</span>
  }
  
<span class="line-removed">- </span>
  // We had to move these methods here, because vm threads get into ObjectSynchronizer::enter
  // However, there is a note in JavaThread::is_lock_owned() about the VM threads not being
  // used for compilation in the future. If that change is made, the need for these methods
  // should be revisited, and they should be removed if possible.
  
<span class="line-new-header">--- 983,50 ---</span>
        cur = cur-&gt;next();
      }
    }
  }
  
<span class="line-modified">! // Checks safepoint allowed and clears unhandled oops at potential safepoints.</span>
<span class="line-added">+ void Thread::check_possible_safepoint() {</span>
<span class="line-added">+   if (!is_Java_thread()) return;</span>
  
<span class="line-modified">!   if (_no_safepoint_count &gt; 0) {</span>
<span class="line-modified">!     print_owned_locks();</span>
<span class="line-modified">!     fatal(&quot;Possible safepoint reached by thread that does not allow it&quot;);</span>
    }
<span class="line-modified">! #ifdef CHECK_UNHANDLED_OOPS</span>
<span class="line-added">+   // Clear unhandled oops in JavaThreads so we get a crash right away.</span>
<span class="line-added">+   clear_unhandled_oops();</span>
<span class="line-added">+ #endif // CHECK_UNHANDLED_OOPS</span>
  }
  
<span class="line-added">+ void Thread::check_for_valid_safepoint_state() {</span>
<span class="line-added">+   if (!is_Java_thread()) return;</span>
  
<span class="line-modified">!   // Check NoSafepointVerifier, which is implied by locks taken that can be</span>
<span class="line-modified">!   // shared with the VM thread.  This makes sure that no locks with allow_vm_block</span>
<span class="line-modified">!   // are held.</span>
<span class="line-added">+   check_possible_safepoint();</span>
  
<span class="line-modified">!   if (((JavaThread*)this)-&gt;thread_state() != _thread_in_vm) {</span>
      fatal(&quot;LEAF method calling lock?&quot;);
    }
  
    if (GCALotAtAllSafepoints) {
      // We could enter a safepoint here and thus have a gc
      InterfaceSupport::check_gc_alot();
    }
  }
<span class="line-modified">! #endif // ASSERT</span>
  
<span class="line-added">+ // Check for adr in the live portion of our stack.</span>
  bool Thread::is_in_stack(address adr) const {
    assert(Thread::current() == this, &quot;is_in_stack can only be called from current thread&quot;);
    address end = os::current_stack_pointer();
<span class="line-modified">!   return (stack_base() &gt; adr &amp;&amp; adr &gt;= end);</span>
  }
  
  // We had to move these methods here, because vm threads get into ObjectSynchronizer::enter
  // However, there is a note in JavaThread::is_lock_owned() about the VM threads not being
  // used for compilation in the future. If that change is made, the need for these methods
  // should be revisited, and they should be removed if possible.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1137,10 ***</span>
<span class="line-new-header">--- 1093,12 ---</span>
    return thread_oop();
  }
  
  char java_runtime_name[128] = &quot;&quot;;
  char java_runtime_version[128] = &quot;&quot;;
<span class="line-added">+ char java_runtime_vendor_version[128] = &quot;&quot;;</span>
<span class="line-added">+ char java_runtime_vendor_vm_bug_url[128] = &quot;&quot;;</span>
  
  // extract the JRE name from java.lang.VersionProps.java_runtime_name
  static const char* get_java_runtime_name(TRAPS) {
    Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),
                                      Handle(), Handle(), CHECK_AND_CLEAR_NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1182,10 ***</span>
<span class="line-new-header">--- 1140,54 ---</span>
    } else {
      return NULL;
    }
  }
  
<span class="line-added">+ // extract the JRE vendor version from java.lang.VersionProps.VENDOR_VERSION</span>
<span class="line-added">+ static const char* get_java_runtime_vendor_version(TRAPS) {</span>
<span class="line-added">+   Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),</span>
<span class="line-added">+                                     Handle(), Handle(), CHECK_AND_CLEAR_NULL);</span>
<span class="line-added">+   fieldDescriptor fd;</span>
<span class="line-added">+   bool found = k != NULL &amp;&amp;</span>
<span class="line-added">+                InstanceKlass::cast(k)-&gt;find_local_field(vmSymbols::java_runtime_vendor_version_name(),</span>
<span class="line-added">+                                                         vmSymbols::string_signature(), &amp;fd);</span>
<span class="line-added">+   if (found) {</span>
<span class="line-added">+     oop name_oop = k-&gt;java_mirror()-&gt;obj_field(fd.offset());</span>
<span class="line-added">+     if (name_oop == NULL) {</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     const char* name = java_lang_String::as_utf8_string(name_oop,</span>
<span class="line-added">+                                                         java_runtime_vendor_version,</span>
<span class="line-added">+                                                         sizeof(java_runtime_vendor_version));</span>
<span class="line-added">+     return name;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // extract the JRE vendor VM bug URL from java.lang.VersionProps.VENDOR_URL_VM_BUG</span>
<span class="line-added">+ static const char* get_java_runtime_vendor_vm_bug_url(TRAPS) {</span>
<span class="line-added">+   Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),</span>
<span class="line-added">+                                     Handle(), Handle(), CHECK_AND_CLEAR_NULL);</span>
<span class="line-added">+   fieldDescriptor fd;</span>
<span class="line-added">+   bool found = k != NULL &amp;&amp;</span>
<span class="line-added">+                InstanceKlass::cast(k)-&gt;find_local_field(vmSymbols::java_runtime_vendor_vm_bug_url_name(),</span>
<span class="line-added">+                                                         vmSymbols::string_signature(), &amp;fd);</span>
<span class="line-added">+   if (found) {</span>
<span class="line-added">+     oop name_oop = k-&gt;java_mirror()-&gt;obj_field(fd.offset());</span>
<span class="line-added">+     if (name_oop == NULL) {</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     const char* name = java_lang_String::as_utf8_string(name_oop,</span>
<span class="line-added">+                                                         java_runtime_vendor_vm_bug_url,</span>
<span class="line-added">+                                                         sizeof(java_runtime_vendor_vm_bug_url));</span>
<span class="line-added">+     return name;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // General purpose hook into Java code, run once when the VM is initialized.
  // The Java library method itself may be changed independently from the VM.
  static void call_postVMInitHook(TRAPS) {
    Klass* klass = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_PostVMInitHook(), THREAD);
    if (klass != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1270,64 ***</span>
  
  NonJavaThread::List NonJavaThread::_the_list;
  
  NonJavaThread::Iterator::Iterator() :
    _protect_enter(_the_list._protect.enter()),
<span class="line-modified">!   _current(OrderAccess::load_acquire(&amp;_the_list._head))</span>
  {}
  
  NonJavaThread::Iterator::~Iterator() {
    _the_list._protect.exit(_protect_enter);
  }
  
  void NonJavaThread::Iterator::step() {
    assert(!end(), &quot;precondition&quot;);
<span class="line-modified">!   _current = OrderAccess::load_acquire(&amp;_current-&gt;_next);</span>
  }
  
  NonJavaThread::NonJavaThread() : Thread(), _next(NULL) {
    assert(BarrierSet::barrier_set() != NULL, &quot;NonJavaThread created too soon!&quot;);
  }
  
  NonJavaThread::~NonJavaThread() { }
  
  void NonJavaThread::add_to_the_list() {
<span class="line-modified">!   MutexLockerEx lock(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   _next = _the_list._head;</span>
<span class="line-modified">!   OrderAccess::release_store(&amp;_the_list._head, this);</span>
  }
  
  void NonJavaThread::remove_from_the_list() {
<span class="line-modified">!   MutexLockerEx lock(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   NonJavaThread* volatile* p = &amp;_the_list._head;</span>
<span class="line-modified">!   for (NonJavaThread* t = *p; t != NULL; p = &amp;t-&gt;_next, t = *p) {</span>
<span class="line-modified">!     if (t == this) {</span>
<span class="line-modified">!       *p = this-&gt;_next;</span>
<span class="line-modified">!       // Wait for any in-progress iterators.  Concurrent synchronize is</span>
<span class="line-modified">!       // not allowed, so do it while holding the list lock.</span>
<span class="line-modified">!       _the_list._protect.synchronize();</span>
<span class="line-modified">!       break;</span>
      }
    }
  }
  
  void NonJavaThread::pre_run() {
<span class="line-removed">-   // Initialize BarrierSet-related data before adding to list.</span>
<span class="line-removed">-   assert(BarrierSet::barrier_set() != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   BarrierSet::barrier_set()-&gt;on_thread_attach(this);</span>
    add_to_the_list();
  
    // This is slightly odd in that NamedThread is a subclass, but
    // in fact name() is defined in Thread
    assert(this-&gt;name() != NULL, &quot;thread name was not set before it was started&quot;);
    this-&gt;set_native_thread_name(this-&gt;name());
  }
  
  void NonJavaThread::post_run() {
    JFR_ONLY(Jfr::on_thread_exit(this);)
<span class="line-removed">-   // Clean up BarrierSet data before removing from list.</span>
<span class="line-removed">-   BarrierSet::barrier_set()-&gt;on_thread_detach(this);</span>
    remove_from_the_list();
    // Ensure thread-local-storage is cleared before termination.
    Thread::clear_thread_current();
  }
  
<span class="line-new-header">--- 1272,68 ---</span>
  
  NonJavaThread::List NonJavaThread::_the_list;
  
  NonJavaThread::Iterator::Iterator() :
    _protect_enter(_the_list._protect.enter()),
<span class="line-modified">!   _current(Atomic::load_acquire(&amp;_the_list._head))</span>
  {}
  
  NonJavaThread::Iterator::~Iterator() {
    _the_list._protect.exit(_protect_enter);
  }
  
  void NonJavaThread::Iterator::step() {
    assert(!end(), &quot;precondition&quot;);
<span class="line-modified">!   _current = Atomic::load_acquire(&amp;_current-&gt;_next);</span>
  }
  
  NonJavaThread::NonJavaThread() : Thread(), _next(NULL) {
    assert(BarrierSet::barrier_set() != NULL, &quot;NonJavaThread created too soon!&quot;);
  }
  
  NonJavaThread::~NonJavaThread() { }
  
  void NonJavaThread::add_to_the_list() {
<span class="line-modified">!   MutexLocker ml(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!   // Initialize BarrierSet-related data before adding to list.</span>
<span class="line-modified">!   BarrierSet::barrier_set()-&gt;on_thread_attach(this);</span>
<span class="line-added">+   Atomic::release_store(&amp;_next, _the_list._head);</span>
<span class="line-added">+   Atomic::release_store(&amp;_the_list._head, this);</span>
  }
  
  void NonJavaThread::remove_from_the_list() {
<span class="line-modified">!   {</span>
<span class="line-modified">!     MutexLocker ml(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!     // Cleanup BarrierSet-related data before removing from list.</span>
<span class="line-modified">!     BarrierSet::barrier_set()-&gt;on_thread_detach(this);</span>
<span class="line-modified">!     NonJavaThread* volatile* p = &amp;_the_list._head;</span>
<span class="line-modified">!     for (NonJavaThread* t = *p; t != NULL; p = &amp;t-&gt;_next, t = *p) {</span>
<span class="line-modified">!       if (t == this) {</span>
<span class="line-modified">!         *p = _next;</span>
<span class="line-modified">!         break;</span>
<span class="line-added">+       }</span>
      }
    }
<span class="line-added">+   // Wait for any in-progress iterators.  Concurrent synchronize is not</span>
<span class="line-added">+   // allowed, so do it while holding a dedicated lock.  Outside and distinct</span>
<span class="line-added">+   // from NJTList_lock in case an iteration attempts to lock it.</span>
<span class="line-added">+   MutexLocker ml(NonJavaThreadsListSync_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   _the_list._protect.synchronize();</span>
<span class="line-added">+   _next = NULL;                 // Safe to drop the link now.</span>
  }
  
  void NonJavaThread::pre_run() {
    add_to_the_list();
  
    // This is slightly odd in that NamedThread is a subclass, but
    // in fact name() is defined in Thread
    assert(this-&gt;name() != NULL, &quot;thread name was not set before it was started&quot;);
    this-&gt;set_native_thread_name(this-&gt;name());
  }
  
  void NonJavaThread::post_run() {
    JFR_ONLY(Jfr::on_thread_exit(this);)
    remove_from_the_list();
    // Ensure thread-local-storage is cleared before termination.
    Thread::clear_thread_current();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1339,20 ***</span>
    _processed_thread(NULL),
    _gc_id(GCId::undefined())
  {}
  
  NamedThread::~NamedThread() {
<span class="line-modified">!   if (_name != NULL) {</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(char, _name);</span>
<span class="line-removed">-     _name = NULL;</span>
<span class="line-removed">-   }</span>
  }
  
  void NamedThread::set_name(const char* format, ...) {
    guarantee(_name == NULL, &quot;Only get to set name once.&quot;);
    _name = NEW_C_HEAP_ARRAY(char, max_name_len, mtThread);
<span class="line-removed">-   guarantee(_name != NULL, &quot;alloc failure&quot;);</span>
    va_list ap;
    va_start(ap, format);
    jio_vsnprintf(_name, max_name_len, format, ap);
    va_end(ap);
  }
<span class="line-new-header">--- 1345,16 ---</span>
    _processed_thread(NULL),
    _gc_id(GCId::undefined())
  {}
  
  NamedThread::~NamedThread() {
<span class="line-modified">!   FREE_C_HEAP_ARRAY(char, _name);</span>
  }
  
  void NamedThread::set_name(const char* format, ...) {
    guarantee(_name == NULL, &quot;Only get to set name once.&quot;);
    _name = NEW_C_HEAP_ARRAY(char, max_name_len, mtThread);
    va_list ap;
    va_start(ap, format);
    jio_vsnprintf(_name, max_name_len, format, ap);
    va_end(ap);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1393,11 ***</span>
  }
  
  int WatcherThread::sleep() const {
    // The WatcherThread does not participate in the safepoint protocol
    // for the PeriodicTask_lock because it is not a JavaThread.
<span class="line-modified">!   MutexLockerEx ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);</span>
  
    if (_should_terminate) {
      // check for termination before we do any housekeeping or wait
      return 0;  // we did not sleep.
    }
<span class="line-new-header">--- 1395,11 ---</span>
  }
  
  int WatcherThread::sleep() const {
    // The WatcherThread does not participate in the safepoint protocol
    // for the PeriodicTask_lock because it is not a JavaThread.
<span class="line-modified">!   MonitorLocker ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);</span>
  
    if (_should_terminate) {
      // check for termination before we do any housekeeping or wait
      return 0;  // we did not sleep.
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1413,12 ***</span>
    OSThreadWaitState osts(this-&gt;osthread(), false /* not Object.wait() */);
  
    jlong time_before_loop = os::javaTimeNanos();
  
    while (true) {
<span class="line-modified">!     bool timedout = PeriodicTask_lock-&gt;wait(Mutex::_no_safepoint_check_flag,</span>
<span class="line-removed">-                                             remaining);</span>
      jlong now = os::javaTimeNanos();
  
      if (remaining == 0) {
        // if we didn&#39;t have any tasks we could have waited for a long time
        // consider the time_slept zero and reset time_before_loop
<span class="line-new-header">--- 1415,11 ---</span>
    OSThreadWaitState osts(this-&gt;osthread(), false /* not Object.wait() */);
  
    jlong time_before_loop = os::javaTimeNanos();
  
    while (true) {
<span class="line-modified">!     bool timedout = ml.wait(remaining);</span>
      jlong now = os::javaTimeNanos();
  
      if (remaining == 0) {
        // if we didn&#39;t have any tasks we could have waited for a long time
        // consider the time_slept zero and reset time_before_loop
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1502,13 ***</span>
      PeriodicTask::real_time_tick(time_waited);
    }
  
    // Signal that it is terminated
    {
<span class="line-modified">!     MutexLockerEx mu(Terminator_lock, Mutex::_no_safepoint_check_flag);</span>
      _watcher_thread = NULL;
<span class="line-modified">!     Terminator_lock-&gt;notify();</span>
    }
  }
  
  void WatcherThread::start() {
    assert(PeriodicTask_lock-&gt;owned_by_self(), &quot;PeriodicTask_lock required&quot;);
<span class="line-new-header">--- 1503,13 ---</span>
      PeriodicTask::real_time_tick(time_waited);
    }
  
    // Signal that it is terminated
    {
<span class="line-modified">!     MutexLocker mu(Terminator_lock, Mutex::_no_safepoint_check_flag);</span>
      _watcher_thread = NULL;
<span class="line-modified">!     Terminator_lock-&gt;notify_all();</span>
    }
  }
  
  void WatcherThread::start() {
    assert(PeriodicTask_lock-&gt;owned_by_self(), &quot;PeriodicTask_lock required&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1537,17 ***</span>
        // unpark the WatcherThread so it can see that it should terminate
        watcher-&gt;unpark();
      }
    }
  
<span class="line-modified">!   MutexLocker mu(Terminator_lock);</span>
  
    while (watcher_thread() != NULL) {
      // This wait should make safepoint checks, wait without a timeout,
      // and wait as a suspend-equivalent condition.
<span class="line-modified">!     Terminator_lock-&gt;wait(!Mutex::_no_safepoint_check_flag, 0,</span>
<span class="line-removed">-                           Mutex::_as_suspend_equivalent_flag);</span>
    }
  }
  
  void WatcherThread::unpark() {
    assert(PeriodicTask_lock-&gt;owned_by_self(), &quot;PeriodicTask_lock required&quot;);
<span class="line-new-header">--- 1538,16 ---</span>
        // unpark the WatcherThread so it can see that it should terminate
        watcher-&gt;unpark();
      }
    }
  
<span class="line-modified">!   MonitorLocker mu(Terminator_lock);</span>
  
    while (watcher_thread() != NULL) {
      // This wait should make safepoint checks, wait without a timeout,
      // and wait as a suspend-equivalent condition.
<span class="line-modified">!     mu.wait(0, Mutex::_as_suspend_equivalent_flag);</span>
    }
  }
  
  void WatcherThread::unpark() {
    assert(PeriodicTask_lock-&gt;owned_by_self(), &quot;PeriodicTask_lock required&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1568,26 ***</span>
  
  bool jvmci_counters_include(JavaThread* thread) {
    return !JVMCICountersExcludeCompiler || !thread-&gt;is_Compiler_thread();
  }
  
<span class="line-modified">! void JavaThread::collect_counters(typeArrayOop array) {</span>
<span class="line-modified">!   if (JVMCICounterSize &gt; 0) {</span>
<span class="line-modified">!     JavaThreadIteratorWithHandle jtiwh;</span>
<span class="line-modified">!     for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-modified">!       array-&gt;long_at_put(i, _jvmci_old_thread_counters[i]);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     for (; JavaThread *tp = jtiwh.next(); ) {</span>
<span class="line-modified">!       if (jvmci_counters_include(tp)) {</span>
<span class="line-modified">!         for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-removed">-           array-&gt;long_at_put(i, array-&gt;long_at(i) + tp-&gt;_jvmci_counters[i]);</span>
<span class="line-removed">-         }</span>
        }
      }
    }
  }
  
  #endif // INCLUDE_JVMCI
  
  // A JavaThread is a normal Java thread
  
  void JavaThread::initialize() {
<span class="line-new-header">--- 1568,73 ---</span>
  
  bool jvmci_counters_include(JavaThread* thread) {
    return !JVMCICountersExcludeCompiler || !thread-&gt;is_Compiler_thread();
  }
  
<span class="line-modified">! void JavaThread::collect_counters(jlong* array, int length) {</span>
<span class="line-modified">!   assert(length == JVMCICounterSize, &quot;wrong value&quot;);</span>
<span class="line-modified">!   for (int i = 0; i &lt; length; i++) {</span>
<span class="line-modified">!     array[i] = _jvmci_old_thread_counters[i];</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *tp = jtiwh.next(); ) {</span>
<span class="line-modified">!     if (jvmci_counters_include(tp)) {</span>
<span class="line-modified">!       for (int i = 0; i &lt; length; i++) {</span>
<span class="line-modified">!         array[i] += tp-&gt;_jvmci_counters[i];</span>
        }
      }
    }
  }
  
<span class="line-added">+ // Attempt to enlarge the array for per thread counters.</span>
<span class="line-added">+ jlong* resize_counters_array(jlong* old_counters, int current_size, int new_size) {</span>
<span class="line-added">+   jlong* new_counters = NEW_C_HEAP_ARRAY(jlong, new_size, mtJVMCI);</span>
<span class="line-added">+   if (old_counters == NULL) {</span>
<span class="line-added">+     old_counters = new_counters;</span>
<span class="line-added">+     memset(old_counters, 0, sizeof(jlong) * new_size);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     for (int i = 0; i &lt; MIN2((int) current_size, new_size); i++) {</span>
<span class="line-added">+       new_counters[i] = old_counters[i];</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (new_size &gt; current_size) {</span>
<span class="line-added">+       memset(new_counters + current_size, 0, sizeof(jlong) * (new_size - current_size));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     FREE_C_HEAP_ARRAY(jlong, old_counters);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return new_counters;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Attempt to enlarge the array for per thread counters.</span>
<span class="line-added">+ void JavaThread::resize_counters(int current_size, int new_size) {</span>
<span class="line-added">+   _jvmci_counters = resize_counters_array(_jvmci_counters, current_size, new_size);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class VM_JVMCIResizeCounters : public VM_Operation {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   int _new_size;</span>
<span class="line-added">+ </span>
<span class="line-added">+  public:</span>
<span class="line-added">+   VM_JVMCIResizeCounters(int new_size) : _new_size(new_size) { }</span>
<span class="line-added">+   VMOp_Type type()                  const        { return VMOp_JVMCIResizeCounters; }</span>
<span class="line-added">+   bool allow_nested_vm_operations() const        { return true; }</span>
<span class="line-added">+   void doit() {</span>
<span class="line-added">+     // Resize the old thread counters array</span>
<span class="line-added">+     jlong* new_counters = resize_counters_array(JavaThread::_jvmci_old_thread_counters, JVMCICounterSize, _new_size);</span>
<span class="line-added">+     JavaThread::_jvmci_old_thread_counters = new_counters;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Now resize each threads array</span>
<span class="line-added">+     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *tp = jtiwh.next(); ) {</span>
<span class="line-added">+       tp-&gt;resize_counters(JVMCICounterSize, _new_size);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     JVMCICounterSize = _new_size;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JavaThread::resize_all_jvmci_counters(int new_size) {</span>
<span class="line-added">+   VM_JVMCIResizeCounters op(new_size);</span>
<span class="line-added">+   VMThread::execute(&amp;op);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #endif // INCLUDE_JVMCI
  
  // A JavaThread is a normal Java thread
  
  void JavaThread::initialize() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1604,15 ***</span>
    set_vframe_array_head(NULL);
    set_vframe_array_last(NULL);
    set_deferred_locals(NULL);
    set_deopt_mark(NULL);
    set_deopt_compiled_method(NULL);
<span class="line-removed">-   clear_must_deopt_id();</span>
    set_monitor_chunks(NULL);
<span class="line-removed">-   set_next(NULL);</span>
    _on_thread_list = false;
<span class="line-modified">!   set_thread_state(_thread_new);</span>
    _terminated = _not_terminated;
    _array_for_gc = NULL;
    _suspend_equivalent = false;
    _in_deopt_handler = 0;
    _doing_unsafe_access = false;
<span class="line-new-header">--- 1651,13 ---</span>
    set_vframe_array_head(NULL);
    set_vframe_array_last(NULL);
    set_deferred_locals(NULL);
    set_deopt_mark(NULL);
    set_deopt_compiled_method(NULL);
    set_monitor_chunks(NULL);
    _on_thread_list = false;
<span class="line-modified">!   _thread_state = _thread_new;</span>
    _terminated = _not_terminated;
    _array_for_gc = NULL;
    _suspend_equivalent = false;
    _in_deopt_handler = 0;
    _doing_unsafe_access = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1620,19 ***</span>
  #if INCLUDE_JVMCI
    _pending_monitorenter = false;
    _pending_deoptimization = -1;
    _pending_failed_speculation = 0;
    _pending_transfer_to_interpreter = false;
<span class="line-removed">-   _adjusting_comp_level = false;</span>
    _in_retryable_allocation = false;
    _jvmci._alternate_call_target = NULL;
    assert(_jvmci._implicit_exception_pc == NULL, &quot;must be&quot;);
    if (JVMCICounterSize &gt; 0) {
<span class="line-modified">!     _jvmci_counters = NEW_C_HEAP_ARRAY(jlong, JVMCICounterSize, mtInternal);</span>
<span class="line-removed">-     memset(_jvmci_counters, 0, sizeof(jlong) * JVMCICounterSize);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     _jvmci_counters = NULL;</span>
    }
  #endif // INCLUDE_JVMCI
    _reserved_stack_activation = NULL;  // stack base not known yet
    (void)const_cast&lt;oop&amp;&gt;(_exception_oop = oop(NULL));
    _exception_pc  = 0;
<span class="line-new-header">--- 1665,16 ---</span>
  #if INCLUDE_JVMCI
    _pending_monitorenter = false;
    _pending_deoptimization = -1;
    _pending_failed_speculation = 0;
    _pending_transfer_to_interpreter = false;
    _in_retryable_allocation = false;
    _jvmci._alternate_call_target = NULL;
    assert(_jvmci._implicit_exception_pc == NULL, &quot;must be&quot;);
<span class="line-added">+   _jvmci_counters = NULL;</span>
    if (JVMCICounterSize &gt; 0) {
<span class="line-modified">!     resize_counters(0, (int) JVMCICounterSize);</span>
    }
  #endif // INCLUDE_JVMCI
    _reserved_stack_activation = NULL;  // stack base not known yet
    (void)const_cast&lt;oop&amp;&gt;(_exception_oop = oop(NULL));
    _exception_pc  = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1643,24 ***</span>
    _interp_only_mode    = 0;
    _special_runtime_exit_condition = _no_async_condition;
    _pending_async_exception = NULL;
    _thread_stat = NULL;
    _thread_stat = new ThreadStatistics();
<span class="line-removed">-   _blocked_on_compilation = false;</span>
    _jni_active_critical = 0;
    _pending_jni_exception_check_fn = NULL;
    _do_not_unlock_if_synchronized = false;
    _cached_monitor_info = NULL;
    _parker = Parker::Allocate(this);
<span class="line-modified">! </span>
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-   _jmp_ring_index = 0;</span>
<span class="line-removed">-   for (int ji = 0; ji &lt; jump_ring_buffer_size; ji++) {</span>
<span class="line-removed">-     record_jump(NULL, NULL, NULL, 0);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif // PRODUCT</span>
<span class="line-removed">- </span>
    // Setup safepoint state info for this thread
    ThreadSafepointState::create(this);
  
    debug_only(_java_call_counter = 0);
  
<span class="line-new-header">--- 1685,16 ---</span>
    _interp_only_mode    = 0;
    _special_runtime_exit_condition = _no_async_condition;
    _pending_async_exception = NULL;
    _thread_stat = NULL;
    _thread_stat = new ThreadStatistics();
    _jni_active_critical = 0;
    _pending_jni_exception_check_fn = NULL;
    _do_not_unlock_if_synchronized = false;
    _cached_monitor_info = NULL;
    _parker = Parker::Allocate(this);
<span class="line-modified">!   _SleepEvent = ParkEvent::Allocate(this);</span>
    // Setup safepoint state info for this thread
    ThreadSafepointState::create(this);
  
    debug_only(_java_call_counter = 0);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1688,10 ***</span>
<span class="line-new-header">--- 1722,68 ---</span>
      _jni_attach_state = _not_attaching_via_jni;
    }
    assert(deferred_card_mark().is_empty(), &quot;Default MemRegion ctor&quot;);
  }
  
<span class="line-added">+ </span>
<span class="line-added">+ // interrupt support</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JavaThread::interrupt() {</span>
<span class="line-added">+   debug_only(check_for_dangling_thread_pointer(this);)</span>
<span class="line-added">+ </span>
<span class="line-added">+   // For Windows _interrupt_event</span>
<span class="line-added">+   osthread()-&gt;set_interrupted(true);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // For Thread.sleep</span>
<span class="line-added">+   _SleepEvent-&gt;unpark();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // For JSR166 LockSupport.park</span>
<span class="line-added">+   parker()-&gt;unpark();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // For ObjectMonitor and JvmtiRawMonitor</span>
<span class="line-added">+   _ParkEvent-&gt;unpark();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ bool JavaThread::is_interrupted(bool clear_interrupted) {</span>
<span class="line-added">+   debug_only(check_for_dangling_thread_pointer(this);)</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (threadObj() == NULL) {</span>
<span class="line-added">+     // If there is no j.l.Thread then it is impossible to have</span>
<span class="line-added">+     // been interrupted. We can find NULL during VM initialization</span>
<span class="line-added">+     // or when a JNI thread is still in the process of attaching.</span>
<span class="line-added">+     // In such cases this must be the current thread.</span>
<span class="line-added">+     assert(this == Thread::current(), &quot;invariant&quot;);</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool interrupted = java_lang_Thread::interrupted(threadObj());</span>
<span class="line-added">+ </span>
<span class="line-added">+   // NOTE that since there is no &quot;lock&quot; around the interrupt and</span>
<span class="line-added">+   // is_interrupted operations, there is the possibility that the</span>
<span class="line-added">+   // interrupted flag will be &quot;false&quot; but that the</span>
<span class="line-added">+   // low-level events will be in the signaled state. This is</span>
<span class="line-added">+   // intentional. The effect of this is that Object.wait() and</span>
<span class="line-added">+   // LockSupport.park() will appear to have a spurious wakeup, which</span>
<span class="line-added">+   // is allowed and not harmful, and the possibility is so rare that</span>
<span class="line-added">+   // it is not worth the added complexity to add yet another lock.</span>
<span class="line-added">+   // For the sleep event an explicit reset is performed on entry</span>
<span class="line-added">+   // to JavaThread::sleep, so there is no early return. It has also been</span>
<span class="line-added">+   // recommended not to put the interrupted flag into the &quot;event&quot;</span>
<span class="line-added">+   // structure because it hides the issue.</span>
<span class="line-added">+   // Also, because there is no lock, we must only clear the interrupt</span>
<span class="line-added">+   // state if we are going to report that we were interrupted; otherwise</span>
<span class="line-added">+   // an interrupt that happens just after we read the field would be lost.</span>
<span class="line-added">+   if (interrupted &amp;&amp; clear_interrupted) {</span>
<span class="line-added">+     assert(this == Thread::current(), &quot;only the current thread can clear&quot;);</span>
<span class="line-added">+     java_lang_Thread::set_interrupted(threadObj(), false);</span>
<span class="line-added">+     osthread()-&gt;set_interrupted(false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return interrupted;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool JavaThread::reguard_stack(address cur_sp) {
    if (_stack_guard_state != stack_guard_yellow_reserved_disabled
        &amp;&amp; _stack_guard_state != stack_guard_reserved_disabled) {
      return true; // Stack already guarded or guard pages not needed.
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1725,15 ***</span>
  bool JavaThread::reguard_stack(void) {
    return reguard_stack(os::current_stack_pointer());
  }
  
  
  void JavaThread::block_if_vm_exited() {
    if (_terminated == _vm_exited) {
      // _vm_exited is set at safepoint, and Threads_lock is never released
<span class="line-modified">!     // we will block here forever</span>
<span class="line-modified">!     Threads_lock-&gt;lock_without_safepoint_check();</span>
      ShouldNotReachHere();
    }
  }
  
  
<span class="line-new-header">--- 1817,26 ---</span>
  bool JavaThread::reguard_stack(void) {
    return reguard_stack(os::current_stack_pointer());
  }
  
  
<span class="line-added">+ // Check for adr in the usable portion of this thread&#39;s stack.</span>
<span class="line-added">+ bool JavaThread::is_in_usable_stack(address adr) const {</span>
<span class="line-added">+   size_t stack_guard_size = os::uses_stack_guard_pages() ? JavaThread::stack_guard_zone_size() : 0;</span>
<span class="line-added">+   size_t usable_stack_size = _stack_size - stack_guard_size;</span>
<span class="line-added">+ </span>
<span class="line-added">+   return ((stack_base() &gt; adr) &amp;&amp; (adr &gt;= (stack_base() - usable_stack_size)));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JavaThread::block_if_vm_exited() {
    if (_terminated == _vm_exited) {
      // _vm_exited is set at safepoint, and Threads_lock is never released
<span class="line-modified">!     // we will block here forever.</span>
<span class="line-modified">!     // Here we can be doing a jump from a safe state to an unsafe state without</span>
<span class="line-added">+     // proper transition, but it happens after the final safepoint has begun.</span>
<span class="line-added">+     set_thread_state(_thread_in_vm);</span>
<span class="line-added">+     Threads_lock-&gt;lock();</span>
      ShouldNotReachHere();
    }
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1768,10 ***</span>
<span class="line-new-header">--- 1871,14 ---</span>
  
    // JSR166 -- return the parker to the free list
    Parker::Release(_parker);
    _parker = NULL;
  
<span class="line-added">+   // Return the sleep event to the free list</span>
<span class="line-added">+   ParkEvent::Release(_SleepEvent);</span>
<span class="line-added">+   _SleepEvent = NULL;</span>
<span class="line-added">+ </span>
    // Free any remaining  previous UnrollBlock
    vframeArray* old_array = vframe_array_last();
  
    if (old_array != NULL) {
      Deoptimization::UnrollBlock* old_info = old_array-&gt;unroll_block();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1833,11 ***</span>
  
    this-&gt;cache_global_variables();
  
    // Thread is now sufficiently initialized to be handled by the safepoint code as being
    // in the VM. Change thread state from _thread_new to _thread_in_vm
<span class="line-modified">!   ThreadStateTransition::transition_and_fence(this, _thread_new, _thread_in_vm);</span>
  
    assert(JavaThread::current() == this, &quot;sanity check&quot;);
    assert(!Thread::current()-&gt;owns_locks(), &quot;sanity check&quot;);
  
    DTRACE_THREAD_PROBE(start, this);
<span class="line-new-header">--- 1940,15 ---</span>
  
    this-&gt;cache_global_variables();
  
    // Thread is now sufficiently initialized to be handled by the safepoint code as being
    // in the VM. Change thread state from _thread_new to _thread_in_vm
<span class="line-modified">!   ThreadStateTransition::transition(this, _thread_new, _thread_in_vm);</span>
<span class="line-added">+   // Before a thread is on the threads list it is always safe, so after leaving the</span>
<span class="line-added">+   // _thread_new we should emit a instruction barrier. The distance to modified code</span>
<span class="line-added">+   // from here is probably far enough, but this is consistent and safe.</span>
<span class="line-added">+   OrderAccess::cross_modify_fence();</span>
  
    assert(JavaThread::current() == this, &quot;sanity check&quot;);
    assert(!Thread::current()-&gt;owns_locks(), &quot;sanity check&quot;);
  
    DTRACE_THREAD_PROBE(start, this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1982,11 ***</span>
      // We have notified the agents that we are exiting, before we go on,
      // we must check for a pending external suspend request and honor it
      // in order to not surprise the thread that made the suspend request.
      while (true) {
        {
<span class="line-modified">!         MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
          if (!is_external_suspend()) {
            set_terminated(_thread_exiting);
            ThreadService::current_thread_exiting(this, is_daemon(threadObj()));
            break;
          }
<span class="line-new-header">--- 2093,11 ---</span>
      // We have notified the agents that we are exiting, before we go on,
      // we must check for a pending external suspend request and honor it
      // in order to not surprise the thread that made the suspend request.
      while (true) {
        {
<span class="line-modified">!         MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
          if (!is_external_suspend()) {
            set_terminated(_thread_exiting);
            ThreadService::current_thread_exiting(this, is_daemon(threadObj()));
            break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2013,10 ***</span>
<span class="line-new-header">--- 2124,14 ---</span>
  
    if (log_is_enabled(Debug, os, thread, timer)) {
      _timer_exit_phase1.stop();
      _timer_exit_phase2.start();
    }
<span class="line-added">+ </span>
<span class="line-added">+   // Capture daemon status before the thread is marked as terminated.</span>
<span class="line-added">+   bool daemon = is_daemon(threadObj());</span>
<span class="line-added">+ </span>
    // Notify waiters on thread object. This has to be done after exit() is called
    // on the thread (if the thread is the last thread in a daemon ThreadGroup the
    // group should have the destroyed bit set before waiters are notified).
    ensure_join(this);
    assert(!this-&gt;has_pending_exception(), &quot;ensure_join should have cleared&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2081,11 ***</span>
    if (log_is_enabled(Debug, os, thread, timer)) {
      _timer_exit_phase3.stop();
      _timer_exit_phase4.start();
    }
    // Remove from list of active threads list, and notify VM thread if we are the last non-daemon thread
<span class="line-modified">!   Threads::remove(this);</span>
  
    if (log_is_enabled(Debug, os, thread, timer)) {
      _timer_exit_phase4.stop();
      ResourceMark rm(this);
      log_debug(os, thread, timer)(&quot;name=&#39;%s&#39;&quot;
<span class="line-new-header">--- 2196,11 ---</span>
    if (log_is_enabled(Debug, os, thread, timer)) {
      _timer_exit_phase3.stop();
      _timer_exit_phase4.start();
    }
    // Remove from list of active threads list, and notify VM thread if we are the last non-daemon thread
<span class="line-modified">!   Threads::remove(this, daemon);</span>
  
    if (log_is_enabled(Debug, os, thread, timer)) {
      _timer_exit_phase4.stop();
      ResourceMark rm(this);
      log_debug(os, thread, timer)(&quot;name=&#39;%s&#39;&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2099,11 ***</span>
                                   _timer_exit_phase3.milliseconds(),
                                   _timer_exit_phase4.milliseconds());
    }
  }
  
<span class="line-modified">! void JavaThread::cleanup_failed_attach_current_thread() {</span>
    if (active_handles() != NULL) {
      JNIHandleBlock* block = active_handles();
      set_active_handles(NULL);
      JNIHandleBlock::release_block(block);
    }
<span class="line-new-header">--- 2214,11 ---</span>
                                   _timer_exit_phase3.milliseconds(),
                                   _timer_exit_phase4.milliseconds());
    }
  }
  
<span class="line-modified">! void JavaThread::cleanup_failed_attach_current_thread(bool is_daemon) {</span>
    if (active_handles() != NULL) {
      JNIHandleBlock* block = active_handles();
      set_active_handles(NULL);
      JNIHandleBlock::release_block(block);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2121,11 ***</span>
      tlab().retire();
    }
  
    BarrierSet::barrier_set()-&gt;on_thread_detach(this);
  
<span class="line-modified">!   Threads::remove(this);</span>
    this-&gt;smr_delete();
  }
  
  JavaThread* JavaThread::active() {
    Thread* thread = Thread::current();
<span class="line-new-header">--- 2236,11 ---</span>
      tlab().retire();
    }
  
    BarrierSet::barrier_set()-&gt;on_thread_detach(this);
  
<span class="line-modified">!   Threads::remove(this, is_daemon);</span>
    this-&gt;smr_delete();
  }
  
  JavaThread* JavaThread::active() {
    Thread* thread = Thread::current();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2261,64 ***</span>
           (!check_unsafe_error &amp;&amp; condition == _async_unsafe_access_error),
           &quot;must have handled the async condition, if no exception&quot;);
  }
  
  void JavaThread::handle_special_runtime_exit_condition(bool check_asyncs) {
<span class="line-removed">-   //</span>
<span class="line-removed">-   // Check for pending external suspend. Internal suspend requests do</span>
<span class="line-removed">-   // not use handle_special_runtime_exit_condition().</span>
<span class="line-removed">-   // If JNIEnv proxies are allowed, don&#39;t self-suspend if the target</span>
<span class="line-removed">-   // thread is not the current thread. In older versions of jdbx, jdbx</span>
<span class="line-removed">-   // threads could call into the VM with another thread&#39;s JNIEnv so we</span>
<span class="line-removed">-   // can be here operating on behalf of a suspended thread (4432884).</span>
<span class="line-removed">-   bool do_self_suspend = is_external_suspend_with_lock();</span>
<span class="line-removed">-   if (do_self_suspend &amp;&amp; (!AllowJNIEnvProxy || this == JavaThread::current())) {</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // Because thread is external suspended the safepoint code will count</span>
<span class="line-removed">-     // thread as at a safepoint. This can be odd because we can be here</span>
<span class="line-removed">-     // as _thread_in_Java which would normally transition to _thread_blocked</span>
<span class="line-removed">-     // at a safepoint. We would like to mark the thread as _thread_blocked</span>
<span class="line-removed">-     // before calling java_suspend_self like all other callers of it but</span>
<span class="line-removed">-     // we must then observe proper safepoint protocol. (We can&#39;t leave</span>
<span class="line-removed">-     // _thread_blocked with a safepoint in progress). However we can be</span>
<span class="line-removed">-     // here as _thread_in_native_trans so we can&#39;t use a normal transition</span>
<span class="line-removed">-     // constructor/destructor pair because they assert on that type of</span>
<span class="line-removed">-     // transition. We could do something like:</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // JavaThreadState state = thread_state();</span>
<span class="line-removed">-     // set_thread_state(_thread_in_vm);</span>
<span class="line-removed">-     // {</span>
<span class="line-removed">-     //   ThreadBlockInVM tbivm(this);</span>
<span class="line-removed">-     //   java_suspend_self()</span>
<span class="line-removed">-     // }</span>
<span class="line-removed">-     // set_thread_state(_thread_in_vm_trans);</span>
<span class="line-removed">-     // if (safepoint) block;</span>
<span class="line-removed">-     // set_thread_state(state);</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // but that is pretty messy. Instead we just go with the way the</span>
<span class="line-removed">-     // code has worked before and note that this is the only path to</span>
<span class="line-removed">-     // java_suspend_self that doesn&#39;t put the thread in _thread_blocked</span>
<span class="line-removed">-     // mode.</span>
  
      frame_anchor()-&gt;make_walkable(this);
<span class="line-modified">!     java_suspend_self();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We might be here for reasons in addition to the self-suspend request</span>
<span class="line-removed">-     // so check for other async requests.</span>
    }
  
    if (check_asyncs) {
      check_and_handle_async_exceptions();
    }
  
    JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(this);)
  }
  
  void JavaThread::send_thread_stop(oop java_throwable)  {
<span class="line-modified">!   assert(Thread::current()-&gt;is_VM_thread(), &quot;should be in the vm thread&quot;);</span>
<span class="line-modified">!   assert(Threads_lock-&gt;is_locked(), &quot;Threads_lock should be locked by safepoint code&quot;);</span>
<span class="line-removed">-   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);</span>
  
    // Do not throw asynchronous exceptions against the compiler thread
    // (the compiler thread should not be a Java thread -- fix in 1.4.2)
    if (!can_call_java()) return;
  
<span class="line-new-header">--- 2376,29 ---</span>
           (!check_unsafe_error &amp;&amp; condition == _async_unsafe_access_error),
           &quot;must have handled the async condition, if no exception&quot;);
  }
  
  void JavaThread::handle_special_runtime_exit_condition(bool check_asyncs) {
  
<span class="line-added">+   // Check for pending external suspend.</span>
<span class="line-added">+   if (is_external_suspend_with_lock()) {</span>
      frame_anchor()-&gt;make_walkable(this);
<span class="line-modified">!     java_suspend_self_with_safepoint_check();</span>
    }
  
<span class="line-added">+   // We might be here for reasons in addition to the self-suspend request</span>
<span class="line-added">+   // so check for other async requests.</span>
    if (check_asyncs) {
      check_and_handle_async_exceptions();
    }
  
    JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(this);)
  }
  
  void JavaThread::send_thread_stop(oop java_throwable)  {
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   assert(Thread::current()-&gt;is_VM_thread() || Thread::current() == this, &quot;should be in the vm thread&quot;);</span>
  
    // Do not throw asynchronous exceptions against the compiler thread
    // (the compiler thread should not be a Java thread -- fix in 1.4.2)
    if (!can_call_java()) return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2331,15 ***</span>
        // must deoptimize the caller before continuing, as the compiled  exception handler table
        // may not be valid
        if (has_last_Java_frame()) {
          frame f = last_frame();
          if (f.is_runtime_frame() || f.is_safepoint_blob_frame()) {
<span class="line-modified">!           // BiasedLocking needs an updated RegisterMap for the revoke monitors pass</span>
<span class="line-removed">-           RegisterMap reg_map(this, UseBiasedLocking);</span>
            frame compiled_frame = f.sender(&amp;reg_map);
            if (!StressCompiledExceptionHandlers &amp;&amp; compiled_frame.can_be_deoptimized()) {
<span class="line-modified">!             Deoptimization::deoptimize(this, compiled_frame, &amp;reg_map);</span>
            }
          }
        }
  
        // Set async. pending exception in thread.
<span class="line-new-header">--- 2411,14 ---</span>
        // must deoptimize the caller before continuing, as the compiled  exception handler table
        // may not be valid
        if (has_last_Java_frame()) {
          frame f = last_frame();
          if (f.is_runtime_frame() || f.is_safepoint_blob_frame()) {
<span class="line-modified">!           RegisterMap reg_map(this, false);</span>
            frame compiled_frame = f.sender(&amp;reg_map);
            if (!StressCompiledExceptionHandlers &amp;&amp; compiled_frame.can_be_deoptimized()) {
<span class="line-modified">!             Deoptimization::deoptimize(this, compiled_frame);</span>
            }
          }
        }
  
        // Set async. pending exception in thread.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2354,12 ***</span>
        Exceptions::debug_check_abort(_pending_async_exception-&gt;klass()-&gt;external_name());
      }
    }
  
  
<span class="line-modified">!   // Interrupt thread so it will wake up from a potential wait()</span>
<span class="line-modified">!   Thread::interrupt(this);</span>
  }
  
  // External suspension mechanism.
  //
  // Tell the VM to suspend a thread when ever it knows that it does not hold on
<span class="line-new-header">--- 2433,13 ---</span>
        Exceptions::debug_check_abort(_pending_async_exception-&gt;klass()-&gt;external_name());
      }
    }
  
  
<span class="line-modified">!   // Interrupt thread so it will wake up from a potential wait()/sleep()/park()</span>
<span class="line-modified">!   java_lang_Thread::set_interrupted(threadObj(), true);</span>
<span class="line-added">+   this-&gt;interrupt();</span>
  }
  
  // External suspension mechanism.
  //
  // Tell the VM to suspend a thread when ever it knows that it does not hold on
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2376,11 ***</span>
    ThreadsListHandle tlh;
    if (!tlh.includes(this) || threadObj() == NULL || is_exiting()) {
      return;
    }
  
<span class="line-modified">!   { MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      if (!is_external_suspend()) {
        // a racing resume has cancelled us; bail out now
        return;
      }
  
<span class="line-new-header">--- 2456,11 ---</span>
    ThreadsListHandle tlh;
    if (!tlh.includes(this) || threadObj() == NULL || is_exiting()) {
      return;
    }
  
<span class="line-modified">!   { MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
      if (!is_external_suspend()) {
        // a racing resume has cancelled us; bail out now
        return;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2422,10 ***</span>
<span class="line-new-header">--- 2502,11 ---</span>
  //       thread. java_suspend_self() is the second stage of cooperative
  //       suspension for external suspend requests and should only be used
  //       to complete an external suspend request.
  //
  int JavaThread::java_suspend_self() {
<span class="line-added">+   assert(thread_state() == _thread_blocked, &quot;wrong state for java_suspend_self()&quot;);</span>
    int ret = 0;
  
    // we are in the process of exiting so don&#39;t suspend
    if (is_exiting()) {
      clear_external_suspend();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2434,11 ***</span>
  
    assert(_anchor.walkable() ||
           (is_Java_thread() &amp;&amp; !((JavaThread*)this)-&gt;has_last_Java_frame()),
           &quot;must have walkable stack&quot;);
  
<span class="line-modified">!   MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
  
    assert(!this-&gt;is_ext_suspended(),
           &quot;a thread trying to self-suspend should not already be suspended&quot;);
  
    if (this-&gt;is_suspend_equivalent()) {
<span class="line-new-header">--- 2515,11 ---</span>
  
    assert(_anchor.walkable() ||
           (is_Java_thread() &amp;&amp; !((JavaThread*)this)-&gt;has_last_Java_frame()),
           &quot;must have walkable stack&quot;);
  
<span class="line-modified">!   MonitorLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
  
    assert(!this-&gt;is_ext_suspended(),
           &quot;a thread trying to self-suspend should not already be suspended&quot;);
  
    if (this-&gt;is_suspend_equivalent()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2462,17 ***</span>
      ret++;
      this-&gt;set_ext_suspended();
  
      // _ext_suspended flag is cleared by java_resume()
      while (is_ext_suspended()) {
<span class="line-modified">!       this-&gt;SR_lock()-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
      }
    }
<span class="line-removed">- </span>
    return ret;
  }
  
  #ifdef ASSERT
  // Verify the JavaThread has not yet been published in the Threads::list, and
  // hence doesn&#39;t need protection from concurrent access at this stage.
  void JavaThread::verify_not_published() {
    // Cannot create a ThreadsListHandle here and check !tlh.includes(this)
<span class="line-new-header">--- 2543,48 ---</span>
      ret++;
      this-&gt;set_ext_suspended();
  
      // _ext_suspended flag is cleared by java_resume()
      while (is_ext_suspended()) {
<span class="line-modified">!       ml.wait();</span>
      }
    }
    return ret;
  }
  
<span class="line-added">+ // Helper routine to set up the correct thread state before calling java_suspend_self.</span>
<span class="line-added">+ // This is called when regular thread-state transition helpers can&#39;t be used because</span>
<span class="line-added">+ // we can be in various states, in particular _thread_in_native_trans.</span>
<span class="line-added">+ // Because this thread is external suspended the safepoint code will count it as at</span>
<span class="line-added">+ // a safepoint, regardless of what its actual current thread-state is. But</span>
<span class="line-added">+ // is_ext_suspend_completed() may be waiting to see a thread transition from</span>
<span class="line-added">+ // _thread_in_native_trans to _thread_blocked. So we set the thread state directly</span>
<span class="line-added">+ // to _thread_blocked. The problem with setting thread state directly is that a</span>
<span class="line-added">+ // safepoint could happen just after java_suspend_self() returns after being resumed,</span>
<span class="line-added">+ // and the VM thread will see the _thread_blocked state. So we must check for a safepoint</span>
<span class="line-added">+ // after restoring the state to make sure we won&#39;t leave while a safepoint is in progress.</span>
<span class="line-added">+ // However, not all initial-states are allowed when performing a safepoint check, as we</span>
<span class="line-added">+ // should never be blocking at a safepoint whilst in those states. Of these &#39;bad&#39; states</span>
<span class="line-added">+ // only _thread_in_native is possible when executing this code (based on our two callers).</span>
<span class="line-added">+ // A thread that is _thread_in_native is already safepoint-safe and so it doesn&#39;t matter</span>
<span class="line-added">+ // whether the VMThread sees the _thread_blocked state, or the _thread_in_native state,</span>
<span class="line-added">+ // and so we don&#39;t need the explicit safepoint check.</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JavaThread::java_suspend_self_with_safepoint_check() {</span>
<span class="line-added">+   assert(this == Thread::current(), &quot;invariant&quot;);</span>
<span class="line-added">+   JavaThreadState state = thread_state();</span>
<span class="line-added">+   set_thread_state(_thread_blocked);</span>
<span class="line-added">+   java_suspend_self();</span>
<span class="line-added">+   set_thread_state_fence(state);</span>
<span class="line-added">+   // Since we are not using a regular thread-state transition helper here,</span>
<span class="line-added">+   // we must manually emit the instruction barrier after leaving a safe state.</span>
<span class="line-added">+   OrderAccess::cross_modify_fence();</span>
<span class="line-added">+   if (state != _thread_in_native) {</span>
<span class="line-added">+     SafepointMechanism::block_if_requested(this);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #ifdef ASSERT
  // Verify the JavaThread has not yet been published in the Threads::list, and
  // hence doesn&#39;t need protection from concurrent access at this stage.
  void JavaThread::verify_not_published() {
    // Cannot create a ThreadsListHandle here and check !tlh.includes(this)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2490,60 ***</span>
  // Note only the ThreadInVMfromNative transition can call this function
  // directly and when thread state is _thread_in_native_trans
  void JavaThread::check_safepoint_and_suspend_for_native_trans(JavaThread *thread) {
    assert(thread-&gt;thread_state() == _thread_in_native_trans, &quot;wrong state&quot;);
  
<span class="line-modified">!   JavaThread *curJT = JavaThread::current();</span>
<span class="line-modified">!   bool do_self_suspend = thread-&gt;is_external_suspend();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   assert(!curJT-&gt;has_last_Java_frame() || curJT-&gt;frame_anchor()-&gt;walkable(), &quot;Unwalkable stack in native-&gt;vm transition&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // If JNIEnv proxies are allowed, don&#39;t self-suspend if the target</span>
<span class="line-removed">-   // thread is not the current thread. In older versions of jdbx, jdbx</span>
<span class="line-removed">-   // threads could call into the VM with another thread&#39;s JNIEnv so we</span>
<span class="line-removed">-   // can be here operating on behalf of a suspended thread (4432884).</span>
<span class="line-removed">-   if (do_self_suspend &amp;&amp; (!AllowJNIEnvProxy || curJT == thread)) {</span>
<span class="line-removed">-     JavaThreadState state = thread-&gt;thread_state();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We mark this thread_blocked state as a suspend-equivalent so</span>
<span class="line-removed">-     // that a caller to is_ext_suspend_completed() won&#39;t be confused.</span>
<span class="line-removed">-     // The suspend-equivalent state is cleared by java_suspend_self().</span>
<span class="line-removed">-     thread-&gt;set_suspend_equivalent();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If the safepoint code sees the _thread_in_native_trans state, it will</span>
<span class="line-removed">-     // wait until the thread changes to other thread state. There is no</span>
<span class="line-removed">-     // guarantee on how soon we can obtain the SR_lock and complete the</span>
<span class="line-removed">-     // self-suspend request. It would be a bad idea to let safepoint wait for</span>
<span class="line-removed">-     // too long. Temporarily change the state to _thread_blocked to</span>
<span class="line-removed">-     // let the VM thread know that this thread is ready for GC. The problem</span>
<span class="line-removed">-     // of changing thread state is that safepoint could happen just after</span>
<span class="line-removed">-     // java_suspend_self() returns after being resumed, and VM thread will</span>
<span class="line-removed">-     // see the _thread_blocked state. We must check for safepoint</span>
<span class="line-removed">-     // after restoring the state and make sure we won&#39;t leave while a safepoint</span>
<span class="line-removed">-     // is in progress.</span>
<span class="line-removed">-     thread-&gt;set_thread_state(_thread_blocked);</span>
<span class="line-removed">-     thread-&gt;java_suspend_self();</span>
<span class="line-removed">-     thread-&gt;set_thread_state(state);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     InterfaceSupport::serialize_thread_state_with_handler(thread);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   SafepointMechanism::block_if_requested(curJT);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (thread-&gt;is_deopt_suspend()) {</span>
<span class="line-removed">-     thread-&gt;clear_deopt_suspend();</span>
<span class="line-removed">-     RegisterMap map(thread, false);</span>
<span class="line-removed">-     frame f = thread-&gt;last_frame();</span>
<span class="line-removed">-     while (f.id() != thread-&gt;must_deopt_id() &amp;&amp; ! f.is_first_frame()) {</span>
<span class="line-removed">-       f = f.sender(&amp;map);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (f.id() == thread-&gt;must_deopt_id()) {</span>
<span class="line-removed">-       thread-&gt;clear_must_deopt_id();</span>
<span class="line-removed">-       f.deoptimize(thread);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       fatal(&quot;missed deoptimization!&quot;);</span>
<span class="line-removed">-     }</span>
    }
  
    JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(thread);)
  }
  
<span class="line-new-header">--- 2602,16 ---</span>
  // Note only the ThreadInVMfromNative transition can call this function
  // directly and when thread state is _thread_in_native_trans
  void JavaThread::check_safepoint_and_suspend_for_native_trans(JavaThread *thread) {
    assert(thread-&gt;thread_state() == _thread_in_native_trans, &quot;wrong state&quot;);
  
<span class="line-modified">!   assert(!thread-&gt;has_last_Java_frame() || thread-&gt;frame_anchor()-&gt;walkable(), &quot;Unwalkable stack in native-&gt;vm transition&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (thread-&gt;is_external_suspend()) {</span>
<span class="line-modified">!     thread-&gt;java_suspend_self_with_safepoint_check();</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     SafepointMechanism::block_if_requested(thread);</span>
    }
  
    JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(thread);)
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2595,11 ***</span>
    ThreadsListHandle tlh;
    if (!tlh.includes(this) || is_exiting() || !is_external_suspend()) {
      return;
    }
  
<span class="line-modified">!   MutexLockerEx ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
  
    clear_external_suspend();
  
    if (is_ext_suspended()) {
      clear_ext_suspended();
<span class="line-new-header">--- 2663,11 ---</span>
    ThreadsListHandle tlh;
    if (!tlh.includes(this) || is_exiting() || !is_external_suspend()) {
      return;
    }
  
<span class="line-modified">!   MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);</span>
  
    clear_external_suspend();
  
    if (is_ext_suspended()) {
      clear_ext_suspended();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2791,12 ***</span>
  
  #ifndef PRODUCT
  // Deoptimization
  // Function for testing deoptimization
  void JavaThread::deoptimize() {
<span class="line-modified">!   // BiasedLocking needs an updated RegisterMap for the revoke monitors pass</span>
<span class="line-removed">-   StackFrameStream fst(this, UseBiasedLocking);</span>
    bool deopt = false;           // Dump stack only if a deopt actually happens.
    bool only_at = strlen(DeoptimizeOnlyAt) &gt; 0;
    // Iterate over all frames in the thread and deoptimize
    for (; !fst.is_done(); fst.next()) {
      if (fst.current()-&gt;can_be_deoptimized()) {
<span class="line-new-header">--- 2859,11 ---</span>
  
  #ifndef PRODUCT
  // Deoptimization
  // Function for testing deoptimization
  void JavaThread::deoptimize() {
<span class="line-modified">!   StackFrameStream fst(this, false);</span>
    bool deopt = false;           // Dump stack only if a deopt actually happens.
    bool only_at = strlen(DeoptimizeOnlyAt) &gt; 0;
    // Iterate over all frames in the thread and deoptimize
    for (; !fst.is_done(); fst.next()) {
      if (fst.current()-&gt;can_be_deoptimized()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2829,11 ***</span>
          deopt = true; // One-time only print before deopt
          tty-&gt;print_cr(&quot;[BEFORE Deoptimization]&quot;);
          trace_frames();
          trace_stack();
        }
<span class="line-modified">!       Deoptimization::deoptimize(this, *fst.current(), fst.register_map());</span>
      }
    }
  
    if (DebugDeoptimization &amp;&amp; deopt) {
      tty-&gt;print_cr(&quot;[AFTER Deoptimization]&quot;);
<span class="line-new-header">--- 2896,11 ---</span>
          deopt = true; // One-time only print before deopt
          tty-&gt;print_cr(&quot;[BEFORE Deoptimization]&quot;);
          trace_frames();
          trace_stack();
        }
<span class="line-modified">!       Deoptimization::deoptimize(this, *fst.current());</span>
      }
    }
  
    if (DebugDeoptimization &amp;&amp; deopt) {
      tty-&gt;print_cr(&quot;[AFTER Deoptimization]&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2853,22 ***</span>
    }
  }
  #endif // PRODUCT
  
  
<span class="line-modified">! void JavaThread::deoptimized_wrt_marked_nmethods() {</span>
    if (!has_last_Java_frame()) return;
<span class="line-modified">!   // BiasedLocking needs an updated RegisterMap for the revoke monitors pass</span>
<span class="line-removed">-   StackFrameStream fst(this, UseBiasedLocking);</span>
    for (; !fst.is_done(); fst.next()) {
      if (fst.current()-&gt;should_be_deoptimized()) {
<span class="line-modified">!       Deoptimization::deoptimize(this, *fst.current(), fst.register_map());</span>
      }
    }
  }
  
<span class="line-removed">- </span>
  // If the caller is a NamedThread, then remember, in the current scope,
  // the given JavaThread in its _processed_thread field.
  class RememberProcessedThread: public StackObj {
    NamedThread* _cur_thr;
   public:
<span class="line-new-header">--- 2920,20 ---</span>
    }
  }
  #endif // PRODUCT
  
  
<span class="line-modified">! void JavaThread::deoptimize_marked_methods() {</span>
    if (!has_last_Java_frame()) return;
<span class="line-modified">!   StackFrameStream fst(this, false);</span>
    for (; !fst.is_done(); fst.next()) {
      if (fst.current()-&gt;should_be_deoptimized()) {
<span class="line-modified">!       Deoptimization::deoptimize(this, *fst.current());</span>
      }
    }
  }
  
  // If the caller is a NamedThread, then remember, in the current scope,
  // the given JavaThread in its _processed_thread field.
  class RememberProcessedThread: public StackObj {
    NamedThread* _cur_thr;
   public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2919,15 ***</span>
      for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {
        fst.current()-&gt;oops_do(f, cf, fst.register_map());
      }
    }
  
<span class="line-removed">-   // callee_target is never live across a gc point so NULL it here should</span>
<span class="line-removed">-   // it still contain a methdOop.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   set_callee_target(NULL);</span>
<span class="line-removed">- </span>
    assert(vframe_array_head() == NULL, &quot;deopt in progress at a safepoint!&quot;);
    // If we have deferred set_locals there might be oops waiting to be
    // written
    GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt;* list = deferred_locals();
    if (list != NULL) {
<span class="line-new-header">--- 2984,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2942,27 ***</span>
    f-&gt;do_oop((oop*) &amp;_vm_result);
    f-&gt;do_oop((oop*) &amp;_exception_oop);
    f-&gt;do_oop((oop*) &amp;_pending_async_exception);
  
    if (jvmti_thread_state() != NULL) {
<span class="line-modified">!     jvmti_thread_state()-&gt;oops_do(f);</span>
    }
  }
  
  void JavaThread::nmethods_do(CodeBlobClosure* cf) {
    assert((!has_last_Java_frame() &amp;&amp; java_call_counter() == 0) ||
<span class="line-modified">!          (has_last_Java_frame() &amp;&amp; java_call_counter() &gt; 0), &quot;wrong java_sp info!&quot;);</span>
  
    if (has_last_Java_frame()) {
      // Traverse the execution stack
      for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {
        fst.current()-&gt;nmethods_do(cf);
      }
    }
  }
  
<span class="line-modified">! void JavaThread::metadata_do(void f(Metadata*)) {</span>
    if (has_last_Java_frame()) {
      // Traverse the execution stack to call f() on the methods in the stack
      for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {
        fst.current()-&gt;metadata_do(f);
      }
<span class="line-new-header">--- 3002,43 ---</span>
    f-&gt;do_oop((oop*) &amp;_vm_result);
    f-&gt;do_oop((oop*) &amp;_exception_oop);
    f-&gt;do_oop((oop*) &amp;_pending_async_exception);
  
    if (jvmti_thread_state() != NULL) {
<span class="line-modified">!     jvmti_thread_state()-&gt;oops_do(f, cf);</span>
    }
  }
  
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+ void JavaThread::verify_states_for_handshake() {</span>
<span class="line-added">+   // This checks that the thread has a correct frame state during a handshake.</span>
<span class="line-added">+   assert((!has_last_Java_frame() &amp;&amp; java_call_counter() == 0) ||</span>
<span class="line-added">+          (has_last_Java_frame() &amp;&amp; java_call_counter() &gt; 0),</span>
<span class="line-added">+          &quot;unexpected frame info: has_last_frame=%d, java_call_counter=%d&quot;,</span>
<span class="line-added">+          has_last_Java_frame(), java_call_counter());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  void JavaThread::nmethods_do(CodeBlobClosure* cf) {
    assert((!has_last_Java_frame() &amp;&amp; java_call_counter() == 0) ||
<span class="line-modified">!          (has_last_Java_frame() &amp;&amp; java_call_counter() &gt; 0),</span>
<span class="line-added">+          &quot;unexpected frame info: has_last_frame=%d, java_call_counter=%d&quot;,</span>
<span class="line-added">+          has_last_Java_frame(), java_call_counter());</span>
  
    if (has_last_Java_frame()) {
      // Traverse the execution stack
      for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {
        fst.current()-&gt;nmethods_do(cf);
      }
    }
<span class="line-added">+ </span>
<span class="line-added">+   if (jvmti_thread_state() != NULL) {</span>
<span class="line-added">+     jvmti_thread_state()-&gt;nmethods_do(cf);</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! void JavaThread::metadata_do(MetadataClosure* f) {</span>
    if (has_last_Java_frame()) {
      // Traverse the execution stack to call f() on the methods in the stack
      for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {
        fst.current()-&gt;metadata_do(f);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2999,13 ***</span>
  
  #ifndef PRODUCT
  void JavaThread::print_thread_state_on(outputStream *st) const {
    st-&gt;print_cr(&quot;   JavaThread state: %s&quot;, _get_thread_state_name(_thread_state));
  };
<span class="line-removed">- void JavaThread::print_thread_state() const {</span>
<span class="line-removed">-   print_thread_state_on(tty);</span>
<span class="line-removed">- }</span>
  #endif // PRODUCT
  
  // Called by Threads::print() for VM_PrintThreads operation
  void JavaThread::print_on(outputStream *st, bool print_extended_info) const {
    st-&gt;print_raw(&quot;\&quot;&quot;);
<span class="line-new-header">--- 3075,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3036,10 ***</span>
<span class="line-new-header">--- 3109,12 ---</span>
      }
      st-&gt;cr();
    }
  }
  
<span class="line-added">+ void JavaThread::print() const { print_on(tty); }</span>
<span class="line-added">+ </span>
  void JavaThread::print_name_on_error(outputStream* st, char *buf, int buflen) const {
    st-&gt;print(&quot;%s&quot;, get_thread_name_string(buf, buflen));
  }
  
  // Called by fatal error handler. The difference between this and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3088,11 ***</span>
    if (!SafepointSynchronize::is_at_safepoint()) {
      Thread *cur = Thread::current();
      if (!(cur-&gt;is_Java_thread() &amp;&amp; cur == this)) {
        // Current JavaThreads are allowed to get their own name without
        // the Threads_lock.
<span class="line-modified">!       assert_locked_or_safepoint(Threads_lock);</span>
      }
    }
  #endif // ASSERT
    return get_thread_name_string();
  }
<span class="line-new-header">--- 3163,11 ---</span>
    if (!SafepointSynchronize::is_at_safepoint()) {
      Thread *cur = Thread::current();
      if (!(cur-&gt;is_Java_thread() &amp;&amp; cur == this)) {
        // Current JavaThreads are allowed to get their own name without
        // the Threads_lock.
<span class="line-modified">!       assert_locked_or_safepoint_or_handshake(Threads_lock, this);</span>
      }
    }
  #endif // ASSERT
    return get_thread_name_string();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3120,51 ***</span>
    }
    assert(name_str != NULL, &quot;unexpected NULL thread name&quot;);
    return name_str;
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- const char* JavaThread::get_threadgroup_name() const {</span>
<span class="line-removed">-   debug_only(if (JavaThread::current() != this) assert_locked_or_safepoint(Threads_lock);)</span>
<span class="line-removed">-   oop thread_obj = threadObj();</span>
<span class="line-removed">-   if (thread_obj != NULL) {</span>
<span class="line-removed">-     oop thread_group = java_lang_Thread::threadGroup(thread_obj);</span>
<span class="line-removed">-     if (thread_group != NULL) {</span>
<span class="line-removed">-       // ThreadGroup.name can be null</span>
<span class="line-removed">-       return java_lang_ThreadGroup::name(thread_group);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return NULL;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- const char* JavaThread::get_parent_name() const {</span>
<span class="line-removed">-   debug_only(if (JavaThread::current() != this) assert_locked_or_safepoint(Threads_lock);)</span>
<span class="line-removed">-   oop thread_obj = threadObj();</span>
<span class="line-removed">-   if (thread_obj != NULL) {</span>
<span class="line-removed">-     oop thread_group = java_lang_Thread::threadGroup(thread_obj);</span>
<span class="line-removed">-     if (thread_group != NULL) {</span>
<span class="line-removed">-       oop parent = java_lang_ThreadGroup::parent(thread_group);</span>
<span class="line-removed">-       if (parent != NULL) {</span>
<span class="line-removed">-         // ThreadGroup.name can be null</span>
<span class="line-removed">-         return java_lang_ThreadGroup::name(parent);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return NULL;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- ThreadPriority JavaThread::java_priority() const {</span>
<span class="line-removed">-   oop thr_oop = threadObj();</span>
<span class="line-removed">-   if (thr_oop == NULL) return NormPriority; // Bootstrapping</span>
<span class="line-removed">-   ThreadPriority priority = java_lang_Thread::priority(thr_oop);</span>
<span class="line-removed">-   assert(MinPriority &lt;= priority &amp;&amp; priority &lt;= MaxPriority, &quot;sanity check&quot;);</span>
<span class="line-removed">-   return priority;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void JavaThread::prepare(jobject jni_thread, ThreadPriority prio) {
  
    assert(Threads_lock-&gt;owner() == Thread::current(), &quot;must have threads lock&quot;);
    // Link Java Thread object &lt;-&gt; C++ Thread
  
    // Get the C++ thread object (an oop) from the JNI handle (a jthread)
    // and put it into a new Handle.  The Handle &quot;thread_oop&quot; can then
    // be used to pass the C++ thread object to other methods.
<span class="line-new-header">--- 3195,14 ---</span>
    }
    assert(name_str != NULL, &quot;unexpected NULL thread name&quot;);
    return name_str;
  }
  
  void JavaThread::prepare(jobject jni_thread, ThreadPriority prio) {
  
    assert(Threads_lock-&gt;owner() == Thread::current(), &quot;must have threads lock&quot;);
<span class="line-added">+   assert(NoPriority &lt;= prio &amp;&amp; prio &lt;= MaxPriority, &quot;sanity check&quot;);</span>
    // Link Java Thread object &lt;-&gt; C++ Thread
  
    // Get the C++ thread object (an oop) from the JNI handle (a jthread)
    // and put it into a new Handle.  The Handle &quot;thread_oop&quot; can then
    // be used to pass the C++ thread object to other methods.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3200,12 ***</span>
  }
  
  oop JavaThread::current_park_blocker() {
    // Support for JSR-166 locks
    oop thread_oop = threadObj();
<span class="line-modified">!   if (thread_oop != NULL &amp;&amp;</span>
<span class="line-removed">-       JDK_Version::current().supports_thread_park_blocker()) {</span>
      return java_lang_Thread::park_blocker(thread_oop);
    }
    return NULL;
  }
  
<span class="line-new-header">--- 3238,11 ---</span>
  }
  
  oop JavaThread::current_park_blocker() {
    // Support for JSR-166 locks
    oop thread_oop = threadObj();
<span class="line-modified">!   if (thread_oop != NULL) {</span>
      return java_lang_Thread::park_blocker(thread_oop);
    }
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3262,11 ***</span>
    return in_WordSize(sz / wordSize);
  }
  
  void JavaThread::popframe_free_preserved_args() {
    assert(_popframe_preserved_args != NULL, &quot;should not free PopFrame preserved arguments twice&quot;);
<span class="line-modified">!   FREE_C_HEAP_ARRAY(char, (char*) _popframe_preserved_args);</span>
    _popframe_preserved_args = NULL;
    _popframe_preserved_args_size = 0;
  }
  
  #ifndef PRODUCT
<span class="line-new-header">--- 3299,11 ---</span>
    return in_WordSize(sz / wordSize);
  }
  
  void JavaThread::popframe_free_preserved_args() {
    assert(_popframe_preserved_args != NULL, &quot;should not free PopFrame preserved arguments twice&quot;);
<span class="line-modified">!   FREE_C_HEAP_ARRAY(char, (char*)_popframe_preserved_args);</span>
    _popframe_preserved_args = NULL;
    _popframe_preserved_args_size = 0;
  }
  
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3301,27 ***</span>
   public:
    virtual void do_oop(oop* p) { do_oop_work(p); }
    virtual void do_oop(narrowOop* p)  { do_oop_work(p); }
  };
  
<span class="line-removed">- </span>
<span class="line-removed">- static void oops_print(frame* f, const RegisterMap *map) {</span>
<span class="line-removed">-   PrintAndVerifyOopClosure print;</span>
<span class="line-removed">-   f-&gt;print_value();</span>
<span class="line-removed">-   f-&gt;oops_do(&amp;print, NULL, (RegisterMap*)map);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Print our all the locations that contain oops and whether they are</span>
<span class="line-removed">- // valid or not.  This useful when trying to find the oldest frame</span>
<span class="line-removed">- // where an oop has gone bad since the frame walk is from youngest to</span>
<span class="line-removed">- // oldest.</span>
<span class="line-removed">- void JavaThread::trace_oops() {</span>
<span class="line-removed">-   tty-&gt;print_cr(&quot;[Trace oops]&quot;);</span>
<span class="line-removed">-   frames_do(oops_print);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  #ifdef ASSERT
  // Print or validate the layout of stack frames
  void JavaThread::print_frame_layout(int depth, bool validate_only) {
    ResourceMark rm;
    PRESERVE_EXCEPTION_MARK;
<span class="line-new-header">--- 3338,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3386,10 ***</span>
<span class="line-new-header">--- 3406,66 ---</span>
      return vfst.method()-&gt;method_holder();
    }
    return NULL;
  }
  
<span class="line-added">+ // java.lang.Thread.sleep support</span>
<span class="line-added">+ // Returns true if sleep time elapsed as expected, and false</span>
<span class="line-added">+ // if the thread was interrupted.</span>
<span class="line-added">+ bool JavaThread::sleep(jlong millis) {</span>
<span class="line-added">+   assert(this == Thread::current(),  &quot;thread consistency check&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ParkEvent * const slp = this-&gt;_SleepEvent;</span>
<span class="line-added">+   // Because there can be races with thread interruption sending an unpark()</span>
<span class="line-added">+   // to the event, we explicitly reset it here to avoid an immediate return.</span>
<span class="line-added">+   // The actual interrupt state will be checked before we park().</span>
<span class="line-added">+   slp-&gt;reset();</span>
<span class="line-added">+   // Thread interruption establishes a happens-before ordering in the</span>
<span class="line-added">+   // Java Memory Model, so we need to ensure we synchronize with the</span>
<span class="line-added">+   // interrupt state.</span>
<span class="line-added">+   OrderAccess::fence();</span>
<span class="line-added">+ </span>
<span class="line-added">+   jlong prevtime = os::javaTimeNanos();</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (;;) {</span>
<span class="line-added">+     // interruption has precedence over timing out</span>
<span class="line-added">+     if (this-&gt;is_interrupted(true)) {</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (millis &lt;= 0) {</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+       ThreadBlockInVM tbivm(this);</span>
<span class="line-added">+       OSThreadWaitState osts(this-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-added">+ </span>
<span class="line-added">+       this-&gt;set_suspend_equivalent();</span>
<span class="line-added">+       // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-added">+       // java_suspend_self() via check_and_wait_while_suspended()</span>
<span class="line-added">+ </span>
<span class="line-added">+       slp-&gt;park(millis);</span>
<span class="line-added">+ </span>
<span class="line-added">+       // were we externally suspended while we were waiting?</span>
<span class="line-added">+       this-&gt;check_and_wait_while_suspended();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Update elapsed time tracking</span>
<span class="line-added">+     jlong newtime = os::javaTimeNanos();</span>
<span class="line-added">+     if (newtime - prevtime &lt; 0) {</span>
<span class="line-added">+       // time moving backwards, should only happen if no monotonic clock</span>
<span class="line-added">+       // not a guarantee() because JVM should not abort on kernel/glibc bugs</span>
<span class="line-added">+       assert(!os::supports_monotonic_clock(),</span>
<span class="line-added">+              &quot;unexpected time moving backwards detected in JavaThread::sleep()&quot;);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     prevtime = newtime;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static void compiler_thread_entry(JavaThread* thread, TRAPS) {
    assert(thread-&gt;is_Compiler_thread(), &quot;must be compiler thread&quot;);
    CompileBroker::compiler_thread_loop();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3464,15 ***</span>
  //
  // Note: The Threads_lock is currently more widely used than we
  // would like. We are actively migrating Threads_lock uses to other
  // mechanisms in order to reduce Threads_lock contention.
  
<span class="line-removed">- JavaThread* Threads::_thread_list = NULL;</span>
  int         Threads::_number_of_threads = 0;
  int         Threads::_number_of_non_daemon_threads = 0;
  int         Threads::_return_code = 0;
<span class="line-modified">! int         Threads::_thread_claim_parity = 0;</span>
  size_t      JavaThread::_stack_size_at_create = 0;
  
  #ifdef ASSERT
  bool        Threads::_vm_complete = false;
  #endif
<span class="line-new-header">--- 3540,14 ---</span>
  //
  // Note: The Threads_lock is currently more widely used than we
  // would like. We are actively migrating Threads_lock uses to other
  // mechanisms in order to reduce Threads_lock contention.
  
  int         Threads::_number_of_threads = 0;
  int         Threads::_number_of_non_daemon_threads = 0;
  int         Threads::_return_code = 0;
<span class="line-modified">! uintx       Threads::_thread_claim_token = 1; // Never zero.</span>
  size_t      JavaThread::_stack_size_at_create = 0;
  
  #ifdef ASSERT
  bool        Threads::_vm_complete = false;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3499,11 ***</span>
  // All JavaThreads
  #define ALL_JAVA_THREADS(X) DO_JAVA_THREADS(ThreadsSMRSupport::get_java_thread_list(), X)
  
  // All NonJavaThreads (i.e., every non-JavaThread in the system).
  void Threads::non_java_threads_do(ThreadClosure* tc) {
<span class="line-modified">!   NoSafepointVerifier nsv(!SafepointSynchronize::is_at_safepoint(), false);</span>
    for (NonJavaThread::Iterator njti; !njti.end(); njti.step()) {
      tc-&gt;do_thread(njti.current());
    }
  }
  
<span class="line-new-header">--- 3574,11 ---</span>
  // All JavaThreads
  #define ALL_JAVA_THREADS(X) DO_JAVA_THREADS(ThreadsSMRSupport::get_java_thread_list(), X)
  
  // All NonJavaThreads (i.e., every non-JavaThread in the system).
  void Threads::non_java_threads_do(ThreadClosure* tc) {
<span class="line-modified">!   NoSafepointVerifier nsv;</span>
    for (NonJavaThread::Iterator njti; !njti.end(); njti.step()) {
      tc-&gt;do_thread(njti.current());
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3528,18 ***</span>
    java_threads_do(tc);
    non_java_threads_do(tc);
  }
  
  void Threads::possibly_parallel_threads_do(bool is_par, ThreadClosure* tc) {
<span class="line-modified">!   int cp = Threads::thread_claim_parity();</span>
    ALL_JAVA_THREADS(p) {
<span class="line-modified">!     if (p-&gt;claim_oops_do(is_par, cp)) {</span>
        tc-&gt;do_thread(p);
      }
    }
    VMThread* vmt = VMThread::vm_thread();
<span class="line-modified">!   if (vmt-&gt;claim_oops_do(is_par, cp)) {</span>
      tc-&gt;do_thread(vmt);
    }
  }
  
  // The system initialization in the library has three phases.
<span class="line-new-header">--- 3603,18 ---</span>
    java_threads_do(tc);
    non_java_threads_do(tc);
  }
  
  void Threads::possibly_parallel_threads_do(bool is_par, ThreadClosure* tc) {
<span class="line-modified">!   uintx claim_token = Threads::thread_claim_token();</span>
    ALL_JAVA_THREADS(p) {
<span class="line-modified">!     if (p-&gt;claim_threads_do(is_par, claim_token)) {</span>
        tc-&gt;do_thread(p);
      }
    }
    VMThread* vmt = VMThread::vm_thread();
<span class="line-modified">!   if (vmt-&gt;claim_threads_do(is_par, claim_token)) {</span>
      tc-&gt;do_thread(vmt);
    }
  }
  
  // The system initialization in the library has three phases.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3622,38 ***</span>
    Handle thread_group = create_initial_thread_group(CHECK);
    Universe::set_main_thread_group(thread_group());
    initialize_class(vmSymbols::java_lang_Thread(), CHECK);
    oop thread_object = create_initial_thread(thread_group, main_thread, CHECK);
    main_thread-&gt;set_threadObj(thread_object);
    // Set thread status to running since main thread has
    // been started and running.
    java_lang_Thread::set_thread_status(thread_object,
                                        java_lang_Thread::RUNNABLE);
  
    // The VM creates objects of this class.
    initialize_class(vmSymbols::java_lang_Module(), CHECK);
  
    // The VM preresolves methods to these classes. Make sure that they get initialized
    initialize_class(vmSymbols::java_lang_reflect_Method(), CHECK);
    initialize_class(vmSymbols::java_lang_ref_Finalizer(), CHECK);
  
    // Phase 1 of the system initialization in the library, java.lang.System class initialization
    call_initPhase1(CHECK);
  
<span class="line-modified">!   // get the Java runtime name after java.lang.System is initialized</span>
    JDK_Version::set_runtime_name(get_java_runtime_name(THREAD));
    JDK_Version::set_runtime_version(get_java_runtime_version(THREAD));
  
    // an instance of OutOfMemory exception has been allocated earlier
    initialize_class(vmSymbols::java_lang_OutOfMemoryError(), CHECK);
    initialize_class(vmSymbols::java_lang_NullPointerException(), CHECK);
    initialize_class(vmSymbols::java_lang_ClassCastException(), CHECK);
    initialize_class(vmSymbols::java_lang_ArrayStoreException(), CHECK);
    initialize_class(vmSymbols::java_lang_ArithmeticException(), CHECK);
    initialize_class(vmSymbols::java_lang_StackOverflowError(), CHECK);
    initialize_class(vmSymbols::java_lang_IllegalMonitorStateException(), CHECK);
    initialize_class(vmSymbols::java_lang_IllegalArgumentException(), CHECK);
  }
  
  void Threads::initialize_jsr292_core_classes(TRAPS) {
    TraceTime timer(&quot;Initialize java.lang.invoke classes&quot;, TRACETIME_LOG(Info, startuptime));
  
<span class="line-new-header">--- 3697,53 ---</span>
    Handle thread_group = create_initial_thread_group(CHECK);
    Universe::set_main_thread_group(thread_group());
    initialize_class(vmSymbols::java_lang_Thread(), CHECK);
    oop thread_object = create_initial_thread(thread_group, main_thread, CHECK);
    main_thread-&gt;set_threadObj(thread_object);
<span class="line-added">+ </span>
    // Set thread status to running since main thread has
    // been started and running.
    java_lang_Thread::set_thread_status(thread_object,
                                        java_lang_Thread::RUNNABLE);
  
    // The VM creates objects of this class.
    initialize_class(vmSymbols::java_lang_Module(), CHECK);
  
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+   InstanceKlass *k = SystemDictionary::UnsafeConstants_klass();</span>
<span class="line-added">+   assert(k-&gt;is_not_initialized(), &quot;UnsafeConstants should not already be initialized&quot;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+   // initialize the hardware-specific constants needed by Unsafe</span>
<span class="line-added">+   initialize_class(vmSymbols::jdk_internal_misc_UnsafeConstants(), CHECK);</span>
<span class="line-added">+   jdk_internal_misc_UnsafeConstants::set_unsafe_constants();</span>
<span class="line-added">+ </span>
    // The VM preresolves methods to these classes. Make sure that they get initialized
    initialize_class(vmSymbols::java_lang_reflect_Method(), CHECK);
    initialize_class(vmSymbols::java_lang_ref_Finalizer(), CHECK);
  
    // Phase 1 of the system initialization in the library, java.lang.System class initialization
    call_initPhase1(CHECK);
  
<span class="line-modified">!   // get the Java runtime name, version, and vendor info after java.lang.System is initialized</span>
    JDK_Version::set_runtime_name(get_java_runtime_name(THREAD));
    JDK_Version::set_runtime_version(get_java_runtime_version(THREAD));
<span class="line-added">+   JDK_Version::set_runtime_vendor_version(get_java_runtime_vendor_version(THREAD));</span>
<span class="line-added">+   JDK_Version::set_runtime_vendor_vm_bug_url(get_java_runtime_vendor_vm_bug_url(THREAD));</span>
  
    // an instance of OutOfMemory exception has been allocated earlier
    initialize_class(vmSymbols::java_lang_OutOfMemoryError(), CHECK);
    initialize_class(vmSymbols::java_lang_NullPointerException(), CHECK);
    initialize_class(vmSymbols::java_lang_ClassCastException(), CHECK);
    initialize_class(vmSymbols::java_lang_ArrayStoreException(), CHECK);
    initialize_class(vmSymbols::java_lang_ArithmeticException(), CHECK);
    initialize_class(vmSymbols::java_lang_StackOverflowError(), CHECK);
    initialize_class(vmSymbols::java_lang_IllegalMonitorStateException(), CHECK);
    initialize_class(vmSymbols::java_lang_IllegalArgumentException(), CHECK);
<span class="line-added">+ </span>
<span class="line-added">+   // Eager box cache initialization only if AOT is on and any library is loaded.</span>
<span class="line-added">+   AOTLoader::initialize_box_caches(CHECK);</span>
  }
  
  void Threads::initialize_jsr292_core_classes(TRAPS) {
    TraceTime timer(&quot;Initialize java.lang.invoke classes&quot;, TRACETIME_LOG(Info, startuptime));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3719,12 ***</span>
    bool constraint_result = JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterErgo);
    if (!constraint_result) {
      return JNI_EINVAL;
    }
  
<span class="line-removed">-   JVMFlagWriteableList::mark_startup();</span>
<span class="line-removed">- </span>
    if (PauseAtStartup) {
      os::pause();
    }
  
    HOTSPOT_VM_INIT_BEGIN();
<span class="line-new-header">--- 3809,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3761,20 ***</span>
    if (Arguments::init_agents_at_startup()) {
      create_vm_init_agents();
    }
  
    // Initialize Threads state
<span class="line-removed">-   _thread_list = NULL;</span>
    _number_of_threads = 0;
    _number_of_non_daemon_threads = 0;
  
    // Initialize global data structures and create system classes in heap
    vm_init_globals();
  
  #if INCLUDE_JVMCI
    if (JVMCICounterSize &gt; 0) {
<span class="line-modified">!     JavaThread::_jvmci_old_thread_counters = NEW_C_HEAP_ARRAY(jlong, JVMCICounterSize, mtInternal);</span>
      memset(JavaThread::_jvmci_old_thread_counters, 0, sizeof(jlong) * JVMCICounterSize);
    } else {
      JavaThread::_jvmci_old_thread_counters = NULL;
    }
  #endif // INCLUDE_JVMCI
<span class="line-new-header">--- 3849,19 ---</span>
    if (Arguments::init_agents_at_startup()) {
      create_vm_init_agents();
    }
  
    // Initialize Threads state
    _number_of_threads = 0;
    _number_of_non_daemon_threads = 0;
  
    // Initialize global data structures and create system classes in heap
    vm_init_globals();
  
  #if INCLUDE_JVMCI
    if (JVMCICounterSize &gt; 0) {
<span class="line-modified">!     JavaThread::_jvmci_old_thread_counters = NEW_C_HEAP_ARRAY(jlong, JVMCICounterSize, mtJVMCI);</span>
      memset(JavaThread::_jvmci_old_thread_counters, 0, sizeof(jlong) * JVMCICounterSize);
    } else {
      JavaThread::_jvmci_old_thread_counters = NULL;
    }
  #endif // INCLUDE_JVMCI
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3809,11 ***</span>
      main_thread-&gt;smr_delete();
      *canTryAgain = false; // don&#39;t let caller call JNI_CreateJavaVM again
      return status;
    }
  
<span class="line-modified">!   JFR_ONLY(Jfr::on_vm_init();)</span>
  
    // Should be done after the heap is fully created
    main_thread-&gt;cache_global_variables();
  
    HandleMark hm;
<span class="line-new-header">--- 3896,11 ---</span>
      main_thread-&gt;smr_delete();
      *canTryAgain = false; // don&#39;t let caller call JNI_CreateJavaVM again
      return status;
    }
  
<span class="line-modified">!   JFR_ONLY(Jfr::on_create_vm_1();)</span>
  
    // Should be done after the heap is fully created
    main_thread-&gt;cache_global_variables();
  
    HandleMark hm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3827,25 ***</span>
    JvmtiExport::transition_pending_onload_raw_monitors();
  
    // Create the VMThread
    { TraceTime timer(&quot;Start VMThread&quot;, TRACETIME_LOG(Info, startuptime));
  
<span class="line-modified">!   VMThread::create();</span>
      Thread* vmthread = VMThread::vm_thread();
  
      if (!os::create_thread(vmthread, os::vm_thread)) {
        vm_exit_during_initialization(&quot;Cannot create VM thread. &quot;
                                      &quot;Out of system resources.&quot;);
      }
  
      // Wait for the VM thread to become ready, and VMThread::run to initialize
      // Monitors can have spurious returns, must always check another state flag
      {
<span class="line-modified">!       MutexLocker ml(Notify_lock);</span>
        os::start_thread(vmthread);
        while (vmthread-&gt;active_handles() == NULL) {
<span class="line-modified">!         Notify_lock-&gt;wait();</span>
        }
      }
    }
  
    assert(Universe::is_fully_initialized(), &quot;not initialized&quot;);
<span class="line-new-header">--- 3914,25 ---</span>
    JvmtiExport::transition_pending_onload_raw_monitors();
  
    // Create the VMThread
    { TraceTime timer(&quot;Start VMThread&quot;, TRACETIME_LOG(Info, startuptime));
  
<span class="line-modified">!     VMThread::create();</span>
      Thread* vmthread = VMThread::vm_thread();
  
      if (!os::create_thread(vmthread, os::vm_thread)) {
        vm_exit_during_initialization(&quot;Cannot create VM thread. &quot;
                                      &quot;Out of system resources.&quot;);
      }
  
      // Wait for the VM thread to become ready, and VMThread::run to initialize
      // Monitors can have spurious returns, must always check another state flag
      {
<span class="line-modified">!       MonitorLocker ml(Notify_lock);</span>
        os::start_thread(vmthread);
        while (vmthread-&gt;active_handles() == NULL) {
<span class="line-modified">!         ml.wait();</span>
        }
      }
    }
  
    assert(Universe::is_fully_initialized(), &quot;not initialized&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3913,20 ***</span>
  
    if (CleanChunkPoolAsync) {
      Chunk::start_chunk_pool_cleaner_task();
    }
  
    // initialize compiler(s)
  #if defined(COMPILER1) || COMPILER2_OR_JVMCI
  #if INCLUDE_JVMCI
    bool force_JVMCI_intialization = false;
    if (EnableJVMCI) {
      // Initialize JVMCI eagerly when it is explicitly requested.
<span class="line-modified">!     // Or when JVMCIPrintProperties is enabled.</span>
<span class="line-modified">!     // The JVMCI Java initialization code will read this flag and</span>
<span class="line-removed">-     // do the printing if it&#39;s set.</span>
<span class="line-removed">-     force_JVMCI_intialization = EagerJVMCI || JVMCIPrintProperties;</span>
  
      if (!force_JVMCI_intialization) {
        // 8145270: Force initialization of JVMCI runtime otherwise requests for blocking
        // compilations via JVMCI will not actually block until JVMCI is initialized.
        force_JVMCI_intialization = UseJVMCICompiler &amp;&amp; (!UseInterpreter || !BackgroundCompilation);
<span class="line-new-header">--- 4000,23 ---</span>
  
    if (CleanChunkPoolAsync) {
      Chunk::start_chunk_pool_cleaner_task();
    }
  
<span class="line-added">+   // Start the service thread</span>
<span class="line-added">+   // The service thread enqueues JVMTI deferred events and does various hashtable</span>
<span class="line-added">+   // and other cleanups.  Needs to start before the compilers start posting events.</span>
<span class="line-added">+   ServiceThread::initialize();</span>
<span class="line-added">+ </span>
    // initialize compiler(s)
  #if defined(COMPILER1) || COMPILER2_OR_JVMCI
  #if INCLUDE_JVMCI
    bool force_JVMCI_intialization = false;
    if (EnableJVMCI) {
      // Initialize JVMCI eagerly when it is explicitly requested.
<span class="line-modified">!     // Or when JVMCILibDumpJNIConfig or JVMCIPrintProperties is enabled.</span>
<span class="line-modified">!     force_JVMCI_intialization = EagerJVMCI || JVMCIPrintProperties || JVMCILibDumpJNIConfig;</span>
  
      if (!force_JVMCI_intialization) {
        // 8145270: Force initialization of JVMCI runtime otherwise requests for blocking
        // compilations via JVMCI will not actually block until JVMCI is initialized.
        force_JVMCI_intialization = UseJVMCICompiler &amp;&amp; (!UseInterpreter || !BackgroundCompilation);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3949,10 ***</span>
<span class="line-new-header">--- 4039,12 ---</span>
  
    // This will initialize the module system.  Only java.base classes can be
    // loaded until phase 2 completes
    call_initPhase2(CHECK_JNI_ERR);
  
<span class="line-added">+   JFR_ONLY(Jfr::on_create_vm_2();)</span>
<span class="line-added">+ </span>
    // Always call even when there are not JVMTI environments yet, since environments
    // may be attached late and JVMTI must track phases of VM execution
    JvmtiExport::enter_start_phase();
  
    // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3963,19 ***</span>
  
    // cache the system and platform class loaders
    SystemDictionary::compute_java_loaders(CHECK_JNI_ERR);
  
  #if INCLUDE_CDS
<span class="line-modified">!   if (DumpSharedSpaces) {</span>
<span class="line-modified">!     // capture the module path info from the ModuleEntryTable</span>
<span class="line-removed">-     ClassLoader::initialize_module_path(THREAD);</span>
<span class="line-removed">-   }</span>
  #endif
  
  #if INCLUDE_JVMCI
    if (force_JVMCI_intialization) {
<span class="line-modified">!     JVMCIRuntime::force_initialization(CHECK_JNI_ERR);</span>
      CompileBroker::compilation_init_phase2();
    }
  #endif
  
    // Always call even when there are not JVMTI environments yet, since environments
<span class="line-new-header">--- 4055,17 ---</span>
  
    // cache the system and platform class loaders
    SystemDictionary::compute_java_loaders(CHECK_JNI_ERR);
  
  #if INCLUDE_CDS
<span class="line-modified">!   // capture the module path info from the ModuleEntryTable</span>
<span class="line-modified">!   ClassLoader::initialize_module_path(THREAD);</span>
  #endif
  
  #if INCLUDE_JVMCI
    if (force_JVMCI_intialization) {
<span class="line-modified">!     JVMCI::initialize_compiler(CHECK_JNI_ERR);</span>
      CompileBroker::compilation_init_phase2();
    }
  #endif
  
    // Always call even when there are not JVMTI environments yet, since environments
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3986,11 ***</span>
    PerfMemory::set_accessible(true);
  
    // Notify JVMTI agents that VM initialization is complete - nop if no agents.
    JvmtiExport::post_vm_initialized();
  
<span class="line-modified">!   JFR_ONLY(Jfr::on_vm_start();)</span>
  
  #if INCLUDE_MANAGEMENT
    Management::initialize(THREAD);
  
    if (HAS_PENDING_EXCEPTION) {
<span class="line-new-header">--- 4076,11 ---</span>
    PerfMemory::set_accessible(true);
  
    // Notify JVMTI agents that VM initialization is complete - nop if no agents.
    JvmtiExport::post_vm_initialized();
  
<span class="line-modified">!   JFR_ONLY(Jfr::on_create_vm_3();)</span>
  
  #if INCLUDE_MANAGEMENT
    Management::initialize(THREAD);
  
    if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4009,17 ***</span>
  
  #if INCLUDE_RTM_OPT
    RTMLockingCounters::init();
  #endif
  
<span class="line-modified">!   if (JDK_Version::current().post_vm_init_hook_enabled()) {</span>
<span class="line-modified">!     call_postVMInitHook(THREAD);</span>
<span class="line-modified">!     // The Java side of PostVMInitHook.run must deal with all</span>
<span class="line-modified">!     // exceptions and provide means of diagnosis.</span>
<span class="line-modified">!     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-removed">-       CLEAR_PENDING_EXCEPTION;</span>
<span class="line-removed">-     }</span>
    }
  
    {
      MutexLocker ml(PeriodicTask_lock);
      // Make sure the WatcherThread can be started by WatcherThread::start()
<span class="line-new-header">--- 4099,15 ---</span>
  
  #if INCLUDE_RTM_OPT
    RTMLockingCounters::init();
  #endif
  
<span class="line-modified">!   call_postVMInitHook(THREAD);</span>
<span class="line-modified">!   // The Java side of PostVMInitHook.run must deal with all</span>
<span class="line-modified">!   // exceptions and provide means of diagnosis.</span>
<span class="line-modified">!   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-modified">!     CLEAR_PENDING_EXCEPTION;</span>
    }
  
    {
      MutexLocker ml(PeriodicTask_lock);
      // Make sure the WatcherThread can be started by WatcherThread::start()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4170,11 ***</span>
    JvmtiExport::enter_onload_phase();
  
    for (agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) {
      // CDS dumping does not support native JVMTI agent.
      // CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.
<span class="line-modified">!     if (DumpSharedSpaces) {</span>
        if(!agent-&gt;is_instrument_lib()) {
          vm_exit_during_cds_dumping(&quot;CDS dumping does not support native JVMTI agent, name&quot;, agent-&gt;name());
        } else if (!AllowArchivingWithJavaAgent) {
          vm_exit_during_cds_dumping(
            &quot;Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping&quot;);
<span class="line-new-header">--- 4258,11 ---</span>
    JvmtiExport::enter_onload_phase();
  
    for (agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) {
      // CDS dumping does not support native JVMTI agent.
      // CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.
<span class="line-modified">!     if (Arguments::is_dumping_archive()) {</span>
        if(!agent-&gt;is_instrument_lib()) {
          vm_exit_during_cds_dumping(&quot;CDS dumping does not support native JVMTI agent, name&quot;, agent-&gt;name());
        } else if (!AllowArchivingWithJavaAgent) {
          vm_exit_during_cds_dumping(
            &quot;Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4271,11 ***</span>
      // the Shutdown class would have already been loaded
      // (Runtime.addShutdownHook will load it).
      JavaValue result(T_VOID);
      JavaCalls::call_static(&amp;result,
                             shutdown_klass,
<span class="line-modified">!                            vmSymbols::shutdown_method_name(),</span>
                             vmSymbols::void_method_signature(),
                             THREAD);
    }
    CLEAR_PENDING_EXCEPTION;
  }
<span class="line-new-header">--- 4359,11 ---</span>
      // the Shutdown class would have already been loaded
      // (Runtime.addShutdownHook will load it).
      JavaValue result(T_VOID);
      JavaCalls::call_static(&amp;result,
                             shutdown_klass,
<span class="line-modified">!                            vmSymbols::shutdown_name(),</span>
                             vmSymbols::void_method_signature(),
                             THREAD);
    }
    CLEAR_PENDING_EXCEPTION;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4294,11 ***</span>
  //   + Call java.lang.Shutdown.shutdown(), which will invoke Java level
  //        shutdown hooks
  //   + Call before_exit(), prepare for VM exit
  //      &gt; run VM level shutdown hooks (they are registered through JVM_OnExit(),
  //        currently the only user of this mechanism is File.deleteOnExit())
<span class="line-modified">! //      &gt; stop StatSampler, watcher thread, CMS threads,</span>
  //        post thread end and vm death events to JVMTI,
  //        stop signal thread
  //   + Call JavaThread::exit(), it will:
  //      &gt; release JNI handle blocks, remove stack guard pages
  //      &gt; remove this thread from Threads list
<span class="line-new-header">--- 4382,11 ---</span>
  //   + Call java.lang.Shutdown.shutdown(), which will invoke Java level
  //        shutdown hooks
  //   + Call before_exit(), prepare for VM exit
  //      &gt; run VM level shutdown hooks (they are registered through JVM_OnExit(),
  //        currently the only user of this mechanism is File.deleteOnExit())
<span class="line-modified">! //      &gt; stop StatSampler, watcher thread,</span>
  //        post thread end and vm death events to JVMTI,
  //        stop signal thread
  //   + Call JavaThread::exit(), it will:
  //      &gt; release JNI handle blocks, remove stack guard pages
  //      &gt; remove this thread from Threads list
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4319,16 ***</span>
  
  #ifdef ASSERT
    _vm_complete = false;
  #endif
    // Wait until we are the last non-daemon thread to execute
<span class="line-modified">!   { MutexLocker nu(Threads_lock);</span>
      while (Threads::number_of_non_daemon_threads() &gt; 1)
        // This wait should make safepoint checks, wait without a timeout,
        // and wait as a suspend-equivalent condition.
<span class="line-modified">!       Threads_lock-&gt;wait(!Mutex::_no_safepoint_check_flag, 0,</span>
<span class="line-removed">-                          Mutex::_as_suspend_equivalent_flag);</span>
    }
  
    EventShutdown e;
    if (e.should_commit()) {
      e.set_reason(&quot;No remaining non-daemon Java threads&quot;);
<span class="line-new-header">--- 4407,15 ---</span>
  
  #ifdef ASSERT
    _vm_complete = false;
  #endif
    // Wait until we are the last non-daemon thread to execute
<span class="line-modified">!   { MonitorLocker nu(Threads_lock);</span>
      while (Threads::number_of_non_daemon_threads() &gt; 1)
        // This wait should make safepoint checks, wait without a timeout,
        // and wait as a suspend-equivalent condition.
<span class="line-modified">!       nu.wait(0, Mutex::_as_suspend_equivalent_flag);</span>
    }
  
    EventShutdown e;
    if (e.should_commit()) {
      e.set_reason(&quot;No remaining non-daemon Java threads&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4355,11 ***</span>
      // heap is unparseable if they are caught. Grab the Heap_lock
      // to prevent this. The GC vm_operations will not be able to
      // queue until after the vm thread is dead. After this point,
      // we&#39;ll never emerge out of the safepoint before the VM exits.
  
<span class="line-modified">!     MutexLockerEx ml(Heap_lock, Mutex::_no_safepoint_check_flag);</span>
  
      VMThread::wait_for_vm_thread_exit();
      assert(SafepointSynchronize::is_at_safepoint(), &quot;VM thread should exit at Safepoint&quot;);
      VMThread::destroy();
    }
<span class="line-new-header">--- 4442,11 ---</span>
      // heap is unparseable if they are caught. Grab the Heap_lock
      // to prevent this. The GC vm_operations will not be able to
      // queue until after the vm thread is dead. After this point,
      // we&#39;ll never emerge out of the safepoint before the VM exits.
  
<span class="line-modified">!     MutexLocker ml(Heap_lock, Mutex::_no_safepoint_check_flag);</span>
  
      VMThread::wait_for_vm_thread_exit();
      assert(SafepointSynchronize::is_at_safepoint(), &quot;VM thread should exit at Safepoint&quot;);
      VMThread::destroy();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4427,13 ***</span>
    // The threads lock must be owned at this point
    assert(Threads_lock-&gt;owned_by_self(), &quot;must have threads lock&quot;);
  
    BarrierSet::barrier_set()-&gt;on_thread_attach(p);
  
<span class="line-removed">-   p-&gt;set_next(_thread_list);</span>
<span class="line-removed">-   _thread_list = p;</span>
<span class="line-removed">- </span>
    // Once a JavaThread is added to the Threads list, smr_delete() has
    // to be used to delete it. Otherwise we can just delete it directly.
    p-&gt;set_on_thread_list();
  
    _number_of_threads++;
<span class="line-new-header">--- 4514,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4453,52 ***</span>
  
    // Possible GC point.
    Events::log(p, &quot;Thread added: &quot; INTPTR_FORMAT, p2i(p));
  }
  
<span class="line-modified">! void Threads::remove(JavaThread* p) {</span>
  
<span class="line-modified">!   // Reclaim the objectmonitors from the omInUseList and omFreeList of the moribund thread.</span>
<span class="line-modified">!   ObjectSynchronizer::omFlush(p);</span>
  
    // Extra scope needed for Thread_lock, so we can check
    // that we do not remove thread without safepoint code notice
<span class="line-modified">!   { MutexLocker ml(Threads_lock);</span>
  
      assert(ThreadsSMRSupport::get_java_thread_list()-&gt;includes(p), &quot;p must be present&quot;);
  
      // Maintain fast thread list
      ThreadsSMRSupport::remove_thread(p);
  
<span class="line-removed">-     JavaThread* current = _thread_list;</span>
<span class="line-removed">-     JavaThread* prev    = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     while (current != p) {</span>
<span class="line-removed">-       prev    = current;</span>
<span class="line-removed">-       current = current-&gt;next();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (prev) {</span>
<span class="line-removed">-       prev-&gt;set_next(current-&gt;next());</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       _thread_list = p-&gt;next();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      _number_of_threads--;
<span class="line-modified">!     oop threadObj = p-&gt;threadObj();</span>
<span class="line-removed">-     bool daemon = true;</span>
<span class="line-removed">-     if (!is_daemon(threadObj)) {</span>
        _number_of_non_daemon_threads--;
<span class="line-removed">-       daemon = false;</span>
  
        // Only one thread left, do a notify on the Threads_lock so a thread waiting
        // on destroy_vm will wake up.
        if (number_of_non_daemon_threads() == 1) {
<span class="line-modified">!         Threads_lock-&gt;notify_all();</span>
        }
      }
<span class="line-modified">!     ThreadService::remove_thread(p, daemon);</span>
  
      // Make sure that safepoint code disregard this thread. This is needed since
      // the thread might mess around with locks after this point. This can cause it
      // to do callbacks into the safepoint code. However, the safepoint code is not aware
      // of this thread since it is removed from the queue.
<span class="line-new-header">--- 4537,35 ---</span>
  
    // Possible GC point.
    Events::log(p, &quot;Thread added: &quot; INTPTR_FORMAT, p2i(p));
  }
  
<span class="line-modified">! void Threads::remove(JavaThread* p, bool is_daemon) {</span>
  
<span class="line-modified">!   // Reclaim the ObjectMonitors from the om_in_use_list and om_free_list of the moribund thread.</span>
<span class="line-modified">!   ObjectSynchronizer::om_flush(p);</span>
  
    // Extra scope needed for Thread_lock, so we can check
    // that we do not remove thread without safepoint code notice
<span class="line-modified">!   { MonitorLocker ml(Threads_lock);</span>
  
      assert(ThreadsSMRSupport::get_java_thread_list()-&gt;includes(p), &quot;p must be present&quot;);
  
      // Maintain fast thread list
      ThreadsSMRSupport::remove_thread(p);
  
      _number_of_threads--;
<span class="line-modified">!     if (!is_daemon) {</span>
        _number_of_non_daemon_threads--;
  
        // Only one thread left, do a notify on the Threads_lock so a thread waiting
        // on destroy_vm will wake up.
        if (number_of_non_daemon_threads() == 1) {
<span class="line-modified">!         ml.notify_all();</span>
        }
      }
<span class="line-modified">!     ThreadService::remove_thread(p, is_daemon);</span>
  
      // Make sure that safepoint code disregard this thread. This is needed since
      // the thread might mess around with locks after this point. This can cause it
      // to do callbacks into the safepoint code. However, the safepoint code is not aware
      // of this thread since it is removed from the queue.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4521,31 ***</span>
      p-&gt;oops_do(f, cf);
    }
    VMThread::vm_thread()-&gt;oops_do(f, cf);
  }
  
<span class="line-modified">! void Threads::change_thread_claim_parity() {</span>
<span class="line-modified">!   // Set the new claim parity.</span>
<span class="line-modified">!   assert(_thread_claim_parity &gt;= 0 &amp;&amp; _thread_claim_parity &lt;= 2,</span>
<span class="line-modified">!          &quot;Not in range.&quot;);</span>
<span class="line-modified">!   _thread_claim_parity++;</span>
<span class="line-modified">!   if (_thread_claim_parity == 3) _thread_claim_parity = 1;</span>
<span class="line-modified">!   assert(_thread_claim_parity &gt;= 1 &amp;&amp; _thread_claim_parity &lt;= 2,</span>
<span class="line-modified">!          &quot;Not in range.&quot;);</span>
  }
  
  #ifdef ASSERT
  void Threads::assert_all_threads_claimed() {
    ALL_JAVA_THREADS(p) {
<span class="line-modified">!     const int thread_parity = p-&gt;oops_do_parity();</span>
<span class="line-removed">-     assert((thread_parity == _thread_claim_parity),</span>
<span class="line-removed">-            &quot;Thread &quot; PTR_FORMAT &quot; has incorrect parity %d != %d&quot;, p2i(p), thread_parity, _thread_claim_parity);</span>
    }
<span class="line-modified">!   VMThread* vmt = VMThread::vm_thread();</span>
<span class="line-removed">-   const int thread_parity = vmt-&gt;oops_do_parity();</span>
<span class="line-removed">-   assert((thread_parity == _thread_claim_parity),</span>
<span class="line-removed">-          &quot;VMThread &quot; PTR_FORMAT &quot; has incorrect parity %d != %d&quot;, p2i(vmt), thread_parity, _thread_claim_parity);</span>
  }
  #endif // ASSERT
  
  class ParallelOopsDoThreadClosure : public ThreadClosure {
  private:
<span class="line-new-header">--- 4588,43 ---</span>
      p-&gt;oops_do(f, cf);
    }
    VMThread::vm_thread()-&gt;oops_do(f, cf);
  }
  
<span class="line-modified">! void Threads::change_thread_claim_token() {</span>
<span class="line-modified">!   if (++_thread_claim_token == 0) {</span>
<span class="line-modified">!     // On overflow of the token counter, there is a risk of future</span>
<span class="line-modified">!     // collisions between a new global token value and a stale token</span>
<span class="line-modified">!     // for a thread, because not all iterations visit all threads.</span>
<span class="line-modified">!     // (Though it&#39;s pretty much a theoretical concern for non-trivial</span>
<span class="line-modified">!     // token counter sizes.)  To deal with the possibility, reset all</span>
<span class="line-modified">!     // the thread tokens to zero on global token overflow.</span>
<span class="line-added">+     struct ResetClaims : public ThreadClosure {</span>
<span class="line-added">+       virtual void do_thread(Thread* t) {</span>
<span class="line-added">+         t-&gt;claim_threads_do(false, 0);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } reset_claims;</span>
<span class="line-added">+     Threads::threads_do(&amp;reset_claims);</span>
<span class="line-added">+     // On overflow, update the global token to non-zero, to</span>
<span class="line-added">+     // avoid the special &quot;never claimed&quot; initial thread value.</span>
<span class="line-added">+     _thread_claim_token = 1;</span>
<span class="line-added">+   }</span>
  }
  
  #ifdef ASSERT
<span class="line-added">+ void assert_thread_claimed(const char* kind, Thread* t, uintx expected) {</span>
<span class="line-added">+   const uintx token = t-&gt;threads_do_token();</span>
<span class="line-added">+   assert(token == expected,</span>
<span class="line-added">+          &quot;%s &quot; PTR_FORMAT &quot; has incorrect value &quot; UINTX_FORMAT &quot; != &quot;</span>
<span class="line-added">+          UINTX_FORMAT, kind, p2i(t), token, expected);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Threads::assert_all_threads_claimed() {
    ALL_JAVA_THREADS(p) {
<span class="line-modified">!     assert_thread_claimed(&quot;Thread&quot;, p, _thread_claim_token);</span>
    }
<span class="line-modified">!   assert_thread_claimed(&quot;VMThread&quot;, VMThread::vm_thread(), _thread_claim_token);</span>
  }
  #endif // ASSERT
  
  class ParallelOopsDoThreadClosure : public ThreadClosure {
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4572,11 ***</span>
        p-&gt;nmethods_do(cf);
      }
    }
  }
  
<span class="line-modified">! void Threads::metadata_do(void f(Metadata*)) {</span>
    ALL_JAVA_THREADS(p) {
      p-&gt;metadata_do(f);
    }
  }
  
<span class="line-new-header">--- 4651,11 ---</span>
        p-&gt;nmethods_do(cf);
      }
    }
  }
  
<span class="line-modified">! void Threads::metadata_do(MetadataClosure* f) {</span>
    ALL_JAVA_THREADS(p) {
      p-&gt;metadata_do(f);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4593,17 ***</span>
    // Only walk the Handles in Thread.
    ThreadHandlesClosure handles_closure(f);
    threads_do(&amp;handles_closure);
  }
  
<span class="line-removed">- void Threads::deoptimized_wrt_marked_nmethods() {</span>
<span class="line-removed">-   ALL_JAVA_THREADS(p) {</span>
<span class="line-removed">-     p-&gt;deoptimized_wrt_marked_nmethods();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  // Get count Java threads that are waiting to enter the specified monitor.
  GrowableArray&lt;JavaThread*&gt;* Threads::get_pending_threads(ThreadsList * t_list,
                                                           int count,
                                                           address monitor) {
    GrowableArray&lt;JavaThread*&gt;* result = new GrowableArray&lt;JavaThread*&gt;(count);
<span class="line-new-header">--- 4672,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4818,11 ***</span>
  
  
  typedef volatile int SpinLockT;
  
  void Thread::SpinAcquire(volatile int * adr, const char * LockName) {
<span class="line-modified">!   if (Atomic::cmpxchg (1, adr, 0) == 0) {</span>
      return;   // normal fast-path return
    }
  
    // Slow-path : We&#39;ve encountered contention -- Spin/Yield/Block strategy.
    int ctr = 0;
<span class="line-new-header">--- 4890,11 ---</span>
  
  
  typedef volatile int SpinLockT;
  
  void Thread::SpinAcquire(volatile int * adr, const char * LockName) {
<span class="line-modified">!   if (Atomic::cmpxchg(adr, 0, 1) == 0) {</span>
      return;   // normal fast-path return
    }
  
    // Slow-path : We&#39;ve encountered contention -- Spin/Yield/Block strategy.
    int ctr = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4839,11 ***</span>
          }
        } else {
          SpinPause();
        }
      }
<span class="line-modified">!     if (Atomic::cmpxchg(1, adr, 0) == 0) return;</span>
    }
  }
  
  void Thread::SpinRelease(volatile int * adr) {
    assert(*adr != 0, &quot;invariant&quot;);
<span class="line-new-header">--- 4911,11 ---</span>
          }
        } else {
          SpinPause();
        }
      }
<span class="line-modified">!     if (Atomic::cmpxchg(adr, 0, 1) == 0) return;</span>
    }
  }
  
  void Thread::SpinRelease(volatile int * adr) {
    assert(*adr != 0, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4911,13 ***</span>
  
  
  const intptr_t LOCKBIT = 1;
  
  void Thread::muxAcquire(volatile intptr_t * Lock, const char * LockName) {
<span class="line-modified">!   intptr_t w = Atomic::cmpxchg(LOCKBIT, Lock, (intptr_t)0);</span>
    if (w == 0) return;
<span class="line-modified">!   if ((w &amp; LOCKBIT) == 0 &amp;&amp; Atomic::cmpxchg(w|LOCKBIT, Lock, w) == w) {</span>
      return;
    }
  
    ParkEvent * const Self = Thread::current()-&gt;_MuxEvent;
    assert((intptr_t(Self) &amp; LOCKBIT) == 0, &quot;invariant&quot;);
<span class="line-new-header">--- 4983,13 ---</span>
  
  
  const intptr_t LOCKBIT = 1;
  
  void Thread::muxAcquire(volatile intptr_t * Lock, const char * LockName) {
<span class="line-modified">!   intptr_t w = Atomic::cmpxchg(Lock, (intptr_t)0, LOCKBIT);</span>
    if (w == 0) return;
<span class="line-modified">!   if ((w &amp; LOCKBIT) == 0 &amp;&amp; Atomic::cmpxchg(Lock, w, w|LOCKBIT) == w) {</span>
      return;
    }
  
    ParkEvent * const Self = Thread::current()-&gt;_MuxEvent;
    assert((intptr_t(Self) &amp; LOCKBIT) == 0, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4925,11 ***</span>
      int its = (os::is_MP() ? 100 : 0) + 1;
  
      // Optional spin phase: spin-then-park strategy
      while (--its &gt;= 0) {
        w = *Lock;
<span class="line-modified">!       if ((w &amp; LOCKBIT) == 0 &amp;&amp; Atomic::cmpxchg(w|LOCKBIT, Lock, w) == w) {</span>
          return;
        }
      }
  
      Self-&gt;reset();
<span class="line-new-header">--- 4997,11 ---</span>
      int its = (os::is_MP() ? 100 : 0) + 1;
  
      // Optional spin phase: spin-then-park strategy
      while (--its &gt;= 0) {
        w = *Lock;
<span class="line-modified">!       if ((w &amp; LOCKBIT) == 0 &amp;&amp; Atomic::cmpxchg(Lock, w, w|LOCKBIT) == w) {</span>
          return;
        }
      }
  
      Self-&gt;reset();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4938,86 ***</span>
      // CAS() both serializes execution and ratifies the fetched *Lock value.
      OrderAccess::fence();
      for (;;) {
        w = *Lock;
        if ((w &amp; LOCKBIT) == 0) {
<span class="line-modified">!         if (Atomic::cmpxchg(w|LOCKBIT, Lock, w) == w) {</span>
            Self-&gt;OnList = 0;   // hygiene - allows stronger asserts
            return;
          }
          continue;      // Interference -- *Lock changed -- Just retry
        }
        assert(w &amp; LOCKBIT, &quot;invariant&quot;);
        Self-&gt;ListNext = (ParkEvent *) (w &amp; ~LOCKBIT);
<span class="line-modified">!       if (Atomic::cmpxchg(intptr_t(Self)|LOCKBIT, Lock, w) == w) break;</span>
      }
  
      while (Self-&gt;OnList != 0) {
        Self-&gt;park();
      }
    }
  }
  
<span class="line-removed">- void Thread::muxAcquireW(volatile intptr_t * Lock, ParkEvent * ev) {</span>
<span class="line-removed">-   intptr_t w = Atomic::cmpxchg(LOCKBIT, Lock, (intptr_t)0);</span>
<span class="line-removed">-   if (w == 0) return;</span>
<span class="line-removed">-   if ((w &amp; LOCKBIT) == 0 &amp;&amp; Atomic::cmpxchg(w|LOCKBIT, Lock, w) == w) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ParkEvent * ReleaseAfter = NULL;</span>
<span class="line-removed">-   if (ev == NULL) {</span>
<span class="line-removed">-     ev = ReleaseAfter = ParkEvent::Allocate(NULL);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert((intptr_t(ev) &amp; LOCKBIT) == 0, &quot;invariant&quot;);</span>
<span class="line-removed">-   for (;;) {</span>
<span class="line-removed">-     guarantee(ev-&gt;OnList == 0, &quot;invariant&quot;);</span>
<span class="line-removed">-     int its = (os::is_MP() ? 100 : 0) + 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Optional spin phase: spin-then-park strategy</span>
<span class="line-removed">-     while (--its &gt;= 0) {</span>
<span class="line-removed">-       w = *Lock;</span>
<span class="line-removed">-       if ((w &amp; LOCKBIT) == 0 &amp;&amp; Atomic::cmpxchg(w|LOCKBIT, Lock, w) == w) {</span>
<span class="line-removed">-         if (ReleaseAfter != NULL) {</span>
<span class="line-removed">-           ParkEvent::Release(ReleaseAfter);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ev-&gt;reset();</span>
<span class="line-removed">-     ev-&gt;OnList = intptr_t(Lock);</span>
<span class="line-removed">-     // The following fence() isn&#39;t _strictly necessary as the subsequent</span>
<span class="line-removed">-     // CAS() both serializes execution and ratifies the fetched *Lock value.</span>
<span class="line-removed">-     OrderAccess::fence();</span>
<span class="line-removed">-     for (;;) {</span>
<span class="line-removed">-       w = *Lock;</span>
<span class="line-removed">-       if ((w &amp; LOCKBIT) == 0) {</span>
<span class="line-removed">-         if (Atomic::cmpxchg(w|LOCKBIT, Lock, w) == w) {</span>
<span class="line-removed">-           ev-&gt;OnList = 0;</span>
<span class="line-removed">-           // We call ::Release while holding the outer lock, thus</span>
<span class="line-removed">-           // artificially lengthening the critical section.</span>
<span class="line-removed">-           // Consider deferring the ::Release() until the subsequent unlock(),</span>
<span class="line-removed">-           // after we&#39;ve dropped the outer lock.</span>
<span class="line-removed">-           if (ReleaseAfter != NULL) {</span>
<span class="line-removed">-             ParkEvent::Release(ReleaseAfter);</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         continue;      // Interference -- *Lock changed -- Just retry</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       assert(w &amp; LOCKBIT, &quot;invariant&quot;);</span>
<span class="line-removed">-       ev-&gt;ListNext = (ParkEvent *) (w &amp; ~LOCKBIT);</span>
<span class="line-removed">-       if (Atomic::cmpxchg(intptr_t(ev)|LOCKBIT, Lock, w) == w) break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     while (ev-&gt;OnList != 0) {</span>
<span class="line-removed">-       ev-&gt;park();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Release() must extract a successor from the list and then wake that thread.
  // It can &quot;pop&quot; the front of the list or use a detach-modify-reattach (DMR) scheme
  // similar to that used by ParkEvent::Allocate() and ::Release().  DMR-based
  // Release() would :
  // (A) CAS() or swap() null to *Lock, releasing the lock and detaching the list.
<span class="line-new-header">--- 5010,27 ---</span>
      // CAS() both serializes execution and ratifies the fetched *Lock value.
      OrderAccess::fence();
      for (;;) {
        w = *Lock;
        if ((w &amp; LOCKBIT) == 0) {
<span class="line-modified">!         if (Atomic::cmpxchg(Lock, w, w|LOCKBIT) == w) {</span>
            Self-&gt;OnList = 0;   // hygiene - allows stronger asserts
            return;
          }
          continue;      // Interference -- *Lock changed -- Just retry
        }
        assert(w &amp; LOCKBIT, &quot;invariant&quot;);
        Self-&gt;ListNext = (ParkEvent *) (w &amp; ~LOCKBIT);
<span class="line-modified">!       if (Atomic::cmpxchg(Lock, w, intptr_t(Self)|LOCKBIT) == w) break;</span>
      }
  
      while (Self-&gt;OnList != 0) {
        Self-&gt;park();
      }
    }
  }
  
  // Release() must extract a successor from the list and then wake that thread.
  // It can &quot;pop&quot; the front of the list or use a detach-modify-reattach (DMR) scheme
  // similar to that used by ParkEvent::Allocate() and ::Release().  DMR-based
  // Release() would :
  // (A) CAS() or swap() null to *Lock, releasing the lock and detaching the list.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5041,22 ***</span>
  // bidirectional fence/MEMBAR semantics, ensuring that all prior memory operations
  // executed within the critical section are complete and globally visible before the
  // store (CAS) to the lock-word that releases the lock becomes globally visible.
  void Thread::muxRelease(volatile intptr_t * Lock)  {
    for (;;) {
<span class="line-modified">!     const intptr_t w = Atomic::cmpxchg((intptr_t)0, Lock, LOCKBIT);</span>
      assert(w &amp; LOCKBIT, &quot;invariant&quot;);
      if (w == LOCKBIT) return;
      ParkEvent * const List = (ParkEvent *) (w &amp; ~LOCKBIT);
      assert(List != NULL, &quot;invariant&quot;);
      assert(List-&gt;OnList == intptr_t(Lock), &quot;invariant&quot;);
      ParkEvent * const nxt = List-&gt;ListNext;
      guarantee((intptr_t(nxt) &amp; LOCKBIT) == 0, &quot;invariant&quot;);
  
      // The following CAS() releases the lock and pops the head element.
      // The CAS() also ratifies the previously fetched lock-word value.
<span class="line-modified">!     if (Atomic::cmpxchg(intptr_t(nxt), Lock, w) != w) {</span>
        continue;
      }
      List-&gt;OnList = 0;
      OrderAccess::fence();
      List-&gt;unpark();
<span class="line-new-header">--- 5054,22 ---</span>
  // bidirectional fence/MEMBAR semantics, ensuring that all prior memory operations
  // executed within the critical section are complete and globally visible before the
  // store (CAS) to the lock-word that releases the lock becomes globally visible.
  void Thread::muxRelease(volatile intptr_t * Lock)  {
    for (;;) {
<span class="line-modified">!     const intptr_t w = Atomic::cmpxchg(Lock, LOCKBIT, (intptr_t)0);</span>
      assert(w &amp; LOCKBIT, &quot;invariant&quot;);
      if (w == LOCKBIT) return;
      ParkEvent * const List = (ParkEvent *) (w &amp; ~LOCKBIT);
      assert(List != NULL, &quot;invariant&quot;);
      assert(List-&gt;OnList == intptr_t(Lock), &quot;invariant&quot;);
      ParkEvent * const nxt = List-&gt;ListNext;
      guarantee((intptr_t(nxt) &amp; LOCKBIT) == 0, &quot;invariant&quot;);
  
      // The following CAS() releases the lock and pops the head element.
      // The CAS() also ratifies the previously fetched lock-word value.
<span class="line-modified">!     if (Atomic::cmpxchg(Lock, w, intptr_t(nxt)) != w) {</span>
        continue;
      }
      List-&gt;OnList = 0;
      OrderAccess::fence();
      List-&gt;unpark();
</pre>
<center><a href="task.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
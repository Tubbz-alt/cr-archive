<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/os.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="orderAccess.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/os.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -36,14 +36,14 @@</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="udiff-line-removed">- #ifdef ASSERT</span>
  #include &quot;memory/guardedMemory.hpp&quot;
<span class="udiff-line-removed">- #endif</span>
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;oops/compressedOops.inline.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86,16 +86,10 @@</span>
  
  static size_t cur_malloc_words = 0;  // current size for MallocMaxTestWords
  
  DEBUG_ONLY(bool os::_mutex_init_done = false;)
  
<span class="udiff-line-removed">- void os_init_globals() {</span>
<span class="udiff-line-removed">-   // Called from init_globals().</span>
<span class="udiff-line-removed">-   // See Threads::create_vm() in thread.cpp, and init.cpp.</span>
<span class="udiff-line-removed">-   os::init_globals();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  static time_t get_timezone(const struct tm* time_struct) {
  #if defined(_ALLBSD_SOURCE)
    return time_struct-&gt;tm_gmtoff;
  #elif defined(_WINDOWS)
    long zone;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -277,16 +271,29 @@</span>
      return os::stat(buffer, &amp;statbuf) == 0;
    }
    return false;
  }
  
<span class="udiff-line-added">+ // Frees all memory allocated on the heap for the</span>
<span class="udiff-line-added">+ // supplied array of arrays of chars (a), where n</span>
<span class="udiff-line-added">+ // is the number of elements in the array.</span>
<span class="udiff-line-added">+ static void free_array_of_char_arrays(char** a, size_t n) {</span>
<span class="udiff-line-added">+       while (n &gt; 0) {</span>
<span class="udiff-line-added">+           n--;</span>
<span class="udiff-line-added">+           if (a[n] != NULL) {</span>
<span class="udiff-line-added">+             FREE_C_HEAP_ARRAY(char, a[n]);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       FREE_C_HEAP_ARRAY(char*, a);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  bool os::dll_locate_lib(char *buffer, size_t buflen,
                          const char* pname, const char* fname) {
    bool retval = false;
  
    size_t fullfnamelen = strlen(JNI_LIB_PREFIX) + strlen(fname) + strlen(JNI_LIB_SUFFIX);
<span class="udiff-line-modified-removed">-   char* fullfname = (char*)NEW_C_HEAP_ARRAY(char, fullfnamelen + 1, mtInternal);</span>
<span class="udiff-line-modified-added">+   char* fullfname = NEW_C_HEAP_ARRAY(char, fullfnamelen + 1, mtInternal);</span>
    if (dll_build_name(fullfname, fullfnamelen + 1, fname)) {
      const size_t pnamelen = pname ? strlen(pname) : 0;
  
      if (pnamelen == 0) {
        // If no path given, use current working directory.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -297,14 +304,14 @@</span>
          retval = conc_path_file_and_check(buffer, &amp;buffer[plen], buflen - plen,
                                            &quot;&quot;, lastchar, fullfname);
        }
      } else if (strchr(pname, *os::path_separator()) != NULL) {
        // A list of paths. Search for the path that contains the library.
<span class="udiff-line-modified-removed">-       int n;</span>
<span class="udiff-line-modified-removed">-       char** pelements = split_path(pname, &amp;n);</span>
<span class="udiff-line-modified-added">+       size_t n;</span>
<span class="udiff-line-modified-added">+       char** pelements = split_path(pname, &amp;n, fullfnamelen);</span>
        if (pelements != NULL) {
<span class="udiff-line-modified-removed">-         for (int i = 0; i &lt; n; i++) {</span>
<span class="udiff-line-modified-added">+         for (size_t i = 0; i &lt; n; i++) {</span>
            char* path = pelements[i];
            // Really shouldn&#39;t be NULL, but check can&#39;t hurt.
            size_t plen = (path == NULL) ? 0 : strlen(path);
            if (plen == 0) {
              continue; // Skip the empty path values.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -312,16 +319,11 @@</span>
            const char lastchar = path[plen - 1];
            retval = conc_path_file_and_check(buffer, buffer, buflen, path, lastchar, fullfname);
            if (retval) break;
          }
          // Release the storage allocated by split_path.
<span class="udiff-line-modified-removed">-         for (int i = 0; i &lt; n; i++) {</span>
<span class="udiff-line-removed">-           if (pelements[i] != NULL) {</span>
<span class="udiff-line-removed">-             FREE_C_HEAP_ARRAY(char, pelements[i]);</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         FREE_C_HEAP_ARRAY(char*, pelements);</span>
<span class="udiff-line-modified-added">+         free_array_of_char_arrays(pelements, n);</span>
        }
      } else {
        // A definite path.
        const char lastchar = pname[pnamelen-1];
        retval = conc_path_file_and_check(buffer, buffer, buflen, pname, lastchar, fullfname);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -358,15 +360,37 @@</span>
         return;
      }
  
      switch (sig) {
        case SIGBREAK: {
<span class="udiff-line-added">+ #if INCLUDE_SERVICES</span>
          // Check if the signal is a trigger to start the Attach Listener - in that
          // case don&#39;t print stack traces.
<span class="udiff-line-modified-removed">-         if (!DisableAttachMechanism &amp;&amp; AttachListener::is_init_trigger()) {</span>
<span class="udiff-line-modified-removed">-           continue;</span>
<span class="udiff-line-modified-added">+         if (!DisableAttachMechanism) {</span>
<span class="udiff-line-modified-added">+           // Attempt to transit state to AL_INITIALIZING.</span>
<span class="udiff-line-added">+           AttachListenerState cur_state = AttachListener::transit_state(AL_INITIALIZING, AL_NOT_INITIALIZED);</span>
<span class="udiff-line-added">+           if (cur_state == AL_INITIALIZING) {</span>
<span class="udiff-line-added">+             // Attach Listener has been started to initialize. Ignore this signal.</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+           } else if (cur_state == AL_NOT_INITIALIZED) {</span>
<span class="udiff-line-added">+             // Start to initialize.</span>
<span class="udiff-line-added">+             if (AttachListener::is_init_trigger()) {</span>
<span class="udiff-line-added">+               // Attach Listener has been initialized.</span>
<span class="udiff-line-added">+               // Accept subsequent request.</span>
<span class="udiff-line-added">+               continue;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+               // Attach Listener could not be started.</span>
<span class="udiff-line-added">+               // So we need to transit the state to AL_NOT_INITIALIZED.</span>
<span class="udiff-line-added">+               AttachListener::set_state(AL_NOT_INITIALIZED);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           } else if (AttachListener::check_socket_file()) {</span>
<span class="udiff-line-added">+             // Attach Listener has been started, but unix domain socket file</span>
<span class="udiff-line-added">+             // does not exist. So restart Attach Listener.</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+           }</span>
          }
<span class="udiff-line-added">+ #endif</span>
          // Print stack traces
          // Any SIGBREAK operations added here should make sure to flush
          // the output stream (e.g. tty-&gt;flush()) after output.  See 4803766.
          // Each module also prints an extra carriage return after its output.
          VM_PrintThreads op;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -466,11 +490,11 @@</span>
                              vmSymbols::add_method_name(),
                              vmSymbols::thread_void_signature(),
                              thread_oop,
                              CHECK);
  
<span class="udiff-line-modified-removed">-     { MutexLocker mu(Threads_lock);</span>
<span class="udiff-line-modified-added">+     { MutexLocker mu(THREAD, Threads_lock);</span>
        JavaThread* signal_thread = new JavaThread(&amp;signal_thread_entry);
  
        // At this point it may be possible that no osthread was created for the
        // JavaThread due to lack of memory. We would have to throw an exception
        // in that case. However, since this must work and we do not allow
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -510,18 +534,10 @@</span>
  void* os::native_java_library() {
    if (_native_java_library == NULL) {
      char buffer[JVM_MAXPATHLEN];
      char ebuf[1024];
  
<span class="udiff-line-removed">-     // Try to load verify dll first. In 1.3 java dll depends on it and is not</span>
<span class="udiff-line-removed">-     // always able to find it when the loading executable is outside the JDK.</span>
<span class="udiff-line-removed">-     // In order to keep working with 1.2 we ignore any loading errors.</span>
<span class="udiff-line-removed">-     if (dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(),</span>
<span class="udiff-line-removed">-                        &quot;verify&quot;)) {</span>
<span class="udiff-line-removed">-       dll_load(buffer, ebuf, sizeof(ebuf));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      // Load java dll
      if (dll_locate_lib(buffer, sizeof(buffer), Arguments::get_dll_dir(),
                         &quot;java&quot;)) {
        _native_java_library = dll_load(buffer, ebuf, sizeof(ebuf));
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -650,11 +666,11 @@</span>
      size_t words = (alloc_size / BytesPerWord);
  
      if ((cur_malloc_words + words) &gt; MallocMaxTestWords) {
        return true;
      }
<span class="udiff-line-modified-removed">-     Atomic::add(words, &amp;cur_malloc_words);</span>
<span class="udiff-line-modified-added">+     Atomic::add(&amp;cur_malloc_words, words);</span>
    }
    return false;
  }
  
  void* os::malloc(size_t size, MEMFLAGS flags) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -702,16 +718,19 @@</span>
      return NULL;
    }
    // Wrap memory with guard
    GuardedMemory guarded(ptr, size + nmt_header_size);
    ptr = guarded.get_user_ptr();
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ </span>
    if ((intptr_t)ptr == (intptr_t)MallocCatchPtr) {
      log_warning(malloc, free)(&quot;os::malloc caught, &quot; SIZE_FORMAT &quot; bytes --&gt; &quot; PTR_FORMAT, size, p2i(ptr));
      breakpoint();
    }
<span class="udiff-line-modified-removed">-   debug_only(if (paranoid) verify_memory(ptr));</span>
<span class="udiff-line-modified-added">+   if (paranoid) {</span>
<span class="udiff-line-added">+     verify_memory(ptr);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
  
    // we do not track guard memory
    return MemTracker::record_malloc((address)ptr, size, memflags, stack, level);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -734,12 +753,12 @@</span>
  
  #ifndef ASSERT
    NOT_PRODUCT(inc_stat_counter(&amp;num_mallocs, 1));
    NOT_PRODUCT(inc_stat_counter(&amp;alloc_bytes, size));
     // NMT support
<span class="udiff-line-removed">-   void* membase = MemTracker::record_free(memblock);</span>
    NMT_TrackingLevel level = MemTracker::tracking_level();
<span class="udiff-line-added">+   void* membase = MemTracker::record_free(memblock, level);</span>
    size_t  nmt_header_size = MemTracker::malloc_header_size(level);
    void* ptr = ::realloc(membase, size + nmt_header_size);
    return MemTracker::record_malloc(ptr, size, memflags, stack, level);
  #else
    if (memblock == NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -758,40 +777,38 @@</span>
    if (ptr != NULL ) {
      GuardedMemory guarded(MemTracker::malloc_base(memblock));
      // Guard&#39;s user data contains NMT header
      size_t memblock_size = guarded.get_user_size() - MemTracker::malloc_header_size(memblock);
      memcpy(ptr, memblock, MIN2(size, memblock_size));
<span class="udiff-line-modified-removed">-     if (paranoid) verify_memory(MemTracker::malloc_base(ptr));</span>
<span class="udiff-line-modified-removed">-     if ((intptr_t)ptr == (intptr_t)MallocCatchPtr) {</span>
<span class="udiff-line-removed">-       log_warning(malloc, free)(&quot;os::realloc caught, &quot; SIZE_FORMAT &quot; bytes --&gt; &quot; PTR_FORMAT, size, p2i(ptr));</span>
<span class="udiff-line-removed">-       breakpoint();</span>
<span class="udiff-line-modified-added">+     if (paranoid) {</span>
<span class="udiff-line-modified-added">+       verify_memory(MemTracker::malloc_base(ptr));</span>
      }
      os::free(memblock);
    }
    return ptr;
  #endif
  }
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+ // handles NULL pointers</span>
  void  os::free(void *memblock) {
    NOT_PRODUCT(inc_stat_counter(&amp;num_frees, 1));
  #ifdef ASSERT
    if (memblock == NULL) return;
    if ((intptr_t)memblock == (intptr_t)MallocCatchPtr) {
      log_warning(malloc, free)(&quot;os::free caught &quot; PTR_FORMAT, p2i(memblock));
      breakpoint();
    }
<span class="udiff-line-modified-removed">-   void* membase = MemTracker::record_free(memblock);</span>
<span class="udiff-line-modified-added">+   void* membase = MemTracker::record_free(memblock, MemTracker::tracking_level());</span>
    verify_memory(membase);
  
    GuardedMemory guarded(membase);
    size_t size = guarded.get_user_size();
    inc_stat_counter(&amp;free_bytes, size);
    membase = guarded.release_for_freeing();
    ::free(membase);
  #else
<span class="udiff-line-modified-removed">-   void* membase = MemTracker::record_free(memblock);</span>
<span class="udiff-line-modified-added">+   void* membase = MemTracker::record_free(memblock, MemTracker::tracking_level());</span>
    ::free(membase);
  #endif
  }
  
  void os::init_random(unsigned int initval) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -836,11 +853,11 @@</span>
  int os::random() {
    // Make updating the random seed thread safe.
    while (true) {
      unsigned int seed = _rand_seed;
      unsigned int rand = random_helper(seed);
<span class="udiff-line-modified-removed">-     if (Atomic::cmpxchg(rand, &amp;_rand_seed, seed) == seed) {</span>
<span class="udiff-line-modified-added">+     if (Atomic::cmpxchg(&amp;_rand_seed, seed, rand) == seed) {</span>
        return static_cast&lt;int&gt;(rand);
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -855,11 +872,11 @@</span>
  // to do so in a context in which races are impossible, or should do appropriate
  // locking.
  
  void os::start_thread(Thread* thread) {
    // guard suspend/resume
<span class="udiff-line-modified-removed">-   MutexLockerEx ml(thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MutexLocker ml(thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);</span>
    OSThread* osthread = thread-&gt;osthread();
    osthread-&gt;set_state(RUNNABLE);
    pd_start_thread(thread);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -909,10 +926,18 @@</span>
      }
    }
    st-&gt;cr();
  }
  
<span class="udiff-line-added">+ void os::print_dhm(outputStream* st, const char* startStr, long sec) {</span>
<span class="udiff-line-added">+   long days    = sec/86400;</span>
<span class="udiff-line-added">+   long hours   = (sec/3600) - (days * 24);</span>
<span class="udiff-line-added">+   long minutes = (sec/60) - (days * 1440) - (hours * 60);</span>
<span class="udiff-line-added">+   if (startStr == NULL) startStr = &quot;&quot;;</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;%s %ld days %ld:%02ld hours&quot;, startStr, days, hours, minutes);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void os::print_instructions(outputStream* st, address pc, int unitsize) {
    st-&gt;print_cr(&quot;Instructions: (pc=&quot; PTR_FORMAT &quot;)&quot;, p2i(pc));
    print_hex_dump(st, pc - 256, pc + 256, unitsize);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1021,12 +1046,13 @@</span>
    int deadbeef = 0xdeadbeef;  // tester value 2
    return (SafeFetch32(aligned, cafebabe) != cafebabe) || (SafeFetch32(aligned, deadbeef) != deadbeef);
  }
  
  bool os::is_readable_range(const void* from, const void* to) {
<span class="udiff-line-modified-removed">-   for (address p = align_down((address)from, min_page_size()); p &lt; to; p += min_page_size()) {</span>
<span class="udiff-line-modified-removed">-     if (!is_readable_pointer(p)) {</span>
<span class="udiff-line-modified-added">+   if ((uintptr_t)from &gt;= (uintptr_t)to) return false;</span>
<span class="udiff-line-modified-added">+   for (uintptr_t p = align_down((uintptr_t)from, min_page_size()); p &lt; (uintptr_t)to; p += min_page_size()) {</span>
<span class="udiff-line-added">+     if (!is_readable_pointer((const void*)p)) {</span>
        return false;
      }
    }
    return true;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1048,40 +1074,14 @@</span>
      b-&gt;dump_for_addr(addr, st, verbose);
      return;
    }
  
    // Check if addr points into Java heap.
<span class="udiff-line-modified-removed">-   if (Universe::heap()-&gt;is_in(addr)) {</span>
<span class="udiff-line-removed">-     oop o = oopDesc::oop_or_null(addr);</span>
<span class="udiff-line-removed">-     if (o != NULL) {</span>
<span class="udiff-line-removed">-       if ((HeapWord*)o == (HeapWord*)addr) {</span>
<span class="udiff-line-removed">-         st-&gt;print(INTPTR_FORMAT &quot; is an oop: &quot;, p2i(addr));</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         st-&gt;print(INTPTR_FORMAT &quot; is pointing into object: &quot; , p2i(addr));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       o-&gt;print_on(st);</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else if (Universe::heap()-&gt;is_in_reserved(addr)) {</span>
<span class="udiff-line-removed">-     st-&gt;print_cr(INTPTR_FORMAT &quot; is an unallocated location in the heap&quot;, p2i(addr));</span>
<span class="udiff-line-modified-added">+   if (Universe::heap()-&gt;print_location(st, addr)) {</span>
      return;
    }
  
<span class="udiff-line-removed">-   // Compressed oop needs to be decoded first.</span>
<span class="udiff-line-removed">- #ifdef _LP64</span>
<span class="udiff-line-removed">-   if (UseCompressedOops &amp;&amp; ((uintptr_t)addr &amp;~ (uintptr_t)max_juint) == 0) {</span>
<span class="udiff-line-removed">-     narrowOop narrow_oop = (narrowOop)(uintptr_t)addr;</span>
<span class="udiff-line-removed">-     oop o = oopDesc::decode_oop_raw(narrow_oop);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (oopDesc::is_valid(o)) {</span>
<span class="udiff-line-removed">-       st-&gt;print(UINT32_FORMAT &quot; is a compressed pointer to object: &quot;, narrow_oop);</span>
<span class="udiff-line-removed">-       o-&gt;print_on(st);</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
    bool accessible = is_readable_pointer(addr);
  
    // Check if addr is a JNI handle.
    if (align_down((intptr_t)addr, sizeof(intptr_t)) != 0 &amp;&amp; accessible) {
      if (JNIHandles::is_global_handle((jobject) addr)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1139,11 +1139,11 @@</span>
  
    // Compressed klass needs to be decoded first.
  #ifdef _LP64
    if (UseCompressedClassPointers &amp;&amp; ((uintptr_t)addr &amp;~ (uintptr_t)max_juint) == 0) {
      narrowKlass narrow_klass = (narrowKlass)(uintptr_t)addr;
<span class="udiff-line-modified-removed">-     Klass* k = Klass::decode_klass_raw(narrow_klass);</span>
<span class="udiff-line-modified-added">+     Klass* k = CompressedKlassPointers::decode_raw(narrow_klass);</span>
  
      if (Klass::is_valid(k)) {
        st-&gt;print_cr(UINT32_FORMAT &quot; is a compressed pointer to class: &quot; INTPTR_FORMAT, narrow_klass, p2i((HeapWord*)k));
        k-&gt;print_on(st);
        return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1222,13 +1222,10 @@</span>
          if (*p == &#39;%&#39;) formatted_path_len += home_len - 1;
          ++formatted_path_len;
      }
  
      char* formatted_path = NEW_C_HEAP_ARRAY(char, formatted_path_len + 1, mtInternal);
<span class="udiff-line-removed">-     if (formatted_path == NULL) {</span>
<span class="udiff-line-removed">-         return NULL;</span>
<span class="udiff-line-removed">-     }</span>
  
      // Create boot classpath from format, substituting separator chars and
      // java home directory.
      char* q = formatted_path;
      for (p = format_string; *p != 0; ++p) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1308,61 +1305,62 @@</span>
    FREE_C_HEAP_ARRAY(char, base_classes);
  
    return false;
  }
  
<span class="udiff-line-modified-removed">- /*</span>
<span class="udiff-line-modified-removed">-  * Splits a path, based on its separator, the number of</span>
<span class="udiff-line-modified-removed">-  * elements is returned back in n.</span>
<span class="udiff-line-modified-removed">-  * It is the callers responsibility to:</span>
<span class="udiff-line-modified-removed">-  *   a&gt; check the value of n, and n may be 0.</span>
<span class="udiff-line-modified-removed">-  *   b&gt; ignore any empty path elements</span>
<span class="udiff-line-modified-removed">-  *   c&gt; free up the data.</span>
<span class="udiff-line-modified-removed">-  */</span>
<span class="udiff-line-modified-removed">- char** os::split_path(const char* path, int* n) {</span>
<span class="udiff-line-modified-removed">-   *n = 0;</span>
<span class="udiff-line-modified-removed">-   if (path == NULL || strlen(path) == 0) {</span>
<span class="udiff-line-modified-added">+ // Splits a path, based on its separator, the number of</span>
<span class="udiff-line-modified-added">+ // elements is returned back in &quot;elements&quot;.</span>
<span class="udiff-line-modified-added">+ // file_name_length is used as a modifier for each path&#39;s</span>
<span class="udiff-line-modified-added">+ // length when compared to JVM_MAXPATHLEN. So if you know</span>
<span class="udiff-line-modified-added">+ // each returned path will have something appended when</span>
<span class="udiff-line-modified-added">+ // in use, you can pass the length of that in</span>
<span class="udiff-line-modified-added">+ // file_name_length, to ensure we detect if any path</span>
<span class="udiff-line-modified-added">+ // exceeds the maximum path length once prepended onto</span>
<span class="udiff-line-modified-added">+ // the sub-path/file name.</span>
<span class="udiff-line-modified-added">+ // It is the callers responsibility to:</span>
<span class="udiff-line-modified-added">+ //   a&gt; check the value of &quot;elements&quot;, which may be 0.</span>
<span class="udiff-line-added">+ //   b&gt; ignore any empty path elements</span>
<span class="udiff-line-added">+ //   c&gt; free up the data.</span>
<span class="udiff-line-added">+ char** os::split_path(const char* path, size_t* elements, size_t file_name_length) {</span>
<span class="udiff-line-added">+   *elements = (size_t)0;</span>
<span class="udiff-line-added">+   if (path == NULL || strlen(path) == 0 || file_name_length == (size_t)NULL) {</span>
      return NULL;
    }
    const char psepchar = *os::path_separator();
<span class="udiff-line-modified-removed">-   char* inpath = (char*)NEW_C_HEAP_ARRAY(char, strlen(path) + 1, mtInternal);</span>
<span class="udiff-line-removed">-   if (inpath == NULL) {</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   char* inpath = NEW_C_HEAP_ARRAY(char, strlen(path) + 1, mtInternal);</span>
    strcpy(inpath, path);
<span class="udiff-line-modified-removed">-   int count = 1;</span>
<span class="udiff-line-modified-added">+   size_t count = 1;</span>
    char* p = strchr(inpath, psepchar);
    // Get a count of elements to allocate memory
    while (p != NULL) {
      count++;
      p++;
      p = strchr(p, psepchar);
    }
<span class="udiff-line-modified-removed">-   char** opath = (char**) NEW_C_HEAP_ARRAY(char*, count, mtInternal);</span>
<span class="udiff-line-modified-removed">-   if (opath == NULL) {</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   char** opath = NEW_C_HEAP_ARRAY(char*, count, mtInternal);</span>
  
    // do the actual splitting
    p = inpath;
<span class="udiff-line-modified-removed">-   for (int i = 0 ; i &lt; count ; i++) {</span>
<span class="udiff-line-modified-added">+   for (size_t i = 0 ; i &lt; count ; i++) {</span>
      size_t len = strcspn(p, os::path_separator());
<span class="udiff-line-modified-removed">-     if (len &gt; JVM_MAXPATHLEN) {</span>
<span class="udiff-line-modified-removed">-       return NULL;</span>
<span class="udiff-line-modified-added">+     if (len + file_name_length &gt; JVM_MAXPATHLEN) {</span>
<span class="udiff-line-modified-added">+       // release allocated storage before exiting the vm</span>
<span class="udiff-line-added">+       free_array_of_char_arrays(opath, i++);</span>
<span class="udiff-line-added">+       vm_exit_during_initialization(&quot;The VM tried to use a path that exceeds the maximum path length for &quot;</span>
<span class="udiff-line-added">+                                     &quot;this system. Review path-containing parameters and properties, such as &quot;</span>
<span class="udiff-line-added">+                                     &quot;sun.boot.library.path, to identify potential sources for this path.&quot;);</span>
      }
      // allocate the string and add terminator storage
<span class="udiff-line-modified-removed">-     char* s  = (char*)NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);</span>
<span class="udiff-line-removed">-     if (s == NULL) {</span>
<span class="udiff-line-removed">-       return NULL;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     char* s = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);</span>
      strncpy(s, p, len);
      s[len] = &#39;\0&#39;;
      opath[i] = s;
      p += len + 1;
    }
    FREE_C_HEAP_ARRAY(char, inpath);
<span class="udiff-line-modified-removed">-   *n = count;</span>
<span class="udiff-line-modified-added">+   *elements = count;</span>
    return opath;
  }
  
  // Returns true if the current stack pointer is above the stack shadow
  // pages, false otherwise.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1812,13 +1810,25 @@</span>
   * returns the state set after the method is complete
   */
  os::SuspendResume::State os::SuspendResume::switch_state(os::SuspendResume::State from,
                                                           os::SuspendResume::State to)
  {
<span class="udiff-line-modified-removed">-   os::SuspendResume::State result = Atomic::cmpxchg(to, &amp;_state, from);</span>
<span class="udiff-line-modified-added">+   os::SuspendResume::State result = Atomic::cmpxchg(&amp;_state, from, to);</span>
    if (result == from) {
      // success
      return to;
    }
    return result;
  }
  #endif
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Convenience wrapper around naked_short_sleep to allow for longer sleep</span>
<span class="udiff-line-added">+ // times. Only for use by non-JavaThreads.</span>
<span class="udiff-line-added">+ void os::naked_sleep(jlong millis) {</span>
<span class="udiff-line-added">+   assert(!Thread::current()-&gt;is_Java_thread(), &quot;not for use by JavaThreads&quot;);</span>
<span class="udiff-line-added">+   const jlong limit = 999;</span>
<span class="udiff-line-added">+   while (millis &gt; limit) {</span>
<span class="udiff-line-added">+     naked_short_sleep(limit);</span>
<span class="udiff-line-added">+     millis -= limit;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   naked_short_sleep(millis);</span>
<span class="udiff-line-added">+ }</span>
</pre>
<center><a href="orderAccess.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
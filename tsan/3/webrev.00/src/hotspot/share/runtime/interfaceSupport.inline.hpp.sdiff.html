<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/interfaceSupport.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interfaceSupport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="java.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/interfaceSupport.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
 26 #define SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
 27 
 28 #include &quot;runtime/handles.inline.hpp&quot;
 29 #include &quot;runtime/mutexLocker.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/os.hpp&quot;
 32 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
 33 #include &quot;runtime/safepointVerifiers.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #include &quot;runtime/vmOperations.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;

 37 #include &quot;utilities/macros.hpp&quot;
 38 #include &quot;utilities/preserveException.hpp&quot;
 39 
 40 // Wrapper for all entry points to the virtual machine.
 41 
 42 // InterfaceSupport provides functionality used by the VM_LEAF_BASE and
 43 // VM_ENTRY_BASE macros. These macros are used to guard entry points into
 44 // the VM and perform checks upon leave of the VM.
 45 
 46 
 47 class InterfaceSupport: AllStatic {
 48 # ifdef ASSERT
 49  public:
 50   static long _scavenge_alot_counter;
 51   static long _fullgc_alot_counter;
 52   static long _number_of_calls;
 53   static long _fullgc_alot_invocation;
 54 
 55   // Helper methods used to implement +ScavengeALot and +FullGCALot
 56   static void check_gc_alot() { if (ScavengeALot || FullGCALot) gc_alot(); }
 57   static void gc_alot();
 58 
 59   static void walk_stack_from(vframe* start_vf);
 60   static void walk_stack();
 61 
 62   static void zombieAll();
 63   static void deoptimizeAll();
<span class="line-removed"> 64   static void stress_derived_pointers();</span>
 65   static void verify_stack();
 66   static void verify_last_frame();
 67 # endif
<span class="line-removed"> 68 </span>
<span class="line-removed"> 69  public:</span>
<span class="line-removed"> 70   static void serialize_thread_state_with_handler(JavaThread* thread) {</span>
<span class="line-removed"> 71     serialize_thread_state_internal(thread, true);</span>
<span class="line-removed"> 72   }</span>
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74   // Should only call this if we know that we have a proper SEH set up.</span>
<span class="line-removed"> 75   static void serialize_thread_state(JavaThread* thread) {</span>
<span class="line-removed"> 76     serialize_thread_state_internal(thread, false);</span>
<span class="line-removed"> 77   }</span>
<span class="line-removed"> 78 </span>
<span class="line-removed"> 79  private:</span>
<span class="line-removed"> 80   static void serialize_thread_state_internal(JavaThread* thread, bool needs_exception_handler) {</span>
<span class="line-removed"> 81     // Make sure new state is seen by VM thread</span>
<span class="line-removed"> 82     OrderAccess::fence();</span>
<span class="line-removed"> 83   }</span>
 84 };
 85 
 86 
 87 // Basic class for all thread transition classes.
 88 
 89 class ThreadStateTransition : public StackObj {
 90  protected:
 91   JavaThread* _thread;
 92  public:
 93   ThreadStateTransition(JavaThread *thread) {
 94     _thread = thread;
 95     assert(thread != NULL &amp;&amp; thread-&gt;is_Java_thread(), &quot;must be Java thread&quot;);
 96   }
 97 
 98   // Change threadstate in a manner, so safepoint can detect changes.
 99   // Time-critical: called on exit from every runtime routine
100   static inline void transition(JavaThread *thread, JavaThreadState from, JavaThreadState to) {
101     assert(from != _thread_in_Java, &quot;use transition_from_java&quot;);
102     assert(from != _thread_in_native, &quot;use transition_from_native&quot;);
103     assert((from &amp; 1) == 0 &amp;&amp; (to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
104     assert(thread-&gt;thread_state() == from, &quot;coming from wrong thread state&quot;);
<span class="line-removed">105     // Change to transition state</span>
<span class="line-removed">106     thread-&gt;set_thread_state((JavaThreadState)(from + 1));</span>
107 
<span class="line-modified">108     InterfaceSupport::serialize_thread_state(thread);</span>


109 
<span class="line-modified">110     SafepointMechanism::block_if_requested(thread);</span>
<span class="line-modified">111     thread-&gt;set_thread_state(to);</span>
<span class="line-removed">112 </span>
<span class="line-removed">113     CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
<span class="line-removed">114   }</span>
<span class="line-removed">115 </span>
<span class="line-removed">116   // transition_and_fence must be used on any thread state transition</span>
<span class="line-removed">117   // where there might not be a Java call stub on the stack, in</span>
<span class="line-removed">118   // particular on Windows where the Structured Exception Handler is</span>
<span class="line-removed">119   // set up in the call stub.</span>
<span class="line-removed">120   static inline void transition_and_fence(JavaThread *thread, JavaThreadState from, JavaThreadState to) {</span>
<span class="line-removed">121     assert(thread-&gt;thread_state() == from, &quot;coming from wrong thread state&quot;);</span>
<span class="line-removed">122     assert((from &amp; 1) == 0 &amp;&amp; (to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);</span>
<span class="line-removed">123     // Change to transition state</span>
<span class="line-removed">124     thread-&gt;set_thread_state((JavaThreadState)(from + 1));</span>
<span class="line-removed">125 </span>
<span class="line-removed">126     InterfaceSupport::serialize_thread_state_with_handler(thread);</span>
127 
128     SafepointMechanism::block_if_requested(thread);
129     thread-&gt;set_thread_state(to);
<span class="line-removed">130 </span>
<span class="line-removed">131     CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
132   }
133 
134   // Same as above, but assumes from = _thread_in_Java. This is simpler, since we
135   // never block on entry to the VM. This will break the code, since e.g. preserve arguments
136   // have not been setup.
137   static inline void transition_from_java(JavaThread *thread, JavaThreadState to) {
138     assert(thread-&gt;thread_state() == _thread_in_Java, &quot;coming from wrong thread state&quot;);
139     thread-&gt;set_thread_state(to);
140   }
141 
142   static inline void transition_from_native(JavaThread *thread, JavaThreadState to) {
143     assert((to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
144     assert(thread-&gt;thread_state() == _thread_in_native, &quot;coming from wrong thread state&quot;);
<span class="line-modified">145     // Change to transition state</span>
<span class="line-modified">146     thread-&gt;set_thread_state(_thread_in_native_trans);</span>
<span class="line-removed">147 </span>
<span class="line-removed">148     InterfaceSupport::serialize_thread_state_with_handler(thread);</span>
149 
150     // We never install asynchronous exceptions when coming (back) in
151     // to the runtime from native code because the runtime is not set
152     // up to handle exceptions floating around at arbitrary points.
153     if (SafepointMechanism::should_block(thread) || thread-&gt;is_suspend_after_native()) {
154       JavaThread::check_safepoint_and_suspend_for_native_trans(thread);
<span class="line-removed">155 </span>
<span class="line-removed">156       // Clear unhandled oops anywhere where we could block, even if we don&#39;t.</span>
<span class="line-removed">157       CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
158     }
159 
160     thread-&gt;set_thread_state(to);
161   }
162  protected:
163    void trans(JavaThreadState from, JavaThreadState to)  { transition(_thread, from, to); }
164    void trans_from_java(JavaThreadState to)              { transition_from_java(_thread, to); }
165    void trans_from_native(JavaThreadState to)            { transition_from_native(_thread, to); }
<span class="line-removed">166    void trans_and_fence(JavaThreadState from, JavaThreadState to) { transition_and_fence(_thread, from, to); }</span>
167 };
168 
169 class ThreadInVMForHandshake : public ThreadStateTransition {
170   const JavaThreadState _original_state;
171 
172   void transition_back() {
173     // This can be invoked from transition states and must return to the original state properly
174     assert(_thread-&gt;thread_state() == _thread_in_vm, &quot;should only call when leaving VM after handshake&quot;);
<span class="line-modified">175     _thread-&gt;set_thread_state(_thread_in_vm_trans);</span>
<span class="line-modified">176 </span>
<span class="line-removed">177     InterfaceSupport::serialize_thread_state(_thread);</span>
178 
179     SafepointMechanism::block_if_requested(_thread);
180 
181     _thread-&gt;set_thread_state(_original_state);






182   }
183 
184  public:
185 
186   ThreadInVMForHandshake(JavaThread* thread) : ThreadStateTransition(thread),
187       _original_state(thread-&gt;thread_state()) {
188 
189     if (thread-&gt;has_last_Java_frame()) {
190       thread-&gt;frame_anchor()-&gt;make_walkable(thread);
191     }
192 
193     thread-&gt;set_thread_state(_thread_in_vm);
194   }
195 
196   ~ThreadInVMForHandshake() {
197     transition_back();
198   }
199 
200 };
201 
202 class ThreadInVMfromJava : public ThreadStateTransition {
203  public:
204   ThreadInVMfromJava(JavaThread* thread) : ThreadStateTransition(thread) {
205     trans_from_java(_thread_in_vm);
206   }
207   ~ThreadInVMfromJava()  {
208     if (_thread-&gt;stack_yellow_reserved_zone_disabled()) {
209       _thread-&gt;enable_stack_yellow_reserved_zone();
210     }
211     trans(_thread_in_vm, _thread_in_Java);
212     // Check for pending. async. exceptions or suspends.
213     if (_thread-&gt;has_special_runtime_exit_condition()) _thread-&gt;handle_special_runtime_exit_condition();
214   }
215 };
216 
217 
218 class ThreadInVMfromUnknown {
<span class="line-removed">219  private:</span>
220   JavaThread* _thread;
221  public:
222   ThreadInVMfromUnknown() : _thread(NULL) {
223     Thread* t = Thread::current();
224     if (t-&gt;is_Java_thread()) {
225       JavaThread* t2 = (JavaThread*) t;
226       if (t2-&gt;thread_state() == _thread_in_native) {
227         _thread = t2;
228         ThreadStateTransition::transition_from_native(t2, _thread_in_vm);
229         // Used to have a HandleMarkCleaner but that is dangerous as
230         // it could free a handle in our (indirect, nested) caller.
231         // We expect any handles will be short lived and figure we
232         // don&#39;t need an actual HandleMark.
233       }
234     }
235   }
236   ~ThreadInVMfromUnknown()  {
237     if (_thread) {
<span class="line-modified">238       ThreadStateTransition::transition_and_fence(_thread, _thread_in_vm, _thread_in_native);</span>
239     }
240   }
241 };
242 
243 
244 class ThreadInVMfromNative : public ThreadStateTransition {
245  public:
246   ThreadInVMfromNative(JavaThread* thread) : ThreadStateTransition(thread) {
247     trans_from_native(_thread_in_vm);
248   }
249   ~ThreadInVMfromNative() {
<span class="line-modified">250     trans_and_fence(_thread_in_vm, _thread_in_native);</span>
251   }
252 };
253 
254 
255 class ThreadToNativeFromVM : public ThreadStateTransition {
256  public:
257   ThreadToNativeFromVM(JavaThread *thread) : ThreadStateTransition(thread) {
258     // We are leaving the VM at this point and going directly to native code.
259     // Block, if we are in the middle of a safepoint synchronization.
260     assert(!thread-&gt;owns_locks(), &quot;must release all locks when leaving VM&quot;);
261     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
<span class="line-modified">262     trans_and_fence(_thread_in_vm, _thread_in_native);</span>
263     // Check for pending. async. exceptions or suspends.
264     if (_thread-&gt;has_special_runtime_exit_condition()) _thread-&gt;handle_special_runtime_exit_condition(false);
265   }
266 
267   ~ThreadToNativeFromVM() {
268     trans_from_native(_thread_in_vm);
269     assert(!_thread-&gt;is_pending_jni_exception_check(), &quot;Pending JNI Exception Check&quot;);
270     // We don&#39;t need to clear_walkable because it will happen automagically when we return to java
271   }
272 };
273 
274 
275 class ThreadBlockInVM : public ThreadStateTransition {
276  public:
277   ThreadBlockInVM(JavaThread *thread)
278   : ThreadStateTransition(thread) {
279     // Once we are blocked vm expects stack to be walkable
280     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
<span class="line-modified">281     trans_and_fence(_thread_in_vm, _thread_blocked);</span>
282   }
283   ~ThreadBlockInVM() {
<span class="line-modified">284     trans_and_fence(_thread_blocked, _thread_in_vm);</span>

285     // We don&#39;t need to clear_walkable because it will happen automagically when we return to java
286   }
287 };
288 
289 // Unlike ThreadBlockInVM, this class is designed to avoid certain deadlock scenarios while making
<span class="line-modified">290 // transitions inside class Monitor in cases where we need to block for a safepoint or handshake. It</span>
<span class="line-modified">291 // receives an extra argument compared to ThreadBlockInVM, the address of a pointer to the monitor we</span>
<span class="line-modified">292 // are trying to acquire. This will be used to access and release the monitor if needed to avoid</span>
293 // said deadlocks.
294 // It works like ThreadBlockInVM but differs from it in two ways:
295 // - When transitioning in (constructor), it checks for safepoints without blocking, i.e., calls
296 //   back if needed to allow a pending safepoint to continue but does not block in it.
297 // - When transitioning back (destructor), if there is a pending safepoint or handshake it releases
<span class="line-modified">298 //   the monitor that is only partially acquired.</span>
299 class ThreadBlockInVMWithDeadlockCheck : public ThreadStateTransition {
300  private:
<span class="line-modified">301   Monitor** _in_flight_monitor_adr;</span>
<span class="line-modified">302 </span>
<span class="line-modified">303   void release_monitor() {</span>
<span class="line-modified">304     assert(_in_flight_monitor_adr != NULL, &quot;_in_flight_monitor_adr should have been set on constructor&quot;);</span>
<span class="line-modified">305     Monitor* in_flight_monitor = *_in_flight_monitor_adr;</span>
<span class="line-modified">306     if (in_flight_monitor != NULL) {</span>
<span class="line-modified">307       in_flight_monitor-&gt;release_for_safepoint();</span>
<span class="line-modified">308       *_in_flight_monitor_adr = NULL;</span>
309     }
310   }
311  public:
<span class="line-modified">312   ThreadBlockInVMWithDeadlockCheck(JavaThread* thread, Monitor** in_flight_monitor_adr)</span>
<span class="line-modified">313   : ThreadStateTransition(thread), _in_flight_monitor_adr(in_flight_monitor_adr) {</span>
314     // Once we are blocked vm expects stack to be walkable
315     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
316 
317     // All unsafe states are treated the same by the VMThread
318     // so we can skip the _thread_in_vm_trans state here. Since
319     // we don&#39;t read poll, it&#39;s enough to order the stores.
320     OrderAccess::storestore();
321 
322     thread-&gt;set_thread_state(_thread_blocked);
<span class="line-removed">323 </span>
<span class="line-removed">324     CHECK_UNHANDLED_OOPS_ONLY(_thread-&gt;clear_unhandled_oops();)</span>
325   }
326   ~ThreadBlockInVMWithDeadlockCheck() {
<span class="line-modified">327     // Change to transition state</span>
<span class="line-modified">328     _thread-&gt;set_thread_state((JavaThreadState)(_thread_blocked_trans));</span>
<span class="line-removed">329 </span>
<span class="line-removed">330     InterfaceSupport::serialize_thread_state_with_handler(_thread);</span>
331 
332     if (SafepointMechanism::should_block(_thread)) {
<span class="line-modified">333       release_monitor();</span>
334       SafepointMechanism::block_if_requested(_thread);
335     }
336 
337     _thread-&gt;set_thread_state(_thread_in_vm);
<span class="line-modified">338     CHECK_UNHANDLED_OOPS_ONLY(_thread-&gt;clear_unhandled_oops();)</span>
339   }
340 };
341 
342 
343 // This special transition class is only used to prevent asynchronous exceptions
344 // from being installed on vm exit in situations where we can&#39;t tolerate them.
345 // See bugs: 4324348, 4854693, 4998314, 5040492, 5050705.
346 class ThreadInVMfromJavaNoAsyncException : public ThreadStateTransition {
347  public:
348   ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread) {
349     trans_from_java(_thread_in_vm);
350   }
351   ~ThreadInVMfromJavaNoAsyncException()  {
352     if (_thread-&gt;stack_yellow_reserved_zone_disabled()) {
353       _thread-&gt;enable_stack_yellow_reserved_zone();
354     }
355     trans(_thread_in_vm, _thread_in_Java);
356     // NOTE: We do not check for pending. async. exceptions.
357     // If we did and moved the pending async exception over into the
358     // pending exception field, we would need to deopt (currently C2
359     // only). However, to do so would require that we transition back
360     // to the _thread_in_vm state. Instead we postpone the handling of
361     // the async exception.
362 
363 
364     // Check for pending. suspends only.
365     if (_thread-&gt;has_special_runtime_exit_condition())
366       _thread-&gt;handle_special_runtime_exit_condition(false);
367   }
368 };
369 
<span class="line-modified">370 // Debug class instantiated in JRT_ENTRY and ITR_ENTRY macro.</span>
371 // Can be used to verify properties on enter/exit of the VM.
372 
373 #ifdef ASSERT
374 class VMEntryWrapper {
375  public:
376   VMEntryWrapper();
377   ~VMEntryWrapper();
378 };
379 
380 
381 class VMNativeEntryWrapper {
382  public:
<span class="line-modified">383   VMNativeEntryWrapper() {</span>
<span class="line-modified">384     if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();</span>
<span class="line-removed">385   }</span>
<span class="line-removed">386 </span>
<span class="line-removed">387   ~VMNativeEntryWrapper() {</span>
<span class="line-removed">388     if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();</span>
<span class="line-removed">389   }</span>
<span class="line-removed">390 };</span>
<span class="line-removed">391 </span>
<span class="line-removed">392 #endif</span>
<span class="line-removed">393 </span>
<span class="line-removed">394 </span>
<span class="line-removed">395 // VM-internal runtime interface support</span>
<span class="line-removed">396 </span>
<span class="line-removed">397 // Definitions for JRT (Java (Compiler/Shared) Runtime)</span>
<span class="line-removed">398 </span>
<span class="line-removed">399 // JRT_LEAF currently can be called from either _thread_in_Java or</span>
<span class="line-removed">400 // _thread_in_native mode. In _thread_in_native, it is ok</span>
<span class="line-removed">401 // for another thread to trigger GC. The rest of the JRT_LEAF</span>
<span class="line-removed">402 // rules apply.</span>
<span class="line-removed">403 class JRTLeafVerifier : public NoSafepointVerifier {</span>
<span class="line-removed">404   static bool should_verify_GC();</span>
<span class="line-removed">405  public:</span>
<span class="line-removed">406 #ifdef ASSERT</span>
<span class="line-removed">407   JRTLeafVerifier();</span>
<span class="line-removed">408   ~JRTLeafVerifier();</span>
<span class="line-removed">409 #else</span>
<span class="line-removed">410   JRTLeafVerifier() {}</span>
<span class="line-removed">411   ~JRTLeafVerifier() {}</span>
<span class="line-removed">412 #endif</span>
413 };
414 
<span class="line-removed">415 #ifdef ASSERT</span>
<span class="line-removed">416 </span>
417 class RuntimeHistogramElement : public HistogramElement {
418   public:
419    RuntimeHistogramElement(const char* name);
420 };

421 

422 #define TRACE_CALL(result_type, header)                            \
423   InterfaceSupport::_number_of_calls++;                            \
424   if (CountRuntimeCalls) {                                         \
425     static RuntimeHistogramElement* e = new RuntimeHistogramElement(#header); \
426     if (e != NULL) e-&gt;increment_count();                           \
427   }
428 #else
429 #define TRACE_CALL(result_type, header)                            \
430   /* do nothing */
<span class="line-modified">431 #endif</span>
432 
433 
434 // LEAF routines do not lock, GC or throw exceptions
435 
436 #define VM_LEAF_BASE(result_type, header)                            \
437   TRACE_CALL(result_type, header)                                    \
438   debug_only(NoHandleMark __hm;)                                     \
439   os::verify_stack_alignment();                                      \
440   /* begin of body */
441 
442 #define VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)         \
443   TRACE_CALL(result_type, header)                                    \
444   debug_only(ResetNoHandleMark __rnhm;)                              \
445   HandleMarkCleaner __hm(thread);                                    \
446   Thread* THREAD = thread;                                           \
447   os::verify_stack_alignment();                                      \
448   /* begin of body */
449 
450 
451 // ENTRY routines may lock, GC and throw exceptions
452 
453 #define VM_ENTRY_BASE(result_type, header, thread)                   \
454   TRACE_CALL(result_type, header)                                    \
455   HandleMarkCleaner __hm(thread);                                    \
456   Thread* THREAD = thread;                                           \
457   os::verify_stack_alignment();                                      \
458   /* begin of body */
459 
460 
<span class="line-removed">461 // QUICK_ENTRY routines behave like ENTRY but without a handle mark</span>
<span class="line-removed">462 </span>
<span class="line-removed">463 #define VM_QUICK_ENTRY_BASE(result_type, header, thread)             \</span>
<span class="line-removed">464   TRACE_CALL(result_type, header)                                    \</span>
<span class="line-removed">465   debug_only(NoHandleMark __hm;)                                     \</span>
<span class="line-removed">466   Thread* THREAD = thread;                                           \</span>
<span class="line-removed">467   os::verify_stack_alignment();                                      \</span>
<span class="line-removed">468   /* begin of body */</span>
<span class="line-removed">469 </span>
<span class="line-removed">470 </span>
<span class="line-removed">471 // Definitions for IRT (Interpreter Runtime)</span>
<span class="line-removed">472 // (thread is an argument passed in to all these routines)</span>
<span class="line-removed">473 </span>
<span class="line-removed">474 #define IRT_ENTRY(result_type, header)                               \</span>
<span class="line-removed">475   result_type header {                                               \</span>
<span class="line-removed">476     ThreadInVMfromJava __tiv(thread);                                \</span>
<span class="line-removed">477     VM_ENTRY_BASE(result_type, header, thread)                       \</span>
<span class="line-removed">478     debug_only(VMEntryWrapper __vew;)</span>
<span class="line-removed">479 </span>
<span class="line-removed">480 </span>
<span class="line-removed">481 #define IRT_LEAF(result_type, header)                                \</span>
<span class="line-removed">482   result_type header {                                               \</span>
<span class="line-removed">483     VM_LEAF_BASE(result_type, header)                                \</span>
<span class="line-removed">484     debug_only(NoSafepointVerifier __nspv(true);)</span>
<span class="line-removed">485 </span>
<span class="line-removed">486 </span>
<span class="line-removed">487 #define IRT_ENTRY_NO_ASYNC(result_type, header)                      \</span>
<span class="line-removed">488   result_type header {                                               \</span>
<span class="line-removed">489     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \</span>
<span class="line-removed">490     VM_ENTRY_BASE(result_type, header, thread)                       \</span>
<span class="line-removed">491     debug_only(VMEntryWrapper __vew;)</span>
<span class="line-removed">492 </span>
<span class="line-removed">493 #define IRT_END }</span>
<span class="line-removed">494 </span>
495 #define JRT_ENTRY(result_type, header)                               \
496   result_type header {                                               \
497     ThreadInVMfromJava __tiv(thread);                                \
498     VM_ENTRY_BASE(result_type, header, thread)                       \
499     debug_only(VMEntryWrapper __vew;)
500 













501 
502 #define JRT_LEAF(result_type, header)                                \
503   result_type header {                                               \
504   VM_LEAF_BASE(result_type, header)                                  \
<span class="line-modified">505   debug_only(JRTLeafVerifier __jlv;)</span>
506 
507 
508 #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
509   result_type header {                                               \
510     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
511     VM_ENTRY_BASE(result_type, header, thread)                       \
512     debug_only(VMEntryWrapper __vew;)
513 
514 // Same as JRT Entry but allows for return value after the safepoint
515 // to get back into Java from the VM
516 #define JRT_BLOCK_ENTRY(result_type, header)                         \
517   result_type header {                                               \
518     TRACE_CALL(result_type, header)                                  \
519     HandleMarkCleaner __hm(thread);
520 
521 #define JRT_BLOCK                                                    \
522     {                                                                \
523     ThreadInVMfromJava __tiv(thread);                                \
524     Thread* THREAD = thread;                                         \
525     debug_only(VMEntryWrapper __vew;)
</pre>
<hr />
<pre>
533 #define JRT_BLOCK_END }
534 
535 #define JRT_END }
536 
537 // Definitions for JNI
538 
539 #define JNI_ENTRY(result_type, header)                               \
540     JNI_ENTRY_NO_PRESERVE(result_type, header)                       \
541     WeakPreserveExceptionMark __wem(thread);
542 
543 #define JNI_ENTRY_NO_PRESERVE(result_type, header)                   \
544 extern &quot;C&quot; {                                                         \
545   result_type JNICALL header {                                       \
546     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
547     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \
548     ThreadInVMfromNative __tiv(thread);                              \
549     debug_only(VMNativeEntryWrapper __vew;)                          \
550     VM_ENTRY_BASE(result_type, header, thread)
551 
552 
<span class="line-removed">553 // Ensure that the VMNativeEntryWrapper constructor, which can cause</span>
<span class="line-removed">554 // a GC, is called outside the NoHandleMark (set via VM_QUICK_ENTRY_BASE).</span>
<span class="line-removed">555 #define JNI_QUICK_ENTRY(result_type, header)                         \</span>
<span class="line-removed">556 extern &quot;C&quot; {                                                         \</span>
<span class="line-removed">557   result_type JNICALL header {                                       \</span>
<span class="line-removed">558     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \</span>
<span class="line-removed">559     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \</span>
<span class="line-removed">560     ThreadInVMfromNative __tiv(thread);                              \</span>
<span class="line-removed">561     debug_only(VMNativeEntryWrapper __vew;)                          \</span>
<span class="line-removed">562     VM_QUICK_ENTRY_BASE(result_type, header, thread)</span>
<span class="line-removed">563 </span>
<span class="line-removed">564 </span>
565 #define JNI_LEAF(result_type, header)                                \
566 extern &quot;C&quot; {                                                         \
567   result_type JNICALL header {                                       \
568     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
569     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \
570     VM_LEAF_BASE(result_type, header)
571 
572 
573 // Close the routine and the extern &quot;C&quot;
574 #define JNI_END } }
575 
576 
577 
578 // Definitions for JVM
579 
580 #define JVM_ENTRY(result_type, header)                               \
581 extern &quot;C&quot; {                                                         \
582   result_type JNICALL header {                                       \
583     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
584     ThreadInVMfromNative __tiv(thread);                              \
585     debug_only(VMNativeEntryWrapper __vew;)                          \
586     VM_ENTRY_BASE(result_type, header, thread)
587 
588 
589 #define JVM_ENTRY_NO_ENV(result_type, header)                        \
590 extern &quot;C&quot; {                                                         \
591   result_type JNICALL header {                                       \
592     JavaThread* thread = JavaThread::current();                      \
593     ThreadInVMfromNative __tiv(thread);                              \
594     debug_only(VMNativeEntryWrapper __vew;)                          \
595     VM_ENTRY_BASE(result_type, header, thread)
596 
597 
<span class="line-removed">598 #define JVM_QUICK_ENTRY(result_type, header)                         \</span>
<span class="line-removed">599 extern &quot;C&quot; {                                                         \</span>
<span class="line-removed">600   result_type JNICALL header {                                       \</span>
<span class="line-removed">601     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \</span>
<span class="line-removed">602     ThreadInVMfromNative __tiv(thread);                              \</span>
<span class="line-removed">603     debug_only(VMNativeEntryWrapper __vew;)                          \</span>
<span class="line-removed">604     VM_QUICK_ENTRY_BASE(result_type, header, thread)</span>
<span class="line-removed">605 </span>
<span class="line-removed">606 </span>
607 #define JVM_LEAF(result_type, header)                                \
608 extern &quot;C&quot; {                                                         \
609   result_type JNICALL header {                                       \
610     VM_Exit::block_if_vm_exited();                                   \
611     VM_LEAF_BASE(result_type, header)
612 
613 
614 #define JVM_ENTRY_FROM_LEAF(env, result_type, header)                \
615   { {                                                                \
616     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
617     ThreadInVMfromNative __tiv(thread);                              \
618     debug_only(VMNativeEntryWrapper __vew;)                          \
619     VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)
620 
621 
622 #define JVM_END } }
623 
624 #endif // SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
 26 #define SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
 27 
 28 #include &quot;runtime/handles.inline.hpp&quot;
 29 #include &quot;runtime/mutexLocker.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/os.hpp&quot;
 32 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
 33 #include &quot;runtime/safepointVerifiers.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #include &quot;runtime/vmOperations.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-added"> 37 #include &quot;utilities/histogram.hpp&quot;</span>
 38 #include &quot;utilities/macros.hpp&quot;
 39 #include &quot;utilities/preserveException.hpp&quot;
 40 
 41 // Wrapper for all entry points to the virtual machine.
 42 
 43 // InterfaceSupport provides functionality used by the VM_LEAF_BASE and
 44 // VM_ENTRY_BASE macros. These macros are used to guard entry points into
 45 // the VM and perform checks upon leave of the VM.
 46 
 47 
 48 class InterfaceSupport: AllStatic {
 49 # ifdef ASSERT
 50  public:
 51   static long _scavenge_alot_counter;
 52   static long _fullgc_alot_counter;
 53   static long _number_of_calls;
 54   static long _fullgc_alot_invocation;
 55 
 56   // Helper methods used to implement +ScavengeALot and +FullGCALot
 57   static void check_gc_alot() { if (ScavengeALot || FullGCALot) gc_alot(); }
 58   static void gc_alot();
 59 
 60   static void walk_stack_from(vframe* start_vf);
 61   static void walk_stack();
 62 
 63   static void zombieAll();
 64   static void deoptimizeAll();

 65   static void verify_stack();
 66   static void verify_last_frame();
 67 # endif
















 68 };
 69 
 70 
 71 // Basic class for all thread transition classes.
 72 
 73 class ThreadStateTransition : public StackObj {
 74  protected:
 75   JavaThread* _thread;
 76  public:
 77   ThreadStateTransition(JavaThread *thread) {
 78     _thread = thread;
 79     assert(thread != NULL &amp;&amp; thread-&gt;is_Java_thread(), &quot;must be Java thread&quot;);
 80   }
 81 
 82   // Change threadstate in a manner, so safepoint can detect changes.
 83   // Time-critical: called on exit from every runtime routine
 84   static inline void transition(JavaThread *thread, JavaThreadState from, JavaThreadState to) {
 85     assert(from != _thread_in_Java, &quot;use transition_from_java&quot;);
 86     assert(from != _thread_in_native, &quot;use transition_from_native&quot;);
 87     assert((from &amp; 1) == 0 &amp;&amp; (to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
 88     assert(thread-&gt;thread_state() == from, &quot;coming from wrong thread state&quot;);


 89 
<span class="line-modified"> 90     // Check NoSafepointVerifier</span>
<span class="line-added"> 91     // This also clears unhandled oops if CheckUnhandledOops is used.</span>
<span class="line-added"> 92     thread-&gt;check_possible_safepoint();</span>
 93 
<span class="line-modified"> 94     // Change to transition state and ensure it is seen by the VM thread.</span>
<span class="line-modified"> 95     thread-&gt;set_thread_state_fence((JavaThreadState)(from + 1));</span>















 96 
 97     SafepointMechanism::block_if_requested(thread);
 98     thread-&gt;set_thread_state(to);


 99   }
100 
101   // Same as above, but assumes from = _thread_in_Java. This is simpler, since we
102   // never block on entry to the VM. This will break the code, since e.g. preserve arguments
103   // have not been setup.
104   static inline void transition_from_java(JavaThread *thread, JavaThreadState to) {
105     assert(thread-&gt;thread_state() == _thread_in_Java, &quot;coming from wrong thread state&quot;);
106     thread-&gt;set_thread_state(to);
107   }
108 
109   static inline void transition_from_native(JavaThread *thread, JavaThreadState to) {
110     assert((to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
111     assert(thread-&gt;thread_state() == _thread_in_native, &quot;coming from wrong thread state&quot;);
<span class="line-modified">112     // Change to transition state and ensure it is seen by the VM thread.</span>
<span class="line-modified">113     thread-&gt;set_thread_state_fence(_thread_in_native_trans);</span>


114 
115     // We never install asynchronous exceptions when coming (back) in
116     // to the runtime from native code because the runtime is not set
117     // up to handle exceptions floating around at arbitrary points.
118     if (SafepointMechanism::should_block(thread) || thread-&gt;is_suspend_after_native()) {
119       JavaThread::check_safepoint_and_suspend_for_native_trans(thread);



120     }
121 
122     thread-&gt;set_thread_state(to);
123   }
124  protected:
125    void trans(JavaThreadState from, JavaThreadState to)  { transition(_thread, from, to); }
126    void trans_from_java(JavaThreadState to)              { transition_from_java(_thread, to); }
127    void trans_from_native(JavaThreadState to)            { transition_from_native(_thread, to); }

128 };
129 
130 class ThreadInVMForHandshake : public ThreadStateTransition {
131   const JavaThreadState _original_state;
132 
133   void transition_back() {
134     // This can be invoked from transition states and must return to the original state properly
135     assert(_thread-&gt;thread_state() == _thread_in_vm, &quot;should only call when leaving VM after handshake&quot;);
<span class="line-modified">136     // Change to transition state and ensure it is seen by the VM thread.</span>
<span class="line-modified">137     _thread-&gt;set_thread_state_fence(_thread_in_vm_trans);</span>

138 
139     SafepointMechanism::block_if_requested(_thread);
140 
141     _thread-&gt;set_thread_state(_original_state);
<span class="line-added">142 </span>
<span class="line-added">143     if (_original_state != _thread_blocked_trans &amp;&amp;  _original_state != _thread_in_vm_trans &amp;&amp;</span>
<span class="line-added">144         _thread-&gt;has_special_runtime_exit_condition()) {</span>
<span class="line-added">145       _thread-&gt;handle_special_runtime_exit_condition(</span>
<span class="line-added">146           !_thread-&gt;is_at_poll_safepoint() &amp;&amp; (_original_state != _thread_in_native_trans));</span>
<span class="line-added">147     }</span>
148   }
149 
150  public:
151 
152   ThreadInVMForHandshake(JavaThread* thread) : ThreadStateTransition(thread),
153       _original_state(thread-&gt;thread_state()) {
154 
155     if (thread-&gt;has_last_Java_frame()) {
156       thread-&gt;frame_anchor()-&gt;make_walkable(thread);
157     }
158 
159     thread-&gt;set_thread_state(_thread_in_vm);
160   }
161 
162   ~ThreadInVMForHandshake() {
163     transition_back();
164   }
165 
166 };
167 
168 class ThreadInVMfromJava : public ThreadStateTransition {
169  public:
170   ThreadInVMfromJava(JavaThread* thread) : ThreadStateTransition(thread) {
171     trans_from_java(_thread_in_vm);
172   }
173   ~ThreadInVMfromJava()  {
174     if (_thread-&gt;stack_yellow_reserved_zone_disabled()) {
175       _thread-&gt;enable_stack_yellow_reserved_zone();
176     }
177     trans(_thread_in_vm, _thread_in_Java);
178     // Check for pending. async. exceptions or suspends.
179     if (_thread-&gt;has_special_runtime_exit_condition()) _thread-&gt;handle_special_runtime_exit_condition();
180   }
181 };
182 
183 
184 class ThreadInVMfromUnknown {

185   JavaThread* _thread;
186  public:
187   ThreadInVMfromUnknown() : _thread(NULL) {
188     Thread* t = Thread::current();
189     if (t-&gt;is_Java_thread()) {
190       JavaThread* t2 = (JavaThread*) t;
191       if (t2-&gt;thread_state() == _thread_in_native) {
192         _thread = t2;
193         ThreadStateTransition::transition_from_native(t2, _thread_in_vm);
194         // Used to have a HandleMarkCleaner but that is dangerous as
195         // it could free a handle in our (indirect, nested) caller.
196         // We expect any handles will be short lived and figure we
197         // don&#39;t need an actual HandleMark.
198       }
199     }
200   }
201   ~ThreadInVMfromUnknown()  {
202     if (_thread) {
<span class="line-modified">203       ThreadStateTransition::transition(_thread, _thread_in_vm, _thread_in_native);</span>
204     }
205   }
206 };
207 
208 
209 class ThreadInVMfromNative : public ThreadStateTransition {
210  public:
211   ThreadInVMfromNative(JavaThread* thread) : ThreadStateTransition(thread) {
212     trans_from_native(_thread_in_vm);
213   }
214   ~ThreadInVMfromNative() {
<span class="line-modified">215     trans(_thread_in_vm, _thread_in_native);</span>
216   }
217 };
218 
219 
220 class ThreadToNativeFromVM : public ThreadStateTransition {
221  public:
222   ThreadToNativeFromVM(JavaThread *thread) : ThreadStateTransition(thread) {
223     // We are leaving the VM at this point and going directly to native code.
224     // Block, if we are in the middle of a safepoint synchronization.
225     assert(!thread-&gt;owns_locks(), &quot;must release all locks when leaving VM&quot;);
226     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
<span class="line-modified">227     trans(_thread_in_vm, _thread_in_native);</span>
228     // Check for pending. async. exceptions or suspends.
229     if (_thread-&gt;has_special_runtime_exit_condition()) _thread-&gt;handle_special_runtime_exit_condition(false);
230   }
231 
232   ~ThreadToNativeFromVM() {
233     trans_from_native(_thread_in_vm);
234     assert(!_thread-&gt;is_pending_jni_exception_check(), &quot;Pending JNI Exception Check&quot;);
235     // We don&#39;t need to clear_walkable because it will happen automagically when we return to java
236   }
237 };
238 
239 
240 class ThreadBlockInVM : public ThreadStateTransition {
241  public:
242   ThreadBlockInVM(JavaThread *thread)
243   : ThreadStateTransition(thread) {
244     // Once we are blocked vm expects stack to be walkable
245     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
<span class="line-modified">246     trans(_thread_in_vm, _thread_blocked);</span>
247   }
248   ~ThreadBlockInVM() {
<span class="line-modified">249     trans(_thread_blocked, _thread_in_vm);</span>
<span class="line-added">250     OrderAccess::cross_modify_fence();</span>
251     // We don&#39;t need to clear_walkable because it will happen automagically when we return to java
252   }
253 };
254 
255 // Unlike ThreadBlockInVM, this class is designed to avoid certain deadlock scenarios while making
<span class="line-modified">256 // transitions inside class Mutex in cases where we need to block for a safepoint or handshake. It</span>
<span class="line-modified">257 // receives an extra argument compared to ThreadBlockInVM, the address of a pointer to the mutex we</span>
<span class="line-modified">258 // are trying to acquire. This will be used to access and release the mutex if needed to avoid</span>
259 // said deadlocks.
260 // It works like ThreadBlockInVM but differs from it in two ways:
261 // - When transitioning in (constructor), it checks for safepoints without blocking, i.e., calls
262 //   back if needed to allow a pending safepoint to continue but does not block in it.
263 // - When transitioning back (destructor), if there is a pending safepoint or handshake it releases
<span class="line-modified">264 //   the mutex that is only partially acquired.</span>
265 class ThreadBlockInVMWithDeadlockCheck : public ThreadStateTransition {
266  private:
<span class="line-modified">267   Mutex** _in_flight_mutex_addr;</span>
<span class="line-modified">268 </span>
<span class="line-modified">269   void release_mutex() {</span>
<span class="line-modified">270     assert(_in_flight_mutex_addr != NULL, &quot;_in_flight_mutex_addr should have been set on constructor&quot;);</span>
<span class="line-modified">271     Mutex* in_flight_mutex = *_in_flight_mutex_addr;</span>
<span class="line-modified">272     if (in_flight_mutex != NULL) {</span>
<span class="line-modified">273       in_flight_mutex-&gt;release_for_safepoint();</span>
<span class="line-modified">274       *_in_flight_mutex_addr = NULL;</span>
275     }
276   }
277  public:
<span class="line-modified">278   ThreadBlockInVMWithDeadlockCheck(JavaThread* thread, Mutex** in_flight_mutex_addr)</span>
<span class="line-modified">279   : ThreadStateTransition(thread), _in_flight_mutex_addr(in_flight_mutex_addr) {</span>
280     // Once we are blocked vm expects stack to be walkable
281     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
282 
283     // All unsafe states are treated the same by the VMThread
284     // so we can skip the _thread_in_vm_trans state here. Since
285     // we don&#39;t read poll, it&#39;s enough to order the stores.
286     OrderAccess::storestore();
287 
288     thread-&gt;set_thread_state(_thread_blocked);


289   }
290   ~ThreadBlockInVMWithDeadlockCheck() {
<span class="line-modified">291     // Change to transition state and ensure it is seen by the VM thread.</span>
<span class="line-modified">292     _thread-&gt;set_thread_state_fence((JavaThreadState)(_thread_blocked_trans));</span>


293 
294     if (SafepointMechanism::should_block(_thread)) {
<span class="line-modified">295       release_mutex();</span>
296       SafepointMechanism::block_if_requested(_thread);
297     }
298 
299     _thread-&gt;set_thread_state(_thread_in_vm);
<span class="line-modified">300     OrderAccess::cross_modify_fence();</span>
301   }
302 };
303 
304 
305 // This special transition class is only used to prevent asynchronous exceptions
306 // from being installed on vm exit in situations where we can&#39;t tolerate them.
307 // See bugs: 4324348, 4854693, 4998314, 5040492, 5050705.
308 class ThreadInVMfromJavaNoAsyncException : public ThreadStateTransition {
309  public:
310   ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread) {
311     trans_from_java(_thread_in_vm);
312   }
313   ~ThreadInVMfromJavaNoAsyncException()  {
314     if (_thread-&gt;stack_yellow_reserved_zone_disabled()) {
315       _thread-&gt;enable_stack_yellow_reserved_zone();
316     }
317     trans(_thread_in_vm, _thread_in_Java);
318     // NOTE: We do not check for pending. async. exceptions.
319     // If we did and moved the pending async exception over into the
320     // pending exception field, we would need to deopt (currently C2
321     // only). However, to do so would require that we transition back
322     // to the _thread_in_vm state. Instead we postpone the handling of
323     // the async exception.
324 
325 
326     // Check for pending. suspends only.
327     if (_thread-&gt;has_special_runtime_exit_condition())
328       _thread-&gt;handle_special_runtime_exit_condition(false);
329   }
330 };
331 
<span class="line-modified">332 // Debug class instantiated in JRT_ENTRY macro.</span>
333 // Can be used to verify properties on enter/exit of the VM.
334 
335 #ifdef ASSERT
336 class VMEntryWrapper {
337  public:
338   VMEntryWrapper();
339   ~VMEntryWrapper();
340 };
341 
342 
343 class VMNativeEntryWrapper {
344  public:
<span class="line-modified">345   VMNativeEntryWrapper();</span>
<span class="line-modified">346   ~VMNativeEntryWrapper();</span>




























347 };
348 


349 class RuntimeHistogramElement : public HistogramElement {
350   public:
351    RuntimeHistogramElement(const char* name);
352 };
<span class="line-added">353 #endif // ASSERT</span>
354 
<span class="line-added">355 #ifdef ASSERT</span>
356 #define TRACE_CALL(result_type, header)                            \
357   InterfaceSupport::_number_of_calls++;                            \
358   if (CountRuntimeCalls) {                                         \
359     static RuntimeHistogramElement* e = new RuntimeHistogramElement(#header); \
360     if (e != NULL) e-&gt;increment_count();                           \
361   }
362 #else
363 #define TRACE_CALL(result_type, header)                            \
364   /* do nothing */
<span class="line-modified">365 #endif // ASSERT</span>
366 
367 
368 // LEAF routines do not lock, GC or throw exceptions
369 
370 #define VM_LEAF_BASE(result_type, header)                            \
371   TRACE_CALL(result_type, header)                                    \
372   debug_only(NoHandleMark __hm;)                                     \
373   os::verify_stack_alignment();                                      \
374   /* begin of body */
375 
376 #define VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)         \
377   TRACE_CALL(result_type, header)                                    \
378   debug_only(ResetNoHandleMark __rnhm;)                              \
379   HandleMarkCleaner __hm(thread);                                    \
380   Thread* THREAD = thread;                                           \
381   os::verify_stack_alignment();                                      \
382   /* begin of body */
383 
384 
385 // ENTRY routines may lock, GC and throw exceptions
386 
387 #define VM_ENTRY_BASE(result_type, header, thread)                   \
388   TRACE_CALL(result_type, header)                                    \
389   HandleMarkCleaner __hm(thread);                                    \
390   Thread* THREAD = thread;                                           \
391   os::verify_stack_alignment();                                      \
392   /* begin of body */
393 
394 


































395 #define JRT_ENTRY(result_type, header)                               \
396   result_type header {                                               \
397     ThreadInVMfromJava __tiv(thread);                                \
398     VM_ENTRY_BASE(result_type, header, thread)                       \
399     debug_only(VMEntryWrapper __vew;)
400 
<span class="line-added">401 // JRT_LEAF currently can be called from either _thread_in_Java or</span>
<span class="line-added">402 // _thread_in_native mode.</span>
<span class="line-added">403 //</span>
<span class="line-added">404 // JRT_LEAF rules:</span>
<span class="line-added">405 // A JRT_LEAF method may not interfere with safepointing by</span>
<span class="line-added">406 //   1) acquiring or blocking on a Mutex or JavaLock - checked</span>
<span class="line-added">407 //   2) allocating heap memory - checked</span>
<span class="line-added">408 //   3) executing a VM operation - checked</span>
<span class="line-added">409 //   4) executing a system call (including malloc) that could block or grab a lock</span>
<span class="line-added">410 //   5) invoking GC</span>
<span class="line-added">411 //   6) reaching a safepoint</span>
<span class="line-added">412 //   7) running too long</span>
<span class="line-added">413 // Nor may any method it calls.</span>
414 
415 #define JRT_LEAF(result_type, header)                                \
416   result_type header {                                               \
417   VM_LEAF_BASE(result_type, header)                                  \
<span class="line-modified">418   debug_only(NoSafepointVerifier __nsv;)</span>
419 
420 
421 #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
422   result_type header {                                               \
423     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
424     VM_ENTRY_BASE(result_type, header, thread)                       \
425     debug_only(VMEntryWrapper __vew;)
426 
427 // Same as JRT Entry but allows for return value after the safepoint
428 // to get back into Java from the VM
429 #define JRT_BLOCK_ENTRY(result_type, header)                         \
430   result_type header {                                               \
431     TRACE_CALL(result_type, header)                                  \
432     HandleMarkCleaner __hm(thread);
433 
434 #define JRT_BLOCK                                                    \
435     {                                                                \
436     ThreadInVMfromJava __tiv(thread);                                \
437     Thread* THREAD = thread;                                         \
438     debug_only(VMEntryWrapper __vew;)
</pre>
<hr />
<pre>
446 #define JRT_BLOCK_END }
447 
448 #define JRT_END }
449 
450 // Definitions for JNI
451 
452 #define JNI_ENTRY(result_type, header)                               \
453     JNI_ENTRY_NO_PRESERVE(result_type, header)                       \
454     WeakPreserveExceptionMark __wem(thread);
455 
456 #define JNI_ENTRY_NO_PRESERVE(result_type, header)                   \
457 extern &quot;C&quot; {                                                         \
458   result_type JNICALL header {                                       \
459     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
460     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \
461     ThreadInVMfromNative __tiv(thread);                              \
462     debug_only(VMNativeEntryWrapper __vew;)                          \
463     VM_ENTRY_BASE(result_type, header, thread)
464 
465 












466 #define JNI_LEAF(result_type, header)                                \
467 extern &quot;C&quot; {                                                         \
468   result_type JNICALL header {                                       \
469     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
470     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \
471     VM_LEAF_BASE(result_type, header)
472 
473 
474 // Close the routine and the extern &quot;C&quot;
475 #define JNI_END } }
476 
477 
478 
479 // Definitions for JVM
480 
481 #define JVM_ENTRY(result_type, header)                               \
482 extern &quot;C&quot; {                                                         \
483   result_type JNICALL header {                                       \
484     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
485     ThreadInVMfromNative __tiv(thread);                              \
486     debug_only(VMNativeEntryWrapper __vew;)                          \
487     VM_ENTRY_BASE(result_type, header, thread)
488 
489 
490 #define JVM_ENTRY_NO_ENV(result_type, header)                        \
491 extern &quot;C&quot; {                                                         \
492   result_type JNICALL header {                                       \
493     JavaThread* thread = JavaThread::current();                      \
494     ThreadInVMfromNative __tiv(thread);                              \
495     debug_only(VMNativeEntryWrapper __vew;)                          \
496     VM_ENTRY_BASE(result_type, header, thread)
497 
498 









499 #define JVM_LEAF(result_type, header)                                \
500 extern &quot;C&quot; {                                                         \
501   result_type JNICALL header {                                       \
502     VM_Exit::block_if_vm_exited();                                   \
503     VM_LEAF_BASE(result_type, header)
504 
505 
506 #define JVM_ENTRY_FROM_LEAF(env, result_type, header)                \
507   { {                                                                \
508     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
509     ThreadInVMfromNative __tiv(thread);                              \
510     debug_only(VMNativeEntryWrapper __vew;)                          \
511     VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)
512 
513 
514 #define JVM_END } }
515 
516 #endif // SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="interfaceSupport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="java.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
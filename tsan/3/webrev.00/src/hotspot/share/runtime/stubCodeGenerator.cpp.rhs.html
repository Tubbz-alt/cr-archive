<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/stubCodeGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;compiler/disassembler.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;prims/forte.hpp&quot;
 32 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 33 
 34 
 35 // Implementation of StubCodeDesc
 36 
 37 StubCodeDesc* StubCodeDesc::_list = NULL;
 38 bool          StubCodeDesc::_frozen = false;
 39 
 40 StubCodeDesc* StubCodeDesc::desc_for(address pc) {
 41   StubCodeDesc* p = _list;
 42   while (p != NULL &amp;&amp; !p-&gt;contains(pc)) {
 43     p = p-&gt;_next;
 44   }
 45   return p;
 46 }
 47 
 48 const char* StubCodeDesc::name_for(address pc) {
 49   StubCodeDesc* p = desc_for(pc);
 50   return p == NULL ? NULL : p-&gt;name();
 51 }
 52 
 53 
 54 void StubCodeDesc::freeze() {
 55   assert(!_frozen, &quot;repeated freeze operation&quot;);
 56   _frozen = true;
 57 }
 58 
 59 void StubCodeDesc::print_on(outputStream* st) const {
 60   st-&gt;print(&quot;%s&quot;, group());
 61   st-&gt;print(&quot;::&quot;);
 62   st-&gt;print(&quot;%s&quot;, name());
<a name="2" id="anc2"></a><span class="line-modified"> 63   st-&gt;print(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;] (%d bytes)&quot;, p2i(begin()), p2i(end()), size_in_bytes());</span>
 64 }
 65 
<a name="3" id="anc3"></a><span class="line-added"> 66 void StubCodeDesc::print() const { print_on(tty); }</span>
<span class="line-added"> 67 </span>
 68 // Implementation of StubCodeGenerator
 69 
 70 StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, bool print_code) {
 71   _masm = new MacroAssembler(code );
 72   _print_code = PrintStubCode || print_code;
 73 }
 74 
 75 StubCodeGenerator::~StubCodeGenerator() {
 76   if (PRODUCT_ONLY(_print_code) NOT_PRODUCT(true)) {
 77     CodeBuffer* cbuf = _masm-&gt;code();
 78     CodeBlob*   blob = CodeCache::find_blob_unsafe(cbuf-&gt;insts()-&gt;start());
 79     if (blob != NULL) {
 80       blob-&gt;set_strings(cbuf-&gt;strings());
 81     }
 82   }
 83 }
 84 
 85 void StubCodeGenerator::stub_prolog(StubCodeDesc* cdesc) {
 86   // default implementation - do nothing
 87 }
 88 
 89 void StubCodeGenerator::stub_epilog(StubCodeDesc* cdesc) {
 90   if (_print_code) {
 91     CodeStrings cs;
 92     ptrdiff_t offset = 0;
 93 #ifndef PRODUCT
 94     // Find the code strings in the outer CodeBuffer.
 95     CodeBuffer *outer_cbuf = _masm-&gt;code_section()-&gt;outer();
 96     cs = outer_cbuf-&gt;strings();
 97     // The offset from the start of the outer CodeBuffer to the start
 98     // of this stub.
 99     offset = cdesc-&gt;begin() - outer_cbuf-&gt;insts()-&gt;start();
100 #endif
<a name="4" id="anc4"></a><span class="line-modified">101     ttyLocker ttyl;</span>
<span class="line-added">102     tty-&gt;print_cr(&quot;- - - [BEGIN] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&quot;);</span>
<span class="line-added">103     cdesc-&gt;print_on(tty);</span>
104     tty-&gt;cr();
<a name="5" id="anc5"></a><span class="line-modified">105     Disassembler::decode(cdesc-&gt;begin(), cdesc-&gt;end(), tty, cs /*, offset */);</span>
<span class="line-added">106     tty-&gt;print_cr(&quot;- - - [END] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&quot;);</span>
107     tty-&gt;cr();
108   }
109 }
110 
111 
112 // Implementation of CodeMark
113 
114 StubCodeMark::StubCodeMark(StubCodeGenerator* cgen, const char* group, const char* name) {
115   _cgen  = cgen;
116   _cdesc = new StubCodeDesc(group, name, _cgen-&gt;assembler()-&gt;pc());
117   _cgen-&gt;stub_prolog(_cdesc);
118   // define the stub&#39;s beginning (= entry point) to be after the prolog:
119   _cdesc-&gt;set_begin(_cgen-&gt;assembler()-&gt;pc());
120 }
121 
122 StubCodeMark::~StubCodeMark() {
123   _cgen-&gt;assembler()-&gt;flush();
124   _cdesc-&gt;set_end(_cgen-&gt;assembler()-&gt;pc());
125   assert(StubCodeDesc::_list == _cdesc, &quot;expected order on list&quot;);
126   _cgen-&gt;stub_epilog(_cdesc);
127   Forte::register_stub(_cdesc-&gt;name(), _cdesc-&gt;begin(), _cdesc-&gt;end());
128 
129   if (JvmtiExport::should_post_dynamic_code_generated()) {
130     JvmtiExport::post_dynamic_code_generated(_cdesc-&gt;name(), _cdesc-&gt;begin(), _cdesc-&gt;end());
131   }
132 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
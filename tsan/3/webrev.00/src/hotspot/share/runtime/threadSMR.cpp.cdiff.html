<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/threadSMR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="threadHeapSampler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadSMR.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/threadSMR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,18 ***</span>
<span class="line-new-header">--- 23,23 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/jniHandles.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/sharedRuntime.hpp&quot;</span>
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/threadSMR.inline.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
<span class="line-added">+ #include &quot;services/threadIdTable.hpp&quot;</span>
  #include &quot;services/threadService.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;utilities/resourceHash.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
  
  // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
  // -XX:+EnableThreadSMRStatistics:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,15 ***</span>
  
  // Max # of parallel ThreadsLists on the to-delete list.
  // Impl note: See _to_delete_list_cnt note.
  uint                  ThreadsSMRSupport::_to_delete_list_max = 0;
  
<span class="line-removed">- </span>
  // &#39;inline&#39; functions first so the definitions are before first use:
  
  inline void ThreadsSMRSupport::add_deleted_thread_times(uint add_value) {
<span class="line-modified">!   Atomic::add(add_value, &amp;_deleted_thread_times);</span>
  }
  
  inline void ThreadsSMRSupport::inc_deleted_thread_cnt() {
    Atomic::inc(&amp;_deleted_thread_cnt);
  }
<span class="line-new-header">--- 132,14 ---</span>
  
  // Max # of parallel ThreadsLists on the to-delete list.
  // Impl note: See _to_delete_list_cnt note.
  uint                  ThreadsSMRSupport::_to_delete_list_max = 0;
  
  // &#39;inline&#39; functions first so the definitions are before first use:
  
  inline void ThreadsSMRSupport::add_deleted_thread_times(uint add_value) {
<span class="line-modified">!   Atomic::add(&amp;_deleted_thread_times, add_value);</span>
  }
  
  inline void ThreadsSMRSupport::inc_deleted_thread_cnt() {
    Atomic::inc(&amp;_deleted_thread_cnt);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,11 ***</span>
      uint cur_value = _deleted_thread_time_max;
      if (new_value &lt;= cur_value) {
        // No need to update max value so we&#39;re done.
        break;
      }
<span class="line-modified">!     if (Atomic::cmpxchg(new_value, &amp;_deleted_thread_time_max, cur_value) == cur_value) {</span>
        // Updated max value so we&#39;re done. Otherwise try it all again.
        break;
      }
    }
  }
<span class="line-new-header">--- 157,11 ---</span>
      uint cur_value = _deleted_thread_time_max;
      if (new_value &lt;= cur_value) {
        // No need to update max value so we&#39;re done.
        break;
      }
<span class="line-modified">!     if (Atomic::cmpxchg(&amp;_deleted_thread_time_max, cur_value, new_value) == cur_value) {</span>
        // Updated max value so we&#39;re done. Otherwise try it all again.
        break;
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,11 ***</span>
      _java_thread_list_max = new_value;
    }
  }
  
  inline ThreadsList* ThreadsSMRSupport::xchg_java_thread_list(ThreadsList* new_list) {
<span class="line-modified">!   return (ThreadsList*)Atomic::xchg(new_list, &amp;_java_thread_list);</span>
  }
  
  // Hash table of pointers found by a scan. Used for collecting hazard
  // pointers (ThreadsList references). Also used for collecting JavaThreads
  // that are indirectly referenced by hazard ptrs. An instance of this
<span class="line-new-header">--- 171,11 ---</span>
      _java_thread_list_max = new_value;
    }
  }
  
  inline ThreadsList* ThreadsSMRSupport::xchg_java_thread_list(ThreadsList* new_list) {
<span class="line-modified">!   return (ThreadsList*)Atomic::xchg(&amp;_java_thread_list, new_list);</span>
  }
  
  // Hash table of pointers found by a scan. Used for collecting hazard
  // pointers (ThreadsList references). Also used for collecting JavaThreads
  // that are indirectly referenced by hazard ptrs. An instance of this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 525,10 ***</span>
<span class="line-new-header">--- 529,26 ---</span>
    if (ThreadsSMRSupport::is_bootstrap_list(_list)) {
      // We are early in VM bootstrapping so nothing to do here.
      return;
    }
  
<span class="line-added">+   if ( _thread == VM_Exit::shutdown_thread()) {</span>
<span class="line-added">+     // The shutdown thread has removed itself from the Threads</span>
<span class="line-added">+     // list and is safe to have a waiver from this check because</span>
<span class="line-added">+     // VM_Exit::_shutdown_thread is not set until after the VMThread</span>
<span class="line-added">+     // has started the final safepoint which holds the Threads_lock</span>
<span class="line-added">+     // for the remainder of the VM&#39;s life.</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (VMError::is_error_reported() &amp;&amp;</span>
<span class="line-added">+       VMError::get_first_error_tid() == os::current_thread_id()) {</span>
<span class="line-added">+     // If there is an error reported by this thread it may use ThreadsList even</span>
<span class="line-added">+     // if it&#39;s unsafe.</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // The closure will attempt to verify that the calling thread can
    // be found by threads_do() on the specified ThreadsList. If it
    // is successful, then the specified ThreadsList was acquired as
    // a stable hazard ptr by the calling thread in a way that honored
    // the Thread-SMR protocol.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 537,26 ***</span>
    // it is not the shutdown thread, then the calling thread is not
    // honoring the Thread-SMR ptotocol. This means that the specified
    // ThreadsList is not a stable hazard ptr and can be freed by
    // another thread from the to-be-deleted list at any time.
    //
<span class="line-removed">-   // Note: The shutdown thread has removed itself from the Threads</span>
<span class="line-removed">-   // list and is safe to have a waiver from this check because</span>
<span class="line-removed">-   // VM_Exit::_shutdown_thread is not set until after the VMThread</span>
<span class="line-removed">-   // has started the final safepoint which holds the Threads_lock</span>
<span class="line-removed">-   // for the remainder of the VM&#39;s life.</span>
<span class="line-removed">-   //</span>
    VerifyHazardPtrThreadClosure cl(_thread);
    ThreadsSMRSupport::threads_do(&amp;cl, _list);
  
    // If the calling thread is not honoring the Thread-SMR protocol,
    // then we will either crash in threads_do() above because &#39;threads&#39;
    // was freed by another thread or we will fail the assert() below.
    // In either case, we won&#39;t get past this point with a badly placed
    // ThreadsListHandle.
  
<span class="line-modified">!   assert(cl.found() || _thread == VM_Exit::shutdown_thread(), &quot;Acquired a ThreadsList snapshot from a thread not recognized by the Thread-SMR protocol.&quot;);</span>
  #endif
  }
  
  // &#39;entries + 1&#39; so we always have at least one entry.
  ThreadsList::ThreadsList(int entries) :
<span class="line-new-header">--- 557,20 ---</span>
    // it is not the shutdown thread, then the calling thread is not
    // honoring the Thread-SMR ptotocol. This means that the specified
    // ThreadsList is not a stable hazard ptr and can be freed by
    // another thread from the to-be-deleted list at any time.
    //
    VerifyHazardPtrThreadClosure cl(_thread);
    ThreadsSMRSupport::threads_do(&amp;cl, _list);
  
    // If the calling thread is not honoring the Thread-SMR protocol,
    // then we will either crash in threads_do() above because &#39;threads&#39;
    // was freed by another thread or we will fail the assert() below.
    // In either case, we won&#39;t get past this point with a badly placed
    // ThreadsListHandle.
  
<span class="line-modified">!   assert(cl.found(), &quot;Acquired a ThreadsList snapshot from a thread not recognized by the Thread-SMR protocol.&quot;);</span>
  #endif
  }
  
  // &#39;entries + 1&#39; so we always have at least one entry.
  ThreadsList::ThreadsList(int entries) :
</pre>
<hr />
<pre>
<span class="line-old-header">*** 588,16 ***</span>
  
    return new_list;
  }
  
  void ThreadsList::dec_nested_handle_cnt() {
<span class="line-modified">!   // The decrement needs to be MO_ACQ_REL. At the moment, the Atomic::dec</span>
<span class="line-removed">-   // backend on PPC does not yet conform to these requirements. Therefore</span>
<span class="line-removed">-   // the decrement is simulated with an Atomic::sub(1, &amp;addr).</span>
<span class="line-removed">-   // Without this MO_ACQ_REL Atomic::dec simulation, the nested SMR mechanism</span>
<span class="line-removed">-   // is not generally safe to use.</span>
<span class="line-removed">-   Atomic::sub(1, &amp;_nested_handle_cnt);</span>
  }
  
  int ThreadsList::find_index_of_JavaThread(JavaThread *target) {
    if (target == NULL) {
      return -1;
<span class="line-new-header">--- 602,11 ---</span>
  
    return new_list;
  }
  
  void ThreadsList::dec_nested_handle_cnt() {
<span class="line-modified">!   Atomic::dec(&amp;_nested_handle_cnt);</span>
  }
  
  int ThreadsList::find_index_of_JavaThread(JavaThread *target) {
    if (target == NULL) {
      return -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 609,38 ***</span>
    }
    return -1;
  }
  
  JavaThread* ThreadsList::find_JavaThread_from_java_tid(jlong java_tid) const {
<span class="line-modified">!   for (uint i = 0; i &lt; length(); i++) {</span>
<span class="line-modified">!     JavaThread* thread = thread_at(i);</span>
<span class="line-modified">!     oop tobj = thread-&gt;threadObj();</span>
<span class="line-modified">!     // Ignore the thread if it hasn&#39;t run yet, has exited</span>
<span class="line-modified">!     // or is starting to exit.</span>
<span class="line-modified">!     if (tobj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp;</span>
<span class="line-modified">!         java_tid == java_lang_Thread::thread_id(tobj)) {</span>
<span class="line-modified">!       // found a match</span>
<span class="line-modified">!       return thread;</span>
      }
    }
    return NULL;
  }
  
  void ThreadsList::inc_nested_handle_cnt() {
<span class="line-modified">!   // The increment needs to be MO_SEQ_CST. At the moment, the Atomic::inc</span>
<span class="line-removed">-   // backend on PPC does not yet conform to these requirements. Therefore</span>
<span class="line-removed">-   // the increment is simulated with a load phi; cas phi + 1; loop.</span>
<span class="line-removed">-   // Without this MO_SEQ_CST Atomic::inc simulation, the nested SMR mechanism</span>
<span class="line-removed">-   // is not generally safe to use.</span>
<span class="line-removed">-   intx sample = OrderAccess::load_acquire(&amp;_nested_handle_cnt);</span>
<span class="line-removed">-   for (;;) {</span>
<span class="line-removed">-     if (Atomic::cmpxchg(sample + 1, &amp;_nested_handle_cnt, sample) == sample) {</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       sample = OrderAccess::load_acquire(&amp;_nested_handle_cnt);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  }
  
  bool ThreadsList::includes(const JavaThread * const p) const {
    if (p == NULL) {
      return false;
<span class="line-new-header">--- 618,38 ---</span>
    }
    return -1;
  }
  
  JavaThread* ThreadsList::find_JavaThread_from_java_tid(jlong java_tid) const {
<span class="line-modified">!   ThreadIdTable::lazy_initialize(this);</span>
<span class="line-modified">!   JavaThread* thread = ThreadIdTable::find_thread_by_tid(java_tid);</span>
<span class="line-modified">!   if (thread == NULL) {</span>
<span class="line-modified">!     // If the thread is not found in the table find it</span>
<span class="line-modified">!     // with a linear search and add to the table.</span>
<span class="line-modified">!     for (uint i = 0; i &lt; length(); i++) {</span>
<span class="line-modified">!       thread = thread_at(i);</span>
<span class="line-modified">!       oop tobj = thread-&gt;threadObj();</span>
<span class="line-modified">!       // Ignore the thread if it hasn&#39;t run yet, has exited</span>
<span class="line-added">+       // or is starting to exit.</span>
<span class="line-added">+       if (tobj != NULL &amp;&amp; java_tid == java_lang_Thread::thread_id(tobj)) {</span>
<span class="line-added">+         MutexLocker ml(Threads_lock);</span>
<span class="line-added">+         // Must be inside the lock to ensure that we don&#39;t add a thread to the table</span>
<span class="line-added">+         // that has just passed the removal point in ThreadsSMRSupport::remove_thread()</span>
<span class="line-added">+         if (!thread-&gt;is_exiting()) {</span>
<span class="line-added">+           ThreadIdTable::add_thread(java_tid, thread);</span>
<span class="line-added">+           return thread;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
      }
<span class="line-added">+   } else if (!thread-&gt;is_exiting()) {</span>
<span class="line-added">+     return thread;</span>
    }
    return NULL;
  }
  
  void ThreadsList::inc_nested_handle_cnt() {
<span class="line-modified">!   Atomic::inc(&amp;_nested_handle_cnt);</span>
  }
  
  bool ThreadsList::includes(const JavaThread * const p) const {
    if (p == NULL) {
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 753,10 ***</span>
<span class="line-new-header">--- 762,14 ---</span>
    // Initial _java_thread_list will not generate a &quot;Threads::add&quot; mesg.
    log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::add: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
  
    ThreadsList *old_list = xchg_java_thread_list(new_list);
    free_list(old_list);
<span class="line-added">+   if (ThreadIdTable::is_initialized()) {</span>
<span class="line-added">+     jlong tid = SharedRuntime::get_java_tid(thread);</span>
<span class="line-added">+     ThreadIdTable::add_thread(tid, thread);</span>
<span class="line-added">+   }</span>
  }
  
  // set_delete_notify() and clear_delete_notify() are called
  // under the protection of the delete_lock, but we also use an
  // Atomic operation to ensure the memory update is seen earlier than
</pre>
<hr />
<pre>
<span class="line-old-header">*** 767,11 ***</span>
  }
  
  bool ThreadsSMRSupport::delete_notify() {
    // Use load_acquire() in order to see any updates to _delete_notify
    // earlier than when delete_lock is grabbed.
<span class="line-modified">!   return (OrderAccess::load_acquire(&amp;_delete_notify) != 0);</span>
  }
  
  // Safely free a ThreadsList after a Threads::add() or Threads::remove().
  // The specified ThreadsList may not get deleted during this call if it
  // is still in-use (referenced by a hazard ptr). Other ThreadsLists
<span class="line-new-header">--- 780,11 ---</span>
  }
  
  bool ThreadsSMRSupport::delete_notify() {
    // Use load_acquire() in order to see any updates to _delete_notify
    // earlier than when delete_lock is grabbed.
<span class="line-modified">!   return (Atomic::load_acquire(&amp;_delete_notify) != 0);</span>
  }
  
  // Safely free a ThreadsList after a Threads::add() or Threads::remove().
  // The specified ThreadsList may not get deleted during this call if it
  // is still in-use (referenced by a hazard ptr). Other ThreadsLists
</pre>
<hr />
<pre>
<span class="line-old-header">*** 795,17 ***</span>
      }
    }
  
    // Hash table size should be first power of two higher than twice the length of the ThreadsList
    int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
<span class="line-modified">!   hash_table_size--;</span>
<span class="line-removed">-   hash_table_size |= hash_table_size &gt;&gt; 1;</span>
<span class="line-removed">-   hash_table_size |= hash_table_size &gt;&gt; 2;</span>
<span class="line-removed">-   hash_table_size |= hash_table_size &gt;&gt; 4;</span>
<span class="line-removed">-   hash_table_size |= hash_table_size &gt;&gt; 8;</span>
<span class="line-removed">-   hash_table_size |= hash_table_size &gt;&gt; 16;</span>
<span class="line-removed">-   hash_table_size++;</span>
  
    // Gather a hash table of the current hazard ptrs:
    ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
    ScanHazardPtrGatherThreadsListClosure scan_cl(scan_table);
    threads_do(&amp;scan_cl);
<span class="line-new-header">--- 808,11 ---</span>
      }
    }
  
    // Hash table size should be first power of two higher than twice the length of the ThreadsList
    int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
<span class="line-modified">!   hash_table_size = round_up_power_of_2(hash_table_size);</span>
  
    // Gather a hash table of the current hazard ptrs:
    ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
    ScanHazardPtrGatherThreadsListClosure scan_cl(scan_table);
    threads_do(&amp;scan_cl);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 858,17 ***</span>
    assert_locked_or_safepoint(Threads_lock);
  
    // Hash table size should be first power of two higher than twice
    // the length of the Threads list.
    int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
<span class="line-modified">!   hash_table_size--;</span>
<span class="line-removed">-   hash_table_size |= hash_table_size &gt;&gt; 1;</span>
<span class="line-removed">-   hash_table_size |= hash_table_size &gt;&gt; 2;</span>
<span class="line-removed">-   hash_table_size |= hash_table_size &gt;&gt; 4;</span>
<span class="line-removed">-   hash_table_size |= hash_table_size &gt;&gt; 8;</span>
<span class="line-removed">-   hash_table_size |= hash_table_size &gt;&gt; 16;</span>
<span class="line-removed">-   hash_table_size++;</span>
  
    // Gather a hash table of the JavaThreads indirectly referenced by
    // hazard ptrs.
    ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
    ScanHazardPtrGatherProtectedThreadsClosure scan_cl(scan_table);
<span class="line-new-header">--- 865,11 ---</span>
    assert_locked_or_safepoint(Threads_lock);
  
    // Hash table size should be first power of two higher than twice
    // the length of the Threads list.
    int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
<span class="line-modified">!   hash_table_size = round_up_power_of_2(hash_table_size);</span>
  
    // Gather a hash table of the JavaThreads indirectly referenced by
    // hazard ptrs.
    ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
    ScanHazardPtrGatherProtectedThreadsClosure scan_cl(scan_table);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 910,20 ***</span>
    // Threads_lock (which was grabbed before delete_lock) so that
    // threads_do() can be called. This means the system can&#39;t start a
    // safepoint which means this thread can&#39;t take too long to get to
    // a safepoint because of being blocked on delete_lock.
    //
<span class="line-modified">!   MonitorLockerEx ml(ThreadsSMRSupport::delete_lock(), Monitor::_no_safepoint_check_flag);</span>
    if (ThreadsSMRSupport::delete_notify()) {
      // Notify any exiting JavaThreads that are waiting in smr_delete()
      // that we&#39;ve released a ThreadsList.
      ml.notify_all();
      log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::release_stable_list notified %s&quot;, os::current_thread_id(), log_str);
    }
  }
  
  void ThreadsSMRSupport::remove_thread(JavaThread *thread) {
    ThreadsList *new_list = ThreadsList::remove_thread(ThreadsSMRSupport::get_java_thread_list(), thread);
    if (EnableThreadSMRStatistics) {
      ThreadsSMRSupport::inc_java_thread_list_alloc_cnt();
      // This list is smaller so no need to check for a &quot;longest&quot; update.
    }
<span class="line-new-header">--- 911,24 ---</span>
    // Threads_lock (which was grabbed before delete_lock) so that
    // threads_do() can be called. This means the system can&#39;t start a
    // safepoint which means this thread can&#39;t take too long to get to
    // a safepoint because of being blocked on delete_lock.
    //
<span class="line-modified">!   MonitorLocker ml(ThreadsSMRSupport::delete_lock(), Monitor::_no_safepoint_check_flag);</span>
    if (ThreadsSMRSupport::delete_notify()) {
      // Notify any exiting JavaThreads that are waiting in smr_delete()
      // that we&#39;ve released a ThreadsList.
      ml.notify_all();
      log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::release_stable_list notified %s&quot;, os::current_thread_id(), log_str);
    }
  }
  
  void ThreadsSMRSupport::remove_thread(JavaThread *thread) {
<span class="line-added">+   if (ThreadIdTable::is_initialized()) {</span>
<span class="line-added">+     jlong tid = SharedRuntime::get_java_tid(thread);</span>
<span class="line-added">+     ThreadIdTable::remove_thread(tid);</span>
<span class="line-added">+   }</span>
    ThreadsList *new_list = ThreadsList::remove_thread(ThreadsSMRSupport::get_java_thread_list(), thread);
    if (EnableThreadSMRStatistics) {
      ThreadsSMRSupport::inc_java_thread_list_alloc_cnt();
      // This list is smaller so no need to check for a &quot;longest&quot; update.
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 953,14 ***</span>
      timer.start();
    }
  
    while (true) {
      {
<span class="line-modified">!       // No safepoint check because this JavaThread is not on the</span>
<span class="line-modified">!       // Threads list.</span>
<span class="line-modified">!       MutexLockerEx ml(Threads_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!       // Cannot use a MonitorLockerEx helper here because we have</span>
        // to drop the Threads_lock first if we wait.
        ThreadsSMRSupport::delete_lock()-&gt;lock_without_safepoint_check();
        // Set the delete_notify flag after we grab delete_lock
        // and before we scan hazard ptrs because we&#39;re doing
        // double-check locking in release_stable_list().
<span class="line-new-header">--- 958,14 ---</span>
      timer.start();
    }
  
    while (true) {
      {
<span class="line-modified">!       // Will not make a safepoint check because this JavaThread</span>
<span class="line-modified">!       // is not on the current ThreadsList.</span>
<span class="line-modified">!       MutexLocker ml(Threads_lock);</span>
<span class="line-modified">!       // Cannot use a MonitorLocker helper here because we have</span>
        // to drop the Threads_lock first if we wait.
        ThreadsSMRSupport::delete_lock()-&gt;lock_without_safepoint_check();
        // Set the delete_notify flag after we grab delete_lock
        // and before we scan hazard ptrs because we&#39;re doing
        // double-check locking in release_stable_list().
</pre>
<hr />
<pre>
<span class="line-old-header">*** 996,12 ***</span>
        }
      }
      // Wait for a release_stable_list() call before we check again. No
      // safepoint check, no timeout, and not as suspend equivalent flag
      // because this JavaThread is not on the Threads list.
<span class="line-modified">!     ThreadsSMRSupport::delete_lock()-&gt;wait(Mutex::_no_safepoint_check_flag, 0,</span>
<span class="line-removed">-                                      !Mutex::_as_suspend_equivalent_flag);</span>
      if (EnableThreadSMRStatistics) {
        _delete_lock_wait_cnt--;
      }
  
      ThreadsSMRSupport::clear_delete_notify();
<span class="line-new-header">--- 1001,11 ---</span>
        }
      }
      // Wait for a release_stable_list() call before we check again. No
      // safepoint check, no timeout, and not as suspend equivalent flag
      // because this JavaThread is not on the Threads list.
<span class="line-modified">!     ThreadsSMRSupport::delete_lock()-&gt;wait_without_safepoint_check();</span>
      if (EnableThreadSMRStatistics) {
        _delete_lock_wait_cnt--;
      }
  
      ThreadsSMRSupport::clear_delete_notify();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1089,11 ***</span>
    // freed concurrently. However, grabbing the Threads_lock during
    // error reporting can be equally dangerous since this thread might
    // block during error reporting or a nested error could leave the
    // Threads_lock held. The classic no win scenario.
    //
<span class="line-modified">!   MutexLockerEx ml((Threads_lock-&gt;owned_by_self() || VMError::is_error_reported()) ? NULL : Threads_lock);</span>
  
    st-&gt;print_cr(&quot;Threads class SMR info:&quot;);
    st-&gt;print_cr(&quot;_java_thread_list=&quot; INTPTR_FORMAT &quot;, length=%u, &quot;
                 &quot;elements={&quot;, p2i(_java_thread_list),
                 _java_thread_list-&gt;length());
<span class="line-new-header">--- 1093,11 ---</span>
    // freed concurrently. However, grabbing the Threads_lock during
    // error reporting can be equally dangerous since this thread might
    // block during error reporting or a nested error could leave the
    // Threads_lock held. The classic no win scenario.
    //
<span class="line-modified">!   MutexLocker ml((Threads_lock-&gt;owned_by_self() || VMError::is_error_reported()) ? NULL : Threads_lock);</span>
  
    st-&gt;print_cr(&quot;Threads class SMR info:&quot;);
    st-&gt;print_cr(&quot;_java_thread_list=&quot; INTPTR_FORMAT &quot;, length=%u, &quot;
                 &quot;elements={&quot;, p2i(_java_thread_list),
                 _java_thread_list-&gt;length());
</pre>
<center><a href="threadHeapSampler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadSMR.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/frame.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="flags/jvmFlagRangeList.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/frame.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -21,20 +21,21 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/moduleEntry.hpp&quot;</span>
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/vmreg.inline.hpp&quot;
  #include &quot;compiler/abstractCompiler.hpp&quot;
  #include &quot;compiler/disassembler.hpp&quot;
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;oops/markOop.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/methodData.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/verifyOopClosure.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -268,68 +269,15 @@</span>
  
    return !nm-&gt;is_at_poll_return(pc());
  }
  
  void frame::deoptimize(JavaThread* thread) {
<span class="udiff-line-added">+   assert(thread-&gt;frame_anchor()-&gt;has_last_Java_frame() &amp;&amp;</span>
<span class="udiff-line-added">+          thread-&gt;frame_anchor()-&gt;walkable(), &quot;must be&quot;);</span>
    // Schedule deoptimization of an nmethod activation with this frame.
    assert(_cb != NULL &amp;&amp; _cb-&gt;is_compiled(), &quot;must be&quot;);
  
<span class="udiff-line-removed">-   // This is a fix for register window patching race</span>
<span class="udiff-line-removed">-   if (NeedsDeoptSuspend &amp;&amp; Thread::current() != thread) {</span>
<span class="udiff-line-removed">-     assert(SafepointSynchronize::is_at_safepoint(),</span>
<span class="udiff-line-removed">-            &quot;patching other threads for deopt may only occur at a safepoint&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // It is possible especially with DeoptimizeALot/DeoptimizeRandom that</span>
<span class="udiff-line-removed">-     // we could see the frame again and ask for it to be deoptimized since</span>
<span class="udiff-line-removed">-     // it might move for a long time. That is harmless and we just ignore it.</span>
<span class="udiff-line-removed">-     if (id() == thread-&gt;must_deopt_id()) {</span>
<span class="udiff-line-removed">-       assert(thread-&gt;is_deopt_suspend(), &quot;lost suspension&quot;);</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // We are at a safepoint so the target thread can only be</span>
<span class="udiff-line-removed">-     // in 4 states:</span>
<span class="udiff-line-removed">-     //     blocked - no problem</span>
<span class="udiff-line-removed">-     //     blocked_trans - no problem (i.e. could have woken up from blocked</span>
<span class="udiff-line-removed">-     //                                 during a safepoint).</span>
<span class="udiff-line-removed">-     //     native - register window pc patching race</span>
<span class="udiff-line-removed">-     //     native_trans - momentary state</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     // We could just wait out a thread in native_trans to block.</span>
<span class="udiff-line-removed">-     // Then we&#39;d have all the issues that the safepoint code has as to</span>
<span class="udiff-line-removed">-     // whether to spin or block. It isn&#39;t worth it. Just treat it like</span>
<span class="udiff-line-removed">-     // native and be done with it.</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     // Examine the state of the thread at the start of safepoint since</span>
<span class="udiff-line-removed">-     // threads that were in native at the start of the safepoint could</span>
<span class="udiff-line-removed">-     // come to a halt during the safepoint, changing the current value</span>
<span class="udiff-line-removed">-     // of the safepoint_state.</span>
<span class="udiff-line-removed">-     JavaThreadState state = thread-&gt;safepoint_state()-&gt;orig_thread_state();</span>
<span class="udiff-line-removed">-     if (state == _thread_in_native || state == _thread_in_native_trans) {</span>
<span class="udiff-line-removed">-       // Since we are at a safepoint the target thread will stop itself</span>
<span class="udiff-line-removed">-       // before it can return to java as long as we remain at the safepoint.</span>
<span class="udiff-line-removed">-       // Therefore we can put an additional request for the thread to stop</span>
<span class="udiff-line-removed">-       // no matter what no (like a suspend). This will cause the thread</span>
<span class="udiff-line-removed">-       // to notice it needs to do the deopt on its own once it leaves native.</span>
<span class="udiff-line-removed">-       //</span>
<span class="udiff-line-removed">-       // The only reason we must do this is because on machine with register</span>
<span class="udiff-line-removed">-       // windows we have a race with patching the return address and the</span>
<span class="udiff-line-removed">-       // window coming live as the thread returns to the Java code (but still</span>
<span class="udiff-line-removed">-       // in native mode) and then blocks. It is only this top most frame</span>
<span class="udiff-line-removed">-       // that is at risk. So in truth we could add an additional check to</span>
<span class="udiff-line-removed">-       // see if this frame is one that is at risk.</span>
<span class="udiff-line-removed">-       RegisterMap map(thread, false);</span>
<span class="udiff-line-removed">-       frame at_risk =  thread-&gt;last_frame().sender(&amp;map);</span>
<span class="udiff-line-removed">-       if (id() == at_risk.id()) {</span>
<span class="udiff-line-removed">-         thread-&gt;set_must_deopt_id(id());</span>
<span class="udiff-line-removed">-         thread-&gt;set_deopt_suspend();</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } // NeedsDeoptSuspend</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
    // If the call site is a MethodHandle call site use the MH deopt
    // handler.
    CompiledMethod* cm = (CompiledMethod*) _cb;
    address deopt = cm-&gt;is_method_handle_return(pc()) ?
                          cm-&gt;deopt_mh_handler_begin() :
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -679,11 +627,11 @@</span>
          st-&gt;print(&quot; (%d bytes) @ &quot; PTR_FORMAT &quot; [&quot; PTR_FORMAT &quot;+&quot; INTPTR_FORMAT &quot;]&quot;,
                    m-&gt;code_size(), p2i(_pc), p2i(_cb-&gt;code_begin()), _pc - _cb-&gt;code_begin());
  #if INCLUDE_JVMCI
          if (cm-&gt;is_nmethod()) {
            nmethod* nm = cm-&gt;as_nmethod();
<span class="udiff-line-modified-removed">-           char* jvmciName = nm-&gt;jvmci_installed_code_name(buf, buflen);</span>
<span class="udiff-line-modified-added">+           const char* jvmciName = nm-&gt;jvmci_name();</span>
            if (jvmciName != NULL) {
              st-&gt;print(&quot; (%s)&quot;, jvmciName);
            }
          }
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -764,30 +712,31 @@</span>
    int max_locals()  { return _max_locals; }
    frame* fr()       { return _fr; }
  };
  
  
<span class="udiff-line-modified-removed">- class InterpretedArgumentOopFinder: public SignatureInfo {</span>
<span class="udiff-line-modified-added">+ class InterpretedArgumentOopFinder: public SignatureIterator {</span>
   private:
    OopClosure* _f;        // Closure to invoke
    int    _offset;        // TOS-relative offset, decremented with each argument
    bool   _has_receiver;  // true if the callee has a receiver
    frame* _fr;
  
<span class="udiff-line-modified-removed">-   void set(int size, BasicType type) {</span>
<span class="udiff-line-modified-removed">-     _offset -= size;</span>
<span class="udiff-line-modified-removed">-     if (type == T_OBJECT || type == T_ARRAY) oop_offset_do();</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="udiff-line-modified-added">+   void do_type(BasicType type) {</span>
<span class="udiff-line-modified-added">+     _offset -= parameter_type_word_count(type);</span>
<span class="udiff-line-modified-added">+     if (is_reference_type(type)) oop_offset_do();</span>
<span class="udiff-line-added">+    }</span>
  
    void oop_offset_do() {
      oop* addr;
      addr = (oop*)_fr-&gt;interpreter_frame_tos_at(_offset);
      _f-&gt;do_oop(addr);
    }
  
   public:
<span class="udiff-line-modified-removed">-   InterpretedArgumentOopFinder(Symbol* signature, bool has_receiver, frame* fr, OopClosure* f) : SignatureInfo(signature), _has_receiver(has_receiver) {</span>
<span class="udiff-line-modified-added">+   InterpretedArgumentOopFinder(Symbol* signature, bool has_receiver, frame* fr, OopClosure* f) : SignatureIterator(signature), _has_receiver(has_receiver) {</span>
      // compute size of arguments
      int args_size = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0);
      assert(!fr-&gt;is_interpreted_frame() ||
             args_size &lt;= fr-&gt;interpreter_frame_expression_stack_size(),
              &quot;args cannot be on stack anymore&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -800,11 +749,11 @@</span>
    void oops_do() {
      if (_has_receiver) {
        --_offset;
        oop_offset_do();
      }
<span class="udiff-line-modified-removed">-     iterate_parameters();</span>
<span class="udiff-line-modified-added">+     do_parameters_on(this);</span>
    }
  };
  
  
  // Entry frame has following form (n arguments)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -817,41 +766,43 @@</span>
  //         +-----------+
  
  
  
  // visits and GC&#39;s all the arguments in entry frame
<span class="udiff-line-modified-removed">- class EntryFrameOopFinder: public SignatureInfo {</span>
<span class="udiff-line-modified-added">+ class EntryFrameOopFinder: public SignatureIterator {</span>
   private:
    bool   _is_static;
    int    _offset;
    frame* _fr;
    OopClosure* _f;
  
<span class="udiff-line-modified-removed">-   void set(int size, BasicType type) {</span>
<span class="udiff-line-modified-added">+   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="udiff-line-added">+   void do_type(BasicType type) {</span>
<span class="udiff-line-added">+     // decrement offset before processing the type</span>
<span class="udiff-line-added">+     _offset -= parameter_type_word_count(type);</span>
      assert (_offset &gt;= 0, &quot;illegal offset&quot;);
<span class="udiff-line-modified-removed">-     if (type == T_OBJECT || type == T_ARRAY) oop_at_offset_do(_offset);</span>
<span class="udiff-line-modified-removed">-     _offset -= size;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+     if (is_reference_type(type))  oop_at_offset_do(_offset);</span>
<span class="udiff-line-modified-added">+  }</span>
  
    void oop_at_offset_do(int offset) {
      assert (offset &gt;= 0, &quot;illegal offset&quot;);
      oop* addr = (oop*) _fr-&gt;entry_frame_argument_at(offset);
      _f-&gt;do_oop(addr);
    }
  
   public:
<span class="udiff-line-modified-removed">-    EntryFrameOopFinder(frame* frame, Symbol* signature, bool is_static) : SignatureInfo(signature) {</span>
<span class="udiff-line-modified-removed">-      _f = NULL; // will be set later</span>
<span class="udiff-line-modified-removed">-      _fr = frame;</span>
<span class="udiff-line-modified-removed">-      _is_static = is_static;</span>
<span class="udiff-line-modified-removed">-      _offset = ArgumentSizeComputer(signature).size() - 1; // last parameter is at index 0</span>
<span class="udiff-line-modified-removed">-    }</span>
<span class="udiff-line-modified-added">+   EntryFrameOopFinder(frame* frame, Symbol* signature, bool is_static) : SignatureIterator(signature) {</span>
<span class="udiff-line-modified-added">+     _f = NULL; // will be set later</span>
<span class="udiff-line-modified-added">+     _fr = frame;</span>
<span class="udiff-line-modified-added">+     _is_static = is_static;</span>
<span class="udiff-line-modified-added">+     _offset = ArgumentSizeComputer(signature).size();  // pre-decremented down to zero</span>
<span class="udiff-line-modified-added">+   }</span>
  
    void arguments_do(OopClosure* f) {
      _f = f;
<span class="udiff-line-modified-removed">-     if (!_is_static) oop_at_offset_do(_offset+1); // do the receiver</span>
<span class="udiff-line-modified-removed">-     iterate_parameters();</span>
<span class="udiff-line-modified-added">+     if (!_is_static)  oop_at_offset_do(_offset); // do the receiver</span>
<span class="udiff-line-modified-added">+     do_parameters_on(this);</span>
    }
  
  };
  
  oop* frame::interpreter_callee_receiver_addr(Symbol* signature) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -965,24 +916,25 @@</span>
    // closure decides how it wants nmethods to be traced.
    if (cf != NULL)
      cf-&gt;do_code_blob(_cb);
  }
  
<span class="udiff-line-modified-removed">- class CompiledArgumentOopFinder: public SignatureInfo {</span>
<span class="udiff-line-modified-added">+ class CompiledArgumentOopFinder: public SignatureIterator {</span>
   protected:
    OopClosure*     _f;
    int             _offset;        // the current offset, incremented with each argument
    bool            _has_receiver;  // true if the callee has a receiver
    bool            _has_appendix;  // true if the call has an appendix
    frame           _fr;
    RegisterMap*    _reg_map;
    int             _arg_size;
    VMRegPair*      _regs;        // VMReg list of arguments
  
<span class="udiff-line-modified-removed">-   void set(int size, BasicType type) {</span>
<span class="udiff-line-modified-removed">-     if (type == T_OBJECT || type == T_ARRAY) handle_oop_offset();</span>
<span class="udiff-line-modified-removed">-     _offset += size;</span>
<span class="udiff-line-modified-added">+   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="udiff-line-modified-added">+   void do_type(BasicType type) {</span>
<span class="udiff-line-modified-added">+     if (is_reference_type(type))  handle_oop_offset();</span>
<span class="udiff-line-added">+     _offset += parameter_type_word_count(type);</span>
    }
  
    virtual void handle_oop_offset() {
      // Extract low order register number from register array.
      // In LP64-land, the high-order bits are valid but unhelpful.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -990,12 +942,12 @@</span>
      oop *loc = _fr.oopmapreg_to_location(reg, _reg_map);
      _f-&gt;do_oop(loc);
    }
  
   public:
<span class="udiff-line-modified-removed">-   CompiledArgumentOopFinder(Symbol* signature, bool has_receiver, bool has_appendix, OopClosure* f, frame fr,  const RegisterMap* reg_map)</span>
<span class="udiff-line-modified-removed">-     : SignatureInfo(signature) {</span>
<span class="udiff-line-modified-added">+   CompiledArgumentOopFinder(Symbol* signature, bool has_receiver, bool has_appendix, OopClosure* f, frame fr, const RegisterMap* reg_map)</span>
<span class="udiff-line-modified-added">+     : SignatureIterator(signature) {</span>
  
      // initialize CompiledArgumentOopFinder
      _f         = f;
      _offset    = 0;
      _has_receiver = has_receiver;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1012,11 +964,11 @@</span>
    void oops_do() {
      if (_has_receiver) {
        handle_oop_offset();
        _offset++;
      }
<span class="udiff-line-modified-removed">-     iterate_parameters();</span>
<span class="udiff-line-modified-added">+     do_parameters_on(this);</span>
      if (_has_appendix) {
        handle_oop_offset();
        _offset++;
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1113,17 +1065,17 @@</span>
      cf-&gt;do_code_blob(_cb);
    }
  }
  
  
<span class="udiff-line-modified-removed">- // call f() on the interpreted Method*s in the stack.</span>
<span class="udiff-line-modified-removed">- // Have to walk the entire code cache for the compiled frames Yuck.</span>
<span class="udiff-line-modified-removed">- void frame::metadata_do(void f(Metadata*)) {</span>
<span class="udiff-line-modified-added">+ // Call f closure on the interpreted Method*s in the stack.</span>
<span class="udiff-line-modified-added">+ void frame::metadata_do(MetadataClosure* f) {</span>
<span class="udiff-line-modified-added">+   ResourceMark rm;</span>
    if (is_interpreted_frame()) {
      Method* m = this-&gt;interpreter_frame_method();
      assert(m != NULL, &quot;expecting a method in this frame&quot;);
<span class="udiff-line-modified-removed">-     f(m);</span>
<span class="udiff-line-modified-added">+     f-&gt;do_metadata(m);</span>
    }
  }
  
  void frame::verify(const RegisterMap* map) {
    // for now make sure receiver type is correct
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1214,11 +1166,11 @@</span>
        }
      }
  
      // Compute the actual expression stack size
      InterpreterOopMap mask;
<span class="udiff-line-modified-removed">-     OopMapCache::compute_one_oop_map(m, bci, &amp;mask);</span>
<span class="udiff-line-modified-added">+     OopMapCache::compute_one_oop_map(methodHandle(Thread::current(), m), bci, &amp;mask);</span>
      intptr_t* tos = NULL;
      // Report each stack element and mark as owned by this frame
      for (int e = 0; e &lt; mask.expression_stack_size(); e++) {
        tos = MAX2(tos, interpreter_frame_expression_stack_at(e));
        values.describe(frame_no, interpreter_frame_expression_stack_at(e),
</pre>
<center><a href="flags/jvmFlagRangeList.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
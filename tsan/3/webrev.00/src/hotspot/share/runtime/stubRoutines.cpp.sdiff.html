<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/stubRoutines.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubCodeGenerator.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutines.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/stubRoutines.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/codeBuffer.hpp&quot;

 27 #include &quot;memory/resourceArea.hpp&quot;
 28 #include &quot;oops/access.inline.hpp&quot;
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 31 #include &quot;runtime/timerTrace.hpp&quot;
 32 #include &quot;runtime/sharedRuntime.hpp&quot;
 33 #include &quot;runtime/stubRoutines.hpp&quot;
 34 #include &quot;utilities/align.hpp&quot;
 35 #include &quot;utilities/copy.hpp&quot;
 36 #include &quot;utilities/vmError.hpp&quot;
 37 #ifdef COMPILER2
 38 #include &quot;opto/runtime.hpp&quot;
 39 #endif
 40 




 41 
 42 // Implementation of StubRoutines - for a description
 43 // of how to extend it, see the header file.
 44 
 45 // Class Variables
 46 
 47 BufferBlob* StubRoutines::_code1                                = NULL;
 48 BufferBlob* StubRoutines::_code2                                = NULL;
 49 
 50 address StubRoutines::_call_stub_return_address                 = NULL;
 51 address StubRoutines::_call_stub_entry                          = NULL;
 52 
 53 address StubRoutines::_catch_exception_entry                    = NULL;
 54 address StubRoutines::_forward_exception_entry                  = NULL;
 55 address StubRoutines::_throw_AbstractMethodError_entry          = NULL;
 56 address StubRoutines::_throw_IncompatibleClassChangeError_entry = NULL;
 57 address StubRoutines::_throw_NullPointerException_at_call_entry = NULL;
 58 address StubRoutines::_throw_StackOverflowError_entry           = NULL;
 59 address StubRoutines::_throw_delayed_StackOverflowError_entry   = NULL;
 60 jint    StubRoutines::_verify_oop_count                         = 0;
</pre>
<hr />
<pre>
 91 address StubRoutines::_jint_disjoint_arraycopy           = CAST_FROM_FN_PTR(address, StubRoutines::jint_copy);
 92 address StubRoutines::_jlong_disjoint_arraycopy          = CAST_FROM_FN_PTR(address, StubRoutines::jlong_copy);
 93 address StubRoutines::_oop_disjoint_arraycopy            = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy);
 94 address StubRoutines::_oop_disjoint_arraycopy_uninit     = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy_uninit);
 95 
 96 address StubRoutines::_arrayof_jbyte_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jbyte_copy);
 97 address StubRoutines::_arrayof_jshort_arraycopy = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jshort_copy);
 98 address StubRoutines::_arrayof_jint_arraycopy   = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jint_copy);
 99 address StubRoutines::_arrayof_jlong_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jlong_copy);
100 address StubRoutines::_arrayof_oop_arraycopy    = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy);
101 address StubRoutines::_arrayof_oop_arraycopy_uninit      = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy_uninit);
102 address StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jbyte_copy);
103 address StubRoutines::_arrayof_jshort_disjoint_arraycopy = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jshort_copy);
104 address StubRoutines::_arrayof_jint_disjoint_arraycopy   = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jint_copy);
105 address StubRoutines::_arrayof_jlong_disjoint_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jlong_copy);
106 address StubRoutines::_arrayof_oop_disjoint_arraycopy    = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy);
107 address StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy_uninit);
108 
109 address StubRoutines::_zero_aligned_words = CAST_FROM_FN_PTR(address, Copy::zero_to_words);
110 



111 address StubRoutines::_checkcast_arraycopy               = NULL;
112 address StubRoutines::_checkcast_arraycopy_uninit        = NULL;
113 address StubRoutines::_unsafe_arraycopy                  = NULL;
114 address StubRoutines::_generic_arraycopy                 = NULL;
115 
<span class="line-removed">116 </span>
117 address StubRoutines::_jbyte_fill;
118 address StubRoutines::_jshort_fill;
119 address StubRoutines::_jint_fill;
120 address StubRoutines::_arrayof_jbyte_fill;
121 address StubRoutines::_arrayof_jshort_fill;
122 address StubRoutines::_arrayof_jint_fill;
123 
124 address StubRoutines::_aescrypt_encryptBlock               = NULL;
125 address StubRoutines::_aescrypt_decryptBlock               = NULL;
126 address StubRoutines::_cipherBlockChaining_encryptAESCrypt = NULL;
127 address StubRoutines::_cipherBlockChaining_decryptAESCrypt = NULL;


128 address StubRoutines::_counterMode_AESCrypt                = NULL;
129 address StubRoutines::_ghash_processBlocks                 = NULL;
130 address StubRoutines::_base64_encodeBlock                  = NULL;
131 
132 address StubRoutines::_sha1_implCompress     = NULL;
133 address StubRoutines::_sha1_implCompressMB   = NULL;
134 address StubRoutines::_sha256_implCompress   = NULL;
135 address StubRoutines::_sha256_implCompressMB = NULL;
136 address StubRoutines::_sha512_implCompress   = NULL;
137 address StubRoutines::_sha512_implCompressMB = NULL;
138 
139 address StubRoutines::_updateBytesCRC32 = NULL;
140 address StubRoutines::_crc_table_adr =    NULL;
141 
142 address StubRoutines::_crc32c_table_addr = NULL;
143 address StubRoutines::_updateBytesCRC32C = NULL;
144 address StubRoutines::_updateBytesAdler32 = NULL;
145 
146 address StubRoutines::_multiplyToLen = NULL;
147 address StubRoutines::_squareToLen = NULL;
148 address StubRoutines::_mulAdd = NULL;
149 address StubRoutines::_montgomeryMultiply = NULL;
150 address StubRoutines::_montgomerySquare = NULL;


151 
152 address StubRoutines::_vectorizedMismatch = NULL;
153 
154 address StubRoutines::_dexp = NULL;
155 address StubRoutines::_dlog = NULL;
156 address StubRoutines::_dlog10 = NULL;
157 address StubRoutines::_dpow = NULL;
158 address StubRoutines::_dsin = NULL;
159 address StubRoutines::_dcos = NULL;
160 address StubRoutines::_dlibm_sin_cos_huge = NULL;
161 address StubRoutines::_dlibm_reduce_pi04l = NULL;
162 address StubRoutines::_dlibm_tan_cot_huge = NULL;
163 address StubRoutines::_dtan = NULL;
164 
165 address StubRoutines::_safefetch32_entry                 = NULL;
166 address StubRoutines::_safefetch32_fault_pc              = NULL;
167 address StubRoutines::_safefetch32_continuation_pc       = NULL;
168 address StubRoutines::_safefetchN_entry                  = NULL;
169 address StubRoutines::_safefetchN_fault_pc               = NULL;
170 address StubRoutines::_safefetchN_continuation_pc        = NULL;
171 
172 // Initialization
173 //
174 // Note: to break cycle with universe initialization, stubs are generated in two phases.
175 // The first one generates stubs needed during universe init (e.g., _handle_must_compile_first_entry).
176 // The second phase includes all other stubs (which may depend on universe being initialized.)
177 
178 extern void StubGenerator_generate(CodeBuffer* code, bool all); // only interface to generators
179 

























180 void StubRoutines::initialize1() {
181   if (_code1 == NULL) {
182     ResourceMark rm;
183     TraceTime timer(&quot;StubRoutines generation 1&quot;, TRACETIME_LOG(Info, startuptime));
184     _code1 = BufferBlob::create(&quot;StubRoutines (1)&quot;, code_size1);
185     if (_code1 == NULL) {
186       vm_exit_out_of_memory(code_size1, OOM_MALLOC_ERROR, &quot;CodeCache: no room for StubRoutines (1)&quot;);
187     }
188     CodeBuffer buffer(_code1);
189     StubGenerator_generate(&amp;buffer, false);
190     // When new stubs added we need to make sure there is some space left
191     // to catch situation when we should increase size again.
192     assert(code_size1 == 0 || buffer.insts_remaining() &gt; 200, &quot;increase code_size1&quot;);
193   }
194 }
195 
196 
197 #ifdef ASSERT
198 typedef void (*arraycopy_fn)(address src, address dst, int count);
199 
</pre>
<hr />
<pre>
552     case COPYFUNC_CONJOINT | COPYFUNC_ALIGNED:    RETURN_STUB(arrayof_jlong_arraycopy);
553     case COPYFUNC_DISJOINT | COPYFUNC_UNALIGNED:  RETURN_STUB(jlong_disjoint_arraycopy);
554     case COPYFUNC_DISJOINT | COPYFUNC_ALIGNED:    RETURN_STUB(arrayof_jlong_disjoint_arraycopy);
555     }
556   case T_ARRAY:
557   case T_OBJECT:
558     switch (selector) {
559     case COPYFUNC_CONJOINT | COPYFUNC_UNALIGNED:  RETURN_STUB_PARM(oop_arraycopy, dest_uninitialized);
560     case COPYFUNC_CONJOINT | COPYFUNC_ALIGNED:    RETURN_STUB_PARM(arrayof_oop_arraycopy, dest_uninitialized);
561     case COPYFUNC_DISJOINT | COPYFUNC_UNALIGNED:  RETURN_STUB_PARM(oop_disjoint_arraycopy, dest_uninitialized);
562     case COPYFUNC_DISJOINT | COPYFUNC_ALIGNED:    RETURN_STUB_PARM(arrayof_oop_disjoint_arraycopy, dest_uninitialized);
563     }
564   default:
565     ShouldNotReachHere();
566     return NULL;
567   }
568 
569 #undef RETURN_STUB
570 #undef RETURN_STUB_PARM
571 }






















</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/codeBuffer.hpp&quot;
<span class="line-added"> 27 #include &quot;asm/macroAssembler.inline.hpp&quot;</span>
 28 #include &quot;memory/resourceArea.hpp&quot;
 29 #include &quot;oops/access.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 32 #include &quot;runtime/timerTrace.hpp&quot;
 33 #include &quot;runtime/sharedRuntime.hpp&quot;
 34 #include &quot;runtime/stubRoutines.hpp&quot;
 35 #include &quot;utilities/align.hpp&quot;
 36 #include &quot;utilities/copy.hpp&quot;
 37 #include &quot;utilities/vmError.hpp&quot;
 38 #ifdef COMPILER2
 39 #include &quot;opto/runtime.hpp&quot;
 40 #endif
 41 
<span class="line-added"> 42 UnsafeCopyMemory* UnsafeCopyMemory::_table                      = NULL;</span>
<span class="line-added"> 43 int UnsafeCopyMemory::_table_length                             = 0;</span>
<span class="line-added"> 44 int UnsafeCopyMemory::_table_max_length                         = 0;</span>
<span class="line-added"> 45 address UnsafeCopyMemory::_common_exit_stub_pc                  = NULL;</span>
 46 
 47 // Implementation of StubRoutines - for a description
 48 // of how to extend it, see the header file.
 49 
 50 // Class Variables
 51 
 52 BufferBlob* StubRoutines::_code1                                = NULL;
 53 BufferBlob* StubRoutines::_code2                                = NULL;
 54 
 55 address StubRoutines::_call_stub_return_address                 = NULL;
 56 address StubRoutines::_call_stub_entry                          = NULL;
 57 
 58 address StubRoutines::_catch_exception_entry                    = NULL;
 59 address StubRoutines::_forward_exception_entry                  = NULL;
 60 address StubRoutines::_throw_AbstractMethodError_entry          = NULL;
 61 address StubRoutines::_throw_IncompatibleClassChangeError_entry = NULL;
 62 address StubRoutines::_throw_NullPointerException_at_call_entry = NULL;
 63 address StubRoutines::_throw_StackOverflowError_entry           = NULL;
 64 address StubRoutines::_throw_delayed_StackOverflowError_entry   = NULL;
 65 jint    StubRoutines::_verify_oop_count                         = 0;
</pre>
<hr />
<pre>
 96 address StubRoutines::_jint_disjoint_arraycopy           = CAST_FROM_FN_PTR(address, StubRoutines::jint_copy);
 97 address StubRoutines::_jlong_disjoint_arraycopy          = CAST_FROM_FN_PTR(address, StubRoutines::jlong_copy);
 98 address StubRoutines::_oop_disjoint_arraycopy            = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy);
 99 address StubRoutines::_oop_disjoint_arraycopy_uninit     = CAST_FROM_FN_PTR(address, StubRoutines::oop_copy_uninit);
100 
101 address StubRoutines::_arrayof_jbyte_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jbyte_copy);
102 address StubRoutines::_arrayof_jshort_arraycopy = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jshort_copy);
103 address StubRoutines::_arrayof_jint_arraycopy   = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jint_copy);
104 address StubRoutines::_arrayof_jlong_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jlong_copy);
105 address StubRoutines::_arrayof_oop_arraycopy    = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy);
106 address StubRoutines::_arrayof_oop_arraycopy_uninit      = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy_uninit);
107 address StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jbyte_copy);
108 address StubRoutines::_arrayof_jshort_disjoint_arraycopy = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jshort_copy);
109 address StubRoutines::_arrayof_jint_disjoint_arraycopy   = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jint_copy);
110 address StubRoutines::_arrayof_jlong_disjoint_arraycopy  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_jlong_copy);
111 address StubRoutines::_arrayof_oop_disjoint_arraycopy    = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy);
112 address StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit  = CAST_FROM_FN_PTR(address, StubRoutines::arrayof_oop_copy_uninit);
113 
114 address StubRoutines::_zero_aligned_words = CAST_FROM_FN_PTR(address, Copy::zero_to_words);
115 
<span class="line-added">116 address StubRoutines::_data_cache_writeback              = NULL;</span>
<span class="line-added">117 address StubRoutines::_data_cache_writeback_sync         = NULL;</span>
<span class="line-added">118 </span>
119 address StubRoutines::_checkcast_arraycopy               = NULL;
120 address StubRoutines::_checkcast_arraycopy_uninit        = NULL;
121 address StubRoutines::_unsafe_arraycopy                  = NULL;
122 address StubRoutines::_generic_arraycopy                 = NULL;
123 

124 address StubRoutines::_jbyte_fill;
125 address StubRoutines::_jshort_fill;
126 address StubRoutines::_jint_fill;
127 address StubRoutines::_arrayof_jbyte_fill;
128 address StubRoutines::_arrayof_jshort_fill;
129 address StubRoutines::_arrayof_jint_fill;
130 
131 address StubRoutines::_aescrypt_encryptBlock               = NULL;
132 address StubRoutines::_aescrypt_decryptBlock               = NULL;
133 address StubRoutines::_cipherBlockChaining_encryptAESCrypt = NULL;
134 address StubRoutines::_cipherBlockChaining_decryptAESCrypt = NULL;
<span class="line-added">135 address StubRoutines::_electronicCodeBook_encryptAESCrypt  = NULL;</span>
<span class="line-added">136 address StubRoutines::_electronicCodeBook_decryptAESCrypt  = NULL;</span>
137 address StubRoutines::_counterMode_AESCrypt                = NULL;
138 address StubRoutines::_ghash_processBlocks                 = NULL;
139 address StubRoutines::_base64_encodeBlock                  = NULL;
140 
141 address StubRoutines::_sha1_implCompress     = NULL;
142 address StubRoutines::_sha1_implCompressMB   = NULL;
143 address StubRoutines::_sha256_implCompress   = NULL;
144 address StubRoutines::_sha256_implCompressMB = NULL;
145 address StubRoutines::_sha512_implCompress   = NULL;
146 address StubRoutines::_sha512_implCompressMB = NULL;
147 
148 address StubRoutines::_updateBytesCRC32 = NULL;
149 address StubRoutines::_crc_table_adr =    NULL;
150 
151 address StubRoutines::_crc32c_table_addr = NULL;
152 address StubRoutines::_updateBytesCRC32C = NULL;
153 address StubRoutines::_updateBytesAdler32 = NULL;
154 
155 address StubRoutines::_multiplyToLen = NULL;
156 address StubRoutines::_squareToLen = NULL;
157 address StubRoutines::_mulAdd = NULL;
158 address StubRoutines::_montgomeryMultiply = NULL;
159 address StubRoutines::_montgomerySquare = NULL;
<span class="line-added">160 address StubRoutines::_bigIntegerRightShiftWorker = NULL;</span>
<span class="line-added">161 address StubRoutines::_bigIntegerLeftShiftWorker = NULL;</span>
162 
163 address StubRoutines::_vectorizedMismatch = NULL;
164 
165 address StubRoutines::_dexp = NULL;
166 address StubRoutines::_dlog = NULL;
167 address StubRoutines::_dlog10 = NULL;
168 address StubRoutines::_dpow = NULL;
169 address StubRoutines::_dsin = NULL;
170 address StubRoutines::_dcos = NULL;
171 address StubRoutines::_dlibm_sin_cos_huge = NULL;
172 address StubRoutines::_dlibm_reduce_pi04l = NULL;
173 address StubRoutines::_dlibm_tan_cot_huge = NULL;
174 address StubRoutines::_dtan = NULL;
175 
176 address StubRoutines::_safefetch32_entry                 = NULL;
177 address StubRoutines::_safefetch32_fault_pc              = NULL;
178 address StubRoutines::_safefetch32_continuation_pc       = NULL;
179 address StubRoutines::_safefetchN_entry                  = NULL;
180 address StubRoutines::_safefetchN_fault_pc               = NULL;
181 address StubRoutines::_safefetchN_continuation_pc        = NULL;
182 
183 // Initialization
184 //
185 // Note: to break cycle with universe initialization, stubs are generated in two phases.
186 // The first one generates stubs needed during universe init (e.g., _handle_must_compile_first_entry).
187 // The second phase includes all other stubs (which may depend on universe being initialized.)
188 
189 extern void StubGenerator_generate(CodeBuffer* code, bool all); // only interface to generators
190 
<span class="line-added">191 void UnsafeCopyMemory::create_table(int max_size) {</span>
<span class="line-added">192   UnsafeCopyMemory::_table = new UnsafeCopyMemory[max_size];</span>
<span class="line-added">193   UnsafeCopyMemory::_table_max_length = max_size;</span>
<span class="line-added">194 }</span>
<span class="line-added">195 </span>
<span class="line-added">196 bool UnsafeCopyMemory::contains_pc(address pc) {</span>
<span class="line-added">197   for (int i = 0; i &lt; UnsafeCopyMemory::_table_length; i++) {</span>
<span class="line-added">198     UnsafeCopyMemory* entry = &amp;UnsafeCopyMemory::_table[i];</span>
<span class="line-added">199     if (pc &gt;= entry-&gt;start_pc() &amp;&amp; pc &lt; entry-&gt;end_pc()) {</span>
<span class="line-added">200       return true;</span>
<span class="line-added">201     }</span>
<span class="line-added">202   }</span>
<span class="line-added">203   return false;</span>
<span class="line-added">204 }</span>
<span class="line-added">205 </span>
<span class="line-added">206 address UnsafeCopyMemory::page_error_continue_pc(address pc) {</span>
<span class="line-added">207   for (int i = 0; i &lt; UnsafeCopyMemory::_table_length; i++) {</span>
<span class="line-added">208     UnsafeCopyMemory* entry = &amp;UnsafeCopyMemory::_table[i];</span>
<span class="line-added">209     if (pc &gt;= entry-&gt;start_pc() &amp;&amp; pc &lt; entry-&gt;end_pc()) {</span>
<span class="line-added">210       return entry-&gt;error_exit_pc();</span>
<span class="line-added">211     }</span>
<span class="line-added">212   }</span>
<span class="line-added">213   return NULL;</span>
<span class="line-added">214 }</span>
<span class="line-added">215 </span>
216 void StubRoutines::initialize1() {
217   if (_code1 == NULL) {
218     ResourceMark rm;
219     TraceTime timer(&quot;StubRoutines generation 1&quot;, TRACETIME_LOG(Info, startuptime));
220     _code1 = BufferBlob::create(&quot;StubRoutines (1)&quot;, code_size1);
221     if (_code1 == NULL) {
222       vm_exit_out_of_memory(code_size1, OOM_MALLOC_ERROR, &quot;CodeCache: no room for StubRoutines (1)&quot;);
223     }
224     CodeBuffer buffer(_code1);
225     StubGenerator_generate(&amp;buffer, false);
226     // When new stubs added we need to make sure there is some space left
227     // to catch situation when we should increase size again.
228     assert(code_size1 == 0 || buffer.insts_remaining() &gt; 200, &quot;increase code_size1&quot;);
229   }
230 }
231 
232 
233 #ifdef ASSERT
234 typedef void (*arraycopy_fn)(address src, address dst, int count);
235 
</pre>
<hr />
<pre>
588     case COPYFUNC_CONJOINT | COPYFUNC_ALIGNED:    RETURN_STUB(arrayof_jlong_arraycopy);
589     case COPYFUNC_DISJOINT | COPYFUNC_UNALIGNED:  RETURN_STUB(jlong_disjoint_arraycopy);
590     case COPYFUNC_DISJOINT | COPYFUNC_ALIGNED:    RETURN_STUB(arrayof_jlong_disjoint_arraycopy);
591     }
592   case T_ARRAY:
593   case T_OBJECT:
594     switch (selector) {
595     case COPYFUNC_CONJOINT | COPYFUNC_UNALIGNED:  RETURN_STUB_PARM(oop_arraycopy, dest_uninitialized);
596     case COPYFUNC_CONJOINT | COPYFUNC_ALIGNED:    RETURN_STUB_PARM(arrayof_oop_arraycopy, dest_uninitialized);
597     case COPYFUNC_DISJOINT | COPYFUNC_UNALIGNED:  RETURN_STUB_PARM(oop_disjoint_arraycopy, dest_uninitialized);
598     case COPYFUNC_DISJOINT | COPYFUNC_ALIGNED:    RETURN_STUB_PARM(arrayof_oop_disjoint_arraycopy, dest_uninitialized);
599     }
600   default:
601     ShouldNotReachHere();
602     return NULL;
603   }
604 
605 #undef RETURN_STUB
606 #undef RETURN_STUB_PARM
607 }
<span class="line-added">608 </span>
<span class="line-added">609 UnsafeCopyMemoryMark::UnsafeCopyMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc) {</span>
<span class="line-added">610   _cgen = cgen;</span>
<span class="line-added">611   _ucm_entry = NULL;</span>
<span class="line-added">612   if (add_entry) {</span>
<span class="line-added">613     address err_exit_pc = NULL;</span>
<span class="line-added">614     if (!continue_at_scope_end) {</span>
<span class="line-added">615       err_exit_pc = error_exit_pc != NULL ? error_exit_pc : UnsafeCopyMemory::common_exit_stub_pc();</span>
<span class="line-added">616     }</span>
<span class="line-added">617     assert(err_exit_pc != NULL || continue_at_scope_end, &quot;error exit not set&quot;);</span>
<span class="line-added">618     _ucm_entry = UnsafeCopyMemory::add_to_table(_cgen-&gt;assembler()-&gt;pc(), NULL, err_exit_pc);</span>
<span class="line-added">619   }</span>
<span class="line-added">620 }</span>
<span class="line-added">621 </span>
<span class="line-added">622 UnsafeCopyMemoryMark::~UnsafeCopyMemoryMark() {</span>
<span class="line-added">623   if (_ucm_entry != NULL) {</span>
<span class="line-added">624     _ucm_entry-&gt;set_end_pc(_cgen-&gt;assembler()-&gt;pc());</span>
<span class="line-added">625     if (_ucm_entry-&gt;error_exit_pc() == NULL) {</span>
<span class="line-added">626       _ucm_entry-&gt;set_error_exit_pc(_cgen-&gt;assembler()-&gt;pc());</span>
<span class="line-added">627     }</span>
<span class="line-added">628   }</span>
<span class="line-added">629 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="stubCodeGenerator.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubRoutines.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/arguments.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../prims/whitebox.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arguments.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/arguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,25 ***</span>
  #include &quot;classfile/classLoader.hpp&quot;
  #include &quot;classfile/javaAssertions.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
<span class="line-removed">- #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
  #include &quot;gc/shared/gcArguments.hpp&quot;
  #include &quot;gc/shared/gcConfig.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logConfiguration.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;logging/logTag.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-modified">! #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/flags/jvmFlag.hpp&quot;
  #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
<span class="line-removed">- #include &quot;runtime/flags/jvmFlagWriteableList.hpp&quot;</span>
  #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
<span class="line-new-header">--- 27,23 ---</span>
  #include &quot;classfile/classLoader.hpp&quot;
  #include &quot;classfile/javaAssertions.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;gc/shared/gcArguments.hpp&quot;
  #include &quot;gc/shared/gcConfig.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logConfiguration.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;logging/logTag.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-modified">! #include &quot;memory/filemap.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/flags/jvmFlag.hpp&quot;
  #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,24 ***</span>
  #include &quot;services/management.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/defaultStream.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/stringUtils.hpp&quot;
<span class="line-removed">- #if INCLUDE_JVMCI</span>
<span class="line-removed">- #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
<span class="line-removed">- #endif</span>
  #if INCLUDE_JFR
  #include &quot;jfr/jfr.hpp&quot;
  #endif
  
<span class="line-removed">- // Note: This is a special bug reporting site for the JVM</span>
<span class="line-removed">- #ifdef VENDOR_URL_VM_BUG</span>
<span class="line-removed">- # define DEFAULT_VENDOR_URL_BUG VENDOR_URL_VM_BUG</span>
<span class="line-removed">- #else</span>
<span class="line-removed">- # define DEFAULT_VENDOR_URL_BUG &quot;http://bugreport.java.com/bugreport/crash.jsp&quot;</span>
<span class="line-removed">- #endif</span>
  #define DEFAULT_JAVA_LAUNCHER  &quot;generic&quot;
  
  char*  Arguments::_jvm_flags_file               = NULL;
  char** Arguments::_jvm_flags_array              = NULL;
  int    Arguments::_num_jvm_flags                = 0;
<span class="line-new-header">--- 52,16 ---</span>
  #include &quot;services/management.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/defaultStream.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;utilities/stringUtils.hpp&quot;
  #if INCLUDE_JFR
  #include &quot;jfr/jfr.hpp&quot;
  #endif
  
  #define DEFAULT_JAVA_LAUNCHER  &quot;generic&quot;
  
  char*  Arguments::_jvm_flags_file               = NULL;
  char** Arguments::_jvm_flags_array              = NULL;
  int    Arguments::_num_jvm_flags                = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,30 ***</span>
  int    Arguments::_num_jvm_args                 = 0;
  char*  Arguments::_java_command                 = NULL;
  SystemProperty* Arguments::_system_properties   = NULL;
  const char*  Arguments::_gc_log_filename        = NULL;
  size_t Arguments::_conservative_max_heap_alignment = 0;
<span class="line-removed">- size_t Arguments::_min_heap_size                = 0;</span>
  Arguments::Mode Arguments::_mode                = _mixed;
  bool   Arguments::_java_compiler                = false;
  bool   Arguments::_xdebug_mode                  = false;
<span class="line-modified">! const char*  Arguments::_java_vendor_url_bug    = DEFAULT_VENDOR_URL_BUG;</span>
  const char*  Arguments::_sun_java_launcher      = DEFAULT_JAVA_LAUNCHER;
<span class="line-removed">- int    Arguments::_sun_java_launcher_pid        = -1;</span>
  bool   Arguments::_sun_java_launcher_is_altjvm  = false;
  
  // These parameters are reset in method parse_vm_init_args()
  bool   Arguments::_AlwaysCompileLoopMethods     = AlwaysCompileLoopMethods;
  bool   Arguments::_UseOnStackReplacement        = UseOnStackReplacement;
  bool   Arguments::_BackgroundCompilation        = BackgroundCompilation;
  bool   Arguments::_ClipInlining                 = ClipInlining;
  intx   Arguments::_Tier3InvokeNotifyFreqLog     = Tier3InvokeNotifyFreqLog;
  intx   Arguments::_Tier4InvocationThreshold     = Tier4InvocationThreshold;
  
  bool   Arguments::_enable_preview               = false;
  
  char*  Arguments::SharedArchivePath             = NULL;
  
  AgentLibraryList Arguments::_libraryList;
  AgentLibraryList Arguments::_agentList;
  
  // These are not set by the JDK&#39;s built-in launchers, but they can be set by
<span class="line-new-header">--- 69,30 ---</span>
  int    Arguments::_num_jvm_args                 = 0;
  char*  Arguments::_java_command                 = NULL;
  SystemProperty* Arguments::_system_properties   = NULL;
  const char*  Arguments::_gc_log_filename        = NULL;
  size_t Arguments::_conservative_max_heap_alignment = 0;
  Arguments::Mode Arguments::_mode                = _mixed;
  bool   Arguments::_java_compiler                = false;
  bool   Arguments::_xdebug_mode                  = false;
<span class="line-modified">! const char*  Arguments::_java_vendor_url_bug    = NULL;</span>
  const char*  Arguments::_sun_java_launcher      = DEFAULT_JAVA_LAUNCHER;
  bool   Arguments::_sun_java_launcher_is_altjvm  = false;
  
  // These parameters are reset in method parse_vm_init_args()
  bool   Arguments::_AlwaysCompileLoopMethods     = AlwaysCompileLoopMethods;
  bool   Arguments::_UseOnStackReplacement        = UseOnStackReplacement;
  bool   Arguments::_BackgroundCompilation        = BackgroundCompilation;
  bool   Arguments::_ClipInlining                 = ClipInlining;
  intx   Arguments::_Tier3InvokeNotifyFreqLog     = Tier3InvokeNotifyFreqLog;
  intx   Arguments::_Tier4InvocationThreshold     = Tier4InvocationThreshold;
<span class="line-added">+ size_t Arguments::_SharedBaseAddress            = SharedBaseAddress;</span>
  
  bool   Arguments::_enable_preview               = false;
  
  char*  Arguments::SharedArchivePath             = NULL;
<span class="line-added">+ char*  Arguments::SharedDynamicArchivePath      = NULL;</span>
  
  AgentLibraryList Arguments::_libraryList;
  AgentLibraryList Arguments::_agentList;
  
  // These are not set by the JDK&#39;s built-in launchers, but they can be set by
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,21 ***</span>
<span class="line-new-header">--- 259,29 ---</span>
    }
    return false;
  }
  
  #if INCLUDE_JFR
<span class="line-added">+ static bool _has_jfr_option = false;  // is using JFR</span>
<span class="line-added">+ </span>
  // return true on failure
  static bool match_jfr_option(const JavaVMOption** option) {
    assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
    char* tail = NULL;
    if (match_option(*option, &quot;-XX:StartFlightRecording&quot;, (const char**)&amp;tail)) {
<span class="line-added">+     _has_jfr_option = true;</span>
      return Jfr::on_start_flight_recording_option(option, tail);
    } else if (match_option(*option, &quot;-XX:FlightRecorderOptions&quot;, (const char**)&amp;tail)) {
<span class="line-added">+     _has_jfr_option = true;</span>
      return Jfr::on_flight_recorder_option(option, tail);
    }
    return false;
  }
<span class="line-added">+ </span>
<span class="line-added">+ bool Arguments::has_jfr_option() {</span>
<span class="line-added">+   return _has_jfr_option;</span>
<span class="line-added">+ }</span>
  #endif
  
  static void logOption(const char* opt) {
    if (PrintVMOptions) {
      jio_fprintf(defaultStream::output_stream(), &quot;VM option &#39;%s&#39;\n&quot;, opt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 355,12 ***</span>
    return false;
  }
  
  // Process java launcher properties.
  void Arguments::process_sun_java_launcher_properties(JavaVMInitArgs* args) {
<span class="line-modified">!   // See if sun.java.launcher, sun.java.launcher.is_altjvm or</span>
<span class="line-removed">-   // sun.java.launcher.pid is defined.</span>
    // Must do this before setting up other system properties,
    // as some of them may depend on launcher type.
    for (int index = 0; index &lt; args-&gt;nOptions; index++) {
      const JavaVMOption* option = args-&gt;options + index;
      const char* tail;
<span class="line-new-header">--- 353,11 ---</span>
    return false;
  }
  
  // Process java launcher properties.
  void Arguments::process_sun_java_launcher_properties(JavaVMInitArgs* args) {
<span class="line-modified">!   // See if sun.java.launcher or sun.java.launcher.is_altjvm is defined.</span>
    // Must do this before setting up other system properties,
    // as some of them may depend on launcher type.
    for (int index = 0; index &lt; args-&gt;nOptions; index++) {
      const JavaVMOption* option = args-&gt;options + index;
      const char* tail;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,14 ***</span>
        if (strcmp(tail, &quot;true&quot;) == 0) {
          _sun_java_launcher_is_altjvm = true;
        }
        continue;
      }
<span class="line-removed">-     if (match_option(option, &quot;-Dsun.java.launcher.pid=&quot;, &amp;tail)) {</span>
<span class="line-removed">-       _sun_java_launcher_pid = atoi(tail);</span>
<span class="line-removed">-       continue;</span>
<span class="line-removed">-     }</span>
    }
  }
  
  // Initialize system properties key and value.
  void Arguments::init_system_properties() {
<span class="line-new-header">--- 370,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 521,18 ***</span>
  // - All expired options should be removed from the table.
  static SpecialFlag const special_jvm_flags[] = {
    // -------------- Deprecated Flags --------------
    // --- Non-alias flags - sorted by obsolete_in then expired_in:
    { &quot;MaxGCMinorPauseMillis&quot;,        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },
<span class="line-removed">-   { &quot;UseConcMarkSweepGC&quot;,           JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },</span>
    { &quot;MaxRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;MinRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;InitialRAMFraction&quot;,           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;UseMembar&quot;,                    JDK_Version::jdk(10), JDK_Version::jdk(12), JDK_Version::undefined() },
<span class="line-modified">!   { &quot;CompilationPolicyChoice&quot;,      JDK_Version::jdk(13), JDK_Version::jdk(14), JDK_Version::undefined() },</span>
<span class="line-modified">!   { &quot;FailOverToOldVerifier&quot;,        JDK_Version::jdk(13), JDK_Version::jdk(14), JDK_Version::undefined() },</span>
<span class="line-modified">!   { &quot;ThreadLocalHandshakes&quot;,        JDK_Version::jdk(13), JDK_Version::jdk(14), JDK_Version::jdk(15) },</span>
  
    // --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:
    { &quot;DefaultMaxRAMFraction&quot;,        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;CreateMinidumpOnCrash&quot;,        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;TLABStats&quot;,                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },
<span class="line-new-header">--- 514,19 ---</span>
  // - All expired options should be removed from the table.
  static SpecialFlag const special_jvm_flags[] = {
    // -------------- Deprecated Flags --------------
    // --- Non-alias flags - sorted by obsolete_in then expired_in:
    { &quot;MaxGCMinorPauseMillis&quot;,        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;MaxRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;MinRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;InitialRAMFraction&quot;,           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;UseMembar&quot;,                    JDK_Version::jdk(10), JDK_Version::jdk(12), JDK_Version::undefined() },
<span class="line-modified">!   { &quot;AllowRedefinitionToAddDeleteMethods&quot;, JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },</span>
<span class="line-modified">!   { &quot;FlightRecorder&quot;,               JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },</span>
<span class="line-modified">!   { &quot;MonitorBound&quot;,                 JDK_Version::jdk(14), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-added">+   { &quot;PrintVMQWaitTime&quot;,             JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
<span class="line-added">+   { &quot;UseNewFieldLayout&quot;,            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
  
    // --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:
    { &quot;DefaultMaxRAMFraction&quot;,        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;CreateMinidumpOnCrash&quot;,        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;TLABStats&quot;,                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },
</pre>
<hr />
<pre>
<span class="line-old-header">*** 542,27 ***</span>
    { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
    { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
    { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
    { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
    { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
<span class="line-modified">!   { &quot;ProfilerPrintByteCodeStatistics&quot;, JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified">!   { &quot;ProfilerRecordPC&quot;,              JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified">!   { &quot;ProfileVM&quot;,                     JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified">!   { &quot;ProfileIntervals&quot;,              JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified">!   { &quot;ProfileIntervalsTicks&quot;,         JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified">!   { &quot;ProfilerCheckIntervals&quot;,        JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-modified">!   { &quot;ProfilerNumberOfInterpretedMethods&quot;, JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-removed">-   { &quot;ProfilerNumberOfCompiledMethods&quot;, JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-removed">-   { &quot;ProfilerNumberOfStubMethods&quot;,   JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-removed">-   { &quot;ProfilerNumberOfRuntimeStubNodes&quot;, JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
<span class="line-removed">-   { &quot;UseImplicitStableValues&quot;,       JDK_Version::undefined(), JDK_Version::jdk(13), JDK_Version::jdk(14) },</span>
  
  #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
    // These entries will generate build errors.  Their purpose is to test the macros.
    { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
    { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
    { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
    { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
    { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
  #endif
  
<span class="line-new-header">--- 536,24 ---</span>
    { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
    { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
    { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
    { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
    { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
<span class="line-modified">!   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },</span>
<span class="line-modified">!   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },</span>
<span class="line-modified">!   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },</span>
<span class="line-modified">!   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-modified">!   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-modified">!   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-modified">!   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
  
  #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
    // These entries will generate build errors.  Their purpose is to test the macros.
    { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
    { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
    { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
<span class="line-added">+   { &quot;obs &gt; exp&quot;,                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },</span>
    { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
    { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
    { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 595,10 ***</span>
<span class="line-new-header">--- 586,11 ---</span>
    { &quot;TraceLoaderConstraints&quot;,    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },
    { &quot;TraceMonitorInflation&quot;,     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },
    { &quot;TraceSafepointCleanupTime&quot;, LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },
    { &quot;TraceJVMTIObjectTagging&quot;,   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },
    { &quot;TraceRedefineClasses&quot;,      LogLevel::Info,  false, LOG_TAGS(redefine, class) },
<span class="line-added">+   { &quot;PrintJNIResolving&quot;,         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },</span>
    { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }
  };
  
  #ifndef PRODUCT
  // These options are removed in jdk9. Remove this code for jdk10.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 625,18 ***</span>
    } else {
      return true;
    }
  }
  
<span class="line-removed">- extern bool lookup_special_flag_ext(const char *flag_name, SpecialFlag&amp; flag);</span>
<span class="line-removed">- </span>
  static bool lookup_special_flag(const char *flag_name, SpecialFlag&amp; flag) {
<span class="line-removed">-   // Allow extensions to have priority</span>
<span class="line-removed">-   if (lookup_special_flag_ext(flag_name, flag)) {</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
      if ((strcmp(special_jvm_flags[i].name, flag_name) == 0)) {
        flag = special_jvm_flags[i];
        return true;
      }
<span class="line-new-header">--- 617,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 649,10 ***</span>
<span class="line-new-header">--- 634,22 ---</span>
    SpecialFlag flag;
    if (lookup_special_flag(flag_name, flag)) {
      if (!flag.obsolete_in.is_undefined()) {
        if (!version_less_than(JDK_Version::current(), flag.obsolete_in)) {
          *version = flag.obsolete_in;
<span class="line-added">+         // This flag may have been marked for obsoletion in this version, but we may not</span>
<span class="line-added">+         // have actually removed it yet. Rather than ignoring it as soon as we reach</span>
<span class="line-added">+         // this version we allow some time for the removal to happen. So if the flag</span>
<span class="line-added">+         // still actually exists we process it as normal, but issue an adjusted warning.</span>
<span class="line-added">+         const JVMFlag *real_flag = JVMFlag::find_declared_flag(flag_name);</span>
<span class="line-added">+         if (real_flag != NULL) {</span>
<span class="line-added">+           char version_str[256];</span>
<span class="line-added">+           version-&gt;to_string(version_str, sizeof(version_str));</span>
<span class="line-added">+           warning(&quot;Temporarily processing option %s; support is scheduled for removal in %s&quot;,</span>
<span class="line-added">+                   flag_name, version_str);</span>
<span class="line-added">+           return false;</span>
<span class="line-added">+         }</span>
          return true;
        }
      }
    }
    return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 709,15 ***</span>
  
  // Verifies the correctness of the entries in the special_jvm_flags table.
  // If there is a semantic error (i.e. a bug in the table) such as the obsoletion
  // version being earlier than the deprecation version, then a warning is issued
  // and verification fails - by returning false. If it is detected that the table
<span class="line-modified">! // is out of date, with respect to the current version, then a warning is issued</span>
<span class="line-modified">! // but verification does not fail. This allows the VM to operate when the version</span>
<span class="line-modified">! // is first updated, without needing to update all the impacted flags at the</span>
<span class="line-modified">! // same time.</span>
<span class="line-modified">! static bool verify_special_jvm_flags() {</span>
    bool success = true;
    for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
      const SpecialFlag&amp; flag = special_jvm_flags[i];
      if (lookup_special_flag(flag.name, i)) {
        warning(&quot;Duplicate special flag declaration \&quot;%s\&quot;&quot;, flag.name);
<span class="line-new-header">--- 706,26 ---</span>
  
  // Verifies the correctness of the entries in the special_jvm_flags table.
  // If there is a semantic error (i.e. a bug in the table) such as the obsoletion
  // version being earlier than the deprecation version, then a warning is issued
  // and verification fails - by returning false. If it is detected that the table
<span class="line-modified">! // is out of date, with respect to the current version, then ideally a warning is</span>
<span class="line-modified">! // issued but verification does not fail. This allows the VM to operate when the</span>
<span class="line-modified">! // version is first updated, without needing to update all the impacted flags at</span>
<span class="line-modified">! // the same time. In practice we can&#39;t issue the warning immediately when the version</span>
<span class="line-modified">! // is updated as it occurs for every test and some tests are not prepared to handle</span>
<span class="line-added">+ // unexpected output - see 8196739. Instead we only check if the table is up-to-date</span>
<span class="line-added">+ // if the check_globals flag is true, and in addition allow a grace period and only</span>
<span class="line-added">+ // check for stale flags when we hit build 20 (which is far enough into the 6 month</span>
<span class="line-added">+ // release cycle that all flag updates should have been processed, whilst still</span>
<span class="line-added">+ // leaving time to make the change before RDP2).</span>
<span class="line-added">+ // We use a gtest to call this, passing true, so that we can detect stale flags before</span>
<span class="line-added">+ // the end of the release cycle.</span>
<span class="line-added">+ </span>
<span class="line-added">+ static const int SPECIAL_FLAG_VALIDATION_BUILD = 20;</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Arguments::verify_special_jvm_flags(bool check_globals) {</span>
    bool success = true;
    for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
      const SpecialFlag&amp; flag = special_jvm_flags[i];
      if (lookup_special_flag(flag.name, i)) {
        warning(&quot;Duplicate special flag declaration \&quot;%s\&quot;&quot;, flag.name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,28 ***</span>
          warning(&quot;Special flag entry \&quot;%s\&quot; must be obsoleted before expired.&quot;, flag.name);
          success = false;
        }
  
        // if flag has become obsolete it should not have a &quot;globals&quot; flag defined anymore.
<span class="line-modified">!       if (!version_less_than(JDK_Version::current(), flag.obsolete_in)) {</span>
<span class="line-modified">!         if (JVMFlag::find_flag(flag.name) != NULL) {</span>
<span class="line-modified">!           // Temporarily disable the warning: 8196739</span>
<span class="line-modified">!           // warning(&quot;Global variable for obsolete special flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);</span>
          }
        }
      }
  
      if (!flag.expired_in.is_undefined()) {
        // if flag has become expired it should not have a &quot;globals&quot; flag defined anymore.
<span class="line-modified">!       if (!version_less_than(JDK_Version::current(), flag.expired_in)) {</span>
<span class="line-modified">!         if (JVMFlag::find_flag(flag.name) != NULL) {</span>
<span class="line-modified">!           // Temporarily disable the warning: 8196739</span>
<span class="line-modified">!           // warning(&quot;Global variable for expired flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);</span>
          }
        }
      }
<span class="line-removed">- </span>
    }
    return success;
  }
  #endif
  
<span class="line-new-header">--- 754,33 ---</span>
          warning(&quot;Special flag entry \&quot;%s\&quot; must be obsoleted before expired.&quot;, flag.name);
          success = false;
        }
  
        // if flag has become obsolete it should not have a &quot;globals&quot; flag defined anymore.
<span class="line-modified">!       if (check_globals &amp;&amp; VM_Version::vm_build_number() &gt;= SPECIAL_FLAG_VALIDATION_BUILD &amp;&amp;</span>
<span class="line-modified">!           !version_less_than(JDK_Version::current(), flag.obsolete_in)) {</span>
<span class="line-modified">!         if (JVMFlag::find_declared_flag(flag.name) != NULL) {</span>
<span class="line-modified">!           warning(&quot;Global variable for obsolete special flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);</span>
<span class="line-added">+           success = false;</span>
          }
        }
<span class="line-added">+ </span>
<span class="line-added">+     } else if (!flag.expired_in.is_undefined()) {</span>
<span class="line-added">+       warning(&quot;Special flag entry \&quot;%s\&quot; must be explicitly obsoleted before expired.&quot;, flag.name);</span>
<span class="line-added">+       success = false;</span>
      }
  
      if (!flag.expired_in.is_undefined()) {
        // if flag has become expired it should not have a &quot;globals&quot; flag defined anymore.
<span class="line-modified">!       if (check_globals &amp;&amp; VM_Version::vm_build_number() &gt;= SPECIAL_FLAG_VALIDATION_BUILD &amp;&amp;</span>
<span class="line-modified">!           !version_less_than(JDK_Version::current(), flag.expired_in)) {</span>
<span class="line-modified">!         if (JVMFlag::find_declared_flag(flag.name) != NULL) {</span>
<span class="line-modified">!           warning(&quot;Global variable for expired flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);</span>
<span class="line-added">+           success = false;</span>
          }
        }
      }
    }
    return success;
  }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 841,96 ***</span>
    default:
      ShouldNotReachHere();
    }
  }
  
<span class="line-modified">! static bool set_bool_flag(const char* name, bool value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   if (JVMFlag::boolAtPut(name, &amp;value, origin) == JVMFlag::SUCCESS) {</span>
      return true;
    } else {
      return false;
    }
  }
  
<span class="line-modified">! static bool set_fp_numeric_flag(const char* name, char* value, JVMFlag::Flags origin) {</span>
    char* end;
    errno = 0;
    double v = strtod(value, &amp;end);
    if ((errno != 0) || (*end != 0)) {
      return false;
    }
  
<span class="line-modified">!   if (JVMFlag::doubleAtPut(name, &amp;v, origin) == JVMFlag::SUCCESS) {</span>
      return true;
    }
    return false;
  }
  
<span class="line-modified">! static bool set_numeric_flag(const char* name, char* value, JVMFlag::Flags origin) {</span>
    julong v;
    int int_v;
    intx intx_v;
    bool is_neg = false;
<span class="line-removed">-   JVMFlag* result = JVMFlag::find_flag(name, strlen(name));</span>
  
<span class="line-modified">!   if (result == NULL) {</span>
      return false;
    }
  
    // Check the sign first since atojulong() parses only unsigned values.
    if (*value == &#39;-&#39;) {
<span class="line-modified">!     if (!result-&gt;is_intx() &amp;&amp; !result-&gt;is_int()) {</span>
        return false;
      }
      value++;
      is_neg = true;
    }
    if (!Arguments::atojulong(value, &amp;v)) {
      return false;
    }
<span class="line-modified">!   if (result-&gt;is_int()) {</span>
      int_v = (int) v;
      if (is_neg) {
        int_v = -int_v;
      }
<span class="line-modified">!     return JVMFlag::intAtPut(result, &amp;int_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (result-&gt;is_uint()) {</span>
      uint uint_v = (uint) v;
<span class="line-modified">!     return JVMFlag::uintAtPut(result, &amp;uint_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (result-&gt;is_intx()) {</span>
      intx_v = (intx) v;
      if (is_neg) {
        intx_v = -intx_v;
      }
<span class="line-modified">!     return JVMFlag::intxAtPut(result, &amp;intx_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (result-&gt;is_uintx()) {</span>
      uintx uintx_v = (uintx) v;
<span class="line-modified">!     return JVMFlag::uintxAtPut(result, &amp;uintx_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (result-&gt;is_uint64_t()) {</span>
      uint64_t uint64_t_v = (uint64_t) v;
<span class="line-modified">!     return JVMFlag::uint64_tAtPut(result, &amp;uint64_t_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (result-&gt;is_size_t()) {</span>
      size_t size_t_v = (size_t) v;
<span class="line-modified">!     return JVMFlag::size_tAtPut(result, &amp;size_t_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (result-&gt;is_double()) {</span>
      double double_v = (double) v;
<span class="line-modified">!     return JVMFlag::doubleAtPut(result, &amp;double_v, origin) == JVMFlag::SUCCESS;</span>
    } else {
      return false;
    }
  }
  
<span class="line-modified">! static bool set_string_flag(const char* name, const char* value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   if (JVMFlag::ccstrAtPut(name, &amp;value, origin) != JVMFlag::SUCCESS) return false;</span>
    // Contract:  JVMFlag always returns a pointer that needs freeing.
    FREE_C_HEAP_ARRAY(char, value);
    return true;
  }
  
<span class="line-modified">! static bool append_to_string_flag(const char* name, const char* new_value, JVMFlag::Flags origin) {</span>
    const char* old_value = &quot;&quot;;
<span class="line-modified">!   if (JVMFlag::ccstrAt(name, &amp;old_value) != JVMFlag::SUCCESS) return false;</span>
    size_t old_len = old_value != NULL ? strlen(old_value) : 0;
    size_t new_len = strlen(new_value);
    const char* value;
    char* free_this_too = NULL;
    if (old_len == 0) {
<span class="line-new-header">--- 854,95 ---</span>
    default:
      ShouldNotReachHere();
    }
  }
  
<span class="line-modified">! static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   if (JVMFlag::boolAtPut(flag, &amp;value, origin) == JVMFlag::SUCCESS) {</span>
      return true;
    } else {
      return false;
    }
  }
  
<span class="line-modified">! static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {</span>
    char* end;
    errno = 0;
    double v = strtod(value, &amp;end);
    if ((errno != 0) || (*end != 0)) {
      return false;
    }
  
<span class="line-modified">!   if (JVMFlag::doubleAtPut(flag, &amp;v, origin) == JVMFlag::SUCCESS) {</span>
      return true;
    }
    return false;
  }
  
<span class="line-modified">! static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {</span>
    julong v;
    int int_v;
    intx intx_v;
    bool is_neg = false;
  
<span class="line-modified">!   if (flag == NULL) {</span>
      return false;
    }
  
    // Check the sign first since atojulong() parses only unsigned values.
    if (*value == &#39;-&#39;) {
<span class="line-modified">!     if (!flag-&gt;is_intx() &amp;&amp; !flag-&gt;is_int()) {</span>
        return false;
      }
      value++;
      is_neg = true;
    }
    if (!Arguments::atojulong(value, &amp;v)) {
      return false;
    }
<span class="line-modified">!   if (flag-&gt;is_int()) {</span>
      int_v = (int) v;
      if (is_neg) {
        int_v = -int_v;
      }
<span class="line-modified">!     return JVMFlag::intAtPut(flag, &amp;int_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (flag-&gt;is_uint()) {</span>
      uint uint_v = (uint) v;
<span class="line-modified">!     return JVMFlag::uintAtPut(flag, &amp;uint_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (flag-&gt;is_intx()) {</span>
      intx_v = (intx) v;
      if (is_neg) {
        intx_v = -intx_v;
      }
<span class="line-modified">!     return JVMFlag::intxAtPut(flag, &amp;intx_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (flag-&gt;is_uintx()) {</span>
      uintx uintx_v = (uintx) v;
<span class="line-modified">!     return JVMFlag::uintxAtPut(flag, &amp;uintx_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (flag-&gt;is_uint64_t()) {</span>
      uint64_t uint64_t_v = (uint64_t) v;
<span class="line-modified">!     return JVMFlag::uint64_tAtPut(flag, &amp;uint64_t_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (flag-&gt;is_size_t()) {</span>
      size_t size_t_v = (size_t) v;
<span class="line-modified">!     return JVMFlag::size_tAtPut(flag, &amp;size_t_v, origin) == JVMFlag::SUCCESS;</span>
<span class="line-modified">!   } else if (flag-&gt;is_double()) {</span>
      double double_v = (double) v;
<span class="line-modified">!     return JVMFlag::doubleAtPut(flag, &amp;double_v, origin) == JVMFlag::SUCCESS;</span>
    } else {
      return false;
    }
  }
  
<span class="line-modified">! static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   if (JVMFlag::ccstrAtPut(flag, &amp;value, origin) != JVMFlag::SUCCESS) return false;</span>
    // Contract:  JVMFlag always returns a pointer that needs freeing.
    FREE_C_HEAP_ARRAY(char, value);
    return true;
  }
  
<span class="line-modified">! static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlag::Flags origin) {</span>
    const char* old_value = &quot;&quot;;
<span class="line-modified">!   if (JVMFlag::ccstrAt(flag, &amp;old_value) != JVMFlag::SUCCESS) return false;</span>
    size_t old_len = old_value != NULL ? strlen(old_value) : 0;
    size_t new_len = strlen(new_value);
    const char* value;
    char* free_this_too = NULL;
    if (old_len == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 943,26 ***</span>
      // each new setting adds another LINE to the switch:
      jio_snprintf(buf, length, &quot;%s\n%s&quot;, old_value, new_value);
      value = buf;
      free_this_too = buf;
    }
<span class="line-modified">!   (void) JVMFlag::ccstrAtPut(name, &amp;value, origin);</span>
    // JVMFlag always returns a pointer that needs freeing.
    FREE_C_HEAP_ARRAY(char, value);
<span class="line-modified">!   if (free_this_too != NULL) {</span>
<span class="line-modified">!     // JVMFlag made its own copy, so I must delete my own temp. buffer.</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(char, free_this_too);</span>
<span class="line-removed">-   }</span>
    return true;
  }
  
  const char* Arguments::handle_aliases_and_deprecation(const char* arg, bool warn) {
    const char* real_name = real_flag_name(arg);
    JDK_Version since = JDK_Version();
    switch (is_deprecated_flag(arg, &amp;since)) {
<span class="line-modified">!     case -1:</span>
<span class="line-modified">!       return NULL; // obsolete or expired, don&#39;t process normally</span>
      case 0:
        return real_name;
      case 1: {
        if (warn) {
          char version[256];
<span class="line-new-header">--- 955,33 ---</span>
      // each new setting adds another LINE to the switch:
      jio_snprintf(buf, length, &quot;%s\n%s&quot;, old_value, new_value);
      value = buf;
      free_this_too = buf;
    }
<span class="line-modified">!   (void) JVMFlag::ccstrAtPut(flag, &amp;value, origin);</span>
    // JVMFlag always returns a pointer that needs freeing.
    FREE_C_HEAP_ARRAY(char, value);
<span class="line-modified">!   // JVMFlag made its own copy, so I must delete my own temp. buffer.</span>
<span class="line-modified">!   FREE_C_HEAP_ARRAY(char, free_this_too);</span>
    return true;
  }
  
  const char* Arguments::handle_aliases_and_deprecation(const char* arg, bool warn) {
    const char* real_name = real_flag_name(arg);
    JDK_Version since = JDK_Version();
    switch (is_deprecated_flag(arg, &amp;since)) {
<span class="line-modified">!   case -1: {</span>
<span class="line-modified">!       // Obsolete or expired, so don&#39;t process normally,</span>
<span class="line-added">+       // but allow for an obsolete flag we&#39;re still</span>
<span class="line-added">+       // temporarily allowing.</span>
<span class="line-added">+       if (!is_obsolete_flag(arg, &amp;since)) {</span>
<span class="line-added">+         return real_name;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       // Note if we&#39;re not considered obsolete then we can&#39;t be expired either</span>
<span class="line-added">+       // as obsoletion must come first.</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
      case 0:
        return real_name;
      case 1: {
        if (warn) {
          char version[256];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1038,11 ***</span>
      }
      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
      if (real_name == NULL) {
        return false;
      }
<span class="line-modified">!     return set_bool_flag(real_name, false, origin);</span>
    }
    if (sscanf(arg, &quot;+%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;dummy) == 1) {
      AliasedLoggingFlag alf = catch_logging_aliases(name, true);
      if (alf.alias_name != NULL){
        LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
<span class="line-new-header">--- 1057,12 ---</span>
      }
      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
      if (real_name == NULL) {
        return false;
      }
<span class="line-modified">!     JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
<span class="line-added">+     return set_bool_flag(flag, false, origin);</span>
    }
    if (sscanf(arg, &quot;+%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;dummy) == 1) {
      AliasedLoggingFlag alf = catch_logging_aliases(name, true);
      if (alf.alias_name != NULL){
        LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1050,17 ***</span>
      }
      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
      if (real_name == NULL) {
        return false;
      }
<span class="line-modified">!     return set_bool_flag(real_name, true, origin);</span>
    }
  
    char punct;
    if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;punct) == 2 &amp;&amp; punct == &#39;=&#39;) {
      const char* value = strchr(arg, &#39;=&#39;) + 1;
<span class="line-removed">-     JVMFlag* flag;</span>
  
      // this scanf pattern matches both strings (handled here) and numbers (handled later))
      AliasedLoggingFlag alf = catch_logging_aliases(name, true);
      if (alf.alias_name != NULL) {
        LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
<span class="line-new-header">--- 1070,17 ---</span>
      }
      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
      if (real_name == NULL) {
        return false;
      }
<span class="line-modified">!     JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
<span class="line-added">+     return set_bool_flag(flag, true, origin);</span>
    }
  
    char punct;
    if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;punct) == 2 &amp;&amp; punct == &#39;=&#39;) {
      const char* value = strchr(arg, &#39;=&#39;) + 1;
  
      // this scanf pattern matches both strings (handled here) and numbers (handled later))
      AliasedLoggingFlag alf = catch_logging_aliases(name, true);
      if (alf.alias_name != NULL) {
        LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1068,19 ***</span>
      }
      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
      if (real_name == NULL) {
        return false;
      }
<span class="line-modified">!     flag = JVMFlag::find_flag(real_name);</span>
      if (flag != NULL &amp;&amp; flag-&gt;is_ccstr()) {
        if (flag-&gt;ccstr_accumulates()) {
<span class="line-modified">!         return append_to_string_flag(real_name, value, origin);</span>
        } else {
          if (value[0] == &#39;\0&#39;) {
            value = NULL;
          }
<span class="line-modified">!         return set_string_flag(real_name, value, origin);</span>
        }
      } else {
        warn_if_deprecated = false; // if arg is deprecated, we&#39;ve already done warning...
      }
    }
<span class="line-new-header">--- 1088,19 ---</span>
      }
      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
      if (real_name == NULL) {
        return false;
      }
<span class="line-modified">!     JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
      if (flag != NULL &amp;&amp; flag-&gt;is_ccstr()) {
        if (flag-&gt;ccstr_accumulates()) {
<span class="line-modified">!         return append_to_string_flag(flag, value, origin);</span>
        } else {
          if (value[0] == &#39;\0&#39;) {
            value = NULL;
          }
<span class="line-modified">!         return set_string_flag(flag, value, origin);</span>
        }
      } else {
        warn_if_deprecated = false; // if arg is deprecated, we&#39;ve already done warning...
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1093,11 ***</span>
      }
      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
      if (real_name == NULL) {
        return false;
      }
<span class="line-modified">!     return set_string_flag(real_name, value, origin);</span>
    }
  
  #define SIGNED_FP_NUMBER_RANGE &quot;[-0123456789.eE+]&quot;
  #define SIGNED_NUMBER_RANGE    &quot;[-0123456789]&quot;
  #define        NUMBER_RANGE    &quot;[0123456789eE+-]&quot;
<span class="line-new-header">--- 1113,12 ---</span>
      }
      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
      if (real_name == NULL) {
        return false;
      }
<span class="line-modified">!     JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
<span class="line-added">+     return set_string_flag(flag, value, origin);</span>
    }
  
  #define SIGNED_FP_NUMBER_RANGE &quot;[-0123456789.eE+]&quot;
  #define SIGNED_NUMBER_RANGE    &quot;[-0123456789]&quot;
  #define        NUMBER_RANGE    &quot;[0123456789eE+-]&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1108,21 ***</span>
      if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) SIGNED_FP_NUMBER_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
        real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
        if (real_name == NULL) {
          return false;
        }
<span class="line-modified">!       return set_fp_numeric_flag(real_name, value, origin);</span>
      }
    }
  
  #define VALUE_RANGE &quot;[-kmgtxKMGTX0123456789abcdefABCDEF]&quot;
    if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) VALUE_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
      if (real_name == NULL) {
        return false;
      }
<span class="line-modified">!     return set_numeric_flag(real_name, value, origin);</span>
    }
  
    return false;
  }
  
<span class="line-new-header">--- 1129,23 ---</span>
      if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) SIGNED_FP_NUMBER_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
        real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
        if (real_name == NULL) {
          return false;
        }
<span class="line-modified">!       JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
<span class="line-added">+       return set_fp_numeric_flag(flag, value, origin);</span>
      }
    }
  
  #define VALUE_RANGE &quot;[-kmgtxKMGTX0123456789abcdefABCDEF]&quot;
    if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) VALUE_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
      if (real_name == NULL) {
        return false;
      }
<span class="line-modified">!     JVMFlag* flag = JVMFlag::find_flag(real_name);</span>
<span class="line-added">+     return set_numeric_flag(flag, value, origin);</span>
    }
  
    return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1274,11 ***</span>
  #endif //PRODUCT
    }
  
    // For locked flags, report a custom error message if available.
    // Otherwise, report the standard unrecognized VM option.
<span class="line-modified">!   JVMFlag* found_flag = JVMFlag::find_flag((const char*)argname, arg_len, true, true);</span>
    if (found_flag != NULL) {
      char locked_message_buf[BUFLEN];
      JVMFlag::MsgType msg_type = found_flag-&gt;get_locked_message(locked_message_buf, BUFLEN);
      if (strlen(locked_message_buf) == 0) {
        if (found_flag-&gt;is_bool() &amp;&amp; !has_plus_minus) {
<span class="line-new-header">--- 1297,11 ---</span>
  #endif //PRODUCT
    }
  
    // For locked flags, report a custom error message if available.
    // Otherwise, report the standard unrecognized VM option.
<span class="line-modified">!   const JVMFlag* found_flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);</span>
    if (found_flag != NULL) {
      char locked_message_buf[BUFLEN];
      JVMFlag::MsgType msg_type = found_flag-&gt;get_locked_message(locked_message_buf, BUFLEN);
      if (strlen(locked_message_buf) == 0) {
        if (found_flag-&gt;is_bool() &amp;&amp; !has_plus_minus) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1413,14 ***</span>
    }
  
    if (strcmp(key, &quot;java.compiler&quot;) == 0) {
      process_java_compiler_argument(value);
      // Record value in Arguments, but let it get passed to Java.
<span class="line-modified">!   } else if (strcmp(key, &quot;sun.java.launcher.is_altjvm&quot;) == 0 ||</span>
<span class="line-modified">!              strcmp(key, &quot;sun.java.launcher.pid&quot;) == 0) {</span>
<span class="line-modified">!     // sun.java.launcher.is_altjvm and sun.java.launcher.pid property are</span>
<span class="line-removed">-     // private and are processed in process_sun_java_launcher_properties();</span>
      // the sun.java.launcher property is passed on to the java application
    } else if (strcmp(key, &quot;sun.boot.library.path&quot;) == 0) {
      // append is true, writable is true, internal is false
      PropertyList_unique_add(&amp;_system_properties, key, value, AppendProperty,
                              WriteableProperty, ExternalProperty);
<span class="line-new-header">--- 1436,13 ---</span>
    }
  
    if (strcmp(key, &quot;java.compiler&quot;) == 0) {
      process_java_compiler_argument(value);
      // Record value in Arguments, but let it get passed to Java.
<span class="line-modified">!   } else if (strcmp(key, &quot;sun.java.launcher.is_altjvm&quot;) == 0) {</span>
<span class="line-modified">!     // sun.java.launcher.is_altjvm property is</span>
<span class="line-modified">!     // private and is processed in process_sun_java_launcher_properties();</span>
      // the sun.java.launcher property is passed on to the java application
    } else if (strcmp(key, &quot;sun.boot.library.path&quot;) == 0) {
      // append is true, writable is true, internal is false
      PropertyList_unique_add(&amp;_system_properties, key, value, AppendProperty,
                              WriteableProperty, ExternalProperty);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1430,16 ***</span>
        _java_command = os::strdup_check_oom(value, mtArguments);
        if (old_java_command != NULL) {
          os::free(old_java_command);
        }
      } else if (strcmp(key, &quot;java.vendor.url.bug&quot;) == 0) {
        const char* old_java_vendor_url_bug = _java_vendor_url_bug;
        // save it in _java_vendor_url_bug, so JVM fatal error handler can access
        // its value without going through the property list or making a Java call.
        _java_vendor_url_bug = os::strdup_check_oom(value, mtArguments);
<span class="line-modified">!       if (old_java_vendor_url_bug != DEFAULT_VENDOR_URL_BUG) {</span>
<span class="line-removed">-         assert(old_java_vendor_url_bug != NULL, &quot;_java_vendor_url_bug is NULL&quot;);</span>
          os::free((void *)old_java_vendor_url_bug);
        }
      }
  
      // Create new property and add at the end of the list
<span class="line-new-header">--- 1452,20 ---</span>
        _java_command = os::strdup_check_oom(value, mtArguments);
        if (old_java_command != NULL) {
          os::free(old_java_command);
        }
      } else if (strcmp(key, &quot;java.vendor.url.bug&quot;) == 0) {
<span class="line-added">+       // If this property is set on the command line then its value will be</span>
<span class="line-added">+       // displayed in VM error logs as the URL at which to submit such logs.</span>
<span class="line-added">+       // Normally the URL displayed in error logs is different from the value</span>
<span class="line-added">+       // of this system property, so a different property should have been</span>
<span class="line-added">+       // used here, but we leave this as-is in case someone depends upon it.</span>
        const char* old_java_vendor_url_bug = _java_vendor_url_bug;
        // save it in _java_vendor_url_bug, so JVM fatal error handler can access
        // its value without going through the property list or making a Java call.
        _java_vendor_url_bug = os::strdup_check_oom(value, mtArguments);
<span class="line-modified">!       if (old_java_vendor_url_bug != NULL) {</span>
          os::free((void *)old_java_vendor_url_bug);
        }
      }
  
      // Create new property and add at the end of the list
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1462,11 ***</span>
  const char* unsupported_options[] = { &quot;--limit-modules&quot;,
                                        &quot;--upgrade-module-path&quot;,
                                        &quot;--patch-module&quot;
                                      };
  void Arguments::check_unsupported_dumping_properties() {
<span class="line-modified">!   assert(DumpSharedSpaces, &quot;this function is only used with -Xshare:dump&quot;);</span>
    assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);
    // If a vm option is found in the unsupported_options array, vm will exit with an error message.
    SystemProperty* sp = system_properties();
    while (sp != NULL) {
      for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
<span class="line-new-header">--- 1488,12 ---</span>
  const char* unsupported_options[] = { &quot;--limit-modules&quot;,
                                        &quot;--upgrade-module-path&quot;,
                                        &quot;--patch-module&quot;
                                      };
  void Arguments::check_unsupported_dumping_properties() {
<span class="line-modified">!   assert(is_dumping_archive(),</span>
<span class="line-added">+          &quot;this function is only used with CDS dump time&quot;);</span>
    assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);
    // If a vm option is found in the unsupported_options array, vm will exit with an error message.
    SystemProperty* sp = system_properties();
    while (sp != NULL) {
      for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1485,10 ***</span>
<span class="line-new-header">--- 1512,17 ---</span>
  }
  
  bool Arguments::check_unsupported_cds_runtime_properties() {
    assert(UseSharedSpaces, &quot;this function is only used with -Xshare:{on,auto}&quot;);
    assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);
<span class="line-added">+   if (ArchiveClassesAtExit != NULL) {</span>
<span class="line-added">+     // dynamic dumping, just return false for now.</span>
<span class="line-added">+     // check_unsupported_dumping_properties() will be called later to check the same set of</span>
<span class="line-added">+     // properties, and will exit the VM with the correct error message if the unsupported properties</span>
<span class="line-added">+     // are used.</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
    for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
      if (get_property(unsupported_properties[i]) != NULL) {
        if (RequireSharedSpaces) {
          warning(&quot;CDS is disabled when the %s option is specified.&quot;, unsupported_options[i]);
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1568,10 ***</span>
<span class="line-new-header">--- 1602,11 ---</span>
    if (RequireSharedSpaces) {
      jio_fprintf(defaultStream::error_stream(),
        &quot;Class data sharing is inconsistent with other specified options.\n&quot;);
      vm_exit_during_initialization(&quot;Unable to use shared archive&quot;, message);
    } else {
<span class="line-added">+     log_info(cds)(&quot;Unable to use shared archive: %s&quot;, message);</span>
      FLAG_SET_DEFAULT(UseSharedSpaces, false);
    }
  }
  
  void set_object_alignment() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1611,19 ***</span>
  void Arguments::set_use_compressed_oops() {
  #ifndef ZERO
  #ifdef _LP64
    // MaxHeapSize is not set up properly at this point, but
    // the only value that can override MaxHeapSize if we are
<span class="line-modified">!   // to use UseCompressedOops is InitialHeapSize.</span>
<span class="line-modified">!   size_t max_heap_size = MAX2(MaxHeapSize, InitialHeapSize);</span>
  
    if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
<span class="line-removed">- #if !defined(COMPILER1) || defined(TIERED)</span>
      if (FLAG_IS_DEFAULT(UseCompressedOops)) {
<span class="line-modified">!       FLAG_SET_ERGO(bool, UseCompressedOops, true);</span>
      }
<span class="line-removed">- #endif</span>
    } else {
      if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
        warning(&quot;Max heap size too large for Compressed Oops&quot;);
        FLAG_SET_DEFAULT(UseCompressedOops, false);
        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
<span class="line-new-header">--- 1646,17 ---</span>
  void Arguments::set_use_compressed_oops() {
  #ifndef ZERO
  #ifdef _LP64
    // MaxHeapSize is not set up properly at this point, but
    // the only value that can override MaxHeapSize if we are
<span class="line-modified">!   // to use UseCompressedOops are InitialHeapSize and MinHeapSize.</span>
<span class="line-modified">!   size_t max_heap_size = MAX3(MaxHeapSize, InitialHeapSize, MinHeapSize);</span>
  
    if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
      if (FLAG_IS_DEFAULT(UseCompressedOops)) {
<span class="line-modified">!       FLAG_SET_ERGO(UseCompressedOops, true);</span>
      }
    } else {
      if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
        warning(&quot;Max heap size too large for Compressed Oops&quot;);
        FLAG_SET_DEFAULT(UseCompressedOops, false);
        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1646,11 ***</span>
      }
      FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
    } else {
      // Turn on UseCompressedClassPointers too
      if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
<span class="line-modified">!       FLAG_SET_ERGO(bool, UseCompressedClassPointers, true);</span>
      }
      // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
      if (UseCompressedClassPointers) {
        if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
          warning(&quot;CompressedClassSpaceSize is too large for UseCompressedClassPointers&quot;);
<span class="line-new-header">--- 1679,11 ---</span>
      }
      FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
    } else {
      // Turn on UseCompressedClassPointers too
      if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
<span class="line-modified">!       FLAG_SET_ERGO(UseCompressedClassPointers, true);</span>
      }
      // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
      if (UseCompressedClassPointers) {
        if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
          warning(&quot;CompressedClassSpaceSize is too large for UseCompressedClassPointers&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1663,17 ***</span>
  }
  
  void Arguments::set_conservative_max_heap_alignment() {
    // The conservative maximum required alignment for the heap is the maximum of
    // the alignments imposed by several sources: any requirements from the heap
<span class="line-modified">!   // itself, the collector policy and the maximum page size we may run the VM</span>
<span class="line-removed">-   // with.</span>
    size_t heap_alignment = GCConfig::arguments()-&gt;conservative_max_heap_alignment();
    _conservative_max_heap_alignment = MAX4(heap_alignment,
                                            (size_t)os::vm_allocation_granularity(),
                                            os::max_page_size(),
<span class="line-modified">!                                           CollectorPolicy::compute_heap_alignment());</span>
  }
  
  jint Arguments::set_ergonomics_flags() {
    GCConfig::initialize();
  
<span class="line-new-header">--- 1696,16 ---</span>
  }
  
  void Arguments::set_conservative_max_heap_alignment() {
    // The conservative maximum required alignment for the heap is the maximum of
    // the alignments imposed by several sources: any requirements from the heap
<span class="line-modified">!   // itself and the maximum page size we may run the VM with.</span>
    size_t heap_alignment = GCConfig::arguments()-&gt;conservative_max_heap_alignment();
    _conservative_max_heap_alignment = MAX4(heap_alignment,
                                            (size_t)os::vm_allocation_granularity(),
                                            os::max_page_size(),
<span class="line-modified">!                                           GCArguments::compute_heap_alignment());</span>
  }
  
  jint Arguments::set_ergonomics_flags() {
    GCConfig::initialize();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1706,13 ***</span>
  
  // Use static initialization to get the default before parsing
  static const size_t DefaultHeapBaseMinAddress = HeapBaseMinAddress;
  
  void Arguments::set_heap_size() {
<span class="line-modified">!   julong phys_mem =</span>
<span class="line-modified">!     FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)</span>
<span class="line-modified">!                             : (julong)MaxRAM;</span>
  
    // Convert deprecated flags
    if (FLAG_IS_DEFAULT(MaxRAMPercentage) &amp;&amp;
        !FLAG_IS_DEFAULT(MaxRAMFraction))
      MaxRAMPercentage = 100.0 / MaxRAMFraction;
<span class="line-new-header">--- 1738,37 ---</span>
  
  // Use static initialization to get the default before parsing
  static const size_t DefaultHeapBaseMinAddress = HeapBaseMinAddress;
  
  void Arguments::set_heap_size() {
<span class="line-modified">!   julong phys_mem;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // If the user specified one of these options, they</span>
<span class="line-added">+   // want specific memory sizing so do not limit memory</span>
<span class="line-added">+   // based on compressed oops addressability.</span>
<span class="line-added">+   // Also, memory limits will be calculated based on</span>
<span class="line-added">+   // available os physical memory, not our MaxRAM limit,</span>
<span class="line-added">+   // unless MaxRAM is also specified.</span>
<span class="line-added">+   bool override_coop_limit = (!FLAG_IS_DEFAULT(MaxRAMPercentage) ||</span>
<span class="line-added">+                            !FLAG_IS_DEFAULT(MaxRAMFraction) ||</span>
<span class="line-added">+                            !FLAG_IS_DEFAULT(MinRAMPercentage) ||</span>
<span class="line-added">+                            !FLAG_IS_DEFAULT(MinRAMFraction) ||</span>
<span class="line-added">+                            !FLAG_IS_DEFAULT(InitialRAMPercentage) ||</span>
<span class="line-added">+                            !FLAG_IS_DEFAULT(InitialRAMFraction) ||</span>
<span class="line-added">+                            !FLAG_IS_DEFAULT(MaxRAM));</span>
<span class="line-added">+   if (override_coop_limit) {</span>
<span class="line-added">+     if (FLAG_IS_DEFAULT(MaxRAM)) {</span>
<span class="line-added">+       phys_mem = os::physical_memory();</span>
<span class="line-added">+       FLAG_SET_ERGO(MaxRAM, (uint64_t)phys_mem);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       phys_mem = (julong)MaxRAM;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)</span>
<span class="line-added">+                                        : (julong)MaxRAM;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
  
    // Convert deprecated flags
    if (FLAG_IS_DEFAULT(MaxRAMPercentage) &amp;&amp;
        !FLAG_IS_DEFAULT(MaxRAMFraction))
      MaxRAMPercentage = 100.0 / MaxRAMFraction;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1742,10 ***</span>
<span class="line-new-header">--- 1798,12 ---</span>
  
      if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
        // Limit the heap size to ErgoHeapSizeLimit
        reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
      }
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef _LP64</span>
      if (UseCompressedOops) {
        // Limit the heap size to the maximum possible when using compressed oops
        julong max_coop_heap = (julong)max_heap_for_compressed_oops();
  
        // HeapBaseMinAddress can be greater than default but not less than.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1755,60 ***</span>
            log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
                                       &quot; (&quot; SIZE_FORMAT &quot;G) which is greater than value given &quot; SIZE_FORMAT,
                                       DefaultHeapBaseMinAddress,
                                       DefaultHeapBaseMinAddress/G,
                                       HeapBaseMinAddress);
<span class="line-modified">!           FLAG_SET_ERGO(size_t, HeapBaseMinAddress, DefaultHeapBaseMinAddress);</span>
          }
        }
  
        if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
          // Heap should be above HeapBaseMinAddress to get zero based compressed oops
          // but it should be not less than default MaxHeapSize.
          max_coop_heap -= HeapBaseMinAddress;
        }
<span class="line-modified">!       reasonable_max = MIN2(reasonable_max, max_coop_heap);</span>
      }
      reasonable_max = limit_by_allocatable_memory(reasonable_max);
  
      if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
        // An initial heap size was specified on the command line,
        // so be sure that the maximum size is consistent.  Done
        // after call to limit_by_allocatable_memory because that
        // method might reduce the allocation size.
        reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
      }
  
      log_trace(gc, heap)(&quot;  Maximum heap size &quot; SIZE_FORMAT, (size_t) reasonable_max);
<span class="line-modified">!     FLAG_SET_ERGO(size_t, MaxHeapSize, (size_t)reasonable_max);</span>
    }
  
    // If the minimum or initial heap_size have not been set or requested to be set
    // ergonomically, set them accordingly.
<span class="line-modified">!   if (InitialHeapSize == 0 || min_heap_size() == 0) {</span>
      julong reasonable_minimum = (julong)(OldSize + NewSize);
  
      reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);
  
      reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);
  
      if (InitialHeapSize == 0) {
        julong reasonable_initial = (julong)((phys_mem * InitialRAMPercentage) / 100);
  
<span class="line-modified">!       reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)min_heap_size());</span>
        reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);
  
        reasonable_initial = limit_by_allocatable_memory(reasonable_initial);
  
<span class="line-modified">!       log_trace(gc, heap)(&quot;  Initial heap size &quot; SIZE_FORMAT, (size_t)reasonable_initial);</span>
<span class="line-modified">!       FLAG_SET_ERGO(size_t, InitialHeapSize, (size_t)reasonable_initial);</span>
      }
<span class="line-modified">!     // If the minimum heap size has not been set (via -Xms),</span>
      // synchronize with InitialHeapSize to avoid errors with the default value.
<span class="line-modified">!     if (min_heap_size() == 0) {</span>
<span class="line-modified">!       set_min_heap_size(MIN2((size_t)reasonable_minimum, InitialHeapSize));</span>
<span class="line-modified">!       log_trace(gc, heap)(&quot;  Minimum heap size &quot; SIZE_FORMAT, min_heap_size());</span>
      }
    }
  }
  
  // This option inspects the machine and attempts to set various
<span class="line-new-header">--- 1813,80 ---</span>
            log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
                                       &quot; (&quot; SIZE_FORMAT &quot;G) which is greater than value given &quot; SIZE_FORMAT,
                                       DefaultHeapBaseMinAddress,
                                       DefaultHeapBaseMinAddress/G,
                                       HeapBaseMinAddress);
<span class="line-modified">!           FLAG_SET_ERGO(HeapBaseMinAddress, DefaultHeapBaseMinAddress);</span>
          }
        }
  
        if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
          // Heap should be above HeapBaseMinAddress to get zero based compressed oops
          // but it should be not less than default MaxHeapSize.
          max_coop_heap -= HeapBaseMinAddress;
        }
<span class="line-modified">! </span>
<span class="line-added">+       // If user specified flags prioritizing os physical</span>
<span class="line-added">+       // memory limits, then disable compressed oops if</span>
<span class="line-added">+       // limits exceed max_coop_heap and UseCompressedOops</span>
<span class="line-added">+       // was not specified.</span>
<span class="line-added">+       if (reasonable_max &gt; max_coop_heap) {</span>
<span class="line-added">+         if (FLAG_IS_ERGO(UseCompressedOops) &amp;&amp; override_coop_limit) {</span>
<span class="line-added">+           log_info(cds)(&quot;UseCompressedOops and UseCompressedClassPointers have been disabled due to&quot;</span>
<span class="line-added">+             &quot; max heap &quot; SIZE_FORMAT &quot; &gt; compressed oop heap &quot; SIZE_FORMAT &quot;. &quot;</span>
<span class="line-added">+             &quot;Please check the setting of MaxRAMPercentage %5.2f.&quot;</span>
<span class="line-added">+             ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);</span>
<span class="line-added">+           FLAG_SET_ERGO(UseCompressedOops, false);</span>
<span class="line-added">+           FLAG_SET_ERGO(UseCompressedClassPointers, false);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           reasonable_max = MIN2(reasonable_max, max_coop_heap);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
      }
<span class="line-added">+ #endif // _LP64</span>
<span class="line-added">+ </span>
      reasonable_max = limit_by_allocatable_memory(reasonable_max);
  
      if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
        // An initial heap size was specified on the command line,
        // so be sure that the maximum size is consistent.  Done
        // after call to limit_by_allocatable_memory because that
        // method might reduce the allocation size.
        reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
<span class="line-added">+     } else if (!FLAG_IS_DEFAULT(MinHeapSize)) {</span>
<span class="line-added">+       reasonable_max = MAX2(reasonable_max, (julong)MinHeapSize);</span>
      }
  
      log_trace(gc, heap)(&quot;  Maximum heap size &quot; SIZE_FORMAT, (size_t) reasonable_max);
<span class="line-modified">!     FLAG_SET_ERGO(MaxHeapSize, (size_t)reasonable_max);</span>
    }
  
    // If the minimum or initial heap_size have not been set or requested to be set
    // ergonomically, set them accordingly.
<span class="line-modified">!   if (InitialHeapSize == 0 || MinHeapSize == 0) {</span>
      julong reasonable_minimum = (julong)(OldSize + NewSize);
  
      reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);
  
      reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);
  
      if (InitialHeapSize == 0) {
        julong reasonable_initial = (julong)((phys_mem * InitialRAMPercentage) / 100);
  
<span class="line-modified">!       reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)MinHeapSize);</span>
        reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);
  
        reasonable_initial = limit_by_allocatable_memory(reasonable_initial);
  
<span class="line-modified">!       FLAG_SET_ERGO(InitialHeapSize, (size_t)reasonable_initial);</span>
<span class="line-modified">!       log_trace(gc, heap)(&quot;  Initial heap size &quot; SIZE_FORMAT, InitialHeapSize);</span>
      }
<span class="line-modified">!     // If the minimum heap size has not been set (via -Xms or -XX:MinHeapSize),</span>
      // synchronize with InitialHeapSize to avoid errors with the default value.
<span class="line-modified">!     if (MinHeapSize == 0) {</span>
<span class="line-modified">!       FLAG_SET_ERGO(MinHeapSize, MIN2((size_t)reasonable_minimum, InitialHeapSize));</span>
<span class="line-modified">!       log_trace(gc, heap)(&quot;  Minimum heap size &quot; SIZE_FORMAT, MinHeapSize);</span>
      }
    }
  }
  
  // This option inspects the machine and attempts to set various
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1839,49 ***</span>
            total_memory - (julong) 160 * M);
  
    initHeapSize = limit_by_allocatable_memory(initHeapSize);
  
    if (FLAG_IS_DEFAULT(MaxHeapSize)) {
<span class="line-modified">!     if (FLAG_SET_CMDLINE(size_t, MaxHeapSize, initHeapSize) != JVMFlag::SUCCESS) {</span>
        return JNI_EINVAL;
      }
<span class="line-modified">!     if (FLAG_SET_CMDLINE(size_t, InitialHeapSize, initHeapSize) != JVMFlag::SUCCESS) {</span>
        return JNI_EINVAL;
      }
<span class="line-removed">-     // Currently the minimum size and the initial heap sizes are the same.</span>
<span class="line-removed">-     set_min_heap_size(initHeapSize);</span>
    }
    if (FLAG_IS_DEFAULT(NewSize)) {
      // Make the young generation 3/8ths of the total heap.
<span class="line-modified">!     if (FLAG_SET_CMDLINE(size_t, NewSize,</span>
              ((julong) MaxHeapSize / (julong) 8) * (julong) 3) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
<span class="line-modified">!     if (FLAG_SET_CMDLINE(size_t, MaxNewSize, NewSize) != JVMFlag::SUCCESS) {</span>
        return JNI_EINVAL;
      }
    }
  
  #if !defined(_ALLBSD_SOURCE) &amp;&amp; !defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
    FLAG_SET_DEFAULT(UseLargePages, true);
  #endif
  
    // Increase some data structure sizes for efficiency
<span class="line-modified">!   if (FLAG_SET_CMDLINE(size_t, BaseFootPrintEstimate, MaxHeapSize) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
<span class="line-modified">!   if (FLAG_SET_CMDLINE(bool, ResizeTLAB, false) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
<span class="line-modified">!   if (FLAG_SET_CMDLINE(size_t, TLABSize, 256 * K) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
  
    // See the OldPLABSize comment below, but replace &#39;after promotion&#39;
    // with &#39;after copying&#39;.  YoungPLABSize is the size of the survivor
    // space per-gc-thread buffers.  The default is 4kw.
<span class="line-modified">!   if (FLAG_SET_CMDLINE(size_t, YoungPLABSize, 256 * K) != JVMFlag::SUCCESS) { // Note: this is in words</span>
      return JNI_EINVAL;
    }
  
    // OldPLABSize is the size of the buffers in the old gen that
    // UseParallelGC uses to promote live data that doesn&#39;t fit in the
<span class="line-new-header">--- 1917,50 ---</span>
            total_memory - (julong) 160 * M);
  
    initHeapSize = limit_by_allocatable_memory(initHeapSize);
  
    if (FLAG_IS_DEFAULT(MaxHeapSize)) {
<span class="line-modified">!     if (FLAG_SET_CMDLINE(MaxHeapSize, initHeapSize) != JVMFlag::SUCCESS) {</span>
        return JNI_EINVAL;
      }
<span class="line-modified">!     if (FLAG_SET_CMDLINE(InitialHeapSize, initHeapSize) != JVMFlag::SUCCESS) {</span>
<span class="line-added">+       return JNI_EINVAL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (FLAG_SET_CMDLINE(MinHeapSize, initHeapSize) != JVMFlag::SUCCESS) {</span>
        return JNI_EINVAL;
      }
    }
    if (FLAG_IS_DEFAULT(NewSize)) {
      // Make the young generation 3/8ths of the total heap.
<span class="line-modified">!     if (FLAG_SET_CMDLINE(NewSize,</span>
              ((julong) MaxHeapSize / (julong) 8) * (julong) 3) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
<span class="line-modified">!     if (FLAG_SET_CMDLINE(MaxNewSize, NewSize) != JVMFlag::SUCCESS) {</span>
        return JNI_EINVAL;
      }
    }
  
  #if !defined(_ALLBSD_SOURCE) &amp;&amp; !defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
    FLAG_SET_DEFAULT(UseLargePages, true);
  #endif
  
    // Increase some data structure sizes for efficiency
<span class="line-modified">!   if (FLAG_SET_CMDLINE(BaseFootPrintEstimate, MaxHeapSize) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
<span class="line-modified">!   if (FLAG_SET_CMDLINE(ResizeTLAB, false) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
<span class="line-modified">!   if (FLAG_SET_CMDLINE(TLABSize, 256 * K) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
  
    // See the OldPLABSize comment below, but replace &#39;after promotion&#39;
    // with &#39;after copying&#39;.  YoungPLABSize is the size of the survivor
    // space per-gc-thread buffers.  The default is 4kw.
<span class="line-modified">!   if (FLAG_SET_CMDLINE(YoungPLABSize, 256 * K) != JVMFlag::SUCCESS) { // Note: this is in words</span>
      return JNI_EINVAL;
    }
  
    // OldPLABSize is the size of the buffers in the old gen that
    // UseParallelGC uses to promote live data that doesn&#39;t fit in the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1894,33 ***</span>
    // is that a bigger PLAB results in retaining something like the
    // original allocation order after promotion, which improves mutator
    // locality.  A minor effect may be that larger PLABs reduce the
    // number of PLAB allocation events during gc.  The value of 8kw
    // was arrived at by experimenting with specjbb.
<span class="line-modified">!   if (FLAG_SET_CMDLINE(size_t, OldPLABSize, 8 * K) != JVMFlag::SUCCESS) { // Note: this is in words</span>
      return JNI_EINVAL;
    }
  
    // Enable parallel GC and adaptive generation sizing
<span class="line-modified">!   if (FLAG_SET_CMDLINE(bool, UseParallelGC, true) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
  
    // Encourage steady state memory management
<span class="line-modified">!   if (FLAG_SET_CMDLINE(uintx, ThresholdTolerance, 100) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
  
    // This appears to improve mutator locality
<span class="line-modified">!   if (FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {</span>
<span class="line-removed">-     return JNI_EINVAL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Get around early Solaris scheduling bug</span>
<span class="line-removed">-   // (affinity vs other jobs on system)</span>
<span class="line-removed">-   // but disallow DR and offlining (5008695).</span>
<span class="line-removed">-   if (FLAG_SET_CMDLINE(bool, BindGCTaskThreadsToCPUs, true) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
  
    return JNI_OK;
  }
<span class="line-new-header">--- 1973,26 ---</span>
    // is that a bigger PLAB results in retaining something like the
    // original allocation order after promotion, which improves mutator
    // locality.  A minor effect may be that larger PLABs reduce the
    // number of PLAB allocation events during gc.  The value of 8kw
    // was arrived at by experimenting with specjbb.
<span class="line-modified">!   if (FLAG_SET_CMDLINE(OldPLABSize, 8 * K) != JVMFlag::SUCCESS) { // Note: this is in words</span>
      return JNI_EINVAL;
    }
  
    // Enable parallel GC and adaptive generation sizing
<span class="line-modified">!   if (FLAG_SET_CMDLINE(UseParallelGC, true) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
  
    // Encourage steady state memory management
<span class="line-modified">!   if (FLAG_SET_CMDLINE(ThresholdTolerance, 100) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
  
    // This appears to improve mutator locality
<span class="line-modified">!   if (FLAG_SET_CMDLINE(ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {</span>
      return JNI_EINVAL;
    }
  
    return JNI_OK;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2037,21 ***</span>
    }
  #endif
  
  #ifndef SUPPORT_RESERVED_STACK_AREA
    if (StackReservedPages != 0) {
<span class="line-modified">!     FLAG_SET_CMDLINE(intx, StackReservedPages, 0);</span>
      warning(&quot;Reserved Stack Area not supported on this platform&quot;);
    }
  #endif
  
<span class="line-removed">-   if (!FLAG_IS_DEFAULT(AllocateHeapAt)) {</span>
<span class="line-removed">-     if ((UseNUMAInterleaving &amp;&amp; !FLAG_IS_DEFAULT(UseNUMAInterleaving)) || (UseNUMA &amp;&amp; !FLAG_IS_DEFAULT(UseNUMA))) {</span>
<span class="line-removed">-       log_warning(arguments) (&quot;NUMA support for Heap depends on the file system when AllocateHeapAt option is used.\n&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    status = status &amp;&amp; GCArguments::check_args_consistency();
  
    return status;
  }
  
<span class="line-new-header">--- 2109,15 ---</span>
    }
  #endif
  
  #ifndef SUPPORT_RESERVED_STACK_AREA
    if (StackReservedPages != 0) {
<span class="line-modified">!     FLAG_SET_CMDLINE(StackReservedPages, 0);</span>
      warning(&quot;Reserved Stack Area not supported on this platform&quot;);
    }
  #endif
  
    status = status &amp;&amp; GCArguments::check_args_consistency();
  
    return status;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2146,11 ***</span>
    return check_memory_size(*long_arg, min_size, max_size);
  }
  
  // Parse JavaVMInitArgs structure
  
<span class="line-modified">! jint Arguments::parse_vm_init_args(const JavaVMInitArgs *java_tool_options_args,</span>
                                     const JavaVMInitArgs *java_options_args,
                                     const JavaVMInitArgs *cmd_line_args) {
    bool patch_mod_javabase = false;
  
    // Save default settings for some mode flags
<span class="line-new-header">--- 2212,12 ---</span>
    return check_memory_size(*long_arg, min_size, max_size);
  }
  
  // Parse JavaVMInitArgs structure
  
<span class="line-modified">! jint Arguments::parse_vm_init_args(const JavaVMInitArgs *vm_options_args,</span>
<span class="line-added">+                                    const JavaVMInitArgs *java_tool_options_args,</span>
                                     const JavaVMInitArgs *java_options_args,
                                     const JavaVMInitArgs *cmd_line_args) {
    bool patch_mod_javabase = false;
  
    // Save default settings for some mode flags
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2161,16 ***</span>
    if (TieredCompilation) {
      Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;
      Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;
    }
  
    // Setup flags for mixed which is the default
    set_mode_flags(_mixed);
  
    // Parse args structure generated from JAVA_TOOL_OPTIONS environment
    // variable (if present).
<span class="line-modified">!   jint result = parse_each_vm_init_arg(java_tool_options_args, &amp;patch_mod_javabase, JVMFlag::ENVIRON_VAR);</span>
    if (result != JNI_OK) {
      return result;
    }
  
    // Parse args structure generated from the command line flags.
<span class="line-new-header">--- 2228,25 ---</span>
    if (TieredCompilation) {
      Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;
      Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;
    }
  
<span class="line-added">+   // CDS dumping always write the archive to the default value of SharedBaseAddress.</span>
<span class="line-added">+   Arguments::_SharedBaseAddress = SharedBaseAddress;</span>
<span class="line-added">+ </span>
    // Setup flags for mixed which is the default
    set_mode_flags(_mixed);
  
<span class="line-added">+   // Parse args structure generated from java.base vm options resource</span>
<span class="line-added">+   jint result = parse_each_vm_init_arg(vm_options_args, &amp;patch_mod_javabase, JVMFlag::JIMAGE_RESOURCE);</span>
<span class="line-added">+   if (result != JNI_OK) {</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Parse args structure generated from JAVA_TOOL_OPTIONS environment
    // variable (if present).
<span class="line-modified">!   result = parse_each_vm_init_arg(java_tool_options_args, &amp;patch_mod_javabase, JVMFlag::ENVIRON_VAR);</span>
    if (result != JNI_OK) {
      return result;
    }
  
    // Parse args structure generated from the command line flags.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2356,13 ***</span>
          LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, load));
          LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, unload));
        } else if (!strcmp(tail, &quot;:gc&quot;)) {
          LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(gc));
        } else if (!strcmp(tail, &quot;:jni&quot;)) {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, PrintJNIResolving, true) != JVMFlag::SUCCESS) {</span>
<span class="line-removed">-           return JNI_EINVAL;</span>
<span class="line-removed">-         }</span>
        }
      // -da / -ea / -disableassertions / -enableassertions
      // These accept an optional class/package name separated by a colon, e.g.,
      // -da:java.lang.Thread.
      } else if (match_option(option, user_assertion_options, &amp;tail, true)) {
<span class="line-new-header">--- 2432,11 ---</span>
          LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, load));
          LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, unload));
        } else if (!strcmp(tail, &quot;:gc&quot;)) {
          LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(gc));
        } else if (!strcmp(tail, &quot;:jni&quot;)) {
<span class="line-modified">!         LogConfiguration::configure_stdout(LogLevel::Debug, true, LOG_TAGS(jni, resolve));</span>
        }
      // -da / -ea / -disableassertions / -enableassertions
      // These accept an optional class/package name separated by a colon, e.g.,
      // -da:java.lang.Thread.
      } else if (match_option(option, user_assertion_options, &amp;tail, true)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2499,28 ***</span>
      // --enable_preview
      } else if (match_option(option, &quot;--enable-preview&quot;)) {
        set_enable_preview();
      // -Xnoclassgc
      } else if (match_option(option, &quot;-Xnoclassgc&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, ClassUnloading, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-removed">-     // -Xconcgc</span>
<span class="line-removed">-     } else if (match_option(option, &quot;-Xconcgc&quot;)) {</span>
<span class="line-removed">-       if (FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, true) != JVMFlag::SUCCESS) {</span>
<span class="line-removed">-         return JNI_EINVAL;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       handle_extra_cms_flags(&quot;-Xconcgc uses UseConcMarkSweepGC&quot;);</span>
<span class="line-removed">-     // -Xnoconcgc</span>
<span class="line-removed">-     } else if (match_option(option, &quot;-Xnoconcgc&quot;)) {</span>
<span class="line-removed">-       if (FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, false) != JVMFlag::SUCCESS) {</span>
<span class="line-removed">-         return JNI_EINVAL;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       handle_extra_cms_flags(&quot;-Xnoconcgc uses UseConcMarkSweepGC&quot;);</span>
      // -Xbatch
      } else if (match_option(option, &quot;-Xbatch&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, BackgroundCompilation, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xmn for compatibility with other JVM vendors
      } else if (match_option(option, &quot;-Xmn&quot;, &amp;tail)) {
        julong long_initial_young_size = 0;
<span class="line-new-header">--- 2573,16 ---</span>
      // --enable_preview
      } else if (match_option(option, &quot;--enable-preview&quot;)) {
        set_enable_preview();
      // -Xnoclassgc
      } else if (match_option(option, &quot;-Xnoclassgc&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(ClassUnloading, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xbatch
      } else if (match_option(option, &quot;-Xbatch&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(BackgroundCompilation, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xmn for compatibility with other JVM vendors
      } else if (match_option(option, &quot;-Xmn&quot;, &amp;tail)) {
        julong long_initial_young_size = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2529,31 ***</span>
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Invalid initial young generation size: %s\n&quot;, option-&gt;optionString);
          describe_range_error(errcode);
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(size_t, MaxNewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(size_t, NewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xms
      } else if (match_option(option, &quot;-Xms&quot;, &amp;tail)) {
<span class="line-modified">!       julong long_initial_heap_size = 0;</span>
        // an initial heap size of 0 means automatically determine
<span class="line-modified">!       ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_heap_size, 0);</span>
        if (errcode != arg_in_range) {
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Invalid initial heap size: %s\n&quot;, option-&gt;optionString);
          describe_range_error(errcode);
          return JNI_EINVAL;
        }
<span class="line-modified">!       set_min_heap_size((size_t)long_initial_heap_size);</span>
<span class="line-modified">!       // Currently the minimum size and the initial heap sizes are the same.</span>
<span class="line-modified">!       // Can be overridden with -XX:InitialHeapSize.</span>
<span class="line-modified">!       if (FLAG_SET_CMDLINE(size_t, InitialHeapSize, (size_t)long_initial_heap_size) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xmx
      } else if (match_option(option, &quot;-Xmx&quot;, &amp;tail) || match_option(option, &quot;-XX:MaxHeapSize=&quot;, &amp;tail)) {
        julong long_max_heap_size = 0;
<span class="line-new-header">--- 2591,31 ---</span>
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Invalid initial young generation size: %s\n&quot;, option-&gt;optionString);
          describe_range_error(errcode);
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(MaxNewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(NewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xms
      } else if (match_option(option, &quot;-Xms&quot;, &amp;tail)) {
<span class="line-modified">!       julong size = 0;</span>
        // an initial heap size of 0 means automatically determine
<span class="line-modified">!       ArgsRange errcode = parse_memory_size(tail, &amp;size, 0);</span>
        if (errcode != arg_in_range) {
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Invalid initial heap size: %s\n&quot;, option-&gt;optionString);
          describe_range_error(errcode);
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(MinHeapSize, (size_t)size) != JVMFlag::SUCCESS) {</span>
<span class="line-modified">!         return JNI_EINVAL;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       if (FLAG_SET_CMDLINE(InitialHeapSize, (size_t)size) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xmx
      } else if (match_option(option, &quot;-Xmx&quot;, &amp;tail) || match_option(option, &quot;-XX:MaxHeapSize=&quot;, &amp;tail)) {
        julong long_max_heap_size = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2562,11 ***</span>
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Invalid maximum heap size: %s\n&quot;, option-&gt;optionString);
          describe_range_error(errcode);
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(size_t, MaxHeapSize, (size_t)long_max_heap_size) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // Xmaxf
      } else if (match_option(option, &quot;-Xmaxf&quot;, &amp;tail)) {
        char* err;
<span class="line-new-header">--- 2624,11 ---</span>
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Invalid maximum heap size: %s\n&quot;, option-&gt;optionString);
          describe_range_error(errcode);
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(MaxHeapSize, (size_t)long_max_heap_size) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // Xmaxf
      } else if (match_option(option, &quot;-Xmaxf&quot;, &amp;tail)) {
        char* err;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2575,11 ***</span>
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Bad max heap free percentage size: %s\n&quot;,
                      option-&gt;optionString);
          return JNI_EINVAL;
        } else {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(uintx, MaxHeapFreeRatio, maxf) != JVMFlag::SUCCESS) {</span>
              return JNI_EINVAL;
          }
        }
      // Xminf
      } else if (match_option(option, &quot;-Xminf&quot;, &amp;tail)) {
<span class="line-new-header">--- 2637,11 ---</span>
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Bad max heap free percentage size: %s\n&quot;,
                      option-&gt;optionString);
          return JNI_EINVAL;
        } else {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(MaxHeapFreeRatio, maxf) != JVMFlag::SUCCESS) {</span>
              return JNI_EINVAL;
          }
        }
      // Xminf
      } else if (match_option(option, &quot;-Xminf&quot;, &amp;tail)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2589,22 ***</span>
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Bad min heap free percentage size: %s\n&quot;,
                      option-&gt;optionString);
          return JNI_EINVAL;
        } else {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(uintx, MinHeapFreeRatio, minf) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
        }
      // -Xss
      } else if (match_option(option, &quot;-Xss&quot;, &amp;tail)) {
        intx value = 0;
        jint err = parse_xss(option, tail, &amp;value);
        if (err != JNI_OK) {
          return err;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(intx, ThreadStackSize, value) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      } else if (match_option(option, &quot;-Xmaxjitcodesize&quot;, &amp;tail) ||
                 match_option(option, &quot;-XX:ReservedCodeCacheSize=&quot;, &amp;tail)) {
        julong long_ReservedCodeCacheSize = 0;
<span class="line-new-header">--- 2651,22 ---</span>
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Bad min heap free percentage size: %s\n&quot;,
                      option-&gt;optionString);
          return JNI_EINVAL;
        } else {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(MinHeapFreeRatio, minf) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
        }
      // -Xss
      } else if (match_option(option, &quot;-Xss&quot;, &amp;tail)) {
        intx value = 0;
        jint err = parse_xss(option, tail, &amp;value);
        if (err != JNI_OK) {
          return err;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(ThreadStackSize, value) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      } else if (match_option(option, &quot;-Xmaxjitcodesize&quot;, &amp;tail) ||
                 match_option(option, &quot;-XX:ReservedCodeCacheSize=&quot;, &amp;tail)) {
        julong long_ReservedCodeCacheSize = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2613,11 ***</span>
        if (errcode != arg_in_range) {
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Invalid maximum code cache size: %s.\n&quot;, option-&gt;optionString);
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(uintx, ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -green
      } else if (match_option(option, &quot;-green&quot;)) {
        jio_fprintf(defaultStream::error_stream(),
<span class="line-new-header">--- 2675,11 ---</span>
        if (errcode != arg_in_range) {
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Invalid maximum code cache size: %s.\n&quot;, option-&gt;optionString);
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -green
      } else if (match_option(option, &quot;-green&quot;)) {
        jio_fprintf(defaultStream::error_stream(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2627,11 ***</span>
      } else if (match_option(option, &quot;-native&quot;)) {
            // HotSpot always uses native threads, ignore silently for compatibility
      // -Xrs
      } else if (match_option(option, &quot;-Xrs&quot;)) {
            // Classic/EVM option, new functionality
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, ReduceSignalUsage, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
        // -Xprof
      } else if (match_option(option, &quot;-Xprof&quot;)) {
        char version[256];
<span class="line-new-header">--- 2689,11 ---</span>
      } else if (match_option(option, &quot;-native&quot;)) {
            // HotSpot always uses native threads, ignore silently for compatibility
      // -Xrs
      } else if (match_option(option, &quot;-Xrs&quot;)) {
            // Classic/EVM option, new functionality
<span class="line-modified">!       if (FLAG_SET_CMDLINE(ReduceSignalUsage, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
        // -Xprof
      } else if (match_option(option, &quot;-Xprof&quot;)) {
        char version[256];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2672,18 ***</span>
        // &quot;-Djdk.module.addmods=java.sql&quot;
        if (is_internal_module_property(option-&gt;optionString + 2)) {
          needs_module_property_warning = true;
          continue;
        }
<span class="line-removed">- </span>
        if (!add_property(tail)) {
          return JNI_ENOMEM;
        }
        // Out of the box management support
        if (match_option(option, &quot;-Dcom.sun.management&quot;, &amp;tail)) {
  #if INCLUDE_MANAGEMENT
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, ManagementServer, true) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
          // management agent in module jdk.management.agent
          if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.management.agent&quot;, addmods_count++)) {
            return JNI_ENOMEM;
<span class="line-new-header">--- 2734,17 ---</span>
        // &quot;-Djdk.module.addmods=java.sql&quot;
        if (is_internal_module_property(option-&gt;optionString + 2)) {
          needs_module_property_warning = true;
          continue;
        }
        if (!add_property(tail)) {
          return JNI_ENOMEM;
        }
        // Out of the box management support
        if (match_option(option, &quot;-Dcom.sun.management&quot;, &amp;tail)) {
  #if INCLUDE_MANAGEMENT
<span class="line-modified">!         if (FLAG_SET_CMDLINE(ManagementServer, true) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
          // management agent in module jdk.management.agent
          if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.management.agent&quot;, addmods_count++)) {
            return JNI_ENOMEM;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2704,59 ***</span>
      } else if (match_option(option, &quot;-Xcomp&quot;)) {
        // for testing the compiler; turn off all flags that inhibit compilation
            set_mode_flags(_comp);
      // -Xshare:dump
      } else if (match_option(option, &quot;-Xshare:dump&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, DumpSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-removed">-       set_mode_flags(_int);     // Prevent compilation, which creates objects</span>
      // -Xshare:on
      } else if (match_option(option, &quot;-Xshare:on&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!     // -Xshare:auto</span>
      } else if (match_option(option, &quot;-Xshare:auto&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xshare:off
      } else if (match_option(option, &quot;-Xshare:off&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xverify
      } else if (match_option(option, &quot;-Xverify&quot;, &amp;tail)) {
        if (strcmp(tail, &quot;:all&quot;) == 0 || strcmp(tail, &quot;&quot;) == 0) {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, true) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
        } else if (strcmp(tail, &quot;:remote&quot;) == 0) {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
        } else if (strcmp(tail, &quot;:none&quot;) == 0) {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
          warning(&quot;Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.&quot;);
        } else if (is_bad_option(option, args-&gt;ignoreUnrecognized, &quot;verification&quot;)) {
          return JNI_EINVAL;
<span class="line-new-header">--- 2765,58 ---</span>
      } else if (match_option(option, &quot;-Xcomp&quot;)) {
        // for testing the compiler; turn off all flags that inhibit compilation
            set_mode_flags(_comp);
      // -Xshare:dump
      } else if (match_option(option, &quot;-Xshare:dump&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(DumpSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xshare:on
      } else if (match_option(option, &quot;-Xshare:on&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!     // -Xshare:auto || -XX:ArchiveClassesAtExit=&lt;archive file&gt;</span>
      } else if (match_option(option, &quot;-Xshare:auto&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(RequireSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xshare:off
      } else if (match_option(option, &quot;-Xshare:off&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(UseSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(RequireSharedSpaces, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      // -Xverify
      } else if (match_option(option, &quot;-Xverify&quot;, &amp;tail)) {
        if (strcmp(tail, &quot;:all&quot;) == 0 || strcmp(tail, &quot;&quot;) == 0) {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, true) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
<span class="line-modified">!         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
        } else if (strcmp(tail, &quot;:remote&quot;) == 0) {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
<span class="line-modified">!         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
        } else if (strcmp(tail, &quot;:none&quot;) == 0) {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
<span class="line-modified">!         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
          warning(&quot;Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.&quot;);
        } else if (is_bad_option(option, args-&gt;ignoreUnrecognized, &quot;verification&quot;)) {
          return JNI_EINVAL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2812,105 ***</span>
      } else if (match_option(option, &quot;abort&quot;)) {
        _abort_hook = CAST_TO_FN_PTR(abort_hook_t, option-&gt;extraInfo);
      // Need to keep consistency of MaxTenuringThreshold and AlwaysTenure/NeverTenure;
      // and the last option wins.
      } else if (match_option(option, &quot;-XX:+NeverTenure&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, NeverTenure, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, AlwaysTenure, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, markOopDesc::max_age + 1) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      } else if (match_option(option, &quot;-XX:+AlwaysTenure&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, NeverTenure, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, AlwaysTenure, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, 0) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      } else if (match_option(option, &quot;-XX:MaxTenuringThreshold=&quot;, &amp;tail)) {
        uintx max_tenuring_thresh = 0;
        if (!parse_uintx(tail, &amp;max_tenuring_thresh, 0)) {
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Improperly specified VM option \&#39;MaxTenuringThreshold=%s\&#39;\n&quot;, tail);
          return JNI_EINVAL;
        }
  
<span class="line-modified">!       if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, max_tenuring_thresh) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
  
        if (MaxTenuringThreshold == 0) {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, NeverTenure, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, AlwaysTenure, true) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
        } else {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, NeverTenure, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
<span class="line-modified">!         if (FLAG_SET_CMDLINE(bool, AlwaysTenure, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
        }
      } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStderr&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStdout&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      } else if (match_option(option, &quot;-XX:+ExtendedDTraceProbes&quot;)) {
  #if defined(DTRACE_ENABLED)
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, ExtendedDTraceProbes, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, DTraceMethodProbes, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, DTraceAllocProbes, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, DTraceMonitorProbes, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
  #else // defined(DTRACE_ENABLED)
        jio_fprintf(defaultStream::error_stream(),
                    &quot;ExtendedDTraceProbes flag is not applicable for this configuration\n&quot;);
        return JNI_EINVAL;
  #endif // defined(DTRACE_ENABLED)
  #ifdef ASSERT
      } else if (match_option(option, &quot;-XX:+FullGCALot&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, FullGCALot, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
        // disable scavenge before parallel mark-compact
<span class="line-modified">!       if (FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
  #endif
  #if !INCLUDE_MANAGEMENT
      } else if (match_option(option, &quot;-XX:+ManagementServer&quot;)) {
          jio_fprintf(defaultStream::error_stream(),
            &quot;ManagementServer is not supported in this VM.\n&quot;);
          return JNI_ERR;
  #endif // INCLUDE_MANAGEMENT
  #if INCLUDE_JFR
      } else if (match_jfr_option(&amp;option)) {
        return JNI_EINVAL;
  #endif
      } else if (match_option(option, &quot;-XX:&quot;, &amp;tail)) { // -XX:xxxx
<span class="line-new-header">--- 2872,141 ---</span>
      } else if (match_option(option, &quot;abort&quot;)) {
        _abort_hook = CAST_TO_FN_PTR(abort_hook_t, option-&gt;extraInfo);
      // Need to keep consistency of MaxTenuringThreshold and AlwaysTenure/NeverTenure;
      // and the last option wins.
      } else if (match_option(option, &quot;-XX:+NeverTenure&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(NeverTenure, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(AlwaysTenure, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, markWord::max_age + 1) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      } else if (match_option(option, &quot;-XX:+AlwaysTenure&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(AlwaysTenure, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, 0) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      } else if (match_option(option, &quot;-XX:MaxTenuringThreshold=&quot;, &amp;tail)) {
        uintx max_tenuring_thresh = 0;
        if (!parse_uintx(tail, &amp;max_tenuring_thresh, 0)) {
          jio_fprintf(defaultStream::error_stream(),
                      &quot;Improperly specified VM option \&#39;MaxTenuringThreshold=%s\&#39;\n&quot;, tail);
          return JNI_EINVAL;
        }
  
<span class="line-modified">!       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, max_tenuring_thresh) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
  
        if (MaxTenuringThreshold == 0) {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
<span class="line-modified">!         if (FLAG_SET_CMDLINE(AlwaysTenure, true) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
        } else {
<span class="line-modified">!         if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
<span class="line-modified">!         if (FLAG_SET_CMDLINE(AlwaysTenure, false) != JVMFlag::SUCCESS) {</span>
            return JNI_EINVAL;
          }
        }
      } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStderr&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(DisplayVMOutputToStdout, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(DisplayVMOutputToStderr, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStdout&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(DisplayVMOutputToStderr, false) != JVMFlag::SUCCESS) {</span>
<span class="line-added">+         return JNI_EINVAL;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (FLAG_SET_CMDLINE(DisplayVMOutputToStdout, true) != JVMFlag::SUCCESS) {</span>
<span class="line-added">+         return JNI_EINVAL;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else if (match_option(option, &quot;-XX:+ErrorFileToStderr&quot;)) {</span>
<span class="line-added">+       if (FLAG_SET_CMDLINE(ErrorFileToStdout, false) != JVMFlag::SUCCESS) {</span>
<span class="line-added">+         return JNI_EINVAL;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (FLAG_SET_CMDLINE(ErrorFileToStderr, true) != JVMFlag::SUCCESS) {</span>
<span class="line-added">+         return JNI_EINVAL;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else if (match_option(option, &quot;-XX:+ErrorFileToStdout&quot;)) {</span>
<span class="line-added">+       if (FLAG_SET_CMDLINE(ErrorFileToStderr, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(ErrorFileToStdout, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
      } else if (match_option(option, &quot;-XX:+ExtendedDTraceProbes&quot;)) {
  #if defined(DTRACE_ENABLED)
<span class="line-modified">!       if (FLAG_SET_CMDLINE(ExtendedDTraceProbes, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(DTraceMethodProbes, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(DTraceAllocProbes, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
<span class="line-modified">!       if (FLAG_SET_CMDLINE(DTraceMonitorProbes, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
  #else // defined(DTRACE_ENABLED)
        jio_fprintf(defaultStream::error_stream(),
                    &quot;ExtendedDTraceProbes flag is not applicable for this configuration\n&quot;);
        return JNI_EINVAL;
  #endif // defined(DTRACE_ENABLED)
  #ifdef ASSERT
      } else if (match_option(option, &quot;-XX:+FullGCALot&quot;)) {
<span class="line-modified">!       if (FLAG_SET_CMDLINE(FullGCALot, true) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
        // disable scavenge before parallel mark-compact
<span class="line-modified">!       if (FLAG_SET_CMDLINE(ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {</span>
          return JNI_EINVAL;
        }
  #endif
  #if !INCLUDE_MANAGEMENT
      } else if (match_option(option, &quot;-XX:+ManagementServer&quot;)) {
          jio_fprintf(defaultStream::error_stream(),
            &quot;ManagementServer is not supported in this VM.\n&quot;);
          return JNI_ERR;
  #endif // INCLUDE_MANAGEMENT
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+     } else if (match_option(option, &quot;-XX:-EnableJVMCIProduct&quot;)) {</span>
<span class="line-added">+       if (EnableJVMCIProduct) {</span>
<span class="line-added">+         jio_fprintf(defaultStream::error_stream(),</span>
<span class="line-added">+                   &quot;-XX:-EnableJVMCIProduct cannot come after -XX:+EnableJVMCIProduct\n&quot;);</span>
<span class="line-added">+         return JNI_EINVAL;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else if (match_option(option, &quot;-XX:+EnableJVMCIProduct&quot;)) {</span>
<span class="line-added">+       JVMFlag *jvmciFlag = JVMFlag::find_flag(&quot;EnableJVMCIProduct&quot;);</span>
<span class="line-added">+       // Allow this flag if it has been unlocked.</span>
<span class="line-added">+       if (jvmciFlag != NULL &amp;&amp; jvmciFlag-&gt;is_unlocked()) {</span>
<span class="line-added">+         if (!JVMCIGlobals::enable_jvmci_product_mode(origin)) {</span>
<span class="line-added">+           jio_fprintf(defaultStream::error_stream(),</span>
<span class="line-added">+             &quot;Unable to enable JVMCI in product mode&quot;);</span>
<span class="line-added">+           return JNI_ERR;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       // The flag was locked so process normally to report that error</span>
<span class="line-added">+       else if (!process_argument(&quot;EnableJVMCIProduct&quot;, args-&gt;ignoreUnrecognized, origin)) {</span>
<span class="line-added">+         return JNI_EINVAL;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ #endif // INCLUDE_JVMCI</span>
  #if INCLUDE_JFR
      } else if (match_jfr_option(&amp;option)) {
        return JNI_EINVAL;
  #endif
      } else if (match_option(option, &quot;-XX:&quot;, &amp;tail)) { // -XX:xxxx
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2930,27 ***</span>
  
    // PrintSharedArchiveAndExit will turn on
    //   -Xshare:on
    //   -Xlog:class+path=info
    if (PrintSharedArchiveAndExit) {
<span class="line-modified">!     if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
        return JNI_EINVAL;
      }
<span class="line-modified">!     if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
        return JNI_EINVAL;
      }
      LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, path));
    }
  
<span class="line-removed">-   // Change the default value for flags  which have different default values</span>
<span class="line-removed">-   // when working with older JDKs.</span>
<span class="line-removed">- #ifdef LINUX</span>
<span class="line-removed">-  if (JDK_Version::current().compare_major(6) &lt;= 0 &amp;&amp;</span>
<span class="line-removed">-       FLAG_IS_DEFAULT(UseLinuxPosixThreadCPUClocks)) {</span>
<span class="line-removed">-     FLAG_SET_DEFAULT(UseLinuxPosixThreadCPUClocks, false);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif // LINUX</span>
    fix_appclasspath();
  
    return JNI_OK;
  }
  
<span class="line-new-header">--- 3026,19 ---</span>
  
    // PrintSharedArchiveAndExit will turn on
    //   -Xshare:on
    //   -Xlog:class+path=info
    if (PrintSharedArchiveAndExit) {
<span class="line-modified">!     if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
        return JNI_EINVAL;
      }
<span class="line-modified">!     if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
        return JNI_EINVAL;
      }
      LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, path));
    }
  
    fix_appclasspath();
  
    return JNI_OK;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3066,11 ***</span>
      set_mode_flags(_int);
    }
  
    // eventually fix up InitialTenuringThreshold if only MaxTenuringThreshold is set
    if (FLAG_IS_DEFAULT(InitialTenuringThreshold) &amp;&amp; (InitialTenuringThreshold &gt; MaxTenuringThreshold)) {
<span class="line-modified">!     FLAG_SET_ERGO(uintx, InitialTenuringThreshold, MaxTenuringThreshold);</span>
    }
  
  #if !COMPILER2_OR_JVMCI
    // Don&#39;t degrade server performance for footprint
    if (FLAG_IS_DEFAULT(UseLargePages) &amp;&amp;
<span class="line-new-header">--- 3154,11 ---</span>
      set_mode_flags(_int);
    }
  
    // eventually fix up InitialTenuringThreshold if only MaxTenuringThreshold is set
    if (FLAG_IS_DEFAULT(InitialTenuringThreshold) &amp;&amp; (InitialTenuringThreshold &gt; MaxTenuringThreshold)) {
<span class="line-modified">!     FLAG_SET_ERGO(InitialTenuringThreshold, MaxTenuringThreshold);</span>
    }
  
  #if !COMPILER2_OR_JVMCI
    // Don&#39;t degrade server performance for footprint
    if (FLAG_IS_DEFAULT(UseLargePages) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3083,11 ***</span>
  
    UNSUPPORTED_OPTION(ProfileInterpreter);
    NOT_PRODUCT(UNSUPPORTED_OPTION(TraceProfileInterpreter));
  #endif
  
<span class="line-modified">! #ifndef TIERED</span>
    // Tiered compilation is undefined.
    UNSUPPORTED_OPTION(TieredCompilation);
  #endif
  
    if (!check_vm_args_consistency()) {
<span class="line-new-header">--- 3171,17 ---</span>
  
    UNSUPPORTED_OPTION(ProfileInterpreter);
    NOT_PRODUCT(UNSUPPORTED_OPTION(TraceProfileInterpreter));
  #endif
  
<span class="line-modified">! </span>
<span class="line-added">+ #ifdef TIERED</span>
<span class="line-added">+   // Parse the CompilationMode flag</span>
<span class="line-added">+   if (!CompilationModeFlag::initialize()) {</span>
<span class="line-added">+     return JNI_ERR;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #else</span>
    // Tiered compilation is undefined.
    UNSUPPORTED_OPTION(TieredCompilation);
  #endif
  
    if (!check_vm_args_consistency()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3098,19 ***</span>
    if (DumpSharedSpaces) {
      // Disable biased locking now as it interferes with the clean up of
      // the archived Klasses and Java string objects (at dump time only).
      UseBiasedLocking = false;
  
      // Always verify non-system classes during CDS dump
      if (!BytecodeVerificationRemote) {
        BytecodeVerificationRemote = true;
        log_info(cds)(&quot;All non-system classes will be verified (-Xverify:remote) during CDS dump time.&quot;);
      }
<span class="line-modified">! </span>
<span class="line-modified">!     // Compilation is already disabled if the user specifies -Xshare:dump.</span>
<span class="line-modified">!     // Disable compilation in case user specifies -XX:+DumpSharedSpaces instead of -Xshare:dump.</span>
<span class="line-removed">-     set_mode_flags(_int);</span>
    }
    if (UseSharedSpaces &amp;&amp; patch_mod_javabase) {
      no_shared_spaces(&quot;CDS is disabled when &quot; JAVA_BASE_NAME &quot; module is patched.&quot;);
    }
    if (UseSharedSpaces &amp;&amp; !DumpSharedSpaces &amp;&amp; check_unsupported_cds_runtime_properties()) {
<span class="line-new-header">--- 3192,28 ---</span>
    if (DumpSharedSpaces) {
      // Disable biased locking now as it interferes with the clean up of
      // the archived Klasses and Java string objects (at dump time only).
      UseBiasedLocking = false;
  
<span class="line-added">+     // Compiler threads may concurrently update the class metadata (such as method entries), so it&#39;s</span>
<span class="line-added">+     // unsafe with DumpSharedSpaces (which modifies the class metadata in place). Let&#39;s disable</span>
<span class="line-added">+     // compiler just to be safe.</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // Note: this is not a concern for DynamicDumpSharedSpaces, which makes a copy of the class metadata</span>
<span class="line-added">+     // instead of modifying them in place. The copy is inaccessible to the compiler.</span>
<span class="line-added">+     // TODO: revisit the following for the static archive case.</span>
<span class="line-added">+     set_mode_flags(_int);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (DumpSharedSpaces || ArchiveClassesAtExit != NULL) {</span>
      // Always verify non-system classes during CDS dump
      if (!BytecodeVerificationRemote) {
        BytecodeVerificationRemote = true;
        log_info(cds)(&quot;All non-system classes will be verified (-Xverify:remote) during CDS dump time.&quot;);
      }
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (ArchiveClassesAtExit == NULL) {</span>
<span class="line-modified">!     FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, false);</span>
    }
    if (UseSharedSpaces &amp;&amp; patch_mod_javabase) {
      no_shared_spaces(&quot;CDS is disabled when &quot; JAVA_BASE_NAME &quot; module is patched.&quot;);
    }
    if (UseSharedSpaces &amp;&amp; !DumpSharedSpaces &amp;&amp; check_unsupported_cds_runtime_properties()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3390,35 ***</span>
    return status;
  }
  
  void Arguments::set_shared_spaces_flags() {
    if (DumpSharedSpaces) {
<span class="line-removed">-     if (FailOverToOldVerifier) {</span>
<span class="line-removed">-       // Don&#39;t fall back to the old verifier on verification failure. If a</span>
<span class="line-removed">-       // class fails verification with the split verifier, it might fail the</span>
<span class="line-removed">-       // CDS runtime verifier constraint check. In that case, we don&#39;t want</span>
<span class="line-removed">-       // to share the class. We only archive classes that pass the split verifier.</span>
<span class="line-removed">-       FLAG_SET_DEFAULT(FailOverToOldVerifier, false);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      if (RequireSharedSpaces) {
        warning(&quot;Cannot dump shared archive while using shared archive&quot;);
      }
      UseSharedSpaces = false;
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">-     if (!UseCompressedOops || !UseCompressedClassPointers) {</span>
<span class="line-removed">-       vm_exit_during_initialization(</span>
<span class="line-removed">-         &quot;Cannot dump shared archive when UseCompressedOops or UseCompressedClassPointers is off.&quot;, NULL);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     if (!UseCompressedOops || !UseCompressedClassPointers) {</span>
<span class="line-removed">-       no_shared_spaces(&quot;UseCompressedOops and UseCompressedClassPointers must be on for UseSharedSpaces.&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
    }
  }
  
  // Sharing support
  // Construct the path to the archive
  char* Arguments::get_default_shared_archive_path() {
    char *default_archive_path;
    char jvm_path[JVM_MAXPATHLEN];
<span class="line-new-header">--- 3493,18 ---</span>
    return status;
  }
  
  void Arguments::set_shared_spaces_flags() {
    if (DumpSharedSpaces) {
      if (RequireSharedSpaces) {
        warning(&quot;Cannot dump shared archive while using shared archive&quot;);
      }
      UseSharedSpaces = false;
    }
  }
  
<span class="line-added">+ #if INCLUDE_CDS</span>
  // Sharing support
  // Construct the path to the archive
  char* Arguments::get_default_shared_archive_path() {
    char *default_archive_path;
    char jvm_path[JVM_MAXPATHLEN];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3427,26 ***</span>
    if (end != NULL) *end = &#39;\0&#39;;
    size_t jvm_path_len = strlen(jvm_path);
    size_t file_sep_len = strlen(os::file_separator());
    const size_t len = jvm_path_len + file_sep_len + 20;
    default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);
<span class="line-modified">!   if (default_archive_path != NULL) {</span>
<span class="line-modified">!     jio_snprintf(default_archive_path, len, &quot;%s%sclasses.jsa&quot;,</span>
<span class="line-removed">-       jvm_path, os::file_separator());</span>
<span class="line-removed">-   }</span>
    return default_archive_path;
  }
  
<span class="line-modified">! static char* get_shared_archive_path() {</span>
<span class="line-modified">!   char *shared_archive_path;</span>
    if (SharedArchiveFile == NULL) {
<span class="line-modified">!     shared_archive_path = Arguments::get_default_shared_archive_path();</span>
    } else {
<span class="line-modified">!     shared_archive_path = os::strdup_check_oom(SharedArchiveFile, mtArguments);</span>
    }
<span class="line-modified">!   return shared_archive_path;</span>
  }
  
  #ifndef PRODUCT
  // Determine whether LogVMOutput should be implicitly turned on.
  static bool use_vm_log() {
    if (LogCompilation || !FLAG_IS_DEFAULT(LogFile) ||
<span class="line-new-header">--- 3513,113 ---</span>
    if (end != NULL) *end = &#39;\0&#39;;
    size_t jvm_path_len = strlen(jvm_path);
    size_t file_sep_len = strlen(os::file_separator());
    const size_t len = jvm_path_len + file_sep_len + 20;
    default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);
<span class="line-modified">!   jio_snprintf(default_archive_path, len, &quot;%s%sclasses.jsa&quot;,</span>
<span class="line-modified">!                jvm_path, os::file_separator());</span>
    return default_archive_path;
  }
  
<span class="line-modified">! int Arguments::num_archives(const char* archive_path) {</span>
<span class="line-modified">!   if (archive_path == NULL) {</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   int npaths = 1;</span>
<span class="line-added">+   char* p = (char*)archive_path;</span>
<span class="line-added">+   while (*p != &#39;\0&#39;) {</span>
<span class="line-added">+     if (*p == os::path_separator()[0]) {</span>
<span class="line-added">+       npaths++;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     p++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return npaths;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Arguments::extract_shared_archive_paths(const char* archive_path,</span>
<span class="line-added">+                                          char** base_archive_path,</span>
<span class="line-added">+                                          char** top_archive_path) {</span>
<span class="line-added">+   char* begin_ptr = (char*)archive_path;</span>
<span class="line-added">+   char* end_ptr = strchr((char*)archive_path, os::path_separator()[0]);</span>
<span class="line-added">+   if (end_ptr == NULL || end_ptr == begin_ptr) {</span>
<span class="line-added">+     vm_exit_during_initialization(&quot;Base archive was not specified&quot;, archive_path);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   size_t len = end_ptr - begin_ptr;</span>
<span class="line-added">+   char* cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);</span>
<span class="line-added">+   strncpy(cur_path, begin_ptr, len);</span>
<span class="line-added">+   cur_path[len] = &#39;\0&#39;;</span>
<span class="line-added">+   FileMapInfo::check_archive((const char*)cur_path, true /*is_static*/);</span>
<span class="line-added">+   *base_archive_path = cur_path;</span>
<span class="line-added">+ </span>
<span class="line-added">+   begin_ptr = ++end_ptr;</span>
<span class="line-added">+   if (*begin_ptr == &#39;\0&#39;) {</span>
<span class="line-added">+     vm_exit_during_initialization(&quot;Top archive was not specified&quot;, archive_path);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   end_ptr = strchr(begin_ptr, &#39;\0&#39;);</span>
<span class="line-added">+   assert(end_ptr != NULL, &quot;sanity&quot;);</span>
<span class="line-added">+   len = end_ptr - begin_ptr;</span>
<span class="line-added">+   cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);</span>
<span class="line-added">+   strncpy(cur_path, begin_ptr, len + 1);</span>
<span class="line-added">+   //cur_path[len] = &#39;\0&#39;;</span>
<span class="line-added">+   FileMapInfo::check_archive((const char*)cur_path, false /*is_static*/);</span>
<span class="line-added">+   *top_archive_path = cur_path;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Arguments::init_shared_archive_paths() {</span>
<span class="line-added">+   if (ArchiveClassesAtExit != NULL) {</span>
<span class="line-added">+     if (DumpSharedSpaces) {</span>
<span class="line-added">+       vm_exit_during_initialization(&quot;-XX:ArchiveClassesAtExit cannot be used with -Xshare:dump&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (FLAG_SET_CMDLINE(DynamicDumpSharedSpaces, true) != JVMFlag::SUCCESS) {</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     check_unsupported_dumping_properties();</span>
<span class="line-added">+     SharedDynamicArchivePath = os::strdup_check_oom(ArchiveClassesAtExit, mtArguments);</span>
<span class="line-added">+   }</span>
    if (SharedArchiveFile == NULL) {
<span class="line-modified">!     SharedArchivePath = get_default_shared_archive_path();</span>
    } else {
<span class="line-modified">!     int archives = num_archives(SharedArchiveFile);</span>
<span class="line-added">+     if (is_dumping_archive()) {</span>
<span class="line-added">+       if (archives &gt; 1) {</span>
<span class="line-added">+         vm_exit_during_initialization(</span>
<span class="line-added">+           &quot;Cannot have more than 1 archive file specified in -XX:SharedArchiveFile during CDS dumping&quot;);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">+         if (os::same_files(SharedArchiveFile, ArchiveClassesAtExit)) {</span>
<span class="line-added">+           vm_exit_during_initialization(</span>
<span class="line-added">+             &quot;Cannot have the same archive file specified for -XX:SharedArchiveFile and -XX:ArchiveClassesAtExit&quot;,</span>
<span class="line-added">+             SharedArchiveFile);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (!is_dumping_archive()){</span>
<span class="line-added">+       if (archives &gt; 2) {</span>
<span class="line-added">+         vm_exit_during_initialization(</span>
<span class="line-added">+           &quot;Cannot have more than 2 archive files specified in the -XX:SharedArchiveFile option&quot;);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (archives == 1) {</span>
<span class="line-added">+         char* temp_archive_path = os::strdup_check_oom(SharedArchiveFile, mtArguments);</span>
<span class="line-added">+         int name_size;</span>
<span class="line-added">+         bool success =</span>
<span class="line-added">+           FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &amp;name_size, &amp;SharedArchivePath);</span>
<span class="line-added">+         if (!success) {</span>
<span class="line-added">+           SharedArchivePath = temp_archive_path;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           SharedDynamicArchivePath = temp_archive_path;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         extract_shared_archive_paths((const char*)SharedArchiveFile,</span>
<span class="line-added">+                                       &amp;SharedArchivePath, &amp;SharedDynamicArchivePath);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else { // CDS dumping</span>
<span class="line-added">+       SharedArchivePath = os::strdup_check_oom(SharedArchiveFile, mtArguments);</span>
<span class="line-added">+     }</span>
    }
<span class="line-modified">!   return (SharedArchivePath != NULL);</span>
  }
<span class="line-added">+ #endif // INCLUDE_CDS</span>
  
  #ifndef PRODUCT
  // Determine whether LogVMOutput should be implicitly turned on.
  static bool use_vm_log() {
    if (LogCompilation || !FLAG_IS_DEFAULT(LogFile) ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3660,43 ***</span>
      LogConfiguration::configure_stdout(LogLevel::Info, !PrintGCDetails, LOG_TAGS(gc));
    }
    return true;
  }
  
<span class="line-removed">- void Arguments::handle_extra_cms_flags(const char* msg) {</span>
<span class="line-removed">-   SpecialFlag flag;</span>
<span class="line-removed">-   const char *flag_name = &quot;UseConcMarkSweepGC&quot;;</span>
<span class="line-removed">-   if (lookup_special_flag(flag_name, flag)) {</span>
<span class="line-removed">-     handle_aliases_and_deprecation(flag_name, /* print warning */ true);</span>
<span class="line-removed">-     warning(&quot;%s&quot;, msg);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Parse entry point called from JNI_CreateJavaVM
  
  jint Arguments::parse(const JavaVMInitArgs* initial_cmd_args) {
<span class="line-modified">!   assert(verify_special_jvm_flags(), &quot;deprecated and obsolete flag table inconsistent&quot;);</span>
  
<span class="line-modified">!   // Initialize ranges, constraints and writeables</span>
    JVMFlagRangeList::init();
    JVMFlagConstraintList::init();
<span class="line-removed">-   JVMFlagWriteableList::init();</span>
  
    // If flag &quot;-XX:Flags=flags-file&quot; is used it will be the first option to be processed.
    const char* hotspotrc = &quot;.hotspotrc&quot;;
    bool settings_file_specified = false;
    bool needs_hotspotrc_warning = false;
    ScopedVMInitArgs initial_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
    ScopedVMInitArgs initial_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
  
    // Pointers to current working set of containers
    JavaVMInitArgs* cur_cmd_args;
    JavaVMInitArgs* cur_java_options_args;
    JavaVMInitArgs* cur_java_tool_options_args;
  
    // Containers for modified/expanded options
    ScopedVMInitArgs mod_cmd_args(&quot;cmd_line_args&quot;);
    ScopedVMInitArgs mod_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
    ScopedVMInitArgs mod_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
  
  
    jint code =
<span class="line-new-header">--- 3833,36 ---</span>
      LogConfiguration::configure_stdout(LogLevel::Info, !PrintGCDetails, LOG_TAGS(gc));
    }
    return true;
  }
  
  // Parse entry point called from JNI_CreateJavaVM
  
  jint Arguments::parse(const JavaVMInitArgs* initial_cmd_args) {
<span class="line-modified">!   assert(verify_special_jvm_flags(false), &quot;deprecated and obsolete flag table inconsistent&quot;);</span>
  
<span class="line-modified">!   // Initialize ranges and constraints</span>
    JVMFlagRangeList::init();
    JVMFlagConstraintList::init();
  
    // If flag &quot;-XX:Flags=flags-file&quot; is used it will be the first option to be processed.
    const char* hotspotrc = &quot;.hotspotrc&quot;;
    bool settings_file_specified = false;
    bool needs_hotspotrc_warning = false;
<span class="line-added">+   ScopedVMInitArgs initial_vm_options_args(&quot;&quot;);</span>
    ScopedVMInitArgs initial_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
    ScopedVMInitArgs initial_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
  
    // Pointers to current working set of containers
    JavaVMInitArgs* cur_cmd_args;
<span class="line-added">+   JavaVMInitArgs* cur_vm_options_args;</span>
    JavaVMInitArgs* cur_java_options_args;
    JavaVMInitArgs* cur_java_tool_options_args;
  
    // Containers for modified/expanded options
    ScopedVMInitArgs mod_cmd_args(&quot;cmd_line_args&quot;);
<span class="line-added">+   ScopedVMInitArgs mod_vm_options_args(&quot;vm_options_args&quot;);</span>
    ScopedVMInitArgs mod_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
    ScopedVMInitArgs mod_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
  
  
    jint code =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3708,10 ***</span>
<span class="line-new-header">--- 3874,20 ---</span>
    code = parse_java_options_environment_variable(&amp;initial_java_options_args);
    if (code != JNI_OK) {
      return code;
    }
  
<span class="line-added">+   // Parse the options in the /java.base/jdk/internal/vm/options resource, if present</span>
<span class="line-added">+   char *vmoptions = ClassLoader::lookup_vm_options();</span>
<span class="line-added">+   if (vmoptions != NULL) {</span>
<span class="line-added">+     code = parse_options_buffer(&quot;vm options resource&quot;, vmoptions, strlen(vmoptions), &amp;initial_vm_options_args);</span>
<span class="line-added">+     FREE_C_HEAP_ARRAY(char, vmoptions);</span>
<span class="line-added">+     if (code != JNI_OK) {</span>
<span class="line-added">+       return code;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    code = expand_vm_options_as_needed(initial_java_tool_options_args.get(),
                                       &amp;mod_java_tool_options_args,
                                       &amp;cur_java_tool_options_args);
    if (code != JNI_OK) {
      return code;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3729,10 ***</span>
<span class="line-new-header">--- 3905,17 ---</span>
                                       &amp;cur_java_options_args);
    if (code != JNI_OK) {
      return code;
    }
  
<span class="line-added">+   code = expand_vm_options_as_needed(initial_vm_options_args.get(),</span>
<span class="line-added">+                                      &amp;mod_vm_options_args,</span>
<span class="line-added">+                                      &amp;cur_vm_options_args);</span>
<span class="line-added">+   if (code != JNI_OK) {</span>
<span class="line-added">+     return code;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    const char* flags_file = Arguments::get_jvm_flags_file();
    settings_file_specified = (flags_file != NULL);
  
    if (IgnoreUnrecognizedVMOptions) {
      cur_cmd_args-&gt;ignoreUnrecognized = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3766,28 ***</span>
      print_options(cur_cmd_args);
      print_options(cur_java_options_args);
    }
  
    // Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS
<span class="line-modified">!   jint result = parse_vm_init_args(cur_java_tool_options_args,</span>
                                     cur_java_options_args,
                                     cur_cmd_args);
  
    if (result != JNI_OK) {
      return result;
    }
  
<span class="line-modified">!   // Call get_shared_archive_path() here, after possible SharedArchiveFile option got parsed.</span>
<span class="line-modified">!   SharedArchivePath = get_shared_archive_path();</span>
<span class="line-modified">!   if (SharedArchivePath == NULL) {</span>
      return JNI_ENOMEM;
    }
<span class="line-modified">! </span>
<span class="line-removed">-   // Set up VerifySharedSpaces</span>
<span class="line-removed">-   if (FLAG_IS_DEFAULT(VerifySharedSpaces) &amp;&amp; SharedArchiveFile != NULL) {</span>
<span class="line-removed">-     VerifySharedSpaces = true;</span>
<span class="line-removed">-   }</span>
  
    // Delay warning until here so that we&#39;ve had a chance to process
    // the -XX:-PrintWarnings flag
    if (needs_hotspotrc_warning) {
      warning(&quot;%s file is present but has been ignored.  &quot;
<span class="line-new-header">--- 3949,25 ---</span>
      print_options(cur_cmd_args);
      print_options(cur_java_options_args);
    }
  
    // Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS
<span class="line-modified">!   jint result = parse_vm_init_args(cur_vm_options_args,</span>
<span class="line-added">+                                    cur_java_tool_options_args,</span>
                                     cur_java_options_args,
                                     cur_cmd_args);
  
    if (result != JNI_OK) {
      return result;
    }
  
<span class="line-modified">! #if INCLUDE_CDS</span>
<span class="line-modified">!   // Initialize shared archive paths which could include both base and dynamic archive paths</span>
<span class="line-modified">!   if (!init_shared_archive_paths()) {</span>
      return JNI_ENOMEM;
    }
<span class="line-modified">! #endif</span>
  
    // Delay warning until here so that we&#39;ve had a chance to process
    // the -XX:-PrintWarnings flag
    if (needs_hotspotrc_warning) {
      warning(&quot;%s file is present but has been ignored.  &quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3839,27 ***</span>
    if (DumpSharedSpaces || RequireSharedSpaces) {
      jio_fprintf(defaultStream::error_stream(),
        &quot;Shared spaces are not supported in this VM\n&quot;);
      return JNI_ERR;
    }
    if ((UseSharedSpaces &amp;&amp; FLAG_IS_CMDLINE(UseSharedSpaces)) ||
        log_is_enabled(Info, cds)) {
      warning(&quot;Shared spaces are not supported in this VM&quot;);
      FLAG_SET_DEFAULT(UseSharedSpaces, false);
      LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(cds));
    }
    no_shared_spaces(&quot;CDS Disabled&quot;);
  #endif // INCLUDE_CDS
  
    TSAN_RUNTIME_ONLY(
      // Currently TSAN is only implemented for interpreter.
      set_mode_flags(_int);
      // TSAN instrumentation is not implemented for the RewriteBytecodes
      // code paths because TSAN slows down the application so much that the
      // performance benefits from rewriting bytecodes is negligible.
<span class="line-modified">!     FLAG_SET_ERGO(bool, RewriteBytecodes, false);</span>
<span class="line-modified">!     FLAG_SET_ERGO(bool, RewriteFrequentPairs, false);</span>
      // Turn off CDS, it interferes with eagerly allocating jmethodIDs.
      no_shared_spaces(&quot;CDS is not compatible with TSAN&quot;);
    );
  
    return JNI_OK;
<span class="line-new-header">--- 4019,38 ---</span>
    if (DumpSharedSpaces || RequireSharedSpaces) {
      jio_fprintf(defaultStream::error_stream(),
        &quot;Shared spaces are not supported in this VM\n&quot;);
      return JNI_ERR;
    }
<span class="line-added">+   if (DumpLoadedClassList != NULL) {</span>
<span class="line-added">+     jio_fprintf(defaultStream::error_stream(),</span>
<span class="line-added">+       &quot;DumpLoadedClassList is not supported in this VM\n&quot;);</span>
<span class="line-added">+     return JNI_ERR;</span>
<span class="line-added">+   }</span>
    if ((UseSharedSpaces &amp;&amp; FLAG_IS_CMDLINE(UseSharedSpaces)) ||
        log_is_enabled(Info, cds)) {
      warning(&quot;Shared spaces are not supported in this VM&quot;);
      FLAG_SET_DEFAULT(UseSharedSpaces, false);
      LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(cds));
    }
    no_shared_spaces(&quot;CDS Disabled&quot;);
  #endif // INCLUDE_CDS
  
<span class="line-added">+ #ifndef TIERED</span>
<span class="line-added">+   if (FLAG_IS_CMDLINE(CompilationMode)) {</span>
<span class="line-added">+     warning(&quot;CompilationMode has no effect in non-tiered VMs&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
    TSAN_RUNTIME_ONLY(
      // Currently TSAN is only implemented for interpreter.
      set_mode_flags(_int);
      // TSAN instrumentation is not implemented for the RewriteBytecodes
      // code paths because TSAN slows down the application so much that the
      // performance benefits from rewriting bytecodes is negligible.
<span class="line-modified">!     FLAG_SET_ERGO(RewriteBytecodes, false);</span>
<span class="line-modified">!     FLAG_SET_ERGO(RewriteFrequentPairs, false);</span>
      // Turn off CDS, it interferes with eagerly allocating jmethodIDs.
      no_shared_spaces(&quot;CDS is not compatible with TSAN&quot;);
    );
  
    return JNI_OK;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3960,46 ***</span>
    if (!UseBiasedLocking) {
      UseOptoBiasInlining = false;
    }
  #endif
  
<span class="line-removed">- #if defined(IA32)</span>
<span class="line-removed">-   // Only server compiler can optimize safepoints well enough.</span>
<span class="line-removed">-   if (!is_server_compilation_mode_vm()) {</span>
<span class="line-removed">-     FLAG_SET_ERGO_IF_DEFAULT(bool, ThreadLocalHandshakes, false);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // ThreadLocalHandshakesConstraintFunc handles the constraints.</span>
<span class="line-removed">-   if (FLAG_IS_DEFAULT(ThreadLocalHandshakes) || !SafepointMechanism::supports_thread_local_poll()) {</span>
<span class="line-removed">-     log_debug(ergo)(&quot;ThreadLocalHandshakes %s&quot;, ThreadLocalHandshakes ? &quot;enabled.&quot; : &quot;disabled.&quot;);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     log_info(ergo)(&quot;ThreadLocalHandshakes %s&quot;, ThreadLocalHandshakes ? &quot;enabled.&quot; : &quot;disabled.&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    return JNI_OK;
  }
  
  jint Arguments::adjust_after_os() {
    if (UseNUMA) {
<span class="line-modified">!     if (!FLAG_IS_DEFAULT(AllocateHeapAt)) {</span>
<span class="line-removed">-       FLAG_SET_ERGO(bool, UseNUMA, false);</span>
<span class="line-removed">-     } else if (UseParallelGC || UseParallelOldGC) {</span>
        if (FLAG_IS_DEFAULT(MinHeapDeltaBytes)) {
           FLAG_SET_DEFAULT(MinHeapDeltaBytes, 64*M);
        }
      }
<span class="line-modified">!     // UseNUMAInterleaving is set to ON for all collectors and</span>
<span class="line-modified">!     // platforms when UseNUMA is set to ON. NUMA-aware collectors</span>
<span class="line-modified">!     // such as the parallel collector for Linux and Solaris will</span>
<span class="line-modified">!     // interleave old gen and survivor spaces on top of NUMA</span>
<span class="line-modified">!     // allocation policy for the eden space.</span>
<span class="line-removed">-     // Non NUMA-aware collectors such as CMS, G1 and Serial-GC on</span>
<span class="line-removed">-     // all platforms and ParallelGC on Windows will interleave all</span>
<span class="line-removed">-     // of the heap spaces across NUMA nodes.</span>
      if (FLAG_IS_DEFAULT(UseNUMAInterleaving)) {
<span class="line-modified">!       FLAG_SET_ERGO(bool, UseNUMAInterleaving, true);</span>
      }
    }
    return JNI_OK;
  }
  
<span class="line-new-header">--- 4151,27 ---</span>
    if (!UseBiasedLocking) {
      UseOptoBiasInlining = false;
    }
  #endif
  
    return JNI_OK;
  }
  
  jint Arguments::adjust_after_os() {
    if (UseNUMA) {
<span class="line-modified">!     if (UseParallelGC) {</span>
        if (FLAG_IS_DEFAULT(MinHeapDeltaBytes)) {
           FLAG_SET_DEFAULT(MinHeapDeltaBytes, 64*M);
        }
      }
<span class="line-modified">!     // UseNUMAInterleaving is set to ON for all collectors and platforms when</span>
<span class="line-modified">!     // UseNUMA is set to ON. NUMA-aware collectors will interleave old gen and</span>
<span class="line-modified">!     // survivor spaces on top of NUMA allocation policy for the eden space.</span>
<span class="line-modified">!     // Non NUMA-aware collectors will interleave all of the heap spaces across</span>
<span class="line-modified">!     // NUMA nodes.</span>
      if (FLAG_IS_DEFAULT(UseNUMAInterleaving)) {
<span class="line-modified">!       FLAG_SET_ERGO(UseNUMAInterleaving, true);</span>
      }
    }
    return JNI_OK;
  }
  
</pre>
<center><a href="../prims/whitebox.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arguments.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
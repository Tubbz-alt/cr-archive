diff a/src/hotspot/share/runtime/interfaceSupport.cpp b/src/hotspot/share/runtime/interfaceSupport.cpp
--- a/src/hotspot/share/runtime/interfaceSupport.cpp
+++ b/src/hotspot/share/runtime/interfaceSupport.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,16 +25,16 @@
 #include "precompiled.hpp"
 #include "gc/shared/collectedHeap.hpp"
 #include "gc/shared/collectedHeap.inline.hpp"
 #include "logging/log.hpp"
 #include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/init.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
-#include "runtime/orderAccess.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/safepointVerifiers.hpp"
 #include "runtime/vframe.hpp"
 #include "runtime/vmThread.hpp"
@@ -52,16 +52,10 @@
 VMEntryWrapper::~VMEntryWrapper() {
   InterfaceSupport::check_gc_alot();
   if (WalkStackALot) {
     InterfaceSupport::walk_stack();
   }
-#ifdef COMPILER2
-  // This option is not used by Compiler 1
-  if (StressDerivedPointers) {
-    InterfaceSupport::stress_derived_pointers();
-  }
-#endif
   if (DeoptimizeALot || DeoptimizeRandom) {
     InterfaceSupport::deoptimizeAll();
   }
   if (ZombieALot) {
     InterfaceSupport::zombieAll();
@@ -70,10 +64,18 @@
   if (VerifyStack) {
     InterfaceSupport::verify_stack();
   }
 }
 
+VMNativeEntryWrapper::VMNativeEntryWrapper() {
+  if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();
+}
+
+VMNativeEntryWrapper::~VMNativeEntryWrapper() {
+  if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();
+}
+
 long InterfaceSupport::_number_of_calls       = 0;
 long InterfaceSupport::_scavenge_alot_counter = 1;
 long InterfaceSupport::_fullgc_alot_counter   = 1;
 long InterfaceSupport::_fullgc_alot_invocation = 0;
 
@@ -82,12 +84,12 @@
 RuntimeHistogramElement::RuntimeHistogramElement(const char* elementName) {
   static volatile int RuntimeHistogram_lock = 0;
   _name = elementName;
   uintx count = 0;
 
-  while (Atomic::cmpxchg(1, &RuntimeHistogram_lock, 0) != 0) {
-    while (OrderAccess::load_acquire(&RuntimeHistogram_lock) != 0) {
+  while (Atomic::cmpxchg(&RuntimeHistogram_lock, 0, 1) != 0) {
+    while (Atomic::load_acquire(&RuntimeHistogram_lock) != 0) {
       count +=1;
       if ( (WarnOnStalledSpinLock > 0)
         && (count % WarnOnStalledSpinLock == 0)) {
         warning("RuntimeHistogram_lock seems to be stalled");
       }
@@ -223,35 +225,10 @@
   }
   deoptimizeAllCounter++;
 }
 
 
-void InterfaceSupport::stress_derived_pointers() {
-#ifdef COMPILER2
-  JavaThread *thread = JavaThread::current();
-  if (!is_init_completed()) return;
-  ResourceMark rm(thread);
-  bool found = false;
-  for (StackFrameStream sfs(thread); !sfs.is_done() && !found; sfs.next()) {
-    CodeBlob* cb = sfs.current()->cb();
-    if (cb != NULL && cb->oop_maps() ) {
-      // Find oopmap for current method
-      const ImmutableOopMap* map = cb->oop_map_for_return_address(sfs.current()->pc());
-      assert(map != NULL, "no oopmap found for pc");
-      found = map->has_derived_pointer();
-    }
-  }
-  if (found) {
-    // $$$ Not sure what to do here.
-    /*
-    Scavenge::invoke(0);
-    */
-  }
-#endif
-}
-
-
 void InterfaceSupport::verify_stack() {
   JavaThread* thread = JavaThread::current();
   ResourceMark rm(thread);
   // disabled because it throws warnings that oop maps should only be accessed
   // in VM thread or during debugging
@@ -289,42 +266,5 @@
   if (ScavengeALot || FullGCALot) {
     srand(ScavengeALotInterval * FullGCALotInterval);
   }
 #endif
 }
-
-#ifdef ASSERT
-// JRT_LEAF rules:
-// A JRT_LEAF method may not interfere with safepointing by
-//   1) acquiring or blocking on a Mutex or JavaLock - checked
-//   2) allocating heap memory - checked
-//   3) executing a VM operation - checked
-//   4) executing a system call (including malloc) that could block or grab a lock
-//   5) invoking GC
-//   6) reaching a safepoint
-//   7) running too long
-// Nor may any method it calls.
-JRTLeafVerifier::JRTLeafVerifier()
-  : NoSafepointVerifier(true, JRTLeafVerifier::should_verify_GC())
-{
-}
-
-JRTLeafVerifier::~JRTLeafVerifier()
-{
-}
-
-bool JRTLeafVerifier::should_verify_GC() {
-  switch (JavaThread::current()->thread_state()) {
-  case _thread_in_Java:
-    // is in a leaf routine, there must be no safepoint.
-    return true;
-  case _thread_in_native:
-    // A native thread is not subject to safepoints.
-    // Even while it is in a leaf routine, GC is ok
-    return false;
-  default:
-    // Leaf routines cannot be called from other contexts.
-    ShouldNotReachHere();
-    return false;
-  }
-}
-#endif // ASSERT

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/vmThread.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vmStructs.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmThread.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/vmThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;compiler/compileBroker.hpp&quot;
 27 #include &quot;gc/shared/collectedHeap.hpp&quot;
 28 #include &quot;jfr/jfrEvents.hpp&quot;
 29 #include &quot;jfr/support/jfrThreadId.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;logging/logConfiguration.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;

 34 #include &quot;oops/method.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;oops/verifyOopClosure.hpp&quot;

 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 39 #include &quot;runtime/mutexLocker.hpp&quot;
 40 #include &quot;runtime/os.hpp&quot;
 41 #include &quot;runtime/safepoint.hpp&quot;
 42 #include &quot;runtime/thread.inline.hpp&quot;
 43 #include &quot;runtime/vmThread.hpp&quot;
 44 #include &quot;runtime/vmOperations.hpp&quot;
 45 #include &quot;services/runtimeService.hpp&quot;
 46 #include &quot;utilities/dtrace.hpp&quot;
 47 #include &quot;utilities/events.hpp&quot;
 48 #include &quot;utilities/vmError.hpp&quot;
 49 #include &quot;utilities/xmlstream.hpp&quot;
 50 


 51 VMOperationQueue::VMOperationQueue() {
 52   // The queue is a circular doubled-linked list, which always contains
 53   // one element (i.e., one element means empty).
 54   for(int i = 0; i &lt; nof_priorities; i++) {
 55     _queue_length[i] = 0;
 56     _queue_counter = 0;
<span class="line-modified"> 57     _queue[i] = new VM_None(&quot;QueueHead&quot;);</span>
 58     _queue[i]-&gt;set_next(_queue[i]);
 59     _queue[i]-&gt;set_prev(_queue[i]);
 60   }
<span class="line-removed"> 61   _drain_list = NULL;</span>
 62 }
 63 
 64 
 65 bool VMOperationQueue::queue_empty(int prio) {
 66   // It is empty if there is exactly one element
 67   bool empty = (_queue[prio] == _queue[prio]-&gt;next());
 68   assert( (_queue_length[prio] == 0 &amp;&amp; empty) ||
 69           (_queue_length[prio] &gt; 0  &amp;&amp; !empty), &quot;sanity check&quot;);
 70   return _queue_length[prio] == 0;
 71 }
 72 
 73 // Inserts an element to the right of the q element
 74 void VMOperationQueue::insert(VM_Operation* q, VM_Operation* n) {
 75   assert(q-&gt;next()-&gt;prev() == q &amp;&amp; q-&gt;prev()-&gt;next() == q, &quot;sanity check&quot;);
 76   n-&gt;set_prev(q);
 77   n-&gt;set_next(q-&gt;next());
 78   q-&gt;next()-&gt;set_prev(n);
 79   q-&gt;set_next(n);
 80 }
 81 
<span class="line-modified"> 82 void VMOperationQueue::queue_add_front(int prio, VM_Operation *op) {</span>
<span class="line-removed"> 83   _queue_length[prio]++;</span>
<span class="line-removed"> 84   insert(_queue[prio]-&gt;next(), op);</span>
<span class="line-removed"> 85 }</span>
<span class="line-removed"> 86 </span>
<span class="line-removed"> 87 void VMOperationQueue::queue_add_back(int prio, VM_Operation *op) {</span>
 88   _queue_length[prio]++;
 89   insert(_queue[prio]-&gt;prev(), op);
 90 }
 91 
 92 
 93 void VMOperationQueue::unlink(VM_Operation* q) {
 94   assert(q-&gt;next()-&gt;prev() == q &amp;&amp; q-&gt;prev()-&gt;next() == q, &quot;sanity check&quot;);
 95   q-&gt;prev()-&gt;set_next(q-&gt;next());
 96   q-&gt;next()-&gt;set_prev(q-&gt;prev());
 97 }
 98 
 99 VM_Operation* VMOperationQueue::queue_remove_front(int prio) {
100   if (queue_empty(prio)) return NULL;
101   assert(_queue_length[prio] &gt;= 0, &quot;sanity check&quot;);
102   _queue_length[prio]--;
103   VM_Operation* r = _queue[prio]-&gt;next();
104   assert(r != _queue[prio], &quot;cannot remove base element&quot;);
105   unlink(r);
106   return r;
107 }
</pre>
<hr />
<pre>
112   assert(length &gt;= 0, &quot;sanity check&quot;);
113   _queue_length[prio] = 0;
114   VM_Operation* r = _queue[prio]-&gt;next();
115   assert(r != _queue[prio], &quot;cannot remove base element&quot;);
116   // remove links to base element from head and tail
117   r-&gt;set_prev(NULL);
118   _queue[prio]-&gt;prev()-&gt;set_next(NULL);
119   // restore queue to empty state
120   _queue[prio]-&gt;set_next(_queue[prio]);
121   _queue[prio]-&gt;set_prev(_queue[prio]);
122   assert(queue_empty(prio), &quot;drain corrupted queue&quot;);
123 #ifdef ASSERT
124   int len = 0;
125   VM_Operation* cur;
126   for(cur = r; cur != NULL; cur=cur-&gt;next()) len++;
127   assert(len == length, &quot;drain lost some ops&quot;);
128 #endif
129   return r;
130 }
131 
<span class="line-removed">132 void VMOperationQueue::queue_oops_do(int queue, OopClosure* f) {</span>
<span class="line-removed">133   VM_Operation* cur = _queue[queue];</span>
<span class="line-removed">134   cur = cur-&gt;next();</span>
<span class="line-removed">135   while (cur != _queue[queue]) {</span>
<span class="line-removed">136     cur-&gt;oops_do(f);</span>
<span class="line-removed">137     cur = cur-&gt;next();</span>
<span class="line-removed">138   }</span>
<span class="line-removed">139 }</span>
<span class="line-removed">140 </span>
<span class="line-removed">141 void VMOperationQueue::drain_list_oops_do(OopClosure* f) {</span>
<span class="line-removed">142   VM_Operation* cur = _drain_list;</span>
<span class="line-removed">143   while (cur != NULL) {</span>
<span class="line-removed">144     cur-&gt;oops_do(f);</span>
<span class="line-removed">145     cur = cur-&gt;next();</span>
<span class="line-removed">146   }</span>
<span class="line-removed">147 }</span>
<span class="line-removed">148 </span>
149 //-----------------------------------------------------------------
150 // High-level interface
<span class="line-modified">151 bool VMOperationQueue::add(VM_Operation *op) {</span>
152 
153   HOTSPOT_VMOPS_REQUEST(
154                    (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">155                    op-&gt;evaluation_mode());</span>
156 
157   // Encapsulates VM queue policy. Currently, that
158   // only involves putting them on the right list
<span class="line-modified">159   if (op-&gt;evaluate_at_safepoint()) {</span>
<span class="line-removed">160     queue_add_back(SafepointPriority, op);</span>
<span class="line-removed">161     return true;</span>
<span class="line-removed">162   }</span>
<span class="line-removed">163 </span>
<span class="line-removed">164   queue_add_back(MediumPriority, op);</span>
<span class="line-removed">165   return true;</span>
166 }
167 
168 VM_Operation* VMOperationQueue::remove_next() {
169   // Assuming VMOperation queue is two-level priority queue. If there are
170   // more than two priorities, we need a different scheduling algorithm.
171   assert(SafepointPriority == 0 &amp;&amp; MediumPriority == 1 &amp;&amp; nof_priorities == 2,
172          &quot;current algorithm does not work&quot;);
173 
174   // simple counter based scheduling to prevent starvation of lower priority
175   // queue. -- see 4390175
176   int high_prio, low_prio;
177   if (_queue_counter++ &lt; 10) {
178       high_prio = SafepointPriority;
179       low_prio  = MediumPriority;
180   } else {
181       _queue_counter = 0;
182       high_prio = MediumPriority;
183       low_prio  = SafepointPriority;
184   }
185 
186   return queue_remove_front(queue_empty(high_prio) ? low_prio : high_prio);
187 }
188 
<span class="line-removed">189 void VMOperationQueue::oops_do(OopClosure* f) {</span>
<span class="line-removed">190   for(int i = 0; i &lt; nof_priorities; i++) {</span>
<span class="line-removed">191     queue_oops_do(i, f);</span>
<span class="line-removed">192   }</span>
<span class="line-removed">193   drain_list_oops_do(f);</span>
<span class="line-removed">194 }</span>
<span class="line-removed">195 </span>
196 //------------------------------------------------------------------------------------------------------------------
197 // Timeout machinery
198 
199 void VMOperationTimeoutTask::task() {
200   assert(AbortVMOnVMOperationTimeout, &quot;only if enabled&quot;);
201   if (is_armed()) {
<span class="line-modified">202     jlong delay = (os::javaTimeMillis() - _arm_time);</span>
203     if (delay &gt; AbortVMOnVMOperationTimeoutDelay) {
204       fatal(&quot;VM operation took too long: &quot; JLONG_FORMAT &quot; ms (timeout: &quot; INTX_FORMAT &quot; ms)&quot;,
205             delay, AbortVMOnVMOperationTimeoutDelay);
206     }
207   }
208 }
209 
210 bool VMOperationTimeoutTask::is_armed() {
<span class="line-modified">211   return OrderAccess::load_acquire(&amp;_armed) != 0;</span>
212 }
213 
214 void VMOperationTimeoutTask::arm() {
<span class="line-modified">215   _arm_time = os::javaTimeMillis();</span>
<span class="line-modified">216   OrderAccess::release_store_fence(&amp;_armed, 1);</span>
217 }
218 
219 void VMOperationTimeoutTask::disarm() {
<span class="line-modified">220   OrderAccess::release_store_fence(&amp;_armed, 0);</span>
221 }
222 
223 //------------------------------------------------------------------------------------------------------------------
224 // Implementation of VMThread stuff
225 
226 bool              VMThread::_should_terminate   = false;
227 bool              VMThread::_terminated         = false;
228 Monitor*          VMThread::_terminate_lock     = NULL;
229 VMThread*         VMThread::_vm_thread          = NULL;
230 VM_Operation*     VMThread::_cur_vm_operation   = NULL;
231 VMOperationQueue* VMThread::_vm_queue           = NULL;
232 PerfCounter*      VMThread::_perf_accumulated_vm_operation_time = NULL;
233 uint64_t          VMThread::_coalesced_count = 0;
234 VMOperationTimeoutTask* VMThread::_timeout_task = NULL;
235 
236 
237 void VMThread::create() {
238   assert(vm_thread() == NULL, &quot;we can only allocate one VMThread&quot;);
239   _vm_thread = new VMThread();
240 
</pre>
<hr />
<pre>
325     Universe::heap()-&gt;prepare_for_verify();
326     // Silent verification so as not to pollute normal output,
327     // unless we really asked for it.
328     Universe::verify();
329   }
330 
331   CompileBroker::set_should_block();
332 
333   // wait for threads (compiler threads or daemon threads) in the
334   // _thread_in_native state to block.
335   VM_Exit::wait_for_threads_in_native_to_block();
336 
337   // signal other threads that VM process is gone
338   {
339     // Note: we must have the _no_safepoint_check_flag. Mutex::lock() allows
340     // VM thread to enter any lock at Safepoint as long as its _owner is NULL.
341     // If that happens after _terminate_lock-&gt;wait() has unset _owner
342     // but before it actually drops the lock and waits, the notification below
343     // may get lost and we will have a hang. To avoid this, we need to use
344     // Mutex::lock_without_safepoint_check().
<span class="line-modified">345     MutexLockerEx ml(_terminate_lock, Mutex::_no_safepoint_check_flag);</span>
346     _terminated = true;
<span class="line-modified">347     _terminate_lock-&gt;notify();</span>
348   }
349 
350   // We are now racing with the VM termination being carried out in
351   // another thread, so we don&#39;t &quot;delete this&quot;. Numerous threads don&#39;t
352   // get deleted when the VM terminates
353 
354 }
355 
356 
357 // Notify the VMThread that the last non-daemon JavaThread has terminated,
358 // and wait until operation is performed.
359 void VMThread::wait_for_vm_thread_exit() {
360   assert(Thread::current()-&gt;is_Java_thread(), &quot;Should be a JavaThread&quot;);
361   assert(((JavaThread*)Thread::current())-&gt;is_terminated(), &quot;Should be terminated&quot;);
<span class="line-modified">362   { MutexLockerEx mu(VMOperationQueue_lock, Mutex::_no_safepoint_check_flag);</span>
363     _should_terminate = true;
<span class="line-modified">364     VMOperationQueue_lock-&gt;notify();</span>
365   }
366 
367   // Note: VM thread leaves at Safepoint. We are not stopped by Safepoint
368   // because this thread has been removed from the threads list. But anything
369   // that could get blocked by Safepoint should not be used after this point,
370   // otherwise we will hang, since there is no one can end the safepoint.
371 
372   // Wait until VM thread is terminated
373   // Note: it should be OK to use Terminator_lock here. But this is called
374   // at a very delicate time (VM shutdown) and we are operating in non- VM
375   // thread at Safepoint. It&#39;s safer to not share lock with other threads.
<span class="line-modified">376   { MutexLockerEx ml(_terminate_lock, Mutex::_no_safepoint_check_flag);</span>
377     while(!VMThread::is_terminated()) {
<span class="line-modified">378         _terminate_lock-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
379     }
380   }
381 }
382 
383 static void post_vm_operation_event(EventExecuteVMOperation* event, VM_Operation* op) {
384   assert(event != NULL, &quot;invariant&quot;);
385   assert(event-&gt;should_commit(), &quot;invariant&quot;);
386   assert(op != NULL, &quot;invariant&quot;);
<span class="line-removed">387   const bool is_concurrent = op-&gt;evaluate_concurrently();</span>
388   const bool evaluate_at_safepoint = op-&gt;evaluate_at_safepoint();
389   event-&gt;set_operation(op-&gt;type());
390   event-&gt;set_safepoint(evaluate_at_safepoint);
<span class="line-modified">391   event-&gt;set_blocking(!is_concurrent);</span>
<span class="line-modified">392   // Only write caller thread information for non-concurrent vm operations.</span>
<span class="line-modified">393   // For concurrent vm operations, the thread id is set to 0 indicating thread is unknown.</span>
<span class="line-removed">394   // This is because the caller thread could have exited already.</span>
<span class="line-removed">395   event-&gt;set_caller(is_concurrent ? 0 : JFR_THREAD_ID(op-&gt;calling_thread()));</span>
<span class="line-removed">396   event-&gt;set_safepointId(evaluate_at_safepoint ? SafepointSynchronize::safepoint_counter() : 0);</span>
397   event-&gt;commit();
398 }
399 
400 void VMThread::evaluate_operation(VM_Operation* op) {
401   ResourceMark rm;
402 
403   {
404     PerfTraceTime vm_op_timer(perf_accumulated_vm_operation_time());
405     HOTSPOT_VMOPS_BEGIN(
406                      (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">407                      op-&gt;evaluation_mode());</span>
408 
409     EventExecuteVMOperation event;
410     op-&gt;evaluate();
411     if (event.should_commit()) {
412       post_vm_operation_event(&amp;event, op);
413     }
414 
415     HOTSPOT_VMOPS_END(
416                      (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">417                      op-&gt;evaluation_mode());</span>
418   }
419 
<span class="line-removed">420   // Last access of info in _cur_vm_operation!</span>
<span class="line-removed">421   bool c_heap_allocated = op-&gt;is_cheap_allocated();</span>
<span class="line-removed">422 </span>
423   // Mark as completed
<span class="line-modified">424   if (!op-&gt;evaluate_concurrently()) {</span>
<span class="line-removed">425     op-&gt;calling_thread()-&gt;increment_vm_operation_completed_count();</span>
<span class="line-removed">426   }</span>
<span class="line-removed">427   // It is unsafe to access the _cur_vm_operation after the &#39;increment_vm_operation_completed_count&#39; call,</span>
<span class="line-removed">428   // since if it is stack allocated the calling thread might have deallocated</span>
<span class="line-removed">429   if (c_heap_allocated) {</span>
<span class="line-removed">430     delete _cur_vm_operation;</span>
<span class="line-removed">431   }</span>
432 }
433 
434 static VM_None    safepointALot_op(&quot;SafepointALot&quot;);
435 static VM_Cleanup cleanup_op;
436 
<span class="line-modified">437 VM_Operation* VMThread::no_op_safepoint(bool check_time) {</span>
<span class="line-modified">438   if (SafepointALot) {</span>
<span class="line-modified">439     return &amp;safepointALot_op;</span>






440   }
<span class="line-modified">441   if (!SafepointSynchronize::is_cleanup_needed()) {</span>
<span class="line-modified">442     return NULL;</span>










443   }
<span class="line-modified">444   if (check_time) {</span>
<span class="line-modified">445     long interval_ms = SafepointTracing::time_since_last_safepoint_ms();</span>
<span class="line-modified">446     bool max_time_exceeded = GuaranteedSafepointInterval != 0 &amp;&amp;</span>
<span class="line-modified">447                              (interval_ms &gt; GuaranteedSafepointInterval);</span>
<span class="line-modified">448     if (!max_time_exceeded) {</span>
<span class="line-modified">449       return NULL;</span>
<span class="line-modified">450     }</span>



451   }
<span class="line-modified">452   return &amp;cleanup_op;</span>

453 }
454 
455 void VMThread::loop() {
456   assert(_cur_vm_operation == NULL, &quot;no current one should be executing&quot;);
457 
458   SafepointSynchronize::init(_vm_thread);
459 
460   while(true) {
461     VM_Operation* safepoint_ops = NULL;
462     //
463     // Wait for VM operation
464     //
465     // use no_safepoint_check to get lock without attempting to &quot;sneak&quot;
<span class="line-modified">466     { MutexLockerEx mu_queue(VMOperationQueue_lock,</span>
467                              Mutex::_no_safepoint_check_flag);
468 
469       // Look for new operation
470       assert(_cur_vm_operation == NULL, &quot;no current one should be executing&quot;);
471       _cur_vm_operation = _vm_queue-&gt;remove_next();
472 
473       // Stall time tracking code
<span class="line-modified">474       if (PrintVMQWaitTime &amp;&amp; _cur_vm_operation != NULL &amp;&amp;</span>
<span class="line-modified">475           !_cur_vm_operation-&gt;evaluate_concurrently()) {</span>
<span class="line-removed">476         long stall = os::javaTimeMillis() - _cur_vm_operation-&gt;timestamp();</span>
477         if (stall &gt; 0)
<span class="line-modified">478           tty-&gt;print_cr(&quot;%s stall: %ld&quot;,  _cur_vm_operation-&gt;name(), stall);</span>
479       }
480 
481       while (!should_terminate() &amp;&amp; _cur_vm_operation == NULL) {
482         // wait with a timeout to guarantee safepoints at regular intervals
<span class="line-modified">483         bool timedout =</span>
<span class="line-modified">484           VMOperationQueue_lock-&gt;wait(Mutex::_no_safepoint_check_flag,</span>
<span class="line-removed">485                                       GuaranteedSafepointInterval);</span>
486 
487         // Support for self destruction
488         if ((SelfDestructTimer != 0) &amp;&amp; !VMError::is_error_reported() &amp;&amp;
489             (os::elapsedTime() &gt; (double)SelfDestructTimer * 60.0)) {
490           tty-&gt;print_cr(&quot;VM self-destructed&quot;);
491           exit(-1);
492         }
493 
<span class="line-modified">494         if (timedout &amp;&amp; (_cur_vm_operation = VMThread::no_op_safepoint(false)) != NULL) {</span>
<span class="line-modified">495           MutexUnlockerEx mul(VMOperationQueue_lock,</span>
<span class="line-modified">496                               Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">497           // Force a safepoint since we have not had one for at least</span>
<span class="line-modified">498           // &#39;GuaranteedSafepointInterval&#39; milliseconds.  This will run all</span>
<span class="line-modified">499           // the clean-up processing that needs to be done regularly at a</span>
<span class="line-modified">500           // safepoint</span>
<span class="line-modified">501           SafepointSynchronize::begin();</span>
<span class="line-modified">502           #ifdef ASSERT</span>





503             if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();
<span class="line-modified">504           #endif</span>
<span class="line-modified">505           SafepointSynchronize::end();</span>
<span class="line-modified">506           _cur_vm_operation = NULL;</span>

507         }
508         _cur_vm_operation = _vm_queue-&gt;remove_next();
509 
510         // If we are at a safepoint we will evaluate all the operations that
511         // follow that also require a safepoint
512         if (_cur_vm_operation != NULL &amp;&amp;
513             _cur_vm_operation-&gt;evaluate_at_safepoint()) {
514           safepoint_ops = _vm_queue-&gt;drain_at_safepoint_priority();
515         }
516       }
517 
518       if (should_terminate()) break;
519     } // Release mu_queue_lock
520 
521     //
522     // Execute VM operation
523     //
524     { HandleMark hm(VMThread::vm_thread());
525 
526       EventMark em(&quot;Executing VM operation: %s&quot;, vm_operation()-&gt;name());
527       assert(_cur_vm_operation != NULL, &quot;we should have found an operation to execute&quot;);
528 
529       // If we are at a safepoint we will evaluate all the operations that
530       // follow that also require a safepoint
531       if (_cur_vm_operation-&gt;evaluate_at_safepoint()) {
532         log_debug(vmthread)(&quot;Evaluating safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());
533 
<span class="line-removed">534         _vm_queue-&gt;set_drain_list(safepoint_ops); // ensure ops can be scanned</span>
<span class="line-removed">535 </span>
536         SafepointSynchronize::begin();
537 
538         if (_timeout_task != NULL) {
539           _timeout_task-&gt;arm();
540         }
541 
542         evaluate_operation(_cur_vm_operation);
543         // now process all queued safepoint ops, iteratively draining
544         // the queue until there are none left
545         do {
546           _cur_vm_operation = safepoint_ops;
547           if (_cur_vm_operation != NULL) {
548             do {

549               log_debug(vmthread)(&quot;Evaluating coalesced safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());
550               // evaluate_operation deletes the op object so we have
551               // to grab the next op now
552               VM_Operation* next = _cur_vm_operation-&gt;next();
<span class="line-removed">553               _vm_queue-&gt;set_drain_list(next);</span>
554               evaluate_operation(_cur_vm_operation);
555               _cur_vm_operation = next;
556               _coalesced_count++;
557             } while (_cur_vm_operation != NULL);
558           }
559           // There is a chance that a thread enqueued a safepoint op
560           // since we released the op-queue lock and initiated the safepoint.
561           // So we drain the queue again if there is anything there, as an
562           // optimization to try and reduce the number of safepoints.
563           // As the safepoint synchronizes us with JavaThreads we will see
564           // any enqueue made by a JavaThread, but the peek will not
565           // necessarily detect a concurrent enqueue by a GC thread, but
566           // that simply means the op will wait for the next major cycle of the
567           // VMThread - just as it would if the GC thread lost the race for
568           // the lock.
569           if (_vm_queue-&gt;peek_at_safepoint_priority()) {
570             // must hold lock while draining queue
<span class="line-modified">571             MutexLockerEx mu_queue(VMOperationQueue_lock,</span>
<span class="line-modified">572                                      Mutex::_no_safepoint_check_flag);</span>
573             safepoint_ops = _vm_queue-&gt;drain_at_safepoint_priority();
574           } else {
575             safepoint_ops = NULL;
576           }
577         } while(safepoint_ops != NULL);
578 
<span class="line-removed">579         _vm_queue-&gt;set_drain_list(NULL);</span>
<span class="line-removed">580 </span>
581         if (_timeout_task != NULL) {
582           _timeout_task-&gt;disarm();
583         }
584 
585         // Complete safepoint synchronization
586         SafepointSynchronize::end();
587 
588       } else {  // not a safepoint operation
589         log_debug(vmthread)(&quot;Evaluating non-safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());
590         if (TraceLongCompiles) {
591           elapsedTimer t;
592           t.start();
593           evaluate_operation(_cur_vm_operation);
594           t.stop();
595           double secs = t.seconds();
596           if (secs * 1e3 &gt; LongCompileThreshold) {
597             // XXX - _cur_vm_operation should not be accessed after
598             // the completed count has been incremented; the waiting
599             // thread may have already freed this memory.
600             tty-&gt;print_cr(&quot;vm %s: %3.7f secs]&quot;, _cur_vm_operation-&gt;name(), secs);
601           }
602         } else {
603           evaluate_operation(_cur_vm_operation);
604         }
605 
606         _cur_vm_operation = NULL;
607       }
608     }
609 
610     //
<span class="line-modified">611     //  Notify (potential) waiting Java thread(s) - lock without safepoint</span>
<span class="line-modified">612     //  check so that sneaking is not possible</span>
<span class="line-modified">613     { MutexLockerEx mu(VMOperationRequest_lock,</span>
<span class="line-removed">614                        Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">615       VMOperationRequest_lock-&gt;notify_all();</span>
<span class="line-removed">616     }</span>
<span class="line-removed">617 </span>
<span class="line-removed">618     //</span>
<span class="line-removed">619     // We want to make sure that we get to a safepoint regularly.</span>
<span class="line-removed">620     //</span>
<span class="line-removed">621     if ((_cur_vm_operation = VMThread::no_op_safepoint(false)) != NULL) {</span>
<span class="line-removed">622       HandleMark hm(VMThread::vm_thread());</span>
<span class="line-removed">623       SafepointSynchronize::begin();</span>
<span class="line-removed">624       SafepointSynchronize::end();</span>
<span class="line-removed">625       _cur_vm_operation = NULL;</span>
626     }
627   }
628 }
629 
630 // A SkipGCALot object is used to elide the usual effect of gc-a-lot
631 // over a section of execution by a thread. Currently, it&#39;s used only to
632 // prevent re-entrant calls to GC.
633 class SkipGCALot : public StackObj {
634   private:
635    bool _saved;
636    Thread* _t;
637 
638   public:
639 #ifdef ASSERT
640     SkipGCALot(Thread* t) : _t(t) {
641       _saved = _t-&gt;skip_gcalot();
642       _t-&gt;set_skip_gcalot(true);
643     }
644 
645     ~SkipGCALot() {
646       assert(_t-&gt;skip_gcalot(), &quot;Save-restore protocol invariant&quot;);
647       _t-&gt;set_skip_gcalot(_saved);
648     }
649 #else
650     SkipGCALot(Thread* t) { }
651     ~SkipGCALot() { }
652 #endif
653 };
654 
655 void VMThread::execute(VM_Operation* op) {
656   Thread* t = Thread::current();
657 
658   if (!t-&gt;is_VM_thread()) {
659     SkipGCALot sgcalot(t);    // avoid re-entrant attempts to gc-a-lot
660     // JavaThread or WatcherThread
<span class="line-modified">661     bool concurrent = op-&gt;evaluate_concurrently();</span>
<span class="line-removed">662     // only blocking VM operations need to verify the caller&#39;s safepoint state:</span>
<span class="line-removed">663     if (!concurrent) {</span>
<span class="line-removed">664       t-&gt;check_for_valid_safepoint_state(true);</span>
<span class="line-removed">665     }</span>
666 
667     // New request from Java thread, evaluate prologue
668     if (!op-&gt;doit_prologue()) {
669       return;   // op was cancelled
670     }
671 
672     // Setup VM_operations for execution
<span class="line-modified">673     op-&gt;set_calling_thread(t, Thread::get_priority(t));</span>
674 
<span class="line-modified">675     // It does not make sense to execute the epilogue, if the VM operation object is getting</span>
<span class="line-modified">676     // deallocated by the VM thread.</span>
<span class="line-removed">677     bool execute_epilog = !op-&gt;is_cheap_allocated();</span>
<span class="line-removed">678     assert(!concurrent || op-&gt;is_cheap_allocated(), &quot;concurrent =&gt; cheap_allocated&quot;);</span>
<span class="line-removed">679 </span>
<span class="line-removed">680     // Get ticket number for non-concurrent VM operations</span>
<span class="line-removed">681     int ticket = 0;</span>
<span class="line-removed">682     if (!concurrent) {</span>
<span class="line-removed">683       ticket = t-&gt;vm_operation_ticket();</span>
<span class="line-removed">684     }</span>
685 
686     // Add VM operation to list of waiting threads. We are guaranteed not to block while holding the
687     // VMOperationQueue_lock, so we can block without a safepoint check. This allows vm operation requests
688     // to be queued up during a safepoint synchronization.
689     {
<span class="line-modified">690       VMOperationQueue_lock-&gt;lock_without_safepoint_check();</span>
691       log_debug(vmthread)(&quot;Adding VM operation: %s&quot;, op-&gt;name());
<span class="line-modified">692       bool ok = _vm_queue-&gt;add(op);</span>
<span class="line-modified">693       op-&gt;set_timestamp(os::javaTimeMillis());</span>
<span class="line-modified">694       VMOperationQueue_lock-&gt;notify();</span>
<span class="line-removed">695       VMOperationQueue_lock-&gt;unlock();</span>
<span class="line-removed">696       // VM_Operation got skipped</span>
<span class="line-removed">697       if (!ok) {</span>
<span class="line-removed">698         assert(concurrent, &quot;can only skip concurrent tasks&quot;);</span>
<span class="line-removed">699         if (op-&gt;is_cheap_allocated()) delete op;</span>
<span class="line-removed">700         return;</span>
<span class="line-removed">701       }</span>
702     }
<span class="line-modified">703 </span>
<span class="line-modified">704     if (!concurrent) {</span>
<span class="line-removed">705       // Wait for completion of request (non-concurrent)</span>
706       // Note: only a JavaThread triggers the safepoint check when locking
<span class="line-modified">707       MutexLocker mu(VMOperationRequest_lock);</span>

708       while(t-&gt;vm_operation_completed_count() &lt; ticket) {
<span class="line-modified">709         VMOperationRequest_lock-&gt;wait(!t-&gt;is_Java_thread());</span>
710       }
711     }
<span class="line-modified">712 </span>
<span class="line-removed">713     if (execute_epilog) {</span>
<span class="line-removed">714       op-&gt;doit_epilogue();</span>
<span class="line-removed">715     }</span>
716   } else {
717     // invoked by VM thread; usually nested VM operation
718     assert(t-&gt;is_VM_thread(), &quot;must be a VM thread&quot;);
719     VM_Operation* prev_vm_operation = vm_operation();
720     if (prev_vm_operation != NULL) {
721       // Check the VM operation allows nested VM operation. This normally not the case, e.g., the compiler
722       // does not allow nested scavenges or compiles.
723       if (!prev_vm_operation-&gt;allow_nested_vm_operations()) {
724         fatal(&quot;Nested VM operation %s requested by operation %s&quot;,
725               op-&gt;name(), vm_operation()-&gt;name());
726       }
<span class="line-modified">727       op-&gt;set_calling_thread(prev_vm_operation-&gt;calling_thread(), prev_vm_operation-&gt;priority());</span>
728     }
729 
730     EventMark em(&quot;Executing %s VM operation: %s&quot;, prev_vm_operation ? &quot;nested&quot; : &quot;&quot;, op-&gt;name());
731 
732     // Release all internal handles after operation is evaluated
733     HandleMark hm(t);
734     _cur_vm_operation = op;
735 
736     if (op-&gt;evaluate_at_safepoint() &amp;&amp; !SafepointSynchronize::is_at_safepoint()) {
737       SafepointSynchronize::begin();
738       op-&gt;evaluate();
739       SafepointSynchronize::end();
740     } else {
741       op-&gt;evaluate();
742     }
743 
<span class="line-removed">744     // Free memory if needed</span>
<span class="line-removed">745     if (op-&gt;is_cheap_allocated()) delete op;</span>
<span class="line-removed">746 </span>
747     _cur_vm_operation = prev_vm_operation;
748   }
749 }
750 
<span class="line-removed">751 </span>
<span class="line-removed">752 void VMThread::oops_do(OopClosure* f, CodeBlobClosure* cf) {</span>
<span class="line-removed">753   Thread::oops_do(f, cf);</span>
<span class="line-removed">754   _vm_queue-&gt;oops_do(f);</span>
<span class="line-removed">755 }</span>
<span class="line-removed">756 </span>
<span class="line-removed">757 //------------------------------------------------------------------------------------------------------------------</span>
<span class="line-removed">758 #ifndef PRODUCT</span>
<span class="line-removed">759 </span>
<span class="line-removed">760 void VMOperationQueue::verify_queue(int prio) {</span>
<span class="line-removed">761   // Check that list is correctly linked</span>
<span class="line-removed">762   int length = _queue_length[prio];</span>
<span class="line-removed">763   VM_Operation *cur = _queue[prio];</span>
<span class="line-removed">764   int i;</span>
<span class="line-removed">765 </span>
<span class="line-removed">766   // Check forward links</span>
<span class="line-removed">767   for(i = 0; i &lt; length; i++) {</span>
<span class="line-removed">768     cur = cur-&gt;next();</span>
<span class="line-removed">769     assert(cur != _queue[prio], &quot;list to short (forward)&quot;);</span>
<span class="line-removed">770   }</span>
<span class="line-removed">771   assert(cur-&gt;next() == _queue[prio], &quot;list to long (forward)&quot;);</span>
<span class="line-removed">772 </span>
<span class="line-removed">773   // Check backwards links</span>
<span class="line-removed">774   cur = _queue[prio];</span>
<span class="line-removed">775   for(i = 0; i &lt; length; i++) {</span>
<span class="line-removed">776     cur = cur-&gt;prev();</span>
<span class="line-removed">777     assert(cur != _queue[prio], &quot;list to short (backwards)&quot;);</span>
<span class="line-removed">778   }</span>
<span class="line-removed">779   assert(cur-&gt;prev() == _queue[prio], &quot;list to long (backwards)&quot;);</span>
<span class="line-removed">780 }</span>
<span class="line-removed">781 </span>
<span class="line-removed">782 #endif</span>
<span class="line-removed">783 </span>
784 void VMThread::verify() {
785   oops_do(&amp;VerifyOopClosure::verify_oop, NULL);
786 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;compiler/compileBroker.hpp&quot;
 27 #include &quot;gc/shared/collectedHeap.hpp&quot;
 28 #include &quot;jfr/jfrEvents.hpp&quot;
 29 #include &quot;jfr/support/jfrThreadId.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;logging/logConfiguration.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 34 #include &quot;memory/universe.hpp&quot;</span>
 35 #include &quot;oops/method.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;oops/verifyOopClosure.hpp&quot;
<span class="line-added"> 38 #include &quot;runtime/atomic.hpp&quot;</span>
 39 #include &quot;runtime/handles.inline.hpp&quot;
 40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 41 #include &quot;runtime/mutexLocker.hpp&quot;
 42 #include &quot;runtime/os.hpp&quot;
 43 #include &quot;runtime/safepoint.hpp&quot;
 44 #include &quot;runtime/thread.inline.hpp&quot;
 45 #include &quot;runtime/vmThread.hpp&quot;
 46 #include &quot;runtime/vmOperations.hpp&quot;
 47 #include &quot;services/runtimeService.hpp&quot;
 48 #include &quot;utilities/dtrace.hpp&quot;
 49 #include &quot;utilities/events.hpp&quot;
 50 #include &quot;utilities/vmError.hpp&quot;
 51 #include &quot;utilities/xmlstream.hpp&quot;
 52 
<span class="line-added"> 53 VM_QueueHead VMOperationQueue::_queue_head[VMOperationQueue::nof_priorities];</span>
<span class="line-added"> 54 </span>
 55 VMOperationQueue::VMOperationQueue() {
 56   // The queue is a circular doubled-linked list, which always contains
 57   // one element (i.e., one element means empty).
 58   for(int i = 0; i &lt; nof_priorities; i++) {
 59     _queue_length[i] = 0;
 60     _queue_counter = 0;
<span class="line-modified"> 61     _queue[i] = &amp;_queue_head[i];</span>
 62     _queue[i]-&gt;set_next(_queue[i]);
 63     _queue[i]-&gt;set_prev(_queue[i]);
 64   }

 65 }
 66 
 67 
 68 bool VMOperationQueue::queue_empty(int prio) {
 69   // It is empty if there is exactly one element
 70   bool empty = (_queue[prio] == _queue[prio]-&gt;next());
 71   assert( (_queue_length[prio] == 0 &amp;&amp; empty) ||
 72           (_queue_length[prio] &gt; 0  &amp;&amp; !empty), &quot;sanity check&quot;);
 73   return _queue_length[prio] == 0;
 74 }
 75 
 76 // Inserts an element to the right of the q element
 77 void VMOperationQueue::insert(VM_Operation* q, VM_Operation* n) {
 78   assert(q-&gt;next()-&gt;prev() == q &amp;&amp; q-&gt;prev()-&gt;next() == q, &quot;sanity check&quot;);
 79   n-&gt;set_prev(q);
 80   n-&gt;set_next(q-&gt;next());
 81   q-&gt;next()-&gt;set_prev(n);
 82   q-&gt;set_next(n);
 83 }
 84 
<span class="line-modified"> 85 void VMOperationQueue::queue_add(int prio, VM_Operation *op) {</span>





 86   _queue_length[prio]++;
 87   insert(_queue[prio]-&gt;prev(), op);
 88 }
 89 
 90 
 91 void VMOperationQueue::unlink(VM_Operation* q) {
 92   assert(q-&gt;next()-&gt;prev() == q &amp;&amp; q-&gt;prev()-&gt;next() == q, &quot;sanity check&quot;);
 93   q-&gt;prev()-&gt;set_next(q-&gt;next());
 94   q-&gt;next()-&gt;set_prev(q-&gt;prev());
 95 }
 96 
 97 VM_Operation* VMOperationQueue::queue_remove_front(int prio) {
 98   if (queue_empty(prio)) return NULL;
 99   assert(_queue_length[prio] &gt;= 0, &quot;sanity check&quot;);
100   _queue_length[prio]--;
101   VM_Operation* r = _queue[prio]-&gt;next();
102   assert(r != _queue[prio], &quot;cannot remove base element&quot;);
103   unlink(r);
104   return r;
105 }
</pre>
<hr />
<pre>
110   assert(length &gt;= 0, &quot;sanity check&quot;);
111   _queue_length[prio] = 0;
112   VM_Operation* r = _queue[prio]-&gt;next();
113   assert(r != _queue[prio], &quot;cannot remove base element&quot;);
114   // remove links to base element from head and tail
115   r-&gt;set_prev(NULL);
116   _queue[prio]-&gt;prev()-&gt;set_next(NULL);
117   // restore queue to empty state
118   _queue[prio]-&gt;set_next(_queue[prio]);
119   _queue[prio]-&gt;set_prev(_queue[prio]);
120   assert(queue_empty(prio), &quot;drain corrupted queue&quot;);
121 #ifdef ASSERT
122   int len = 0;
123   VM_Operation* cur;
124   for(cur = r; cur != NULL; cur=cur-&gt;next()) len++;
125   assert(len == length, &quot;drain lost some ops&quot;);
126 #endif
127   return r;
128 }
129 

















130 //-----------------------------------------------------------------
131 // High-level interface
<span class="line-modified">132 void VMOperationQueue::add(VM_Operation *op) {</span>
133 
134   HOTSPOT_VMOPS_REQUEST(
135                    (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">136                    op-&gt;evaluate_at_safepoint() ? 0 : 1);</span>
137 
138   // Encapsulates VM queue policy. Currently, that
139   // only involves putting them on the right list
<span class="line-modified">140   queue_add(op-&gt;evaluate_at_safepoint() ? SafepointPriority : MediumPriority, op);</span>






141 }
142 
143 VM_Operation* VMOperationQueue::remove_next() {
144   // Assuming VMOperation queue is two-level priority queue. If there are
145   // more than two priorities, we need a different scheduling algorithm.
146   assert(SafepointPriority == 0 &amp;&amp; MediumPriority == 1 &amp;&amp; nof_priorities == 2,
147          &quot;current algorithm does not work&quot;);
148 
149   // simple counter based scheduling to prevent starvation of lower priority
150   // queue. -- see 4390175
151   int high_prio, low_prio;
152   if (_queue_counter++ &lt; 10) {
153       high_prio = SafepointPriority;
154       low_prio  = MediumPriority;
155   } else {
156       _queue_counter = 0;
157       high_prio = MediumPriority;
158       low_prio  = SafepointPriority;
159   }
160 
161   return queue_remove_front(queue_empty(high_prio) ? low_prio : high_prio);
162 }
163 







164 //------------------------------------------------------------------------------------------------------------------
165 // Timeout machinery
166 
167 void VMOperationTimeoutTask::task() {
168   assert(AbortVMOnVMOperationTimeout, &quot;only if enabled&quot;);
169   if (is_armed()) {
<span class="line-modified">170     jlong delay = nanos_to_millis(os::javaTimeNanos() - _arm_time);</span>
171     if (delay &gt; AbortVMOnVMOperationTimeoutDelay) {
172       fatal(&quot;VM operation took too long: &quot; JLONG_FORMAT &quot; ms (timeout: &quot; INTX_FORMAT &quot; ms)&quot;,
173             delay, AbortVMOnVMOperationTimeoutDelay);
174     }
175   }
176 }
177 
178 bool VMOperationTimeoutTask::is_armed() {
<span class="line-modified">179   return Atomic::load_acquire(&amp;_armed) != 0;</span>
180 }
181 
182 void VMOperationTimeoutTask::arm() {
<span class="line-modified">183   _arm_time = os::javaTimeNanos();</span>
<span class="line-modified">184   Atomic::release_store_fence(&amp;_armed, 1);</span>
185 }
186 
187 void VMOperationTimeoutTask::disarm() {
<span class="line-modified">188   Atomic::release_store_fence(&amp;_armed, 0);</span>
189 }
190 
191 //------------------------------------------------------------------------------------------------------------------
192 // Implementation of VMThread stuff
193 
194 bool              VMThread::_should_terminate   = false;
195 bool              VMThread::_terminated         = false;
196 Monitor*          VMThread::_terminate_lock     = NULL;
197 VMThread*         VMThread::_vm_thread          = NULL;
198 VM_Operation*     VMThread::_cur_vm_operation   = NULL;
199 VMOperationQueue* VMThread::_vm_queue           = NULL;
200 PerfCounter*      VMThread::_perf_accumulated_vm_operation_time = NULL;
201 uint64_t          VMThread::_coalesced_count = 0;
202 VMOperationTimeoutTask* VMThread::_timeout_task = NULL;
203 
204 
205 void VMThread::create() {
206   assert(vm_thread() == NULL, &quot;we can only allocate one VMThread&quot;);
207   _vm_thread = new VMThread();
208 
</pre>
<hr />
<pre>
293     Universe::heap()-&gt;prepare_for_verify();
294     // Silent verification so as not to pollute normal output,
295     // unless we really asked for it.
296     Universe::verify();
297   }
298 
299   CompileBroker::set_should_block();
300 
301   // wait for threads (compiler threads or daemon threads) in the
302   // _thread_in_native state to block.
303   VM_Exit::wait_for_threads_in_native_to_block();
304 
305   // signal other threads that VM process is gone
306   {
307     // Note: we must have the _no_safepoint_check_flag. Mutex::lock() allows
308     // VM thread to enter any lock at Safepoint as long as its _owner is NULL.
309     // If that happens after _terminate_lock-&gt;wait() has unset _owner
310     // but before it actually drops the lock and waits, the notification below
311     // may get lost and we will have a hang. To avoid this, we need to use
312     // Mutex::lock_without_safepoint_check().
<span class="line-modified">313     MonitorLocker ml(_terminate_lock, Mutex::_no_safepoint_check_flag);</span>
314     _terminated = true;
<span class="line-modified">315     ml.notify();</span>
316   }
317 
318   // We are now racing with the VM termination being carried out in
319   // another thread, so we don&#39;t &quot;delete this&quot;. Numerous threads don&#39;t
320   // get deleted when the VM terminates
321 
322 }
323 
324 
325 // Notify the VMThread that the last non-daemon JavaThread has terminated,
326 // and wait until operation is performed.
327 void VMThread::wait_for_vm_thread_exit() {
328   assert(Thread::current()-&gt;is_Java_thread(), &quot;Should be a JavaThread&quot;);
329   assert(((JavaThread*)Thread::current())-&gt;is_terminated(), &quot;Should be terminated&quot;);
<span class="line-modified">330   { MonitorLocker mu(VMOperationQueue_lock, Mutex::_no_safepoint_check_flag);</span>
331     _should_terminate = true;
<span class="line-modified">332     mu.notify();</span>
333   }
334 
335   // Note: VM thread leaves at Safepoint. We are not stopped by Safepoint
336   // because this thread has been removed from the threads list. But anything
337   // that could get blocked by Safepoint should not be used after this point,
338   // otherwise we will hang, since there is no one can end the safepoint.
339 
340   // Wait until VM thread is terminated
341   // Note: it should be OK to use Terminator_lock here. But this is called
342   // at a very delicate time (VM shutdown) and we are operating in non- VM
343   // thread at Safepoint. It&#39;s safer to not share lock with other threads.
<span class="line-modified">344   { MonitorLocker ml(_terminate_lock, Mutex::_no_safepoint_check_flag);</span>
345     while(!VMThread::is_terminated()) {
<span class="line-modified">346       ml.wait();</span>
347     }
348   }
349 }
350 
351 static void post_vm_operation_event(EventExecuteVMOperation* event, VM_Operation* op) {
352   assert(event != NULL, &quot;invariant&quot;);
353   assert(event-&gt;should_commit(), &quot;invariant&quot;);
354   assert(op != NULL, &quot;invariant&quot;);

355   const bool evaluate_at_safepoint = op-&gt;evaluate_at_safepoint();
356   event-&gt;set_operation(op-&gt;type());
357   event-&gt;set_safepoint(evaluate_at_safepoint);
<span class="line-modified">358   event-&gt;set_blocking(true);</span>
<span class="line-modified">359   event-&gt;set_caller(JFR_THREAD_ID(op-&gt;calling_thread()));</span>
<span class="line-modified">360   event-&gt;set_safepointId(evaluate_at_safepoint ? SafepointSynchronize::safepoint_id() : 0);</span>



361   event-&gt;commit();
362 }
363 
364 void VMThread::evaluate_operation(VM_Operation* op) {
365   ResourceMark rm;
366 
367   {
368     PerfTraceTime vm_op_timer(perf_accumulated_vm_operation_time());
369     HOTSPOT_VMOPS_BEGIN(
370                      (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">371                      op-&gt;evaluate_at_safepoint() ? 0 : 1);</span>
372 
373     EventExecuteVMOperation event;
374     op-&gt;evaluate();
375     if (event.should_commit()) {
376       post_vm_operation_event(&amp;event, op);
377     }
378 
379     HOTSPOT_VMOPS_END(
380                      (char *) op-&gt;name(), strlen(op-&gt;name()),
<span class="line-modified">381                      op-&gt;evaluate_at_safepoint() ? 0 : 1);</span>
382   }
383 



384   // Mark as completed
<span class="line-modified">385   op-&gt;calling_thread()-&gt;increment_vm_operation_completed_count();</span>







386 }
387 
388 static VM_None    safepointALot_op(&quot;SafepointALot&quot;);
389 static VM_Cleanup cleanup_op;
390 
<span class="line-modified">391 class HandshakeALotClosure : public HandshakeClosure {</span>
<span class="line-modified">392  public:</span>
<span class="line-modified">393   HandshakeALotClosure() : HandshakeClosure(&quot;HandshakeALot&quot;) {}</span>
<span class="line-added">394   void do_thread(Thread* thread) {</span>
<span class="line-added">395 #ifdef ASSERT</span>
<span class="line-added">396     assert(thread-&gt;is_Java_thread(), &quot;must be&quot;);</span>
<span class="line-added">397     JavaThread* jt = (JavaThread*)thread;</span>
<span class="line-added">398     jt-&gt;verify_states_for_handshake();</span>
<span class="line-added">399 #endif</span>
400   }
<span class="line-modified">401 };</span>
<span class="line-modified">402 </span>
<span class="line-added">403 void VMThread::check_for_forced_cleanup() {</span>
<span class="line-added">404   MonitorLocker mq(VMOperationQueue_lock,  Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">405   mq.notify();</span>
<span class="line-added">406 }</span>
<span class="line-added">407 </span>
<span class="line-added">408 VM_Operation* VMThread::no_op_safepoint() {</span>
<span class="line-added">409   // Check for handshakes first since we may need to return a VMop.</span>
<span class="line-added">410   if (HandshakeALot) {</span>
<span class="line-added">411     HandshakeALotClosure hal_cl;</span>
<span class="line-added">412     Handshake::execute(&amp;hal_cl);</span>
413   }
<span class="line-modified">414   // Check for a cleanup before SafepointALot to keep stats correct.</span>
<span class="line-modified">415   long interval_ms = SafepointTracing::time_since_last_safepoint_ms();</span>
<span class="line-modified">416   bool max_time_exceeded = GuaranteedSafepointInterval != 0 &amp;&amp;</span>
<span class="line-modified">417                            (interval_ms &gt;= GuaranteedSafepointInterval);</span>
<span class="line-modified">418   if ((max_time_exceeded &amp;&amp; SafepointSynchronize::is_cleanup_needed()) ||</span>
<span class="line-modified">419       SafepointSynchronize::is_forced_cleanup_needed()) {</span>
<span class="line-modified">420     return &amp;cleanup_op;</span>
<span class="line-added">421   }</span>
<span class="line-added">422   if (SafepointALot) {</span>
<span class="line-added">423     return &amp;safepointALot_op;</span>
424   }
<span class="line-modified">425   // Nothing to be done.</span>
<span class="line-added">426   return NULL;</span>
427 }
428 
429 void VMThread::loop() {
430   assert(_cur_vm_operation == NULL, &quot;no current one should be executing&quot;);
431 
432   SafepointSynchronize::init(_vm_thread);
433 
434   while(true) {
435     VM_Operation* safepoint_ops = NULL;
436     //
437     // Wait for VM operation
438     //
439     // use no_safepoint_check to get lock without attempting to &quot;sneak&quot;
<span class="line-modified">440     { MonitorLocker mu_queue(VMOperationQueue_lock,</span>
441                              Mutex::_no_safepoint_check_flag);
442 
443       // Look for new operation
444       assert(_cur_vm_operation == NULL, &quot;no current one should be executing&quot;);
445       _cur_vm_operation = _vm_queue-&gt;remove_next();
446 
447       // Stall time tracking code
<span class="line-modified">448       if (PrintVMQWaitTime &amp;&amp; _cur_vm_operation != NULL) {</span>
<span class="line-modified">449         jlong stall = nanos_to_millis(os::javaTimeNanos() - _cur_vm_operation-&gt;timestamp());</span>

450         if (stall &gt; 0)
<span class="line-modified">451           tty-&gt;print_cr(&quot;%s stall: &quot; JLONG_FORMAT,  _cur_vm_operation-&gt;name(), stall);</span>
452       }
453 
454       while (!should_terminate() &amp;&amp; _cur_vm_operation == NULL) {
455         // wait with a timeout to guarantee safepoints at regular intervals
<span class="line-modified">456         // (if there is cleanup work to do)</span>
<span class="line-modified">457         (void)mu_queue.wait(GuaranteedSafepointInterval);</span>

458 
459         // Support for self destruction
460         if ((SelfDestructTimer != 0) &amp;&amp; !VMError::is_error_reported() &amp;&amp;
461             (os::elapsedTime() &gt; (double)SelfDestructTimer * 60.0)) {
462           tty-&gt;print_cr(&quot;VM self-destructed&quot;);
463           exit(-1);
464         }
465 
<span class="line-modified">466         // If the queue contains a safepoint VM op,</span>
<span class="line-modified">467         // clean up will be done so we can skip this part.</span>
<span class="line-modified">468         if (!_vm_queue-&gt;peek_at_safepoint_priority()) {</span>
<span class="line-modified">469 </span>
<span class="line-modified">470           // Have to unlock VMOperationQueue_lock just in case no_op_safepoint()</span>
<span class="line-modified">471           // has to do a handshake when HandshakeALot is enabled.</span>
<span class="line-modified">472           MutexUnlocker mul(VMOperationQueue_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">473           if ((_cur_vm_operation = VMThread::no_op_safepoint()) != NULL) {</span>
<span class="line-modified">474             // Force a safepoint since we have not had one for at least</span>
<span class="line-added">475             // &#39;GuaranteedSafepointInterval&#39; milliseconds and we need to clean</span>
<span class="line-added">476             // something. This will run all the clean-up processing that needs</span>
<span class="line-added">477             // to be done at a safepoint.</span>
<span class="line-added">478             SafepointSynchronize::begin();</span>
<span class="line-added">479             #ifdef ASSERT</span>
480             if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();
<span class="line-modified">481             #endif</span>
<span class="line-modified">482             SafepointSynchronize::end();</span>
<span class="line-modified">483             _cur_vm_operation = NULL;</span>
<span class="line-added">484           }</span>
485         }
486         _cur_vm_operation = _vm_queue-&gt;remove_next();
487 
488         // If we are at a safepoint we will evaluate all the operations that
489         // follow that also require a safepoint
490         if (_cur_vm_operation != NULL &amp;&amp;
491             _cur_vm_operation-&gt;evaluate_at_safepoint()) {
492           safepoint_ops = _vm_queue-&gt;drain_at_safepoint_priority();
493         }
494       }
495 
496       if (should_terminate()) break;
497     } // Release mu_queue_lock
498 
499     //
500     // Execute VM operation
501     //
502     { HandleMark hm(VMThread::vm_thread());
503 
504       EventMark em(&quot;Executing VM operation: %s&quot;, vm_operation()-&gt;name());
505       assert(_cur_vm_operation != NULL, &quot;we should have found an operation to execute&quot;);
506 
507       // If we are at a safepoint we will evaluate all the operations that
508       // follow that also require a safepoint
509       if (_cur_vm_operation-&gt;evaluate_at_safepoint()) {
510         log_debug(vmthread)(&quot;Evaluating safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());
511 


512         SafepointSynchronize::begin();
513 
514         if (_timeout_task != NULL) {
515           _timeout_task-&gt;arm();
516         }
517 
518         evaluate_operation(_cur_vm_operation);
519         // now process all queued safepoint ops, iteratively draining
520         // the queue until there are none left
521         do {
522           _cur_vm_operation = safepoint_ops;
523           if (_cur_vm_operation != NULL) {
524             do {
<span class="line-added">525               EventMark em(&quot;Executing coalesced safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());</span>
526               log_debug(vmthread)(&quot;Evaluating coalesced safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());
527               // evaluate_operation deletes the op object so we have
528               // to grab the next op now
529               VM_Operation* next = _cur_vm_operation-&gt;next();

530               evaluate_operation(_cur_vm_operation);
531               _cur_vm_operation = next;
532               _coalesced_count++;
533             } while (_cur_vm_operation != NULL);
534           }
535           // There is a chance that a thread enqueued a safepoint op
536           // since we released the op-queue lock and initiated the safepoint.
537           // So we drain the queue again if there is anything there, as an
538           // optimization to try and reduce the number of safepoints.
539           // As the safepoint synchronizes us with JavaThreads we will see
540           // any enqueue made by a JavaThread, but the peek will not
541           // necessarily detect a concurrent enqueue by a GC thread, but
542           // that simply means the op will wait for the next major cycle of the
543           // VMThread - just as it would if the GC thread lost the race for
544           // the lock.
545           if (_vm_queue-&gt;peek_at_safepoint_priority()) {
546             // must hold lock while draining queue
<span class="line-modified">547             MutexLocker mu_queue(VMOperationQueue_lock,</span>
<span class="line-modified">548                                  Mutex::_no_safepoint_check_flag);</span>
549             safepoint_ops = _vm_queue-&gt;drain_at_safepoint_priority();
550           } else {
551             safepoint_ops = NULL;
552           }
553         } while(safepoint_ops != NULL);
554 


555         if (_timeout_task != NULL) {
556           _timeout_task-&gt;disarm();
557         }
558 
559         // Complete safepoint synchronization
560         SafepointSynchronize::end();
561 
562       } else {  // not a safepoint operation
563         log_debug(vmthread)(&quot;Evaluating non-safepoint VM operation: %s&quot;, _cur_vm_operation-&gt;name());
564         if (TraceLongCompiles) {
565           elapsedTimer t;
566           t.start();
567           evaluate_operation(_cur_vm_operation);
568           t.stop();
569           double secs = t.seconds();
570           if (secs * 1e3 &gt; LongCompileThreshold) {
571             // XXX - _cur_vm_operation should not be accessed after
572             // the completed count has been incremented; the waiting
573             // thread may have already freed this memory.
574             tty-&gt;print_cr(&quot;vm %s: %3.7f secs]&quot;, _cur_vm_operation-&gt;name(), secs);
575           }
576         } else {
577           evaluate_operation(_cur_vm_operation);
578         }
579 
580         _cur_vm_operation = NULL;
581       }
582     }
583 
584     //
<span class="line-modified">585     //  Notify (potential) waiting Java thread(s)</span>
<span class="line-modified">586     { MonitorLocker mu(VMOperationRequest_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">587       mu.notify_all();</span>












588     }
589   }
590 }
591 
592 // A SkipGCALot object is used to elide the usual effect of gc-a-lot
593 // over a section of execution by a thread. Currently, it&#39;s used only to
594 // prevent re-entrant calls to GC.
595 class SkipGCALot : public StackObj {
596   private:
597    bool _saved;
598    Thread* _t;
599 
600   public:
601 #ifdef ASSERT
602     SkipGCALot(Thread* t) : _t(t) {
603       _saved = _t-&gt;skip_gcalot();
604       _t-&gt;set_skip_gcalot(true);
605     }
606 
607     ~SkipGCALot() {
608       assert(_t-&gt;skip_gcalot(), &quot;Save-restore protocol invariant&quot;);
609       _t-&gt;set_skip_gcalot(_saved);
610     }
611 #else
612     SkipGCALot(Thread* t) { }
613     ~SkipGCALot() { }
614 #endif
615 };
616 
617 void VMThread::execute(VM_Operation* op) {
618   Thread* t = Thread::current();
619 
620   if (!t-&gt;is_VM_thread()) {
621     SkipGCALot sgcalot(t);    // avoid re-entrant attempts to gc-a-lot
622     // JavaThread or WatcherThread
<span class="line-modified">623     t-&gt;check_for_valid_safepoint_state();</span>




624 
625     // New request from Java thread, evaluate prologue
626     if (!op-&gt;doit_prologue()) {
627       return;   // op was cancelled
628     }
629 
630     // Setup VM_operations for execution
<span class="line-modified">631     op-&gt;set_calling_thread(t);</span>
632 
<span class="line-modified">633     // Get ticket number for the VM operation</span>
<span class="line-modified">634     int ticket = t-&gt;vm_operation_ticket();</span>








635 
636     // Add VM operation to list of waiting threads. We are guaranteed not to block while holding the
637     // VMOperationQueue_lock, so we can block without a safepoint check. This allows vm operation requests
638     // to be queued up during a safepoint synchronization.
639     {
<span class="line-modified">640       MonitorLocker ml(VMOperationQueue_lock, Mutex::_no_safepoint_check_flag);</span>
641       log_debug(vmthread)(&quot;Adding VM operation: %s&quot;, op-&gt;name());
<span class="line-modified">642       _vm_queue-&gt;add(op);</span>
<span class="line-modified">643       op-&gt;set_timestamp(os::javaTimeNanos());</span>
<span class="line-modified">644       ml.notify();</span>







645     }
<span class="line-modified">646     {</span>
<span class="line-modified">647       // Wait for completion of request</span>

648       // Note: only a JavaThread triggers the safepoint check when locking
<span class="line-modified">649       MonitorLocker ml(VMOperationRequest_lock,</span>
<span class="line-added">650                        t-&gt;is_Java_thread() ? Mutex::_safepoint_check_flag : Mutex::_no_safepoint_check_flag);</span>
651       while(t-&gt;vm_operation_completed_count() &lt; ticket) {
<span class="line-modified">652         ml.wait();</span>
653       }
654     }
<span class="line-modified">655     op-&gt;doit_epilogue();</span>



656   } else {
657     // invoked by VM thread; usually nested VM operation
658     assert(t-&gt;is_VM_thread(), &quot;must be a VM thread&quot;);
659     VM_Operation* prev_vm_operation = vm_operation();
660     if (prev_vm_operation != NULL) {
661       // Check the VM operation allows nested VM operation. This normally not the case, e.g., the compiler
662       // does not allow nested scavenges or compiles.
663       if (!prev_vm_operation-&gt;allow_nested_vm_operations()) {
664         fatal(&quot;Nested VM operation %s requested by operation %s&quot;,
665               op-&gt;name(), vm_operation()-&gt;name());
666       }
<span class="line-modified">667       op-&gt;set_calling_thread(prev_vm_operation-&gt;calling_thread());</span>
668     }
669 
670     EventMark em(&quot;Executing %s VM operation: %s&quot;, prev_vm_operation ? &quot;nested&quot; : &quot;&quot;, op-&gt;name());
671 
672     // Release all internal handles after operation is evaluated
673     HandleMark hm(t);
674     _cur_vm_operation = op;
675 
676     if (op-&gt;evaluate_at_safepoint() &amp;&amp; !SafepointSynchronize::is_at_safepoint()) {
677       SafepointSynchronize::begin();
678       op-&gt;evaluate();
679       SafepointSynchronize::end();
680     } else {
681       op-&gt;evaluate();
682     }
683 



684     _cur_vm_operation = prev_vm_operation;
685   }
686 }
687 

































688 void VMThread::verify() {
689   oops_do(&amp;VerifyOopClosure::verify_oop, NULL);
690 }
</pre>
</td>
</tr>
</table>
<center><a href="vmStructs.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmThread.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
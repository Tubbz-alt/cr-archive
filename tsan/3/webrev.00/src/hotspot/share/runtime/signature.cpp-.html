<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/signature.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;memory/oopFactory.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;oops/instanceKlass.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;oops/symbol.hpp&quot;
 33 #include &quot;oops/typeArrayKlass.hpp&quot;
 34 #include &quot;runtime/signature.hpp&quot;
 35 
 36 // Implementation of SignatureIterator
 37 
 38 // Signature syntax:
 39 //
 40 // Signature  = &quot;(&quot; {Parameter} &quot;)&quot; ReturnType.
 41 // Parameter  = FieldType.
 42 // ReturnType = FieldType | &quot;V&quot;.
 43 // FieldType  = &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;F&quot; | &quot;I&quot; | &quot;J&quot; | &quot;S&quot; | &quot;Z&quot; | &quot;L&quot; ClassName &quot;;&quot; | &quot;[&quot; FieldType.
 44 // ClassName  = string.
 45 
 46 
 47 SignatureIterator::SignatureIterator(Symbol* signature) {
 48   _signature       = signature;
 49   _parameter_index = 0;
 50 }
 51 
 52 void SignatureIterator::expect(char c) {
 53   if (_signature-&gt;char_at(_index) != c) fatal(&quot;expecting %c&quot;, c);
 54   _index++;
 55 }
 56 
 57 int SignatureIterator::parse_type() {
 58   // Note: This function could be simplified by using &quot;return T_XXX_size;&quot;
 59   //       instead of the assignment and the break statements. However, it
 60   //       seems that the product build for win32_i486 with MS VC++ 6.0 doesn&#39;t
 61   //       work (stack underflow for some tests) - this seems to be a VC++ 6.0
 62   //       compiler bug (was problem - gri 4/27/2000).
 63   int size = -1;
 64   switch(_signature-&gt;char_at(_index)) {
 65     case &#39;B&#39;: do_byte  (); if (_parameter_index &lt; 0 ) _return_type = T_BYTE;
 66               _index++; size = T_BYTE_size   ; break;
 67     case &#39;C&#39;: do_char  (); if (_parameter_index &lt; 0 ) _return_type = T_CHAR;
 68               _index++; size = T_CHAR_size   ; break;
 69     case &#39;D&#39;: do_double(); if (_parameter_index &lt; 0 ) _return_type = T_DOUBLE;
 70               _index++; size = T_DOUBLE_size ; break;
 71     case &#39;F&#39;: do_float (); if (_parameter_index &lt; 0 ) _return_type = T_FLOAT;
 72               _index++; size = T_FLOAT_size  ; break;
 73     case &#39;I&#39;: do_int   (); if (_parameter_index &lt; 0 ) _return_type = T_INT;
 74               _index++; size = T_INT_size    ; break;
 75     case &#39;J&#39;: do_long  (); if (_parameter_index &lt; 0 ) _return_type = T_LONG;
 76               _index++; size = T_LONG_size   ; break;
 77     case &#39;S&#39;: do_short (); if (_parameter_index &lt; 0 ) _return_type = T_SHORT;
 78               _index++; size = T_SHORT_size  ; break;
 79     case &#39;Z&#39;: do_bool  (); if (_parameter_index &lt; 0 ) _return_type = T_BOOLEAN;
 80               _index++; size = T_BOOLEAN_size; break;
 81     case &#39;V&#39;: do_void  (); if (_parameter_index &lt; 0 ) _return_type = T_VOID;
 82               _index++; size = T_VOID_size;  ; break;
 83     case &#39;L&#39;:
 84       { int begin = ++_index;
 85         Symbol* sig = _signature;
 86         while (sig-&gt;char_at(_index++) != &#39;;&#39;) ;
 87         do_object(begin, _index);
 88       }
 89       if (_parameter_index &lt; 0 ) _return_type = T_OBJECT;
 90       size = T_OBJECT_size;
 91       break;
 92     case &#39;[&#39;:
 93       { int begin = ++_index;
 94         Symbol* sig = _signature;
 95         while (sig-&gt;char_at(_index) == &#39;[&#39;) {
 96           _index++;
 97         }
 98         if (sig-&gt;char_at(_index) == &#39;L&#39;) {
 99           while (sig-&gt;char_at(_index++) != &#39;;&#39;) ;
100         } else {
101           _index++;
102         }
103         do_array(begin, _index);
104        if (_parameter_index &lt; 0 ) _return_type = T_ARRAY;
105       }
106       size = T_ARRAY_size;
107       break;
108     default:
109       ShouldNotReachHere();
110       break;
111   }
112   assert(size &gt;= 0, &quot;size must be set&quot;);
113   return size;
114 }
115 
116 
117 void SignatureIterator::check_signature_end() {
118   if (_index &lt; _signature-&gt;utf8_length()) {
119     tty-&gt;print_cr(&quot;too many chars in signature&quot;);
120     _signature-&gt;print_value_on(tty);
121     tty-&gt;print_cr(&quot; @ %d&quot;, _index);
122   }
123 }
124 
125 
126 void SignatureIterator::iterate_parameters() {
127   // Parse parameters
128   _index = 0;
129   _parameter_index = 0;
130   expect(&#39;(&#39;);
131   while (_signature-&gt;char_at(_index) != &#39;)&#39;) _parameter_index += parse_type();
132   expect(&#39;)&#39;);
133   _parameter_index = 0;
134 }
135 
136 // Optimized version of iterate_parameters when fingerprint is known
137 void SignatureIterator::iterate_parameters( uint64_t fingerprint ) {
138   uint64_t saved_fingerprint = fingerprint;
139 
140   // Check for too many arguments
141   if (fingerprint == (uint64_t)CONST64(-1)) {
142     SignatureIterator::iterate_parameters();
143     return;
144   }
145 
146   assert(fingerprint, &quot;Fingerprint should not be 0&quot;);
147 
148   _parameter_index = 0;
149   fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);
150   while ( 1 ) {
151     switch ( fingerprint &amp; parameter_feature_mask ) {
152       case bool_parm:
153         do_bool();
154         _parameter_index += T_BOOLEAN_size;
155         break;
156       case byte_parm:
157         do_byte();
158         _parameter_index += T_BYTE_size;
159         break;
160       case char_parm:
161         do_char();
162         _parameter_index += T_CHAR_size;
163         break;
164       case short_parm:
165         do_short();
166         _parameter_index += T_SHORT_size;
167         break;
168       case int_parm:
169         do_int();
170         _parameter_index += T_INT_size;
171         break;
172       case obj_parm:
173         do_object(0, 0);
174         _parameter_index += T_OBJECT_size;
175         break;
176       case long_parm:
177         do_long();
178         _parameter_index += T_LONG_size;
179         break;
180       case float_parm:
181         do_float();
182         _parameter_index += T_FLOAT_size;
183         break;
184       case double_parm:
185         do_double();
186         _parameter_index += T_DOUBLE_size;
187         break;
188       case done_parm:
189         return;
190       default:
191         tty-&gt;print_cr(&quot;*** parameter is &quot; UINT64_FORMAT, fingerprint &amp; parameter_feature_mask);
192         tty-&gt;print_cr(&quot;*** fingerprint is &quot; PTR64_FORMAT, saved_fingerprint);
193         ShouldNotReachHere();
194         break;
195     }
196     fingerprint &gt;&gt;= parameter_feature_size;
197   }
198 }
199 
200 
201 void SignatureIterator::iterate_returntype() {
202   // Ignore parameters
203   _index = 0;
204   expect(&#39;(&#39;);
205   Symbol* sig = _signature;
206   // Need to skip over each type in the signature&#39;s argument list until a
207   // closing &#39;)&#39; is found., then get the return type.  We cannot just scan
208   // for the first &#39;)&#39; because &#39;)&#39; is a legal character in a type name.
209   while (sig-&gt;char_at(_index) != &#39;)&#39;) {
210     switch(sig-&gt;char_at(_index)) {
211       case &#39;B&#39;:
212       case &#39;C&#39;:
213       case &#39;D&#39;:
214       case &#39;F&#39;:
215       case &#39;I&#39;:
216       case &#39;J&#39;:
217       case &#39;S&#39;:
218       case &#39;Z&#39;:
219       case &#39;V&#39;:
220         {
221           _index++;
222         }
223         break;
224       case &#39;L&#39;:
225         {
226           while (sig-&gt;char_at(_index++) != &#39;;&#39;) ;
227         }
228         break;
229       case &#39;[&#39;:
230         {
231           while (sig-&gt;char_at(++_index) == &#39;[&#39;) ;
232           if (sig-&gt;char_at(_index) == &#39;L&#39;) {
233             while (sig-&gt;char_at(_index++) != &#39;;&#39;) ;
234           } else {
235             _index++;
236           }
237         }
238         break;
239       default:
240         ShouldNotReachHere();
241         break;
242     }
243   }
244   expect(&#39;)&#39;);
245   // Parse return type
246   _parameter_index = -1;
247   parse_type();
248   check_signature_end();
249   _parameter_index = 0;
250 }
251 
252 
253 void SignatureIterator::iterate() {
254   // Parse parameters
255   _parameter_index = 0;
256   _index = 0;
257   expect(&#39;(&#39;);
258   while (_signature-&gt;char_at(_index) != &#39;)&#39;) _parameter_index += parse_type();
259   expect(&#39;)&#39;);
260   // Parse return type
261   _parameter_index = -1;
262   parse_type();
263   check_signature_end();
264   _parameter_index = 0;
265 }
266 
267 
268 // Implementation of SignatureStream
269 SignatureStream::SignatureStream(Symbol* signature, bool is_method) :
270                    _signature(signature), _at_return_type(false), _previous_name(NULL), _names(NULL) {
271   _begin = _end = (is_method ? 1 : 0);  // skip first &#39;(&#39; in method signatures
272   next();
273 }
274 
275 SignatureStream::~SignatureStream() {
276   // decrement refcount for names created during signature parsing
277   if (_names != NULL) {
278     for (int i = 0; i &lt; _names-&gt;length(); i++) {
279       _names-&gt;at(i)-&gt;decrement_refcount();
280     }
281   }
282 }
283 
284 bool SignatureStream::is_done() const {
285   return _end &gt; _signature-&gt;utf8_length();
286 }
287 
288 
289 void SignatureStream::next_non_primitive(int t) {
290   switch (t) {
291     case &#39;L&#39;: {
292       _type = T_OBJECT;
293       Symbol* sig = _signature;
294       while (sig-&gt;char_at(_end++) != &#39;;&#39;);
295       break;
296     }
297     case &#39;[&#39;: {
298       _type = T_ARRAY;
299       Symbol* sig = _signature;
300       char c = sig-&gt;char_at(_end);
301       while (&#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;) c = sig-&gt;char_at(_end++);
302       while (sig-&gt;char_at(_end) == &#39;[&#39;) {
303         _end++;
304         c = sig-&gt;char_at(_end);
305         while (&#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;) c = sig-&gt;char_at(_end++);
306       }
307       switch(sig-&gt;char_at(_end)) {
308         case &#39;B&#39;:
309         case &#39;C&#39;:
310         case &#39;D&#39;:
311         case &#39;F&#39;:
312         case &#39;I&#39;:
313         case &#39;J&#39;:
314         case &#39;S&#39;:
315         case &#39;Z&#39;:_end++; break;
316         default: {
317           while (sig-&gt;char_at(_end++) != &#39;;&#39;);
318           break;
319         }
320       }
321       break;
322     }
323     case &#39;)&#39;: _end++; next(); _at_return_type = true; break;
324     default : ShouldNotReachHere();
325   }
326 }
327 
328 
329 bool SignatureStream::is_object() const {
330   return _type == T_OBJECT
331       || _type == T_ARRAY;
332 }
333 
334 bool SignatureStream::is_array() const {
335   return _type == T_ARRAY;
336 }
337 
338 Symbol* SignatureStream::as_symbol(TRAPS) {
339   // Create a symbol from for string _begin _end
340   int begin = _begin;
341   int end   = _end;
342 
343   if (   _signature-&gt;char_at(_begin) == &#39;L&#39;
344       &amp;&amp; _signature-&gt;char_at(_end-1) == &#39;;&#39;) {
345     begin++;
346     end--;
347   }
348 
349   const char* symbol_chars = (const char*)_signature-&gt;base() + begin;
350   int len = end - begin;
351 
352   // Quick check for common symbols in signatures
353   assert((vmSymbols::java_lang_String()-&gt;utf8_length() == 16 &amp;&amp; vmSymbols::java_lang_Object()-&gt;utf8_length() == 16), &quot;sanity&quot;);
354   if (len == 16 &amp;&amp;
355       strncmp(symbol_chars, &quot;java/lang/&quot;, 10) == 0) {
356     if (strncmp(&quot;String&quot;, symbol_chars + 10, 6) == 0) {
357       return vmSymbols::java_lang_String();
358     } else if (strncmp(&quot;Object&quot;, symbol_chars + 10, 6) == 0) {
359       return vmSymbols::java_lang_Object();
360     }
361   }
362 
363   Symbol* name = _previous_name;
364   if (name != NULL &amp;&amp; name-&gt;equals(symbol_chars, len)) {
365     return name;
366   }
367 
368   // Save names for cleaning up reference count at the end of
369   // SignatureStream scope.
370   name = SymbolTable::new_symbol(symbol_chars, len, CHECK_NULL);
371   if (!name-&gt;is_permanent()) {
372     if (_names == NULL) {
373       _names = new GrowableArray&lt;Symbol*&gt;(10);
374     }
375     _names-&gt;push(name);  // save new symbol for decrementing later
376   }
377   _previous_name = name;
378   return name;
379 }
380 
381 Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,
382                                    FailureMode failure_mode, TRAPS) {
383   if (!is_object())  return NULL;
384   Symbol* name = as_symbol(CHECK_NULL);
385   if (failure_mode == ReturnNull) {
386     return SystemDictionary::resolve_or_null(name, class_loader, protection_domain, THREAD);
387   } else {
388     bool throw_error = (failure_mode == NCDFError);
389     return SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, THREAD);
390   }
391 }
392 
393 oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,
394                                     FailureMode failure_mode, TRAPS) {
395   if (!is_object())
396     return Universe::java_mirror(type());
397   Klass* klass = as_klass(class_loader, protection_domain, failure_mode, CHECK_NULL);
398   if (klass == NULL)  return NULL;
399   return klass-&gt;java_mirror();
400 }
401 
402 Symbol* SignatureStream::as_symbol_or_null() {
403   // Create a symbol from for string _begin _end
404   ResourceMark rm;
405 
406   int begin = _begin;
407   int end   = _end;
408 
409   if (   _signature-&gt;char_at(_begin) == &#39;L&#39;
410       &amp;&amp; _signature-&gt;char_at(_end-1) == &#39;;&#39;) {
411     begin++;
412     end--;
413   }
414 
415   char* buffer = NEW_RESOURCE_ARRAY(char, end - begin);
416   for (int index = begin; index &lt; end; index++) {
417     buffer[index - begin] = _signature-&gt;char_at(index);
418   }
419   Symbol* result = SymbolTable::probe(buffer, end - begin);
420   return result;
421 }
422 
423 int SignatureStream::reference_parameter_count() {
424   int args_count = 0;
425   for ( ; !at_return_type(); next()) {
426     if (is_object()) {
427       args_count++;
428     }
429   }
430   return args_count;
431 }
432 
433 #ifdef ASSERT
434 bool SignatureVerifier::is_valid_method_signature(Symbol* sig) {
435   const char* method_sig = (const char*)sig-&gt;bytes();
436   ssize_t len = sig-&gt;utf8_length();
437   ssize_t index = 0;
438   if (method_sig != NULL &amp;&amp; len &gt; 1 &amp;&amp; method_sig[index] == &#39;(&#39;) {
439     ++index;
440     while (index &lt; len &amp;&amp; method_sig[index] != &#39;)&#39;) {
441       ssize_t res = is_valid_type(&amp;method_sig[index], len - index);
442       if (res == -1) {
443         return false;
444       } else {
445         index += res;
446       }
447     }
448     if (index &lt; len &amp;&amp; method_sig[index] == &#39;)&#39;) {
449       // check the return type
450       ++index;
451       return (is_valid_type(&amp;method_sig[index], len - index) == (len - index));
452     }
453   }
454   return false;
455 }
456 
457 bool SignatureVerifier::is_valid_type_signature(Symbol* sig) {
458   const char* type_sig = (const char*)sig-&gt;bytes();
459   ssize_t len = sig-&gt;utf8_length();
460   return (type_sig != NULL &amp;&amp; len &gt;= 1 &amp;&amp;
461           (is_valid_type(type_sig, len) == len));
462 }
463 
464 // Checks to see if the type (not to go beyond &#39;limit&#39;) refers to a valid type.
465 // Returns -1 if it is not, or the index of the next character that is not part
466 // of the type.  The type encoding may end before &#39;limit&#39; and that&#39;s ok.
467 ssize_t SignatureVerifier::is_valid_type(const char* type, ssize_t limit) {
468   ssize_t index = 0;
469 
470   // Iterate over any number of array dimensions
471   while (index &lt; limit &amp;&amp; type[index] == &#39;[&#39;) ++index;
472   if (index &gt;= limit) {
473     return -1;
474   }
475   switch (type[index]) {
476     case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;F&#39;: case &#39;I&#39;:
477     case &#39;J&#39;: case &#39;S&#39;: case &#39;Z&#39;: case &#39;V&#39;:
478       return index + 1;
479     case &#39;L&#39;:
480       for (index = index + 1; index &lt; limit; ++index) {
481         char c = type[index];
482         switch (c) {
483           case &#39;;&#39;:
484             return index + 1;
485           case &#39;\0&#39;: case &#39;.&#39;: case &#39;[&#39;:
486             return -1;
487           default: ; // fall through
488         }
489       }
490       // fall through
491     default: ; // fall through
492   }
493   return -1;
494 }
495 #endif // ASSERT
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/deoptimization.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="biasedLocking.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/deoptimization.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,9 ---</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,55 ***</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jvm.h&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/debugInfoRec.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;code/pcDesc.hpp&quot;
  #include &quot;code/scopeDesc.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/constantPool.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.hpp&quot;</span>
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
  #include &quot;oops/verifyOopClosure.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
<span class="line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/signature.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
  #include &quot;runtime/vframe.hpp&quot;
  #include &quot;runtime/vframeArray.hpp&quot;
  #include &quot;runtime/vframe_hp.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/preserveException.hpp&quot;
  #include &quot;utilities/xmlstream.hpp&quot;
<span class="line-modified">! </span>
<span class="line-modified">! #if INCLUDE_JVMCI</span>
<span class="line-modified">! #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
<span class="line-removed">- #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
  #endif
  
<span class="line-removed">- </span>
  bool DeoptimizationMarker::_is_active = false;
  
  Deoptimization::UnrollBlock::UnrollBlock(int  size_of_deoptimized_frame,
                                           int  caller_adjustment,
                                           int  caller_actual_parameters,
<span class="line-new-header">--- 24,61 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jvm.h&quot;
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/debugInfoRec.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;code/pcDesc.hpp&quot;
  #include &quot;code/scopeDesc.hpp&quot;
<span class="line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/constantPool.hpp&quot;
  #include &quot;oops/method.hpp&quot;
<span class="line-added">+ #include &quot;oops/objArrayKlass.hpp&quot;</span>
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified">! #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
  #include &quot;oops/verifyOopClosure.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/deoptimization.hpp&quot;
<span class="line-added">+ #include &quot;runtime/fieldDescriptor.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/jniHandles.inline.hpp&quot;</span>
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/signature.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
  #include &quot;runtime/vframe.hpp&quot;
  #include &quot;runtime/vframeArray.hpp&quot;
  #include &quot;runtime/vframe_hp.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
<span class="line-added">+ #include &quot;utilities/macros.hpp&quot;</span>
  #include &quot;utilities/preserveException.hpp&quot;
  #include &quot;utilities/xmlstream.hpp&quot;
<span class="line-modified">! #if INCLUDE_JFR</span>
<span class="line-modified">! #include &quot;jfr/jfrEvents.hpp&quot;</span>
<span class="line-modified">! #include &quot;jfr/metadata/jfrSerializer.hpp&quot;</span>
  #endif
  
  bool DeoptimizationMarker::_is_active = false;
  
  Deoptimization::UnrollBlock::UnrollBlock(int  size_of_deoptimized_frame,
                                           int  caller_adjustment,
                                           int  caller_actual_parameters,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,10 ***</span>
<span class="line-new-header">--- 162,96 ---</span>
    thread-&gt;inc_in_deopt_handler();
  
    return fetch_unroll_info_helper(thread, exec_mode);
  JRT_END
  
<span class="line-added">+ #if COMPILER2_OR_JVMCI</span>
<span class="line-added">+ static bool eliminate_allocations(JavaThread* thread, int exec_mode, CompiledMethod* compiled_method,</span>
<span class="line-added">+                                   frame&amp; deoptee, RegisterMap&amp; map, GrowableArray&lt;compiledVFrame*&gt;* chunk) {</span>
<span class="line-added">+   bool realloc_failures = false;</span>
<span class="line-added">+   assert (chunk-&gt;at(0)-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   GrowableArray&lt;ScopeValue*&gt;* objects = chunk-&gt;at(0)-&gt;scope()-&gt;objects();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // The flag return_oop() indicates call sites which return oop</span>
<span class="line-added">+   // in compiled code. Such sites include java method calls,</span>
<span class="line-added">+   // runtime calls (for example, used to allocate new objects/arrays</span>
<span class="line-added">+   // on slow code path) and any other calls generated in compiled code.</span>
<span class="line-added">+   // It is not guaranteed that we can get such information here only</span>
<span class="line-added">+   // by analyzing bytecode in deoptimized frames. This is why this flag</span>
<span class="line-added">+   // is set during method compilation (see Compile::Process_OopMap_Node()).</span>
<span class="line-added">+   // If the previous frame was popped or if we are dispatching an exception,</span>
<span class="line-added">+   // we don&#39;t have an oop result.</span>
<span class="line-added">+   bool save_oop_result = chunk-&gt;at(0)-&gt;scope()-&gt;return_oop() &amp;&amp; !thread-&gt;popframe_forcing_deopt_reexecution() &amp;&amp; (exec_mode == Deoptimization::Unpack_deopt);</span>
<span class="line-added">+   Handle return_value;</span>
<span class="line-added">+   if (save_oop_result) {</span>
<span class="line-added">+     // Reallocation may trigger GC. If deoptimization happened on return from</span>
<span class="line-added">+     // call which returns oop we need to save it since it is not in oopmap.</span>
<span class="line-added">+     oop result = deoptee.saved_oop_result(&amp;map);</span>
<span class="line-added">+     assert(oopDesc::is_oop_or_null(result), &quot;must be oop&quot;);</span>
<span class="line-added">+     return_value = Handle(thread, result);</span>
<span class="line-added">+     assert(Universe::heap()-&gt;is_in_or_null(result), &quot;must be heap pointer&quot;);</span>
<span class="line-added">+     if (TraceDeoptimization) {</span>
<span class="line-added">+       ttyLocker ttyl;</span>
<span class="line-added">+       tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (objects != NULL) {</span>
<span class="line-added">+     JRT_BLOCK</span>
<span class="line-added">+       realloc_failures = Deoptimization::realloc_objects(thread, &amp;deoptee, &amp;map, objects, THREAD);</span>
<span class="line-added">+     JRT_END</span>
<span class="line-added">+     bool skip_internal = (compiled_method != NULL) &amp;&amp; !compiled_method-&gt;is_compiled_by_jvmci();</span>
<span class="line-added">+     Deoptimization::reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal);</span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+     if (TraceDeoptimization) {</span>
<span class="line-added">+       ttyLocker ttyl;</span>
<span class="line-added">+       tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));</span>
<span class="line-added">+       Deoptimization::print_objects(objects, realloc_failures);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (save_oop_result) {</span>
<span class="line-added">+     // Restore result.</span>
<span class="line-added">+     deoptee.set_saved_oop_result(&amp;map, return_value());</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return realloc_failures;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void eliminate_locks(JavaThread* thread, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {</span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+   bool first = true;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   for (int i = 0; i &lt; chunk-&gt;length(); i++) {</span>
<span class="line-added">+     compiledVFrame* cvf = chunk-&gt;at(i);</span>
<span class="line-added">+     assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);</span>
<span class="line-added">+     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();</span>
<span class="line-added">+     if (monitors-&gt;is_nonempty()) {</span>
<span class="line-added">+       Deoptimization::relock_objects(monitors, thread, realloc_failures);</span>
<span class="line-added">+ #ifndef PRODUCT</span>
<span class="line-added">+       if (PrintDeoptimizationDetails) {</span>
<span class="line-added">+         ttyLocker ttyl;</span>
<span class="line-added">+         for (int j = 0; j &lt; monitors-&gt;length(); j++) {</span>
<span class="line-added">+           MonitorInfo* mi = monitors-&gt;at(j);</span>
<span class="line-added">+           if (mi-&gt;eliminated()) {</span>
<span class="line-added">+             if (first) {</span>
<span class="line-added">+               first = false;</span>
<span class="line-added">+               tty-&gt;print_cr(&quot;RELOCK OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (mi-&gt;owner_is_scalar_replaced()) {</span>
<span class="line-added">+               Klass* k = java_lang_Class::as_Klass(mi-&gt;owner_klass());</span>
<span class="line-added">+               tty-&gt;print_cr(&quot;     failed reallocation for klass %s&quot;, k-&gt;external_name());</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+               tty-&gt;print_cr(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; locked&quot;, p2i(mi-&gt;owner()));</span>
<span class="line-added">+             }</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ #endif // !PRODUCT</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // COMPILER2_OR_JVMCI</span>
  
  // This is factored, since it is both called from a JRT_LEAF (deoptimization) and a JRT_ENTRY (uncommon_trap)
  Deoptimization::UnrollBlock* Deoptimization::fetch_unroll_info_helper(JavaThread* thread, int exec_mode) {
  
    // Note: there is a safepoint safety issue here. No matter whether we enter
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,99 ***</span>
    chunk-&gt;push(compiledVFrame::cast(vf));
  
    bool realloc_failures = false;
  
  #if COMPILER2_OR_JVMCI
    // Reallocate the non-escaping objects and restore their fields. Then
    // relock objects if synchronization on them was eliminated.
<span class="line-modified">! #if !INCLUDE_JVMCI</span>
<span class="line-modified">!   if (DoEscapeAnalysis || EliminateNestedLocks) {</span>
<span class="line-modified">!     if (EliminateAllocations) {</span>
<span class="line-modified">! #endif // INCLUDE_JVMCI</span>
<span class="line-modified">!       assert (chunk-&gt;at(0)-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);</span>
<span class="line-modified">!       GrowableArray&lt;ScopeValue*&gt;* objects = chunk-&gt;at(0)-&gt;scope()-&gt;objects();</span>
<span class="line-modified">! </span>
<span class="line-modified">!       // The flag return_oop() indicates call sites which return oop</span>
<span class="line-modified">!       // in compiled code. Such sites include java method calls,</span>
<span class="line-modified">!       // runtime calls (for example, used to allocate new objects/arrays</span>
<span class="line-modified">!       // on slow code path) and any other calls generated in compiled code.</span>
<span class="line-modified">!       // It is not guaranteed that we can get such information here only</span>
<span class="line-modified">!       // by analyzing bytecode in deoptimized frames. This is why this flag</span>
<span class="line-modified">!       // is set during method compilation (see Compile::Process_OopMap_Node()).</span>
<span class="line-modified">!       // If the previous frame was popped or if we are dispatching an exception,</span>
<span class="line-modified">!       // we don&#39;t have an oop result.</span>
<span class="line-modified">!       bool save_oop_result = chunk-&gt;at(0)-&gt;scope()-&gt;return_oop() &amp;&amp; !thread-&gt;popframe_forcing_deopt_reexecution() &amp;&amp; (exec_mode == Unpack_deopt);</span>
<span class="line-modified">!       Handle return_value;</span>
<span class="line-removed">-       if (save_oop_result) {</span>
<span class="line-removed">-         // Reallocation may trigger GC. If deoptimization happened on return from</span>
<span class="line-removed">-         // call which returns oop we need to save it since it is not in oopmap.</span>
<span class="line-removed">-         oop result = deoptee.saved_oop_result(&amp;map);</span>
<span class="line-removed">-         assert(oopDesc::is_oop_or_null(result), &quot;must be oop&quot;);</span>
<span class="line-removed">-         return_value = Handle(thread, result);</span>
<span class="line-removed">-         assert(Universe::heap()-&gt;is_in_or_null(result), &quot;must be heap pointer&quot;);</span>
<span class="line-removed">-         if (TraceDeoptimization) {</span>
<span class="line-removed">-           ttyLocker ttyl;</span>
<span class="line-removed">-           tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (objects != NULL) {</span>
<span class="line-removed">-         JRT_BLOCK</span>
<span class="line-removed">-           realloc_failures = realloc_objects(thread, &amp;deoptee, objects, THREAD);</span>
<span class="line-removed">-         JRT_END</span>
<span class="line-removed">-         bool skip_internal = (cm != NULL) &amp;&amp; !cm-&gt;is_compiled_by_jvmci();</span>
<span class="line-removed">-         reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal);</span>
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-         if (TraceDeoptimization) {</span>
<span class="line-removed">-           ttyLocker ttyl;</span>
<span class="line-removed">-           tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));</span>
<span class="line-removed">-           print_objects(objects, realloc_failures);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (save_oop_result) {</span>
<span class="line-removed">-         // Restore result.</span>
<span class="line-removed">-         deoptee.set_saved_oop_result(&amp;map, return_value());</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- #if !INCLUDE_JVMCI</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (EliminateLocks) {</span>
<span class="line-removed">- #endif // INCLUDE_JVMCI</span>
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-       bool first = true;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-       for (int i = 0; i &lt; chunk-&gt;length(); i++) {</span>
<span class="line-removed">-         compiledVFrame* cvf = chunk-&gt;at(i);</span>
<span class="line-removed">-         assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);</span>
<span class="line-removed">-         GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();</span>
<span class="line-removed">-         if (monitors-&gt;is_nonempty()) {</span>
<span class="line-removed">-           relock_objects(monitors, thread, realloc_failures);</span>
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-           if (PrintDeoptimizationDetails) {</span>
<span class="line-removed">-             ttyLocker ttyl;</span>
<span class="line-removed">-             for (int j = 0; j &lt; monitors-&gt;length(); j++) {</span>
<span class="line-removed">-               MonitorInfo* mi = monitors-&gt;at(j);</span>
<span class="line-removed">-               if (mi-&gt;eliminated()) {</span>
<span class="line-removed">-                 if (first) {</span>
<span class="line-removed">-                   first = false;</span>
<span class="line-removed">-                   tty-&gt;print_cr(&quot;RELOCK OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (mi-&gt;owner_is_scalar_replaced()) {</span>
<span class="line-removed">-                   Klass* k = java_lang_Class::as_Klass(mi-&gt;owner_klass());</span>
<span class="line-removed">-                   tty-&gt;print_cr(&quot;     failed reallocation for klass %s&quot;, k-&gt;external_name());</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                   tty-&gt;print_cr(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; locked&quot;, p2i(mi-&gt;owner()));</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-           }</span>
<span class="line-removed">- #endif // !PRODUCT</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- #if !INCLUDE_JVMCI</span>
<span class="line-removed">-     }</span>
    }
<span class="line-removed">- #endif // INCLUDE_JVMCI</span>
  #endif // COMPILER2_OR_JVMCI
  
    ScopeDesc* trap_scope = chunk-&gt;at(0)-&gt;scope();
    Handle exceptionObject;
    if (trap_scope-&gt;rethrow_exception()) {
<span class="line-new-header">--- 292,37 ---</span>
    chunk-&gt;push(compiledVFrame::cast(vf));
  
    bool realloc_failures = false;
  
  #if COMPILER2_OR_JVMCI
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+   bool jvmci_enabled = true;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+   bool jvmci_enabled = false;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
    // Reallocate the non-escaping objects and restore their fields. Then
    // relock objects if synchronization on them was eliminated.
<span class="line-modified">!   if (jvmci_enabled COMPILER2_PRESENT( || (DoEscapeAnalysis &amp;&amp; EliminateAllocations) )) {</span>
<span class="line-modified">!     realloc_failures = eliminate_allocations(thread, exec_mode, cm, deoptee, map, chunk);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! #endif // COMPILER2_OR_JVMCI</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Revoke biases, done with in java state.</span>
<span class="line-modified">!   // No safepoints allowed after this</span>
<span class="line-modified">!   revoke_from_deopt_handler(thread, deoptee, &amp;map);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Ensure that no safepoint is taken after pointers have been stored</span>
<span class="line-modified">!   // in fields of rematerialized objects.  If a safepoint occurs from here on</span>
<span class="line-modified">!   // out the java state residing in the vframeArray will be missed.</span>
<span class="line-modified">!   // Locks may be rebaised in a safepoint.</span>
<span class="line-modified">!   NoSafepointVerifier no_safepoint;</span>
<span class="line-modified">! </span>
<span class="line-modified">! #if COMPILER2_OR_JVMCI</span>
<span class="line-modified">!   if (jvmci_enabled COMPILER2_PRESENT( || ((DoEscapeAnalysis || EliminateNestedLocks) &amp;&amp; EliminateLocks) )) {</span>
<span class="line-modified">!     eliminate_locks(thread, chunk, realloc_failures);</span>
    }
  #endif // COMPILER2_OR_JVMCI
  
    ScopeDesc* trap_scope = chunk-&gt;at(0)-&gt;scope();
    Handle exceptionObject;
    if (trap_scope-&gt;rethrow_exception()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,15 ***</span>
      ScopeValue* topOfStack = expressions-&gt;top();
      exceptionObject = StackValue::create_stack_value(&amp;deoptee, &amp;map, topOfStack)-&gt;get_obj();
      guarantee(exceptionObject() != NULL, &quot;exception oop can not be null&quot;);
    }
  
<span class="line-removed">-   // Ensure that no safepoint is taken after pointers have been stored</span>
<span class="line-removed">-   // in fields of rematerialized objects.  If a safepoint occurs from here on</span>
<span class="line-removed">-   // out the java state residing in the vframeArray will be missed.</span>
<span class="line-removed">-   NoSafepointVerifier no_safepoint;</span>
<span class="line-removed">- </span>
    vframeArray* array = create_vframeArray(thread, deoptee, &amp;map, chunk, realloc_failures);
  #if COMPILER2_OR_JVMCI
    if (realloc_failures) {
      pop_frames_failed_reallocs(thread, array);
    }
<span class="line-new-header">--- 334,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 406,11 ***</span>
    // handles are used.  If the caller is interpreted get the real
    // value so that the proper amount of space can be added to it&#39;s
    // frame.
    bool caller_was_method_handle = false;
    if (deopt_sender.is_interpreted_frame()) {
<span class="line-modified">!     methodHandle method = deopt_sender.interpreter_frame_method();</span>
      Bytecode_invoke cur = Bytecode_invoke_check(method, deopt_sender.interpreter_frame_bci());
      if (cur.is_invokedynamic() || cur.is_invokehandle()) {
        // Method handle invokes may involve fairly arbitrary chains of
        // calls so it&#39;s impossible to know how much actual space the
        // caller has for locals.
<span class="line-new-header">--- 433,11 ---</span>
    // handles are used.  If the caller is interpreted get the real
    // value so that the proper amount of space can be added to it&#39;s
    // frame.
    bool caller_was_method_handle = false;
    if (deopt_sender.is_interpreted_frame()) {
<span class="line-modified">!     methodHandle method(thread, deopt_sender.interpreter_frame_method());</span>
      Bytecode_invoke cur = Bytecode_invoke_check(method, deopt_sender.interpreter_frame_bci());
      if (cur.is_invokedynamic() || cur.is_invokehandle()) {
        // Method handle invokes may involve fairly arbitrary chains of
        // calls so it&#39;s impossible to know how much actual space the
        // caller has for locals.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 629,11 ***</span>
      ttyLocker ttyl;
      tty-&gt;print_cr(&quot;DEOPT UNPACKING thread &quot; INTPTR_FORMAT &quot; vframeArray &quot; INTPTR_FORMAT &quot; mode %d&quot;,
                    p2i(thread), p2i(array), exec_mode);
    }
  #endif
<span class="line-modified">!   Events::log(thread, &quot;DEOPT UNPACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT &quot; mode %d&quot;,</span>
                p2i(stub_frame.pc()), p2i(stub_frame.sp()), exec_mode);
  
    UnrollBlock* info = array-&gt;unroll_block();
  
    // Unpack the interpreter frames and any adapter frame (c2 only) we might create.
<span class="line-new-header">--- 656,11 ---</span>
      ttyLocker ttyl;
      tty-&gt;print_cr(&quot;DEOPT UNPACKING thread &quot; INTPTR_FORMAT &quot; vframeArray &quot; INTPTR_FORMAT &quot; mode %d&quot;,
                    p2i(thread), p2i(array), exec_mode);
    }
  #endif
<span class="line-modified">!   Events::log_deopt_message(thread, &quot;DEOPT UNPACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT &quot; mode %d&quot;,</span>
                p2i(stub_frame.pc()), p2i(stub_frame.sp()), exec_mode);
  
    UnrollBlock* info = array-&gt;unroll_block();
  
    // Unpack the interpreter frames and any adapter frame (c2 only) we might create.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 677,12 ***</span>
        bool try_next_mask = false;
        int next_mask_expression_stack_size = -1;
        int top_frame_expression_stack_adjustment = 0;
        methodHandle mh(thread, iframe-&gt;interpreter_frame_method());
        OopMapCache::compute_one_oop_map(mh, iframe-&gt;interpreter_frame_bci(), &amp;mask);
<span class="line-modified">!       BytecodeStream str(mh);</span>
<span class="line-removed">-       str.set_start(iframe-&gt;interpreter_frame_bci());</span>
        int max_bci = mh-&gt;code_size();
        // Get to the next bytecode if possible
        assert(str.bci() &lt; max_bci, &quot;bci in interpreter frame out of bounds&quot;);
        // Check to see if we can grab the number of outgoing arguments
        // at an uncommon trap for an invoke (where the compiler
<span class="line-new-header">--- 704,11 ---</span>
        bool try_next_mask = false;
        int next_mask_expression_stack_size = -1;
        int top_frame_expression_stack_adjustment = 0;
        methodHandle mh(thread, iframe-&gt;interpreter_frame_method());
        OopMapCache::compute_one_oop_map(mh, iframe-&gt;interpreter_frame_bci(), &amp;mask);
<span class="line-modified">!       BytecodeStream str(mh, iframe-&gt;interpreter_frame_bci());</span>
        int max_bci = mh-&gt;code_size();
        // Get to the next bytecode if possible
        assert(str.bci() &lt; max_bci, &quot;bci in interpreter frame out of bounds&quot;);
        // Check to see if we can grab the number of outgoing arguments
        // at an uncommon trap for an invoke (where the compiler
</pre>
<hr />
<pre>
<span class="line-old-header">*** 777,21 ***</span>
  
  
    return bt;
  JRT_END
  
  
<span class="line-modified">! int Deoptimization::deoptimize_dependents() {</span>
<span class="line-modified">!   Threads::deoptimized_wrt_marked_nmethods();</span>
<span class="line-modified">!   return 0;</span>
  }
  
  Deoptimization::DeoptAction Deoptimization::_unloaded_action
    = Deoptimization::Action_reinterpret;
  
  #if COMPILER2_OR_JVMCI
<span class="line-modified">! bool Deoptimization::realloc_objects(JavaThread* thread, frame* fr, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {</span>
    Handle pending_exception(THREAD, thread-&gt;pending_exception());
    const char* exception_file = thread-&gt;exception_file();
    int exception_line = thread-&gt;exception_line();
    thread-&gt;clear_pending_exception();
  
<span class="line-new-header">--- 803,178 ---</span>
  
  
    return bt;
  JRT_END
  
<span class="line-added">+ class DeoptimizeMarkedClosure : public HandshakeClosure {</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   DeoptimizeMarkedClosure() : HandshakeClosure(&quot;Deoptimize&quot;) {}</span>
<span class="line-added">+   void do_thread(Thread* thread) {</span>
<span class="line-added">+     JavaThread* jt = (JavaThread*)thread;</span>
<span class="line-added">+     jt-&gt;deoptimize_marked_methods();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Deoptimization::deoptimize_all_marked(nmethod* nmethod_only) {</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+   DeoptimizationMarker dm;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Make the dependent methods not entrant</span>
<span class="line-added">+   if (nmethod_only != NULL) {</span>
<span class="line-added">+     nmethod_only-&gt;mark_for_deoptimization();</span>
<span class="line-added">+     nmethod_only-&gt;make_not_entrant();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+     CodeCache::make_marked_nmethods_not_entrant();</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   DeoptimizeMarkedClosure deopt;</span>
<span class="line-modified">!   if (SafepointSynchronize::is_at_safepoint()) {</span>
<span class="line-modified">!     Threads::java_threads_do(&amp;deopt);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     Handshake::execute(&amp;deopt);</span>
<span class="line-added">+   }</span>
  }
  
  Deoptimization::DeoptAction Deoptimization::_unloaded_action
    = Deoptimization::Action_reinterpret;
  
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_JVMCI || INCLUDE_AOT</span>
<span class="line-added">+ template&lt;typename CacheType&gt;</span>
<span class="line-added">+ class BoxCacheBase : public CHeapObj&lt;mtCompiler&gt; {</span>
<span class="line-added">+ protected:</span>
<span class="line-added">+   static InstanceKlass* find_cache_klass(Symbol* klass_name, TRAPS) {</span>
<span class="line-added">+     ResourceMark rm;</span>
<span class="line-added">+     char* klass_name_str = klass_name-&gt;as_C_string();</span>
<span class="line-added">+     Klass* k = SystemDictionary::find(klass_name, Handle(), Handle(), THREAD);</span>
<span class="line-added">+     guarantee(k != NULL, &quot;%s must be loaded&quot;, klass_name_str);</span>
<span class="line-added">+     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">+     guarantee(ik-&gt;is_initialized(), &quot;%s must be initialized&quot;, klass_name_str);</span>
<span class="line-added">+     CacheType::compute_offsets(ik);</span>
<span class="line-added">+     return ik;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename PrimitiveType, typename CacheType, typename BoxType&gt; class BoxCache  : public BoxCacheBase&lt;CacheType&gt; {</span>
<span class="line-added">+   PrimitiveType _low;</span>
<span class="line-added">+   PrimitiveType _high;</span>
<span class="line-added">+   jobject _cache;</span>
<span class="line-added">+ protected:</span>
<span class="line-added">+   static BoxCache&lt;PrimitiveType, CacheType, BoxType&gt; *_singleton;</span>
<span class="line-added">+   BoxCache(Thread* thread) {</span>
<span class="line-added">+     InstanceKlass* ik = BoxCacheBase&lt;CacheType&gt;::find_cache_klass(CacheType::symbol(), thread);</span>
<span class="line-added">+     objArrayOop cache = CacheType::cache(ik);</span>
<span class="line-added">+     assert(cache-&gt;length() &gt; 0, &quot;Empty cache&quot;);</span>
<span class="line-added">+     _low = BoxType::value(cache-&gt;obj_at(0));</span>
<span class="line-added">+     _high = _low + cache-&gt;length() - 1;</span>
<span class="line-added">+     _cache = JNIHandles::make_global(Handle(thread, cache));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   ~BoxCache() {</span>
<span class="line-added">+     JNIHandles::destroy_global(_cache);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   static BoxCache&lt;PrimitiveType, CacheType, BoxType&gt;* singleton(Thread* thread) {</span>
<span class="line-added">+     if (_singleton == NULL) {</span>
<span class="line-added">+       BoxCache&lt;PrimitiveType, CacheType, BoxType&gt;* s = new BoxCache&lt;PrimitiveType, CacheType, BoxType&gt;(thread);</span>
<span class="line-added">+       if (!Atomic::replace_if_null(&amp;_singleton, s)) {</span>
<span class="line-added">+         delete s;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return _singleton;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   oop lookup(PrimitiveType value) {</span>
<span class="line-added">+     if (_low &lt;= value &amp;&amp; value &lt;= _high) {</span>
<span class="line-added">+       int offset = value - _low;</span>
<span class="line-added">+       return objArrayOop(JNIHandles::resolve_non_null(_cache))-&gt;obj_at(offset);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   oop lookup_raw(intptr_t raw_value) {</span>
<span class="line-added">+     // Have to cast to avoid little/big-endian problems.</span>
<span class="line-added">+     if (sizeof(PrimitiveType) &gt; sizeof(jint)) {</span>
<span class="line-added">+       jlong value = (jlong)raw_value;</span>
<span class="line-added">+       return lookup(value);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     PrimitiveType value = (PrimitiveType)*((jint*)&amp;raw_value);</span>
<span class="line-added">+     return lookup(value);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ typedef BoxCache&lt;jint, java_lang_Integer_IntegerCache, java_lang_Integer&gt; IntegerBoxCache;</span>
<span class="line-added">+ typedef BoxCache&lt;jlong, java_lang_Long_LongCache, java_lang_Long&gt; LongBoxCache;</span>
<span class="line-added">+ typedef BoxCache&lt;jchar, java_lang_Character_CharacterCache, java_lang_Character&gt; CharacterBoxCache;</span>
<span class="line-added">+ typedef BoxCache&lt;jshort, java_lang_Short_ShortCache, java_lang_Short&gt; ShortBoxCache;</span>
<span class="line-added">+ typedef BoxCache&lt;jbyte, java_lang_Byte_ByteCache, java_lang_Byte&gt; ByteBoxCache;</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;&gt; BoxCache&lt;jint, java_lang_Integer_IntegerCache, java_lang_Integer&gt;* BoxCache&lt;jint, java_lang_Integer_IntegerCache, java_lang_Integer&gt;::_singleton = NULL;</span>
<span class="line-added">+ template&lt;&gt; BoxCache&lt;jlong, java_lang_Long_LongCache, java_lang_Long&gt;* BoxCache&lt;jlong, java_lang_Long_LongCache, java_lang_Long&gt;::_singleton = NULL;</span>
<span class="line-added">+ template&lt;&gt; BoxCache&lt;jchar, java_lang_Character_CharacterCache, java_lang_Character&gt;* BoxCache&lt;jchar, java_lang_Character_CharacterCache, java_lang_Character&gt;::_singleton = NULL;</span>
<span class="line-added">+ template&lt;&gt; BoxCache&lt;jshort, java_lang_Short_ShortCache, java_lang_Short&gt;* BoxCache&lt;jshort, java_lang_Short_ShortCache, java_lang_Short&gt;::_singleton = NULL;</span>
<span class="line-added">+ template&lt;&gt; BoxCache&lt;jbyte, java_lang_Byte_ByteCache, java_lang_Byte&gt;* BoxCache&lt;jbyte, java_lang_Byte_ByteCache, java_lang_Byte&gt;::_singleton = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ class BooleanBoxCache : public BoxCacheBase&lt;java_lang_Boolean&gt; {</span>
<span class="line-added">+   jobject _true_cache;</span>
<span class="line-added">+   jobject _false_cache;</span>
<span class="line-added">+ protected:</span>
<span class="line-added">+   static BooleanBoxCache *_singleton;</span>
<span class="line-added">+   BooleanBoxCache(Thread *thread) {</span>
<span class="line-added">+     InstanceKlass* ik = find_cache_klass(java_lang_Boolean::symbol(), thread);</span>
<span class="line-added">+     _true_cache = JNIHandles::make_global(Handle(thread, java_lang_Boolean::get_TRUE(ik)));</span>
<span class="line-added">+     _false_cache = JNIHandles::make_global(Handle(thread, java_lang_Boolean::get_FALSE(ik)));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   ~BooleanBoxCache() {</span>
<span class="line-added">+     JNIHandles::destroy_global(_true_cache);</span>
<span class="line-added">+     JNIHandles::destroy_global(_false_cache);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   static BooleanBoxCache* singleton(Thread* thread) {</span>
<span class="line-added">+     if (_singleton == NULL) {</span>
<span class="line-added">+       BooleanBoxCache* s = new BooleanBoxCache(thread);</span>
<span class="line-added">+       if (!Atomic::replace_if_null(&amp;_singleton, s)) {</span>
<span class="line-added">+         delete s;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return _singleton;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   oop lookup_raw(intptr_t raw_value) {</span>
<span class="line-added">+     // Have to cast to avoid little/big-endian problems.</span>
<span class="line-added">+     jboolean value = (jboolean)*((jint*)&amp;raw_value);</span>
<span class="line-added">+     return lookup(value);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   oop lookup(jboolean value) {</span>
<span class="line-added">+     if (value != 0) {</span>
<span class="line-added">+       return JNIHandles::resolve_non_null(_true_cache);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return JNIHandles::resolve_non_null(_false_cache);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ BooleanBoxCache* BooleanBoxCache::_singleton = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+ oop Deoptimization::get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, TRAPS) {</span>
<span class="line-added">+    Klass* k = java_lang_Class::as_Klass(bv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());</span>
<span class="line-added">+    BasicType box_type = SystemDictionary::box_klass_type(k);</span>
<span class="line-added">+    if (box_type != T_OBJECT) {</span>
<span class="line-added">+      StackValue* value = StackValue::create_stack_value(fr, reg_map, bv-&gt;field_at(box_type == T_LONG ? 1 : 0));</span>
<span class="line-added">+      switch(box_type) {</span>
<span class="line-added">+        case T_INT:     return IntegerBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added">+        case T_CHAR:    return CharacterBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added">+        case T_SHORT:   return ShortBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added">+        case T_BYTE:    return ByteBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added">+        case T_BOOLEAN: return BooleanBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added">+        case T_LONG:    return LongBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added">+        default:;</span>
<span class="line-added">+      }</span>
<span class="line-added">+    }</span>
<span class="line-added">+    return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // INCLUDE_JVMCI || INCLUDE_AOT</span>
<span class="line-added">+ </span>
  #if COMPILER2_OR_JVMCI
<span class="line-modified">! bool Deoptimization::realloc_objects(JavaThread* thread, frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {</span>
    Handle pending_exception(THREAD, thread-&gt;pending_exception());
    const char* exception_file = thread-&gt;exception_file();
    int exception_line = thread-&gt;exception_line();
    thread-&gt;clear_pending_exception();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 803,12 ***</span>
  
      Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
      oop obj = NULL;
  
      if (k-&gt;is_instance_klass()) {
        InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">!       obj = ik-&gt;allocate_instance(THREAD);</span>
      } else if (k-&gt;is_typeArray_klass()) {
        TypeArrayKlass* ak = TypeArrayKlass::cast(k);
        assert(sv-&gt;field_size() % type2size[ak-&gt;element_type()] == 0, &quot;non-integral array length&quot;);
        int len = sv-&gt;field_size() / type2size[ak-&gt;element_type()];
        obj = ak-&gt;allocate(len, THREAD);
<span class="line-new-header">--- 986,25 ---</span>
  
      Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
      oop obj = NULL;
  
      if (k-&gt;is_instance_klass()) {
<span class="line-added">+ #if INCLUDE_JVMCI || INCLUDE_AOT</span>
<span class="line-added">+       CompiledMethod* cm = fr-&gt;cb()-&gt;as_compiled_method_or_null();</span>
<span class="line-added">+       if (cm-&gt;is_compiled_by_jvmci() &amp;&amp; sv-&gt;is_auto_box()) {</span>
<span class="line-added">+         AutoBoxObjectValue* abv = (AutoBoxObjectValue*) sv;</span>
<span class="line-added">+         obj = get_cached_box(abv, fr, reg_map, THREAD);</span>
<span class="line-added">+         if (obj != NULL) {</span>
<span class="line-added">+           // Set the flag to indicate the box came from a cache, so that we can skip the field reassignment for it.</span>
<span class="line-added">+           abv-&gt;set_cached(true);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ #endif // INCLUDE_JVMCI || INCLUDE_AOT</span>
        InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">!       if (obj == NULL) {</span>
<span class="line-added">+         obj = ik-&gt;allocate_instance(THREAD);</span>
<span class="line-added">+       }</span>
      } else if (k-&gt;is_typeArray_klass()) {
        TypeArrayKlass* ak = TypeArrayKlass::cast(k);
        assert(sv-&gt;field_size() % type2size[ak-&gt;element_type()] == 0, &quot;non-integral array length&quot;);
        int len = sv-&gt;field_size() / type2size[ak-&gt;element_type()];
        obj = ak-&gt;allocate(len, THREAD);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 958,22 ***</span>
  }
  
  // Restore fields of an eliminated instance object using the same field order
  // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
  static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal) {
<span class="line-removed">-   if (klass-&gt;superklass() != NULL) {</span>
<span class="line-removed">-     svIndex = reassign_fields_by_klass(klass-&gt;superklass(), fr, reg_map, sv, svIndex, obj, skip_internal);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
<span class="line-modified">!   for (AllFieldStream fs(klass); !fs.done(); fs.next()) {</span>
<span class="line-modified">!     if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {</span>
<span class="line-modified">!       ReassignedField field;</span>
<span class="line-modified">!       field._offset = fs.offset();</span>
<span class="line-modified">!       field._type = FieldType::basic_type(fs.signature());</span>
<span class="line-modified">!       fields-&gt;append(field);</span>
      }
    }
    fields-&gt;sort(compare);
    for (int i = 0; i &lt; fields-&gt;length(); i++) {
      intptr_t val;
      ScopeValue* scope_field = sv-&gt;field_at(svIndex);
<span class="line-new-header">--- 1154,22 ---</span>
  }
  
  // Restore fields of an eliminated instance object using the same field order
  // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
  static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal) {
    GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
<span class="line-modified">!   InstanceKlass* ik = klass;</span>
<span class="line-modified">!   while (ik != NULL) {</span>
<span class="line-modified">!     for (AllFieldStream fs(ik); !fs.done(); fs.next()) {</span>
<span class="line-modified">!       if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {</span>
<span class="line-modified">!         ReassignedField field;</span>
<span class="line-modified">!         field._offset = fs.offset();</span>
<span class="line-added">+         field._type = Signature::basic_type(fs.signature());</span>
<span class="line-added">+         fields-&gt;append(field);</span>
<span class="line-added">+       }</span>
      }
<span class="line-added">+     ik = ik-&gt;superklass();</span>
    }
    fields-&gt;sort(compare);
    for (int i = 0; i &lt; fields-&gt;length(); i++) {
      intptr_t val;
      ScopeValue* scope_field = sv-&gt;field_at(svIndex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1077,11 ***</span>
        tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
      }
      if (obj.is_null()) {
        continue;
      }
<span class="line-modified">! </span>
      if (k-&gt;is_instance_klass()) {
        InstanceKlass* ik = InstanceKlass::cast(k);
        reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);
      } else if (k-&gt;is_typeArray_klass()) {
        TypeArrayKlass* ak = TypeArrayKlass::cast(k);
<span class="line-new-header">--- 1273,16 ---</span>
        tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
      }
      if (obj.is_null()) {
        continue;
      }
<span class="line-modified">! #if INCLUDE_JVMCI || INCLUDE_AOT</span>
<span class="line-added">+     // Don&#39;t reassign fields of boxes that came from a cache. Caches may be in CDS.</span>
<span class="line-added">+     if (sv-&gt;is_auto_box() &amp;&amp; ((AutoBoxObjectValue*) sv)-&gt;is_cached()) {</span>
<span class="line-added">+       continue;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif // INCLUDE_JVMCI || INCLUDE_AOT</span>
      if (k-&gt;is_instance_klass()) {
        InstanceKlass* ik = InstanceKlass::cast(k);
        reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);
      } else if (k-&gt;is_typeArray_klass()) {
        TypeArrayKlass* ak = TypeArrayKlass::cast(k);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1099,23 ***</span>
      MonitorInfo* mon_info = monitors-&gt;at(i);
      if (mon_info-&gt;eliminated()) {
        assert(!mon_info-&gt;owner_is_scalar_replaced() || realloc_failures, &quot;reallocation was missed&quot;);
        if (!mon_info-&gt;owner_is_scalar_replaced()) {
          Handle obj(thread, mon_info-&gt;owner());
<span class="line-modified">!         markOop mark = obj-&gt;mark();</span>
<span class="line-modified">!         if (UseBiasedLocking &amp;&amp; mark-&gt;has_bias_pattern()) {</span>
            // New allocated objects may have the mark set to anonymously biased.
            // Also the deoptimized method may called methods with synchronization
            // where the thread-local object is bias locked to the current thread.
<span class="line-modified">!           assert(mark-&gt;is_biased_anonymously() ||</span>
<span class="line-modified">!                  mark-&gt;biased_locker() == thread, &quot;should be locked to current thread&quot;);</span>
            // Reset mark word to unbiased prototype.
<span class="line-modified">!           markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span>
            obj-&gt;set_mark(unbiased_prototype);
          }
          BasicLock* lock = mon_info-&gt;lock();
<span class="line-modified">!         ObjectSynchronizer::slow_enter(obj, lock, thread);</span>
          assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
        }
      }
    }
  }
<span class="line-new-header">--- 1300,23 ---</span>
      MonitorInfo* mon_info = monitors-&gt;at(i);
      if (mon_info-&gt;eliminated()) {
        assert(!mon_info-&gt;owner_is_scalar_replaced() || realloc_failures, &quot;reallocation was missed&quot;);
        if (!mon_info-&gt;owner_is_scalar_replaced()) {
          Handle obj(thread, mon_info-&gt;owner());
<span class="line-modified">!         markWord mark = obj-&gt;mark();</span>
<span class="line-modified">!         if (UseBiasedLocking &amp;&amp; mark.has_bias_pattern()) {</span>
            // New allocated objects may have the mark set to anonymously biased.
            // Also the deoptimized method may called methods with synchronization
            // where the thread-local object is bias locked to the current thread.
<span class="line-modified">!           assert(mark.is_biased_anonymously() ||</span>
<span class="line-modified">!                  mark.biased_locker() == thread, &quot;should be locked to current thread&quot;);</span>
            // Reset mark word to unbiased prototype.
<span class="line-modified">!           markWord unbiased_prototype = markWord::prototype().set_age(mark.age());</span>
            obj-&gt;set_mark(unbiased_prototype);
          }
          BasicLock* lock = mon_info-&gt;lock();
<span class="line-modified">!         ObjectSynchronizer::enter(obj, lock, thread);</span>
          assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
        }
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1148,11 ***</span>
  }
  #endif
  #endif // COMPILER2_OR_JVMCI
  
  vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
<span class="line-modified">!   Events::log(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));</span>
  
  #ifndef PRODUCT
    if (PrintDeoptimizationDetails) {
      ttyLocker ttyl;
      tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
<span class="line-new-header">--- 1349,11 ---</span>
  }
  #endif
  #endif // COMPILER2_OR_JVMCI
  
  vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
<span class="line-modified">!   Events::log_deopt_message(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));</span>
  
  #ifndef PRODUCT
    if (PrintDeoptimizationDetails) {
      ttyLocker ttyl;
      tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1221,11 ***</span>
      MonitorChunk* monitors = array-&gt;element(i)-&gt;monitors();
      if (monitors != NULL) {
        for (int j = 0; j &lt; monitors-&gt;number_of_monitors(); j++) {
          BasicObjectLock* src = monitors-&gt;at(j);
          if (src-&gt;obj() != NULL) {
<span class="line-modified">!           ObjectSynchronizer::fast_exit(src-&gt;obj(), src-&gt;lock(), thread);</span>
          }
        }
        array-&gt;element(i)-&gt;free_monitors(thread);
  #ifdef ASSERT
        array-&gt;element(i)-&gt;set_removed_monitors();
<span class="line-new-header">--- 1422,11 ---</span>
      MonitorChunk* monitors = array-&gt;element(i)-&gt;monitors();
      if (monitors != NULL) {
        for (int j = 0; j &lt; monitors-&gt;number_of_monitors(); j++) {
          BasicObjectLock* src = monitors-&gt;at(j);
          if (src-&gt;obj() != NULL) {
<span class="line-modified">!           ObjectSynchronizer::exit(src-&gt;obj(), src-&gt;lock(), thread);</span>
          }
        }
        array-&gt;element(i)-&gt;free_monitors(thread);
  #ifdef ASSERT
        array-&gt;element(i)-&gt;set_removed_monitors();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1244,18 ***</span>
        objects_to_revoke-&gt;append(Handle(thread, mon_info-&gt;owner()));
      }
    }
  }
  
<span class="line-modified">! </span>
<span class="line-removed">- void Deoptimization::revoke_biases_of_monitors(JavaThread* thread, frame fr, RegisterMap* map) {</span>
<span class="line-removed">-   if (!UseBiasedLocking) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   GrowableArray&lt;Handle&gt;* objects_to_revoke = new GrowableArray&lt;Handle&gt;();</span>
<span class="line-removed">- </span>
    // Unfortunately we don&#39;t have a RegisterMap available in most of
    // the places we want to call this routine so we need to walk the
    // stack again to update the register map.
    if (map == NULL || !map-&gt;update_map()) {
      StackFrameStream sfs(thread, true);
<span class="line-new-header">--- 1445,11 ---</span>
        objects_to_revoke-&gt;append(Handle(thread, mon_info-&gt;owner()));
      }
    }
  }
  
<span class="line-modified">! static void get_monitors_from_stack(GrowableArray&lt;Handle&gt;* objects_to_revoke, JavaThread* thread, frame fr, RegisterMap* map) {</span>
    // Unfortunately we don&#39;t have a RegisterMap available in most of
    // the places we want to call this routine so we need to walk the
    // stack again to update the register map.
    if (map == NULL || !map-&gt;update_map()) {
      StackFrameStream sfs(thread, true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1275,15 ***</span>
    while (!cvf-&gt;is_top()) {
      collect_monitors(cvf, objects_to_revoke);
      cvf = compiledVFrame::cast(cvf-&gt;sender());
    }
    collect_monitors(cvf, objects_to_revoke);
  
<span class="line-modified">!   if (SafepointSynchronize::is_at_safepoint()) {</span>
<span class="line-modified">!     BiasedLocking::revoke_at_safepoint(objects_to_revoke);</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     BiasedLocking::revoke(objects_to_revoke);</span>
    }
  }
  
  
  void Deoptimization::deoptimize_single_frame(JavaThread* thread, frame fr, Deoptimization::DeoptReason reason) {
<span class="line-new-header">--- 1469,24 ---</span>
    while (!cvf-&gt;is_top()) {
      collect_monitors(cvf, objects_to_revoke);
      cvf = compiledVFrame::cast(cvf-&gt;sender());
    }
    collect_monitors(cvf, objects_to_revoke);
<span class="line-added">+ }</span>
  
<span class="line-modified">! void Deoptimization::revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map) {</span>
<span class="line-modified">!   if (!UseBiasedLocking) {</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
<span class="line-added">+   GrowableArray&lt;Handle&gt;* objects_to_revoke = new GrowableArray&lt;Handle&gt;();</span>
<span class="line-added">+   get_monitors_from_stack(objects_to_revoke, thread, fr, map);</span>
<span class="line-added">+ </span>
<span class="line-added">+   int len = objects_to_revoke-&gt;length();</span>
<span class="line-added">+   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-added">+     oop obj = (objects_to_revoke-&gt;at(i))();</span>
<span class="line-added">+     BiasedLocking::revoke_own_lock(objects_to_revoke-&gt;at(i), thread);</span>
<span class="line-added">+     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
    }
  }
  
  
  void Deoptimization::deoptimize_single_frame(JavaThread* thread, frame fr, Deoptimization::DeoptReason reason) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1311,47 ***</span>
    // Patch the compiled method so that when execution returns to it we will
    // deopt the execution state and return to the interpreter.
    fr.deoptimize(thread);
  }
  
<span class="line-modified">! void Deoptimization::deoptimize(JavaThread* thread, frame fr, RegisterMap *map) {</span>
<span class="line-removed">-   deoptimize(thread, fr, map, Reason_constraint);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Deoptimization::deoptimize(JavaThread* thread, frame fr, RegisterMap *map, DeoptReason reason) {</span>
    // Deoptimize only if the frame comes from compile code.
    // Do not deoptimize the frame which is already patched
    // during the execution of the loops below.
    if (!fr.is_compiled_frame() || fr.is_deoptimized_frame()) {
      return;
    }
    ResourceMark rm;
    DeoptimizationMarker dm;
<span class="line-removed">-   if (UseBiasedLocking) {</span>
<span class="line-removed">-     revoke_biases_of_monitors(thread, fr, map);</span>
<span class="line-removed">-   }</span>
    deoptimize_single_frame(thread, fr, reason);
<span class="line-removed">- </span>
  }
  
  #if INCLUDE_JVMCI
  address Deoptimization::deoptimize_for_missing_exception_handler(CompiledMethod* cm) {
    // there is no exception handler for this pc =&gt; deoptimize
    cm-&gt;make_not_entrant();
  
    // Use Deoptimization::deoptimize for all of its side-effects:
<span class="line-modified">!   // revoking biases of monitors, gathering traps statistics, logging...</span>
    // it also patches the return pc but we do not care about that
    // since we return a continuation to the deopt_blob below.
    JavaThread* thread = JavaThread::current();
<span class="line-modified">!   RegisterMap reg_map(thread, UseBiasedLocking);</span>
    frame runtime_frame = thread-&gt;last_frame();
    frame caller_frame = runtime_frame.sender(&amp;reg_map);
    assert(caller_frame.cb()-&gt;as_compiled_method_or_null() == cm, &quot;expect top frame compiled method&quot;);
<span class="line-modified">!   Deoptimization::deoptimize(thread, caller_frame, &amp;reg_map, Deoptimization::Reason_not_compiled_exception_handler);</span>
  
<span class="line-modified">!   MethodData* trap_mdo = get_method_data(thread, cm-&gt;method(), true);</span>
    if (trap_mdo != NULL) {
      trap_mdo-&gt;inc_trap_count(Deoptimization::Reason_not_compiled_exception_handler);
    }
  
    return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
<span class="line-new-header">--- 1514,39 ---</span>
    // Patch the compiled method so that when execution returns to it we will
    // deopt the execution state and return to the interpreter.
    fr.deoptimize(thread);
  }
  
<span class="line-modified">! void Deoptimization::deoptimize(JavaThread* thread, frame fr, DeoptReason reason) {</span>
    // Deoptimize only if the frame comes from compile code.
    // Do not deoptimize the frame which is already patched
    // during the execution of the loops below.
    if (!fr.is_compiled_frame() || fr.is_deoptimized_frame()) {
      return;
    }
    ResourceMark rm;
    DeoptimizationMarker dm;
    deoptimize_single_frame(thread, fr, reason);
  }
  
  #if INCLUDE_JVMCI
  address Deoptimization::deoptimize_for_missing_exception_handler(CompiledMethod* cm) {
    // there is no exception handler for this pc =&gt; deoptimize
    cm-&gt;make_not_entrant();
  
    // Use Deoptimization::deoptimize for all of its side-effects:
<span class="line-modified">!   // gathering traps statistics, logging...</span>
    // it also patches the return pc but we do not care about that
    // since we return a continuation to the deopt_blob below.
    JavaThread* thread = JavaThread::current();
<span class="line-modified">!   RegisterMap reg_map(thread, false);</span>
    frame runtime_frame = thread-&gt;last_frame();
    frame caller_frame = runtime_frame.sender(&amp;reg_map);
    assert(caller_frame.cb()-&gt;as_compiled_method_or_null() == cm, &quot;expect top frame compiled method&quot;);
<span class="line-modified">!   Deoptimization::deoptimize(thread, caller_frame, Deoptimization::Reason_not_compiled_exception_handler);</span>
  
<span class="line-modified">!   MethodData* trap_mdo = get_method_data(thread, methodHandle(thread, cm-&gt;method()), true);</span>
    if (trap_mdo != NULL) {
      trap_mdo-&gt;inc_trap_count(Deoptimization::Reason_not_compiled_exception_handler);
    }
  
    return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1360,16 ***</span>
  
  void Deoptimization::deoptimize_frame_internal(JavaThread* thread, intptr_t* id, DeoptReason reason) {
    assert(thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),
           &quot;can only deoptimize other thread at a safepoint&quot;);
    // Compute frame and register map based on thread and sp.
<span class="line-modified">!   RegisterMap reg_map(thread, UseBiasedLocking);</span>
    frame fr = thread-&gt;last_frame();
    while (fr.id() != id) {
      fr = fr.sender(&amp;reg_map);
    }
<span class="line-modified">!   deoptimize(thread, fr, &amp;reg_map, reason);</span>
  }
  
  
  void Deoptimization::deoptimize_frame(JavaThread* thread, intptr_t* id, DeoptReason reason) {
    if (thread == Thread::current()) {
<span class="line-new-header">--- 1555,16 ---</span>
  
  void Deoptimization::deoptimize_frame_internal(JavaThread* thread, intptr_t* id, DeoptReason reason) {
    assert(thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),
           &quot;can only deoptimize other thread at a safepoint&quot;);
    // Compute frame and register map based on thread and sp.
<span class="line-modified">!   RegisterMap reg_map(thread, false);</span>
    frame fr = thread-&gt;last_frame();
    while (fr.id() != id) {
      fr = fr.sender(&amp;reg_map);
    }
<span class="line-modified">!   deoptimize(thread, fr, reason);</span>
  }
  
  
  void Deoptimization::deoptimize_frame(JavaThread* thread, intptr_t* id, DeoptReason reason) {
    if (thread == Thread::current()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1409,37 ***</span>
    return mdo;
  }
  
  #if COMPILER2_OR_JVMCI
  void Deoptimization::load_class_by_index(const constantPoolHandle&amp; constant_pool, int index, TRAPS) {
<span class="line-modified">!   // in case of an unresolved klass entry, load the class.</span>
    if (constant_pool-&gt;tag_at(index).is_unresolved_klass()) {
      Klass* tk = constant_pool-&gt;klass_at_ignore_error(index, CHECK);
      return;
    }
  
<span class="line-modified">!   if (!constant_pool-&gt;tag_at(index).is_symbol()) return;</span>
<span class="line-modified">! </span>
<span class="line-removed">-   Handle class_loader (THREAD, constant_pool-&gt;pool_holder()-&gt;class_loader());</span>
<span class="line-removed">-   Symbol*  symbol  = constant_pool-&gt;symbol_at(index);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // class name?</span>
<span class="line-removed">-   if (symbol-&gt;char_at(0) != &#39;(&#39;) {</span>
<span class="line-removed">-     Handle protection_domain (THREAD, constant_pool-&gt;pool_holder()-&gt;protection_domain());</span>
<span class="line-removed">-     SystemDictionary::resolve_or_null(symbol, class_loader, protection_domain, CHECK);</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // then it must be a signature!</span>
<span class="line-removed">-   ResourceMark rm(THREAD);</span>
<span class="line-removed">-   for (SignatureStream ss(symbol); !ss.is_done(); ss.next()) {</span>
<span class="line-removed">-     if (ss.is_object()) {</span>
<span class="line-removed">-       Symbol* class_name = ss.as_symbol(CHECK);</span>
<span class="line-removed">-       Handle protection_domain (THREAD, constant_pool-&gt;pool_holder()-&gt;protection_domain());</span>
<span class="line-removed">-       SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  }
  
  
  void Deoptimization::load_class_by_index(const constantPoolHandle&amp; constant_pool, int index) {
    EXCEPTION_MARK;
<span class="line-new-header">--- 1604,24 ---</span>
    return mdo;
  }
  
  #if COMPILER2_OR_JVMCI
  void Deoptimization::load_class_by_index(const constantPoolHandle&amp; constant_pool, int index, TRAPS) {
<span class="line-modified">!   // In case of an unresolved klass entry, load the class.</span>
<span class="line-added">+   // This path is exercised from case _ldc in Parse::do_one_bytecode,</span>
<span class="line-added">+   // and probably nowhere else.</span>
<span class="line-added">+   // Even that case would benefit from simply re-interpreting the</span>
<span class="line-added">+   // bytecode, without paying special attention to the class index.</span>
<span class="line-added">+   // So this whole &quot;class index&quot; feature should probably be removed.</span>
<span class="line-added">+ </span>
    if (constant_pool-&gt;tag_at(index).is_unresolved_klass()) {
      Klass* tk = constant_pool-&gt;klass_at_ignore_error(index, CHECK);
      return;
    }
  
<span class="line-modified">!   assert(!constant_pool-&gt;tag_at(index).is_symbol(),</span>
<span class="line-modified">!          &quot;no symbolic names here, please&quot;);</span>
  }
  
  
  void Deoptimization::load_class_by_index(const constantPoolHandle&amp; constant_pool, int index) {
    EXCEPTION_MARK;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1460,10 ***</span>
<span class="line-new-header">--- 1642,73 ---</span>
      if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
      assert(guard_pages_enabled, &quot;stack banging in uncommon trap blob may cause crash&quot;);
    }
  }
  
<span class="line-added">+ #if INCLUDE_JFR</span>
<span class="line-added">+ </span>
<span class="line-added">+ class DeoptReasonSerializer : public JfrSerializer {</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">+     writer.write_count((u4)(Deoptimization::Reason_LIMIT + 1)); // + Reason::many (-1)</span>
<span class="line-added">+     for (int i = -1; i &lt; Deoptimization::Reason_LIMIT; ++i) {</span>
<span class="line-added">+       writer.write_key((u8)i);</span>
<span class="line-added">+       writer.write(Deoptimization::trap_reason_name(i));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class DeoptActionSerializer : public JfrSerializer {</span>
<span class="line-added">+  public:</span>
<span class="line-added">+   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">+     static const u4 nof_actions = Deoptimization::Action_LIMIT;</span>
<span class="line-added">+     writer.write_count(nof_actions);</span>
<span class="line-added">+     for (u4 i = 0; i &lt; Deoptimization::Action_LIMIT; ++i) {</span>
<span class="line-added">+       writer.write_key(i);</span>
<span class="line-added">+       writer.write(Deoptimization::trap_action_name((int)i));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void register_serializers() {</span>
<span class="line-added">+   static int critical_section = 0;</span>
<span class="line-added">+   if (1 == critical_section || Atomic::cmpxchg(&amp;critical_section, 0, 1) == 1) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   JfrSerializer::register_serializer(TYPE_DEOPTIMIZATIONREASON, true, new DeoptReasonSerializer());</span>
<span class="line-added">+   JfrSerializer::register_serializer(TYPE_DEOPTIMIZATIONACTION, true, new DeoptActionSerializer());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void post_deoptimization_event(CompiledMethod* nm,</span>
<span class="line-added">+                                       const Method* method,</span>
<span class="line-added">+                                       int trap_bci,</span>
<span class="line-added">+                                       int instruction,</span>
<span class="line-added">+                                       Deoptimization::DeoptReason reason,</span>
<span class="line-added">+                                       Deoptimization::DeoptAction action) {</span>
<span class="line-added">+   assert(nm != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+   if (EventDeoptimization::is_enabled()) {</span>
<span class="line-added">+     static bool serializers_registered = false;</span>
<span class="line-added">+     if (!serializers_registered) {</span>
<span class="line-added">+       register_serializers();</span>
<span class="line-added">+       serializers_registered = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     EventDeoptimization event;</span>
<span class="line-added">+     event.set_compileId(nm-&gt;compile_id());</span>
<span class="line-added">+     event.set_compiler(nm-&gt;compiler_type());</span>
<span class="line-added">+     event.set_method(method);</span>
<span class="line-added">+     event.set_lineNumber(method-&gt;line_number_from_bci(trap_bci));</span>
<span class="line-added">+     event.set_bci(trap_bci);</span>
<span class="line-added">+     event.set_instruction(instruction);</span>
<span class="line-added">+     event.set_reason(reason);</span>
<span class="line-added">+     event.set_action(action);</span>
<span class="line-added">+     event.commit();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif // INCLUDE_JFR</span>
<span class="line-added">+ </span>
  JRT_ENTRY(void, Deoptimization::uncommon_trap_inner(JavaThread* thread, jint trap_request)) {
    HandleMark hm;
  
    // uncommon_trap() is called at the beginning of the uncommon trap
    // handler. Note this fact before we start generating temporary frames
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1483,19 ***</span>
    // Make sure the calling nmethod is not getting deoptimized and removed
    // before we are done with it.
    nmethodLocker nl(fr.pc());
  
    // Log a message
<span class="line-modified">!   Events::log(thread, &quot;Uncommon trap: trap_request=&quot; PTR32_FORMAT &quot; fr.pc=&quot; INTPTR_FORMAT &quot; relative=&quot; INTPTR_FORMAT,</span>
                trap_request, p2i(fr.pc()), fr.pc() - fr.cb()-&gt;code_begin());
  
    {
      ResourceMark rm;
  
<span class="line-removed">-     // Revoke biases of any monitors in the frame to ensure we can migrate them</span>
<span class="line-removed">-     revoke_biases_of_monitors(thread, fr, &amp;reg_map);</span>
<span class="line-removed">- </span>
      DeoptReason reason = trap_request_reason(trap_request);
      DeoptAction action = trap_request_action(trap_request);
  #if INCLUDE_JVMCI
      int debug_id = trap_request_debug_id(trap_request);
  #endif
<span class="line-new-header">--- 1728,16 ---</span>
    // Make sure the calling nmethod is not getting deoptimized and removed
    // before we are done with it.
    nmethodLocker nl(fr.pc());
  
    // Log a message
<span class="line-modified">!   Events::log_deopt_message(thread, &quot;Uncommon trap: trap_request=&quot; PTR32_FORMAT &quot; fr.pc=&quot; INTPTR_FORMAT &quot; relative=&quot; INTPTR_FORMAT,</span>
                trap_request, p2i(fr.pc()), fr.pc() - fr.cb()-&gt;code_begin());
  
    {
      ResourceMark rm;
  
      DeoptReason reason = trap_request_reason(trap_request);
      DeoptAction action = trap_request_action(trap_request);
  #if INCLUDE_JVMCI
      int debug_id = trap_request_debug_id(trap_request);
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1515,40 ***</span>
            , debug_id
  #endif
            );
      }
  
<span class="line-modified">!     methodHandle    trap_method = trap_scope-&gt;method();</span>
      int             trap_bci    = trap_scope-&gt;bci();
  #if INCLUDE_JVMCI
<span class="line-modified">!     long speculation = thread-&gt;pending_failed_speculation();</span>
<span class="line-modified">!     if (nm-&gt;is_compiled_by_jvmci()) {</span>
<span class="line-modified">!       if (speculation != 0) {</span>
<span class="line-removed">-         oop speculation_log = nm-&gt;as_nmethod()-&gt;speculation_log();</span>
<span class="line-removed">-         if (speculation_log != NULL) {</span>
<span class="line-removed">-           if (TraceDeoptimization || TraceUncollectedSpeculations) {</span>
<span class="line-removed">-             if (HotSpotSpeculationLog::lastFailed(speculation_log) != 0) {</span>
<span class="line-removed">-               tty-&gt;print_cr(&quot;A speculation that was not collected by the compiler is being overwritten&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           if (TraceDeoptimization) {</span>
<span class="line-removed">-             tty-&gt;print_cr(&quot;Saving speculation to speculation log&quot;);</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           HotSpotSpeculationLog::set_lastFailed(speculation_log, speculation);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           if (TraceDeoptimization) {</span>
<span class="line-removed">-             tty-&gt;print_cr(&quot;Speculation present but no speculation log&quot;);</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         thread-&gt;set_pending_failed_speculation(0);</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         if (TraceDeoptimization) {</span>
<span class="line-removed">-           tty-&gt;print_cr(&quot;No speculation&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
      } else {
<span class="line-modified">!       assert(speculation == 0, &quot;There should not be a speculation for method compiled by non-JVMCI compilers&quot;);</span>
      }
  
      if (trap_bci == SynchronizationEntryBCI) {
        trap_bci = 0;
        thread-&gt;set_pending_monitorenter(true);
<span class="line-new-header">--- 1757,18 ---</span>
            , debug_id
  #endif
            );
      }
  
<span class="line-modified">!     methodHandle    trap_method(THREAD, trap_scope-&gt;method());</span>
      int             trap_bci    = trap_scope-&gt;bci();
  #if INCLUDE_JVMCI
<span class="line-modified">!     jlong           speculation = thread-&gt;pending_failed_speculation();</span>
<span class="line-modified">!     if (nm-&gt;is_compiled_by_jvmci() &amp;&amp; nm-&gt;is_nmethod()) { // Exclude AOTed methods</span>
<span class="line-modified">!       nm-&gt;as_nmethod()-&gt;update_speculation(thread);</span>
      } else {
<span class="line-modified">!       assert(speculation == 0, &quot;There should not be a speculation for methods compiled by non-JVMCI compilers&quot;);</span>
      }
  
      if (trap_bci == SynchronizationEntryBCI) {
        trap_bci = 0;
        thread-&gt;set_pending_monitorenter(true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1568,21 ***</span>
      bool create_if_missing = ProfileTraps || UseCodeAging RTM_OPT_ONLY( || UseRTMLocking );
  
      methodHandle profiled_method;
  #if INCLUDE_JVMCI
      if (nm-&gt;is_compiled_by_jvmci()) {
<span class="line-modified">!       profiled_method = nm-&gt;method();</span>
      } else {
        profiled_method = trap_method;
      }
  #else
      profiled_method = trap_method;
  #endif
  
      MethodData* trap_mdo =
        get_method_data(thread, profiled_method, create_if_missing);
  
      // Log a message
      Events::log_deopt_message(thread, &quot;Uncommon trap: reason=%s action=%s pc=&quot; INTPTR_FORMAT &quot; method=%s @ %d %s&quot;,
                                trap_reason_name(reason), trap_action_name(action), p2i(fr.pc()),
                                trap_method-&gt;name_and_sig_as_C_string(), trap_bci, nm-&gt;compiler_name());
  
<span class="line-new-header">--- 1788,23 ---</span>
      bool create_if_missing = ProfileTraps || UseCodeAging RTM_OPT_ONLY( || UseRTMLocking );
  
      methodHandle profiled_method;
  #if INCLUDE_JVMCI
      if (nm-&gt;is_compiled_by_jvmci()) {
<span class="line-modified">!       profiled_method = methodHandle(THREAD, nm-&gt;method());</span>
      } else {
        profiled_method = trap_method;
      }
  #else
      profiled_method = trap_method;
  #endif
  
      MethodData* trap_mdo =
        get_method_data(thread, profiled_method, create_if_missing);
  
<span class="line-added">+     JFR_ONLY(post_deoptimization_event(nm, trap_method(), trap_bci, trap_bc, reason, action);)</span>
<span class="line-added">+ </span>
      // Log a message
      Events::log_deopt_message(thread, &quot;Uncommon trap: reason=%s action=%s pc=&quot; INTPTR_FORMAT &quot; method=%s @ %d %s&quot;,
                                trap_reason_name(reason), trap_action_name(action), p2i(fr.pc()),
                                trap_method-&gt;name_and_sig_as_C_string(), trap_bci, nm-&gt;compiler_name());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1593,10 ***</span>
<span class="line-new-header">--- 1815,15 ---</span>
        char buf[100];
        if (xtty != NULL) {
          xtty-&gt;begin_head(&quot;uncommon_trap thread=&#39;&quot; UINTX_FORMAT &quot;&#39; %s&quot;,
                           os::current_thread_id(),
                           format_trap_request(buf, sizeof(buf), trap_request));
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+         if (speculation != 0) {</span>
<span class="line-added">+           xtty-&gt;print(&quot; speculation=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, speculation);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #endif</span>
          nm-&gt;log_identity(xtty);
        }
        Symbol* class_name = NULL;
        bool unresolved = false;
        if (unloaded_class_index &gt;= 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1638,11 ***</span>
          tty-&gt;print(&quot;Uncommon trap occurred in&quot;);
          nm-&gt;method()-&gt;print_short_name(tty);
          tty-&gt;print(&quot; compiler=%s compile_id=%d&quot;, nm-&gt;compiler_name(), nm-&gt;compile_id());
  #if INCLUDE_JVMCI
          if (nm-&gt;is_nmethod()) {
<span class="line-modified">!           char* installed_code_name = nm-&gt;as_nmethod()-&gt;jvmci_installed_code_name(buf, sizeof(buf));</span>
            if (installed_code_name != NULL) {
              tty-&gt;print(&quot; (JVMCI: installed code name=%s) &quot;, installed_code_name);
            }
          }
  #endif
<span class="line-new-header">--- 1865,11 ---</span>
          tty-&gt;print(&quot;Uncommon trap occurred in&quot;);
          nm-&gt;method()-&gt;print_short_name(tty);
          tty-&gt;print(&quot; compiler=%s compile_id=%d&quot;, nm-&gt;compiler_name(), nm-&gt;compile_id());
  #if INCLUDE_JVMCI
          if (nm-&gt;is_nmethod()) {
<span class="line-modified">!           const char* installed_code_name = nm-&gt;as_nmethod()-&gt;jvmci_name();</span>
            if (installed_code_name != NULL) {
              tty-&gt;print(&quot; (JVMCI: installed code name=%s) &quot;, installed_code_name);
            }
          }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1900,11 ***</span>
            (uint)PerBytecodeRecompilationCutoff) {
          // Give up on the method containing the bad BCI.
          if (trap_method() == nm-&gt;method()) {
            make_not_compilable = true;
          } else {
<span class="line-modified">!           trap_method-&gt;set_not_compilable(CompLevel_full_optimization, true, &quot;overflow_recompile_count &gt; PerBytecodeRecompilationCutoff&quot;);</span>
            // But give grace to the enclosing nm-&gt;method().
          }
        }
      }
  
<span class="line-new-header">--- 2127,11 ---</span>
            (uint)PerBytecodeRecompilationCutoff) {
          // Give up on the method containing the bad BCI.
          if (trap_method() == nm-&gt;method()) {
            make_not_compilable = true;
          } else {
<span class="line-modified">!           trap_method-&gt;set_not_compilable(&quot;overflow_recompile_count &gt; PerBytecodeRecompilationCutoff&quot;, CompLevel_full_optimization);</span>
            // But give grace to the enclosing nm-&gt;method().
          }
        }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1914,11 ***</span>
      }
  
      // Give up compiling
      if (make_not_compilable &amp;&amp; !nm-&gt;method()-&gt;is_not_compilable(CompLevel_full_optimization)) {
        assert(make_not_entrant, &quot;consistent&quot;);
<span class="line-modified">!       nm-&gt;method()-&gt;set_not_compilable(CompLevel_full_optimization);</span>
      }
  
    } // Free marked resources
  
  }
<span class="line-new-header">--- 2141,11 ---</span>
      }
  
      // Give up compiling
      if (make_not_compilable &amp;&amp; !nm-&gt;method()-&gt;is_not_compilable(CompLevel_full_optimization)) {
        assert(make_not_entrant, &quot;consistent&quot;);
<span class="line-modified">!       nm-&gt;method()-&gt;set_not_compilable(&quot;give up compiling&quot;, CompLevel_full_optimization);</span>
      }
  
    } // Free marked resources
  
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2144,10 ***</span>
<span class="line-new-header">--- 2371,11 ---</span>
    &quot;intrinsic&quot; JVMCI_ONLY(&quot;_or_type_checked_inlining&quot;),
    &quot;bimorphic&quot; JVMCI_ONLY(&quot;_or_optimized_type_check&quot;),
    &quot;profile_predicate&quot;,
    &quot;unloaded&quot;,
    &quot;uninitialized&quot;,
<span class="line-added">+   &quot;initialized&quot;,</span>
    &quot;unreached&quot;,
    &quot;unhandled&quot;,
    &quot;constraint&quot;,
    &quot;div0_check&quot;,
    &quot;age&quot;,
</pre>
<center><a href="biasedLocking.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/runtime/synchronizer.cpp b/src/hotspot/share/runtime/synchronizer.cpp
--- a/src/hotspot/share/runtime/synchronizer.cpp
+++ b/src/hotspot/share/runtime/synchronizer.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,11 +29,12 @@
 #include "jfr/jfrEvents.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/metaspaceShared.hpp"
 #include "memory/padded.hpp"
 #include "memory/resourceArea.hpp"
-#include "oops/markOop.hpp"
+#include "memory/universe.hpp"
+#include "oops/markWord.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/biasedLocking.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
@@ -114,26 +115,278 @@
 
 #define NINFLATIONLOCKS 256
 static volatile intptr_t gInflationLocks[NINFLATIONLOCKS];
 
 // global list of blocks of monitors
-PaddedEnd<ObjectMonitor> * volatile ObjectSynchronizer::gBlockList = NULL;
-// global monitor free list
-ObjectMonitor * volatile ObjectSynchronizer::gFreeList  = NULL;
-// global monitor in-use list, for moribund threads,
-// monitors they inflated need to be scanned for deflation
-ObjectMonitor * volatile ObjectSynchronizer::gOmInUseList  = NULL;
-// count of entries in gOmInUseList
-int ObjectSynchronizer::gOmInUseCount = 0;
-
-static volatile intptr_t gListLock = 0;      // protects global monitor lists
-static volatile int gMonitorFreeCount  = 0;  // # on gFreeList
-static volatile int gMonitorPopulation = 0;  // # Extant -- in circulation
+PaddedObjectMonitor* ObjectSynchronizer::g_block_list = NULL;
+
+struct ObjectMonitorListGlobals {
+  char         _pad_prefix[OM_CACHE_LINE_SIZE];
+  // These are highly shared list related variables.
+  // To avoid false-sharing they need to be the sole occupants of a cache line.
+
+  // Global ObjectMonitor free list. Newly allocated and deflated
+  // ObjectMonitors are prepended here.
+  ObjectMonitor* _free_list;
+  DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));
+
+  // Global ObjectMonitor in-use list. When a JavaThread is exiting,
+  // ObjectMonitors on its per-thread in-use list are prepended here.
+  ObjectMonitor* _in_use_list;
+  DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));
+
+  int _free_count;    // # on free_list
+  DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(int));
+
+  int _in_use_count;  // # on in_use_list
+  DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));
+
+  int _population;    // # Extant -- in circulation
+  DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));
+};
+static ObjectMonitorListGlobals om_list_globals;
 
 #define CHAINMARKER (cast_to_oop<intptr_t>(-1))
 
 
+// =====================> Spin-lock functions
+
+// ObjectMonitors are not lockable outside of this file. We use spin-locks
+// implemented using a bit in the _next_om field instead of the heavier
+// weight locking mechanisms for faster list management.
+
+#define OM_LOCK_BIT 0x1
+
+// Return true if the ObjectMonitor is locked.
+// Otherwise returns false.
+static bool is_locked(ObjectMonitor* om) {
+  return ((intptr_t)om->next_om() & OM_LOCK_BIT) == OM_LOCK_BIT;
+}
+
+// Mark an ObjectMonitor* with OM_LOCK_BIT and return it.
+static ObjectMonitor* mark_om_ptr(ObjectMonitor* om) {
+  return (ObjectMonitor*)((intptr_t)om | OM_LOCK_BIT);
+}
+
+// Return the unmarked next field in an ObjectMonitor. Note: the next
+// field may or may not have been marked with OM_LOCK_BIT originally.
+static ObjectMonitor* unmarked_next(ObjectMonitor* om) {
+  return (ObjectMonitor*)((intptr_t)om->next_om() & ~OM_LOCK_BIT);
+}
+
+// Try to lock an ObjectMonitor. Returns true if locking was successful.
+// Otherwise returns false.
+static bool try_om_lock(ObjectMonitor* om) {
+  // Get current next field without any OM_LOCK_BIT value.
+  ObjectMonitor* next = unmarked_next(om);
+  if (om->try_set_next_om(next, mark_om_ptr(next)) != next) {
+    return false;  // Cannot lock the ObjectMonitor.
+  }
+  return true;
+}
+
+// Lock an ObjectMonitor.
+static void om_lock(ObjectMonitor* om) {
+  while (true) {
+    if (try_om_lock(om)) {
+      return;
+    }
+  }
+}
+
+// Unlock an ObjectMonitor.
+static void om_unlock(ObjectMonitor* om) {
+  ObjectMonitor* next = om->next_om();
+  guarantee(((intptr_t)next & OM_LOCK_BIT) == OM_LOCK_BIT, "next=" INTPTR_FORMAT
+            " must have OM_LOCK_BIT=%x set.", p2i(next), OM_LOCK_BIT);
+
+  next = (ObjectMonitor*)((intptr_t)next & ~OM_LOCK_BIT);  // Clear OM_LOCK_BIT.
+  om->set_next_om(next);
+}
+
+// Get the list head after locking it. Returns the list head or NULL
+// if the list is empty.
+static ObjectMonitor* get_list_head_locked(ObjectMonitor** list_p) {
+  while (true) {
+    ObjectMonitor* mid = Atomic::load(list_p);
+    if (mid == NULL) {
+      return NULL;  // The list is empty.
+    }
+    if (try_om_lock(mid)) {
+      if (Atomic::load(list_p) != mid) {
+        // The list head changed before we could lock it so we have to retry.
+        om_unlock(mid);
+        continue;
+      }
+      return mid;
+    }
+  }
+}
+
+#undef OM_LOCK_BIT
+
+
+// =====================> List Management functions
+
+// Prepend a list of ObjectMonitors to the specified *list_p. 'tail' is
+// the last ObjectMonitor in the list and there are 'count' on the list.
+// Also updates the specified *count_p.
+static void prepend_list_to_common(ObjectMonitor* list, ObjectMonitor* tail,
+                                   int count, ObjectMonitor** list_p,
+                                   int* count_p) {
+  while (true) {
+    ObjectMonitor* cur = Atomic::load(list_p);
+    // Prepend list to *list_p.
+    if (!try_om_lock(tail)) {
+      // Failed to lock tail due to a list walker so try it all again.
+      continue;
+    }
+    tail->set_next_om(cur);  // tail now points to cur (and unlocks tail)
+    if (cur == NULL) {
+      // No potential race with takers or other prependers since
+      // *list_p is empty.
+      if (Atomic::cmpxchg(list_p, cur, list) == cur) {
+        // Successfully switched *list_p to the list value.
+        Atomic::add(count_p, count);
+        break;
+      }
+      // Implied else: try it all again
+    } else {
+      if (!try_om_lock(cur)) {
+        continue;  // failed to lock cur so try it all again
+      }
+      // We locked cur so try to switch *list_p to the list value.
+      if (Atomic::cmpxchg(list_p, cur, list) != cur) {
+        // The list head has changed so unlock cur and try again:
+        om_unlock(cur);
+        continue;
+      }
+      Atomic::add(count_p, count);
+      om_unlock(cur);
+      break;
+    }
+  }
+}
+
+// Prepend a newly allocated block of ObjectMonitors to g_block_list and
+// om_list_globals._free_list. Also updates om_list_globals._population
+// and om_list_globals._free_count.
+void ObjectSynchronizer::prepend_block_to_lists(PaddedObjectMonitor* new_blk) {
+  // First we handle g_block_list:
+  while (true) {
+    PaddedObjectMonitor* cur = Atomic::load(&g_block_list);
+    // Prepend new_blk to g_block_list. The first ObjectMonitor in
+    // a block is reserved for use as linkage to the next block.
+    new_blk[0].set_next_om(cur);
+    if (Atomic::cmpxchg(&g_block_list, cur, new_blk) == cur) {
+      // Successfully switched g_block_list to the new_blk value.
+      Atomic::add(&om_list_globals._population, _BLOCKSIZE - 1);
+      break;
+    }
+    // Implied else: try it all again
+  }
+
+  // Second we handle om_list_globals._free_list:
+  prepend_list_to_common(new_blk + 1, &new_blk[_BLOCKSIZE - 1], _BLOCKSIZE - 1,
+                         &om_list_globals._free_list, &om_list_globals._free_count);
+}
+
+// Prepend a list of ObjectMonitors to om_list_globals._free_list.
+// 'tail' is the last ObjectMonitor in the list and there are 'count'
+// on the list. Also updates om_list_globals._free_count.
+static void prepend_list_to_global_free_list(ObjectMonitor* list,
+                                             ObjectMonitor* tail, int count) {
+  prepend_list_to_common(list, tail, count, &om_list_globals._free_list,
+                         &om_list_globals._free_count);
+}
+
+// Prepend a list of ObjectMonitors to om_list_globals._in_use_list.
+// 'tail' is the last ObjectMonitor in the list and there are 'count'
+// on the list. Also updates om_list_globals._in_use_list.
+static void prepend_list_to_global_in_use_list(ObjectMonitor* list,
+                                               ObjectMonitor* tail, int count) {
+  prepend_list_to_common(list, tail, count, &om_list_globals._in_use_list,
+                         &om_list_globals._in_use_count);
+}
+
+// Prepend an ObjectMonitor to the specified list. Also updates
+// the specified counter.
+static void prepend_to_common(ObjectMonitor* m, ObjectMonitor** list_p,
+                              int* count_p) {
+  while (true) {
+    om_lock(m);  // Lock m so we can safely update its next field.
+    ObjectMonitor* cur = NULL;
+    // Lock the list head to guard against races with a list walker
+    // thread:
+    if ((cur = get_list_head_locked(list_p)) != NULL) {
+      // List head is now locked so we can safely switch it.
+      m->set_next_om(cur);  // m now points to cur (and unlocks m)
+      Atomic::store(list_p, m);  // Switch list head to unlocked m.
+      om_unlock(cur);
+      break;
+    }
+    // The list is empty so try to set the list head.
+    assert(cur == NULL, "cur must be NULL: cur=" INTPTR_FORMAT, p2i(cur));
+    m->set_next_om(cur);  // m now points to NULL (and unlocks m)
+    if (Atomic::cmpxchg(list_p, cur, m) == cur) {
+      // List head is now unlocked m.
+      break;
+    }
+    // Implied else: try it all again
+  }
+  Atomic::inc(count_p);
+}
+
+// Prepend an ObjectMonitor to a per-thread om_free_list.
+// Also updates the per-thread om_free_count.
+static void prepend_to_om_free_list(Thread* self, ObjectMonitor* m) {
+  prepend_to_common(m, &self->om_free_list, &self->om_free_count);
+}
+
+// Prepend an ObjectMonitor to a per-thread om_in_use_list.
+// Also updates the per-thread om_in_use_count.
+static void prepend_to_om_in_use_list(Thread* self, ObjectMonitor* m) {
+  prepend_to_common(m, &self->om_in_use_list, &self->om_in_use_count);
+}
+
+// Take an ObjectMonitor from the start of the specified list. Also
+// decrements the specified counter. Returns NULL if none are available.
+static ObjectMonitor* take_from_start_of_common(ObjectMonitor** list_p,
+                                                int* count_p) {
+  ObjectMonitor* take = NULL;
+  // Lock the list head to guard against races with a list walker
+  // thread:
+  if ((take = get_list_head_locked(list_p)) == NULL) {
+    return NULL;  // None are available.
+  }
+  ObjectMonitor* next = unmarked_next(take);
+  // Switch locked list head to next (which unlocks the list head, but
+  // leaves take locked):
+  Atomic::store(list_p, next);
+  Atomic::dec(count_p);
+  // Unlock take, but leave the next value for any lagging list
+  // walkers. It will get cleaned up when take is prepended to
+  // the in-use list:
+  om_unlock(take);
+  return take;
+}
+
+// Take an ObjectMonitor from the start of the om_list_globals._free_list.
+// Also updates om_list_globals._free_count. Returns NULL if none are
+// available.
+static ObjectMonitor* take_from_start_of_global_free_list() {
+  return take_from_start_of_common(&om_list_globals._free_list,
+                                   &om_list_globals._free_count);
+}
+
+// Take an ObjectMonitor from the start of a per-thread free-list.
+// Also updates om_free_count. Returns NULL if none are available.
+static ObjectMonitor* take_from_start_of_om_free_list(Thread* self) {
+  return take_from_start_of_common(&self->om_free_list, &self->om_free_count);
+}
+
+
 // =====================> Quick functions
 
 // The quick_* forms are special fast-path variants used to improve
 // performance.  In the simplest case, a "quick_*" implementation could
 // simply return false, in which case the caller will perform the necessary
@@ -152,27 +405,27 @@
 //   synchronized (someobj) { .... ; notify(); }
 // That is, we find a notify() or notifyAll() call that immediately precedes
 // the monitorexit operation.  In that case the JIT could fuse the operations
 // into a single notifyAndExit() runtime primitive.
 
-bool ObjectSynchronizer::quick_notify(oopDesc * obj, Thread * self, bool all) {
+bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {
   assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
   assert(self->is_Java_thread(), "invariant");
   assert(((JavaThread *) self)->thread_state() == _thread_in_Java, "invariant");
   NoSafepointVerifier nsv;
   if (obj == NULL) return false;  // slow-path for invalid obj
-  const markOop mark = obj->mark();
+  const markWord mark = obj->mark();
 
-  if (mark->has_locker() && self->is_lock_owned((address)mark->locker())) {
+  if (mark.has_locker() && self->is_lock_owned((address)mark.locker())) {
     // Degenerate notify
     // stack-locked by caller so by definition the implied waitset is empty.
     return true;
   }
 
-  if (mark->has_monitor()) {
-    ObjectMonitor * const mon = mark->monitor();
-    assert(oopDesc::equals((oop) mon->object(), obj), "invariant");
+  if (mark.has_monitor()) {
+    ObjectMonitor* const mon = mark.monitor();
+    assert(mon->object() == obj, "invariant");
     if (mon->owner() != self) return false;  // slow-path for IMS exception
 
     if (mon->first_waiter() != NULL) {
       // We have one or more waiters. Since this is an inflated monitor
       // that we own, we can transfer one or more threads from the waitset
@@ -180,16 +433,16 @@
       if (all) {
         DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
       } else {
         DTRACE_MONITOR_PROBE(notify, mon, obj, self);
       }
-      int tally = 0;
+      int free_count = 0;
       do {
         mon->INotify(self);
-        ++tally;
+        ++free_count;
       } while (mon->first_waiter() != NULL && all);
-      OM_PERFDATA_OP(Notifications, inc(tally));
+      OM_PERFDATA_OP(Notifications, inc(free_count));
     }
     return true;
   }
 
   // biased locking and any other IMS exception states take the slow-path
@@ -201,30 +454,30 @@
 // been too big if it were to have included support for the cases of inflated
 // recursive enter and exit, so they go here instead.
 // Note that we can't safely call AsyncPrintJavaStack() from within
 // quick_enter() as our thread state remains _in_Java.
 
-bool ObjectSynchronizer::quick_enter(oop obj, Thread * Self,
+bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,
                                      BasicLock * lock) {
   assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
-  assert(Self->is_Java_thread(), "invariant");
-  assert(((JavaThread *) Self)->thread_state() == _thread_in_Java, "invariant");
+  assert(self->is_Java_thread(), "invariant");
+  assert(((JavaThread *) self)->thread_state() == _thread_in_Java, "invariant");
   NoSafepointVerifier nsv;
   if (obj == NULL) return false;       // Need to throw NPE
-  const markOop mark = obj->mark();
+  const markWord mark = obj->mark();
 
-  if (mark->has_monitor()) {
-    ObjectMonitor * const m = mark->monitor();
-    assert(oopDesc::equals((oop) m->object(), obj), "invariant");
-    Thread * const owner = (Thread *) m->_owner;
+  if (mark.has_monitor()) {
+    ObjectMonitor* const m = mark.monitor();
+    assert(m->object() == obj, "invariant");
+    Thread* const owner = (Thread *) m->_owner;
 
     // Lock contention and Transactional Lock Elision (TLE) diagnostics
     // and observability
     // Case: light contention possibly amenable to TLE
     // Case: TLE inimical operations such as nested/recursive synchronization
 
-    if (owner == Self) {
+    if (owner == self) {
       m->_recursions++;
       return true;
     }
 
     // This Java Monitor is inflated so obj's header will never be
@@ -235,15 +488,14 @@
     // performance reasons, stack walkers generally first check for
     // Biased Locking in the object's header, the second check is for
     // stack-locking in the object's header, the third check is for
     // recursive stack-locking in the displaced header in the BasicLock,
     // and last are the inflated Java Monitor (ObjectMonitor) checks.
-    lock->set_displaced_header(markOopDesc::unused_mark());
+    lock->set_displaced_header(markWord::unused_mark());
 
-    if (owner == NULL && Atomic::replace_if_null(Self, &(m->_owner))) {
+    if (owner == NULL && m->try_set_owner_from(NULL, self) == NULL) {
       assert(m->_recursions == 0, "invariant");
-      assert(m->_owner == Self, "invariant");
       return true;
     }
   }
 
   // Note that we could inflate in quick_enter.
@@ -255,124 +507,100 @@
 
   return false;        // revert to slow-path
 }
 
 // -----------------------------------------------------------------------------
-//  Fast Monitor Enter/Exit
-// This the fast monitor enter. The interpreter and compiler use
-// some assembly copies of this code. Make sure update those code
-// if the following function is changed. The implementation is
-// extremely sensitive to race condition. Be careful.
-
-void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock,
-                                    bool attempt_rebias, TRAPS) {
+// Monitor Enter/Exit
+// The interpreter and compiler assembly code tries to lock using the fast path
+// of this algorithm. Make sure to update that code if the following function is
+// changed. The implementation is extremely sensitive to race condition. Be careful.
+
+void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {
   if (UseBiasedLocking) {
     if (!SafepointSynchronize::is_at_safepoint()) {
-      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);
-      if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) {
-        return;
-      }
+      BiasedLocking::revoke(obj, THREAD);
     } else {
-      assert(!attempt_rebias, "can not rebias toward VM thread");
       BiasedLocking::revoke_at_safepoint(obj);
     }
-    assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now");
   }
 
-  slow_enter(obj, lock, THREAD);
+  markWord mark = obj->mark();
+  assert(!mark.has_bias_pattern(), "should not see bias pattern here");
+
+  if (mark.is_neutral()) {
+    // Anticipate successful CAS -- the ST of the displaced mark must
+    // be visible <= the ST performed by the CAS.
+    lock->set_displaced_header(mark);
+    if (mark == obj()->cas_set_mark(markWord::from_pointer(lock), mark)) {
+      return;
+    }
+    // Fall through to inflate() ...
+  } else if (mark.has_locker() &&
+             THREAD->is_lock_owned((address)mark.locker())) {
+    assert(lock != mark.locker(), "must not re-lock the same lock");
+    assert(lock != (BasicLock*)obj->mark().value(), "don't relock with same BasicLock");
+    lock->set_displaced_header(markWord::from_pointer(NULL));
+    return;
+  }
+
+  // The object header will never be displaced to this lock,
+  // so it does not matter what the value is, except that it
+  // must be non-zero to avoid looking like a re-entrant lock,
+  // and must not look locked either.
+  lock->set_displaced_header(markWord::unused_mark());
+  inflate(THREAD, obj(), inflate_cause_monitor_enter)->enter(THREAD);
 }
 
-void ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) {
-  markOop mark = object->mark();
+void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {
+  markWord mark = object->mark();
   // We cannot check for Biased Locking if we are racing an inflation.
-  assert(mark == markOopDesc::INFLATING() ||
-         !mark->has_bias_pattern(), "should not see bias pattern here");
+  assert(mark == markWord::INFLATING() ||
+         !mark.has_bias_pattern(), "should not see bias pattern here");
 
-  markOop dhw = lock->displaced_header();
-  if (dhw == NULL) {
+  markWord dhw = lock->displaced_header();
+  if (dhw.value() == 0) {
     // If the displaced header is NULL, then this exit matches up with
     // a recursive enter. No real work to do here except for diagnostics.
 #ifndef PRODUCT
-    if (mark != markOopDesc::INFLATING()) {
+    if (mark != markWord::INFLATING()) {
       // Only do diagnostics if we are not racing an inflation. Simply
       // exiting a recursive enter of a Java Monitor that is being
       // inflated is safe; see the has_monitor() comment below.
-      assert(!mark->is_neutral(), "invariant");
-      assert(!mark->has_locker() ||
-             THREAD->is_lock_owned((address)mark->locker()), "invariant");
-      if (mark->has_monitor()) {
+      assert(!mark.is_neutral(), "invariant");
+      assert(!mark.has_locker() ||
+             THREAD->is_lock_owned((address)mark.locker()), "invariant");
+      if (mark.has_monitor()) {
         // The BasicLock's displaced_header is marked as a recursive
         // enter and we have an inflated Java Monitor (ObjectMonitor).
         // This is a special case where the Java Monitor was inflated
         // after this thread entered the stack-lock recursively. When a
         // Java Monitor is inflated, we cannot safely walk the Java
         // Monitor owner's stack and update the BasicLocks because a
         // Java Monitor can be asynchronously inflated by a thread that
         // does not own the Java Monitor.
-        ObjectMonitor * m = mark->monitor();
+        ObjectMonitor* m = mark.monitor();
         assert(((oop)(m->object()))->mark() == mark, "invariant");
         assert(m->is_entered(THREAD), "invariant");
       }
     }
 #endif
     return;
   }
 
-  if (mark == (markOop) lock) {
+  if (mark == markWord::from_pointer(lock)) {
     // If the object is stack-locked by the current thread, try to
     // swing the displaced header from the BasicLock back to the mark.
-    assert(dhw->is_neutral(), "invariant");
+    assert(dhw.is_neutral(), "invariant");
     if (object->cas_set_mark(dhw, mark) == mark) {
       return;
     }
   }
 
   // We have to take the slow-path of possible inflation and then exit.
   inflate(THREAD, object, inflate_cause_vm_internal)->exit(true, THREAD);
 }
 
-// -----------------------------------------------------------------------------
-// Interpreter/Compiler Slow Case
-// This routine is used to handle interpreter/compiler slow case
-// We don't need to use fast path here, because it must have been
-// failed in the interpreter/compiler code.
-void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {
-  markOop mark = obj->mark();
-  assert(!mark->has_bias_pattern(), "should not see bias pattern here");
-
-  if (mark->is_neutral()) {
-    // Anticipate successful CAS -- the ST of the displaced mark must
-    // be visible <= the ST performed by the CAS.
-    lock->set_displaced_header(mark);
-    if (mark == obj()->cas_set_mark((markOop) lock, mark)) {
-      return;
-    }
-    // Fall through to inflate() ...
-  } else if (mark->has_locker() &&
-             THREAD->is_lock_owned((address)mark->locker())) {
-    assert(lock != mark->locker(), "must not re-lock the same lock");
-    assert(lock != (BasicLock*)obj->mark(), "don't relock with same BasicLock");
-    lock->set_displaced_header(NULL);
-    return;
-  }
-
-  // The object header will never be displaced to this lock,
-  // so it does not matter what the value is, except that it
-  // must be non-zero to avoid looking like a re-entrant lock,
-  // and must not look locked either.
-  lock->set_displaced_header(markOopDesc::unused_mark());
-  inflate(THREAD, obj(), inflate_cause_monitor_enter)->enter(THREAD);
-}
-
-// This routine is used to handle interpreter/compiler slow case
-// We don't need to use fast path here, because it must have
-// failed in the interpreter/compiler code. Simply use the heavy
-// weight monitor should be ok, unless someone find otherwise.
-void ObjectSynchronizer::slow_exit(oop object, BasicLock* lock, TRAPS) {
-  fast_exit(object, lock, THREAD);
-}
-
 // -----------------------------------------------------------------------------
 // Class Loader  support to workaround deadlocks on the class loader lock objects
 // Also used by GC
 // complete_exit()/reenter() are used to wait on a nested lock
 // i.e. to give up an outer lock completely and then re-enter
@@ -389,40 +617,40 @@
 //             the absolute recursion count tracked by Tsan, and (2) in the
 //             general case, we cannot merely store Tsan's recursion count
 //             once: we must track it for *each invocation* of complete_exit.
 //             Hence, the best place to instrument for Tsan is at the call site
 //             for complete_exit/reenter. Luckily, there is only one call site.
-intptr_t ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {
+intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {
   if (UseBiasedLocking) {
-    BiasedLocking::revoke_and_rebias(obj, false, THREAD);
-    assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+    BiasedLocking::revoke(obj, THREAD);
+    assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
 
   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 
   return monitor->complete_exit(THREAD);
 }
 
 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
-void ObjectSynchronizer::reenter(Handle obj, intptr_t recursion, TRAPS) {
+void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {
   if (UseBiasedLocking) {
-    BiasedLocking::revoke_and_rebias(obj, false, THREAD);
-    assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+    BiasedLocking::revoke(obj, THREAD);
+    assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
 
   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 
-  monitor->reenter(recursion, THREAD);
+  monitor->reenter(recursions, THREAD);
 }
 // -----------------------------------------------------------------------------
 // JNI locks on java objects
 // NOTE: must use heavy weight monitor to handle jni monitor enter
 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
   // the current locking is from JNI instead of Java code
   if (UseBiasedLocking) {
-    BiasedLocking::revoke_and_rebias(obj, false, THREAD);
-    assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+    BiasedLocking::revoke(obj, THREAD);
+    assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
   THREAD->set_current_pending_monitor_is_from_java(false);
   inflate(THREAD, obj(), inflate_cause_jni_enter)->enter(THREAD);
   THREAD->set_current_pending_monitor_is_from_java(true);
   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(THREAD, obj()));
@@ -430,54 +658,55 @@
 
 // NOTE: must use heavy weight monitor to handle jni monitor exit
 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
   if (UseBiasedLocking) {
     Handle h_obj(THREAD, obj);
-    BiasedLocking::revoke_and_rebias(h_obj, false, THREAD);
+    BiasedLocking::revoke(h_obj, THREAD);
     obj = h_obj();
   }
-  assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+  assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
 
   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
-  // If this thread has locked the object, exit the monitor.  Note:  can't use
-  // monitor->check(CHECK); must exit even if an exception is pending.
-  if (monitor->check(THREAD)) {
+  // If this thread has locked the object, exit the monitor. We
+  // intentionally do not use CHECK here because we must exit the
+  // monitor even if an exception is pending.
+  if (monitor->check_owner(THREAD)) {
     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(THREAD, obj));
     monitor->exit(true, THREAD);
   }
 }
 
 // -----------------------------------------------------------------------------
 // Internal VM locks on java objects
 // standard constructor, allows locking failures
-ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool doLock) {
-  _dolock = doLock;
+ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool do_lock) {
+  _dolock = do_lock;
   _thread = thread;
-  debug_only(if (StrictSafepointChecks) _thread->check_for_valid_safepoint_state(false);)
+  _thread->check_for_valid_safepoint_state();
   _obj = obj;
 
   if (_dolock) {
-    ObjectSynchronizer::fast_enter(_obj, &_lock, false, _thread);
+    ObjectSynchronizer::enter(_obj, &_lock, _thread);
     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));
   }
 }
 
 ObjectLocker::~ObjectLocker() {
   if (_dolock) {
     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));
-    ObjectSynchronizer::fast_exit(_obj(), &_lock, _thread);
+    ObjectSynchronizer::exit(_obj(), &_lock, _thread);
   }
 }
 
 
 // -----------------------------------------------------------------------------
 //  Wait/Notify/NotifyAll
 // NOTE: must use heavy weight monitor to handle wait()
 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
   if (UseBiasedLocking) {
-    BiasedLocking::revoke_and_rebias(obj, false, THREAD);
-    assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+    BiasedLocking::revoke(obj, THREAD);
+    assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
   if (millis < 0) {
     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "timeout value is negative");
   }
   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
@@ -499,14 +728,14 @@
   // and change this function back into a "void" func.
   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
   return dtrace_waited_probe(monitor, obj, THREAD);
 }
 
-void ObjectSynchronizer::waitUninterruptibly(Handle obj, jlong millis, TRAPS) {
+void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {
   if (UseBiasedLocking) {
-    BiasedLocking::revoke_and_rebias(obj, false, THREAD);
-    assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+    BiasedLocking::revoke(obj, THREAD);
+    assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
   if (millis < 0) {
     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "timeout value is negative");
   }
   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
@@ -519,30 +748,30 @@
   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));
 }
 
 void ObjectSynchronizer::notify(Handle obj, TRAPS) {
   if (UseBiasedLocking) {
-    BiasedLocking::revoke_and_rebias(obj, false, THREAD);
-    assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+    BiasedLocking::revoke(obj, THREAD);
+    assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
 
-  markOop mark = obj->mark();
-  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {
+  markWord mark = obj->mark();
+  if (mark.has_locker() && THREAD->is_lock_owned((address)mark.locker())) {
     return;
   }
   inflate(THREAD, obj(), inflate_cause_notify)->notify(THREAD);
 }
 
 // NOTE: see comment of notify()
 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
   if (UseBiasedLocking) {
-    BiasedLocking::revoke_and_rebias(obj, false, THREAD);
-    assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+    BiasedLocking::revoke(obj, THREAD);
+    assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
 
-  markOop mark = obj->mark();
-  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {
+  markWord mark = obj->mark();
+  if (mark.has_locker() && THREAD->is_lock_owned((address)mark.locker())) {
     return;
   }
   inflate(THREAD, obj(), inflate_cause_notify)->notifyAll(THREAD);
 }
 
@@ -566,40 +795,39 @@
 // As a general policy we use "volatile" to control compiler-based reordering
 // and explicit fences (barriers) to control for architectural reordering
 // performed by the CPU(s) or platform.
 
 struct SharedGlobals {
-  char         _pad_prefix[DEFAULT_CACHE_LINE_SIZE];
+  char         _pad_prefix[OM_CACHE_LINE_SIZE];
   // These are highly shared mostly-read variables.
   // To avoid false-sharing they need to be the sole occupants of a cache line.
-  volatile int stwRandom;
-  volatile int stwCycle;
-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int) * 2);
+  volatile int stw_random;
+  volatile int stw_cycle;
+  DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(volatile int) * 2);
   // Hot RW variable -- Sequester to avoid false-sharing
-  volatile int hcSequence;
-  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int));
+  volatile int hc_sequence;
+  DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(volatile int));
 };
 
 static SharedGlobals GVars;
-static int MonitorScavengeThreshold = 1000000;
-static volatile int ForceMonitorScavenge = 0; // Scavenge required and pending
+static int _forceMonitorScavenge = 0; // Scavenge required and pending
 
-static markOop ReadStableMark(oop obj) {
-  markOop mark = obj->mark();
-  if (!mark->is_being_inflated()) {
+static markWord read_stable_mark(oop obj) {
+  markWord mark = obj->mark();
+  if (!mark.is_being_inflated()) {
     return mark;       // normal fast-path return
   }
 
   int its = 0;
   for (;;) {
-    markOop mark = obj->mark();
-    if (!mark->is_being_inflated()) {
+    markWord mark = obj->mark();
+    if (!mark.is_being_inflated()) {
       return mark;    // normal fast-path return
     }
 
     // The object is being inflated by some other thread.
-    // The caller of ReadStableMark() must wait for inflation to complete.
+    // The caller of read_stable_mark() must wait for inflation to complete.
     // Avoid live-lock
     // TODO: consider calling SafepointSynchronize::do_call_back() while
     // spinning to see if there's a safepoint pending.  If so, immediately
     // yielding or blocking would be appropriate.  Avoid spinning while
     // there is a safepoint pending.
@@ -629,13 +857,13 @@
         int ix = (cast_from_oop<intptr_t>(obj) >> 5) & (NINFLATIONLOCKS-1);
         int YieldThenBlock = 0;
         assert(ix >= 0 && ix < NINFLATIONLOCKS, "invariant");
         assert((NINFLATIONLOCKS & (NINFLATIONLOCKS-1)) == 0, "invariant");
         Thread::muxAcquire(gInflationLocks + ix, "gInflationLock");
-        while (obj->mark() == markOopDesc::INFLATING()) {
+        while (obj->mark() == markWord::INFLATING()) {
           // Beware: NakedYield() is advisory and has almost no effect on some platforms
-          // so we periodically call Self->_ParkEvent->park(1).
+          // so we periodically call self->_ParkEvent->park(1).
           // We use a mixed spin/yield/block mechanism.
           if ((YieldThenBlock++) >= 16) {
             Thread::current()->_ParkEvent->park(1);
           } else {
             os::naked_yield();
@@ -650,166 +878,172 @@
 }
 
 // hashCode() generation :
 //
 // Possibilities:
-// * MD5Digest of {obj,stwRandom}
-// * CRC32 of {obj,stwRandom} or any linear-feedback shift register function.
+// * MD5Digest of {obj,stw_random}
+// * CRC32 of {obj,stw_random} or any linear-feedback shift register function.
 // * A DES- or AES-style SBox[] mechanism
 // * One of the Phi-based schemes, such as:
 //   2654435761 = 2^32 * Phi (golden ratio)
-//   HashCodeValue = ((uintptr_t(obj) >> 3) * 2654435761) ^ GVars.stwRandom ;
+//   HashCodeValue = ((uintptr_t(obj) >> 3) * 2654435761) ^ GVars.stw_random ;
 // * A variation of Marsaglia's shift-xor RNG scheme.
-// * (obj ^ stwRandom) is appealing, but can result
+// * (obj ^ stw_random) is appealing, but can result
 //   in undesirable regularity in the hashCode values of adjacent objects
 //   (objects allocated back-to-back, in particular).  This could potentially
 //   result in hashtable collisions and reduced hashtable efficiency.
 //   There are simple ways to "diffuse" the middle address bits over the
 //   generated hashCode values:
 
-static inline intptr_t get_next_hash(Thread * Self, oop obj) {
+static inline intptr_t get_next_hash(Thread* self, oop obj) {
   intptr_t value = 0;
   if (hashCode == 0) {
     // This form uses global Park-Miller RNG.
     // On MP system we'll have lots of RW access to a global, so the
     // mechanism induces lots of coherency traffic.
     value = os::random();
   } else if (hashCode == 1) {
     // This variation has the property of being stable (idempotent)
     // between STW operations.  This can be useful in some of the 1-0
     // synchronization schemes.
-    intptr_t addrBits = cast_from_oop<intptr_t>(obj) >> 3;
-    value = addrBits ^ (addrBits >> 5) ^ GVars.stwRandom;
+    intptr_t addr_bits = cast_from_oop<intptr_t>(obj) >> 3;
+    value = addr_bits ^ (addr_bits >> 5) ^ GVars.stw_random;
   } else if (hashCode == 2) {
     value = 1;            // for sensitivity testing
   } else if (hashCode == 3) {
-    value = ++GVars.hcSequence;
+    value = ++GVars.hc_sequence;
   } else if (hashCode == 4) {
     value = cast_from_oop<intptr_t>(obj);
   } else {
     // Marsaglia's xor-shift scheme with thread-specific state
     // This is probably the best overall implementation -- we'll
     // likely make this the default in future releases.
-    unsigned t = Self->_hashStateX;
+    unsigned t = self->_hashStateX;
     t ^= (t << 11);
-    Self->_hashStateX = Self->_hashStateY;
-    Self->_hashStateY = Self->_hashStateZ;
-    Self->_hashStateZ = Self->_hashStateW;
-    unsigned v = Self->_hashStateW;
+    self->_hashStateX = self->_hashStateY;
+    self->_hashStateY = self->_hashStateZ;
+    self->_hashStateZ = self->_hashStateW;
+    unsigned v = self->_hashStateW;
     v = (v ^ (v >> 19)) ^ (t ^ (t >> 8));
-    Self->_hashStateW = v;
+    self->_hashStateW = v;
     value = v;
   }
 
-  value &= markOopDesc::hash_mask;
+  value &= markWord::hash_mask;
   if (value == 0) value = 0xBAD;
-  assert(value != markOopDesc::no_hash, "invariant");
+  assert(value != markWord::no_hash, "invariant");
   return value;
 }
 
-intptr_t ObjectSynchronizer::FastHashCode(Thread * Self, oop obj) {
+intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {
   if (UseBiasedLocking) {
     // NOTE: many places throughout the JVM do not expect a safepoint
     // to be taken here, in particular most operations on perm gen
     // objects. However, we only ever bias Java instances and all of
     // the call sites of identity_hash that might revoke biases have
     // been checked to make sure they can handle a safepoint. The
     // added check of the bias pattern is to avoid useless calls to
     // thread-local storage.
-    if (obj->mark()->has_bias_pattern()) {
+    if (obj->mark().has_bias_pattern()) {
       // Handle for oop obj in case of STW safepoint
-      Handle hobj(Self, obj);
+      Handle hobj(self, obj);
       // Relaxing assertion for bug 6320749.
       assert(Universe::verify_in_progress() ||
              !SafepointSynchronize::is_at_safepoint(),
              "biases should not be seen by VM thread here");
-      BiasedLocking::revoke_and_rebias(hobj, false, JavaThread::current());
+      BiasedLocking::revoke(hobj, JavaThread::current());
       obj = hobj();
-      assert(!obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+      assert(!obj->mark().has_bias_pattern(), "biases should be revoked by now");
     }
   }
 
   // hashCode() is a heap mutator ...
   // Relaxing assertion for bug 6320749.
   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
          !SafepointSynchronize::is_at_safepoint(), "invariant");
   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
-         Self->is_Java_thread() , "invariant");
+         self->is_Java_thread() , "invariant");
   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
-         ((JavaThread *)Self)->thread_state() != _thread_blocked, "invariant");
+         ((JavaThread *)self)->thread_state() != _thread_blocked, "invariant");
 
   ObjectMonitor* monitor = NULL;
-  markOop temp, test;
+  markWord temp, test;
   intptr_t hash;
-  markOop mark = ReadStableMark(obj);
+  markWord mark = read_stable_mark(obj);
 
   // object should remain ineligible for biased locking
-  assert(!mark->has_bias_pattern(), "invariant");
+  assert(!mark.has_bias_pattern(), "invariant");
 
-  if (mark->is_neutral()) {
-    hash = mark->hash();              // this is a normal header
-    if (hash != 0) {                  // if it has hash, just return it
+  if (mark.is_neutral()) {            // if this is a normal header
+    hash = mark.hash();
+    if (hash != 0) {                  // if it has a hash, just return it
       return hash;
     }
-    hash = get_next_hash(Self, obj);  // allocate a new hash code
-    temp = mark->copy_set_hash(hash); // merge the hash code into header
-    // use (machine word version) atomic operation to install the hash
+    hash = get_next_hash(self, obj);  // get a new hash
+    temp = mark.copy_set_hash(hash);  // merge the hash into header
+                                      // try to install the hash
     test = obj->cas_set_mark(temp, mark);
-    if (test == mark) {
+    if (test == mark) {               // if the hash was installed, return it
       return hash;
     }
-    // If atomic operation failed, we must inflate the header
-    // into heavy weight monitor. We could add more code here
-    // for fast path, but it does not worth the complexity.
-  } else if (mark->has_monitor()) {
-    monitor = mark->monitor();
+    // Failed to install the hash. It could be that another thread
+    // installed the hash just before our attempt or inflation has
+    // occurred or... so we fall thru to inflate the monitor for
+    // stability and then install the hash.
+  } else if (mark.has_monitor()) {
+    monitor = mark.monitor();
     temp = monitor->header();
-    assert(temp->is_neutral(), "invariant: header=" INTPTR_FORMAT, p2i((address)temp));
-    hash = temp->hash();
-    if (hash != 0) {
+    assert(temp.is_neutral(), "invariant: header=" INTPTR_FORMAT, temp.value());
+    hash = temp.hash();
+    if (hash != 0) {                  // if it has a hash, just return it
       return hash;
     }
-    // Skip to the following code to reduce code size
-  } else if (Self->is_lock_owned((address)mark->locker())) {
-    temp = mark->displaced_mark_helper(); // this is a lightweight monitor owned
-    assert(temp->is_neutral(), "invariant: header=" INTPTR_FORMAT, p2i((address)temp));
-    hash = temp->hash();              // by current thread, check if the displaced
-    if (hash != 0) {                  // header contains hash code
+    // Fall thru so we only have one place that installs the hash in
+    // the ObjectMonitor.
+  } else if (self->is_lock_owned((address)mark.locker())) {
+    // This is a stack lock owned by the calling thread so fetch the
+    // displaced markWord from the BasicLock on the stack.
+    temp = mark.displaced_mark_helper();
+    assert(temp.is_neutral(), "invariant: header=" INTPTR_FORMAT, temp.value());
+    hash = temp.hash();
+    if (hash != 0) {                  // if it has a hash, just return it
       return hash;
     }
     // WARNING:
-    //   The displaced header is strictly immutable.
-    // It can NOT be changed in ANY cases. So we have
-    // to inflate the header into heavyweight monitor
-    // even the current thread owns the lock. The reason
-    // is the BasicLock (stack slot) will be asynchronously
-    // read by other threads during the inflate() function.
-    // Any change to stack may not propagate to other threads
-    // correctly.
-  }
-
-  // Inflate the monitor to set hash code
-  monitor = inflate(Self, obj, inflate_cause_hash_code);
-  // Load displaced header and check it has hash code
+    // The displaced header in the BasicLock on a thread's stack
+    // is strictly immutable. It CANNOT be changed in ANY cases.
+    // So we have to inflate the stack lock into an ObjectMonitor
+    // even if the current thread owns the lock. The BasicLock on
+    // a thread's stack can be asynchronously read by other threads
+    // during an inflate() call so any change to that stack memory
+    // may not propagate to other threads correctly.
+  }
+
+  // Inflate the monitor to set the hash.
+  monitor = inflate(self, obj, inflate_cause_hash_code);
+  // Load ObjectMonitor's header/dmw field and see if it has a hash.
   mark = monitor->header();
-  assert(mark->is_neutral(), "invariant: header=" INTPTR_FORMAT, p2i((address)mark));
-  hash = mark->hash();
-  if (hash == 0) {
-    hash = get_next_hash(Self, obj);
-    temp = mark->copy_set_hash(hash); // merge hash code into header
-    assert(temp->is_neutral(), "invariant: header=" INTPTR_FORMAT, p2i((address)temp));
-    test = Atomic::cmpxchg(temp, monitor->header_addr(), mark);
+  assert(mark.is_neutral(), "invariant: header=" INTPTR_FORMAT, mark.value());
+  hash = mark.hash();
+  if (hash == 0) {                    // if it does not have a hash
+    hash = get_next_hash(self, obj);  // get a new hash
+    temp = mark.copy_set_hash(hash);  // merge the hash into header
+    assert(temp.is_neutral(), "invariant: header=" INTPTR_FORMAT, temp.value());
+    uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor->header_addr(), mark.value(), temp.value());
+    test = markWord(v);
     if (test != mark) {
-      // The only update to the header in the monitor (outside GC)
-      // is install the hash code. If someone add new usage of
-      // displaced header, please update this code
-      hash = test->hash();
-      assert(test->is_neutral(), "invariant: header=" INTPTR_FORMAT, p2i((address)test));
-      assert(hash != 0, "Trivial unexpected object/monitor header usage.");
+      // The attempt to update the ObjectMonitor's header/dmw field
+      // did not work. This can happen if another thread managed to
+      // merge in the hash just before our cmpxchg().
+      // If we add any new usages of the header/dmw field, this code
+      // will need to be updated.
+      hash = test.hash();
+      assert(test.is_neutral(), "invariant: header=" INTPTR_FORMAT, test.value());
+      assert(hash != 0, "should only have lost the race to a thread that set a non-zero hash");
     }
   }
-  // We finally get the hash
+  // We finally get the hash.
   return hash;
 }
 
 // Deprecated -- use FastHashCode() instead.
 
@@ -819,30 +1053,30 @@
 
 
 bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
                                                    Handle h_obj) {
   if (UseBiasedLocking) {
-    BiasedLocking::revoke_and_rebias(h_obj, false, thread);
-    assert(!h_obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+    BiasedLocking::revoke(h_obj, thread);
+    assert(!h_obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
 
   assert(thread == JavaThread::current(), "Can only be called on current thread");
   oop obj = h_obj();
 
-  markOop mark = ReadStableMark(obj);
+  markWord mark = read_stable_mark(obj);
 
   // Uncontended case, header points to stack
-  if (mark->has_locker()) {
-    return thread->is_lock_owned((address)mark->locker());
+  if (mark.has_locker()) {
+    return thread->is_lock_owned((address)mark.locker());
   }
   // Contended case, header points to ObjectMonitor (tagged pointer)
-  if (mark->has_monitor()) {
-    ObjectMonitor* monitor = mark->monitor();
+  if (mark.has_monitor()) {
+    ObjectMonitor* monitor = mark.monitor();
     return monitor->is_entered(thread) != 0;
   }
   // Unlocked case, header in place
-  assert(mark->is_neutral(), "sanity check");
+  assert(mark.is_neutral(), "sanity check");
   return false;
 }
 
 // Be aware of this method could revoke bias of the lock object.
 // This method queries the ownership of the lock handle specified by 'h_obj'.
@@ -856,66 +1090,66 @@
   assert(!SafepointSynchronize::is_at_safepoint(), "invariant");
   assert(self->thread_state() != _thread_blocked, "invariant");
 
   // Possible mark states: neutral, biased, stack-locked, inflated
 
-  if (UseBiasedLocking && h_obj()->mark()->has_bias_pattern()) {
+  if (UseBiasedLocking && h_obj()->mark().has_bias_pattern()) {
     // CASE: biased
-    BiasedLocking::revoke_and_rebias(h_obj, false, self);
-    assert(!h_obj->mark()->has_bias_pattern(),
+    BiasedLocking::revoke(h_obj, self);
+    assert(!h_obj->mark().has_bias_pattern(),
            "biases should be revoked by now");
   }
 
   assert(self == JavaThread::current(), "Can only be called on current thread");
   oop obj = h_obj();
-  markOop mark = ReadStableMark(obj);
+  markWord mark = read_stable_mark(obj);
 
   // CASE: stack-locked.  Mark points to a BasicLock on the owner's stack.
-  if (mark->has_locker()) {
-    return self->is_lock_owned((address)mark->locker()) ?
+  if (mark.has_locker()) {
+    return self->is_lock_owned((address)mark.locker()) ?
       owner_self : owner_other;
   }
 
   // CASE: inflated. Mark (tagged pointer) points to an ObjectMonitor.
   // The Object:ObjectMonitor relationship is stable as long as we're
   // not at a safepoint.
-  if (mark->has_monitor()) {
-    void * owner = mark->monitor()->_owner;
+  if (mark.has_monitor()) {
+    void* owner = mark.monitor()->_owner;
     if (owner == NULL) return owner_none;
     return (owner == self ||
             self->is_lock_owned((address)owner)) ? owner_self : owner_other;
   }
 
   // CASE: neutral
-  assert(mark->is_neutral(), "sanity check");
+  assert(mark.is_neutral(), "sanity check");
   return owner_none;           // it's unlocked
 }
 
 // FIXME: jvmti should call this
 JavaThread* ObjectSynchronizer::get_lock_owner(ThreadsList * t_list, Handle h_obj) {
   if (UseBiasedLocking) {
     if (SafepointSynchronize::is_at_safepoint()) {
       BiasedLocking::revoke_at_safepoint(h_obj);
     } else {
-      BiasedLocking::revoke_and_rebias(h_obj, false, JavaThread::current());
+      BiasedLocking::revoke(h_obj, JavaThread::current());
     }
-    assert(!h_obj->mark()->has_bias_pattern(), "biases should be revoked by now");
+    assert(!h_obj->mark().has_bias_pattern(), "biases should be revoked by now");
   }
 
   oop obj = h_obj();
   address owner = NULL;
 
-  markOop mark = ReadStableMark(obj);
+  markWord mark = read_stable_mark(obj);
 
   // Uncontended case, header points to stack
-  if (mark->has_locker()) {
-    owner = (address) mark->locker();
+  if (mark.has_locker()) {
+    owner = (address) mark.locker();
   }
 
   // Contended case, header points to ObjectMonitor (tagged pointer)
-  else if (mark->has_monitor()) {
-    ObjectMonitor* monitor = mark->monitor();
+  else if (mark.has_monitor()) {
+    ObjectMonitor* monitor = mark.monitor();
     assert(monitor != NULL, "monitor should be non-null");
     owner = (address) monitor->owner();
   }
 
   if (owner != NULL) {
@@ -924,52 +1158,67 @@
   }
 
   // Unlocked case, header in place
   // Cannot have assertion since this object may have been
   // locked by another thread when reaching here.
-  // assert(mark->is_neutral(), "sanity check");
+  // assert(mark.is_neutral(), "sanity check");
 
   return NULL;
 }
 
 // Visitors ...
 
 void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure) {
-  PaddedEnd<ObjectMonitor> * block = OrderAccess::load_acquire(&gBlockList);
+  PaddedObjectMonitor* block = Atomic::load(&g_block_list);
   while (block != NULL) {
     assert(block->object() == CHAINMARKER, "must be a block header");
     for (int i = _BLOCKSIZE - 1; i > 0; i--) {
       ObjectMonitor* mid = (ObjectMonitor *)(block + i);
       oop object = (oop)mid->object();
       if (object != NULL) {
+        // Only process with closure if the object is set.
         closure->do_monitor(mid);
       }
     }
-    block = (PaddedEnd<ObjectMonitor> *)block->FreeNext;
+    // unmarked_next() is not needed with g_block_list (no locking
+    // used with block linkage _next_om fields).
+    block = (PaddedObjectMonitor*)block->next_om();
   }
 }
 
-// Get the next block in the block list.
-static inline PaddedEnd<ObjectMonitor>* next(PaddedEnd<ObjectMonitor>* block) {
-  assert(block->object() == CHAINMARKER, "must be a block header");
-  block = (PaddedEnd<ObjectMonitor>*) block->FreeNext;
-  assert(block == NULL || block->object() == CHAINMARKER, "must be a block header");
-  return block;
-}
-
 static bool monitors_used_above_threshold() {
-  if (gMonitorPopulation == 0) {
+  int population = Atomic::load(&om_list_globals._population);
+  if (population == 0) {
     return false;
   }
-  int monitors_used = gMonitorPopulation - gMonitorFreeCount;
-  int monitor_usage = (monitors_used * 100LL) / gMonitorPopulation;
-  return monitor_usage > MonitorUsedDeflationThreshold;
+  if (MonitorUsedDeflationThreshold > 0) {
+    int monitors_used = population - Atomic::load(&om_list_globals._free_count);
+    int monitor_usage = (monitors_used * 100LL) / population;
+    return monitor_usage > MonitorUsedDeflationThreshold;
+  }
+  return false;
+}
+
+// Returns true if MonitorBound is set (> 0) and if the specified
+// cnt is > MonitorBound. Otherwise returns false.
+static bool is_MonitorBound_exceeded(const int cnt) {
+  const int mx = MonitorBound;
+  return mx > 0 && cnt > mx;
 }
 
 bool ObjectSynchronizer::is_cleanup_needed() {
-  if (MonitorUsedDeflationThreshold > 0) {
-    return monitors_used_above_threshold();
+  if (monitors_used_above_threshold()) {
+    // Too many monitors in use.
+    return true;
+  }
+  return needs_monitor_scavenge();
+}
+
+bool ObjectSynchronizer::needs_monitor_scavenge() {
+  if (Atomic::load(&_forceMonitorScavenge) == 1) {
+    log_info(monitorinflation)("Monitor scavenge needed, triggering safepoint cleanup.");
+    return true;
   }
   return false;
 }
 
 void ObjectSynchronizer::oops_do(OopClosure* f) {
@@ -978,51 +1227,51 @@
   global_used_oops_do(f);
 }
 
 void ObjectSynchronizer::global_used_oops_do(OopClosure* f) {
   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
-  list_oops_do(gOmInUseList, f);
+  list_oops_do(Atomic::load(&om_list_globals._in_use_list), f);
 }
 
 void ObjectSynchronizer::thread_local_used_oops_do(Thread* thread, OopClosure* f) {
   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
-  list_oops_do(thread->omInUseList, f);
+  list_oops_do(thread->om_in_use_list, f);
 }
 
 void ObjectSynchronizer::list_oops_do(ObjectMonitor* list, OopClosure* f) {
   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
-  ObjectMonitor* mid;
-  for (mid = list; mid != NULL; mid = mid->FreeNext) {
+  // The oops_do() phase does not overlap with monitor deflation
+  // so no need to lock ObjectMonitors for the list traversal.
+  for (ObjectMonitor* mid = list; mid != NULL; mid = unmarked_next(mid)) {
     if (mid->object() != NULL) {
       f->do_oop((oop*)mid->object_addr());
     }
   }
 }
 
 
 // -----------------------------------------------------------------------------
 // ObjectMonitor Lifecycle
 // -----------------------
-// Inflation unlinks monitors from the global gFreeList and
-// associates them with objects.  Deflation -- which occurs at
-// STW-time -- disassociates idle monitors from objects.  Such
-// scavenged monitors are returned to the gFreeList.
-//
-// The global list is protected by gListLock.  All the critical sections
-// are short and operate in constant-time.
+// Inflation unlinks monitors from om_list_globals._free_list or a per-thread
+// free list and associates them with objects. Deflation -- which occurs at
+// STW-time -- disassociates idle monitors from objects.
+// Such scavenged monitors are returned to the om_list_globals._free_list.
 //
 // ObjectMonitors reside in type-stable memory (TSM) and are immortal.
 //
 // Lifecycle:
-// --   unassigned and on the global free list
-// --   unassigned and on a thread's private omFreeList
+// --   unassigned and on the om_list_globals._free_list
+// --   unassigned and on a per-thread free list
 // --   assigned to an object.  The object is inflated and the mark refers
-//      to the objectmonitor.
+//      to the ObjectMonitor.
 
 
 // Constraining monitor pool growth via MonitorBound ...
 //
+// If MonitorBound is not set (<= 0), MonitorBound checks are disabled.
+//
 // The monitor pool is grow-only.  We scavenge at STW safepoint-time, but the
 // the rate of scavenging is driven primarily by GC.  As such,  we can find
 // an inordinate number of monitors in circulation.
 // To avoid that scenario we can artificially induce a STW safepoint
 // if the pool appears to be growing past some reasonable bound.
@@ -1031,275 +1280,344 @@
 // type of limit.  Beware that if MonitorBound is set to too low a value
 // we could just loop. In addition, if MonitorBound is set to a low value
 // we'll incur more safepoints, which are harmful to performance.
 // See also: GuaranteedSafepointInterval
 //
-// The current implementation uses asynchronous VM operations.
+// If MonitorBound is set, the boundry applies to
+//     (om_list_globals._population - om_list_globals._free_count)
+// i.e., if there are not enough ObjectMonitors on the global free list,
+// then a safepoint deflation is induced. Picking a good MonitorBound value
+// is non-trivial.
 
-static void InduceScavenge(Thread * Self, const char * Whence) {
+static void InduceScavenge(Thread* self, const char * Whence) {
   // Induce STW safepoint to trim monitors
   // Ultimately, this results in a call to deflate_idle_monitors() in the near future.
-  // More precisely, trigger an asynchronous STW safepoint as the number
+  // More precisely, trigger a cleanup safepoint as the number
   // of active monitors passes the specified threshold.
   // TODO: assert thread state is reasonable
 
-  if (ForceMonitorScavenge == 0 && Atomic::xchg (1, &ForceMonitorScavenge) == 0) {
-    // Induce a 'null' safepoint to scavenge monitors
-    // Must VM_Operation instance be heap allocated as the op will be enqueue and posted
-    // to the VMthread and have a lifespan longer than that of this activation record.
-    // The VMThread will delete the op when completed.
-    VMThread::execute(new VM_ScavengeMonitors());
+  if (Atomic::xchg(&_forceMonitorScavenge, 1) == 0) {
+    VMThread::check_for_forced_cleanup();
   }
 }
 
-ObjectMonitor* ObjectSynchronizer::omAlloc(Thread * Self) {
+ObjectMonitor* ObjectSynchronizer::om_alloc(Thread* self) {
   // A large MAXPRIVATE value reduces both list lock contention
   // and list coherency traffic, but also tends to increase the
-  // number of objectMonitors in circulation as well as the STW
+  // number of ObjectMonitors in circulation as well as the STW
   // scavenge costs.  As usual, we lean toward time in space-time
   // tradeoffs.
   const int MAXPRIVATE = 1024;
+  NoSafepointVerifier nsv;
+
+  stringStream ss;
   for (;;) {
-    ObjectMonitor * m;
+    ObjectMonitor* m;
 
-    // 1: try to allocate from the thread's local omFreeList.
+    // 1: try to allocate from the thread's local om_free_list.
     // Threads will attempt to allocate first from their local list, then
-    // from the global list, and only after those attempts fail will the thread
-    // attempt to instantiate new monitors.   Thread-local free lists take
-    // heat off the gListLock and improve allocation latency, as well as reducing
-    // coherency traffic on the shared global list.
-    m = Self->omFreeList;
+    // from the global list, and only after those attempts fail will the
+    // thread attempt to instantiate new monitors. Thread-local free lists
+    // improve allocation latency, as well as reducing coherency traffic
+    // on the shared global list.
+    m = take_from_start_of_om_free_list(self);
     if (m != NULL) {
-      Self->omFreeList = m->FreeNext;
-      Self->omFreeCount--;
       guarantee(m->object() == NULL, "invariant");
-      m->FreeNext = Self->omInUseList;
-      Self->omInUseList = m;
-      Self->omInUseCount++;
+      prepend_to_om_in_use_list(self, m);
       return m;
     }
 
-    // 2: try to allocate from the global gFreeList
-    // CONSIDER: use muxTry() instead of muxAcquire().
-    // If the muxTry() fails then drop immediately into case 3.
+    // 2: try to allocate from the global om_list_globals._free_list
     // If we're using thread-local free lists then try
     // to reprovision the caller's free list.
-    if (gFreeList != NULL) {
-      // Reprovision the thread's omFreeList.
+    if (Atomic::load(&om_list_globals._free_list) != NULL) {
+      // Reprovision the thread's om_free_list.
       // Use bulk transfers to reduce the allocation rate and heat
       // on various locks.
-      Thread::muxAcquire(&gListLock, "omAlloc(1)");
-      for (int i = Self->omFreeProvision; --i >= 0 && gFreeList != NULL;) {
-        gMonitorFreeCount--;
-        ObjectMonitor * take = gFreeList;
-        gFreeList = take->FreeNext;
+      for (int i = self->om_free_provision; --i >= 0;) {
+        ObjectMonitor* take = take_from_start_of_global_free_list();
+        if (take == NULL) {
+          break;  // No more are available.
+        }
         guarantee(take->object() == NULL, "invariant");
-        guarantee(!take->is_busy(), "invariant");
         take->Recycle();
-        omRelease(Self, take, false);
+        om_release(self, take, false);
       }
-      Thread::muxRelease(&gListLock);
-      Self->omFreeProvision += 1 + (Self->omFreeProvision/2);
-      if (Self->omFreeProvision > MAXPRIVATE) Self->omFreeProvision = MAXPRIVATE;
+      self->om_free_provision += 1 + (self->om_free_provision / 2);
+      if (self->om_free_provision > MAXPRIVATE) self->om_free_provision = MAXPRIVATE;
 
-      const int mx = MonitorBound;
-      if (mx > 0 && (gMonitorPopulation-gMonitorFreeCount) > mx) {
-        // We can't safely induce a STW safepoint from omAlloc() as our thread
+      if (is_MonitorBound_exceeded(Atomic::load(&om_list_globals._population) -
+                                   Atomic::load(&om_list_globals._free_count))) {
+        // Not enough ObjectMonitors on the global free list.
+        // We can't safely induce a STW safepoint from om_alloc() as our thread
         // state may not be appropriate for such activities and callers may hold
         // naked oops, so instead we defer the action.
-        InduceScavenge(Self, "omAlloc");
+        InduceScavenge(self, "om_alloc");
       }
       continue;
     }
 
     // 3: allocate a block of new ObjectMonitors
     // Both the local and global free lists are empty -- resort to malloc().
-    // In the current implementation objectMonitors are TSM - immortal.
+    // In the current implementation ObjectMonitors are TSM - immortal.
     // Ideally, we'd write "new ObjectMonitor[_BLOCKSIZE], but we want
     // each ObjectMonitor to start at the beginning of a cache line,
     // so we use align_up().
     // A better solution would be to use C++ placement-new.
     // BEWARE: As it stands currently, we don't run the ctors!
     assert(_BLOCKSIZE > 1, "invariant");
-    size_t neededsize = sizeof(PaddedEnd<ObjectMonitor>) * _BLOCKSIZE;
-    PaddedEnd<ObjectMonitor> * temp;
-    size_t aligned_size = neededsize + (DEFAULT_CACHE_LINE_SIZE - 1);
-    void* real_malloc_addr = (void *)NEW_C_HEAP_ARRAY(char, aligned_size,
-                                                      mtInternal);
-    temp = (PaddedEnd<ObjectMonitor> *)
-             align_up(real_malloc_addr, DEFAULT_CACHE_LINE_SIZE);
-
-    // NOTE: (almost) no way to recover if allocation failed.
-    // We might be able to induce a STW safepoint and scavenge enough
-    // objectMonitors to permit progress.
-    if (temp == NULL) {
-      vm_exit_out_of_memory(neededsize, OOM_MALLOC_ERROR,
-                            "Allocate ObjectMonitors");
-    }
+    size_t neededsize = sizeof(PaddedObjectMonitor) * _BLOCKSIZE;
+    PaddedObjectMonitor* temp;
+    size_t aligned_size = neededsize + (OM_CACHE_LINE_SIZE - 1);
+    void* real_malloc_addr = NEW_C_HEAP_ARRAY(char, aligned_size, mtInternal);
+    temp = (PaddedObjectMonitor*)align_up(real_malloc_addr, OM_CACHE_LINE_SIZE);
     (void)memset((void *) temp, 0, neededsize);
 
     // Format the block.
     // initialize the linked list, each monitor points to its next
     // forming the single linked free list, the very first monitor
     // will points to next block, which forms the block list.
-    // The trick of using the 1st element in the block as gBlockList
+    // The trick of using the 1st element in the block as g_block_list
     // linkage should be reconsidered.  A better implementation would
     // look like: class Block { Block * next; int N; ObjectMonitor Body [N] ; }
 
     for (int i = 1; i < _BLOCKSIZE; i++) {
-      temp[i].FreeNext = (ObjectMonitor *)&temp[i+1];
+      temp[i].set_next_om((ObjectMonitor*)&temp[i + 1]);
     }
 
     // terminate the last monitor as the end of list
-    temp[_BLOCKSIZE - 1].FreeNext = NULL;
+    temp[_BLOCKSIZE - 1].set_next_om((ObjectMonitor*)NULL);
 
     // Element [0] is reserved for global list linkage
     temp[0].set_object(CHAINMARKER);
 
     // Consider carving out this thread's current request from the
     // block in hand.  This avoids some lock traffic and redundant
     // list activity.
 
-    // Acquire the gListLock to manipulate gBlockList and gFreeList.
-    // An Oyama-Taura-Yonezawa scheme might be more efficient.
-    Thread::muxAcquire(&gListLock, "omAlloc(2)");
-    gMonitorPopulation += _BLOCKSIZE-1;
-    gMonitorFreeCount += _BLOCKSIZE-1;
-
-    // Add the new block to the list of extant blocks (gBlockList).
-    // The very first objectMonitor in a block is reserved and dedicated.
-    // It serves as blocklist "next" linkage.
-    temp[0].FreeNext = gBlockList;
-    // There are lock-free uses of gBlockList so make sure that
-    // the previous stores happen before we update gBlockList.
-    OrderAccess::release_store(&gBlockList, temp);
-
-    // Add the new string of objectMonitors to the global free list
-    temp[_BLOCKSIZE - 1].FreeNext = gFreeList;
-    gFreeList = temp + 1;
-    Thread::muxRelease(&gListLock);
+    prepend_block_to_lists(temp);
   }
 }
 
-// Place "m" on the caller's private per-thread omFreeList.
+// Place "m" on the caller's private per-thread om_free_list.
 // In practice there's no need to clamp or limit the number of
-// monitors on a thread's omFreeList as the only time we'll call
-// omRelease is to return a monitor to the free list after a CAS
-// attempt failed.  This doesn't allow unbounded #s of monitors to
+// monitors on a thread's om_free_list as the only non-allocation time
+// we'll call om_release() is to return a monitor to the free list after
+// a CAS attempt failed. This doesn't allow unbounded #s of monitors to
 // accumulate on a thread's free list.
 //
 // Key constraint: all ObjectMonitors on a thread's free list and the global
 // free list must have their object field set to null. This prevents the
-// scavenger -- deflate_monitor_list() -- from reclaiming them.
+// scavenger -- deflate_monitor_list() -- from reclaiming them while we
+// are trying to release them.
 
-void ObjectSynchronizer::omRelease(Thread * Self, ObjectMonitor * m,
-                                   bool fromPerThreadAlloc) {
-  guarantee(m->header() == NULL, "invariant");
+void ObjectSynchronizer::om_release(Thread* self, ObjectMonitor* m,
+                                    bool from_per_thread_alloc) {
+  guarantee(m->header().value() == 0, "invariant");
   guarantee(m->object() == NULL, "invariant");
-  guarantee(((m->is_busy()|m->_recursions) == 0), "freeing in-use monitor");
-  // Remove from omInUseList
-  if (fromPerThreadAlloc) {
-    ObjectMonitor* cur_mid_in_use = NULL;
-    bool extracted = false;
-    for (ObjectMonitor* mid = Self->omInUseList; mid != NULL; cur_mid_in_use = mid, mid = mid->FreeNext) {
-      if (m == mid) {
-        // extract from per-thread in-use list
-        if (mid == Self->omInUseList) {
-          Self->omInUseList = mid->FreeNext;
-        } else if (cur_mid_in_use != NULL) {
-          cur_mid_in_use->FreeNext = mid->FreeNext; // maintain the current thread in-use list
+  NoSafepointVerifier nsv;
+
+  stringStream ss;
+  guarantee((m->is_busy() | m->_recursions) == 0, "freeing in-use monitor: "
+            "%s, recursions=" INTX_FORMAT, m->is_busy_to_string(&ss),
+            m->_recursions);
+  // _next_om is used for both per-thread in-use and free lists so
+  // we have to remove 'm' from the in-use list first (as needed).
+  if (from_per_thread_alloc) {
+    // Need to remove 'm' from om_in_use_list.
+    ObjectMonitor* mid = NULL;
+    ObjectMonitor* next = NULL;
+
+    // This list walk can only race with another list walker since
+    // deflation can only happen at a safepoint so we don't have to
+    // worry about an ObjectMonitor being removed from this list
+    // while we are walking it.
+
+    // Lock the list head to avoid racing with another list walker.
+    if ((mid = get_list_head_locked(&self->om_in_use_list)) == NULL) {
+      fatal("thread=" INTPTR_FORMAT " in-use list must not be empty.", p2i(self));
+    }
+    next = unmarked_next(mid);
+    if (m == mid) {
+      // First special case:
+      // 'm' matches mid, is the list head and is locked. Switch the list
+      // head to next which unlocks the list head, but leaves the extracted
+      // mid locked:
+      Atomic::store(&self->om_in_use_list, next);
+    } else if (m == next) {
+      // Second special case:
+      // 'm' matches next after the list head and we already have the list
+      // head locked so set mid to what we are extracting:
+      mid = next;
+      // Lock mid to prevent races with a list walker:
+      om_lock(mid);
+      // Update next to what follows mid (if anything):
+      next = unmarked_next(mid);
+      // Switch next after the list head to new next which unlocks the
+      // list head, but leaves the extracted mid locked:
+      self->om_in_use_list->set_next_om(next);
+    } else {
+      // We have to search the list to find 'm'.
+      om_unlock(mid);  // unlock the list head
+      guarantee(next != NULL, "thread=" INTPTR_FORMAT ": om_in_use_list=" INTPTR_FORMAT
+                " is too short.", p2i(self), p2i(self->om_in_use_list));
+      // Our starting anchor is next after the list head which is the
+      // last ObjectMonitor we checked:
+      ObjectMonitor* anchor = next;
+      while ((mid = unmarked_next(anchor)) != NULL) {
+        if (m == mid) {
+          // We found 'm' on the per-thread in-use list so extract it.
+          om_lock(anchor);  // Lock the anchor so we can safely modify it.
+          // Update next to what follows mid (if anything):
+          next = unmarked_next(mid);
+          // Switch next after the anchor to new next which unlocks the
+          // anchor, but leaves the extracted mid locked:
+          anchor->set_next_om(next);
+          break;
+        } else {
+          anchor = mid;
         }
-        extracted = true;
-        Self->omInUseCount--;
-        break;
       }
     }
-    assert(extracted, "Should have extracted from in-use list");
+
+    if (mid == NULL) {
+      // Reached end of the list and didn't find 'm' so:
+      fatal("thread=" INTPTR_FORMAT " must find m=" INTPTR_FORMAT "on om_in_use_list="
+            INTPTR_FORMAT, p2i(self), p2i(m), p2i(self->om_in_use_list));
+    }
+
+    // At this point mid is disconnected from the in-use list so
+    // its lock no longer has any effects on the in-use list.
+    Atomic::dec(&self->om_in_use_count);
+    // Unlock mid, but leave the next value for any lagging list
+    // walkers. It will get cleaned up when mid is prepended to
+    // the thread's free list:
+    om_unlock(mid);
   }
 
-  // FreeNext is used for both omInUseList and omFreeList, so clear old before setting new
-  m->FreeNext = Self->omFreeList;
-  Self->omFreeList = m;
-  Self->omFreeCount++;
+  prepend_to_om_free_list(self, m);
 }
 
-// Return the monitors of a moribund thread's local free list to
-// the global free list.  Typically a thread calls omFlush() when
-// it's dying.  We could also consider having the VM thread steal
-// monitors from threads that have not run java code over a few
-// consecutive STW safepoints.  Relatedly, we might decay
-// omFreeProvision at STW safepoints.
-//
-// Also return the monitors of a moribund thread's omInUseList to
-// a global gOmInUseList under the global list lock so these
-// will continue to be scanned.
+// Return ObjectMonitors on a moribund thread's free and in-use
+// lists to the appropriate global lists. The ObjectMonitors on the
+// per-thread in-use list may still be in use by other threads.
 //
-// We currently call omFlush() from Threads::remove() _before the thread
-// has been excised from the thread list and is no longer a mutator.
-// This means that omFlush() cannot run concurrently with a safepoint and
-// interleave with the deflate_idle_monitors scavenge operator. In particular,
-// this ensures that the thread's monitors are scanned by a GC safepoint,
-// either via Thread::oops_do() (if safepoint happens before omFlush()) or via
-// ObjectSynchronizer::oops_do() (if it happens after omFlush() and the thread's
-// monitors have been transferred to the global in-use list).
-
-void ObjectSynchronizer::omFlush(Thread * Self) {
-  ObjectMonitor * list = Self->omFreeList;  // Null-terminated SLL
-  ObjectMonitor * tail = NULL;
-  int tally = 0;
-  if (list != NULL) {
-    ObjectMonitor * s;
-    // The thread is going away, the per-thread free monitors
-    // are freed via set_owner(NULL)
-    // Link them to tail, which will be linked into the global free list
-    // gFreeList below, under the gListLock
-    for (s = list; s != NULL; s = s->FreeNext) {
-      tally++;
-      tail = s;
-      guarantee(s->object() == NULL, "invariant");
-      guarantee(!s->is_busy(), "invariant");
-      s->set_owner(NULL);   // redundant but good hygiene
+// We currently call om_flush() from Threads::remove() before the
+// thread has been excised from the thread list and is no longer a
+// mutator. This means that om_flush() cannot run concurrently with
+// a safepoint and interleave with deflate_idle_monitors(). In
+// particular, this ensures that the thread's in-use monitors are
+// scanned by a GC safepoint, either via Thread::oops_do() (before
+// om_flush() is called) or via ObjectSynchronizer::oops_do() (after
+// om_flush() is called).
+
+void ObjectSynchronizer::om_flush(Thread* self) {
+  // Process the per-thread in-use list first to be consistent.
+  int in_use_count = 0;
+  ObjectMonitor* in_use_list = NULL;
+  ObjectMonitor* in_use_tail = NULL;
+  NoSafepointVerifier nsv;
+
+  // This function can race with a list walker thread so we lock the
+  // list head to prevent confusion.
+  if ((in_use_list = get_list_head_locked(&self->om_in_use_list)) != NULL) {
+    // At this point, we have locked the in-use list head so a racing
+    // thread cannot come in after us. However, a racing thread could
+    // be ahead of us; we'll detect that and delay to let it finish.
+    //
+    // The thread is going away, however the ObjectMonitors on the
+    // om_in_use_list may still be in-use by other threads. Link
+    // them to in_use_tail, which will be linked into the global
+    // in-use list (om_list_globals._in_use_list) below.
+    //
+    // Account for the in-use list head before the loop since it is
+    // already locked (by this thread):
+    in_use_tail = in_use_list;
+    in_use_count++;
+    for (ObjectMonitor* cur_om = unmarked_next(in_use_list); cur_om != NULL; cur_om = unmarked_next(cur_om)) {
+      if (is_locked(cur_om)) {
+        // cur_om is locked so there must be a racing walker thread ahead
+        // of us so we'll give it a chance to finish.
+        while (is_locked(cur_om)) {
+          os::naked_short_sleep(1);
+        }
+      }
+      in_use_tail = cur_om;
+      in_use_count++;
     }
-    guarantee(tail != NULL, "invariant");
-    assert(Self->omFreeCount == tally, "free-count off");
-    Self->omFreeList = NULL;
-    Self->omFreeCount = 0;
-  }
-
-  ObjectMonitor * inUseList = Self->omInUseList;
-  ObjectMonitor * inUseTail = NULL;
-  int inUseTally = 0;
-  if (inUseList != NULL) {
-    ObjectMonitor *cur_om;
-    // The thread is going away, however the omInUseList inflated
-    // monitors may still be in-use by other threads.
-    // Link them to inUseTail, which will be linked into the global in-use list
-    // gOmInUseList below, under the gListLock
-    for (cur_om = inUseList; cur_om != NULL; cur_om = cur_om->FreeNext) {
-      inUseTail = cur_om;
-      inUseTally++;
+    guarantee(in_use_tail != NULL, "invariant");
+    int l_om_in_use_count = Atomic::load(&self->om_in_use_count);
+    assert(l_om_in_use_count == in_use_count, "in-use counts don't match: "
+          "l_om_in_use_count=%d, in_use_count=%d", l_om_in_use_count, in_use_count);
+    Atomic::store(&self->om_in_use_count, 0);
+    // Clear the in-use list head (which also unlocks it):
+    Atomic::store(&self->om_in_use_list, (ObjectMonitor*)NULL);
+    om_unlock(in_use_list);
+  }
+
+  int free_count = 0;
+  ObjectMonitor* free_list = NULL;
+  ObjectMonitor* free_tail = NULL;
+  // This function can race with a list walker thread so we lock the
+  // list head to prevent confusion.
+  if ((free_list = get_list_head_locked(&self->om_free_list)) != NULL) {
+    // At this point, we have locked the free list head so a racing
+    // thread cannot come in after us. However, a racing thread could
+    // be ahead of us; we'll detect that and delay to let it finish.
+    //
+    // The thread is going away. Set 'free_tail' to the last per-thread free
+    // monitor which will be linked to om_list_globals._free_list below.
+    //
+    // Account for the free list head before the loop since it is
+    // already locked (by this thread):
+    free_tail = free_list;
+    free_count++;
+    for (ObjectMonitor* s = unmarked_next(free_list); s != NULL; s = unmarked_next(s)) {
+      if (is_locked(s)) {
+        // s is locked so there must be a racing walker thread ahead
+        // of us so we'll give it a chance to finish.
+        while (is_locked(s)) {
+          os::naked_short_sleep(1);
+        }
+      }
+      free_tail = s;
+      free_count++;
+      guarantee(s->object() == NULL, "invariant");
+      stringStream ss;
+      guarantee(!s->is_busy(), "must be !is_busy: %s", s->is_busy_to_string(&ss));
     }
-    guarantee(inUseTail != NULL, "invariant");
-    assert(Self->omInUseCount == inUseTally, "in-use count off");
-    Self->omInUseList = NULL;
-    Self->omInUseCount = 0;
+    guarantee(free_tail != NULL, "invariant");
+    int l_om_free_count = Atomic::load(&self->om_free_count);
+    assert(l_om_free_count == free_count, "free counts don't match: "
+           "l_om_free_count=%d, free_count=%d", l_om_free_count, free_count);
+    Atomic::store(&self->om_free_count, 0);
+    Atomic::store(&self->om_free_list, (ObjectMonitor*)NULL);
+    om_unlock(free_list);
   }
 
-  Thread::muxAcquire(&gListLock, "omFlush");
-  if (tail != NULL) {
-    tail->FreeNext = gFreeList;
-    gFreeList = list;
-    gMonitorFreeCount += tally;
+  if (free_tail != NULL) {
+    prepend_list_to_global_free_list(free_list, free_tail, free_count);
   }
 
-  if (inUseTail != NULL) {
-    inUseTail->FreeNext = gOmInUseList;
-    gOmInUseList = inUseList;
-    gOmInUseCount += inUseTally;
+  if (in_use_tail != NULL) {
+    prepend_list_to_global_in_use_list(in_use_list, in_use_tail, in_use_count);
   }
 
-  Thread::muxRelease(&gListLock);
+  LogStreamHandle(Debug, monitorinflation) lsh_debug;
+  LogStreamHandle(Info, monitorinflation) lsh_info;
+  LogStream* ls = NULL;
+  if (log_is_enabled(Debug, monitorinflation)) {
+    ls = &lsh_debug;
+  } else if ((free_count != 0 || in_use_count != 0) &&
+             log_is_enabled(Info, monitorinflation)) {
+    ls = &lsh_info;
+  }
+  if (ls != NULL) {
+    ls->print_cr("om_flush: jt=" INTPTR_FORMAT ", free_count=%d"
+                 ", in_use_count=%d" ", om_free_provision=%d",
+                 p2i(self), free_count, in_use_count, self->om_free_provision);
+  }
 }
 
 static void post_monitor_inflate_event(EventJavaMonitorInflate* event,
                                        const oop obj,
                                        ObjectSynchronizer::InflateCause cause) {
@@ -1311,58 +1629,57 @@
   event->commit();
 }
 
 // Fast path code shared by multiple functions
 void ObjectSynchronizer::inflate_helper(oop obj) {
-  markOop mark = obj->mark();
-  if (mark->has_monitor()) {
-    assert(ObjectSynchronizer::verify_objmon_isinpool(mark->monitor()), "monitor is invalid");
-    assert(mark->monitor()->header()->is_neutral(), "monitor must record a good object header");
+  markWord mark = obj->mark();
+  if (mark.has_monitor()) {
+    assert(ObjectSynchronizer::verify_objmon_isinpool(mark.monitor()), "monitor is invalid");
+    assert(mark.monitor()->header().is_neutral(), "monitor must record a good object header");
     return;
   }
   inflate(Thread::current(), obj, inflate_cause_vm_internal);
 }
 
-ObjectMonitor* ObjectSynchronizer::inflate(Thread * Self,
-                                           oop object,
-                                           const InflateCause cause) {
+ObjectMonitor* ObjectSynchronizer::inflate(Thread* self,
+                                           oop object, const InflateCause cause) {
   // Inflate mutates the heap ...
   // Relaxing assertion for bug 6320749.
   assert(Universe::verify_in_progress() ||
          !SafepointSynchronize::is_at_safepoint(), "invariant");
 
   EventJavaMonitorInflate event;
 
   for (;;) {
-    const markOop mark = object->mark();
-    assert(!mark->has_bias_pattern(), "invariant");
+    const markWord mark = object->mark();
+    assert(!mark.has_bias_pattern(), "invariant");
 
     // The mark can be in one of the following states:
     // *  Inflated     - just return
     // *  Stack-locked - coerce it to inflated
     // *  INFLATING    - busy wait for conversion to complete
     // *  Neutral      - aggressively inflate the object.
     // *  BIASED       - Illegal.  We should never see this
 
     // CASE: inflated
-    if (mark->has_monitor()) {
-      ObjectMonitor * inf = mark->monitor();
-      markOop dmw = inf->header();
-      assert(dmw->is_neutral(), "invariant: header=" INTPTR_FORMAT, p2i((address)dmw));
-      assert(oopDesc::equals((oop) inf->object(), object), "invariant");
+    if (mark.has_monitor()) {
+      ObjectMonitor* inf = mark.monitor();
+      markWord dmw = inf->header();
+      assert(dmw.is_neutral(), "invariant: header=" INTPTR_FORMAT, dmw.value());
+      assert(inf->object() == object, "invariant");
       assert(ObjectSynchronizer::verify_objmon_isinpool(inf), "monitor is invalid");
       return inf;
     }
 
     // CASE: inflation in progress - inflating over a stack-lock.
     // Some other thread is converting from stack-locked to inflated.
     // Only that thread can complete inflation -- other threads must wait.
     // The INFLATING value is transient.
     // Currently, we spin/yield/park and poll the markword, waiting for inflation to finish.
     // We could always eliminate polling by parking the thread on some auxiliary list.
-    if (mark == markOopDesc::INFLATING()) {
-      ReadStableMark(object);
+    if (mark == markWord::INFLATING()) {
+      read_stable_mark(object);
       continue;
     }
 
     // CASE: stack-locked
     // Could be stack-locked either by this thread or by some other thread.
@@ -1377,29 +1694,28 @@
     // We now use per-thread private objectmonitor free lists.
     // These list are reprovisioned from the global free list outside the
     // critical INFLATING...ST interval.  A thread can transfer
     // multiple objectmonitors en-mass from the global free list to its local free list.
     // This reduces coherency traffic and lock contention on the global free list.
-    // Using such local free lists, it doesn't matter if the omAlloc() call appears
+    // Using such local free lists, it doesn't matter if the om_alloc() call appears
     // before or after the CAS(INFLATING) operation.
-    // See the comments in omAlloc().
+    // See the comments in om_alloc().
 
     LogStreamHandle(Trace, monitorinflation) lsh;
 
-    if (mark->has_locker()) {
-      ObjectMonitor * m = omAlloc(Self);
+    if (mark.has_locker()) {
+      ObjectMonitor* m = om_alloc(self);
       // Optimistically prepare the objectmonitor - anticipate successful CAS
       // We do this before the CAS in order to minimize the length of time
       // in which INFLATING appears in the mark.
       m->Recycle();
       m->_Responsible  = NULL;
-      m->_recursions   = 0;
       m->_SpinDuration = ObjectMonitor::Knob_SpinLimit;   // Consider: maintain by type/class
 
-      markOop cmp = object->cas_set_mark(markOopDesc::INFLATING(), mark);
+      markWord cmp = object->cas_set_mark(markWord::INFLATING(), mark);
       if (cmp != mark) {
-        omRelease(Self, m, true);
+        om_release(self, m, true);
         continue;       // Interference -- just retry
       }
 
       // We've successfully installed INFLATING (0) into the mark-word.
       // This is the only case where 0 will appear in a mark-word.
@@ -1408,92 +1724,93 @@
       //
       // Why do we CAS a 0 into the mark-word instead of just CASing the
       // mark-word from the stack-locked value directly to the new inflated state?
       // Consider what happens when a thread unlocks a stack-locked object.
       // It attempts to use CAS to swing the displaced header value from the
-      // on-stack basiclock back into the object header.  Recall also that the
-      // header value (hashcode, etc) can reside in (a) the object header, or
+      // on-stack BasicLock back into the object header.  Recall also that the
+      // header value (hash code, etc) can reside in (a) the object header, or
       // (b) a displaced header associated with the stack-lock, or (c) a displaced
-      // header in an objectMonitor.  The inflate() routine must copy the header
-      // value from the basiclock on the owner's stack to the objectMonitor, all
+      // header in an ObjectMonitor.  The inflate() routine must copy the header
+      // value from the BasicLock on the owner's stack to the ObjectMonitor, all
       // the while preserving the hashCode stability invariants.  If the owner
       // decides to release the lock while the value is 0, the unlock will fail
       // and control will eventually pass from slow_exit() to inflate.  The owner
       // will then spin, waiting for the 0 value to disappear.   Put another way,
       // the 0 causes the owner to stall if the owner happens to try to
-      // drop the lock (restoring the header from the basiclock to the object)
+      // drop the lock (restoring the header from the BasicLock to the object)
       // while inflation is in-progress.  This protocol avoids races that might
       // would otherwise permit hashCode values to change or "flicker" for an object.
-      // Critically, while object->mark is 0 mark->displaced_mark_helper() is stable.
+      // Critically, while object->mark is 0 mark.displaced_mark_helper() is stable.
       // 0 serves as a "BUSY" inflate-in-progress indicator.
 
 
       // fetch the displaced mark from the owner's stack.
       // The owner can't die or unwind past the lock while our INFLATING
       // object is in the mark.  Furthermore the owner can't complete
       // an unlock on the object, either.
-      markOop dmw = mark->displaced_mark_helper();
-      assert(dmw->is_neutral(), "invariant");
+      markWord dmw = mark.displaced_mark_helper();
+      // Catch if the object's header is not neutral (not locked and
+      // not marked is what we care about here).
+      assert(dmw.is_neutral(), "invariant: header=" INTPTR_FORMAT, dmw.value());
 
       // Setup monitor fields to proper values -- prepare the monitor
       m->set_header(dmw);
 
-      // Optimization: if the mark->locker stack address is associated
-      // with this thread we could simply set m->_owner = Self.
+      // Optimization: if the mark.locker stack address is associated
+      // with this thread we could simply set m->_owner = self.
       // Note that a thread can inflate an object
       // that it has stack-locked -- as might happen in wait() -- directly
       // with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.
-      m->set_owner(mark->locker());
+      m->set_owner_from(NULL, mark.locker());
       m->set_object(object);
       // TODO-FIXME: assert BasicLock->dhw != 0.
 
       // Must preserve store ordering. The monitor state must
       // be stable at the time of publishing the monitor address.
-      guarantee(object->mark() == markOopDesc::INFLATING(), "invariant");
-      object->release_set_mark(markOopDesc::encode(m));
+      guarantee(object->mark() == markWord::INFLATING(), "invariant");
+      object->release_set_mark(markWord::encode(m));
 
       // Hopefully the performance counters are allocated on distinct cache lines
       // to avoid false sharing on MP systems ...
       OM_PERFDATA_OP(Inflations, inc());
       if (log_is_enabled(Trace, monitorinflation)) {
-        ResourceMark rm(Self);
+        ResourceMark rm(self);
         lsh.print_cr("inflate(has_locker): object=" INTPTR_FORMAT ", mark="
                      INTPTR_FORMAT ", type='%s'", p2i(object),
-                     p2i(object->mark()), object->klass()->external_name());
+                     object->mark().value(), object->klass()->external_name());
       }
       if (event.should_commit()) {
         post_monitor_inflate_event(&event, object, cause);
       }
       return m;
     }
 
     // CASE: neutral
     // TODO-FIXME: for entry we currently inflate and then try to CAS _owner.
     // If we know we're inflating for entry it's better to inflate by swinging a
-    // pre-locked objectMonitor pointer into the object header.   A successful
+    // pre-locked ObjectMonitor pointer into the object header.   A successful
     // CAS inflates the object *and* confers ownership to the inflating thread.
     // In the current implementation we use a 2-step mechanism where we CAS()
-    // to inflate and then CAS() again to try to swing _owner from NULL to Self.
-    // An inflateTry() method that we could call from fast_enter() and slow_enter()
-    // would be useful.
+    // to inflate and then CAS() again to try to swing _owner from NULL to self.
+    // An inflateTry() method that we could call from enter() would be useful.
 
-    assert(mark->is_neutral(), "invariant");
-    ObjectMonitor * m = omAlloc(Self);
+    // Catch if the object's header is not neutral (not locked and
+    // not marked is what we care about here).
+    assert(mark.is_neutral(), "invariant: header=" INTPTR_FORMAT, mark.value());
+    ObjectMonitor* m = om_alloc(self);
     // prepare m for installation - set monitor to initial state
     m->Recycle();
     m->set_header(mark);
-    m->set_owner(NULL);
     m->set_object(object);
-    m->_recursions   = 0;
     m->_Responsible  = NULL;
     m->_SpinDuration = ObjectMonitor::Knob_SpinLimit;       // consider: keep metastats by type/class
 
-    if (object->cas_set_mark(markOopDesc::encode(m), mark) != mark) {
-      m->set_header(NULL);
+    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {
+      m->set_header(markWord::zero());
       m->set_object(NULL);
       m->Recycle();
-      omRelease(Self, m, true);
+      om_release(self, m, true);
       m = NULL;
       continue;
       // interference - the markword changed - just retry.
       // The state-transitions are one-way, so there's no chance of
       // live-lock -- "Inflated" is an absorbing state.
@@ -1501,183 +1818,212 @@
 
     // Hopefully the performance counters are allocated on distinct
     // cache lines to avoid false sharing on MP systems ...
     OM_PERFDATA_OP(Inflations, inc());
     if (log_is_enabled(Trace, monitorinflation)) {
-      ResourceMark rm(Self);
+      ResourceMark rm(self);
       lsh.print_cr("inflate(neutral): object=" INTPTR_FORMAT ", mark="
                    INTPTR_FORMAT ", type='%s'", p2i(object),
-                   p2i(object->mark()), object->klass()->external_name());
+                   object->mark().value(), object->klass()->external_name());
     }
     if (event.should_commit()) {
       post_monitor_inflate_event(&event, object, cause);
     }
     return m;
   }
 }
 
 
-// We create a list of in-use monitors for each thread.
+// We maintain a list of in-use monitors for each thread.
 //
 // deflate_thread_local_monitors() scans a single thread's in-use list, while
 // deflate_idle_monitors() scans only a global list of in-use monitors which
-// is populated only as a thread dies (see omFlush()).
+// is populated only as a thread dies (see om_flush()).
 //
 // These operations are called at all safepoints, immediately after mutators
 // are stopped, but before any objects have moved. Collectively they traverse
 // the population of in-use monitors, deflating where possible. The scavenged
-// monitors are returned to the monitor free list.
+// monitors are returned to the global monitor free list.
 //
 // Beware that we scavenge at *every* stop-the-world point. Having a large
 // number of monitors in-use could negatively impact performance. We also want
 // to minimize the total # of monitors in circulation, as they incur a small
 // footprint penalty.
 //
 // Perversely, the heap size -- and thus the STW safepoint rate --
 // typically drives the scavenge rate.  Large heaps can mean infrequent GC,
-// which in turn can mean large(r) numbers of objectmonitors in circulation.
+// which in turn can mean large(r) numbers of ObjectMonitors in circulation.
 // This is an unfortunate aspect of this design.
 
 // Deflate a single monitor if not in-use
 // Return true if deflated, false if in-use
 bool ObjectSynchronizer::deflate_monitor(ObjectMonitor* mid, oop obj,
-                                         ObjectMonitor** freeHeadp,
-                                         ObjectMonitor** freeTailp) {
+                                         ObjectMonitor** free_head_p,
+                                         ObjectMonitor** free_tail_p) {
   bool deflated;
   // Normal case ... The monitor is associated with obj.
-  guarantee(obj->mark() == markOopDesc::encode(mid), "invariant");
-  guarantee(mid == obj->mark()->monitor(), "invariant");
-  guarantee(mid->header()->is_neutral(), "invariant");
+  const markWord mark = obj->mark();
+  guarantee(mark == markWord::encode(mid), "should match: mark="
+            INTPTR_FORMAT ", encoded mid=" INTPTR_FORMAT, mark.value(),
+            markWord::encode(mid).value());
+  // Make sure that mark.monitor() and markWord::encode() agree:
+  guarantee(mark.monitor() == mid, "should match: monitor()=" INTPTR_FORMAT
+            ", mid=" INTPTR_FORMAT, p2i(mark.monitor()), p2i(mid));
+  const markWord dmw = mid->header();
+  guarantee(dmw.is_neutral(), "invariant: header=" INTPTR_FORMAT, dmw.value());
 
   if (mid->is_busy()) {
+    // Easy checks are first - the ObjectMonitor is busy so no deflation.
     deflated = false;
   } else {
     // Deflate the monitor if it is no longer being used
     // It's idle - scavenge and return to the global free list
     // plain old deflation ...
     if (log_is_enabled(Trace, monitorinflation)) {
       ResourceMark rm;
       log_trace(monitorinflation)("deflate_monitor: "
-                                  "object=" INTPTR_FORMAT ", mark=" INTPTR_FORMAT ", type='%s'",
-                                  p2i(obj), p2i(obj->mark()),
-                                  obj->klass()->external_name());
+                                  "object=" INTPTR_FORMAT ", mark="
+                                  INTPTR_FORMAT ", type='%s'", p2i(obj),
+                                  mark.value(), obj->klass()->external_name());
     }
 
     // Restore the header back to obj
-    obj->release_set_mark(mid->header());
+    obj->release_set_mark(dmw);
     mid->clear();
 
-    assert(mid->object() == NULL, "invariant");
-
-    // Move the object to the working free list defined by freeHeadp, freeTailp
-    if (*freeHeadp == NULL) *freeHeadp = mid;
-    if (*freeTailp != NULL) {
-      ObjectMonitor * prevtail = *freeTailp;
-      assert(prevtail->FreeNext == NULL, "cleaned up deflated?");
-      prevtail->FreeNext = mid;
+    assert(mid->object() == NULL, "invariant: object=" INTPTR_FORMAT,
+           p2i(mid->object()));
+
+    // Move the deflated ObjectMonitor to the working free list
+    // defined by free_head_p and free_tail_p.
+    if (*free_head_p == NULL) *free_head_p = mid;
+    if (*free_tail_p != NULL) {
+      // We append to the list so the caller can use mid->_next_om
+      // to fix the linkages in its context.
+      ObjectMonitor* prevtail = *free_tail_p;
+      // Should have been cleaned up by the caller:
+      // Note: Should not have to lock prevtail here since we're at a
+      // safepoint and ObjectMonitors on the local free list should
+      // not be accessed in parallel.
+#ifdef ASSERT
+      ObjectMonitor* l_next_om = prevtail->next_om();
+#endif
+      assert(l_next_om == NULL, "must be NULL: _next_om=" INTPTR_FORMAT, p2i(l_next_om));
+      prevtail->set_next_om(mid);
     }
-    *freeTailp = mid;
+    *free_tail_p = mid;
+    // At this point, mid->_next_om still refers to its current
+    // value and another ObjectMonitor's _next_om field still
+    // refers to this ObjectMonitor. Those linkages have to be
+    // cleaned up by the caller who has the complete context.
     deflated = true;
   }
   return deflated;
 }
 
-// Walk a given monitor list, and deflate idle monitors
-// The given list could be a per-thread list or a global list
-// Caller acquires gListLock as needed.
+// Walk a given monitor list, and deflate idle monitors.
+// The given list could be a per-thread list or a global list.
 //
 // In the case of parallel processing of thread local monitor lists,
 // work is done by Threads::parallel_threads_do() which ensures that
 // each Java thread is processed by exactly one worker thread, and
 // thus avoid conflicts that would arise when worker threads would
 // process the same monitor lists concurrently.
 //
 // See also ParallelSPCleanupTask and
 // SafepointSynchronize::do_cleanup_tasks() in safepoint.cpp and
 // Threads::parallel_java_threads_do() in thread.cpp.
-int ObjectSynchronizer::deflate_monitor_list(ObjectMonitor** listHeadp,
-                                             ObjectMonitor** freeHeadp,
-                                             ObjectMonitor** freeTailp) {
-  ObjectMonitor* mid;
-  ObjectMonitor* next;
+int ObjectSynchronizer::deflate_monitor_list(ObjectMonitor** list_p,
+                                             int* count_p,
+                                             ObjectMonitor** free_head_p,
+                                             ObjectMonitor** free_tail_p) {
   ObjectMonitor* cur_mid_in_use = NULL;
+  ObjectMonitor* mid = NULL;
+  ObjectMonitor* next = NULL;
   int deflated_count = 0;
 
-  for (mid = *listHeadp; mid != NULL;) {
+  // This list walk executes at a safepoint and does not race with any
+  // other list walkers.
+
+  for (mid = Atomic::load(list_p); mid != NULL; mid = next) {
+    next = unmarked_next(mid);
     oop obj = (oop) mid->object();
-    if (obj != NULL && deflate_monitor(mid, obj, freeHeadp, freeTailp)) {
-      // if deflate_monitor succeeded,
-      // extract from per-thread in-use list
-      if (mid == *listHeadp) {
-        *listHeadp = mid->FreeNext;
-      } else if (cur_mid_in_use != NULL) {
-        cur_mid_in_use->FreeNext = mid->FreeNext; // maintain the current thread in-use list
+    if (obj != NULL && deflate_monitor(mid, obj, free_head_p, free_tail_p)) {
+      // Deflation succeeded and already updated free_head_p and
+      // free_tail_p as needed. Finish the move to the local free list
+      // by unlinking mid from the global or per-thread in-use list.
+      if (cur_mid_in_use == NULL) {
+        // mid is the list head so switch the list head to next:
+        Atomic::store(list_p, next);
+      } else {
+        // Switch cur_mid_in_use's next field to next:
+        cur_mid_in_use->set_next_om(next);
       }
-      next = mid->FreeNext;
-      mid->FreeNext = NULL;  // This mid is current tail in the freeHeadp list
-      mid = next;
+      // At this point mid is disconnected from the in-use list.
       deflated_count++;
+      Atomic::dec(count_p);
+      // mid is current tail in the free_head_p list so NULL terminate it:
+      mid->set_next_om(NULL);
     } else {
       cur_mid_in_use = mid;
-      mid = mid->FreeNext;
     }
   }
   return deflated_count;
 }
 
 void ObjectSynchronizer::prepare_deflate_idle_monitors(DeflateMonitorCounters* counters) {
-  counters->nInuse = 0;              // currently associated with objects
-  counters->nInCirculation = 0;      // extant
-  counters->nScavenged = 0;          // reclaimed (global and per-thread)
-  counters->perThreadScavenged = 0;  // per-thread scavenge total
-  counters->perThreadTimes = 0.0;    // per-thread scavenge times
+  counters->n_in_use = 0;              // currently associated with objects
+  counters->n_in_circulation = 0;      // extant
+  counters->n_scavenged = 0;           // reclaimed (global and per-thread)
+  counters->per_thread_scavenged = 0;  // per-thread scavenge total
+  counters->per_thread_times = 0.0;    // per-thread scavenge times
 }
 
 void ObjectSynchronizer::deflate_idle_monitors(DeflateMonitorCounters* counters) {
   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
   bool deflated = false;
 
-  ObjectMonitor * freeHeadp = NULL;  // Local SLL of scavenged monitors
-  ObjectMonitor * freeTailp = NULL;
+  ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors
+  ObjectMonitor* free_tail_p = NULL;
   elapsedTimer timer;
 
   if (log_is_enabled(Info, monitorinflation)) {
     timer.start();
   }
 
-  // Prevent omFlush from changing mids in Thread dtor's during deflation
-  // And in case the vm thread is acquiring a lock during a safepoint
-  // See e.g. 6320749
-  Thread::muxAcquire(&gListLock, "deflate_idle_monitors");
-
   // Note: the thread-local monitors lists get deflated in
   // a separate pass. See deflate_thread_local_monitors().
 
-  // For moribund threads, scan gOmInUseList
+  // For moribund threads, scan om_list_globals._in_use_list
   int deflated_count = 0;
-  if (gOmInUseList) {
-    counters->nInCirculation += gOmInUseCount;
-    deflated_count = deflate_monitor_list((ObjectMonitor **)&gOmInUseList, &freeHeadp, &freeTailp);
-    gOmInUseCount -= deflated_count;
-    counters->nScavenged += deflated_count;
-    counters->nInuse += gOmInUseCount;
-  }
-
-  // Move the scavenged monitors back to the global free list.
-  if (freeHeadp != NULL) {
-    guarantee(freeTailp != NULL && counters->nScavenged > 0, "invariant");
-    assert(freeTailp->FreeNext == NULL, "invariant");
-    // constant-time list splice - prepend scavenged segment to gFreeList
-    freeTailp->FreeNext = gFreeList;
-    gFreeList = freeHeadp;
-  }
-  Thread::muxRelease(&gListLock);
+  if (Atomic::load(&om_list_globals._in_use_list) != NULL) {
+    // Update n_in_circulation before om_list_globals._in_use_count is
+    // updated by deflation.
+    Atomic::add(&counters->n_in_circulation,
+                Atomic::load(&om_list_globals._in_use_count));
+
+    deflated_count = deflate_monitor_list(&om_list_globals._in_use_list,
+                                          &om_list_globals._in_use_count,
+                                          &free_head_p, &free_tail_p);
+    Atomic::add(&counters->n_in_use, Atomic::load(&om_list_globals._in_use_count));
+  }
+
+  if (free_head_p != NULL) {
+    // Move the deflated ObjectMonitors back to the global free list.
+    guarantee(free_tail_p != NULL && deflated_count > 0, "invariant");
+#ifdef ASSERT
+    ObjectMonitor* l_next_om = free_tail_p->next_om();
+#endif
+    assert(l_next_om == NULL, "must be NULL: _next_om=" INTPTR_FORMAT, p2i(l_next_om));
+    prepend_list_to_global_free_list(free_head_p, free_tail_p, deflated_count);
+    Atomic::add(&counters->n_scavenged, deflated_count);
+  }
   timer.stop();
 
   LogStreamHandle(Debug, monitorinflation) lsh_debug;
   LogStreamHandle(Info, monitorinflation) lsh_info;
-  LogStream * ls = NULL;
+  LogStream* ls = NULL;
   if (log_is_enabled(Debug, monitorinflation)) {
     ls = &lsh_debug;
   } else if (deflated_count != 0 && log_is_enabled(Info, monitorinflation)) {
     ls = &lsh_info;
   }
@@ -1689,78 +2035,77 @@
 void ObjectSynchronizer::finish_deflate_idle_monitors(DeflateMonitorCounters* counters) {
   // Report the cumulative time for deflating each thread's idle
   // monitors. Note: if the work is split among more than one
   // worker thread, then the reported time will likely be more
   // than a beginning to end measurement of the phase.
-  log_info(safepoint, cleanup)("deflating per-thread idle monitors, %3.7f secs, monitors=%d", counters->perThreadTimes, counters->perThreadScavenged);
-
-  LogStreamHandle(Debug, monitorinflation) lsh_debug;
-  LogStreamHandle(Info, monitorinflation) lsh_info;
-  LogStream * ls = NULL;
-  if (log_is_enabled(Debug, monitorinflation)) {
-    ls = &lsh_debug;
-  } else if (counters->perThreadScavenged != 0 && log_is_enabled(Info, monitorinflation)) {
-    ls = &lsh_info;
-  }
-  if (ls != NULL) {
-    ls->print_cr("deflating per-thread idle monitors, %3.7f secs, %d monitors", counters->perThreadTimes, counters->perThreadScavenged);
-  }
-
-  gMonitorFreeCount += counters->nScavenged;
+  log_info(safepoint, cleanup)("deflating per-thread idle monitors, %3.7f secs, monitors=%d", counters->per_thread_times, counters->per_thread_scavenged);
 
   if (log_is_enabled(Debug, monitorinflation)) {
     // exit_globals()'s call to audit_and_print_stats() is done
-    // at the Info level.
+    // at the Info level and not at a safepoint.
     ObjectSynchronizer::audit_and_print_stats(false /* on_exit */);
+  } else if (log_is_enabled(Info, monitorinflation)) {
+    log_info(monitorinflation)("global_population=%d, global_in_use_count=%d, "
+                               "global_free_count=%d",
+                               Atomic::load(&om_list_globals._population),
+                               Atomic::load(&om_list_globals._in_use_count),
+                               Atomic::load(&om_list_globals._free_count));
   }
 
-  ForceMonitorScavenge = 0;    // Reset
+  Atomic::store(&_forceMonitorScavenge, 0);    // Reset
 
-  OM_PERFDATA_OP(Deflations, inc(counters->nScavenged));
-  OM_PERFDATA_OP(MonExtant, set_value(counters->nInCirculation));
+  OM_PERFDATA_OP(Deflations, inc(counters->n_scavenged));
+  OM_PERFDATA_OP(MonExtant, set_value(counters->n_in_circulation));
 
-  GVars.stwRandom = os::random();
-  GVars.stwCycle++;
+  GVars.stw_random = os::random();
+  GVars.stw_cycle++;
 }
 
 void ObjectSynchronizer::deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters) {
   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
 
-  ObjectMonitor * freeHeadp = NULL;  // Local SLL of scavenged monitors
-  ObjectMonitor * freeTailp = NULL;
+  ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors
+  ObjectMonitor* free_tail_p = NULL;
   elapsedTimer timer;
 
   if (log_is_enabled(Info, safepoint, cleanup) ||
       log_is_enabled(Info, monitorinflation)) {
     timer.start();
   }
 
-  int deflated_count = deflate_monitor_list(thread->omInUseList_addr(), &freeHeadp, &freeTailp);
-
-  timer.stop();
+  // Update n_in_circulation before om_in_use_count is updated by deflation.
+  Atomic::add(&counters->n_in_circulation, Atomic::load(&thread->om_in_use_count));
 
-  Thread::muxAcquire(&gListLock, "deflate_thread_local_monitors");
+  int deflated_count = deflate_monitor_list(&thread->om_in_use_list, &thread->om_in_use_count, &free_head_p, &free_tail_p);
+  Atomic::add(&counters->n_in_use, Atomic::load(&thread->om_in_use_count));
 
-  // Adjust counters
-  counters->nInCirculation += thread->omInUseCount;
-  thread->omInUseCount -= deflated_count;
-  counters->nScavenged += deflated_count;
-  counters->nInuse += thread->omInUseCount;
-  counters->perThreadScavenged += deflated_count;
-  // For now, we only care about cumulative per-thread deflation time.
-  counters->perThreadTimes += timer.seconds();
+  if (free_head_p != NULL) {
+    // Move the deflated ObjectMonitors back to the global free list.
+    guarantee(free_tail_p != NULL && deflated_count > 0, "invariant");
+#ifdef ASSERT
+    ObjectMonitor* l_next_om = free_tail_p->next_om();
+#endif
+    assert(l_next_om == NULL, "must be NULL: _next_om=" INTPTR_FORMAT, p2i(l_next_om));
+    prepend_list_to_global_free_list(free_head_p, free_tail_p, deflated_count);
+    Atomic::add(&counters->n_scavenged, deflated_count);
+    Atomic::add(&counters->per_thread_scavenged, deflated_count);
+  }
 
-  // Move the scavenged monitors back to the global free list.
-  if (freeHeadp != NULL) {
-    guarantee(freeTailp != NULL && deflated_count > 0, "invariant");
-    assert(freeTailp->FreeNext == NULL, "invariant");
+  timer.stop();
+  counters->per_thread_times += timer.seconds();
 
-    // constant-time list splice - prepend scavenged segment to gFreeList
-    freeTailp->FreeNext = gFreeList;
-    gFreeList = freeHeadp;
+  LogStreamHandle(Debug, monitorinflation) lsh_debug;
+  LogStreamHandle(Info, monitorinflation) lsh_info;
+  LogStream* ls = NULL;
+  if (log_is_enabled(Debug, monitorinflation)) {
+    ls = &lsh_debug;
+  } else if (deflated_count != 0 && log_is_enabled(Info, monitorinflation)) {
+    ls = &lsh_info;
+  }
+  if (ls != NULL) {
+    ls->print_cr("jt=" INTPTR_FORMAT ": deflating per-thread idle monitors, %3.7f secs, %d monitors", p2i(thread), timer.seconds(), deflated_count);
   }
-  Thread::muxRelease(&gListLock);
 }
 
 // Monitor cleanup on JavaThread::exit
 
 // Iterate through monitor cache and attempt to release thread's monitors
@@ -1800,13 +2145,11 @@
 
 void ObjectSynchronizer::release_monitors_owned_by_thread(TRAPS) {
   assert(THREAD == JavaThread::current(), "must be current Java thread");
   NoSafepointVerifier nsv;
   ReleaseJavaMonitorsClosure rjmc(THREAD);
-  Thread::muxAcquire(&gListLock, "release_monitors_owned_by_thread");
   ObjectSynchronizer::monitors_iterate(&rjmc);
-  Thread::muxRelease(&gListLock);
   THREAD->clear_pending_exception();
 }
 
 const char* ObjectSynchronizer::inflate_cause_name(const InflateCause cause) {
   switch (cause) {
@@ -1828,77 +2171,84 @@
 
 u_char* ObjectSynchronizer::get_gvars_addr() {
   return (u_char*)&GVars;
 }
 
-u_char* ObjectSynchronizer::get_gvars_hcSequence_addr() {
-  return (u_char*)&GVars.hcSequence;
+u_char* ObjectSynchronizer::get_gvars_hc_sequence_addr() {
+  return (u_char*)&GVars.hc_sequence;
 }
 
 size_t ObjectSynchronizer::get_gvars_size() {
   return sizeof(SharedGlobals);
 }
 
-u_char* ObjectSynchronizer::get_gvars_stwRandom_addr() {
-  return (u_char*)&GVars.stwRandom;
+u_char* ObjectSynchronizer::get_gvars_stw_random_addr() {
+  return (u_char*)&GVars.stw_random;
 }
 
+// This function can be called at a safepoint or it can be called when
+// we are trying to exit the VM. When we are trying to exit the VM, the
+// list walker functions can run in parallel with the other list
+// operations so spin-locking is used for safety.
+//
+// Calls to this function can be added in various places as a debugging
+// aid; pass 'true' for the 'on_exit' parameter to have in-use monitor
+// details logged at the Info level and 'false' for the 'on_exit'
+// parameter to have in-use monitor details logged at the Trace level.
+// deflate_monitor_list() no longer uses spin-locking so be careful
+// when adding audit_and_print_stats() calls at a safepoint.
+//
 void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {
   assert(on_exit || SafepointSynchronize::is_at_safepoint(), "invariant");
 
   LogStreamHandle(Debug, monitorinflation) lsh_debug;
   LogStreamHandle(Info, monitorinflation) lsh_info;
   LogStreamHandle(Trace, monitorinflation) lsh_trace;
-  LogStream * ls = NULL;
+  LogStream* ls = NULL;
   if (log_is_enabled(Trace, monitorinflation)) {
     ls = &lsh_trace;
   } else if (log_is_enabled(Debug, monitorinflation)) {
     ls = &lsh_debug;
   } else if (log_is_enabled(Info, monitorinflation)) {
     ls = &lsh_info;
   }
   assert(ls != NULL, "sanity check");
 
-  if (!on_exit) {
-    // Not at VM exit so grab the global list lock.
-    Thread::muxAcquire(&gListLock, "audit_and_print_stats");
-  }
-
   // Log counts for the global and per-thread monitor lists:
-  int chkMonitorPopulation = log_monitor_list_counts(ls);
+  int chk_om_population = log_monitor_list_counts(ls);
   int error_cnt = 0;
 
   ls->print_cr("Checking global lists:");
 
-  // Check gMonitorPopulation:
-  if (gMonitorPopulation == chkMonitorPopulation) {
-     ls->print_cr("gMonitorPopulation=%d equals chkMonitorPopulation=%d",
-                  gMonitorPopulation, chkMonitorPopulation);
+  // Check om_list_globals._population:
+  if (Atomic::load(&om_list_globals._population) == chk_om_population) {
+    ls->print_cr("global_population=%d equals chk_om_population=%d",
+                 Atomic::load(&om_list_globals._population), chk_om_population);
   } else {
-     ls->print_cr("ERROR: gMonitorPopulation=%d is not equal to "
-                  "chkMonitorPopulation=%d", gMonitorPopulation,
-                  chkMonitorPopulation);
-     error_cnt++;
+    // With fine grained locks on the monitor lists, it is possible for
+    // log_monitor_list_counts() to return a value that doesn't match
+    // om_list_globals._population. So far a higher value has been
+    // seen in testing so something is being double counted by
+    // log_monitor_list_counts().
+    ls->print_cr("WARNING: global_population=%d is not equal to "
+                 "chk_om_population=%d",
+                 Atomic::load(&om_list_globals._population), chk_om_population);
   }
 
-  // Check gOmInUseList and gOmInUseCount:
+  // Check om_list_globals._in_use_list and om_list_globals._in_use_count:
   chk_global_in_use_list_and_count(ls, &error_cnt);
 
-  // Check gFreeList and gMonitorFreeCount:
+  // Check om_list_globals._free_list and om_list_globals._free_count:
   chk_global_free_list_and_count(ls, &error_cnt);
 
-  if (!on_exit) {
-    Thread::muxRelease(&gListLock);
-  }
-
   ls->print_cr("Checking per-thread lists:");
 
   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
-    // Check omInUseList and omInUseCount:
+    // Check om_in_use_list and om_in_use_count:
     chk_per_thread_in_use_list_and_count(jt, ls, &error_cnt);
 
-    // Check omFreeList and omFreeCount:
+    // Check om_free_list and om_free_count:
     chk_per_thread_free_list_and_count(jt, ls, &error_cnt);
   }
 
   if (error_cnt == 0) {
     ls->print_cr("No errors found in monitor list checks.");
@@ -1909,42 +2259,43 @@
   if ((on_exit && log_is_enabled(Info, monitorinflation)) ||
       (!on_exit && log_is_enabled(Trace, monitorinflation))) {
     // When exiting this log output is at the Info level. When called
     // at a safepoint, this log output is at the Trace level since
     // there can be a lot of it.
-    log_in_use_monitor_details(ls, on_exit);
+    log_in_use_monitor_details(ls);
   }
 
   ls->flush();
 
   guarantee(error_cnt == 0, "ERROR: found monitor list errors: error_cnt=%d", error_cnt);
 }
 
 // Check a free monitor entry; log any errors.
-void ObjectSynchronizer::chk_free_entry(JavaThread * jt, ObjectMonitor * n,
+void ObjectSynchronizer::chk_free_entry(JavaThread* jt, ObjectMonitor* n,
                                         outputStream * out, int *error_cnt_p) {
+  stringStream ss;
   if (n->is_busy()) {
     if (jt != NULL) {
       out->print_cr("ERROR: jt=" INTPTR_FORMAT ", monitor=" INTPTR_FORMAT
-                    ": free per-thread monitor must not be busy.", p2i(jt),
-                    p2i(n));
+                    ": free per-thread monitor must not be busy: %s", p2i(jt),
+                    p2i(n), n->is_busy_to_string(&ss));
     } else {
       out->print_cr("ERROR: monitor=" INTPTR_FORMAT ": free global monitor "
-                    "must not be busy.", p2i(n));
+                    "must not be busy: %s", p2i(n), n->is_busy_to_string(&ss));
     }
     *error_cnt_p = *error_cnt_p + 1;
   }
-  if (n->header() != NULL) {
+  if (n->header().value() != 0) {
     if (jt != NULL) {
       out->print_cr("ERROR: jt=" INTPTR_FORMAT ", monitor=" INTPTR_FORMAT
                     ": free per-thread monitor must have NULL _header "
                     "field: _header=" INTPTR_FORMAT, p2i(jt), p2i(n),
-                    p2i(n->header()));
+                    n->header().value());
     } else {
       out->print_cr("ERROR: monitor=" INTPTR_FORMAT ": free global monitor "
                     "must have NULL _header field: _header=" INTPTR_FORMAT,
-                    p2i(n), p2i(n->header()));
+                    p2i(n), n->header().value());
     }
     *error_cnt_p = *error_cnt_p + 1;
   }
   if (n->object() != NULL) {
     if (jt != NULL) {
@@ -1959,51 +2310,94 @@
     }
     *error_cnt_p = *error_cnt_p + 1;
   }
 }
 
+// Lock the next ObjectMonitor for traversal and unlock the current
+// ObjectMonitor. Returns the next ObjectMonitor if there is one.
+// Otherwise returns NULL (after unlocking the current ObjectMonitor).
+// This function is used by the various list walker functions to
+// safely walk a list without allowing an ObjectMonitor to be moved
+// to another list in the middle of a walk.
+static ObjectMonitor* lock_next_for_traversal(ObjectMonitor* cur) {
+  assert(is_locked(cur), "cur=" INTPTR_FORMAT " must be locked", p2i(cur));
+  ObjectMonitor* next = unmarked_next(cur);
+  if (next == NULL) {  // Reached the end of the list.
+    om_unlock(cur);
+    return NULL;
+  }
+  om_lock(next);   // Lock next before unlocking current to keep
+  om_unlock(cur);  // from being by-passed by another thread.
+  return next;
+}
+
 // Check the global free list and count; log the results of the checks.
 void ObjectSynchronizer::chk_global_free_list_and_count(outputStream * out,
                                                         int *error_cnt_p) {
-  int chkMonitorFreeCount = 0;
-  for (ObjectMonitor * n = gFreeList; n != NULL; n = n->FreeNext) {
-    chk_free_entry(NULL /* jt */, n, out, error_cnt_p);
-    chkMonitorFreeCount++;
-  }
-  if (gMonitorFreeCount == chkMonitorFreeCount) {
-    out->print_cr("gMonitorFreeCount=%d equals chkMonitorFreeCount=%d",
-                  gMonitorFreeCount, chkMonitorFreeCount);
+  int chk_om_free_count = 0;
+  ObjectMonitor* cur = NULL;
+  if ((cur = get_list_head_locked(&om_list_globals._free_list)) != NULL) {
+    // Marked the global free list head so process the list.
+    while (true) {
+      chk_free_entry(NULL /* jt */, cur, out, error_cnt_p);
+      chk_om_free_count++;
+
+      cur = lock_next_for_traversal(cur);
+      if (cur == NULL) {
+        break;
+      }
+    }
+  }
+  int l_free_count = Atomic::load(&om_list_globals._free_count);
+  if (l_free_count == chk_om_free_count) {
+    out->print_cr("global_free_count=%d equals chk_om_free_count=%d",
+                  l_free_count, chk_om_free_count);
   } else {
-    out->print_cr("ERROR: gMonitorFreeCount=%d is not equal to "
-                  "chkMonitorFreeCount=%d", gMonitorFreeCount,
-                  chkMonitorFreeCount);
-    *error_cnt_p = *error_cnt_p + 1;
+    // With fine grained locks on om_list_globals._free_list, it
+    // is possible for an ObjectMonitor to be prepended to
+    // om_list_globals._free_list after we started calculating
+    // chk_om_free_count so om_list_globals._free_count may not
+    // match anymore.
+    out->print_cr("WARNING: global_free_count=%d is not equal to "
+                  "chk_om_free_count=%d", l_free_count, chk_om_free_count);
   }
 }
 
 // Check the global in-use list and count; log the results of the checks.
 void ObjectSynchronizer::chk_global_in_use_list_and_count(outputStream * out,
                                                           int *error_cnt_p) {
-  int chkOmInUseCount = 0;
-  for (ObjectMonitor * n = gOmInUseList; n != NULL; n = n->FreeNext) {
-    chk_in_use_entry(NULL /* jt */, n, out, error_cnt_p);
-    chkOmInUseCount++;
-  }
-  if (gOmInUseCount == chkOmInUseCount) {
-    out->print_cr("gOmInUseCount=%d equals chkOmInUseCount=%d", gOmInUseCount,
-                  chkOmInUseCount);
+  int chk_om_in_use_count = 0;
+  ObjectMonitor* cur = NULL;
+  if ((cur = get_list_head_locked(&om_list_globals._in_use_list)) != NULL) {
+    // Marked the global in-use list head so process the list.
+    while (true) {
+      chk_in_use_entry(NULL /* jt */, cur, out, error_cnt_p);
+      chk_om_in_use_count++;
+
+      cur = lock_next_for_traversal(cur);
+      if (cur == NULL) {
+        break;
+      }
+    }
+  }
+  int l_in_use_count = Atomic::load(&om_list_globals._in_use_count);
+  if (l_in_use_count == chk_om_in_use_count) {
+    out->print_cr("global_in_use_count=%d equals chk_om_in_use_count=%d",
+                  l_in_use_count, chk_om_in_use_count);
   } else {
-    out->print_cr("ERROR: gOmInUseCount=%d is not equal to chkOmInUseCount=%d",
-                  gOmInUseCount, chkOmInUseCount);
-    *error_cnt_p = *error_cnt_p + 1;
+    // With fine grained locks on the monitor lists, it is possible for
+    // an exiting JavaThread to put its in-use ObjectMonitors on the
+    // global in-use list after chk_om_in_use_count is calculated above.
+    out->print_cr("WARNING: global_in_use_count=%d is not equal to chk_om_in_use_count=%d",
+                  l_in_use_count, chk_om_in_use_count);
   }
 }
 
 // Check an in-use monitor entry; log any errors.
-void ObjectSynchronizer::chk_in_use_entry(JavaThread * jt, ObjectMonitor * n,
+void ObjectSynchronizer::chk_in_use_entry(JavaThread* jt, ObjectMonitor* n,
                                           outputStream * out, int *error_cnt_p) {
-  if (n->header() == NULL) {
+  if (n->header().value() == 0) {
     if (jt != NULL) {
       out->print_cr("ERROR: jt=" INTPTR_FORMAT ", monitor=" INTPTR_FORMAT
                     ": in-use per-thread monitor must have non-NULL _header "
                     "field.", p2i(jt), p2i(n));
     } else {
@@ -2022,178 +2416,220 @@
                     "must have non-NULL _object field.", p2i(n));
     }
     *error_cnt_p = *error_cnt_p + 1;
   }
   const oop obj = (oop)n->object();
-  const markOop mark = obj->mark();
-  if (!mark->has_monitor()) {
+  const markWord mark = obj->mark();
+  if (!mark.has_monitor()) {
     if (jt != NULL) {
       out->print_cr("ERROR: jt=" INTPTR_FORMAT ", monitor=" INTPTR_FORMAT
                     ": in-use per-thread monitor's object does not think "
                     "it has a monitor: obj=" INTPTR_FORMAT ", mark="
-                    INTPTR_FORMAT,  p2i(jt), p2i(n), p2i((address)obj),
-                    p2i((address)mark));
+                    INTPTR_FORMAT,  p2i(jt), p2i(n), p2i(obj), mark.value());
     } else {
       out->print_cr("ERROR: monitor=" INTPTR_FORMAT ": in-use global "
                     "monitor's object does not think it has a monitor: obj="
                     INTPTR_FORMAT ", mark=" INTPTR_FORMAT, p2i(n),
-                    p2i((address)obj), p2i((address)mark));
+                    p2i(obj), mark.value());
     }
     *error_cnt_p = *error_cnt_p + 1;
   }
-  ObjectMonitor * const obj_mon = mark->monitor();
+  ObjectMonitor* const obj_mon = mark.monitor();
   if (n != obj_mon) {
     if (jt != NULL) {
       out->print_cr("ERROR: jt=" INTPTR_FORMAT ", monitor=" INTPTR_FORMAT
                     ": in-use per-thread monitor's object does not refer "
                     "to the same monitor: obj=" INTPTR_FORMAT ", mark="
                     INTPTR_FORMAT ", obj_mon=" INTPTR_FORMAT, p2i(jt),
-                    p2i(n), p2i((address)obj), p2i((address)mark),
-                    p2i((address)obj_mon));
+                    p2i(n), p2i(obj), mark.value(), p2i(obj_mon));
     } else {
       out->print_cr("ERROR: monitor=" INTPTR_FORMAT ": in-use global "
                     "monitor's object does not refer to the same monitor: obj="
                     INTPTR_FORMAT ", mark=" INTPTR_FORMAT ", obj_mon="
-                    INTPTR_FORMAT, p2i(n), p2i((address)obj),
-                    p2i((address)mark), p2i((address)obj_mon));
+                    INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));
     }
     *error_cnt_p = *error_cnt_p + 1;
   }
 }
 
 // Check the thread's free list and count; log the results of the checks.
 void ObjectSynchronizer::chk_per_thread_free_list_and_count(JavaThread *jt,
                                                             outputStream * out,
                                                             int *error_cnt_p) {
-  int chkOmFreeCount = 0;
-  for (ObjectMonitor * n = jt->omFreeList; n != NULL; n = n->FreeNext) {
-    chk_free_entry(jt, n, out, error_cnt_p);
-    chkOmFreeCount++;
-  }
-  if (jt->omFreeCount == chkOmFreeCount) {
-    out->print_cr("jt=" INTPTR_FORMAT ": omFreeCount=%d equals "
-                  "chkOmFreeCount=%d", p2i(jt), jt->omFreeCount, chkOmFreeCount);
+  int chk_om_free_count = 0;
+  ObjectMonitor* cur = NULL;
+  if ((cur = get_list_head_locked(&jt->om_free_list)) != NULL) {
+    // Marked the per-thread free list head so process the list.
+    while (true) {
+      chk_free_entry(jt, cur, out, error_cnt_p);
+      chk_om_free_count++;
+
+      cur = lock_next_for_traversal(cur);
+      if (cur == NULL) {
+        break;
+      }
+    }
+  }
+  int l_om_free_count = Atomic::load(&jt->om_free_count);
+  if (l_om_free_count == chk_om_free_count) {
+    out->print_cr("jt=" INTPTR_FORMAT ": om_free_count=%d equals "
+                  "chk_om_free_count=%d", p2i(jt), l_om_free_count, chk_om_free_count);
   } else {
-    out->print_cr("ERROR: jt=" INTPTR_FORMAT ": omFreeCount=%d is not "
-                  "equal to chkOmFreeCount=%d", p2i(jt), jt->omFreeCount,
-                  chkOmFreeCount);
+    out->print_cr("ERROR: jt=" INTPTR_FORMAT ": om_free_count=%d is not "
+                  "equal to chk_om_free_count=%d", p2i(jt), l_om_free_count,
+                  chk_om_free_count);
     *error_cnt_p = *error_cnt_p + 1;
   }
 }
 
 // Check the thread's in-use list and count; log the results of the checks.
 void ObjectSynchronizer::chk_per_thread_in_use_list_and_count(JavaThread *jt,
                                                               outputStream * out,
                                                               int *error_cnt_p) {
-  int chkOmInUseCount = 0;
-  for (ObjectMonitor * n = jt->omInUseList; n != NULL; n = n->FreeNext) {
-    chk_in_use_entry(jt, n, out, error_cnt_p);
-    chkOmInUseCount++;
-  }
-  if (jt->omInUseCount == chkOmInUseCount) {
-    out->print_cr("jt=" INTPTR_FORMAT ": omInUseCount=%d equals "
-                  "chkOmInUseCount=%d", p2i(jt), jt->omInUseCount,
-                  chkOmInUseCount);
+  int chk_om_in_use_count = 0;
+  ObjectMonitor* cur = NULL;
+  if ((cur = get_list_head_locked(&jt->om_in_use_list)) != NULL) {
+    // Marked the per-thread in-use list head so process the list.
+    while (true) {
+      chk_in_use_entry(jt, cur, out, error_cnt_p);
+      chk_om_in_use_count++;
+
+      cur = lock_next_for_traversal(cur);
+      if (cur == NULL) {
+        break;
+      }
+    }
+  }
+  int l_om_in_use_count = Atomic::load(&jt->om_in_use_count);
+  if (l_om_in_use_count == chk_om_in_use_count) {
+    out->print_cr("jt=" INTPTR_FORMAT ": om_in_use_count=%d equals "
+                  "chk_om_in_use_count=%d", p2i(jt), l_om_in_use_count,
+                  chk_om_in_use_count);
   } else {
-    out->print_cr("ERROR: jt=" INTPTR_FORMAT ": omInUseCount=%d is not "
-                  "equal to chkOmInUseCount=%d", p2i(jt), jt->omInUseCount,
-                  chkOmInUseCount);
+    out->print_cr("ERROR: jt=" INTPTR_FORMAT ": om_in_use_count=%d is not "
+                  "equal to chk_om_in_use_count=%d", p2i(jt), l_om_in_use_count,
+                  chk_om_in_use_count);
     *error_cnt_p = *error_cnt_p + 1;
   }
 }
 
 // Log details about ObjectMonitors on the in-use lists. The 'BHL'
 // flags indicate why the entry is in-use, 'object' and 'object type'
 // indicate the associated object and its type.
-void ObjectSynchronizer::log_in_use_monitor_details(outputStream * out,
-                                                    bool on_exit) {
-  if (!on_exit) {
-    // Not at VM exit so grab the global list lock.
-    Thread::muxAcquire(&gListLock, "log_in_use_monitor_details");
-  }
-
-  if (gOmInUseCount > 0) {
+void ObjectSynchronizer::log_in_use_monitor_details(outputStream * out) {
+  stringStream ss;
+  if (Atomic::load(&om_list_globals._in_use_count) > 0) {
     out->print_cr("In-use global monitor info:");
-    out->print_cr("(B -> is_busy, H -> has hashcode, L -> lock status)");
+    out->print_cr("(B -> is_busy, H -> has hash code, L -> lock status)");
     out->print_cr("%18s  %s  %18s  %18s",
                   "monitor", "BHL", "object", "object type");
     out->print_cr("==================  ===  ==================  ==================");
-    for (ObjectMonitor * n = gOmInUseList; n != NULL; n = n->FreeNext) {
-      const oop obj = (oop) n->object();
-      const markOop mark = n->header();
-      ResourceMark rm;
-      out->print_cr(INTPTR_FORMAT "  %d%d%d  " INTPTR_FORMAT "  %s", p2i(n),
-                    n->is_busy() != 0, mark->hash() != 0, n->owner() != NULL,
-                    p2i(obj), obj->klass()->external_name());
-    }
-  }
+    ObjectMonitor* cur = NULL;
+    if ((cur = get_list_head_locked(&om_list_globals._in_use_list)) != NULL) {
+      // Marked the global in-use list head so process the list.
+      while (true) {
+        const oop obj = (oop) cur->object();
+        const markWord mark = cur->header();
+        ResourceMark rm;
+        out->print(INTPTR_FORMAT "  %d%d%d  " INTPTR_FORMAT "  %s", p2i(cur),
+                   cur->is_busy() != 0, mark.hash() != 0, cur->owner() != NULL,
+                   p2i(obj), obj->klass()->external_name());
+        if (cur->is_busy() != 0) {
+          out->print(" (%s)", cur->is_busy_to_string(&ss));
+          ss.reset();
+        }
+        out->cr();
 
-  if (!on_exit) {
-    Thread::muxRelease(&gListLock);
+        cur = lock_next_for_traversal(cur);
+        if (cur == NULL) {
+          break;
+        }
+      }
+    }
   }
 
   out->print_cr("In-use per-thread monitor info:");
-  out->print_cr("(B -> is_busy, H -> has hashcode, L -> lock status)");
+  out->print_cr("(B -> is_busy, H -> has hash code, L -> lock status)");
   out->print_cr("%18s  %18s  %s  %18s  %18s",
                 "jt", "monitor", "BHL", "object", "object type");
   out->print_cr("==================  ==================  ===  ==================  ==================");
   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
-    for (ObjectMonitor * n = jt->omInUseList; n != NULL; n = n->FreeNext) {
-      const oop obj = (oop) n->object();
-      const markOop mark = n->header();
-      ResourceMark rm;
-      out->print_cr(INTPTR_FORMAT "  " INTPTR_FORMAT "  %d%d%d  " INTPTR_FORMAT
-                    "  %s", p2i(jt), p2i(n), n->is_busy() != 0,
-                    mark->hash() != 0, n->owner() != NULL, p2i(obj),
-                    obj->klass()->external_name());
+    ObjectMonitor* cur = NULL;
+    if ((cur = get_list_head_locked(&jt->om_in_use_list)) != NULL) {
+      // Marked the global in-use list head so process the list.
+      while (true) {
+        const oop obj = (oop) cur->object();
+        const markWord mark = cur->header();
+        ResourceMark rm;
+        out->print(INTPTR_FORMAT "  " INTPTR_FORMAT "  %d%d%d  " INTPTR_FORMAT
+                   "  %s", p2i(jt), p2i(cur), cur->is_busy() != 0,
+                   mark.hash() != 0, cur->owner() != NULL, p2i(obj),
+                   obj->klass()->external_name());
+        if (cur->is_busy() != 0) {
+          out->print(" (%s)", cur->is_busy_to_string(&ss));
+          ss.reset();
+        }
+        out->cr();
+
+        cur = lock_next_for_traversal(cur);
+        if (cur == NULL) {
+          break;
+        }
+      }
     }
   }
 
   out->flush();
 }
 
 // Log counts for the global and per-thread monitor lists and return
 // the population count.
 int ObjectSynchronizer::log_monitor_list_counts(outputStream * out) {
-  int popCount = 0;
+  int pop_count = 0;
   out->print_cr("%18s  %10s  %10s  %10s",
                 "Global Lists:", "InUse", "Free", "Total");
   out->print_cr("==================  ==========  ==========  ==========");
-  out->print_cr("%18s  %10d  %10d  %10d", "",
-                gOmInUseCount, gMonitorFreeCount, gMonitorPopulation);
-  popCount += gOmInUseCount + gMonitorFreeCount;
+  int l_in_use_count = Atomic::load(&om_list_globals._in_use_count);
+  int l_free_count = Atomic::load(&om_list_globals._free_count);
+  out->print_cr("%18s  %10d  %10d  %10d", "", l_in_use_count,
+                l_free_count, Atomic::load(&om_list_globals._population));
+  pop_count += l_in_use_count + l_free_count;
 
   out->print_cr("%18s  %10s  %10s  %10s",
                 "Per-Thread Lists:", "InUse", "Free", "Provision");
   out->print_cr("==================  ==========  ==========  ==========");
 
   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
+    int l_om_in_use_count = Atomic::load(&jt->om_in_use_count);
+    int l_om_free_count = Atomic::load(&jt->om_free_count);
     out->print_cr(INTPTR_FORMAT "  %10d  %10d  %10d", p2i(jt),
-                  jt->omInUseCount, jt->omFreeCount, jt->omFreeProvision);
-    popCount += jt->omInUseCount + jt->omFreeCount;
+                  l_om_in_use_count, l_om_free_count, jt->om_free_provision);
+    pop_count += l_om_in_use_count + l_om_free_count;
   }
-  return popCount;
+  return pop_count;
 }
 
 #ifndef PRODUCT
 
 // Check if monitor belongs to the monitor cache
 // The list is grow-only so it's *relatively* safe to traverse
 // the list of extant blocks without taking a lock.
 
 int ObjectSynchronizer::verify_objmon_isinpool(ObjectMonitor *monitor) {
-  PaddedEnd<ObjectMonitor> * block = OrderAccess::load_acquire(&gBlockList);
+  PaddedObjectMonitor* block = Atomic::load(&g_block_list);
   while (block != NULL) {
     assert(block->object() == CHAINMARKER, "must be a block header");
     if (monitor > &block[0] && monitor < &block[_BLOCKSIZE]) {
       address mon = (address)monitor;
       address blk = (address)block;
       size_t diff = mon - blk;
-      assert((diff % sizeof(PaddedEnd<ObjectMonitor>)) == 0, "must be aligned");
+      assert((diff % sizeof(PaddedObjectMonitor)) == 0, "must be aligned");
       return 1;
     }
-    block = (PaddedEnd<ObjectMonitor> *)block->FreeNext;
+    // unmarked_next() is not needed with g_block_list (no locking
+    // used with block linkage _next_om fields).
+    block = (PaddedObjectMonitor*)block->next_om();
   }
   return 0;
 }
 
 #endif

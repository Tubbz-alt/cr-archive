<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/safepoint.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="safepoint.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepointMechanism.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/safepoint.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -46,10 +46,18 @@</span>
  // exit safepoint methods, when a thread is blocked/restarted. Hence, all mutex exter/
  // exit points *must* be at a safepoint.
  
  class ThreadSafepointState;
  
<span class="udiff-line-added">+ class SafepointStateTracker {</span>
<span class="udiff-line-added">+   uint64_t _safepoint_id;</span>
<span class="udiff-line-added">+   bool     _at_safepoint;</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   SafepointStateTracker(uint64_t safepoint_id, bool at_safepoint);</span>
<span class="udiff-line-added">+   bool safepoint_state_changed();</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  //
  // Implements roll-forward to safepoint (safepoint synchronization)
  //
  class SafepointSynchronize : AllStatic {
   public:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,20 +73,21 @@</span>
      SAFEPOINT_CLEANUP_DEFLATE_MONITORS,
      SAFEPOINT_CLEANUP_UPDATE_INLINE_CACHES,
      SAFEPOINT_CLEANUP_COMPILATION_POLICY,
      SAFEPOINT_CLEANUP_SYMBOL_TABLE_REHASH,
      SAFEPOINT_CLEANUP_STRING_TABLE_REHASH,
<span class="udiff-line-removed">-     SAFEPOINT_CLEANUP_CLD_PURGE,</span>
      SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE,
<span class="udiff-line-added">+     SAFEPOINT_CLEANUP_REQUEST_OOPSTORAGE_CLEANUP,</span>
      // Leave this one last.
      SAFEPOINT_CLEANUP_NUM_TASKS
    };
  
   private:
    friend class SafepointMechanism;
    friend class ThreadSafepointState;
    friend class HandshakeState;
<span class="udiff-line-added">+   friend class SafepointStateTracker;</span>
  
    // Threads might read this flag directly, without acquiring the Threads_lock:
    static volatile SynchronizeState _state;
    // Number of threads we are waiting for to block:
    static int              _waiting_to_block;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -89,33 +98,30 @@</span>
    // An even value means there are no ongoing safepoint operations.
    // The counter is incremented ONLY at the beginning and end of each
    // safepoint.
    static volatile uint64_t _safepoint_counter;
  
<span class="udiff-line-added">+   // A change in this counter or a change in the result of</span>
<span class="udiff-line-added">+   // is_at_safepoint() are used by SafepointStateTracker::</span>
<span class="udiff-line-added">+   // safepoint_state_changed() to determine its answer.</span>
<span class="udiff-line-added">+   static uint64_t _safepoint_id;</span>
<span class="udiff-line-added">+ </span>
    // JavaThreads that need to block for the safepoint will stop on the
    // _wait_barrier, where they can quickly be started again.
    static WaitBarrier* _wait_barrier;
<span class="udiff-line-removed">-   static long         _end_of_last_safepoint;     // Time of last safepoint in milliseconds</span>
    static julong       _coalesced_vmop_count;     // coalesced vmop count
  
<span class="udiff-line-removed">-   // Statistics</span>
<span class="udiff-line-removed">-   static void begin_statistics(int nof_threads, int nof_running);</span>
<span class="udiff-line-removed">-   static void update_statistics_on_spin_end();</span>
<span class="udiff-line-removed">-   static void update_statistics_on_sync_end(jlong end_time);</span>
<span class="udiff-line-removed">-   static void update_statistics_on_cleanup_end(jlong end_time);</span>
<span class="udiff-line-removed">-   static void end_statistics(jlong end_time);</span>
<span class="udiff-line-removed">-   static void print_statistics();</span>
<span class="udiff-line-removed">- </span>
    // For debug long safepoint
    static void print_safepoint_timeout();
  
    // Helper methods for safepoint procedure:
    static void arm_safepoint();
    static int synchronize_threads(jlong safepoint_limit_time, int nof_threads, int* initial_running);
    static void disarm_safepoint();
    static void increment_jni_active_count();
    static void decrement_waiting_to_block();
<span class="udiff-line-added">+   static bool thread_not_running(ThreadSafepointState *cur_state);</span>
  
    // Used in safepoint_safe to do a stable load of the thread state.
    static bool try_stable_load_state(JavaThreadState *state,
                                      JavaThread *thread,
                                      uint64_t safepoint_count);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -125,10 +131,12 @@</span>
  
    // Called from VMThread during handshakes.
    // If true the VMThread may safely process the handshake operation for the JavaThread.
    static bool handshake_safe(JavaThread *thread);
  
<span class="udiff-line-added">+   static uint64_t safepoint_counter()             { return _safepoint_counter; }</span>
<span class="udiff-line-added">+ </span>
  public:
  
    static void init(Thread* vmthread);
  
    // Roll all threads forward to safepoint. Must be called by the VMThread.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -139,16 +147,24 @@</span>
    static const uint64_t InactiveSafepointCounter;
  
    // Query
    static bool is_at_safepoint()                   { return _state == _synchronized; }
    static bool is_synchronizing()                  { return _state == _synchronizing; }
<span class="udiff-line-modified-removed">-   static uint64_t safepoint_counter()             { return _safepoint_counter; }</span>
<span class="udiff-line-modified-removed">-   static bool is_same_safepoint(uint64_t counter) { return (SafepointSynchronize::safepoint_counter() - counter) &lt; 2; }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   static uint64_t safepoint_id() {</span>
<span class="udiff-line-added">+     return _safepoint_id;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static SafepointStateTracker safepoint_state_tracker() {</span>
<span class="udiff-line-added">+     return SafepointStateTracker(safepoint_id(), is_at_safepoint());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Exception handling for page polling
    static void handle_polling_page_exception(JavaThread *thread);
  
    static bool is_cleanup_needed();
<span class="udiff-line-added">+   static bool is_forced_cleanup_needed();</span>
    static void do_cleanup_tasks();
  
    static void set_is_at_safepoint()             { _state = _synchronized; }
    static void set_is_not_at_safepoint()         { _state = _not_synchronized; }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -188,11 +204,10 @@</span>
    // At polling page safepoint (NOT a poll return safepoint):
    volatile bool                   _at_poll_safepoint;
    JavaThread*                     _thread;
    bool                            _safepoint_safe;
    volatile uint64_t               _safepoint_id;
<span class="udiff-line-removed">-   JavaThreadState                 _orig_thread_state;</span>
  
    ThreadSafepointState*           _next;
  
    void account_safe_thread();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -214,21 +229,18 @@</span>
  
    uint64_t get_safepoint_id() const;
    void     reset_safepoint_id();
    void     set_safepoint_id(uint64_t sid);
  
<span class="udiff-line-removed">-   JavaThreadState orig_thread_state() const { return _orig_thread_state; }</span>
<span class="udiff-line-removed">- </span>
    // Support for safepoint timeout (debugging)
    bool is_at_poll_safepoint()           { return _at_poll_safepoint; }
    void set_at_poll_safepoint(bool val)  { _at_poll_safepoint = val; }
  
    void handle_polling_page_exception();
  
    // debugging
    void print_on(outputStream* st) const;
<span class="udiff-line-removed">-   void print() const                        { print_on(tty); }</span>
  
    // Initialize
    static void create(JavaThread *thread);
    static void destroy(JavaThread *thread);
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -238,12 +250,11 @@</span>
    // Absolute
    static jlong _last_safepoint_begin_time_ns;
    static jlong _last_safepoint_sync_time_ns;
    static jlong _last_safepoint_cleanup_time_ns;
    static jlong _last_safepoint_end_time_ns;
<span class="udiff-line-modified-removed">-   // amount of ms since epoch</span>
<span class="udiff-line-removed">-   static jlong _last_safepoint_end_time_epoch_ms;</span>
<span class="udiff-line-modified-added">+ </span>
    // Relative
    static jlong _last_app_time_ns;
  
    static int _nof_threads;
    static int _nof_running;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -265,15 +276,15 @@</span>
    static void end();
  
    static void statistics_exit_log();
  
    static jlong time_since_last_safepoint_ms() {
<span class="udiff-line-modified-removed">-     return (os::javaTimeNanos() - _last_safepoint_end_time_ns) / (NANOUNITS / MILLIUNITS);</span>
<span class="udiff-line-modified-added">+     return nanos_to_millis(os::javaTimeNanos() - _last_safepoint_end_time_ns);</span>
    }
  
<span class="udiff-line-modified-removed">-   static jlong end_of_last_safepoint_epoch_ms() {</span>
<span class="udiff-line-modified-removed">-     return _last_safepoint_end_time_epoch_ms;</span>
<span class="udiff-line-modified-added">+   static jlong end_of_last_safepoint_ms() {</span>
<span class="udiff-line-modified-added">+     return nanos_to_millis(_last_safepoint_end_time_ns);</span>
    }
  
    static jlong start_of_safepoint() {
      return _last_safepoint_begin_time_ns;
    }
</pre>
<center><a href="safepoint.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepointMechanism.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
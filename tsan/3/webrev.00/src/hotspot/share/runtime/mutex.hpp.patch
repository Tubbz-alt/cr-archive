diff a/src/hotspot/share/runtime/mutex.hpp b/src/hotspot/share/runtime/mutex.hpp
--- a/src/hotspot/share/runtime/mutex.hpp
+++ b/src/hotspot/share/runtime/mutex.hpp
@@ -25,23 +25,21 @@
 #ifndef SHARE_RUNTIME_MUTEX_HPP
 #define SHARE_RUNTIME_MUTEX_HPP
 
 #include "memory/allocation.hpp"
 #include "runtime/os.hpp"
-#include "utilities/histogram.hpp"
-
 
 // A Mutex/Monitor is a simple wrapper around a native lock plus condition
 // variable that supports lock ownership tracking, lock ranking for deadlock
 // detection and coordinates with the safepoint protocol.
 
-// The default length of monitor name was originally chosen to be 64 to avoid
-// false sharing. Now, PaddedMonitor is available for this purpose.
-// TODO: Check if _name[MONITOR_NAME_LEN] should better get replaced by const char*.
-static const int MONITOR_NAME_LEN = 64;
+// The default length of mutex name was originally chosen to be 64 to avoid
+// false sharing. Now, PaddedMutex and PaddedMonitor are available for this purpose.
+// TODO: Check if _name[MUTEX_NAME_LEN] should better get replaced by const char*.
+static const int MUTEX_NAME_LEN = 64;
 
-class Monitor : public CHeapObj<mtSynchronizer> {
+class Mutex : public CHeapObj<mtSynchronizer> {
 
  public:
   // A special lock: Is a lock where you are guaranteed not to block while you are
   // holding it, i.e., no vm operation can happen, taking other (blocking) locks, etc.
   // The rank 'access' is similar to 'special' and has the same restrictions on usage.
@@ -52,195 +50,164 @@
   // Since memory accesses should be able to be performed pretty much anywhere
   // in the code, that requires locks required for performing accesses being
   // inherently a bit more special than even locks of the 'special' rank.
   // NOTE: It is critical that the rank 'special' be the lowest (earliest)
   // (except for "event" and "access") for the deadlock detection to work correctly.
-  // The rank native is only for use in Mutex's created by JVM_RawMonitorCreate,
-  // which being external to the VM are not subject to deadlock detection.
+  // The rank native was only for use in Mutexes created by JVM_RawMonitorCreate,
+  // which being external to the VM are not subject to deadlock detection,
+  // however it has now been used by other locks that don't fit into the
+  // deadlock detection scheme.
   // While at a safepoint no mutexes of rank safepoint are held by any thread.
   // The rank named "leaf" is probably historical (and should
   // be changed) -- mutexes of this rank aren't really leaf mutexes
   // at all.
   enum lock_types {
        event,
        access         = event          +   1,
        tty            = access         +   2,
-       special        = tty            +   1,
+       special        = tty            +   2,
        suspend_resume = special        +   1,
-       vmweak         = suspend_resume +   2,
-       leaf           = vmweak         +   2,
+       oopstorage     = suspend_resume +   2,
+       leaf           = oopstorage     +   2,
        safepoint      = leaf           +  10,
        barrier        = safepoint      +   1,
        nonleaf        = barrier        +   1,
        max_nonleaf    = nonleaf        + 900,
        native         = max_nonleaf    +   1
   };
 
  protected:                              // Monitor-Mutex metadata
   Thread * volatile _owner;              // The owner of the lock
   os::PlatformMonitor _lock;             // Native monitor implementation
-  char _name[MONITOR_NAME_LEN];          // Name of mutex/monitor
+  char _name[MUTEX_NAME_LEN];            // Name of mutex/monitor
 
   // Debugging fields for naming, deadlock detection, etc. (some only used in debug mode)
 #ifndef PRODUCT
-  bool      _allow_vm_block;
-  DEBUG_ONLY(int _rank;)                 // rank (to avoid/detect potential deadlocks)
-  DEBUG_ONLY(Monitor * _next;)           // Used by a Thread to link up owned locks
-  DEBUG_ONLY(Thread* _last_owner;)       // the last thread to own the lock
-  DEBUG_ONLY(static bool contains(Monitor * locks, Monitor * lock);)
-  DEBUG_ONLY(static Monitor * get_least_ranked_lock(Monitor * locks);)
-  DEBUG_ONLY(Monitor * get_least_ranked_lock_besides_this(Monitor * locks);)
-#endif
-
-  void set_owner_implementation(Thread* owner)                        PRODUCT_RETURN;
-  void check_prelock_state     (Thread* thread, bool safepoint_check) PRODUCT_RETURN;
-  void check_block_state       (Thread* thread)                       PRODUCT_RETURN;
+  bool    _allow_vm_block;
+  int     _rank;                 // rank (to avoid/detect potential deadlocks)
+  Mutex*  _next;                 // Used by a Thread to link up owned locks
+  Thread* _last_owner;           // the last thread to own the lock
+  static bool contains(Mutex* locks, Mutex* lock);
+  static Mutex* get_least_ranked_lock(Mutex* locks);
+  Mutex* get_least_ranked_lock_besides_this(Mutex* locks);
+#endif  // ASSERT
+
+  void set_owner_implementation(Thread* owner)                        NOT_DEBUG({ _owner = owner;});
+  void check_block_state       (Thread* thread)                       NOT_DEBUG_RETURN;
+  void check_safepoint_state   (Thread* thread)                       NOT_DEBUG_RETURN;
+  void check_no_safepoint_state(Thread* thread)                       NOT_DEBUG_RETURN;
   void assert_owner            (Thread* expected)                     NOT_DEBUG_RETURN;
+  void no_safepoint_verifier   (Thread* thread, bool enable)          NOT_DEBUG_RETURN;
 
  public:
   enum {
-    _no_safepoint_check_flag    = true,
     _allow_vm_block_flag        = true,
     _as_suspend_equivalent_flag = true
   };
 
-  // Locks can be acquired with or without safepoint check.
-  // Monitor::lock and Monitor::lock_without_safepoint_check
-  // checks these flags when acquiring a lock to ensure
-  // consistent checking for each lock.
-  // A few existing locks will sometimes have a safepoint check and
-  // sometimes not, but these locks are set up in such a way to avoid deadlocks.
-  // Note: monitors that may be shared between JavaThreads and the VMThread
-  // should never encounter a safepoint check whilst they are held, else a
-  // deadlock with the VMThread can occur.
+  // Locks can be acquired with or without a safepoint check. NonJavaThreads do not follow
+  // the safepoint protocol when acquiring locks.
+
+  // Each lock can be acquired by only JavaThreads, only NonJavaThreads, or shared between
+  // Java and NonJavaThreads. When the lock is initialized with _safepoint_check_always,
+  // that means that whenever the lock is acquired by a JavaThread, it will verify that
+  // it is done with a safepoint check. In corollary, when the lock is initialized with
+  // _safepoint_check_never, that means that whenever the lock is acquired by a JavaThread
+  // it will verify that it is done without a safepoint check.
+
+
+  // There are a couple of existing locks that will sometimes have a safepoint check and
+  // sometimes not when acquired by a JavaThread, but these locks are set up carefully
+  // to avoid deadlocks. TODO: Fix these locks and remove _safepoint_check_sometimes.
+
+  // TODO: Locks that are shared between JavaThreads and NonJavaThreads
+  // should never encounter a safepoint check while they are held, or else a
+  // deadlock can occur. We should check this by noting which
+  // locks are shared, and walk held locks during safepoint checking.
+
+  enum SafepointCheckFlag {
+    _safepoint_check_flag,
+    _no_safepoint_check_flag
+  };
+
   enum SafepointCheckRequired {
-    _safepoint_check_never,       // Monitors with this value will cause errors
-                                  // when acquired with a safepoint check.
-    _safepoint_check_sometimes,   // Certain locks are called sometimes with and
-                                  // sometimes without safepoint checks. These
+    _safepoint_check_never,       // Mutexes with this value will cause errors
+                                  // when acquired by a JavaThread with a safepoint check.
+    _safepoint_check_sometimes,   // A couple of special locks are acquired by JavaThreads sometimes
+                                  // with and sometimes without safepoint checks. These
                                   // locks will not produce errors when locked.
-    _safepoint_check_always       // Causes error if locked without a safepoint
-                                  // check.
+    _safepoint_check_always       // Mutexes with this value will cause errors
+                                  // when acquired by a JavaThread without a safepoint check.
   };
 
   NOT_PRODUCT(SafepointCheckRequired _safepoint_check_required;)
 
- protected:
-   static void ClearMonitor (Monitor * m, const char* name = NULL) ;
-   Monitor() ;
-
  public:
-  Monitor(int rank, const char *name, bool allow_vm_block = false,
-          SafepointCheckRequired safepoint_check_required = _safepoint_check_always);
-  ~Monitor();
-
-  // Wait until monitor is notified (or times out).
-  // Defaults are to make safepoint checks, wait time is forever (i.e.,
-  // zero), and not a suspend-equivalent condition. Returns true if wait
-  // times out; otherwise returns false.
-  bool wait(bool no_safepoint_check = !_no_safepoint_check_flag,
-            long timeout = 0,
-            bool as_suspend_equivalent = !_as_suspend_equivalent_flag);
-  void notify();
-  void notify_all();
-
+  Mutex(int rank, const char *name, bool allow_vm_block = false,
+        SafepointCheckRequired safepoint_check_required = _safepoint_check_always);
+  ~Mutex();
 
   void lock(); // prints out warning if VM thread blocks
   void lock(Thread *thread); // overloaded with current thread
   void unlock();
   bool is_locked() const                     { return _owner != NULL; }
 
   bool try_lock(); // Like lock(), but unblocking. It returns false instead
+ private:
+  void lock_contended(Thread *thread); // contended slow-path
+ public:
 
   void release_for_safepoint();
 
   // Lock without safepoint check. Should ONLY be used by safepoint code and other code
   // that is guaranteed not to block while running inside the VM.
   void lock_without_safepoint_check();
-  void lock_without_safepoint_check (Thread * Self) ;
+  void lock_without_safepoint_check(Thread* self);
 
   // Current owner - not not MT-safe. Can only be used to guarantee that
   // the current running thread owns the lock
   Thread* owner() const         { return _owner; }
   bool owned_by_self() const;
 
-  // Support for JVM_RawMonitorEnter & JVM_RawMonitorExit. These can be called by
-  // non-Java thread. (We should really have a RawMonitor abstraction)
-  void jvm_raw_lock();
-  void jvm_raw_unlock();
   const char *name() const                  { return _name; }
 
   void print_on_error(outputStream* st) const;
 
   #ifndef PRODUCT
     void print_on(outputStream* st) const;
     void print() const                      { print_on(::tty); }
-    DEBUG_ONLY(int    rank() const          { return _rank; })
-    bool   allow_vm_block()                 { return _allow_vm_block; }
-
-    DEBUG_ONLY(Monitor *next()  const         { return _next; })
-    DEBUG_ONLY(void   set_next(Monitor *next) { _next = next; })
   #endif
+  #ifdef ASSERT
+    int    rank() const          { return _rank; }
+    bool   allow_vm_block()      { return _allow_vm_block; }
 
-  void set_owner(Thread* owner) {
-  #ifndef PRODUCT
-    set_owner_implementation(owner);
-    DEBUG_ONLY(void verify_Monitor(Thread* thr);)
-  #else
-    _owner = owner;
-  #endif
-  }
+    Mutex *next()  const         { return _next; }
+    void   set_next(Mutex *next) { _next = next; }
+  #endif // ASSERT
 
+  void set_owner(Thread* owner)             { set_owner_implementation(owner); }
 };
 
-class PaddedMonitor : public Monitor {
-  enum {
-    CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Monitor),
-    PADDING_LEN = CACHE_LINE_PADDING > 0 ? CACHE_LINE_PADDING : 1
-  };
-  char _padding[PADDING_LEN];
+class Monitor : public Mutex {
+  void assert_wait_lock_state  (Thread* self)                         NOT_DEBUG_RETURN;
  public:
-  PaddedMonitor(int rank, const char *name, bool allow_vm_block = false,
-               SafepointCheckRequired safepoint_check_required = _safepoint_check_always) :
-    Monitor(rank, name, allow_vm_block, safepoint_check_required) {};
-};
-
-// Normally we'd expect Monitor to extend Mutex in the sense that a monitor
-// constructed from pthreads primitives might extend a mutex by adding
-// a condvar and some extra metadata.  In fact this was the case until J2SE7.
-//
-// Currently, however, the base object is a monitor.  Monitor contains all the
-// logic for wait(), notify(), etc.   Mutex extends monitor and restricts the
-// visibility of wait(), notify(), and notify_all().
-//
-// Another viable alternative would have been to have Monitor extend Mutex and
-// implement all the normal mutex and wait()-notify() logic in Mutex base class.
-// The wait()-notify() facility would be exposed via special protected member functions
-// (e.g., _Wait() and _Notify()) in Mutex.  Monitor would extend Mutex and expose wait()
-// as a call to _Wait().  That is, the public wait() would be a wrapper for the protected
-// _Wait().
-//
-// An even better alternative is to simply eliminate Mutex:: and use Monitor:: instead.
-// After all, monitors are sufficient for Java-level synchronization.   At one point in time
-// there may have been some benefit to having distinct mutexes and monitors, but that time
-// has past.
-//
-
-class Mutex : public Monitor {      // degenerate Monitor
- public:
-   Mutex(int rank, const char *name, bool allow_vm_block = false,
+   Monitor(int rank, const char *name, bool allow_vm_block = false,
          SafepointCheckRequired safepoint_check_required = _safepoint_check_always);
-  // default destructor
- private:
-   void notify ()    { ShouldNotReachHere(); }
-   void notify_all() { ShouldNotReachHere(); }
-   bool wait (bool no_safepoint_check, long timeout, bool as_suspend_equivalent) {
-     ShouldNotReachHere() ;
-     return false ;
-   }
+   // default destructor
+
+  // Wait until monitor is notified (or times out).
+  // Defaults are to make safepoint checks, wait time is forever (i.e.,
+  // zero), and not a suspend-equivalent condition. Returns true if wait
+  // times out; otherwise returns false.
+  bool wait(long timeout = 0,
+            bool as_suspend_equivalent = !_as_suspend_equivalent_flag);
+  bool wait_without_safepoint_check(long timeout = 0);
+  void notify();
+  void notify_all();
 };
 
+
 class PaddedMutex : public Mutex {
   enum {
     CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Mutex),
     PADDING_LEN = CACHE_LINE_PADDING > 0 ? CACHE_LINE_PADDING : 1
   };
@@ -249,6 +216,18 @@
   PaddedMutex(int rank, const char *name, bool allow_vm_block = false,
               SafepointCheckRequired safepoint_check_required = _safepoint_check_always) :
     Mutex(rank, name, allow_vm_block, safepoint_check_required) {};
 };
 
+class PaddedMonitor : public Monitor {
+  enum {
+    CACHE_LINE_PADDING = (int)DEFAULT_CACHE_LINE_SIZE - (int)sizeof(Monitor),
+    PADDING_LEN = CACHE_LINE_PADDING > 0 ? CACHE_LINE_PADDING : 1
+  };
+  char _padding[PADDING_LEN];
+ public:
+  PaddedMonitor(int rank, const char *name, bool allow_vm_block = false,
+               SafepointCheckRequired safepoint_check_required = _safepoint_check_always) :
+    Monitor(rank, name, allow_vm_block, safepoint_check_required) {};
+};
+
 #endif // SHARE_RUNTIME_MUTEX_HPP

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/sweeper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubRoutines.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sweeper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -35,12 +35,10 @@</span>
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/method.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/atomic.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/handshake.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/orderAccess.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -197,31 +195,31 @@</span>
  }
  bool NMethodSweeper::wait_for_stack_scanning() {
    return _current.end();
  }
  
<span class="udiff-line-modified-removed">- class NMethodMarkingThreadClosure : public ThreadClosure {</span>
<span class="udiff-line-modified-added">+ class NMethodMarkingClosure : public HandshakeClosure {</span>
  private:
    CodeBlobClosure* _cl;
  public:
<span class="udiff-line-modified-removed">-   NMethodMarkingThreadClosure(CodeBlobClosure* cl) : _cl(cl) {}</span>
<span class="udiff-line-modified-added">+   NMethodMarkingClosure(CodeBlobClosure* cl) : HandshakeClosure(&quot;NMethodMarking&quot;), _cl(cl) {}</span>
    void do_thread(Thread* thread) {
      if (thread-&gt;is_Java_thread() &amp;&amp; ! thread-&gt;is_Code_cache_sweeper_thread()) {
        JavaThread* jt = (JavaThread*) thread;
        jt-&gt;nmethods_do(_cl);
      }
    }
  };
  
  class NMethodMarkingTask : public AbstractGangTask {
  private:
<span class="udiff-line-modified-removed">-   NMethodMarkingThreadClosure* _cl;</span>
<span class="udiff-line-modified-added">+   NMethodMarkingClosure* _cl;</span>
  public:
<span class="udiff-line-modified-removed">-   NMethodMarkingTask(NMethodMarkingThreadClosure* cl) :</span>
<span class="udiff-line-modified-added">+   NMethodMarkingTask(NMethodMarkingClosure* cl) :</span>
      AbstractGangTask(&quot;Parallel NMethod Marking&quot;),
      _cl(cl) {
<span class="udiff-line-modified-removed">-     Threads::change_thread_claim_parity();</span>
<span class="udiff-line-modified-added">+     Threads::change_thread_claim_token();</span>
    }
  
    ~NMethodMarkingTask() {
      Threads::assert_all_threads_claimed();
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -239,22 +237,22 @@</span>
  void NMethodSweeper::mark_active_nmethods() {
    CodeBlobClosure* cl = prepare_mark_active_nmethods();
    if (cl != NULL) {
      WorkGang* workers = Universe::heap()-&gt;get_safepoint_workers();
      if (workers != NULL) {
<span class="udiff-line-modified-removed">-       NMethodMarkingThreadClosure tcl(cl);</span>
<span class="udiff-line-modified-added">+       NMethodMarkingClosure tcl(cl);</span>
        NMethodMarkingTask task(&amp;tcl);
        workers-&gt;run_task(&amp;task);
      } else {
        Threads::nmethods_do(cl);
      }
    }
  }
  
  CodeBlobClosure* NMethodSweeper::prepare_mark_active_nmethods() {
  #ifdef ASSERT
<span class="udiff-line-modified-removed">-   if (ThreadLocalHandshakes) {</span>
<span class="udiff-line-modified-added">+   if (SafepointMechanism::uses_thread_local_poll()) {</span>
      assert(Thread::current()-&gt;is_Code_cache_sweeper_thread(), &quot;must be executed under CodeCache_lock and in sweeper thread&quot;);
      assert_lock_strong(CodeCache_lock);
    } else {
      assert(SafepointSynchronize::is_at_safepoint(), &quot;must be executed at a safepoint&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -317,19 +315,19 @@</span>
    * methods. Stack scanning is mandatory for the sweeper to make progress.
    */
  void NMethodSweeper::do_stack_scanning() {
    assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
    if (wait_for_stack_scanning()) {
<span class="udiff-line-modified-removed">-     if (ThreadLocalHandshakes) {</span>
<span class="udiff-line-modified-added">+     if (SafepointMechanism::uses_thread_local_poll()) {</span>
        CodeBlobClosure* code_cl;
        {
<span class="udiff-line-modified-removed">-         MutexLockerEx ccl(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+         MutexLocker ccl(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
          code_cl = prepare_mark_active_nmethods();
        }
        if (code_cl != NULL) {
<span class="udiff-line-modified-removed">-         NMethodMarkingThreadClosure tcl(code_cl);</span>
<span class="udiff-line-modified-removed">-         Handshake::execute(&amp;tcl);</span>
<span class="udiff-line-modified-added">+         NMethodMarkingClosure nm_cl(code_cl);</span>
<span class="udiff-line-modified-added">+         Handshake::execute(&amp;nm_cl);</span>
        }
      } else {
        VM_MarkActiveNMethods op;
        VMThread::execute(&amp;op);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -339,13 +337,13 @@</span>
  void NMethodSweeper::sweeper_loop() {
    bool timeout;
    while (true) {
      {
        ThreadBlockInVM tbivm(JavaThread::current());
<span class="udiff-line-modified-removed">-       MutexLockerEx waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+       MonitorLocker waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
        const long wait_time = 60*60*24 * 1000;
<span class="udiff-line-modified-removed">-       timeout = CodeCache_lock-&gt;wait(Mutex::_no_safepoint_check_flag, wait_time);</span>
<span class="udiff-line-modified-added">+       timeout = waiter.wait(wait_time);</span>
      }
      if (!timeout) {
        possibly_sweep();
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -367,19 +365,19 @@</span>
  /**
    * Wakes up the sweeper thread and forces a sweep. Blocks until it finished.
    */
  void NMethodSweeper::force_sweep() {
    ThreadBlockInVM tbivm(JavaThread::current());
<span class="udiff-line-modified-removed">-   MutexLockerEx waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker waiter(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
    // Request forced sweep
    _force_sweep = true;
    while (_force_sweep) {
      // Notify sweeper that we want to force a sweep and wait for completion.
      // In case a sweep currently takes place we timeout and try again because
      // we want to enforce a full sweep.
      CodeCache_lock-&gt;notify();
<span class="udiff-line-modified-removed">-     CodeCache_lock-&gt;wait(Mutex::_no_safepoint_check_flag, 1000);</span>
<span class="udiff-line-modified-added">+     waiter.wait(1000);</span>
    }
  }
  
  /**
   * Handle a safepoint request
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -388,11 +386,11 @@</span>
    JavaThread* thread = JavaThread::current();
    if (SafepointMechanism::should_block(thread)) {
      if (PrintMethodFlushing &amp;&amp; Verbose) {
        tty-&gt;print_cr(&quot;### Sweep at %d out of %d, yielding to safepoint&quot;, _seen, CodeCache::nmethod_count());
      }
<span class="udiff-line-modified-removed">-     MutexUnlockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
      ThreadBlockInVM tbivm(thread);
      thread-&gt;java_suspend_self();
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -473,11 +471,11 @@</span>
    }
  
    if (forced) {
      // Notify requester that forced sweep finished
      assert(_force_sweep, &quot;Should be a forced sweep&quot;);
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
      _force_sweep = false;
      CodeCache_lock-&gt;notify();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -517,11 +515,11 @@</span>
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be in safepoint when we get here&quot;);
    assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
  
    int freed_memory = 0;
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
  
      while (!_current.end()) {
        swept_count++;
        // Since we will give up the CodeCache_lock, always skip ahead
        // to the next nmethod.  Other blobs can be deleted by other
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -529,11 +527,11 @@</span>
        CompiledMethod* nm = _current.method();
        _current.next();
  
        // Now ready to process nmethod and give up CodeCache_lock
        {
<span class="udiff-line-modified-removed">-         MutexUnlockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+         MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
          // Save information before potentially flushing the nmethod
          // Only flushing nmethods so size only matters for them.
          int size = nm-&gt;is_nmethod() ? ((nmethod*)nm)-&gt;total_size() : 0;
          bool is_c2_method = nm-&gt;is_compiled_by_c2();
          bool is_osr = nm-&gt;is_osr_method();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -574,11 +572,11 @@</span>
    assert(_current.end(), &quot;must have scanned the whole cache&quot;);
  
    const Ticks sweep_end_counter = Ticks::now();
    const Tickspan sweep_time = sweep_end_counter - sweep_start_counter;
    {
<span class="udiff-line-modified-removed">-     MutexLockerEx mu(NMethodSweeperStats_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker mu(NMethodSweeperStats_lock, Mutex::_no_safepoint_check_flag);</span>
      _total_time_sweeping  += sweep_time;
      _total_time_this_sweep += sweep_time;
      _peak_sweep_fraction_time = MAX2(sweep_time, _peak_sweep_fraction_time);
      _total_flushed_size += freed_memory;
      _total_nof_methods_reclaimed += flushed_count;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -697,47 +695,26 @@</span>
      OrderAccess::loadload(); // _stack_traversal_mark and _state
      if (cm-&gt;can_convert_to_zombie()) {
        // Code cache state change is tracked in make_zombie()
        cm-&gt;make_zombie();
        SWEEP(cm);
<span class="udiff-line-modified-removed">-       // The nmethod may have been locked by JVMTI after being made zombie (see</span>
<span class="udiff-line-modified-removed">-       // JvmtiDeferredEvent::compiled_method_unload_event()). If so, we cannot</span>
<span class="udiff-line-modified-removed">-       // flush the osr nmethod directly but have to wait for a later sweeper cycle.</span>
<span class="udiff-line-removed">-       if (cm-&gt;is_osr_method() &amp;&amp; !cm-&gt;is_locked_by_vm()) {</span>
<span class="udiff-line-removed">-         // No inline caches will ever point to osr methods, so we can just remove it.</span>
<span class="udiff-line-removed">-         // Make sure that we unregistered the nmethod with the heap and flushed all</span>
<span class="udiff-line-removed">-         // dependencies before removing the nmethod (done in make_zombie()).</span>
<span class="udiff-line-removed">-         assert(cm-&gt;is_zombie(), &quot;nmethod must be unregistered&quot;);</span>
<span class="udiff-line-removed">-         cm-&gt;flush();</span>
<span class="udiff-line-removed">-         assert(result == None, &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-         result = Flushed;</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         assert(result == None, &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-         result = MadeZombie;</span>
<span class="udiff-line-removed">-         assert(cm-&gt;is_zombie(), &quot;nmethod must be zombie&quot;);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       assert(result == None, &quot;sanity&quot;);</span>
<span class="udiff-line-modified-added">+       result = MadeZombie;</span>
<span class="udiff-line-modified-added">+       assert(cm-&gt;is_zombie(), &quot;nmethod must be zombie&quot;);</span>
      } else {
        // Still alive, clean up its inline caches
        cm-&gt;cleanup_inline_caches(false);
        SWEEP(cm);
      }
    } else if (cm-&gt;is_unloaded()) {
      // Code is unloaded, so there are no activations on the stack.
<span class="udiff-line-modified-removed">-     // Convert the nmethod to zombie or flush it directly in the OSR case.</span>
<span class="udiff-line-modified-removed">-     if (cm-&gt;is_osr_method()) {</span>
<span class="udiff-line-modified-removed">-       SWEEP(cm);</span>
<span class="udiff-line-modified-removed">-       // No inline caches will ever point to osr methods, so we can just remove it</span>
<span class="udiff-line-modified-removed">-       cm-&gt;flush();</span>
<span class="udiff-line-modified-removed">-       assert(result == None, &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-       result = Flushed;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       // Code cache state change is tracked in make_zombie()</span>
<span class="udiff-line-removed">-       cm-&gt;make_zombie();</span>
<span class="udiff-line-removed">-       SWEEP(cm);</span>
<span class="udiff-line-removed">-       assert(result == None, &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-       result = MadeZombie;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     // Convert the nmethod to zombie.</span>
<span class="udiff-line-modified-added">+     // Code cache state change is tracked in make_zombie()</span>
<span class="udiff-line-modified-added">+     cm-&gt;make_zombie();</span>
<span class="udiff-line-modified-added">+     SWEEP(cm);</span>
<span class="udiff-line-modified-added">+     assert(result == None, &quot;sanity&quot;);</span>
<span class="udiff-line-modified-added">+     result = MadeZombie;</span>
    } else {
      if (cm-&gt;is_nmethod()) {
        possibly_flush((nmethod*)cm);
      }
      // Clean inline caches that point to zombie/non-entrant/unloaded nmethods
</pre>
<center><a href="stubRoutines.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
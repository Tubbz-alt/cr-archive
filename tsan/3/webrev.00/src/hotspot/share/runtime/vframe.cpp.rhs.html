<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/vframe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;classfile/vmSymbols.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 #include &quot;code/debugInfoRec.hpp&quot;
 31 #include &quot;code/nmethod.hpp&quot;
 32 #include &quot;code/pcDesc.hpp&quot;
 33 #include &quot;code/scopeDesc.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;interpreter/oopMapCache.hpp&quot;
 36 #include &quot;memory/resourceArea.hpp&quot;
 37 #include &quot;oops/instanceKlass.hpp&quot;
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 #include &quot;runtime/frame.inline.hpp&quot;
 40 #include &quot;runtime/handles.inline.hpp&quot;
 41 #include &quot;runtime/objectMonitor.hpp&quot;
 42 #include &quot;runtime/objectMonitor.inline.hpp&quot;
 43 #include &quot;runtime/signature.hpp&quot;
 44 #include &quot;runtime/stubRoutines.hpp&quot;
 45 #include &quot;runtime/synchronizer.hpp&quot;
 46 #include &quot;runtime/thread.inline.hpp&quot;
 47 #include &quot;runtime/vframe.inline.hpp&quot;
 48 #include &quot;runtime/vframeArray.hpp&quot;
 49 #include &quot;runtime/vframe_hp.hpp&quot;
 50 
 51 vframe::vframe(const frame* fr, const RegisterMap* reg_map, JavaThread* thread)
 52 : _reg_map(reg_map), _thread(thread) {
 53   assert(fr != NULL, &quot;must have frame&quot;);
 54   _fr = *fr;
 55 }
 56 
 57 vframe::vframe(const frame* fr, JavaThread* thread)
 58 : _reg_map(thread), _thread(thread) {
 59   assert(fr != NULL, &quot;must have frame&quot;);
 60   _fr = *fr;
 61 }
 62 
 63 vframe* vframe::new_vframe(const frame* f, const RegisterMap* reg_map, JavaThread* thread) {
 64   // Interpreter frame
 65   if (f-&gt;is_interpreted_frame()) {
 66     return new interpretedVFrame(f, reg_map, thread);
 67   }
 68 
 69   // Compiled frame
 70   CodeBlob* cb = f-&gt;cb();
 71   if (cb != NULL) {
 72     if (cb-&gt;is_compiled()) {
 73       CompiledMethod* nm = (CompiledMethod*)cb;
 74       return new compiledVFrame(f, reg_map, thread, nm);
 75     }
 76 
 77     if (f-&gt;is_runtime_frame()) {
 78       // Skip this frame and try again.
 79       RegisterMap temp_map = *reg_map;
 80       frame s = f-&gt;sender(&amp;temp_map);
 81       return new_vframe(&amp;s, &amp;temp_map, thread);
 82     }
 83   }
 84 
 85   // External frame
 86   return new externalVFrame(f, reg_map, thread);
 87 }
 88 
 89 vframe* vframe::sender() const {
 90   RegisterMap temp_map = *register_map();
 91   assert(is_top(), &quot;just checking&quot;);
 92   if (_fr.is_entry_frame() &amp;&amp; _fr.is_first_frame()) return NULL;
 93   frame s = _fr.real_sender(&amp;temp_map);
 94   if (s.is_first_frame()) return NULL;
 95   return vframe::new_vframe(&amp;s, &amp;temp_map, thread());
 96 }
 97 
 98 vframe* vframe::top() const {
 99   vframe* vf = (vframe*) this;
100   while (!vf-&gt;is_top()) vf = vf-&gt;sender();
101   return vf;
102 }
103 
104 
105 javaVFrame* vframe::java_sender() const {
106   vframe* f = sender();
107   while (f != NULL) {
108     if (f-&gt;is_java_frame()) return javaVFrame::cast(f);
109     f = f-&gt;sender();
110   }
111   return NULL;
112 }
113 
114 // ------------- javaVFrame --------------
115 
116 GrowableArray&lt;MonitorInfo*&gt;* javaVFrame::locked_monitors() {
117   assert(SafepointSynchronize::is_at_safepoint() || JavaThread::current() == thread(),
118          &quot;must be at safepoint or it&#39;s a java frame of the current thread&quot;);
119 
120   GrowableArray&lt;MonitorInfo*&gt;* mons = monitors();
121   GrowableArray&lt;MonitorInfo*&gt;* result = new GrowableArray&lt;MonitorInfo*&gt;(mons-&gt;length());
122   if (mons-&gt;is_empty()) return result;
123 
124   bool found_first_monitor = false;
125   ObjectMonitor *pending_monitor = thread()-&gt;current_pending_monitor();
126   ObjectMonitor *waiting_monitor = thread()-&gt;current_waiting_monitor();
127   oop pending_obj = (pending_monitor != NULL ? (oop) pending_monitor-&gt;object() : (oop) NULL);
128   oop waiting_obj = (waiting_monitor != NULL ? (oop) waiting_monitor-&gt;object() : (oop) NULL);
129 
130   for (int index = (mons-&gt;length()-1); index &gt;= 0; index--) {
131     MonitorInfo* monitor = mons-&gt;at(index);
132     if (monitor-&gt;eliminated() &amp;&amp; is_compiled_frame()) continue; // skip eliminated monitor
133     oop obj = monitor-&gt;owner();
134     if (obj == NULL) continue; // skip unowned monitor
135     //
136     // Skip the monitor that the thread is blocked to enter or waiting on
137     //
<a name="1" id="anc1"></a><span class="line-modified">138     if (!found_first_monitor &amp;&amp; (obj == pending_obj || obj == waiting_obj)) {</span>
139       continue;
140     }
141     found_first_monitor = true;
142     result-&gt;append(monitor);
143   }
144   return result;
145 }
146 
147 void javaVFrame::print_locked_object_class_name(outputStream* st, Handle obj, const char* lock_state) {
148   if (obj.not_null()) {
149     st-&gt;print(&quot;\t- %s &lt;&quot; INTPTR_FORMAT &quot;&gt; &quot;, lock_state, p2i(obj()));
150     if (obj-&gt;klass() == SystemDictionary::Class_klass()) {
151       st-&gt;print_cr(&quot;(a java.lang.Class for %s)&quot;, java_lang_Class::as_external_name(obj()));
152     } else {
153       Klass* k = obj-&gt;klass();
154       st-&gt;print_cr(&quot;(a %s)&quot;, k-&gt;external_name());
155     }
156   }
157 }
158 
159 void javaVFrame::print_lock_info_on(outputStream* st, int frame_count) {
160   Thread* THREAD = Thread::current();
161   ResourceMark rm(THREAD);
162 
163   // If this is the first frame and it is java.lang.Object.wait(...)
164   // then print out the receiver. Locals are not always available,
165   // e.g., compiled native frames have no scope so there are no locals.
166   if (frame_count == 0) {
167     if (method()-&gt;name() == vmSymbols::wait_name() &amp;&amp;
168         method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Object()) {
169       const char *wait_state = &quot;waiting on&quot;; // assume we are waiting
170       // If earlier in the output we reported java.lang.Thread.State ==
171       // &quot;WAITING (on object monitor)&quot; and now we report &quot;waiting on&quot;, then
172       // we are still waiting for notification or timeout. Otherwise if
173       // we earlier reported java.lang.Thread.State == &quot;BLOCKED (on object
174       // monitor)&quot;, then we are actually waiting to re-lock the monitor.
175       StackValueCollection* locs = locals();
176       if (!locs-&gt;is_empty()) {
177         StackValue* sv = locs-&gt;at(0);
178         if (sv-&gt;type() == T_OBJECT) {
179           Handle o = locs-&gt;at(0)-&gt;get_obj();
180           if (java_lang_Thread::get_thread_status(thread()-&gt;threadObj()) ==
181                                 java_lang_Thread::BLOCKED_ON_MONITOR_ENTER) {
182             wait_state = &quot;waiting to re-lock in wait()&quot;;
183           }
184           print_locked_object_class_name(st, o, wait_state);
185         }
186       } else {
187         st-&gt;print_cr(&quot;\t- %s &lt;no object reference available&gt;&quot;, wait_state);
188       }
189     } else if (thread()-&gt;current_park_blocker() != NULL) {
190       oop obj = thread()-&gt;current_park_blocker();
191       Klass* k = obj-&gt;klass();
192       st-&gt;print_cr(&quot;\t- %s &lt;&quot; INTPTR_FORMAT &quot;&gt; (a %s)&quot;, &quot;parking to wait for &quot;, p2i(obj), k-&gt;external_name());
193     }
194     else if (thread()-&gt;osthread()-&gt;get_state() == OBJECT_WAIT) {
195       // We are waiting on an Object monitor but Object.wait() isn&#39;t the
196       // top-frame, so we should be waiting on a Class initialization monitor.
197       InstanceKlass* k = thread()-&gt;class_to_be_initialized();
198       if (k != NULL) {
199         st-&gt;print_cr(&quot;\t- waiting on the Class initialization monitor for %s&quot;, k-&gt;external_name());
200       }
201     }
202   }
203 
204   // Print out all monitors that we have locked, or are trying to lock,
205   // including re-locking after being notified or timing out in a wait().
206   GrowableArray&lt;MonitorInfo*&gt;* mons = monitors();
207   if (!mons-&gt;is_empty()) {
208     bool found_first_monitor = false;
209     for (int index = (mons-&gt;length()-1); index &gt;= 0; index--) {
210       MonitorInfo* monitor = mons-&gt;at(index);
211       if (monitor-&gt;eliminated() &amp;&amp; is_compiled_frame()) { // Eliminated in compiled code
212         if (monitor-&gt;owner_is_scalar_replaced()) {
213           Klass* k = java_lang_Class::as_Klass(monitor-&gt;owner_klass());
<a name="2" id="anc2"></a>
214           st-&gt;print(&quot;\t- eliminated &lt;owner is scalar replaced&gt; (a %s)&quot;, k-&gt;external_name());
215         } else {
216           Handle obj(THREAD, monitor-&gt;owner());
217           if (obj() != NULL) {
218             print_locked_object_class_name(st, obj, &quot;eliminated&quot;);
219           }
220         }
221         continue;
222       }
223       if (monitor-&gt;owner() != NULL) {
224         // the monitor is associated with an object, i.e., it is locked
225 
<a name="3" id="anc3"></a>
226         const char *lock_state = &quot;locked&quot;; // assume we have the monitor locked
227         if (!found_first_monitor &amp;&amp; frame_count == 0) {
228           // If this is the first frame and we haven&#39;t found an owned
229           // monitor before, then we need to see if we have completed
230           // the lock or if we are blocked trying to acquire it. Only
231           // an inflated monitor that is first on the monitor list in
232           // the first frame can block us on a monitor enter.
<a name="4" id="anc4"></a><span class="line-modified">233           markWord mark = monitor-&gt;owner()-&gt;mark();</span>
<span class="line-modified">234           if (mark.has_monitor() &amp;&amp;</span>
235               ( // we have marked ourself as pending on this monitor
<a name="5" id="anc5"></a><span class="line-modified">236                 mark.monitor() == thread()-&gt;current_pending_monitor() ||</span>
237                 // we are not the owner of this monitor
<a name="6" id="anc6"></a><span class="line-modified">238                 !mark.monitor()-&gt;is_entered(thread())</span>
239               )) {
240             lock_state = &quot;waiting to lock&quot;;
<a name="7" id="anc7"></a>



241           }
242         }
243         print_locked_object_class_name(st, Handle(THREAD, monitor-&gt;owner()), lock_state);
244 
245         found_first_monitor = true;
246       }
247     }
248   }
249 }
250 
251 // ------------- interpretedVFrame --------------
252 
253 u_char* interpretedVFrame::bcp() const {
254   return fr().interpreter_frame_bcp();
255 }
256 
257 void interpretedVFrame::set_bcp(u_char* bcp) {
258   fr().interpreter_frame_set_bcp(bcp);
259 }
260 
261 intptr_t* interpretedVFrame::locals_addr_at(int offset) const {
262   assert(fr().is_interpreted_frame(), &quot;frame should be an interpreted frame&quot;);
263   return fr().interpreter_frame_local_at(offset);
264 }
265 
266 
267 GrowableArray&lt;MonitorInfo*&gt;* interpretedVFrame::monitors() const {
268   GrowableArray&lt;MonitorInfo*&gt;* result = new GrowableArray&lt;MonitorInfo*&gt;(5);
269   for (BasicObjectLock* current = (fr().previous_monitor_in_interpreter_frame(fr().interpreter_frame_monitor_begin()));
270        current &gt;= fr().interpreter_frame_monitor_end();
271        current = fr().previous_monitor_in_interpreter_frame(current)) {
272     result-&gt;push(new MonitorInfo(current-&gt;obj(), current-&gt;lock(), false, false));
273   }
274   return result;
275 }
276 
277 int interpretedVFrame::bci() const {
278   return method()-&gt;bci_from(bcp());
279 }
280 
281 Method* interpretedVFrame::method() const {
282   return fr().interpreter_frame_method();
283 }
284 
285 static StackValue* create_stack_value_from_oop_map(const InterpreterOopMap&amp; oop_mask,
286                                                    int index,
287                                                    const intptr_t* const addr) {
288 
289   assert(index &gt;= 0 &amp;&amp;
290          index &lt; oop_mask.number_of_entries(), &quot;invariant&quot;);
291 
292   // categorize using oop_mask
293   if (oop_mask.is_oop(index)) {
294     // reference (oop) &quot;r&quot;
295     Handle h(Thread::current(), addr != NULL ? (*(oop*)addr) : (oop)NULL);
296     return new StackValue(h);
297   }
298   // value (integer) &quot;v&quot;
299   return new StackValue(addr != NULL ? *addr : 0);
300 }
301 
302 static bool is_in_expression_stack(const frame&amp; fr, const intptr_t* const addr) {
303   assert(addr != NULL, &quot;invariant&quot;);
304 
305   // Ensure to be &#39;inside&#39; the expresion stack (i.e., addr &gt;= sp for Intel).
306   // In case of exceptions, the expression stack is invalid and the sp
307   // will be reset to express this condition.
308   if (frame::interpreter_frame_expression_stack_direction() &gt; 0) {
309     return addr &lt;= fr.interpreter_frame_tos_address();
310   }
311 
312   return addr &gt;= fr.interpreter_frame_tos_address();
313 }
314 
315 static void stack_locals(StackValueCollection* result,
316                          int length,
317                          const InterpreterOopMap&amp; oop_mask,
318                          const frame&amp; fr) {
319 
320   assert(result != NULL, &quot;invariant&quot;);
321 
322   for (int i = 0; i &lt; length; ++i) {
323     const intptr_t* const addr = fr.interpreter_frame_local_at(i);
324     assert(addr != NULL, &quot;invariant&quot;);
325     assert(addr &gt;= fr.sp(), &quot;must be inside the frame&quot;);
326 
327     StackValue* const sv = create_stack_value_from_oop_map(oop_mask, i, addr);
328     assert(sv != NULL, &quot;sanity check&quot;);
329 
330     result-&gt;add(sv);
331   }
332 }
333 
334 static void stack_expressions(StackValueCollection* result,
335                               int length,
336                               int max_locals,
337                               const InterpreterOopMap&amp; oop_mask,
338                               const frame&amp; fr) {
339 
340   assert(result != NULL, &quot;invariant&quot;);
341 
342   for (int i = 0; i &lt; length; ++i) {
343     const intptr_t* addr = fr.interpreter_frame_expression_stack_at(i);
344     assert(addr != NULL, &quot;invariant&quot;);
345     if (!is_in_expression_stack(fr, addr)) {
346       // Need to ensure no bogus escapes.
347       addr = NULL;
348     }
349 
350     StackValue* const sv = create_stack_value_from_oop_map(oop_mask,
351                                                            i + max_locals,
352                                                            addr);
353     assert(sv != NULL, &quot;sanity check&quot;);
354 
355     result-&gt;add(sv);
356   }
357 }
358 
359 StackValueCollection* interpretedVFrame::locals() const {
360   return stack_data(false);
361 }
362 
363 StackValueCollection* interpretedVFrame::expressions() const {
364   return stack_data(true);
365 }
366 
367 /*
368  * Worker routine for fetching references and/or values
369  * for a particular bci in the interpretedVFrame.
370  *
371  * Returns data for either &quot;locals&quot; or &quot;expressions&quot;,
372  * using bci relative oop_map (oop_mask) information.
373  *
374  * @param expressions  bool switch controlling what data to return
375                        (false == locals / true == expression)
376  *
377  */
378 StackValueCollection* interpretedVFrame::stack_data(bool expressions) const {
379 
380   InterpreterOopMap oop_mask;
381   method()-&gt;mask_for(bci(), &amp;oop_mask);
382   const int mask_len = oop_mask.number_of_entries();
383 
384   // If the method is native, method()-&gt;max_locals() is not telling the truth.
385   // For our purposes, max locals instead equals the size of parameters.
386   const int max_locals = method()-&gt;is_native() ?
387     method()-&gt;size_of_parameters() : method()-&gt;max_locals();
388 
389   assert(mask_len &gt;= max_locals, &quot;invariant&quot;);
390 
391   const int length = expressions ? mask_len - max_locals : max_locals;
392   assert(length &gt;= 0, &quot;invariant&quot;);
393 
394   StackValueCollection* const result = new StackValueCollection(length);
395 
396   if (0 == length) {
397     return result;
398   }
399 
400   if (expressions) {
401     stack_expressions(result, length, max_locals, oop_mask, fr());
402   } else {
403     stack_locals(result, length, oop_mask, fr());
404   }
405 
406   assert(length == result-&gt;size(), &quot;invariant&quot;);
407 
408   return result;
409 }
410 
411 void interpretedVFrame::set_locals(StackValueCollection* values) const {
412   if (values == NULL || values-&gt;size() == 0) return;
413 
414   // If the method is native, max_locals is not telling the truth.
415   // maxlocals then equals the size of parameters
416   const int max_locals = method()-&gt;is_native() ?
417     method()-&gt;size_of_parameters() : method()-&gt;max_locals();
418 
419   assert(max_locals == values-&gt;size(), &quot;Mismatch between actual stack format and supplied data&quot;);
420 
421   // handle locals
422   for (int i = 0; i &lt; max_locals; i++) {
423     // Find stack location
424     intptr_t *addr = locals_addr_at(i);
425 
426     // Depending on oop/int put it in the right package
427     const StackValue* const sv = values-&gt;at(i);
428     assert(sv != NULL, &quot;sanity check&quot;);
429     if (sv-&gt;type() == T_OBJECT) {
430       *(oop *) addr = (sv-&gt;get_obj())();
431     } else {                   // integer
432       *addr = sv-&gt;get_int();
433     }
434   }
435 }
436 
437 // ------------- cChunk --------------
438 
439 entryVFrame::entryVFrame(const frame* fr, const RegisterMap* reg_map, JavaThread* thread)
440 : externalVFrame(fr, reg_map, thread) {}
441 
442 #ifdef ASSERT
443 void vframeStreamCommon::found_bad_method_frame() const {
444   // 6379830 Cut point for an assertion that occasionally fires when
445   // we are using the performance analyzer.
446   // Disable this assert when testing the analyzer with fastdebug.
447   // -XX:SuppressErrorAt=vframe.cpp:XXX (XXX=following line number)
448   fatal(&quot;invalid bci or invalid scope desc&quot;);
449 }
450 #endif
451 
452 // top-frame will be skipped
453 vframeStream::vframeStream(JavaThread* thread, frame top_frame,
454   bool stop_at_java_call_stub) : vframeStreamCommon(thread) {
455   _stop_at_java_call_stub = stop_at_java_call_stub;
456 
457   // skip top frame, as it may not be at safepoint
458   _prev_frame = top_frame;
459   _frame  = top_frame.sender(&amp;_reg_map);
460   while (!fill_from_frame()) {
461     _prev_frame = _frame;
462     _frame = _frame.sender(&amp;_reg_map);
463   }
464 }
465 
466 
467 // Step back n frames, skip any pseudo frames in between.
468 // This function is used in Class.forName, Class.newInstance, Method.Invoke,
469 // AccessController.doPrivileged.
470 void vframeStreamCommon::security_get_caller_frame(int depth) {
471   assert(depth &gt;= 0, &quot;invalid depth: %d&quot;, depth);
472   for (int n = 0; !at_end(); security_next()) {
473     if (!method()-&gt;is_ignored_by_security_stack_walk()) {
474       if (n == depth) {
475         // We have reached the desired depth; return.
476         return;
477       }
478       n++;  // this is a non-skipped frame; count it against the depth
479     }
480   }
481   // NOTE: At this point there were not enough frames on the stack
482   // to walk to depth.  Callers of this method have to check for at_end.
483 }
484 
485 
486 void vframeStreamCommon::security_next() {
487   if (method()-&gt;is_prefixed_native()) {
488     skip_prefixed_method_and_wrappers();  // calls next()
489   } else {
490     next();
491   }
492 }
493 
494 
495 void vframeStreamCommon::skip_prefixed_method_and_wrappers() {
496   ResourceMark rm;
497   HandleMark hm;
498 
499   int    method_prefix_count = 0;
500   char** method_prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;method_prefix_count);
501   Klass* prefixed_klass = method()-&gt;method_holder();
502   const char* prefixed_name = method()-&gt;name()-&gt;as_C_string();
503   size_t prefixed_name_len = strlen(prefixed_name);
504   int prefix_index = method_prefix_count-1;
505 
506   while (!at_end()) {
507     next();
508     if (method()-&gt;method_holder() != prefixed_klass) {
509       break; // classes don&#39;t match, can&#39;t be a wrapper
510     }
511     const char* name = method()-&gt;name()-&gt;as_C_string();
512     size_t name_len = strlen(name);
513     size_t prefix_len = prefixed_name_len - name_len;
514     if (prefix_len &lt;= 0 || strcmp(name, prefixed_name + prefix_len) != 0) {
515       break; // prefixed name isn&#39;t prefixed version of method name, can&#39;t be a wrapper
516     }
517     for (; prefix_index &gt;= 0; --prefix_index) {
518       const char* possible_prefix = method_prefixes[prefix_index];
519       size_t possible_prefix_len = strlen(possible_prefix);
520       if (possible_prefix_len == prefix_len &amp;&amp;
521           strncmp(possible_prefix, prefixed_name, prefix_len) == 0) {
522         break; // matching prefix found
523       }
524     }
525     if (prefix_index &lt; 0) {
526       break; // didn&#39;t find the prefix, can&#39;t be a wrapper
527     }
528     prefixed_name = name;
529     prefixed_name_len = name_len;
530   }
531 }
532 
533 
534 void vframeStreamCommon::skip_reflection_related_frames() {
535   while (!at_end() &amp;&amp;
536           (method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::reflect_MethodAccessorImpl_klass()) ||
537            method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::reflect_ConstructorAccessorImpl_klass()))) {
538     next();
539   }
540 }
541 
542 javaVFrame* vframeStreamCommon::asJavaVFrame() {
543   javaVFrame* result = NULL;
544   if (_mode == compiled_mode) {
545     guarantee(_frame.is_compiled_frame(), &quot;expected compiled Java frame&quot;);
546 
547     // lazy update to register map
548     bool update_map = true;
549     RegisterMap map(_thread, update_map);
550     frame f = _prev_frame.sender(&amp;map);
551 
552     guarantee(f.is_compiled_frame(), &quot;expected compiled Java frame&quot;);
553 
554     compiledVFrame* cvf = compiledVFrame::cast(vframe::new_vframe(&amp;f, &amp;map, _thread));
555 
556     guarantee(cvf-&gt;cb() == cb(), &quot;wrong code blob&quot;);
557 
558     // get the same scope as this stream
559     cvf = cvf-&gt;at_scope(_decode_offset, _vframe_id);
560 
561     guarantee(cvf-&gt;scope()-&gt;decode_offset() == _decode_offset, &quot;wrong scope&quot;);
562     guarantee(cvf-&gt;scope()-&gt;sender_decode_offset() == _sender_decode_offset, &quot;wrong scope&quot;);
563     guarantee(cvf-&gt;vframe_id() == _vframe_id, &quot;wrong vframe&quot;);
564 
565     result = cvf;
566   } else {
567     result = javaVFrame::cast(vframe::new_vframe(&amp;_frame, &amp;_reg_map, _thread));
568   }
569   guarantee(result-&gt;method() == method(), &quot;wrong method&quot;);
570   return result;
571 }
572 
573 
574 #ifndef PRODUCT
575 void vframe::print() {
576   if (WizardMode) _fr.print_value_on(tty,NULL);
577 }
578 
579 
580 void vframe::print_value() const {
581   ((vframe*)this)-&gt;print();
582 }
583 
584 
585 void entryVFrame::print_value() const {
586   ((entryVFrame*)this)-&gt;print();
587 }
588 
589 void entryVFrame::print() {
590   vframe::print();
591   tty-&gt;print_cr(&quot;C Chunk inbetween Java&quot;);
592   tty-&gt;print_cr(&quot;C     link &quot; INTPTR_FORMAT, p2i(_fr.link()));
593 }
594 
595 
596 // ------------- javaVFrame --------------
597 
598 static void print_stack_values(const char* title, StackValueCollection* values) {
599   if (values-&gt;is_empty()) return;
600   tty-&gt;print_cr(&quot;\t%s:&quot;, title);
601   values-&gt;print();
602 }
603 
604 
605 void javaVFrame::print() {
606   ResourceMark rm;
607   vframe::print();
608   tty-&gt;print(&quot;\t&quot;);
609   method()-&gt;print_value();
610   tty-&gt;cr();
611   tty-&gt;print_cr(&quot;\tbci:    %d&quot;, bci());
612 
613   print_stack_values(&quot;locals&quot;,      locals());
614   print_stack_values(&quot;expressions&quot;, expressions());
615 
616   GrowableArray&lt;MonitorInfo*&gt;* list = monitors();
617   if (list-&gt;is_empty()) return;
618   tty-&gt;print_cr(&quot;\tmonitor list:&quot;);
619   for (int index = (list-&gt;length()-1); index &gt;= 0; index--) {
620     MonitorInfo* monitor = list-&gt;at(index);
621     tty-&gt;print(&quot;\t  obj\t&quot;);
622     if (monitor-&gt;owner_is_scalar_replaced()) {
623       Klass* k = java_lang_Class::as_Klass(monitor-&gt;owner_klass());
624       tty-&gt;print(&quot;( is scalar replaced %s)&quot;, k-&gt;external_name());
625     } else if (monitor-&gt;owner() == NULL) {
626       tty-&gt;print(&quot;( null )&quot;);
627     } else {
628       monitor-&gt;owner()-&gt;print_value();
629       tty-&gt;print(&quot;(owner=&quot; INTPTR_FORMAT &quot;)&quot;, p2i(monitor-&gt;owner()));
630     }
631     if (monitor-&gt;eliminated()) {
632       if(is_compiled_frame()) {
633         tty-&gt;print(&quot; ( lock is eliminated in compiled frame )&quot;);
634       } else {
635         tty-&gt;print(&quot; ( lock is eliminated, frame not compiled )&quot;);
636       }
637     }
638     tty-&gt;cr();
639     tty-&gt;print(&quot;\t  &quot;);
640     monitor-&gt;lock()-&gt;print_on(tty);
641     tty-&gt;cr();
642   }
643 }
644 
645 
646 void javaVFrame::print_value() const {
647   Method*    m = method();
648   InstanceKlass*     k = m-&gt;method_holder();
649   tty-&gt;print_cr(&quot;frame( sp=&quot; INTPTR_FORMAT &quot;, unextended_sp=&quot; INTPTR_FORMAT &quot;, fp=&quot; INTPTR_FORMAT &quot;, pc=&quot; INTPTR_FORMAT &quot;)&quot;,
650                 p2i(_fr.sp()),  p2i(_fr.unextended_sp()), p2i(_fr.fp()), p2i(_fr.pc()));
651   tty-&gt;print(&quot;%s.%s&quot;, k-&gt;internal_name(), m-&gt;name()-&gt;as_C_string());
652 
653   if (!m-&gt;is_native()) {
654     Symbol*  source_name = k-&gt;source_file_name();
655     int        line_number = m-&gt;line_number_from_bci(bci());
656     if (source_name != NULL &amp;&amp; (line_number != -1)) {
657       tty-&gt;print(&quot;(%s:%d)&quot;, source_name-&gt;as_C_string(), line_number);
658     }
659   } else {
660     tty-&gt;print(&quot;(Native Method)&quot;);
661   }
662   // Check frame size and print warning if it looks suspiciously large
663   if (fr().sp() != NULL) {
664     RegisterMap map = *register_map();
665     uint size = fr().frame_size(&amp;map);
666 #ifdef _LP64
667     if (size &gt; 8*K) warning(&quot;SUSPICIOUSLY LARGE FRAME (%d)&quot;, size);
668 #else
669     if (size &gt; 4*K) warning(&quot;SUSPICIOUSLY LARGE FRAME (%d)&quot;, size);
670 #endif
671   }
672 }
673 
674 
675 bool javaVFrame::structural_compare(javaVFrame* other) {
676   // Check static part
677   if (method() != other-&gt;method()) return false;
678   if (bci()    != other-&gt;bci())    return false;
679 
680   // Check locals
681   StackValueCollection *locs = locals();
682   StackValueCollection *other_locs = other-&gt;locals();
683   assert(locs-&gt;size() == other_locs-&gt;size(), &quot;sanity check&quot;);
684   int i;
685   for(i = 0; i &lt; locs-&gt;size(); i++) {
686     // it might happen the compiler reports a conflict and
687     // the interpreter reports a bogus int.
688     if (       is_compiled_frame() &amp;&amp;       locs-&gt;at(i)-&gt;type() == T_CONFLICT) continue;
689     if (other-&gt;is_compiled_frame() &amp;&amp; other_locs-&gt;at(i)-&gt;type() == T_CONFLICT) continue;
690 
691     if (!locs-&gt;at(i)-&gt;equal(other_locs-&gt;at(i)))
692       return false;
693   }
694 
695   // Check expressions
696   StackValueCollection* exprs = expressions();
697   StackValueCollection* other_exprs = other-&gt;expressions();
698   assert(exprs-&gt;size() == other_exprs-&gt;size(), &quot;sanity check&quot;);
699   for(i = 0; i &lt; exprs-&gt;size(); i++) {
700     if (!exprs-&gt;at(i)-&gt;equal(other_exprs-&gt;at(i)))
701       return false;
702   }
703 
704   return true;
705 }
706 
707 
708 void javaVFrame::print_activation(int index) const {
709   // frame number and method
710   tty-&gt;print(&quot;%2d - &quot;, index);
711   ((vframe*)this)-&gt;print_value();
712   tty-&gt;cr();
713 
714   if (WizardMode) {
715     ((vframe*)this)-&gt;print();
716     tty-&gt;cr();
717   }
718 }
719 
720 
721 void javaVFrame::verify() const {
722 }
723 
724 
725 void interpretedVFrame::verify() const {
726 }
727 
728 
729 // ------------- externalVFrame --------------
730 
731 void externalVFrame::print() {
732   _fr.print_value_on(tty,NULL);
733 }
734 
735 
736 void externalVFrame::print_value() const {
737   ((vframe*)this)-&gt;print();
738 }
739 #endif // PRODUCT
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
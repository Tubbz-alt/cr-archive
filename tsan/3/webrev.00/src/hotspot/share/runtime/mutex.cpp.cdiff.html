<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/mutex.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memprofiler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutex.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/mutex.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,278 ***</span>
  #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  
<span class="line-modified">! void Monitor::lock(Thread * self) {</span>
<span class="line-modified">!   // Ensure that the Monitor requires/allows safepoint checks.</span>
<span class="line-modified">!   assert(_safepoint_check_required != Monitor::_safepoint_check_never,</span>
<span class="line-modified">!          &quot;This lock should never have a safepoint check: %s&quot;, name());</span>
  
<span class="line-modified">! #ifdef CHECK_UNHANDLED_OOPS</span>
<span class="line-modified">!   // Clear unhandled oops in JavaThreads so we get a crash right away.</span>
<span class="line-modified">!   if (self-&gt;is_Java_thread()) {</span>
<span class="line-modified">!     self-&gt;clear_unhandled_oops();</span>
    }
<span class="line-modified">! #endif // CHECK_UNHANDLED_OOPS</span>
  
<span class="line-modified">!   DEBUG_ONLY(check_prelock_state(self, StrictSafepointChecks));</span>
<span class="line-modified">!   assert(_owner != self, &quot;invariant&quot;);</span>
  
<span class="line-modified">!   Monitor* in_flight_monitor = NULL;</span>
    DEBUG_ONLY(int retry_cnt = 0;)
<span class="line-modified">!   while (!_lock.try_lock()) {</span>
<span class="line-modified">!     // The lock is contended</span>
<span class="line-modified">! </span>
<span class="line-removed">-   #ifdef ASSERT</span>
<span class="line-removed">-     check_block_state(self);</span>
      if (retry_cnt++ &gt; 3) {
<span class="line-modified">!       log_trace(vmmonitor)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; on %d attempt trying to acquire vmmonitor %s&quot;, p2i(self), retry_cnt, _name);</span>
      }
<span class="line-modified">!   #endif // ASSERT</span>
  
<span class="line-modified">!     if (self-&gt;is_Java_thread()) {</span>
        assert(rank() &gt; Mutex::special, &quot;Potential deadlock with special or lesser rank mutex&quot;);
<span class="line-modified">!       { ThreadBlockInVMWithDeadlockCheck tbivmdc((JavaThread *) self, &amp;in_flight_monitor);</span>
<span class="line-modified">!         in_flight_monitor = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
          _lock.lock();
        }
<span class="line-modified">!       if (in_flight_monitor != NULL) {</span>
          // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck
          break;
        }
      } else {
        _lock.lock();
        break;
      }
    }
  
    assert_owner(NULL);
    set_owner(self);
  }
  
<span class="line-modified">! void Monitor::lock() {</span>
<span class="line-modified">!   this-&gt;lock(Thread::current());</span>
  }
  
  // Lock without safepoint check - a degenerate variant of lock() for use by
  // JavaThreads when it is known to be safe to not check for a safepoint when
  // acquiring this lock. If the thread blocks acquiring the lock it is not
  // safepoint-safe and so will prevent a safepoint from being reached. If used
  // in the wrong way this can lead to a deadlock with the safepoint code.
  
<span class="line-modified">! void Monitor::lock_without_safepoint_check(Thread * self) {</span>
<span class="line-modified">!   // Ensure that the Monitor does not require safepoint checks.</span>
<span class="line-removed">-   assert(_safepoint_check_required != Monitor::_safepoint_check_always,</span>
<span class="line-removed">-          &quot;This lock should always have a safepoint check: %s&quot;, name());</span>
    assert(_owner != self, &quot;invariant&quot;);
    _lock.lock();
    assert_owner(NULL);
    set_owner(self);
  }
  
<span class="line-modified">! void Monitor::lock_without_safepoint_check() {</span>
    lock_without_safepoint_check(Thread::current());
  }
  
  
  // Returns true if thread succeeds in grabbing the lock, otherwise false.
  
<span class="line-modified">! bool Monitor::try_lock() {</span>
    Thread * const self = Thread::current();
<span class="line-modified">!   DEBUG_ONLY(check_prelock_state(self, false);)</span>
<span class="line-modified">! </span>
    if (_lock.try_lock()) {
      assert_owner(NULL);
      set_owner(self);
      return true;
    }
    return false;
  }
  
<span class="line-modified">! void Monitor::release_for_safepoint() {</span>
    assert_owner(NULL);
    _lock.unlock();
  }
  
<span class="line-modified">! void Monitor::unlock() {</span>
<span class="line-modified">!   assert_owner(Thread::current());</span>
    set_owner(NULL);
    _lock.unlock();
  }
  
  void Monitor::notify() {
<span class="line-modified">!   assert_owner(Thread::current());</span>
    _lock.notify();
  }
  
  void Monitor::notify_all() {
<span class="line-modified">!   assert_owner(Thread::current());</span>
    _lock.notify_all();
  }
  
<span class="line-modified">! bool Monitor::wait(bool no_safepoint_check, long timeout,</span>
<span class="line-modified">!                    bool as_suspend_equivalent) {</span>
<span class="line-modified">!   // Make sure safepoint checking is used properly.</span>
<span class="line-removed">-   assert(!(_safepoint_check_required == Monitor::_safepoint_check_never &amp;&amp; no_safepoint_check == false),</span>
<span class="line-removed">-          &quot;This lock should never have a safepoint check: %s&quot;, name());</span>
<span class="line-removed">-   assert(!(_safepoint_check_required == Monitor::_safepoint_check_always &amp;&amp; no_safepoint_check == true),</span>
<span class="line-removed">-          &quot;This lock should always have a safepoint check: %s&quot;, name());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // timeout is in milliseconds - with zero meaning never timeout</span>
<span class="line-removed">-   assert(timeout &gt;= 0, &quot;negative timeout&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Thread * const self = Thread::current();</span>
<span class="line-removed">-   assert_owner(self);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // as_suspend_equivalent logically implies !no_safepoint_check</span>
<span class="line-removed">-   guarantee(!as_suspend_equivalent || !no_safepoint_check, &quot;invariant&quot;);</span>
<span class="line-removed">-   // !no_safepoint_check logically implies java_thread</span>
<span class="line-removed">-   guarantee(no_safepoint_check || self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   #ifdef ASSERT</span>
<span class="line-removed">-   Monitor * least = get_least_ranked_lock_besides_this(self-&gt;owned_locks());</span>
    assert(least != this, &quot;Specification of get_least_... call above&quot;);
    if (least != NULL &amp;&amp; least-&gt;rank() &lt;= special) {
      ::tty-&gt;print(&quot;Attempting to wait on monitor %s/%d while holding&quot;
                 &quot; lock %s/%d -- possible deadlock&quot;,
                 name(), rank(), least-&gt;name(), least-&gt;rank());
      assert(false, &quot;Shouldn&#39;t block(wait) while holding a lock of rank special&quot;);
    }
<span class="line-modified">!   #endif // ASSERT</span>
  
<span class="line-removed">-   int wait_status;</span>
    // conceptually set the owner to NULL in anticipation of
    // abdicating the lock in wait
    set_owner(NULL);
<span class="line-modified">!   if (no_safepoint_check) {</span>
<span class="line-modified">!     wait_status = _lock.wait(timeout);</span>
<span class="line-removed">-     set_owner(self);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">-     JavaThread *jt = (JavaThread *)self;</span>
<span class="line-removed">-     Monitor* in_flight_monitor = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       ThreadBlockInVMWithDeadlockCheck tbivmdc(jt, &amp;in_flight_monitor);</span>
<span class="line-removed">-       OSThreadWaitState osts(self-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-removed">-       if (as_suspend_equivalent) {</span>
<span class="line-removed">-         jt-&gt;set_suspend_equivalent();</span>
<span class="line-removed">-         // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-removed">-         // java_suspend_self()</span>
<span class="line-removed">-       }</span>
  
<span class="line-modified">!       wait_status = _lock.wait(timeout);</span>
<span class="line-modified">!       in_flight_monitor = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">! </span>
<span class="line-modified">!       // were we externally suspended while we were waiting?</span>
<span class="line-modified">!       if (as_suspend_equivalent &amp;&amp; jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">!         // Our event wait has finished and we own the lock, but</span>
<span class="line-modified">!         // while we were waiting another thread suspended us. We don&#39;t</span>
<span class="line-modified">!         // want to hold the lock while suspended because that</span>
<span class="line-modified">!         // would surprise the thread that suspended us.</span>
<span class="line-modified">!         _lock.unlock();</span>
<span class="line-modified">!         jt-&gt;java_suspend_self();</span>
<span class="line-modified">!         _lock.lock();</span>
<span class="line-modified">!       }</span>
      }
  
<span class="line-modified">!     if (in_flight_monitor != NULL) {</span>
<span class="line-modified">!       // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">!       assert_owner(NULL);</span>
<span class="line-modified">!       // Conceptually reestablish ownership of the lock.</span>
<span class="line-modified">!       set_owner(self);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       lock(self);</span>
      }
    }
<span class="line-removed">-   return wait_status != 0;          // return true IFF timeout</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  
<span class="line-modified">! // Temporary JVM_RawMonitor* support.</span>
<span class="line-modified">! // Yet another degenerate version of Monitor::lock() or lock_without_safepoint_check()</span>
<span class="line-modified">! // jvm_raw_lock() and _unlock() can be called by non-Java threads via JVM_RawMonitorEnter.</span>
<span class="line-modified">! // There&#39;s no expectation that JVM_RawMonitors will interoperate properly with the native</span>
<span class="line-modified">! // Mutex-Monitor constructs.  We happen to implement JVM_RawMonitors in terms of</span>
<span class="line-modified">! // native Mutex-Monitors simply as a matter of convenience.</span>
  
<span class="line-modified">! void Monitor::jvm_raw_lock() {</span>
<span class="line-removed">-   _lock.lock();</span>
<span class="line-removed">-   assert_owner(NULL);</span>
  }
  
<span class="line-modified">! void Monitor::jvm_raw_unlock() {</span>
    assert_owner(NULL);
<span class="line-removed">-   _lock.unlock();</span>
  }
  
<span class="line-modified">! Monitor::~Monitor() {</span>
<span class="line-modified">!   assert_owner(NULL);</span>
  }
  
<span class="line-modified">! void Monitor::ClearMonitor(Monitor * m, const char *name) {</span>
<span class="line-modified">!   m-&gt;_owner             = NULL;</span>
    if (name == NULL) {
<span class="line-modified">!     strcpy(m-&gt;_name, &quot;UNKNOWN&quot;);</span>
    } else {
<span class="line-modified">!     strncpy(m-&gt;_name, name, MONITOR_NAME_LEN - 1);</span>
<span class="line-modified">!     m-&gt;_name[MONITOR_NAME_LEN - 1] = &#39;\0&#39;;</span>
    }
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Monitor::Monitor() {</span>
<span class="line-removed">-   assert(os::mutex_init_done(), &quot;Too early!&quot;);</span>
<span class="line-removed">-   ClearMonitor(this);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Monitor::Monitor(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-removed">-                  SafepointCheckRequired safepoint_check_required) {</span>
<span class="line-removed">-   assert(os::mutex_init_done(), &quot;Too early!&quot;);</span>
<span class="line-removed">-   ClearMonitor(this, name);</span>
  #ifdef ASSERT
    _allow_vm_block  = allow_vm_block;
    _rank            = Rank;
<span class="line-modified">!   NOT_PRODUCT(_safepoint_check_required = safepoint_check_required;)</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! Mutex::Mutex(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-modified">!              SafepointCheckRequired safepoint_check_required) {</span>
<span class="line-modified">!   ClearMonitor((Monitor *) this, name);</span>
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-modified">!   _allow_vm_block   = allow_vm_block;</span>
<span class="line-removed">-   _rank             = Rank;</span>
<span class="line-removed">-   NOT_PRODUCT(_safepoint_check_required = safepoint_check_required;)</span>
  #endif
  }
  
<span class="line-modified">! bool Monitor::owned_by_self() const {</span>
    return _owner == Thread::current();
  }
  
<span class="line-modified">! void Monitor::print_on_error(outputStream* st) const {</span>
    st-&gt;print(&quot;[&quot; PTR_FORMAT, p2i(this));
    st-&gt;print(&quot;] %s&quot;, _name);
    st-&gt;print(&quot; - owner thread: &quot; PTR_FORMAT, p2i(_owner));
  }
  
  // ----------------------------------------------------------------------------------
  // Non-product code
  
  #ifndef PRODUCT
<span class="line-modified">! void Monitor::print_on(outputStream* st) const {</span>
<span class="line-modified">!   st-&gt;print_cr(&quot;Mutex: [&quot; PTR_FORMAT &quot;] %s - owner: &quot; PTR_FORMAT,</span>
<span class="line-modified">!                p2i(this), _name, p2i(_owner));</span>
  }
  #endif
  
<span class="line-removed">- #ifndef PRODUCT</span>
  #ifdef ASSERT
<span class="line-modified">! </span>
<span class="line-removed">- void Monitor::assert_owner(Thread * expected) {</span>
    const char* msg = &quot;invalid owner&quot;;
    if (expected == NULL) {
      msg = &quot;should be un-owned&quot;;
    }
    else if (expected == Thread::current()) {
<span class="line-new-header">--- 30,311 ---</span>
  #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+ void Mutex::check_block_state(Thread* thread) {</span>
<span class="line-added">+   if (!_allow_vm_block &amp;&amp; thread-&gt;is_VM_thread()) {</span>
<span class="line-added">+     // JavaThreads are checked to make sure that they do not hold _allow_vm_block locks during operations</span>
<span class="line-added">+     // that could safepoint.  Make sure the vm thread never uses locks with _allow_vm_block == false.</span>
<span class="line-added">+     fatal(&quot;VM thread could block on lock that may be held by a JavaThread during safepoint: %s&quot;, name());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(!os::ThreadCrashProtection::is_crash_protected(thread),</span>
<span class="line-added">+          &quot;locking not allowed when crash protection is set&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Mutex::check_safepoint_state(Thread* thread) {</span>
<span class="line-added">+   check_block_state(thread);</span>
  
<span class="line-modified">!   // If the JavaThread checks for safepoint, verify that the lock wasn&#39;t created with safepoint_check_never.</span>
<span class="line-modified">!   if (thread-&gt;is_active_Java_thread()) {</span>
<span class="line-modified">!     assert(_safepoint_check_required != _safepoint_check_never,</span>
<span class="line-modified">!            &quot;This lock should %s have a safepoint check for Java threads: %s&quot;,</span>
<span class="line-added">+            _safepoint_check_required ? &quot;always&quot; : &quot;never&quot;, name());</span>
  
<span class="line-modified">!     // Also check NoSafepointVerifier, and thread state is _thread_in_vm</span>
<span class="line-modified">!     thread-&gt;check_for_valid_safepoint_state();</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     // If initialized with safepoint_check_never, a NonJavaThread should never ask to safepoint check either.</span>
<span class="line-added">+     assert(_safepoint_check_required != _safepoint_check_never,</span>
<span class="line-added">+            &quot;NonJavaThread should not check for safepoint&quot;);</span>
    }
<span class="line-modified">! }</span>
  
<span class="line-modified">! void Mutex::check_no_safepoint_state(Thread* thread) {</span>
<span class="line-modified">!   check_block_state(thread);</span>
<span class="line-added">+   assert(!thread-&gt;is_active_Java_thread() || _safepoint_check_required != _safepoint_check_always,</span>
<span class="line-added">+          &quot;This lock should %s have a safepoint check for Java threads: %s&quot;,</span>
<span class="line-added">+          _safepoint_check_required ? &quot;always&quot; : &quot;never&quot;, name());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // ASSERT</span>
  
<span class="line-modified">! void Mutex::lock_contended(Thread* self) {</span>
<span class="line-added">+   Mutex *in_flight_mutex = NULL;</span>
    DEBUG_ONLY(int retry_cnt = 0;)
<span class="line-modified">!   bool is_active_Java_thread = self-&gt;is_active_Java_thread();</span>
<span class="line-modified">!   do {</span>
<span class="line-modified">!     #ifdef ASSERT</span>
      if (retry_cnt++ &gt; 3) {
<span class="line-modified">!       log_trace(vmmutex)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; on %d attempt trying to acquire vmmutex %s&quot;, p2i(self), retry_cnt, _name);</span>
      }
<span class="line-modified">!     #endif // ASSERT</span>
  
<span class="line-modified">!     // Is it a JavaThread participating in the safepoint protocol.</span>
<span class="line-added">+     if (is_active_Java_thread) {</span>
        assert(rank() &gt; Mutex::special, &quot;Potential deadlock with special or lesser rank mutex&quot;);
<span class="line-modified">!       { ThreadBlockInVMWithDeadlockCheck tbivmdc((JavaThread *) self, &amp;in_flight_mutex);</span>
<span class="line-modified">!         in_flight_mutex = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
          _lock.lock();
        }
<span class="line-modified">!       if (in_flight_mutex != NULL) {</span>
          // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck
          break;
        }
      } else {
        _lock.lock();
        break;
      }
<span class="line-added">+   } while (!_lock.try_lock());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Mutex::lock(Thread* self) {</span>
<span class="line-added">+   check_safepoint_state(self);</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(_owner != self, &quot;invariant&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!_lock.try_lock()) {</span>
<span class="line-added">+     // The lock is contended, use contended slow-path function to lock</span>
<span class="line-added">+     lock_contended(self);</span>
    }
  
    assert_owner(NULL);
    set_owner(self);
  }
  
<span class="line-modified">! void Mutex::lock() {</span>
<span class="line-modified">!   lock(Thread::current());</span>
  }
  
  // Lock without safepoint check - a degenerate variant of lock() for use by
  // JavaThreads when it is known to be safe to not check for a safepoint when
  // acquiring this lock. If the thread blocks acquiring the lock it is not
  // safepoint-safe and so will prevent a safepoint from being reached. If used
  // in the wrong way this can lead to a deadlock with the safepoint code.
  
<span class="line-modified">! void Mutex::lock_without_safepoint_check(Thread * self) {</span>
<span class="line-modified">!   check_no_safepoint_state(self);</span>
    assert(_owner != self, &quot;invariant&quot;);
    _lock.lock();
    assert_owner(NULL);
    set_owner(self);
  }
  
<span class="line-modified">! void Mutex::lock_without_safepoint_check() {</span>
    lock_without_safepoint_check(Thread::current());
  }
  
  
  // Returns true if thread succeeds in grabbing the lock, otherwise false.
  
<span class="line-modified">! bool Mutex::try_lock() {</span>
    Thread * const self = Thread::current();
<span class="line-modified">!   // Some safepoint_check_always locks use try_lock, so cannot check</span>
<span class="line-modified">!   // safepoint state, but can check blocking state.</span>
<span class="line-added">+   check_block_state(self);</span>
    if (_lock.try_lock()) {
      assert_owner(NULL);
      set_owner(self);
      return true;
    }
    return false;
  }
  
<span class="line-modified">! void Mutex::release_for_safepoint() {</span>
    assert_owner(NULL);
    _lock.unlock();
  }
  
<span class="line-modified">! void Mutex::unlock() {</span>
<span class="line-modified">!   DEBUG_ONLY(assert_owner(Thread::current()));</span>
    set_owner(NULL);
    _lock.unlock();
  }
  
  void Monitor::notify() {
<span class="line-modified">!   DEBUG_ONLY(assert_owner(Thread::current()));</span>
    _lock.notify();
  }
  
  void Monitor::notify_all() {
<span class="line-modified">!   DEBUG_ONLY(assert_owner(Thread::current()));</span>
    _lock.notify_all();
  }
  
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-modified">! void Monitor::assert_wait_lock_state(Thread* self) {</span>
<span class="line-modified">!   Mutex* least = get_least_ranked_lock_besides_this(self-&gt;owned_locks());</span>
    assert(least != this, &quot;Specification of get_least_... call above&quot;);
    if (least != NULL &amp;&amp; least-&gt;rank() &lt;= special) {
      ::tty-&gt;print(&quot;Attempting to wait on monitor %s/%d while holding&quot;
                 &quot; lock %s/%d -- possible deadlock&quot;,
                 name(), rank(), least-&gt;name(), least-&gt;rank());
      assert(false, &quot;Shouldn&#39;t block(wait) while holding a lock of rank special&quot;);
    }
<span class="line-modified">! }</span>
<span class="line-added">+ #endif // ASSERT</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Monitor::wait_without_safepoint_check(long timeout) {</span>
<span class="line-added">+   Thread* const self = Thread::current();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // timeout is in milliseconds - with zero meaning never timeout</span>
<span class="line-added">+   assert(timeout &gt;= 0, &quot;negative timeout&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert_owner(self);</span>
<span class="line-added">+   assert_wait_lock_state(self);</span>
  
    // conceptually set the owner to NULL in anticipation of
    // abdicating the lock in wait
    set_owner(NULL);
<span class="line-modified">!   // Check safepoint state after resetting owner and possible NSV.</span>
<span class="line-modified">!   check_no_safepoint_state(self);</span>
  
<span class="line-modified">!   int wait_status = _lock.wait(timeout);</span>
<span class="line-modified">!   set_owner(self);</span>
<span class="line-modified">!   return wait_status != 0;          // return true IFF timeout</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! bool Monitor::wait(long timeout, bool as_suspend_equivalent) {</span>
<span class="line-modified">!   Thread* const self = Thread::current();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // timeout is in milliseconds - with zero meaning never timeout</span>
<span class="line-modified">!   assert(timeout &gt;= 0, &quot;negative timeout&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   assert_owner(self);</span>
<span class="line-modified">! </span>
<span class="line-added">+   // Safepoint checking logically implies an active JavaThread.</span>
<span class="line-added">+   guarantee(self-&gt;is_active_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-added">+   assert_wait_lock_state(self);</span>
<span class="line-added">+ </span>
<span class="line-added">+   int wait_status;</span>
<span class="line-added">+   // conceptually set the owner to NULL in anticipation of</span>
<span class="line-added">+   // abdicating the lock in wait</span>
<span class="line-added">+   set_owner(NULL);</span>
<span class="line-added">+   // Check safepoint state after resetting owner and possible NSV.</span>
<span class="line-added">+   check_safepoint_state(self);</span>
<span class="line-added">+   JavaThread *jt = (JavaThread *)self;</span>
<span class="line-added">+   Mutex* in_flight_mutex = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+   {</span>
<span class="line-added">+     ThreadBlockInVMWithDeadlockCheck tbivmdc(jt, &amp;in_flight_mutex);</span>
<span class="line-added">+     OSThreadWaitState osts(self-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-added">+     if (as_suspend_equivalent) {</span>
<span class="line-added">+       jt-&gt;set_suspend_equivalent();</span>
<span class="line-added">+       // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-added">+       // java_suspend_self()</span>
      }
  
<span class="line-modified">!     wait_status = _lock.wait(timeout);</span>
<span class="line-modified">!     in_flight_mutex = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // were we externally suspended while we were waiting?</span>
<span class="line-modified">!     if (as_suspend_equivalent &amp;&amp; jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">!       // Our event wait has finished and we own the lock, but</span>
<span class="line-modified">!       // while we were waiting another thread suspended us. We don&#39;t</span>
<span class="line-added">+       // want to hold the lock while suspended because that</span>
<span class="line-added">+       // would surprise the thread that suspended us.</span>
<span class="line-added">+       _lock.unlock();</span>
<span class="line-added">+       jt-&gt;java_suspend_self();</span>
<span class="line-added">+       _lock.lock();</span>
      }
    }
  
<span class="line-modified">!   if (in_flight_mutex != NULL) {</span>
<span class="line-modified">!     // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">!     assert_owner(NULL);</span>
<span class="line-modified">!     // Conceptually reestablish ownership of the lock.</span>
<span class="line-modified">!     set_owner(self);</span>
<span class="line-modified">!   } else {</span>
<span class="line-added">+     lock(self);</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   return wait_status != 0;          // return true IFF timeout</span>
  }
  
<span class="line-modified">! Mutex::~Mutex() {</span>
    assert_owner(NULL);
  }
  
<span class="line-modified">! // Only Threads_lock, Heap_lock and SR_lock may be safepoint_check_sometimes.</span>
<span class="line-modified">! bool is_sometimes_ok(const char* name) {</span>
<span class="line-added">+   return (strcmp(name, &quot;Threads_lock&quot;) == 0 || strcmp(name, &quot;Heap_lock&quot;) == 0 || strcmp(name, &quot;SR_lock&quot;) == 0);</span>
  }
  
<span class="line-modified">! Mutex::Mutex(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-modified">!              SafepointCheckRequired safepoint_check_required) : _owner(NULL) {</span>
<span class="line-added">+   assert(os::mutex_init_done(), &quot;Too early!&quot;);</span>
    if (name == NULL) {
<span class="line-modified">!     strcpy(_name, &quot;UNKNOWN&quot;);</span>
    } else {
<span class="line-modified">!     strncpy(_name, name, MUTEX_NAME_LEN - 1);</span>
<span class="line-modified">!     _name[MUTEX_NAME_LEN - 1] = &#39;\0&#39;;</span>
    }
  #ifdef ASSERT
    _allow_vm_block  = allow_vm_block;
    _rank            = Rank;
<span class="line-modified">!   _safepoint_check_required = safepoint_check_required;</span>
  
<span class="line-modified">!   assert(_safepoint_check_required != _safepoint_check_sometimes || is_sometimes_ok(name),</span>
<span class="line-modified">!          &quot;Lock has _safepoint_check_sometimes %s&quot;, name);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   assert(_rank &gt; special || _safepoint_check_required == _safepoint_check_never,</span>
<span class="line-modified">!          &quot;Special locks or below should never safepoint&quot;);</span>
  #endif
  }
  
<span class="line-modified">! Monitor::Monitor(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-added">+              SafepointCheckRequired safepoint_check_required) :</span>
<span class="line-added">+   Mutex(Rank, name, allow_vm_block, safepoint_check_required) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Mutex::owned_by_self() const {</span>
    return _owner == Thread::current();
  }
  
<span class="line-modified">! void Mutex::print_on_error(outputStream* st) const {</span>
    st-&gt;print(&quot;[&quot; PTR_FORMAT, p2i(this));
    st-&gt;print(&quot;] %s&quot;, _name);
    st-&gt;print(&quot; - owner thread: &quot; PTR_FORMAT, p2i(_owner));
  }
  
  // ----------------------------------------------------------------------------------
  // Non-product code
  
  #ifndef PRODUCT
<span class="line-modified">! const char* print_safepoint_check(Mutex::SafepointCheckRequired safepoint_check) {</span>
<span class="line-modified">!   switch (safepoint_check) {</span>
<span class="line-modified">!   case Mutex::_safepoint_check_never:     return &quot;safepoint_check_never&quot;;</span>
<span class="line-added">+   case Mutex::_safepoint_check_sometimes: return &quot;safepoint_check_sometimes&quot;;</span>
<span class="line-added">+   case Mutex::_safepoint_check_always:    return &quot;safepoint_check_always&quot;;</span>
<span class="line-added">+   default: return &quot;&quot;;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Mutex::print_on(outputStream* st) const {</span>
<span class="line-added">+   st-&gt;print(&quot;Mutex: [&quot; PTR_FORMAT &quot;] %s - owner: &quot; PTR_FORMAT,</span>
<span class="line-added">+             p2i(this), _name, p2i(_owner));</span>
<span class="line-added">+   if (_allow_vm_block) {</span>
<span class="line-added">+     st-&gt;print(&quot;%s&quot;, &quot; allow_vm_block&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   st-&gt;print(&quot; %s&quot;, print_safepoint_check(_safepoint_check_required));</span>
<span class="line-added">+   st-&gt;cr();</span>
  }
  #endif
  
  #ifdef ASSERT
<span class="line-modified">! void Mutex::assert_owner(Thread * expected) {</span>
    const char* msg = &quot;invalid owner&quot;;
    if (expected == NULL) {
      msg = &quot;should be un-owned&quot;;
    }
    else if (expected == Thread::current()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,12 ***</span>
    assert(_owner == expected,
           &quot;%s: owner=&quot; INTPTR_FORMAT &quot;, should be=&quot; INTPTR_FORMAT,
           msg, p2i(_owner), p2i(expected));
  }
  
<span class="line-modified">! Monitor * Monitor::get_least_ranked_lock(Monitor * locks) {</span>
<span class="line-modified">!   Monitor *res, *tmp;</span>
    for (res = tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
      if (tmp-&gt;rank() &lt; res-&gt;rank()) {
        res = tmp;
      }
    }
<span class="line-new-header">--- 343,12 ---</span>
    assert(_owner == expected,
           &quot;%s: owner=&quot; INTPTR_FORMAT &quot;, should be=&quot; INTPTR_FORMAT,
           msg, p2i(_owner), p2i(expected));
  }
  
<span class="line-modified">! Mutex* Mutex::get_least_ranked_lock(Mutex* locks) {</span>
<span class="line-modified">!   Mutex *res, *tmp;</span>
    for (res = tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
      if (tmp-&gt;rank() &lt; res-&gt;rank()) {
        res = tmp;
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 330,12 ***</span>
      }
    }
    return res;
  }
  
<span class="line-modified">! Monitor* Monitor::get_least_ranked_lock_besides_this(Monitor* locks) {</span>
<span class="line-modified">!   Monitor *res, *tmp;</span>
    for (res = NULL, tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
      if (tmp != this &amp;&amp; (res == NULL || tmp-&gt;rank() &lt; res-&gt;rank())) {
        res = tmp;
      }
    }
<span class="line-new-header">--- 363,12 ---</span>
      }
    }
    return res;
  }
  
<span class="line-modified">! Mutex* Mutex::get_least_ranked_lock_besides_this(Mutex* locks) {</span>
<span class="line-modified">!   Mutex *res, *tmp;</span>
    for (res = NULL, tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
      if (tmp != this &amp;&amp; (res == NULL || tmp-&gt;rank() &lt; res-&gt;rank())) {
        res = tmp;
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,27 ***</span>
      }
    }
    return res;
  }
  
<span class="line-modified">! </span>
<span class="line-removed">- bool Monitor::contains(Monitor* locks, Monitor * lock) {</span>
    for (; locks != NULL; locks = locks-&gt;next()) {
      if (locks == lock) {
        return true;
      }
    }
    return false;
  }
<span class="line-modified">! #endif</span>
  
  // Called immediately after lock acquisition or release as a diagnostic
  // to track the lock-set of the thread and test for rank violations that
  // might indicate exposure to deadlock.
  // Rather like an EventListener for _owner (:&gt;).
  
<span class="line-modified">! void Monitor::set_owner_implementation(Thread *new_owner) {</span>
    // This function is solely responsible for maintaining
    // and checking the invariant that threads and locks
    // are in a 1/N relation, with some some locks unowned.
    // It uses the Mutex::_owner, Mutex::_next, and
    // Thread::_owned_locks fields, and no other function
<span class="line-new-header">--- 383,42 ---</span>
      }
    }
    return res;
  }
  
<span class="line-modified">! bool Mutex::contains(Mutex* locks, Mutex* lock) {</span>
    for (; locks != NULL; locks = locks-&gt;next()) {
      if (locks == lock) {
        return true;
      }
    }
    return false;
  }
<span class="line-modified">! </span>
<span class="line-added">+ // NSV implied with locking allow_vm_block or !safepoint_check locks.</span>
<span class="line-added">+ void Mutex::no_safepoint_verifier(Thread* thread, bool enable) {</span>
<span class="line-added">+   // The tty_lock is special because it is released for the safepoint by</span>
<span class="line-added">+   // the safepoint mechanism.</span>
<span class="line-added">+   if (this == tty_lock) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (_allow_vm_block) {</span>
<span class="line-added">+     if (enable) {</span>
<span class="line-added">+       thread-&gt;_no_safepoint_count++;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       thread-&gt;_no_safepoint_count--;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
  // Called immediately after lock acquisition or release as a diagnostic
  // to track the lock-set of the thread and test for rank violations that
  // might indicate exposure to deadlock.
  // Rather like an EventListener for _owner (:&gt;).
  
<span class="line-modified">! void Mutex::set_owner_implementation(Thread *new_owner) {</span>
    // This function is solely responsible for maintaining
    // and checking the invariant that threads and locks
    // are in a 1/N relation, with some some locks unowned.
    // It uses the Mutex::_owner, Mutex::_next, and
    // Thread::_owned_locks fields, and no other function
</pre>
<hr />
<pre>
<span class="line-old-header">*** 386,12 ***</span>
      assert(_owner == NULL, &quot;setting the owner thread of an already owned mutex&quot;);
      _owner = new_owner; // set the owner
  
      // link &quot;this&quot; into the owned locks list
  
<span class="line-modified">! #ifdef ASSERT  // Thread::_owned_locks is under the same ifdef</span>
<span class="line-removed">-     Monitor* locks = get_least_ranked_lock(new_owner-&gt;owned_locks());</span>
      // Mutex::set_owner_implementation is a friend of Thread
  
      assert(this-&gt;rank() &gt;= 0, &quot;bad lock rank&quot;);
  
      // Deadlock avoidance rules require us to acquire Mutexes only in
<span class="line-new-header">--- 434,11 ---</span>
      assert(_owner == NULL, &quot;setting the owner thread of an already owned mutex&quot;);
      _owner = new_owner; // set the owner
  
      // link &quot;this&quot; into the owned locks list
  
<span class="line-modified">!     Mutex* locks = get_least_ranked_lock(new_owner-&gt;owned_locks());</span>
      // Mutex::set_owner_implementation is a friend of Thread
  
      assert(this-&gt;rank() &gt;= 0, &quot;bad lock rank&quot;);
  
      // Deadlock avoidance rules require us to acquire Mutexes only in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,29 ***</span>
              locks-&gt;name(), locks-&gt;rank());
      }
  
      this-&gt;_next = new_owner-&gt;_owned_locks;
      new_owner-&gt;_owned_locks = this;
<span class="line-modified">! #endif</span>
  
    } else {
      // the thread is releasing this lock
  
      Thread* old_owner = _owner;
<span class="line-modified">!     DEBUG_ONLY(_last_owner = old_owner;)</span>
  
      assert(old_owner != NULL, &quot;removing the owner thread of an unowned mutex&quot;);
      assert(old_owner == Thread::current(), &quot;removing the owner thread of an unowned mutex&quot;);
  
      _owner = NULL; // set the owner
  
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-removed">-     Monitor *locks = old_owner-&gt;owned_locks();</span>
  
      // remove &quot;this&quot; from the owned locks list
  
<span class="line-modified">!     Monitor *prev = NULL;</span>
      bool found = false;
      for (; locks != NULL; prev = locks, locks = locks-&gt;next()) {
        if (locks == this) {
          found = true;
          break;
<span class="line-new-header">--- 458,30 ---</span>
              locks-&gt;name(), locks-&gt;rank());
      }
  
      this-&gt;_next = new_owner-&gt;_owned_locks;
      new_owner-&gt;_owned_locks = this;
<span class="line-modified">! </span>
<span class="line-added">+     // NSV implied with locking allow_vm_block flag.</span>
<span class="line-added">+     no_safepoint_verifier(new_owner, true);</span>
  
    } else {
      // the thread is releasing this lock
  
      Thread* old_owner = _owner;
<span class="line-modified">!     _last_owner = old_owner;</span>
  
      assert(old_owner != NULL, &quot;removing the owner thread of an unowned mutex&quot;);
      assert(old_owner == Thread::current(), &quot;removing the owner thread of an unowned mutex&quot;);
  
      _owner = NULL; // set the owner
  
<span class="line-modified">!     Mutex* locks = old_owner-&gt;owned_locks();</span>
  
      // remove &quot;this&quot; from the owned locks list
  
<span class="line-modified">!     Mutex* prev = NULL;</span>
      bool found = false;
      for (; locks != NULL; prev = locks, locks = locks-&gt;next()) {
        if (locks == this) {
          found = true;
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,35 ***</span>
        old_owner-&gt;_owned_locks = _next;
      } else {
        prev-&gt;_next = _next;
      }
      _next = NULL;
<span class="line-removed">- #endif</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- // Factored out common sanity checks for locking mutex&#39;es. Used by lock() and try_lock()</span>
<span class="line-removed">- void Monitor::check_prelock_state(Thread *thread, bool safepoint_check) {</span>
<span class="line-removed">-   if (safepoint_check) {</span>
<span class="line-removed">-     assert((!thread-&gt;is_Java_thread() || ((JavaThread *)thread)-&gt;thread_state() == _thread_in_vm)</span>
<span class="line-removed">-            || rank() == Mutex::special, &quot;wrong thread state for using locks&quot;);</span>
<span class="line-removed">-     if (thread-&gt;is_VM_thread() &amp;&amp; !allow_vm_block()) {</span>
<span class="line-removed">-       fatal(&quot;VM thread using lock %s (not allowed to block on)&quot;, name());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     DEBUG_ONLY(if (rank() != Mutex::special) \</span>
<span class="line-removed">-                thread-&gt;check_for_valid_safepoint_state(false);)</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert(!os::ThreadCrashProtection::is_crash_protected(thread),</span>
<span class="line-removed">-          &quot;locking not allowed when crash protection is set&quot;);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void Monitor::check_block_state(Thread *thread) {</span>
<span class="line-modified">!   if (!_allow_vm_block &amp;&amp; thread-&gt;is_VM_thread()) {</span>
<span class="line-removed">-     warning(&quot;VM thread blocked on lock&quot;);</span>
<span class="line-removed">-     print();</span>
<span class="line-removed">-     BREAKPOINT;</span>
    }
<span class="line-removed">-   assert(_owner != thread, &quot;deadlock: blocking on monitor owned by current thread&quot;);</span>
  }
<span class="line-modified">! </span>
<span class="line-removed">- #endif // PRODUCT</span>
<span class="line-new-header">--- 492,11 ---</span>
        old_owner-&gt;_owned_locks = _next;
      } else {
        prev-&gt;_next = _next;
      }
      _next = NULL;
  
<span class="line-modified">!     // ~NSV implied with locking allow_vm_block flag.</span>
<span class="line-modified">!     no_safepoint_verifier(old_owner, false);</span>
    }
  }
<span class="line-modified">! #endif // ASSERT</span>
</pre>
<center><a href="memprofiler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutex.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
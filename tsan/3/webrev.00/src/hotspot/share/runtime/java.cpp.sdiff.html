<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/java.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interfaceSupport.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="java.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/java.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;aot/aotLoader.hpp&quot;
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 30 #include &quot;classfile/stringTable.hpp&quot;

 31 #include &quot;classfile/systemDictionary.hpp&quot;
 32 #include &quot;code/codeCache.hpp&quot;
 33 #include &quot;compiler/compileBroker.hpp&quot;
 34 #include &quot;compiler/compilerOracle.hpp&quot;
 35 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
 36 #include &quot;jfr/jfrEvents.hpp&quot;
 37 #include &quot;jfr/support/jfrThreadId.hpp&quot;
 38 #if INCLUDE_JVMCI
<span class="line-modified"> 39 #include &quot;jvmci/jvmciCompiler.hpp&quot;</span>
<span class="line-removed"> 40 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
 41 #endif
 42 #include &quot;logging/log.hpp&quot;
 43 #include &quot;logging/logStream.hpp&quot;
 44 #include &quot;memory/oopFactory.hpp&quot;
 45 #include &quot;memory/resourceArea.hpp&quot;

 46 #include &quot;memory/universe.hpp&quot;
 47 #include &quot;oops/constantPool.hpp&quot;
 48 #include &quot;oops/generateOopMap.hpp&quot;
 49 #include &quot;oops/instanceKlass.hpp&quot;
 50 #include &quot;oops/instanceOop.hpp&quot;
 51 #include &quot;oops/method.hpp&quot;
 52 #include &quot;oops/objArrayOop.hpp&quot;
 53 #include &quot;oops/oop.inline.hpp&quot;
 54 #include &quot;oops/symbol.hpp&quot;
 55 #include &quot;prims/jvmtiExport.hpp&quot;
 56 #include &quot;runtime/arguments.hpp&quot;
 57 #include &quot;runtime/biasedLocking.hpp&quot;
<span class="line-removed"> 58 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
 59 #include &quot;runtime/deoptimization.hpp&quot;
 60 #include &quot;runtime/flags/flagSetting.hpp&quot;
 61 #include &quot;runtime/handles.inline.hpp&quot;
 62 #include &quot;runtime/init.hpp&quot;
 63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 64 #include &quot;runtime/java.hpp&quot;
 65 #include &quot;runtime/memprofiler.hpp&quot;
 66 #include &quot;runtime/sharedRuntime.hpp&quot;
 67 #include &quot;runtime/statSampler.hpp&quot;
 68 #include &quot;runtime/sweeper.hpp&quot;
 69 #include &quot;runtime/task.hpp&quot;
 70 #include &quot;runtime/thread.inline.hpp&quot;
 71 #include &quot;runtime/timer.hpp&quot;
 72 #include &quot;runtime/vmOperations.hpp&quot;
 73 #include &quot;services/memTracker.hpp&quot;
 74 #include &quot;utilities/dtrace.hpp&quot;
 75 #include &quot;utilities/globalDefinitions.hpp&quot;
 76 #include &quot;utilities/histogram.hpp&quot;
 77 #include &quot;utilities/macros.hpp&quot;
 78 #include &quot;utilities/vmError.hpp&quot;
</pre>
<hr />
<pre>
185   total = int_total + comp_total;
186   tty-&gt;print_cr(&quot;Invocations summary:&quot;);
187   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) interpreted&quot;,  int_total,    100.0 * int_total    / total);
188   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) compiled&quot;,     comp_total,   100.0 * comp_total   / total);
189   tty-&gt;print_cr(&quot;\t%9d (100%%)  total&quot;,         total);
190   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) synchronized&quot;, synch_total,  100.0 * synch_total  / total);
191   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) final&quot;,        final_total,  100.0 * final_total  / total);
192   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) static&quot;,       static_total, 100.0 * static_total / total);
193   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) native&quot;,       nativ_total,  100.0 * nativ_total  / total);
194   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) accessor&quot;,     acces_total,  100.0 * acces_total  / total);
195   tty-&gt;cr();
196   SharedRuntime::print_call_statistics(comp_total);
197 }
198 
199 void print_bytecode_count() {
200   if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
201     tty-&gt;print_cr(&quot;[BytecodeCounter::counter_value = %d]&quot;, BytecodeCounter::counter_value());
202   }
203 }
204 
<span class="line-removed">205 AllocStats alloc_stats;</span>
<span class="line-removed">206 </span>
<span class="line-removed">207 </span>
208 
209 // General statistics printing (profiling ...)
210 void print_statistics() {
211 #ifdef ASSERT
212 
213   if (CountRuntimeCalls) {
214     extern Histogram *RuntimeHistogram;
215     RuntimeHistogram-&gt;print();
216   }
217 
218   if (CountJNICalls) {
219     extern Histogram *JNIHistogram;
220     JNIHistogram-&gt;print();
221   }
222 
223   if (CountJVMCalls) {
224     extern Histogram *JVMHistogram;
225     JVMHistogram-&gt;print();
226   }
227 
</pre>
<hr />
<pre>
285   if (CountCompiledCalls) {
286     print_method_invocation_histogram();
287   }
288 
289   print_method_profiling_data();
290 
291   if (TimeOopMap) {
292     GenerateOopMap::print_time();
293   }
294   if (PrintSymbolTableSizeHistogram) {
295     SymbolTable::print_histogram();
296   }
297   if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
298     BytecodeCounter::print();
299   }
300   if (PrintBytecodePairHistogram) {
301     BytecodePairHistogram::print();
302   }
303 
304   if (PrintCodeCache) {
<span class="line-modified">305     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
306     CodeCache::print();
307   }
308 
309   // CodeHeap State Analytics.
310   // Does also call NMethodSweeper::print(tty)
311   if (PrintCodeHeapAnalytics) {
<span class="line-modified">312     CompileBroker::print_heapinfo(NULL, &quot;all&quot;, &quot;4096&quot;); // details</span>
313   } else if (PrintMethodFlushingStatistics) {
314     NMethodSweeper::print(tty);
315   }
316 
317   if (PrintCodeCache2) {
<span class="line-modified">318     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
319     CodeCache::print_internals();
320   }
321 
322   if (PrintVtableStats) {
323     klassVtable::print_statistics();
324     klassItable::print_statistics();
325   }
326   if (VerifyOops &amp;&amp; Verbose) {
327     tty-&gt;print_cr(&quot;+VerifyOops count: %d&quot;, StubRoutines::verify_oop_count());
328   }
329 
330   print_bytecode_count();
<span class="line-removed">331   if (PrintMallocStatistics) {</span>
<span class="line-removed">332     tty-&gt;print(&quot;allocation stats: &quot;);</span>
<span class="line-removed">333     alloc_stats.print();</span>
<span class="line-removed">334     tty-&gt;cr();</span>
<span class="line-removed">335   }</span>
336 
337   if (PrintSystemDictionaryAtExit) {
338     ResourceMark rm;
339     MutexLocker mcld(ClassLoaderDataGraph_lock);
340     SystemDictionary::print();
341     ClassLoaderDataGraph::print();
342   }
343 
344   if (LogTouchedMethods &amp;&amp; PrintTouchedMethodsAtExit) {
345     Method::print_touched_methods(tty);
346   }
347 
348   if (PrintBiasedLockingStatistics) {
349     BiasedLocking::print_counters();
350   }
351 
352   // Native memory tracking data
353   if (PrintNMTStatistics) {
354     MemTracker::final_report(tty);
355   }
356 
357   ThreadsSMRSupport::log_statistics();
358 }
359 
360 #else // PRODUCT MODE STATISTICS
361 
362 void print_statistics() {
363 
364   if (PrintMethodData) {
365     print_method_profiling_data();
366   }
367 
368   if (CITime) {
369     CompileBroker::print_times();
370   }
371 
372   if (PrintCodeCache) {
<span class="line-modified">373     MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
374     CodeCache::print();
375   }
376 
377   // CodeHeap State Analytics.
378   // Does also call NMethodSweeper::print(tty)
379   if (PrintCodeHeapAnalytics) {
<span class="line-modified">380     CompileBroker::print_heapinfo(NULL, &quot;all&quot;, &quot;4096&quot;); // details</span>
381   } else if (PrintMethodFlushingStatistics) {
382     NMethodSweeper::print(tty);
383   }
384 
385 #ifdef COMPILER2
386   if (PrintPreciseBiasedLockingStatistics || PrintPreciseRTMLockingStatistics) {
387     OptoRuntime::print_named_counters();
388   }
389 #endif
390   if (PrintBiasedLockingStatistics) {
391     BiasedLocking::print_counters();
392   }
393 
394   // Native memory tracking data
395   if (PrintNMTStatistics) {
396     MemTracker::final_report(tty);
397   }
398 
399   if (LogTouchedMethods &amp;&amp; PrintTouchedMethodsAtExit) {
400     Method::print_touched_methods(tty);
</pre>
<hr />
<pre>
402 
403   ThreadsSMRSupport::log_statistics();
404 }
405 
406 #endif
407 
408 // Note: before_exit() can be executed only once, if more than one threads
409 //       are trying to shutdown the VM at the same time, only one thread
410 //       can run before_exit() and all other threads must wait.
411 void before_exit(JavaThread* thread) {
412   #define BEFORE_EXIT_NOT_RUN 0
413   #define BEFORE_EXIT_RUNNING 1
414   #define BEFORE_EXIT_DONE    2
415   static jint volatile _before_exit_status = BEFORE_EXIT_NOT_RUN;
416 
417   // Note: don&#39;t use a Mutex to guard the entire before_exit(), as
418   // JVMTI post_thread_end_event and post_vm_death_event will run native code.
419   // A CAS or OSMutex would work just fine but then we need to manipulate
420   // thread state for Safepoint. Here we use Monitor wait() and notify_all()
421   // for synchronization.
<span class="line-modified">422   { MutexLocker ml(BeforeExit_lock);</span>
423     switch (_before_exit_status) {
424     case BEFORE_EXIT_NOT_RUN:
425       _before_exit_status = BEFORE_EXIT_RUNNING;
426       break;
427     case BEFORE_EXIT_RUNNING:
428       while (_before_exit_status == BEFORE_EXIT_RUNNING) {
<span class="line-modified">429         BeforeExit_lock-&gt;wait();</span>
430       }
431       assert(_before_exit_status == BEFORE_EXIT_DONE, &quot;invalid state&quot;);
432       return;
433     case BEFORE_EXIT_DONE:
434       // need block to avoid SS compiler bug
435       {
436         return;
437       }
438     }
439   }
440 
441 #if INCLUDE_JVMCI
<span class="line-modified">442   // We are not using CATCH here because we want the exit to continue normally.</span>
<span class="line-removed">443   Thread* THREAD = thread;</span>
<span class="line-removed">444   JVMCIRuntime::shutdown(THREAD);</span>
<span class="line-removed">445   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-removed">446     HandleMark hm(THREAD);</span>
<span class="line-removed">447     Handle exception(THREAD, PENDING_EXCEPTION);</span>
<span class="line-removed">448     CLEAR_PENDING_EXCEPTION;</span>
<span class="line-removed">449     java_lang_Throwable::java_printStackTrace(exception, THREAD);</span>
<span class="line-removed">450   }</span>
451 #endif
452 
453   // Hang forever on exit if we&#39;re reporting an error.
454   if (ShowMessageBoxOnError &amp;&amp; VMError::is_error_reported()) {
455     os::infinite_sleep();
456   }
457 
458   EventThreadEnd event;
459   if (event.should_commit()) {
460     event.set_thread(JFR_THREAD_ID(thread));
461     event.commit();
462   }
463 
464   JFR_ONLY(Jfr::on_vm_shutdown();)
465 
466   // Stop the WatcherThread. We do this before disenrolling various
467   // PeriodicTasks to reduce the likelihood of races.
468   if (PeriodicTask::num_tasks() &gt; 0) {
469     WatcherThread::stop();
470   }
</pre>
<hr />
<pre>
489     }
490   }
491 
492   if (PrintBytecodeHistogram) {
493     BytecodeHistogram::print();
494   }
495 
496   if (JvmtiExport::should_post_thread_life()) {
497     JvmtiExport::post_thread_end(thread);
498   }
499 
500   // Always call even when there are not JVMTI environments yet, since environments
501   // may be attached late and JVMTI must track phases of VM execution
502   JvmtiExport::post_vm_death();
503   Threads::shutdown_vm_agents();
504 
505   // Terminate the signal thread
506   // Note: we don&#39;t wait until it actually dies.
507   os::terminate_signal_thread();
508 






509   print_statistics();
510   Universe::heap()-&gt;print_tracing_info();
511 
512   { MutexLocker ml(BeforeExit_lock);
513     _before_exit_status = BEFORE_EXIT_DONE;
514     BeforeExit_lock-&gt;notify_all();
515   }
516 
517   if (VerifyStringTableAtExit) {
518     size_t fail_cnt = StringTable::verify_and_compare_entries();
519     if (fail_cnt != 0) {
520       tty-&gt;print_cr(&quot;ERROR: fail_cnt=&quot; SIZE_FORMAT, fail_cnt);
521       guarantee(fail_cnt == 0, &quot;unexpected StringTable verification failures&quot;);
522     }
523   }
524 
525   #undef BEFORE_EXIT_NOT_RUN
526   #undef BEFORE_EXIT_RUNNING
527   #undef BEFORE_EXIT_DONE
528 }
529 
530 void vm_exit(int code) {
531   Thread* thread =
532       ThreadLocalStorage::is_initialized() ? Thread::current_or_null() : NULL;
533   if (thread == NULL) {
534     // very early initialization failure -- just exit
535     vm_direct_exit(code);
536   }
537 





538   if (VMThread::vm_thread() != NULL) {








539     // Fire off a VM_Exit operation to bring VM to a safepoint and exit
540     VM_Exit op(code);
<span class="line-modified">541     if (thread-&gt;is_Java_thread())</span>
<span class="line-modified">542       ((JavaThread*)thread)-&gt;set_thread_state(_thread_in_vm);</span>







543     VMThread::execute(&amp;op);
544     // should never reach here; but in case something wrong with VM Thread.
545     vm_direct_exit(code);
546   } else {
547     // VM thread is gone, just exit
548     vm_direct_exit(code);
549   }
550   ShouldNotReachHere();
551 }
552 
553 void notify_vm_shutdown() {
554   // For now, just a dtrace probe.
555   HOTSPOT_VM_SHUTDOWN();
556   HS_DTRACE_WORKAROUND_TAIL_CALL_BUG();
557 }
558 
559 void vm_direct_exit(int code) {
560   notify_vm_shutdown();
561   os::wait_for_keypress_at_exit();
562   os::exit(code);
</pre>
<hr />
<pre>
663 
664   // Failure during initialization, we don&#39;t want to dump core
665   vm_abort(false);
666 }
667 
668 void vm_exit_during_initialization(const char* error, const char* message) {
669   vm_notify_during_shutdown(error, message);
670 
671   // Failure during initialization, we don&#39;t want to dump core
672   vm_abort(false);
673 }
674 
675 void vm_shutdown_during_initialization(const char* error, const char* message) {
676   vm_notify_during_shutdown(error, message);
677   vm_shutdown();
678 }
679 
680 JDK_Version JDK_Version::_current;
681 const char* JDK_Version::_runtime_name;
682 const char* JDK_Version::_runtime_version;


683 
684 void JDK_Version::initialize() {
<span class="line-removed">685   jdk_version_info info;</span>
686   assert(!_current.is_valid(), &quot;Don&#39;t initialize twice&quot;);
687 
<span class="line-modified">688   void *lib_handle = os::native_java_library();</span>
<span class="line-modified">689   jdk_version_info_fn_t func = CAST_TO_FN_PTR(jdk_version_info_fn_t,</span>
<span class="line-modified">690      os::dll_lookup(lib_handle, &quot;JDK_GetVersionInfo0&quot;));</span>
<span class="line-modified">691 </span>
<span class="line-modified">692   assert(func != NULL, &quot;Support for JDK 1.5 or older has been removed after JEP-223&quot;);</span>
<span class="line-modified">693 </span>
<span class="line-removed">694   (*func)(&amp;info, sizeof(info));</span>
<span class="line-removed">695 </span>
<span class="line-removed">696   int major = JDK_VERSION_MAJOR(info.jdk_version);</span>
<span class="line-removed">697   int minor = JDK_VERSION_MINOR(info.jdk_version);</span>
<span class="line-removed">698   int security = JDK_VERSION_SECURITY(info.jdk_version);</span>
<span class="line-removed">699   int build = JDK_VERSION_BUILD(info.jdk_version);</span>
<span class="line-removed">700 </span>
<span class="line-removed">701   // Incompatible with pre-4243978 JDK.</span>
<span class="line-removed">702   if (info.pending_list_uses_discovered_field == 0) {</span>
<span class="line-removed">703     vm_exit_during_initialization(</span>
<span class="line-removed">704       &quot;Incompatible JDK is not using Reference.discovered field for pending list&quot;);</span>
<span class="line-removed">705   }</span>
<span class="line-removed">706   _current = JDK_Version(major, minor, security, info.patch_version, build,</span>
<span class="line-removed">707                          info.thread_park_blocker == 1,</span>
<span class="line-removed">708                          info.post_vm_init_hook_enabled == 1);</span>
709 }
710 
711 void JDK_Version_init() {
712   JDK_Version::initialize();
713 }
714 
715 static int64_t encode_jdk_version(const JDK_Version&amp; v) {
716   return
717     ((int64_t)v.major_version()          &lt;&lt; (BitsPerByte * 4)) |
718     ((int64_t)v.minor_version()          &lt;&lt; (BitsPerByte * 3)) |
719     ((int64_t)v.security_version()       &lt;&lt; (BitsPerByte * 2)) |
720     ((int64_t)v.patch_version()          &lt;&lt; (BitsPerByte * 1)) |
721     ((int64_t)v.build_number()           &lt;&lt; (BitsPerByte * 0));
722 }
723 
724 int JDK_Version::compare(const JDK_Version&amp; other) const {
725   assert(is_valid() &amp;&amp; other.is_valid(), &quot;Invalid version (uninitialized?)&quot;);
726   uint64_t e = encode_jdk_version(*this);
727   uint64_t o = encode_jdk_version(other);
728   return (e &gt; o) ? 1 : ((e == o) ? 0 : -1);
729 }
730 

731 void JDK_Version::to_string(char* buffer, size_t buflen) const {
732   assert(buffer &amp;&amp; buflen &gt; 0, &quot;call with useful buffer&quot;);
733   size_t index = 0;
734 
735   if (!is_valid()) {
736     jio_snprintf(buffer, buflen, &quot;%s&quot;, &quot;(uninitialized)&quot;);
737   } else {
738     int rc = jio_snprintf(
739         &amp;buffer[index], buflen - index, &quot;%d.%d&quot;, _major, _minor);
740     if (rc == -1) return;
741     index += rc;
<span class="line-modified">742     if (_security &gt; 0) {</span>
<span class="line-modified">743       rc = jio_snprintf(&amp;buffer[index], buflen - index, &quot;.%d&quot;, _security);</span>
744       if (rc == -1) return;
745       index += rc;
<span class="line-modified">746     }</span>
<span class="line-modified">747     if (_patch &gt; 0) {</span>
<span class="line-removed">748       rc = jio_snprintf(&amp;buffer[index], buflen - index, &quot;.%d&quot;, _patch);</span>
749       if (rc == -1) return;
750       index += rc;
751     }
752     if (_build &gt; 0) {
753       rc = jio_snprintf(&amp;buffer[index], buflen - index, &quot;+%d&quot;, _build);
754       if (rc == -1) return;
755       index += rc;
756     }
757   }
758 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;aot/aotLoader.hpp&quot;
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 30 #include &quot;classfile/stringTable.hpp&quot;
<span class="line-added"> 31 #include &quot;classfile/symbolTable.hpp&quot;</span>
 32 #include &quot;classfile/systemDictionary.hpp&quot;
 33 #include &quot;code/codeCache.hpp&quot;
 34 #include &quot;compiler/compileBroker.hpp&quot;
 35 #include &quot;compiler/compilerOracle.hpp&quot;
 36 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
 37 #include &quot;jfr/jfrEvents.hpp&quot;
 38 #include &quot;jfr/support/jfrThreadId.hpp&quot;
 39 #if INCLUDE_JVMCI
<span class="line-modified"> 40 #include &quot;jvmci/jvmci.hpp&quot;</span>

 41 #endif
 42 #include &quot;logging/log.hpp&quot;
 43 #include &quot;logging/logStream.hpp&quot;
 44 #include &quot;memory/oopFactory.hpp&quot;
 45 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 46 #include &quot;memory/dynamicArchive.hpp&quot;</span>
 47 #include &quot;memory/universe.hpp&quot;
 48 #include &quot;oops/constantPool.hpp&quot;
 49 #include &quot;oops/generateOopMap.hpp&quot;
 50 #include &quot;oops/instanceKlass.hpp&quot;
 51 #include &quot;oops/instanceOop.hpp&quot;
 52 #include &quot;oops/method.hpp&quot;
 53 #include &quot;oops/objArrayOop.hpp&quot;
 54 #include &quot;oops/oop.inline.hpp&quot;
 55 #include &quot;oops/symbol.hpp&quot;
 56 #include &quot;prims/jvmtiExport.hpp&quot;
 57 #include &quot;runtime/arguments.hpp&quot;
 58 #include &quot;runtime/biasedLocking.hpp&quot;

 59 #include &quot;runtime/deoptimization.hpp&quot;
 60 #include &quot;runtime/flags/flagSetting.hpp&quot;
 61 #include &quot;runtime/handles.inline.hpp&quot;
 62 #include &quot;runtime/init.hpp&quot;
 63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 64 #include &quot;runtime/java.hpp&quot;
 65 #include &quot;runtime/memprofiler.hpp&quot;
 66 #include &quot;runtime/sharedRuntime.hpp&quot;
 67 #include &quot;runtime/statSampler.hpp&quot;
 68 #include &quot;runtime/sweeper.hpp&quot;
 69 #include &quot;runtime/task.hpp&quot;
 70 #include &quot;runtime/thread.inline.hpp&quot;
 71 #include &quot;runtime/timer.hpp&quot;
 72 #include &quot;runtime/vmOperations.hpp&quot;
 73 #include &quot;services/memTracker.hpp&quot;
 74 #include &quot;utilities/dtrace.hpp&quot;
 75 #include &quot;utilities/globalDefinitions.hpp&quot;
 76 #include &quot;utilities/histogram.hpp&quot;
 77 #include &quot;utilities/macros.hpp&quot;
 78 #include &quot;utilities/vmError.hpp&quot;
</pre>
<hr />
<pre>
185   total = int_total + comp_total;
186   tty-&gt;print_cr(&quot;Invocations summary:&quot;);
187   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) interpreted&quot;,  int_total,    100.0 * int_total    / total);
188   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) compiled&quot;,     comp_total,   100.0 * comp_total   / total);
189   tty-&gt;print_cr(&quot;\t%9d (100%%)  total&quot;,         total);
190   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) synchronized&quot;, synch_total,  100.0 * synch_total  / total);
191   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) final&quot;,        final_total,  100.0 * final_total  / total);
192   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) static&quot;,       static_total, 100.0 * static_total / total);
193   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) native&quot;,       nativ_total,  100.0 * nativ_total  / total);
194   tty-&gt;print_cr(&quot;\t%9d (%4.1f%%) accessor&quot;,     acces_total,  100.0 * acces_total  / total);
195   tty-&gt;cr();
196   SharedRuntime::print_call_statistics(comp_total);
197 }
198 
199 void print_bytecode_count() {
200   if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
201     tty-&gt;print_cr(&quot;[BytecodeCounter::counter_value = %d]&quot;, BytecodeCounter::counter_value());
202   }
203 }
204 



205 
206 // General statistics printing (profiling ...)
207 void print_statistics() {
208 #ifdef ASSERT
209 
210   if (CountRuntimeCalls) {
211     extern Histogram *RuntimeHistogram;
212     RuntimeHistogram-&gt;print();
213   }
214 
215   if (CountJNICalls) {
216     extern Histogram *JNIHistogram;
217     JNIHistogram-&gt;print();
218   }
219 
220   if (CountJVMCalls) {
221     extern Histogram *JVMHistogram;
222     JVMHistogram-&gt;print();
223   }
224 
</pre>
<hr />
<pre>
282   if (CountCompiledCalls) {
283     print_method_invocation_histogram();
284   }
285 
286   print_method_profiling_data();
287 
288   if (TimeOopMap) {
289     GenerateOopMap::print_time();
290   }
291   if (PrintSymbolTableSizeHistogram) {
292     SymbolTable::print_histogram();
293   }
294   if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
295     BytecodeCounter::print();
296   }
297   if (PrintBytecodePairHistogram) {
298     BytecodePairHistogram::print();
299   }
300 
301   if (PrintCodeCache) {
<span class="line-modified">302     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
303     CodeCache::print();
304   }
305 
306   // CodeHeap State Analytics.
307   // Does also call NMethodSweeper::print(tty)
308   if (PrintCodeHeapAnalytics) {
<span class="line-modified">309     CompileBroker::print_heapinfo(NULL, &quot;all&quot;, 4096); // details</span>
310   } else if (PrintMethodFlushingStatistics) {
311     NMethodSweeper::print(tty);
312   }
313 
314   if (PrintCodeCache2) {
<span class="line-modified">315     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
316     CodeCache::print_internals();
317   }
318 
319   if (PrintVtableStats) {
320     klassVtable::print_statistics();
321     klassItable::print_statistics();
322   }
323   if (VerifyOops &amp;&amp; Verbose) {
324     tty-&gt;print_cr(&quot;+VerifyOops count: %d&quot;, StubRoutines::verify_oop_count());
325   }
326 
327   print_bytecode_count();





328 
329   if (PrintSystemDictionaryAtExit) {
330     ResourceMark rm;
331     MutexLocker mcld(ClassLoaderDataGraph_lock);
332     SystemDictionary::print();
333     ClassLoaderDataGraph::print();
334   }
335 
336   if (LogTouchedMethods &amp;&amp; PrintTouchedMethodsAtExit) {
337     Method::print_touched_methods(tty);
338   }
339 
340   if (PrintBiasedLockingStatistics) {
341     BiasedLocking::print_counters();
342   }
343 
344   // Native memory tracking data
345   if (PrintNMTStatistics) {
346     MemTracker::final_report(tty);
347   }
348 
349   ThreadsSMRSupport::log_statistics();
350 }
351 
352 #else // PRODUCT MODE STATISTICS
353 
354 void print_statistics() {
355 
356   if (PrintMethodData) {
357     print_method_profiling_data();
358   }
359 
360   if (CITime) {
361     CompileBroker::print_times();
362   }
363 
364   if (PrintCodeCache) {
<span class="line-modified">365     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
366     CodeCache::print();
367   }
368 
369   // CodeHeap State Analytics.
370   // Does also call NMethodSweeper::print(tty)
371   if (PrintCodeHeapAnalytics) {
<span class="line-modified">372     CompileBroker::print_heapinfo(NULL, &quot;all&quot;, 4096); // details</span>
373   } else if (PrintMethodFlushingStatistics) {
374     NMethodSweeper::print(tty);
375   }
376 
377 #ifdef COMPILER2
378   if (PrintPreciseBiasedLockingStatistics || PrintPreciseRTMLockingStatistics) {
379     OptoRuntime::print_named_counters();
380   }
381 #endif
382   if (PrintBiasedLockingStatistics) {
383     BiasedLocking::print_counters();
384   }
385 
386   // Native memory tracking data
387   if (PrintNMTStatistics) {
388     MemTracker::final_report(tty);
389   }
390 
391   if (LogTouchedMethods &amp;&amp; PrintTouchedMethodsAtExit) {
392     Method::print_touched_methods(tty);
</pre>
<hr />
<pre>
394 
395   ThreadsSMRSupport::log_statistics();
396 }
397 
398 #endif
399 
400 // Note: before_exit() can be executed only once, if more than one threads
401 //       are trying to shutdown the VM at the same time, only one thread
402 //       can run before_exit() and all other threads must wait.
403 void before_exit(JavaThread* thread) {
404   #define BEFORE_EXIT_NOT_RUN 0
405   #define BEFORE_EXIT_RUNNING 1
406   #define BEFORE_EXIT_DONE    2
407   static jint volatile _before_exit_status = BEFORE_EXIT_NOT_RUN;
408 
409   // Note: don&#39;t use a Mutex to guard the entire before_exit(), as
410   // JVMTI post_thread_end_event and post_vm_death_event will run native code.
411   // A CAS or OSMutex would work just fine but then we need to manipulate
412   // thread state for Safepoint. Here we use Monitor wait() and notify_all()
413   // for synchronization.
<span class="line-modified">414   { MonitorLocker ml(BeforeExit_lock);</span>
415     switch (_before_exit_status) {
416     case BEFORE_EXIT_NOT_RUN:
417       _before_exit_status = BEFORE_EXIT_RUNNING;
418       break;
419     case BEFORE_EXIT_RUNNING:
420       while (_before_exit_status == BEFORE_EXIT_RUNNING) {
<span class="line-modified">421         ml.wait();</span>
422       }
423       assert(_before_exit_status == BEFORE_EXIT_DONE, &quot;invalid state&quot;);
424       return;
425     case BEFORE_EXIT_DONE:
426       // need block to avoid SS compiler bug
427       {
428         return;
429       }
430     }
431   }
432 
433 #if INCLUDE_JVMCI
<span class="line-modified">434   JVMCI::shutdown();</span>








435 #endif
436 
437   // Hang forever on exit if we&#39;re reporting an error.
438   if (ShowMessageBoxOnError &amp;&amp; VMError::is_error_reported()) {
439     os::infinite_sleep();
440   }
441 
442   EventThreadEnd event;
443   if (event.should_commit()) {
444     event.set_thread(JFR_THREAD_ID(thread));
445     event.commit();
446   }
447 
448   JFR_ONLY(Jfr::on_vm_shutdown();)
449 
450   // Stop the WatcherThread. We do this before disenrolling various
451   // PeriodicTasks to reduce the likelihood of races.
452   if (PeriodicTask::num_tasks() &gt; 0) {
453     WatcherThread::stop();
454   }
</pre>
<hr />
<pre>
473     }
474   }
475 
476   if (PrintBytecodeHistogram) {
477     BytecodeHistogram::print();
478   }
479 
480   if (JvmtiExport::should_post_thread_life()) {
481     JvmtiExport::post_thread_end(thread);
482   }
483 
484   // Always call even when there are not JVMTI environments yet, since environments
485   // may be attached late and JVMTI must track phases of VM execution
486   JvmtiExport::post_vm_death();
487   Threads::shutdown_vm_agents();
488 
489   // Terminate the signal thread
490   // Note: we don&#39;t wait until it actually dies.
491   os::terminate_signal_thread();
492 
<span class="line-added">493 #if INCLUDE_CDS</span>
<span class="line-added">494   if (DynamicDumpSharedSpaces) {</span>
<span class="line-added">495     DynamicArchive::dump();</span>
<span class="line-added">496   }</span>
<span class="line-added">497 #endif</span>
<span class="line-added">498 </span>
499   print_statistics();
500   Universe::heap()-&gt;print_tracing_info();
501 
502   { MutexLocker ml(BeforeExit_lock);
503     _before_exit_status = BEFORE_EXIT_DONE;
504     BeforeExit_lock-&gt;notify_all();
505   }
506 
507   if (VerifyStringTableAtExit) {
508     size_t fail_cnt = StringTable::verify_and_compare_entries();
509     if (fail_cnt != 0) {
510       tty-&gt;print_cr(&quot;ERROR: fail_cnt=&quot; SIZE_FORMAT, fail_cnt);
511       guarantee(fail_cnt == 0, &quot;unexpected StringTable verification failures&quot;);
512     }
513   }
514 
515   #undef BEFORE_EXIT_NOT_RUN
516   #undef BEFORE_EXIT_RUNNING
517   #undef BEFORE_EXIT_DONE
518 }
519 
520 void vm_exit(int code) {
521   Thread* thread =
522       ThreadLocalStorage::is_initialized() ? Thread::current_or_null() : NULL;
523   if (thread == NULL) {
524     // very early initialization failure -- just exit
525     vm_direct_exit(code);
526   }
527 
<span class="line-added">528   // We&#39;d like to add an entry to the XML log to show that the VM is</span>
<span class="line-added">529   // terminating, but we can&#39;t safely do that here. The logic to make</span>
<span class="line-added">530   // XML termination logging safe is tied to the termination of the</span>
<span class="line-added">531   // VMThread, and it doesn&#39;t terminate on this exit path. See 8222534.</span>
<span class="line-added">532 </span>
533   if (VMThread::vm_thread() != NULL) {
<span class="line-added">534     if (thread-&gt;is_Java_thread()) {</span>
<span class="line-added">535       // We must be &quot;in_vm&quot; for the code below to work correctly.</span>
<span class="line-added">536       // Historically there must have been some exit path for which</span>
<span class="line-added">537       // that was not the case and so we set it explicitly - even</span>
<span class="line-added">538       // though we no longer know what that path may be.</span>
<span class="line-added">539       ((JavaThread*)thread)-&gt;set_thread_state(_thread_in_vm);</span>
<span class="line-added">540     }</span>
<span class="line-added">541 </span>
542     // Fire off a VM_Exit operation to bring VM to a safepoint and exit
543     VM_Exit op(code);
<span class="line-modified">544 </span>
<span class="line-modified">545     // 4945125 The vm thread comes to a safepoint during exit.</span>
<span class="line-added">546     // GC vm_operations can get caught at the safepoint, and the</span>
<span class="line-added">547     // heap is unparseable if they are caught. Grab the Heap_lock</span>
<span class="line-added">548     // to prevent this. The GC vm_operations will not be able to</span>
<span class="line-added">549     // queue until after we release it, but we never do that as we</span>
<span class="line-added">550     // are terminating the VM process.</span>
<span class="line-added">551     MutexLocker ml(Heap_lock);</span>
<span class="line-added">552 </span>
553     VMThread::execute(&amp;op);
554     // should never reach here; but in case something wrong with VM Thread.
555     vm_direct_exit(code);
556   } else {
557     // VM thread is gone, just exit
558     vm_direct_exit(code);
559   }
560   ShouldNotReachHere();
561 }
562 
563 void notify_vm_shutdown() {
564   // For now, just a dtrace probe.
565   HOTSPOT_VM_SHUTDOWN();
566   HS_DTRACE_WORKAROUND_TAIL_CALL_BUG();
567 }
568 
569 void vm_direct_exit(int code) {
570   notify_vm_shutdown();
571   os::wait_for_keypress_at_exit();
572   os::exit(code);
</pre>
<hr />
<pre>
673 
674   // Failure during initialization, we don&#39;t want to dump core
675   vm_abort(false);
676 }
677 
678 void vm_exit_during_initialization(const char* error, const char* message) {
679   vm_notify_during_shutdown(error, message);
680 
681   // Failure during initialization, we don&#39;t want to dump core
682   vm_abort(false);
683 }
684 
685 void vm_shutdown_during_initialization(const char* error, const char* message) {
686   vm_notify_during_shutdown(error, message);
687   vm_shutdown();
688 }
689 
690 JDK_Version JDK_Version::_current;
691 const char* JDK_Version::_runtime_name;
692 const char* JDK_Version::_runtime_version;
<span class="line-added">693 const char* JDK_Version::_runtime_vendor_version;</span>
<span class="line-added">694 const char* JDK_Version::_runtime_vendor_vm_bug_url;</span>
695 
696 void JDK_Version::initialize() {

697   assert(!_current.is_valid(), &quot;Don&#39;t initialize twice&quot;);
698 
<span class="line-modified">699   int major = VM_Version::vm_major_version();</span>
<span class="line-modified">700   int minor = VM_Version::vm_minor_version();</span>
<span class="line-modified">701   int security = VM_Version::vm_security_version();</span>
<span class="line-modified">702   int build = VM_Version::vm_build_number();</span>
<span class="line-modified">703   int patch = VM_Version::vm_patch_version();</span>
<span class="line-modified">704   _current = JDK_Version(major, minor, security, patch, build);</span>















705 }
706 
707 void JDK_Version_init() {
708   JDK_Version::initialize();
709 }
710 
711 static int64_t encode_jdk_version(const JDK_Version&amp; v) {
712   return
713     ((int64_t)v.major_version()          &lt;&lt; (BitsPerByte * 4)) |
714     ((int64_t)v.minor_version()          &lt;&lt; (BitsPerByte * 3)) |
715     ((int64_t)v.security_version()       &lt;&lt; (BitsPerByte * 2)) |
716     ((int64_t)v.patch_version()          &lt;&lt; (BitsPerByte * 1)) |
717     ((int64_t)v.build_number()           &lt;&lt; (BitsPerByte * 0));
718 }
719 
720 int JDK_Version::compare(const JDK_Version&amp; other) const {
721   assert(is_valid() &amp;&amp; other.is_valid(), &quot;Invalid version (uninitialized?)&quot;);
722   uint64_t e = encode_jdk_version(*this);
723   uint64_t o = encode_jdk_version(other);
724   return (e &gt; o) ? 1 : ((e == o) ? 0 : -1);
725 }
726 
<span class="line-added">727 /* See JEP 223 */</span>
728 void JDK_Version::to_string(char* buffer, size_t buflen) const {
729   assert(buffer &amp;&amp; buflen &gt; 0, &quot;call with useful buffer&quot;);
730   size_t index = 0;
731 
732   if (!is_valid()) {
733     jio_snprintf(buffer, buflen, &quot;%s&quot;, &quot;(uninitialized)&quot;);
734   } else {
735     int rc = jio_snprintf(
736         &amp;buffer[index], buflen - index, &quot;%d.%d&quot;, _major, _minor);
737     if (rc == -1) return;
738     index += rc;
<span class="line-modified">739     if (_patch &gt; 0) {</span>
<span class="line-modified">740       rc = jio_snprintf(&amp;buffer[index], buflen - index, &quot;.%d.%d&quot;, _security, _patch);</span>
741       if (rc == -1) return;
742       index += rc;
<span class="line-modified">743     } else if (_security &gt; 0) {</span>
<span class="line-modified">744       rc = jio_snprintf(&amp;buffer[index], buflen - index, &quot;.%d&quot;, _security);</span>

745       if (rc == -1) return;
746       index += rc;
747     }
748     if (_build &gt; 0) {
749       rc = jio_snprintf(&amp;buffer[index], buflen - index, &quot;+%d&quot;, _build);
750       if (rc == -1) return;
751       index += rc;
752     }
753   }
754 }
</pre>
</td>
</tr>
</table>
<center><a href="interfaceSupport.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="java.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
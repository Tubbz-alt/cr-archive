<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sweeper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/vmSymbols.hpp&quot;
  27 #include &quot;logging/log.hpp&quot;
  28 #include &quot;logging/logStream.hpp&quot;
  29 #include &quot;jfr/jfrEvents.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;memory/metaspaceShared.hpp&quot;
  32 #include &quot;memory/padded.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">  34 #include &quot;oops/markOop.hpp&quot;</span>

  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;runtime/atomic.hpp&quot;
  37 #include &quot;runtime/biasedLocking.hpp&quot;
  38 #include &quot;runtime/handles.inline.hpp&quot;
  39 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  40 #include &quot;runtime/mutexLocker.hpp&quot;
  41 #include &quot;runtime/objectMonitor.hpp&quot;
  42 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  43 #include &quot;runtime/osThread.hpp&quot;
  44 #include &quot;runtime/safepointVerifiers.hpp&quot;
  45 #include &quot;runtime/sharedRuntime.hpp&quot;
  46 #include &quot;runtime/stubRoutines.hpp&quot;
  47 #include &quot;runtime/synchronizer.hpp&quot;
  48 #include &quot;runtime/thread.inline.hpp&quot;
  49 #include &quot;runtime/timer.hpp&quot;
  50 #include &quot;runtime/vframe.hpp&quot;
  51 #include &quot;runtime/vmThread.hpp&quot;
  52 #include &quot;utilities/align.hpp&quot;
  53 #include &quot;utilities/dtrace.hpp&quot;
  54 #include &quot;utilities/events.hpp&quot;
</pre>
<hr />
<pre>
  99     }                                                                      \
 100   }
 101 
 102 #else //  ndef DTRACE_ENABLED
 103 
 104 #define DTRACE_MONITOR_WAIT_PROBE(obj, thread, millis, mon)    {;}
 105 #define DTRACE_MONITOR_PROBE(probe, obj, thread, mon)          {;}
 106 
 107 #endif // ndef DTRACE_ENABLED
 108 
 109 // This exists only as a workaround of dtrace bug 6254741
 110 int dtrace_waited_probe(ObjectMonitor* monitor, Handle obj, Thread* thr) {
 111   DTRACE_MONITOR_PROBE(waited, monitor, obj(), thr);
 112   return 0;
 113 }
 114 
 115 #define NINFLATIONLOCKS 256
 116 static volatile intptr_t gInflationLocks[NINFLATIONLOCKS];
 117 
 118 // global list of blocks of monitors
<span class="line-modified"> 119 PaddedEnd&lt;ObjectMonitor&gt; * volatile ObjectSynchronizer::gBlockList = NULL;</span>
<span class="line-modified"> 120 // global monitor free list</span>
<span class="line-modified"> 121 ObjectMonitor * volatile ObjectSynchronizer::gFreeList  = NULL;</span>
<span class="line-modified"> 122 // global monitor in-use list, for moribund threads,</span>
<span class="line-modified"> 123 // monitors they inflated need to be scanned for deflation</span>
<span class="line-modified"> 124 ObjectMonitor * volatile ObjectSynchronizer::gOmInUseList  = NULL;</span>
<span class="line-modified"> 125 // count of entries in gOmInUseList</span>
<span class="line-modified"> 126 int ObjectSynchronizer::gOmInUseCount = 0;</span>
<span class="line-modified"> 127 </span>
<span class="line-modified"> 128 static volatile intptr_t gListLock = 0;      // protects global monitor lists</span>
<span class="line-modified"> 129 static volatile int gMonitorFreeCount  = 0;  // # on gFreeList</span>
<span class="line-modified"> 130 static volatile int gMonitorPopulation = 0;  // # Extant -- in circulation</span>















 131 
 132 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 133 
 134 













































































































































































































































 135 // =====================&gt; Quick functions
 136 
 137 // The quick_* forms are special fast-path variants used to improve
 138 // performance.  In the simplest case, a &quot;quick_*&quot; implementation could
 139 // simply return false, in which case the caller will perform the necessary
 140 // state transitions and call the slow-path form.
 141 // The fast-path is designed to handle frequently arising cases in an efficient
 142 // manner and is just a degenerate &quot;optimistic&quot; variant of the slow-path.
 143 // returns true  -- to indicate the call was satisfied.
 144 // returns false -- to indicate the call needs the services of the slow-path.
 145 // A no-loitering ordinance is in effect for code in the quick_* family
 146 // operators: safepoints or indefinite blocking (blocking that might span a
 147 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 148 // entry.
 149 //
 150 // Consider: An interesting optimization is to have the JIT recognize the
 151 // following common idiom:
 152 //   synchronized (someobj) { .... ; notify(); }
 153 // That is, we find a notify() or notifyAll() call that immediately precedes
 154 // the monitorexit operation.  In that case the JIT could fuse the operations
 155 // into a single notifyAndExit() runtime primitive.
 156 
<span class="line-modified"> 157 bool ObjectSynchronizer::quick_notify(oopDesc * obj, Thread * self, bool all) {</span>
 158   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 159   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 160   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 161   NoSafepointVerifier nsv;
 162   if (obj == NULL) return false;  // slow-path for invalid obj
<span class="line-modified"> 163   const markOop mark = obj-&gt;mark();</span>
 164 
<span class="line-modified"> 165   if (mark-&gt;has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
 166     // Degenerate notify
 167     // stack-locked by caller so by definition the implied waitset is empty.
 168     return true;
 169   }
 170 
<span class="line-modified"> 171   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 172     ObjectMonitor * const mon = mark-&gt;monitor();</span>
<span class="line-modified"> 173     assert(oopDesc::equals((oop) mon-&gt;object(), obj), &quot;invariant&quot;);</span>
 174     if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
 175 
 176     if (mon-&gt;first_waiter() != NULL) {
 177       // We have one or more waiters. Since this is an inflated monitor
 178       // that we own, we can transfer one or more threads from the waitset
 179       // to the entrylist here and now, avoiding the slow-path.
 180       if (all) {
 181         DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
 182       } else {
 183         DTRACE_MONITOR_PROBE(notify, mon, obj, self);
 184       }
<span class="line-modified"> 185       int tally = 0;</span>
 186       do {
 187         mon-&gt;INotify(self);
<span class="line-modified"> 188         ++tally;</span>
 189       } while (mon-&gt;first_waiter() != NULL &amp;&amp; all);
<span class="line-modified"> 190       OM_PERFDATA_OP(Notifications, inc(tally));</span>
 191     }
 192     return true;
 193   }
 194 
 195   // biased locking and any other IMS exception states take the slow-path
 196   return false;
 197 }
 198 
 199 
 200 // The LockNode emitted directly at the synchronization site would have
 201 // been too big if it were to have included support for the cases of inflated
 202 // recursive enter and exit, so they go here instead.
 203 // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
 204 // quick_enter() as our thread state remains _in_Java.
 205 
<span class="line-modified"> 206 bool ObjectSynchronizer::quick_enter(oop obj, Thread * Self,</span>
 207                                      BasicLock * lock) {
 208   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified"> 209   assert(Self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-modified"> 210   assert(((JavaThread *) Self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);</span>
 211   NoSafepointVerifier nsv;
 212   if (obj == NULL) return false;       // Need to throw NPE
<span class="line-modified"> 213   const markOop mark = obj-&gt;mark();</span>
 214 
<span class="line-modified"> 215   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 216     ObjectMonitor * const m = mark-&gt;monitor();</span>
<span class="line-modified"> 217     assert(oopDesc::equals((oop) m-&gt;object(), obj), &quot;invariant&quot;);</span>
<span class="line-modified"> 218     Thread * const owner = (Thread *) m-&gt;_owner;</span>
 219 
 220     // Lock contention and Transactional Lock Elision (TLE) diagnostics
 221     // and observability
 222     // Case: light contention possibly amenable to TLE
 223     // Case: TLE inimical operations such as nested/recursive synchronization
 224 
<span class="line-modified"> 225     if (owner == Self) {</span>
 226       m-&gt;_recursions++;
 227       return true;
 228     }
 229 
 230     // This Java Monitor is inflated so obj&#39;s header will never be
 231     // displaced to this thread&#39;s BasicLock. Make the displaced header
 232     // non-NULL so this BasicLock is not seen as recursive nor as
 233     // being locked. We do this unconditionally so that this thread&#39;s
 234     // BasicLock cannot be mis-interpreted by any stack walkers. For
 235     // performance reasons, stack walkers generally first check for
 236     // Biased Locking in the object&#39;s header, the second check is for
 237     // stack-locking in the object&#39;s header, the third check is for
 238     // recursive stack-locking in the displaced header in the BasicLock,
 239     // and last are the inflated Java Monitor (ObjectMonitor) checks.
<span class="line-modified"> 240     lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span>
 241 
<span class="line-modified"> 242     if (owner == NULL &amp;&amp; Atomic::replace_if_null(Self, &amp;(m-&gt;_owner))) {</span>
 243       assert(m-&gt;_recursions == 0, &quot;invariant&quot;);
<span class="line-removed"> 244       assert(m-&gt;_owner == Self, &quot;invariant&quot;);</span>
 245       return true;
 246     }
 247   }
 248 
 249   // Note that we could inflate in quick_enter.
 250   // This is likely a useful optimization
 251   // Critically, in quick_enter() we must not:
 252   // -- perform bias revocation, or
 253   // -- block indefinitely, or
 254   // -- reach a safepoint
 255 
 256   return false;        // revert to slow-path
 257 }
 258 
 259 // -----------------------------------------------------------------------------
<span class="line-modified"> 260 //  Fast Monitor Enter/Exit</span>
<span class="line-modified"> 261 // This the fast monitor enter. The interpreter and compiler use</span>
<span class="line-modified"> 262 // some assembly copies of this code. Make sure update those code</span>
<span class="line-modified"> 263 // if the following function is changed. The implementation is</span>
<span class="line-modified"> 264 // extremely sensitive to race condition. Be careful.</span>
<span class="line-modified"> 265 </span>
<span class="line-removed"> 266 void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock,</span>
<span class="line-removed"> 267                                     bool attempt_rebias, TRAPS) {</span>
 268   if (UseBiasedLocking) {
 269     if (!SafepointSynchronize::is_at_safepoint()) {
<span class="line-modified"> 270       BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span>
<span class="line-removed"> 271       if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) {</span>
<span class="line-removed"> 272         return;</span>
<span class="line-removed"> 273       }</span>
 274     } else {
<span class="line-removed"> 275       assert(!attempt_rebias, &quot;can not rebias toward VM thread&quot;);</span>
 276       BiasedLocking::revoke_at_safepoint(obj);
 277     }
<span class="line-removed"> 278     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 279   }
 280 
<span class="line-modified"> 281   slow_enter(obj, lock, THREAD);</span>
























 282 }
 283 
<span class="line-modified"> 284 void ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) {</span>
<span class="line-modified"> 285   markOop mark = object-&gt;mark();</span>
 286   // We cannot check for Biased Locking if we are racing an inflation.
<span class="line-modified"> 287   assert(mark == markOopDesc::INFLATING() ||</span>
<span class="line-modified"> 288          !mark-&gt;has_bias_pattern(), &quot;should not see bias pattern here&quot;);</span>
 289 
<span class="line-modified"> 290   markOop dhw = lock-&gt;displaced_header();</span>
<span class="line-modified"> 291   if (dhw == NULL) {</span>
 292     // If the displaced header is NULL, then this exit matches up with
 293     // a recursive enter. No real work to do here except for diagnostics.
 294 #ifndef PRODUCT
<span class="line-modified"> 295     if (mark != markOopDesc::INFLATING()) {</span>
 296       // Only do diagnostics if we are not racing an inflation. Simply
 297       // exiting a recursive enter of a Java Monitor that is being
 298       // inflated is safe; see the has_monitor() comment below.
<span class="line-modified"> 299       assert(!mark-&gt;is_neutral(), &quot;invariant&quot;);</span>
<span class="line-modified"> 300       assert(!mark-&gt;has_locker() ||</span>
<span class="line-modified"> 301              THREAD-&gt;is_lock_owned((address)mark-&gt;locker()), &quot;invariant&quot;);</span>
<span class="line-modified"> 302       if (mark-&gt;has_monitor()) {</span>
 303         // The BasicLock&#39;s displaced_header is marked as a recursive
 304         // enter and we have an inflated Java Monitor (ObjectMonitor).
 305         // This is a special case where the Java Monitor was inflated
 306         // after this thread entered the stack-lock recursively. When a
 307         // Java Monitor is inflated, we cannot safely walk the Java
 308         // Monitor owner&#39;s stack and update the BasicLocks because a
 309         // Java Monitor can be asynchronously inflated by a thread that
 310         // does not own the Java Monitor.
<span class="line-modified"> 311         ObjectMonitor * m = mark-&gt;monitor();</span>
 312         assert(((oop)(m-&gt;object()))-&gt;mark() == mark, &quot;invariant&quot;);
 313         assert(m-&gt;is_entered(THREAD), &quot;invariant&quot;);
 314       }
 315     }
 316 #endif
 317     return;
 318   }
 319 
<span class="line-modified"> 320   if (mark == (markOop) lock) {</span>
 321     // If the object is stack-locked by the current thread, try to
 322     // swing the displaced header from the BasicLock back to the mark.
<span class="line-modified"> 323     assert(dhw-&gt;is_neutral(), &quot;invariant&quot;);</span>
 324     if (object-&gt;cas_set_mark(dhw, mark) == mark) {
 325       return;
 326     }
 327   }
 328 
 329   // We have to take the slow-path of possible inflation and then exit.
 330   inflate(THREAD, object, inflate_cause_vm_internal)-&gt;exit(true, THREAD);
 331 }
 332 
<span class="line-removed"> 333 // -----------------------------------------------------------------------------</span>
<span class="line-removed"> 334 // Interpreter/Compiler Slow Case</span>
<span class="line-removed"> 335 // This routine is used to handle interpreter/compiler slow case</span>
<span class="line-removed"> 336 // We don&#39;t need to use fast path here, because it must have been</span>
<span class="line-removed"> 337 // failed in the interpreter/compiler code.</span>
<span class="line-removed"> 338 void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {</span>
<span class="line-removed"> 339   markOop mark = obj-&gt;mark();</span>
<span class="line-removed"> 340   assert(!mark-&gt;has_bias_pattern(), &quot;should not see bias pattern here&quot;);</span>
<span class="line-removed"> 341 </span>
<span class="line-removed"> 342   if (mark-&gt;is_neutral()) {</span>
<span class="line-removed"> 343     // Anticipate successful CAS -- the ST of the displaced mark must</span>
<span class="line-removed"> 344     // be visible &lt;= the ST performed by the CAS.</span>
<span class="line-removed"> 345     lock-&gt;set_displaced_header(mark);</span>
<span class="line-removed"> 346     if (mark == obj()-&gt;cas_set_mark((markOop) lock, mark)) {</span>
<span class="line-removed"> 347       return;</span>
<span class="line-removed"> 348     }</span>
<span class="line-removed"> 349     // Fall through to inflate() ...</span>
<span class="line-removed"> 350   } else if (mark-&gt;has_locker() &amp;&amp;</span>
<span class="line-removed"> 351              THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
<span class="line-removed"> 352     assert(lock != mark-&gt;locker(), &quot;must not re-lock the same lock&quot;);</span>
<span class="line-removed"> 353     assert(lock != (BasicLock*)obj-&gt;mark(), &quot;don&#39;t relock with same BasicLock&quot;);</span>
<span class="line-removed"> 354     lock-&gt;set_displaced_header(NULL);</span>
<span class="line-removed"> 355     return;</span>
<span class="line-removed"> 356   }</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358   // The object header will never be displaced to this lock,</span>
<span class="line-removed"> 359   // so it does not matter what the value is, except that it</span>
<span class="line-removed"> 360   // must be non-zero to avoid looking like a re-entrant lock,</span>
<span class="line-removed"> 361   // and must not look locked either.</span>
<span class="line-removed"> 362   lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span>
<span class="line-removed"> 363   inflate(THREAD, obj(), inflate_cause_monitor_enter)-&gt;enter(THREAD);</span>
<span class="line-removed"> 364 }</span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366 // This routine is used to handle interpreter/compiler slow case</span>
<span class="line-removed"> 367 // We don&#39;t need to use fast path here, because it must have</span>
<span class="line-removed"> 368 // failed in the interpreter/compiler code. Simply use the heavy</span>
<span class="line-removed"> 369 // weight monitor should be ok, unless someone find otherwise.</span>
<span class="line-removed"> 370 void ObjectSynchronizer::slow_exit(oop object, BasicLock* lock, TRAPS) {</span>
<span class="line-removed"> 371   fast_exit(object, lock, THREAD);</span>
<span class="line-removed"> 372 }</span>
<span class="line-removed"> 373 </span>
 374 // -----------------------------------------------------------------------------
 375 // Class Loader  support to workaround deadlocks on the class loader lock objects
 376 // Also used by GC
 377 // complete_exit()/reenter() are used to wait on a nested lock
 378 // i.e. to give up an outer lock completely and then re-enter
 379 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 380 //  1) complete_exit lock1 - saving recursion count
 381 //  2) wait on lock2
 382 //  3) when notified on lock2, unlock lock2
 383 //  4) reenter lock1 with original recursion count
 384 //  5) lock lock2
 385 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 386 // NOTE(TSAN): We cannot instrument complete_exit/reenter in ObjectSynchronizer
 387 //             in a manner similar to wait and waitUninterruptibly, because
 388 //             (1) recursion count stored by inflated monitor is different from
 389 //             the absolute recursion count tracked by Tsan, and (2) in the
 390 //             general case, we cannot merely store Tsan&#39;s recursion count
 391 //             once: we must track it for *each invocation* of complete_exit.
 392 //             Hence, the best place to instrument for Tsan is at the call site
 393 //             for complete_exit/reenter. Luckily, there is only one call site.
<span class="line-modified"> 394 intptr_t ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {</span>
 395   if (UseBiasedLocking) {
<span class="line-modified"> 396     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 397     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 398   }
 399 
 400   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 401 
 402   return monitor-&gt;complete_exit(THREAD);
 403 }
 404 
 405 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
<span class="line-modified"> 406 void ObjectSynchronizer::reenter(Handle obj, intptr_t recursion, TRAPS) {</span>
 407   if (UseBiasedLocking) {
<span class="line-modified"> 408     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 409     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 410   }
 411 
 412   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 413 
<span class="line-modified"> 414   monitor-&gt;reenter(recursion, THREAD);</span>
 415 }
 416 // -----------------------------------------------------------------------------
 417 // JNI locks on java objects
 418 // NOTE: must use heavy weight monitor to handle jni monitor enter
 419 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 420   // the current locking is from JNI instead of Java code
 421   if (UseBiasedLocking) {
<span class="line-modified"> 422     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 423     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 424   }
 425   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 426   inflate(THREAD, obj(), inflate_cause_jni_enter)-&gt;enter(THREAD);
 427   THREAD-&gt;set_current_pending_monitor_is_from_java(true);
 428   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(THREAD, obj()));
 429 }
 430 
 431 // NOTE: must use heavy weight monitor to handle jni monitor exit
 432 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
 433   if (UseBiasedLocking) {
 434     Handle h_obj(THREAD, obj);
<span class="line-modified"> 435     BiasedLocking::revoke_and_rebias(h_obj, false, THREAD);</span>
 436     obj = h_obj();
 437   }
<span class="line-modified"> 438   assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 439 
 440   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
<span class="line-modified"> 441   // If this thread has locked the object, exit the monitor.  Note:  can&#39;t use</span>
<span class="line-modified"> 442   // monitor-&gt;check(CHECK); must exit even if an exception is pending.</span>
<span class="line-modified"> 443   if (monitor-&gt;check(THREAD)) {</span>

 444     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(THREAD, obj));
 445     monitor-&gt;exit(true, THREAD);
 446   }
 447 }
 448 
 449 // -----------------------------------------------------------------------------
 450 // Internal VM locks on java objects
 451 // standard constructor, allows locking failures
<span class="line-modified"> 452 ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool doLock) {</span>
<span class="line-modified"> 453   _dolock = doLock;</span>
 454   _thread = thread;
<span class="line-modified"> 455   debug_only(if (StrictSafepointChecks) _thread-&gt;check_for_valid_safepoint_state(false);)</span>
 456   _obj = obj;
 457 
 458   if (_dolock) {
<span class="line-modified"> 459     ObjectSynchronizer::fast_enter(_obj, &amp;_lock, false, _thread);</span>
 460     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));
 461   }
 462 }
 463 
 464 ObjectLocker::~ObjectLocker() {
 465   if (_dolock) {
 466     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));
<span class="line-modified"> 467     ObjectSynchronizer::fast_exit(_obj(), &amp;_lock, _thread);</span>
 468   }
 469 }
 470 
 471 
 472 // -----------------------------------------------------------------------------
 473 //  Wait/Notify/NotifyAll
 474 // NOTE: must use heavy weight monitor to handle wait()
 475 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
 476   if (UseBiasedLocking) {
<span class="line-modified"> 477     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 478     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 479   }
 480   if (millis &lt; 0) {
 481     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 482   }
 483   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 484 
 485   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
 486 
 487   TSAN_ONLY(int tsan_rec = 0;)
 488   TSAN_RUNTIME_ONLY(
 489     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());
 490     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);
 491   );
 492 
 493   monitor-&gt;wait(millis, true, THREAD);
 494 
 495   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));
 496 
 497   // This dummy call is in place to get around dtrace bug 6254741.  Once
 498   // that&#39;s fixed we can uncomment the following line, remove the call
 499   // and change this function back into a &quot;void&quot; func.
 500   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 501   return dtrace_waited_probe(monitor, obj, THREAD);
 502 }
 503 
<span class="line-modified"> 504 void ObjectSynchronizer::waitUninterruptibly(Handle obj, jlong millis, TRAPS) {</span>
 505   if (UseBiasedLocking) {
<span class="line-modified"> 506     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 507     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 508   }
 509   if (millis &lt; 0) {
 510     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 511   }
 512   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 513   TSAN_ONLY(int tsan_rec;)
 514   TSAN_RUNTIME_ONLY(
 515     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());
 516     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);
 517   );
 518   monitor-&gt;wait(millis, false, THREAD);
 519   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));
 520 }
 521 
 522 void ObjectSynchronizer::notify(Handle obj, TRAPS) {
 523   if (UseBiasedLocking) {
<span class="line-modified"> 524     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 525     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 526   }
 527 
<span class="line-modified"> 528   markOop mark = obj-&gt;mark();</span>
<span class="line-modified"> 529   if (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
 530     return;
 531   }
 532   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notify(THREAD);
 533 }
 534 
 535 // NOTE: see comment of notify()
 536 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
 537   if (UseBiasedLocking) {
<span class="line-modified"> 538     BiasedLocking::revoke_and_rebias(obj, false, THREAD);</span>
<span class="line-modified"> 539     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 540   }
 541 
<span class="line-modified"> 542   markOop mark = obj-&gt;mark();</span>
<span class="line-modified"> 543   if (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
 544     return;
 545   }
 546   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notifyAll(THREAD);
 547 }
 548 
 549 // -----------------------------------------------------------------------------
 550 // Hash Code handling
 551 //
 552 // Performance concern:
 553 // OrderAccess::storestore() calls release() which at one time stored 0
 554 // into the global volatile OrderAccess::dummy variable. This store was
 555 // unnecessary for correctness. Many threads storing into a common location
 556 // causes considerable cache migration or &quot;sloshing&quot; on large SMP systems.
 557 // As such, I avoided using OrderAccess::storestore(). In some cases
 558 // OrderAccess::fence() -- which incurs local latency on the executing
 559 // processor -- is a better choice as it scales on SMP systems.
 560 //
 561 // See http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot for
 562 // a discussion of coherency costs. Note that all our current reference
 563 // platforms provide strong ST-ST order, so the issue is moot on IA32,
 564 // x64, and SPARC.
 565 //
 566 // As a general policy we use &quot;volatile&quot; to control compiler-based reordering
 567 // and explicit fences (barriers) to control for architectural reordering
 568 // performed by the CPU(s) or platform.
 569 
 570 struct SharedGlobals {
<span class="line-modified"> 571   char         _pad_prefix[DEFAULT_CACHE_LINE_SIZE];</span>
 572   // These are highly shared mostly-read variables.
 573   // To avoid false-sharing they need to be the sole occupants of a cache line.
<span class="line-modified"> 574   volatile int stwRandom;</span>
<span class="line-modified"> 575   volatile int stwCycle;</span>
<span class="line-modified"> 576   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int) * 2);</span>
 577   // Hot RW variable -- Sequester to avoid false-sharing
<span class="line-modified"> 578   volatile int hcSequence;</span>
<span class="line-modified"> 579   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int));</span>
 580 };
 581 
 582 static SharedGlobals GVars;
<span class="line-modified"> 583 static int MonitorScavengeThreshold = 1000000;</span>
<span class="line-removed"> 584 static volatile int ForceMonitorScavenge = 0; // Scavenge required and pending</span>
 585 
<span class="line-modified"> 586 static markOop ReadStableMark(oop obj) {</span>
<span class="line-modified"> 587   markOop mark = obj-&gt;mark();</span>
<span class="line-modified"> 588   if (!mark-&gt;is_being_inflated()) {</span>
 589     return mark;       // normal fast-path return
 590   }
 591 
 592   int its = 0;
 593   for (;;) {
<span class="line-modified"> 594     markOop mark = obj-&gt;mark();</span>
<span class="line-modified"> 595     if (!mark-&gt;is_being_inflated()) {</span>
 596       return mark;    // normal fast-path return
 597     }
 598 
 599     // The object is being inflated by some other thread.
<span class="line-modified"> 600     // The caller of ReadStableMark() must wait for inflation to complete.</span>
 601     // Avoid live-lock
 602     // TODO: consider calling SafepointSynchronize::do_call_back() while
 603     // spinning to see if there&#39;s a safepoint pending.  If so, immediately
 604     // yielding or blocking would be appropriate.  Avoid spinning while
 605     // there is a safepoint pending.
 606     // TODO: add inflation contention performance counters.
 607     // TODO: restrict the aggregate number of spinners.
 608 
 609     ++its;
 610     if (its &gt; 10000 || !os::is_MP()) {
 611       if (its &amp; 1) {
 612         os::naked_yield();
 613       } else {
 614         // Note that the following code attenuates the livelock problem but is not
 615         // a complete remedy.  A more complete solution would require that the inflating
 616         // thread hold the associated inflation lock.  The following code simply restricts
 617         // the number of spinners to at most one.  We&#39;ll have N-2 threads blocked
 618         // on the inflationlock, 1 thread holding the inflation lock and using
 619         // a yield/park strategy, and 1 thread in the midst of inflation.
 620         // A more refined approach would be to change the encoding of INFLATING
 621         // to allow encapsulation of a native thread pointer.  Threads waiting for
 622         // inflation to complete would use CAS to push themselves onto a singly linked
 623         // list rooted at the markword.  Once enqueued, they&#39;d loop, checking a per-thread flag
 624         // and calling park().  When inflation was complete the thread that accomplished inflation
 625         // would detach the list and set the markword to inflated with a single CAS and
 626         // then for each thread on the list, set the flag and unpark() the thread.
 627         // This is conceptually similar to muxAcquire-muxRelease, except that muxRelease
 628         // wakes at most one thread whereas we need to wake the entire list.
 629         int ix = (cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 5) &amp; (NINFLATIONLOCKS-1);
 630         int YieldThenBlock = 0;
 631         assert(ix &gt;= 0 &amp;&amp; ix &lt; NINFLATIONLOCKS, &quot;invariant&quot;);
 632         assert((NINFLATIONLOCKS &amp; (NINFLATIONLOCKS-1)) == 0, &quot;invariant&quot;);
 633         Thread::muxAcquire(gInflationLocks + ix, &quot;gInflationLock&quot;);
<span class="line-modified"> 634         while (obj-&gt;mark() == markOopDesc::INFLATING()) {</span>
 635           // Beware: NakedYield() is advisory and has almost no effect on some platforms
<span class="line-modified"> 636           // so we periodically call Self-&gt;_ParkEvent-&gt;park(1).</span>
 637           // We use a mixed spin/yield/block mechanism.
 638           if ((YieldThenBlock++) &gt;= 16) {
 639             Thread::current()-&gt;_ParkEvent-&gt;park(1);
 640           } else {
 641             os::naked_yield();
 642           }
 643         }
 644         Thread::muxRelease(gInflationLocks + ix);
 645       }
 646     } else {
 647       SpinPause();       // SMP-polite spinning
 648     }
 649   }
 650 }
 651 
 652 // hashCode() generation :
 653 //
 654 // Possibilities:
<span class="line-modified"> 655 // * MD5Digest of {obj,stwRandom}</span>
<span class="line-modified"> 656 // * CRC32 of {obj,stwRandom} or any linear-feedback shift register function.</span>
 657 // * A DES- or AES-style SBox[] mechanism
 658 // * One of the Phi-based schemes, such as:
 659 //   2654435761 = 2^32 * Phi (golden ratio)
<span class="line-modified"> 660 //   HashCodeValue = ((uintptr_t(obj) &gt;&gt; 3) * 2654435761) ^ GVars.stwRandom ;</span>
 661 // * A variation of Marsaglia&#39;s shift-xor RNG scheme.
<span class="line-modified"> 662 // * (obj ^ stwRandom) is appealing, but can result</span>
 663 //   in undesirable regularity in the hashCode values of adjacent objects
 664 //   (objects allocated back-to-back, in particular).  This could potentially
 665 //   result in hashtable collisions and reduced hashtable efficiency.
 666 //   There are simple ways to &quot;diffuse&quot; the middle address bits over the
 667 //   generated hashCode values:
 668 
<span class="line-modified"> 669 static inline intptr_t get_next_hash(Thread * Self, oop obj) {</span>
 670   intptr_t value = 0;
 671   if (hashCode == 0) {
 672     // This form uses global Park-Miller RNG.
 673     // On MP system we&#39;ll have lots of RW access to a global, so the
 674     // mechanism induces lots of coherency traffic.
 675     value = os::random();
 676   } else if (hashCode == 1) {
 677     // This variation has the property of being stable (idempotent)
 678     // between STW operations.  This can be useful in some of the 1-0
 679     // synchronization schemes.
<span class="line-modified"> 680     intptr_t addrBits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3;</span>
<span class="line-modified"> 681     value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom;</span>
 682   } else if (hashCode == 2) {
 683     value = 1;            // for sensitivity testing
 684   } else if (hashCode == 3) {
<span class="line-modified"> 685     value = ++GVars.hcSequence;</span>
 686   } else if (hashCode == 4) {
 687     value = cast_from_oop&lt;intptr_t&gt;(obj);
 688   } else {
 689     // Marsaglia&#39;s xor-shift scheme with thread-specific state
 690     // This is probably the best overall implementation -- we&#39;ll
 691     // likely make this the default in future releases.
<span class="line-modified"> 692     unsigned t = Self-&gt;_hashStateX;</span>
 693     t ^= (t &lt;&lt; 11);
<span class="line-modified"> 694     Self-&gt;_hashStateX = Self-&gt;_hashStateY;</span>
<span class="line-modified"> 695     Self-&gt;_hashStateY = Self-&gt;_hashStateZ;</span>
<span class="line-modified"> 696     Self-&gt;_hashStateZ = Self-&gt;_hashStateW;</span>
<span class="line-modified"> 697     unsigned v = Self-&gt;_hashStateW;</span>
 698     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
<span class="line-modified"> 699     Self-&gt;_hashStateW = v;</span>
 700     value = v;
 701   }
 702 
<span class="line-modified"> 703   value &amp;= markOopDesc::hash_mask;</span>
 704   if (value == 0) value = 0xBAD;
<span class="line-modified"> 705   assert(value != markOopDesc::no_hash, &quot;invariant&quot;);</span>
 706   return value;
 707 }
 708 
<span class="line-modified"> 709 intptr_t ObjectSynchronizer::FastHashCode(Thread * Self, oop obj) {</span>
 710   if (UseBiasedLocking) {
 711     // NOTE: many places throughout the JVM do not expect a safepoint
 712     // to be taken here, in particular most operations on perm gen
 713     // objects. However, we only ever bias Java instances and all of
 714     // the call sites of identity_hash that might revoke biases have
 715     // been checked to make sure they can handle a safepoint. The
 716     // added check of the bias pattern is to avoid useless calls to
 717     // thread-local storage.
<span class="line-modified"> 718     if (obj-&gt;mark()-&gt;has_bias_pattern()) {</span>
 719       // Handle for oop obj in case of STW safepoint
<span class="line-modified"> 720       Handle hobj(Self, obj);</span>
 721       // Relaxing assertion for bug 6320749.
 722       assert(Universe::verify_in_progress() ||
 723              !SafepointSynchronize::is_at_safepoint(),
 724              &quot;biases should not be seen by VM thread here&quot;);
<span class="line-modified"> 725       BiasedLocking::revoke_and_rebias(hobj, false, JavaThread::current());</span>
 726       obj = hobj();
<span class="line-modified"> 727       assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 728     }
 729   }
 730 
 731   // hashCode() is a heap mutator ...
 732   // Relaxing assertion for bug 6320749.
 733   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
 734          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 735   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
<span class="line-modified"> 736          Self-&gt;is_Java_thread() , &quot;invariant&quot;);</span>
 737   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
<span class="line-modified"> 738          ((JavaThread *)Self)-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);</span>
 739 
 740   ObjectMonitor* monitor = NULL;
<span class="line-modified"> 741   markOop temp, test;</span>
 742   intptr_t hash;
<span class="line-modified"> 743   markOop mark = ReadStableMark(obj);</span>
 744 
 745   // object should remain ineligible for biased locking
<span class="line-modified"> 746   assert(!mark-&gt;has_bias_pattern(), &quot;invariant&quot;);</span>
 747 
<span class="line-modified"> 748   if (mark-&gt;is_neutral()) {</span>
<span class="line-modified"> 749     hash = mark-&gt;hash();              // this is a normal header</span>
<span class="line-modified"> 750     if (hash != 0) {                  // if it has hash, just return it</span>
 751       return hash;
 752     }
<span class="line-modified"> 753     hash = get_next_hash(Self, obj);  // allocate a new hash code</span>
<span class="line-modified"> 754     temp = mark-&gt;copy_set_hash(hash); // merge the hash code into header</span>
<span class="line-modified"> 755     // use (machine word version) atomic operation to install the hash</span>
 756     test = obj-&gt;cas_set_mark(temp, mark);
<span class="line-modified"> 757     if (test == mark) {</span>
 758       return hash;
 759     }
<span class="line-modified"> 760     // If atomic operation failed, we must inflate the header</span>
<span class="line-modified"> 761     // into heavy weight monitor. We could add more code here</span>
<span class="line-modified"> 762     // for fast path, but it does not worth the complexity.</span>
<span class="line-modified"> 763   } else if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 764     monitor = mark-&gt;monitor();</span>

 765     temp = monitor-&gt;header();
<span class="line-modified"> 766     assert(temp-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)temp));</span>
<span class="line-modified"> 767     hash = temp-&gt;hash();</span>
<span class="line-modified"> 768     if (hash != 0) {</span>
 769       return hash;
 770     }
<span class="line-modified"> 771     // Skip to the following code to reduce code size</span>
<span class="line-modified"> 772   } else if (Self-&gt;is_lock_owned((address)mark-&gt;locker())) {</span>
<span class="line-modified"> 773     temp = mark-&gt;displaced_mark_helper(); // this is a lightweight monitor owned</span>
<span class="line-modified"> 774     assert(temp-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)temp));</span>
<span class="line-modified"> 775     hash = temp-&gt;hash();              // by current thread, check if the displaced</span>
<span class="line-modified"> 776     if (hash != 0) {                  // header contains hash code</span>



 777       return hash;
 778     }
 779     // WARNING:
<span class="line-modified"> 780     //   The displaced header is strictly immutable.</span>
<span class="line-modified"> 781     // It can NOT be changed in ANY cases. So we have</span>
<span class="line-modified"> 782     // to inflate the header into heavyweight monitor</span>
<span class="line-modified"> 783     // even the current thread owns the lock. The reason</span>
<span class="line-modified"> 784     // is the BasicLock (stack slot) will be asynchronously</span>
<span class="line-modified"> 785     // read by other threads during the inflate() function.</span>
<span class="line-modified"> 786     // Any change to stack may not propagate to other threads</span>
<span class="line-modified"> 787     // correctly.</span>
<span class="line-modified"> 788   }</span>
<span class="line-modified"> 789 </span>
<span class="line-modified"> 790   // Inflate the monitor to set hash code</span>
<span class="line-modified"> 791   monitor = inflate(Self, obj, inflate_cause_hash_code);</span>
<span class="line-removed"> 792   // Load displaced header and check it has hash code</span>
 793   mark = monitor-&gt;header();
<span class="line-modified"> 794   assert(mark-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)mark));</span>
<span class="line-modified"> 795   hash = mark-&gt;hash();</span>
<span class="line-modified"> 796   if (hash == 0) {</span>
<span class="line-modified"> 797     hash = get_next_hash(Self, obj);</span>
<span class="line-modified"> 798     temp = mark-&gt;copy_set_hash(hash); // merge hash code into header</span>
<span class="line-modified"> 799     assert(temp-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)temp));</span>
<span class="line-modified"> 800     test = Atomic::cmpxchg(temp, monitor-&gt;header_addr(), mark);</span>

 801     if (test != mark) {
<span class="line-modified"> 802       // The only update to the header in the monitor (outside GC)</span>
<span class="line-modified"> 803       // is install the hash code. If someone add new usage of</span>
<span class="line-modified"> 804       // displaced header, please update this code</span>
<span class="line-modified"> 805       hash = test-&gt;hash();</span>
<span class="line-modified"> 806       assert(test-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)test));</span>
<span class="line-modified"> 807       assert(hash != 0, &quot;Trivial unexpected object/monitor header usage.&quot;);</span>


 808     }
 809   }
<span class="line-modified"> 810   // We finally get the hash</span>
 811   return hash;
 812 }
 813 
 814 // Deprecated -- use FastHashCode() instead.
 815 
 816 intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) {
 817   return FastHashCode(Thread::current(), obj());
 818 }
 819 
 820 
 821 bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
 822                                                    Handle h_obj) {
 823   if (UseBiasedLocking) {
<span class="line-modified"> 824     BiasedLocking::revoke_and_rebias(h_obj, false, thread);</span>
<span class="line-modified"> 825     assert(!h_obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 826   }
 827 
 828   assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
 829   oop obj = h_obj();
 830 
<span class="line-modified"> 831   markOop mark = ReadStableMark(obj);</span>
 832 
 833   // Uncontended case, header points to stack
<span class="line-modified"> 834   if (mark-&gt;has_locker()) {</span>
<span class="line-modified"> 835     return thread-&gt;is_lock_owned((address)mark-&gt;locker());</span>
 836   }
 837   // Contended case, header points to ObjectMonitor (tagged pointer)
<span class="line-modified"> 838   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 839     ObjectMonitor* monitor = mark-&gt;monitor();</span>
 840     return monitor-&gt;is_entered(thread) != 0;
 841   }
 842   // Unlocked case, header in place
<span class="line-modified"> 843   assert(mark-&gt;is_neutral(), &quot;sanity check&quot;);</span>
 844   return false;
 845 }
 846 
 847 // Be aware of this method could revoke bias of the lock object.
 848 // This method queries the ownership of the lock handle specified by &#39;h_obj&#39;.
 849 // If the current thread owns the lock, it returns owner_self. If no
 850 // thread owns the lock, it returns owner_none. Otherwise, it will return
 851 // owner_other.
 852 ObjectSynchronizer::LockOwnership ObjectSynchronizer::query_lock_ownership
 853 (JavaThread *self, Handle h_obj) {
 854   // The caller must beware this method can revoke bias, and
 855   // revocation can result in a safepoint.
 856   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 857   assert(self-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);
 858 
 859   // Possible mark states: neutral, biased, stack-locked, inflated
 860 
<span class="line-modified"> 861   if (UseBiasedLocking &amp;&amp; h_obj()-&gt;mark()-&gt;has_bias_pattern()) {</span>
 862     // CASE: biased
<span class="line-modified"> 863     BiasedLocking::revoke_and_rebias(h_obj, false, self);</span>
<span class="line-modified"> 864     assert(!h_obj-&gt;mark()-&gt;has_bias_pattern(),</span>
 865            &quot;biases should be revoked by now&quot;);
 866   }
 867 
 868   assert(self == JavaThread::current(), &quot;Can only be called on current thread&quot;);
 869   oop obj = h_obj();
<span class="line-modified"> 870   markOop mark = ReadStableMark(obj);</span>
 871 
 872   // CASE: stack-locked.  Mark points to a BasicLock on the owner&#39;s stack.
<span class="line-modified"> 873   if (mark-&gt;has_locker()) {</span>
<span class="line-modified"> 874     return self-&gt;is_lock_owned((address)mark-&gt;locker()) ?</span>
 875       owner_self : owner_other;
 876   }
 877 
 878   // CASE: inflated. Mark (tagged pointer) points to an ObjectMonitor.
 879   // The Object:ObjectMonitor relationship is stable as long as we&#39;re
 880   // not at a safepoint.
<span class="line-modified"> 881   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 882     void * owner = mark-&gt;monitor()-&gt;_owner;</span>
 883     if (owner == NULL) return owner_none;
 884     return (owner == self ||
 885             self-&gt;is_lock_owned((address)owner)) ? owner_self : owner_other;
 886   }
 887 
 888   // CASE: neutral
<span class="line-modified"> 889   assert(mark-&gt;is_neutral(), &quot;sanity check&quot;);</span>
 890   return owner_none;           // it&#39;s unlocked
 891 }
 892 
 893 // FIXME: jvmti should call this
 894 JavaThread* ObjectSynchronizer::get_lock_owner(ThreadsList * t_list, Handle h_obj) {
 895   if (UseBiasedLocking) {
 896     if (SafepointSynchronize::is_at_safepoint()) {
 897       BiasedLocking::revoke_at_safepoint(h_obj);
 898     } else {
<span class="line-modified"> 899       BiasedLocking::revoke_and_rebias(h_obj, false, JavaThread::current());</span>
 900     }
<span class="line-modified"> 901     assert(!h_obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 902   }
 903 
 904   oop obj = h_obj();
 905   address owner = NULL;
 906 
<span class="line-modified"> 907   markOop mark = ReadStableMark(obj);</span>
 908 
 909   // Uncontended case, header points to stack
<span class="line-modified"> 910   if (mark-&gt;has_locker()) {</span>
<span class="line-modified"> 911     owner = (address) mark-&gt;locker();</span>
 912   }
 913 
 914   // Contended case, header points to ObjectMonitor (tagged pointer)
<span class="line-modified"> 915   else if (mark-&gt;has_monitor()) {</span>
<span class="line-modified"> 916     ObjectMonitor* monitor = mark-&gt;monitor();</span>
 917     assert(monitor != NULL, &quot;monitor should be non-null&quot;);
 918     owner = (address) monitor-&gt;owner();
 919   }
 920 
 921   if (owner != NULL) {
 922     // owning_thread_from_monitor_owner() may also return NULL here
 923     return Threads::owning_thread_from_monitor_owner(t_list, owner);
 924   }
 925 
 926   // Unlocked case, header in place
 927   // Cannot have assertion since this object may have been
 928   // locked by another thread when reaching here.
<span class="line-modified"> 929   // assert(mark-&gt;is_neutral(), &quot;sanity check&quot;);</span>
 930 
 931   return NULL;
 932 }
 933 
 934 // Visitors ...
 935 
 936 void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure) {
<span class="line-modified"> 937   PaddedEnd&lt;ObjectMonitor&gt; * block = OrderAccess::load_acquire(&amp;gBlockList);</span>
 938   while (block != NULL) {
 939     assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
 940     for (int i = _BLOCKSIZE - 1; i &gt; 0; i--) {
 941       ObjectMonitor* mid = (ObjectMonitor *)(block + i);
 942       oop object = (oop)mid-&gt;object();
 943       if (object != NULL) {

 944         closure-&gt;do_monitor(mid);
 945       }
 946     }
<span class="line-modified"> 947     block = (PaddedEnd&lt;ObjectMonitor&gt; *)block-&gt;FreeNext;</span>


 948   }
 949 }
 950 
<span class="line-removed"> 951 // Get the next block in the block list.</span>
<span class="line-removed"> 952 static inline PaddedEnd&lt;ObjectMonitor&gt;* next(PaddedEnd&lt;ObjectMonitor&gt;* block) {</span>
<span class="line-removed"> 953   assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);</span>
<span class="line-removed"> 954   block = (PaddedEnd&lt;ObjectMonitor&gt;*) block-&gt;FreeNext;</span>
<span class="line-removed"> 955   assert(block == NULL || block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);</span>
<span class="line-removed"> 956   return block;</span>
<span class="line-removed"> 957 }</span>
<span class="line-removed"> 958 </span>
 959 static bool monitors_used_above_threshold() {
<span class="line-modified"> 960   if (gMonitorPopulation == 0) {</span>

 961     return false;
 962   }
<span class="line-modified"> 963   int monitors_used = gMonitorPopulation - gMonitorFreeCount;</span>
<span class="line-modified"> 964   int monitor_usage = (monitors_used * 100LL) / gMonitorPopulation;</span>
<span class="line-modified"> 965   return monitor_usage &gt; MonitorUsedDeflationThreshold;</span>










 966 }
 967 
 968 bool ObjectSynchronizer::is_cleanup_needed() {
<span class="line-modified"> 969   if (MonitorUsedDeflationThreshold &gt; 0) {</span>
<span class="line-modified"> 970     return monitors_used_above_threshold();</span>









 971   }
 972   return false;
 973 }
 974 
 975 void ObjectSynchronizer::oops_do(OopClosure* f) {
 976   // We only scan the global used list here (for moribund threads), and
 977   // the thread-local monitors in Thread::oops_do().
 978   global_used_oops_do(f);
 979 }
 980 
 981 void ObjectSynchronizer::global_used_oops_do(OopClosure* f) {
 982   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified"> 983   list_oops_do(gOmInUseList, f);</span>
 984 }
 985 
 986 void ObjectSynchronizer::thread_local_used_oops_do(Thread* thread, OopClosure* f) {
 987   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified"> 988   list_oops_do(thread-&gt;omInUseList, f);</span>
 989 }
 990 
 991 void ObjectSynchronizer::list_oops_do(ObjectMonitor* list, OopClosure* f) {
 992   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified"> 993   ObjectMonitor* mid;</span>
<span class="line-modified"> 994   for (mid = list; mid != NULL; mid = mid-&gt;FreeNext) {</span>

 995     if (mid-&gt;object() != NULL) {
 996       f-&gt;do_oop((oop*)mid-&gt;object_addr());
 997     }
 998   }
 999 }
1000 
1001 
1002 // -----------------------------------------------------------------------------
1003 // ObjectMonitor Lifecycle
1004 // -----------------------
<span class="line-modified">1005 // Inflation unlinks monitors from the global gFreeList and</span>
<span class="line-modified">1006 // associates them with objects.  Deflation -- which occurs at</span>
<span class="line-modified">1007 // STW-time -- disassociates idle monitors from objects.  Such</span>
<span class="line-modified">1008 // scavenged monitors are returned to the gFreeList.</span>
<span class="line-removed">1009 //</span>
<span class="line-removed">1010 // The global list is protected by gListLock.  All the critical sections</span>
<span class="line-removed">1011 // are short and operate in constant-time.</span>
1012 //
1013 // ObjectMonitors reside in type-stable memory (TSM) and are immortal.
1014 //
1015 // Lifecycle:
<span class="line-modified">1016 // --   unassigned and on the global free list</span>
<span class="line-modified">1017 // --   unassigned and on a thread&#39;s private omFreeList</span>
1018 // --   assigned to an object.  The object is inflated and the mark refers
<span class="line-modified">1019 //      to the objectmonitor.</span>
1020 
1021 
1022 // Constraining monitor pool growth via MonitorBound ...
1023 //


1024 // The monitor pool is grow-only.  We scavenge at STW safepoint-time, but the
1025 // the rate of scavenging is driven primarily by GC.  As such,  we can find
1026 // an inordinate number of monitors in circulation.
1027 // To avoid that scenario we can artificially induce a STW safepoint
1028 // if the pool appears to be growing past some reasonable bound.
1029 // Generally we favor time in space-time tradeoffs, but as there&#39;s no
1030 // natural back-pressure on the # of extant monitors we need to impose some
1031 // type of limit.  Beware that if MonitorBound is set to too low a value
1032 // we could just loop. In addition, if MonitorBound is set to a low value
1033 // we&#39;ll incur more safepoints, which are harmful to performance.
1034 // See also: GuaranteedSafepointInterval
1035 //
<span class="line-modified">1036 // The current implementation uses asynchronous VM operations.</span>




1037 
<span class="line-modified">1038 static void InduceScavenge(Thread * Self, const char * Whence) {</span>
1039   // Induce STW safepoint to trim monitors
1040   // Ultimately, this results in a call to deflate_idle_monitors() in the near future.
<span class="line-modified">1041   // More precisely, trigger an asynchronous STW safepoint as the number</span>
1042   // of active monitors passes the specified threshold.
1043   // TODO: assert thread state is reasonable
1044 
<span class="line-modified">1045   if (ForceMonitorScavenge == 0 &amp;&amp; Atomic::xchg (1, &amp;ForceMonitorScavenge) == 0) {</span>
<span class="line-modified">1046     // Induce a &#39;null&#39; safepoint to scavenge monitors</span>
<span class="line-removed">1047     // Must VM_Operation instance be heap allocated as the op will be enqueue and posted</span>
<span class="line-removed">1048     // to the VMthread and have a lifespan longer than that of this activation record.</span>
<span class="line-removed">1049     // The VMThread will delete the op when completed.</span>
<span class="line-removed">1050     VMThread::execute(new VM_ScavengeMonitors());</span>
1051   }
1052 }
1053 
<span class="line-modified">1054 ObjectMonitor* ObjectSynchronizer::omAlloc(Thread * Self) {</span>
1055   // A large MAXPRIVATE value reduces both list lock contention
1056   // and list coherency traffic, but also tends to increase the
<span class="line-modified">1057   // number of objectMonitors in circulation as well as the STW</span>
1058   // scavenge costs.  As usual, we lean toward time in space-time
1059   // tradeoffs.
1060   const int MAXPRIVATE = 1024;



1061   for (;;) {
<span class="line-modified">1062     ObjectMonitor * m;</span>
1063 
<span class="line-modified">1064     // 1: try to allocate from the thread&#39;s local omFreeList.</span>
1065     // Threads will attempt to allocate first from their local list, then
<span class="line-modified">1066     // from the global list, and only after those attempts fail will the thread</span>
<span class="line-modified">1067     // attempt to instantiate new monitors.   Thread-local free lists take</span>
<span class="line-modified">1068     // heat off the gListLock and improve allocation latency, as well as reducing</span>
<span class="line-modified">1069     // coherency traffic on the shared global list.</span>
<span class="line-modified">1070     m = Self-&gt;omFreeList;</span>
1071     if (m != NULL) {
<span class="line-removed">1072       Self-&gt;omFreeList = m-&gt;FreeNext;</span>
<span class="line-removed">1073       Self-&gt;omFreeCount--;</span>
1074       guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-modified">1075       m-&gt;FreeNext = Self-&gt;omInUseList;</span>
<span class="line-removed">1076       Self-&gt;omInUseList = m;</span>
<span class="line-removed">1077       Self-&gt;omInUseCount++;</span>
1078       return m;
1079     }
1080 
<span class="line-modified">1081     // 2: try to allocate from the global gFreeList</span>
<span class="line-removed">1082     // CONSIDER: use muxTry() instead of muxAcquire().</span>
<span class="line-removed">1083     // If the muxTry() fails then drop immediately into case 3.</span>
1084     // If we&#39;re using thread-local free lists then try
1085     // to reprovision the caller&#39;s free list.
<span class="line-modified">1086     if (gFreeList != NULL) {</span>
<span class="line-modified">1087       // Reprovision the thread&#39;s omFreeList.</span>
1088       // Use bulk transfers to reduce the allocation rate and heat
1089       // on various locks.
<span class="line-modified">1090       Thread::muxAcquire(&amp;gListLock, &quot;omAlloc(1)&quot;);</span>
<span class="line-modified">1091       for (int i = Self-&gt;omFreeProvision; --i &gt;= 0 &amp;&amp; gFreeList != NULL;) {</span>
<span class="line-modified">1092         gMonitorFreeCount--;</span>
<span class="line-modified">1093         ObjectMonitor * take = gFreeList;</span>
<span class="line-modified">1094         gFreeList = take-&gt;FreeNext;</span>
1095         guarantee(take-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-removed">1096         guarantee(!take-&gt;is_busy(), &quot;invariant&quot;);</span>
1097         take-&gt;Recycle();
<span class="line-modified">1098         omRelease(Self, take, false);</span>
1099       }
<span class="line-modified">1100       Thread::muxRelease(&amp;gListLock);</span>
<span class="line-modified">1101       Self-&gt;omFreeProvision += 1 + (Self-&gt;omFreeProvision/2);</span>
<span class="line-removed">1102       if (Self-&gt;omFreeProvision &gt; MAXPRIVATE) Self-&gt;omFreeProvision = MAXPRIVATE;</span>
1103 
<span class="line-modified">1104       const int mx = MonitorBound;</span>
<span class="line-modified">1105       if (mx &gt; 0 &amp;&amp; (gMonitorPopulation-gMonitorFreeCount) &gt; mx) {</span>
<span class="line-modified">1106         // We can&#39;t safely induce a STW safepoint from omAlloc() as our thread</span>

1107         // state may not be appropriate for such activities and callers may hold
1108         // naked oops, so instead we defer the action.
<span class="line-modified">1109         InduceScavenge(Self, &quot;omAlloc&quot;);</span>
1110       }
1111       continue;
1112     }
1113 
1114     // 3: allocate a block of new ObjectMonitors
1115     // Both the local and global free lists are empty -- resort to malloc().
<span class="line-modified">1116     // In the current implementation objectMonitors are TSM - immortal.</span>
1117     // Ideally, we&#39;d write &quot;new ObjectMonitor[_BLOCKSIZE], but we want
1118     // each ObjectMonitor to start at the beginning of a cache line,
1119     // so we use align_up().
1120     // A better solution would be to use C++ placement-new.
1121     // BEWARE: As it stands currently, we don&#39;t run the ctors!
1122     assert(_BLOCKSIZE &gt; 1, &quot;invariant&quot;);
<span class="line-modified">1123     size_t neededsize = sizeof(PaddedEnd&lt;ObjectMonitor&gt;) * _BLOCKSIZE;</span>
<span class="line-modified">1124     PaddedEnd&lt;ObjectMonitor&gt; * temp;</span>
<span class="line-modified">1125     size_t aligned_size = neededsize + (DEFAULT_CACHE_LINE_SIZE - 1);</span>
<span class="line-modified">1126     void* real_malloc_addr = (void *)NEW_C_HEAP_ARRAY(char, aligned_size,</span>
<span class="line-modified">1127                                                       mtInternal);</span>
<span class="line-removed">1128     temp = (PaddedEnd&lt;ObjectMonitor&gt; *)</span>
<span class="line-removed">1129              align_up(real_malloc_addr, DEFAULT_CACHE_LINE_SIZE);</span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131     // NOTE: (almost) no way to recover if allocation failed.</span>
<span class="line-removed">1132     // We might be able to induce a STW safepoint and scavenge enough</span>
<span class="line-removed">1133     // objectMonitors to permit progress.</span>
<span class="line-removed">1134     if (temp == NULL) {</span>
<span class="line-removed">1135       vm_exit_out_of_memory(neededsize, OOM_MALLOC_ERROR,</span>
<span class="line-removed">1136                             &quot;Allocate ObjectMonitors&quot;);</span>
<span class="line-removed">1137     }</span>
1138     (void)memset((void *) temp, 0, neededsize);
1139 
1140     // Format the block.
1141     // initialize the linked list, each monitor points to its next
1142     // forming the single linked free list, the very first monitor
1143     // will points to next block, which forms the block list.
<span class="line-modified">1144     // The trick of using the 1st element in the block as gBlockList</span>
1145     // linkage should be reconsidered.  A better implementation would
1146     // look like: class Block { Block * next; int N; ObjectMonitor Body [N] ; }
1147 
1148     for (int i = 1; i &lt; _BLOCKSIZE; i++) {
<span class="line-modified">1149       temp[i].FreeNext = (ObjectMonitor *)&amp;temp[i+1];</span>
1150     }
1151 
1152     // terminate the last monitor as the end of list
<span class="line-modified">1153     temp[_BLOCKSIZE - 1].FreeNext = NULL;</span>
1154 
1155     // Element [0] is reserved for global list linkage
1156     temp[0].set_object(CHAINMARKER);
1157 
1158     // Consider carving out this thread&#39;s current request from the
1159     // block in hand.  This avoids some lock traffic and redundant
1160     // list activity.
1161 
<span class="line-modified">1162     // Acquire the gListLock to manipulate gBlockList and gFreeList.</span>
<span class="line-removed">1163     // An Oyama-Taura-Yonezawa scheme might be more efficient.</span>
<span class="line-removed">1164     Thread::muxAcquire(&amp;gListLock, &quot;omAlloc(2)&quot;);</span>
<span class="line-removed">1165     gMonitorPopulation += _BLOCKSIZE-1;</span>
<span class="line-removed">1166     gMonitorFreeCount += _BLOCKSIZE-1;</span>
<span class="line-removed">1167 </span>
<span class="line-removed">1168     // Add the new block to the list of extant blocks (gBlockList).</span>
<span class="line-removed">1169     // The very first objectMonitor in a block is reserved and dedicated.</span>
<span class="line-removed">1170     // It serves as blocklist &quot;next&quot; linkage.</span>
<span class="line-removed">1171     temp[0].FreeNext = gBlockList;</span>
<span class="line-removed">1172     // There are lock-free uses of gBlockList so make sure that</span>
<span class="line-removed">1173     // the previous stores happen before we update gBlockList.</span>
<span class="line-removed">1174     OrderAccess::release_store(&amp;gBlockList, temp);</span>
<span class="line-removed">1175 </span>
<span class="line-removed">1176     // Add the new string of objectMonitors to the global free list</span>
<span class="line-removed">1177     temp[_BLOCKSIZE - 1].FreeNext = gFreeList;</span>
<span class="line-removed">1178     gFreeList = temp + 1;</span>
<span class="line-removed">1179     Thread::muxRelease(&amp;gListLock);</span>
1180   }
1181 }
1182 
<span class="line-modified">1183 // Place &quot;m&quot; on the caller&#39;s private per-thread omFreeList.</span>
1184 // In practice there&#39;s no need to clamp or limit the number of
<span class="line-modified">1185 // monitors on a thread&#39;s omFreeList as the only time we&#39;ll call</span>
<span class="line-modified">1186 // omRelease is to return a monitor to the free list after a CAS</span>
<span class="line-modified">1187 // attempt failed.  This doesn&#39;t allow unbounded #s of monitors to</span>
1188 // accumulate on a thread&#39;s free list.
1189 //
1190 // Key constraint: all ObjectMonitors on a thread&#39;s free list and the global
1191 // free list must have their object field set to null. This prevents the
<span class="line-modified">1192 // scavenger -- deflate_monitor_list() -- from reclaiming them.</span>

1193 
<span class="line-modified">1194 void ObjectSynchronizer::omRelease(Thread * Self, ObjectMonitor * m,</span>
<span class="line-modified">1195                                    bool fromPerThreadAlloc) {</span>
<span class="line-modified">1196   guarantee(m-&gt;header() == NULL, &quot;invariant&quot;);</span>
1197   guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-modified">1198   guarantee(((m-&gt;is_busy()|m-&gt;_recursions) == 0), &quot;freeing in-use monitor&quot;);</span>
<span class="line-modified">1199   // Remove from omInUseList</span>
<span class="line-modified">1200   if (fromPerThreadAlloc) {</span>
<span class="line-modified">1201     ObjectMonitor* cur_mid_in_use = NULL;</span>
<span class="line-modified">1202     bool extracted = false;</span>
<span class="line-modified">1203     for (ObjectMonitor* mid = Self-&gt;omInUseList; mid != NULL; cur_mid_in_use = mid, mid = mid-&gt;FreeNext) {</span>
<span class="line-modified">1204       if (m == mid) {</span>
<span class="line-modified">1205         // extract from per-thread in-use list</span>
<span class="line-modified">1206         if (mid == Self-&gt;omInUseList) {</span>
<span class="line-modified">1207           Self-&gt;omInUseList = mid-&gt;FreeNext;</span>
<span class="line-modified">1208         } else if (cur_mid_in_use != NULL) {</span>
<span class="line-modified">1209           cur_mid_in_use-&gt;FreeNext = mid-&gt;FreeNext; // maintain the current thread in-use list</span>

















































1210         }
<span class="line-removed">1211         extracted = true;</span>
<span class="line-removed">1212         Self-&gt;omInUseCount--;</span>
<span class="line-removed">1213         break;</span>
1214       }
1215     }
<span class="line-modified">1216     assert(extracted, &quot;Should have extracted from in-use list&quot;);</span>













1217   }
1218 
<span class="line-modified">1219   // FreeNext is used for both omInUseList and omFreeList, so clear old before setting new</span>
<span class="line-removed">1220   m-&gt;FreeNext = Self-&gt;omFreeList;</span>
<span class="line-removed">1221   Self-&gt;omFreeList = m;</span>
<span class="line-removed">1222   Self-&gt;omFreeCount++;</span>
1223 }
1224 
<span class="line-modified">1225 // Return the monitors of a moribund thread&#39;s local free list to</span>
<span class="line-modified">1226 // the global free list.  Typically a thread calls omFlush() when</span>
<span class="line-modified">1227 // it&#39;s dying.  We could also consider having the VM thread steal</span>
<span class="line-removed">1228 // monitors from threads that have not run java code over a few</span>
<span class="line-removed">1229 // consecutive STW safepoints.  Relatedly, we might decay</span>
<span class="line-removed">1230 // omFreeProvision at STW safepoints.</span>
<span class="line-removed">1231 //</span>
<span class="line-removed">1232 // Also return the monitors of a moribund thread&#39;s omInUseList to</span>
<span class="line-removed">1233 // a global gOmInUseList under the global list lock so these</span>
<span class="line-removed">1234 // will continue to be scanned.</span>
1235 //
<span class="line-modified">1236 // We currently call omFlush() from Threads::remove() _before the thread</span>
<span class="line-modified">1237 // has been excised from the thread list and is no longer a mutator.</span>
<span class="line-modified">1238 // This means that omFlush() cannot run concurrently with a safepoint and</span>
<span class="line-modified">1239 // interleave with the deflate_idle_monitors scavenge operator. In particular,</span>
<span class="line-modified">1240 // this ensures that the thread&#39;s monitors are scanned by a GC safepoint,</span>
<span class="line-modified">1241 // either via Thread::oops_do() (if safepoint happens before omFlush()) or via</span>
<span class="line-modified">1242 // ObjectSynchronizer::oops_do() (if it happens after omFlush() and the thread&#39;s</span>
<span class="line-modified">1243 // monitors have been transferred to the global in-use list).</span>
<span class="line-modified">1244 </span>
<span class="line-modified">1245 void ObjectSynchronizer::omFlush(Thread * Self) {</span>
<span class="line-modified">1246   ObjectMonitor * list = Self-&gt;omFreeList;  // Null-terminated SLL</span>
<span class="line-modified">1247   ObjectMonitor * tail = NULL;</span>
<span class="line-modified">1248   int tally = 0;</span>
<span class="line-modified">1249   if (list != NULL) {</span>
<span class="line-modified">1250     ObjectMonitor * s;</span>
<span class="line-modified">1251     // The thread is going away, the per-thread free monitors</span>
<span class="line-modified">1252     // are freed via set_owner(NULL)</span>
<span class="line-modified">1253     // Link them to tail, which will be linked into the global free list</span>
<span class="line-modified">1254     // gFreeList below, under the gListLock</span>
<span class="line-modified">1255     for (s = list; s != NULL; s = s-&gt;FreeNext) {</span>
<span class="line-modified">1256       tally++;</span>
<span class="line-modified">1257       tail = s;</span>
<span class="line-modified">1258       guarantee(s-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1259       guarantee(!s-&gt;is_busy(), &quot;invariant&quot;);</span>
<span class="line-modified">1260       s-&gt;set_owner(NULL);   // redundant but good hygiene</span>

















1261     }
<span class="line-modified">1262     guarantee(tail != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1263     assert(Self-&gt;omFreeCount == tally, &quot;free-count off&quot;);</span>
<span class="line-modified">1264     Self-&gt;omFreeList = NULL;</span>
<span class="line-modified">1265     Self-&gt;omFreeCount = 0;</span>
<span class="line-modified">1266   }</span>
<span class="line-modified">1267 </span>
<span class="line-modified">1268   ObjectMonitor * inUseList = Self-&gt;omInUseList;</span>
<span class="line-modified">1269   ObjectMonitor * inUseTail = NULL;</span>
<span class="line-modified">1270   int inUseTally = 0;</span>
<span class="line-modified">1271   if (inUseList != NULL) {</span>
<span class="line-modified">1272     ObjectMonitor *cur_om;</span>
<span class="line-modified">1273     // The thread is going away, however the omInUseList inflated</span>
<span class="line-modified">1274     // monitors may still be in-use by other threads.</span>
<span class="line-modified">1275     // Link them to inUseTail, which will be linked into the global in-use list</span>
<span class="line-modified">1276     // gOmInUseList below, under the gListLock</span>
<span class="line-modified">1277     for (cur_om = inUseList; cur_om != NULL; cur_om = cur_om-&gt;FreeNext) {</span>
<span class="line-modified">1278       inUseTail = cur_om;</span>
<span class="line-modified">1279       inUseTally++;</span>






















1280     }
<span class="line-modified">1281     guarantee(inUseTail != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1282     assert(Self-&gt;omInUseCount == inUseTally, &quot;in-use count off&quot;);</span>
<span class="line-modified">1283     Self-&gt;omInUseList = NULL;</span>
<span class="line-modified">1284     Self-&gt;omInUseCount = 0;</span>



1285   }
1286 
<span class="line-modified">1287   Thread::muxAcquire(&amp;gListLock, &quot;omFlush&quot;);</span>
<span class="line-modified">1288   if (tail != NULL) {</span>
<span class="line-removed">1289     tail-&gt;FreeNext = gFreeList;</span>
<span class="line-removed">1290     gFreeList = list;</span>
<span class="line-removed">1291     gMonitorFreeCount += tally;</span>
1292   }
1293 
<span class="line-modified">1294   if (inUseTail != NULL) {</span>
<span class="line-modified">1295     inUseTail-&gt;FreeNext = gOmInUseList;</span>
<span class="line-removed">1296     gOmInUseList = inUseList;</span>
<span class="line-removed">1297     gOmInUseCount += inUseTally;</span>
1298   }
1299 
<span class="line-modified">1300   Thread::muxRelease(&amp;gListLock);</span>













1301 }
1302 
1303 static void post_monitor_inflate_event(EventJavaMonitorInflate* event,
1304                                        const oop obj,
1305                                        ObjectSynchronizer::InflateCause cause) {
1306   assert(event != NULL, &quot;invariant&quot;);
1307   assert(event-&gt;should_commit(), &quot;invariant&quot;);
1308   event-&gt;set_monitorClass(obj-&gt;klass());
1309   event-&gt;set_address((uintptr_t)(void*)obj);
1310   event-&gt;set_cause((u1)cause);
1311   event-&gt;commit();
1312 }
1313 
1314 // Fast path code shared by multiple functions
1315 void ObjectSynchronizer::inflate_helper(oop obj) {
<span class="line-modified">1316   markOop mark = obj-&gt;mark();</span>
<span class="line-modified">1317   if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">1318     assert(ObjectSynchronizer::verify_objmon_isinpool(mark-&gt;monitor()), &quot;monitor is invalid&quot;);</span>
<span class="line-modified">1319     assert(mark-&gt;monitor()-&gt;header()-&gt;is_neutral(), &quot;monitor must record a good object header&quot;);</span>
1320     return;
1321   }
1322   inflate(Thread::current(), obj, inflate_cause_vm_internal);
1323 }
1324 
<span class="line-modified">1325 ObjectMonitor* ObjectSynchronizer::inflate(Thread * Self,</span>
<span class="line-modified">1326                                            oop object,</span>
<span class="line-removed">1327                                            const InflateCause cause) {</span>
1328   // Inflate mutates the heap ...
1329   // Relaxing assertion for bug 6320749.
1330   assert(Universe::verify_in_progress() ||
1331          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1332 
1333   EventJavaMonitorInflate event;
1334 
1335   for (;;) {
<span class="line-modified">1336     const markOop mark = object-&gt;mark();</span>
<span class="line-modified">1337     assert(!mark-&gt;has_bias_pattern(), &quot;invariant&quot;);</span>
1338 
1339     // The mark can be in one of the following states:
1340     // *  Inflated     - just return
1341     // *  Stack-locked - coerce it to inflated
1342     // *  INFLATING    - busy wait for conversion to complete
1343     // *  Neutral      - aggressively inflate the object.
1344     // *  BIASED       - Illegal.  We should never see this
1345 
1346     // CASE: inflated
<span class="line-modified">1347     if (mark-&gt;has_monitor()) {</span>
<span class="line-modified">1348       ObjectMonitor * inf = mark-&gt;monitor();</span>
<span class="line-modified">1349       markOop dmw = inf-&gt;header();</span>
<span class="line-modified">1350       assert(dmw-&gt;is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, p2i((address)dmw));</span>
<span class="line-modified">1351       assert(oopDesc::equals((oop) inf-&gt;object(), object), &quot;invariant&quot;);</span>
1352       assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
1353       return inf;
1354     }
1355 
1356     // CASE: inflation in progress - inflating over a stack-lock.
1357     // Some other thread is converting from stack-locked to inflated.
1358     // Only that thread can complete inflation -- other threads must wait.
1359     // The INFLATING value is transient.
1360     // Currently, we spin/yield/park and poll the markword, waiting for inflation to finish.
1361     // We could always eliminate polling by parking the thread on some auxiliary list.
<span class="line-modified">1362     if (mark == markOopDesc::INFLATING()) {</span>
<span class="line-modified">1363       ReadStableMark(object);</span>
1364       continue;
1365     }
1366 
1367     // CASE: stack-locked
1368     // Could be stack-locked either by this thread or by some other thread.
1369     //
1370     // Note that we allocate the objectmonitor speculatively, _before_ attempting
1371     // to install INFLATING into the mark word.  We originally installed INFLATING,
1372     // allocated the objectmonitor, and then finally STed the address of the
1373     // objectmonitor into the mark.  This was correct, but artificially lengthened
1374     // the interval in which INFLATED appeared in the mark, thus increasing
1375     // the odds of inflation contention.
1376     //
1377     // We now use per-thread private objectmonitor free lists.
1378     // These list are reprovisioned from the global free list outside the
1379     // critical INFLATING...ST interval.  A thread can transfer
1380     // multiple objectmonitors en-mass from the global free list to its local free list.
1381     // This reduces coherency traffic and lock contention on the global free list.
<span class="line-modified">1382     // Using such local free lists, it doesn&#39;t matter if the omAlloc() call appears</span>
1383     // before or after the CAS(INFLATING) operation.
<span class="line-modified">1384     // See the comments in omAlloc().</span>
1385 
1386     LogStreamHandle(Trace, monitorinflation) lsh;
1387 
<span class="line-modified">1388     if (mark-&gt;has_locker()) {</span>
<span class="line-modified">1389       ObjectMonitor * m = omAlloc(Self);</span>
1390       // Optimistically prepare the objectmonitor - anticipate successful CAS
1391       // We do this before the CAS in order to minimize the length of time
1392       // in which INFLATING appears in the mark.
1393       m-&gt;Recycle();
1394       m-&gt;_Responsible  = NULL;
<span class="line-removed">1395       m-&gt;_recursions   = 0;</span>
1396       m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;   // Consider: maintain by type/class
1397 
<span class="line-modified">1398       markOop cmp = object-&gt;cas_set_mark(markOopDesc::INFLATING(), mark);</span>
1399       if (cmp != mark) {
<span class="line-modified">1400         omRelease(Self, m, true);</span>
1401         continue;       // Interference -- just retry
1402       }
1403 
1404       // We&#39;ve successfully installed INFLATING (0) into the mark-word.
1405       // This is the only case where 0 will appear in a mark-word.
1406       // Only the singular thread that successfully swings the mark-word
1407       // to 0 can perform (or more precisely, complete) inflation.
1408       //
1409       // Why do we CAS a 0 into the mark-word instead of just CASing the
1410       // mark-word from the stack-locked value directly to the new inflated state?
1411       // Consider what happens when a thread unlocks a stack-locked object.
1412       // It attempts to use CAS to swing the displaced header value from the
<span class="line-modified">1413       // on-stack basiclock back into the object header.  Recall also that the</span>
<span class="line-modified">1414       // header value (hashcode, etc) can reside in (a) the object header, or</span>
1415       // (b) a displaced header associated with the stack-lock, or (c) a displaced
<span class="line-modified">1416       // header in an objectMonitor.  The inflate() routine must copy the header</span>
<span class="line-modified">1417       // value from the basiclock on the owner&#39;s stack to the objectMonitor, all</span>
1418       // the while preserving the hashCode stability invariants.  If the owner
1419       // decides to release the lock while the value is 0, the unlock will fail
1420       // and control will eventually pass from slow_exit() to inflate.  The owner
1421       // will then spin, waiting for the 0 value to disappear.   Put another way,
1422       // the 0 causes the owner to stall if the owner happens to try to
<span class="line-modified">1423       // drop the lock (restoring the header from the basiclock to the object)</span>
1424       // while inflation is in-progress.  This protocol avoids races that might
1425       // would otherwise permit hashCode values to change or &quot;flicker&quot; for an object.
<span class="line-modified">1426       // Critically, while object-&gt;mark is 0 mark-&gt;displaced_mark_helper() is stable.</span>
1427       // 0 serves as a &quot;BUSY&quot; inflate-in-progress indicator.
1428 
1429 
1430       // fetch the displaced mark from the owner&#39;s stack.
1431       // The owner can&#39;t die or unwind past the lock while our INFLATING
1432       // object is in the mark.  Furthermore the owner can&#39;t complete
1433       // an unlock on the object, either.
<span class="line-modified">1434       markOop dmw = mark-&gt;displaced_mark_helper();</span>
<span class="line-modified">1435       assert(dmw-&gt;is_neutral(), &quot;invariant&quot;);</span>


1436 
1437       // Setup monitor fields to proper values -- prepare the monitor
1438       m-&gt;set_header(dmw);
1439 
<span class="line-modified">1440       // Optimization: if the mark-&gt;locker stack address is associated</span>
<span class="line-modified">1441       // with this thread we could simply set m-&gt;_owner = Self.</span>
1442       // Note that a thread can inflate an object
1443       // that it has stack-locked -- as might happen in wait() -- directly
1444       // with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.
<span class="line-modified">1445       m-&gt;set_owner(mark-&gt;locker());</span>
1446       m-&gt;set_object(object);
1447       // TODO-FIXME: assert BasicLock-&gt;dhw != 0.
1448 
1449       // Must preserve store ordering. The monitor state must
1450       // be stable at the time of publishing the monitor address.
<span class="line-modified">1451       guarantee(object-&gt;mark() == markOopDesc::INFLATING(), &quot;invariant&quot;);</span>
<span class="line-modified">1452       object-&gt;release_set_mark(markOopDesc::encode(m));</span>
1453 
1454       // Hopefully the performance counters are allocated on distinct cache lines
1455       // to avoid false sharing on MP systems ...
1456       OM_PERFDATA_OP(Inflations, inc());
1457       if (log_is_enabled(Trace, monitorinflation)) {
<span class="line-modified">1458         ResourceMark rm(Self);</span>
1459         lsh.print_cr(&quot;inflate(has_locker): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
1460                      INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
<span class="line-modified">1461                      p2i(object-&gt;mark()), object-&gt;klass()-&gt;external_name());</span>
1462       }
1463       if (event.should_commit()) {
1464         post_monitor_inflate_event(&amp;event, object, cause);
1465       }
1466       return m;
1467     }
1468 
1469     // CASE: neutral
1470     // TODO-FIXME: for entry we currently inflate and then try to CAS _owner.
1471     // If we know we&#39;re inflating for entry it&#39;s better to inflate by swinging a
<span class="line-modified">1472     // pre-locked objectMonitor pointer into the object header.   A successful</span>
1473     // CAS inflates the object *and* confers ownership to the inflating thread.
1474     // In the current implementation we use a 2-step mechanism where we CAS()
<span class="line-modified">1475     // to inflate and then CAS() again to try to swing _owner from NULL to Self.</span>
<span class="line-modified">1476     // An inflateTry() method that we could call from fast_enter() and slow_enter()</span>
<span class="line-removed">1477     // would be useful.</span>
1478 
<span class="line-modified">1479     assert(mark-&gt;is_neutral(), &quot;invariant&quot;);</span>
<span class="line-modified">1480     ObjectMonitor * m = omAlloc(Self);</span>


1481     // prepare m for installation - set monitor to initial state
1482     m-&gt;Recycle();
1483     m-&gt;set_header(mark);
<span class="line-removed">1484     m-&gt;set_owner(NULL);</span>
1485     m-&gt;set_object(object);
<span class="line-removed">1486     m-&gt;_recursions   = 0;</span>
1487     m-&gt;_Responsible  = NULL;
1488     m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;       // consider: keep metastats by type/class
1489 
<span class="line-modified">1490     if (object-&gt;cas_set_mark(markOopDesc::encode(m), mark) != mark) {</span>
<span class="line-modified">1491       m-&gt;set_header(NULL);</span>
1492       m-&gt;set_object(NULL);
1493       m-&gt;Recycle();
<span class="line-modified">1494       omRelease(Self, m, true);</span>
1495       m = NULL;
1496       continue;
1497       // interference - the markword changed - just retry.
1498       // The state-transitions are one-way, so there&#39;s no chance of
1499       // live-lock -- &quot;Inflated&quot; is an absorbing state.
1500     }
1501 
1502     // Hopefully the performance counters are allocated on distinct
1503     // cache lines to avoid false sharing on MP systems ...
1504     OM_PERFDATA_OP(Inflations, inc());
1505     if (log_is_enabled(Trace, monitorinflation)) {
<span class="line-modified">1506       ResourceMark rm(Self);</span>
1507       lsh.print_cr(&quot;inflate(neutral): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
1508                    INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
<span class="line-modified">1509                    p2i(object-&gt;mark()), object-&gt;klass()-&gt;external_name());</span>
1510     }
1511     if (event.should_commit()) {
1512       post_monitor_inflate_event(&amp;event, object, cause);
1513     }
1514     return m;
1515   }
1516 }
1517 
1518 
<span class="line-modified">1519 // We create a list of in-use monitors for each thread.</span>
1520 //
1521 // deflate_thread_local_monitors() scans a single thread&#39;s in-use list, while
1522 // deflate_idle_monitors() scans only a global list of in-use monitors which
<span class="line-modified">1523 // is populated only as a thread dies (see omFlush()).</span>
1524 //
1525 // These operations are called at all safepoints, immediately after mutators
1526 // are stopped, but before any objects have moved. Collectively they traverse
1527 // the population of in-use monitors, deflating where possible. The scavenged
<span class="line-modified">1528 // monitors are returned to the monitor free list.</span>
1529 //
1530 // Beware that we scavenge at *every* stop-the-world point. Having a large
1531 // number of monitors in-use could negatively impact performance. We also want
1532 // to minimize the total # of monitors in circulation, as they incur a small
1533 // footprint penalty.
1534 //
1535 // Perversely, the heap size -- and thus the STW safepoint rate --
1536 // typically drives the scavenge rate.  Large heaps can mean infrequent GC,
<span class="line-modified">1537 // which in turn can mean large(r) numbers of objectmonitors in circulation.</span>
1538 // This is an unfortunate aspect of this design.
1539 
1540 // Deflate a single monitor if not in-use
1541 // Return true if deflated, false if in-use
1542 bool ObjectSynchronizer::deflate_monitor(ObjectMonitor* mid, oop obj,
<span class="line-modified">1543                                          ObjectMonitor** freeHeadp,</span>
<span class="line-modified">1544                                          ObjectMonitor** freeTailp) {</span>
1545   bool deflated;
1546   // Normal case ... The monitor is associated with obj.
<span class="line-modified">1547   guarantee(obj-&gt;mark() == markOopDesc::encode(mid), &quot;invariant&quot;);</span>
<span class="line-modified">1548   guarantee(mid == obj-&gt;mark()-&gt;monitor(), &quot;invariant&quot;);</span>
<span class="line-modified">1549   guarantee(mid-&gt;header()-&gt;is_neutral(), &quot;invariant&quot;);</span>






1550 
1551   if (mid-&gt;is_busy()) {

1552     deflated = false;
1553   } else {
1554     // Deflate the monitor if it is no longer being used
1555     // It&#39;s idle - scavenge and return to the global free list
1556     // plain old deflation ...
1557     if (log_is_enabled(Trace, monitorinflation)) {
1558       ResourceMark rm;
1559       log_trace(monitorinflation)(&quot;deflate_monitor: &quot;
<span class="line-modified">1560                                   &quot;object=&quot; INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;,</span>
<span class="line-modified">1561                                   p2i(obj), p2i(obj-&gt;mark()),</span>
<span class="line-modified">1562                                   obj-&gt;klass()-&gt;external_name());</span>
1563     }
1564 
1565     // Restore the header back to obj
<span class="line-modified">1566     obj-&gt;release_set_mark(mid-&gt;header());</span>
1567     mid-&gt;clear();
1568 
<span class="line-modified">1569     assert(mid-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1570 </span>
<span class="line-modified">1571     // Move the object to the working free list defined by freeHeadp, freeTailp</span>
<span class="line-modified">1572     if (*freeHeadp == NULL) *freeHeadp = mid;</span>
<span class="line-modified">1573     if (*freeTailp != NULL) {</span>
<span class="line-modified">1574       ObjectMonitor * prevtail = *freeTailp;</span>
<span class="line-modified">1575       assert(prevtail-&gt;FreeNext == NULL, &quot;cleaned up deflated?&quot;);</span>
<span class="line-modified">1576       prevtail-&gt;FreeNext = mid;</span>











1577     }
<span class="line-modified">1578     *freeTailp = mid;</span>




1579     deflated = true;
1580   }
1581   return deflated;
1582 }
1583 
<span class="line-modified">1584 // Walk a given monitor list, and deflate idle monitors</span>
<span class="line-modified">1585 // The given list could be a per-thread list or a global list</span>
<span class="line-removed">1586 // Caller acquires gListLock as needed.</span>
1587 //
1588 // In the case of parallel processing of thread local monitor lists,
1589 // work is done by Threads::parallel_threads_do() which ensures that
1590 // each Java thread is processed by exactly one worker thread, and
1591 // thus avoid conflicts that would arise when worker threads would
1592 // process the same monitor lists concurrently.
1593 //
1594 // See also ParallelSPCleanupTask and
1595 // SafepointSynchronize::do_cleanup_tasks() in safepoint.cpp and
1596 // Threads::parallel_java_threads_do() in thread.cpp.
<span class="line-modified">1597 int ObjectSynchronizer::deflate_monitor_list(ObjectMonitor** listHeadp,</span>
<span class="line-modified">1598                                              ObjectMonitor** freeHeadp,</span>
<span class="line-modified">1599                                              ObjectMonitor** freeTailp) {</span>
<span class="line-modified">1600   ObjectMonitor* mid;</span>
<span class="line-removed">1601   ObjectMonitor* next;</span>
1602   ObjectMonitor* cur_mid_in_use = NULL;


1603   int deflated_count = 0;
1604 
<span class="line-modified">1605   for (mid = *listHeadp; mid != NULL;) {</span>




1606     oop obj = (oop) mid-&gt;object();
<span class="line-modified">1607     if (obj != NULL &amp;&amp; deflate_monitor(mid, obj, freeHeadp, freeTailp)) {</span>
<span class="line-modified">1608       // if deflate_monitor succeeded,</span>
<span class="line-modified">1609       // extract from per-thread in-use list</span>
<span class="line-modified">1610       if (mid == *listHeadp) {</span>
<span class="line-modified">1611         *listHeadp = mid-&gt;FreeNext;</span>
<span class="line-modified">1612       } else if (cur_mid_in_use != NULL) {</span>
<span class="line-modified">1613         cur_mid_in_use-&gt;FreeNext = mid-&gt;FreeNext; // maintain the current thread in-use list</span>



1614       }
<span class="line-modified">1615       next = mid-&gt;FreeNext;</span>
<span class="line-removed">1616       mid-&gt;FreeNext = NULL;  // This mid is current tail in the freeHeadp list</span>
<span class="line-removed">1617       mid = next;</span>
1618       deflated_count++;



1619     } else {
1620       cur_mid_in_use = mid;
<span class="line-removed">1621       mid = mid-&gt;FreeNext;</span>
1622     }
1623   }
1624   return deflated_count;
1625 }
1626 
1627 void ObjectSynchronizer::prepare_deflate_idle_monitors(DeflateMonitorCounters* counters) {
<span class="line-modified">1628   counters-&gt;nInuse = 0;              // currently associated with objects</span>
<span class="line-modified">1629   counters-&gt;nInCirculation = 0;      // extant</span>
<span class="line-modified">1630   counters-&gt;nScavenged = 0;          // reclaimed (global and per-thread)</span>
<span class="line-modified">1631   counters-&gt;perThreadScavenged = 0;  // per-thread scavenge total</span>
<span class="line-modified">1632   counters-&gt;perThreadTimes = 0.0;    // per-thread scavenge times</span>
1633 }
1634 
1635 void ObjectSynchronizer::deflate_idle_monitors(DeflateMonitorCounters* counters) {
1636   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
1637   bool deflated = false;
1638 
<span class="line-modified">1639   ObjectMonitor * freeHeadp = NULL;  // Local SLL of scavenged monitors</span>
<span class="line-modified">1640   ObjectMonitor * freeTailp = NULL;</span>
1641   elapsedTimer timer;
1642 
1643   if (log_is_enabled(Info, monitorinflation)) {
1644     timer.start();
1645   }
1646 
<span class="line-removed">1647   // Prevent omFlush from changing mids in Thread dtor&#39;s during deflation</span>
<span class="line-removed">1648   // And in case the vm thread is acquiring a lock during a safepoint</span>
<span class="line-removed">1649   // See e.g. 6320749</span>
<span class="line-removed">1650   Thread::muxAcquire(&amp;gListLock, &quot;deflate_idle_monitors&quot;);</span>
<span class="line-removed">1651 </span>
1652   // Note: the thread-local monitors lists get deflated in
1653   // a separate pass. See deflate_thread_local_monitors().
1654 
<span class="line-modified">1655   // For moribund threads, scan gOmInUseList</span>
1656   int deflated_count = 0;
<span class="line-modified">1657   if (gOmInUseList) {</span>
<span class="line-modified">1658     counters-&gt;nInCirculation += gOmInUseCount;</span>
<span class="line-modified">1659     deflated_count = deflate_monitor_list((ObjectMonitor **)&amp;gOmInUseList, &amp;freeHeadp, &amp;freeTailp);</span>
<span class="line-modified">1660     gOmInUseCount -= deflated_count;</span>
<span class="line-modified">1661     counters-&gt;nScavenged += deflated_count;</span>
<span class="line-modified">1662     counters-&gt;nInuse += gOmInUseCount;</span>
<span class="line-modified">1663   }</span>
<span class="line-modified">1664 </span>
<span class="line-modified">1665   // Move the scavenged monitors back to the global free list.</span>
<span class="line-modified">1666   if (freeHeadp != NULL) {</span>
<span class="line-modified">1667     guarantee(freeTailp != NULL &amp;&amp; counters-&gt;nScavenged &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">1668     assert(freeTailp-&gt;FreeNext == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1669     // constant-time list splice - prepend scavenged segment to gFreeList</span>
<span class="line-modified">1670     freeTailp-&gt;FreeNext = gFreeList;</span>
<span class="line-modified">1671     gFreeList = freeHeadp;</span>
<span class="line-modified">1672   }</span>
<span class="line-modified">1673   Thread::muxRelease(&amp;gListLock);</span>





1674   timer.stop();
1675 
1676   LogStreamHandle(Debug, monitorinflation) lsh_debug;
1677   LogStreamHandle(Info, monitorinflation) lsh_info;
<span class="line-modified">1678   LogStream * ls = NULL;</span>
1679   if (log_is_enabled(Debug, monitorinflation)) {
1680     ls = &amp;lsh_debug;
1681   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {
1682     ls = &amp;lsh_info;
1683   }
1684   if (ls != NULL) {
1685     ls-&gt;print_cr(&quot;deflating global idle monitors, %3.7f secs, %d monitors&quot;, timer.seconds(), deflated_count);
1686   }
1687 }
1688 
1689 void ObjectSynchronizer::finish_deflate_idle_monitors(DeflateMonitorCounters* counters) {
1690   // Report the cumulative time for deflating each thread&#39;s idle
1691   // monitors. Note: if the work is split among more than one
1692   // worker thread, then the reported time will likely be more
1693   // than a beginning to end measurement of the phase.
<span class="line-modified">1694   log_info(safepoint, cleanup)(&quot;deflating per-thread idle monitors, %3.7f secs, monitors=%d&quot;, counters-&gt;perThreadTimes, counters-&gt;perThreadScavenged);</span>
<span class="line-removed">1695 </span>
<span class="line-removed">1696   LogStreamHandle(Debug, monitorinflation) lsh_debug;</span>
<span class="line-removed">1697   LogStreamHandle(Info, monitorinflation) lsh_info;</span>
<span class="line-removed">1698   LogStream * ls = NULL;</span>
<span class="line-removed">1699   if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="line-removed">1700     ls = &amp;lsh_debug;</span>
<span class="line-removed">1701   } else if (counters-&gt;perThreadScavenged != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {</span>
<span class="line-removed">1702     ls = &amp;lsh_info;</span>
<span class="line-removed">1703   }</span>
<span class="line-removed">1704   if (ls != NULL) {</span>
<span class="line-removed">1705     ls-&gt;print_cr(&quot;deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, counters-&gt;perThreadTimes, counters-&gt;perThreadScavenged);</span>
<span class="line-removed">1706   }</span>
<span class="line-removed">1707 </span>
<span class="line-removed">1708   gMonitorFreeCount += counters-&gt;nScavenged;</span>
1709 
1710   if (log_is_enabled(Debug, monitorinflation)) {
1711     // exit_globals()&#39;s call to audit_and_print_stats() is done
<span class="line-modified">1712     // at the Info level.</span>
1713     ObjectSynchronizer::audit_and_print_stats(false /* on_exit */);






1714   }
1715 
<span class="line-modified">1716   ForceMonitorScavenge = 0;    // Reset</span>
1717 
<span class="line-modified">1718   OM_PERFDATA_OP(Deflations, inc(counters-&gt;nScavenged));</span>
<span class="line-modified">1719   OM_PERFDATA_OP(MonExtant, set_value(counters-&gt;nInCirculation));</span>
1720 
<span class="line-modified">1721   GVars.stwRandom = os::random();</span>
<span class="line-modified">1722   GVars.stwCycle++;</span>
1723 }
1724 
1725 void ObjectSynchronizer::deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters) {
1726   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
1727 
<span class="line-modified">1728   ObjectMonitor * freeHeadp = NULL;  // Local SLL of scavenged monitors</span>
<span class="line-modified">1729   ObjectMonitor * freeTailp = NULL;</span>
1730   elapsedTimer timer;
1731 
1732   if (log_is_enabled(Info, safepoint, cleanup) ||
1733       log_is_enabled(Info, monitorinflation)) {
1734     timer.start();
1735   }
1736 
<span class="line-modified">1737   int deflated_count = deflate_monitor_list(thread-&gt;omInUseList_addr(), &amp;freeHeadp, &amp;freeTailp);</span>
<span class="line-modified">1738 </span>
<span class="line-removed">1739   timer.stop();</span>
1740 
<span class="line-modified">1741   Thread::muxAcquire(&amp;gListLock, &quot;deflate_thread_local_monitors&quot;);</span>

1742 
<span class="line-modified">1743   // Adjust counters</span>
<span class="line-modified">1744   counters-&gt;nInCirculation += thread-&gt;omInUseCount;</span>
<span class="line-modified">1745   thread-&gt;omInUseCount -= deflated_count;</span>
<span class="line-modified">1746   counters-&gt;nScavenged += deflated_count;</span>
<span class="line-modified">1747   counters-&gt;nInuse += thread-&gt;omInUseCount;</span>
<span class="line-modified">1748   counters-&gt;perThreadScavenged += deflated_count;</span>
<span class="line-modified">1749   // For now, we only care about cumulative per-thread deflation time.</span>
<span class="line-modified">1750   counters-&gt;perThreadTimes += timer.seconds();</span>



1751 
<span class="line-modified">1752   // Move the scavenged monitors back to the global free list.</span>
<span class="line-modified">1753   if (freeHeadp != NULL) {</span>
<span class="line-removed">1754     guarantee(freeTailp != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">1755     assert(freeTailp-&gt;FreeNext == NULL, &quot;invariant&quot;);</span>
1756 
<span class="line-modified">1757     // constant-time list splice - prepend scavenged segment to gFreeList</span>
<span class="line-modified">1758     freeTailp-&gt;FreeNext = gFreeList;</span>
<span class="line-modified">1759     gFreeList = freeHeadp;</span>







1760   }
<span class="line-removed">1761   Thread::muxRelease(&amp;gListLock);</span>
1762 }
1763 
1764 // Monitor cleanup on JavaThread::exit
1765 
1766 // Iterate through monitor cache and attempt to release thread&#39;s monitors
1767 // Gives up on a particular monitor if an exception occurs, but continues
1768 // the overall iteration, swallowing the exception.
1769 class ReleaseJavaMonitorsClosure: public MonitorClosure {
1770  private:
1771   TRAPS;
1772 
1773  public:
1774   ReleaseJavaMonitorsClosure(Thread* thread) : THREAD(thread) {}
1775   void do_monitor(ObjectMonitor* mid) {
1776     if (mid-&gt;owner() == THREAD) {
1777       // Note well -- this occurs ONLY on thread exit, and is a last ditch
1778       // effort to release all locks. Hence, we don&#39;t need to record tsan&#39;s
1779       // recursion count -- it will never be locked again.
1780       TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_unlock(THREAD, (oop)mid-&gt;object()));
1781       (void)mid-&gt;complete_exit(CHECK);
</pre>
<hr />
<pre>
1785 
1786 // Release all inflated monitors owned by THREAD.  Lightweight monitors are
1787 // ignored.  This is meant to be called during JNI thread detach which assumes
1788 // all remaining monitors are heavyweight.  All exceptions are swallowed.
1789 // Scanning the extant monitor list can be time consuming.
1790 // A simple optimization is to add a per-thread flag that indicates a thread
1791 // called jni_monitorenter() during its lifetime.
1792 //
1793 // Instead of No_Savepoint_Verifier it might be cheaper to
1794 // use an idiom of the form:
1795 //   auto int tmp = SafepointSynchronize::_safepoint_counter ;
1796 //   &lt;code that must not run at safepoint&gt;
1797 //   guarantee (((tmp ^ _safepoint_counter) | (tmp &amp; 1)) == 0) ;
1798 // Since the tests are extremely cheap we could leave them enabled
1799 // for normal product builds.
1800 
1801 void ObjectSynchronizer::release_monitors_owned_by_thread(TRAPS) {
1802   assert(THREAD == JavaThread::current(), &quot;must be current Java thread&quot;);
1803   NoSafepointVerifier nsv;
1804   ReleaseJavaMonitorsClosure rjmc(THREAD);
<span class="line-removed">1805   Thread::muxAcquire(&amp;gListLock, &quot;release_monitors_owned_by_thread&quot;);</span>
1806   ObjectSynchronizer::monitors_iterate(&amp;rjmc);
<span class="line-removed">1807   Thread::muxRelease(&amp;gListLock);</span>
1808   THREAD-&gt;clear_pending_exception();
1809 }
1810 
1811 const char* ObjectSynchronizer::inflate_cause_name(const InflateCause cause) {
1812   switch (cause) {
1813     case inflate_cause_vm_internal:    return &quot;VM Internal&quot;;
1814     case inflate_cause_monitor_enter:  return &quot;Monitor Enter&quot;;
1815     case inflate_cause_wait:           return &quot;Monitor Wait&quot;;
1816     case inflate_cause_notify:         return &quot;Monitor Notify&quot;;
1817     case inflate_cause_hash_code:      return &quot;Monitor Hash Code&quot;;
1818     case inflate_cause_jni_enter:      return &quot;JNI Monitor Enter&quot;;
1819     case inflate_cause_jni_exit:       return &quot;JNI Monitor Exit&quot;;
1820     default:
1821       ShouldNotReachHere();
1822   }
1823   return &quot;Unknown&quot;;
1824 }
1825 
1826 //------------------------------------------------------------------------------
1827 // Debugging code
1828 
1829 u_char* ObjectSynchronizer::get_gvars_addr() {
1830   return (u_char*)&amp;GVars;
1831 }
1832 
<span class="line-modified">1833 u_char* ObjectSynchronizer::get_gvars_hcSequence_addr() {</span>
<span class="line-modified">1834   return (u_char*)&amp;GVars.hcSequence;</span>
1835 }
1836 
1837 size_t ObjectSynchronizer::get_gvars_size() {
1838   return sizeof(SharedGlobals);
1839 }
1840 
<span class="line-modified">1841 u_char* ObjectSynchronizer::get_gvars_stwRandom_addr() {</span>
<span class="line-modified">1842   return (u_char*)&amp;GVars.stwRandom;</span>
1843 }
1844 












1845 void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {
1846   assert(on_exit || SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1847 
1848   LogStreamHandle(Debug, monitorinflation) lsh_debug;
1849   LogStreamHandle(Info, monitorinflation) lsh_info;
1850   LogStreamHandle(Trace, monitorinflation) lsh_trace;
<span class="line-modified">1851   LogStream * ls = NULL;</span>
1852   if (log_is_enabled(Trace, monitorinflation)) {
1853     ls = &amp;lsh_trace;
1854   } else if (log_is_enabled(Debug, monitorinflation)) {
1855     ls = &amp;lsh_debug;
1856   } else if (log_is_enabled(Info, monitorinflation)) {
1857     ls = &amp;lsh_info;
1858   }
1859   assert(ls != NULL, &quot;sanity check&quot;);
1860 
<span class="line-removed">1861   if (!on_exit) {</span>
<span class="line-removed">1862     // Not at VM exit so grab the global list lock.</span>
<span class="line-removed">1863     Thread::muxAcquire(&amp;gListLock, &quot;audit_and_print_stats&quot;);</span>
<span class="line-removed">1864   }</span>
<span class="line-removed">1865 </span>
1866   // Log counts for the global and per-thread monitor lists:
<span class="line-modified">1867   int chkMonitorPopulation = log_monitor_list_counts(ls);</span>
1868   int error_cnt = 0;
1869 
1870   ls-&gt;print_cr(&quot;Checking global lists:&quot;);
1871 
<span class="line-modified">1872   // Check gMonitorPopulation:</span>
<span class="line-modified">1873   if (gMonitorPopulation == chkMonitorPopulation) {</span>
<span class="line-modified">1874      ls-&gt;print_cr(&quot;gMonitorPopulation=%d equals chkMonitorPopulation=%d&quot;,</span>
<span class="line-modified">1875                   gMonitorPopulation, chkMonitorPopulation);</span>
1876   } else {
<span class="line-modified">1877      ls-&gt;print_cr(&quot;ERROR: gMonitorPopulation=%d is not equal to &quot;</span>
<span class="line-modified">1878                   &quot;chkMonitorPopulation=%d&quot;, gMonitorPopulation,</span>
<span class="line-modified">1879                   chkMonitorPopulation);</span>
<span class="line-modified">1880      error_cnt++;</span>




1881   }
1882 
<span class="line-modified">1883   // Check gOmInUseList and gOmInUseCount:</span>
1884   chk_global_in_use_list_and_count(ls, &amp;error_cnt);
1885 
<span class="line-modified">1886   // Check gFreeList and gMonitorFreeCount:</span>
1887   chk_global_free_list_and_count(ls, &amp;error_cnt);
1888 
<span class="line-removed">1889   if (!on_exit) {</span>
<span class="line-removed">1890     Thread::muxRelease(&amp;gListLock);</span>
<span class="line-removed">1891   }</span>
<span class="line-removed">1892 </span>
1893   ls-&gt;print_cr(&quot;Checking per-thread lists:&quot;);
1894 
1895   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-modified">1896     // Check omInUseList and omInUseCount:</span>
1897     chk_per_thread_in_use_list_and_count(jt, ls, &amp;error_cnt);
1898 
<span class="line-modified">1899     // Check omFreeList and omFreeCount:</span>
1900     chk_per_thread_free_list_and_count(jt, ls, &amp;error_cnt);
1901   }
1902 
1903   if (error_cnt == 0) {
1904     ls-&gt;print_cr(&quot;No errors found in monitor list checks.&quot;);
1905   } else {
1906     log_error(monitorinflation)(&quot;found monitor list errors: error_cnt=%d&quot;, error_cnt);
1907   }
1908 
1909   if ((on_exit &amp;&amp; log_is_enabled(Info, monitorinflation)) ||
1910       (!on_exit &amp;&amp; log_is_enabled(Trace, monitorinflation))) {
1911     // When exiting this log output is at the Info level. When called
1912     // at a safepoint, this log output is at the Trace level since
1913     // there can be a lot of it.
<span class="line-modified">1914     log_in_use_monitor_details(ls, on_exit);</span>
1915   }
1916 
1917   ls-&gt;flush();
1918 
1919   guarantee(error_cnt == 0, &quot;ERROR: found monitor list errors: error_cnt=%d&quot;, error_cnt);
1920 }
1921 
1922 // Check a free monitor entry; log any errors.
<span class="line-modified">1923 void ObjectSynchronizer::chk_free_entry(JavaThread * jt, ObjectMonitor * n,</span>
1924                                         outputStream * out, int *error_cnt_p) {

1925   if (n-&gt;is_busy()) {
1926     if (jt != NULL) {
1927       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
<span class="line-modified">1928                     &quot;: free per-thread monitor must not be busy.&quot;, p2i(jt),</span>
<span class="line-modified">1929                     p2i(n));</span>
1930     } else {
1931       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
<span class="line-modified">1932                     &quot;must not be busy.&quot;, p2i(n));</span>
1933     }
1934     *error_cnt_p = *error_cnt_p + 1;
1935   }
<span class="line-modified">1936   if (n-&gt;header() != NULL) {</span>
1937     if (jt != NULL) {
1938       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
1939                     &quot;: free per-thread monitor must have NULL _header &quot;
1940                     &quot;field: _header=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
<span class="line-modified">1941                     p2i(n-&gt;header()));</span>
1942     } else {
1943       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
1944                     &quot;must have NULL _header field: _header=&quot; INTPTR_FORMAT,
<span class="line-modified">1945                     p2i(n), p2i(n-&gt;header()));</span>
1946     }
1947     *error_cnt_p = *error_cnt_p + 1;
1948   }
1949   if (n-&gt;object() != NULL) {
1950     if (jt != NULL) {
1951       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
1952                     &quot;: free per-thread monitor must have NULL _object &quot;
1953                     &quot;field: _object=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
1954                     p2i(n-&gt;object()));
1955     } else {
1956       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
1957                     &quot;must have NULL _object field: _object=&quot; INTPTR_FORMAT,
1958                     p2i(n), p2i(n-&gt;object()));
1959     }
1960     *error_cnt_p = *error_cnt_p + 1;
1961   }
1962 }
1963 


















1964 // Check the global free list and count; log the results of the checks.
1965 void ObjectSynchronizer::chk_global_free_list_and_count(outputStream * out,
1966                                                         int *error_cnt_p) {
<span class="line-modified">1967   int chkMonitorFreeCount = 0;</span>
<span class="line-modified">1968   for (ObjectMonitor * n = gFreeList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">1969     chk_free_entry(NULL /* jt */, n, out, error_cnt_p);</span>
<span class="line-modified">1970     chkMonitorFreeCount++;</span>
<span class="line-modified">1971   }</span>
<span class="line-modified">1972   if (gMonitorFreeCount == chkMonitorFreeCount) {</span>
<span class="line-modified">1973     out-&gt;print_cr(&quot;gMonitorFreeCount=%d equals chkMonitorFreeCount=%d&quot;,</span>
<span class="line-modified">1974                   gMonitorFreeCount, chkMonitorFreeCount);</span>










1975   } else {
<span class="line-modified">1976     out-&gt;print_cr(&quot;ERROR: gMonitorFreeCount=%d is not equal to &quot;</span>
<span class="line-modified">1977                   &quot;chkMonitorFreeCount=%d&quot;, gMonitorFreeCount,</span>
<span class="line-modified">1978                   chkMonitorFreeCount);</span>
<span class="line-modified">1979     *error_cnt_p = *error_cnt_p + 1;</span>



1980   }
1981 }
1982 
1983 // Check the global in-use list and count; log the results of the checks.
1984 void ObjectSynchronizer::chk_global_in_use_list_and_count(outputStream * out,
1985                                                           int *error_cnt_p) {
<span class="line-modified">1986   int chkOmInUseCount = 0;</span>
<span class="line-modified">1987   for (ObjectMonitor * n = gOmInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">1988     chk_in_use_entry(NULL /* jt */, n, out, error_cnt_p);</span>
<span class="line-modified">1989     chkOmInUseCount++;</span>
<span class="line-modified">1990   }</span>
<span class="line-modified">1991   if (gOmInUseCount == chkOmInUseCount) {</span>
<span class="line-modified">1992     out-&gt;print_cr(&quot;gOmInUseCount=%d equals chkOmInUseCount=%d&quot;, gOmInUseCount,</span>
<span class="line-modified">1993                   chkOmInUseCount);</span>










1994   } else {
<span class="line-modified">1995     out-&gt;print_cr(&quot;ERROR: gOmInUseCount=%d is not equal to chkOmInUseCount=%d&quot;,</span>
<span class="line-modified">1996                   gOmInUseCount, chkOmInUseCount);</span>
<span class="line-modified">1997     *error_cnt_p = *error_cnt_p + 1;</span>


1998   }
1999 }
2000 
2001 // Check an in-use monitor entry; log any errors.
<span class="line-modified">2002 void ObjectSynchronizer::chk_in_use_entry(JavaThread * jt, ObjectMonitor * n,</span>
2003                                           outputStream * out, int *error_cnt_p) {
<span class="line-modified">2004   if (n-&gt;header() == NULL) {</span>
2005     if (jt != NULL) {
2006       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2007                     &quot;: in-use per-thread monitor must have non-NULL _header &quot;
2008                     &quot;field.&quot;, p2i(jt), p2i(n));
2009     } else {
2010       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global monitor &quot;
2011                     &quot;must have non-NULL _header field.&quot;, p2i(n));
2012     }
2013     *error_cnt_p = *error_cnt_p + 1;
2014   }
2015   if (n-&gt;object() == NULL) {
2016     if (jt != NULL) {
2017       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2018                     &quot;: in-use per-thread monitor must have non-NULL _object &quot;
2019                     &quot;field.&quot;, p2i(jt), p2i(n));
2020     } else {
2021       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global monitor &quot;
2022                     &quot;must have non-NULL _object field.&quot;, p2i(n));
2023     }
2024     *error_cnt_p = *error_cnt_p + 1;
2025   }
2026   const oop obj = (oop)n-&gt;object();
<span class="line-modified">2027   const markOop mark = obj-&gt;mark();</span>
<span class="line-modified">2028   if (!mark-&gt;has_monitor()) {</span>
2029     if (jt != NULL) {
2030       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2031                     &quot;: in-use per-thread monitor&#39;s object does not think &quot;
2032                     &quot;it has a monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
<span class="line-modified">2033                     INTPTR_FORMAT,  p2i(jt), p2i(n), p2i((address)obj),</span>
<span class="line-removed">2034                     p2i((address)mark));</span>
2035     } else {
2036       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
2037                     &quot;monitor&#39;s object does not think it has a monitor: obj=&quot;
2038                     INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT, p2i(n),
<span class="line-modified">2039                     p2i((address)obj), p2i((address)mark));</span>
2040     }
2041     *error_cnt_p = *error_cnt_p + 1;
2042   }
<span class="line-modified">2043   ObjectMonitor * const obj_mon = mark-&gt;monitor();</span>
2044   if (n != obj_mon) {
2045     if (jt != NULL) {
2046       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2047                     &quot;: in-use per-thread monitor&#39;s object does not refer &quot;
2048                     &quot;to the same monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
2049                     INTPTR_FORMAT &quot;, obj_mon=&quot; INTPTR_FORMAT, p2i(jt),
<span class="line-modified">2050                     p2i(n), p2i((address)obj), p2i((address)mark),</span>
<span class="line-removed">2051                     p2i((address)obj_mon));</span>
2052     } else {
2053       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
2054                     &quot;monitor&#39;s object does not refer to the same monitor: obj=&quot;
2055                     INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT &quot;, obj_mon=&quot;
<span class="line-modified">2056                     INTPTR_FORMAT, p2i(n), p2i((address)obj),</span>
<span class="line-removed">2057                     p2i((address)mark), p2i((address)obj_mon));</span>
2058     }
2059     *error_cnt_p = *error_cnt_p + 1;
2060   }
2061 }
2062 
2063 // Check the thread&#39;s free list and count; log the results of the checks.
2064 void ObjectSynchronizer::chk_per_thread_free_list_and_count(JavaThread *jt,
2065                                                             outputStream * out,
2066                                                             int *error_cnt_p) {
<span class="line-modified">2067   int chkOmFreeCount = 0;</span>
<span class="line-modified">2068   for (ObjectMonitor * n = jt-&gt;omFreeList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">2069     chk_free_entry(jt, n, out, error_cnt_p);</span>
<span class="line-modified">2070     chkOmFreeCount++;</span>
<span class="line-modified">2071   }</span>
<span class="line-modified">2072   if (jt-&gt;omFreeCount == chkOmFreeCount) {</span>
<span class="line-modified">2073     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: omFreeCount=%d equals &quot;</span>
<span class="line-modified">2074                   &quot;chkOmFreeCount=%d&quot;, p2i(jt), jt-&gt;omFreeCount, chkOmFreeCount);</span>










2075   } else {
<span class="line-modified">2076     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: omFreeCount=%d is not &quot;</span>
<span class="line-modified">2077                   &quot;equal to chkOmFreeCount=%d&quot;, p2i(jt), jt-&gt;omFreeCount,</span>
<span class="line-modified">2078                   chkOmFreeCount);</span>
2079     *error_cnt_p = *error_cnt_p + 1;
2080   }
2081 }
2082 
2083 // Check the thread&#39;s in-use list and count; log the results of the checks.
2084 void ObjectSynchronizer::chk_per_thread_in_use_list_and_count(JavaThread *jt,
2085                                                               outputStream * out,
2086                                                               int *error_cnt_p) {
<span class="line-modified">2087   int chkOmInUseCount = 0;</span>
<span class="line-modified">2088   for (ObjectMonitor * n = jt-&gt;omInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">2089     chk_in_use_entry(jt, n, out, error_cnt_p);</span>
<span class="line-modified">2090     chkOmInUseCount++;</span>
<span class="line-modified">2091   }</span>
<span class="line-modified">2092   if (jt-&gt;omInUseCount == chkOmInUseCount) {</span>
<span class="line-modified">2093     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: omInUseCount=%d equals &quot;</span>
<span class="line-modified">2094                   &quot;chkOmInUseCount=%d&quot;, p2i(jt), jt-&gt;omInUseCount,</span>
<span class="line-modified">2095                   chkOmInUseCount);</span>










2096   } else {
<span class="line-modified">2097     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: omInUseCount=%d is not &quot;</span>
<span class="line-modified">2098                   &quot;equal to chkOmInUseCount=%d&quot;, p2i(jt), jt-&gt;omInUseCount,</span>
<span class="line-modified">2099                   chkOmInUseCount);</span>
2100     *error_cnt_p = *error_cnt_p + 1;
2101   }
2102 }
2103 
2104 // Log details about ObjectMonitors on the in-use lists. The &#39;BHL&#39;
2105 // flags indicate why the entry is in-use, &#39;object&#39; and &#39;object type&#39;
2106 // indicate the associated object and its type.
<span class="line-modified">2107 void ObjectSynchronizer::log_in_use_monitor_details(outputStream * out,</span>
<span class="line-modified">2108                                                     bool on_exit) {</span>
<span class="line-modified">2109   if (!on_exit) {</span>
<span class="line-removed">2110     // Not at VM exit so grab the global list lock.</span>
<span class="line-removed">2111     Thread::muxAcquire(&amp;gListLock, &quot;log_in_use_monitor_details&quot;);</span>
<span class="line-removed">2112   }</span>
<span class="line-removed">2113 </span>
<span class="line-removed">2114   if (gOmInUseCount &gt; 0) {</span>
2115     out-&gt;print_cr(&quot;In-use global monitor info:&quot;);
<span class="line-modified">2116     out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hashcode, L -&gt; lock status)&quot;);</span>
2117     out-&gt;print_cr(&quot;%18s  %s  %18s  %18s&quot;,
2118                   &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
2119     out-&gt;print_cr(&quot;==================  ===  ==================  ==================&quot;);
<span class="line-modified">2120     for (ObjectMonitor * n = gOmInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">2121       const oop obj = (oop) n-&gt;object();</span>
<span class="line-modified">2122       const markOop mark = n-&gt;header();</span>
<span class="line-modified">2123       ResourceMark rm;</span>
<span class="line-modified">2124       out-&gt;print_cr(INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT &quot;  %s&quot;, p2i(n),</span>
<span class="line-modified">2125                     n-&gt;is_busy() != 0, mark-&gt;hash() != 0, n-&gt;owner() != NULL,</span>
<span class="line-modified">2126                     p2i(obj), obj-&gt;klass()-&gt;external_name());</span>
<span class="line-modified">2127     }</span>
<span class="line-modified">2128   }</span>






2129 
<span class="line-modified">2130   if (!on_exit) {</span>
<span class="line-modified">2131     Thread::muxRelease(&amp;gListLock);</span>




2132   }
2133 
2134   out-&gt;print_cr(&quot;In-use per-thread monitor info:&quot;);
<span class="line-modified">2135   out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hashcode, L -&gt; lock status)&quot;);</span>
2136   out-&gt;print_cr(&quot;%18s  %18s  %s  %18s  %18s&quot;,
2137                 &quot;jt&quot;, &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
2138   out-&gt;print_cr(&quot;==================  ==================  ===  ==================  ==================&quot;);
2139   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-modified">2140     for (ObjectMonitor * n = jt-&gt;omInUseList; n != NULL; n = n-&gt;FreeNext) {</span>
<span class="line-modified">2141       const oop obj = (oop) n-&gt;object();</span>
<span class="line-modified">2142       const markOop mark = n-&gt;header();</span>
<span class="line-modified">2143       ResourceMark rm;</span>
<span class="line-modified">2144       out-&gt;print_cr(INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT</span>
<span class="line-modified">2145                     &quot;  %s&quot;, p2i(jt), p2i(n), n-&gt;is_busy() != 0,</span>
<span class="line-modified">2146                     mark-&gt;hash() != 0, n-&gt;owner() != NULL, p2i(obj),</span>
<span class="line-modified">2147                     obj-&gt;klass()-&gt;external_name());</span>














2148     }
2149   }
2150 
2151   out-&gt;flush();
2152 }
2153 
2154 // Log counts for the global and per-thread monitor lists and return
2155 // the population count.
2156 int ObjectSynchronizer::log_monitor_list_counts(outputStream * out) {
<span class="line-modified">2157   int popCount = 0;</span>
2158   out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
2159                 &quot;Global Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Total&quot;);
2160   out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
<span class="line-modified">2161   out-&gt;print_cr(&quot;%18s  %10d  %10d  %10d&quot;, &quot;&quot;,</span>
<span class="line-modified">2162                 gOmInUseCount, gMonitorFreeCount, gMonitorPopulation);</span>
<span class="line-modified">2163   popCount += gOmInUseCount + gMonitorFreeCount;</span>


2164 
2165   out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
2166                 &quot;Per-Thread Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Provision&quot;);
2167   out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
2168 
2169   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {


2170     out-&gt;print_cr(INTPTR_FORMAT &quot;  %10d  %10d  %10d&quot;, p2i(jt),
<span class="line-modified">2171                   jt-&gt;omInUseCount, jt-&gt;omFreeCount, jt-&gt;omFreeProvision);</span>
<span class="line-modified">2172     popCount += jt-&gt;omInUseCount + jt-&gt;omFreeCount;</span>
2173   }
<span class="line-modified">2174   return popCount;</span>
2175 }
2176 
2177 #ifndef PRODUCT
2178 
2179 // Check if monitor belongs to the monitor cache
2180 // The list is grow-only so it&#39;s *relatively* safe to traverse
2181 // the list of extant blocks without taking a lock.
2182 
2183 int ObjectSynchronizer::verify_objmon_isinpool(ObjectMonitor *monitor) {
<span class="line-modified">2184   PaddedEnd&lt;ObjectMonitor&gt; * block = OrderAccess::load_acquire(&amp;gBlockList);</span>
2185   while (block != NULL) {
2186     assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
2187     if (monitor &gt; &amp;block[0] &amp;&amp; monitor &lt; &amp;block[_BLOCKSIZE]) {
2188       address mon = (address)monitor;
2189       address blk = (address)block;
2190       size_t diff = mon - blk;
<span class="line-modified">2191       assert((diff % sizeof(PaddedEnd&lt;ObjectMonitor&gt;)) == 0, &quot;must be aligned&quot;);</span>
2192       return 1;
2193     }
<span class="line-modified">2194     block = (PaddedEnd&lt;ObjectMonitor&gt; *)block-&gt;FreeNext;</span>


2195   }
2196   return 0;
2197 }
2198 
2199 #endif
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/vmSymbols.hpp&quot;
  27 #include &quot;logging/log.hpp&quot;
  28 #include &quot;logging/logStream.hpp&quot;
  29 #include &quot;jfr/jfrEvents.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;memory/metaspaceShared.hpp&quot;
  32 #include &quot;memory/padded.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">  34 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">  35 #include &quot;oops/markWord.hpp&quot;</span>
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;runtime/atomic.hpp&quot;
  38 #include &quot;runtime/biasedLocking.hpp&quot;
  39 #include &quot;runtime/handles.inline.hpp&quot;
  40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  41 #include &quot;runtime/mutexLocker.hpp&quot;
  42 #include &quot;runtime/objectMonitor.hpp&quot;
  43 #include &quot;runtime/objectMonitor.inline.hpp&quot;
  44 #include &quot;runtime/osThread.hpp&quot;
  45 #include &quot;runtime/safepointVerifiers.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/stubRoutines.hpp&quot;
  48 #include &quot;runtime/synchronizer.hpp&quot;
  49 #include &quot;runtime/thread.inline.hpp&quot;
  50 #include &quot;runtime/timer.hpp&quot;
  51 #include &quot;runtime/vframe.hpp&quot;
  52 #include &quot;runtime/vmThread.hpp&quot;
  53 #include &quot;utilities/align.hpp&quot;
  54 #include &quot;utilities/dtrace.hpp&quot;
  55 #include &quot;utilities/events.hpp&quot;
</pre>
<hr />
<pre>
 100     }                                                                      \
 101   }
 102 
 103 #else //  ndef DTRACE_ENABLED
 104 
 105 #define DTRACE_MONITOR_WAIT_PROBE(obj, thread, millis, mon)    {;}
 106 #define DTRACE_MONITOR_PROBE(probe, obj, thread, mon)          {;}
 107 
 108 #endif // ndef DTRACE_ENABLED
 109 
 110 // This exists only as a workaround of dtrace bug 6254741
 111 int dtrace_waited_probe(ObjectMonitor* monitor, Handle obj, Thread* thr) {
 112   DTRACE_MONITOR_PROBE(waited, monitor, obj(), thr);
 113   return 0;
 114 }
 115 
 116 #define NINFLATIONLOCKS 256
 117 static volatile intptr_t gInflationLocks[NINFLATIONLOCKS];
 118 
 119 // global list of blocks of monitors
<span class="line-modified"> 120 PaddedObjectMonitor* ObjectSynchronizer::g_block_list = NULL;</span>
<span class="line-modified"> 121 </span>
<span class="line-modified"> 122 struct ObjectMonitorListGlobals {</span>
<span class="line-modified"> 123   char         _pad_prefix[OM_CACHE_LINE_SIZE];</span>
<span class="line-modified"> 124   // These are highly shared list related variables.</span>
<span class="line-modified"> 125   // To avoid false-sharing they need to be the sole occupants of a cache line.</span>
<span class="line-modified"> 126 </span>
<span class="line-modified"> 127   // Global ObjectMonitor free list. Newly allocated and deflated</span>
<span class="line-modified"> 128   // ObjectMonitors are prepended here.</span>
<span class="line-modified"> 129   ObjectMonitor* _free_list;</span>
<span class="line-modified"> 130   DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));</span>
<span class="line-modified"> 131 </span>
<span class="line-added"> 132   // Global ObjectMonitor in-use list. When a JavaThread is exiting,</span>
<span class="line-added"> 133   // ObjectMonitors on its per-thread in-use list are prepended here.</span>
<span class="line-added"> 134   ObjectMonitor* _in_use_list;</span>
<span class="line-added"> 135   DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));</span>
<span class="line-added"> 136 </span>
<span class="line-added"> 137   int _free_count;    // # on free_list</span>
<span class="line-added"> 138   DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(int));</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140   int _in_use_count;  // # on in_use_list</span>
<span class="line-added"> 141   DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));</span>
<span class="line-added"> 142 </span>
<span class="line-added"> 143   int _population;    // # Extant -- in circulation</span>
<span class="line-added"> 144   DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));</span>
<span class="line-added"> 145 };</span>
<span class="line-added"> 146 static ObjectMonitorListGlobals om_list_globals;</span>
 147 
 148 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 149 
 150 
<span class="line-added"> 151 // =====================&gt; Spin-lock functions</span>
<span class="line-added"> 152 </span>
<span class="line-added"> 153 // ObjectMonitors are not lockable outside of this file. We use spin-locks</span>
<span class="line-added"> 154 // implemented using a bit in the _next_om field instead of the heavier</span>
<span class="line-added"> 155 // weight locking mechanisms for faster list management.</span>
<span class="line-added"> 156 </span>
<span class="line-added"> 157 #define OM_LOCK_BIT 0x1</span>
<span class="line-added"> 158 </span>
<span class="line-added"> 159 // Return true if the ObjectMonitor is locked.</span>
<span class="line-added"> 160 // Otherwise returns false.</span>
<span class="line-added"> 161 static bool is_locked(ObjectMonitor* om) {</span>
<span class="line-added"> 162   return ((intptr_t)om-&gt;next_om() &amp; OM_LOCK_BIT) == OM_LOCK_BIT;</span>
<span class="line-added"> 163 }</span>
<span class="line-added"> 164 </span>
<span class="line-added"> 165 // Mark an ObjectMonitor* with OM_LOCK_BIT and return it.</span>
<span class="line-added"> 166 static ObjectMonitor* mark_om_ptr(ObjectMonitor* om) {</span>
<span class="line-added"> 167   return (ObjectMonitor*)((intptr_t)om | OM_LOCK_BIT);</span>
<span class="line-added"> 168 }</span>
<span class="line-added"> 169 </span>
<span class="line-added"> 170 // Return the unmarked next field in an ObjectMonitor. Note: the next</span>
<span class="line-added"> 171 // field may or may not have been marked with OM_LOCK_BIT originally.</span>
<span class="line-added"> 172 static ObjectMonitor* unmarked_next(ObjectMonitor* om) {</span>
<span class="line-added"> 173   return (ObjectMonitor*)((intptr_t)om-&gt;next_om() &amp; ~OM_LOCK_BIT);</span>
<span class="line-added"> 174 }</span>
<span class="line-added"> 175 </span>
<span class="line-added"> 176 // Try to lock an ObjectMonitor. Returns true if locking was successful.</span>
<span class="line-added"> 177 // Otherwise returns false.</span>
<span class="line-added"> 178 static bool try_om_lock(ObjectMonitor* om) {</span>
<span class="line-added"> 179   // Get current next field without any OM_LOCK_BIT value.</span>
<span class="line-added"> 180   ObjectMonitor* next = unmarked_next(om);</span>
<span class="line-added"> 181   if (om-&gt;try_set_next_om(next, mark_om_ptr(next)) != next) {</span>
<span class="line-added"> 182     return false;  // Cannot lock the ObjectMonitor.</span>
<span class="line-added"> 183   }</span>
<span class="line-added"> 184   return true;</span>
<span class="line-added"> 185 }</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187 // Lock an ObjectMonitor.</span>
<span class="line-added"> 188 static void om_lock(ObjectMonitor* om) {</span>
<span class="line-added"> 189   while (true) {</span>
<span class="line-added"> 190     if (try_om_lock(om)) {</span>
<span class="line-added"> 191       return;</span>
<span class="line-added"> 192     }</span>
<span class="line-added"> 193   }</span>
<span class="line-added"> 194 }</span>
<span class="line-added"> 195 </span>
<span class="line-added"> 196 // Unlock an ObjectMonitor.</span>
<span class="line-added"> 197 static void om_unlock(ObjectMonitor* om) {</span>
<span class="line-added"> 198   ObjectMonitor* next = om-&gt;next_om();</span>
<span class="line-added"> 199   guarantee(((intptr_t)next &amp; OM_LOCK_BIT) == OM_LOCK_BIT, &quot;next=&quot; INTPTR_FORMAT</span>
<span class="line-added"> 200             &quot; must have OM_LOCK_BIT=%x set.&quot;, p2i(next), OM_LOCK_BIT);</span>
<span class="line-added"> 201 </span>
<span class="line-added"> 202   next = (ObjectMonitor*)((intptr_t)next &amp; ~OM_LOCK_BIT);  // Clear OM_LOCK_BIT.</span>
<span class="line-added"> 203   om-&gt;set_next_om(next);</span>
<span class="line-added"> 204 }</span>
<span class="line-added"> 205 </span>
<span class="line-added"> 206 // Get the list head after locking it. Returns the list head or NULL</span>
<span class="line-added"> 207 // if the list is empty.</span>
<span class="line-added"> 208 static ObjectMonitor* get_list_head_locked(ObjectMonitor** list_p) {</span>
<span class="line-added"> 209   while (true) {</span>
<span class="line-added"> 210     ObjectMonitor* mid = Atomic::load(list_p);</span>
<span class="line-added"> 211     if (mid == NULL) {</span>
<span class="line-added"> 212       return NULL;  // The list is empty.</span>
<span class="line-added"> 213     }</span>
<span class="line-added"> 214     if (try_om_lock(mid)) {</span>
<span class="line-added"> 215       if (Atomic::load(list_p) != mid) {</span>
<span class="line-added"> 216         // The list head changed before we could lock it so we have to retry.</span>
<span class="line-added"> 217         om_unlock(mid);</span>
<span class="line-added"> 218         continue;</span>
<span class="line-added"> 219       }</span>
<span class="line-added"> 220       return mid;</span>
<span class="line-added"> 221     }</span>
<span class="line-added"> 222   }</span>
<span class="line-added"> 223 }</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225 #undef OM_LOCK_BIT</span>
<span class="line-added"> 226 </span>
<span class="line-added"> 227 </span>
<span class="line-added"> 228 // =====================&gt; List Management functions</span>
<span class="line-added"> 229 </span>
<span class="line-added"> 230 // Prepend a list of ObjectMonitors to the specified *list_p. &#39;tail&#39; is</span>
<span class="line-added"> 231 // the last ObjectMonitor in the list and there are &#39;count&#39; on the list.</span>
<span class="line-added"> 232 // Also updates the specified *count_p.</span>
<span class="line-added"> 233 static void prepend_list_to_common(ObjectMonitor* list, ObjectMonitor* tail,</span>
<span class="line-added"> 234                                    int count, ObjectMonitor** list_p,</span>
<span class="line-added"> 235                                    int* count_p) {</span>
<span class="line-added"> 236   while (true) {</span>
<span class="line-added"> 237     ObjectMonitor* cur = Atomic::load(list_p);</span>
<span class="line-added"> 238     // Prepend list to *list_p.</span>
<span class="line-added"> 239     if (!try_om_lock(tail)) {</span>
<span class="line-added"> 240       // Failed to lock tail due to a list walker so try it all again.</span>
<span class="line-added"> 241       continue;</span>
<span class="line-added"> 242     }</span>
<span class="line-added"> 243     tail-&gt;set_next_om(cur);  // tail now points to cur (and unlocks tail)</span>
<span class="line-added"> 244     if (cur == NULL) {</span>
<span class="line-added"> 245       // No potential race with takers or other prependers since</span>
<span class="line-added"> 246       // *list_p is empty.</span>
<span class="line-added"> 247       if (Atomic::cmpxchg(list_p, cur, list) == cur) {</span>
<span class="line-added"> 248         // Successfully switched *list_p to the list value.</span>
<span class="line-added"> 249         Atomic::add(count_p, count);</span>
<span class="line-added"> 250         break;</span>
<span class="line-added"> 251       }</span>
<span class="line-added"> 252       // Implied else: try it all again</span>
<span class="line-added"> 253     } else {</span>
<span class="line-added"> 254       if (!try_om_lock(cur)) {</span>
<span class="line-added"> 255         continue;  // failed to lock cur so try it all again</span>
<span class="line-added"> 256       }</span>
<span class="line-added"> 257       // We locked cur so try to switch *list_p to the list value.</span>
<span class="line-added"> 258       if (Atomic::cmpxchg(list_p, cur, list) != cur) {</span>
<span class="line-added"> 259         // The list head has changed so unlock cur and try again:</span>
<span class="line-added"> 260         om_unlock(cur);</span>
<span class="line-added"> 261         continue;</span>
<span class="line-added"> 262       }</span>
<span class="line-added"> 263       Atomic::add(count_p, count);</span>
<span class="line-added"> 264       om_unlock(cur);</span>
<span class="line-added"> 265       break;</span>
<span class="line-added"> 266     }</span>
<span class="line-added"> 267   }</span>
<span class="line-added"> 268 }</span>
<span class="line-added"> 269 </span>
<span class="line-added"> 270 // Prepend a newly allocated block of ObjectMonitors to g_block_list and</span>
<span class="line-added"> 271 // om_list_globals._free_list. Also updates om_list_globals._population</span>
<span class="line-added"> 272 // and om_list_globals._free_count.</span>
<span class="line-added"> 273 void ObjectSynchronizer::prepend_block_to_lists(PaddedObjectMonitor* new_blk) {</span>
<span class="line-added"> 274   // First we handle g_block_list:</span>
<span class="line-added"> 275   while (true) {</span>
<span class="line-added"> 276     PaddedObjectMonitor* cur = Atomic::load(&amp;g_block_list);</span>
<span class="line-added"> 277     // Prepend new_blk to g_block_list. The first ObjectMonitor in</span>
<span class="line-added"> 278     // a block is reserved for use as linkage to the next block.</span>
<span class="line-added"> 279     new_blk[0].set_next_om(cur);</span>
<span class="line-added"> 280     if (Atomic::cmpxchg(&amp;g_block_list, cur, new_blk) == cur) {</span>
<span class="line-added"> 281       // Successfully switched g_block_list to the new_blk value.</span>
<span class="line-added"> 282       Atomic::add(&amp;om_list_globals._population, _BLOCKSIZE - 1);</span>
<span class="line-added"> 283       break;</span>
<span class="line-added"> 284     }</span>
<span class="line-added"> 285     // Implied else: try it all again</span>
<span class="line-added"> 286   }</span>
<span class="line-added"> 287 </span>
<span class="line-added"> 288   // Second we handle om_list_globals._free_list:</span>
<span class="line-added"> 289   prepend_list_to_common(new_blk + 1, &amp;new_blk[_BLOCKSIZE - 1], _BLOCKSIZE - 1,</span>
<span class="line-added"> 290                          &amp;om_list_globals._free_list, &amp;om_list_globals._free_count);</span>
<span class="line-added"> 291 }</span>
<span class="line-added"> 292 </span>
<span class="line-added"> 293 // Prepend a list of ObjectMonitors to om_list_globals._free_list.</span>
<span class="line-added"> 294 // &#39;tail&#39; is the last ObjectMonitor in the list and there are &#39;count&#39;</span>
<span class="line-added"> 295 // on the list. Also updates om_list_globals._free_count.</span>
<span class="line-added"> 296 static void prepend_list_to_global_free_list(ObjectMonitor* list,</span>
<span class="line-added"> 297                                              ObjectMonitor* tail, int count) {</span>
<span class="line-added"> 298   prepend_list_to_common(list, tail, count, &amp;om_list_globals._free_list,</span>
<span class="line-added"> 299                          &amp;om_list_globals._free_count);</span>
<span class="line-added"> 300 }</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302 // Prepend a list of ObjectMonitors to om_list_globals._in_use_list.</span>
<span class="line-added"> 303 // &#39;tail&#39; is the last ObjectMonitor in the list and there are &#39;count&#39;</span>
<span class="line-added"> 304 // on the list. Also updates om_list_globals._in_use_list.</span>
<span class="line-added"> 305 static void prepend_list_to_global_in_use_list(ObjectMonitor* list,</span>
<span class="line-added"> 306                                                ObjectMonitor* tail, int count) {</span>
<span class="line-added"> 307   prepend_list_to_common(list, tail, count, &amp;om_list_globals._in_use_list,</span>
<span class="line-added"> 308                          &amp;om_list_globals._in_use_count);</span>
<span class="line-added"> 309 }</span>
<span class="line-added"> 310 </span>
<span class="line-added"> 311 // Prepend an ObjectMonitor to the specified list. Also updates</span>
<span class="line-added"> 312 // the specified counter.</span>
<span class="line-added"> 313 static void prepend_to_common(ObjectMonitor* m, ObjectMonitor** list_p,</span>
<span class="line-added"> 314                               int* count_p) {</span>
<span class="line-added"> 315   while (true) {</span>
<span class="line-added"> 316     om_lock(m);  // Lock m so we can safely update its next field.</span>
<span class="line-added"> 317     ObjectMonitor* cur = NULL;</span>
<span class="line-added"> 318     // Lock the list head to guard against races with a list walker</span>
<span class="line-added"> 319     // thread:</span>
<span class="line-added"> 320     if ((cur = get_list_head_locked(list_p)) != NULL) {</span>
<span class="line-added"> 321       // List head is now locked so we can safely switch it.</span>
<span class="line-added"> 322       m-&gt;set_next_om(cur);  // m now points to cur (and unlocks m)</span>
<span class="line-added"> 323       Atomic::store(list_p, m);  // Switch list head to unlocked m.</span>
<span class="line-added"> 324       om_unlock(cur);</span>
<span class="line-added"> 325       break;</span>
<span class="line-added"> 326     }</span>
<span class="line-added"> 327     // The list is empty so try to set the list head.</span>
<span class="line-added"> 328     assert(cur == NULL, &quot;cur must be NULL: cur=&quot; INTPTR_FORMAT, p2i(cur));</span>
<span class="line-added"> 329     m-&gt;set_next_om(cur);  // m now points to NULL (and unlocks m)</span>
<span class="line-added"> 330     if (Atomic::cmpxchg(list_p, cur, m) == cur) {</span>
<span class="line-added"> 331       // List head is now unlocked m.</span>
<span class="line-added"> 332       break;</span>
<span class="line-added"> 333     }</span>
<span class="line-added"> 334     // Implied else: try it all again</span>
<span class="line-added"> 335   }</span>
<span class="line-added"> 336   Atomic::inc(count_p);</span>
<span class="line-added"> 337 }</span>
<span class="line-added"> 338 </span>
<span class="line-added"> 339 // Prepend an ObjectMonitor to a per-thread om_free_list.</span>
<span class="line-added"> 340 // Also updates the per-thread om_free_count.</span>
<span class="line-added"> 341 static void prepend_to_om_free_list(Thread* self, ObjectMonitor* m) {</span>
<span class="line-added"> 342   prepend_to_common(m, &amp;self-&gt;om_free_list, &amp;self-&gt;om_free_count);</span>
<span class="line-added"> 343 }</span>
<span class="line-added"> 344 </span>
<span class="line-added"> 345 // Prepend an ObjectMonitor to a per-thread om_in_use_list.</span>
<span class="line-added"> 346 // Also updates the per-thread om_in_use_count.</span>
<span class="line-added"> 347 static void prepend_to_om_in_use_list(Thread* self, ObjectMonitor* m) {</span>
<span class="line-added"> 348   prepend_to_common(m, &amp;self-&gt;om_in_use_list, &amp;self-&gt;om_in_use_count);</span>
<span class="line-added"> 349 }</span>
<span class="line-added"> 350 </span>
<span class="line-added"> 351 // Take an ObjectMonitor from the start of the specified list. Also</span>
<span class="line-added"> 352 // decrements the specified counter. Returns NULL if none are available.</span>
<span class="line-added"> 353 static ObjectMonitor* take_from_start_of_common(ObjectMonitor** list_p,</span>
<span class="line-added"> 354                                                 int* count_p) {</span>
<span class="line-added"> 355   ObjectMonitor* take = NULL;</span>
<span class="line-added"> 356   // Lock the list head to guard against races with a list walker</span>
<span class="line-added"> 357   // thread:</span>
<span class="line-added"> 358   if ((take = get_list_head_locked(list_p)) == NULL) {</span>
<span class="line-added"> 359     return NULL;  // None are available.</span>
<span class="line-added"> 360   }</span>
<span class="line-added"> 361   ObjectMonitor* next = unmarked_next(take);</span>
<span class="line-added"> 362   // Switch locked list head to next (which unlocks the list head, but</span>
<span class="line-added"> 363   // leaves take locked):</span>
<span class="line-added"> 364   Atomic::store(list_p, next);</span>
<span class="line-added"> 365   Atomic::dec(count_p);</span>
<span class="line-added"> 366   // Unlock take, but leave the next value for any lagging list</span>
<span class="line-added"> 367   // walkers. It will get cleaned up when take is prepended to</span>
<span class="line-added"> 368   // the in-use list:</span>
<span class="line-added"> 369   om_unlock(take);</span>
<span class="line-added"> 370   return take;</span>
<span class="line-added"> 371 }</span>
<span class="line-added"> 372 </span>
<span class="line-added"> 373 // Take an ObjectMonitor from the start of the om_list_globals._free_list.</span>
<span class="line-added"> 374 // Also updates om_list_globals._free_count. Returns NULL if none are</span>
<span class="line-added"> 375 // available.</span>
<span class="line-added"> 376 static ObjectMonitor* take_from_start_of_global_free_list() {</span>
<span class="line-added"> 377   return take_from_start_of_common(&amp;om_list_globals._free_list,</span>
<span class="line-added"> 378                                    &amp;om_list_globals._free_count);</span>
<span class="line-added"> 379 }</span>
<span class="line-added"> 380 </span>
<span class="line-added"> 381 // Take an ObjectMonitor from the start of a per-thread free-list.</span>
<span class="line-added"> 382 // Also updates om_free_count. Returns NULL if none are available.</span>
<span class="line-added"> 383 static ObjectMonitor* take_from_start_of_om_free_list(Thread* self) {</span>
<span class="line-added"> 384   return take_from_start_of_common(&amp;self-&gt;om_free_list, &amp;self-&gt;om_free_count);</span>
<span class="line-added"> 385 }</span>
<span class="line-added"> 386 </span>
<span class="line-added"> 387 </span>
 388 // =====================&gt; Quick functions
 389 
 390 // The quick_* forms are special fast-path variants used to improve
 391 // performance.  In the simplest case, a &quot;quick_*&quot; implementation could
 392 // simply return false, in which case the caller will perform the necessary
 393 // state transitions and call the slow-path form.
 394 // The fast-path is designed to handle frequently arising cases in an efficient
 395 // manner and is just a degenerate &quot;optimistic&quot; variant of the slow-path.
 396 // returns true  -- to indicate the call was satisfied.
 397 // returns false -- to indicate the call needs the services of the slow-path.
 398 // A no-loitering ordinance is in effect for code in the quick_* family
 399 // operators: safepoints or indefinite blocking (blocking that might span a
 400 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 401 // entry.
 402 //
 403 // Consider: An interesting optimization is to have the JIT recognize the
 404 // following common idiom:
 405 //   synchronized (someobj) { .... ; notify(); }
 406 // That is, we find a notify() or notifyAll() call that immediately precedes
 407 // the monitorexit operation.  In that case the JIT could fuse the operations
 408 // into a single notifyAndExit() runtime primitive.
 409 
<span class="line-modified"> 410 bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {</span>
 411   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 412   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);
 413   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);
 414   NoSafepointVerifier nsv;
 415   if (obj == NULL) return false;  // slow-path for invalid obj
<span class="line-modified"> 416   const markWord mark = obj-&gt;mark();</span>
 417 
<span class="line-modified"> 418   if (mark.has_locker() &amp;&amp; self-&gt;is_lock_owned((address)mark.locker())) {</span>
 419     // Degenerate notify
 420     // stack-locked by caller so by definition the implied waitset is empty.
 421     return true;
 422   }
 423 
<span class="line-modified"> 424   if (mark.has_monitor()) {</span>
<span class="line-modified"> 425     ObjectMonitor* const mon = mark.monitor();</span>
<span class="line-modified"> 426     assert(mon-&gt;object() == obj, &quot;invariant&quot;);</span>
 427     if (mon-&gt;owner() != self) return false;  // slow-path for IMS exception
 428 
 429     if (mon-&gt;first_waiter() != NULL) {
 430       // We have one or more waiters. Since this is an inflated monitor
 431       // that we own, we can transfer one or more threads from the waitset
 432       // to the entrylist here and now, avoiding the slow-path.
 433       if (all) {
 434         DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);
 435       } else {
 436         DTRACE_MONITOR_PROBE(notify, mon, obj, self);
 437       }
<span class="line-modified"> 438       int free_count = 0;</span>
 439       do {
 440         mon-&gt;INotify(self);
<span class="line-modified"> 441         ++free_count;</span>
 442       } while (mon-&gt;first_waiter() != NULL &amp;&amp; all);
<span class="line-modified"> 443       OM_PERFDATA_OP(Notifications, inc(free_count));</span>
 444     }
 445     return true;
 446   }
 447 
 448   // biased locking and any other IMS exception states take the slow-path
 449   return false;
 450 }
 451 
 452 
 453 // The LockNode emitted directly at the synchronization site would have
 454 // been too big if it were to have included support for the cases of inflated
 455 // recursive enter and exit, so they go here instead.
 456 // Note that we can&#39;t safely call AsyncPrintJavaStack() from within
 457 // quick_enter() as our thread state remains _in_Java.
 458 
<span class="line-modified"> 459 bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,</span>
 460                                      BasicLock * lock) {
 461   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
<span class="line-modified"> 462   assert(self-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-modified"> 463   assert(((JavaThread *) self)-&gt;thread_state() == _thread_in_Java, &quot;invariant&quot;);</span>
 464   NoSafepointVerifier nsv;
 465   if (obj == NULL) return false;       // Need to throw NPE
<span class="line-modified"> 466   const markWord mark = obj-&gt;mark();</span>
 467 
<span class="line-modified"> 468   if (mark.has_monitor()) {</span>
<span class="line-modified"> 469     ObjectMonitor* const m = mark.monitor();</span>
<span class="line-modified"> 470     assert(m-&gt;object() == obj, &quot;invariant&quot;);</span>
<span class="line-modified"> 471     Thread* const owner = (Thread *) m-&gt;_owner;</span>
 472 
 473     // Lock contention and Transactional Lock Elision (TLE) diagnostics
 474     // and observability
 475     // Case: light contention possibly amenable to TLE
 476     // Case: TLE inimical operations such as nested/recursive synchronization
 477 
<span class="line-modified"> 478     if (owner == self) {</span>
 479       m-&gt;_recursions++;
 480       return true;
 481     }
 482 
 483     // This Java Monitor is inflated so obj&#39;s header will never be
 484     // displaced to this thread&#39;s BasicLock. Make the displaced header
 485     // non-NULL so this BasicLock is not seen as recursive nor as
 486     // being locked. We do this unconditionally so that this thread&#39;s
 487     // BasicLock cannot be mis-interpreted by any stack walkers. For
 488     // performance reasons, stack walkers generally first check for
 489     // Biased Locking in the object&#39;s header, the second check is for
 490     // stack-locking in the object&#39;s header, the third check is for
 491     // recursive stack-locking in the displaced header in the BasicLock,
 492     // and last are the inflated Java Monitor (ObjectMonitor) checks.
<span class="line-modified"> 493     lock-&gt;set_displaced_header(markWord::unused_mark());</span>
 494 
<span class="line-modified"> 495     if (owner == NULL &amp;&amp; m-&gt;try_set_owner_from(NULL, self) == NULL) {</span>
 496       assert(m-&gt;_recursions == 0, &quot;invariant&quot;);

 497       return true;
 498     }
 499   }
 500 
 501   // Note that we could inflate in quick_enter.
 502   // This is likely a useful optimization
 503   // Critically, in quick_enter() we must not:
 504   // -- perform bias revocation, or
 505   // -- block indefinitely, or
 506   // -- reach a safepoint
 507 
 508   return false;        // revert to slow-path
 509 }
 510 
 511 // -----------------------------------------------------------------------------
<span class="line-modified"> 512 // Monitor Enter/Exit</span>
<span class="line-modified"> 513 // The interpreter and compiler assembly code tries to lock using the fast path</span>
<span class="line-modified"> 514 // of this algorithm. Make sure to update that code if the following function is</span>
<span class="line-modified"> 515 // changed. The implementation is extremely sensitive to race condition. Be careful.</span>
<span class="line-modified"> 516 </span>
<span class="line-modified"> 517 void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {</span>


 518   if (UseBiasedLocking) {
 519     if (!SafepointSynchronize::is_at_safepoint()) {
<span class="line-modified"> 520       BiasedLocking::revoke(obj, THREAD);</span>



 521     } else {

 522       BiasedLocking::revoke_at_safepoint(obj);
 523     }

 524   }
 525 
<span class="line-modified"> 526   markWord mark = obj-&gt;mark();</span>
<span class="line-added"> 527   assert(!mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529   if (mark.is_neutral()) {</span>
<span class="line-added"> 530     // Anticipate successful CAS -- the ST of the displaced mark must</span>
<span class="line-added"> 531     // be visible &lt;= the ST performed by the CAS.</span>
<span class="line-added"> 532     lock-&gt;set_displaced_header(mark);</span>
<span class="line-added"> 533     if (mark == obj()-&gt;cas_set_mark(markWord::from_pointer(lock), mark)) {</span>
<span class="line-added"> 534       return;</span>
<span class="line-added"> 535     }</span>
<span class="line-added"> 536     // Fall through to inflate() ...</span>
<span class="line-added"> 537   } else if (mark.has_locker() &amp;&amp;</span>
<span class="line-added"> 538              THREAD-&gt;is_lock_owned((address)mark.locker())) {</span>
<span class="line-added"> 539     assert(lock != mark.locker(), &quot;must not re-lock the same lock&quot;);</span>
<span class="line-added"> 540     assert(lock != (BasicLock*)obj-&gt;mark().value(), &quot;don&#39;t relock with same BasicLock&quot;);</span>
<span class="line-added"> 541     lock-&gt;set_displaced_header(markWord::from_pointer(NULL));</span>
<span class="line-added"> 542     return;</span>
<span class="line-added"> 543   }</span>
<span class="line-added"> 544 </span>
<span class="line-added"> 545   // The object header will never be displaced to this lock,</span>
<span class="line-added"> 546   // so it does not matter what the value is, except that it</span>
<span class="line-added"> 547   // must be non-zero to avoid looking like a re-entrant lock,</span>
<span class="line-added"> 548   // and must not look locked either.</span>
<span class="line-added"> 549   lock-&gt;set_displaced_header(markWord::unused_mark());</span>
<span class="line-added"> 550   inflate(THREAD, obj(), inflate_cause_monitor_enter)-&gt;enter(THREAD);</span>
 551 }
 552 
<span class="line-modified"> 553 void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {</span>
<span class="line-modified"> 554   markWord mark = object-&gt;mark();</span>
 555   // We cannot check for Biased Locking if we are racing an inflation.
<span class="line-modified"> 556   assert(mark == markWord::INFLATING() ||</span>
<span class="line-modified"> 557          !mark.has_bias_pattern(), &quot;should not see bias pattern here&quot;);</span>
 558 
<span class="line-modified"> 559   markWord dhw = lock-&gt;displaced_header();</span>
<span class="line-modified"> 560   if (dhw.value() == 0) {</span>
 561     // If the displaced header is NULL, then this exit matches up with
 562     // a recursive enter. No real work to do here except for diagnostics.
 563 #ifndef PRODUCT
<span class="line-modified"> 564     if (mark != markWord::INFLATING()) {</span>
 565       // Only do diagnostics if we are not racing an inflation. Simply
 566       // exiting a recursive enter of a Java Monitor that is being
 567       // inflated is safe; see the has_monitor() comment below.
<span class="line-modified"> 568       assert(!mark.is_neutral(), &quot;invariant&quot;);</span>
<span class="line-modified"> 569       assert(!mark.has_locker() ||</span>
<span class="line-modified"> 570              THREAD-&gt;is_lock_owned((address)mark.locker()), &quot;invariant&quot;);</span>
<span class="line-modified"> 571       if (mark.has_monitor()) {</span>
 572         // The BasicLock&#39;s displaced_header is marked as a recursive
 573         // enter and we have an inflated Java Monitor (ObjectMonitor).
 574         // This is a special case where the Java Monitor was inflated
 575         // after this thread entered the stack-lock recursively. When a
 576         // Java Monitor is inflated, we cannot safely walk the Java
 577         // Monitor owner&#39;s stack and update the BasicLocks because a
 578         // Java Monitor can be asynchronously inflated by a thread that
 579         // does not own the Java Monitor.
<span class="line-modified"> 580         ObjectMonitor* m = mark.monitor();</span>
 581         assert(((oop)(m-&gt;object()))-&gt;mark() == mark, &quot;invariant&quot;);
 582         assert(m-&gt;is_entered(THREAD), &quot;invariant&quot;);
 583       }
 584     }
 585 #endif
 586     return;
 587   }
 588 
<span class="line-modified"> 589   if (mark == markWord::from_pointer(lock)) {</span>
 590     // If the object is stack-locked by the current thread, try to
 591     // swing the displaced header from the BasicLock back to the mark.
<span class="line-modified"> 592     assert(dhw.is_neutral(), &quot;invariant&quot;);</span>
 593     if (object-&gt;cas_set_mark(dhw, mark) == mark) {
 594       return;
 595     }
 596   }
 597 
 598   // We have to take the slow-path of possible inflation and then exit.
 599   inflate(THREAD, object, inflate_cause_vm_internal)-&gt;exit(true, THREAD);
 600 }
 601 









































 602 // -----------------------------------------------------------------------------
 603 // Class Loader  support to workaround deadlocks on the class loader lock objects
 604 // Also used by GC
 605 // complete_exit()/reenter() are used to wait on a nested lock
 606 // i.e. to give up an outer lock completely and then re-enter
 607 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 608 //  1) complete_exit lock1 - saving recursion count
 609 //  2) wait on lock2
 610 //  3) when notified on lock2, unlock lock2
 611 //  4) reenter lock1 with original recursion count
 612 //  5) lock lock2
 613 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 614 // NOTE(TSAN): We cannot instrument complete_exit/reenter in ObjectSynchronizer
 615 //             in a manner similar to wait and waitUninterruptibly, because
 616 //             (1) recursion count stored by inflated monitor is different from
 617 //             the absolute recursion count tracked by Tsan, and (2) in the
 618 //             general case, we cannot merely store Tsan&#39;s recursion count
 619 //             once: we must track it for *each invocation* of complete_exit.
 620 //             Hence, the best place to instrument for Tsan is at the call site
 621 //             for complete_exit/reenter. Luckily, there is only one call site.
<span class="line-modified"> 622 intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {</span>
 623   if (UseBiasedLocking) {
<span class="line-modified"> 624     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified"> 625     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 626   }
 627 
 628   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 629 
 630   return monitor-&gt;complete_exit(THREAD);
 631 }
 632 
 633 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
<span class="line-modified"> 634 void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {</span>
 635   if (UseBiasedLocking) {
<span class="line-modified"> 636     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified"> 637     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 638   }
 639 
 640   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 641 
<span class="line-modified"> 642   monitor-&gt;reenter(recursions, THREAD);</span>
 643 }
 644 // -----------------------------------------------------------------------------
 645 // JNI locks on java objects
 646 // NOTE: must use heavy weight monitor to handle jni monitor enter
 647 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 648   // the current locking is from JNI instead of Java code
 649   if (UseBiasedLocking) {
<span class="line-modified"> 650     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified"> 651     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 652   }
 653   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 654   inflate(THREAD, obj(), inflate_cause_jni_enter)-&gt;enter(THREAD);
 655   THREAD-&gt;set_current_pending_monitor_is_from_java(true);
 656   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(THREAD, obj()));
 657 }
 658 
 659 // NOTE: must use heavy weight monitor to handle jni monitor exit
 660 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
 661   if (UseBiasedLocking) {
 662     Handle h_obj(THREAD, obj);
<span class="line-modified"> 663     BiasedLocking::revoke(h_obj, THREAD);</span>
 664     obj = h_obj();
 665   }
<span class="line-modified"> 666   assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 667 
 668   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
<span class="line-modified"> 669   // If this thread has locked the object, exit the monitor. We</span>
<span class="line-modified"> 670   // intentionally do not use CHECK here because we must exit the</span>
<span class="line-modified"> 671   // monitor even if an exception is pending.</span>
<span class="line-added"> 672   if (monitor-&gt;check_owner(THREAD)) {</span>
 673     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(THREAD, obj));
 674     monitor-&gt;exit(true, THREAD);
 675   }
 676 }
 677 
 678 // -----------------------------------------------------------------------------
 679 // Internal VM locks on java objects
 680 // standard constructor, allows locking failures
<span class="line-modified"> 681 ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool do_lock) {</span>
<span class="line-modified"> 682   _dolock = do_lock;</span>
 683   _thread = thread;
<span class="line-modified"> 684   _thread-&gt;check_for_valid_safepoint_state();</span>
 685   _obj = obj;
 686 
 687   if (_dolock) {
<span class="line-modified"> 688     ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);</span>
 689     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));
 690   }
 691 }
 692 
 693 ObjectLocker::~ObjectLocker() {
 694   if (_dolock) {
 695     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));
<span class="line-modified"> 696     ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);</span>
 697   }
 698 }
 699 
 700 
 701 // -----------------------------------------------------------------------------
 702 //  Wait/Notify/NotifyAll
 703 // NOTE: must use heavy weight monitor to handle wait()
 704 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
 705   if (UseBiasedLocking) {
<span class="line-modified"> 706     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified"> 707     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 708   }
 709   if (millis &lt; 0) {
 710     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 711   }
 712   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 713 
 714   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
 715 
 716   TSAN_ONLY(int tsan_rec = 0;)
 717   TSAN_RUNTIME_ONLY(
 718     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());
 719     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);
 720   );
 721 
 722   monitor-&gt;wait(millis, true, THREAD);
 723 
 724   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));
 725 
 726   // This dummy call is in place to get around dtrace bug 6254741.  Once
 727   // that&#39;s fixed we can uncomment the following line, remove the call
 728   // and change this function back into a &quot;void&quot; func.
 729   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 730   return dtrace_waited_probe(monitor, obj, THREAD);
 731 }
 732 
<span class="line-modified"> 733 void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {</span>
 734   if (UseBiasedLocking) {
<span class="line-modified"> 735     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified"> 736     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 737   }
 738   if (millis &lt; 0) {
 739     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 740   }
 741   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 742   TSAN_ONLY(int tsan_rec;)
 743   TSAN_RUNTIME_ONLY(
 744     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());
 745     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);
 746   );
 747   monitor-&gt;wait(millis, false, THREAD);
 748   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));
 749 }
 750 
 751 void ObjectSynchronizer::notify(Handle obj, TRAPS) {
 752   if (UseBiasedLocking) {
<span class="line-modified"> 753     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified"> 754     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 755   }
 756 
<span class="line-modified"> 757   markWord mark = obj-&gt;mark();</span>
<span class="line-modified"> 758   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {</span>
 759     return;
 760   }
 761   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notify(THREAD);
 762 }
 763 
 764 // NOTE: see comment of notify()
 765 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
 766   if (UseBiasedLocking) {
<span class="line-modified"> 767     BiasedLocking::revoke(obj, THREAD);</span>
<span class="line-modified"> 768     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 769   }
 770 
<span class="line-modified"> 771   markWord mark = obj-&gt;mark();</span>
<span class="line-modified"> 772   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {</span>
 773     return;
 774   }
 775   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notifyAll(THREAD);
 776 }
 777 
 778 // -----------------------------------------------------------------------------
 779 // Hash Code handling
 780 //
 781 // Performance concern:
 782 // OrderAccess::storestore() calls release() which at one time stored 0
 783 // into the global volatile OrderAccess::dummy variable. This store was
 784 // unnecessary for correctness. Many threads storing into a common location
 785 // causes considerable cache migration or &quot;sloshing&quot; on large SMP systems.
 786 // As such, I avoided using OrderAccess::storestore(). In some cases
 787 // OrderAccess::fence() -- which incurs local latency on the executing
 788 // processor -- is a better choice as it scales on SMP systems.
 789 //
 790 // See http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot for
 791 // a discussion of coherency costs. Note that all our current reference
 792 // platforms provide strong ST-ST order, so the issue is moot on IA32,
 793 // x64, and SPARC.
 794 //
 795 // As a general policy we use &quot;volatile&quot; to control compiler-based reordering
 796 // and explicit fences (barriers) to control for architectural reordering
 797 // performed by the CPU(s) or platform.
 798 
 799 struct SharedGlobals {
<span class="line-modified"> 800   char         _pad_prefix[OM_CACHE_LINE_SIZE];</span>
 801   // These are highly shared mostly-read variables.
 802   // To avoid false-sharing they need to be the sole occupants of a cache line.
<span class="line-modified"> 803   volatile int stw_random;</span>
<span class="line-modified"> 804   volatile int stw_cycle;</span>
<span class="line-modified"> 805   DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(volatile int) * 2);</span>
 806   // Hot RW variable -- Sequester to avoid false-sharing
<span class="line-modified"> 807   volatile int hc_sequence;</span>
<span class="line-modified"> 808   DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(volatile int));</span>
 809 };
 810 
 811 static SharedGlobals GVars;
<span class="line-modified"> 812 static int _forceMonitorScavenge = 0; // Scavenge required and pending</span>

 813 
<span class="line-modified"> 814 static markWord read_stable_mark(oop obj) {</span>
<span class="line-modified"> 815   markWord mark = obj-&gt;mark();</span>
<span class="line-modified"> 816   if (!mark.is_being_inflated()) {</span>
 817     return mark;       // normal fast-path return
 818   }
 819 
 820   int its = 0;
 821   for (;;) {
<span class="line-modified"> 822     markWord mark = obj-&gt;mark();</span>
<span class="line-modified"> 823     if (!mark.is_being_inflated()) {</span>
 824       return mark;    // normal fast-path return
 825     }
 826 
 827     // The object is being inflated by some other thread.
<span class="line-modified"> 828     // The caller of read_stable_mark() must wait for inflation to complete.</span>
 829     // Avoid live-lock
 830     // TODO: consider calling SafepointSynchronize::do_call_back() while
 831     // spinning to see if there&#39;s a safepoint pending.  If so, immediately
 832     // yielding or blocking would be appropriate.  Avoid spinning while
 833     // there is a safepoint pending.
 834     // TODO: add inflation contention performance counters.
 835     // TODO: restrict the aggregate number of spinners.
 836 
 837     ++its;
 838     if (its &gt; 10000 || !os::is_MP()) {
 839       if (its &amp; 1) {
 840         os::naked_yield();
 841       } else {
 842         // Note that the following code attenuates the livelock problem but is not
 843         // a complete remedy.  A more complete solution would require that the inflating
 844         // thread hold the associated inflation lock.  The following code simply restricts
 845         // the number of spinners to at most one.  We&#39;ll have N-2 threads blocked
 846         // on the inflationlock, 1 thread holding the inflation lock and using
 847         // a yield/park strategy, and 1 thread in the midst of inflation.
 848         // A more refined approach would be to change the encoding of INFLATING
 849         // to allow encapsulation of a native thread pointer.  Threads waiting for
 850         // inflation to complete would use CAS to push themselves onto a singly linked
 851         // list rooted at the markword.  Once enqueued, they&#39;d loop, checking a per-thread flag
 852         // and calling park().  When inflation was complete the thread that accomplished inflation
 853         // would detach the list and set the markword to inflated with a single CAS and
 854         // then for each thread on the list, set the flag and unpark() the thread.
 855         // This is conceptually similar to muxAcquire-muxRelease, except that muxRelease
 856         // wakes at most one thread whereas we need to wake the entire list.
 857         int ix = (cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 5) &amp; (NINFLATIONLOCKS-1);
 858         int YieldThenBlock = 0;
 859         assert(ix &gt;= 0 &amp;&amp; ix &lt; NINFLATIONLOCKS, &quot;invariant&quot;);
 860         assert((NINFLATIONLOCKS &amp; (NINFLATIONLOCKS-1)) == 0, &quot;invariant&quot;);
 861         Thread::muxAcquire(gInflationLocks + ix, &quot;gInflationLock&quot;);
<span class="line-modified"> 862         while (obj-&gt;mark() == markWord::INFLATING()) {</span>
 863           // Beware: NakedYield() is advisory and has almost no effect on some platforms
<span class="line-modified"> 864           // so we periodically call self-&gt;_ParkEvent-&gt;park(1).</span>
 865           // We use a mixed spin/yield/block mechanism.
 866           if ((YieldThenBlock++) &gt;= 16) {
 867             Thread::current()-&gt;_ParkEvent-&gt;park(1);
 868           } else {
 869             os::naked_yield();
 870           }
 871         }
 872         Thread::muxRelease(gInflationLocks + ix);
 873       }
 874     } else {
 875       SpinPause();       // SMP-polite spinning
 876     }
 877   }
 878 }
 879 
 880 // hashCode() generation :
 881 //
 882 // Possibilities:
<span class="line-modified"> 883 // * MD5Digest of {obj,stw_random}</span>
<span class="line-modified"> 884 // * CRC32 of {obj,stw_random} or any linear-feedback shift register function.</span>
 885 // * A DES- or AES-style SBox[] mechanism
 886 // * One of the Phi-based schemes, such as:
 887 //   2654435761 = 2^32 * Phi (golden ratio)
<span class="line-modified"> 888 //   HashCodeValue = ((uintptr_t(obj) &gt;&gt; 3) * 2654435761) ^ GVars.stw_random ;</span>
 889 // * A variation of Marsaglia&#39;s shift-xor RNG scheme.
<span class="line-modified"> 890 // * (obj ^ stw_random) is appealing, but can result</span>
 891 //   in undesirable regularity in the hashCode values of adjacent objects
 892 //   (objects allocated back-to-back, in particular).  This could potentially
 893 //   result in hashtable collisions and reduced hashtable efficiency.
 894 //   There are simple ways to &quot;diffuse&quot; the middle address bits over the
 895 //   generated hashCode values:
 896 
<span class="line-modified"> 897 static inline intptr_t get_next_hash(Thread* self, oop obj) {</span>
 898   intptr_t value = 0;
 899   if (hashCode == 0) {
 900     // This form uses global Park-Miller RNG.
 901     // On MP system we&#39;ll have lots of RW access to a global, so the
 902     // mechanism induces lots of coherency traffic.
 903     value = os::random();
 904   } else if (hashCode == 1) {
 905     // This variation has the property of being stable (idempotent)
 906     // between STW operations.  This can be useful in some of the 1-0
 907     // synchronization schemes.
<span class="line-modified"> 908     intptr_t addr_bits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3;</span>
<span class="line-modified"> 909     value = addr_bits ^ (addr_bits &gt;&gt; 5) ^ GVars.stw_random;</span>
 910   } else if (hashCode == 2) {
 911     value = 1;            // for sensitivity testing
 912   } else if (hashCode == 3) {
<span class="line-modified"> 913     value = ++GVars.hc_sequence;</span>
 914   } else if (hashCode == 4) {
 915     value = cast_from_oop&lt;intptr_t&gt;(obj);
 916   } else {
 917     // Marsaglia&#39;s xor-shift scheme with thread-specific state
 918     // This is probably the best overall implementation -- we&#39;ll
 919     // likely make this the default in future releases.
<span class="line-modified"> 920     unsigned t = self-&gt;_hashStateX;</span>
 921     t ^= (t &lt;&lt; 11);
<span class="line-modified"> 922     self-&gt;_hashStateX = self-&gt;_hashStateY;</span>
<span class="line-modified"> 923     self-&gt;_hashStateY = self-&gt;_hashStateZ;</span>
<span class="line-modified"> 924     self-&gt;_hashStateZ = self-&gt;_hashStateW;</span>
<span class="line-modified"> 925     unsigned v = self-&gt;_hashStateW;</span>
 926     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
<span class="line-modified"> 927     self-&gt;_hashStateW = v;</span>
 928     value = v;
 929   }
 930 
<span class="line-modified"> 931   value &amp;= markWord::hash_mask;</span>
 932   if (value == 0) value = 0xBAD;
<span class="line-modified"> 933   assert(value != markWord::no_hash, &quot;invariant&quot;);</span>
 934   return value;
 935 }
 936 
<span class="line-modified"> 937 intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {</span>
 938   if (UseBiasedLocking) {
 939     // NOTE: many places throughout the JVM do not expect a safepoint
 940     // to be taken here, in particular most operations on perm gen
 941     // objects. However, we only ever bias Java instances and all of
 942     // the call sites of identity_hash that might revoke biases have
 943     // been checked to make sure they can handle a safepoint. The
 944     // added check of the bias pattern is to avoid useless calls to
 945     // thread-local storage.
<span class="line-modified"> 946     if (obj-&gt;mark().has_bias_pattern()) {</span>
 947       // Handle for oop obj in case of STW safepoint
<span class="line-modified"> 948       Handle hobj(self, obj);</span>
 949       // Relaxing assertion for bug 6320749.
 950       assert(Universe::verify_in_progress() ||
 951              !SafepointSynchronize::is_at_safepoint(),
 952              &quot;biases should not be seen by VM thread here&quot;);
<span class="line-modified"> 953       BiasedLocking::revoke(hobj, JavaThread::current());</span>
 954       obj = hobj();
<span class="line-modified"> 955       assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
 956     }
 957   }
 958 
 959   // hashCode() is a heap mutator ...
 960   // Relaxing assertion for bug 6320749.
 961   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
 962          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
 963   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
<span class="line-modified"> 964          self-&gt;is_Java_thread() , &quot;invariant&quot;);</span>
 965   assert(Universe::verify_in_progress() || DumpSharedSpaces ||
<span class="line-modified"> 966          ((JavaThread *)self)-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);</span>
 967 
 968   ObjectMonitor* monitor = NULL;
<span class="line-modified"> 969   markWord temp, test;</span>
 970   intptr_t hash;
<span class="line-modified"> 971   markWord mark = read_stable_mark(obj);</span>
 972 
 973   // object should remain ineligible for biased locking
<span class="line-modified"> 974   assert(!mark.has_bias_pattern(), &quot;invariant&quot;);</span>
 975 
<span class="line-modified"> 976   if (mark.is_neutral()) {            // if this is a normal header</span>
<span class="line-modified"> 977     hash = mark.hash();</span>
<span class="line-modified"> 978     if (hash != 0) {                  // if it has a hash, just return it</span>
 979       return hash;
 980     }
<span class="line-modified"> 981     hash = get_next_hash(self, obj);  // get a new hash</span>
<span class="line-modified"> 982     temp = mark.copy_set_hash(hash);  // merge the hash into header</span>
<span class="line-modified"> 983                                       // try to install the hash</span>
 984     test = obj-&gt;cas_set_mark(temp, mark);
<span class="line-modified"> 985     if (test == mark) {               // if the hash was installed, return it</span>
 986       return hash;
 987     }
<span class="line-modified"> 988     // Failed to install the hash. It could be that another thread</span>
<span class="line-modified"> 989     // installed the hash just before our attempt or inflation has</span>
<span class="line-modified"> 990     // occurred or... so we fall thru to inflate the monitor for</span>
<span class="line-modified"> 991     // stability and then install the hash.</span>
<span class="line-modified"> 992   } else if (mark.has_monitor()) {</span>
<span class="line-added"> 993     monitor = mark.monitor();</span>
 994     temp = monitor-&gt;header();
<span class="line-modified"> 995     assert(temp.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, temp.value());</span>
<span class="line-modified"> 996     hash = temp.hash();</span>
<span class="line-modified"> 997     if (hash != 0) {                  // if it has a hash, just return it</span>
 998       return hash;
 999     }
<span class="line-modified">1000     // Fall thru so we only have one place that installs the hash in</span>
<span class="line-modified">1001     // the ObjectMonitor.</span>
<span class="line-modified">1002   } else if (self-&gt;is_lock_owned((address)mark.locker())) {</span>
<span class="line-modified">1003     // This is a stack lock owned by the calling thread so fetch the</span>
<span class="line-modified">1004     // displaced markWord from the BasicLock on the stack.</span>
<span class="line-modified">1005     temp = mark.displaced_mark_helper();</span>
<span class="line-added">1006     assert(temp.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, temp.value());</span>
<span class="line-added">1007     hash = temp.hash();</span>
<span class="line-added">1008     if (hash != 0) {                  // if it has a hash, just return it</span>
1009       return hash;
1010     }
1011     // WARNING:
<span class="line-modified">1012     // The displaced header in the BasicLock on a thread&#39;s stack</span>
<span class="line-modified">1013     // is strictly immutable. It CANNOT be changed in ANY cases.</span>
<span class="line-modified">1014     // So we have to inflate the stack lock into an ObjectMonitor</span>
<span class="line-modified">1015     // even if the current thread owns the lock. The BasicLock on</span>
<span class="line-modified">1016     // a thread&#39;s stack can be asynchronously read by other threads</span>
<span class="line-modified">1017     // during an inflate() call so any change to that stack memory</span>
<span class="line-modified">1018     // may not propagate to other threads correctly.</span>
<span class="line-modified">1019   }</span>
<span class="line-modified">1020 </span>
<span class="line-modified">1021   // Inflate the monitor to set the hash.</span>
<span class="line-modified">1022   monitor = inflate(self, obj, inflate_cause_hash_code);</span>
<span class="line-modified">1023   // Load ObjectMonitor&#39;s header/dmw field and see if it has a hash.</span>

1024   mark = monitor-&gt;header();
<span class="line-modified">1025   assert(mark.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, mark.value());</span>
<span class="line-modified">1026   hash = mark.hash();</span>
<span class="line-modified">1027   if (hash == 0) {                    // if it does not have a hash</span>
<span class="line-modified">1028     hash = get_next_hash(self, obj);  // get a new hash</span>
<span class="line-modified">1029     temp = mark.copy_set_hash(hash);  // merge the hash into header</span>
<span class="line-modified">1030     assert(temp.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, temp.value());</span>
<span class="line-modified">1031     uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor-&gt;header_addr(), mark.value(), temp.value());</span>
<span class="line-added">1032     test = markWord(v);</span>
1033     if (test != mark) {
<span class="line-modified">1034       // The attempt to update the ObjectMonitor&#39;s header/dmw field</span>
<span class="line-modified">1035       // did not work. This can happen if another thread managed to</span>
<span class="line-modified">1036       // merge in the hash just before our cmpxchg().</span>
<span class="line-modified">1037       // If we add any new usages of the header/dmw field, this code</span>
<span class="line-modified">1038       // will need to be updated.</span>
<span class="line-modified">1039       hash = test.hash();</span>
<span class="line-added">1040       assert(test.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, test.value());</span>
<span class="line-added">1041       assert(hash != 0, &quot;should only have lost the race to a thread that set a non-zero hash&quot;);</span>
1042     }
1043   }
<span class="line-modified">1044   // We finally get the hash.</span>
1045   return hash;
1046 }
1047 
1048 // Deprecated -- use FastHashCode() instead.
1049 
1050 intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) {
1051   return FastHashCode(Thread::current(), obj());
1052 }
1053 
1054 
1055 bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,
1056                                                    Handle h_obj) {
1057   if (UseBiasedLocking) {
<span class="line-modified">1058     BiasedLocking::revoke(h_obj, thread);</span>
<span class="line-modified">1059     assert(!h_obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
1060   }
1061 
1062   assert(thread == JavaThread::current(), &quot;Can only be called on current thread&quot;);
1063   oop obj = h_obj();
1064 
<span class="line-modified">1065   markWord mark = read_stable_mark(obj);</span>
1066 
1067   // Uncontended case, header points to stack
<span class="line-modified">1068   if (mark.has_locker()) {</span>
<span class="line-modified">1069     return thread-&gt;is_lock_owned((address)mark.locker());</span>
1070   }
1071   // Contended case, header points to ObjectMonitor (tagged pointer)
<span class="line-modified">1072   if (mark.has_monitor()) {</span>
<span class="line-modified">1073     ObjectMonitor* monitor = mark.monitor();</span>
1074     return monitor-&gt;is_entered(thread) != 0;
1075   }
1076   // Unlocked case, header in place
<span class="line-modified">1077   assert(mark.is_neutral(), &quot;sanity check&quot;);</span>
1078   return false;
1079 }
1080 
1081 // Be aware of this method could revoke bias of the lock object.
1082 // This method queries the ownership of the lock handle specified by &#39;h_obj&#39;.
1083 // If the current thread owns the lock, it returns owner_self. If no
1084 // thread owns the lock, it returns owner_none. Otherwise, it will return
1085 // owner_other.
1086 ObjectSynchronizer::LockOwnership ObjectSynchronizer::query_lock_ownership
1087 (JavaThread *self, Handle h_obj) {
1088   // The caller must beware this method can revoke bias, and
1089   // revocation can result in a safepoint.
1090   assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1091   assert(self-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);
1092 
1093   // Possible mark states: neutral, biased, stack-locked, inflated
1094 
<span class="line-modified">1095   if (UseBiasedLocking &amp;&amp; h_obj()-&gt;mark().has_bias_pattern()) {</span>
1096     // CASE: biased
<span class="line-modified">1097     BiasedLocking::revoke(h_obj, self);</span>
<span class="line-modified">1098     assert(!h_obj-&gt;mark().has_bias_pattern(),</span>
1099            &quot;biases should be revoked by now&quot;);
1100   }
1101 
1102   assert(self == JavaThread::current(), &quot;Can only be called on current thread&quot;);
1103   oop obj = h_obj();
<span class="line-modified">1104   markWord mark = read_stable_mark(obj);</span>
1105 
1106   // CASE: stack-locked.  Mark points to a BasicLock on the owner&#39;s stack.
<span class="line-modified">1107   if (mark.has_locker()) {</span>
<span class="line-modified">1108     return self-&gt;is_lock_owned((address)mark.locker()) ?</span>
1109       owner_self : owner_other;
1110   }
1111 
1112   // CASE: inflated. Mark (tagged pointer) points to an ObjectMonitor.
1113   // The Object:ObjectMonitor relationship is stable as long as we&#39;re
1114   // not at a safepoint.
<span class="line-modified">1115   if (mark.has_monitor()) {</span>
<span class="line-modified">1116     void* owner = mark.monitor()-&gt;_owner;</span>
1117     if (owner == NULL) return owner_none;
1118     return (owner == self ||
1119             self-&gt;is_lock_owned((address)owner)) ? owner_self : owner_other;
1120   }
1121 
1122   // CASE: neutral
<span class="line-modified">1123   assert(mark.is_neutral(), &quot;sanity check&quot;);</span>
1124   return owner_none;           // it&#39;s unlocked
1125 }
1126 
1127 // FIXME: jvmti should call this
1128 JavaThread* ObjectSynchronizer::get_lock_owner(ThreadsList * t_list, Handle h_obj) {
1129   if (UseBiasedLocking) {
1130     if (SafepointSynchronize::is_at_safepoint()) {
1131       BiasedLocking::revoke_at_safepoint(h_obj);
1132     } else {
<span class="line-modified">1133       BiasedLocking::revoke(h_obj, JavaThread::current());</span>
1134     }
<span class="line-modified">1135     assert(!h_obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
1136   }
1137 
1138   oop obj = h_obj();
1139   address owner = NULL;
1140 
<span class="line-modified">1141   markWord mark = read_stable_mark(obj);</span>
1142 
1143   // Uncontended case, header points to stack
<span class="line-modified">1144   if (mark.has_locker()) {</span>
<span class="line-modified">1145     owner = (address) mark.locker();</span>
1146   }
1147 
1148   // Contended case, header points to ObjectMonitor (tagged pointer)
<span class="line-modified">1149   else if (mark.has_monitor()) {</span>
<span class="line-modified">1150     ObjectMonitor* monitor = mark.monitor();</span>
1151     assert(monitor != NULL, &quot;monitor should be non-null&quot;);
1152     owner = (address) monitor-&gt;owner();
1153   }
1154 
1155   if (owner != NULL) {
1156     // owning_thread_from_monitor_owner() may also return NULL here
1157     return Threads::owning_thread_from_monitor_owner(t_list, owner);
1158   }
1159 
1160   // Unlocked case, header in place
1161   // Cannot have assertion since this object may have been
1162   // locked by another thread when reaching here.
<span class="line-modified">1163   // assert(mark.is_neutral(), &quot;sanity check&quot;);</span>
1164 
1165   return NULL;
1166 }
1167 
1168 // Visitors ...
1169 
1170 void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure) {
<span class="line-modified">1171   PaddedObjectMonitor* block = Atomic::load(&amp;g_block_list);</span>
1172   while (block != NULL) {
1173     assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
1174     for (int i = _BLOCKSIZE - 1; i &gt; 0; i--) {
1175       ObjectMonitor* mid = (ObjectMonitor *)(block + i);
1176       oop object = (oop)mid-&gt;object();
1177       if (object != NULL) {
<span class="line-added">1178         // Only process with closure if the object is set.</span>
1179         closure-&gt;do_monitor(mid);
1180       }
1181     }
<span class="line-modified">1182     // unmarked_next() is not needed with g_block_list (no locking</span>
<span class="line-added">1183     // used with block linkage _next_om fields).</span>
<span class="line-added">1184     block = (PaddedObjectMonitor*)block-&gt;next_om();</span>
1185   }
1186 }
1187 








1188 static bool monitors_used_above_threshold() {
<span class="line-modified">1189   int population = Atomic::load(&amp;om_list_globals._population);</span>
<span class="line-added">1190   if (population == 0) {</span>
1191     return false;
1192   }
<span class="line-modified">1193   if (MonitorUsedDeflationThreshold &gt; 0) {</span>
<span class="line-modified">1194     int monitors_used = population - Atomic::load(&amp;om_list_globals._free_count);</span>
<span class="line-modified">1195     int monitor_usage = (monitors_used * 100LL) / population;</span>
<span class="line-added">1196     return monitor_usage &gt; MonitorUsedDeflationThreshold;</span>
<span class="line-added">1197   }</span>
<span class="line-added">1198   return false;</span>
<span class="line-added">1199 }</span>
<span class="line-added">1200 </span>
<span class="line-added">1201 // Returns true if MonitorBound is set (&gt; 0) and if the specified</span>
<span class="line-added">1202 // cnt is &gt; MonitorBound. Otherwise returns false.</span>
<span class="line-added">1203 static bool is_MonitorBound_exceeded(const int cnt) {</span>
<span class="line-added">1204   const int mx = MonitorBound;</span>
<span class="line-added">1205   return mx &gt; 0 &amp;&amp; cnt &gt; mx;</span>
1206 }
1207 
1208 bool ObjectSynchronizer::is_cleanup_needed() {
<span class="line-modified">1209   if (monitors_used_above_threshold()) {</span>
<span class="line-modified">1210     // Too many monitors in use.</span>
<span class="line-added">1211     return true;</span>
<span class="line-added">1212   }</span>
<span class="line-added">1213   return needs_monitor_scavenge();</span>
<span class="line-added">1214 }</span>
<span class="line-added">1215 </span>
<span class="line-added">1216 bool ObjectSynchronizer::needs_monitor_scavenge() {</span>
<span class="line-added">1217   if (Atomic::load(&amp;_forceMonitorScavenge) == 1) {</span>
<span class="line-added">1218     log_info(monitorinflation)(&quot;Monitor scavenge needed, triggering safepoint cleanup.&quot;);</span>
<span class="line-added">1219     return true;</span>
1220   }
1221   return false;
1222 }
1223 
1224 void ObjectSynchronizer::oops_do(OopClosure* f) {
1225   // We only scan the global used list here (for moribund threads), and
1226   // the thread-local monitors in Thread::oops_do().
1227   global_used_oops_do(f);
1228 }
1229 
1230 void ObjectSynchronizer::global_used_oops_do(OopClosure* f) {
1231   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">1232   list_oops_do(Atomic::load(&amp;om_list_globals._in_use_list), f);</span>
1233 }
1234 
1235 void ObjectSynchronizer::thread_local_used_oops_do(Thread* thread, OopClosure* f) {
1236   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">1237   list_oops_do(thread-&gt;om_in_use_list, f);</span>
1238 }
1239 
1240 void ObjectSynchronizer::list_oops_do(ObjectMonitor* list, OopClosure* f) {
1241   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">1242   // The oops_do() phase does not overlap with monitor deflation</span>
<span class="line-modified">1243   // so no need to lock ObjectMonitors for the list traversal.</span>
<span class="line-added">1244   for (ObjectMonitor* mid = list; mid != NULL; mid = unmarked_next(mid)) {</span>
1245     if (mid-&gt;object() != NULL) {
1246       f-&gt;do_oop((oop*)mid-&gt;object_addr());
1247     }
1248   }
1249 }
1250 
1251 
1252 // -----------------------------------------------------------------------------
1253 // ObjectMonitor Lifecycle
1254 // -----------------------
<span class="line-modified">1255 // Inflation unlinks monitors from om_list_globals._free_list or a per-thread</span>
<span class="line-modified">1256 // free list and associates them with objects. Deflation -- which occurs at</span>
<span class="line-modified">1257 // STW-time -- disassociates idle monitors from objects.</span>
<span class="line-modified">1258 // Such scavenged monitors are returned to the om_list_globals._free_list.</span>



1259 //
1260 // ObjectMonitors reside in type-stable memory (TSM) and are immortal.
1261 //
1262 // Lifecycle:
<span class="line-modified">1263 // --   unassigned and on the om_list_globals._free_list</span>
<span class="line-modified">1264 // --   unassigned and on a per-thread free list</span>
1265 // --   assigned to an object.  The object is inflated and the mark refers
<span class="line-modified">1266 //      to the ObjectMonitor.</span>
1267 
1268 
1269 // Constraining monitor pool growth via MonitorBound ...
1270 //
<span class="line-added">1271 // If MonitorBound is not set (&lt;= 0), MonitorBound checks are disabled.</span>
<span class="line-added">1272 //</span>
1273 // The monitor pool is grow-only.  We scavenge at STW safepoint-time, but the
1274 // the rate of scavenging is driven primarily by GC.  As such,  we can find
1275 // an inordinate number of monitors in circulation.
1276 // To avoid that scenario we can artificially induce a STW safepoint
1277 // if the pool appears to be growing past some reasonable bound.
1278 // Generally we favor time in space-time tradeoffs, but as there&#39;s no
1279 // natural back-pressure on the # of extant monitors we need to impose some
1280 // type of limit.  Beware that if MonitorBound is set to too low a value
1281 // we could just loop. In addition, if MonitorBound is set to a low value
1282 // we&#39;ll incur more safepoints, which are harmful to performance.
1283 // See also: GuaranteedSafepointInterval
1284 //
<span class="line-modified">1285 // If MonitorBound is set, the boundry applies to</span>
<span class="line-added">1286 //     (om_list_globals._population - om_list_globals._free_count)</span>
<span class="line-added">1287 // i.e., if there are not enough ObjectMonitors on the global free list,</span>
<span class="line-added">1288 // then a safepoint deflation is induced. Picking a good MonitorBound value</span>
<span class="line-added">1289 // is non-trivial.</span>
1290 
<span class="line-modified">1291 static void InduceScavenge(Thread* self, const char * Whence) {</span>
1292   // Induce STW safepoint to trim monitors
1293   // Ultimately, this results in a call to deflate_idle_monitors() in the near future.
<span class="line-modified">1294   // More precisely, trigger a cleanup safepoint as the number</span>
1295   // of active monitors passes the specified threshold.
1296   // TODO: assert thread state is reasonable
1297 
<span class="line-modified">1298   if (Atomic::xchg(&amp;_forceMonitorScavenge, 1) == 0) {</span>
<span class="line-modified">1299     VMThread::check_for_forced_cleanup();</span>




1300   }
1301 }
1302 
<span class="line-modified">1303 ObjectMonitor* ObjectSynchronizer::om_alloc(Thread* self) {</span>
1304   // A large MAXPRIVATE value reduces both list lock contention
1305   // and list coherency traffic, but also tends to increase the
<span class="line-modified">1306   // number of ObjectMonitors in circulation as well as the STW</span>
1307   // scavenge costs.  As usual, we lean toward time in space-time
1308   // tradeoffs.
1309   const int MAXPRIVATE = 1024;
<span class="line-added">1310   NoSafepointVerifier nsv;</span>
<span class="line-added">1311 </span>
<span class="line-added">1312   stringStream ss;</span>
1313   for (;;) {
<span class="line-modified">1314     ObjectMonitor* m;</span>
1315 
<span class="line-modified">1316     // 1: try to allocate from the thread&#39;s local om_free_list.</span>
1317     // Threads will attempt to allocate first from their local list, then
<span class="line-modified">1318     // from the global list, and only after those attempts fail will the</span>
<span class="line-modified">1319     // thread attempt to instantiate new monitors. Thread-local free lists</span>
<span class="line-modified">1320     // improve allocation latency, as well as reducing coherency traffic</span>
<span class="line-modified">1321     // on the shared global list.</span>
<span class="line-modified">1322     m = take_from_start_of_om_free_list(self);</span>
1323     if (m != NULL) {


1324       guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-modified">1325       prepend_to_om_in_use_list(self, m);</span>


1326       return m;
1327     }
1328 
<span class="line-modified">1329     // 2: try to allocate from the global om_list_globals._free_list</span>


1330     // If we&#39;re using thread-local free lists then try
1331     // to reprovision the caller&#39;s free list.
<span class="line-modified">1332     if (Atomic::load(&amp;om_list_globals._free_list) != NULL) {</span>
<span class="line-modified">1333       // Reprovision the thread&#39;s om_free_list.</span>
1334       // Use bulk transfers to reduce the allocation rate and heat
1335       // on various locks.
<span class="line-modified">1336       for (int i = self-&gt;om_free_provision; --i &gt;= 0;) {</span>
<span class="line-modified">1337         ObjectMonitor* take = take_from_start_of_global_free_list();</span>
<span class="line-modified">1338         if (take == NULL) {</span>
<span class="line-modified">1339           break;  // No more are available.</span>
<span class="line-modified">1340         }</span>
1341         guarantee(take-&gt;object() == NULL, &quot;invariant&quot;);

1342         take-&gt;Recycle();
<span class="line-modified">1343         om_release(self, take, false);</span>
1344       }
<span class="line-modified">1345       self-&gt;om_free_provision += 1 + (self-&gt;om_free_provision / 2);</span>
<span class="line-modified">1346       if (self-&gt;om_free_provision &gt; MAXPRIVATE) self-&gt;om_free_provision = MAXPRIVATE;</span>

1347 
<span class="line-modified">1348       if (is_MonitorBound_exceeded(Atomic::load(&amp;om_list_globals._population) -</span>
<span class="line-modified">1349                                    Atomic::load(&amp;om_list_globals._free_count))) {</span>
<span class="line-modified">1350         // Not enough ObjectMonitors on the global free list.</span>
<span class="line-added">1351         // We can&#39;t safely induce a STW safepoint from om_alloc() as our thread</span>
1352         // state may not be appropriate for such activities and callers may hold
1353         // naked oops, so instead we defer the action.
<span class="line-modified">1354         InduceScavenge(self, &quot;om_alloc&quot;);</span>
1355       }
1356       continue;
1357     }
1358 
1359     // 3: allocate a block of new ObjectMonitors
1360     // Both the local and global free lists are empty -- resort to malloc().
<span class="line-modified">1361     // In the current implementation ObjectMonitors are TSM - immortal.</span>
1362     // Ideally, we&#39;d write &quot;new ObjectMonitor[_BLOCKSIZE], but we want
1363     // each ObjectMonitor to start at the beginning of a cache line,
1364     // so we use align_up().
1365     // A better solution would be to use C++ placement-new.
1366     // BEWARE: As it stands currently, we don&#39;t run the ctors!
1367     assert(_BLOCKSIZE &gt; 1, &quot;invariant&quot;);
<span class="line-modified">1368     size_t neededsize = sizeof(PaddedObjectMonitor) * _BLOCKSIZE;</span>
<span class="line-modified">1369     PaddedObjectMonitor* temp;</span>
<span class="line-modified">1370     size_t aligned_size = neededsize + (OM_CACHE_LINE_SIZE - 1);</span>
<span class="line-modified">1371     void* real_malloc_addr = NEW_C_HEAP_ARRAY(char, aligned_size, mtInternal);</span>
<span class="line-modified">1372     temp = (PaddedObjectMonitor*)align_up(real_malloc_addr, OM_CACHE_LINE_SIZE);</span>










1373     (void)memset((void *) temp, 0, neededsize);
1374 
1375     // Format the block.
1376     // initialize the linked list, each monitor points to its next
1377     // forming the single linked free list, the very first monitor
1378     // will points to next block, which forms the block list.
<span class="line-modified">1379     // The trick of using the 1st element in the block as g_block_list</span>
1380     // linkage should be reconsidered.  A better implementation would
1381     // look like: class Block { Block * next; int N; ObjectMonitor Body [N] ; }
1382 
1383     for (int i = 1; i &lt; _BLOCKSIZE; i++) {
<span class="line-modified">1384       temp[i].set_next_om((ObjectMonitor*)&amp;temp[i + 1]);</span>
1385     }
1386 
1387     // terminate the last monitor as the end of list
<span class="line-modified">1388     temp[_BLOCKSIZE - 1].set_next_om((ObjectMonitor*)NULL);</span>
1389 
1390     // Element [0] is reserved for global list linkage
1391     temp[0].set_object(CHAINMARKER);
1392 
1393     // Consider carving out this thread&#39;s current request from the
1394     // block in hand.  This avoids some lock traffic and redundant
1395     // list activity.
1396 
<span class="line-modified">1397     prepend_block_to_lists(temp);</span>

















1398   }
1399 }
1400 
<span class="line-modified">1401 // Place &quot;m&quot; on the caller&#39;s private per-thread om_free_list.</span>
1402 // In practice there&#39;s no need to clamp or limit the number of
<span class="line-modified">1403 // monitors on a thread&#39;s om_free_list as the only non-allocation time</span>
<span class="line-modified">1404 // we&#39;ll call om_release() is to return a monitor to the free list after</span>
<span class="line-modified">1405 // a CAS attempt failed. This doesn&#39;t allow unbounded #s of monitors to</span>
1406 // accumulate on a thread&#39;s free list.
1407 //
1408 // Key constraint: all ObjectMonitors on a thread&#39;s free list and the global
1409 // free list must have their object field set to null. This prevents the
<span class="line-modified">1410 // scavenger -- deflate_monitor_list() -- from reclaiming them while we</span>
<span class="line-added">1411 // are trying to release them.</span>
1412 
<span class="line-modified">1413 void ObjectSynchronizer::om_release(Thread* self, ObjectMonitor* m,</span>
<span class="line-modified">1414                                     bool from_per_thread_alloc) {</span>
<span class="line-modified">1415   guarantee(m-&gt;header().value() == 0, &quot;invariant&quot;);</span>
1416   guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-modified">1417   NoSafepointVerifier nsv;</span>
<span class="line-modified">1418 </span>
<span class="line-modified">1419   stringStream ss;</span>
<span class="line-modified">1420   guarantee((m-&gt;is_busy() | m-&gt;_recursions) == 0, &quot;freeing in-use monitor: &quot;</span>
<span class="line-modified">1421             &quot;%s, recursions=&quot; INTX_FORMAT, m-&gt;is_busy_to_string(&amp;ss),</span>
<span class="line-modified">1422             m-&gt;_recursions);</span>
<span class="line-modified">1423   // _next_om is used for both per-thread in-use and free lists so</span>
<span class="line-modified">1424   // we have to remove &#39;m&#39; from the in-use list first (as needed).</span>
<span class="line-modified">1425   if (from_per_thread_alloc) {</span>
<span class="line-modified">1426     // Need to remove &#39;m&#39; from om_in_use_list.</span>
<span class="line-modified">1427     ObjectMonitor* mid = NULL;</span>
<span class="line-modified">1428     ObjectMonitor* next = NULL;</span>
<span class="line-added">1429 </span>
<span class="line-added">1430     // This list walk can only race with another list walker since</span>
<span class="line-added">1431     // deflation can only happen at a safepoint so we don&#39;t have to</span>
<span class="line-added">1432     // worry about an ObjectMonitor being removed from this list</span>
<span class="line-added">1433     // while we are walking it.</span>
<span class="line-added">1434 </span>
<span class="line-added">1435     // Lock the list head to avoid racing with another list walker.</span>
<span class="line-added">1436     if ((mid = get_list_head_locked(&amp;self-&gt;om_in_use_list)) == NULL) {</span>
<span class="line-added">1437       fatal(&quot;thread=&quot; INTPTR_FORMAT &quot; in-use list must not be empty.&quot;, p2i(self));</span>
<span class="line-added">1438     }</span>
<span class="line-added">1439     next = unmarked_next(mid);</span>
<span class="line-added">1440     if (m == mid) {</span>
<span class="line-added">1441       // First special case:</span>
<span class="line-added">1442       // &#39;m&#39; matches mid, is the list head and is locked. Switch the list</span>
<span class="line-added">1443       // head to next which unlocks the list head, but leaves the extracted</span>
<span class="line-added">1444       // mid locked:</span>
<span class="line-added">1445       Atomic::store(&amp;self-&gt;om_in_use_list, next);</span>
<span class="line-added">1446     } else if (m == next) {</span>
<span class="line-added">1447       // Second special case:</span>
<span class="line-added">1448       // &#39;m&#39; matches next after the list head and we already have the list</span>
<span class="line-added">1449       // head locked so set mid to what we are extracting:</span>
<span class="line-added">1450       mid = next;</span>
<span class="line-added">1451       // Lock mid to prevent races with a list walker:</span>
<span class="line-added">1452       om_lock(mid);</span>
<span class="line-added">1453       // Update next to what follows mid (if anything):</span>
<span class="line-added">1454       next = unmarked_next(mid);</span>
<span class="line-added">1455       // Switch next after the list head to new next which unlocks the</span>
<span class="line-added">1456       // list head, but leaves the extracted mid locked:</span>
<span class="line-added">1457       self-&gt;om_in_use_list-&gt;set_next_om(next);</span>
<span class="line-added">1458     } else {</span>
<span class="line-added">1459       // We have to search the list to find &#39;m&#39;.</span>
<span class="line-added">1460       om_unlock(mid);  // unlock the list head</span>
<span class="line-added">1461       guarantee(next != NULL, &quot;thread=&quot; INTPTR_FORMAT &quot;: om_in_use_list=&quot; INTPTR_FORMAT</span>
<span class="line-added">1462                 &quot; is too short.&quot;, p2i(self), p2i(self-&gt;om_in_use_list));</span>
<span class="line-added">1463       // Our starting anchor is next after the list head which is the</span>
<span class="line-added">1464       // last ObjectMonitor we checked:</span>
<span class="line-added">1465       ObjectMonitor* anchor = next;</span>
<span class="line-added">1466       while ((mid = unmarked_next(anchor)) != NULL) {</span>
<span class="line-added">1467         if (m == mid) {</span>
<span class="line-added">1468           // We found &#39;m&#39; on the per-thread in-use list so extract it.</span>
<span class="line-added">1469           om_lock(anchor);  // Lock the anchor so we can safely modify it.</span>
<span class="line-added">1470           // Update next to what follows mid (if anything):</span>
<span class="line-added">1471           next = unmarked_next(mid);</span>
<span class="line-added">1472           // Switch next after the anchor to new next which unlocks the</span>
<span class="line-added">1473           // anchor, but leaves the extracted mid locked:</span>
<span class="line-added">1474           anchor-&gt;set_next_om(next);</span>
<span class="line-added">1475           break;</span>
<span class="line-added">1476         } else {</span>
<span class="line-added">1477           anchor = mid;</span>
1478         }



1479       }
1480     }
<span class="line-modified">1481 </span>
<span class="line-added">1482     if (mid == NULL) {</span>
<span class="line-added">1483       // Reached end of the list and didn&#39;t find &#39;m&#39; so:</span>
<span class="line-added">1484       fatal(&quot;thread=&quot; INTPTR_FORMAT &quot; must find m=&quot; INTPTR_FORMAT &quot;on om_in_use_list=&quot;</span>
<span class="line-added">1485             INTPTR_FORMAT, p2i(self), p2i(m), p2i(self-&gt;om_in_use_list));</span>
<span class="line-added">1486     }</span>
<span class="line-added">1487 </span>
<span class="line-added">1488     // At this point mid is disconnected from the in-use list so</span>
<span class="line-added">1489     // its lock no longer has any effects on the in-use list.</span>
<span class="line-added">1490     Atomic::dec(&amp;self-&gt;om_in_use_count);</span>
<span class="line-added">1491     // Unlock mid, but leave the next value for any lagging list</span>
<span class="line-added">1492     // walkers. It will get cleaned up when mid is prepended to</span>
<span class="line-added">1493     // the thread&#39;s free list:</span>
<span class="line-added">1494     om_unlock(mid);</span>
1495   }
1496 
<span class="line-modified">1497   prepend_to_om_free_list(self, m);</span>



1498 }
1499 
<span class="line-modified">1500 // Return ObjectMonitors on a moribund thread&#39;s free and in-use</span>
<span class="line-modified">1501 // lists to the appropriate global lists. The ObjectMonitors on the</span>
<span class="line-modified">1502 // per-thread in-use list may still be in use by other threads.</span>







1503 //
<span class="line-modified">1504 // We currently call om_flush() from Threads::remove() before the</span>
<span class="line-modified">1505 // thread has been excised from the thread list and is no longer a</span>
<span class="line-modified">1506 // mutator. This means that om_flush() cannot run concurrently with</span>
<span class="line-modified">1507 // a safepoint and interleave with deflate_idle_monitors(). In</span>
<span class="line-modified">1508 // particular, this ensures that the thread&#39;s in-use monitors are</span>
<span class="line-modified">1509 // scanned by a GC safepoint, either via Thread::oops_do() (before</span>
<span class="line-modified">1510 // om_flush() is called) or via ObjectSynchronizer::oops_do() (after</span>
<span class="line-modified">1511 // om_flush() is called).</span>
<span class="line-modified">1512 </span>
<span class="line-modified">1513 void ObjectSynchronizer::om_flush(Thread* self) {</span>
<span class="line-modified">1514   // Process the per-thread in-use list first to be consistent.</span>
<span class="line-modified">1515   int in_use_count = 0;</span>
<span class="line-modified">1516   ObjectMonitor* in_use_list = NULL;</span>
<span class="line-modified">1517   ObjectMonitor* in_use_tail = NULL;</span>
<span class="line-modified">1518   NoSafepointVerifier nsv;</span>
<span class="line-modified">1519 </span>
<span class="line-modified">1520   // This function can race with a list walker thread so we lock the</span>
<span class="line-modified">1521   // list head to prevent confusion.</span>
<span class="line-modified">1522   if ((in_use_list = get_list_head_locked(&amp;self-&gt;om_in_use_list)) != NULL) {</span>
<span class="line-modified">1523     // At this point, we have locked the in-use list head so a racing</span>
<span class="line-modified">1524     // thread cannot come in after us. However, a racing thread could</span>
<span class="line-modified">1525     // be ahead of us; we&#39;ll detect that and delay to let it finish.</span>
<span class="line-modified">1526     //</span>
<span class="line-modified">1527     // The thread is going away, however the ObjectMonitors on the</span>
<span class="line-modified">1528     // om_in_use_list may still be in-use by other threads. Link</span>
<span class="line-added">1529     // them to in_use_tail, which will be linked into the global</span>
<span class="line-added">1530     // in-use list (om_list_globals._in_use_list) below.</span>
<span class="line-added">1531     //</span>
<span class="line-added">1532     // Account for the in-use list head before the loop since it is</span>
<span class="line-added">1533     // already locked (by this thread):</span>
<span class="line-added">1534     in_use_tail = in_use_list;</span>
<span class="line-added">1535     in_use_count++;</span>
<span class="line-added">1536     for (ObjectMonitor* cur_om = unmarked_next(in_use_list); cur_om != NULL; cur_om = unmarked_next(cur_om)) {</span>
<span class="line-added">1537       if (is_locked(cur_om)) {</span>
<span class="line-added">1538         // cur_om is locked so there must be a racing walker thread ahead</span>
<span class="line-added">1539         // of us so we&#39;ll give it a chance to finish.</span>
<span class="line-added">1540         while (is_locked(cur_om)) {</span>
<span class="line-added">1541           os::naked_short_sleep(1);</span>
<span class="line-added">1542         }</span>
<span class="line-added">1543       }</span>
<span class="line-added">1544       in_use_tail = cur_om;</span>
<span class="line-added">1545       in_use_count++;</span>
1546     }
<span class="line-modified">1547     guarantee(in_use_tail != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1548     int l_om_in_use_count = Atomic::load(&amp;self-&gt;om_in_use_count);</span>
<span class="line-modified">1549     assert(l_om_in_use_count == in_use_count, &quot;in-use counts don&#39;t match: &quot;</span>
<span class="line-modified">1550           &quot;l_om_in_use_count=%d, in_use_count=%d&quot;, l_om_in_use_count, in_use_count);</span>
<span class="line-modified">1551     Atomic::store(&amp;self-&gt;om_in_use_count, 0);</span>
<span class="line-modified">1552     // Clear the in-use list head (which also unlocks it):</span>
<span class="line-modified">1553     Atomic::store(&amp;self-&gt;om_in_use_list, (ObjectMonitor*)NULL);</span>
<span class="line-modified">1554     om_unlock(in_use_list);</span>
<span class="line-modified">1555   }</span>
<span class="line-modified">1556 </span>
<span class="line-modified">1557   int free_count = 0;</span>
<span class="line-modified">1558   ObjectMonitor* free_list = NULL;</span>
<span class="line-modified">1559   ObjectMonitor* free_tail = NULL;</span>
<span class="line-modified">1560   // This function can race with a list walker thread so we lock the</span>
<span class="line-modified">1561   // list head to prevent confusion.</span>
<span class="line-modified">1562   if ((free_list = get_list_head_locked(&amp;self-&gt;om_free_list)) != NULL) {</span>
<span class="line-modified">1563     // At this point, we have locked the free list head so a racing</span>
<span class="line-modified">1564     // thread cannot come in after us. However, a racing thread could</span>
<span class="line-added">1565     // be ahead of us; we&#39;ll detect that and delay to let it finish.</span>
<span class="line-added">1566     //</span>
<span class="line-added">1567     // The thread is going away. Set &#39;free_tail&#39; to the last per-thread free</span>
<span class="line-added">1568     // monitor which will be linked to om_list_globals._free_list below.</span>
<span class="line-added">1569     //</span>
<span class="line-added">1570     // Account for the free list head before the loop since it is</span>
<span class="line-added">1571     // already locked (by this thread):</span>
<span class="line-added">1572     free_tail = free_list;</span>
<span class="line-added">1573     free_count++;</span>
<span class="line-added">1574     for (ObjectMonitor* s = unmarked_next(free_list); s != NULL; s = unmarked_next(s)) {</span>
<span class="line-added">1575       if (is_locked(s)) {</span>
<span class="line-added">1576         // s is locked so there must be a racing walker thread ahead</span>
<span class="line-added">1577         // of us so we&#39;ll give it a chance to finish.</span>
<span class="line-added">1578         while (is_locked(s)) {</span>
<span class="line-added">1579           os::naked_short_sleep(1);</span>
<span class="line-added">1580         }</span>
<span class="line-added">1581       }</span>
<span class="line-added">1582       free_tail = s;</span>
<span class="line-added">1583       free_count++;</span>
<span class="line-added">1584       guarantee(s-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">1585       stringStream ss;</span>
<span class="line-added">1586       guarantee(!s-&gt;is_busy(), &quot;must be !is_busy: %s&quot;, s-&gt;is_busy_to_string(&amp;ss));</span>
1587     }
<span class="line-modified">1588     guarantee(free_tail != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1589     int l_om_free_count = Atomic::load(&amp;self-&gt;om_free_count);</span>
<span class="line-modified">1590     assert(l_om_free_count == free_count, &quot;free counts don&#39;t match: &quot;</span>
<span class="line-modified">1591            &quot;l_om_free_count=%d, free_count=%d&quot;, l_om_free_count, free_count);</span>
<span class="line-added">1592     Atomic::store(&amp;self-&gt;om_free_count, 0);</span>
<span class="line-added">1593     Atomic::store(&amp;self-&gt;om_free_list, (ObjectMonitor*)NULL);</span>
<span class="line-added">1594     om_unlock(free_list);</span>
1595   }
1596 
<span class="line-modified">1597   if (free_tail != NULL) {</span>
<span class="line-modified">1598     prepend_list_to_global_free_list(free_list, free_tail, free_count);</span>



1599   }
1600 
<span class="line-modified">1601   if (in_use_tail != NULL) {</span>
<span class="line-modified">1602     prepend_list_to_global_in_use_list(in_use_list, in_use_tail, in_use_count);</span>


1603   }
1604 
<span class="line-modified">1605   LogStreamHandle(Debug, monitorinflation) lsh_debug;</span>
<span class="line-added">1606   LogStreamHandle(Info, monitorinflation) lsh_info;</span>
<span class="line-added">1607   LogStream* ls = NULL;</span>
<span class="line-added">1608   if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="line-added">1609     ls = &amp;lsh_debug;</span>
<span class="line-added">1610   } else if ((free_count != 0 || in_use_count != 0) &amp;&amp;</span>
<span class="line-added">1611              log_is_enabled(Info, monitorinflation)) {</span>
<span class="line-added">1612     ls = &amp;lsh_info;</span>
<span class="line-added">1613   }</span>
<span class="line-added">1614   if (ls != NULL) {</span>
<span class="line-added">1615     ls-&gt;print_cr(&quot;om_flush: jt=&quot; INTPTR_FORMAT &quot;, free_count=%d&quot;</span>
<span class="line-added">1616                  &quot;, in_use_count=%d&quot; &quot;, om_free_provision=%d&quot;,</span>
<span class="line-added">1617                  p2i(self), free_count, in_use_count, self-&gt;om_free_provision);</span>
<span class="line-added">1618   }</span>
1619 }
1620 
1621 static void post_monitor_inflate_event(EventJavaMonitorInflate* event,
1622                                        const oop obj,
1623                                        ObjectSynchronizer::InflateCause cause) {
1624   assert(event != NULL, &quot;invariant&quot;);
1625   assert(event-&gt;should_commit(), &quot;invariant&quot;);
1626   event-&gt;set_monitorClass(obj-&gt;klass());
1627   event-&gt;set_address((uintptr_t)(void*)obj);
1628   event-&gt;set_cause((u1)cause);
1629   event-&gt;commit();
1630 }
1631 
1632 // Fast path code shared by multiple functions
1633 void ObjectSynchronizer::inflate_helper(oop obj) {
<span class="line-modified">1634   markWord mark = obj-&gt;mark();</span>
<span class="line-modified">1635   if (mark.has_monitor()) {</span>
<span class="line-modified">1636     assert(ObjectSynchronizer::verify_objmon_isinpool(mark.monitor()), &quot;monitor is invalid&quot;);</span>
<span class="line-modified">1637     assert(mark.monitor()-&gt;header().is_neutral(), &quot;monitor must record a good object header&quot;);</span>
1638     return;
1639   }
1640   inflate(Thread::current(), obj, inflate_cause_vm_internal);
1641 }
1642 
<span class="line-modified">1643 ObjectMonitor* ObjectSynchronizer::inflate(Thread* self,</span>
<span class="line-modified">1644                                            oop object, const InflateCause cause) {</span>

1645   // Inflate mutates the heap ...
1646   // Relaxing assertion for bug 6320749.
1647   assert(Universe::verify_in_progress() ||
1648          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1649 
1650   EventJavaMonitorInflate event;
1651 
1652   for (;;) {
<span class="line-modified">1653     const markWord mark = object-&gt;mark();</span>
<span class="line-modified">1654     assert(!mark.has_bias_pattern(), &quot;invariant&quot;);</span>
1655 
1656     // The mark can be in one of the following states:
1657     // *  Inflated     - just return
1658     // *  Stack-locked - coerce it to inflated
1659     // *  INFLATING    - busy wait for conversion to complete
1660     // *  Neutral      - aggressively inflate the object.
1661     // *  BIASED       - Illegal.  We should never see this
1662 
1663     // CASE: inflated
<span class="line-modified">1664     if (mark.has_monitor()) {</span>
<span class="line-modified">1665       ObjectMonitor* inf = mark.monitor();</span>
<span class="line-modified">1666       markWord dmw = inf-&gt;header();</span>
<span class="line-modified">1667       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());</span>
<span class="line-modified">1668       assert(inf-&gt;object() == object, &quot;invariant&quot;);</span>
1669       assert(ObjectSynchronizer::verify_objmon_isinpool(inf), &quot;monitor is invalid&quot;);
1670       return inf;
1671     }
1672 
1673     // CASE: inflation in progress - inflating over a stack-lock.
1674     // Some other thread is converting from stack-locked to inflated.
1675     // Only that thread can complete inflation -- other threads must wait.
1676     // The INFLATING value is transient.
1677     // Currently, we spin/yield/park and poll the markword, waiting for inflation to finish.
1678     // We could always eliminate polling by parking the thread on some auxiliary list.
<span class="line-modified">1679     if (mark == markWord::INFLATING()) {</span>
<span class="line-modified">1680       read_stable_mark(object);</span>
1681       continue;
1682     }
1683 
1684     // CASE: stack-locked
1685     // Could be stack-locked either by this thread or by some other thread.
1686     //
1687     // Note that we allocate the objectmonitor speculatively, _before_ attempting
1688     // to install INFLATING into the mark word.  We originally installed INFLATING,
1689     // allocated the objectmonitor, and then finally STed the address of the
1690     // objectmonitor into the mark.  This was correct, but artificially lengthened
1691     // the interval in which INFLATED appeared in the mark, thus increasing
1692     // the odds of inflation contention.
1693     //
1694     // We now use per-thread private objectmonitor free lists.
1695     // These list are reprovisioned from the global free list outside the
1696     // critical INFLATING...ST interval.  A thread can transfer
1697     // multiple objectmonitors en-mass from the global free list to its local free list.
1698     // This reduces coherency traffic and lock contention on the global free list.
<span class="line-modified">1699     // Using such local free lists, it doesn&#39;t matter if the om_alloc() call appears</span>
1700     // before or after the CAS(INFLATING) operation.
<span class="line-modified">1701     // See the comments in om_alloc().</span>
1702 
1703     LogStreamHandle(Trace, monitorinflation) lsh;
1704 
<span class="line-modified">1705     if (mark.has_locker()) {</span>
<span class="line-modified">1706       ObjectMonitor* m = om_alloc(self);</span>
1707       // Optimistically prepare the objectmonitor - anticipate successful CAS
1708       // We do this before the CAS in order to minimize the length of time
1709       // in which INFLATING appears in the mark.
1710       m-&gt;Recycle();
1711       m-&gt;_Responsible  = NULL;

1712       m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;   // Consider: maintain by type/class
1713 
<span class="line-modified">1714       markWord cmp = object-&gt;cas_set_mark(markWord::INFLATING(), mark);</span>
1715       if (cmp != mark) {
<span class="line-modified">1716         om_release(self, m, true);</span>
1717         continue;       // Interference -- just retry
1718       }
1719 
1720       // We&#39;ve successfully installed INFLATING (0) into the mark-word.
1721       // This is the only case where 0 will appear in a mark-word.
1722       // Only the singular thread that successfully swings the mark-word
1723       // to 0 can perform (or more precisely, complete) inflation.
1724       //
1725       // Why do we CAS a 0 into the mark-word instead of just CASing the
1726       // mark-word from the stack-locked value directly to the new inflated state?
1727       // Consider what happens when a thread unlocks a stack-locked object.
1728       // It attempts to use CAS to swing the displaced header value from the
<span class="line-modified">1729       // on-stack BasicLock back into the object header.  Recall also that the</span>
<span class="line-modified">1730       // header value (hash code, etc) can reside in (a) the object header, or</span>
1731       // (b) a displaced header associated with the stack-lock, or (c) a displaced
<span class="line-modified">1732       // header in an ObjectMonitor.  The inflate() routine must copy the header</span>
<span class="line-modified">1733       // value from the BasicLock on the owner&#39;s stack to the ObjectMonitor, all</span>
1734       // the while preserving the hashCode stability invariants.  If the owner
1735       // decides to release the lock while the value is 0, the unlock will fail
1736       // and control will eventually pass from slow_exit() to inflate.  The owner
1737       // will then spin, waiting for the 0 value to disappear.   Put another way,
1738       // the 0 causes the owner to stall if the owner happens to try to
<span class="line-modified">1739       // drop the lock (restoring the header from the BasicLock to the object)</span>
1740       // while inflation is in-progress.  This protocol avoids races that might
1741       // would otherwise permit hashCode values to change or &quot;flicker&quot; for an object.
<span class="line-modified">1742       // Critically, while object-&gt;mark is 0 mark.displaced_mark_helper() is stable.</span>
1743       // 0 serves as a &quot;BUSY&quot; inflate-in-progress indicator.
1744 
1745 
1746       // fetch the displaced mark from the owner&#39;s stack.
1747       // The owner can&#39;t die or unwind past the lock while our INFLATING
1748       // object is in the mark.  Furthermore the owner can&#39;t complete
1749       // an unlock on the object, either.
<span class="line-modified">1750       markWord dmw = mark.displaced_mark_helper();</span>
<span class="line-modified">1751       // Catch if the object&#39;s header is not neutral (not locked and</span>
<span class="line-added">1752       // not marked is what we care about here).</span>
<span class="line-added">1753       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());</span>
1754 
1755       // Setup monitor fields to proper values -- prepare the monitor
1756       m-&gt;set_header(dmw);
1757 
<span class="line-modified">1758       // Optimization: if the mark.locker stack address is associated</span>
<span class="line-modified">1759       // with this thread we could simply set m-&gt;_owner = self.</span>
1760       // Note that a thread can inflate an object
1761       // that it has stack-locked -- as might happen in wait() -- directly
1762       // with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.
<span class="line-modified">1763       m-&gt;set_owner_from(NULL, mark.locker());</span>
1764       m-&gt;set_object(object);
1765       // TODO-FIXME: assert BasicLock-&gt;dhw != 0.
1766 
1767       // Must preserve store ordering. The monitor state must
1768       // be stable at the time of publishing the monitor address.
<span class="line-modified">1769       guarantee(object-&gt;mark() == markWord::INFLATING(), &quot;invariant&quot;);</span>
<span class="line-modified">1770       object-&gt;release_set_mark(markWord::encode(m));</span>
1771 
1772       // Hopefully the performance counters are allocated on distinct cache lines
1773       // to avoid false sharing on MP systems ...
1774       OM_PERFDATA_OP(Inflations, inc());
1775       if (log_is_enabled(Trace, monitorinflation)) {
<span class="line-modified">1776         ResourceMark rm(self);</span>
1777         lsh.print_cr(&quot;inflate(has_locker): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
1778                      INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
<span class="line-modified">1779                      object-&gt;mark().value(), object-&gt;klass()-&gt;external_name());</span>
1780       }
1781       if (event.should_commit()) {
1782         post_monitor_inflate_event(&amp;event, object, cause);
1783       }
1784       return m;
1785     }
1786 
1787     // CASE: neutral
1788     // TODO-FIXME: for entry we currently inflate and then try to CAS _owner.
1789     // If we know we&#39;re inflating for entry it&#39;s better to inflate by swinging a
<span class="line-modified">1790     // pre-locked ObjectMonitor pointer into the object header.   A successful</span>
1791     // CAS inflates the object *and* confers ownership to the inflating thread.
1792     // In the current implementation we use a 2-step mechanism where we CAS()
<span class="line-modified">1793     // to inflate and then CAS() again to try to swing _owner from NULL to self.</span>
<span class="line-modified">1794     // An inflateTry() method that we could call from enter() would be useful.</span>

1795 
<span class="line-modified">1796     // Catch if the object&#39;s header is not neutral (not locked and</span>
<span class="line-modified">1797     // not marked is what we care about here).</span>
<span class="line-added">1798     assert(mark.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, mark.value());</span>
<span class="line-added">1799     ObjectMonitor* m = om_alloc(self);</span>
1800     // prepare m for installation - set monitor to initial state
1801     m-&gt;Recycle();
1802     m-&gt;set_header(mark);

1803     m-&gt;set_object(object);

1804     m-&gt;_Responsible  = NULL;
1805     m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit;       // consider: keep metastats by type/class
1806 
<span class="line-modified">1807     if (object-&gt;cas_set_mark(markWord::encode(m), mark) != mark) {</span>
<span class="line-modified">1808       m-&gt;set_header(markWord::zero());</span>
1809       m-&gt;set_object(NULL);
1810       m-&gt;Recycle();
<span class="line-modified">1811       om_release(self, m, true);</span>
1812       m = NULL;
1813       continue;
1814       // interference - the markword changed - just retry.
1815       // The state-transitions are one-way, so there&#39;s no chance of
1816       // live-lock -- &quot;Inflated&quot; is an absorbing state.
1817     }
1818 
1819     // Hopefully the performance counters are allocated on distinct
1820     // cache lines to avoid false sharing on MP systems ...
1821     OM_PERFDATA_OP(Inflations, inc());
1822     if (log_is_enabled(Trace, monitorinflation)) {
<span class="line-modified">1823       ResourceMark rm(self);</span>
1824       lsh.print_cr(&quot;inflate(neutral): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
1825                    INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
<span class="line-modified">1826                    object-&gt;mark().value(), object-&gt;klass()-&gt;external_name());</span>
1827     }
1828     if (event.should_commit()) {
1829       post_monitor_inflate_event(&amp;event, object, cause);
1830     }
1831     return m;
1832   }
1833 }
1834 
1835 
<span class="line-modified">1836 // We maintain a list of in-use monitors for each thread.</span>
1837 //
1838 // deflate_thread_local_monitors() scans a single thread&#39;s in-use list, while
1839 // deflate_idle_monitors() scans only a global list of in-use monitors which
<span class="line-modified">1840 // is populated only as a thread dies (see om_flush()).</span>
1841 //
1842 // These operations are called at all safepoints, immediately after mutators
1843 // are stopped, but before any objects have moved. Collectively they traverse
1844 // the population of in-use monitors, deflating where possible. The scavenged
<span class="line-modified">1845 // monitors are returned to the global monitor free list.</span>
1846 //
1847 // Beware that we scavenge at *every* stop-the-world point. Having a large
1848 // number of monitors in-use could negatively impact performance. We also want
1849 // to minimize the total # of monitors in circulation, as they incur a small
1850 // footprint penalty.
1851 //
1852 // Perversely, the heap size -- and thus the STW safepoint rate --
1853 // typically drives the scavenge rate.  Large heaps can mean infrequent GC,
<span class="line-modified">1854 // which in turn can mean large(r) numbers of ObjectMonitors in circulation.</span>
1855 // This is an unfortunate aspect of this design.
1856 
1857 // Deflate a single monitor if not in-use
1858 // Return true if deflated, false if in-use
1859 bool ObjectSynchronizer::deflate_monitor(ObjectMonitor* mid, oop obj,
<span class="line-modified">1860                                          ObjectMonitor** free_head_p,</span>
<span class="line-modified">1861                                          ObjectMonitor** free_tail_p) {</span>
1862   bool deflated;
1863   // Normal case ... The monitor is associated with obj.
<span class="line-modified">1864   const markWord mark = obj-&gt;mark();</span>
<span class="line-modified">1865   guarantee(mark == markWord::encode(mid), &quot;should match: mark=&quot;</span>
<span class="line-modified">1866             INTPTR_FORMAT &quot;, encoded mid=&quot; INTPTR_FORMAT, mark.value(),</span>
<span class="line-added">1867             markWord::encode(mid).value());</span>
<span class="line-added">1868   // Make sure that mark.monitor() and markWord::encode() agree:</span>
<span class="line-added">1869   guarantee(mark.monitor() == mid, &quot;should match: monitor()=&quot; INTPTR_FORMAT</span>
<span class="line-added">1870             &quot;, mid=&quot; INTPTR_FORMAT, p2i(mark.monitor()), p2i(mid));</span>
<span class="line-added">1871   const markWord dmw = mid-&gt;header();</span>
<span class="line-added">1872   guarantee(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());</span>
1873 
1874   if (mid-&gt;is_busy()) {
<span class="line-added">1875     // Easy checks are first - the ObjectMonitor is busy so no deflation.</span>
1876     deflated = false;
1877   } else {
1878     // Deflate the monitor if it is no longer being used
1879     // It&#39;s idle - scavenge and return to the global free list
1880     // plain old deflation ...
1881     if (log_is_enabled(Trace, monitorinflation)) {
1882       ResourceMark rm;
1883       log_trace(monitorinflation)(&quot;deflate_monitor: &quot;
<span class="line-modified">1884                                   &quot;object=&quot; INTPTR_FORMAT &quot;, mark=&quot;</span>
<span class="line-modified">1885                                   INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(obj),</span>
<span class="line-modified">1886                                   mark.value(), obj-&gt;klass()-&gt;external_name());</span>
1887     }
1888 
1889     // Restore the header back to obj
<span class="line-modified">1890     obj-&gt;release_set_mark(dmw);</span>
1891     mid-&gt;clear();
1892 
<span class="line-modified">1893     assert(mid-&gt;object() == NULL, &quot;invariant: object=&quot; INTPTR_FORMAT,</span>
<span class="line-modified">1894            p2i(mid-&gt;object()));</span>
<span class="line-modified">1895 </span>
<span class="line-modified">1896     // Move the deflated ObjectMonitor to the working free list</span>
<span class="line-modified">1897     // defined by free_head_p and free_tail_p.</span>
<span class="line-modified">1898     if (*free_head_p == NULL) *free_head_p = mid;</span>
<span class="line-modified">1899     if (*free_tail_p != NULL) {</span>
<span class="line-modified">1900       // We append to the list so the caller can use mid-&gt;_next_om</span>
<span class="line-added">1901       // to fix the linkages in its context.</span>
<span class="line-added">1902       ObjectMonitor* prevtail = *free_tail_p;</span>
<span class="line-added">1903       // Should have been cleaned up by the caller:</span>
<span class="line-added">1904       // Note: Should not have to lock prevtail here since we&#39;re at a</span>
<span class="line-added">1905       // safepoint and ObjectMonitors on the local free list should</span>
<span class="line-added">1906       // not be accessed in parallel.</span>
<span class="line-added">1907 #ifdef ASSERT</span>
<span class="line-added">1908       ObjectMonitor* l_next_om = prevtail-&gt;next_om();</span>
<span class="line-added">1909 #endif</span>
<span class="line-added">1910       assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="line-added">1911       prevtail-&gt;set_next_om(mid);</span>
1912     }
<span class="line-modified">1913     *free_tail_p = mid;</span>
<span class="line-added">1914     // At this point, mid-&gt;_next_om still refers to its current</span>
<span class="line-added">1915     // value and another ObjectMonitor&#39;s _next_om field still</span>
<span class="line-added">1916     // refers to this ObjectMonitor. Those linkages have to be</span>
<span class="line-added">1917     // cleaned up by the caller who has the complete context.</span>
1918     deflated = true;
1919   }
1920   return deflated;
1921 }
1922 
<span class="line-modified">1923 // Walk a given monitor list, and deflate idle monitors.</span>
<span class="line-modified">1924 // The given list could be a per-thread list or a global list.</span>

1925 //
1926 // In the case of parallel processing of thread local monitor lists,
1927 // work is done by Threads::parallel_threads_do() which ensures that
1928 // each Java thread is processed by exactly one worker thread, and
1929 // thus avoid conflicts that would arise when worker threads would
1930 // process the same monitor lists concurrently.
1931 //
1932 // See also ParallelSPCleanupTask and
1933 // SafepointSynchronize::do_cleanup_tasks() in safepoint.cpp and
1934 // Threads::parallel_java_threads_do() in thread.cpp.
<span class="line-modified">1935 int ObjectSynchronizer::deflate_monitor_list(ObjectMonitor** list_p,</span>
<span class="line-modified">1936                                              int* count_p,</span>
<span class="line-modified">1937                                              ObjectMonitor** free_head_p,</span>
<span class="line-modified">1938                                              ObjectMonitor** free_tail_p) {</span>

1939   ObjectMonitor* cur_mid_in_use = NULL;
<span class="line-added">1940   ObjectMonitor* mid = NULL;</span>
<span class="line-added">1941   ObjectMonitor* next = NULL;</span>
1942   int deflated_count = 0;
1943 
<span class="line-modified">1944   // This list walk executes at a safepoint and does not race with any</span>
<span class="line-added">1945   // other list walkers.</span>
<span class="line-added">1946 </span>
<span class="line-added">1947   for (mid = Atomic::load(list_p); mid != NULL; mid = next) {</span>
<span class="line-added">1948     next = unmarked_next(mid);</span>
1949     oop obj = (oop) mid-&gt;object();
<span class="line-modified">1950     if (obj != NULL &amp;&amp; deflate_monitor(mid, obj, free_head_p, free_tail_p)) {</span>
<span class="line-modified">1951       // Deflation succeeded and already updated free_head_p and</span>
<span class="line-modified">1952       // free_tail_p as needed. Finish the move to the local free list</span>
<span class="line-modified">1953       // by unlinking mid from the global or per-thread in-use list.</span>
<span class="line-modified">1954       if (cur_mid_in_use == NULL) {</span>
<span class="line-modified">1955         // mid is the list head so switch the list head to next:</span>
<span class="line-modified">1956         Atomic::store(list_p, next);</span>
<span class="line-added">1957       } else {</span>
<span class="line-added">1958         // Switch cur_mid_in_use&#39;s next field to next:</span>
<span class="line-added">1959         cur_mid_in_use-&gt;set_next_om(next);</span>
1960       }
<span class="line-modified">1961       // At this point mid is disconnected from the in-use list.</span>


1962       deflated_count++;
<span class="line-added">1963       Atomic::dec(count_p);</span>
<span class="line-added">1964       // mid is current tail in the free_head_p list so NULL terminate it:</span>
<span class="line-added">1965       mid-&gt;set_next_om(NULL);</span>
1966     } else {
1967       cur_mid_in_use = mid;

1968     }
1969   }
1970   return deflated_count;
1971 }
1972 
1973 void ObjectSynchronizer::prepare_deflate_idle_monitors(DeflateMonitorCounters* counters) {
<span class="line-modified">1974   counters-&gt;n_in_use = 0;              // currently associated with objects</span>
<span class="line-modified">1975   counters-&gt;n_in_circulation = 0;      // extant</span>
<span class="line-modified">1976   counters-&gt;n_scavenged = 0;           // reclaimed (global and per-thread)</span>
<span class="line-modified">1977   counters-&gt;per_thread_scavenged = 0;  // per-thread scavenge total</span>
<span class="line-modified">1978   counters-&gt;per_thread_times = 0.0;    // per-thread scavenge times</span>
1979 }
1980 
1981 void ObjectSynchronizer::deflate_idle_monitors(DeflateMonitorCounters* counters) {
1982   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
1983   bool deflated = false;
1984 
<span class="line-modified">1985   ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors</span>
<span class="line-modified">1986   ObjectMonitor* free_tail_p = NULL;</span>
1987   elapsedTimer timer;
1988 
1989   if (log_is_enabled(Info, monitorinflation)) {
1990     timer.start();
1991   }
1992 





1993   // Note: the thread-local monitors lists get deflated in
1994   // a separate pass. See deflate_thread_local_monitors().
1995 
<span class="line-modified">1996   // For moribund threads, scan om_list_globals._in_use_list</span>
1997   int deflated_count = 0;
<span class="line-modified">1998   if (Atomic::load(&amp;om_list_globals._in_use_list) != NULL) {</span>
<span class="line-modified">1999     // Update n_in_circulation before om_list_globals._in_use_count is</span>
<span class="line-modified">2000     // updated by deflation.</span>
<span class="line-modified">2001     Atomic::add(&amp;counters-&gt;n_in_circulation,</span>
<span class="line-modified">2002                 Atomic::load(&amp;om_list_globals._in_use_count));</span>
<span class="line-modified">2003 </span>
<span class="line-modified">2004     deflated_count = deflate_monitor_list(&amp;om_list_globals._in_use_list,</span>
<span class="line-modified">2005                                           &amp;om_list_globals._in_use_count,</span>
<span class="line-modified">2006                                           &amp;free_head_p, &amp;free_tail_p);</span>
<span class="line-modified">2007     Atomic::add(&amp;counters-&gt;n_in_use, Atomic::load(&amp;om_list_globals._in_use_count));</span>
<span class="line-modified">2008   }</span>
<span class="line-modified">2009 </span>
<span class="line-modified">2010   if (free_head_p != NULL) {</span>
<span class="line-modified">2011     // Move the deflated ObjectMonitors back to the global free list.</span>
<span class="line-modified">2012     guarantee(free_tail_p != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">2013 #ifdef ASSERT</span>
<span class="line-modified">2014     ObjectMonitor* l_next_om = free_tail_p-&gt;next_om();</span>
<span class="line-added">2015 #endif</span>
<span class="line-added">2016     assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="line-added">2017     prepend_list_to_global_free_list(free_head_p, free_tail_p, deflated_count);</span>
<span class="line-added">2018     Atomic::add(&amp;counters-&gt;n_scavenged, deflated_count);</span>
<span class="line-added">2019   }</span>
2020   timer.stop();
2021 
2022   LogStreamHandle(Debug, monitorinflation) lsh_debug;
2023   LogStreamHandle(Info, monitorinflation) lsh_info;
<span class="line-modified">2024   LogStream* ls = NULL;</span>
2025   if (log_is_enabled(Debug, monitorinflation)) {
2026     ls = &amp;lsh_debug;
2027   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {
2028     ls = &amp;lsh_info;
2029   }
2030   if (ls != NULL) {
2031     ls-&gt;print_cr(&quot;deflating global idle monitors, %3.7f secs, %d monitors&quot;, timer.seconds(), deflated_count);
2032   }
2033 }
2034 
2035 void ObjectSynchronizer::finish_deflate_idle_monitors(DeflateMonitorCounters* counters) {
2036   // Report the cumulative time for deflating each thread&#39;s idle
2037   // monitors. Note: if the work is split among more than one
2038   // worker thread, then the reported time will likely be more
2039   // than a beginning to end measurement of the phase.
<span class="line-modified">2040   log_info(safepoint, cleanup)(&quot;deflating per-thread idle monitors, %3.7f secs, monitors=%d&quot;, counters-&gt;per_thread_times, counters-&gt;per_thread_scavenged);</span>














2041 
2042   if (log_is_enabled(Debug, monitorinflation)) {
2043     // exit_globals()&#39;s call to audit_and_print_stats() is done
<span class="line-modified">2044     // at the Info level and not at a safepoint.</span>
2045     ObjectSynchronizer::audit_and_print_stats(false /* on_exit */);
<span class="line-added">2046   } else if (log_is_enabled(Info, monitorinflation)) {</span>
<span class="line-added">2047     log_info(monitorinflation)(&quot;global_population=%d, global_in_use_count=%d, &quot;</span>
<span class="line-added">2048                                &quot;global_free_count=%d&quot;,</span>
<span class="line-added">2049                                Atomic::load(&amp;om_list_globals._population),</span>
<span class="line-added">2050                                Atomic::load(&amp;om_list_globals._in_use_count),</span>
<span class="line-added">2051                                Atomic::load(&amp;om_list_globals._free_count));</span>
2052   }
2053 
<span class="line-modified">2054   Atomic::store(&amp;_forceMonitorScavenge, 0);    // Reset</span>
2055 
<span class="line-modified">2056   OM_PERFDATA_OP(Deflations, inc(counters-&gt;n_scavenged));</span>
<span class="line-modified">2057   OM_PERFDATA_OP(MonExtant, set_value(counters-&gt;n_in_circulation));</span>
2058 
<span class="line-modified">2059   GVars.stw_random = os::random();</span>
<span class="line-modified">2060   GVars.stw_cycle++;</span>
2061 }
2062 
2063 void ObjectSynchronizer::deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters) {
2064   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
2065 
<span class="line-modified">2066   ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors</span>
<span class="line-modified">2067   ObjectMonitor* free_tail_p = NULL;</span>
2068   elapsedTimer timer;
2069 
2070   if (log_is_enabled(Info, safepoint, cleanup) ||
2071       log_is_enabled(Info, monitorinflation)) {
2072     timer.start();
2073   }
2074 
<span class="line-modified">2075   // Update n_in_circulation before om_in_use_count is updated by deflation.</span>
<span class="line-modified">2076   Atomic::add(&amp;counters-&gt;n_in_circulation, Atomic::load(&amp;thread-&gt;om_in_use_count));</span>

2077 
<span class="line-modified">2078   int deflated_count = deflate_monitor_list(&amp;thread-&gt;om_in_use_list, &amp;thread-&gt;om_in_use_count, &amp;free_head_p, &amp;free_tail_p);</span>
<span class="line-added">2079   Atomic::add(&amp;counters-&gt;n_in_use, Atomic::load(&amp;thread-&gt;om_in_use_count));</span>
2080 
<span class="line-modified">2081   if (free_head_p != NULL) {</span>
<span class="line-modified">2082     // Move the deflated ObjectMonitors back to the global free list.</span>
<span class="line-modified">2083     guarantee(free_tail_p != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">2084 #ifdef ASSERT</span>
<span class="line-modified">2085     ObjectMonitor* l_next_om = free_tail_p-&gt;next_om();</span>
<span class="line-modified">2086 #endif</span>
<span class="line-modified">2087     assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="line-modified">2088     prepend_list_to_global_free_list(free_head_p, free_tail_p, deflated_count);</span>
<span class="line-added">2089     Atomic::add(&amp;counters-&gt;n_scavenged, deflated_count);</span>
<span class="line-added">2090     Atomic::add(&amp;counters-&gt;per_thread_scavenged, deflated_count);</span>
<span class="line-added">2091   }</span>
2092 
<span class="line-modified">2093   timer.stop();</span>
<span class="line-modified">2094   counters-&gt;per_thread_times += timer.seconds();</span>


2095 
<span class="line-modified">2096   LogStreamHandle(Debug, monitorinflation) lsh_debug;</span>
<span class="line-modified">2097   LogStreamHandle(Info, monitorinflation) lsh_info;</span>
<span class="line-modified">2098   LogStream* ls = NULL;</span>
<span class="line-added">2099   if (log_is_enabled(Debug, monitorinflation)) {</span>
<span class="line-added">2100     ls = &amp;lsh_debug;</span>
<span class="line-added">2101   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {</span>
<span class="line-added">2102     ls = &amp;lsh_info;</span>
<span class="line-added">2103   }</span>
<span class="line-added">2104   if (ls != NULL) {</span>
<span class="line-added">2105     ls-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, p2i(thread), timer.seconds(), deflated_count);</span>
2106   }

2107 }
2108 
2109 // Monitor cleanup on JavaThread::exit
2110 
2111 // Iterate through monitor cache and attempt to release thread&#39;s monitors
2112 // Gives up on a particular monitor if an exception occurs, but continues
2113 // the overall iteration, swallowing the exception.
2114 class ReleaseJavaMonitorsClosure: public MonitorClosure {
2115  private:
2116   TRAPS;
2117 
2118  public:
2119   ReleaseJavaMonitorsClosure(Thread* thread) : THREAD(thread) {}
2120   void do_monitor(ObjectMonitor* mid) {
2121     if (mid-&gt;owner() == THREAD) {
2122       // Note well -- this occurs ONLY on thread exit, and is a last ditch
2123       // effort to release all locks. Hence, we don&#39;t need to record tsan&#39;s
2124       // recursion count -- it will never be locked again.
2125       TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_unlock(THREAD, (oop)mid-&gt;object()));
2126       (void)mid-&gt;complete_exit(CHECK);
</pre>
<hr />
<pre>
2130 
2131 // Release all inflated monitors owned by THREAD.  Lightweight monitors are
2132 // ignored.  This is meant to be called during JNI thread detach which assumes
2133 // all remaining monitors are heavyweight.  All exceptions are swallowed.
2134 // Scanning the extant monitor list can be time consuming.
2135 // A simple optimization is to add a per-thread flag that indicates a thread
2136 // called jni_monitorenter() during its lifetime.
2137 //
2138 // Instead of No_Savepoint_Verifier it might be cheaper to
2139 // use an idiom of the form:
2140 //   auto int tmp = SafepointSynchronize::_safepoint_counter ;
2141 //   &lt;code that must not run at safepoint&gt;
2142 //   guarantee (((tmp ^ _safepoint_counter) | (tmp &amp; 1)) == 0) ;
2143 // Since the tests are extremely cheap we could leave them enabled
2144 // for normal product builds.
2145 
2146 void ObjectSynchronizer::release_monitors_owned_by_thread(TRAPS) {
2147   assert(THREAD == JavaThread::current(), &quot;must be current Java thread&quot;);
2148   NoSafepointVerifier nsv;
2149   ReleaseJavaMonitorsClosure rjmc(THREAD);

2150   ObjectSynchronizer::monitors_iterate(&amp;rjmc);

2151   THREAD-&gt;clear_pending_exception();
2152 }
2153 
2154 const char* ObjectSynchronizer::inflate_cause_name(const InflateCause cause) {
2155   switch (cause) {
2156     case inflate_cause_vm_internal:    return &quot;VM Internal&quot;;
2157     case inflate_cause_monitor_enter:  return &quot;Monitor Enter&quot;;
2158     case inflate_cause_wait:           return &quot;Monitor Wait&quot;;
2159     case inflate_cause_notify:         return &quot;Monitor Notify&quot;;
2160     case inflate_cause_hash_code:      return &quot;Monitor Hash Code&quot;;
2161     case inflate_cause_jni_enter:      return &quot;JNI Monitor Enter&quot;;
2162     case inflate_cause_jni_exit:       return &quot;JNI Monitor Exit&quot;;
2163     default:
2164       ShouldNotReachHere();
2165   }
2166   return &quot;Unknown&quot;;
2167 }
2168 
2169 //------------------------------------------------------------------------------
2170 // Debugging code
2171 
2172 u_char* ObjectSynchronizer::get_gvars_addr() {
2173   return (u_char*)&amp;GVars;
2174 }
2175 
<span class="line-modified">2176 u_char* ObjectSynchronizer::get_gvars_hc_sequence_addr() {</span>
<span class="line-modified">2177   return (u_char*)&amp;GVars.hc_sequence;</span>
2178 }
2179 
2180 size_t ObjectSynchronizer::get_gvars_size() {
2181   return sizeof(SharedGlobals);
2182 }
2183 
<span class="line-modified">2184 u_char* ObjectSynchronizer::get_gvars_stw_random_addr() {</span>
<span class="line-modified">2185   return (u_char*)&amp;GVars.stw_random;</span>
2186 }
2187 
<span class="line-added">2188 // This function can be called at a safepoint or it can be called when</span>
<span class="line-added">2189 // we are trying to exit the VM. When we are trying to exit the VM, the</span>
<span class="line-added">2190 // list walker functions can run in parallel with the other list</span>
<span class="line-added">2191 // operations so spin-locking is used for safety.</span>
<span class="line-added">2192 //</span>
<span class="line-added">2193 // Calls to this function can be added in various places as a debugging</span>
<span class="line-added">2194 // aid; pass &#39;true&#39; for the &#39;on_exit&#39; parameter to have in-use monitor</span>
<span class="line-added">2195 // details logged at the Info level and &#39;false&#39; for the &#39;on_exit&#39;</span>
<span class="line-added">2196 // parameter to have in-use monitor details logged at the Trace level.</span>
<span class="line-added">2197 // deflate_monitor_list() no longer uses spin-locking so be careful</span>
<span class="line-added">2198 // when adding audit_and_print_stats() calls at a safepoint.</span>
<span class="line-added">2199 //</span>
2200 void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {
2201   assert(on_exit || SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
2202 
2203   LogStreamHandle(Debug, monitorinflation) lsh_debug;
2204   LogStreamHandle(Info, monitorinflation) lsh_info;
2205   LogStreamHandle(Trace, monitorinflation) lsh_trace;
<span class="line-modified">2206   LogStream* ls = NULL;</span>
2207   if (log_is_enabled(Trace, monitorinflation)) {
2208     ls = &amp;lsh_trace;
2209   } else if (log_is_enabled(Debug, monitorinflation)) {
2210     ls = &amp;lsh_debug;
2211   } else if (log_is_enabled(Info, monitorinflation)) {
2212     ls = &amp;lsh_info;
2213   }
2214   assert(ls != NULL, &quot;sanity check&quot;);
2215 





2216   // Log counts for the global and per-thread monitor lists:
<span class="line-modified">2217   int chk_om_population = log_monitor_list_counts(ls);</span>
2218   int error_cnt = 0;
2219 
2220   ls-&gt;print_cr(&quot;Checking global lists:&quot;);
2221 
<span class="line-modified">2222   // Check om_list_globals._population:</span>
<span class="line-modified">2223   if (Atomic::load(&amp;om_list_globals._population) == chk_om_population) {</span>
<span class="line-modified">2224     ls-&gt;print_cr(&quot;global_population=%d equals chk_om_population=%d&quot;,</span>
<span class="line-modified">2225                  Atomic::load(&amp;om_list_globals._population), chk_om_population);</span>
2226   } else {
<span class="line-modified">2227     // With fine grained locks on the monitor lists, it is possible for</span>
<span class="line-modified">2228     // log_monitor_list_counts() to return a value that doesn&#39;t match</span>
<span class="line-modified">2229     // om_list_globals._population. So far a higher value has been</span>
<span class="line-modified">2230     // seen in testing so something is being double counted by</span>
<span class="line-added">2231     // log_monitor_list_counts().</span>
<span class="line-added">2232     ls-&gt;print_cr(&quot;WARNING: global_population=%d is not equal to &quot;</span>
<span class="line-added">2233                  &quot;chk_om_population=%d&quot;,</span>
<span class="line-added">2234                  Atomic::load(&amp;om_list_globals._population), chk_om_population);</span>
2235   }
2236 
<span class="line-modified">2237   // Check om_list_globals._in_use_list and om_list_globals._in_use_count:</span>
2238   chk_global_in_use_list_and_count(ls, &amp;error_cnt);
2239 
<span class="line-modified">2240   // Check om_list_globals._free_list and om_list_globals._free_count:</span>
2241   chk_global_free_list_and_count(ls, &amp;error_cnt);
2242 




2243   ls-&gt;print_cr(&quot;Checking per-thread lists:&quot;);
2244 
2245   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-modified">2246     // Check om_in_use_list and om_in_use_count:</span>
2247     chk_per_thread_in_use_list_and_count(jt, ls, &amp;error_cnt);
2248 
<span class="line-modified">2249     // Check om_free_list and om_free_count:</span>
2250     chk_per_thread_free_list_and_count(jt, ls, &amp;error_cnt);
2251   }
2252 
2253   if (error_cnt == 0) {
2254     ls-&gt;print_cr(&quot;No errors found in monitor list checks.&quot;);
2255   } else {
2256     log_error(monitorinflation)(&quot;found monitor list errors: error_cnt=%d&quot;, error_cnt);
2257   }
2258 
2259   if ((on_exit &amp;&amp; log_is_enabled(Info, monitorinflation)) ||
2260       (!on_exit &amp;&amp; log_is_enabled(Trace, monitorinflation))) {
2261     // When exiting this log output is at the Info level. When called
2262     // at a safepoint, this log output is at the Trace level since
2263     // there can be a lot of it.
<span class="line-modified">2264     log_in_use_monitor_details(ls);</span>
2265   }
2266 
2267   ls-&gt;flush();
2268 
2269   guarantee(error_cnt == 0, &quot;ERROR: found monitor list errors: error_cnt=%d&quot;, error_cnt);
2270 }
2271 
2272 // Check a free monitor entry; log any errors.
<span class="line-modified">2273 void ObjectSynchronizer::chk_free_entry(JavaThread* jt, ObjectMonitor* n,</span>
2274                                         outputStream * out, int *error_cnt_p) {
<span class="line-added">2275   stringStream ss;</span>
2276   if (n-&gt;is_busy()) {
2277     if (jt != NULL) {
2278       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
<span class="line-modified">2279                     &quot;: free per-thread monitor must not be busy: %s&quot;, p2i(jt),</span>
<span class="line-modified">2280                     p2i(n), n-&gt;is_busy_to_string(&amp;ss));</span>
2281     } else {
2282       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
<span class="line-modified">2283                     &quot;must not be busy: %s&quot;, p2i(n), n-&gt;is_busy_to_string(&amp;ss));</span>
2284     }
2285     *error_cnt_p = *error_cnt_p + 1;
2286   }
<span class="line-modified">2287   if (n-&gt;header().value() != 0) {</span>
2288     if (jt != NULL) {
2289       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2290                     &quot;: free per-thread monitor must have NULL _header &quot;
2291                     &quot;field: _header=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
<span class="line-modified">2292                     n-&gt;header().value());</span>
2293     } else {
2294       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
2295                     &quot;must have NULL _header field: _header=&quot; INTPTR_FORMAT,
<span class="line-modified">2296                     p2i(n), n-&gt;header().value());</span>
2297     }
2298     *error_cnt_p = *error_cnt_p + 1;
2299   }
2300   if (n-&gt;object() != NULL) {
2301     if (jt != NULL) {
2302       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2303                     &quot;: free per-thread monitor must have NULL _object &quot;
2304                     &quot;field: _object=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
2305                     p2i(n-&gt;object()));
2306     } else {
2307       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
2308                     &quot;must have NULL _object field: _object=&quot; INTPTR_FORMAT,
2309                     p2i(n), p2i(n-&gt;object()));
2310     }
2311     *error_cnt_p = *error_cnt_p + 1;
2312   }
2313 }
2314 
<span class="line-added">2315 // Lock the next ObjectMonitor for traversal and unlock the current</span>
<span class="line-added">2316 // ObjectMonitor. Returns the next ObjectMonitor if there is one.</span>
<span class="line-added">2317 // Otherwise returns NULL (after unlocking the current ObjectMonitor).</span>
<span class="line-added">2318 // This function is used by the various list walker functions to</span>
<span class="line-added">2319 // safely walk a list without allowing an ObjectMonitor to be moved</span>
<span class="line-added">2320 // to another list in the middle of a walk.</span>
<span class="line-added">2321 static ObjectMonitor* lock_next_for_traversal(ObjectMonitor* cur) {</span>
<span class="line-added">2322   assert(is_locked(cur), &quot;cur=&quot; INTPTR_FORMAT &quot; must be locked&quot;, p2i(cur));</span>
<span class="line-added">2323   ObjectMonitor* next = unmarked_next(cur);</span>
<span class="line-added">2324   if (next == NULL) {  // Reached the end of the list.</span>
<span class="line-added">2325     om_unlock(cur);</span>
<span class="line-added">2326     return NULL;</span>
<span class="line-added">2327   }</span>
<span class="line-added">2328   om_lock(next);   // Lock next before unlocking current to keep</span>
<span class="line-added">2329   om_unlock(cur);  // from being by-passed by another thread.</span>
<span class="line-added">2330   return next;</span>
<span class="line-added">2331 }</span>
<span class="line-added">2332 </span>
2333 // Check the global free list and count; log the results of the checks.
2334 void ObjectSynchronizer::chk_global_free_list_and_count(outputStream * out,
2335                                                         int *error_cnt_p) {
<span class="line-modified">2336   int chk_om_free_count = 0;</span>
<span class="line-modified">2337   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2338   if ((cur = get_list_head_locked(&amp;om_list_globals._free_list)) != NULL) {</span>
<span class="line-modified">2339     // Marked the global free list head so process the list.</span>
<span class="line-modified">2340     while (true) {</span>
<span class="line-modified">2341       chk_free_entry(NULL /* jt */, cur, out, error_cnt_p);</span>
<span class="line-modified">2342       chk_om_free_count++;</span>
<span class="line-modified">2343 </span>
<span class="line-added">2344       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2345       if (cur == NULL) {</span>
<span class="line-added">2346         break;</span>
<span class="line-added">2347       }</span>
<span class="line-added">2348     }</span>
<span class="line-added">2349   }</span>
<span class="line-added">2350   int l_free_count = Atomic::load(&amp;om_list_globals._free_count);</span>
<span class="line-added">2351   if (l_free_count == chk_om_free_count) {</span>
<span class="line-added">2352     out-&gt;print_cr(&quot;global_free_count=%d equals chk_om_free_count=%d&quot;,</span>
<span class="line-added">2353                   l_free_count, chk_om_free_count);</span>
2354   } else {
<span class="line-modified">2355     // With fine grained locks on om_list_globals._free_list, it</span>
<span class="line-modified">2356     // is possible for an ObjectMonitor to be prepended to</span>
<span class="line-modified">2357     // om_list_globals._free_list after we started calculating</span>
<span class="line-modified">2358     // chk_om_free_count so om_list_globals._free_count may not</span>
<span class="line-added">2359     // match anymore.</span>
<span class="line-added">2360     out-&gt;print_cr(&quot;WARNING: global_free_count=%d is not equal to &quot;</span>
<span class="line-added">2361                   &quot;chk_om_free_count=%d&quot;, l_free_count, chk_om_free_count);</span>
2362   }
2363 }
2364 
2365 // Check the global in-use list and count; log the results of the checks.
2366 void ObjectSynchronizer::chk_global_in_use_list_and_count(outputStream * out,
2367                                                           int *error_cnt_p) {
<span class="line-modified">2368   int chk_om_in_use_count = 0;</span>
<span class="line-modified">2369   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2370   if ((cur = get_list_head_locked(&amp;om_list_globals._in_use_list)) != NULL) {</span>
<span class="line-modified">2371     // Marked the global in-use list head so process the list.</span>
<span class="line-modified">2372     while (true) {</span>
<span class="line-modified">2373       chk_in_use_entry(NULL /* jt */, cur, out, error_cnt_p);</span>
<span class="line-modified">2374       chk_om_in_use_count++;</span>
<span class="line-modified">2375 </span>
<span class="line-added">2376       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2377       if (cur == NULL) {</span>
<span class="line-added">2378         break;</span>
<span class="line-added">2379       }</span>
<span class="line-added">2380     }</span>
<span class="line-added">2381   }</span>
<span class="line-added">2382   int l_in_use_count = Atomic::load(&amp;om_list_globals._in_use_count);</span>
<span class="line-added">2383   if (l_in_use_count == chk_om_in_use_count) {</span>
<span class="line-added">2384     out-&gt;print_cr(&quot;global_in_use_count=%d equals chk_om_in_use_count=%d&quot;,</span>
<span class="line-added">2385                   l_in_use_count, chk_om_in_use_count);</span>
2386   } else {
<span class="line-modified">2387     // With fine grained locks on the monitor lists, it is possible for</span>
<span class="line-modified">2388     // an exiting JavaThread to put its in-use ObjectMonitors on the</span>
<span class="line-modified">2389     // global in-use list after chk_om_in_use_count is calculated above.</span>
<span class="line-added">2390     out-&gt;print_cr(&quot;WARNING: global_in_use_count=%d is not equal to chk_om_in_use_count=%d&quot;,</span>
<span class="line-added">2391                   l_in_use_count, chk_om_in_use_count);</span>
2392   }
2393 }
2394 
2395 // Check an in-use monitor entry; log any errors.
<span class="line-modified">2396 void ObjectSynchronizer::chk_in_use_entry(JavaThread* jt, ObjectMonitor* n,</span>
2397                                           outputStream * out, int *error_cnt_p) {
<span class="line-modified">2398   if (n-&gt;header().value() == 0) {</span>
2399     if (jt != NULL) {
2400       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2401                     &quot;: in-use per-thread monitor must have non-NULL _header &quot;
2402                     &quot;field.&quot;, p2i(jt), p2i(n));
2403     } else {
2404       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global monitor &quot;
2405                     &quot;must have non-NULL _header field.&quot;, p2i(n));
2406     }
2407     *error_cnt_p = *error_cnt_p + 1;
2408   }
2409   if (n-&gt;object() == NULL) {
2410     if (jt != NULL) {
2411       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2412                     &quot;: in-use per-thread monitor must have non-NULL _object &quot;
2413                     &quot;field.&quot;, p2i(jt), p2i(n));
2414     } else {
2415       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global monitor &quot;
2416                     &quot;must have non-NULL _object field.&quot;, p2i(n));
2417     }
2418     *error_cnt_p = *error_cnt_p + 1;
2419   }
2420   const oop obj = (oop)n-&gt;object();
<span class="line-modified">2421   const markWord mark = obj-&gt;mark();</span>
<span class="line-modified">2422   if (!mark.has_monitor()) {</span>
2423     if (jt != NULL) {
2424       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2425                     &quot;: in-use per-thread monitor&#39;s object does not think &quot;
2426                     &quot;it has a monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
<span class="line-modified">2427                     INTPTR_FORMAT,  p2i(jt), p2i(n), p2i(obj), mark.value());</span>

2428     } else {
2429       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
2430                     &quot;monitor&#39;s object does not think it has a monitor: obj=&quot;
2431                     INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT, p2i(n),
<span class="line-modified">2432                     p2i(obj), mark.value());</span>
2433     }
2434     *error_cnt_p = *error_cnt_p + 1;
2435   }
<span class="line-modified">2436   ObjectMonitor* const obj_mon = mark.monitor();</span>
2437   if (n != obj_mon) {
2438     if (jt != NULL) {
2439       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2440                     &quot;: in-use per-thread monitor&#39;s object does not refer &quot;
2441                     &quot;to the same monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
2442                     INTPTR_FORMAT &quot;, obj_mon=&quot; INTPTR_FORMAT, p2i(jt),
<span class="line-modified">2443                     p2i(n), p2i(obj), mark.value(), p2i(obj_mon));</span>

2444     } else {
2445       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
2446                     &quot;monitor&#39;s object does not refer to the same monitor: obj=&quot;
2447                     INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT &quot;, obj_mon=&quot;
<span class="line-modified">2448                     INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));</span>

2449     }
2450     *error_cnt_p = *error_cnt_p + 1;
2451   }
2452 }
2453 
2454 // Check the thread&#39;s free list and count; log the results of the checks.
2455 void ObjectSynchronizer::chk_per_thread_free_list_and_count(JavaThread *jt,
2456                                                             outputStream * out,
2457                                                             int *error_cnt_p) {
<span class="line-modified">2458   int chk_om_free_count = 0;</span>
<span class="line-modified">2459   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2460   if ((cur = get_list_head_locked(&amp;jt-&gt;om_free_list)) != NULL) {</span>
<span class="line-modified">2461     // Marked the per-thread free list head so process the list.</span>
<span class="line-modified">2462     while (true) {</span>
<span class="line-modified">2463       chk_free_entry(jt, cur, out, error_cnt_p);</span>
<span class="line-modified">2464       chk_om_free_count++;</span>
<span class="line-modified">2465 </span>
<span class="line-added">2466       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2467       if (cur == NULL) {</span>
<span class="line-added">2468         break;</span>
<span class="line-added">2469       }</span>
<span class="line-added">2470     }</span>
<span class="line-added">2471   }</span>
<span class="line-added">2472   int l_om_free_count = Atomic::load(&amp;jt-&gt;om_free_count);</span>
<span class="line-added">2473   if (l_om_free_count == chk_om_free_count) {</span>
<span class="line-added">2474     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: om_free_count=%d equals &quot;</span>
<span class="line-added">2475                   &quot;chk_om_free_count=%d&quot;, p2i(jt), l_om_free_count, chk_om_free_count);</span>
2476   } else {
<span class="line-modified">2477     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: om_free_count=%d is not &quot;</span>
<span class="line-modified">2478                   &quot;equal to chk_om_free_count=%d&quot;, p2i(jt), l_om_free_count,</span>
<span class="line-modified">2479                   chk_om_free_count);</span>
2480     *error_cnt_p = *error_cnt_p + 1;
2481   }
2482 }
2483 
2484 // Check the thread&#39;s in-use list and count; log the results of the checks.
2485 void ObjectSynchronizer::chk_per_thread_in_use_list_and_count(JavaThread *jt,
2486                                                               outputStream * out,
2487                                                               int *error_cnt_p) {
<span class="line-modified">2488   int chk_om_in_use_count = 0;</span>
<span class="line-modified">2489   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2490   if ((cur = get_list_head_locked(&amp;jt-&gt;om_in_use_list)) != NULL) {</span>
<span class="line-modified">2491     // Marked the per-thread in-use list head so process the list.</span>
<span class="line-modified">2492     while (true) {</span>
<span class="line-modified">2493       chk_in_use_entry(jt, cur, out, error_cnt_p);</span>
<span class="line-modified">2494       chk_om_in_use_count++;</span>
<span class="line-modified">2495 </span>
<span class="line-modified">2496       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2497       if (cur == NULL) {</span>
<span class="line-added">2498         break;</span>
<span class="line-added">2499       }</span>
<span class="line-added">2500     }</span>
<span class="line-added">2501   }</span>
<span class="line-added">2502   int l_om_in_use_count = Atomic::load(&amp;jt-&gt;om_in_use_count);</span>
<span class="line-added">2503   if (l_om_in_use_count == chk_om_in_use_count) {</span>
<span class="line-added">2504     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: om_in_use_count=%d equals &quot;</span>
<span class="line-added">2505                   &quot;chk_om_in_use_count=%d&quot;, p2i(jt), l_om_in_use_count,</span>
<span class="line-added">2506                   chk_om_in_use_count);</span>
2507   } else {
<span class="line-modified">2508     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: om_in_use_count=%d is not &quot;</span>
<span class="line-modified">2509                   &quot;equal to chk_om_in_use_count=%d&quot;, p2i(jt), l_om_in_use_count,</span>
<span class="line-modified">2510                   chk_om_in_use_count);</span>
2511     *error_cnt_p = *error_cnt_p + 1;
2512   }
2513 }
2514 
2515 // Log details about ObjectMonitors on the in-use lists. The &#39;BHL&#39;
2516 // flags indicate why the entry is in-use, &#39;object&#39; and &#39;object type&#39;
2517 // indicate the associated object and its type.
<span class="line-modified">2518 void ObjectSynchronizer::log_in_use_monitor_details(outputStream * out) {</span>
<span class="line-modified">2519   stringStream ss;</span>
<span class="line-modified">2520   if (Atomic::load(&amp;om_list_globals._in_use_count) &gt; 0) {</span>





2521     out-&gt;print_cr(&quot;In-use global monitor info:&quot;);
<span class="line-modified">2522     out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hash code, L -&gt; lock status)&quot;);</span>
2523     out-&gt;print_cr(&quot;%18s  %s  %18s  %18s&quot;,
2524                   &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
2525     out-&gt;print_cr(&quot;==================  ===  ==================  ==================&quot;);
<span class="line-modified">2526     ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2527     if ((cur = get_list_head_locked(&amp;om_list_globals._in_use_list)) != NULL) {</span>
<span class="line-modified">2528       // Marked the global in-use list head so process the list.</span>
<span class="line-modified">2529       while (true) {</span>
<span class="line-modified">2530         const oop obj = (oop) cur-&gt;object();</span>
<span class="line-modified">2531         const markWord mark = cur-&gt;header();</span>
<span class="line-modified">2532         ResourceMark rm;</span>
<span class="line-modified">2533         out-&gt;print(INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT &quot;  %s&quot;, p2i(cur),</span>
<span class="line-modified">2534                    cur-&gt;is_busy() != 0, mark.hash() != 0, cur-&gt;owner() != NULL,</span>
<span class="line-added">2535                    p2i(obj), obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added">2536         if (cur-&gt;is_busy() != 0) {</span>
<span class="line-added">2537           out-&gt;print(&quot; (%s)&quot;, cur-&gt;is_busy_to_string(&amp;ss));</span>
<span class="line-added">2538           ss.reset();</span>
<span class="line-added">2539         }</span>
<span class="line-added">2540         out-&gt;cr();</span>
2541 
<span class="line-modified">2542         cur = lock_next_for_traversal(cur);</span>
<span class="line-modified">2543         if (cur == NULL) {</span>
<span class="line-added">2544           break;</span>
<span class="line-added">2545         }</span>
<span class="line-added">2546       }</span>
<span class="line-added">2547     }</span>
2548   }
2549 
2550   out-&gt;print_cr(&quot;In-use per-thread monitor info:&quot;);
<span class="line-modified">2551   out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hash code, L -&gt; lock status)&quot;);</span>
2552   out-&gt;print_cr(&quot;%18s  %18s  %s  %18s  %18s&quot;,
2553                 &quot;jt&quot;, &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
2554   out-&gt;print_cr(&quot;==================  ==================  ===  ==================  ==================&quot;);
2555   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-modified">2556     ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2557     if ((cur = get_list_head_locked(&amp;jt-&gt;om_in_use_list)) != NULL) {</span>
<span class="line-modified">2558       // Marked the global in-use list head so process the list.</span>
<span class="line-modified">2559       while (true) {</span>
<span class="line-modified">2560         const oop obj = (oop) cur-&gt;object();</span>
<span class="line-modified">2561         const markWord mark = cur-&gt;header();</span>
<span class="line-modified">2562         ResourceMark rm;</span>
<span class="line-modified">2563         out-&gt;print(INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT</span>
<span class="line-added">2564                    &quot;  %s&quot;, p2i(jt), p2i(cur), cur-&gt;is_busy() != 0,</span>
<span class="line-added">2565                    mark.hash() != 0, cur-&gt;owner() != NULL, p2i(obj),</span>
<span class="line-added">2566                    obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added">2567         if (cur-&gt;is_busy() != 0) {</span>
<span class="line-added">2568           out-&gt;print(&quot; (%s)&quot;, cur-&gt;is_busy_to_string(&amp;ss));</span>
<span class="line-added">2569           ss.reset();</span>
<span class="line-added">2570         }</span>
<span class="line-added">2571         out-&gt;cr();</span>
<span class="line-added">2572 </span>
<span class="line-added">2573         cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2574         if (cur == NULL) {</span>
<span class="line-added">2575           break;</span>
<span class="line-added">2576         }</span>
<span class="line-added">2577       }</span>
2578     }
2579   }
2580 
2581   out-&gt;flush();
2582 }
2583 
2584 // Log counts for the global and per-thread monitor lists and return
2585 // the population count.
2586 int ObjectSynchronizer::log_monitor_list_counts(outputStream * out) {
<span class="line-modified">2587   int pop_count = 0;</span>
2588   out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
2589                 &quot;Global Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Total&quot;);
2590   out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
<span class="line-modified">2591   int l_in_use_count = Atomic::load(&amp;om_list_globals._in_use_count);</span>
<span class="line-modified">2592   int l_free_count = Atomic::load(&amp;om_list_globals._free_count);</span>
<span class="line-modified">2593   out-&gt;print_cr(&quot;%18s  %10d  %10d  %10d&quot;, &quot;&quot;, l_in_use_count,</span>
<span class="line-added">2594                 l_free_count, Atomic::load(&amp;om_list_globals._population));</span>
<span class="line-added">2595   pop_count += l_in_use_count + l_free_count;</span>
2596 
2597   out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
2598                 &quot;Per-Thread Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Provision&quot;);
2599   out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
2600 
2601   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-added">2602     int l_om_in_use_count = Atomic::load(&amp;jt-&gt;om_in_use_count);</span>
<span class="line-added">2603     int l_om_free_count = Atomic::load(&amp;jt-&gt;om_free_count);</span>
2604     out-&gt;print_cr(INTPTR_FORMAT &quot;  %10d  %10d  %10d&quot;, p2i(jt),
<span class="line-modified">2605                   l_om_in_use_count, l_om_free_count, jt-&gt;om_free_provision);</span>
<span class="line-modified">2606     pop_count += l_om_in_use_count + l_om_free_count;</span>
2607   }
<span class="line-modified">2608   return pop_count;</span>
2609 }
2610 
2611 #ifndef PRODUCT
2612 
2613 // Check if monitor belongs to the monitor cache
2614 // The list is grow-only so it&#39;s *relatively* safe to traverse
2615 // the list of extant blocks without taking a lock.
2616 
2617 int ObjectSynchronizer::verify_objmon_isinpool(ObjectMonitor *monitor) {
<span class="line-modified">2618   PaddedObjectMonitor* block = Atomic::load(&amp;g_block_list);</span>
2619   while (block != NULL) {
2620     assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
2621     if (monitor &gt; &amp;block[0] &amp;&amp; monitor &lt; &amp;block[_BLOCKSIZE]) {
2622       address mon = (address)monitor;
2623       address blk = (address)block;
2624       size_t diff = mon - blk;
<span class="line-modified">2625       assert((diff % sizeof(PaddedObjectMonitor)) == 0, &quot;must be aligned&quot;);</span>
2626       return 1;
2627     }
<span class="line-modified">2628     // unmarked_next() is not needed with g_block_list (no locking</span>
<span class="line-added">2629     // used with block linkage _next_om fields).</span>
<span class="line-added">2630     block = (PaddedObjectMonitor*)block-&gt;next_om();</span>
2631   }
2632   return 0;
2633 }
2634 
2635 #endif
</pre>
</td>
</tr>
</table>
<center><a href="sweeper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
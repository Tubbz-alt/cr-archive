<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/interfaceSupport.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interfaceSupport.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="java.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/interfaceSupport.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,10 ***</span>
<span class="line-new-header">--- 32,11 ---</span>
  #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  #include &quot;runtime/safepointVerifiers.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-added">+ #include &quot;utilities/histogram.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/preserveException.hpp&quot;
  
  // Wrapper for all entry points to the virtual machine.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,30 ***</span>
    static void walk_stack_from(vframe* start_vf);
    static void walk_stack();
  
    static void zombieAll();
    static void deoptimizeAll();
<span class="line-removed">-   static void stress_derived_pointers();</span>
    static void verify_stack();
    static void verify_last_frame();
  # endif
<span class="line-removed">- </span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   static void serialize_thread_state_with_handler(JavaThread* thread) {</span>
<span class="line-removed">-     serialize_thread_state_internal(thread, true);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Should only call this if we know that we have a proper SEH set up.</span>
<span class="line-removed">-   static void serialize_thread_state(JavaThread* thread) {</span>
<span class="line-removed">-     serialize_thread_state_internal(thread, false);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   static void serialize_thread_state_internal(JavaThread* thread, bool needs_exception_handler) {</span>
<span class="line-removed">-     // Make sure new state is seen by VM thread</span>
<span class="line-removed">-     OrderAccess::fence();</span>
<span class="line-removed">-   }</span>
  };
  
  
  // Basic class for all thread transition classes.
  
<span class="line-new-header">--- 60,13 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,37 ***</span>
    static inline void transition(JavaThread *thread, JavaThreadState from, JavaThreadState to) {
      assert(from != _thread_in_Java, &quot;use transition_from_java&quot;);
      assert(from != _thread_in_native, &quot;use transition_from_native&quot;);
      assert((from &amp; 1) == 0 &amp;&amp; (to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
      assert(thread-&gt;thread_state() == from, &quot;coming from wrong thread state&quot;);
<span class="line-removed">-     // Change to transition state</span>
<span class="line-removed">-     thread-&gt;set_thread_state((JavaThreadState)(from + 1));</span>
  
<span class="line-modified">!     InterfaceSupport::serialize_thread_state(thread);</span>
  
<span class="line-modified">!     SafepointMechanism::block_if_requested(thread);</span>
<span class="line-modified">!     thread-&gt;set_thread_state(to);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // transition_and_fence must be used on any thread state transition</span>
<span class="line-removed">-   // where there might not be a Java call stub on the stack, in</span>
<span class="line-removed">-   // particular on Windows where the Structured Exception Handler is</span>
<span class="line-removed">-   // set up in the call stub.</span>
<span class="line-removed">-   static inline void transition_and_fence(JavaThread *thread, JavaThreadState from, JavaThreadState to) {</span>
<span class="line-removed">-     assert(thread-&gt;thread_state() == from, &quot;coming from wrong thread state&quot;);</span>
<span class="line-removed">-     assert((from &amp; 1) == 0 &amp;&amp; (to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);</span>
<span class="line-removed">-     // Change to transition state</span>
<span class="line-removed">-     thread-&gt;set_thread_state((JavaThreadState)(from + 1));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     InterfaceSupport::serialize_thread_state_with_handler(thread);</span>
  
      SafepointMechanism::block_if_requested(thread);
      thread-&gt;set_thread_state(to);
<span class="line-removed">- </span>
<span class="line-removed">-     CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
    }
  
    // Same as above, but assumes from = _thread_in_Java. This is simpler, since we
    // never block on entry to the VM. This will break the code, since e.g. preserve arguments
    // have not been setup.
<span class="line-new-header">--- 84,20 ---</span>
    static inline void transition(JavaThread *thread, JavaThreadState from, JavaThreadState to) {
      assert(from != _thread_in_Java, &quot;use transition_from_java&quot;);
      assert(from != _thread_in_native, &quot;use transition_from_native&quot;);
      assert((from &amp; 1) == 0 &amp;&amp; (to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
      assert(thread-&gt;thread_state() == from, &quot;coming from wrong thread state&quot;);
  
<span class="line-modified">!     // Check NoSafepointVerifier</span>
<span class="line-added">+     // This also clears unhandled oops if CheckUnhandledOops is used.</span>
<span class="line-added">+     thread-&gt;check_possible_safepoint();</span>
  
<span class="line-modified">!     // Change to transition state and ensure it is seen by the VM thread.</span>
<span class="line-modified">!     thread-&gt;set_thread_state_fence((JavaThreadState)(from + 1));</span>
  
      SafepointMechanism::block_if_requested(thread);
      thread-&gt;set_thread_state(to);
    }
  
    // Same as above, but assumes from = _thread_in_Java. This is simpler, since we
    // never block on entry to the VM. This will break the code, since e.g. preserve arguments
    // have not been setup.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,47 ***</span>
    }
  
    static inline void transition_from_native(JavaThread *thread, JavaThreadState to) {
      assert((to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
      assert(thread-&gt;thread_state() == _thread_in_native, &quot;coming from wrong thread state&quot;);
<span class="line-modified">!     // Change to transition state</span>
<span class="line-modified">!     thread-&gt;set_thread_state(_thread_in_native_trans);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     InterfaceSupport::serialize_thread_state_with_handler(thread);</span>
  
      // We never install asynchronous exceptions when coming (back) in
      // to the runtime from native code because the runtime is not set
      // up to handle exceptions floating around at arbitrary points.
      if (SafepointMechanism::should_block(thread) || thread-&gt;is_suspend_after_native()) {
        JavaThread::check_safepoint_and_suspend_for_native_trans(thread);
<span class="line-removed">- </span>
<span class="line-removed">-       // Clear unhandled oops anywhere where we could block, even if we don&#39;t.</span>
<span class="line-removed">-       CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
      }
  
      thread-&gt;set_thread_state(to);
    }
   protected:
     void trans(JavaThreadState from, JavaThreadState to)  { transition(_thread, from, to); }
     void trans_from_java(JavaThreadState to)              { transition_from_java(_thread, to); }
     void trans_from_native(JavaThreadState to)            { transition_from_native(_thread, to); }
<span class="line-removed">-    void trans_and_fence(JavaThreadState from, JavaThreadState to) { transition_and_fence(_thread, from, to); }</span>
  };
  
  class ThreadInVMForHandshake : public ThreadStateTransition {
    const JavaThreadState _original_state;
  
    void transition_back() {
      // This can be invoked from transition states and must return to the original state properly
      assert(_thread-&gt;thread_state() == _thread_in_vm, &quot;should only call when leaving VM after handshake&quot;);
<span class="line-modified">!     _thread-&gt;set_thread_state(_thread_in_vm_trans);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     InterfaceSupport::serialize_thread_state(_thread);</span>
  
      SafepointMechanism::block_if_requested(_thread);
  
      _thread-&gt;set_thread_state(_original_state);
    }
  
   public:
  
    ThreadInVMForHandshake(JavaThread* thread) : ThreadStateTransition(thread),
<span class="line-new-header">--- 107,46 ---</span>
    }
  
    static inline void transition_from_native(JavaThread *thread, JavaThreadState to) {
      assert((to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
      assert(thread-&gt;thread_state() == _thread_in_native, &quot;coming from wrong thread state&quot;);
<span class="line-modified">!     // Change to transition state and ensure it is seen by the VM thread.</span>
<span class="line-modified">!     thread-&gt;set_thread_state_fence(_thread_in_native_trans);</span>
  
      // We never install asynchronous exceptions when coming (back) in
      // to the runtime from native code because the runtime is not set
      // up to handle exceptions floating around at arbitrary points.
      if (SafepointMechanism::should_block(thread) || thread-&gt;is_suspend_after_native()) {
        JavaThread::check_safepoint_and_suspend_for_native_trans(thread);
      }
  
      thread-&gt;set_thread_state(to);
    }
   protected:
     void trans(JavaThreadState from, JavaThreadState to)  { transition(_thread, from, to); }
     void trans_from_java(JavaThreadState to)              { transition_from_java(_thread, to); }
     void trans_from_native(JavaThreadState to)            { transition_from_native(_thread, to); }
  };
  
  class ThreadInVMForHandshake : public ThreadStateTransition {
    const JavaThreadState _original_state;
  
    void transition_back() {
      // This can be invoked from transition states and must return to the original state properly
      assert(_thread-&gt;thread_state() == _thread_in_vm, &quot;should only call when leaving VM after handshake&quot;);
<span class="line-modified">!     // Change to transition state and ensure it is seen by the VM thread.</span>
<span class="line-modified">!     _thread-&gt;set_thread_state_fence(_thread_in_vm_trans);</span>
  
      SafepointMechanism::block_if_requested(_thread);
  
      _thread-&gt;set_thread_state(_original_state);
<span class="line-added">+ </span>
<span class="line-added">+     if (_original_state != _thread_blocked_trans &amp;&amp;  _original_state != _thread_in_vm_trans &amp;&amp;</span>
<span class="line-added">+         _thread-&gt;has_special_runtime_exit_condition()) {</span>
<span class="line-added">+       _thread-&gt;handle_special_runtime_exit_condition(</span>
<span class="line-added">+           !_thread-&gt;is_at_poll_safepoint() &amp;&amp; (_original_state != _thread_in_native_trans));</span>
<span class="line-added">+     }</span>
    }
  
   public:
  
    ThreadInVMForHandshake(JavaThread* thread) : ThreadStateTransition(thread),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,11 ***</span>
    }
  };
  
  
  class ThreadInVMfromUnknown {
<span class="line-removed">-  private:</span>
    JavaThread* _thread;
   public:
    ThreadInVMfromUnknown() : _thread(NULL) {
      Thread* t = Thread::current();
      if (t-&gt;is_Java_thread()) {
<span class="line-new-header">--- 180,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,11 ***</span>
        }
      }
    }
    ~ThreadInVMfromUnknown()  {
      if (_thread) {
<span class="line-modified">!       ThreadStateTransition::transition_and_fence(_thread, _thread_in_vm, _thread_in_native);</span>
      }
    }
  };
  
  
<span class="line-new-header">--- 198,11 ---</span>
        }
      }
    }
    ~ThreadInVMfromUnknown()  {
      if (_thread) {
<span class="line-modified">!       ThreadStateTransition::transition(_thread, _thread_in_vm, _thread_in_native);</span>
      }
    }
  };
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,11 ***</span>
   public:
    ThreadInVMfromNative(JavaThread* thread) : ThreadStateTransition(thread) {
      trans_from_native(_thread_in_vm);
    }
    ~ThreadInVMfromNative() {
<span class="line-modified">!     trans_and_fence(_thread_in_vm, _thread_in_native);</span>
    }
  };
  
  
  class ThreadToNativeFromVM : public ThreadStateTransition {
<span class="line-new-header">--- 210,11 ---</span>
   public:
    ThreadInVMfromNative(JavaThread* thread) : ThreadStateTransition(thread) {
      trans_from_native(_thread_in_vm);
    }
    ~ThreadInVMfromNative() {
<span class="line-modified">!     trans(_thread_in_vm, _thread_in_native);</span>
    }
  };
  
  
  class ThreadToNativeFromVM : public ThreadStateTransition {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,11 ***</span>
    ThreadToNativeFromVM(JavaThread *thread) : ThreadStateTransition(thread) {
      // We are leaving the VM at this point and going directly to native code.
      // Block, if we are in the middle of a safepoint synchronization.
      assert(!thread-&gt;owns_locks(), &quot;must release all locks when leaving VM&quot;);
      thread-&gt;frame_anchor()-&gt;make_walkable(thread);
<span class="line-modified">!     trans_and_fence(_thread_in_vm, _thread_in_native);</span>
      // Check for pending. async. exceptions or suspends.
      if (_thread-&gt;has_special_runtime_exit_condition()) _thread-&gt;handle_special_runtime_exit_condition(false);
    }
  
    ~ThreadToNativeFromVM() {
<span class="line-new-header">--- 222,11 ---</span>
    ThreadToNativeFromVM(JavaThread *thread) : ThreadStateTransition(thread) {
      // We are leaving the VM at this point and going directly to native code.
      // Block, if we are in the middle of a safepoint synchronization.
      assert(!thread-&gt;owns_locks(), &quot;must release all locks when leaving VM&quot;);
      thread-&gt;frame_anchor()-&gt;make_walkable(thread);
<span class="line-modified">!     trans(_thread_in_vm, _thread_in_native);</span>
      // Check for pending. async. exceptions or suspends.
      if (_thread-&gt;has_special_runtime_exit_condition()) _thread-&gt;handle_special_runtime_exit_condition(false);
    }
  
    ~ThreadToNativeFromVM() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 276,68 ***</span>
   public:
    ThreadBlockInVM(JavaThread *thread)
    : ThreadStateTransition(thread) {
      // Once we are blocked vm expects stack to be walkable
      thread-&gt;frame_anchor()-&gt;make_walkable(thread);
<span class="line-modified">!     trans_and_fence(_thread_in_vm, _thread_blocked);</span>
    }
    ~ThreadBlockInVM() {
<span class="line-modified">!     trans_and_fence(_thread_blocked, _thread_in_vm);</span>
      // We don&#39;t need to clear_walkable because it will happen automagically when we return to java
    }
  };
  
  // Unlike ThreadBlockInVM, this class is designed to avoid certain deadlock scenarios while making
<span class="line-modified">! // transitions inside class Monitor in cases where we need to block for a safepoint or handshake. It</span>
<span class="line-modified">! // receives an extra argument compared to ThreadBlockInVM, the address of a pointer to the monitor we</span>
<span class="line-modified">! // are trying to acquire. This will be used to access and release the monitor if needed to avoid</span>
  // said deadlocks.
  // It works like ThreadBlockInVM but differs from it in two ways:
  // - When transitioning in (constructor), it checks for safepoints without blocking, i.e., calls
  //   back if needed to allow a pending safepoint to continue but does not block in it.
  // - When transitioning back (destructor), if there is a pending safepoint or handshake it releases
<span class="line-modified">! //   the monitor that is only partially acquired.</span>
  class ThreadBlockInVMWithDeadlockCheck : public ThreadStateTransition {
   private:
<span class="line-modified">!   Monitor** _in_flight_monitor_adr;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   void release_monitor() {</span>
<span class="line-modified">!     assert(_in_flight_monitor_adr != NULL, &quot;_in_flight_monitor_adr should have been set on constructor&quot;);</span>
<span class="line-modified">!     Monitor* in_flight_monitor = *_in_flight_monitor_adr;</span>
<span class="line-modified">!     if (in_flight_monitor != NULL) {</span>
<span class="line-modified">!       in_flight_monitor-&gt;release_for_safepoint();</span>
<span class="line-modified">!       *_in_flight_monitor_adr = NULL;</span>
      }
    }
   public:
<span class="line-modified">!   ThreadBlockInVMWithDeadlockCheck(JavaThread* thread, Monitor** in_flight_monitor_adr)</span>
<span class="line-modified">!   : ThreadStateTransition(thread), _in_flight_monitor_adr(in_flight_monitor_adr) {</span>
      // Once we are blocked vm expects stack to be walkable
      thread-&gt;frame_anchor()-&gt;make_walkable(thread);
  
      // All unsafe states are treated the same by the VMThread
      // so we can skip the _thread_in_vm_trans state here. Since
      // we don&#39;t read poll, it&#39;s enough to order the stores.
      OrderAccess::storestore();
  
      thread-&gt;set_thread_state(_thread_blocked);
<span class="line-removed">- </span>
<span class="line-removed">-     CHECK_UNHANDLED_OOPS_ONLY(_thread-&gt;clear_unhandled_oops();)</span>
    }
    ~ThreadBlockInVMWithDeadlockCheck() {
<span class="line-modified">!     // Change to transition state</span>
<span class="line-modified">!     _thread-&gt;set_thread_state((JavaThreadState)(_thread_blocked_trans));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     InterfaceSupport::serialize_thread_state_with_handler(_thread);</span>
  
      if (SafepointMechanism::should_block(_thread)) {
<span class="line-modified">!       release_monitor();</span>
        SafepointMechanism::block_if_requested(_thread);
      }
  
      _thread-&gt;set_thread_state(_thread_in_vm);
<span class="line-modified">!     CHECK_UNHANDLED_OOPS_ONLY(_thread-&gt;clear_unhandled_oops();)</span>
    }
  };
  
  
  // This special transition class is only used to prevent asynchronous exceptions
<span class="line-new-header">--- 241,65 ---</span>
   public:
    ThreadBlockInVM(JavaThread *thread)
    : ThreadStateTransition(thread) {
      // Once we are blocked vm expects stack to be walkable
      thread-&gt;frame_anchor()-&gt;make_walkable(thread);
<span class="line-modified">!     trans(_thread_in_vm, _thread_blocked);</span>
    }
    ~ThreadBlockInVM() {
<span class="line-modified">!     trans(_thread_blocked, _thread_in_vm);</span>
<span class="line-added">+     OrderAccess::cross_modify_fence();</span>
      // We don&#39;t need to clear_walkable because it will happen automagically when we return to java
    }
  };
  
  // Unlike ThreadBlockInVM, this class is designed to avoid certain deadlock scenarios while making
<span class="line-modified">! // transitions inside class Mutex in cases where we need to block for a safepoint or handshake. It</span>
<span class="line-modified">! // receives an extra argument compared to ThreadBlockInVM, the address of a pointer to the mutex we</span>
<span class="line-modified">! // are trying to acquire. This will be used to access and release the mutex if needed to avoid</span>
  // said deadlocks.
  // It works like ThreadBlockInVM but differs from it in two ways:
  // - When transitioning in (constructor), it checks for safepoints without blocking, i.e., calls
  //   back if needed to allow a pending safepoint to continue but does not block in it.
  // - When transitioning back (destructor), if there is a pending safepoint or handshake it releases
<span class="line-modified">! //   the mutex that is only partially acquired.</span>
  class ThreadBlockInVMWithDeadlockCheck : public ThreadStateTransition {
   private:
<span class="line-modified">!   Mutex** _in_flight_mutex_addr;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   void release_mutex() {</span>
<span class="line-modified">!     assert(_in_flight_mutex_addr != NULL, &quot;_in_flight_mutex_addr should have been set on constructor&quot;);</span>
<span class="line-modified">!     Mutex* in_flight_mutex = *_in_flight_mutex_addr;</span>
<span class="line-modified">!     if (in_flight_mutex != NULL) {</span>
<span class="line-modified">!       in_flight_mutex-&gt;release_for_safepoint();</span>
<span class="line-modified">!       *_in_flight_mutex_addr = NULL;</span>
      }
    }
   public:
<span class="line-modified">!   ThreadBlockInVMWithDeadlockCheck(JavaThread* thread, Mutex** in_flight_mutex_addr)</span>
<span class="line-modified">!   : ThreadStateTransition(thread), _in_flight_mutex_addr(in_flight_mutex_addr) {</span>
      // Once we are blocked vm expects stack to be walkable
      thread-&gt;frame_anchor()-&gt;make_walkable(thread);
  
      // All unsafe states are treated the same by the VMThread
      // so we can skip the _thread_in_vm_trans state here. Since
      // we don&#39;t read poll, it&#39;s enough to order the stores.
      OrderAccess::storestore();
  
      thread-&gt;set_thread_state(_thread_blocked);
    }
    ~ThreadBlockInVMWithDeadlockCheck() {
<span class="line-modified">!     // Change to transition state and ensure it is seen by the VM thread.</span>
<span class="line-modified">!     _thread-&gt;set_thread_state_fence((JavaThreadState)(_thread_blocked_trans));</span>
  
      if (SafepointMechanism::should_block(_thread)) {
<span class="line-modified">!       release_mutex();</span>
        SafepointMechanism::block_if_requested(_thread);
      }
  
      _thread-&gt;set_thread_state(_thread_in_vm);
<span class="line-modified">!     OrderAccess::cross_modify_fence();</span>
    }
  };
  
  
  // This special transition class is only used to prevent asynchronous exceptions
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,11 ***</span>
      if (_thread-&gt;has_special_runtime_exit_condition())
        _thread-&gt;handle_special_runtime_exit_condition(false);
    }
  };
  
<span class="line-modified">! // Debug class instantiated in JRT_ENTRY and ITR_ENTRY macro.</span>
  // Can be used to verify properties on enter/exit of the VM.
  
  #ifdef ASSERT
  class VMEntryWrapper {
   public:
<span class="line-new-header">--- 327,11 ---</span>
      if (_thread-&gt;has_special_runtime_exit_condition())
        _thread-&gt;handle_special_runtime_exit_condition(false);
    }
  };
  
<span class="line-modified">! // Debug class instantiated in JRT_ENTRY macro.</span>
  // Can be used to verify properties on enter/exit of the VM.
  
  #ifdef ASSERT
  class VMEntryWrapper {
   public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,59 ***</span>
  };
  
  
  class VMNativeEntryWrapper {
   public:
<span class="line-modified">!   VMNativeEntryWrapper() {</span>
<span class="line-modified">!     if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ~VMNativeEntryWrapper() {</span>
<span class="line-removed">-     if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- // VM-internal runtime interface support</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Definitions for JRT (Java (Compiler/Shared) Runtime)</span>
<span class="line-removed">- </span>
<span class="line-removed">- // JRT_LEAF currently can be called from either _thread_in_Java or</span>
<span class="line-removed">- // _thread_in_native mode. In _thread_in_native, it is ok</span>
<span class="line-removed">- // for another thread to trigger GC. The rest of the JRT_LEAF</span>
<span class="line-removed">- // rules apply.</span>
<span class="line-removed">- class JRTLeafVerifier : public NoSafepointVerifier {</span>
<span class="line-removed">-   static bool should_verify_GC();</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   JRTLeafVerifier();</span>
<span class="line-removed">-   ~JRTLeafVerifier();</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-   JRTLeafVerifier() {}</span>
<span class="line-removed">-   ~JRTLeafVerifier() {}</span>
<span class="line-removed">- #endif</span>
  };
  
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">- </span>
  class RuntimeHistogramElement : public HistogramElement {
    public:
     RuntimeHistogramElement(const char* name);
  };
  
  #define TRACE_CALL(result_type, header)                            \
    InterfaceSupport::_number_of_calls++;                            \
    if (CountRuntimeCalls) {                                         \
      static RuntimeHistogramElement* e = new RuntimeHistogramElement(#header); \
      if (e != NULL) e-&gt;increment_count();                           \
    }
  #else
  #define TRACE_CALL(result_type, header)                            \
    /* do nothing */
<span class="line-modified">! #endif</span>
  
  
  // LEAF routines do not lock, GC or throw exceptions
  
  #define VM_LEAF_BASE(result_type, header)                            \
<span class="line-new-header">--- 340,31 ---</span>
  };
  
  
  class VMNativeEntryWrapper {
   public:
<span class="line-modified">!   VMNativeEntryWrapper();</span>
<span class="line-modified">!   ~VMNativeEntryWrapper();</span>
  };
  
  class RuntimeHistogramElement : public HistogramElement {
    public:
     RuntimeHistogramElement(const char* name);
  };
<span class="line-added">+ #endif // ASSERT</span>
  
<span class="line-added">+ #ifdef ASSERT</span>
  #define TRACE_CALL(result_type, header)                            \
    InterfaceSupport::_number_of_calls++;                            \
    if (CountRuntimeCalls) {                                         \
      static RuntimeHistogramElement* e = new RuntimeHistogramElement(#header); \
      if (e != NULL) e-&gt;increment_count();                           \
    }
  #else
  #define TRACE_CALL(result_type, header)                            \
    /* do nothing */
<span class="line-modified">! #endif // ASSERT</span>
  
  
  // LEAF routines do not lock, GC or throw exceptions
  
  #define VM_LEAF_BASE(result_type, header)                            \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 456,55 ***</span>
    Thread* THREAD = thread;                                           \
    os::verify_stack_alignment();                                      \
    /* begin of body */
  
  
<span class="line-removed">- // QUICK_ENTRY routines behave like ENTRY but without a handle mark</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define VM_QUICK_ENTRY_BASE(result_type, header, thread)             \</span>
<span class="line-removed">-   TRACE_CALL(result_type, header)                                    \</span>
<span class="line-removed">-   debug_only(NoHandleMark __hm;)                                     \</span>
<span class="line-removed">-   Thread* THREAD = thread;                                           \</span>
<span class="line-removed">-   os::verify_stack_alignment();                                      \</span>
<span class="line-removed">-   /* begin of body */</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- // Definitions for IRT (Interpreter Runtime)</span>
<span class="line-removed">- // (thread is an argument passed in to all these routines)</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define IRT_ENTRY(result_type, header)                               \</span>
<span class="line-removed">-   result_type header {                                               \</span>
<span class="line-removed">-     ThreadInVMfromJava __tiv(thread);                                \</span>
<span class="line-removed">-     VM_ENTRY_BASE(result_type, header, thread)                       \</span>
<span class="line-removed">-     debug_only(VMEntryWrapper __vew;)</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- #define IRT_LEAF(result_type, header)                                \</span>
<span class="line-removed">-   result_type header {                                               \</span>
<span class="line-removed">-     VM_LEAF_BASE(result_type, header)                                \</span>
<span class="line-removed">-     debug_only(NoSafepointVerifier __nspv(true);)</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- #define IRT_ENTRY_NO_ASYNC(result_type, header)                      \</span>
<span class="line-removed">-   result_type header {                                               \</span>
<span class="line-removed">-     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \</span>
<span class="line-removed">-     VM_ENTRY_BASE(result_type, header, thread)                       \</span>
<span class="line-removed">-     debug_only(VMEntryWrapper __vew;)</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define IRT_END }</span>
<span class="line-removed">- </span>
  #define JRT_ENTRY(result_type, header)                               \
    result_type header {                                               \
      ThreadInVMfromJava __tiv(thread);                                \
      VM_ENTRY_BASE(result_type, header, thread)                       \
      debug_only(VMEntryWrapper __vew;)
  
  
  #define JRT_LEAF(result_type, header)                                \
    result_type header {                                               \
    VM_LEAF_BASE(result_type, header)                                  \
<span class="line-modified">!   debug_only(JRTLeafVerifier __jlv;)</span>
  
  
  #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
    result_type header {                                               \
      ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
<span class="line-new-header">--- 390,34 ---</span>
    Thread* THREAD = thread;                                           \
    os::verify_stack_alignment();                                      \
    /* begin of body */
  
  
  #define JRT_ENTRY(result_type, header)                               \
    result_type header {                                               \
      ThreadInVMfromJava __tiv(thread);                                \
      VM_ENTRY_BASE(result_type, header, thread)                       \
      debug_only(VMEntryWrapper __vew;)
  
<span class="line-added">+ // JRT_LEAF currently can be called from either _thread_in_Java or</span>
<span class="line-added">+ // _thread_in_native mode.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // JRT_LEAF rules:</span>
<span class="line-added">+ // A JRT_LEAF method may not interfere with safepointing by</span>
<span class="line-added">+ //   1) acquiring or blocking on a Mutex or JavaLock - checked</span>
<span class="line-added">+ //   2) allocating heap memory - checked</span>
<span class="line-added">+ //   3) executing a VM operation - checked</span>
<span class="line-added">+ //   4) executing a system call (including malloc) that could block or grab a lock</span>
<span class="line-added">+ //   5) invoking GC</span>
<span class="line-added">+ //   6) reaching a safepoint</span>
<span class="line-added">+ //   7) running too long</span>
<span class="line-added">+ // Nor may any method it calls.</span>
  
  #define JRT_LEAF(result_type, header)                                \
    result_type header {                                               \
    VM_LEAF_BASE(result_type, header)                                  \
<span class="line-modified">!   debug_only(NoSafepointVerifier __nsv;)</span>
  
  
  #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
    result_type header {                                               \
      ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,22 ***</span>
      ThreadInVMfromNative __tiv(thread);                              \
      debug_only(VMNativeEntryWrapper __vew;)                          \
      VM_ENTRY_BASE(result_type, header, thread)
  
  
<span class="line-removed">- // Ensure that the VMNativeEntryWrapper constructor, which can cause</span>
<span class="line-removed">- // a GC, is called outside the NoHandleMark (set via VM_QUICK_ENTRY_BASE).</span>
<span class="line-removed">- #define JNI_QUICK_ENTRY(result_type, header)                         \</span>
<span class="line-removed">- extern &quot;C&quot; {                                                         \</span>
<span class="line-removed">-   result_type JNICALL header {                                       \</span>
<span class="line-removed">-     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \</span>
<span class="line-removed">-     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \</span>
<span class="line-removed">-     ThreadInVMfromNative __tiv(thread);                              \</span>
<span class="line-removed">-     debug_only(VMNativeEntryWrapper __vew;)                          \</span>
<span class="line-removed">-     VM_QUICK_ENTRY_BASE(result_type, header, thread)</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  #define JNI_LEAF(result_type, header)                                \
  extern &quot;C&quot; {                                                         \
    result_type JNICALL header {                                       \
      JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
      assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \
<span class="line-new-header">--- 461,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 593,19 ***</span>
      ThreadInVMfromNative __tiv(thread);                              \
      debug_only(VMNativeEntryWrapper __vew;)                          \
      VM_ENTRY_BASE(result_type, header, thread)
  
  
<span class="line-removed">- #define JVM_QUICK_ENTRY(result_type, header)                         \</span>
<span class="line-removed">- extern &quot;C&quot; {                                                         \</span>
<span class="line-removed">-   result_type JNICALL header {                                       \</span>
<span class="line-removed">-     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \</span>
<span class="line-removed">-     ThreadInVMfromNative __tiv(thread);                              \</span>
<span class="line-removed">-     debug_only(VMNativeEntryWrapper __vew;)                          \</span>
<span class="line-removed">-     VM_QUICK_ENTRY_BASE(result_type, header, thread)</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  #define JVM_LEAF(result_type, header)                                \
  extern &quot;C&quot; {                                                         \
    result_type JNICALL header {                                       \
      VM_Exit::block_if_vm_exited();                                   \
      VM_LEAF_BASE(result_type, header)
<span class="line-new-header">--- 494,10 ---</span>
</pre>
<center><a href="interfaceSupport.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="java.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/vmOperations.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vframe_hp.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/vmOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;compiler/compileBroker.hpp&quot;

 30 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;logging/logStream.hpp&quot;

 33 #include &quot;memory/heapInspection.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;

 35 #include &quot;oops/symbol.hpp&quot;
 36 #include &quot;runtime/arguments.hpp&quot;
 37 #include &quot;runtime/deoptimization.hpp&quot;
 38 #include &quot;runtime/frame.inline.hpp&quot;
 39 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 40 #include &quot;runtime/sweeper.hpp&quot;
 41 #include &quot;runtime/thread.inline.hpp&quot;
 42 #include &quot;runtime/threadSMR.inline.hpp&quot;
 43 #include &quot;runtime/vmOperations.hpp&quot;
 44 #include &quot;services/threadService.hpp&quot;
 45 
 46 #define VM_OP_NAME_INITIALIZE(name) #name,
 47 
 48 const char* VM_Operation::_names[VM_Operation::VMOp_Terminating] = \
 49   { VM_OPS_DO(VM_OP_NAME_INITIALIZE) };
 50 
<span class="line-modified"> 51 void VM_Operation::set_calling_thread(Thread* thread, ThreadPriority priority) {</span>
 52   _calling_thread = thread;
<span class="line-removed"> 53   assert(MinPriority &lt;= priority &amp;&amp; priority &lt;= MaxPriority, &quot;sanity check&quot;);</span>
<span class="line-removed"> 54   _priority = priority;</span>
 55 }
 56 
<span class="line-removed"> 57 </span>
 58 void VM_Operation::evaluate() {
 59   ResourceMark rm;
 60   LogTarget(Debug, vmoperation) lt;
 61   if (lt.is_enabled()) {
 62     LogStream ls(lt);
 63     ls.print(&quot;begin &quot;);
 64     print_on_error(&amp;ls);
 65     ls.cr();
 66   }
 67   doit();
 68   if (lt.is_enabled()) {
 69     LogStream ls(lt);
 70     ls.print(&quot;end &quot;);
 71     print_on_error(&amp;ls);
 72     ls.cr();
 73   }
 74 }
 75 
<span class="line-removed"> 76 const char* VM_Operation::mode_to_string(Mode mode) {</span>
<span class="line-removed"> 77   switch(mode) {</span>
<span class="line-removed"> 78     case _safepoint      : return &quot;safepoint&quot;;</span>
<span class="line-removed"> 79     case _no_safepoint   : return &quot;no safepoint&quot;;</span>
<span class="line-removed"> 80     case _concurrent     : return &quot;concurrent&quot;;</span>
<span class="line-removed"> 81     case _async_safepoint: return &quot;async safepoint&quot;;</span>
<span class="line-removed"> 82     default              : return &quot;unknown&quot;;</span>
<span class="line-removed"> 83   }</span>
<span class="line-removed"> 84 }</span>
 85 // Called by fatal error handler.
 86 void VM_Operation::print_on_error(outputStream* st) const {
 87   st-&gt;print(&quot;VM_Operation (&quot; PTR_FORMAT &quot;): &quot;, p2i(this));
 88   st-&gt;print(&quot;%s&quot;, name());
 89 
<span class="line-modified"> 90   const char* mode = mode_to_string(evaluation_mode());</span>
<span class="line-removed"> 91   st-&gt;print(&quot;, mode: %s&quot;, mode);</span>
 92 
 93   if (calling_thread()) {
 94     st-&gt;print(&quot;, requested by thread &quot; PTR_FORMAT, p2i(calling_thread()));
 95   }
 96 }
 97 
<span class="line-removed"> 98 void VM_ThreadStop::doit() {</span>
<span class="line-removed"> 99   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at a safepoint&quot;);</span>
<span class="line-removed">100   ThreadsListHandle tlh;</span>
<span class="line-removed">101   JavaThread* target = java_lang_Thread::thread(target_thread());</span>
<span class="line-removed">102   // Note that this now allows multiple ThreadDeath exceptions to be</span>
<span class="line-removed">103   // thrown at a thread.</span>
<span class="line-removed">104   if (target != NULL &amp;&amp; (!EnableThreadSMRExtraValidityChecks || tlh.includes(target))) {</span>
<span class="line-removed">105     // The target thread has run and has not exited yet.</span>
<span class="line-removed">106     target-&gt;send_thread_stop(throwable());</span>
<span class="line-removed">107   }</span>
<span class="line-removed">108 }</span>
<span class="line-removed">109 </span>
110 void VM_ClearICs::doit() {
111   if (_preserve_static_stubs) {
112     CodeCache::cleanup_inline_caches();
113   } else {
114     CodeCache::clear_inline_caches();
115   }
116 }
117 
<span class="line-removed">118 void VM_Deoptimize::doit() {</span>
<span class="line-removed">119   // We do not want any GCs to happen while we are in the middle of this VM operation</span>
<span class="line-removed">120   ResourceMark rm;</span>
<span class="line-removed">121   DeoptimizationMarker dm;</span>
<span class="line-removed">122 </span>
<span class="line-removed">123   // Deoptimize all activations depending on marked nmethods</span>
<span class="line-removed">124   Deoptimization::deoptimize_dependents();</span>
<span class="line-removed">125 </span>
<span class="line-removed">126   // Make the dependent methods not entrant</span>
<span class="line-removed">127   CodeCache::make_marked_nmethods_not_entrant();</span>
<span class="line-removed">128 }</span>
<span class="line-removed">129 </span>
130 void VM_MarkActiveNMethods::doit() {
131   NMethodSweeper::mark_active_nmethods();
132 }
133 
134 VM_DeoptimizeFrame::VM_DeoptimizeFrame(JavaThread* thread, intptr_t* id, int reason) {
135   _thread = thread;
136   _id     = id;
137   _reason = reason;
138 }
139 
140 
141 void VM_DeoptimizeFrame::doit() {
142   assert(_reason &gt; Deoptimization::Reason_none &amp;&amp; _reason &lt; Deoptimization::Reason_LIMIT, &quot;invalid deopt reason&quot;);
143   Deoptimization::deoptimize_frame_internal(_thread, _id, (Deoptimization::DeoptReason)_reason);
144 }
145 
146 
147 #ifndef PRODUCT
148 
149 void VM_DeoptimizeAll::doit() {
</pre>
<hr />
<pre>
151   JavaThreadIteratorWithHandle jtiwh;
152   // deoptimize all java threads in the system
153   if (DeoptimizeALot) {
154     for (; JavaThread *thread = jtiwh.next(); ) {
155       if (thread-&gt;has_last_Java_frame()) {
156         thread-&gt;deoptimize();
157       }
158     }
159   } else if (DeoptimizeRandom) {
160 
161     // Deoptimize some selected threads and frames
162     int tnum = os::random() &amp; 0x3;
163     int fnum =  os::random() &amp; 0x3;
164     int tcount = 0;
165     for (; JavaThread *thread = jtiwh.next(); ) {
166       if (thread-&gt;has_last_Java_frame()) {
167         if (tcount++ == tnum)  {
168         tcount = 0;
169           int fcount = 0;
170           // Deoptimize some selected frames.
<span class="line-modified">171           // Biased llocking wants a updated register map</span>
<span class="line-removed">172           for(StackFrameStream fst(thread, UseBiasedLocking); !fst.is_done(); fst.next()) {</span>
173             if (fst.current()-&gt;can_be_deoptimized()) {
174               if (fcount++ == fnum) {
175                 fcount = 0;
<span class="line-modified">176                 Deoptimization::deoptimize(thread, *fst.current(), fst.register_map());</span>
177               }
178             }
179           }
180         }
181       }
182     }
183   }
184 }
185 
186 
187 void VM_ZombieAll::doit() {
188   JavaThread *thread = (JavaThread *)calling_thread();
189   assert(thread-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
190   thread-&gt;make_zombies();
191 }
192 
193 #endif // !PRODUCT
194 
195 void VM_Verify::doit() {
196   Universe::heap()-&gt;prepare_for_verify();
</pre>
<hr />
<pre>
418   // data, and they will be stopped during state transition. In theory, we
419   // don&#39;t have to wait for user threads to be quiescent, but it&#39;s always
420   // better to terminate VM when current thread is the only active thread, so
421   // wait for user threads too. Numbers are in 10 milliseconds.
422   int max_wait_user_thread = 30;                  // at least 300 milliseconds
423   int max_wait_compiler_thread = 1000;            // at least 10 seconds
424 
425   int max_wait = max_wait_compiler_thread;
426 
427   int attempts = 0;
428   JavaThreadIteratorWithHandle jtiwh;
429   while (true) {
430     int num_active = 0;
431     int num_active_compiler_thread = 0;
432 
433     jtiwh.rewind();
434     for (; JavaThread *thr = jtiwh.next(); ) {
435       if (thr!=thr_cur &amp;&amp; thr-&gt;thread_state() == _thread_in_native) {
436         num_active++;
437         if (thr-&gt;is_Compiler_thread()) {












438           num_active_compiler_thread++;

439         }
440       }
441     }
442 
443     if (num_active == 0) {
444        return 0;
445     } else if (attempts &gt; max_wait) {
446        return num_active;
447     } else if (num_active_compiler_thread == 0 &amp;&amp; attempts &gt; max_wait_user_thread) {
448        return num_active;
449     }
450 
451     attempts++;
452 
<span class="line-modified">453     MutexLockerEx ml(&amp;timer, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">454     timer.wait(Mutex::_no_safepoint_check_flag, 10);</span>
455   }
456 }
457 
458 void VM_Exit::doit() {










459   CompileBroker::set_should_block();
460 
461   // Wait for a short period for threads in native to block. Any thread
462   // still executing native code after the wait will be stopped at
463   // native==&gt;Java/VM barriers.
464   // Among 16276 JCK tests, 94% of them come here without any threads still
465   // running in native; the other 6% are quiescent within 250ms (Ultra 80).
466   wait_for_threads_in_native_to_block();
467 
468   set_vm_exited();
469 





470   // cleanup globals resources before exiting. exit_globals() currently
471   // cleans up outputStream resources and PerfMemory resources.
472   exit_globals();
473 


474   // Check for exit hook
475   exit_hook_t exit_hook = Arguments::exit_hook();
476   if (exit_hook != NULL) {
477     // exit hook should exit.
478     exit_hook(_exit_code);
479     // ... but if it didn&#39;t, we must do it here
480     vm_direct_exit(_exit_code);
481   } else {
482     vm_direct_exit(_exit_code);
483   }
484 }
485 
486 
487 void VM_Exit::wait_if_vm_exited() {
488   if (_vm_exited &amp;&amp;
489       Thread::current_or_null() != _shutdown_thread) {
490     // _vm_exited is set at safepoint, and the Threads_lock is never released
491     // we will block here until the process dies
<span class="line-modified">492     Threads_lock-&gt;lock_without_safepoint_check();</span>
493     ShouldNotReachHere();
494   }
495 }
496 
497 void VM_PrintCompileQueue::doit() {
498   CompileBroker::print_compile_queues(_out);
499 }
500 
501 #if INCLUDE_SERVICES
502 void VM_PrintClassHierarchy::doit() {
503   KlassHierarchy::print_class_hierarchy(_out, _print_interfaces, _print_subclasses, _classname);
504 }
505 #endif
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/shared/collectedHeap.hpp&quot;</span>
 31 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
 33 #include &quot;logging/logStream.hpp&quot;
<span class="line-added"> 34 #include &quot;logging/logConfiguration.hpp&quot;</span>
 35 #include &quot;memory/heapInspection.hpp&quot;
 36 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 37 #include &quot;memory/universe.hpp&quot;</span>
 38 #include &quot;oops/symbol.hpp&quot;
 39 #include &quot;runtime/arguments.hpp&quot;
 40 #include &quot;runtime/deoptimization.hpp&quot;
 41 #include &quot;runtime/frame.inline.hpp&quot;
 42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 43 #include &quot;runtime/sweeper.hpp&quot;
 44 #include &quot;runtime/thread.inline.hpp&quot;
 45 #include &quot;runtime/threadSMR.inline.hpp&quot;
 46 #include &quot;runtime/vmOperations.hpp&quot;
 47 #include &quot;services/threadService.hpp&quot;
 48 
 49 #define VM_OP_NAME_INITIALIZE(name) #name,
 50 
 51 const char* VM_Operation::_names[VM_Operation::VMOp_Terminating] = \
 52   { VM_OPS_DO(VM_OP_NAME_INITIALIZE) };
 53 
<span class="line-modified"> 54 void VM_Operation::set_calling_thread(Thread* thread) {</span>
 55   _calling_thread = thread;


 56 }
 57 

 58 void VM_Operation::evaluate() {
 59   ResourceMark rm;
 60   LogTarget(Debug, vmoperation) lt;
 61   if (lt.is_enabled()) {
 62     LogStream ls(lt);
 63     ls.print(&quot;begin &quot;);
 64     print_on_error(&amp;ls);
 65     ls.cr();
 66   }
 67   doit();
 68   if (lt.is_enabled()) {
 69     LogStream ls(lt);
 70     ls.print(&quot;end &quot;);
 71     print_on_error(&amp;ls);
 72     ls.cr();
 73   }
 74 }
 75 









 76 // Called by fatal error handler.
 77 void VM_Operation::print_on_error(outputStream* st) const {
 78   st-&gt;print(&quot;VM_Operation (&quot; PTR_FORMAT &quot;): &quot;, p2i(this));
 79   st-&gt;print(&quot;%s&quot;, name());
 80 
<span class="line-modified"> 81   st-&gt;print(&quot;, mode: %s&quot;, evaluate_at_safepoint() ? &quot;safepoint&quot; : &quot;no safepoint&quot;);</span>

 82 
 83   if (calling_thread()) {
 84     st-&gt;print(&quot;, requested by thread &quot; PTR_FORMAT, p2i(calling_thread()));
 85   }
 86 }
 87 












 88 void VM_ClearICs::doit() {
 89   if (_preserve_static_stubs) {
 90     CodeCache::cleanup_inline_caches();
 91   } else {
 92     CodeCache::clear_inline_caches();
 93   }
 94 }
 95 












 96 void VM_MarkActiveNMethods::doit() {
 97   NMethodSweeper::mark_active_nmethods();
 98 }
 99 
100 VM_DeoptimizeFrame::VM_DeoptimizeFrame(JavaThread* thread, intptr_t* id, int reason) {
101   _thread = thread;
102   _id     = id;
103   _reason = reason;
104 }
105 
106 
107 void VM_DeoptimizeFrame::doit() {
108   assert(_reason &gt; Deoptimization::Reason_none &amp;&amp; _reason &lt; Deoptimization::Reason_LIMIT, &quot;invalid deopt reason&quot;);
109   Deoptimization::deoptimize_frame_internal(_thread, _id, (Deoptimization::DeoptReason)_reason);
110 }
111 
112 
113 #ifndef PRODUCT
114 
115 void VM_DeoptimizeAll::doit() {
</pre>
<hr />
<pre>
117   JavaThreadIteratorWithHandle jtiwh;
118   // deoptimize all java threads in the system
119   if (DeoptimizeALot) {
120     for (; JavaThread *thread = jtiwh.next(); ) {
121       if (thread-&gt;has_last_Java_frame()) {
122         thread-&gt;deoptimize();
123       }
124     }
125   } else if (DeoptimizeRandom) {
126 
127     // Deoptimize some selected threads and frames
128     int tnum = os::random() &amp; 0x3;
129     int fnum =  os::random() &amp; 0x3;
130     int tcount = 0;
131     for (; JavaThread *thread = jtiwh.next(); ) {
132       if (thread-&gt;has_last_Java_frame()) {
133         if (tcount++ == tnum)  {
134         tcount = 0;
135           int fcount = 0;
136           // Deoptimize some selected frames.
<span class="line-modified">137           for(StackFrameStream fst(thread, false); !fst.is_done(); fst.next()) {</span>

138             if (fst.current()-&gt;can_be_deoptimized()) {
139               if (fcount++ == fnum) {
140                 fcount = 0;
<span class="line-modified">141                 Deoptimization::deoptimize(thread, *fst.current());</span>
142               }
143             }
144           }
145         }
146       }
147     }
148   }
149 }
150 
151 
152 void VM_ZombieAll::doit() {
153   JavaThread *thread = (JavaThread *)calling_thread();
154   assert(thread-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
155   thread-&gt;make_zombies();
156 }
157 
158 #endif // !PRODUCT
159 
160 void VM_Verify::doit() {
161   Universe::heap()-&gt;prepare_for_verify();
</pre>
<hr />
<pre>
383   // data, and they will be stopped during state transition. In theory, we
384   // don&#39;t have to wait for user threads to be quiescent, but it&#39;s always
385   // better to terminate VM when current thread is the only active thread, so
386   // wait for user threads too. Numbers are in 10 milliseconds.
387   int max_wait_user_thread = 30;                  // at least 300 milliseconds
388   int max_wait_compiler_thread = 1000;            // at least 10 seconds
389 
390   int max_wait = max_wait_compiler_thread;
391 
392   int attempts = 0;
393   JavaThreadIteratorWithHandle jtiwh;
394   while (true) {
395     int num_active = 0;
396     int num_active_compiler_thread = 0;
397 
398     jtiwh.rewind();
399     for (; JavaThread *thr = jtiwh.next(); ) {
400       if (thr!=thr_cur &amp;&amp; thr-&gt;thread_state() == _thread_in_native) {
401         num_active++;
402         if (thr-&gt;is_Compiler_thread()) {
<span class="line-added">403 #if INCLUDE_JVMCI</span>
<span class="line-added">404           CompilerThread* ct = (CompilerThread*) thr;</span>
<span class="line-added">405           if (ct-&gt;compiler() == NULL || !ct-&gt;compiler()-&gt;is_jvmci()) {</span>
<span class="line-added">406             num_active_compiler_thread++;</span>
<span class="line-added">407           } else {</span>
<span class="line-added">408             // A JVMCI compiler thread never accesses VM data structures</span>
<span class="line-added">409             // while in _thread_in_native state so there&#39;s no need to wait</span>
<span class="line-added">410             // for it and potentially add a 300 millisecond delay to VM</span>
<span class="line-added">411             // shutdown.</span>
<span class="line-added">412             num_active--;</span>
<span class="line-added">413           }</span>
<span class="line-added">414 #else</span>
415           num_active_compiler_thread++;
<span class="line-added">416 #endif</span>
417         }
418       }
419     }
420 
421     if (num_active == 0) {
422        return 0;
423     } else if (attempts &gt; max_wait) {
424        return num_active;
425     } else if (num_active_compiler_thread == 0 &amp;&amp; attempts &gt; max_wait_user_thread) {
426        return num_active;
427     }
428 
429     attempts++;
430 
<span class="line-modified">431     MonitorLocker ml(&amp;timer, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">432     ml.wait(10);</span>
433   }
434 }
435 
436 void VM_Exit::doit() {
<span class="line-added">437 </span>
<span class="line-added">438   if (VerifyBeforeExit) {</span>
<span class="line-added">439     HandleMark hm(VMThread::vm_thread());</span>
<span class="line-added">440     // Among other things, this ensures that Eden top is correct.</span>
<span class="line-added">441     Universe::heap()-&gt;prepare_for_verify();</span>
<span class="line-added">442     // Silent verification so as not to pollute normal output,</span>
<span class="line-added">443     // unless we really asked for it.</span>
<span class="line-added">444     Universe::verify();</span>
<span class="line-added">445   }</span>
<span class="line-added">446 </span>
447   CompileBroker::set_should_block();
448 
449   // Wait for a short period for threads in native to block. Any thread
450   // still executing native code after the wait will be stopped at
451   // native==&gt;Java/VM barriers.
452   // Among 16276 JCK tests, 94% of them come here without any threads still
453   // running in native; the other 6% are quiescent within 250ms (Ultra 80).
454   wait_for_threads_in_native_to_block();
455 
456   set_vm_exited();
457 
<span class="line-added">458   // We&#39;d like to call IdealGraphPrinter::clean_up() to finalize the</span>
<span class="line-added">459   // XML logging, but we can&#39;t safely do that here. The logic to make</span>
<span class="line-added">460   // XML termination logging safe is tied to the termination of the</span>
<span class="line-added">461   // VMThread, and it doesn&#39;t terminate on this exit path. See 8222534.</span>
<span class="line-added">462 </span>
463   // cleanup globals resources before exiting. exit_globals() currently
464   // cleans up outputStream resources and PerfMemory resources.
465   exit_globals();
466 
<span class="line-added">467   LogConfiguration::finalize();</span>
<span class="line-added">468 </span>
469   // Check for exit hook
470   exit_hook_t exit_hook = Arguments::exit_hook();
471   if (exit_hook != NULL) {
472     // exit hook should exit.
473     exit_hook(_exit_code);
474     // ... but if it didn&#39;t, we must do it here
475     vm_direct_exit(_exit_code);
476   } else {
477     vm_direct_exit(_exit_code);
478   }
479 }
480 
481 
482 void VM_Exit::wait_if_vm_exited() {
483   if (_vm_exited &amp;&amp;
484       Thread::current_or_null() != _shutdown_thread) {
485     // _vm_exited is set at safepoint, and the Threads_lock is never released
486     // we will block here until the process dies
<span class="line-modified">487     Threads_lock-&gt;lock();</span>
488     ShouldNotReachHere();
489   }
490 }
491 
492 void VM_PrintCompileQueue::doit() {
493   CompileBroker::print_compile_queues(_out);
494 }
495 
496 #if INCLUDE_SERVICES
497 void VM_PrintClassHierarchy::doit() {
498   KlassHierarchy::print_class_hierarchy(_out, _print_interfaces, _print_subclasses, _classname);
499 }
500 #endif
</pre>
</td>
</tr>
</table>
<center><a href="vframe_hp.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
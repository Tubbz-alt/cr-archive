<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/javaCalls.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="java.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniHandles.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/javaCalls.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;code/nmethod.hpp&quot;

 29 #include &quot;compiler/compileBroker.hpp&quot;
 30 #include &quot;interpreter/interpreter.hpp&quot;
 31 #include &quot;interpreter/linkResolver.hpp&quot;
 32 #include &quot;memory/universe.hpp&quot;
 33 #include &quot;oops/method.inline.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;prims/jniCheck.hpp&quot;
<span class="line-removed"> 36 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 39 #include &quot;runtime/javaCalls.hpp&quot;
 40 #include &quot;runtime/jniHandles.inline.hpp&quot;
 41 #include &quot;runtime/mutexLocker.hpp&quot;
 42 #include &quot;runtime/os.inline.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;runtime/signature.hpp&quot;
 45 #include &quot;runtime/stubRoutines.hpp&quot;
 46 #include &quot;runtime/thread.inline.hpp&quot;
<span class="line-removed"> 47 #if INCLUDE_JVMCI</span>
<span class="line-removed"> 48 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
<span class="line-removed"> 49 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
<span class="line-removed"> 50 #endif</span>
 51 
 52 // -----------------------------------------------------
 53 // Implementation of JavaCallWrapper
 54 
 55 JavaCallWrapper::JavaCallWrapper(const methodHandle&amp; callee_method, Handle receiver, JavaValue* result, TRAPS) {
 56   JavaThread* thread = (JavaThread *)THREAD;
 57   bool clear_pending_exception = true;
 58 
 59   guarantee(thread-&gt;is_Java_thread(), &quot;crucial check - the VM thread cannot and must not escape to Java code&quot;);
 60   assert(!thread-&gt;owns_locks(), &quot;must release all locks when leaving VM&quot;);
 61   guarantee(thread-&gt;can_call_java(), &quot;cannot make java calls from the native compiler&quot;);
 62   _result   = result;
 63 
 64   // Allocate handle block for Java code. This must be done before we change thread_state to _thread_in_Java_or_stub,
 65   // since it can potentially block.
 66   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 67 
 68   // After this, we are official in JavaCode. This needs to be done before we change any of the thread local
 69   // info, since we cannot find oops before the new information is set up completely.
 70   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_Java);
</pre>
<hr />
<pre>
173     case T_DOUBLE : return T_DOUBLE;
174 #ifdef _LP64
175     case T_ARRAY  : // fall through
176     case T_OBJECT:  return T_OBJECT;
177 #endif
178     default:
179       ShouldNotReachHere();
180       return T_ILLEGAL;
181   }
182 }
183 
184 // ============ Virtual calls ============
185 
186 void JavaCalls::call_virtual(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
187   CallInfo callinfo;
188   Handle receiver = args-&gt;receiver();
189   Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
190   LinkInfo link_info(spec_klass, name, signature);
191   LinkResolver::resolve_virtual_call(
192           callinfo, receiver, recvrKlass, link_info, true, CHECK);
<span class="line-modified">193   methodHandle method = callinfo.selected_method();</span>
194   assert(method.not_null(), &quot;should have thrown exception&quot;);
195 
196   // Invoke the method
197   JavaCalls::call(result, method, args, CHECK);
198 }
199 
200 
201 void JavaCalls::call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, TRAPS) {
202   JavaCallArguments args(receiver);
203   call_virtual(result, spec_klass, name, signature, &amp;args, CHECK);
204 }
205 
206 
207 void JavaCalls::call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS) {
208   JavaCallArguments args(receiver);
209   args.push_oop(arg1);
210   call_virtual(result, spec_klass, name, signature, &amp;args, CHECK);
211 }
212 
213 
214 
215 void JavaCalls::call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS) {
216   JavaCallArguments args(receiver);
217   args.push_oop(arg1);
218   args.push_oop(arg2);
219   call_virtual(result, spec_klass, name, signature, &amp;args, CHECK);
220 }
221 
222 
223 // ============ Special calls ============
224 
225 void JavaCalls::call_special(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
226   CallInfo callinfo;
227   LinkInfo link_info(klass, name, signature);
228   LinkResolver::resolve_special_call(callinfo, args-&gt;receiver(), link_info, CHECK);
<span class="line-modified">229   methodHandle method = callinfo.selected_method();</span>
230   assert(method.not_null(), &quot;should have thrown exception&quot;);
231 
232   // Invoke the method
233   JavaCalls::call(result, method, args, CHECK);
234 }
235 
236 
237 void JavaCalls::call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, TRAPS) {
238   JavaCallArguments args(receiver);
239   call_special(result, klass, name, signature, &amp;args, CHECK);
240 }
241 
242 
243 void JavaCalls::call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS) {
244   JavaCallArguments args(receiver);
245   args.push_oop(arg1);
246   call_special(result, klass, name, signature, &amp;args, CHECK);
247 }
248 
249 
250 void JavaCalls::call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS) {
251   JavaCallArguments args(receiver);
252   args.push_oop(arg1);
253   args.push_oop(arg2);
254   call_special(result, klass, name, signature, &amp;args, CHECK);
255 }
256 
257 
258 // ============ Static calls ============
259 
260 void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
261   CallInfo callinfo;
262   LinkInfo link_info(klass, name, signature);
263   LinkResolver::resolve_static_call(callinfo, link_info, true, CHECK);
<span class="line-modified">264   methodHandle method = callinfo.selected_method();</span>
265   assert(method.not_null(), &quot;should have thrown exception&quot;);
266 
267   // Invoke the method
268   JavaCalls::call(result, method, args, CHECK);
269 }
270 
271 
272 void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, TRAPS) {
273   JavaCallArguments args;
274   call_static(result, klass, name, signature, &amp;args, CHECK);
275 }
276 
277 
278 void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS) {
279   JavaCallArguments args(arg1);
280   call_static(result, klass, name, signature, &amp;args, CHECK);
281 }
282 
283 
284 void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS) {
</pre>
<hr />
<pre>
333 // Implementation of JavaCalls (low level)
334 
335 
336 void JavaCalls::call(JavaValue* result, const methodHandle&amp; method, JavaCallArguments* args, TRAPS) {
337   // Check if we need to wrap a potential OS exception handler around thread
338   // This is used for e.g. Win32 structured exception handlers
339   assert(THREAD-&gt;is_Java_thread(), &quot;only JavaThreads can make JavaCalls&quot;);
340   // Need to wrap each and every time, since there might be native code down the
341   // stack that has installed its own exception handlers
342   os::os_exception_wrapper(call_helper, result, method, args, THREAD);
343 }
344 
345 void JavaCalls::call_helper(JavaValue* result, const methodHandle&amp; method, JavaCallArguments* args, TRAPS) {
346 
347   JavaThread* thread = (JavaThread*)THREAD;
348   assert(thread-&gt;is_Java_thread(), &quot;must be called by a java thread&quot;);
349   assert(method.not_null(), &quot;must have a method to call&quot;);
350   assert(!SafepointSynchronize::is_at_safepoint(), &quot;call to Java code during VM operation&quot;);
351   assert(!thread-&gt;handle_area()-&gt;no_handle_mark_active(), &quot;cannot call out to Java here&quot;);
352 
<span class="line-removed">353 </span>
<span class="line-removed">354   CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
<span class="line-removed">355 </span>
356 #if INCLUDE_JVMCI
357   // Gets the nmethod (if any) that should be called instead of normal target
358   nmethod* alternative_target = args-&gt;alternative_target();
359   if (alternative_target == NULL) {
360 #endif
361 // Verify the arguments
362 
363   if (CheckJNICalls)  {
364     args-&gt;verify(method, result-&gt;get_type());
365   }
366   else debug_only(args-&gt;verify(method, result-&gt;get_type()));
367 #if INCLUDE_JVMCI
368   }
369 #else
370 
371   // Ignore call if method is empty
372   if (method-&gt;is_empty_method()) {
373     assert(result-&gt;get_type() == T_VOID, &quot;an empty method must return a void value&quot;);
374     return;
375   }
</pre>
<hr />
<pre>
380     // A klass might not be initialized since JavaCall&#39;s might be used during the executing of
381     // the &lt;clinit&gt;. For example, a Thread.start might start executing on an object that is
382     // not fully initialized! (bad Java programming style)
383     assert(holder-&gt;is_linked(), &quot;rewriting must have taken place&quot;);
384   }
385 #endif
386 
387   CompilationPolicy::compile_if_required(method, CHECK);
388 
389   // Since the call stub sets up like the interpreter we call the from_interpreted_entry
390   // so we can go compiled via a i2c. Otherwise initial entry method will always
391   // run interpreted.
392   address entry_point = method-&gt;from_interpreted_entry();
393   if (JvmtiExport::can_post_interpreter_events() &amp;&amp; thread-&gt;is_interp_only_mode()) {
394     entry_point = method-&gt;interpreter_entry();
395   }
396 
397   // Figure out if the result value is an oop or not (Note: This is a different value
398   // than result_type. result_type will be T_INT of oops. (it is about size)
399   BasicType result_type = runtime_type_from(result);
<span class="line-modified">400   bool oop_result_flag = (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY);</span>
<span class="line-removed">401 </span>
<span class="line-removed">402   // NOTE: if we move the computation of the result_val_address inside</span>
<span class="line-removed">403   // the call to call_stub, the optimizer produces wrong code.</span>
<span class="line-removed">404   intptr_t* result_val_address = (intptr_t*)(result-&gt;get_value_addr());</span>
405 
406   // Find receiver
407   Handle receiver = (!method-&gt;is_static()) ? args-&gt;receiver() : Handle();
408 
409   // When we reenter Java, we need to reenable the reserved/yellow zone which
410   // might already be disabled when we are in VM.
411   if (!thread-&gt;stack_guards_enabled()) {
412     thread-&gt;reguard_stack();
413   }
414 
415   // Check that there are shadow pages available before changing thread state
416   // to Java. Calculate current_stack_pointer here to make sure
417   // stack_shadow_pages_available() and bang_stack_shadow_pages() use the same sp.
418   address sp = os::current_stack_pointer();
419   if (!os::stack_shadow_pages_available(THREAD, method, sp)) {
420     // Throw stack overflow exception with preinitialized exception.
421     Exceptions::throw_stack_overflow_exception(THREAD, __FILE__, __LINE__, method);
422     return;
423   } else {
424     // Touch pages checked if the OS needs them to be touched to be mapped.
425     os::map_stack_shadow_pages(sp);
426   }
427 
428 #if INCLUDE_JVMCI
429   if (alternative_target != NULL) {
430     if (alternative_target-&gt;is_alive() &amp;&amp; !alternative_target-&gt;is_unloading()) {
431       thread-&gt;set_jvmci_alternate_call_target(alternative_target-&gt;verified_entry_point());
432       entry_point = method-&gt;adapter()-&gt;get_i2c_entry();
433     } else {
434       THROW(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
435     }
436   }
437 #endif
438 
439   // do call
440   { JavaCallWrapper link(method, receiver, result, CHECK);
441     { HandleMark hm(thread);  // HandleMark used by HandleMarkCleaner
442 





443       StubRoutines::call_stub()(
444         (address)&amp;link,
445         // (intptr_t*)&amp;(result-&gt;_value), // see NOTE above (compiler problem)
446         result_val_address,          // see NOTE above (compiler problem)
447         result_type,
448         method(),
449         entry_point,
<span class="line-modified">450         args-&gt;parameters(),</span>
451         args-&gt;size_of_parameters(),
452         CHECK
453       );
454 
455       result = link.result();  // circumvent MS C++ 5.0 compiler bug (result is clobbered across call)
456       // Preserve oop return value across possible gc points
457       if (oop_result_flag) {
458         thread-&gt;set_vm_result((oop) result-&gt;get_jobject());
459       }
460     }
461   } // Exit JavaCallWrapper (can block - potential return oop must be preserved)
462 
463   // Check if a thread stop or suspend should be executed
464   // The following assert was not realistic.  Thread.stop can set that bit at any moment.
465   //assert(!thread-&gt;has_special_runtime_exit_condition(), &quot;no async. exceptions should be installed&quot;);
466 
467   // Restore possible oop return
468   if (oop_result_flag) {
<span class="line-modified">469     result-&gt;set_jobject((jobject)thread-&gt;vm_result());</span>
470     thread-&gt;set_vm_result(NULL);
471   }
472 }
473 
474 
475 //--------------------------------------------------------------------------------------
476 // Implementation of JavaCallArguments
477 
478 inline bool is_value_state_indirect_oop(uint state) {
479   assert(state != JavaCallArguments::value_state_oop,
480          &quot;Checking for handles after removal&quot;);
481   assert(state &lt; JavaCallArguments::value_state_limit,
482          &quot;Invalid value state %u&quot;, state);
483   return state != JavaCallArguments::value_state_primitive;
484 }
485 
486 inline oop resolve_indirect_oop(intptr_t value, uint state) {
487   switch (state) {
488   case JavaCallArguments::value_state_handle:
489   {
</pre>
<hr />
<pre>
510     assert(state != value_state_oop, &quot;Multiple handle conversions&quot;);
511     if (is_value_state_indirect_oop(state)) {
512       oop obj = resolve_indirect_oop(_value[i], state);
513       _value[i] = cast_from_oop&lt;intptr_t&gt;(obj);
514       _value_state[i] = value_state_oop;
515     }
516   }
517   // Return argument vector
518   return _value;
519 }
520 
521 
522 class SignatureChekker : public SignatureIterator {
523  private:
524    int _pos;
525    BasicType _return_type;
526    u_char* _value_state;
527    intptr_t* _value;
528 
529  public:
<span class="line-removed">530   bool _is_return;</span>
<span class="line-removed">531 </span>
532   SignatureChekker(Symbol* signature,
533                    BasicType return_type,
534                    bool is_static,
535                    u_char* value_state,
536                    intptr_t* value) :
537     SignatureIterator(signature),
538     _pos(0),
539     _return_type(return_type),
540     _value_state(value_state),
<span class="line-modified">541     _value(value),</span>
<span class="line-removed">542     _is_return(false)</span>
543   {
544     if (!is_static) {
545       check_value(true); // Receiver must be an oop
546     }


547   }
548 
<span class="line-modified">549   void check_value(bool type) {</span>

550     uint state = _value_state[_pos++];
<span class="line-modified">551     if (type) {</span>
552       guarantee(is_value_state_indirect_oop(state),
553                 &quot;signature does not match pushed arguments: %u at %d&quot;,
554                 state, _pos - 1);
555     } else {
556       guarantee(state == JavaCallArguments::value_state_primitive,
557                 &quot;signature does not match pushed arguments: %u at %d&quot;,
558                 state, _pos - 1);
559     }
560   }
561 
<span class="line-removed">562   void check_doing_return(bool state) { _is_return = state; }</span>
<span class="line-removed">563 </span>
564   void check_return_type(BasicType t) {
<span class="line-modified">565     guarantee(_is_return &amp;&amp; t == _return_type, &quot;return type does not match&quot;);</span>
566   }
567 
<span class="line-modified">568   void check_int(BasicType t) {</span>
<span class="line-removed">569     if (_is_return) {</span>
<span class="line-removed">570       check_return_type(t);</span>
<span class="line-removed">571       return;</span>
<span class="line-removed">572     }</span>
573     check_value(false);
574   }
575 
<span class="line-modified">576   void check_double(BasicType t) { check_long(t); }</span>
<span class="line-removed">577 </span>
<span class="line-removed">578   void check_long(BasicType t) {</span>
<span class="line-removed">579     if (_is_return) {</span>
<span class="line-removed">580       check_return_type(t);</span>
<span class="line-removed">581       return;</span>
<span class="line-removed">582     }</span>
<span class="line-removed">583 </span>
584     check_value(false);
585     check_value(false);
586   }
587 
<span class="line-modified">588   void check_obj(BasicType t) {</span>
<span class="line-removed">589     if (_is_return) {</span>
<span class="line-removed">590       check_return_type(t);</span>
<span class="line-removed">591       return;</span>
<span class="line-removed">592     }</span>
<span class="line-removed">593 </span>
594     intptr_t v = _value[_pos];
595     if (v != 0) {
596       // v is a &quot;handle&quot; referring to an oop, cast to integral type.
597       // There shouldn&#39;t be any handles in very low memory.
598       guarantee((size_t)v &gt;= (size_t)os::vm_page_size(),
599                 &quot;Bad JNI oop argument %d: &quot; PTR_FORMAT, _pos, v);
600       // Verify the pointee.
601       oop vv = resolve_indirect_oop(v, _value_state[_pos]);
602       guarantee(oopDesc::is_oop_or_null(vv, true),
603                 &quot;Bad JNI oop argument %d: &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT,
604                 _pos, v, p2i(vv));
605     }
606 
607     check_value(true);          // Verify value state.
608   }
609 
<span class="line-modified">610   void do_bool()                       { check_int(T_BOOLEAN);       }</span>
<span class="line-modified">611   void do_char()                       { check_int(T_CHAR);          }</span>
<span class="line-modified">612   void do_float()                      { check_int(T_FLOAT);         }</span>
<span class="line-modified">613   void do_double()                     { check_double(T_DOUBLE);     }</span>
<span class="line-modified">614   void do_byte()                       { check_int(T_BYTE);          }</span>
<span class="line-modified">615   void do_short()                      { check_int(T_SHORT);         }</span>
<span class="line-modified">616   void do_int()                        { check_int(T_INT);           }</span>
<span class="line-modified">617   void do_long()                       { check_long(T_LONG);         }</span>
<span class="line-modified">618   void do_void()                       { check_return_type(T_VOID);  }</span>
<span class="line-modified">619   void do_object(int begin, int end)   { check_obj(T_OBJECT);        }</span>
<span class="line-modified">620   void do_array(int begin, int end)    { check_obj(T_OBJECT);        }</span>









621 };
622 
623 
624 void JavaCallArguments::verify(const methodHandle&amp; method, BasicType return_type) {
625   guarantee(method-&gt;size_of_parameters() == size_of_parameters(), &quot;wrong no. of arguments pushed&quot;);
626 
627   // Treat T_OBJECT and T_ARRAY as the same
<span class="line-modified">628   if (return_type == T_ARRAY) return_type = T_OBJECT;</span>
629 
630   // Check that oop information is correct
631   Symbol* signature = method-&gt;signature();
632 
633   SignatureChekker sc(signature,
634                       return_type,
635                       method-&gt;is_static(),
636                       _value_state,
637                       _value);
<span class="line-removed">638   sc.iterate_parameters();</span>
<span class="line-removed">639   sc.check_doing_return(true);</span>
<span class="line-removed">640   sc.iterate_returntype();</span>
641 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;code/nmethod.hpp&quot;
<span class="line-added"> 29 #include &quot;compiler/compilationPolicy.hpp&quot;</span>
 30 #include &quot;compiler/compileBroker.hpp&quot;
 31 #include &quot;interpreter/interpreter.hpp&quot;
 32 #include &quot;interpreter/linkResolver.hpp&quot;
 33 #include &quot;memory/universe.hpp&quot;
 34 #include &quot;oops/method.inline.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;prims/jniCheck.hpp&quot;

 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 39 #include &quot;runtime/javaCalls.hpp&quot;
 40 #include &quot;runtime/jniHandles.inline.hpp&quot;
 41 #include &quot;runtime/mutexLocker.hpp&quot;
 42 #include &quot;runtime/os.inline.hpp&quot;
 43 #include &quot;runtime/sharedRuntime.hpp&quot;
 44 #include &quot;runtime/signature.hpp&quot;
 45 #include &quot;runtime/stubRoutines.hpp&quot;
 46 #include &quot;runtime/thread.inline.hpp&quot;




 47 
 48 // -----------------------------------------------------
 49 // Implementation of JavaCallWrapper
 50 
 51 JavaCallWrapper::JavaCallWrapper(const methodHandle&amp; callee_method, Handle receiver, JavaValue* result, TRAPS) {
 52   JavaThread* thread = (JavaThread *)THREAD;
 53   bool clear_pending_exception = true;
 54 
 55   guarantee(thread-&gt;is_Java_thread(), &quot;crucial check - the VM thread cannot and must not escape to Java code&quot;);
 56   assert(!thread-&gt;owns_locks(), &quot;must release all locks when leaving VM&quot;);
 57   guarantee(thread-&gt;can_call_java(), &quot;cannot make java calls from the native compiler&quot;);
 58   _result   = result;
 59 
 60   // Allocate handle block for Java code. This must be done before we change thread_state to _thread_in_Java_or_stub,
 61   // since it can potentially block.
 62   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 63 
 64   // After this, we are official in JavaCode. This needs to be done before we change any of the thread local
 65   // info, since we cannot find oops before the new information is set up completely.
 66   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_Java);
</pre>
<hr />
<pre>
169     case T_DOUBLE : return T_DOUBLE;
170 #ifdef _LP64
171     case T_ARRAY  : // fall through
172     case T_OBJECT:  return T_OBJECT;
173 #endif
174     default:
175       ShouldNotReachHere();
176       return T_ILLEGAL;
177   }
178 }
179 
180 // ============ Virtual calls ============
181 
182 void JavaCalls::call_virtual(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
183   CallInfo callinfo;
184   Handle receiver = args-&gt;receiver();
185   Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
186   LinkInfo link_info(spec_klass, name, signature);
187   LinkResolver::resolve_virtual_call(
188           callinfo, receiver, recvrKlass, link_info, true, CHECK);
<span class="line-modified">189   methodHandle method(THREAD, callinfo.selected_method());</span>
190   assert(method.not_null(), &quot;should have thrown exception&quot;);
191 
192   // Invoke the method
193   JavaCalls::call(result, method, args, CHECK);
194 }
195 
196 
197 void JavaCalls::call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, TRAPS) {
198   JavaCallArguments args(receiver);
199   call_virtual(result, spec_klass, name, signature, &amp;args, CHECK);
200 }
201 
202 
203 void JavaCalls::call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS) {
204   JavaCallArguments args(receiver);
205   args.push_oop(arg1);
206   call_virtual(result, spec_klass, name, signature, &amp;args, CHECK);
207 }
208 
209 
210 
211 void JavaCalls::call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS) {
212   JavaCallArguments args(receiver);
213   args.push_oop(arg1);
214   args.push_oop(arg2);
215   call_virtual(result, spec_klass, name, signature, &amp;args, CHECK);
216 }
217 
218 
219 // ============ Special calls ============
220 
221 void JavaCalls::call_special(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
222   CallInfo callinfo;
223   LinkInfo link_info(klass, name, signature);
224   LinkResolver::resolve_special_call(callinfo, args-&gt;receiver(), link_info, CHECK);
<span class="line-modified">225   methodHandle method(THREAD, callinfo.selected_method());</span>
226   assert(method.not_null(), &quot;should have thrown exception&quot;);
227 
228   // Invoke the method
229   JavaCalls::call(result, method, args, CHECK);
230 }
231 
232 
233 void JavaCalls::call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, TRAPS) {
234   JavaCallArguments args(receiver);
235   call_special(result, klass, name, signature, &amp;args, CHECK);
236 }
237 
238 
239 void JavaCalls::call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS) {
240   JavaCallArguments args(receiver);
241   args.push_oop(arg1);
242   call_special(result, klass, name, signature, &amp;args, CHECK);
243 }
244 
245 
246 void JavaCalls::call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS) {
247   JavaCallArguments args(receiver);
248   args.push_oop(arg1);
249   args.push_oop(arg2);
250   call_special(result, klass, name, signature, &amp;args, CHECK);
251 }
252 
253 
254 // ============ Static calls ============
255 
256 void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
257   CallInfo callinfo;
258   LinkInfo link_info(klass, name, signature);
259   LinkResolver::resolve_static_call(callinfo, link_info, true, CHECK);
<span class="line-modified">260   methodHandle method(THREAD, callinfo.selected_method());</span>
261   assert(method.not_null(), &quot;should have thrown exception&quot;);
262 
263   // Invoke the method
264   JavaCalls::call(result, method, args, CHECK);
265 }
266 
267 
268 void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, TRAPS) {
269   JavaCallArguments args;
270   call_static(result, klass, name, signature, &amp;args, CHECK);
271 }
272 
273 
274 void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS) {
275   JavaCallArguments args(arg1);
276   call_static(result, klass, name, signature, &amp;args, CHECK);
277 }
278 
279 
280 void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS) {
</pre>
<hr />
<pre>
329 // Implementation of JavaCalls (low level)
330 
331 
332 void JavaCalls::call(JavaValue* result, const methodHandle&amp; method, JavaCallArguments* args, TRAPS) {
333   // Check if we need to wrap a potential OS exception handler around thread
334   // This is used for e.g. Win32 structured exception handlers
335   assert(THREAD-&gt;is_Java_thread(), &quot;only JavaThreads can make JavaCalls&quot;);
336   // Need to wrap each and every time, since there might be native code down the
337   // stack that has installed its own exception handlers
338   os::os_exception_wrapper(call_helper, result, method, args, THREAD);
339 }
340 
341 void JavaCalls::call_helper(JavaValue* result, const methodHandle&amp; method, JavaCallArguments* args, TRAPS) {
342 
343   JavaThread* thread = (JavaThread*)THREAD;
344   assert(thread-&gt;is_Java_thread(), &quot;must be called by a java thread&quot;);
345   assert(method.not_null(), &quot;must have a method to call&quot;);
346   assert(!SafepointSynchronize::is_at_safepoint(), &quot;call to Java code during VM operation&quot;);
347   assert(!thread-&gt;handle_area()-&gt;no_handle_mark_active(), &quot;cannot call out to Java here&quot;);
348 



349 #if INCLUDE_JVMCI
350   // Gets the nmethod (if any) that should be called instead of normal target
351   nmethod* alternative_target = args-&gt;alternative_target();
352   if (alternative_target == NULL) {
353 #endif
354 // Verify the arguments
355 
356   if (CheckJNICalls)  {
357     args-&gt;verify(method, result-&gt;get_type());
358   }
359   else debug_only(args-&gt;verify(method, result-&gt;get_type()));
360 #if INCLUDE_JVMCI
361   }
362 #else
363 
364   // Ignore call if method is empty
365   if (method-&gt;is_empty_method()) {
366     assert(result-&gt;get_type() == T_VOID, &quot;an empty method must return a void value&quot;);
367     return;
368   }
</pre>
<hr />
<pre>
373     // A klass might not be initialized since JavaCall&#39;s might be used during the executing of
374     // the &lt;clinit&gt;. For example, a Thread.start might start executing on an object that is
375     // not fully initialized! (bad Java programming style)
376     assert(holder-&gt;is_linked(), &quot;rewriting must have taken place&quot;);
377   }
378 #endif
379 
380   CompilationPolicy::compile_if_required(method, CHECK);
381 
382   // Since the call stub sets up like the interpreter we call the from_interpreted_entry
383   // so we can go compiled via a i2c. Otherwise initial entry method will always
384   // run interpreted.
385   address entry_point = method-&gt;from_interpreted_entry();
386   if (JvmtiExport::can_post_interpreter_events() &amp;&amp; thread-&gt;is_interp_only_mode()) {
387     entry_point = method-&gt;interpreter_entry();
388   }
389 
390   // Figure out if the result value is an oop or not (Note: This is a different value
391   // than result_type. result_type will be T_INT of oops. (it is about size)
392   BasicType result_type = runtime_type_from(result);
<span class="line-modified">393   bool oop_result_flag = is_reference_type(result-&gt;get_type());</span>




394 
395   // Find receiver
396   Handle receiver = (!method-&gt;is_static()) ? args-&gt;receiver() : Handle();
397 
398   // When we reenter Java, we need to reenable the reserved/yellow zone which
399   // might already be disabled when we are in VM.
400   if (!thread-&gt;stack_guards_enabled()) {
401     thread-&gt;reguard_stack();
402   }
403 
404   // Check that there are shadow pages available before changing thread state
405   // to Java. Calculate current_stack_pointer here to make sure
406   // stack_shadow_pages_available() and bang_stack_shadow_pages() use the same sp.
407   address sp = os::current_stack_pointer();
408   if (!os::stack_shadow_pages_available(THREAD, method, sp)) {
409     // Throw stack overflow exception with preinitialized exception.
410     Exceptions::throw_stack_overflow_exception(THREAD, __FILE__, __LINE__, method);
411     return;
412   } else {
413     // Touch pages checked if the OS needs them to be touched to be mapped.
414     os::map_stack_shadow_pages(sp);
415   }
416 
417 #if INCLUDE_JVMCI
418   if (alternative_target != NULL) {
419     if (alternative_target-&gt;is_alive() &amp;&amp; !alternative_target-&gt;is_unloading()) {
420       thread-&gt;set_jvmci_alternate_call_target(alternative_target-&gt;verified_entry_point());
421       entry_point = method-&gt;adapter()-&gt;get_i2c_entry();
422     } else {
423       THROW(vmSymbols::jdk_vm_ci_code_InvalidInstalledCodeException());
424     }
425   }
426 #endif
427 
428   // do call
429   { JavaCallWrapper link(method, receiver, result, CHECK);
430     { HandleMark hm(thread);  // HandleMark used by HandleMarkCleaner
431 
<span class="line-added">432       // NOTE: if we move the computation of the result_val_address inside</span>
<span class="line-added">433       // the call to call_stub, the optimizer produces wrong code.</span>
<span class="line-added">434       intptr_t* result_val_address = (intptr_t*)(result-&gt;get_value_addr());</span>
<span class="line-added">435       intptr_t* parameter_address = args-&gt;parameters();</span>
<span class="line-added">436 </span>
437       StubRoutines::call_stub()(
438         (address)&amp;link,
439         // (intptr_t*)&amp;(result-&gt;_value), // see NOTE above (compiler problem)
440         result_val_address,          // see NOTE above (compiler problem)
441         result_type,
442         method(),
443         entry_point,
<span class="line-modified">444         parameter_address,</span>
445         args-&gt;size_of_parameters(),
446         CHECK
447       );
448 
449       result = link.result();  // circumvent MS C++ 5.0 compiler bug (result is clobbered across call)
450       // Preserve oop return value across possible gc points
451       if (oop_result_flag) {
452         thread-&gt;set_vm_result((oop) result-&gt;get_jobject());
453       }
454     }
455   } // Exit JavaCallWrapper (can block - potential return oop must be preserved)
456 
457   // Check if a thread stop or suspend should be executed
458   // The following assert was not realistic.  Thread.stop can set that bit at any moment.
459   //assert(!thread-&gt;has_special_runtime_exit_condition(), &quot;no async. exceptions should be installed&quot;);
460 
461   // Restore possible oop return
462   if (oop_result_flag) {
<span class="line-modified">463     result-&gt;set_jobject(cast_from_oop&lt;jobject&gt;(thread-&gt;vm_result()));</span>
464     thread-&gt;set_vm_result(NULL);
465   }
466 }
467 
468 
469 //--------------------------------------------------------------------------------------
470 // Implementation of JavaCallArguments
471 
472 inline bool is_value_state_indirect_oop(uint state) {
473   assert(state != JavaCallArguments::value_state_oop,
474          &quot;Checking for handles after removal&quot;);
475   assert(state &lt; JavaCallArguments::value_state_limit,
476          &quot;Invalid value state %u&quot;, state);
477   return state != JavaCallArguments::value_state_primitive;
478 }
479 
480 inline oop resolve_indirect_oop(intptr_t value, uint state) {
481   switch (state) {
482   case JavaCallArguments::value_state_handle:
483   {
</pre>
<hr />
<pre>
504     assert(state != value_state_oop, &quot;Multiple handle conversions&quot;);
505     if (is_value_state_indirect_oop(state)) {
506       oop obj = resolve_indirect_oop(_value[i], state);
507       _value[i] = cast_from_oop&lt;intptr_t&gt;(obj);
508       _value_state[i] = value_state_oop;
509     }
510   }
511   // Return argument vector
512   return _value;
513 }
514 
515 
516 class SignatureChekker : public SignatureIterator {
517  private:
518    int _pos;
519    BasicType _return_type;
520    u_char* _value_state;
521    intptr_t* _value;
522 
523  public:


524   SignatureChekker(Symbol* signature,
525                    BasicType return_type,
526                    bool is_static,
527                    u_char* value_state,
528                    intptr_t* value) :
529     SignatureIterator(signature),
530     _pos(0),
531     _return_type(return_type),
532     _value_state(value_state),
<span class="line-modified">533     _value(value)</span>

534   {
535     if (!is_static) {
536       check_value(true); // Receiver must be an oop
537     }
<span class="line-added">538     do_parameters_on(this);</span>
<span class="line-added">539     check_return_type(return_type);</span>
540   }
541 
<span class="line-modified">542  private:</span>
<span class="line-added">543   void check_value(bool is_reference) {</span>
544     uint state = _value_state[_pos++];
<span class="line-modified">545     if (is_reference) {</span>
546       guarantee(is_value_state_indirect_oop(state),
547                 &quot;signature does not match pushed arguments: %u at %d&quot;,
548                 state, _pos - 1);
549     } else {
550       guarantee(state == JavaCallArguments::value_state_primitive,
551                 &quot;signature does not match pushed arguments: %u at %d&quot;,
552                 state, _pos - 1);
553     }
554   }
555 


556   void check_return_type(BasicType t) {
<span class="line-modified">557     guarantee(t == _return_type, &quot;return type does not match&quot;);</span>
558   }
559 
<span class="line-modified">560   void check_single_word() {</span>




561     check_value(false);
562   }
563 
<span class="line-modified">564   void check_double_word() {</span>







565     check_value(false);
566     check_value(false);
567   }
568 
<span class="line-modified">569   void check_reference() {</span>





570     intptr_t v = _value[_pos];
571     if (v != 0) {
572       // v is a &quot;handle&quot; referring to an oop, cast to integral type.
573       // There shouldn&#39;t be any handles in very low memory.
574       guarantee((size_t)v &gt;= (size_t)os::vm_page_size(),
575                 &quot;Bad JNI oop argument %d: &quot; PTR_FORMAT, _pos, v);
576       // Verify the pointee.
577       oop vv = resolve_indirect_oop(v, _value_state[_pos]);
578       guarantee(oopDesc::is_oop_or_null(vv, true),
579                 &quot;Bad JNI oop argument %d: &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT,
580                 _pos, v, p2i(vv));
581     }
582 
583     check_value(true);          // Verify value state.
584   }
585 
<span class="line-modified">586   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">587   void do_type(BasicType type) {</span>
<span class="line-modified">588     switch (type) {</span>
<span class="line-modified">589     case T_BYTE:</span>
<span class="line-modified">590     case T_BOOLEAN:</span>
<span class="line-modified">591     case T_CHAR:</span>
<span class="line-modified">592     case T_SHORT:</span>
<span class="line-modified">593     case T_INT:</span>
<span class="line-modified">594     case T_FLOAT:  // this one also</span>
<span class="line-modified">595       check_single_word(); break;</span>
<span class="line-modified">596     case T_LONG:</span>
<span class="line-added">597     case T_DOUBLE:</span>
<span class="line-added">598       check_double_word(); break;</span>
<span class="line-added">599     case T_ARRAY:</span>
<span class="line-added">600     case T_OBJECT:</span>
<span class="line-added">601       check_reference(); break;</span>
<span class="line-added">602     default:</span>
<span class="line-added">603       ShouldNotReachHere();</span>
<span class="line-added">604     }</span>
<span class="line-added">605   }</span>
606 };
607 
608 
609 void JavaCallArguments::verify(const methodHandle&amp; method, BasicType return_type) {
610   guarantee(method-&gt;size_of_parameters() == size_of_parameters(), &quot;wrong no. of arguments pushed&quot;);
611 
612   // Treat T_OBJECT and T_ARRAY as the same
<span class="line-modified">613   if (is_reference_type(return_type)) return_type = T_OBJECT;</span>
614 
615   // Check that oop information is correct
616   Symbol* signature = method-&gt;signature();
617 
618   SignatureChekker sc(signature,
619                       return_type,
620                       method-&gt;is_static(),
621                       _value_state,
622                       _value);



623 }
</pre>
</td>
</tr>
</table>
<center><a href="java.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniHandles.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
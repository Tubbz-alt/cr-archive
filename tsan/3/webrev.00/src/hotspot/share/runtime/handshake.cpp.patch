diff a/src/hotspot/share/runtime/handshake.cpp b/src/hotspot/share/runtime/handshake.cpp
--- a/src/hotspot/share/runtime/handshake.cpp
+++ b/src/hotspot/share/runtime/handshake.cpp
@@ -24,17 +24,16 @@
 
 #include "precompiled.hpp"
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
 #include "memory/resourceArea.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/handshake.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
-#include "runtime/orderAccess.hpp"
 #include "runtime/osThread.hpp"
 #include "runtime/semaphore.inline.hpp"
 #include "runtime/task.hpp"
-#include "runtime/timerTrace.hpp"
 #include "runtime/thread.hpp"
 #include "runtime/vmThread.hpp"
 #include "utilities/formatBuffer.hpp"
 #include "utilities/preserveException.hpp"
 
@@ -43,16 +42,18 @@
   virtual void do_handshake(JavaThread* thread) = 0;
 };
 
 class HandshakeThreadsOperation: public HandshakeOperation {
   static Semaphore _done;
-  ThreadClosure* _thread_cl;
-
+  HandshakeClosure* _handshake_cl;
+  bool _executed;
 public:
-  HandshakeThreadsOperation(ThreadClosure* cl) : _thread_cl(cl) {}
+  HandshakeThreadsOperation(HandshakeClosure* cl) : _handshake_cl(cl), _executed(false) {}
   void do_handshake(JavaThread* thread);
   bool thread_has_completed() { return _done.trywait(); }
+  bool executed() const { return _executed; }
+  const char* name() { return _handshake_cl->name(); }
 
 #ifdef ASSERT
   void check_state() {
     assert(!_done.trywait(), "Must be zero");
   }
@@ -64,12 +65,10 @@
 class VM_Handshake: public VM_Operation {
   const jlong _handshake_timeout;
  public:
   bool evaluate_at_safepoint() const { return false; }
 
-  bool evaluate_concurrently() const { return false; }
-
  protected:
   HandshakeThreadsOperation* const _op;
 
   VM_Handshake(HandshakeThreadsOperation* op) :
       _handshake_timeout(TimeHelper::millis_to_counter(HandshakeTimeout)), _op(op) {}
@@ -105,73 +104,88 @@
   }
   log_stream.flush();
   fatal("Handshake operation timed out");
 }
 
+static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int vmt_executed, const char* extra = NULL) {
+  if (start_time_ns != 0) {
+    jlong completion_time = os::javaTimeNanos() - start_time_ns;
+    log_info(handshake)("Handshake \"%s\", Targeted threads: %d, Executed by targeted threads: %d, Total completion time: " JLONG_FORMAT " ns%s%s",
+                        name, targets,
+                        targets - vmt_executed,
+                        completion_time,
+                        extra != NULL ? ", " : "",
+                        extra != NULL ? extra : "");
+  }
+}
+
 class VM_HandshakeOneThread: public VM_Handshake {
   JavaThread* _target;
-  bool _thread_alive;
  public:
   VM_HandshakeOneThread(HandshakeThreadsOperation* op, JavaThread* target) :
-    VM_Handshake(op), _target(target), _thread_alive(false) {}
+    VM_Handshake(op), _target(target) {}
 
   void doit() {
     DEBUG_ONLY(_op->check_state();)
-    TraceTime timer("Performing single-target operation (vmoperation doit)", TRACETIME_LOG(Info, handshake));
+
+    jlong start_time_ns = 0;
+    if (log_is_enabled(Info, handshake)) {
+      start_time_ns = os::javaTimeNanos();
+    }
 
     ThreadsListHandle tlh;
     if (tlh.includes(_target)) {
       set_handshake(_target);
-      _thread_alive = true;
     } else {
+      log_handshake_info(start_time_ns, _op->name(), 0, 0, "(thread dead)");
       return;
     }
 
-    log_trace(handshake)("Thread signaled, begin processing by VMThtread");
-    jlong start_time = os::elapsed_counter();
+    log_trace(handshake)("JavaThread " INTPTR_FORMAT " signaled, begin attempt to process by VMThtread", p2i(_target));
+    jlong timeout_start_time = os::elapsed_counter();
+    bool by_vm_thread = false;
     do {
-      if (handshake_has_timed_out(start_time)) {
+      if (handshake_has_timed_out(timeout_start_time)) {
         handle_timeout();
       }
-
-      // We need to re-think this with SMR ThreadsList.
-      // There is an assumption in the code that the Threads_lock should be
-      // locked during certain phases.
-      {
-        MutexLockerEx ml(Threads_lock, Mutex::_no_safepoint_check_flag);
-        _target->handshake_process_by_vmthread();
-      }
+      by_vm_thread = _target->handshake_try_process_by_vmThread();
     } while (!poll_for_completed_thread());
     DEBUG_ONLY(_op->check_state();)
+    log_handshake_info(start_time_ns, _op->name(), 1, by_vm_thread ? 1 : 0);
   }
 
   VMOp_Type type() const { return VMOp_HandshakeOneThread; }
 
-  bool thread_alive() const { return _thread_alive; }
+  bool executed() const { return _op->executed(); }
 };
 
 class VM_HandshakeAllThreads: public VM_Handshake {
  public:
   VM_HandshakeAllThreads(HandshakeThreadsOperation* op) : VM_Handshake(op) {}
 
   void doit() {
     DEBUG_ONLY(_op->check_state();)
-    TraceTime timer("Performing operation (vmoperation doit)", TRACETIME_LOG(Info, handshake));
+
+    jlong start_time_ns = 0;
+    if (log_is_enabled(Info, handshake)) {
+      start_time_ns = os::javaTimeNanos();
+    }
+    int handshake_executed_by_vm_thread = 0;
 
     JavaThreadIteratorWithHandle jtiwh;
     int number_of_threads_issued = 0;
     for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
       set_handshake(thr);
       number_of_threads_issued++;
     }
 
     if (number_of_threads_issued < 1) {
-      log_debug(handshake)("No threads to handshake.");
+      log_handshake_info(start_time_ns, _op->name(), 0, 0);
       return;
     }
 
-    log_debug(handshake)("Threads signaled, begin processing blocked threads by VMThtread");
+    log_trace(handshake)("Threads signaled, begin processing blocked threads by VMThread");
     const jlong start_time = os::elapsed_counter();
     int number_of_threads_completed = 0;
     do {
       // Check if handshake operation has timed out
       if (handshake_has_timed_out(start_time)) {
@@ -179,143 +193,153 @@
       }
 
       // Have VM thread perform the handshake operation for blocked threads.
       // Observing a blocked state may of course be transient but the processing is guarded
       // by semaphores and we optimistically begin by working on the blocked threads
-      {
-          // We need to re-think this with SMR ThreadsList.
-          // There is an assumption in the code that the Threads_lock should
-          // be locked during certain phases.
-          jtiwh.rewind();
-          MutexLockerEx ml(Threads_lock, Mutex::_no_safepoint_check_flag);
-          for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
-            // A new thread on the ThreadsList will not have an operation,
-            // hence it is skipped in handshake_process_by_vmthread.
-            thr->handshake_process_by_vmthread();
-          }
+      jtiwh.rewind();
+      for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
+        // A new thread on the ThreadsList will not have an operation,
+        // hence it is skipped in handshake_process_by_vmthread.
+        if (thr->handshake_try_process_by_vmThread()) {
+          handshake_executed_by_vm_thread++;
+        }
       }
-
       while (poll_for_completed_thread()) {
         // Includes canceled operations by exiting threads.
         number_of_threads_completed++;
       }
 
     } while (number_of_threads_issued > number_of_threads_completed);
     assert(number_of_threads_issued == number_of_threads_completed, "Must be the same");
     DEBUG_ONLY(_op->check_state();)
+
+    log_handshake_info(start_time_ns, _op->name(), number_of_threads_issued, handshake_executed_by_vm_thread);
   }
 
   VMOp_Type type() const { return VMOp_HandshakeAllThreads; }
 };
 
 class VM_HandshakeFallbackOperation : public VM_Operation {
-  ThreadClosure* _thread_cl;
+  HandshakeClosure* _handshake_cl;
   Thread* _target_thread;
   bool _all_threads;
-  bool _thread_alive;
+  bool _executed;
 public:
-  VM_HandshakeFallbackOperation(ThreadClosure* cl) :
-      _thread_cl(cl), _target_thread(NULL), _all_threads(true), _thread_alive(true) {}
-  VM_HandshakeFallbackOperation(ThreadClosure* cl, Thread* target) :
-      _thread_cl(cl), _target_thread(target), _all_threads(false), _thread_alive(false) {}
+  VM_HandshakeFallbackOperation(HandshakeClosure* cl) :
+      _handshake_cl(cl), _target_thread(NULL), _all_threads(true), _executed(false) {}
+  VM_HandshakeFallbackOperation(HandshakeClosure* cl, Thread* target) :
+      _handshake_cl(cl), _target_thread(target), _all_threads(false), _executed(false) {}
 
   void doit() {
+    log_trace(handshake)("VMThread executing VM_HandshakeFallbackOperation, operation: %s", name());
     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
       if (_all_threads || t == _target_thread) {
         if (t == _target_thread) {
-          _thread_alive = true;
+          _executed = true;
         }
-        _thread_cl->do_thread(t);
+        _handshake_cl->do_thread(t);
       }
     }
   }
 
   VMOp_Type type() const { return VMOp_HandshakeFallback; }
-  bool thread_alive() const { return _thread_alive; }
+  bool executed() const { return _executed; }
 };
 
 void HandshakeThreadsOperation::do_handshake(JavaThread* thread) {
-  ResourceMark rm;
-  FormatBufferResource message("Operation for thread " PTR_FORMAT ", is_vm_thread: %s",
-                               p2i(thread), BOOL_TO_STR(Thread::current()->is_VM_thread()));
-  TraceTime timer(message, TRACETIME_LOG(Debug, handshake, task));
+  jlong start_time_ns = 0;
+  if (log_is_enabled(Debug, handshake, task)) {
+    start_time_ns = os::javaTimeNanos();
+  }
 
   // Only actually execute the operation for non terminated threads.
   if (!thread->is_terminated()) {
-    _thread_cl->do_thread(thread);
+    _handshake_cl->do_thread(thread);
+    _executed = true;
+  }
+
+  if (start_time_ns != 0) {
+    jlong completion_time = os::javaTimeNanos() - start_time_ns;
+    log_debug(handshake, task)("Operation: %s for thread " PTR_FORMAT ", is_vm_thread: %s, completed in " JLONG_FORMAT " ns",
+                               name(), p2i(thread), BOOL_TO_STR(Thread::current()->is_VM_thread()), completion_time);
   }
 
   // Use the semaphore to inform the VM thread that we have completed the operation
   _done.signal();
+
+  // It is no longer safe to refer to 'this' as the VMThread may have destroyed this operation
 }
 
-void Handshake::execute(ThreadClosure* thread_cl) {
-  if (ThreadLocalHandshakes) {
+void Handshake::execute(HandshakeClosure* thread_cl) {
+  if (SafepointMechanism::uses_thread_local_poll()) {
     HandshakeThreadsOperation cto(thread_cl);
     VM_HandshakeAllThreads handshake(&cto);
     VMThread::execute(&handshake);
   } else {
     VM_HandshakeFallbackOperation op(thread_cl);
     VMThread::execute(&op);
   }
 }
 
-bool Handshake::execute(ThreadClosure* thread_cl, JavaThread* target) {
-  if (ThreadLocalHandshakes) {
+bool Handshake::execute(HandshakeClosure* thread_cl, JavaThread* target) {
+  if (SafepointMechanism::uses_thread_local_poll()) {
     HandshakeThreadsOperation cto(thread_cl);
     VM_HandshakeOneThread handshake(&cto, target);
     VMThread::execute(&handshake);
-    return handshake.thread_alive();
+    return handshake.executed();
   } else {
     VM_HandshakeFallbackOperation op(thread_cl, target);
     VMThread::execute(&op);
-    return op.thread_alive();
+    return op.executed();
   }
 }
 
-HandshakeState::HandshakeState() : _operation(NULL), _semaphore(1), _thread_in_process_handshake(false) {}
+HandshakeState::HandshakeState() : _operation(NULL), _semaphore(1), _thread_in_process_handshake(false) {
+  DEBUG_ONLY(_vmthread_processing_handshake = false;)
+}
 
 void HandshakeState::set_operation(JavaThread* target, HandshakeOperation* op) {
   _operation = op;
   SafepointMechanism::arm_local_poll_release(target);
 }
 
 void HandshakeState::clear_handshake(JavaThread* target) {
   _operation = NULL;
-  SafepointMechanism::disarm_local_poll_release(target);
+  SafepointMechanism::disarm_if_needed(target, true /* release */);
 }
 
 void HandshakeState::process_self_inner(JavaThread* thread) {
   assert(Thread::current() == thread, "should call from thread");
   assert(!thread->is_terminated(), "should not be a terminated thread");
+  assert(thread->thread_state() != _thread_blocked, "should not be in a blocked state");
+  assert(thread->thread_state() != _thread_in_native, "should not be in native");
 
-  ThreadInVMForHandshake tivm(thread);
-  if (!_semaphore.trywait()) {
-    _semaphore.wait_with_safepoint_check(thread);
-  }
-  HandshakeOperation* op = OrderAccess::load_acquire(&_operation);
-  if (op != NULL) {
-    HandleMark hm(thread);
-    CautiouslyPreserveExceptionMark pem(thread);
-    // Disarm before execute the operation
-    clear_handshake(thread);
-    op->do_handshake(thread);
-  }
-  _semaphore.signal();
+  do {
+    ThreadInVMForHandshake tivm(thread);
+    if (!_semaphore.trywait()) {
+      _semaphore.wait_with_safepoint_check(thread);
+    }
+    HandshakeOperation* op = Atomic::load_acquire(&_operation);
+    if (op != NULL) {
+      HandleMark hm(thread);
+      CautiouslyPreserveExceptionMark pem(thread);
+      // Disarm before execute the operation
+      clear_handshake(thread);
+      op->do_handshake(thread);
+    }
+    _semaphore.signal();
+  } while (has_operation());
 }
 
 bool HandshakeState::vmthread_can_process_handshake(JavaThread* target) {
   // handshake_safe may only be called with polls armed.
   // VM thread controls this by first claiming the handshake via claim_handshake_for_vmthread.
   return SafepointSynchronize::handshake_safe(target);
 }
 
 static bool possibly_vmthread_can_process_handshake(JavaThread* target) {
-  // An externally suspended thread cannot be resumed while the
-  // Threads_lock is held so it is safe.
   // Note that this method is allowed to produce false positives.
-  assert(Threads_lock->owned_by_self(), "Not holding Threads_lock.");
   if (target->is_ext_suspended()) {
     return true;
   }
   if (target->is_terminated()) {
     return true;
@@ -342,38 +366,43 @@
   }
   _semaphore.signal();
   return false;
 }
 
-void HandshakeState::process_by_vmthread(JavaThread* target) {
+bool HandshakeState::try_process_by_vmThread(JavaThread* target) {
   assert(Thread::current()->is_VM_thread(), "should call from vm thread");
-  // Threads_lock must be held here, but that is assert()ed in
-  // possibly_vmthread_can_process_handshake().
 
   if (!has_operation()) {
     // JT has already cleared its handshake
-    return;
+    return false;
   }
 
   if (!possibly_vmthread_can_process_handshake(target)) {
     // JT is observed in an unsafe state, it must notice the handshake itself
-    return;
+    return false;
   }
 
   // Claim the semaphore if there still an operation to be executed.
   if (!claim_handshake_for_vmthread()) {
-    return;
+    return false;
   }
 
   // If we own the semaphore at this point and while owning the semaphore
   // can observe a safe state the thread cannot possibly continue without
   // getting caught by the semaphore.
+  bool executed = false;
   if (vmthread_can_process_handshake(target)) {
     guarantee(!_semaphore.trywait(), "we should already own the semaphore");
+    log_trace(handshake)("Processing handshake by VMThtread");
+    DEBUG_ONLY(_vmthread_processing_handshake = true;)
     _operation->do_handshake(target);
+    DEBUG_ONLY(_vmthread_processing_handshake = false;)
     // Disarm after VM thread have executed the operation.
     clear_handshake(target);
-    // Release the thread
+    executed = true;
   }
 
+  // Release the thread
   _semaphore.signal();
+
+  return executed;
 }

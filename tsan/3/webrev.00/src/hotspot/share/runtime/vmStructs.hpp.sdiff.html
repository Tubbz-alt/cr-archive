<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/vmStructs.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmThread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/vmStructs.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
151   //  debug_only(static int findType(const char* typeName);)
152   static int findType(const char* typeName);
153 };
154 
155 // This utility macro quotes the passed string
156 #define QUOTE(x) #x
157 
158 //--------------------------------------------------------------------------------
159 // VMStructEntry macros
160 //
161 
162 // This macro generates a VMStructEntry line for a nonstatic field
163 #define GENERATE_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)              \
164  { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 0, offset_of(typeName, fieldName), NULL },
165 
166 // This macro generates a VMStructEntry line for a static field
167 #define GENERATE_STATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)                 \
168  { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 1, 0, &amp;typeName::fieldName },
169 
170 // This macro generates a VMStructEntry line for a static pointer volatile field,
<span class="line-modified">171 // e.g.: &quot;static ObjectMonitor * volatile gBlockList;&quot;</span>
172 #define GENERATE_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY(typeName, fieldName, type)    \
173  { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 1, 0, (void *)&amp;typeName::fieldName },
174 
175 // This macro generates a VMStructEntry line for an unchecked
176 // nonstatic field, in which the size of the type is also specified.
177 // The type string is given as NULL, indicating an &quot;opaque&quot; type.
178 #define GENERATE_UNCHECKED_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, size)    \
179   { QUOTE(typeName), QUOTE(fieldName), NULL, 0, offset_of(typeName, fieldName), NULL },
180 
181 // This macro generates a VMStructEntry line for an unchecked
182 // static field, in which the size of the type is also specified.
183 // The type string is given as NULL, indicating an &quot;opaque&quot; type.
184 #define GENERATE_UNCHECKED_STATIC_VM_STRUCT_ENTRY(typeName, fieldName, size)       \
185  { QUOTE(typeName), QUOTE(fieldName), NULL, 1, 0, (void*) &amp;typeName::fieldName },
186 
187 // This macro generates the sentinel value indicating the end of the list
188 #define GENERATE_VM_STRUCT_LAST_ENTRY() \
189  { NULL, NULL, NULL, 0, 0, NULL }
190 
191 // This macro checks the type of a VMStructEntry by comparing pointer types
192 #define CHECK_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)                 \
193  {typeName *dummyObj = NULL; type* dummy = &amp;dummyObj-&gt;fieldName;                   \
194   assert(offset_of(typeName, fieldName) &lt; sizeof(typeName), &quot;Illegal nonstatic struct entry, field offset too large&quot;); }
195 
196 // This macro checks the type of a volatile VMStructEntry by comparing pointer types
197 #define CHECK_VOLATILE_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)        \
198  {typedef type dummyvtype; typeName *dummyObj = NULL; volatile dummyvtype* dummy = &amp;dummyObj-&gt;fieldName; }
199 
200 // This macro checks the type of a static VMStructEntry by comparing pointer types
201 #define CHECK_STATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)                    \
202  {type* dummy = &amp;typeName::fieldName; }
203 
204 // This macro checks the type of a static pointer volatile VMStructEntry by comparing pointer types,
<span class="line-modified">205 // e.g.: &quot;static ObjectMonitor * volatile gBlockList;&quot;</span>
206 #define CHECK_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY(typeName, fieldName, type)       \
207  {type volatile * dummy = &amp;typeName::fieldName; }
208 
209 // This macro ensures the type of a field and its containing type are
210 // present in the type table. The assertion string is shorter than
211 // preferable because (incredibly) of a bug in Solstice NFS client
212 // which seems to prevent very long lines from compiling. This assertion
213 // means that an entry in VMStructs::localHotSpotVMStructs[] was not
214 // found in VMStructs::localHotSpotVMTypes[].
215 #define ENSURE_FIELD_TYPE_PRESENT(typeName, fieldName, type)                       \
216  { assert(findType(QUOTE(typeName)) != 0, &quot;type \&quot;&quot; QUOTE(typeName) &quot;\&quot; not found in type table&quot;); \
217    assert(findType(QUOTE(type)) != 0, &quot;type \&quot;&quot; QUOTE(type) &quot;\&quot; not found in type table&quot;); }
218 
219 // This is a no-op macro for unchecked fields
220 #define CHECK_NO_OP(a, b, c)
221 
222 
223 //--------------------------------------------------------------------------------
224 // VMTypeEntry macros
225 //
</pre>
</td>
<td>
<hr />
<pre>
151   //  debug_only(static int findType(const char* typeName);)
152   static int findType(const char* typeName);
153 };
154 
155 // This utility macro quotes the passed string
156 #define QUOTE(x) #x
157 
158 //--------------------------------------------------------------------------------
159 // VMStructEntry macros
160 //
161 
162 // This macro generates a VMStructEntry line for a nonstatic field
163 #define GENERATE_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)              \
164  { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 0, offset_of(typeName, fieldName), NULL },
165 
166 // This macro generates a VMStructEntry line for a static field
167 #define GENERATE_STATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)                 \
168  { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 1, 0, &amp;typeName::fieldName },
169 
170 // This macro generates a VMStructEntry line for a static pointer volatile field,
<span class="line-modified">171 // e.g.: &quot;static ObjectMonitor * volatile g_block_list;&quot;</span>
172 #define GENERATE_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY(typeName, fieldName, type)    \
173  { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 1, 0, (void *)&amp;typeName::fieldName },
174 
175 // This macro generates a VMStructEntry line for an unchecked
176 // nonstatic field, in which the size of the type is also specified.
177 // The type string is given as NULL, indicating an &quot;opaque&quot; type.
178 #define GENERATE_UNCHECKED_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, size)    \
179   { QUOTE(typeName), QUOTE(fieldName), NULL, 0, offset_of(typeName, fieldName), NULL },
180 
181 // This macro generates a VMStructEntry line for an unchecked
182 // static field, in which the size of the type is also specified.
183 // The type string is given as NULL, indicating an &quot;opaque&quot; type.
184 #define GENERATE_UNCHECKED_STATIC_VM_STRUCT_ENTRY(typeName, fieldName, size)       \
185  { QUOTE(typeName), QUOTE(fieldName), NULL, 1, 0, (void*) &amp;typeName::fieldName },
186 
187 // This macro generates the sentinel value indicating the end of the list
188 #define GENERATE_VM_STRUCT_LAST_ENTRY() \
189  { NULL, NULL, NULL, 0, 0, NULL }
190 
191 // This macro checks the type of a VMStructEntry by comparing pointer types
192 #define CHECK_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)                 \
193  {typeName *dummyObj = NULL; type* dummy = &amp;dummyObj-&gt;fieldName;                   \
194   assert(offset_of(typeName, fieldName) &lt; sizeof(typeName), &quot;Illegal nonstatic struct entry, field offset too large&quot;); }
195 
196 // This macro checks the type of a volatile VMStructEntry by comparing pointer types
197 #define CHECK_VOLATILE_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)        \
198  {typedef type dummyvtype; typeName *dummyObj = NULL; volatile dummyvtype* dummy = &amp;dummyObj-&gt;fieldName; }
199 
200 // This macro checks the type of a static VMStructEntry by comparing pointer types
201 #define CHECK_STATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)                    \
202  {type* dummy = &amp;typeName::fieldName; }
203 
204 // This macro checks the type of a static pointer volatile VMStructEntry by comparing pointer types,
<span class="line-modified">205 // e.g.: &quot;static ObjectMonitor * volatile g_block_list;&quot;</span>
206 #define CHECK_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY(typeName, fieldName, type)       \
207  {type volatile * dummy = &amp;typeName::fieldName; }
208 
209 // This macro ensures the type of a field and its containing type are
210 // present in the type table. The assertion string is shorter than
211 // preferable because (incredibly) of a bug in Solstice NFS client
212 // which seems to prevent very long lines from compiling. This assertion
213 // means that an entry in VMStructs::localHotSpotVMStructs[] was not
214 // found in VMStructs::localHotSpotVMTypes[].
215 #define ENSURE_FIELD_TYPE_PRESENT(typeName, fieldName, type)                       \
216  { assert(findType(QUOTE(typeName)) != 0, &quot;type \&quot;&quot; QUOTE(typeName) &quot;\&quot; not found in type table&quot;); \
217    assert(findType(QUOTE(type)) != 0, &quot;type \&quot;&quot; QUOTE(type) &quot;\&quot; not found in type table&quot;); }
218 
219 // This is a no-op macro for unchecked fields
220 #define CHECK_NO_OP(a, b, c)
221 
222 
223 //--------------------------------------------------------------------------------
224 // VMTypeEntry macros
225 //
</pre>
</td>
</tr>
</table>
<center><a href="vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmThread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
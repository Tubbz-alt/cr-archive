<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/deoptimization.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="deoptimization.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldDescriptor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/deoptimization.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_DEOPTIMIZATION_HPP
 26 #define SHARE_RUNTIME_DEOPTIMIZATION_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/frame.hpp&quot;
 30 
 31 class ProfileData;
 32 class vframeArray;
 33 class MonitorInfo;
 34 class MonitorValue;
 35 class ObjectValue;

 36 class ScopeValue;
 37 class compiledVFrame;
 38 
 39 template&lt;class E&gt; class GrowableArray;
 40 
 41 class Deoptimization : AllStatic {
 42   friend class VMStructs;
 43 
 44  public:
 45   // What condition caused the deoptimization?
 46   enum DeoptReason {
 47     Reason_many = -1,             // indicates presence of several reasons
 48     Reason_none = 0,              // indicates absence of a relevant deopt.
 49     // Next 8 reasons are recorded per bytecode in DataLayout::trap_bits.
 50     // This is more complicated for JVMCI as JVMCI may deoptimize to *some* bytecode before the
 51     // bytecode that actually caused the deopt (with inlining, JVMCI may even deoptimize to a
 52     // bytecode in another method):
 53     //  - bytecode y in method b() causes deopt
 54     //  - JVMCI deoptimizes to bytecode x in method a()
 55     // -&gt; the deopt reason will be recorded for method a() at bytecode x
 56     Reason_null_check,            // saw unexpected null or zero divisor (@bci)
 57     Reason_null_assert,           // saw unexpected non-null or non-zero (@bci)
 58     Reason_range_check,           // saw unexpected array index (@bci)
 59     Reason_class_check,           // saw unexpected object class (@bci)
 60     Reason_array_check,           // saw unexpected array class (aastore @bci)
 61     Reason_intrinsic,             // saw unexpected operand to intrinsic (@bci)
 62     Reason_bimorphic,             // saw unexpected object class in bimorphic inlining (@bci)
 63 
 64 #if INCLUDE_JVMCI
 65     Reason_unreached0             = Reason_null_assert,
 66     Reason_type_checked_inlining  = Reason_intrinsic,
 67     Reason_optimized_type_check   = Reason_bimorphic,
 68 #endif
 69 
 70     Reason_profile_predicate,     // compiler generated predicate moved from frequent branch in a loop failed
 71 
 72     // recorded per method
 73     Reason_unloaded,              // unloaded class or constant pool entry
 74     Reason_uninitialized,         // bad class state (uninitialized)

 75     Reason_unreached,             // code is not reached, compiler
 76     Reason_unhandled,             // arbitrary compiler limitation
 77     Reason_constraint,            // arbitrary runtime constraint violated
 78     Reason_div0_check,            // a null_check due to division by zero
 79     Reason_age,                   // nmethod too old; tier threshold reached
 80     Reason_predicate,             // compiler generated predicate failed
 81     Reason_loop_limit_check,      // compiler generated loop limits check failed
 82     Reason_speculate_class_check, // saw unexpected object class from type speculation
 83     Reason_speculate_null_check,  // saw unexpected null from type speculation
 84     Reason_speculate_null_assert, // saw unexpected null from type speculation
 85     Reason_rtm_state_change,      // rtm state change detected
 86     Reason_unstable_if,           // a branch predicted always false was taken
 87     Reason_unstable_fused_if,     // fused two ifs that had each one untaken branch. One is now taken.
 88 #if INCLUDE_JVMCI
 89     Reason_aliasing,              // optimistic assumption about aliasing failed
 90     Reason_transfer_to_interpreter, // explicit transferToInterpreter()
 91     Reason_not_compiled_exception_handler,
 92     Reason_unresolved,
 93     Reason_jsr_mismatch,
 94 #endif
</pre>
<hr />
<pre>
118   };
119 
120   enum {
121     _action_bits = 3,
122     _reason_bits = 5,
123     _debug_id_bits = 23,
124     _action_shift = 0,
125     _reason_shift = _action_shift+_action_bits,
126     _debug_id_shift = _reason_shift+_reason_bits,
127     BC_CASE_LIMIT = PRODUCT_ONLY(1) NOT_PRODUCT(4) // for _deoptimization_hist
128   };
129 
130   enum UnpackType {
131     Unpack_deopt                = 0, // normal deoptimization, use pc computed in unpack_vframe_on_stack
132     Unpack_exception            = 1, // exception is pending
133     Unpack_uncommon_trap        = 2, // redo last byte code (C2 only)
134     Unpack_reexecute            = 3, // reexecute bytecode (C1 only)
135     Unpack_LIMIT                = 4
136   };
137 
<span class="line-modified">138   // Checks all compiled methods. Invalid methods are deleted and</span>
<span class="line-modified">139   // corresponding activations are deoptimized.</span>
<span class="line-modified">140   static int deoptimize_dependents();</span>


141 
<span class="line-modified">142   // Deoptimizes a frame lazily. nmethod gets patched deopt happens on return to the frame</span>
<span class="line-modified">143   static void deoptimize(JavaThread* thread, frame fr, RegisterMap *reg_map);</span>
<span class="line-modified">144   static void deoptimize(JavaThread* thread, frame fr, RegisterMap *reg_map, DeoptReason reason);</span>




145 
146 #if INCLUDE_JVMCI
147   static address deoptimize_for_missing_exception_handler(CompiledMethod* cm);

148 #endif
149 
150   private:
151   // Does the actual work for deoptimizing a single frame
152   static void deoptimize_single_frame(JavaThread* thread, frame fr, DeoptReason reason);
153 
<span class="line-removed">154   // Helper function to revoke biases of all monitors in frame if UseBiasedLocking</span>
<span class="line-removed">155   // is enabled</span>
<span class="line-removed">156   static void revoke_biases_of_monitors(JavaThread* thread, frame fr, RegisterMap* map);</span>
<span class="line-removed">157 </span>
158 #if COMPILER2_OR_JVMCI
<span class="line-modified">159 JVMCI_ONLY(public:)</span>
160 
161   // Support for restoring non-escaping objects
<span class="line-modified">162   static bool realloc_objects(JavaThread* thread, frame* fr, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS);</span>
163   static void reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, typeArrayOop obj, BasicType type);
164   static void reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj);
165   static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal);
166   static void relock_objects(GrowableArray&lt;MonitorInfo*&gt;* monitors, JavaThread* thread, bool realloc_failures);
167   static void pop_frames_failed_reallocs(JavaThread* thread, vframeArray* array);
168   NOT_PRODUCT(static void print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures);)
169 #endif // COMPILER2_OR_JVMCI
170 
171   public:
172   static vframeArray* create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures);
173 
174   // Interface used for unpacking deoptimized frames
175 
176   // UnrollBlock is returned by fetch_unroll_info() to the deoptimization handler (blob).
177   // This is only a CheapObj to ease debugging after a deopt failure
178   class UnrollBlock : public CHeapObj&lt;mtCompiler&gt; {
179     friend class VMStructs;
180     friend class JVMCIVMStructs;
181    private:
182     int       _size_of_deoptimized_frame; // Size, in bytes, of current deoptimized frame
</pre>
</td>
<td>
<hr />
<pre>
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_DEOPTIMIZATION_HPP
 26 #define SHARE_RUNTIME_DEOPTIMIZATION_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/frame.hpp&quot;
 30 
 31 class ProfileData;
 32 class vframeArray;
 33 class MonitorInfo;
 34 class MonitorValue;
 35 class ObjectValue;
<span class="line-added"> 36 class AutoBoxObjectValue;</span>
 37 class ScopeValue;
 38 class compiledVFrame;
 39 
 40 template&lt;class E&gt; class GrowableArray;
 41 
 42 class Deoptimization : AllStatic {
 43   friend class VMStructs;
 44 
 45  public:
 46   // What condition caused the deoptimization?
 47   enum DeoptReason {
 48     Reason_many = -1,             // indicates presence of several reasons
 49     Reason_none = 0,              // indicates absence of a relevant deopt.
 50     // Next 8 reasons are recorded per bytecode in DataLayout::trap_bits.
 51     // This is more complicated for JVMCI as JVMCI may deoptimize to *some* bytecode before the
 52     // bytecode that actually caused the deopt (with inlining, JVMCI may even deoptimize to a
 53     // bytecode in another method):
 54     //  - bytecode y in method b() causes deopt
 55     //  - JVMCI deoptimizes to bytecode x in method a()
 56     // -&gt; the deopt reason will be recorded for method a() at bytecode x
 57     Reason_null_check,            // saw unexpected null or zero divisor (@bci)
 58     Reason_null_assert,           // saw unexpected non-null or non-zero (@bci)
 59     Reason_range_check,           // saw unexpected array index (@bci)
 60     Reason_class_check,           // saw unexpected object class (@bci)
 61     Reason_array_check,           // saw unexpected array class (aastore @bci)
 62     Reason_intrinsic,             // saw unexpected operand to intrinsic (@bci)
 63     Reason_bimorphic,             // saw unexpected object class in bimorphic inlining (@bci)
 64 
 65 #if INCLUDE_JVMCI
 66     Reason_unreached0             = Reason_null_assert,
 67     Reason_type_checked_inlining  = Reason_intrinsic,
 68     Reason_optimized_type_check   = Reason_bimorphic,
 69 #endif
 70 
 71     Reason_profile_predicate,     // compiler generated predicate moved from frequent branch in a loop failed
 72 
 73     // recorded per method
 74     Reason_unloaded,              // unloaded class or constant pool entry
 75     Reason_uninitialized,         // bad class state (uninitialized)
<span class="line-added"> 76     Reason_initialized,           // class has been fully initialized</span>
 77     Reason_unreached,             // code is not reached, compiler
 78     Reason_unhandled,             // arbitrary compiler limitation
 79     Reason_constraint,            // arbitrary runtime constraint violated
 80     Reason_div0_check,            // a null_check due to division by zero
 81     Reason_age,                   // nmethod too old; tier threshold reached
 82     Reason_predicate,             // compiler generated predicate failed
 83     Reason_loop_limit_check,      // compiler generated loop limits check failed
 84     Reason_speculate_class_check, // saw unexpected object class from type speculation
 85     Reason_speculate_null_check,  // saw unexpected null from type speculation
 86     Reason_speculate_null_assert, // saw unexpected null from type speculation
 87     Reason_rtm_state_change,      // rtm state change detected
 88     Reason_unstable_if,           // a branch predicted always false was taken
 89     Reason_unstable_fused_if,     // fused two ifs that had each one untaken branch. One is now taken.
 90 #if INCLUDE_JVMCI
 91     Reason_aliasing,              // optimistic assumption about aliasing failed
 92     Reason_transfer_to_interpreter, // explicit transferToInterpreter()
 93     Reason_not_compiled_exception_handler,
 94     Reason_unresolved,
 95     Reason_jsr_mismatch,
 96 #endif
</pre>
<hr />
<pre>
120   };
121 
122   enum {
123     _action_bits = 3,
124     _reason_bits = 5,
125     _debug_id_bits = 23,
126     _action_shift = 0,
127     _reason_shift = _action_shift+_action_bits,
128     _debug_id_shift = _reason_shift+_reason_bits,
129     BC_CASE_LIMIT = PRODUCT_ONLY(1) NOT_PRODUCT(4) // for _deoptimization_hist
130   };
131 
132   enum UnpackType {
133     Unpack_deopt                = 0, // normal deoptimization, use pc computed in unpack_vframe_on_stack
134     Unpack_exception            = 1, // exception is pending
135     Unpack_uncommon_trap        = 2, // redo last byte code (C2 only)
136     Unpack_reexecute            = 3, // reexecute bytecode (C1 only)
137     Unpack_LIMIT                = 4
138   };
139 
<span class="line-modified">140   // Make all nmethods that are marked_for_deoptimization not_entrant and deoptimize any live</span>
<span class="line-modified">141   // activations using those nmethods.  If an nmethod is passed as an argument then it is</span>
<span class="line-modified">142   // marked_for_deoptimization and made not_entrant.  Otherwise a scan of the code cache is done to</span>
<span class="line-added">143   // find all marked nmethods and they are made not_entrant.</span>
<span class="line-added">144   static void deoptimize_all_marked(nmethod* nmethod_only = NULL);</span>
145 
<span class="line-modified">146  private:</span>
<span class="line-modified">147   // Revoke biased locks at deopt.</span>
<span class="line-modified">148   static void revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map);</span>
<span class="line-added">149 </span>
<span class="line-added">150  public:</span>
<span class="line-added">151   // Deoptimizes a frame lazily. Deopt happens on return to the frame.</span>
<span class="line-added">152   static void deoptimize(JavaThread* thread, frame fr, DeoptReason reason = Reason_constraint);</span>
153 
154 #if INCLUDE_JVMCI
155   static address deoptimize_for_missing_exception_handler(CompiledMethod* cm);
<span class="line-added">156   static oop get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, TRAPS);</span>
157 #endif
158 
159   private:
160   // Does the actual work for deoptimizing a single frame
161   static void deoptimize_single_frame(JavaThread* thread, frame fr, DeoptReason reason);
162 




163 #if COMPILER2_OR_JVMCI
<span class="line-modified">164  public:</span>
165 
166   // Support for restoring non-escaping objects
<span class="line-modified">167   static bool realloc_objects(JavaThread* thread, frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS);</span>
168   static void reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, typeArrayOop obj, BasicType type);
169   static void reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj);
170   static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal);
171   static void relock_objects(GrowableArray&lt;MonitorInfo*&gt;* monitors, JavaThread* thread, bool realloc_failures);
172   static void pop_frames_failed_reallocs(JavaThread* thread, vframeArray* array);
173   NOT_PRODUCT(static void print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures);)
174 #endif // COMPILER2_OR_JVMCI
175 
176   public:
177   static vframeArray* create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures);
178 
179   // Interface used for unpacking deoptimized frames
180 
181   // UnrollBlock is returned by fetch_unroll_info() to the deoptimization handler (blob).
182   // This is only a CheapObj to ease debugging after a deopt failure
183   class UnrollBlock : public CHeapObj&lt;mtCompiler&gt; {
184     friend class VMStructs;
185     friend class JVMCIVMStructs;
186    private:
187     int       _size_of_deoptimized_frame; // Size, in bytes, of current deoptimized frame
</pre>
</td>
</tr>
</table>
<center><a href="deoptimization.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldDescriptor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
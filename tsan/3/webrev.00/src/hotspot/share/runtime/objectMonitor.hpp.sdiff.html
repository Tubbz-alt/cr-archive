<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/objectMonitor.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="objectMonitor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objectMonitor.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/objectMonitor.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_OBJECTMONITOR_HPP
 26 #define SHARE_RUNTIME_OBJECTMONITOR_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/padded.hpp&quot;

 30 #include &quot;runtime/os.hpp&quot;
 31 #include &quot;runtime/park.hpp&quot;
 32 #include &quot;runtime/perfData.hpp&quot;
 33 
 34 class ObjectMonitor;
 35 
 36 // ObjectWaiter serves as a &quot;proxy&quot; or surrogate thread.
 37 // TODO-FIXME: Eliminate ObjectWaiter and use the thread-specific
 38 // ParkEvent instead.  Beware, however, that the JVMTI code
 39 // knows about ObjectWaiters, so we&#39;ll have to reconcile that code.
 40 // See next_waiter(), first_waiter(), etc.
 41 
 42 class ObjectWaiter : public StackObj {
 43  public:
 44   enum TStates { TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ };
<span class="line-modified"> 45   enum Sorted  { PREPEND, APPEND, SORTED };</span>
<span class="line-modified"> 46   ObjectWaiter * volatile _next;</span>
<span class="line-removed"> 47   ObjectWaiter * volatile _prev;</span>
 48   Thread*       _thread;
 49   jlong         _notifier_tid;
 50   ParkEvent *   _event;
 51   volatile int  _notified;
 52   volatile TStates TState;
<span class="line-removed"> 53   Sorted        _Sorted;           // List placement disposition</span>
 54   bool          _active;           // Contention monitoring is enabled
 55  public:
 56   ObjectWaiter(Thread* thread);
 57 
 58   void wait_reenter_begin(ObjectMonitor *mon);
 59   void wait_reenter_end(ObjectMonitor *mon);
 60 };
 61 
 62 // The ObjectMonitor class implements the heavyweight version of a
 63 // JavaMonitor. The lightweight BasicLock/stack lock version has been
 64 // inflated into an ObjectMonitor. This inflation is typically due to
 65 // contention or use of Object.wait().
 66 //
 67 // WARNING: This is a very sensitive and fragile class. DO NOT make any
 68 // changes unless you are fully aware of the underlying semantics.
 69 //
<span class="line-removed"> 70 // Class JvmtiRawMonitor currently inherits from ObjectMonitor so</span>
<span class="line-removed"> 71 // changes in this class must be careful to not break JvmtiRawMonitor.</span>
<span class="line-removed"> 72 // These two subsystems should be separated.</span>
<span class="line-removed"> 73 //</span>
 74 // ObjectMonitor Layout Overview/Highlights/Restrictions:
 75 //
 76 // - The _header field must be at offset 0 because the displaced header
<span class="line-modified"> 77 //   from markOop is stored there. We do not want markOop.hpp to include</span>
 78 //   ObjectMonitor.hpp to avoid exposing ObjectMonitor everywhere. This
 79 //   means that ObjectMonitor cannot inherit from any other class nor can
 80 //   it use any virtual member functions. This restriction is critical to
 81 //   the proper functioning of the VM.
 82 // - The _header and _owner fields should be separated by enough space
 83 //   to avoid false sharing due to parallel access by different threads.
 84 //   This is an advisory recommendation.
 85 // - The general layout of the fields in ObjectMonitor is:
 86 //     _header
 87 //     &lt;lightly_used_fields&gt;
 88 //     &lt;optional padding&gt;
 89 //     _owner
 90 //     &lt;remaining_fields&gt;
 91 // - The VM assumes write ordering and machine word alignment with
 92 //   respect to the _owner field and the &lt;remaining_fields&gt; that can
 93 //   be read in parallel by other threads.
 94 // - Generally fields that are accessed closely together in time should
 95 //   be placed proximally in space to promote data cache locality. That
 96 //   is, temporal locality should condition spatial locality.
 97 // - We have to balance avoiding false sharing with excessive invalidation
</pre>
<hr />
<pre>
108 // - Adjacent ObjectMonitors should be separated by enough space to avoid
109 //   false sharing. This is handled by the ObjectMonitor allocation code
110 //   in synchronizer.cpp. Also see TEST_VM(SynchronizerTest, sanity) gtest.
111 //
112 // Futures notes:
113 //   - Separating _owner from the &lt;remaining_fields&gt; by enough space to
114 //     avoid false sharing might be profitable. Given
115 //     http://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate
116 //     we know that the CAS in monitorenter will invalidate the line
117 //     underlying _owner. We want to avoid an L1 data cache miss on that
118 //     same line for monitorexit. Putting these &lt;remaining_fields&gt;:
119 //     _recursions, _EntryList, _cxq, and _succ, all of which may be
120 //     fetched in the inflated unlock path, on a different cache line
121 //     would make them immune to CAS-based invalidation from the _owner
122 //     field.
123 //
124 //   - The _recursions field should be of type int, or int32_t but not
125 //     intptr_t. There&#39;s no reason to use a 64-bit type for this field
126 //     in a 64-bit JVM.
127 
<span class="line-modified">128 class ObjectMonitor {</span>
<span class="line-modified">129  public:</span>
<span class="line-modified">130   enum {</span>
<span class="line-modified">131     OM_OK,                    // no error</span>
<span class="line-modified">132     OM_SYSTEM_ERROR,          // operating system error</span>
<span class="line-removed">133     OM_ILLEGAL_MONITOR_STATE, // IllegalMonitorStateException</span>
<span class="line-removed">134     OM_INTERRUPTED,           // Thread.interrupt()</span>
<span class="line-removed">135     OM_TIMED_OUT              // Object.wait() timed out</span>
<span class="line-removed">136   };</span>
137 
<span class="line-modified">138  private:</span>
139   friend class ObjectSynchronizer;
140   friend class ObjectWaiter;
141   friend class VMStructs;

142 
<span class="line-modified">143   volatile markOop   _header;       // displaced object header word - mark</span>
<span class="line-modified">144   void*     volatile _object;       // backward object pointer - strong root</span>
<span class="line-modified">145  public:</span>
<span class="line-modified">146   ObjectMonitor*     FreeNext;      // Free list linkage</span>
147  private:
<span class="line-modified">148   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE,</span>
<span class="line-modified">149                         sizeof(volatile markOop) + sizeof(void * volatile) +</span>
<span class="line-modified">150                         sizeof(ObjectMonitor *));</span>
<span class="line-modified">151  protected:                         // protected for JvmtiRawMonitor</span>
<span class="line-modified">152   void *  volatile _owner;          // pointer to owning thread OR BasicLock</span>


153   volatile jlong _previous_owner_tid;  // thread id of the previous owner of the monitor
<span class="line-modified">154   volatile intptr_t  _recursions;   // recursion count, 0 for first entry</span>
<span class="line-modified">155   ObjectWaiter * volatile _EntryList; // Threads blocked on entry or reentry.</span>







156                                       // The list is actually composed of WaitNodes,
157                                       // acting as proxies for Threads.
<span class="line-modified">158  private:</span>
<span class="line-modified">159   ObjectWaiter * volatile _cxq;     // LL of recently-arrived threads blocked on entry.</span>
<span class="line-modified">160   Thread * volatile _succ;          // Heir presumptive thread - used for futile wakeup throttling</span>
<span class="line-modified">161   Thread * volatile _Responsible;</span>
162 
163   volatile int _Spinner;            // for exit-&gt;spinner handoff optimization
164   volatile int _SpinDuration;
165 
<span class="line-modified">166   volatile jint  _count;            // reference count to prevent reclamation/deflation</span>
<span class="line-modified">167                                     // at stop-the-world time. See ObjectSynchronizer::deflate_monitor().</span>
<span class="line-modified">168                                     // _count is approximately |_WaitSet| + |_EntryList|</span>
169  protected:
<span class="line-modified">170   ObjectWaiter * volatile _WaitSet; // LL of threads wait()ing on the monitor</span>
171   volatile jint  _waiters;          // number of waiting threads
172  private:
173   volatile int _WaitSetLock;        // protects Wait Queue - simple spinlock
174 
175  public:
176   static void Initialize();
177 
178   // Only perform a PerfData operation if the PerfData object has been
179   // allocated and if the PerfDataManager has not freed the PerfData
180   // objects which can happen at normal VM shutdown.
181   //
182   #define OM_PERFDATA_OP(f, op_str)              \
183     do {                                         \
184       if (ObjectMonitor::_sync_ ## f != NULL &amp;&amp;  \
185           PerfDataManager::has_PerfData()) {     \
186         ObjectMonitor::_sync_ ## f-&gt;op_str;      \
187       }                                          \
188     } while (0)
189 
190   static PerfCounter * _sync_ContendedLockAttempts;
191   static PerfCounter * _sync_FutileWakeups;
192   static PerfCounter * _sync_Parks;
193   static PerfCounter * _sync_Notifications;
194   static PerfCounter * _sync_Inflations;
195   static PerfCounter * _sync_Deflations;
196   static PerfLongVariable * _sync_MonExtant;
197 
198   static int Knob_SpinLimit;
199 
200   void* operator new (size_t size) throw();
201   void* operator new[] (size_t size) throw();
202   void operator delete(void* p);
<span class="line-modified">203   void operator delete[] (void *p);</span>
204 
205   // TODO-FIXME: the &quot;offset&quot; routines should return a type of off_t instead of int ...
206   // ByteSize would also be an appropriate type.
207   static int header_offset_in_bytes()      { return offset_of(ObjectMonitor, _header); }
208   static int object_offset_in_bytes()      { return offset_of(ObjectMonitor, _object); }
209   static int owner_offset_in_bytes()       { return offset_of(ObjectMonitor, _owner); }
<span class="line-removed">210   static int count_offset_in_bytes()       { return offset_of(ObjectMonitor, _count); }</span>
211   static int recursions_offset_in_bytes()  { return offset_of(ObjectMonitor, _recursions); }
212   static int cxq_offset_in_bytes()         { return offset_of(ObjectMonitor, _cxq); }
213   static int succ_offset_in_bytes()        { return offset_of(ObjectMonitor, _succ); }
214   static int EntryList_offset_in_bytes()   { return offset_of(ObjectMonitor, _EntryList); }
215 
<span class="line-modified">216   // ObjectMonitor references can be ORed with markOopDesc::monitor_value</span>
217   // as part of the ObjectMonitor tagging mechanism. When we combine an
218   // ObjectMonitor reference with an offset, we need to remove the tag
219   // value in order to generate the proper address.
220   //
221   // We can either adjust the ObjectMonitor reference and then add the
222   // offset or we can adjust the offset that is added to the ObjectMonitor
223   // reference. The latter avoids an AGI (Address Generation Interlock)
224   // stall so the helper macro adjusts the offset value that is returned
225   // to the ObjectMonitor reference manipulation code:
226   //
227   #define OM_OFFSET_NO_MONITOR_VALUE_TAG(f) \
<span class="line-modified">228     ((ObjectMonitor::f ## _offset_in_bytes()) - markOopDesc::monitor_value)</span>
229 
<span class="line-modified">230   markOop   header() const;</span>
<span class="line-modified">231   volatile markOop* header_addr();</span>
<span class="line-modified">232   void      set_header(markOop hdr);</span>
233 
234   intptr_t is_busy() const {
<span class="line-removed">235     // TODO-FIXME: merge _count and _waiters.</span>
236     // TODO-FIXME: assert _owner == null implies _recursions = 0
<span class="line-modified">237     // TODO-FIXME: assert _WaitSet != null implies _count &gt; 0</span>
<span class="line-removed">238     return _count|_waiters|intptr_t(_owner)|intptr_t(_cxq)|intptr_t(_EntryList);</span>
239   }

240 
241   intptr_t  is_entered(Thread* current) const;
242 
243   void*     owner() const;
<span class="line-modified">244   void      set_owner(void* owner);</span>

















245 
246   jint      waiters() const;
247 
<span class="line-removed">248   jint      count() const;</span>
<span class="line-removed">249   void      set_count(jint count);</span>
250   jint      contentions() const;
<span class="line-modified">251   intptr_t  recursions() const                                         { return _recursions; }</span>
252 
253   // JVM/TI GetObjectMonitorUsage() needs this:
254   ObjectWaiter* first_waiter()                                         { return _WaitSet; }
255   ObjectWaiter* next_waiter(ObjectWaiter* o)                           { return o-&gt;_next; }
256   Thread* thread_of_waiter(ObjectWaiter* o)                            { return o-&gt;_thread; }
257 
258  protected:
259   // We don&#39;t typically expect or want the ctors or dtors to run.
260   // normal ObjectMonitors are type-stable and immortal.
<span class="line-modified">261   ObjectMonitor() { ::memset((void *)this, 0, sizeof(*this)); }</span>
262 
263   ~ObjectMonitor() {
264     // TODO: Add asserts ...
265     // _cxq == 0 _succ == NULL _owner == NULL _waiters == 0
<span class="line-modified">266     // _count == 0 _EntryList  == NULL etc</span>
267   }
268 
269  private:
270   void Recycle() {
271     // TODO: add stronger asserts ...
272     // _cxq == 0 _succ == NULL _owner == NULL _waiters == 0
<span class="line-modified">273     // _count == 0 EntryList  == NULL</span>
274     // _recursions == 0 _WaitSet == NULL
<span class="line-modified">275     assert(((is_busy()|_recursions) == 0), &quot;freeing inuse monitor&quot;);</span>


276     _succ          = NULL;
277     _EntryList     = NULL;
278     _cxq           = NULL;
279     _WaitSet       = NULL;
280     _recursions    = 0;
281   }
282 
283  public:
284 
285   void*     object() const;
286   void*     object_addr();
287   void      set_object(void* obj);
288 
<span class="line-modified">289   bool      check(TRAPS);       // true if the thread owns the monitor.</span>
<span class="line-modified">290   void      check_slow(TRAPS);</span>

291   void      clear();
292 
293   void      enter(TRAPS);
294   void      exit(bool not_suspended, TRAPS);
295   void      wait(jlong millis, bool interruptable, TRAPS);
296   void      notify(TRAPS);
297   void      notifyAll(TRAPS);
298 






299 // Use the following at your own risk
<span class="line-modified">300   intptr_t  complete_exit(TRAPS);</span>
<span class="line-modified">301   void      reenter(intptr_t recursions, TRAPS);</span>
302 
303  private:
<span class="line-modified">304   void      AddWaiter(ObjectWaiter * waiter);</span>
<span class="line-modified">305   void      INotify(Thread * Self);</span>
<span class="line-modified">306   ObjectWaiter * DequeueWaiter();</span>
<span class="line-modified">307   void      DequeueSpecificWaiter(ObjectWaiter * waiter);</span>
308   void      EnterI(TRAPS);
<span class="line-modified">309   void      ReenterI(Thread * Self, ObjectWaiter * SelfNode);</span>
<span class="line-modified">310   void      UnlinkAfterAcquire(Thread * Self, ObjectWaiter * SelfNode);</span>
<span class="line-modified">311   int       TryLock(Thread * Self);</span>
<span class="line-modified">312   int       NotRunnable(Thread * Self, Thread * Owner);</span>
<span class="line-modified">313   int       TrySpin(Thread * Self);</span>
<span class="line-modified">314   void      ExitEpilog(Thread * Self, ObjectWaiter * Wakee);</span>
<span class="line-modified">315   bool      ExitSuspendEquivalent(JavaThread * Self);</span>
316 };
317 
318 #endif // SHARE_RUNTIME_OBJECTMONITOR_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_OBJECTMONITOR_HPP
 26 #define SHARE_RUNTIME_OBJECTMONITOR_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/padded.hpp&quot;
<span class="line-added"> 30 #include &quot;oops/markWord.hpp&quot;</span>
 31 #include &quot;runtime/os.hpp&quot;
 32 #include &quot;runtime/park.hpp&quot;
 33 #include &quot;runtime/perfData.hpp&quot;
 34 
 35 class ObjectMonitor;
 36 
 37 // ObjectWaiter serves as a &quot;proxy&quot; or surrogate thread.
 38 // TODO-FIXME: Eliminate ObjectWaiter and use the thread-specific
 39 // ParkEvent instead.  Beware, however, that the JVMTI code
 40 // knows about ObjectWaiters, so we&#39;ll have to reconcile that code.
 41 // See next_waiter(), first_waiter(), etc.
 42 
 43 class ObjectWaiter : public StackObj {
 44  public:
 45   enum TStates { TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ };
<span class="line-modified"> 46   ObjectWaiter* volatile _next;</span>
<span class="line-modified"> 47   ObjectWaiter* volatile _prev;</span>

 48   Thread*       _thread;
 49   jlong         _notifier_tid;
 50   ParkEvent *   _event;
 51   volatile int  _notified;
 52   volatile TStates TState;

 53   bool          _active;           // Contention monitoring is enabled
 54  public:
 55   ObjectWaiter(Thread* thread);
 56 
 57   void wait_reenter_begin(ObjectMonitor *mon);
 58   void wait_reenter_end(ObjectMonitor *mon);
 59 };
 60 
 61 // The ObjectMonitor class implements the heavyweight version of a
 62 // JavaMonitor. The lightweight BasicLock/stack lock version has been
 63 // inflated into an ObjectMonitor. This inflation is typically due to
 64 // contention or use of Object.wait().
 65 //
 66 // WARNING: This is a very sensitive and fragile class. DO NOT make any
 67 // changes unless you are fully aware of the underlying semantics.
 68 //




 69 // ObjectMonitor Layout Overview/Highlights/Restrictions:
 70 //
 71 // - The _header field must be at offset 0 because the displaced header
<span class="line-modified"> 72 //   from markWord is stored there. We do not want markWord.hpp to include</span>
 73 //   ObjectMonitor.hpp to avoid exposing ObjectMonitor everywhere. This
 74 //   means that ObjectMonitor cannot inherit from any other class nor can
 75 //   it use any virtual member functions. This restriction is critical to
 76 //   the proper functioning of the VM.
 77 // - The _header and _owner fields should be separated by enough space
 78 //   to avoid false sharing due to parallel access by different threads.
 79 //   This is an advisory recommendation.
 80 // - The general layout of the fields in ObjectMonitor is:
 81 //     _header
 82 //     &lt;lightly_used_fields&gt;
 83 //     &lt;optional padding&gt;
 84 //     _owner
 85 //     &lt;remaining_fields&gt;
 86 // - The VM assumes write ordering and machine word alignment with
 87 //   respect to the _owner field and the &lt;remaining_fields&gt; that can
 88 //   be read in parallel by other threads.
 89 // - Generally fields that are accessed closely together in time should
 90 //   be placed proximally in space to promote data cache locality. That
 91 //   is, temporal locality should condition spatial locality.
 92 // - We have to balance avoiding false sharing with excessive invalidation
</pre>
<hr />
<pre>
103 // - Adjacent ObjectMonitors should be separated by enough space to avoid
104 //   false sharing. This is handled by the ObjectMonitor allocation code
105 //   in synchronizer.cpp. Also see TEST_VM(SynchronizerTest, sanity) gtest.
106 //
107 // Futures notes:
108 //   - Separating _owner from the &lt;remaining_fields&gt; by enough space to
109 //     avoid false sharing might be profitable. Given
110 //     http://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate
111 //     we know that the CAS in monitorenter will invalidate the line
112 //     underlying _owner. We want to avoid an L1 data cache miss on that
113 //     same line for monitorexit. Putting these &lt;remaining_fields&gt;:
114 //     _recursions, _EntryList, _cxq, and _succ, all of which may be
115 //     fetched in the inflated unlock path, on a different cache line
116 //     would make them immune to CAS-based invalidation from the _owner
117 //     field.
118 //
119 //   - The _recursions field should be of type int, or int32_t but not
120 //     intptr_t. There&#39;s no reason to use a 64-bit type for this field
121 //     in a 64-bit JVM.
122 
<span class="line-modified">123 #ifndef OM_CACHE_LINE_SIZE</span>
<span class="line-modified">124 // Use DEFAULT_CACHE_LINE_SIZE if not already specified for</span>
<span class="line-modified">125 // the current build platform.</span>
<span class="line-modified">126 #define OM_CACHE_LINE_SIZE DEFAULT_CACHE_LINE_SIZE</span>
<span class="line-modified">127 #endif</span>




128 
<span class="line-modified">129 class ObjectMonitor {</span>
130   friend class ObjectSynchronizer;
131   friend class ObjectWaiter;
132   friend class VMStructs;
<span class="line-added">133   JVMCI_ONLY(friend class JVMCIVMStructs;)</span>
134 
<span class="line-modified">135   // The sync code expects the header field to be at offset zero (0).</span>
<span class="line-modified">136   // Enforced by the assert() in header_addr().</span>
<span class="line-modified">137   volatile markWord _header;        // displaced object header word - mark</span>
<span class="line-modified">138   void* volatile _object;           // backward object pointer - strong root</span>
139  private:
<span class="line-modified">140   // Separate _header and _owner on different cache lines since both can</span>
<span class="line-modified">141   // have busy multi-threaded access. _header and _object are set at</span>
<span class="line-modified">142   // initial inflation and _object doesn&#39;t change until deflation so</span>
<span class="line-modified">143   // _object is a good choice to share the cache line with _header.</span>
<span class="line-modified">144   DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE,</span>
<span class="line-added">145                         sizeof(volatile markWord) + sizeof(void* volatile));</span>
<span class="line-added">146   void* volatile _owner;            // pointer to owning thread OR BasicLock</span>
147   volatile jlong _previous_owner_tid;  // thread id of the previous owner of the monitor
<span class="line-modified">148   // Separate _owner and _next_om on different cache lines since</span>
<span class="line-modified">149   // both can have busy multi-threaded access. _previous_owner_tid is only</span>
<span class="line-added">150   // changed by ObjectMonitor::exit() so it is a good choice to share the</span>
<span class="line-added">151   // cache line with _owner.</span>
<span class="line-added">152   DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(void* volatile) +</span>
<span class="line-added">153                         sizeof(volatile jlong));</span>
<span class="line-added">154   ObjectMonitor* _next_om;          // Next ObjectMonitor* linkage</span>
<span class="line-added">155   volatile intx _recursions;        // recursion count, 0 for first entry</span>
<span class="line-added">156   ObjectWaiter* volatile _EntryList;  // Threads blocked on entry or reentry.</span>
157                                       // The list is actually composed of WaitNodes,
158                                       // acting as proxies for Threads.
<span class="line-modified">159 </span>
<span class="line-modified">160   ObjectWaiter* volatile _cxq;      // LL of recently-arrived threads blocked on entry.</span>
<span class="line-modified">161   Thread* volatile _succ;           // Heir presumptive thread - used for futile wakeup throttling</span>
<span class="line-modified">162   Thread* volatile _Responsible;</span>
163 
164   volatile int _Spinner;            // for exit-&gt;spinner handoff optimization
165   volatile int _SpinDuration;
166 
<span class="line-modified">167   volatile jint  _contentions;      // Number of active contentions in enter(). It is used by is_busy()</span>
<span class="line-modified">168                                     // along with other fields to determine if an ObjectMonitor can be</span>
<span class="line-modified">169                                     // deflated. See ObjectSynchronizer::deflate_monitor().</span>
170  protected:
<span class="line-modified">171   ObjectWaiter* volatile _WaitSet;  // LL of threads wait()ing on the monitor</span>
172   volatile jint  _waiters;          // number of waiting threads
173  private:
174   volatile int _WaitSetLock;        // protects Wait Queue - simple spinlock
175 
176  public:
177   static void Initialize();
178 
179   // Only perform a PerfData operation if the PerfData object has been
180   // allocated and if the PerfDataManager has not freed the PerfData
181   // objects which can happen at normal VM shutdown.
182   //
183   #define OM_PERFDATA_OP(f, op_str)              \
184     do {                                         \
185       if (ObjectMonitor::_sync_ ## f != NULL &amp;&amp;  \
186           PerfDataManager::has_PerfData()) {     \
187         ObjectMonitor::_sync_ ## f-&gt;op_str;      \
188       }                                          \
189     } while (0)
190 
191   static PerfCounter * _sync_ContendedLockAttempts;
192   static PerfCounter * _sync_FutileWakeups;
193   static PerfCounter * _sync_Parks;
194   static PerfCounter * _sync_Notifications;
195   static PerfCounter * _sync_Inflations;
196   static PerfCounter * _sync_Deflations;
197   static PerfLongVariable * _sync_MonExtant;
198 
199   static int Knob_SpinLimit;
200 
201   void* operator new (size_t size) throw();
202   void* operator new[] (size_t size) throw();
203   void operator delete(void* p);
<span class="line-modified">204   void operator delete[] (void* p);</span>
205 
206   // TODO-FIXME: the &quot;offset&quot; routines should return a type of off_t instead of int ...
207   // ByteSize would also be an appropriate type.
208   static int header_offset_in_bytes()      { return offset_of(ObjectMonitor, _header); }
209   static int object_offset_in_bytes()      { return offset_of(ObjectMonitor, _object); }
210   static int owner_offset_in_bytes()       { return offset_of(ObjectMonitor, _owner); }

211   static int recursions_offset_in_bytes()  { return offset_of(ObjectMonitor, _recursions); }
212   static int cxq_offset_in_bytes()         { return offset_of(ObjectMonitor, _cxq); }
213   static int succ_offset_in_bytes()        { return offset_of(ObjectMonitor, _succ); }
214   static int EntryList_offset_in_bytes()   { return offset_of(ObjectMonitor, _EntryList); }
215 
<span class="line-modified">216   // ObjectMonitor references can be ORed with markWord::monitor_value</span>
217   // as part of the ObjectMonitor tagging mechanism. When we combine an
218   // ObjectMonitor reference with an offset, we need to remove the tag
219   // value in order to generate the proper address.
220   //
221   // We can either adjust the ObjectMonitor reference and then add the
222   // offset or we can adjust the offset that is added to the ObjectMonitor
223   // reference. The latter avoids an AGI (Address Generation Interlock)
224   // stall so the helper macro adjusts the offset value that is returned
225   // to the ObjectMonitor reference manipulation code:
226   //
227   #define OM_OFFSET_NO_MONITOR_VALUE_TAG(f) \
<span class="line-modified">228     ((ObjectMonitor::f ## _offset_in_bytes()) - markWord::monitor_value)</span>
229 
<span class="line-modified">230   markWord           header() const;</span>
<span class="line-modified">231   volatile markWord* header_addr();</span>
<span class="line-modified">232   void               set_header(markWord hdr);</span>
233 
234   intptr_t is_busy() const {

235     // TODO-FIXME: assert _owner == null implies _recursions = 0
<span class="line-modified">236     return _contentions|_waiters|intptr_t(_owner)|intptr_t(_cxq)|intptr_t(_EntryList);</span>

237   }
<span class="line-added">238   const char* is_busy_to_string(stringStream* ss);</span>
239 
240   intptr_t  is_entered(Thread* current) const;
241 
242   void*     owner() const;
<span class="line-modified">243   // Clear _owner field; current value must match old_value.</span>
<span class="line-added">244   void      release_clear_owner(void* old_value);</span>
<span class="line-added">245   // Simply set _owner field to new_value; current value must match old_value.</span>
<span class="line-added">246   void      set_owner_from(void* old_value, void* new_value);</span>
<span class="line-added">247   // Simply set _owner field to self; current value must match basic_lock_p.</span>
<span class="line-added">248   void      set_owner_from_BasicLock(void* basic_lock_p, Thread* self);</span>
<span class="line-added">249   // Try to set _owner field to new_value if the current value matches</span>
<span class="line-added">250   // old_value, using Atomic::cmpxchg(). Otherwise, does not change the</span>
<span class="line-added">251   // _owner field. Returns the prior value of the _owner field.</span>
<span class="line-added">252   void*     try_set_owner_from(void* old_value, void* new_value);</span>
<span class="line-added">253 </span>
<span class="line-added">254   ObjectMonitor* next_om() const;</span>
<span class="line-added">255   // Simply set _next_om field to new_value.</span>
<span class="line-added">256   void set_next_om(ObjectMonitor* new_value);</span>
<span class="line-added">257   // Try to set _next_om field to new_value if the current value matches</span>
<span class="line-added">258   // old_value, using Atomic::cmpxchg(). Otherwise, does not change the</span>
<span class="line-added">259   // _next_om field. Returns the prior value of the _next_om field.</span>
<span class="line-added">260   ObjectMonitor* try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value);</span>
261 
262   jint      waiters() const;
263 


264   jint      contentions() const;
<span class="line-modified">265   intx      recursions() const                                         { return _recursions; }</span>
266 
267   // JVM/TI GetObjectMonitorUsage() needs this:
268   ObjectWaiter* first_waiter()                                         { return _WaitSet; }
269   ObjectWaiter* next_waiter(ObjectWaiter* o)                           { return o-&gt;_next; }
270   Thread* thread_of_waiter(ObjectWaiter* o)                            { return o-&gt;_thread; }
271 
272  protected:
273   // We don&#39;t typically expect or want the ctors or dtors to run.
274   // normal ObjectMonitors are type-stable and immortal.
<span class="line-modified">275   ObjectMonitor() { ::memset((void*)this, 0, sizeof(*this)); }</span>
276 
277   ~ObjectMonitor() {
278     // TODO: Add asserts ...
279     // _cxq == 0 _succ == NULL _owner == NULL _waiters == 0
<span class="line-modified">280     // _contentions == 0 _EntryList  == NULL etc</span>
281   }
282 
283  private:
284   void Recycle() {
285     // TODO: add stronger asserts ...
286     // _cxq == 0 _succ == NULL _owner == NULL _waiters == 0
<span class="line-modified">287     // _contentions == 0 EntryList  == NULL</span>
288     // _recursions == 0 _WaitSet == NULL
<span class="line-modified">289     DEBUG_ONLY(stringStream ss;)</span>
<span class="line-added">290     assert((is_busy() | _recursions) == 0, &quot;freeing in-use monitor: %s, &quot;</span>
<span class="line-added">291            &quot;recursions=&quot; INTX_FORMAT, is_busy_to_string(&amp;ss), _recursions);</span>
292     _succ          = NULL;
293     _EntryList     = NULL;
294     _cxq           = NULL;
295     _WaitSet       = NULL;
296     _recursions    = 0;
297   }
298 
299  public:
300 
301   void*     object() const;
302   void*     object_addr();
303   void      set_object(void* obj);
304 
<span class="line-modified">305   // Returns true if the specified thread owns the ObjectMonitor. Otherwise</span>
<span class="line-modified">306   // returns false and throws IllegalMonitorStateException (IMSE).</span>
<span class="line-added">307   bool      check_owner(Thread* THREAD);</span>
308   void      clear();
309 
310   void      enter(TRAPS);
311   void      exit(bool not_suspended, TRAPS);
312   void      wait(jlong millis, bool interruptable, TRAPS);
313   void      notify(TRAPS);
314   void      notifyAll(TRAPS);
315 
<span class="line-added">316   void      print() const;</span>
<span class="line-added">317 #ifdef ASSERT</span>
<span class="line-added">318   void      print_debug_style_on(outputStream* st) const;</span>
<span class="line-added">319 #endif</span>
<span class="line-added">320   void      print_on(outputStream* st) const;</span>
<span class="line-added">321 </span>
322 // Use the following at your own risk
<span class="line-modified">323   intx      complete_exit(TRAPS);</span>
<span class="line-modified">324   void      reenter(intx recursions, TRAPS);</span>
325 
326  private:
<span class="line-modified">327   void      AddWaiter(ObjectWaiter* waiter);</span>
<span class="line-modified">328   void      INotify(Thread* self);</span>
<span class="line-modified">329   ObjectWaiter* DequeueWaiter();</span>
<span class="line-modified">330   void      DequeueSpecificWaiter(ObjectWaiter* waiter);</span>
331   void      EnterI(TRAPS);
<span class="line-modified">332   void      ReenterI(Thread* self, ObjectWaiter* self_node);</span>
<span class="line-modified">333   void      UnlinkAfterAcquire(Thread* self, ObjectWaiter* self_node);</span>
<span class="line-modified">334   int       TryLock(Thread* self);</span>
<span class="line-modified">335   int       NotRunnable(Thread* self, Thread * Owner);</span>
<span class="line-modified">336   int       TrySpin(Thread* self);</span>
<span class="line-modified">337   void      ExitEpilog(Thread* self, ObjectWaiter* Wakee);</span>
<span class="line-modified">338   bool      ExitSuspendEquivalent(JavaThread* self);</span>
339 };
340 
341 #endif // SHARE_RUNTIME_OBJECTMONITOR_HPP
</pre>
</td>
</tr>
</table>
<center><a href="objectMonitor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objectMonitor.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
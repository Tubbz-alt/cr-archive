<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/osThread.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="osThread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_perf.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/osThread.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45   ALLOCATED,                    // Memory has been allocated but not initialized
 46   INITIALIZED,                  // The thread has been initialized but yet started
 47   RUNNABLE,                     // Has been started and is runnable, but not necessarily running
 48   MONITOR_WAIT,                 // Waiting on a contended monitor lock
 49   CONDVAR_WAIT,                 // Waiting on a condition variable
 50   OBJECT_WAIT,                  // Waiting on an Object.wait() call
 51   BREAKPOINTED,                 // Suspended at breakpoint
 52   SLEEPING,                     // Thread.sleep()
 53   ZOMBIE                        // All done, but not reclaimed yet
 54 };
 55 
 56 typedef int (*OSThreadStartFunc)(void*);
 57 
 58 class OSThread: public CHeapObj&lt;mtThread&gt; {
 59   friend class VMStructs;
 60   friend class JVMCIVMStructs;
 61  private:
 62   OSThreadStartFunc _start_proc;  // Thread start routine
 63   void* _start_parm;              // Thread start routine parameter
 64   volatile ThreadState _state;    // Thread state *hint*
<span class="line-removed"> 65   volatile jint _interrupted;     // Thread.isInterrupted state</span>
<span class="line-removed"> 66 </span>
<span class="line-removed"> 67   // Note:  _interrupted must be jint, so that Java intrinsics can access it.</span>
<span class="line-removed"> 68   // The value stored there must be either 0 or 1.  It must be possible</span>
<span class="line-removed"> 69   // for Java to emulate Thread.currentThread().isInterrupted() by performing</span>
<span class="line-removed"> 70   // the double indirection Thread::current()-&gt;_osthread-&gt;_interrupted.</span>
 71 
 72   // Methods
 73  public:
 74   void set_state(ThreadState state)                { _state = state; }
 75   ThreadState get_state()                          { return _state; }
 76 
 77   OSThread(OSThreadStartFunc start_proc, void* start_parm);
 78   ~OSThread();
 79 
 80   // Accessors
 81   OSThreadStartFunc start_proc() const              { return _start_proc; }
 82   void set_start_proc(OSThreadStartFunc start_proc) { _start_proc = start_proc; }
 83   void* start_parm() const                          { return _start_parm; }
 84   void set_start_parm(void* start_parm)             { _start_parm = start_parm; }
<span class="line-modified"> 85 </span>
<span class="line-modified"> 86   volatile bool interrupted() const                 { return _interrupted != 0; }</span>
<span class="line-modified"> 87   void set_interrupted(bool z)                      { _interrupted = z ? 1 : 0; }</span>
<span class="line-modified"> 88 </span>
 89   // Printing
 90   void print_on(outputStream* st) const;
<span class="line-modified"> 91   void print() const                                { print_on(tty); }</span>
<span class="line-removed"> 92 </span>
<span class="line-removed"> 93   // For java intrinsics:</span>
<span class="line-removed"> 94   static ByteSize interrupted_offset()            { return byte_offset_of(OSThread, _interrupted); }</span>
 95 
 96   // Platform dependent stuff
 97 #include OS_HEADER(osThread)
 98 
 99  public:
100   static ByteSize thread_id_offset()              { return byte_offset_of(OSThread, _thread_id); }
101   static size_t thread_id_size()                  { return sizeof(thread_id_t); }
102 
103   thread_id_t thread_id() const                   { return _thread_id; }
104 
105   void set_thread_id(thread_id_t id)              { _thread_id = id; }
106 
107  private:
108   // _thread_id is kernel thread id (similar to LWP id on Solaris). Each
109   // thread has a unique thread_id (BsdThreads or NPTL). It can be used
110   // to access /proc.
111   thread_id_t _thread_id;
112 };
113 
114 
</pre>
</td>
<td>
<hr />
<pre>
 45   ALLOCATED,                    // Memory has been allocated but not initialized
 46   INITIALIZED,                  // The thread has been initialized but yet started
 47   RUNNABLE,                     // Has been started and is runnable, but not necessarily running
 48   MONITOR_WAIT,                 // Waiting on a contended monitor lock
 49   CONDVAR_WAIT,                 // Waiting on a condition variable
 50   OBJECT_WAIT,                  // Waiting on an Object.wait() call
 51   BREAKPOINTED,                 // Suspended at breakpoint
 52   SLEEPING,                     // Thread.sleep()
 53   ZOMBIE                        // All done, but not reclaimed yet
 54 };
 55 
 56 typedef int (*OSThreadStartFunc)(void*);
 57 
 58 class OSThread: public CHeapObj&lt;mtThread&gt; {
 59   friend class VMStructs;
 60   friend class JVMCIVMStructs;
 61  private:
 62   OSThreadStartFunc _start_proc;  // Thread start routine
 63   void* _start_parm;              // Thread start routine parameter
 64   volatile ThreadState _state;    // Thread state *hint*






 65 
 66   // Methods
 67  public:
 68   void set_state(ThreadState state)                { _state = state; }
 69   ThreadState get_state()                          { return _state; }
 70 
 71   OSThread(OSThreadStartFunc start_proc, void* start_parm);
 72   ~OSThread();
 73 
 74   // Accessors
 75   OSThreadStartFunc start_proc() const              { return _start_proc; }
 76   void set_start_proc(OSThreadStartFunc start_proc) { _start_proc = start_proc; }
 77   void* start_parm() const                          { return _start_parm; }
 78   void set_start_parm(void* start_parm)             { _start_parm = start_parm; }
<span class="line-modified"> 79   // This is specialized on Windows.</span>
<span class="line-modified"> 80 #ifndef _WINDOWS</span>
<span class="line-modified"> 81   void set_interrupted(bool z)                      { /* nothing to do */ }</span>
<span class="line-modified"> 82 #endif</span>
 83   // Printing
 84   void print_on(outputStream* st) const;
<span class="line-modified"> 85   void print() const;</span>



 86 
 87   // Platform dependent stuff
 88 #include OS_HEADER(osThread)
 89 
 90  public:
 91   static ByteSize thread_id_offset()              { return byte_offset_of(OSThread, _thread_id); }
 92   static size_t thread_id_size()                  { return sizeof(thread_id_t); }
 93 
 94   thread_id_t thread_id() const                   { return _thread_id; }
 95 
 96   void set_thread_id(thread_id_t id)              { _thread_id = id; }
 97 
 98  private:
 99   // _thread_id is kernel thread id (similar to LWP id on Solaris). Each
100   // thread has a unique thread_id (BsdThreads or NPTL). It can be used
101   // to access /proc.
102   thread_id_t _thread_id;
103 };
104 
105 
</pre>
</td>
</tr>
</table>
<center><a href="osThread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_perf.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/stackValue.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="signature.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubCodeGenerator.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/stackValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,13 ---</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/stackValue.hpp&quot;
  #if INCLUDE_ZGC
  #include &quot;gc/z/zBarrier.inline.hpp&quot;
  #endif
<span class="line-added">+ #if INCLUDE_SHENANDOAHGC</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;</span>
<span class="line-added">+ #endif</span>
  
  StackValue* StackValue::create_stack_value(const frame* fr, const RegisterMap* reg_map, ScopeValue* sv) {
    if (sv-&gt;is_location()) {
      // Stack or register value
      Location loc = ((LocationValue *)sv)-&gt;location();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,33 ***</span>
          // saved long to the int that the JVM wants.
          value.noop =  (narrowOop) *(julong*) value_addr;
        } else {
          value.noop = *(narrowOop*) value_addr;
        }
<span class="line-modified">!       // Decode narrowoop and wrap a handle around the oop</span>
<span class="line-modified">!       Handle h(Thread::current(), CompressedOops::decode(value.noop));</span>
        return new StackValue(h);
      }
  #endif
      case Location::oop: {
        oop val = *(oop *)value_addr;
  #ifdef _LP64
<span class="line-modified">!       if (Universe::is_narrow_oop_base(val)) {</span>
           // Compiled code may produce decoded oop = narrow_oop_base
           // when a narrow oop implicit null check is used.
           // The narrow_oop_base could be NULL or be the address
           // of the page below heap. Use NULL value for both cases.
           val = (oop)NULL;
        }
  #endif
<span class="line-modified">! #if INCLUDE_ZGC</span>
<span class="line-modified">!       // Deoptimization must make sure all oop have passed load barrier</span>
<span class="line-modified">!       if (UseZGC) {</span>
<span class="line-modified">!         val = ZBarrier::load_barrier_on_oop_field_preloaded((oop*)value_addr, val);</span>
        }
  #endif
<span class="line-modified">! </span>
        Handle h(Thread::current(), val); // Wrap a handle around the oop
        return new StackValue(h);
      }
      case Location::addr: {
        ShouldNotReachHere(); // both C1 and C2 now inline jsrs
<span class="line-new-header">--- 107,40 ---</span>
          // saved long to the int that the JVM wants.
          value.noop =  (narrowOop) *(julong*) value_addr;
        } else {
          value.noop = *(narrowOop*) value_addr;
        }
<span class="line-modified">!       // Decode narrowoop</span>
<span class="line-modified">!       oop val = CompressedOops::decode(value.noop);</span>
<span class="line-added">+       // Deoptimization must make sure all oops have passed load barriers</span>
<span class="line-added">+ #if INCLUDE_SHENANDOAHGC</span>
<span class="line-added">+       if (UseShenandoahGC) {</span>
<span class="line-added">+         val = ShenandoahBarrierSet::barrier_set()-&gt;load_reference_barrier(val);</span>
<span class="line-added">+       }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+       Handle h(Thread::current(), val); // Wrap a handle around the oop</span>
        return new StackValue(h);
      }
  #endif
      case Location::oop: {
        oop val = *(oop *)value_addr;
  #ifdef _LP64
<span class="line-modified">!       if (CompressedOops::is_base(val)) {</span>
           // Compiled code may produce decoded oop = narrow_oop_base
           // when a narrow oop implicit null check is used.
           // The narrow_oop_base could be NULL or be the address
           // of the page below heap. Use NULL value for both cases.
           val = (oop)NULL;
        }
  #endif
<span class="line-modified">!       // Deoptimization must make sure all oops have passed load barriers</span>
<span class="line-modified">! #if INCLUDE_SHENANDOAHGC</span>
<span class="line-modified">!       if (UseShenandoahGC) {</span>
<span class="line-modified">!         val = ShenandoahBarrierSet::barrier_set()-&gt;load_reference_barrier(val);</span>
        }
  #endif
<span class="line-modified">!       assert(oopDesc::is_oop_or_null(val, false), &quot;bad oop found&quot;);</span>
        Handle h(Thread::current(), val); // Wrap a handle around the oop
        return new StackValue(h);
      }
      case Location::addr: {
        ShouldNotReachHere(); // both C1 and C2 now inline jsrs
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,11 ***</span>
        if (_handle_value() != NULL) {
          _handle_value()-&gt;print_value_on(st);
        } else {
          st-&gt;print(&quot;NULL&quot;);
        }
<span class="line-modified">!       st-&gt;print(&quot; &lt;&quot; INTPTR_FORMAT &quot;&gt;&quot;, p2i((address)_handle_value()));</span>
       break;
  
      case T_CONFLICT:
       st-&gt;print(&quot;conflict&quot;);
       break;
<span class="line-new-header">--- 219,11 ---</span>
        if (_handle_value() != NULL) {
          _handle_value()-&gt;print_value_on(st);
        } else {
          st-&gt;print(&quot;NULL&quot;);
        }
<span class="line-modified">!       st-&gt;print(&quot; &lt;&quot; INTPTR_FORMAT &quot;&gt;&quot;, p2i(_handle_value()));</span>
       break;
  
      case T_CONFLICT:
       st-&gt;print(&quot;conflict&quot;);
       break;
</pre>
<center><a href="signature.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubCodeGenerator.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
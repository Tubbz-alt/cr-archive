<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/handles.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_extension.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="handles.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/handles.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 62 // Base class for all handles. Provides overloading of frequently
 63 // used operators for ease of use.
 64 
 65 class Handle {
 66  private:
 67   oop* _handle;
 68 
 69  protected:
 70   oop     obj() const                            { return _handle == NULL ? (oop)NULL : *_handle; }
 71   oop     non_null_obj() const                   { assert(_handle != NULL, &quot;resolving NULL handle&quot;); return *_handle; }
 72 
 73  public:
 74   // Constructors
 75   Handle()                                       { _handle = NULL; }
 76   inline Handle(Thread* thread, oop obj);
 77 
 78   // General access
 79   oop     operator () () const                   { return obj(); }
 80   oop     operator -&gt; () const                   { return non_null_obj(); }
 81 
<span class="line-modified"> 82   bool operator == (oop o) const                 { return oopDesc::equals(obj(), o); }</span>
<span class="line-modified"> 83   bool operator == (const Handle&amp; h) const       { return oopDesc::equals(obj(), h.obj()); }</span>
 84 
 85   // Null checks
 86   bool    is_null() const                        { return _handle == NULL; }
 87   bool    not_null() const                       { return _handle != NULL; }
 88 
 89   // Debugging
 90   void    print()                                { obj()-&gt;print(); }
 91 
 92   // Direct interface, use very sparingly.
 93   // Used by JavaCalls to quickly convert handles and to create handles static data structures.
 94   // Constructor takes a dummy argument to prevent unintentional type conversion in C++.
 95   Handle(oop *handle, bool dummy)                { _handle = handle; }
 96 
 97   // Raw handle access. Allows easy duplication of Handles. This can be very unsafe
 98   // since duplicates is only valid as long as original handle is alive.
 99   oop* raw_value()                               { return _handle; }
100   static oop raw_resolve(oop *handle)            { return handle == NULL ? (oop)NULL : *handle; }
101 };
102 
103 // Specific Handles for different oop types
</pre>
<hr />
<pre>
126 //------------------------------------------------------------------------------------------------------------------------
127 
128 // Metadata Handles.  Unlike oop Handles these are needed to prevent metadata
129 // from being reclaimed by RedefineClasses.
130 // Metadata Handles should be passed around as const references to avoid copy construction
131 // and destruction for parameters.
132 
133 // Specific Handles for different oop types
134 #define DEF_METADATA_HANDLE(name, type)          \
135   class name##Handle;                            \
136   class name##Handle : public StackObj {         \
137     type*     _value;                            \
138     Thread*   _thread;                           \
139    protected:                                    \
140     type*        obj() const                     { return _value; } \
141     type*        non_null_obj() const            { assert(_value != NULL, &quot;resolving NULL _value&quot;); return _value; } \
142                                                  \
143    public:                                       \
144     /* Constructors */                           \
145     name##Handle () : _value(NULL), _thread(NULL) {}   \
<span class="line-removed">146     name##Handle (type* obj);                    \</span>
147     name##Handle (Thread* thread, type* obj);    \
148                                                  \
149     name##Handle (const name##Handle &amp;h);        \
150     name##Handle&amp; operator=(const name##Handle &amp;s); \
151                                                  \
152     /* Destructor */                             \
153     ~name##Handle ();                            \
154     void remove();                               \
155                                                  \
156     /* Operators for ease of use */              \
157     type*        operator () () const            { return obj(); } \
158     type*        operator -&gt; () const            { return non_null_obj(); } \
159                                                  \
160     bool    operator == (type* o) const          { return obj() == o; } \
161     bool    operator == (const name##Handle&amp; h) const  { return obj() == h.obj(); } \
162                                                  \
163     /* Null checks */                            \
164     bool    is_null() const                      { return _value == NULL; } \
165     bool    not_null() const                     { return _value != NULL; } \
166   };
</pre>
</td>
<td>
<hr />
<pre>
 62 // Base class for all handles. Provides overloading of frequently
 63 // used operators for ease of use.
 64 
 65 class Handle {
 66  private:
 67   oop* _handle;
 68 
 69  protected:
 70   oop     obj() const                            { return _handle == NULL ? (oop)NULL : *_handle; }
 71   oop     non_null_obj() const                   { assert(_handle != NULL, &quot;resolving NULL handle&quot;); return *_handle; }
 72 
 73  public:
 74   // Constructors
 75   Handle()                                       { _handle = NULL; }
 76   inline Handle(Thread* thread, oop obj);
 77 
 78   // General access
 79   oop     operator () () const                   { return obj(); }
 80   oop     operator -&gt; () const                   { return non_null_obj(); }
 81 
<span class="line-modified"> 82   bool operator == (oop o) const                 { return obj() == o; }</span>
<span class="line-modified"> 83   bool operator == (const Handle&amp; h) const       { return obj() == h.obj(); }</span>
 84 
 85   // Null checks
 86   bool    is_null() const                        { return _handle == NULL; }
 87   bool    not_null() const                       { return _handle != NULL; }
 88 
 89   // Debugging
 90   void    print()                                { obj()-&gt;print(); }
 91 
 92   // Direct interface, use very sparingly.
 93   // Used by JavaCalls to quickly convert handles and to create handles static data structures.
 94   // Constructor takes a dummy argument to prevent unintentional type conversion in C++.
 95   Handle(oop *handle, bool dummy)                { _handle = handle; }
 96 
 97   // Raw handle access. Allows easy duplication of Handles. This can be very unsafe
 98   // since duplicates is only valid as long as original handle is alive.
 99   oop* raw_value()                               { return _handle; }
100   static oop raw_resolve(oop *handle)            { return handle == NULL ? (oop)NULL : *handle; }
101 };
102 
103 // Specific Handles for different oop types
</pre>
<hr />
<pre>
126 //------------------------------------------------------------------------------------------------------------------------
127 
128 // Metadata Handles.  Unlike oop Handles these are needed to prevent metadata
129 // from being reclaimed by RedefineClasses.
130 // Metadata Handles should be passed around as const references to avoid copy construction
131 // and destruction for parameters.
132 
133 // Specific Handles for different oop types
134 #define DEF_METADATA_HANDLE(name, type)          \
135   class name##Handle;                            \
136   class name##Handle : public StackObj {         \
137     type*     _value;                            \
138     Thread*   _thread;                           \
139    protected:                                    \
140     type*        obj() const                     { return _value; } \
141     type*        non_null_obj() const            { assert(_value != NULL, &quot;resolving NULL _value&quot;); return _value; } \
142                                                  \
143    public:                                       \
144     /* Constructors */                           \
145     name##Handle () : _value(NULL), _thread(NULL) {}   \

146     name##Handle (Thread* thread, type* obj);    \
147                                                  \
148     name##Handle (const name##Handle &amp;h);        \
149     name##Handle&amp; operator=(const name##Handle &amp;s); \
150                                                  \
151     /* Destructor */                             \
152     ~name##Handle ();                            \
153     void remove();                               \
154                                                  \
155     /* Operators for ease of use */              \
156     type*        operator () () const            { return obj(); } \
157     type*        operator -&gt; () const            { return non_null_obj(); } \
158                                                  \
159     bool    operator == (type* o) const          { return obj() == o; } \
160     bool    operator == (const name##Handle&amp; h) const  { return obj() == h.obj(); } \
161                                                  \
162     /* Null checks */                            \
163     bool    is_null() const                      { return _value == NULL; } \
164     bool    not_null() const                     { return _value != NULL; } \
165   };
</pre>
</td>
</tr>
</table>
<center><a href="globals_extension.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="handles.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
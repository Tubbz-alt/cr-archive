<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/signature.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;memory/oopFactory.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a>
 30 #include &quot;oops/instanceKlass.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;oops/symbol.hpp&quot;
 33 #include &quot;oops/typeArrayKlass.hpp&quot;
<a name="3" id="anc3"></a>


 34 #include &quot;runtime/signature.hpp&quot;
 35 
 36 // Implementation of SignatureIterator
 37 
 38 // Signature syntax:
 39 //
 40 // Signature  = &quot;(&quot; {Parameter} &quot;)&quot; ReturnType.
 41 // Parameter  = FieldType.
 42 // ReturnType = FieldType | &quot;V&quot;.
 43 // FieldType  = &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;F&quot; | &quot;I&quot; | &quot;J&quot; | &quot;S&quot; | &quot;Z&quot; | &quot;L&quot; ClassName &quot;;&quot; | &quot;[&quot; FieldType.
 44 // ClassName  = string.
 45 
<a name="4" id="anc4"></a>























 46 
<a name="5" id="anc5"></a><span class="line-modified"> 47 SignatureIterator::SignatureIterator(Symbol* signature) {</span>
<span class="line-modified"> 48   _signature       = signature;</span>
<span class="line-modified"> 49   _parameter_index = 0;</span>





 50 }
 51 
<a name="6" id="anc6"></a><span class="line-modified"> 52 void SignatureIterator::expect(char c) {</span>
<span class="line-modified"> 53   if (_signature-&gt;char_at(_index) != c) fatal(&quot;expecting %c&quot;, c);</span>
<span class="line-modified"> 54   _index++;</span>



 55 }
 56 
<a name="7" id="anc7"></a><span class="line-modified"> 57 int SignatureIterator::parse_type() {</span>
<span class="line-modified"> 58   // Note: This function could be simplified by using &quot;return T_XXX_size;&quot;</span>
<span class="line-modified"> 59   //       instead of the assignment and the break statements. However, it</span>
<span class="line-modified"> 60   //       seems that the product build for win32_i486 with MS VC++ 6.0 doesn&#39;t</span>
<span class="line-modified"> 61   //       work (stack underflow for some tests) - this seems to be a VC++ 6.0</span>
<span class="line-removed"> 62   //       compiler bug (was problem - gri 4/27/2000).</span>
<span class="line-removed"> 63   int size = -1;</span>
<span class="line-removed"> 64   switch(_signature-&gt;char_at(_index)) {</span>
<span class="line-removed"> 65     case &#39;B&#39;: do_byte  (); if (_parameter_index &lt; 0 ) _return_type = T_BYTE;</span>
<span class="line-removed"> 66               _index++; size = T_BYTE_size   ; break;</span>
<span class="line-removed"> 67     case &#39;C&#39;: do_char  (); if (_parameter_index &lt; 0 ) _return_type = T_CHAR;</span>
<span class="line-removed"> 68               _index++; size = T_CHAR_size   ; break;</span>
<span class="line-removed"> 69     case &#39;D&#39;: do_double(); if (_parameter_index &lt; 0 ) _return_type = T_DOUBLE;</span>
<span class="line-removed"> 70               _index++; size = T_DOUBLE_size ; break;</span>
<span class="line-removed"> 71     case &#39;F&#39;: do_float (); if (_parameter_index &lt; 0 ) _return_type = T_FLOAT;</span>
<span class="line-removed"> 72               _index++; size = T_FLOAT_size  ; break;</span>
<span class="line-removed"> 73     case &#39;I&#39;: do_int   (); if (_parameter_index &lt; 0 ) _return_type = T_INT;</span>
<span class="line-removed"> 74               _index++; size = T_INT_size    ; break;</span>
<span class="line-removed"> 75     case &#39;J&#39;: do_long  (); if (_parameter_index &lt; 0 ) _return_type = T_LONG;</span>
<span class="line-removed"> 76               _index++; size = T_LONG_size   ; break;</span>
<span class="line-removed"> 77     case &#39;S&#39;: do_short (); if (_parameter_index &lt; 0 ) _return_type = T_SHORT;</span>
<span class="line-removed"> 78               _index++; size = T_SHORT_size  ; break;</span>
<span class="line-removed"> 79     case &#39;Z&#39;: do_bool  (); if (_parameter_index &lt; 0 ) _return_type = T_BOOLEAN;</span>
<span class="line-removed"> 80               _index++; size = T_BOOLEAN_size; break;</span>
<span class="line-removed"> 81     case &#39;V&#39;: do_void  (); if (_parameter_index &lt; 0 ) _return_type = T_VOID;</span>
<span class="line-removed"> 82               _index++; size = T_VOID_size;  ; break;</span>
<span class="line-removed"> 83     case &#39;L&#39;:</span>
<span class="line-removed"> 84       { int begin = ++_index;</span>
<span class="line-removed"> 85         Symbol* sig = _signature;</span>
<span class="line-removed"> 86         while (sig-&gt;char_at(_index++) != &#39;;&#39;) ;</span>
<span class="line-removed"> 87         do_object(begin, _index);</span>
<span class="line-removed"> 88       }</span>
<span class="line-removed"> 89       if (_parameter_index &lt; 0 ) _return_type = T_OBJECT;</span>
<span class="line-removed"> 90       size = T_OBJECT_size;</span>
<span class="line-removed"> 91       break;</span>
<span class="line-removed"> 92     case &#39;[&#39;:</span>
<span class="line-removed"> 93       { int begin = ++_index;</span>
<span class="line-removed"> 94         Symbol* sig = _signature;</span>
<span class="line-removed"> 95         while (sig-&gt;char_at(_index) == &#39;[&#39;) {</span>
<span class="line-removed"> 96           _index++;</span>
<span class="line-removed"> 97         }</span>
<span class="line-removed"> 98         if (sig-&gt;char_at(_index) == &#39;L&#39;) {</span>
<span class="line-removed"> 99           while (sig-&gt;char_at(_index++) != &#39;;&#39;) ;</span>
<span class="line-removed">100         } else {</span>
<span class="line-removed">101           _index++;</span>
<span class="line-removed">102         }</span>
<span class="line-removed">103         do_array(begin, _index);</span>
<span class="line-removed">104        if (_parameter_index &lt; 0 ) _return_type = T_ARRAY;</span>
<span class="line-removed">105       }</span>
<span class="line-removed">106       size = T_ARRAY_size;</span>
<span class="line-removed">107       break;</span>
<span class="line-removed">108     default:</span>
<span class="line-removed">109       ShouldNotReachHere();</span>
<span class="line-removed">110       break;</span>
<span class="line-removed">111   }</span>
<span class="line-removed">112   assert(size &gt;= 0, &quot;size must be set&quot;);</span>
<span class="line-removed">113   return size;</span>
114 }
115 
<a name="8" id="anc8"></a>





116 
<a name="9" id="anc9"></a><span class="line-modified">117 void SignatureIterator::check_signature_end() {</span>
<span class="line-modified">118   if (_index &lt; _signature-&gt;utf8_length()) {</span>
<span class="line-modified">119     tty-&gt;print_cr(&quot;too many chars in signature&quot;);</span>
<span class="line-modified">120     _signature-&gt;print_value_on(tty);</span>
<span class="line-modified">121     tty-&gt;print_cr(&quot; @ %d&quot;, _index);</span>
<span class="line-removed">122   }</span>
123 }
124 
<a name="10" id="anc10"></a>











125 
<a name="11" id="anc11"></a><span class="line-modified">126 void SignatureIterator::iterate_parameters() {</span>
<span class="line-modified">127   // Parse parameters</span>
<span class="line-modified">128   _index = 0;</span>
<span class="line-modified">129   _parameter_index = 0;</span>
<span class="line-modified">130   expect(&#39;(&#39;);</span>
<span class="line-modified">131   while (_signature-&gt;char_at(_index) != &#39;)&#39;) _parameter_index += parse_type();</span>
<span class="line-modified">132   expect(&#39;)&#39;);</span>
<span class="line-modified">133   _parameter_index = 0;</span>
<span class="line-modified">134 }</span>
135 
<a name="12" id="anc12"></a><span class="line-modified">136 // Optimized version of iterate_parameters when fingerprint is known</span>
<span class="line-modified">137 void SignatureIterator::iterate_parameters( uint64_t fingerprint ) {</span>
<span class="line-modified">138   uint64_t saved_fingerprint = fingerprint;</span>

139 
<a name="13" id="anc13"></a><span class="line-modified">140   // Check for too many arguments</span>
<span class="line-modified">141   if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="line-modified">142     SignatureIterator::iterate_parameters();</span>
<span class="line-modified">143     return;</span>


144   }
145 
<a name="14" id="anc14"></a><span class="line-modified">146   assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="line-modified">147 </span>
<span class="line-modified">148   _parameter_index = 0;</span>
<span class="line-modified">149   fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="line-modified">150   while ( 1 ) {</span>
<span class="line-modified">151     switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="line-removed">152       case bool_parm:</span>
<span class="line-removed">153         do_bool();</span>
<span class="line-removed">154         _parameter_index += T_BOOLEAN_size;</span>
<span class="line-removed">155         break;</span>
<span class="line-removed">156       case byte_parm:</span>
<span class="line-removed">157         do_byte();</span>
<span class="line-removed">158         _parameter_index += T_BYTE_size;</span>
<span class="line-removed">159         break;</span>
<span class="line-removed">160       case char_parm:</span>
<span class="line-removed">161         do_char();</span>
<span class="line-removed">162         _parameter_index += T_CHAR_size;</span>
<span class="line-removed">163         break;</span>
<span class="line-removed">164       case short_parm:</span>
<span class="line-removed">165         do_short();</span>
<span class="line-removed">166         _parameter_index += T_SHORT_size;</span>
<span class="line-removed">167         break;</span>
<span class="line-removed">168       case int_parm:</span>
<span class="line-removed">169         do_int();</span>
<span class="line-removed">170         _parameter_index += T_INT_size;</span>
<span class="line-removed">171         break;</span>
<span class="line-removed">172       case obj_parm:</span>
<span class="line-removed">173         do_object(0, 0);</span>
<span class="line-removed">174         _parameter_index += T_OBJECT_size;</span>
<span class="line-removed">175         break;</span>
<span class="line-removed">176       case long_parm:</span>
<span class="line-removed">177         do_long();</span>
<span class="line-removed">178         _parameter_index += T_LONG_size;</span>
<span class="line-removed">179         break;</span>
<span class="line-removed">180       case float_parm:</span>
<span class="line-removed">181         do_float();</span>
<span class="line-removed">182         _parameter_index += T_FLOAT_size;</span>
<span class="line-removed">183         break;</span>
<span class="line-removed">184       case double_parm:</span>
<span class="line-removed">185         do_double();</span>
<span class="line-removed">186         _parameter_index += T_DOUBLE_size;</span>
<span class="line-removed">187         break;</span>
<span class="line-removed">188       case done_parm:</span>
<span class="line-removed">189         return;</span>
<span class="line-removed">190       default:</span>
<span class="line-removed">191         tty-&gt;print_cr(&quot;*** parameter is &quot; UINT64_FORMAT, fingerprint &amp; parameter_feature_mask);</span>
<span class="line-removed">192         tty-&gt;print_cr(&quot;*** fingerprint is &quot; PTR64_FORMAT, saved_fingerprint);</span>
<span class="line-removed">193         ShouldNotReachHere();</span>
<span class="line-removed">194         break;</span>
<span class="line-removed">195     }</span>
<span class="line-removed">196     fingerprint &gt;&gt;= parameter_feature_size;</span>
197   }
<a name="15" id="anc15"></a><span class="line-removed">198 }</span>
199 
<a name="16" id="anc16"></a>




200 
<a name="17" id="anc17"></a><span class="line-modified">201 void SignatureIterator::iterate_returntype() {</span>
<span class="line-modified">202   // Ignore parameters</span>
<span class="line-modified">203   _index = 0;</span>
<span class="line-modified">204   expect(&#39;(&#39;);</span>
<span class="line-modified">205   Symbol* sig = _signature;</span>
<span class="line-modified">206   // Need to skip over each type in the signature&#39;s argument list until a</span>
<span class="line-removed">207   // closing &#39;)&#39; is found., then get the return type.  We cannot just scan</span>
<span class="line-removed">208   // for the first &#39;)&#39; because &#39;)&#39; is a legal character in a type name.</span>
<span class="line-removed">209   while (sig-&gt;char_at(_index) != &#39;)&#39;) {</span>
<span class="line-removed">210     switch(sig-&gt;char_at(_index)) {</span>
<span class="line-removed">211       case &#39;B&#39;:</span>
<span class="line-removed">212       case &#39;C&#39;:</span>
<span class="line-removed">213       case &#39;D&#39;:</span>
<span class="line-removed">214       case &#39;F&#39;:</span>
<span class="line-removed">215       case &#39;I&#39;:</span>
<span class="line-removed">216       case &#39;J&#39;:</span>
<span class="line-removed">217       case &#39;S&#39;:</span>
<span class="line-removed">218       case &#39;Z&#39;:</span>
<span class="line-removed">219       case &#39;V&#39;:</span>
<span class="line-removed">220         {</span>
<span class="line-removed">221           _index++;</span>
<span class="line-removed">222         }</span>
<span class="line-removed">223         break;</span>
<span class="line-removed">224       case &#39;L&#39;:</span>
<span class="line-removed">225         {</span>
<span class="line-removed">226           while (sig-&gt;char_at(_index++) != &#39;;&#39;) ;</span>
<span class="line-removed">227         }</span>
<span class="line-removed">228         break;</span>
<span class="line-removed">229       case &#39;[&#39;:</span>
<span class="line-removed">230         {</span>
<span class="line-removed">231           while (sig-&gt;char_at(++_index) == &#39;[&#39;) ;</span>
<span class="line-removed">232           if (sig-&gt;char_at(_index) == &#39;L&#39;) {</span>
<span class="line-removed">233             while (sig-&gt;char_at(_index++) != &#39;;&#39;) ;</span>
<span class="line-removed">234           } else {</span>
<span class="line-removed">235             _index++;</span>
<span class="line-removed">236           }</span>
<span class="line-removed">237         }</span>
<span class="line-removed">238         break;</span>
<span class="line-removed">239       default:</span>
<span class="line-removed">240         ShouldNotReachHere();</span>
<span class="line-removed">241         break;</span>
<span class="line-removed">242     }</span>
243   }
<a name="18" id="anc18"></a><span class="line-removed">244   expect(&#39;)&#39;);</span>
<span class="line-removed">245   // Parse return type</span>
<span class="line-removed">246   _parameter_index = -1;</span>
<span class="line-removed">247   parse_type();</span>
<span class="line-removed">248   check_signature_end();</span>
<span class="line-removed">249   _parameter_index = 0;</span>
250 }
251 
<a name="19" id="anc19"></a>
252 
<a name="20" id="anc20"></a><span class="line-modified">253 void SignatureIterator::iterate() {</span>
<span class="line-modified">254   // Parse parameters</span>
<span class="line-modified">255   _parameter_index = 0;</span>
<span class="line-modified">256   _index = 0;</span>
<span class="line-modified">257   expect(&#39;(&#39;);</span>
<span class="line-modified">258   while (_signature-&gt;char_at(_index) != &#39;)&#39;) _parameter_index += parse_type();</span>
<span class="line-modified">259   expect(&#39;)&#39;);</span>
<span class="line-modified">260   // Parse return type</span>
<span class="line-removed">261   _parameter_index = -1;</span>
<span class="line-removed">262   parse_type();</span>
<span class="line-removed">263   check_signature_end();</span>
<span class="line-removed">264   _parameter_index = 0;</span>
265 }
266 
<a name="21" id="anc21"></a><span class="line-modified">267 </span>
<span class="line-modified">268 // Implementation of SignatureStream</span>
<span class="line-modified">269 SignatureStream::SignatureStream(Symbol* signature, bool is_method) :</span>
<span class="line-modified">270                    _signature(signature), _at_return_type(false), _previous_name(NULL), _names(NULL) {</span>
<span class="line-modified">271   _begin = _end = (is_method ? 1 : 0);  // skip first &#39;(&#39; in method signatures</span>








272   next();
273 }
274 
275 SignatureStream::~SignatureStream() {
276   // decrement refcount for names created during signature parsing
277   if (_names != NULL) {
278     for (int i = 0; i &lt; _names-&gt;length(); i++) {
279       _names-&gt;at(i)-&gt;decrement_refcount();
280     }
<a name="22" id="anc22"></a>

281   }
282 }
283 
<a name="23" id="anc23"></a><span class="line-modified">284 bool SignatureStream::is_done() const {</span>
<span class="line-modified">285   return _end &gt; _signature-&gt;utf8_length();</span>






















286 }
287 
<a name="24" id="anc24"></a>

























288 
<a name="25" id="anc25"></a><span class="line-modified">289 void SignatureStream::next_non_primitive(int t) {</span>
<span class="line-modified">290   switch (t) {</span>
<span class="line-modified">291     case &#39;L&#39;: {</span>
<span class="line-modified">292       _type = T_OBJECT;</span>
<span class="line-modified">293       Symbol* sig = _signature;</span>
<span class="line-modified">294       while (sig-&gt;char_at(_end++) != &#39;;&#39;);</span>
<span class="line-modified">295       break;</span>
<span class="line-modified">296     }</span>
<span class="line-modified">297     case &#39;[&#39;: {</span>
<span class="line-removed">298       _type = T_ARRAY;</span>
<span class="line-removed">299       Symbol* sig = _signature;</span>
<span class="line-removed">300       char c = sig-&gt;char_at(_end);</span>
<span class="line-removed">301       while (&#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;) c = sig-&gt;char_at(_end++);</span>
<span class="line-removed">302       while (sig-&gt;char_at(_end) == &#39;[&#39;) {</span>
<span class="line-removed">303         _end++;</span>
<span class="line-removed">304         c = sig-&gt;char_at(_end);</span>
<span class="line-removed">305         while (&#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;) c = sig-&gt;char_at(_end++);</span>
<span class="line-removed">306       }</span>
<span class="line-removed">307       switch(sig-&gt;char_at(_end)) {</span>
<span class="line-removed">308         case &#39;B&#39;:</span>
<span class="line-removed">309         case &#39;C&#39;:</span>
<span class="line-removed">310         case &#39;D&#39;:</span>
<span class="line-removed">311         case &#39;F&#39;:</span>
<span class="line-removed">312         case &#39;I&#39;:</span>
<span class="line-removed">313         case &#39;J&#39;:</span>
<span class="line-removed">314         case &#39;S&#39;:</span>
<span class="line-removed">315         case &#39;Z&#39;:_end++; break;</span>
<span class="line-removed">316         default: {</span>
<span class="line-removed">317           while (sig-&gt;char_at(_end++) != &#39;;&#39;);</span>
<span class="line-removed">318           break;</span>
<span class="line-removed">319         }</span>
<span class="line-removed">320       }</span>
<span class="line-removed">321       break;</span>
<span class="line-removed">322     }</span>
<span class="line-removed">323     case &#39;)&#39;: _end++; next(); _at_return_type = true; break;</span>
<span class="line-removed">324     default : ShouldNotReachHere();</span>
325   }
<a name="26" id="anc26"></a>













326 }
327 
<a name="27" id="anc27"></a>


























328 
<a name="28" id="anc28"></a><span class="line-modified">329 bool SignatureStream::is_object() const {</span>
<span class="line-modified">330   return _type == T_OBJECT</span>
<span class="line-modified">331       || _type == T_ARRAY;</span>

332 }
333 
<a name="29" id="anc29"></a><span class="line-modified">334 bool SignatureStream::is_array() const {</span>
<span class="line-modified">335   return _type == T_ARRAY;</span>

















336 }
<a name="30" id="anc30"></a>
337 
<a name="31" id="anc31"></a><span class="line-modified">338 Symbol* SignatureStream::as_symbol(TRAPS) {</span>

339   // Create a symbol from for string _begin _end
<a name="32" id="anc32"></a><span class="line-modified">340   int begin = _begin;</span>
<span class="line-modified">341   int end   = _end;</span>
<span class="line-removed">342 </span>
<span class="line-removed">343   if (   _signature-&gt;char_at(_begin) == &#39;L&#39;</span>
<span class="line-removed">344       &amp;&amp; _signature-&gt;char_at(_end-1) == &#39;;&#39;) {</span>
<span class="line-removed">345     begin++;</span>
<span class="line-removed">346     end--;</span>
<span class="line-removed">347   }</span>
348 
349   const char* symbol_chars = (const char*)_signature-&gt;base() + begin;
350   int len = end - begin;
351 
352   // Quick check for common symbols in signatures
<a name="33" id="anc33"></a><span class="line-modified">353   assert((vmSymbols::java_lang_String()-&gt;utf8_length() == 16 &amp;&amp; vmSymbols::java_lang_Object()-&gt;utf8_length() == 16), &quot;sanity&quot;);</span>
<span class="line-modified">354   if (len == 16 &amp;&amp;</span>
<span class="line-modified">355       strncmp(symbol_chars, &quot;java/lang/&quot;, 10) == 0) {</span>
<span class="line-modified">356     if (strncmp(&quot;String&quot;, symbol_chars + 10, 6) == 0) {</span>
357       return vmSymbols::java_lang_String();
<a name="34" id="anc34"></a><span class="line-modified">358     } else if (strncmp(&quot;Object&quot;, symbol_chars + 10, 6) == 0) {</span>
359       return vmSymbols::java_lang_Object();
360     }
361   }
362 
363   Symbol* name = _previous_name;
364   if (name != NULL &amp;&amp; name-&gt;equals(symbol_chars, len)) {
365     return name;
366   }
367 
368   // Save names for cleaning up reference count at the end of
369   // SignatureStream scope.
<a name="35" id="anc35"></a><span class="line-modified">370   name = SymbolTable::new_symbol(symbol_chars, len, CHECK_NULL);</span>
<span class="line-modified">371   if (!name-&gt;is_permanent()) {</span>










372     if (_names == NULL) {
373       _names = new GrowableArray&lt;Symbol*&gt;(10);
374     }
375     _names-&gt;push(name);  // save new symbol for decrementing later
376   }
377   _previous_name = name;
378   return name;
379 }
380 
381 Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,
<a name="36" id="anc36"></a><span class="line-modified">382                                    FailureMode failure_mode, TRAPS) {</span>
<span class="line-modified">383   if (!is_object())  return NULL;</span>
<span class="line-modified">384   Symbol* name = as_symbol(CHECK_NULL);</span>

385   if (failure_mode == ReturnNull) {
<a name="37" id="anc37"></a><span class="line-modified">386     return SystemDictionary::resolve_or_null(name, class_loader, protection_domain, THREAD);</span>










387   } else {
<a name="38" id="anc38"></a>


388     bool throw_error = (failure_mode == NCDFError);
<a name="39" id="anc39"></a><span class="line-modified">389     return SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, THREAD);</span>
390   }
<a name="40" id="anc40"></a>

391 }
392 
393 oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,
394                                     FailureMode failure_mode, TRAPS) {
<a name="41" id="anc41"></a><span class="line-modified">395   if (!is_object())</span>
396     return Universe::java_mirror(type());
397   Klass* klass = as_klass(class_loader, protection_domain, failure_mode, CHECK_NULL);
398   if (klass == NULL)  return NULL;
399   return klass-&gt;java_mirror();
400 }
401 
<a name="42" id="anc42"></a><span class="line-modified">402 Symbol* SignatureStream::as_symbol_or_null() {</span>
<span class="line-modified">403   // Create a symbol from for string _begin _end</span>
<span class="line-modified">404   ResourceMark rm;</span>
<span class="line-removed">405 </span>
<span class="line-removed">406   int begin = _begin;</span>
<span class="line-removed">407   int end   = _end;</span>
<span class="line-removed">408 </span>
<span class="line-removed">409   if (   _signature-&gt;char_at(_begin) == &#39;L&#39;</span>
<span class="line-removed">410       &amp;&amp; _signature-&gt;char_at(_end-1) == &#39;;&#39;) {</span>
<span class="line-removed">411     begin++;</span>
<span class="line-removed">412     end--;</span>
<span class="line-removed">413   }</span>
<span class="line-removed">414 </span>
<span class="line-removed">415   char* buffer = NEW_RESOURCE_ARRAY(char, end - begin);</span>
<span class="line-removed">416   for (int index = begin; index &lt; end; index++) {</span>
<span class="line-removed">417     buffer[index - begin] = _signature-&gt;char_at(index);</span>
418   }
<a name="43" id="anc43"></a><span class="line-removed">419   Symbol* result = SymbolTable::probe(buffer, end - begin);</span>
<span class="line-removed">420   return result;</span>
421 }
422 
<a name="44" id="anc44"></a><span class="line-modified">423 int SignatureStream::reference_parameter_count() {</span>
<span class="line-modified">424   int args_count = 0;</span>
<span class="line-modified">425   for ( ; !at_return_type(); next()) {</span>
<span class="line-modified">426     if (is_object()) {</span>
<span class="line-modified">427       args_count++;</span>








428     }
<a name="45" id="anc45"></a>

429   }
<a name="46" id="anc46"></a><span class="line-modified">430   return args_count;</span>
431 }
432 
<a name="47" id="anc47"></a><span class="line-removed">433 #ifdef ASSERT</span>
434 bool SignatureVerifier::is_valid_method_signature(Symbol* sig) {
435   const char* method_sig = (const char*)sig-&gt;bytes();
436   ssize_t len = sig-&gt;utf8_length();
437   ssize_t index = 0;
<a name="48" id="anc48"></a><span class="line-modified">438   if (method_sig != NULL &amp;&amp; len &gt; 1 &amp;&amp; method_sig[index] == &#39;(&#39;) {</span>
439     ++index;
<a name="49" id="anc49"></a><span class="line-modified">440     while (index &lt; len &amp;&amp; method_sig[index] != &#39;)&#39;) {</span>
441       ssize_t res = is_valid_type(&amp;method_sig[index], len - index);
442       if (res == -1) {
443         return false;
444       } else {
445         index += res;
446       }
447     }
<a name="50" id="anc50"></a><span class="line-modified">448     if (index &lt; len &amp;&amp; method_sig[index] == &#39;)&#39;) {</span>
449       // check the return type
450       ++index;
451       return (is_valid_type(&amp;method_sig[index], len - index) == (len - index));
452     }
453   }
454   return false;
455 }
456 
457 bool SignatureVerifier::is_valid_type_signature(Symbol* sig) {
458   const char* type_sig = (const char*)sig-&gt;bytes();
459   ssize_t len = sig-&gt;utf8_length();
460   return (type_sig != NULL &amp;&amp; len &gt;= 1 &amp;&amp;
461           (is_valid_type(type_sig, len) == len));
462 }
463 
464 // Checks to see if the type (not to go beyond &#39;limit&#39;) refers to a valid type.
465 // Returns -1 if it is not, or the index of the next character that is not part
466 // of the type.  The type encoding may end before &#39;limit&#39; and that&#39;s ok.
467 ssize_t SignatureVerifier::is_valid_type(const char* type, ssize_t limit) {
468   ssize_t index = 0;
469 
470   // Iterate over any number of array dimensions
<a name="51" id="anc51"></a><span class="line-modified">471   while (index &lt; limit &amp;&amp; type[index] == &#39;[&#39;) ++index;</span>
472   if (index &gt;= limit) {
473     return -1;
474   }
475   switch (type[index]) {
<a name="52" id="anc52"></a><span class="line-modified">476     case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;F&#39;: case &#39;I&#39;:</span>
<span class="line-modified">477     case &#39;J&#39;: case &#39;S&#39;: case &#39;Z&#39;: case &#39;V&#39;:</span>







478       return index + 1;
<a name="53" id="anc53"></a><span class="line-modified">479     case &#39;L&#39;:</span>
480       for (index = index + 1; index &lt; limit; ++index) {
481         char c = type[index];
482         switch (c) {
<a name="54" id="anc54"></a><span class="line-modified">483           case &#39;;&#39;:</span>
484             return index + 1;
<a name="55" id="anc55"></a><span class="line-modified">485           case &#39;\0&#39;: case &#39;.&#39;: case &#39;[&#39;:</span>
486             return -1;
487           default: ; // fall through
488         }
489       }
490       // fall through
491     default: ; // fall through
492   }
493   return -1;
494 }
<a name="56" id="anc56"></a>
495 #endif // ASSERT
<a name="57" id="anc57"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="57" type="hidden" />
</body>
</html>
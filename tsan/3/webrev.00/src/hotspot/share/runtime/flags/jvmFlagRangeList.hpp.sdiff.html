<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/flags/jvmFlagRangeList.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jvmFlagRangeList.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../frame.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/flags/jvmFlagRangeList.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
22  *
23  */
24 
25 #ifndef SHARE_RUNTIME_FLAGS_JVMFLAGRANGELIST_HPP
26 #define SHARE_RUNTIME_FLAGS_JVMFLAGRANGELIST_HPP
27 
28 #include &quot;runtime/flags/jvmFlag.hpp&quot;
29 #include &quot;utilities/growableArray.hpp&quot;
30 
31 /*
32  * Here we have a mechanism for extracting ranges specified in flag macro tables.
33  *
34  * The specified ranges are used to verify that flags have valid values.
35  *
36  * An example of a range is &quot;min &lt;= flag &lt;= max&quot;. Both &quot;min&quot; and &quot;max&quot; must be
37  * constant and can not change. If either &quot;min&quot; or &quot;max&quot; can change,
38  * then we need to use constraint instead.
39  */
40 
41 class JVMFlagRange : public CHeapObj&lt;mtArguments&gt; {
<span class="line-modified">42 private:</span>
<span class="line-modified">43   const char* _name;</span>
44 public:
45   // the &quot;name&quot; argument must be a string literal
<span class="line-modified">46   JVMFlagRange(const char* name) { _name=name; }</span>
47   ~JVMFlagRange() {}
<span class="line-modified">48   const char* name() { return _name; }</span>

49   virtual JVMFlag::Error check(bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
50   virtual JVMFlag::Error check_int(int value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
51   virtual JVMFlag::Error check_intx(intx value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
52   virtual JVMFlag::Error check_uint(uint value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
53   virtual JVMFlag::Error check_uintx(uintx value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
54   virtual JVMFlag::Error check_uint64_t(uint64_t value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
55   virtual JVMFlag::Error check_size_t(size_t value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
56   virtual JVMFlag::Error check_double(double value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
57   virtual void print(outputStream* st) { ; }
58 };
59 
60 class JVMFlagRangeList : public AllStatic {
61   static GrowableArray&lt;JVMFlagRange*&gt;* _ranges;
62 public:
63   static void init();
64   static int length() { return (_ranges != NULL) ? _ranges-&gt;length() : 0; }
65   static JVMFlagRange* at(int i) { return (_ranges != NULL) ? _ranges-&gt;at(i) : NULL; }
<span class="line-modified">66   static JVMFlagRange* find(const char* name);</span>
67   static void add(JVMFlagRange* range) { _ranges-&gt;append(range); }
<span class="line-modified">68   static void print(outputStream* st, const char* name, RangeStrFunc default_range_str_func);</span>
69   // Check the final values of all flags for ranges.
70   static bool check_ranges();
71 };
72 
73 #endif // SHARE_RUNTIME_FLAGS_JVMFLAGRANGELIST_HPP
</pre>
</td>
<td>
<hr />
<pre>
22  *
23  */
24 
25 #ifndef SHARE_RUNTIME_FLAGS_JVMFLAGRANGELIST_HPP
26 #define SHARE_RUNTIME_FLAGS_JVMFLAGRANGELIST_HPP
27 
28 #include &quot;runtime/flags/jvmFlag.hpp&quot;
29 #include &quot;utilities/growableArray.hpp&quot;
30 
31 /*
32  * Here we have a mechanism for extracting ranges specified in flag macro tables.
33  *
34  * The specified ranges are used to verify that flags have valid values.
35  *
36  * An example of a range is &quot;min &lt;= flag &lt;= max&quot;. Both &quot;min&quot; and &quot;max&quot; must be
37  * constant and can not change. If either &quot;min&quot; or &quot;max&quot; can change,
38  * then we need to use constraint instead.
39  */
40 
41 class JVMFlagRange : public CHeapObj&lt;mtArguments&gt; {
<span class="line-modified">42 protected:</span>
<span class="line-modified">43   const JVMFlag* const _flag;</span>
44 public:
45   // the &quot;name&quot; argument must be a string literal
<span class="line-modified">46   JVMFlagRange(const JVMFlag* flag) : _flag(flag) {}</span>
47   ~JVMFlagRange() {}
<span class="line-modified">48   const JVMFlag* flag() const { return _flag; }</span>
<span class="line-added">49   const char* name() const { return _flag-&gt;_name; }</span>
50   virtual JVMFlag::Error check(bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
51   virtual JVMFlag::Error check_int(int value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
52   virtual JVMFlag::Error check_intx(intx value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
53   virtual JVMFlag::Error check_uint(uint value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
54   virtual JVMFlag::Error check_uintx(uintx value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
55   virtual JVMFlag::Error check_uint64_t(uint64_t value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
56   virtual JVMFlag::Error check_size_t(size_t value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
57   virtual JVMFlag::Error check_double(double value, bool verbose = true) { ShouldNotReachHere(); return JVMFlag::ERR_OTHER; }
58   virtual void print(outputStream* st) { ; }
59 };
60 
61 class JVMFlagRangeList : public AllStatic {
62   static GrowableArray&lt;JVMFlagRange*&gt;* _ranges;
63 public:
64   static void init();
65   static int length() { return (_ranges != NULL) ? _ranges-&gt;length() : 0; }
66   static JVMFlagRange* at(int i) { return (_ranges != NULL) ? _ranges-&gt;at(i) : NULL; }
<span class="line-modified">67   static JVMFlagRange* find(const JVMFlag* flag);</span>
68   static void add(JVMFlagRange* range) { _ranges-&gt;append(range); }
<span class="line-modified">69   static void print(outputStream* st, const JVMFlag* flag, RangeStrFunc default_range_str_func);</span>
70   // Check the final values of all flags for ranges.
71   static bool check_ranges();
72 };
73 
74 #endif // SHARE_RUNTIME_FLAGS_JVMFLAGRANGELIST_HPP
</pre>
</td>
</tr>
</table>
<center><a href="jvmFlagRangeList.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../frame.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
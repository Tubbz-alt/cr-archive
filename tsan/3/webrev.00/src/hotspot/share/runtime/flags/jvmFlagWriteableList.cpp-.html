<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/flags/jvmFlagWriteableList.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;runtime/flags/jvmFlagWriteableList.hpp&quot;
 27 #include &quot;runtime/os.hpp&quot;
 28 #ifdef COMPILER1
 29 #include &quot;c1/c1_globals.hpp&quot;
 30 #endif // COMPILER1
 31 #ifdef COMPILER2
 32 #include &quot;opto/c2_globals.hpp&quot;
 33 #endif // COMPILER2
 34 #if INCLUDE_JVMCI
 35 #include &quot;jvmci/jvmci_globals.hpp&quot;
 36 #endif
 37 
 38 bool JVMFlagWriteable::is_writeable(void) {
 39   return _writeable;
 40 }
 41 
 42 void JVMFlagWriteable::mark_once(void) {
 43   if (_type == Once) {
 44     _writeable = false;
 45   }
 46 }
 47 
 48 void JVMFlagWriteable::mark_startup(void) {
 49   if (_type == JVMFlagWriteable::CommandLineOnly) {
 50     _writeable = false;
 51   }
 52 }
 53 
 54 // No control emitting
 55 void emit_writeable_no(...)                         { /* NOP */ }
 56 
 57 // No control emitting if type argument is NOT provided
 58 void emit_writeable_bool(const char* /*name*/)      { /* NOP */ }
 59 void emit_writeable_ccstr(const char* /*name*/)     { /* NOP */ }
 60 void emit_writeable_ccstrlist(const char* /*name*/) { /* NOP */ }
 61 void emit_writeable_int(const char* /*name*/)       { /* NOP */ }
 62 void emit_writeable_intx(const char* /*name*/)      { /* NOP */ }
 63 void emit_writeable_uint(const char* /*name*/)      { /* NOP */ }
 64 void emit_writeable_uintx(const char* /*name*/)     { /* NOP */ }
 65 void emit_writeable_uint64_t(const char* /*name*/)  { /* NOP */ }
 66 void emit_writeable_size_t(const char* /*name*/)    { /* NOP */ }
 67 void emit_writeable_double(const char* /*name*/)    { /* NOP */ }
 68 
 69 // JVMFlagWriteable emitting code functions if range arguments are provided
 70 void emit_writeable_bool(const char* name, JVMFlagWriteable::WriteableType type) {
 71   JVMFlagWriteableList::add(new JVMFlagWriteable(name, type));
 72 }
 73 void emit_writeable_int(const char* name, JVMFlagWriteable::WriteableType type) {
 74   JVMFlagWriteableList::add(new JVMFlagWriteable(name, type));
 75 }
 76 void emit_writeable_intx(const char* name, JVMFlagWriteable::WriteableType type) {
 77   JVMFlagWriteableList::add(new JVMFlagWriteable(name, type));
 78 }
 79 void emit_writeable_uint(const char* name, JVMFlagWriteable::WriteableType type) {
 80   JVMFlagWriteableList::add(new JVMFlagWriteable(name, type));
 81 }
 82 void emit_writeable_uintx(const char* name, JVMFlagWriteable::WriteableType type) {
 83   JVMFlagWriteableList::add(new JVMFlagWriteable(name, type));
 84 }
 85 void emit_writeable_uint64_t(const char* name, JVMFlagWriteable::WriteableType type) {
 86   JVMFlagWriteableList::add(new JVMFlagWriteable(name, type));
 87 }
 88 void emit_writeable_size_t(const char* name, JVMFlagWriteable::WriteableType type) {
 89   JVMFlagWriteableList::add(new JVMFlagWriteable(name, type));
 90 }
 91 void emit_writeable_double(const char* name, JVMFlagWriteable::WriteableType type) {
 92   JVMFlagWriteableList::add(new JVMFlagWriteable(name, type));
 93 }
 94 
 95 // Generate code to call emit_writeable_xxx function
 96 #define EMIT_WRITEABLE_PRODUCT_FLAG(type, name, value, doc)      ); emit_writeable_##type(#name
 97 #define EMIT_WRITEABLE_DIAGNOSTIC_FLAG(type, name, value, doc)   ); emit_writeable_##type(#name
 98 #define EMIT_WRITEABLE_EXPERIMENTAL_FLAG(type, name, value, doc) ); emit_writeable_##type(#name
 99 #define EMIT_WRITEABLE_MANAGEABLE_FLAG(type, name, value, doc)   ); emit_writeable_##type(#name
100 #define EMIT_WRITEABLE_PRODUCT_RW_FLAG(type, name, value, doc)   ); emit_writeable_##type(#name
101 #define EMIT_WRITEABLE_PD_PRODUCT_FLAG(type, name, doc)          ); emit_writeable_##type(#name
102 #define EMIT_WRITEABLE_DEVELOPER_FLAG(type, name, value, doc)    ); emit_writeable_##type(#name
103 #define EMIT_WRITEABLE_PD_DEVELOPER_FLAG(type, name, doc)        ); emit_writeable_##type(#name
104 #define EMIT_WRITEABLE_PD_DIAGNOSTIC_FLAG(type, name, doc)       ); emit_writeable_##type(#name
105 #define EMIT_WRITEABLE_NOTPRODUCT_FLAG(type, name, value, doc)   ); emit_writeable_##type(#name
106 #define EMIT_WRITEABLE_LP64_PRODUCT_FLAG(type, name, value, doc) ); emit_writeable_##type(#name
107 
108 // Generate type argument to pass into emit_writeable_xxx functions
109 #define EMIT_WRITEABLE(a)                                      , JVMFlagWriteable::a
110 
111 #define INITIAL_WRITEABLES_SIZE 2
112 GrowableArray&lt;JVMFlagWriteable*&gt;* JVMFlagWriteableList::_controls = NULL;
113 
114 void JVMFlagWriteableList::init(void) {
115 
116   _controls = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;JVMFlagWriteable*&gt;(INITIAL_WRITEABLES_SIZE, true);
117 
118   emit_writeable_no(NULL VM_FLAGS(EMIT_WRITEABLE_DEVELOPER_FLAG,
119                                   EMIT_WRITEABLE_PD_DEVELOPER_FLAG,
120                                   EMIT_WRITEABLE_PRODUCT_FLAG,
121                                   EMIT_WRITEABLE_PD_PRODUCT_FLAG,
122                                   EMIT_WRITEABLE_DIAGNOSTIC_FLAG,
123                                   EMIT_WRITEABLE_PD_DIAGNOSTIC_FLAG,
124                                   EMIT_WRITEABLE_EXPERIMENTAL_FLAG,
125                                   EMIT_WRITEABLE_NOTPRODUCT_FLAG,
126                                   EMIT_WRITEABLE_MANAGEABLE_FLAG,
127                                   EMIT_WRITEABLE_PRODUCT_RW_FLAG,
128                                   EMIT_WRITEABLE_LP64_PRODUCT_FLAG,
129                                   IGNORE_RANGE,
130                                   IGNORE_CONSTRAINT,
131                                   EMIT_WRITEABLE));
132 
133   EMIT_WRITEABLES_FOR_GLOBALS_EXT
134 
135   emit_writeable_no(NULL ARCH_FLAGS(EMIT_WRITEABLE_DEVELOPER_FLAG,
136                                 EMIT_WRITEABLE_PRODUCT_FLAG,
137                                 EMIT_WRITEABLE_DIAGNOSTIC_FLAG,
138                                 EMIT_WRITEABLE_EXPERIMENTAL_FLAG,
139                                 EMIT_WRITEABLE_NOTPRODUCT_FLAG,
140                                 IGNORE_RANGE,
141                                 IGNORE_CONSTRAINT,
142                                 EMIT_WRITEABLE));
143 
144 #if INCLUDE_JVMCI
145   emit_writeable_no(NULL JVMCI_FLAGS(EMIT_WRITEABLE_DEVELOPER_FLAG,
146                                  EMIT_WRITEABLE_PD_DEVELOPER_FLAG,
147                                  EMIT_WRITEABLE_PRODUCT_FLAG,
148                                  EMIT_WRITEABLE_PD_PRODUCT_FLAG,
149                                  EMIT_WRITEABLE_DIAGNOSTIC_FLAG,
150                                  EMIT_WRITEABLE_PD_DIAGNOSTIC_FLAG,
151                                  EMIT_WRITEABLE_EXPERIMENTAL_FLAG,
152                                  EMIT_WRITEABLE_NOTPRODUCT_FLAG,
153                                  IGNORE_RANGE,
154                                  IGNORE_CONSTRAINT,
155                                  EMIT_WRITEABLE));
156 #endif // INCLUDE_JVMCI
157 
158 #ifdef COMPILER1
159   emit_writeable_no(NULL C1_FLAGS(EMIT_WRITEABLE_DEVELOPER_FLAG,
160                               EMIT_WRITEABLE_PD_DEVELOPER_FLAG,
161                               EMIT_WRITEABLE_PRODUCT_FLAG,
162                               EMIT_WRITEABLE_PD_PRODUCT_FLAG,
163                               EMIT_WRITEABLE_DIAGNOSTIC_FLAG,
164                               EMIT_WRITEABLE_PD_DIAGNOSTIC_FLAG,
165                               EMIT_WRITEABLE_NOTPRODUCT_FLAG,
166                               IGNORE_RANGE,
167                               IGNORE_CONSTRAINT,
168                               EMIT_WRITEABLE));
169 #endif // COMPILER1
170 
171 #ifdef COMPILER2
172   emit_writeable_no(NULL C2_FLAGS(EMIT_WRITEABLE_DEVELOPER_FLAG,
173                               EMIT_WRITEABLE_PD_DEVELOPER_FLAG,
174                               EMIT_WRITEABLE_PRODUCT_FLAG,
175                               EMIT_WRITEABLE_PD_PRODUCT_FLAG,
176                               EMIT_WRITEABLE_DIAGNOSTIC_FLAG,
177                               EMIT_WRITEABLE_PD_DIAGNOSTIC_FLAG,
178                               EMIT_WRITEABLE_EXPERIMENTAL_FLAG,
179                               EMIT_WRITEABLE_NOTPRODUCT_FLAG,
180                               IGNORE_RANGE,
181                               IGNORE_CONSTRAINT,
182                               EMIT_WRITEABLE));
183 #endif // COMPILER2
184 }
185 
186 JVMFlagWriteable* JVMFlagWriteableList::find(const char* name) {
187   JVMFlagWriteable* found = NULL;
188   for (int i=0; i&lt;length(); i++) {
189     JVMFlagWriteable* writeable = at(i);
190     if (strcmp(writeable-&gt;name(), name) == 0) {
191       found = writeable;
192       break;
193     }
194   }
195   return found;
196 }
197 
198 void JVMFlagWriteableList::mark_startup(void) {
199   for (int i=0; i&lt;length(); i++) {
200     JVMFlagWriteable* writeable = at(i);
201     writeable-&gt;mark_startup();
202   }
203 }
    </pre>
  </body>
</html>
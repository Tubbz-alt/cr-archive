<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/flags/jvmFlag.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../fieldDescriptor.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlag.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/flags/jvmFlag.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,11 ***</span>
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/flags/jvmFlag.hpp&quot;
  #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
<span class="line-removed">- #include &quot;runtime/flags/jvmFlagWriteableList.hpp&quot;</span>
  #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;utilities/defaultStream.hpp&quot;
  #include &quot;utilities/stringUtils.hpp&quot;
  
<span class="line-new-header">--- 26,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,190 ***</span>
  #else
    return false;
  #endif
  }
  
<span class="line-removed">- JVMFlag::Error JVMFlag::check_writable(bool changed) {</span>
<span class="line-removed">-   if (is_constant_in_binary()) {</span>
<span class="line-removed">-     fatal(&quot;flag is constant: %s&quot;, _name);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   JVMFlag::Error error = JVMFlag::SUCCESS;</span>
<span class="line-removed">-   if (changed) {</span>
<span class="line-removed">-     JVMFlagWriteable* writeable = JVMFlagWriteableList::find(_name);</span>
<span class="line-removed">-     if (writeable) {</span>
<span class="line-removed">-       if (writeable-&gt;is_writeable() == false) {</span>
<span class="line-removed">-         switch (writeable-&gt;type())</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           case JVMFlagWriteable::Once:</span>
<span class="line-removed">-             error = JVMFlag::SET_ONLY_ONCE;</span>
<span class="line-removed">-             jio_fprintf(defaultStream::error_stream(), &quot;Error: %s may not be set more than once\n&quot;, _name);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-           case JVMFlagWriteable::CommandLineOnly:</span>
<span class="line-removed">-             error = JVMFlag::COMMAND_LINE_ONLY;</span>
<span class="line-removed">-             jio_fprintf(defaultStream::error_stream(), &quot;Error: %s may be modified only from commad line\n&quot;, _name);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-           default:</span>
<span class="line-removed">-             ShouldNotReachHere();</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       writeable-&gt;mark_once();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return error;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool JVMFlag::is_bool() const {
    return strcmp(_type, &quot;bool&quot;) == 0;
  }
  
<span class="line-removed">- bool JVMFlag::get_bool() const {</span>
<span class="line-removed">-   return *((bool*) _addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::set_bool(bool value) {</span>
<span class="line-removed">-   JVMFlag::Error error = check_writable(value!=get_bool());</span>
<span class="line-removed">-   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed">-     *((bool*) _addr) = value;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return error;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool JVMFlag::is_int() const {
    return strcmp(_type, &quot;int&quot;)  == 0;
  }
  
<span class="line-removed">- int JVMFlag::get_int() const {</span>
<span class="line-removed">-   return *((int*) _addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::set_int(int value) {</span>
<span class="line-removed">-   JVMFlag::Error error = check_writable(value!=get_int());</span>
<span class="line-removed">-   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed">-     *((int*) _addr) = value;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return error;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool JVMFlag::is_uint() const {
    return strcmp(_type, &quot;uint&quot;)  == 0;
  }
  
<span class="line-removed">- uint JVMFlag::get_uint() const {</span>
<span class="line-removed">-   return *((uint*) _addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::set_uint(uint value) {</span>
<span class="line-removed">-   JVMFlag::Error error = check_writable(value!=get_uint());</span>
<span class="line-removed">-   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed">-     *((uint*) _addr) = value;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return error;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool JVMFlag::is_intx() const {
    return strcmp(_type, &quot;intx&quot;)  == 0;
  }
  
<span class="line-removed">- intx JVMFlag::get_intx() const {</span>
<span class="line-removed">-   return *((intx*) _addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::set_intx(intx value) {</span>
<span class="line-removed">-   JVMFlag::Error error = check_writable(value!=get_intx());</span>
<span class="line-removed">-   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed">-     *((intx*) _addr) = value;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return error;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool JVMFlag::is_uintx() const {
    return strcmp(_type, &quot;uintx&quot;) == 0;
  }
  
<span class="line-removed">- uintx JVMFlag::get_uintx() const {</span>
<span class="line-removed">-   return *((uintx*) _addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::set_uintx(uintx value) {</span>
<span class="line-removed">-   JVMFlag::Error error = check_writable(value!=get_uintx());</span>
<span class="line-removed">-   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed">-     *((uintx*) _addr) = value;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return error;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool JVMFlag::is_uint64_t() const {
    return strcmp(_type, &quot;uint64_t&quot;) == 0;
  }
  
<span class="line-removed">- uint64_t JVMFlag::get_uint64_t() const {</span>
<span class="line-removed">-   return *((uint64_t*) _addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::set_uint64_t(uint64_t value) {</span>
<span class="line-removed">-   JVMFlag::Error error = check_writable(value!=get_uint64_t());</span>
<span class="line-removed">-   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed">-     *((uint64_t*) _addr) = value;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return error;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool JVMFlag::is_size_t() const {
    return strcmp(_type, &quot;size_t&quot;) == 0;
  }
  
<span class="line-removed">- size_t JVMFlag::get_size_t() const {</span>
<span class="line-removed">-   return *((size_t*) _addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::set_size_t(size_t value) {</span>
<span class="line-removed">-   JVMFlag::Error error = check_writable(value!=get_size_t());</span>
<span class="line-removed">-   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed">-     *((size_t*) _addr) = value;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return error;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool JVMFlag::is_double() const {
    return strcmp(_type, &quot;double&quot;) == 0;
  }
  
<span class="line-removed">- double JVMFlag::get_double() const {</span>
<span class="line-removed">-   return *((double*) _addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::set_double(double value) {</span>
<span class="line-removed">-   JVMFlag::Error error = check_writable(value!=get_double());</span>
<span class="line-removed">-   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed">-     *((double*) _addr) = value;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return error;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool JVMFlag::is_ccstr() const {
    return strcmp(_type, &quot;ccstr&quot;) == 0 || strcmp(_type, &quot;ccstrlist&quot;) == 0;
  }
  
  bool JVMFlag::ccstr_accumulates() const {
    return strcmp(_type, &quot;ccstrlist&quot;) == 0;
  }
  
<span class="line-removed">- ccstr JVMFlag::get_ccstr() const {</span>
<span class="line-removed">-   return *((ccstr*) _addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::set_ccstr(ccstr value) {</span>
<span class="line-removed">-   JVMFlag::Error error = check_writable(value!=get_ccstr());</span>
<span class="line-removed">-   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed">-     *((ccstr*) _addr) = value;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return error;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  JVMFlag::Flags JVMFlag::get_origin() {
    return Flags(_flags &amp; VALUE_ORIGIN_MASK);
  }
  
  void JVMFlag::set_origin(Flags origin) {
<span class="line-new-header">--- 89,50 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 337,31 ***</span>
    return false;
  #endif
  }
  
  bool JVMFlag::is_unlocker() const {
<span class="line-modified">!   return strcmp(_name, &quot;UnlockDiagnosticVMOptions&quot;) == 0     ||</span>
<span class="line-modified">!   strcmp(_name, &quot;UnlockExperimentalVMOptions&quot;) == 0   ||</span>
<span class="line-removed">-   is_unlocker_ext();</span>
  }
  
  bool JVMFlag::is_unlocked() const {
    if (is_diagnostic()) {
      return UnlockDiagnosticVMOptions;
    }
    if (is_experimental()) {
      return UnlockExperimentalVMOptions;
    }
<span class="line-modified">!   return is_unlocked_ext();</span>
  }
  
  void JVMFlag::clear_diagnostic() {
    assert(is_diagnostic(), &quot;sanity&quot;);
    _flags = Flags(_flags &amp; ~KIND_DIAGNOSTIC);
    assert(!is_diagnostic(), &quot;sanity&quot;);
  }
  
  // Get custom message for this locked flag, or NULL if
  // none is available. Returns message type produced.
  JVMFlag::MsgType JVMFlag::get_locked_message(char* buf, int buflen) const {
    buf[0] = &#39;\0&#39;;
    if (is_diagnostic() &amp;&amp; !is_unlocked()) {
<span class="line-new-header">--- 196,42 ---</span>
    return false;
  #endif
  }
  
  bool JVMFlag::is_unlocker() const {
<span class="line-modified">!   return strcmp(_name, &quot;UnlockDiagnosticVMOptions&quot;) == 0 ||</span>
<span class="line-modified">!          strcmp(_name, &quot;UnlockExperimentalVMOptions&quot;) == 0;</span>
  }
  
  bool JVMFlag::is_unlocked() const {
    if (is_diagnostic()) {
      return UnlockDiagnosticVMOptions;
    }
    if (is_experimental()) {
      return UnlockExperimentalVMOptions;
    }
<span class="line-modified">!   return true;</span>
  }
  
  void JVMFlag::clear_diagnostic() {
    assert(is_diagnostic(), &quot;sanity&quot;);
    _flags = Flags(_flags &amp; ~KIND_DIAGNOSTIC);
    assert(!is_diagnostic(), &quot;sanity&quot;);
  }
  
<span class="line-added">+ void JVMFlag::clear_experimental() {</span>
<span class="line-added">+   assert(is_experimental(), &quot;sanity&quot;);</span>
<span class="line-added">+  _flags = Flags(_flags &amp; ~KIND_EXPERIMENTAL);</span>
<span class="line-added">+   assert(!is_experimental(), &quot;sanity&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMFlag::set_product() {</span>
<span class="line-added">+   assert(!is_product(), &quot;sanity&quot;);</span>
<span class="line-added">+  _flags = Flags(_flags | KIND_PRODUCT);</span>
<span class="line-added">+   assert(is_product(), &quot;sanity&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Get custom message for this locked flag, or NULL if
  // none is available. Returns message type produced.
  JVMFlag::MsgType JVMFlag::get_locked_message(char* buf, int buflen) const {
    buf[0] = &#39;\0&#39;;
    if (is_diagnostic() &amp;&amp; !is_unlocked()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 386,22 ***</span>
    if (is_notproduct() &amp;&amp; is_product_build()) {
      jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is notproduct and is available only in debug version of VM.\n&quot;,
                   _name);
      return JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD;
    }
<span class="line-modified">!   return get_locked_message_ext(buf, buflen);</span>
  }
  
  bool JVMFlag::is_writeable() const {
<span class="line-modified">!   return is_manageable() || (is_product() &amp;&amp; is_read_write()) || is_writeable_ext();</span>
  }
  
  // All flags except &quot;manageable&quot; are assumed to be internal flags.
  // Long term, we need to define a mechanism to specify which flags
  // are external/stable and change this function accordingly.
  bool JVMFlag::is_external() const {
<span class="line-modified">!   return is_manageable() || is_external_ext();</span>
  }
  
  // Helper function for JVMFlag::print_on().
  // Fills current line up to requested position.
  // Should the current position already be past the requested position,
<span class="line-new-header">--- 256,22 ---</span>
    if (is_notproduct() &amp;&amp; is_product_build()) {
      jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is notproduct and is available only in debug version of VM.\n&quot;,
                   _name);
      return JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD;
    }
<span class="line-modified">!   return JVMFlag::NONE;</span>
  }
  
  bool JVMFlag::is_writeable() const {
<span class="line-modified">!   return is_manageable() || (is_product() &amp;&amp; is_read_write());</span>
  }
  
  // All flags except &quot;manageable&quot; are assumed to be internal flags.
  // Long term, we need to define a mechanism to specify which flags
  // are external/stable and change this function accordingly.
  bool JVMFlag::is_external() const {
<span class="line-modified">!   return is_manageable();</span>
  }
  
  // Helper function for JVMFlag::print_on().
  // Fills current line up to requested position.
  // Should the current position already be past the requested position,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,15 ***</span>
      //
      //  The column widths are fixed. They are defined such that, for most cases,
      //  an eye-pleasing tabular output is created.
      //
      //  Sample output:
<span class="line-modified">!     //       bool CMSScavengeBeforeRemark                  = false                                     {product} {default}</span>
<span class="line-modified">!     //      uintx CMSScheduleRemarkEdenPenetration         = 50                                        {product} {default}</span>
<span class="line-modified">!     //     size_t CMSScheduleRemarkEdenSizeThreshold       = 2097152                                   {product} {default}</span>
<span class="line-modified">!     //      uintx CMSScheduleRemarkSamplingRatio           = 5                                         {product} {default}</span>
<span class="line-modified">!     //     double CMSSmallCoalSurplusPercent               = 1.050000                                  {product} {default}</span>
      //      ccstr CompileCommandFile                       = MyFile.cmd                                {product} {command line}
      //  ccstrlist CompileOnly                              = Method1
      //            CompileOnly                             += Method2                                   {product} {command line}
      //  |         |                                       |  |                              |                    |               |
      //  |         |                                       |  |                              |                    |               +-- col7
<span class="line-new-header">--- 304,15 ---</span>
      //
      //  The column widths are fixed. They are defined such that, for most cases,
      //  an eye-pleasing tabular output is created.
      //
      //  Sample output:
<span class="line-modified">!     //       bool ThreadPriorityVerbose                    = false                                     {product} {default}</span>
<span class="line-modified">!     //      uintx ThresholdTolerance                       = 10                                        {product} {default}</span>
<span class="line-modified">!     //     size_t TLABSize                                 = 0                                         {product} {default}</span>
<span class="line-modified">!     //      uintx SurvivorRatio                            = 8                                         {product} {default}</span>
<span class="line-modified">!     //     double InitialRAMPercentage                     = 1.562500                                  {product} {default}</span>
      //      ccstr CompileCommandFile                       = MyFile.cmd                                {product} {command line}
      //  ccstrlist CompileOnly                              = Method1
      //            CompileOnly                             += Method2                                   {product} {command line}
      //  |         |                                       |  |                              |                    |               |
      //  |         |                                       |  |                              |                    |               +-- col7
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,11 ***</span>
      } else {
        st-&gt;print(&quot;unhandled  type %s&quot;, _type);
        st-&gt;cr();
        return;
      }
<span class="line-modified">!     JVMFlagRangeList::print(st, _name, func);</span>
  
      fill_to_pos(st, col5_pos);
      print_kind(st, col5_width);
  
      fill_to_pos(st, col6_pos);
<span class="line-new-header">--- 472,11 ---</span>
      } else {
        st-&gt;print(&quot;unhandled  type %s&quot;, _type);
        st-&gt;cr();
        return;
      }
<span class="line-modified">!     JVMFlagRangeList::print(st, this, func);</span>
  
      fill_to_pos(st, col5_pos);
      print_kind(st, col5_width);
  
      fill_to_pos(st, col6_pos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,10 ***</span>
<span class="line-new-header">--- 566,12 ---</span>
        st-&gt;print(&quot;ergonomic&quot;); break;
      case ATTACH_ON_DEMAND:
        st-&gt;print(&quot;attach&quot;); break;
      case INTERNAL:
        st-&gt;print(&quot;internal&quot;); break;
<span class="line-added">+     case JIMAGE_RESOURCE:</span>
<span class="line-added">+       st-&gt;print(&quot;jimage&quot;); break;</span>
    }
    st-&gt;print(&quot;}&quot;);
  }
  
  void JVMFlag::print_as_flag(outputStream* st) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 820,47 ***</span>
             RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
             RUNTIME_MANAGEABLE_FLAG_STRUCT, \
             RUNTIME_PRODUCT_RW_FLAG_STRUCT, \
             RUNTIME_LP64_PRODUCT_FLAG_STRUCT, \
             IGNORE_RANGE, \
<span class="line-modified">!            IGNORE_CONSTRAINT, \</span>
<span class="line-removed">-            IGNORE_WRITEABLE)</span>
  
    RUNTIME_OS_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
                     RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
                     RUNTIME_PRODUCT_FLAG_STRUCT, \
                     RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
                     RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
                     RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
                     RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
                     IGNORE_RANGE, \
<span class="line-modified">!                    IGNORE_CONSTRAINT, \</span>
<span class="line-removed">-                    IGNORE_WRITEABLE)</span>
  #if INCLUDE_JVMCI
    JVMCI_FLAGS(JVMCI_DEVELOP_FLAG_STRUCT, \
                JVMCI_PD_DEVELOP_FLAG_STRUCT, \
                JVMCI_PRODUCT_FLAG_STRUCT, \
                JVMCI_PD_PRODUCT_FLAG_STRUCT, \
                JVMCI_DIAGNOSTIC_FLAG_STRUCT, \
                JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT, \
                JVMCI_EXPERIMENTAL_FLAG_STRUCT, \
                JVMCI_NOTPRODUCT_FLAG_STRUCT, \
                IGNORE_RANGE, \
<span class="line-modified">!               IGNORE_CONSTRAINT, \</span>
<span class="line-removed">-               IGNORE_WRITEABLE)</span>
  #endif // INCLUDE_JVMCI
  #ifdef COMPILER1
    C1_FLAGS(C1_DEVELOP_FLAG_STRUCT, \
             C1_PD_DEVELOP_FLAG_STRUCT, \
             C1_PRODUCT_FLAG_STRUCT, \
             C1_PD_PRODUCT_FLAG_STRUCT, \
             C1_DIAGNOSTIC_FLAG_STRUCT, \
             C1_PD_DIAGNOSTIC_FLAG_STRUCT, \
             C1_NOTPRODUCT_FLAG_STRUCT, \
             IGNORE_RANGE, \
<span class="line-modified">!            IGNORE_CONSTRAINT, \</span>
<span class="line-removed">-            IGNORE_WRITEABLE)</span>
  #endif // COMPILER1
  #ifdef COMPILER2
    C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, \
             C2_PD_DEVELOP_FLAG_STRUCT, \
             C2_PRODUCT_FLAG_STRUCT, \
<span class="line-new-header">--- 692,43 ---</span>
             RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
             RUNTIME_MANAGEABLE_FLAG_STRUCT, \
             RUNTIME_PRODUCT_RW_FLAG_STRUCT, \
             RUNTIME_LP64_PRODUCT_FLAG_STRUCT, \
             IGNORE_RANGE, \
<span class="line-modified">!            IGNORE_CONSTRAINT)</span>
  
    RUNTIME_OS_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
                     RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
                     RUNTIME_PRODUCT_FLAG_STRUCT, \
                     RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
                     RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
                     RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
                     RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
                     IGNORE_RANGE, \
<span class="line-modified">!                    IGNORE_CONSTRAINT)</span>
  #if INCLUDE_JVMCI
    JVMCI_FLAGS(JVMCI_DEVELOP_FLAG_STRUCT, \
                JVMCI_PD_DEVELOP_FLAG_STRUCT, \
                JVMCI_PRODUCT_FLAG_STRUCT, \
                JVMCI_PD_PRODUCT_FLAG_STRUCT, \
                JVMCI_DIAGNOSTIC_FLAG_STRUCT, \
                JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT, \
                JVMCI_EXPERIMENTAL_FLAG_STRUCT, \
                JVMCI_NOTPRODUCT_FLAG_STRUCT, \
                IGNORE_RANGE, \
<span class="line-modified">!               IGNORE_CONSTRAINT)</span>
  #endif // INCLUDE_JVMCI
  #ifdef COMPILER1
    C1_FLAGS(C1_DEVELOP_FLAG_STRUCT, \
             C1_PD_DEVELOP_FLAG_STRUCT, \
             C1_PRODUCT_FLAG_STRUCT, \
             C1_PD_PRODUCT_FLAG_STRUCT, \
             C1_DIAGNOSTIC_FLAG_STRUCT, \
             C1_PD_DIAGNOSTIC_FLAG_STRUCT, \
             C1_NOTPRODUCT_FLAG_STRUCT, \
             IGNORE_RANGE, \
<span class="line-modified">!            IGNORE_CONSTRAINT)</span>
  #endif // COMPILER1
  #ifdef COMPILER2
    C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, \
             C2_PD_DEVELOP_FLAG_STRUCT, \
             C2_PRODUCT_FLAG_STRUCT, \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 868,22 ***</span>
             C2_DIAGNOSTIC_FLAG_STRUCT, \
             C2_PD_DIAGNOSTIC_FLAG_STRUCT, \
             C2_EXPERIMENTAL_FLAG_STRUCT, \
             C2_NOTPRODUCT_FLAG_STRUCT, \
             IGNORE_RANGE, \
<span class="line-modified">!            IGNORE_CONSTRAINT, \</span>
<span class="line-removed">-            IGNORE_WRITEABLE)</span>
  #endif // COMPILER2
    ARCH_FLAGS(ARCH_DEVELOP_FLAG_STRUCT, \
               ARCH_PRODUCT_FLAG_STRUCT, \
               ARCH_DIAGNOSTIC_FLAG_STRUCT, \
               ARCH_EXPERIMENTAL_FLAG_STRUCT, \
               ARCH_NOTPRODUCT_FLAG_STRUCT, \
               IGNORE_RANGE, \
<span class="line-modified">!              IGNORE_CONSTRAINT, \</span>
<span class="line-removed">-              IGNORE_WRITEABLE)</span>
<span class="line-removed">-   FLAGTABLE_EXT</span>
    {0, NULL, NULL}
  };
  
  JVMFlag* JVMFlag::flags = flagTable;
  size_t JVMFlag::numFlags = (sizeof(flagTable) / sizeof(JVMFlag));
<span class="line-new-header">--- 736,19 ---</span>
             C2_DIAGNOSTIC_FLAG_STRUCT, \
             C2_PD_DIAGNOSTIC_FLAG_STRUCT, \
             C2_EXPERIMENTAL_FLAG_STRUCT, \
             C2_NOTPRODUCT_FLAG_STRUCT, \
             IGNORE_RANGE, \
<span class="line-modified">!            IGNORE_CONSTRAINT)</span>
  #endif // COMPILER2
    ARCH_FLAGS(ARCH_DEVELOP_FLAG_STRUCT, \
               ARCH_PRODUCT_FLAG_STRUCT, \
               ARCH_DIAGNOSTIC_FLAG_STRUCT, \
               ARCH_EXPERIMENTAL_FLAG_STRUCT, \
               ARCH_NOTPRODUCT_FLAG_STRUCT, \
               IGNORE_RANGE, \
<span class="line-modified">!              IGNORE_CONSTRAINT)</span>
    {0, NULL, NULL}
  };
  
  JVMFlag* JVMFlag::flags = flagTable;
  size_t JVMFlag::numFlags = (sizeof(flagTable) / sizeof(JVMFlag));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 955,484 ***</span>
  
    return match;
  }
  
  // Returns the address of the index&#39;th element
<span class="line-modified">! static JVMFlag* address_of_flag(JVMFlagsWithType flag) {</span>
    assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);
    return &amp;JVMFlag::flags[flag];
  }
  
<span class="line-modified">! bool JVMFlagEx::is_default(JVMFlags flag) {</span>
<span class="line-modified">!   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-removed">-   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-removed">-   return f-&gt;is_default();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool JVMFlagEx::is_ergo(JVMFlags flag) {</span>
<span class="line-removed">-   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-removed">-   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-removed">-   return f-&gt;is_ergonomic();</span>
  }
  
<span class="line-modified">! bool JVMFlagEx::is_cmdline(JVMFlags flag) {</span>
<span class="line-modified">!   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-removed">-   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-removed">-   return f-&gt;is_command_line();</span>
  }
  
<span class="line-modified">! bool JVMFlag::wasSetOnCmdline(const char* name, bool* value) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag((char*)name, strlen(name));</span>
<span class="line-removed">-   if (result == NULL) return false;</span>
<span class="line-removed">-   *value = result-&gt;is_command_line();</span>
<span class="line-removed">-   return true;</span>
  }
  
<span class="line-modified">! void JVMFlagEx::setOnCmdLine(JVMFlagsWithType flag) {</span>
<span class="line-modified">!   JVMFlag* faddr = address_of_flag(flag);</span>
    assert(faddr != NULL, &quot;Unknown flag&quot;);
    faddr-&gt;set_command_line();
  }
  
  template&lt;class E, class T&gt;
<span class="line-modified">! static void trace_flag_changed(const char* name, const T old_value, const T new_value, const JVMFlag::Flags origin) {</span>
    E e;
<span class="line-modified">!   e.set_name(name);</span>
    e.set_oldValue(old_value);
    e.set_newValue(new_value);
    e.set_origin(origin);
    e.commit();
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_bool(const char* name, bool new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
    if (constraint != NULL) {
      status = constraint-&gt;apply_bool(new_value, verbose);
    }
    return status;
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::boolAt(const char* name, size_t len, bool* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">!   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!result-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">-   *value = result-&gt;get_bool();</span>
    return JVMFlag::SUCCESS;
  }
  
  JVMFlag::Error JVMFlag::boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin) {
<span class="line-removed">-   const char* name;</span>
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   name = flag-&gt;_name;</span>
<span class="line-removed">-   JVMFlag::Error check = apply_constraint_and_check_range_bool(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    bool old_value = flag-&gt;get_bool();
<span class="line-modified">!   trace_flag_changed&lt;EventBooleanFlagChanged, bool&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">!   check = flag-&gt;set_bool(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return check;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::boolAtPut(const char* name, size_t len, bool* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">-   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">-   return boolAtPut(result, value, origin);</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::boolAtPut(JVMFlagsWithType flag, bool value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = address_of_flag(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_bool(), &quot;wrong flag type&quot;);
    return JVMFlag::boolAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_int(const char* name, int new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
    if (range != NULL) {
      status = range-&gt;check_int(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_int(new_value, verbose);
      }
    }
    return status;
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::intAt(const char* name, size_t len, int* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">!   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!result-&gt;is_int()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">-   *value = result-&gt;get_int();</span>
    return JVMFlag::SUCCESS;
  }
  
  JVMFlag::Error JVMFlag::intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin) {
<span class="line-removed">-   const char* name;</span>
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   name = flag-&gt;_name;</span>
<span class="line-removed">-   JVMFlag::Error check = apply_constraint_and_check_range_int(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    int old_value = flag-&gt;get_int();
<span class="line-modified">!   trace_flag_changed&lt;EventIntFlagChanged, s4&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">!   check = flag-&gt;set_int(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return check;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::intAtPut(const char* name, size_t len, int* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">-   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">-   return intAtPut(result, value, origin);</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::intAtPut(JVMFlagsWithType flag, int value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = address_of_flag(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_int(), &quot;wrong flag type&quot;);
    return JVMFlag::intAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_uint(const char* name, uint new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
    if (range != NULL) {
      status = range-&gt;check_uint(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_uint(new_value, verbose);
      }
    }
    return status;
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::uintAt(const char* name, size_t len, uint* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">!   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!result-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">-   *value = result-&gt;get_uint();</span>
    return JVMFlag::SUCCESS;
  }
  
  JVMFlag::Error JVMFlag::uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin) {
<span class="line-removed">-   const char* name;</span>
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   name = flag-&gt;_name;</span>
<span class="line-removed">-   JVMFlag::Error check = apply_constraint_and_check_range_uint(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    uint old_value = flag-&gt;get_uint();
<span class="line-modified">!   trace_flag_changed&lt;EventUnsignedIntFlagChanged, u4&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">!   check = flag-&gt;set_uint(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return check;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::uintAtPut(const char* name, size_t len, uint* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">-   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">-   return uintAtPut(result, value, origin);</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::uintAtPut(JVMFlagsWithType flag, uint value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = address_of_flag(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint(), &quot;wrong flag type&quot;);
    return JVMFlag::uintAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::intxAt(const char* name, size_t len, intx* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">!   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!result-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">-   *value = result-&gt;get_intx();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_intx(const char* name, intx new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
    if (range != NULL) {
      status = range-&gt;check_intx(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_intx(new_value, verbose);
      }
    }
    return status;
  }
  
  JVMFlag::Error JVMFlag::intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin) {
<span class="line-removed">-   const char* name;</span>
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   name = flag-&gt;_name;</span>
<span class="line-removed">-   JVMFlag::Error check = apply_constraint_and_check_range_intx(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    intx old_value = flag-&gt;get_intx();
<span class="line-modified">!   trace_flag_changed&lt;EventLongFlagChanged, intx&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">!   check = flag-&gt;set_intx(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return check;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::intxAtPut(const char* name, size_t len, intx* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">-   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">-   return intxAtPut(result, value, origin);</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::intxAtPut(JVMFlagsWithType flag, intx value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = address_of_flag(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_intx(), &quot;wrong flag type&quot;);
    return JVMFlag::intxAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::uintxAt(const char* name, size_t len, uintx* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">!   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!result-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">-   *value = result-&gt;get_uintx();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_uintx(const char* name, uintx new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
    if (range != NULL) {
      status = range-&gt;check_uintx(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_uintx(new_value, verbose);
      }
    }
    return status;
  }
  
  JVMFlag::Error JVMFlag::uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin) {
<span class="line-removed">-   const char* name;</span>
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   name = flag-&gt;_name;</span>
<span class="line-removed">-   JVMFlag::Error check = apply_constraint_and_check_range_uintx(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    uintx old_value = flag-&gt;get_uintx();
<span class="line-modified">!   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">!   check = flag-&gt;set_uintx(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return check;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::uintxAtPut(const char* name, size_t len, uintx* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">-   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">-   return uintxAtPut(result, value, origin);</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::uintxAtPut(JVMFlagsWithType flag, uintx value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = address_of_flag(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uintx(), &quot;wrong flag type&quot;);
    return JVMFlag::uintxAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::uint64_tAt(const char* name, size_t len, uint64_t* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">!   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!result-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">-   *value = result-&gt;get_uint64_t();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_uint64_t(const char* name, uint64_t new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
    if (range != NULL) {
      status = range-&gt;check_uint64_t(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_uint64_t(new_value, verbose);
      }
    }
    return status;
  }
  
  JVMFlag::Error JVMFlag::uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin) {
<span class="line-removed">-   const char* name;</span>
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   name = flag-&gt;_name;</span>
<span class="line-removed">-   JVMFlag::Error check = apply_constraint_and_check_range_uint64_t(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    uint64_t old_value = flag-&gt;get_uint64_t();
<span class="line-modified">!   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">!   check = flag-&gt;set_uint64_t(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return check;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::uint64_tAtPut(const char* name, size_t len, uint64_t* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">-   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">-   return uint64_tAtPut(result, value, origin);</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::uint64_tAtPut(JVMFlagsWithType flag, uint64_t value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = address_of_flag(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint64_t(), &quot;wrong flag type&quot;);
    return JVMFlag::uint64_tAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::size_tAt(const char* name, size_t len, size_t* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">!   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!result-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">-   *value = result-&gt;get_size_t();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_size_t(const char* name, size_t new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
    if (range != NULL) {
      status = range-&gt;check_size_t(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_size_t(new_value, verbose);
      }
    }
    return status;
  }
  
  
  JVMFlag::Error JVMFlag::size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin) {
<span class="line-removed">-   const char* name;</span>
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   name = flag-&gt;_name;</span>
<span class="line-removed">-   JVMFlag::Error check = apply_constraint_and_check_range_size_t(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    size_t old_value = flag-&gt;get_size_t();
<span class="line-modified">!   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">!   check = flag-&gt;set_size_t(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return check;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::size_tAtPut(const char* name, size_t len, size_t* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">-   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">-   return size_tAtPut(result, value, origin);</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::size_tAtPut(JVMFlagsWithType flag, size_t value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = address_of_flag(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_size_t(), &quot;wrong flag type&quot;);
    return JVMFlag::size_tAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::doubleAt(const char* name, size_t len, double* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">!   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!result-&gt;is_double()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">-   *value = result-&gt;get_double();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_double(const char* name, double new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
    if (range != NULL) {
      status = range-&gt;check_double(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_double(new_value, verbose);
      }
    }
    return status;
  }
  
  JVMFlag::Error JVMFlag::doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin) {
<span class="line-removed">-   const char* name;</span>
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   name = flag-&gt;_name;</span>
<span class="line-removed">-   JVMFlag::Error check = apply_constraint_and_check_range_double(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    double old_value = flag-&gt;get_double();
<span class="line-modified">!   trace_flag_changed&lt;EventDoubleFlagChanged, double&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">!   check = flag-&gt;set_double(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return check;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JVMFlag::Error JVMFlag::doubleAtPut(const char* name, size_t len, double* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">-   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">-   return doubleAtPut(result, value, origin);</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::doubleAtPut(JVMFlagsWithType flag, double value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = address_of_flag(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_double(), &quot;wrong flag type&quot;);
    return JVMFlag::doubleAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::ccstrAt(const char* name, size_t len, ccstr* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">!   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!result-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">-   *value = result-&gt;get_ccstr();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::ccstrAtPut(const char* name, size_t len, ccstr* value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-modified">!   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!result-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   ccstr old_value = result-&gt;get_ccstr();</span>
<span class="line-removed">-   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(name, old_value, *value, origin);</span>
    char* new_value = NULL;
    if (*value != NULL) {
      new_value = os::strdup_check_oom(*value);
    }
<span class="line-modified">!   JVMFlag::Error check = result-&gt;set_ccstr(new_value);</span>
<span class="line-modified">!   if (result-&gt;is_default() &amp;&amp; old_value != NULL) {</span>
      // Prior value is NOT heap allocated, but was a literal constant.
      old_value = os::strdup_check_oom(old_value);
    }
    *value = old_value;
<span class="line-modified">!   result-&gt;set_origin(origin);</span>
<span class="line-modified">!   return check;</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::ccstrAtPut(JVMFlagsWithType flag, ccstr value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = address_of_flag(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_ccstr(), &quot;wrong flag type&quot;);
    ccstr old_value = faddr-&gt;get_ccstr();
<span class="line-modified">!   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(faddr-&gt;_name, old_value, value, origin);</span>
    char* new_value = os::strdup_check_oom(value);
<span class="line-modified">!   JVMFlag::Error check = faddr-&gt;set_ccstr(new_value);</span>
    if (!faddr-&gt;is_default() &amp;&amp; old_value != NULL) {
      // Prior value is heap allocated so free it.
      FREE_C_HEAP_ARRAY(char, old_value);
    }
    faddr-&gt;set_origin(origin);
<span class="line-modified">!   return check;</span>
  }
  
  extern &quot;C&quot; {
    static int compare_flags(const void* void_a, const void* void_b) {
      return strcmp((*((JVMFlag**) void_a))-&gt;_name, (*((JVMFlag**) void_b))-&gt;_name);
<span class="line-new-header">--- 820,405 ---</span>
  
    return match;
  }
  
  // Returns the address of the index&#39;th element
<span class="line-modified">! JVMFlag* JVMFlagEx::flag_from_enum(JVMFlagsEnum flag) {</span>
    assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);
    return &amp;JVMFlag::flags[flag];
  }
  
<span class="line-modified">! bool JVMFlagEx::is_default(JVMFlagsEnum flag) {</span>
<span class="line-modified">!   return flag_from_enum(flag)-&gt;is_default();</span>
  }
  
<span class="line-modified">! bool JVMFlagEx::is_ergo(JVMFlagsEnum flag) {</span>
<span class="line-modified">!   return flag_from_enum(flag)-&gt;is_ergonomic();</span>
  }
  
<span class="line-modified">! bool JVMFlagEx::is_cmdline(JVMFlagsEnum flag) {</span>
<span class="line-modified">!   return flag_from_enum(flag)-&gt;is_command_line();</span>
  }
  
<span class="line-modified">! void JVMFlagEx::setOnCmdLine(JVMFlagsEnum flag) {</span>
<span class="line-modified">!   JVMFlag* faddr = flag_from_enum(flag);</span>
    assert(faddr != NULL, &quot;Unknown flag&quot;);
    faddr-&gt;set_command_line();
  }
  
  template&lt;class E, class T&gt;
<span class="line-modified">! static void trace_flag_changed(const JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {</span>
    E e;
<span class="line-modified">!   e.set_name(flag-&gt;_name);</span>
    e.set_oldValue(old_value);
    e.set_newValue(new_value);
    e.set_origin(origin);
    e.commit();
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_bool(const JVMFlag* flag, bool new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
    if (constraint != NULL) {
      status = constraint-&gt;apply_bool(new_value, verbose);
    }
    return status;
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::boolAt(const JVMFlag* flag, bool* value) {</span>
<span class="line-modified">!   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   *value = flag-&gt;get_bool();</span>
    return JVMFlag::SUCCESS;
  }
  
  JVMFlag::Error JVMFlag::boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin) {
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   JVMFlag::Error check = apply_constraint_and_check_range_bool(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    bool old_value = flag-&gt;get_bool();
<span class="line-modified">!   trace_flag_changed&lt;EventBooleanFlagChanged, bool&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">!   flag-&gt;set_bool(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return JVMFlag::SUCCESS;</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::boolAtPut(JVMFlagsEnum flag, bool value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = flag_from_enum(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_bool(), &quot;wrong flag type&quot;);
    return JVMFlag::boolAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_int(const JVMFlag* flag, int new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
    if (range != NULL) {
      status = range-&gt;check_int(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_int(new_value, verbose);
      }
    }
    return status;
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::intAt(const JVMFlag* flag, int* value) {</span>
<span class="line-modified">!   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   *value = flag-&gt;get_int();</span>
    return JVMFlag::SUCCESS;
  }
  
  JVMFlag::Error JVMFlag::intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin) {
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   JVMFlag::Error check = apply_constraint_and_check_range_int(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    int old_value = flag-&gt;get_int();
<span class="line-modified">!   trace_flag_changed&lt;EventIntFlagChanged, s4&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">!   flag-&gt;set_int(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return JVMFlag::SUCCESS;</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::intAtPut(JVMFlagsEnum flag, int value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = flag_from_enum(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_int(), &quot;wrong flag type&quot;);
    return JVMFlag::intAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_uint(const JVMFlag* flag, uint new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
    if (range != NULL) {
      status = range-&gt;check_uint(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_uint(new_value, verbose);
      }
    }
    return status;
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::uintAt(const JVMFlag* flag, uint* value) {</span>
<span class="line-modified">!   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   *value = flag-&gt;get_uint();</span>
    return JVMFlag::SUCCESS;
  }
  
  JVMFlag::Error JVMFlag::uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin) {
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   JVMFlag::Error check = apply_constraint_and_check_range_uint(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    uint old_value = flag-&gt;get_uint();
<span class="line-modified">!   trace_flag_changed&lt;EventUnsignedIntFlagChanged, u4&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">!   flag-&gt;set_uint(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return JVMFlag::SUCCESS;</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::uintAtPut(JVMFlagsEnum flag, uint value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = flag_from_enum(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint(), &quot;wrong flag type&quot;);
    return JVMFlag::uintAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::intxAt(const JVMFlag* flag, intx* value) {</span>
<span class="line-modified">!   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   *value = flag-&gt;get_intx();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_intx(const JVMFlag* flag, intx new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
    if (range != NULL) {
      status = range-&gt;check_intx(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_intx(new_value, verbose);
      }
    }
    return status;
  }
  
  JVMFlag::Error JVMFlag::intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin) {
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   JVMFlag::Error check = apply_constraint_and_check_range_intx(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    intx old_value = flag-&gt;get_intx();
<span class="line-modified">!   trace_flag_changed&lt;EventLongFlagChanged, intx&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">!   flag-&gt;set_intx(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return JVMFlag::SUCCESS;</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::intxAtPut(JVMFlagsEnum flag, intx value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = flag_from_enum(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_intx(), &quot;wrong flag type&quot;);
    return JVMFlag::intxAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::uintxAt(const JVMFlag* flag, uintx* value) {</span>
<span class="line-modified">!   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   *value = flag-&gt;get_uintx();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_uintx(const JVMFlag* flag, uintx new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
    if (range != NULL) {
      status = range-&gt;check_uintx(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_uintx(new_value, verbose);
      }
    }
    return status;
  }
  
  JVMFlag::Error JVMFlag::uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin) {
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   JVMFlag::Error check = apply_constraint_and_check_range_uintx(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    uintx old_value = flag-&gt;get_uintx();
<span class="line-modified">!   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">!   flag-&gt;set_uintx(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return JVMFlag::SUCCESS;</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::uintxAtPut(JVMFlagsEnum flag, uintx value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = flag_from_enum(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uintx(), &quot;wrong flag type&quot;);
    return JVMFlag::uintxAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::uint64_tAt(const JVMFlag* flag, uint64_t* value) {</span>
<span class="line-modified">!   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   *value = flag-&gt;get_uint64_t();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_uint64_t(const JVMFlag* flag, uint64_t new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
    if (range != NULL) {
      status = range-&gt;check_uint64_t(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_uint64_t(new_value, verbose);
      }
    }
    return status;
  }
  
  JVMFlag::Error JVMFlag::uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin) {
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   JVMFlag::Error check = apply_constraint_and_check_range_uint64_t(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    uint64_t old_value = flag-&gt;get_uint64_t();
<span class="line-modified">!   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">!   flag-&gt;set_uint64_t(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return JVMFlag::SUCCESS;</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::uint64_tAtPut(JVMFlagsEnum flag, uint64_t value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = flag_from_enum(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint64_t(), &quot;wrong flag type&quot;);
    return JVMFlag::uint64_tAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::size_tAt(const JVMFlag* flag, size_t* value) {</span>
<span class="line-modified">!   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   *value = flag-&gt;get_size_t();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_size_t(const JVMFlag* flag, size_t new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
    if (range != NULL) {
      status = range-&gt;check_size_t(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_size_t(new_value, verbose);
      }
    }
    return status;
  }
  
  
  JVMFlag::Error JVMFlag::size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin) {
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   JVMFlag::Error check = apply_constraint_and_check_range_size_t(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    size_t old_value = flag-&gt;get_size_t();
<span class="line-modified">!   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">!   flag-&gt;set_size_t(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return JVMFlag::SUCCESS;</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::size_tAtPut(JVMFlagsEnum flag, size_t value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = flag_from_enum(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_size_t(), &quot;wrong flag type&quot;);
    return JVMFlag::size_tAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::doubleAt(const JVMFlag* flag, double* value) {</span>
<span class="line-modified">!   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   *value = flag-&gt;get_double();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! static JVMFlag::Error apply_constraint_and_check_range_double(const JVMFlag* flag, double new_value, bool verbose) {</span>
    JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">!   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
    if (range != NULL) {
      status = range-&gt;check_double(new_value, verbose);
    }
    if (status == JVMFlag::SUCCESS) {
<span class="line-modified">!     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
      if (constraint != NULL) {
        status = constraint-&gt;apply_double(new_value, verbose);
      }
    }
    return status;
  }
  
  JVMFlag::Error JVMFlag::doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin) {
    if (flag == NULL) return JVMFlag::INVALID_FLAG;
    if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">!   JVMFlag::Error check = apply_constraint_and_check_range_double(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
    if (check != JVMFlag::SUCCESS) return check;
    double old_value = flag-&gt;get_double();
<span class="line-modified">!   trace_flag_changed&lt;EventDoubleFlagChanged, double&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">!   flag-&gt;set_double(*value);</span>
    *value = old_value;
    flag-&gt;set_origin(origin);
<span class="line-modified">!   return JVMFlag::SUCCESS;</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::doubleAtPut(JVMFlagsEnum flag, double value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = flag_from_enum(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_double(), &quot;wrong flag type&quot;);
    return JVMFlag::doubleAtPut(faddr, &amp;value, origin);
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::ccstrAt(const JVMFlag* flag, ccstr* value) {</span>
<span class="line-modified">!   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!flag-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   *value = flag-&gt;get_ccstr();</span>
    return JVMFlag::SUCCESS;
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlag::ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">!   if (!flag-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">!   ccstr old_value = flag-&gt;get_ccstr();</span>
<span class="line-modified">!   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(flag, old_value, *value, origin);</span>
    char* new_value = NULL;
    if (*value != NULL) {
      new_value = os::strdup_check_oom(*value);
    }
<span class="line-modified">!   flag-&gt;set_ccstr(new_value);</span>
<span class="line-modified">!   if (flag-&gt;is_default() &amp;&amp; old_value != NULL) {</span>
      // Prior value is NOT heap allocated, but was a literal constant.
      old_value = os::strdup_check_oom(old_value);
    }
    *value = old_value;
<span class="line-modified">!   flag-&gt;set_origin(origin);</span>
<span class="line-modified">!   return JVMFlag::SUCCESS;</span>
  }
  
<span class="line-modified">! JVMFlag::Error JVMFlagEx::ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin) {</span>
<span class="line-modified">!   JVMFlag* faddr = flag_from_enum(flag);</span>
    guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_ccstr(), &quot;wrong flag type&quot;);
    ccstr old_value = faddr-&gt;get_ccstr();
<span class="line-modified">!   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(faddr, old_value, value, origin);</span>
    char* new_value = os::strdup_check_oom(value);
<span class="line-modified">!   faddr-&gt;set_ccstr(new_value);</span>
    if (!faddr-&gt;is_default() &amp;&amp; old_value != NULL) {
      // Prior value is heap allocated so free it.
      FREE_C_HEAP_ARRAY(char, old_value);
    }
    faddr-&gt;set_origin(origin);
<span class="line-modified">!   return JVMFlag::SUCCESS;</span>
  }
  
  extern &quot;C&quot; {
    static int compare_flags(const void* void_a, const void* void_b) {
      return strcmp((*((JVMFlag**) void_a))-&gt;_name, (*((JVMFlag**) void_b))-&gt;_name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1473,42 ***</span>
  
  #endif // PRODUCT
  
  void JVMFlag::printFlags(outputStream* out, bool withComments, bool printRanges, bool skipDefaults) {
    // Print the flags sorted by name
<span class="line-modified">!   // note: this method is called before the thread structure is in place</span>
<span class="line-modified">!   //       which means resource allocation cannot be used.</span>
  
    // The last entry is the null entry.
    const size_t length = JVMFlag::numFlags - 1;
  
<span class="line-removed">-   // Sort</span>
<span class="line-removed">-   JVMFlag** array = NEW_C_HEAP_ARRAY(JVMFlag*, length, mtArguments);</span>
<span class="line-removed">-   for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-removed">-     array[i] = &amp;flagTable[i];</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   qsort(array, length, sizeof(JVMFlag*), compare_flags);</span>
<span class="line-removed">- </span>
    // Print
    if (!printRanges) {
      out-&gt;print_cr(&quot;[Global flags]&quot;);
    } else {
      out-&gt;print_cr(&quot;[Global flags ranges]&quot;);
    }
  
<span class="line-modified">!   for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-modified">!     if (array[i]-&gt;is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; array[i]-&gt;is_default())) {</span>
<span class="line-modified">!       array[i]-&gt;print_on(out, withComments, printRanges);</span>
      }
    }
<span class="line-removed">-   FREE_C_HEAP_ARRAY(JVMFlag*, array);</span>
  }
  
  void JVMFlag::printError(bool verbose, const char* msg, ...) {
    if (verbose) {
      va_list listPointer;
      va_start(listPointer, msg);
      jio_vfprintf(defaultStream::error_stream(), msg, listPointer);
      va_end(listPointer);
    }
  }
<span class="line-removed">- </span>
<span class="line-new-header">--- 1259,51 ---</span>
  
  #endif // PRODUCT
  
  void JVMFlag::printFlags(outputStream* out, bool withComments, bool printRanges, bool skipDefaults) {
    // Print the flags sorted by name
<span class="line-modified">!   // Note: This method may be called before the thread structure is in place</span>
<span class="line-modified">!   //       which means resource allocation cannot be used. Also, it may be</span>
<span class="line-added">+   //       called as part of error reporting, so handle native OOMs gracefully.</span>
  
    // The last entry is the null entry.
    const size_t length = JVMFlag::numFlags - 1;
  
    // Print
    if (!printRanges) {
      out-&gt;print_cr(&quot;[Global flags]&quot;);
    } else {
      out-&gt;print_cr(&quot;[Global flags ranges]&quot;);
    }
  
<span class="line-modified">!   // Sort</span>
<span class="line-modified">!   JVMFlag** array = NEW_C_HEAP_ARRAY_RETURN_NULL(JVMFlag*, length, mtArguments);</span>
<span class="line-modified">!   if (array != NULL) {</span>
<span class="line-added">+     for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-added">+       array[i] = &amp;flagTable[i];</span>
<span class="line-added">+     }</span>
<span class="line-added">+     qsort(array, length, sizeof(JVMFlag*), compare_flags);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-added">+       if (array[i]-&gt;is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; array[i]-&gt;is_default())) {</span>
<span class="line-added">+         array[i]-&gt;print_on(out, withComments, printRanges);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     FREE_C_HEAP_ARRAY(JVMFlag*, array);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // OOM? Print unsorted.</span>
<span class="line-added">+     for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-added">+       if (flagTable[i].is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; flagTable[i].is_default())) {</span>
<span class="line-added">+         flagTable[i].print_on(out, withComments, printRanges);</span>
<span class="line-added">+       }</span>
      }
    }
  }
  
  void JVMFlag::printError(bool verbose, const char* msg, ...) {
    if (verbose) {
      va_list listPointer;
      va_start(listPointer, msg);
      jio_vfprintf(defaultStream::error_stream(), msg, listPointer);
      va_end(listPointer);
    }
  }
</pre>
<center><a href="../fieldDescriptor.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlag.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/flags/jvmFlagConstraintList.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jvmFlag.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintList.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/flags/jvmFlagConstraintList.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/stringTable.hpp&quot;
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;gc/shared/jvmFlagConstraintsGC.hpp&quot;
 29 #include &quot;runtime/arguments.hpp&quot;
 30 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 31 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
 32 #include &quot;runtime/flags/jvmFlagConstraintsCompiler.hpp&quot;
 33 #include &quot;runtime/flags/jvmFlagConstraintsRuntime.hpp&quot;


 34 #include &quot;runtime/os.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
<span class="line-removed"> 36 #ifdef COMPILER1</span>
<span class="line-removed"> 37 #include &quot;c1/c1_globals.hpp&quot;</span>
<span class="line-removed"> 38 #endif</span>
<span class="line-removed"> 39 #ifdef COMPILER2</span>
<span class="line-removed"> 40 #include &quot;opto/c2_globals.hpp&quot;</span>
<span class="line-removed"> 41 #endif</span>
 42 
 43 class JVMFlagConstraint_bool : public JVMFlagConstraint {
 44   JVMFlagConstraintFunc_bool _constraint;
<span class="line-removed"> 45   const bool* _ptr;</span>
 46 
 47 public:
<span class="line-modified"> 48   // the &quot;name&quot; argument must be a string literal</span>
<span class="line-modified"> 49   JVMFlagConstraint_bool(const char* name, const bool* ptr,</span>
<span class="line-modified"> 50                                  JVMFlagConstraintFunc_bool func,</span>
<span class="line-removed"> 51                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}</span>
 52 
 53   JVMFlag::Error apply(bool verbose) {
<span class="line-modified"> 54     bool value = *_ptr;</span>
<span class="line-removed"> 55     return _constraint(value, verbose);</span>
 56   }
 57 
 58   JVMFlag::Error apply_bool(bool value, bool verbose) {
 59     return _constraint(value, verbose);
 60   }
 61 };
 62 
 63 class JVMFlagConstraint_int : public JVMFlagConstraint {
 64   JVMFlagConstraintFunc_int _constraint;
<span class="line-removed"> 65   const int* _ptr;</span>
 66 
 67 public:
<span class="line-modified"> 68   // the &quot;name&quot; argument must be a string literal</span>
<span class="line-modified"> 69   JVMFlagConstraint_int(const char* name, const int* ptr,</span>
<span class="line-modified"> 70                                 JVMFlagConstraintFunc_int func,</span>
<span class="line-removed"> 71                                 ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}</span>
 72 
 73   JVMFlag::Error apply(bool verbose) {
<span class="line-modified"> 74     int value = *_ptr;</span>
<span class="line-removed"> 75     return _constraint(value, verbose);</span>
 76   }
 77 
 78   JVMFlag::Error apply_int(int value, bool verbose) {
 79     return _constraint(value, verbose);
 80   }
 81 };
 82 
 83 class JVMFlagConstraint_intx : public JVMFlagConstraint {
 84   JVMFlagConstraintFunc_intx _constraint;
<span class="line-removed"> 85   const intx* _ptr;</span>
 86 
 87 public:
<span class="line-modified"> 88   // the &quot;name&quot; argument must be a string literal</span>
<span class="line-modified"> 89   JVMFlagConstraint_intx(const char* name, const intx* ptr,</span>
<span class="line-modified"> 90                                  JVMFlagConstraintFunc_intx func,</span>
<span class="line-removed"> 91                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}</span>
 92 
 93   JVMFlag::Error apply(bool verbose) {
<span class="line-modified"> 94     intx value = *_ptr;</span>
<span class="line-removed"> 95     return _constraint(value, verbose);</span>
 96   }
 97 
 98   JVMFlag::Error apply_intx(intx value, bool verbose) {
 99     return _constraint(value, verbose);
100   }
101 };
102 
103 class JVMFlagConstraint_uint : public JVMFlagConstraint {
104   JVMFlagConstraintFunc_uint _constraint;
<span class="line-removed">105   const uint* _ptr;</span>
106 
107 public:
<span class="line-modified">108   // the &quot;name&quot; argument must be a string literal</span>
<span class="line-modified">109   JVMFlagConstraint_uint(const char* name, const uint* ptr,</span>
<span class="line-modified">110                                  JVMFlagConstraintFunc_uint func,</span>
<span class="line-removed">111                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}</span>
112 
113   JVMFlag::Error apply(bool verbose) {
<span class="line-modified">114     uint value = *_ptr;</span>
<span class="line-removed">115     return _constraint(value, verbose);</span>
116   }
117 
118   JVMFlag::Error apply_uint(uint value, bool verbose) {
119     return _constraint(value, verbose);
120   }
121 };
122 
123 class JVMFlagConstraint_uintx : public JVMFlagConstraint {
124   JVMFlagConstraintFunc_uintx _constraint;
<span class="line-removed">125   const uintx* _ptr;</span>
126 
127 public:
<span class="line-modified">128   // the &quot;name&quot; argument must be a string literal</span>
<span class="line-modified">129   JVMFlagConstraint_uintx(const char* name, const uintx* ptr,</span>
<span class="line-modified">130                                   JVMFlagConstraintFunc_uintx func,</span>
<span class="line-removed">131                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}</span>
132 
133   JVMFlag::Error apply(bool verbose) {
<span class="line-modified">134     uintx value = *_ptr;</span>
<span class="line-removed">135     return _constraint(value, verbose);</span>
136   }
137 
138   JVMFlag::Error apply_uintx(uintx value, bool verbose) {
139     return _constraint(value, verbose);
140   }
141 };
142 
143 class JVMFlagConstraint_uint64_t : public JVMFlagConstraint {
144   JVMFlagConstraintFunc_uint64_t _constraint;
<span class="line-removed">145   const uint64_t* _ptr;</span>
146 
147 public:
<span class="line-modified">148   // the &quot;name&quot; argument must be a string literal</span>
<span class="line-modified">149   JVMFlagConstraint_uint64_t(const char* name, const uint64_t* ptr,</span>
<span class="line-modified">150                                      JVMFlagConstraintFunc_uint64_t func,</span>
<span class="line-removed">151                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}</span>
152 
153   JVMFlag::Error apply(bool verbose) {
<span class="line-modified">154     uint64_t value = *_ptr;</span>
<span class="line-removed">155     return _constraint(value, verbose);</span>
156   }
157 
158   JVMFlag::Error apply_uint64_t(uint64_t value, bool verbose) {
159     return _constraint(value, verbose);
160   }
161 };
162 
163 class JVMFlagConstraint_size_t : public JVMFlagConstraint {
164   JVMFlagConstraintFunc_size_t _constraint;
<span class="line-modified">165   const size_t* _ptr;</span>
166 public:
<span class="line-modified">167   // the &quot;name&quot; argument must be a string literal</span>
<span class="line-modified">168   JVMFlagConstraint_size_t(const char* name, const size_t* ptr,</span>
<span class="line-modified">169                                    JVMFlagConstraintFunc_size_t func,</span>
<span class="line-removed">170                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}</span>
171 
172   JVMFlag::Error apply(bool verbose) {
<span class="line-modified">173     size_t value = *_ptr;</span>
<span class="line-removed">174     return _constraint(value, verbose);</span>
175   }
176 
177   JVMFlag::Error apply_size_t(size_t value, bool verbose) {
178     return _constraint(value, verbose);
179   }
180 };
181 
182 class JVMFlagConstraint_double : public JVMFlagConstraint {
183   JVMFlagConstraintFunc_double _constraint;
<span class="line-removed">184   const double* _ptr;</span>
185 
186 public:
<span class="line-modified">187   // the &quot;name&quot; argument must be a string literal</span>
<span class="line-modified">188   JVMFlagConstraint_double(const char* name, const double* ptr,</span>
<span class="line-modified">189                                    JVMFlagConstraintFunc_double func,</span>
<span class="line-removed">190                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}</span>
191 
192   JVMFlag::Error apply(bool verbose) {
<span class="line-modified">193     double value = *_ptr;</span>
<span class="line-removed">194     return _constraint(value, verbose);</span>
195   }
196 
197   JVMFlag::Error apply_double(double value, bool verbose) {
198     return _constraint(value, verbose);
199   }
200 };
201 
202 // No constraint emitting
<span class="line-modified">203 void emit_constraint_no(...)                                                      { /* NOP */ }</span>
204 
205 // No constraint emitting if function argument is NOT provided
<span class="line-modified">206 void emit_constraint_bool(const char* /*name*/, const bool* /*value*/)            { /* NOP */ }</span>
<span class="line-modified">207 void emit_constraint_ccstr(const char* /*name*/, const ccstr* /*value*/)          { /* NOP */ }</span>
<span class="line-modified">208 void emit_constraint_ccstrlist(const char* /*name*/, const ccstrlist* /*value*/)  { /* NOP */ }</span>
<span class="line-modified">209 void emit_constraint_int(const char* /*name*/, const int* /*value*/)              { /* NOP */ }</span>
<span class="line-modified">210 void emit_constraint_intx(const char* /*name*/, const intx* /*value*/)            { /* NOP */ }</span>
<span class="line-modified">211 void emit_constraint_uint(const char* /*name*/, const uint* /*value*/)            { /* NOP */ }</span>
<span class="line-modified">212 void emit_constraint_uintx(const char* /*name*/, const uintx* /*value*/)          { /* NOP */ }</span>
<span class="line-modified">213 void emit_constraint_uint64_t(const char* /*name*/, const uint64_t* /*value*/)    { /* NOP */ }</span>
<span class="line-modified">214 void emit_constraint_size_t(const char* /*name*/, const size_t* /*value*/)        { /* NOP */ }</span>
<span class="line-modified">215 void emit_constraint_double(const char* /*name*/, const double* /*value*/)        { /* NOP */ }</span>
216 
217 // JVMFlagConstraint emitting code functions if function argument is provided
<span class="line-modified">218 void emit_constraint_bool(const char* name, const bool* ptr, JVMFlagConstraintFunc_bool func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">219   JVMFlagConstraintList::add(new JVMFlagConstraint_bool(name, ptr, func, type));</span>
220 }
<span class="line-modified">221 void emit_constraint_int(const char* name, const int* ptr, JVMFlagConstraintFunc_int func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">222   JVMFlagConstraintList::add(new JVMFlagConstraint_int(name, ptr, func, type));</span>
223 }
<span class="line-modified">224 void emit_constraint_intx(const char* name, const intx* ptr, JVMFlagConstraintFunc_intx func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">225   JVMFlagConstraintList::add(new JVMFlagConstraint_intx(name, ptr, func, type));</span>
226 }
<span class="line-modified">227 void emit_constraint_uint(const char* name, const uint* ptr, JVMFlagConstraintFunc_uint func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">228   JVMFlagConstraintList::add(new JVMFlagConstraint_uint(name, ptr, func, type));</span>
229 }
<span class="line-modified">230 void emit_constraint_uintx(const char* name, const uintx* ptr, JVMFlagConstraintFunc_uintx func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">231   JVMFlagConstraintList::add(new JVMFlagConstraint_uintx(name, ptr, func, type));</span>
232 }
<span class="line-modified">233 void emit_constraint_uint64_t(const char* name, const uint64_t* ptr, JVMFlagConstraintFunc_uint64_t func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">234   JVMFlagConstraintList::add(new JVMFlagConstraint_uint64_t(name, ptr, func, type));</span>
235 }
<span class="line-modified">236 void emit_constraint_size_t(const char* name, const size_t* ptr, JVMFlagConstraintFunc_size_t func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">237   JVMFlagConstraintList::add(new JVMFlagConstraint_size_t(name, ptr, func, type));</span>
238 }
<span class="line-modified">239 void emit_constraint_double(const char* name, const double* ptr, JVMFlagConstraintFunc_double func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">240   JVMFlagConstraintList::add(new JVMFlagConstraint_double(name, ptr, func, type));</span>
241 }
242 
243 // Generate code to call emit_constraint_xxx function
<span class="line-modified">244 #define EMIT_CONSTRAINT_PRODUCT_FLAG(type, name, value, doc)      ); emit_constraint_##type(#name,&amp;name</span>
<span class="line-modified">245 #define EMIT_CONSTRAINT_DIAGNOSTIC_FLAG(type, name, value, doc)   ); emit_constraint_##type(#name,&amp;name</span>
<span class="line-modified">246 #define EMIT_CONSTRAINT_EXPERIMENTAL_FLAG(type, name, value, doc) ); emit_constraint_##type(#name,&amp;name</span>
<span class="line-modified">247 #define EMIT_CONSTRAINT_MANAGEABLE_FLAG(type, name, value, doc)   ); emit_constraint_##type(#name,&amp;name</span>
<span class="line-modified">248 #define EMIT_CONSTRAINT_PRODUCT_RW_FLAG(type, name, value, doc)   ); emit_constraint_##type(#name,&amp;name</span>
<span class="line-modified">249 #define EMIT_CONSTRAINT_PD_PRODUCT_FLAG(type, name, doc)          ); emit_constraint_##type(#name,&amp;name</span>
<span class="line-modified">250 #define EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG(type, name, doc)       ); emit_constraint_##type(#name,&amp;name</span>



251 #ifndef PRODUCT
<span class="line-modified">252 #define EMIT_CONSTRAINT_DEVELOPER_FLAG(type, name, value, doc)    ); emit_constraint_##type(#name,&amp;name</span>
<span class="line-modified">253 #define EMIT_CONSTRAINT_PD_DEVELOPER_FLAG(type, name, doc)        ); emit_constraint_##type(#name,&amp;name</span>
<span class="line-modified">254 #define EMIT_CONSTRAINT_NOTPRODUCT_FLAG(type, name, value, doc)   ); emit_constraint_##type(#name,&amp;name</span>
255 #else
<span class="line-modified">256 #define EMIT_CONSTRAINT_DEVELOPER_FLAG(type, name, value, doc)    ); emit_constraint_no(#name,&amp;name</span>
<span class="line-modified">257 #define EMIT_CONSTRAINT_PD_DEVELOPER_FLAG(type, name, doc)        ); emit_constraint_no(#name,&amp;name</span>
<span class="line-modified">258 #define EMIT_CONSTRAINT_NOTPRODUCT_FLAG(type, name, value, doc)   ); emit_constraint_no(#name,&amp;name</span>
259 #endif
260 #ifdef _LP64
<span class="line-modified">261 #define EMIT_CONSTRAINT_LP64_PRODUCT_FLAG(type, name, value, doc) ); emit_constraint_##type(#name,&amp;name</span>
262 #else
<span class="line-modified">263 #define EMIT_CONSTRAINT_LP64_PRODUCT_FLAG(type, name, value, doc) ); emit_constraint_no(#name,&amp;name</span>
264 #endif

265 
266 // Generate func argument to pass into emit_constraint_xxx functions
267 #define EMIT_CONSTRAINT_CHECK(func, type)                         , func, JVMFlagConstraint::type
268 
269 // the &quot;name&quot; argument must be a string literal
270 #define INITIAL_CONSTRAINTS_SIZE 72
271 GrowableArray&lt;JVMFlagConstraint*&gt;* JVMFlagConstraintList::_constraints = NULL;
272 JVMFlagConstraint::ConstraintType JVMFlagConstraintList::_validating_type = JVMFlagConstraint::AtParse;
273 
274 // Check the ranges of all flags that have them or print them out and exit if requested
275 void JVMFlagConstraintList::init(void) {
276   _constraints = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;JVMFlagConstraint*&gt;(INITIAL_CONSTRAINTS_SIZE, true);
277 
<span class="line-modified">278   emit_constraint_no(NULL VM_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,</span>
<span class="line-modified">279                                    EMIT_CONSTRAINT_PD_DEVELOPER_FLAG,</span>
<span class="line-modified">280                                    EMIT_CONSTRAINT_PRODUCT_FLAG,</span>
<span class="line-modified">281                                    EMIT_CONSTRAINT_PD_PRODUCT_FLAG,</span>
<span class="line-modified">282                                    EMIT_CONSTRAINT_DIAGNOSTIC_FLAG,</span>
<span class="line-modified">283                                    EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG,</span>
<span class="line-modified">284                                    EMIT_CONSTRAINT_EXPERIMENTAL_FLAG,</span>
<span class="line-modified">285                                    EMIT_CONSTRAINT_NOTPRODUCT_FLAG,</span>
<span class="line-modified">286                                    EMIT_CONSTRAINT_MANAGEABLE_FLAG,</span>
<span class="line-modified">287                                    EMIT_CONSTRAINT_PRODUCT_RW_FLAG,</span>
<span class="line-modified">288                                    EMIT_CONSTRAINT_LP64_PRODUCT_FLAG,</span>
<span class="line-modified">289                                    IGNORE_RANGE,</span>
<span class="line-modified">290                                    EMIT_CONSTRAINT_CHECK,</span>
<span class="line-modified">291                                    IGNORE_WRITEABLE));</span>
<span class="line-modified">292 </span>
<span class="line-modified">293   EMIT_CONSTRAINTS_FOR_GLOBALS_EXT</span>
<span class="line-modified">294 </span>
<span class="line-removed">295   emit_constraint_no(NULL ARCH_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,</span>
<span class="line-removed">296                                      EMIT_CONSTRAINT_PRODUCT_FLAG,</span>
<span class="line-removed">297                                      EMIT_CONSTRAINT_DIAGNOSTIC_FLAG,</span>
<span class="line-removed">298                                      EMIT_CONSTRAINT_EXPERIMENTAL_FLAG,</span>
<span class="line-removed">299                                      EMIT_CONSTRAINT_NOTPRODUCT_FLAG,</span>
<span class="line-removed">300                                      IGNORE_RANGE,</span>
<span class="line-removed">301                                      EMIT_CONSTRAINT_CHECK,</span>
<span class="line-removed">302                                      IGNORE_WRITEABLE));</span>
<span class="line-removed">303 </span>
<span class="line-removed">304 </span>
<span class="line-removed">305 #ifdef COMPILER1</span>
<span class="line-removed">306   emit_constraint_no(NULL C1_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,</span>
<span class="line-removed">307                                    EMIT_CONSTRAINT_PD_DEVELOPER_FLAG,</span>
<span class="line-removed">308                                    EMIT_CONSTRAINT_PRODUCT_FLAG,</span>
<span class="line-removed">309                                    EMIT_CONSTRAINT_PD_PRODUCT_FLAG,</span>
<span class="line-removed">310                                    EMIT_CONSTRAINT_DIAGNOSTIC_FLAG,</span>
<span class="line-removed">311                                    EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG,</span>
<span class="line-removed">312                                    EMIT_CONSTRAINT_NOTPRODUCT_FLAG,</span>
<span class="line-removed">313                                    IGNORE_RANGE,</span>
<span class="line-removed">314                                    EMIT_CONSTRAINT_CHECK,</span>
<span class="line-removed">315                                    IGNORE_WRITEABLE));</span>
<span class="line-removed">316 #endif // COMPILER1</span>
<span class="line-removed">317 </span>
<span class="line-removed">318 #ifdef COMPILER2</span>
<span class="line-removed">319   emit_constraint_no(NULL C2_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,</span>
<span class="line-removed">320                                    EMIT_CONSTRAINT_PD_DEVELOPER_FLAG,</span>
<span class="line-removed">321                                    EMIT_CONSTRAINT_PRODUCT_FLAG,</span>
<span class="line-removed">322                                    EMIT_CONSTRAINT_PD_PRODUCT_FLAG,</span>
<span class="line-removed">323                                    EMIT_CONSTRAINT_DIAGNOSTIC_FLAG,</span>
<span class="line-removed">324                                    EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG,</span>
<span class="line-removed">325                                    EMIT_CONSTRAINT_EXPERIMENTAL_FLAG,</span>
<span class="line-removed">326                                    EMIT_CONSTRAINT_NOTPRODUCT_FLAG,</span>
<span class="line-removed">327                                    IGNORE_RANGE,</span>
<span class="line-removed">328                                    EMIT_CONSTRAINT_CHECK,</span>
<span class="line-removed">329                                    IGNORE_WRITEABLE));</span>
<span class="line-removed">330 #endif // COMPILER2</span>
331 }
332 
<span class="line-modified">333 JVMFlagConstraint* JVMFlagConstraintList::find(const char* name) {</span>
334   JVMFlagConstraint* found = NULL;
335   for (int i=0; i&lt;length(); i++) {
336     JVMFlagConstraint* constraint = at(i);
<span class="line-modified">337     if (strcmp(constraint-&gt;name(), name) == 0) {</span>
338       found = constraint;
339       break;
340     }
341   }
342   return found;
343 }
344 
<span class="line-modified">345 // Find constraints by name and return only if found constraint&#39;s type is equal or lower than current validating type.</span>
<span class="line-modified">346 JVMFlagConstraint* JVMFlagConstraintList::find_if_needs_check(const char* name) {</span>
347   JVMFlagConstraint* found = NULL;
<span class="line-modified">348   JVMFlagConstraint* constraint = find(name);</span>
<span class="line-modified">349   if (constraint &amp;&amp; (constraint-&gt;type() &lt;= _validating_type)) {</span>
350     found = constraint;
351   }
352   return found;
353 }
354 
355 // Check constraints for specific constraint type.
356 bool JVMFlagConstraintList::check_constraints(JVMFlagConstraint::ConstraintType type) {
357   guarantee(type &gt; _validating_type, &quot;Constraint check is out of order.&quot;);
358   _validating_type = type;
359 
360   bool status = true;
361   for (int i=0; i&lt;length(); i++) {
362     JVMFlagConstraint* constraint = at(i);
363     if (type != constraint-&gt;type()) continue;
364     if (constraint-&gt;apply(true) != JVMFlag::SUCCESS) status = false;
365   }
366   return status;
367 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/stringTable.hpp&quot;
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;gc/shared/jvmFlagConstraintsGC.hpp&quot;
 29 #include &quot;runtime/arguments.hpp&quot;
 30 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 31 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
 32 #include &quot;runtime/flags/jvmFlagConstraintsCompiler.hpp&quot;
 33 #include &quot;runtime/flags/jvmFlagConstraintsRuntime.hpp&quot;
<span class="line-added"> 34 #include &quot;runtime/globals.hpp&quot;</span>
<span class="line-added"> 35 #include &quot;runtime/globals_extension.hpp&quot;</span>
 36 #include &quot;runtime/os.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;






 38 
 39 class JVMFlagConstraint_bool : public JVMFlagConstraint {
 40   JVMFlagConstraintFunc_bool _constraint;

 41 
 42 public:
<span class="line-modified"> 43   JVMFlagConstraint_bool(const JVMFlag* flag,</span>
<span class="line-modified"> 44                          JVMFlagConstraintFunc_bool func,</span>
<span class="line-modified"> 45                          ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}</span>

 46 
 47   JVMFlag::Error apply(bool verbose) {
<span class="line-modified"> 48     return _constraint(_flag-&gt;get_bool(), verbose);</span>

 49   }
 50 
 51   JVMFlag::Error apply_bool(bool value, bool verbose) {
 52     return _constraint(value, verbose);
 53   }
 54 };
 55 
 56 class JVMFlagConstraint_int : public JVMFlagConstraint {
 57   JVMFlagConstraintFunc_int _constraint;

 58 
 59 public:
<span class="line-modified"> 60   JVMFlagConstraint_int(const JVMFlag* flag,</span>
<span class="line-modified"> 61                         JVMFlagConstraintFunc_int func,</span>
<span class="line-modified"> 62                         ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}</span>

 63 
 64   JVMFlag::Error apply(bool verbose) {
<span class="line-modified"> 65     return _constraint(_flag-&gt;get_int(), verbose);</span>

 66   }
 67 
 68   JVMFlag::Error apply_int(int value, bool verbose) {
 69     return _constraint(value, verbose);
 70   }
 71 };
 72 
 73 class JVMFlagConstraint_intx : public JVMFlagConstraint {
 74   JVMFlagConstraintFunc_intx _constraint;

 75 
 76 public:
<span class="line-modified"> 77   JVMFlagConstraint_intx(const JVMFlag* flag,</span>
<span class="line-modified"> 78                          JVMFlagConstraintFunc_intx func,</span>
<span class="line-modified"> 79                          ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}</span>

 80 
 81   JVMFlag::Error apply(bool verbose) {
<span class="line-modified"> 82     return _constraint(_flag-&gt;get_intx(), verbose);</span>

 83   }
 84 
 85   JVMFlag::Error apply_intx(intx value, bool verbose) {
 86     return _constraint(value, verbose);
 87   }
 88 };
 89 
 90 class JVMFlagConstraint_uint : public JVMFlagConstraint {
 91   JVMFlagConstraintFunc_uint _constraint;

 92 
 93 public:
<span class="line-modified"> 94   JVMFlagConstraint_uint(const JVMFlag* flag,</span>
<span class="line-modified"> 95                          JVMFlagConstraintFunc_uint func,</span>
<span class="line-modified"> 96                          ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}</span>

 97 
 98   JVMFlag::Error apply(bool verbose) {
<span class="line-modified"> 99     return _constraint(_flag-&gt;get_uint(), verbose);</span>

100   }
101 
102   JVMFlag::Error apply_uint(uint value, bool verbose) {
103     return _constraint(value, verbose);
104   }
105 };
106 
107 class JVMFlagConstraint_uintx : public JVMFlagConstraint {
108   JVMFlagConstraintFunc_uintx _constraint;

109 
110 public:
<span class="line-modified">111   JVMFlagConstraint_uintx(const JVMFlag* flag,</span>
<span class="line-modified">112                           JVMFlagConstraintFunc_uintx func,</span>
<span class="line-modified">113                           ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}</span>

114 
115   JVMFlag::Error apply(bool verbose) {
<span class="line-modified">116     return _constraint(_flag-&gt;get_uintx(), verbose);</span>

117   }
118 
119   JVMFlag::Error apply_uintx(uintx value, bool verbose) {
120     return _constraint(value, verbose);
121   }
122 };
123 
124 class JVMFlagConstraint_uint64_t : public JVMFlagConstraint {
125   JVMFlagConstraintFunc_uint64_t _constraint;

126 
127 public:
<span class="line-modified">128   JVMFlagConstraint_uint64_t(const JVMFlag* flag,</span>
<span class="line-modified">129                              JVMFlagConstraintFunc_uint64_t func,</span>
<span class="line-modified">130                              ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}</span>

131 
132   JVMFlag::Error apply(bool verbose) {
<span class="line-modified">133     return _constraint(_flag-&gt;get_uint64_t(), verbose);</span>

134   }
135 
136   JVMFlag::Error apply_uint64_t(uint64_t value, bool verbose) {
137     return _constraint(value, verbose);
138   }
139 };
140 
141 class JVMFlagConstraint_size_t : public JVMFlagConstraint {
142   JVMFlagConstraintFunc_size_t _constraint;
<span class="line-modified">143 </span>
144 public:
<span class="line-modified">145   JVMFlagConstraint_size_t(const JVMFlag* flag,</span>
<span class="line-modified">146                            JVMFlagConstraintFunc_size_t func,</span>
<span class="line-modified">147                            ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}</span>

148 
149   JVMFlag::Error apply(bool verbose) {
<span class="line-modified">150     return _constraint(_flag-&gt;get_size_t(), verbose);</span>

151   }
152 
153   JVMFlag::Error apply_size_t(size_t value, bool verbose) {
154     return _constraint(value, verbose);
155   }
156 };
157 
158 class JVMFlagConstraint_double : public JVMFlagConstraint {
159   JVMFlagConstraintFunc_double _constraint;

160 
161 public:
<span class="line-modified">162   JVMFlagConstraint_double(const JVMFlag* flag,</span>
<span class="line-modified">163                            JVMFlagConstraintFunc_double func,</span>
<span class="line-modified">164                            ConstraintType type) : JVMFlagConstraint(flag, type), _constraint(func) {}</span>

165 
166   JVMFlag::Error apply(bool verbose) {
<span class="line-modified">167     return _constraint(_flag-&gt;get_double(), verbose);</span>

168   }
169 
170   JVMFlag::Error apply_double(double value, bool verbose) {
171     return _constraint(value, verbose);
172   }
173 };
174 
175 // No constraint emitting
<span class="line-modified">176 void emit_constraint_no(...)                            { /* NOP */ }</span>
177 
178 // No constraint emitting if function argument is NOT provided
<span class="line-modified">179 void emit_constraint_bool(const JVMFlag* /*flag*/)      { /* NOP */ }</span>
<span class="line-modified">180 void emit_constraint_ccstr(const JVMFlag* /*flag*/)     { /* NOP */ }</span>
<span class="line-modified">181 void emit_constraint_ccstrlist(const JVMFlag* /*flag*/) { /* NOP */ }</span>
<span class="line-modified">182 void emit_constraint_int(const JVMFlag* /*flag*/)       { /* NOP */ }</span>
<span class="line-modified">183 void emit_constraint_intx(const JVMFlag* /*flag*/)      { /* NOP */ }</span>
<span class="line-modified">184 void emit_constraint_uint(const JVMFlag* /*flag*/)      { /* NOP */ }</span>
<span class="line-modified">185 void emit_constraint_uintx(const JVMFlag* /*flag*/)     { /* NOP */ }</span>
<span class="line-modified">186 void emit_constraint_uint64_t(const JVMFlag* /*flag*/)  { /* NOP */ }</span>
<span class="line-modified">187 void emit_constraint_size_t(const JVMFlag* /*flag*/)    { /* NOP */ }</span>
<span class="line-modified">188 void emit_constraint_double(const JVMFlag* /*flag*/)    { /* NOP */ }</span>
189 
190 // JVMFlagConstraint emitting code functions if function argument is provided
<span class="line-modified">191 void emit_constraint_bool(const JVMFlag* flag, JVMFlagConstraintFunc_bool func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">192   JVMFlagConstraintList::add(new JVMFlagConstraint_bool(flag, func, type));</span>
193 }
<span class="line-modified">194 void emit_constraint_int(const JVMFlag* flag, JVMFlagConstraintFunc_int func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">195   JVMFlagConstraintList::add(new JVMFlagConstraint_int(flag, func, type));</span>
196 }
<span class="line-modified">197 void emit_constraint_intx(const JVMFlag* flag, JVMFlagConstraintFunc_intx func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">198   JVMFlagConstraintList::add(new JVMFlagConstraint_intx(flag, func, type));</span>
199 }
<span class="line-modified">200 void emit_constraint_uint(const JVMFlag* flag, JVMFlagConstraintFunc_uint func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">201   JVMFlagConstraintList::add(new JVMFlagConstraint_uint(flag, func, type));</span>
202 }
<span class="line-modified">203 void emit_constraint_uintx(const JVMFlag* flag, JVMFlagConstraintFunc_uintx func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">204   JVMFlagConstraintList::add(new JVMFlagConstraint_uintx(flag, func, type));</span>
205 }
<span class="line-modified">206 void emit_constraint_uint64_t(const JVMFlag* flag, JVMFlagConstraintFunc_uint64_t func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">207   JVMFlagConstraintList::add(new JVMFlagConstraint_uint64_t(flag, func, type));</span>
208 }
<span class="line-modified">209 void emit_constraint_size_t(const JVMFlag* flag, JVMFlagConstraintFunc_size_t func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">210   JVMFlagConstraintList::add(new JVMFlagConstraint_size_t(flag, func, type));</span>
211 }
<span class="line-modified">212 void emit_constraint_double(const JVMFlag* flag, JVMFlagConstraintFunc_double func, JVMFlagConstraint::ConstraintType type) {</span>
<span class="line-modified">213   JVMFlagConstraintList::add(new JVMFlagConstraint_double(flag, func, type));</span>
214 }
215 
216 // Generate code to call emit_constraint_xxx function
<span class="line-modified">217 #define EMIT_CONSTRAINT_START       (void)(0</span>
<span class="line-modified">218 #define EMIT_CONSTRAINT(type, name) ); emit_constraint_##type(JVMFlagEx::flag_from_enum(FLAG_MEMBER_ENUM(name))</span>
<span class="line-modified">219 #define EMIT_CONSTRAINT_NO          ); emit_constraint_no(0</span>
<span class="line-modified">220 #define EMIT_CONSTRAINT_PRODUCT_FLAG(type, name, value, doc)      EMIT_CONSTRAINT(type, name)</span>
<span class="line-modified">221 #define EMIT_CONSTRAINT_DIAGNOSTIC_FLAG(type, name, value, doc)   EMIT_CONSTRAINT(type, name)</span>
<span class="line-modified">222 #define EMIT_CONSTRAINT_EXPERIMENTAL_FLAG(type, name, value, doc) EMIT_CONSTRAINT(type, name)</span>
<span class="line-modified">223 #define EMIT_CONSTRAINT_MANAGEABLE_FLAG(type, name, value, doc)   EMIT_CONSTRAINT(type, name)</span>
<span class="line-added">224 #define EMIT_CONSTRAINT_PRODUCT_RW_FLAG(type, name, value, doc)   EMIT_CONSTRAINT(type, name)</span>
<span class="line-added">225 #define EMIT_CONSTRAINT_PD_PRODUCT_FLAG(type, name, doc)          EMIT_CONSTRAINT(type, name)</span>
<span class="line-added">226 #define EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG(type, name, doc)       EMIT_CONSTRAINT(type, name)</span>
227 #ifndef PRODUCT
<span class="line-modified">228 #define EMIT_CONSTRAINT_DEVELOPER_FLAG(type, name, value, doc)    EMIT_CONSTRAINT(type, name)</span>
<span class="line-modified">229 #define EMIT_CONSTRAINT_PD_DEVELOPER_FLAG(type, name, doc)        EMIT_CONSTRAINT(type, name)</span>
<span class="line-modified">230 #define EMIT_CONSTRAINT_NOTPRODUCT_FLAG(type, name, value, doc)   EMIT_CONSTRAINT(type, name)</span>
231 #else
<span class="line-modified">232 #define EMIT_CONSTRAINT_DEVELOPER_FLAG(type, name, value, doc)    EMIT_CONSTRAINT_NO</span>
<span class="line-modified">233 #define EMIT_CONSTRAINT_PD_DEVELOPER_FLAG(type, name, doc)        EMIT_CONSTRAINT_NO</span>
<span class="line-modified">234 #define EMIT_CONSTRAINT_NOTPRODUCT_FLAG(type, name, value, doc)   EMIT_CONSTRAINT_NO</span>
235 #endif
236 #ifdef _LP64
<span class="line-modified">237 #define EMIT_CONSTRAINT_LP64_PRODUCT_FLAG(type, name, value, doc) EMIT_CONSTRAINT(type, name)</span>
238 #else
<span class="line-modified">239 #define EMIT_CONSTRAINT_LP64_PRODUCT_FLAG(type, name, value, doc) EMIT_CONSTRAINT_NO</span>
240 #endif
<span class="line-added">241 #define EMIT_CONSTRAINT_END         );</span>
242 
243 // Generate func argument to pass into emit_constraint_xxx functions
244 #define EMIT_CONSTRAINT_CHECK(func, type)                         , func, JVMFlagConstraint::type
245 
246 // the &quot;name&quot; argument must be a string literal
247 #define INITIAL_CONSTRAINTS_SIZE 72
248 GrowableArray&lt;JVMFlagConstraint*&gt;* JVMFlagConstraintList::_constraints = NULL;
249 JVMFlagConstraint::ConstraintType JVMFlagConstraintList::_validating_type = JVMFlagConstraint::AtParse;
250 
251 // Check the ranges of all flags that have them or print them out and exit if requested
252 void JVMFlagConstraintList::init(void) {
253   _constraints = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;JVMFlagConstraint*&gt;(INITIAL_CONSTRAINTS_SIZE, true);
254 
<span class="line-modified">255   EMIT_CONSTRAINT_START</span>
<span class="line-modified">256 </span>
<span class="line-modified">257   ALL_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,</span>
<span class="line-modified">258             EMIT_CONSTRAINT_PD_DEVELOPER_FLAG,</span>
<span class="line-modified">259             EMIT_CONSTRAINT_PRODUCT_FLAG,</span>
<span class="line-modified">260             EMIT_CONSTRAINT_PD_PRODUCT_FLAG,</span>
<span class="line-modified">261             EMIT_CONSTRAINT_DIAGNOSTIC_FLAG,</span>
<span class="line-modified">262             EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG,</span>
<span class="line-modified">263             EMIT_CONSTRAINT_EXPERIMENTAL_FLAG,</span>
<span class="line-modified">264             EMIT_CONSTRAINT_NOTPRODUCT_FLAG,</span>
<span class="line-modified">265             EMIT_CONSTRAINT_MANAGEABLE_FLAG,</span>
<span class="line-modified">266             EMIT_CONSTRAINT_PRODUCT_RW_FLAG,</span>
<span class="line-modified">267             EMIT_CONSTRAINT_LP64_PRODUCT_FLAG,</span>
<span class="line-modified">268             IGNORE_RANGE,</span>
<span class="line-modified">269             EMIT_CONSTRAINT_CHECK)</span>
<span class="line-modified">270 </span>
<span class="line-modified">271   EMIT_CONSTRAINT_END</span>




































272 }
273 
<span class="line-modified">274 JVMFlagConstraint* JVMFlagConstraintList::find(const JVMFlag* flag) {</span>
275   JVMFlagConstraint* found = NULL;
276   for (int i=0; i&lt;length(); i++) {
277     JVMFlagConstraint* constraint = at(i);
<span class="line-modified">278     if (constraint-&gt;flag() == flag) {</span>
279       found = constraint;
280       break;
281     }
282   }
283   return found;
284 }
285 
<span class="line-modified">286 // Find constraints and return only if found constraint&#39;s type is equal or lower than current validating type.</span>
<span class="line-modified">287 JVMFlagConstraint* JVMFlagConstraintList::find_if_needs_check(const JVMFlag* flag) {</span>
288   JVMFlagConstraint* found = NULL;
<span class="line-modified">289   JVMFlagConstraint* constraint = find(flag);</span>
<span class="line-modified">290   if (constraint != NULL &amp;&amp; (constraint-&gt;type() &lt;= _validating_type)) {</span>
291     found = constraint;
292   }
293   return found;
294 }
295 
296 // Check constraints for specific constraint type.
297 bool JVMFlagConstraintList::check_constraints(JVMFlagConstraint::ConstraintType type) {
298   guarantee(type &gt; _validating_type, &quot;Constraint check is out of order.&quot;);
299   _validating_type = type;
300 
301   bool status = true;
302   for (int i=0; i&lt;length(); i++) {
303     JVMFlagConstraint* constraint = at(i);
304     if (type != constraint-&gt;type()) continue;
305     if (constraint-&gt;apply(true) != JVMFlag::SUCCESS) status = false;
306   }
307   return status;
308 }
</pre>
</td>
</tr>
</table>
<center><a href="jvmFlag.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintList.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
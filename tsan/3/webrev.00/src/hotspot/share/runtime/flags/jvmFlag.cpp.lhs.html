<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/flags/jvmFlag.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jfr/jfrEvents.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;runtime/arguments.hpp&quot;
  29 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  30 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed">  31 #include &quot;runtime/flags/jvmFlagWriteableList.hpp&quot;</span>
  32 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  33 #include &quot;runtime/globals_extension.hpp&quot;
  34 #include &quot;utilities/defaultStream.hpp&quot;
  35 #include &quot;utilities/stringUtils.hpp&quot;
  36 
  37 #define DEFAULT_RANGE_STR_CHUNK_SIZE 64
  38 static char* create_range_str(const char *fmt, ...) {
  39   static size_t string_length = DEFAULT_RANGE_STR_CHUNK_SIZE;
  40   static char* range_string = NEW_C_HEAP_ARRAY(char, string_length, mtLogging);
  41 
  42   int size_needed = 0;
  43   do {
  44     va_list args;
  45     va_start(args, fmt);
  46     size_needed = jio_vsnprintf(range_string, string_length, fmt, args);
  47     va_end(args);
  48 
  49     if (size_needed &lt; 0) {
  50       string_length += DEFAULT_RANGE_STR_CHUNK_SIZE;
  51       range_string = REALLOC_C_HEAP_ARRAY(char, range_string, string_length, mtLogging);
  52       guarantee(range_string != NULL, &quot;create_range_str string should not be NULL&quot;);
  53     }
  54   } while (size_needed &lt; 0);
  55 
  56   return range_string;
  57 }
  58 
  59 const char* JVMFlag::get_int_default_range_str() {
  60   return create_range_str(&quot;[ &quot; INT32_FORMAT_W(-25) &quot; ... &quot; INT32_FORMAT_W(25) &quot; ]&quot;, INT_MIN, INT_MAX);
  61 }
  62 
  63 const char* JVMFlag::get_uint_default_range_str() {
  64   return create_range_str(&quot;[ &quot; UINT32_FORMAT_W(-25) &quot; ... &quot; UINT32_FORMAT_W(25) &quot; ]&quot;, 0, UINT_MAX);
  65 }
  66 
  67 const char* JVMFlag::get_intx_default_range_str() {
  68   return create_range_str(&quot;[ &quot; INTX_FORMAT_W(-25) &quot; ... &quot; INTX_FORMAT_W(25) &quot; ]&quot;, min_intx, max_intx);
  69 }
  70 
  71 const char* JVMFlag::get_uintx_default_range_str() {
  72   return create_range_str(&quot;[ &quot; UINTX_FORMAT_W(-25) &quot; ... &quot; UINTX_FORMAT_W(25) &quot; ]&quot;, 0, max_uintx);
  73 }
  74 
  75 const char* JVMFlag::get_uint64_t_default_range_str() {
  76   return create_range_str(&quot;[ &quot; UINT64_FORMAT_W(-25) &quot; ... &quot; UINT64_FORMAT_W(25) &quot; ]&quot;, 0, uint64_t(max_juint));
  77 }
  78 
  79 const char* JVMFlag::get_size_t_default_range_str() {
  80   return create_range_str(&quot;[ &quot; SIZE_FORMAT_W(-25) &quot; ... &quot; SIZE_FORMAT_W(25) &quot; ]&quot;, 0, SIZE_MAX);
  81 }
  82 
  83 const char* JVMFlag::get_double_default_range_str() {
  84   return create_range_str(&quot;[ %-25.3f ... %25.3f ]&quot;, DBL_MIN, DBL_MAX);
  85 }
  86 
  87 static bool is_product_build() {
  88 #ifdef PRODUCT
  89   return true;
  90 #else
  91   return false;
  92 #endif
  93 }
  94 
<a name="3" id="anc3"></a><span class="line-removed">  95 JVMFlag::Error JVMFlag::check_writable(bool changed) {</span>
<span class="line-removed">  96   if (is_constant_in_binary()) {</span>
<span class="line-removed">  97     fatal(&quot;flag is constant: %s&quot;, _name);</span>
<span class="line-removed">  98   }</span>
<span class="line-removed">  99 </span>
<span class="line-removed"> 100   JVMFlag::Error error = JVMFlag::SUCCESS;</span>
<span class="line-removed"> 101   if (changed) {</span>
<span class="line-removed"> 102     JVMFlagWriteable* writeable = JVMFlagWriteableList::find(_name);</span>
<span class="line-removed"> 103     if (writeable) {</span>
<span class="line-removed"> 104       if (writeable-&gt;is_writeable() == false) {</span>
<span class="line-removed"> 105         switch (writeable-&gt;type())</span>
<span class="line-removed"> 106         {</span>
<span class="line-removed"> 107           case JVMFlagWriteable::Once:</span>
<span class="line-removed"> 108             error = JVMFlag::SET_ONLY_ONCE;</span>
<span class="line-removed"> 109             jio_fprintf(defaultStream::error_stream(), &quot;Error: %s may not be set more than once\n&quot;, _name);</span>
<span class="line-removed"> 110             break;</span>
<span class="line-removed"> 111           case JVMFlagWriteable::CommandLineOnly:</span>
<span class="line-removed"> 112             error = JVMFlag::COMMAND_LINE_ONLY;</span>
<span class="line-removed"> 113             jio_fprintf(defaultStream::error_stream(), &quot;Error: %s may be modified only from commad line\n&quot;, _name);</span>
<span class="line-removed"> 114             break;</span>
<span class="line-removed"> 115           default:</span>
<span class="line-removed"> 116             ShouldNotReachHere();</span>
<span class="line-removed"> 117             break;</span>
<span class="line-removed"> 118         }</span>
<span class="line-removed"> 119       }</span>
<span class="line-removed"> 120       writeable-&gt;mark_once();</span>
<span class="line-removed"> 121     }</span>
<span class="line-removed"> 122   }</span>
<span class="line-removed"> 123   return error;</span>
<span class="line-removed"> 124 }</span>
<span class="line-removed"> 125 </span>
 126 bool JVMFlag::is_bool() const {
 127   return strcmp(_type, &quot;bool&quot;) == 0;
 128 }
 129 
<a name="4" id="anc4"></a><span class="line-removed"> 130 bool JVMFlag::get_bool() const {</span>
<span class="line-removed"> 131   return *((bool*) _addr);</span>
<span class="line-removed"> 132 }</span>
<span class="line-removed"> 133 </span>
<span class="line-removed"> 134 JVMFlag::Error JVMFlag::set_bool(bool value) {</span>
<span class="line-removed"> 135   JVMFlag::Error error = check_writable(value!=get_bool());</span>
<span class="line-removed"> 136   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 137     *((bool*) _addr) = value;</span>
<span class="line-removed"> 138   }</span>
<span class="line-removed"> 139   return error;</span>
<span class="line-removed"> 140 }</span>
<span class="line-removed"> 141 </span>
 142 bool JVMFlag::is_int() const {
 143   return strcmp(_type, &quot;int&quot;)  == 0;
 144 }
 145 
<a name="5" id="anc5"></a><span class="line-removed"> 146 int JVMFlag::get_int() const {</span>
<span class="line-removed"> 147   return *((int*) _addr);</span>
<span class="line-removed"> 148 }</span>
<span class="line-removed"> 149 </span>
<span class="line-removed"> 150 JVMFlag::Error JVMFlag::set_int(int value) {</span>
<span class="line-removed"> 151   JVMFlag::Error error = check_writable(value!=get_int());</span>
<span class="line-removed"> 152   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 153     *((int*) _addr) = value;</span>
<span class="line-removed"> 154   }</span>
<span class="line-removed"> 155   return error;</span>
<span class="line-removed"> 156 }</span>
<span class="line-removed"> 157 </span>
 158 bool JVMFlag::is_uint() const {
 159   return strcmp(_type, &quot;uint&quot;)  == 0;
 160 }
 161 
<a name="6" id="anc6"></a><span class="line-removed"> 162 uint JVMFlag::get_uint() const {</span>
<span class="line-removed"> 163   return *((uint*) _addr);</span>
<span class="line-removed"> 164 }</span>
<span class="line-removed"> 165 </span>
<span class="line-removed"> 166 JVMFlag::Error JVMFlag::set_uint(uint value) {</span>
<span class="line-removed"> 167   JVMFlag::Error error = check_writable(value!=get_uint());</span>
<span class="line-removed"> 168   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 169     *((uint*) _addr) = value;</span>
<span class="line-removed"> 170   }</span>
<span class="line-removed"> 171   return error;</span>
<span class="line-removed"> 172 }</span>
<span class="line-removed"> 173 </span>
 174 bool JVMFlag::is_intx() const {
 175   return strcmp(_type, &quot;intx&quot;)  == 0;
 176 }
 177 
<a name="7" id="anc7"></a><span class="line-removed"> 178 intx JVMFlag::get_intx() const {</span>
<span class="line-removed"> 179   return *((intx*) _addr);</span>
<span class="line-removed"> 180 }</span>
<span class="line-removed"> 181 </span>
<span class="line-removed"> 182 JVMFlag::Error JVMFlag::set_intx(intx value) {</span>
<span class="line-removed"> 183   JVMFlag::Error error = check_writable(value!=get_intx());</span>
<span class="line-removed"> 184   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 185     *((intx*) _addr) = value;</span>
<span class="line-removed"> 186   }</span>
<span class="line-removed"> 187   return error;</span>
<span class="line-removed"> 188 }</span>
<span class="line-removed"> 189 </span>
 190 bool JVMFlag::is_uintx() const {
 191   return strcmp(_type, &quot;uintx&quot;) == 0;
 192 }
 193 
<a name="8" id="anc8"></a><span class="line-removed"> 194 uintx JVMFlag::get_uintx() const {</span>
<span class="line-removed"> 195   return *((uintx*) _addr);</span>
<span class="line-removed"> 196 }</span>
<span class="line-removed"> 197 </span>
<span class="line-removed"> 198 JVMFlag::Error JVMFlag::set_uintx(uintx value) {</span>
<span class="line-removed"> 199   JVMFlag::Error error = check_writable(value!=get_uintx());</span>
<span class="line-removed"> 200   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 201     *((uintx*) _addr) = value;</span>
<span class="line-removed"> 202   }</span>
<span class="line-removed"> 203   return error;</span>
<span class="line-removed"> 204 }</span>
<span class="line-removed"> 205 </span>
 206 bool JVMFlag::is_uint64_t() const {
 207   return strcmp(_type, &quot;uint64_t&quot;) == 0;
 208 }
 209 
<a name="9" id="anc9"></a><span class="line-removed"> 210 uint64_t JVMFlag::get_uint64_t() const {</span>
<span class="line-removed"> 211   return *((uint64_t*) _addr);</span>
<span class="line-removed"> 212 }</span>
<span class="line-removed"> 213 </span>
<span class="line-removed"> 214 JVMFlag::Error JVMFlag::set_uint64_t(uint64_t value) {</span>
<span class="line-removed"> 215   JVMFlag::Error error = check_writable(value!=get_uint64_t());</span>
<span class="line-removed"> 216   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 217     *((uint64_t*) _addr) = value;</span>
<span class="line-removed"> 218   }</span>
<span class="line-removed"> 219   return error;</span>
<span class="line-removed"> 220 }</span>
<span class="line-removed"> 221 </span>
 222 bool JVMFlag::is_size_t() const {
 223   return strcmp(_type, &quot;size_t&quot;) == 0;
 224 }
 225 
<a name="10" id="anc10"></a><span class="line-removed"> 226 size_t JVMFlag::get_size_t() const {</span>
<span class="line-removed"> 227   return *((size_t*) _addr);</span>
<span class="line-removed"> 228 }</span>
<span class="line-removed"> 229 </span>
<span class="line-removed"> 230 JVMFlag::Error JVMFlag::set_size_t(size_t value) {</span>
<span class="line-removed"> 231   JVMFlag::Error error = check_writable(value!=get_size_t());</span>
<span class="line-removed"> 232   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 233     *((size_t*) _addr) = value;</span>
<span class="line-removed"> 234   }</span>
<span class="line-removed"> 235   return error;</span>
<span class="line-removed"> 236 }</span>
<span class="line-removed"> 237 </span>
 238 bool JVMFlag::is_double() const {
 239   return strcmp(_type, &quot;double&quot;) == 0;
 240 }
 241 
<a name="11" id="anc11"></a><span class="line-removed"> 242 double JVMFlag::get_double() const {</span>
<span class="line-removed"> 243   return *((double*) _addr);</span>
<span class="line-removed"> 244 }</span>
<span class="line-removed"> 245 </span>
<span class="line-removed"> 246 JVMFlag::Error JVMFlag::set_double(double value) {</span>
<span class="line-removed"> 247   JVMFlag::Error error = check_writable(value!=get_double());</span>
<span class="line-removed"> 248   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 249     *((double*) _addr) = value;</span>
<span class="line-removed"> 250   }</span>
<span class="line-removed"> 251   return error;</span>
<span class="line-removed"> 252 }</span>
<span class="line-removed"> 253 </span>
 254 bool JVMFlag::is_ccstr() const {
 255   return strcmp(_type, &quot;ccstr&quot;) == 0 || strcmp(_type, &quot;ccstrlist&quot;) == 0;
 256 }
 257 
 258 bool JVMFlag::ccstr_accumulates() const {
 259   return strcmp(_type, &quot;ccstrlist&quot;) == 0;
 260 }
 261 
<a name="12" id="anc12"></a><span class="line-removed"> 262 ccstr JVMFlag::get_ccstr() const {</span>
<span class="line-removed"> 263   return *((ccstr*) _addr);</span>
<span class="line-removed"> 264 }</span>
<span class="line-removed"> 265 </span>
<span class="line-removed"> 266 JVMFlag::Error JVMFlag::set_ccstr(ccstr value) {</span>
<span class="line-removed"> 267   JVMFlag::Error error = check_writable(value!=get_ccstr());</span>
<span class="line-removed"> 268   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 269     *((ccstr*) _addr) = value;</span>
<span class="line-removed"> 270   }</span>
<span class="line-removed"> 271   return error;</span>
<span class="line-removed"> 272 }</span>
<span class="line-removed"> 273 </span>
<span class="line-removed"> 274 </span>
 275 JVMFlag::Flags JVMFlag::get_origin() {
 276   return Flags(_flags &amp; VALUE_ORIGIN_MASK);
 277 }
 278 
 279 void JVMFlag::set_origin(Flags origin) {
 280   assert((origin &amp; VALUE_ORIGIN_MASK) == origin, &quot;sanity&quot;);
 281   Flags new_origin = Flags((origin == COMMAND_LINE) ? Flags(origin | ORIG_COMMAND_LINE) : origin);
 282   _flags = Flags((_flags &amp; ~VALUE_ORIGIN_MASK) | new_origin);
 283 }
 284 
 285 bool JVMFlag::is_default() {
 286   return (get_origin() == DEFAULT);
 287 }
 288 
 289 bool JVMFlag::is_ergonomic() {
 290   return (get_origin() == ERGONOMIC);
 291 }
 292 
 293 bool JVMFlag::is_command_line() {
 294   return (_flags &amp; ORIG_COMMAND_LINE) != 0;
 295 }
 296 
 297 void JVMFlag::set_command_line() {
 298   _flags = Flags(_flags | ORIG_COMMAND_LINE);
 299 }
 300 
 301 bool JVMFlag::is_product() const {
 302   return (_flags &amp; KIND_PRODUCT) != 0;
 303 }
 304 
 305 bool JVMFlag::is_manageable() const {
 306   return (_flags &amp; KIND_MANAGEABLE) != 0;
 307 }
 308 
 309 bool JVMFlag::is_diagnostic() const {
 310   return (_flags &amp; KIND_DIAGNOSTIC) != 0;
 311 }
 312 
 313 bool JVMFlag::is_experimental() const {
 314   return (_flags &amp; KIND_EXPERIMENTAL) != 0;
 315 }
 316 
 317 bool JVMFlag::is_notproduct() const {
 318   return (_flags &amp; KIND_NOT_PRODUCT) != 0;
 319 }
 320 
 321 bool JVMFlag::is_develop() const {
 322   return (_flags &amp; KIND_DEVELOP) != 0;
 323 }
 324 
 325 bool JVMFlag::is_read_write() const {
 326   return (_flags &amp; KIND_READ_WRITE) != 0;
 327 }
 328 
 329 /**
 330  * Returns if this flag is a constant in the binary.  Right now this is
 331  * true for notproduct and develop flags in product builds.
 332  */
 333 bool JVMFlag::is_constant_in_binary() const {
 334 #ifdef PRODUCT
 335   return is_notproduct() || is_develop();
 336 #else
 337   return false;
 338 #endif
 339 }
 340 
 341 bool JVMFlag::is_unlocker() const {
<a name="13" id="anc13"></a><span class="line-modified"> 342   return strcmp(_name, &quot;UnlockDiagnosticVMOptions&quot;) == 0     ||</span>
<span class="line-modified"> 343   strcmp(_name, &quot;UnlockExperimentalVMOptions&quot;) == 0   ||</span>
<span class="line-removed"> 344   is_unlocker_ext();</span>
 345 }
 346 
 347 bool JVMFlag::is_unlocked() const {
 348   if (is_diagnostic()) {
 349     return UnlockDiagnosticVMOptions;
 350   }
 351   if (is_experimental()) {
 352     return UnlockExperimentalVMOptions;
 353   }
<a name="14" id="anc14"></a><span class="line-modified"> 354   return is_unlocked_ext();</span>
 355 }
 356 
 357 void JVMFlag::clear_diagnostic() {
 358   assert(is_diagnostic(), &quot;sanity&quot;);
 359   _flags = Flags(_flags &amp; ~KIND_DIAGNOSTIC);
 360   assert(!is_diagnostic(), &quot;sanity&quot;);
 361 }
 362 
<a name="15" id="anc15"></a>











 363 // Get custom message for this locked flag, or NULL if
 364 // none is available. Returns message type produced.
 365 JVMFlag::MsgType JVMFlag::get_locked_message(char* buf, int buflen) const {
 366   buf[0] = &#39;\0&#39;;
 367   if (is_diagnostic() &amp;&amp; !is_unlocked()) {
 368     jio_snprintf(buf, buflen,
 369                  &quot;Error: VM option &#39;%s&#39; is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions.\n&quot;
 370                  &quot;Error: The unlock option must precede &#39;%s&#39;.\n&quot;,
 371                  _name, _name);
 372     return JVMFlag::DIAGNOSTIC_FLAG_BUT_LOCKED;
 373   }
 374   if (is_experimental() &amp;&amp; !is_unlocked()) {
 375     jio_snprintf(buf, buflen,
 376                  &quot;Error: VM option &#39;%s&#39; is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions.\n&quot;
 377                  &quot;Error: The unlock option must precede &#39;%s&#39;.\n&quot;,
 378                  _name, _name);
 379     return JVMFlag::EXPERIMENTAL_FLAG_BUT_LOCKED;
 380   }
 381   if (is_develop() &amp;&amp; is_product_build()) {
 382     jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is develop and is available only in debug version of VM.\n&quot;,
 383                  _name);
 384     return JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD;
 385   }
 386   if (is_notproduct() &amp;&amp; is_product_build()) {
 387     jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is notproduct and is available only in debug version of VM.\n&quot;,
 388                  _name);
 389     return JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD;
 390   }
<a name="16" id="anc16"></a><span class="line-modified"> 391   return get_locked_message_ext(buf, buflen);</span>
 392 }
 393 
 394 bool JVMFlag::is_writeable() const {
<a name="17" id="anc17"></a><span class="line-modified"> 395   return is_manageable() || (is_product() &amp;&amp; is_read_write()) || is_writeable_ext();</span>
 396 }
 397 
 398 // All flags except &quot;manageable&quot; are assumed to be internal flags.
 399 // Long term, we need to define a mechanism to specify which flags
 400 // are external/stable and change this function accordingly.
 401 bool JVMFlag::is_external() const {
<a name="18" id="anc18"></a><span class="line-modified"> 402   return is_manageable() || is_external_ext();</span>
 403 }
 404 
 405 // Helper function for JVMFlag::print_on().
 406 // Fills current line up to requested position.
 407 // Should the current position already be past the requested position,
 408 // one separator blank is enforced.
 409 void fill_to_pos(outputStream* st, unsigned int req_pos) {
 410   if ((unsigned int)st-&gt;position() &lt; req_pos) {
 411     st-&gt;fill_to(req_pos);  // need to fill with blanks to reach req_pos
 412   } else {
 413     st-&gt;print(&quot; &quot;);        // enforce blank separation. Previous field too long.
 414   }
 415 }
 416 
 417 void JVMFlag::print_on(outputStream* st, bool withComments, bool printRanges) {
 418   // Don&#39;t print notproduct and develop flags in a product build.
 419   if (is_constant_in_binary()) {
 420     return;
 421   }
 422 
 423   if (!printRanges) {
 424     // The command line options -XX:+PrintFlags* cause this function to be called
 425     // for each existing flag to print information pertinent to this flag. The data
 426     // is displayed in columnar form, with the following layout:
 427     //  col1 - data type, right-justified
 428     //  col2 - name,      left-justified
 429     //  col3 - &#39; =&#39;       double-char, leading space to align with possible &#39;+=&#39;
 430     //  col4 - value      left-justified
 431     //  col5 - kind       right-justified
 432     //  col6 - origin     left-justified
 433     //  col7 - comments   left-justified
 434     //
 435     //  The column widths are fixed. They are defined such that, for most cases,
 436     //  an eye-pleasing tabular output is created.
 437     //
 438     //  Sample output:
<a name="19" id="anc19"></a><span class="line-modified"> 439     //       bool CMSScavengeBeforeRemark                  = false                                     {product} {default}</span>
<span class="line-modified"> 440     //      uintx CMSScheduleRemarkEdenPenetration         = 50                                        {product} {default}</span>
<span class="line-modified"> 441     //     size_t CMSScheduleRemarkEdenSizeThreshold       = 2097152                                   {product} {default}</span>
<span class="line-modified"> 442     //      uintx CMSScheduleRemarkSamplingRatio           = 5                                         {product} {default}</span>
<span class="line-modified"> 443     //     double CMSSmallCoalSurplusPercent               = 1.050000                                  {product} {default}</span>
 444     //      ccstr CompileCommandFile                       = MyFile.cmd                                {product} {command line}
 445     //  ccstrlist CompileOnly                              = Method1
 446     //            CompileOnly                             += Method2                                   {product} {command line}
 447     //  |         |                                       |  |                              |                    |               |
 448     //  |         |                                       |  |                              |                    |               +-- col7
 449     //  |         |                                       |  |                              |                    +-- col6
 450     //  |         |                                       |  |                              +-- col5
 451     //  |         |                                       |  +-- col4
 452     //  |         |                                       +-- col3
 453     //  |         +-- col2
 454     //  +-- col1
 455 
 456     const unsigned int col_spacing = 1;
 457     const unsigned int col1_pos    = 0;
 458     const unsigned int col1_width  = 9;
 459     const unsigned int col2_pos    = col1_pos + col1_width + col_spacing;
 460     const unsigned int col2_width  = 39;
 461     const unsigned int col3_pos    = col2_pos + col2_width + col_spacing;
 462     const unsigned int col3_width  = 2;
 463     const unsigned int col4_pos    = col3_pos + col3_width + col_spacing;
 464     const unsigned int col4_width  = 30;
 465     const unsigned int col5_pos    = col4_pos + col4_width + col_spacing;
 466     const unsigned int col5_width  = 20;
 467     const unsigned int col6_pos    = col5_pos + col5_width + col_spacing;
 468     const unsigned int col6_width  = 15;
 469     const unsigned int col7_pos    = col6_pos + col6_width + col_spacing;
 470     const unsigned int col7_width  = 1;
 471 
 472     st-&gt;fill_to(col1_pos);
 473     st-&gt;print(&quot;%*s&quot;, col1_width, _type);  // right-justified, therefore width is required.
 474 
 475     fill_to_pos(st, col2_pos);
 476     st-&gt;print(&quot;%s&quot;, _name);
 477 
 478     fill_to_pos(st, col3_pos);
 479     st-&gt;print(&quot; =&quot;);  // use &quot; =&quot; for proper alignment with multiline ccstr output.
 480 
 481     fill_to_pos(st, col4_pos);
 482     if (is_bool()) {
 483       st-&gt;print(&quot;%s&quot;, get_bool() ? &quot;true&quot; : &quot;false&quot;);
 484     } else if (is_int()) {
 485       st-&gt;print(&quot;%d&quot;, get_int());
 486     } else if (is_uint()) {
 487       st-&gt;print(&quot;%u&quot;, get_uint());
 488     } else if (is_intx()) {
 489       st-&gt;print(INTX_FORMAT, get_intx());
 490     } else if (is_uintx()) {
 491       st-&gt;print(UINTX_FORMAT, get_uintx());
 492     } else if (is_uint64_t()) {
 493       st-&gt;print(UINT64_FORMAT, get_uint64_t());
 494     } else if (is_size_t()) {
 495       st-&gt;print(SIZE_FORMAT, get_size_t());
 496     } else if (is_double()) {
 497       st-&gt;print(&quot;%f&quot;, get_double());
 498     } else if (is_ccstr()) {
 499       // Honor &lt;newline&gt; characters in ccstr: print multiple lines.
 500       const char* cp = get_ccstr();
 501       if (cp != NULL) {
 502         const char* eol;
 503         while ((eol = strchr(cp, &#39;\n&#39;)) != NULL) {
 504           size_t llen = pointer_delta(eol, cp, sizeof(char));
 505           st-&gt;print(&quot;%.*s&quot;, (int)llen, cp);
 506           st-&gt;cr();
 507           cp = eol+1;
 508           fill_to_pos(st, col2_pos);
 509           st-&gt;print(&quot;%s&quot;, _name);
 510           fill_to_pos(st, col3_pos);
 511           st-&gt;print(&quot;+=&quot;);
 512           fill_to_pos(st, col4_pos);
 513         }
 514         st-&gt;print(&quot;%s&quot;, cp);
 515       }
 516     } else {
 517       st-&gt;print(&quot;unhandled  type %s&quot;, _type);
 518       st-&gt;cr();
 519       return;
 520     }
 521 
 522     fill_to_pos(st, col5_pos);
 523     print_kind(st, col5_width);
 524 
 525     fill_to_pos(st, col6_pos);
 526     print_origin(st, col6_width);
 527 
 528 #ifndef PRODUCT
 529     if (withComments) {
 530       fill_to_pos(st, col7_pos);
 531       st-&gt;print(&quot;%s&quot;, _doc);
 532     }
 533 #endif
 534     st-&gt;cr();
 535   } else if (!is_bool() &amp;&amp; !is_ccstr()) {
 536     // The command line options -XX:+PrintFlags* cause this function to be called
 537     // for each existing flag to print information pertinent to this flag. The data
 538     // is displayed in columnar form, with the following layout:
 539     //  col1 - data type, right-justified
 540     //  col2 - name,      left-justified
 541     //  col4 - range      [ min ... max]
 542     //  col5 - kind       right-justified
 543     //  col6 - origin     left-justified
 544     //  col7 - comments   left-justified
 545     //
 546     //  The column widths are fixed. They are defined such that, for most cases,
 547     //  an eye-pleasing tabular output is created.
 548     //
 549     //  Sample output:
 550     //       intx MinPassesBeforeFlush                               [ 0                         ...       9223372036854775807 ]                         {diagnostic} {default}
 551     //      uintx MinRAMFraction                                     [ 1                         ...      18446744073709551615 ]                            {product} {default}
 552     //     double MinRAMPercentage                                   [ 0.000                     ...                   100.000 ]                            {product} {default}
 553     //      uintx MinSurvivorRatio                                   [ 3                         ...      18446744073709551615 ]                            {product} {default}
 554     //     size_t MinTLABSize                                        [ 1                         ...       9223372036854775807 ]                            {product} {default}
 555     //       intx MonitorBound                                       [ 0                         ...                2147483647 ]                            {product} {default}
 556     //  |         |                                                  |                                                           |                                    |               |
 557     //  |         |                                                  |                                                           |                                    |               +-- col7
 558     //  |         |                                                  |                                                           |                                    +-- col6
 559     //  |         |                                                  |                                                           +-- col5
 560     //  |         |                                                  +-- col4
 561     //  |         +-- col2
 562     //  +-- col1
 563 
 564     const unsigned int col_spacing = 1;
 565     const unsigned int col1_pos    = 0;
 566     const unsigned int col1_width  = 9;
 567     const unsigned int col2_pos    = col1_pos + col1_width + col_spacing;
 568     const unsigned int col2_width  = 49;
 569     const unsigned int col3_pos    = col2_pos + col2_width + col_spacing;
 570     const unsigned int col3_width  = 0;
 571     const unsigned int col4_pos    = col3_pos + col3_width + col_spacing;
 572     const unsigned int col4_width  = 60;
 573     const unsigned int col5_pos    = col4_pos + col4_width + col_spacing;
 574     const unsigned int col5_width  = 35;
 575     const unsigned int col6_pos    = col5_pos + col5_width + col_spacing;
 576     const unsigned int col6_width  = 15;
 577     const unsigned int col7_pos    = col6_pos + col6_width + col_spacing;
 578     const unsigned int col7_width  = 1;
 579 
 580     st-&gt;fill_to(col1_pos);
 581     st-&gt;print(&quot;%*s&quot;, col1_width, _type);  // right-justified, therefore width is required.
 582 
 583     fill_to_pos(st, col2_pos);
 584     st-&gt;print(&quot;%s&quot;, _name);
 585 
 586     fill_to_pos(st, col4_pos);
 587     RangeStrFunc func = NULL;
 588     if (is_int()) {
 589       func = JVMFlag::get_int_default_range_str;
 590     } else if (is_uint()) {
 591       func = JVMFlag::get_uint_default_range_str;
 592     } else if (is_intx()) {
 593       func = JVMFlag::get_intx_default_range_str;
 594     } else if (is_uintx()) {
 595       func = JVMFlag::get_uintx_default_range_str;
 596     } else if (is_uint64_t()) {
 597       func = JVMFlag::get_uint64_t_default_range_str;
 598     } else if (is_size_t()) {
 599       func = JVMFlag::get_size_t_default_range_str;
 600     } else if (is_double()) {
 601       func = JVMFlag::get_double_default_range_str;
 602     } else {
 603       st-&gt;print(&quot;unhandled  type %s&quot;, _type);
 604       st-&gt;cr();
 605       return;
 606     }
<a name="20" id="anc20"></a><span class="line-modified"> 607     JVMFlagRangeList::print(st, _name, func);</span>
 608 
 609     fill_to_pos(st, col5_pos);
 610     print_kind(st, col5_width);
 611 
 612     fill_to_pos(st, col6_pos);
 613     print_origin(st, col6_width);
 614 
 615 #ifndef PRODUCT
 616     if (withComments) {
 617       fill_to_pos(st, col7_pos);
 618       st-&gt;print(&quot;%s&quot;, _doc);
 619     }
 620 #endif
 621     st-&gt;cr();
 622   }
 623 }
 624 
 625 void JVMFlag::print_kind(outputStream* st, unsigned int width) {
 626   struct Data {
 627     int flag;
 628     const char* name;
 629   };
 630 
 631   Data data[] = {
 632     { KIND_JVMCI, &quot;JVMCI&quot; },
 633     { KIND_C1, &quot;C1&quot; },
 634     { KIND_C2, &quot;C2&quot; },
 635     { KIND_ARCH, &quot;ARCH&quot; },
 636     { KIND_PLATFORM_DEPENDENT, &quot;pd&quot; },
 637     { KIND_PRODUCT, &quot;product&quot; },
 638     { KIND_MANAGEABLE, &quot;manageable&quot; },
 639     { KIND_DIAGNOSTIC, &quot;diagnostic&quot; },
 640     { KIND_EXPERIMENTAL, &quot;experimental&quot; },
 641     { KIND_NOT_PRODUCT, &quot;notproduct&quot; },
 642     { KIND_DEVELOP, &quot;develop&quot; },
 643     { KIND_LP64_PRODUCT, &quot;lp64_product&quot; },
 644     { KIND_READ_WRITE, &quot;rw&quot; },
 645     { -1, &quot;&quot; }
 646   };
 647 
 648   if ((_flags &amp; KIND_MASK) != 0) {
 649     bool is_first = true;
 650     const size_t buffer_size = 64;
 651     size_t buffer_used = 0;
 652     char kind[buffer_size];
 653 
 654     jio_snprintf(kind, buffer_size, &quot;{&quot;);
 655     buffer_used++;
 656     for (int i = 0; data[i].flag != -1; i++) {
 657       Data d = data[i];
 658       if ((_flags &amp; d.flag) != 0) {
 659         if (is_first) {
 660           is_first = false;
 661         } else {
 662           assert(buffer_used + 1 &lt; buffer_size, &quot;Too small buffer&quot;);
 663           jio_snprintf(kind + buffer_used, buffer_size - buffer_used, &quot; &quot;);
 664           buffer_used++;
 665         }
 666         size_t length = strlen(d.name);
 667         assert(buffer_used + length &lt; buffer_size, &quot;Too small buffer&quot;);
 668         jio_snprintf(kind + buffer_used, buffer_size - buffer_used, &quot;%s&quot;, d.name);
 669         buffer_used += length;
 670       }
 671     }
 672     assert(buffer_used + 2 &lt;= buffer_size, &quot;Too small buffer&quot;);
 673     jio_snprintf(kind + buffer_used, buffer_size - buffer_used, &quot;}&quot;);
 674     st-&gt;print(&quot;%*s&quot;, width, kind);
 675   }
 676 }
 677 
 678 void JVMFlag::print_origin(outputStream* st, unsigned int width) {
 679   int origin = _flags &amp; VALUE_ORIGIN_MASK;
 680   st-&gt;print(&quot;{&quot;);
 681   switch(origin) {
 682     case DEFAULT:
 683       st-&gt;print(&quot;default&quot;); break;
 684     case COMMAND_LINE:
 685       st-&gt;print(&quot;command line&quot;); break;
 686     case ENVIRON_VAR:
 687       st-&gt;print(&quot;environment&quot;); break;
 688     case CONFIG_FILE:
 689       st-&gt;print(&quot;config file&quot;); break;
 690     case MANAGEMENT:
 691       st-&gt;print(&quot;management&quot;); break;
 692     case ERGONOMIC:
 693       if (_flags &amp; ORIG_COMMAND_LINE) {
 694         st-&gt;print(&quot;command line, &quot;);
 695       }
 696       st-&gt;print(&quot;ergonomic&quot;); break;
 697     case ATTACH_ON_DEMAND:
 698       st-&gt;print(&quot;attach&quot;); break;
 699     case INTERNAL:
 700       st-&gt;print(&quot;internal&quot;); break;
<a name="21" id="anc21"></a>

 701   }
 702   st-&gt;print(&quot;}&quot;);
 703 }
 704 
 705 void JVMFlag::print_as_flag(outputStream* st) {
 706   if (is_bool()) {
 707     st-&gt;print(&quot;-XX:%s%s&quot;, get_bool() ? &quot;+&quot; : &quot;-&quot;, _name);
 708   } else if (is_int()) {
 709     st-&gt;print(&quot;-XX:%s=%d&quot;, _name, get_int());
 710   } else if (is_uint()) {
 711     st-&gt;print(&quot;-XX:%s=%u&quot;, _name, get_uint());
 712   } else if (is_intx()) {
 713     st-&gt;print(&quot;-XX:%s=&quot; INTX_FORMAT, _name, get_intx());
 714   } else if (is_uintx()) {
 715     st-&gt;print(&quot;-XX:%s=&quot; UINTX_FORMAT, _name, get_uintx());
 716   } else if (is_uint64_t()) {
 717     st-&gt;print(&quot;-XX:%s=&quot; UINT64_FORMAT, _name, get_uint64_t());
 718   } else if (is_size_t()) {
 719     st-&gt;print(&quot;-XX:%s=&quot; SIZE_FORMAT, _name, get_size_t());
 720   } else if (is_double()) {
 721     st-&gt;print(&quot;-XX:%s=%f&quot;, _name, get_double());
 722   } else if (is_ccstr()) {
 723     st-&gt;print(&quot;-XX:%s=&quot;, _name);
 724     const char* cp = get_ccstr();
 725     if (cp != NULL) {
 726       // Need to turn embedded &#39;\n&#39;s back into separate arguments
 727       // Not so efficient to print one character at a time,
 728       // but the choice is to do the transformation to a buffer
 729       // and print that.  And this need not be efficient.
 730       for (; *cp != &#39;\0&#39;; cp += 1) {
 731         switch (*cp) {
 732           default:
 733             st-&gt;print(&quot;%c&quot;, *cp);
 734             break;
 735           case &#39;\n&#39;:
 736             st-&gt;print(&quot; -XX:%s=&quot;, _name);
 737             break;
 738         }
 739       }
 740     }
 741   } else {
 742     ShouldNotReachHere();
 743   }
 744 }
 745 
 746 const char* JVMFlag::flag_error_str(JVMFlag::Error error) {
 747   switch (error) {
 748     case JVMFlag::MISSING_NAME: return &quot;MISSING_NAME&quot;;
 749     case JVMFlag::MISSING_VALUE: return &quot;MISSING_VALUE&quot;;
 750     case JVMFlag::NON_WRITABLE: return &quot;NON_WRITABLE&quot;;
 751     case JVMFlag::OUT_OF_BOUNDS: return &quot;OUT_OF_BOUNDS&quot;;
 752     case JVMFlag::VIOLATES_CONSTRAINT: return &quot;VIOLATES_CONSTRAINT&quot;;
 753     case JVMFlag::INVALID_FLAG: return &quot;INVALID_FLAG&quot;;
 754     case JVMFlag::ERR_OTHER: return &quot;ERR_OTHER&quot;;
 755     case JVMFlag::SUCCESS: return &quot;SUCCESS&quot;;
 756     default: ShouldNotReachHere(); return &quot;NULL&quot;;
 757   }
 758 }
 759 
 760 // 4991491 do not &quot;optimize out&quot; the was_set false values: omitting them
 761 // tickles a Microsoft compiler bug causing flagTable to be malformed
 762 
 763 #define RUNTIME_PRODUCT_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT) },
 764 #define RUNTIME_PD_PRODUCT_FLAG_STRUCT(  type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 765 #define RUNTIME_DIAGNOSTIC_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DIAGNOSTIC) },
 766 #define RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT(type, name,       doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 767 #define RUNTIME_EXPERIMENTAL_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_EXPERIMENTAL) },
 768 #define RUNTIME_MANAGEABLE_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_MANAGEABLE) },
 769 #define RUNTIME_PRODUCT_RW_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_READ_WRITE) },
 770 #define RUNTIME_DEVELOP_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DEVELOP) },
 771 #define RUNTIME_PD_DEVELOP_FLAG_STRUCT(  type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 772 #define RUNTIME_NOTPRODUCT_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_NOT_PRODUCT) },
 773 
 774 #define JVMCI_PRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_PRODUCT) },
 775 #define JVMCI_PD_PRODUCT_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 776 #define JVMCI_DIAGNOSTIC_FLAG_STRUCT(    type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DIAGNOSTIC) },
 777 #define JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT( type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 778 #define JVMCI_EXPERIMENTAL_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_EXPERIMENTAL) },
 779 #define JVMCI_DEVELOP_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DEVELOP) },
 780 #define JVMCI_PD_DEVELOP_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 781 #define JVMCI_NOTPRODUCT_FLAG_STRUCT(    type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_NOT_PRODUCT) },
 782 
 783 #ifdef _LP64
 784 #define RUNTIME_LP64_PRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_LP64_PRODUCT) },
 785 #else
 786 #define RUNTIME_LP64_PRODUCT_FLAG_STRUCT(type, name, value, doc) /* flag is constant */
 787 #endif // _LP64
 788 
 789 #define C1_PRODUCT_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_PRODUCT) },
 790 #define C1_PD_PRODUCT_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 791 #define C1_DIAGNOSTIC_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DIAGNOSTIC) },
 792 #define C1_PD_DIAGNOSTIC_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 793 #define C1_DEVELOP_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DEVELOP) },
 794 #define C1_PD_DEVELOP_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 795 #define C1_NOTPRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_NOT_PRODUCT) },
 796 
 797 #define C2_PRODUCT_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_PRODUCT) },
 798 #define C2_PD_PRODUCT_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 799 #define C2_DIAGNOSTIC_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DIAGNOSTIC) },
 800 #define C2_PD_DIAGNOSTIC_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 801 #define C2_EXPERIMENTAL_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_EXPERIMENTAL) },
 802 #define C2_DEVELOP_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DEVELOP) },
 803 #define C2_PD_DEVELOP_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 804 #define C2_NOTPRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_NOT_PRODUCT) },
 805 
 806 #define ARCH_PRODUCT_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_PRODUCT) },
 807 #define ARCH_DIAGNOSTIC_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DIAGNOSTIC) },
 808 #define ARCH_EXPERIMENTAL_FLAG_STRUCT(   type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_EXPERIMENTAL) },
 809 #define ARCH_DEVELOP_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DEVELOP) },
 810 #define ARCH_NOTPRODUCT_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_NOT_PRODUCT) },
 811 
 812 static JVMFlag flagTable[] = {
 813   VM_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
 814            RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
 815            RUNTIME_PRODUCT_FLAG_STRUCT, \
 816            RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
 817            RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
 818            RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
 819            RUNTIME_EXPERIMENTAL_FLAG_STRUCT, \
 820            RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
 821            RUNTIME_MANAGEABLE_FLAG_STRUCT, \
 822            RUNTIME_PRODUCT_RW_FLAG_STRUCT, \
 823            RUNTIME_LP64_PRODUCT_FLAG_STRUCT, \
 824            IGNORE_RANGE, \
<a name="22" id="anc22"></a><span class="line-modified"> 825            IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 826            IGNORE_WRITEABLE)</span>
 827 
 828   RUNTIME_OS_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
 829                    RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
 830                    RUNTIME_PRODUCT_FLAG_STRUCT, \
 831                    RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
 832                    RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
 833                    RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
 834                    RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
 835                    IGNORE_RANGE, \
<a name="23" id="anc23"></a><span class="line-modified"> 836                    IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 837                    IGNORE_WRITEABLE)</span>
 838 #if INCLUDE_JVMCI
 839   JVMCI_FLAGS(JVMCI_DEVELOP_FLAG_STRUCT, \
 840               JVMCI_PD_DEVELOP_FLAG_STRUCT, \
 841               JVMCI_PRODUCT_FLAG_STRUCT, \
 842               JVMCI_PD_PRODUCT_FLAG_STRUCT, \
 843               JVMCI_DIAGNOSTIC_FLAG_STRUCT, \
 844               JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT, \
 845               JVMCI_EXPERIMENTAL_FLAG_STRUCT, \
 846               JVMCI_NOTPRODUCT_FLAG_STRUCT, \
 847               IGNORE_RANGE, \
<a name="24" id="anc24"></a><span class="line-modified"> 848               IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 849               IGNORE_WRITEABLE)</span>
 850 #endif // INCLUDE_JVMCI
 851 #ifdef COMPILER1
 852   C1_FLAGS(C1_DEVELOP_FLAG_STRUCT, \
 853            C1_PD_DEVELOP_FLAG_STRUCT, \
 854            C1_PRODUCT_FLAG_STRUCT, \
 855            C1_PD_PRODUCT_FLAG_STRUCT, \
 856            C1_DIAGNOSTIC_FLAG_STRUCT, \
 857            C1_PD_DIAGNOSTIC_FLAG_STRUCT, \
 858            C1_NOTPRODUCT_FLAG_STRUCT, \
 859            IGNORE_RANGE, \
<a name="25" id="anc25"></a><span class="line-modified"> 860            IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 861            IGNORE_WRITEABLE)</span>
 862 #endif // COMPILER1
 863 #ifdef COMPILER2
 864   C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, \
 865            C2_PD_DEVELOP_FLAG_STRUCT, \
 866            C2_PRODUCT_FLAG_STRUCT, \
 867            C2_PD_PRODUCT_FLAG_STRUCT, \
 868            C2_DIAGNOSTIC_FLAG_STRUCT, \
 869            C2_PD_DIAGNOSTIC_FLAG_STRUCT, \
 870            C2_EXPERIMENTAL_FLAG_STRUCT, \
 871            C2_NOTPRODUCT_FLAG_STRUCT, \
 872            IGNORE_RANGE, \
<a name="26" id="anc26"></a><span class="line-modified"> 873            IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 874            IGNORE_WRITEABLE)</span>
 875 #endif // COMPILER2
 876   ARCH_FLAGS(ARCH_DEVELOP_FLAG_STRUCT, \
 877              ARCH_PRODUCT_FLAG_STRUCT, \
 878              ARCH_DIAGNOSTIC_FLAG_STRUCT, \
 879              ARCH_EXPERIMENTAL_FLAG_STRUCT, \
 880              ARCH_NOTPRODUCT_FLAG_STRUCT, \
 881              IGNORE_RANGE, \
<a name="27" id="anc27"></a><span class="line-modified"> 882              IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 883              IGNORE_WRITEABLE)</span>
<span class="line-removed"> 884   FLAGTABLE_EXT</span>
 885   {0, NULL, NULL}
 886 };
 887 
 888 JVMFlag* JVMFlag::flags = flagTable;
 889 size_t JVMFlag::numFlags = (sizeof(flagTable) / sizeof(JVMFlag));
 890 
 891 inline bool str_equal(const char* s, size_t s_len, const char* q, size_t q_len) {
 892   if (s_len != q_len) return false;
 893   return memcmp(s, q, q_len) == 0;
 894 }
 895 
 896 // Search the flag table for a named flag
 897 JVMFlag* JVMFlag::find_flag(const char* name, size_t length, bool allow_locked, bool return_flag) {
 898   for (JVMFlag* current = &amp;flagTable[0]; current-&gt;_name != NULL; current++) {
 899     if (str_equal(current-&gt;_name, current-&gt;get_name_length(), name, length)) {
 900       // Found a matching entry.
 901       // Don&#39;t report notproduct and develop flags in product builds.
 902       if (current-&gt;is_constant_in_binary()) {
 903         return (return_flag ? current : NULL);
 904       }
 905       // Report locked flags only if allowed.
 906       if (!(current-&gt;is_unlocked() || current-&gt;is_unlocker())) {
 907         if (!allow_locked) {
 908           // disable use of locked flags, e.g. diagnostic, experimental,
 909           // etc. until they are explicitly unlocked
 910           return NULL;
 911         }
 912       }
 913       return current;
 914     }
 915   }
 916   // JVMFlag name is not in the flag table
 917   return NULL;
 918 }
 919 
 920 // Get or compute the flag name length
 921 size_t JVMFlag::get_name_length() {
 922   if (_name_len == 0) {
 923     _name_len = strlen(_name);
 924   }
 925   return _name_len;
 926 }
 927 
 928 JVMFlag* JVMFlag::fuzzy_match(const char* name, size_t length, bool allow_locked) {
 929   float VMOptionsFuzzyMatchSimilarity = 0.7f;
 930   JVMFlag* match = NULL;
 931   float score;
 932   float max_score = -1;
 933 
 934   for (JVMFlag* current = &amp;flagTable[0]; current-&gt;_name != NULL; current++) {
 935     score = StringUtils::similarity(current-&gt;_name, strlen(current-&gt;_name), name, length);
 936     if (score &gt; max_score) {
 937       max_score = score;
 938       match = current;
 939     }
 940   }
 941 
 942   if (match == NULL) {
 943     return NULL;
 944   }
 945 
 946   if (!(match-&gt;is_unlocked() || match-&gt;is_unlocker())) {
 947     if (!allow_locked) {
 948       return NULL;
 949     }
 950   }
 951 
 952   if (max_score &lt; VMOptionsFuzzyMatchSimilarity) {
 953     return NULL;
 954   }
 955 
 956   return match;
 957 }
 958 
 959 // Returns the address of the index&#39;th element
<a name="28" id="anc28"></a><span class="line-modified"> 960 static JVMFlag* address_of_flag(JVMFlagsWithType flag) {</span>
 961   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);
 962   return &amp;JVMFlag::flags[flag];
 963 }
 964 
<a name="29" id="anc29"></a><span class="line-modified"> 965 bool JVMFlagEx::is_default(JVMFlags flag) {</span>
<span class="line-modified"> 966   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-removed"> 967   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-removed"> 968   return f-&gt;is_default();</span>
<span class="line-removed"> 969 }</span>
<span class="line-removed"> 970 </span>
<span class="line-removed"> 971 bool JVMFlagEx::is_ergo(JVMFlags flag) {</span>
<span class="line-removed"> 972   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-removed"> 973   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-removed"> 974   return f-&gt;is_ergonomic();</span>
 975 }
 976 
<a name="30" id="anc30"></a><span class="line-modified"> 977 bool JVMFlagEx::is_cmdline(JVMFlags flag) {</span>
<span class="line-modified"> 978   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-removed"> 979   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-removed"> 980   return f-&gt;is_command_line();</span>
 981 }
 982 
<a name="31" id="anc31"></a><span class="line-modified"> 983 bool JVMFlag::wasSetOnCmdline(const char* name, bool* value) {</span>
<span class="line-modified"> 984   JVMFlag* result = JVMFlag::find_flag((char*)name, strlen(name));</span>
<span class="line-removed"> 985   if (result == NULL) return false;</span>
<span class="line-removed"> 986   *value = result-&gt;is_command_line();</span>
<span class="line-removed"> 987   return true;</span>
 988 }
 989 
<a name="32" id="anc32"></a><span class="line-modified"> 990 void JVMFlagEx::setOnCmdLine(JVMFlagsWithType flag) {</span>
<span class="line-modified"> 991   JVMFlag* faddr = address_of_flag(flag);</span>
 992   assert(faddr != NULL, &quot;Unknown flag&quot;);
 993   faddr-&gt;set_command_line();
 994 }
 995 
 996 template&lt;class E, class T&gt;
<a name="33" id="anc33"></a><span class="line-modified"> 997 static void trace_flag_changed(const char* name, const T old_value, const T new_value, const JVMFlag::Flags origin) {</span>
 998   E e;
<a name="34" id="anc34"></a><span class="line-modified"> 999   e.set_name(name);</span>
1000   e.set_oldValue(old_value);
1001   e.set_newValue(new_value);
1002   e.set_origin(origin);
1003   e.commit();
1004 }
1005 
<a name="35" id="anc35"></a><span class="line-modified">1006 static JVMFlag::Error apply_constraint_and_check_range_bool(const char* name, bool new_value, bool verbose) {</span>
1007   JVMFlag::Error status = JVMFlag::SUCCESS;
<a name="36" id="anc36"></a><span class="line-modified">1008   JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1009   if (constraint != NULL) {
1010     status = constraint-&gt;apply_bool(new_value, verbose);
1011   }
1012   return status;
1013 }
1014 
<a name="37" id="anc37"></a><span class="line-modified">1015 JVMFlag::Error JVMFlag::boolAt(const char* name, size_t len, bool* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1016   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1017   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1018   if (!result-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1019   *value = result-&gt;get_bool();</span>
1020   return JVMFlag::SUCCESS;
1021 }
1022 
1023 JVMFlag::Error JVMFlag::boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin) {
<a name="38" id="anc38"></a><span class="line-removed">1024   const char* name;</span>
1025   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1026   if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;
<a name="39" id="anc39"></a><span class="line-modified">1027   name = flag-&gt;_name;</span>
<span class="line-removed">1028   JVMFlag::Error check = apply_constraint_and_check_range_bool(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1029   if (check != JVMFlag::SUCCESS) return check;
1030   bool old_value = flag-&gt;get_bool();
<a name="40" id="anc40"></a><span class="line-modified">1031   trace_flag_changed&lt;EventBooleanFlagChanged, bool&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1032   check = flag-&gt;set_bool(*value);</span>
1033   *value = old_value;
1034   flag-&gt;set_origin(origin);
<a name="41" id="anc41"></a><span class="line-modified">1035   return check;</span>
<span class="line-removed">1036 }</span>
<span class="line-removed">1037 </span>
<span class="line-removed">1038 JVMFlag::Error JVMFlag::boolAtPut(const char* name, size_t len, bool* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1039   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1040   return boolAtPut(result, value, origin);</span>
1041 }
1042 
<a name="42" id="anc42"></a><span class="line-modified">1043 JVMFlag::Error JVMFlagEx::boolAtPut(JVMFlagsWithType flag, bool value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1044   JVMFlag* faddr = address_of_flag(flag);</span>
1045   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_bool(), &quot;wrong flag type&quot;);
1046   return JVMFlag::boolAtPut(faddr, &amp;value, origin);
1047 }
1048 
<a name="43" id="anc43"></a><span class="line-modified">1049 static JVMFlag::Error apply_constraint_and_check_range_int(const char* name, int new_value, bool verbose) {</span>
1050   JVMFlag::Error status = JVMFlag::SUCCESS;
<a name="44" id="anc44"></a><span class="line-modified">1051   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1052   if (range != NULL) {
1053     status = range-&gt;check_int(new_value, verbose);
1054   }
1055   if (status == JVMFlag::SUCCESS) {
<a name="45" id="anc45"></a><span class="line-modified">1056     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1057     if (constraint != NULL) {
1058       status = constraint-&gt;apply_int(new_value, verbose);
1059     }
1060   }
1061   return status;
1062 }
1063 
<a name="46" id="anc46"></a><span class="line-modified">1064 JVMFlag::Error JVMFlag::intAt(const char* name, size_t len, int* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1065   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1066   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1067   if (!result-&gt;is_int()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1068   *value = result-&gt;get_int();</span>
1069   return JVMFlag::SUCCESS;
1070 }
1071 
1072 JVMFlag::Error JVMFlag::intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin) {
<a name="47" id="anc47"></a><span class="line-removed">1073   const char* name;</span>
1074   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1075   if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;
<a name="48" id="anc48"></a><span class="line-modified">1076   name = flag-&gt;_name;</span>
<span class="line-removed">1077   JVMFlag::Error check = apply_constraint_and_check_range_int(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1078   if (check != JVMFlag::SUCCESS) return check;
1079   int old_value = flag-&gt;get_int();
<a name="49" id="anc49"></a><span class="line-modified">1080   trace_flag_changed&lt;EventIntFlagChanged, s4&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1081   check = flag-&gt;set_int(*value);</span>
1082   *value = old_value;
1083   flag-&gt;set_origin(origin);
<a name="50" id="anc50"></a><span class="line-modified">1084   return check;</span>
<span class="line-removed">1085 }</span>
<span class="line-removed">1086 </span>
<span class="line-removed">1087 JVMFlag::Error JVMFlag::intAtPut(const char* name, size_t len, int* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1088   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1089   return intAtPut(result, value, origin);</span>
1090 }
1091 
<a name="51" id="anc51"></a><span class="line-modified">1092 JVMFlag::Error JVMFlagEx::intAtPut(JVMFlagsWithType flag, int value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1093   JVMFlag* faddr = address_of_flag(flag);</span>
1094   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_int(), &quot;wrong flag type&quot;);
1095   return JVMFlag::intAtPut(faddr, &amp;value, origin);
1096 }
1097 
<a name="52" id="anc52"></a><span class="line-modified">1098 static JVMFlag::Error apply_constraint_and_check_range_uint(const char* name, uint new_value, bool verbose) {</span>
1099   JVMFlag::Error status = JVMFlag::SUCCESS;
<a name="53" id="anc53"></a><span class="line-modified">1100   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1101   if (range != NULL) {
1102     status = range-&gt;check_uint(new_value, verbose);
1103   }
1104   if (status == JVMFlag::SUCCESS) {
<a name="54" id="anc54"></a><span class="line-modified">1105     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1106     if (constraint != NULL) {
1107       status = constraint-&gt;apply_uint(new_value, verbose);
1108     }
1109   }
1110   return status;
1111 }
1112 
<a name="55" id="anc55"></a><span class="line-modified">1113 JVMFlag::Error JVMFlag::uintAt(const char* name, size_t len, uint* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1114   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1115   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1116   if (!result-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1117   *value = result-&gt;get_uint();</span>
1118   return JVMFlag::SUCCESS;
1119 }
1120 
1121 JVMFlag::Error JVMFlag::uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin) {
<a name="56" id="anc56"></a><span class="line-removed">1122   const char* name;</span>
1123   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1124   if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;
<a name="57" id="anc57"></a><span class="line-modified">1125   name = flag-&gt;_name;</span>
<span class="line-removed">1126   JVMFlag::Error check = apply_constraint_and_check_range_uint(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1127   if (check != JVMFlag::SUCCESS) return check;
1128   uint old_value = flag-&gt;get_uint();
<a name="58" id="anc58"></a><span class="line-modified">1129   trace_flag_changed&lt;EventUnsignedIntFlagChanged, u4&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1130   check = flag-&gt;set_uint(*value);</span>
1131   *value = old_value;
1132   flag-&gt;set_origin(origin);
<a name="59" id="anc59"></a><span class="line-modified">1133   return check;</span>
<span class="line-removed">1134 }</span>
<span class="line-removed">1135 </span>
<span class="line-removed">1136 JVMFlag::Error JVMFlag::uintAtPut(const char* name, size_t len, uint* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1137   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1138   return uintAtPut(result, value, origin);</span>
1139 }
1140 
<a name="60" id="anc60"></a><span class="line-modified">1141 JVMFlag::Error JVMFlagEx::uintAtPut(JVMFlagsWithType flag, uint value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1142   JVMFlag* faddr = address_of_flag(flag);</span>
1143   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint(), &quot;wrong flag type&quot;);
1144   return JVMFlag::uintAtPut(faddr, &amp;value, origin);
1145 }
1146 
<a name="61" id="anc61"></a><span class="line-modified">1147 JVMFlag::Error JVMFlag::intxAt(const char* name, size_t len, intx* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1148   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1149   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1150   if (!result-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1151   *value = result-&gt;get_intx();</span>
1152   return JVMFlag::SUCCESS;
1153 }
1154 
<a name="62" id="anc62"></a><span class="line-modified">1155 static JVMFlag::Error apply_constraint_and_check_range_intx(const char* name, intx new_value, bool verbose) {</span>
1156   JVMFlag::Error status = JVMFlag::SUCCESS;
<a name="63" id="anc63"></a><span class="line-modified">1157   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1158   if (range != NULL) {
1159     status = range-&gt;check_intx(new_value, verbose);
1160   }
1161   if (status == JVMFlag::SUCCESS) {
<a name="64" id="anc64"></a><span class="line-modified">1162     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1163     if (constraint != NULL) {
1164       status = constraint-&gt;apply_intx(new_value, verbose);
1165     }
1166   }
1167   return status;
1168 }
1169 
1170 JVMFlag::Error JVMFlag::intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin) {
<a name="65" id="anc65"></a><span class="line-removed">1171   const char* name;</span>
1172   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1173   if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;
<a name="66" id="anc66"></a><span class="line-modified">1174   name = flag-&gt;_name;</span>
<span class="line-removed">1175   JVMFlag::Error check = apply_constraint_and_check_range_intx(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1176   if (check != JVMFlag::SUCCESS) return check;
1177   intx old_value = flag-&gt;get_intx();
<a name="67" id="anc67"></a><span class="line-modified">1178   trace_flag_changed&lt;EventLongFlagChanged, intx&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1179   check = flag-&gt;set_intx(*value);</span>
1180   *value = old_value;
1181   flag-&gt;set_origin(origin);
<a name="68" id="anc68"></a><span class="line-modified">1182   return check;</span>
<span class="line-removed">1183 }</span>
<span class="line-removed">1184 </span>
<span class="line-removed">1185 JVMFlag::Error JVMFlag::intxAtPut(const char* name, size_t len, intx* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1186   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1187   return intxAtPut(result, value, origin);</span>
1188 }
1189 
<a name="69" id="anc69"></a><span class="line-modified">1190 JVMFlag::Error JVMFlagEx::intxAtPut(JVMFlagsWithType flag, intx value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1191   JVMFlag* faddr = address_of_flag(flag);</span>
1192   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_intx(), &quot;wrong flag type&quot;);
1193   return JVMFlag::intxAtPut(faddr, &amp;value, origin);
1194 }
1195 
<a name="70" id="anc70"></a><span class="line-modified">1196 JVMFlag::Error JVMFlag::uintxAt(const char* name, size_t len, uintx* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1197   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1198   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1199   if (!result-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1200   *value = result-&gt;get_uintx();</span>
1201   return JVMFlag::SUCCESS;
1202 }
1203 
<a name="71" id="anc71"></a><span class="line-modified">1204 static JVMFlag::Error apply_constraint_and_check_range_uintx(const char* name, uintx new_value, bool verbose) {</span>
1205   JVMFlag::Error status = JVMFlag::SUCCESS;
<a name="72" id="anc72"></a><span class="line-modified">1206   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1207   if (range != NULL) {
1208     status = range-&gt;check_uintx(new_value, verbose);
1209   }
1210   if (status == JVMFlag::SUCCESS) {
<a name="73" id="anc73"></a><span class="line-modified">1211     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1212     if (constraint != NULL) {
1213       status = constraint-&gt;apply_uintx(new_value, verbose);
1214     }
1215   }
1216   return status;
1217 }
1218 
1219 JVMFlag::Error JVMFlag::uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin) {
<a name="74" id="anc74"></a><span class="line-removed">1220   const char* name;</span>
1221   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1222   if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;
<a name="75" id="anc75"></a><span class="line-modified">1223   name = flag-&gt;_name;</span>
<span class="line-removed">1224   JVMFlag::Error check = apply_constraint_and_check_range_uintx(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1225   if (check != JVMFlag::SUCCESS) return check;
1226   uintx old_value = flag-&gt;get_uintx();
<a name="76" id="anc76"></a><span class="line-modified">1227   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1228   check = flag-&gt;set_uintx(*value);</span>
1229   *value = old_value;
1230   flag-&gt;set_origin(origin);
<a name="77" id="anc77"></a><span class="line-modified">1231   return check;</span>
<span class="line-removed">1232 }</span>
<span class="line-removed">1233 </span>
<span class="line-removed">1234 JVMFlag::Error JVMFlag::uintxAtPut(const char* name, size_t len, uintx* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1235   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1236   return uintxAtPut(result, value, origin);</span>
1237 }
1238 
<a name="78" id="anc78"></a><span class="line-modified">1239 JVMFlag::Error JVMFlagEx::uintxAtPut(JVMFlagsWithType flag, uintx value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1240   JVMFlag* faddr = address_of_flag(flag);</span>
1241   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uintx(), &quot;wrong flag type&quot;);
1242   return JVMFlag::uintxAtPut(faddr, &amp;value, origin);
1243 }
1244 
<a name="79" id="anc79"></a><span class="line-modified">1245 JVMFlag::Error JVMFlag::uint64_tAt(const char* name, size_t len, uint64_t* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1246   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1247   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1248   if (!result-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1249   *value = result-&gt;get_uint64_t();</span>
1250   return JVMFlag::SUCCESS;
1251 }
1252 
<a name="80" id="anc80"></a><span class="line-modified">1253 static JVMFlag::Error apply_constraint_and_check_range_uint64_t(const char* name, uint64_t new_value, bool verbose) {</span>
1254   JVMFlag::Error status = JVMFlag::SUCCESS;
<a name="81" id="anc81"></a><span class="line-modified">1255   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1256   if (range != NULL) {
1257     status = range-&gt;check_uint64_t(new_value, verbose);
1258   }
1259   if (status == JVMFlag::SUCCESS) {
<a name="82" id="anc82"></a><span class="line-modified">1260     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1261     if (constraint != NULL) {
1262       status = constraint-&gt;apply_uint64_t(new_value, verbose);
1263     }
1264   }
1265   return status;
1266 }
1267 
1268 JVMFlag::Error JVMFlag::uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin) {
<a name="83" id="anc83"></a><span class="line-removed">1269   const char* name;</span>
1270   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1271   if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;
<a name="84" id="anc84"></a><span class="line-modified">1272   name = flag-&gt;_name;</span>
<span class="line-removed">1273   JVMFlag::Error check = apply_constraint_and_check_range_uint64_t(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1274   if (check != JVMFlag::SUCCESS) return check;
1275   uint64_t old_value = flag-&gt;get_uint64_t();
<a name="85" id="anc85"></a><span class="line-modified">1276   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1277   check = flag-&gt;set_uint64_t(*value);</span>
1278   *value = old_value;
1279   flag-&gt;set_origin(origin);
<a name="86" id="anc86"></a><span class="line-modified">1280   return check;</span>
<span class="line-removed">1281 }</span>
<span class="line-removed">1282 </span>
<span class="line-removed">1283 JVMFlag::Error JVMFlag::uint64_tAtPut(const char* name, size_t len, uint64_t* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1284   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1285   return uint64_tAtPut(result, value, origin);</span>
1286 }
1287 
<a name="87" id="anc87"></a><span class="line-modified">1288 JVMFlag::Error JVMFlagEx::uint64_tAtPut(JVMFlagsWithType flag, uint64_t value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1289   JVMFlag* faddr = address_of_flag(flag);</span>
1290   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint64_t(), &quot;wrong flag type&quot;);
1291   return JVMFlag::uint64_tAtPut(faddr, &amp;value, origin);
1292 }
1293 
<a name="88" id="anc88"></a><span class="line-modified">1294 JVMFlag::Error JVMFlag::size_tAt(const char* name, size_t len, size_t* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1295   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1296   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1297   if (!result-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1298   *value = result-&gt;get_size_t();</span>
1299   return JVMFlag::SUCCESS;
1300 }
1301 
<a name="89" id="anc89"></a><span class="line-modified">1302 static JVMFlag::Error apply_constraint_and_check_range_size_t(const char* name, size_t new_value, bool verbose) {</span>
1303   JVMFlag::Error status = JVMFlag::SUCCESS;
<a name="90" id="anc90"></a><span class="line-modified">1304   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1305   if (range != NULL) {
1306     status = range-&gt;check_size_t(new_value, verbose);
1307   }
1308   if (status == JVMFlag::SUCCESS) {
<a name="91" id="anc91"></a><span class="line-modified">1309     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1310     if (constraint != NULL) {
1311       status = constraint-&gt;apply_size_t(new_value, verbose);
1312     }
1313   }
1314   return status;
1315 }
1316 
1317 
1318 JVMFlag::Error JVMFlag::size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin) {
<a name="92" id="anc92"></a><span class="line-removed">1319   const char* name;</span>
1320   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1321   if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;
<a name="93" id="anc93"></a><span class="line-modified">1322   name = flag-&gt;_name;</span>
<span class="line-removed">1323   JVMFlag::Error check = apply_constraint_and_check_range_size_t(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1324   if (check != JVMFlag::SUCCESS) return check;
1325   size_t old_value = flag-&gt;get_size_t();
<a name="94" id="anc94"></a><span class="line-modified">1326   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1327   check = flag-&gt;set_size_t(*value);</span>
1328   *value = old_value;
1329   flag-&gt;set_origin(origin);
<a name="95" id="anc95"></a><span class="line-modified">1330   return check;</span>
<span class="line-removed">1331 }</span>
<span class="line-removed">1332 </span>
<span class="line-removed">1333 JVMFlag::Error JVMFlag::size_tAtPut(const char* name, size_t len, size_t* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1334   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1335   return size_tAtPut(result, value, origin);</span>
1336 }
1337 
<a name="96" id="anc96"></a><span class="line-modified">1338 JVMFlag::Error JVMFlagEx::size_tAtPut(JVMFlagsWithType flag, size_t value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1339   JVMFlag* faddr = address_of_flag(flag);</span>
1340   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_size_t(), &quot;wrong flag type&quot;);
1341   return JVMFlag::size_tAtPut(faddr, &amp;value, origin);
1342 }
1343 
<a name="97" id="anc97"></a><span class="line-modified">1344 JVMFlag::Error JVMFlag::doubleAt(const char* name, size_t len, double* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1345   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1346   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1347   if (!result-&gt;is_double()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1348   *value = result-&gt;get_double();</span>
1349   return JVMFlag::SUCCESS;
1350 }
1351 
<a name="98" id="anc98"></a><span class="line-modified">1352 static JVMFlag::Error apply_constraint_and_check_range_double(const char* name, double new_value, bool verbose) {</span>
1353   JVMFlag::Error status = JVMFlag::SUCCESS;
<a name="99" id="anc99"></a><span class="line-modified">1354   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1355   if (range != NULL) {
1356     status = range-&gt;check_double(new_value, verbose);
1357   }
1358   if (status == JVMFlag::SUCCESS) {
<a name="100" id="anc100"></a><span class="line-modified">1359     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1360     if (constraint != NULL) {
1361       status = constraint-&gt;apply_double(new_value, verbose);
1362     }
1363   }
1364   return status;
1365 }
1366 
1367 JVMFlag::Error JVMFlag::doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin) {
<a name="101" id="anc101"></a><span class="line-removed">1368   const char* name;</span>
1369   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1370   if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;
<a name="102" id="anc102"></a><span class="line-modified">1371   name = flag-&gt;_name;</span>
<span class="line-removed">1372   JVMFlag::Error check = apply_constraint_and_check_range_double(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1373   if (check != JVMFlag::SUCCESS) return check;
1374   double old_value = flag-&gt;get_double();
<a name="103" id="anc103"></a><span class="line-modified">1375   trace_flag_changed&lt;EventDoubleFlagChanged, double&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1376   check = flag-&gt;set_double(*value);</span>
1377   *value = old_value;
1378   flag-&gt;set_origin(origin);
<a name="104" id="anc104"></a><span class="line-modified">1379   return check;</span>
<span class="line-removed">1380 }</span>
<span class="line-removed">1381 </span>
<span class="line-removed">1382 JVMFlag::Error JVMFlag::doubleAtPut(const char* name, size_t len, double* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1383   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1384   return doubleAtPut(result, value, origin);</span>
1385 }
1386 
<a name="105" id="anc105"></a><span class="line-modified">1387 JVMFlag::Error JVMFlagEx::doubleAtPut(JVMFlagsWithType flag, double value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1388   JVMFlag* faddr = address_of_flag(flag);</span>
1389   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_double(), &quot;wrong flag type&quot;);
1390   return JVMFlag::doubleAtPut(faddr, &amp;value, origin);
1391 }
1392 
<a name="106" id="anc106"></a><span class="line-modified">1393 JVMFlag::Error JVMFlag::ccstrAt(const char* name, size_t len, ccstr* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1394   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1395   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1396   if (!result-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1397   *value = result-&gt;get_ccstr();</span>
1398   return JVMFlag::SUCCESS;
1399 }
1400 
<a name="107" id="anc107"></a><span class="line-modified">1401 JVMFlag::Error JVMFlag::ccstrAtPut(const char* name, size_t len, ccstr* value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1402   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-modified">1403   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1404   if (!result-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">1405   ccstr old_value = result-&gt;get_ccstr();</span>
<span class="line-removed">1406   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(name, old_value, *value, origin);</span>
1407   char* new_value = NULL;
1408   if (*value != NULL) {
1409     new_value = os::strdup_check_oom(*value);
1410   }
<a name="108" id="anc108"></a><span class="line-modified">1411   JVMFlag::Error check = result-&gt;set_ccstr(new_value);</span>
<span class="line-modified">1412   if (result-&gt;is_default() &amp;&amp; old_value != NULL) {</span>
1413     // Prior value is NOT heap allocated, but was a literal constant.
1414     old_value = os::strdup_check_oom(old_value);
1415   }
1416   *value = old_value;
<a name="109" id="anc109"></a><span class="line-modified">1417   result-&gt;set_origin(origin);</span>
<span class="line-modified">1418   return check;</span>
1419 }
1420 
<a name="110" id="anc110"></a><span class="line-modified">1421 JVMFlag::Error JVMFlagEx::ccstrAtPut(JVMFlagsWithType flag, ccstr value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1422   JVMFlag* faddr = address_of_flag(flag);</span>
1423   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_ccstr(), &quot;wrong flag type&quot;);
1424   ccstr old_value = faddr-&gt;get_ccstr();
<a name="111" id="anc111"></a><span class="line-modified">1425   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(faddr-&gt;_name, old_value, value, origin);</span>
1426   char* new_value = os::strdup_check_oom(value);
<a name="112" id="anc112"></a><span class="line-modified">1427   JVMFlag::Error check = faddr-&gt;set_ccstr(new_value);</span>
1428   if (!faddr-&gt;is_default() &amp;&amp; old_value != NULL) {
1429     // Prior value is heap allocated so free it.
1430     FREE_C_HEAP_ARRAY(char, old_value);
1431   }
1432   faddr-&gt;set_origin(origin);
<a name="113" id="anc113"></a><span class="line-modified">1433   return check;</span>
1434 }
1435 
1436 extern &quot;C&quot; {
1437   static int compare_flags(const void* void_a, const void* void_b) {
1438     return strcmp((*((JVMFlag**) void_a))-&gt;_name, (*((JVMFlag**) void_b))-&gt;_name);
1439   }
1440 }
1441 
1442 void JVMFlag::printSetFlags(outputStream* out) {
1443   // Print which flags were set on the command line
1444   // note: this method is called before the thread structure is in place
1445   //       which means resource allocation cannot be used.
1446 
1447   // The last entry is the null entry.
1448   const size_t length = JVMFlag::numFlags - 1;
1449 
1450   // Sort
1451   JVMFlag** array = NEW_C_HEAP_ARRAY(JVMFlag*, length, mtArguments);
1452   for (size_t i = 0; i &lt; length; i++) {
1453     array[i] = &amp;flagTable[i];
1454   }
1455   qsort(array, length, sizeof(JVMFlag*), compare_flags);
1456 
1457   // Print
1458   for (size_t i = 0; i &lt; length; i++) {
1459     if (array[i]-&gt;get_origin() /* naked field! */) {
1460       array[i]-&gt;print_as_flag(out);
1461       out-&gt;print(&quot; &quot;);
1462     }
1463   }
1464   out-&gt;cr();
1465   FREE_C_HEAP_ARRAY(JVMFlag*, array);
1466 }
1467 
1468 #ifndef PRODUCT
1469 
1470 void JVMFlag::verify() {
1471   assert(Arguments::check_vm_args_consistency(), &quot;Some flag settings conflict&quot;);
1472 }
1473 
1474 #endif // PRODUCT
1475 
1476 void JVMFlag::printFlags(outputStream* out, bool withComments, bool printRanges, bool skipDefaults) {
1477   // Print the flags sorted by name
<a name="114" id="anc114"></a><span class="line-modified">1478   // note: this method is called before the thread structure is in place</span>
<span class="line-modified">1479   //       which means resource allocation cannot be used.</span>

1480 
1481   // The last entry is the null entry.
1482   const size_t length = JVMFlag::numFlags - 1;
1483 
<a name="115" id="anc115"></a><span class="line-removed">1484   // Sort</span>
<span class="line-removed">1485   JVMFlag** array = NEW_C_HEAP_ARRAY(JVMFlag*, length, mtArguments);</span>
<span class="line-removed">1486   for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-removed">1487     array[i] = &amp;flagTable[i];</span>
<span class="line-removed">1488   }</span>
<span class="line-removed">1489   qsort(array, length, sizeof(JVMFlag*), compare_flags);</span>
<span class="line-removed">1490 </span>
1491   // Print
1492   if (!printRanges) {
1493     out-&gt;print_cr(&quot;[Global flags]&quot;);
1494   } else {
1495     out-&gt;print_cr(&quot;[Global flags ranges]&quot;);
1496   }
1497 
<a name="116" id="anc116"></a><span class="line-modified">1498   for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-modified">1499     if (array[i]-&gt;is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; array[i]-&gt;is_default())) {</span>
<span class="line-modified">1500       array[i]-&gt;print_on(out, withComments, printRanges);</span>

















1501     }
1502   }
<a name="117" id="anc117"></a><span class="line-removed">1503   FREE_C_HEAP_ARRAY(JVMFlag*, array);</span>
1504 }
1505 
1506 void JVMFlag::printError(bool verbose, const char* msg, ...) {
1507   if (verbose) {
1508     va_list listPointer;
1509     va_start(listPointer, msg);
1510     jio_vfprintf(defaultStream::error_stream(), msg, listPointer);
1511     va_end(listPointer);
1512   }
1513 }
<a name="118" id="anc118"></a><span class="line-removed">1514 </span>
<a name="119" id="anc119"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="119" type="hidden" />
</body>
</html>
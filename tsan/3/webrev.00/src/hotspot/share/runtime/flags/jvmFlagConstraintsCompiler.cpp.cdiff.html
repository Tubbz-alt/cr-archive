<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/flags/jvmFlagConstraintsCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jvmFlagConstraintList.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintsRuntime.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/flags/jvmFlagConstraintsCompiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,10 ***</span>
<span class="line-new-header">--- 31,11 ---</span>
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/flags/jvmFlag.hpp&quot;
  #include &quot;runtime/flags/jvmFlagConstraintsCompiler.hpp&quot;
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  JVMFlag::Error AliasLevelConstraintFunc(intx value, bool verbose) {
    if ((value &lt;= 1) &amp;&amp; (Arguments::mode() == Arguments::_comp || Arguments::mode() == Arguments::_mixed)) {
      JVMFlag::printError(verbose,
                          &quot;AliasLevel (&quot; INTX_FORMAT &quot;) is not &quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,21 ***</span>
   *    the option &quot;TieredStopAtLevel &lt; CompLevel_full_optimization&quot;. As a result, only
   *    C1 can be used, so the minimum number of compiler threads is 1.
   * 4) The JVM is build using the compilers and tiered compilation is enabled. The option
   *    &#39;TieredStopAtLevel = CompLevel_full_optimization&#39; (the default value). As a result,
   *    the minimum number of compiler threads is 2.
   */
  JVMFlag::Error CICompilerCountConstraintFunc(intx value, bool verbose) {
    int min_number_of_compiler_threads = 0;
  #if !defined(COMPILER1) &amp;&amp; !defined(COMPILER2) &amp;&amp; !INCLUDE_JVMCI
    // case 1
<span class="line-modified">! #else</span>
<span class="line-modified">!   if (!TieredCompilation || (TieredStopAtLevel &lt; CompLevel_full_optimization)) {</span>
<span class="line-modified">!     min_number_of_compiler_threads = 1; // case 2 or case 3</span>
    } else {
<span class="line-modified">!     min_number_of_compiler_threads = 2;   // case 4 (tiered)</span>
    }
  #endif
  
    // The default CICompilerCount&#39;s value is CI_COMPILER_COUNT.
    // With a client VM, -XX:+TieredCompilation causes TieredCompilation
    // to be true here (the option is validated later) and
<span class="line-new-header">--- 59,36 ---</span>
   *    the option &quot;TieredStopAtLevel &lt; CompLevel_full_optimization&quot;. As a result, only
   *    C1 can be used, so the minimum number of compiler threads is 1.
   * 4) The JVM is build using the compilers and tiered compilation is enabled. The option
   *    &#39;TieredStopAtLevel = CompLevel_full_optimization&#39; (the default value). As a result,
   *    the minimum number of compiler threads is 2.
<span class="line-added">+  * 5) Non-tiered emulation mode is on. CompilationModeFlag::disable_intermediate() == true.</span>
<span class="line-added">+  *    The minimum number of threads is 2. But if CompilationModeFlag::quick_internal() == false, then it&#39;s 1.</span>
   */
  JVMFlag::Error CICompilerCountConstraintFunc(intx value, bool verbose) {
    int min_number_of_compiler_threads = 0;
  #if !defined(COMPILER1) &amp;&amp; !defined(COMPILER2) &amp;&amp; !INCLUDE_JVMCI
    // case 1
<span class="line-modified">! #elif defined(TIERED)</span>
<span class="line-modified">!   if (TieredCompilation) {</span>
<span class="line-modified">!     if (TieredStopAtLevel &lt; CompLevel_full_optimization || CompilationModeFlag::quick_only()) {</span>
<span class="line-added">+       min_number_of_compiler_threads = 1; // case 3</span>
<span class="line-added">+     } else if (CompilationModeFlag::disable_intermediate()) {</span>
<span class="line-added">+       // case 5</span>
<span class="line-added">+       if (CompilationModeFlag::quick_internal()) {</span>
<span class="line-added">+         min_number_of_compiler_threads = 2;</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         min_number_of_compiler_threads = 1;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       min_number_of_compiler_threads = 2;   // case 4 (tiered)</span>
<span class="line-added">+     }</span>
    } else {
<span class="line-modified">!     min_number_of_compiler_threads = 1; // case 2</span>
    }
<span class="line-added">+ #else</span>
<span class="line-added">+   min_number_of_compiler_threads = 1; // case 2</span>
  #endif
  
    // The default CICompilerCount&#39;s value is CI_COMPILER_COUNT.
    // With a client VM, -XX:+TieredCompilation causes TieredCompilation
    // to be true here (the option is validated later) and
</pre>
<center><a href="jvmFlagConstraintList.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintsRuntime.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/flags/jvmFlagConstraintList.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/stringTable.hpp&quot;
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;gc/shared/jvmFlagConstraintsGC.hpp&quot;
 29 #include &quot;runtime/arguments.hpp&quot;
 30 #include &quot;runtime/flags/jvmFlag.hpp&quot;
 31 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
 32 #include &quot;runtime/flags/jvmFlagConstraintsCompiler.hpp&quot;
 33 #include &quot;runtime/flags/jvmFlagConstraintsRuntime.hpp&quot;
 34 #include &quot;runtime/os.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
 36 #ifdef COMPILER1
 37 #include &quot;c1/c1_globals.hpp&quot;
 38 #endif
 39 #ifdef COMPILER2
 40 #include &quot;opto/c2_globals.hpp&quot;
 41 #endif
 42 
 43 class JVMFlagConstraint_bool : public JVMFlagConstraint {
 44   JVMFlagConstraintFunc_bool _constraint;
 45   const bool* _ptr;
 46 
 47 public:
 48   // the &quot;name&quot; argument must be a string literal
 49   JVMFlagConstraint_bool(const char* name, const bool* ptr,
 50                                  JVMFlagConstraintFunc_bool func,
 51                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}
 52 
 53   JVMFlag::Error apply(bool verbose) {
 54     bool value = *_ptr;
 55     return _constraint(value, verbose);
 56   }
 57 
 58   JVMFlag::Error apply_bool(bool value, bool verbose) {
 59     return _constraint(value, verbose);
 60   }
 61 };
 62 
 63 class JVMFlagConstraint_int : public JVMFlagConstraint {
 64   JVMFlagConstraintFunc_int _constraint;
 65   const int* _ptr;
 66 
 67 public:
 68   // the &quot;name&quot; argument must be a string literal
 69   JVMFlagConstraint_int(const char* name, const int* ptr,
 70                                 JVMFlagConstraintFunc_int func,
 71                                 ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}
 72 
 73   JVMFlag::Error apply(bool verbose) {
 74     int value = *_ptr;
 75     return _constraint(value, verbose);
 76   }
 77 
 78   JVMFlag::Error apply_int(int value, bool verbose) {
 79     return _constraint(value, verbose);
 80   }
 81 };
 82 
 83 class JVMFlagConstraint_intx : public JVMFlagConstraint {
 84   JVMFlagConstraintFunc_intx _constraint;
 85   const intx* _ptr;
 86 
 87 public:
 88   // the &quot;name&quot; argument must be a string literal
 89   JVMFlagConstraint_intx(const char* name, const intx* ptr,
 90                                  JVMFlagConstraintFunc_intx func,
 91                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}
 92 
 93   JVMFlag::Error apply(bool verbose) {
 94     intx value = *_ptr;
 95     return _constraint(value, verbose);
 96   }
 97 
 98   JVMFlag::Error apply_intx(intx value, bool verbose) {
 99     return _constraint(value, verbose);
100   }
101 };
102 
103 class JVMFlagConstraint_uint : public JVMFlagConstraint {
104   JVMFlagConstraintFunc_uint _constraint;
105   const uint* _ptr;
106 
107 public:
108   // the &quot;name&quot; argument must be a string literal
109   JVMFlagConstraint_uint(const char* name, const uint* ptr,
110                                  JVMFlagConstraintFunc_uint func,
111                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}
112 
113   JVMFlag::Error apply(bool verbose) {
114     uint value = *_ptr;
115     return _constraint(value, verbose);
116   }
117 
118   JVMFlag::Error apply_uint(uint value, bool verbose) {
119     return _constraint(value, verbose);
120   }
121 };
122 
123 class JVMFlagConstraint_uintx : public JVMFlagConstraint {
124   JVMFlagConstraintFunc_uintx _constraint;
125   const uintx* _ptr;
126 
127 public:
128   // the &quot;name&quot; argument must be a string literal
129   JVMFlagConstraint_uintx(const char* name, const uintx* ptr,
130                                   JVMFlagConstraintFunc_uintx func,
131                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}
132 
133   JVMFlag::Error apply(bool verbose) {
134     uintx value = *_ptr;
135     return _constraint(value, verbose);
136   }
137 
138   JVMFlag::Error apply_uintx(uintx value, bool verbose) {
139     return _constraint(value, verbose);
140   }
141 };
142 
143 class JVMFlagConstraint_uint64_t : public JVMFlagConstraint {
144   JVMFlagConstraintFunc_uint64_t _constraint;
145   const uint64_t* _ptr;
146 
147 public:
148   // the &quot;name&quot; argument must be a string literal
149   JVMFlagConstraint_uint64_t(const char* name, const uint64_t* ptr,
150                                      JVMFlagConstraintFunc_uint64_t func,
151                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}
152 
153   JVMFlag::Error apply(bool verbose) {
154     uint64_t value = *_ptr;
155     return _constraint(value, verbose);
156   }
157 
158   JVMFlag::Error apply_uint64_t(uint64_t value, bool verbose) {
159     return _constraint(value, verbose);
160   }
161 };
162 
163 class JVMFlagConstraint_size_t : public JVMFlagConstraint {
164   JVMFlagConstraintFunc_size_t _constraint;
165   const size_t* _ptr;
166 public:
167   // the &quot;name&quot; argument must be a string literal
168   JVMFlagConstraint_size_t(const char* name, const size_t* ptr,
169                                    JVMFlagConstraintFunc_size_t func,
170                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}
171 
172   JVMFlag::Error apply(bool verbose) {
173     size_t value = *_ptr;
174     return _constraint(value, verbose);
175   }
176 
177   JVMFlag::Error apply_size_t(size_t value, bool verbose) {
178     return _constraint(value, verbose);
179   }
180 };
181 
182 class JVMFlagConstraint_double : public JVMFlagConstraint {
183   JVMFlagConstraintFunc_double _constraint;
184   const double* _ptr;
185 
186 public:
187   // the &quot;name&quot; argument must be a string literal
188   JVMFlagConstraint_double(const char* name, const double* ptr,
189                                    JVMFlagConstraintFunc_double func,
190                                  ConstraintType type) : JVMFlagConstraint(name, type), _constraint(func), _ptr(ptr) {}
191 
192   JVMFlag::Error apply(bool verbose) {
193     double value = *_ptr;
194     return _constraint(value, verbose);
195   }
196 
197   JVMFlag::Error apply_double(double value, bool verbose) {
198     return _constraint(value, verbose);
199   }
200 };
201 
202 // No constraint emitting
203 void emit_constraint_no(...)                                                      { /* NOP */ }
204 
205 // No constraint emitting if function argument is NOT provided
206 void emit_constraint_bool(const char* /*name*/, const bool* /*value*/)            { /* NOP */ }
207 void emit_constraint_ccstr(const char* /*name*/, const ccstr* /*value*/)          { /* NOP */ }
208 void emit_constraint_ccstrlist(const char* /*name*/, const ccstrlist* /*value*/)  { /* NOP */ }
209 void emit_constraint_int(const char* /*name*/, const int* /*value*/)              { /* NOP */ }
210 void emit_constraint_intx(const char* /*name*/, const intx* /*value*/)            { /* NOP */ }
211 void emit_constraint_uint(const char* /*name*/, const uint* /*value*/)            { /* NOP */ }
212 void emit_constraint_uintx(const char* /*name*/, const uintx* /*value*/)          { /* NOP */ }
213 void emit_constraint_uint64_t(const char* /*name*/, const uint64_t* /*value*/)    { /* NOP */ }
214 void emit_constraint_size_t(const char* /*name*/, const size_t* /*value*/)        { /* NOP */ }
215 void emit_constraint_double(const char* /*name*/, const double* /*value*/)        { /* NOP */ }
216 
217 // JVMFlagConstraint emitting code functions if function argument is provided
218 void emit_constraint_bool(const char* name, const bool* ptr, JVMFlagConstraintFunc_bool func, JVMFlagConstraint::ConstraintType type) {
219   JVMFlagConstraintList::add(new JVMFlagConstraint_bool(name, ptr, func, type));
220 }
221 void emit_constraint_int(const char* name, const int* ptr, JVMFlagConstraintFunc_int func, JVMFlagConstraint::ConstraintType type) {
222   JVMFlagConstraintList::add(new JVMFlagConstraint_int(name, ptr, func, type));
223 }
224 void emit_constraint_intx(const char* name, const intx* ptr, JVMFlagConstraintFunc_intx func, JVMFlagConstraint::ConstraintType type) {
225   JVMFlagConstraintList::add(new JVMFlagConstraint_intx(name, ptr, func, type));
226 }
227 void emit_constraint_uint(const char* name, const uint* ptr, JVMFlagConstraintFunc_uint func, JVMFlagConstraint::ConstraintType type) {
228   JVMFlagConstraintList::add(new JVMFlagConstraint_uint(name, ptr, func, type));
229 }
230 void emit_constraint_uintx(const char* name, const uintx* ptr, JVMFlagConstraintFunc_uintx func, JVMFlagConstraint::ConstraintType type) {
231   JVMFlagConstraintList::add(new JVMFlagConstraint_uintx(name, ptr, func, type));
232 }
233 void emit_constraint_uint64_t(const char* name, const uint64_t* ptr, JVMFlagConstraintFunc_uint64_t func, JVMFlagConstraint::ConstraintType type) {
234   JVMFlagConstraintList::add(new JVMFlagConstraint_uint64_t(name, ptr, func, type));
235 }
236 void emit_constraint_size_t(const char* name, const size_t* ptr, JVMFlagConstraintFunc_size_t func, JVMFlagConstraint::ConstraintType type) {
237   JVMFlagConstraintList::add(new JVMFlagConstraint_size_t(name, ptr, func, type));
238 }
239 void emit_constraint_double(const char* name, const double* ptr, JVMFlagConstraintFunc_double func, JVMFlagConstraint::ConstraintType type) {
240   JVMFlagConstraintList::add(new JVMFlagConstraint_double(name, ptr, func, type));
241 }
242 
243 // Generate code to call emit_constraint_xxx function
244 #define EMIT_CONSTRAINT_PRODUCT_FLAG(type, name, value, doc)      ); emit_constraint_##type(#name,&amp;name
245 #define EMIT_CONSTRAINT_DIAGNOSTIC_FLAG(type, name, value, doc)   ); emit_constraint_##type(#name,&amp;name
246 #define EMIT_CONSTRAINT_EXPERIMENTAL_FLAG(type, name, value, doc) ); emit_constraint_##type(#name,&amp;name
247 #define EMIT_CONSTRAINT_MANAGEABLE_FLAG(type, name, value, doc)   ); emit_constraint_##type(#name,&amp;name
248 #define EMIT_CONSTRAINT_PRODUCT_RW_FLAG(type, name, value, doc)   ); emit_constraint_##type(#name,&amp;name
249 #define EMIT_CONSTRAINT_PD_PRODUCT_FLAG(type, name, doc)          ); emit_constraint_##type(#name,&amp;name
250 #define EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG(type, name, doc)       ); emit_constraint_##type(#name,&amp;name
251 #ifndef PRODUCT
252 #define EMIT_CONSTRAINT_DEVELOPER_FLAG(type, name, value, doc)    ); emit_constraint_##type(#name,&amp;name
253 #define EMIT_CONSTRAINT_PD_DEVELOPER_FLAG(type, name, doc)        ); emit_constraint_##type(#name,&amp;name
254 #define EMIT_CONSTRAINT_NOTPRODUCT_FLAG(type, name, value, doc)   ); emit_constraint_##type(#name,&amp;name
255 #else
256 #define EMIT_CONSTRAINT_DEVELOPER_FLAG(type, name, value, doc)    ); emit_constraint_no(#name,&amp;name
257 #define EMIT_CONSTRAINT_PD_DEVELOPER_FLAG(type, name, doc)        ); emit_constraint_no(#name,&amp;name
258 #define EMIT_CONSTRAINT_NOTPRODUCT_FLAG(type, name, value, doc)   ); emit_constraint_no(#name,&amp;name
259 #endif
260 #ifdef _LP64
261 #define EMIT_CONSTRAINT_LP64_PRODUCT_FLAG(type, name, value, doc) ); emit_constraint_##type(#name,&amp;name
262 #else
263 #define EMIT_CONSTRAINT_LP64_PRODUCT_FLAG(type, name, value, doc) ); emit_constraint_no(#name,&amp;name
264 #endif
265 
266 // Generate func argument to pass into emit_constraint_xxx functions
267 #define EMIT_CONSTRAINT_CHECK(func, type)                         , func, JVMFlagConstraint::type
268 
269 // the &quot;name&quot; argument must be a string literal
270 #define INITIAL_CONSTRAINTS_SIZE 72
271 GrowableArray&lt;JVMFlagConstraint*&gt;* JVMFlagConstraintList::_constraints = NULL;
272 JVMFlagConstraint::ConstraintType JVMFlagConstraintList::_validating_type = JVMFlagConstraint::AtParse;
273 
274 // Check the ranges of all flags that have them or print them out and exit if requested
275 void JVMFlagConstraintList::init(void) {
276   _constraints = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;JVMFlagConstraint*&gt;(INITIAL_CONSTRAINTS_SIZE, true);
277 
278   emit_constraint_no(NULL VM_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,
279                                    EMIT_CONSTRAINT_PD_DEVELOPER_FLAG,
280                                    EMIT_CONSTRAINT_PRODUCT_FLAG,
281                                    EMIT_CONSTRAINT_PD_PRODUCT_FLAG,
282                                    EMIT_CONSTRAINT_DIAGNOSTIC_FLAG,
283                                    EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG,
284                                    EMIT_CONSTRAINT_EXPERIMENTAL_FLAG,
285                                    EMIT_CONSTRAINT_NOTPRODUCT_FLAG,
286                                    EMIT_CONSTRAINT_MANAGEABLE_FLAG,
287                                    EMIT_CONSTRAINT_PRODUCT_RW_FLAG,
288                                    EMIT_CONSTRAINT_LP64_PRODUCT_FLAG,
289                                    IGNORE_RANGE,
290                                    EMIT_CONSTRAINT_CHECK,
291                                    IGNORE_WRITEABLE));
292 
293   EMIT_CONSTRAINTS_FOR_GLOBALS_EXT
294 
295   emit_constraint_no(NULL ARCH_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,
296                                      EMIT_CONSTRAINT_PRODUCT_FLAG,
297                                      EMIT_CONSTRAINT_DIAGNOSTIC_FLAG,
298                                      EMIT_CONSTRAINT_EXPERIMENTAL_FLAG,
299                                      EMIT_CONSTRAINT_NOTPRODUCT_FLAG,
300                                      IGNORE_RANGE,
301                                      EMIT_CONSTRAINT_CHECK,
302                                      IGNORE_WRITEABLE));
303 
304 
305 #ifdef COMPILER1
306   emit_constraint_no(NULL C1_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,
307                                    EMIT_CONSTRAINT_PD_DEVELOPER_FLAG,
308                                    EMIT_CONSTRAINT_PRODUCT_FLAG,
309                                    EMIT_CONSTRAINT_PD_PRODUCT_FLAG,
310                                    EMIT_CONSTRAINT_DIAGNOSTIC_FLAG,
311                                    EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG,
312                                    EMIT_CONSTRAINT_NOTPRODUCT_FLAG,
313                                    IGNORE_RANGE,
314                                    EMIT_CONSTRAINT_CHECK,
315                                    IGNORE_WRITEABLE));
316 #endif // COMPILER1
317 
318 #ifdef COMPILER2
319   emit_constraint_no(NULL C2_FLAGS(EMIT_CONSTRAINT_DEVELOPER_FLAG,
320                                    EMIT_CONSTRAINT_PD_DEVELOPER_FLAG,
321                                    EMIT_CONSTRAINT_PRODUCT_FLAG,
322                                    EMIT_CONSTRAINT_PD_PRODUCT_FLAG,
323                                    EMIT_CONSTRAINT_DIAGNOSTIC_FLAG,
324                                    EMIT_CONSTRAINT_PD_DIAGNOSTIC_FLAG,
325                                    EMIT_CONSTRAINT_EXPERIMENTAL_FLAG,
326                                    EMIT_CONSTRAINT_NOTPRODUCT_FLAG,
327                                    IGNORE_RANGE,
328                                    EMIT_CONSTRAINT_CHECK,
329                                    IGNORE_WRITEABLE));
330 #endif // COMPILER2
331 }
332 
333 JVMFlagConstraint* JVMFlagConstraintList::find(const char* name) {
334   JVMFlagConstraint* found = NULL;
335   for (int i=0; i&lt;length(); i++) {
336     JVMFlagConstraint* constraint = at(i);
337     if (strcmp(constraint-&gt;name(), name) == 0) {
338       found = constraint;
339       break;
340     }
341   }
342   return found;
343 }
344 
345 // Find constraints by name and return only if found constraint&#39;s type is equal or lower than current validating type.
346 JVMFlagConstraint* JVMFlagConstraintList::find_if_needs_check(const char* name) {
347   JVMFlagConstraint* found = NULL;
348   JVMFlagConstraint* constraint = find(name);
349   if (constraint &amp;&amp; (constraint-&gt;type() &lt;= _validating_type)) {
350     found = constraint;
351   }
352   return found;
353 }
354 
355 // Check constraints for specific constraint type.
356 bool JVMFlagConstraintList::check_constraints(JVMFlagConstraint::ConstraintType type) {
357   guarantee(type &gt; _validating_type, &quot;Constraint check is out of order.&quot;);
358   _validating_type = type;
359 
360   bool status = true;
361   for (int i=0; i&lt;length(); i++) {
362     JVMFlagConstraint* constraint = at(i);
363     if (type != constraint-&gt;type()) continue;
364     if (constraint-&gt;apply(true) != JVMFlag::SUCCESS) status = false;
365   }
366   return status;
367 }
    </pre>
  </body>
</html>
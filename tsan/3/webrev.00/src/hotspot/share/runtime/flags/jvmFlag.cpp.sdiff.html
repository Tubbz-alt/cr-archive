<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/flags/jvmFlag.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../fieldDescriptor.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlag.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/flags/jvmFlag.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jfr/jfrEvents.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;runtime/arguments.hpp&quot;
  29 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  30 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
<span class="line-removed">  31 #include &quot;runtime/flags/jvmFlagWriteableList.hpp&quot;</span>
  32 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  33 #include &quot;runtime/globals_extension.hpp&quot;
  34 #include &quot;utilities/defaultStream.hpp&quot;
  35 #include &quot;utilities/stringUtils.hpp&quot;
  36 
  37 #define DEFAULT_RANGE_STR_CHUNK_SIZE 64
  38 static char* create_range_str(const char *fmt, ...) {
  39   static size_t string_length = DEFAULT_RANGE_STR_CHUNK_SIZE;
  40   static char* range_string = NEW_C_HEAP_ARRAY(char, string_length, mtLogging);
  41 
  42   int size_needed = 0;
  43   do {
  44     va_list args;
  45     va_start(args, fmt);
  46     size_needed = jio_vsnprintf(range_string, string_length, fmt, args);
  47     va_end(args);
  48 
  49     if (size_needed &lt; 0) {
  50       string_length += DEFAULT_RANGE_STR_CHUNK_SIZE;
  51       range_string = REALLOC_C_HEAP_ARRAY(char, range_string, string_length, mtLogging);
</pre>
<hr />
<pre>
  75 const char* JVMFlag::get_uint64_t_default_range_str() {
  76   return create_range_str(&quot;[ &quot; UINT64_FORMAT_W(-25) &quot; ... &quot; UINT64_FORMAT_W(25) &quot; ]&quot;, 0, uint64_t(max_juint));
  77 }
  78 
  79 const char* JVMFlag::get_size_t_default_range_str() {
  80   return create_range_str(&quot;[ &quot; SIZE_FORMAT_W(-25) &quot; ... &quot; SIZE_FORMAT_W(25) &quot; ]&quot;, 0, SIZE_MAX);
  81 }
  82 
  83 const char* JVMFlag::get_double_default_range_str() {
  84   return create_range_str(&quot;[ %-25.3f ... %25.3f ]&quot;, DBL_MIN, DBL_MAX);
  85 }
  86 
  87 static bool is_product_build() {
  88 #ifdef PRODUCT
  89   return true;
  90 #else
  91   return false;
  92 #endif
  93 }
  94 
<span class="line-removed">  95 JVMFlag::Error JVMFlag::check_writable(bool changed) {</span>
<span class="line-removed">  96   if (is_constant_in_binary()) {</span>
<span class="line-removed">  97     fatal(&quot;flag is constant: %s&quot;, _name);</span>
<span class="line-removed">  98   }</span>
<span class="line-removed">  99 </span>
<span class="line-removed"> 100   JVMFlag::Error error = JVMFlag::SUCCESS;</span>
<span class="line-removed"> 101   if (changed) {</span>
<span class="line-removed"> 102     JVMFlagWriteable* writeable = JVMFlagWriteableList::find(_name);</span>
<span class="line-removed"> 103     if (writeable) {</span>
<span class="line-removed"> 104       if (writeable-&gt;is_writeable() == false) {</span>
<span class="line-removed"> 105         switch (writeable-&gt;type())</span>
<span class="line-removed"> 106         {</span>
<span class="line-removed"> 107           case JVMFlagWriteable::Once:</span>
<span class="line-removed"> 108             error = JVMFlag::SET_ONLY_ONCE;</span>
<span class="line-removed"> 109             jio_fprintf(defaultStream::error_stream(), &quot;Error: %s may not be set more than once\n&quot;, _name);</span>
<span class="line-removed"> 110             break;</span>
<span class="line-removed"> 111           case JVMFlagWriteable::CommandLineOnly:</span>
<span class="line-removed"> 112             error = JVMFlag::COMMAND_LINE_ONLY;</span>
<span class="line-removed"> 113             jio_fprintf(defaultStream::error_stream(), &quot;Error: %s may be modified only from commad line\n&quot;, _name);</span>
<span class="line-removed"> 114             break;</span>
<span class="line-removed"> 115           default:</span>
<span class="line-removed"> 116             ShouldNotReachHere();</span>
<span class="line-removed"> 117             break;</span>
<span class="line-removed"> 118         }</span>
<span class="line-removed"> 119       }</span>
<span class="line-removed"> 120       writeable-&gt;mark_once();</span>
<span class="line-removed"> 121     }</span>
<span class="line-removed"> 122   }</span>
<span class="line-removed"> 123   return error;</span>
<span class="line-removed"> 124 }</span>
<span class="line-removed"> 125 </span>
 126 bool JVMFlag::is_bool() const {
 127   return strcmp(_type, &quot;bool&quot;) == 0;
 128 }
 129 
<span class="line-removed"> 130 bool JVMFlag::get_bool() const {</span>
<span class="line-removed"> 131   return *((bool*) _addr);</span>
<span class="line-removed"> 132 }</span>
<span class="line-removed"> 133 </span>
<span class="line-removed"> 134 JVMFlag::Error JVMFlag::set_bool(bool value) {</span>
<span class="line-removed"> 135   JVMFlag::Error error = check_writable(value!=get_bool());</span>
<span class="line-removed"> 136   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 137     *((bool*) _addr) = value;</span>
<span class="line-removed"> 138   }</span>
<span class="line-removed"> 139   return error;</span>
<span class="line-removed"> 140 }</span>
<span class="line-removed"> 141 </span>
 142 bool JVMFlag::is_int() const {
 143   return strcmp(_type, &quot;int&quot;)  == 0;
 144 }
 145 
<span class="line-removed"> 146 int JVMFlag::get_int() const {</span>
<span class="line-removed"> 147   return *((int*) _addr);</span>
<span class="line-removed"> 148 }</span>
<span class="line-removed"> 149 </span>
<span class="line-removed"> 150 JVMFlag::Error JVMFlag::set_int(int value) {</span>
<span class="line-removed"> 151   JVMFlag::Error error = check_writable(value!=get_int());</span>
<span class="line-removed"> 152   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 153     *((int*) _addr) = value;</span>
<span class="line-removed"> 154   }</span>
<span class="line-removed"> 155   return error;</span>
<span class="line-removed"> 156 }</span>
<span class="line-removed"> 157 </span>
 158 bool JVMFlag::is_uint() const {
 159   return strcmp(_type, &quot;uint&quot;)  == 0;
 160 }
 161 
<span class="line-removed"> 162 uint JVMFlag::get_uint() const {</span>
<span class="line-removed"> 163   return *((uint*) _addr);</span>
<span class="line-removed"> 164 }</span>
<span class="line-removed"> 165 </span>
<span class="line-removed"> 166 JVMFlag::Error JVMFlag::set_uint(uint value) {</span>
<span class="line-removed"> 167   JVMFlag::Error error = check_writable(value!=get_uint());</span>
<span class="line-removed"> 168   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 169     *((uint*) _addr) = value;</span>
<span class="line-removed"> 170   }</span>
<span class="line-removed"> 171   return error;</span>
<span class="line-removed"> 172 }</span>
<span class="line-removed"> 173 </span>
 174 bool JVMFlag::is_intx() const {
 175   return strcmp(_type, &quot;intx&quot;)  == 0;
 176 }
 177 
<span class="line-removed"> 178 intx JVMFlag::get_intx() const {</span>
<span class="line-removed"> 179   return *((intx*) _addr);</span>
<span class="line-removed"> 180 }</span>
<span class="line-removed"> 181 </span>
<span class="line-removed"> 182 JVMFlag::Error JVMFlag::set_intx(intx value) {</span>
<span class="line-removed"> 183   JVMFlag::Error error = check_writable(value!=get_intx());</span>
<span class="line-removed"> 184   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 185     *((intx*) _addr) = value;</span>
<span class="line-removed"> 186   }</span>
<span class="line-removed"> 187   return error;</span>
<span class="line-removed"> 188 }</span>
<span class="line-removed"> 189 </span>
 190 bool JVMFlag::is_uintx() const {
 191   return strcmp(_type, &quot;uintx&quot;) == 0;
 192 }
 193 
<span class="line-removed"> 194 uintx JVMFlag::get_uintx() const {</span>
<span class="line-removed"> 195   return *((uintx*) _addr);</span>
<span class="line-removed"> 196 }</span>
<span class="line-removed"> 197 </span>
<span class="line-removed"> 198 JVMFlag::Error JVMFlag::set_uintx(uintx value) {</span>
<span class="line-removed"> 199   JVMFlag::Error error = check_writable(value!=get_uintx());</span>
<span class="line-removed"> 200   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 201     *((uintx*) _addr) = value;</span>
<span class="line-removed"> 202   }</span>
<span class="line-removed"> 203   return error;</span>
<span class="line-removed"> 204 }</span>
<span class="line-removed"> 205 </span>
 206 bool JVMFlag::is_uint64_t() const {
 207   return strcmp(_type, &quot;uint64_t&quot;) == 0;
 208 }
 209 
<span class="line-removed"> 210 uint64_t JVMFlag::get_uint64_t() const {</span>
<span class="line-removed"> 211   return *((uint64_t*) _addr);</span>
<span class="line-removed"> 212 }</span>
<span class="line-removed"> 213 </span>
<span class="line-removed"> 214 JVMFlag::Error JVMFlag::set_uint64_t(uint64_t value) {</span>
<span class="line-removed"> 215   JVMFlag::Error error = check_writable(value!=get_uint64_t());</span>
<span class="line-removed"> 216   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 217     *((uint64_t*) _addr) = value;</span>
<span class="line-removed"> 218   }</span>
<span class="line-removed"> 219   return error;</span>
<span class="line-removed"> 220 }</span>
<span class="line-removed"> 221 </span>
 222 bool JVMFlag::is_size_t() const {
 223   return strcmp(_type, &quot;size_t&quot;) == 0;
 224 }
 225 
<span class="line-removed"> 226 size_t JVMFlag::get_size_t() const {</span>
<span class="line-removed"> 227   return *((size_t*) _addr);</span>
<span class="line-removed"> 228 }</span>
<span class="line-removed"> 229 </span>
<span class="line-removed"> 230 JVMFlag::Error JVMFlag::set_size_t(size_t value) {</span>
<span class="line-removed"> 231   JVMFlag::Error error = check_writable(value!=get_size_t());</span>
<span class="line-removed"> 232   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 233     *((size_t*) _addr) = value;</span>
<span class="line-removed"> 234   }</span>
<span class="line-removed"> 235   return error;</span>
<span class="line-removed"> 236 }</span>
<span class="line-removed"> 237 </span>
 238 bool JVMFlag::is_double() const {
 239   return strcmp(_type, &quot;double&quot;) == 0;
 240 }
 241 
<span class="line-removed"> 242 double JVMFlag::get_double() const {</span>
<span class="line-removed"> 243   return *((double*) _addr);</span>
<span class="line-removed"> 244 }</span>
<span class="line-removed"> 245 </span>
<span class="line-removed"> 246 JVMFlag::Error JVMFlag::set_double(double value) {</span>
<span class="line-removed"> 247   JVMFlag::Error error = check_writable(value!=get_double());</span>
<span class="line-removed"> 248   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 249     *((double*) _addr) = value;</span>
<span class="line-removed"> 250   }</span>
<span class="line-removed"> 251   return error;</span>
<span class="line-removed"> 252 }</span>
<span class="line-removed"> 253 </span>
 254 bool JVMFlag::is_ccstr() const {
 255   return strcmp(_type, &quot;ccstr&quot;) == 0 || strcmp(_type, &quot;ccstrlist&quot;) == 0;
 256 }
 257 
 258 bool JVMFlag::ccstr_accumulates() const {
 259   return strcmp(_type, &quot;ccstrlist&quot;) == 0;
 260 }
 261 
<span class="line-removed"> 262 ccstr JVMFlag::get_ccstr() const {</span>
<span class="line-removed"> 263   return *((ccstr*) _addr);</span>
<span class="line-removed"> 264 }</span>
<span class="line-removed"> 265 </span>
<span class="line-removed"> 266 JVMFlag::Error JVMFlag::set_ccstr(ccstr value) {</span>
<span class="line-removed"> 267   JVMFlag::Error error = check_writable(value!=get_ccstr());</span>
<span class="line-removed"> 268   if (error == JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 269     *((ccstr*) _addr) = value;</span>
<span class="line-removed"> 270   }</span>
<span class="line-removed"> 271   return error;</span>
<span class="line-removed"> 272 }</span>
<span class="line-removed"> 273 </span>
<span class="line-removed"> 274 </span>
 275 JVMFlag::Flags JVMFlag::get_origin() {
 276   return Flags(_flags &amp; VALUE_ORIGIN_MASK);
 277 }
 278 
 279 void JVMFlag::set_origin(Flags origin) {
 280   assert((origin &amp; VALUE_ORIGIN_MASK) == origin, &quot;sanity&quot;);
 281   Flags new_origin = Flags((origin == COMMAND_LINE) ? Flags(origin | ORIG_COMMAND_LINE) : origin);
 282   _flags = Flags((_flags &amp; ~VALUE_ORIGIN_MASK) | new_origin);
 283 }
 284 
 285 bool JVMFlag::is_default() {
 286   return (get_origin() == DEFAULT);
 287 }
 288 
 289 bool JVMFlag::is_ergonomic() {
 290   return (get_origin() == ERGONOMIC);
 291 }
 292 
 293 bool JVMFlag::is_command_line() {
 294   return (_flags &amp; ORIG_COMMAND_LINE) != 0;
</pre>
<hr />
<pre>
 322   return (_flags &amp; KIND_DEVELOP) != 0;
 323 }
 324 
 325 bool JVMFlag::is_read_write() const {
 326   return (_flags &amp; KIND_READ_WRITE) != 0;
 327 }
 328 
 329 /**
 330  * Returns if this flag is a constant in the binary.  Right now this is
 331  * true for notproduct and develop flags in product builds.
 332  */
 333 bool JVMFlag::is_constant_in_binary() const {
 334 #ifdef PRODUCT
 335   return is_notproduct() || is_develop();
 336 #else
 337   return false;
 338 #endif
 339 }
 340 
 341 bool JVMFlag::is_unlocker() const {
<span class="line-modified"> 342   return strcmp(_name, &quot;UnlockDiagnosticVMOptions&quot;) == 0     ||</span>
<span class="line-modified"> 343   strcmp(_name, &quot;UnlockExperimentalVMOptions&quot;) == 0   ||</span>
<span class="line-removed"> 344   is_unlocker_ext();</span>
 345 }
 346 
 347 bool JVMFlag::is_unlocked() const {
 348   if (is_diagnostic()) {
 349     return UnlockDiagnosticVMOptions;
 350   }
 351   if (is_experimental()) {
 352     return UnlockExperimentalVMOptions;
 353   }
<span class="line-modified"> 354   return is_unlocked_ext();</span>
 355 }
 356 
 357 void JVMFlag::clear_diagnostic() {
 358   assert(is_diagnostic(), &quot;sanity&quot;);
 359   _flags = Flags(_flags &amp; ~KIND_DIAGNOSTIC);
 360   assert(!is_diagnostic(), &quot;sanity&quot;);
 361 }
 362 












 363 // Get custom message for this locked flag, or NULL if
 364 // none is available. Returns message type produced.
 365 JVMFlag::MsgType JVMFlag::get_locked_message(char* buf, int buflen) const {
 366   buf[0] = &#39;\0&#39;;
 367   if (is_diagnostic() &amp;&amp; !is_unlocked()) {
 368     jio_snprintf(buf, buflen,
 369                  &quot;Error: VM option &#39;%s&#39; is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions.\n&quot;
 370                  &quot;Error: The unlock option must precede &#39;%s&#39;.\n&quot;,
 371                  _name, _name);
 372     return JVMFlag::DIAGNOSTIC_FLAG_BUT_LOCKED;
 373   }
 374   if (is_experimental() &amp;&amp; !is_unlocked()) {
 375     jio_snprintf(buf, buflen,
 376                  &quot;Error: VM option &#39;%s&#39; is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions.\n&quot;
 377                  &quot;Error: The unlock option must precede &#39;%s&#39;.\n&quot;,
 378                  _name, _name);
 379     return JVMFlag::EXPERIMENTAL_FLAG_BUT_LOCKED;
 380   }
 381   if (is_develop() &amp;&amp; is_product_build()) {
 382     jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is develop and is available only in debug version of VM.\n&quot;,
 383                  _name);
 384     return JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD;
 385   }
 386   if (is_notproduct() &amp;&amp; is_product_build()) {
 387     jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is notproduct and is available only in debug version of VM.\n&quot;,
 388                  _name);
 389     return JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD;
 390   }
<span class="line-modified"> 391   return get_locked_message_ext(buf, buflen);</span>
 392 }
 393 
 394 bool JVMFlag::is_writeable() const {
<span class="line-modified"> 395   return is_manageable() || (is_product() &amp;&amp; is_read_write()) || is_writeable_ext();</span>
 396 }
 397 
 398 // All flags except &quot;manageable&quot; are assumed to be internal flags.
 399 // Long term, we need to define a mechanism to specify which flags
 400 // are external/stable and change this function accordingly.
 401 bool JVMFlag::is_external() const {
<span class="line-modified"> 402   return is_manageable() || is_external_ext();</span>
 403 }
 404 
 405 // Helper function for JVMFlag::print_on().
 406 // Fills current line up to requested position.
 407 // Should the current position already be past the requested position,
 408 // one separator blank is enforced.
 409 void fill_to_pos(outputStream* st, unsigned int req_pos) {
 410   if ((unsigned int)st-&gt;position() &lt; req_pos) {
 411     st-&gt;fill_to(req_pos);  // need to fill with blanks to reach req_pos
 412   } else {
 413     st-&gt;print(&quot; &quot;);        // enforce blank separation. Previous field too long.
 414   }
 415 }
 416 
 417 void JVMFlag::print_on(outputStream* st, bool withComments, bool printRanges) {
 418   // Don&#39;t print notproduct and develop flags in a product build.
 419   if (is_constant_in_binary()) {
 420     return;
 421   }
 422 
 423   if (!printRanges) {
 424     // The command line options -XX:+PrintFlags* cause this function to be called
 425     // for each existing flag to print information pertinent to this flag. The data
 426     // is displayed in columnar form, with the following layout:
 427     //  col1 - data type, right-justified
 428     //  col2 - name,      left-justified
 429     //  col3 - &#39; =&#39;       double-char, leading space to align with possible &#39;+=&#39;
 430     //  col4 - value      left-justified
 431     //  col5 - kind       right-justified
 432     //  col6 - origin     left-justified
 433     //  col7 - comments   left-justified
 434     //
 435     //  The column widths are fixed. They are defined such that, for most cases,
 436     //  an eye-pleasing tabular output is created.
 437     //
 438     //  Sample output:
<span class="line-modified"> 439     //       bool CMSScavengeBeforeRemark                  = false                                     {product} {default}</span>
<span class="line-modified"> 440     //      uintx CMSScheduleRemarkEdenPenetration         = 50                                        {product} {default}</span>
<span class="line-modified"> 441     //     size_t CMSScheduleRemarkEdenSizeThreshold       = 2097152                                   {product} {default}</span>
<span class="line-modified"> 442     //      uintx CMSScheduleRemarkSamplingRatio           = 5                                         {product} {default}</span>
<span class="line-modified"> 443     //     double CMSSmallCoalSurplusPercent               = 1.050000                                  {product} {default}</span>
 444     //      ccstr CompileCommandFile                       = MyFile.cmd                                {product} {command line}
 445     //  ccstrlist CompileOnly                              = Method1
 446     //            CompileOnly                             += Method2                                   {product} {command line}
 447     //  |         |                                       |  |                              |                    |               |
 448     //  |         |                                       |  |                              |                    |               +-- col7
 449     //  |         |                                       |  |                              |                    +-- col6
 450     //  |         |                                       |  |                              +-- col5
 451     //  |         |                                       |  +-- col4
 452     //  |         |                                       +-- col3
 453     //  |         +-- col2
 454     //  +-- col1
 455 
 456     const unsigned int col_spacing = 1;
 457     const unsigned int col1_pos    = 0;
 458     const unsigned int col1_width  = 9;
 459     const unsigned int col2_pos    = col1_pos + col1_width + col_spacing;
 460     const unsigned int col2_width  = 39;
 461     const unsigned int col3_pos    = col2_pos + col2_width + col_spacing;
 462     const unsigned int col3_width  = 2;
 463     const unsigned int col4_pos    = col3_pos + col3_width + col_spacing;
</pre>
<hr />
<pre>
 587     RangeStrFunc func = NULL;
 588     if (is_int()) {
 589       func = JVMFlag::get_int_default_range_str;
 590     } else if (is_uint()) {
 591       func = JVMFlag::get_uint_default_range_str;
 592     } else if (is_intx()) {
 593       func = JVMFlag::get_intx_default_range_str;
 594     } else if (is_uintx()) {
 595       func = JVMFlag::get_uintx_default_range_str;
 596     } else if (is_uint64_t()) {
 597       func = JVMFlag::get_uint64_t_default_range_str;
 598     } else if (is_size_t()) {
 599       func = JVMFlag::get_size_t_default_range_str;
 600     } else if (is_double()) {
 601       func = JVMFlag::get_double_default_range_str;
 602     } else {
 603       st-&gt;print(&quot;unhandled  type %s&quot;, _type);
 604       st-&gt;cr();
 605       return;
 606     }
<span class="line-modified"> 607     JVMFlagRangeList::print(st, _name, func);</span>
 608 
 609     fill_to_pos(st, col5_pos);
 610     print_kind(st, col5_width);
 611 
 612     fill_to_pos(st, col6_pos);
 613     print_origin(st, col6_width);
 614 
 615 #ifndef PRODUCT
 616     if (withComments) {
 617       fill_to_pos(st, col7_pos);
 618       st-&gt;print(&quot;%s&quot;, _doc);
 619     }
 620 #endif
 621     st-&gt;cr();
 622   }
 623 }
 624 
 625 void JVMFlag::print_kind(outputStream* st, unsigned int width) {
 626   struct Data {
 627     int flag;
</pre>
<hr />
<pre>
 681   switch(origin) {
 682     case DEFAULT:
 683       st-&gt;print(&quot;default&quot;); break;
 684     case COMMAND_LINE:
 685       st-&gt;print(&quot;command line&quot;); break;
 686     case ENVIRON_VAR:
 687       st-&gt;print(&quot;environment&quot;); break;
 688     case CONFIG_FILE:
 689       st-&gt;print(&quot;config file&quot;); break;
 690     case MANAGEMENT:
 691       st-&gt;print(&quot;management&quot;); break;
 692     case ERGONOMIC:
 693       if (_flags &amp; ORIG_COMMAND_LINE) {
 694         st-&gt;print(&quot;command line, &quot;);
 695       }
 696       st-&gt;print(&quot;ergonomic&quot;); break;
 697     case ATTACH_ON_DEMAND:
 698       st-&gt;print(&quot;attach&quot;); break;
 699     case INTERNAL:
 700       st-&gt;print(&quot;internal&quot;); break;


 701   }
 702   st-&gt;print(&quot;}&quot;);
 703 }
 704 
 705 void JVMFlag::print_as_flag(outputStream* st) {
 706   if (is_bool()) {
 707     st-&gt;print(&quot;-XX:%s%s&quot;, get_bool() ? &quot;+&quot; : &quot;-&quot;, _name);
 708   } else if (is_int()) {
 709     st-&gt;print(&quot;-XX:%s=%d&quot;, _name, get_int());
 710   } else if (is_uint()) {
 711     st-&gt;print(&quot;-XX:%s=%u&quot;, _name, get_uint());
 712   } else if (is_intx()) {
 713     st-&gt;print(&quot;-XX:%s=&quot; INTX_FORMAT, _name, get_intx());
 714   } else if (is_uintx()) {
 715     st-&gt;print(&quot;-XX:%s=&quot; UINTX_FORMAT, _name, get_uintx());
 716   } else if (is_uint64_t()) {
 717     st-&gt;print(&quot;-XX:%s=&quot; UINT64_FORMAT, _name, get_uint64_t());
 718   } else if (is_size_t()) {
 719     st-&gt;print(&quot;-XX:%s=&quot; SIZE_FORMAT, _name, get_size_t());
 720   } else if (is_double()) {
</pre>
<hr />
<pre>
 805 
 806 #define ARCH_PRODUCT_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_PRODUCT) },
 807 #define ARCH_DIAGNOSTIC_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DIAGNOSTIC) },
 808 #define ARCH_EXPERIMENTAL_FLAG_STRUCT(   type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_EXPERIMENTAL) },
 809 #define ARCH_DEVELOP_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DEVELOP) },
 810 #define ARCH_NOTPRODUCT_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_NOT_PRODUCT) },
 811 
 812 static JVMFlag flagTable[] = {
 813   VM_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
 814            RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
 815            RUNTIME_PRODUCT_FLAG_STRUCT, \
 816            RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
 817            RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
 818            RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
 819            RUNTIME_EXPERIMENTAL_FLAG_STRUCT, \
 820            RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
 821            RUNTIME_MANAGEABLE_FLAG_STRUCT, \
 822            RUNTIME_PRODUCT_RW_FLAG_STRUCT, \
 823            RUNTIME_LP64_PRODUCT_FLAG_STRUCT, \
 824            IGNORE_RANGE, \
<span class="line-modified"> 825            IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 826            IGNORE_WRITEABLE)</span>
 827 
 828   RUNTIME_OS_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
 829                    RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
 830                    RUNTIME_PRODUCT_FLAG_STRUCT, \
 831                    RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
 832                    RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
 833                    RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
 834                    RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
 835                    IGNORE_RANGE, \
<span class="line-modified"> 836                    IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 837                    IGNORE_WRITEABLE)</span>
 838 #if INCLUDE_JVMCI
 839   JVMCI_FLAGS(JVMCI_DEVELOP_FLAG_STRUCT, \
 840               JVMCI_PD_DEVELOP_FLAG_STRUCT, \
 841               JVMCI_PRODUCT_FLAG_STRUCT, \
 842               JVMCI_PD_PRODUCT_FLAG_STRUCT, \
 843               JVMCI_DIAGNOSTIC_FLAG_STRUCT, \
 844               JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT, \
 845               JVMCI_EXPERIMENTAL_FLAG_STRUCT, \
 846               JVMCI_NOTPRODUCT_FLAG_STRUCT, \
 847               IGNORE_RANGE, \
<span class="line-modified"> 848               IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 849               IGNORE_WRITEABLE)</span>
 850 #endif // INCLUDE_JVMCI
 851 #ifdef COMPILER1
 852   C1_FLAGS(C1_DEVELOP_FLAG_STRUCT, \
 853            C1_PD_DEVELOP_FLAG_STRUCT, \
 854            C1_PRODUCT_FLAG_STRUCT, \
 855            C1_PD_PRODUCT_FLAG_STRUCT, \
 856            C1_DIAGNOSTIC_FLAG_STRUCT, \
 857            C1_PD_DIAGNOSTIC_FLAG_STRUCT, \
 858            C1_NOTPRODUCT_FLAG_STRUCT, \
 859            IGNORE_RANGE, \
<span class="line-modified"> 860            IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 861            IGNORE_WRITEABLE)</span>
 862 #endif // COMPILER1
 863 #ifdef COMPILER2
 864   C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, \
 865            C2_PD_DEVELOP_FLAG_STRUCT, \
 866            C2_PRODUCT_FLAG_STRUCT, \
 867            C2_PD_PRODUCT_FLAG_STRUCT, \
 868            C2_DIAGNOSTIC_FLAG_STRUCT, \
 869            C2_PD_DIAGNOSTIC_FLAG_STRUCT, \
 870            C2_EXPERIMENTAL_FLAG_STRUCT, \
 871            C2_NOTPRODUCT_FLAG_STRUCT, \
 872            IGNORE_RANGE, \
<span class="line-modified"> 873            IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 874            IGNORE_WRITEABLE)</span>
 875 #endif // COMPILER2
 876   ARCH_FLAGS(ARCH_DEVELOP_FLAG_STRUCT, \
 877              ARCH_PRODUCT_FLAG_STRUCT, \
 878              ARCH_DIAGNOSTIC_FLAG_STRUCT, \
 879              ARCH_EXPERIMENTAL_FLAG_STRUCT, \
 880              ARCH_NOTPRODUCT_FLAG_STRUCT, \
 881              IGNORE_RANGE, \
<span class="line-modified"> 882              IGNORE_CONSTRAINT, \</span>
<span class="line-removed"> 883              IGNORE_WRITEABLE)</span>
<span class="line-removed"> 884   FLAGTABLE_EXT</span>
 885   {0, NULL, NULL}
 886 };
 887 
 888 JVMFlag* JVMFlag::flags = flagTable;
 889 size_t JVMFlag::numFlags = (sizeof(flagTable) / sizeof(JVMFlag));
 890 
 891 inline bool str_equal(const char* s, size_t s_len, const char* q, size_t q_len) {
 892   if (s_len != q_len) return false;
 893   return memcmp(s, q, q_len) == 0;
 894 }
 895 
 896 // Search the flag table for a named flag
 897 JVMFlag* JVMFlag::find_flag(const char* name, size_t length, bool allow_locked, bool return_flag) {
 898   for (JVMFlag* current = &amp;flagTable[0]; current-&gt;_name != NULL; current++) {
 899     if (str_equal(current-&gt;_name, current-&gt;get_name_length(), name, length)) {
 900       // Found a matching entry.
 901       // Don&#39;t report notproduct and develop flags in product builds.
 902       if (current-&gt;is_constant_in_binary()) {
 903         return (return_flag ? current : NULL);
 904       }
</pre>
<hr />
<pre>
 940   }
 941 
 942   if (match == NULL) {
 943     return NULL;
 944   }
 945 
 946   if (!(match-&gt;is_unlocked() || match-&gt;is_unlocker())) {
 947     if (!allow_locked) {
 948       return NULL;
 949     }
 950   }
 951 
 952   if (max_score &lt; VMOptionsFuzzyMatchSimilarity) {
 953     return NULL;
 954   }
 955 
 956   return match;
 957 }
 958 
 959 // Returns the address of the index&#39;th element
<span class="line-modified"> 960 static JVMFlag* address_of_flag(JVMFlagsWithType flag) {</span>
 961   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);
 962   return &amp;JVMFlag::flags[flag];
 963 }
 964 
<span class="line-modified"> 965 bool JVMFlagEx::is_default(JVMFlags flag) {</span>
<span class="line-modified"> 966   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-removed"> 967   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-removed"> 968   return f-&gt;is_default();</span>
<span class="line-removed"> 969 }</span>
<span class="line-removed"> 970 </span>
<span class="line-removed"> 971 bool JVMFlagEx::is_ergo(JVMFlags flag) {</span>
<span class="line-removed"> 972   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-removed"> 973   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-removed"> 974   return f-&gt;is_ergonomic();</span>
 975 }
 976 
<span class="line-modified"> 977 bool JVMFlagEx::is_cmdline(JVMFlags flag) {</span>
<span class="line-modified"> 978   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-removed"> 979   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-removed"> 980   return f-&gt;is_command_line();</span>
 981 }
 982 
<span class="line-modified"> 983 bool JVMFlag::wasSetOnCmdline(const char* name, bool* value) {</span>
<span class="line-modified"> 984   JVMFlag* result = JVMFlag::find_flag((char*)name, strlen(name));</span>
<span class="line-removed"> 985   if (result == NULL) return false;</span>
<span class="line-removed"> 986   *value = result-&gt;is_command_line();</span>
<span class="line-removed"> 987   return true;</span>
 988 }
 989 
<span class="line-modified"> 990 void JVMFlagEx::setOnCmdLine(JVMFlagsWithType flag) {</span>
<span class="line-modified"> 991   JVMFlag* faddr = address_of_flag(flag);</span>
 992   assert(faddr != NULL, &quot;Unknown flag&quot;);
 993   faddr-&gt;set_command_line();
 994 }
 995 
 996 template&lt;class E, class T&gt;
<span class="line-modified"> 997 static void trace_flag_changed(const char* name, const T old_value, const T new_value, const JVMFlag::Flags origin) {</span>
 998   E e;
<span class="line-modified"> 999   e.set_name(name);</span>
1000   e.set_oldValue(old_value);
1001   e.set_newValue(new_value);
1002   e.set_origin(origin);
1003   e.commit();
1004 }
1005 
<span class="line-modified">1006 static JVMFlag::Error apply_constraint_and_check_range_bool(const char* name, bool new_value, bool verbose) {</span>
1007   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1008   JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1009   if (constraint != NULL) {
1010     status = constraint-&gt;apply_bool(new_value, verbose);
1011   }
1012   return status;
1013 }
1014 
<span class="line-modified">1015 JVMFlag::Error JVMFlag::boolAt(const char* name, size_t len, bool* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1016   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1017   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1018   if (!result-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1019   *value = result-&gt;get_bool();</span>
1020   return JVMFlag::SUCCESS;
1021 }
1022 
1023 JVMFlag::Error JVMFlag::boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin) {
<span class="line-removed">1024   const char* name;</span>
1025   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1026   if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1027   name = flag-&gt;_name;</span>
<span class="line-removed">1028   JVMFlag::Error check = apply_constraint_and_check_range_bool(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1029   if (check != JVMFlag::SUCCESS) return check;
1030   bool old_value = flag-&gt;get_bool();
<span class="line-modified">1031   trace_flag_changed&lt;EventBooleanFlagChanged, bool&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1032   check = flag-&gt;set_bool(*value);</span>
1033   *value = old_value;
1034   flag-&gt;set_origin(origin);
<span class="line-modified">1035   return check;</span>
<span class="line-removed">1036 }</span>
<span class="line-removed">1037 </span>
<span class="line-removed">1038 JVMFlag::Error JVMFlag::boolAtPut(const char* name, size_t len, bool* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1039   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1040   return boolAtPut(result, value, origin);</span>
1041 }
1042 
<span class="line-modified">1043 JVMFlag::Error JVMFlagEx::boolAtPut(JVMFlagsWithType flag, bool value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1044   JVMFlag* faddr = address_of_flag(flag);</span>
1045   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_bool(), &quot;wrong flag type&quot;);
1046   return JVMFlag::boolAtPut(faddr, &amp;value, origin);
1047 }
1048 
<span class="line-modified">1049 static JVMFlag::Error apply_constraint_and_check_range_int(const char* name, int new_value, bool verbose) {</span>
1050   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1051   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1052   if (range != NULL) {
1053     status = range-&gt;check_int(new_value, verbose);
1054   }
1055   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1056     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1057     if (constraint != NULL) {
1058       status = constraint-&gt;apply_int(new_value, verbose);
1059     }
1060   }
1061   return status;
1062 }
1063 
<span class="line-modified">1064 JVMFlag::Error JVMFlag::intAt(const char* name, size_t len, int* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1065   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1066   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1067   if (!result-&gt;is_int()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1068   *value = result-&gt;get_int();</span>
1069   return JVMFlag::SUCCESS;
1070 }
1071 
1072 JVMFlag::Error JVMFlag::intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin) {
<span class="line-removed">1073   const char* name;</span>
1074   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1075   if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1076   name = flag-&gt;_name;</span>
<span class="line-removed">1077   JVMFlag::Error check = apply_constraint_and_check_range_int(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1078   if (check != JVMFlag::SUCCESS) return check;
1079   int old_value = flag-&gt;get_int();
<span class="line-modified">1080   trace_flag_changed&lt;EventIntFlagChanged, s4&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1081   check = flag-&gt;set_int(*value);</span>
1082   *value = old_value;
1083   flag-&gt;set_origin(origin);
<span class="line-modified">1084   return check;</span>
<span class="line-removed">1085 }</span>
<span class="line-removed">1086 </span>
<span class="line-removed">1087 JVMFlag::Error JVMFlag::intAtPut(const char* name, size_t len, int* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1088   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1089   return intAtPut(result, value, origin);</span>
1090 }
1091 
<span class="line-modified">1092 JVMFlag::Error JVMFlagEx::intAtPut(JVMFlagsWithType flag, int value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1093   JVMFlag* faddr = address_of_flag(flag);</span>
1094   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_int(), &quot;wrong flag type&quot;);
1095   return JVMFlag::intAtPut(faddr, &amp;value, origin);
1096 }
1097 
<span class="line-modified">1098 static JVMFlag::Error apply_constraint_and_check_range_uint(const char* name, uint new_value, bool verbose) {</span>
1099   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1100   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1101   if (range != NULL) {
1102     status = range-&gt;check_uint(new_value, verbose);
1103   }
1104   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1105     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1106     if (constraint != NULL) {
1107       status = constraint-&gt;apply_uint(new_value, verbose);
1108     }
1109   }
1110   return status;
1111 }
1112 
<span class="line-modified">1113 JVMFlag::Error JVMFlag::uintAt(const char* name, size_t len, uint* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1114   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1115   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1116   if (!result-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1117   *value = result-&gt;get_uint();</span>
1118   return JVMFlag::SUCCESS;
1119 }
1120 
1121 JVMFlag::Error JVMFlag::uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin) {
<span class="line-removed">1122   const char* name;</span>
1123   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1124   if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1125   name = flag-&gt;_name;</span>
<span class="line-removed">1126   JVMFlag::Error check = apply_constraint_and_check_range_uint(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1127   if (check != JVMFlag::SUCCESS) return check;
1128   uint old_value = flag-&gt;get_uint();
<span class="line-modified">1129   trace_flag_changed&lt;EventUnsignedIntFlagChanged, u4&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1130   check = flag-&gt;set_uint(*value);</span>
1131   *value = old_value;
1132   flag-&gt;set_origin(origin);
<span class="line-modified">1133   return check;</span>
<span class="line-removed">1134 }</span>
<span class="line-removed">1135 </span>
<span class="line-removed">1136 JVMFlag::Error JVMFlag::uintAtPut(const char* name, size_t len, uint* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1137   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1138   return uintAtPut(result, value, origin);</span>
1139 }
1140 
<span class="line-modified">1141 JVMFlag::Error JVMFlagEx::uintAtPut(JVMFlagsWithType flag, uint value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1142   JVMFlag* faddr = address_of_flag(flag);</span>
1143   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint(), &quot;wrong flag type&quot;);
1144   return JVMFlag::uintAtPut(faddr, &amp;value, origin);
1145 }
1146 
<span class="line-modified">1147 JVMFlag::Error JVMFlag::intxAt(const char* name, size_t len, intx* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1148   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1149   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1150   if (!result-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1151   *value = result-&gt;get_intx();</span>
1152   return JVMFlag::SUCCESS;
1153 }
1154 
<span class="line-modified">1155 static JVMFlag::Error apply_constraint_and_check_range_intx(const char* name, intx new_value, bool verbose) {</span>
1156   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1157   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1158   if (range != NULL) {
1159     status = range-&gt;check_intx(new_value, verbose);
1160   }
1161   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1162     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1163     if (constraint != NULL) {
1164       status = constraint-&gt;apply_intx(new_value, verbose);
1165     }
1166   }
1167   return status;
1168 }
1169 
1170 JVMFlag::Error JVMFlag::intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin) {
<span class="line-removed">1171   const char* name;</span>
1172   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1173   if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1174   name = flag-&gt;_name;</span>
<span class="line-removed">1175   JVMFlag::Error check = apply_constraint_and_check_range_intx(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1176   if (check != JVMFlag::SUCCESS) return check;
1177   intx old_value = flag-&gt;get_intx();
<span class="line-modified">1178   trace_flag_changed&lt;EventLongFlagChanged, intx&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1179   check = flag-&gt;set_intx(*value);</span>
1180   *value = old_value;
1181   flag-&gt;set_origin(origin);
<span class="line-modified">1182   return check;</span>
<span class="line-removed">1183 }</span>
<span class="line-removed">1184 </span>
<span class="line-removed">1185 JVMFlag::Error JVMFlag::intxAtPut(const char* name, size_t len, intx* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1186   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1187   return intxAtPut(result, value, origin);</span>
1188 }
1189 
<span class="line-modified">1190 JVMFlag::Error JVMFlagEx::intxAtPut(JVMFlagsWithType flag, intx value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1191   JVMFlag* faddr = address_of_flag(flag);</span>
1192   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_intx(), &quot;wrong flag type&quot;);
1193   return JVMFlag::intxAtPut(faddr, &amp;value, origin);
1194 }
1195 
<span class="line-modified">1196 JVMFlag::Error JVMFlag::uintxAt(const char* name, size_t len, uintx* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1197   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1198   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1199   if (!result-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1200   *value = result-&gt;get_uintx();</span>
1201   return JVMFlag::SUCCESS;
1202 }
1203 
<span class="line-modified">1204 static JVMFlag::Error apply_constraint_and_check_range_uintx(const char* name, uintx new_value, bool verbose) {</span>
1205   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1206   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1207   if (range != NULL) {
1208     status = range-&gt;check_uintx(new_value, verbose);
1209   }
1210   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1211     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1212     if (constraint != NULL) {
1213       status = constraint-&gt;apply_uintx(new_value, verbose);
1214     }
1215   }
1216   return status;
1217 }
1218 
1219 JVMFlag::Error JVMFlag::uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin) {
<span class="line-removed">1220   const char* name;</span>
1221   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1222   if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1223   name = flag-&gt;_name;</span>
<span class="line-removed">1224   JVMFlag::Error check = apply_constraint_and_check_range_uintx(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1225   if (check != JVMFlag::SUCCESS) return check;
1226   uintx old_value = flag-&gt;get_uintx();
<span class="line-modified">1227   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1228   check = flag-&gt;set_uintx(*value);</span>
1229   *value = old_value;
1230   flag-&gt;set_origin(origin);
<span class="line-modified">1231   return check;</span>
<span class="line-removed">1232 }</span>
<span class="line-removed">1233 </span>
<span class="line-removed">1234 JVMFlag::Error JVMFlag::uintxAtPut(const char* name, size_t len, uintx* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1235   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1236   return uintxAtPut(result, value, origin);</span>
1237 }
1238 
<span class="line-modified">1239 JVMFlag::Error JVMFlagEx::uintxAtPut(JVMFlagsWithType flag, uintx value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1240   JVMFlag* faddr = address_of_flag(flag);</span>
1241   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uintx(), &quot;wrong flag type&quot;);
1242   return JVMFlag::uintxAtPut(faddr, &amp;value, origin);
1243 }
1244 
<span class="line-modified">1245 JVMFlag::Error JVMFlag::uint64_tAt(const char* name, size_t len, uint64_t* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1246   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1247   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1248   if (!result-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1249   *value = result-&gt;get_uint64_t();</span>
1250   return JVMFlag::SUCCESS;
1251 }
1252 
<span class="line-modified">1253 static JVMFlag::Error apply_constraint_and_check_range_uint64_t(const char* name, uint64_t new_value, bool verbose) {</span>
1254   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1255   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1256   if (range != NULL) {
1257     status = range-&gt;check_uint64_t(new_value, verbose);
1258   }
1259   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1260     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1261     if (constraint != NULL) {
1262       status = constraint-&gt;apply_uint64_t(new_value, verbose);
1263     }
1264   }
1265   return status;
1266 }
1267 
1268 JVMFlag::Error JVMFlag::uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin) {
<span class="line-removed">1269   const char* name;</span>
1270   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1271   if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1272   name = flag-&gt;_name;</span>
<span class="line-removed">1273   JVMFlag::Error check = apply_constraint_and_check_range_uint64_t(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1274   if (check != JVMFlag::SUCCESS) return check;
1275   uint64_t old_value = flag-&gt;get_uint64_t();
<span class="line-modified">1276   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1277   check = flag-&gt;set_uint64_t(*value);</span>
1278   *value = old_value;
1279   flag-&gt;set_origin(origin);
<span class="line-modified">1280   return check;</span>
<span class="line-removed">1281 }</span>
<span class="line-removed">1282 </span>
<span class="line-removed">1283 JVMFlag::Error JVMFlag::uint64_tAtPut(const char* name, size_t len, uint64_t* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1284   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1285   return uint64_tAtPut(result, value, origin);</span>
1286 }
1287 
<span class="line-modified">1288 JVMFlag::Error JVMFlagEx::uint64_tAtPut(JVMFlagsWithType flag, uint64_t value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1289   JVMFlag* faddr = address_of_flag(flag);</span>
1290   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint64_t(), &quot;wrong flag type&quot;);
1291   return JVMFlag::uint64_tAtPut(faddr, &amp;value, origin);
1292 }
1293 
<span class="line-modified">1294 JVMFlag::Error JVMFlag::size_tAt(const char* name, size_t len, size_t* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1295   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1296   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1297   if (!result-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1298   *value = result-&gt;get_size_t();</span>
1299   return JVMFlag::SUCCESS;
1300 }
1301 
<span class="line-modified">1302 static JVMFlag::Error apply_constraint_and_check_range_size_t(const char* name, size_t new_value, bool verbose) {</span>
1303   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1304   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1305   if (range != NULL) {
1306     status = range-&gt;check_size_t(new_value, verbose);
1307   }
1308   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1309     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1310     if (constraint != NULL) {
1311       status = constraint-&gt;apply_size_t(new_value, verbose);
1312     }
1313   }
1314   return status;
1315 }
1316 
1317 
1318 JVMFlag::Error JVMFlag::size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin) {
<span class="line-removed">1319   const char* name;</span>
1320   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1321   if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1322   name = flag-&gt;_name;</span>
<span class="line-removed">1323   JVMFlag::Error check = apply_constraint_and_check_range_size_t(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1324   if (check != JVMFlag::SUCCESS) return check;
1325   size_t old_value = flag-&gt;get_size_t();
<span class="line-modified">1326   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1327   check = flag-&gt;set_size_t(*value);</span>
1328   *value = old_value;
1329   flag-&gt;set_origin(origin);
<span class="line-modified">1330   return check;</span>
<span class="line-removed">1331 }</span>
<span class="line-removed">1332 </span>
<span class="line-removed">1333 JVMFlag::Error JVMFlag::size_tAtPut(const char* name, size_t len, size_t* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1334   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1335   return size_tAtPut(result, value, origin);</span>
1336 }
1337 
<span class="line-modified">1338 JVMFlag::Error JVMFlagEx::size_tAtPut(JVMFlagsWithType flag, size_t value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1339   JVMFlag* faddr = address_of_flag(flag);</span>
1340   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_size_t(), &quot;wrong flag type&quot;);
1341   return JVMFlag::size_tAtPut(faddr, &amp;value, origin);
1342 }
1343 
<span class="line-modified">1344 JVMFlag::Error JVMFlag::doubleAt(const char* name, size_t len, double* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1345   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1346   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1347   if (!result-&gt;is_double()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1348   *value = result-&gt;get_double();</span>
1349   return JVMFlag::SUCCESS;
1350 }
1351 
<span class="line-modified">1352 static JVMFlag::Error apply_constraint_and_check_range_double(const char* name, double new_value, bool verbose) {</span>
1353   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1354   JVMFlagRange* range = JVMFlagRangeList::find(name);</span>
1355   if (range != NULL) {
1356     status = range-&gt;check_double(new_value, verbose);
1357   }
1358   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1359     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(name);</span>
1360     if (constraint != NULL) {
1361       status = constraint-&gt;apply_double(new_value, verbose);
1362     }
1363   }
1364   return status;
1365 }
1366 
1367 JVMFlag::Error JVMFlag::doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin) {
<span class="line-removed">1368   const char* name;</span>
1369   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1370   if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1371   name = flag-&gt;_name;</span>
<span class="line-removed">1372   JVMFlag::Error check = apply_constraint_and_check_range_double(name, *value, !JVMFlagConstraintList::validated_after_ergo());</span>
1373   if (check != JVMFlag::SUCCESS) return check;
1374   double old_value = flag-&gt;get_double();
<span class="line-modified">1375   trace_flag_changed&lt;EventDoubleFlagChanged, double&gt;(name, old_value, *value, origin);</span>
<span class="line-modified">1376   check = flag-&gt;set_double(*value);</span>
1377   *value = old_value;
1378   flag-&gt;set_origin(origin);
<span class="line-modified">1379   return check;</span>
<span class="line-removed">1380 }</span>
<span class="line-removed">1381 </span>
<span class="line-removed">1382 JVMFlag::Error JVMFlag::doubleAtPut(const char* name, size_t len, double* value, JVMFlag::Flags origin) {</span>
<span class="line-removed">1383   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-removed">1384   return doubleAtPut(result, value, origin);</span>
1385 }
1386 
<span class="line-modified">1387 JVMFlag::Error JVMFlagEx::doubleAtPut(JVMFlagsWithType flag, double value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1388   JVMFlag* faddr = address_of_flag(flag);</span>
1389   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_double(), &quot;wrong flag type&quot;);
1390   return JVMFlag::doubleAtPut(faddr, &amp;value, origin);
1391 }
1392 
<span class="line-modified">1393 JVMFlag::Error JVMFlag::ccstrAt(const char* name, size_t len, ccstr* value, bool allow_locked, bool return_flag) {</span>
<span class="line-modified">1394   JVMFlag* result = JVMFlag::find_flag(name, len, allow_locked, return_flag);</span>
<span class="line-modified">1395   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1396   if (!result-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-removed">1397   *value = result-&gt;get_ccstr();</span>
1398   return JVMFlag::SUCCESS;
1399 }
1400 
<span class="line-modified">1401 JVMFlag::Error JVMFlag::ccstrAtPut(const char* name, size_t len, ccstr* value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1402   JVMFlag* result = JVMFlag::find_flag(name, len);</span>
<span class="line-modified">1403   if (result == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1404   if (!result-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">1405   ccstr old_value = result-&gt;get_ccstr();</span>
<span class="line-removed">1406   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(name, old_value, *value, origin);</span>
1407   char* new_value = NULL;
1408   if (*value != NULL) {
1409     new_value = os::strdup_check_oom(*value);
1410   }
<span class="line-modified">1411   JVMFlag::Error check = result-&gt;set_ccstr(new_value);</span>
<span class="line-modified">1412   if (result-&gt;is_default() &amp;&amp; old_value != NULL) {</span>
1413     // Prior value is NOT heap allocated, but was a literal constant.
1414     old_value = os::strdup_check_oom(old_value);
1415   }
1416   *value = old_value;
<span class="line-modified">1417   result-&gt;set_origin(origin);</span>
<span class="line-modified">1418   return check;</span>
1419 }
1420 
<span class="line-modified">1421 JVMFlag::Error JVMFlagEx::ccstrAtPut(JVMFlagsWithType flag, ccstr value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1422   JVMFlag* faddr = address_of_flag(flag);</span>
1423   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_ccstr(), &quot;wrong flag type&quot;);
1424   ccstr old_value = faddr-&gt;get_ccstr();
<span class="line-modified">1425   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(faddr-&gt;_name, old_value, value, origin);</span>
1426   char* new_value = os::strdup_check_oom(value);
<span class="line-modified">1427   JVMFlag::Error check = faddr-&gt;set_ccstr(new_value);</span>
1428   if (!faddr-&gt;is_default() &amp;&amp; old_value != NULL) {
1429     // Prior value is heap allocated so free it.
1430     FREE_C_HEAP_ARRAY(char, old_value);
1431   }
1432   faddr-&gt;set_origin(origin);
<span class="line-modified">1433   return check;</span>
1434 }
1435 
1436 extern &quot;C&quot; {
1437   static int compare_flags(const void* void_a, const void* void_b) {
1438     return strcmp((*((JVMFlag**) void_a))-&gt;_name, (*((JVMFlag**) void_b))-&gt;_name);
1439   }
1440 }
1441 
1442 void JVMFlag::printSetFlags(outputStream* out) {
1443   // Print which flags were set on the command line
1444   // note: this method is called before the thread structure is in place
1445   //       which means resource allocation cannot be used.
1446 
1447   // The last entry is the null entry.
1448   const size_t length = JVMFlag::numFlags - 1;
1449 
1450   // Sort
1451   JVMFlag** array = NEW_C_HEAP_ARRAY(JVMFlag*, length, mtArguments);
1452   for (size_t i = 0; i &lt; length; i++) {
1453     array[i] = &amp;flagTable[i];
</pre>
<hr />
<pre>
1458   for (size_t i = 0; i &lt; length; i++) {
1459     if (array[i]-&gt;get_origin() /* naked field! */) {
1460       array[i]-&gt;print_as_flag(out);
1461       out-&gt;print(&quot; &quot;);
1462     }
1463   }
1464   out-&gt;cr();
1465   FREE_C_HEAP_ARRAY(JVMFlag*, array);
1466 }
1467 
1468 #ifndef PRODUCT
1469 
1470 void JVMFlag::verify() {
1471   assert(Arguments::check_vm_args_consistency(), &quot;Some flag settings conflict&quot;);
1472 }
1473 
1474 #endif // PRODUCT
1475 
1476 void JVMFlag::printFlags(outputStream* out, bool withComments, bool printRanges, bool skipDefaults) {
1477   // Print the flags sorted by name
<span class="line-modified">1478   // note: this method is called before the thread structure is in place</span>
<span class="line-modified">1479   //       which means resource allocation cannot be used.</span>

1480 
1481   // The last entry is the null entry.
1482   const size_t length = JVMFlag::numFlags - 1;
1483 
<span class="line-removed">1484   // Sort</span>
<span class="line-removed">1485   JVMFlag** array = NEW_C_HEAP_ARRAY(JVMFlag*, length, mtArguments);</span>
<span class="line-removed">1486   for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-removed">1487     array[i] = &amp;flagTable[i];</span>
<span class="line-removed">1488   }</span>
<span class="line-removed">1489   qsort(array, length, sizeof(JVMFlag*), compare_flags);</span>
<span class="line-removed">1490 </span>
1491   // Print
1492   if (!printRanges) {
1493     out-&gt;print_cr(&quot;[Global flags]&quot;);
1494   } else {
1495     out-&gt;print_cr(&quot;[Global flags ranges]&quot;);
1496   }
1497 
<span class="line-modified">1498   for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-modified">1499     if (array[i]-&gt;is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; array[i]-&gt;is_default())) {</span>
<span class="line-modified">1500       array[i]-&gt;print_on(out, withComments, printRanges);</span>

















1501     }
1502   }
<span class="line-removed">1503   FREE_C_HEAP_ARRAY(JVMFlag*, array);</span>
1504 }
1505 
1506 void JVMFlag::printError(bool verbose, const char* msg, ...) {
1507   if (verbose) {
1508     va_list listPointer;
1509     va_start(listPointer, msg);
1510     jio_vfprintf(defaultStream::error_stream(), msg, listPointer);
1511     va_end(listPointer);
1512   }
1513 }
<span class="line-removed">1514 </span>
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jfr/jfrEvents.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;runtime/arguments.hpp&quot;
  29 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  30 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;

  31 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  32 #include &quot;runtime/globals_extension.hpp&quot;
  33 #include &quot;utilities/defaultStream.hpp&quot;
  34 #include &quot;utilities/stringUtils.hpp&quot;
  35 
  36 #define DEFAULT_RANGE_STR_CHUNK_SIZE 64
  37 static char* create_range_str(const char *fmt, ...) {
  38   static size_t string_length = DEFAULT_RANGE_STR_CHUNK_SIZE;
  39   static char* range_string = NEW_C_HEAP_ARRAY(char, string_length, mtLogging);
  40 
  41   int size_needed = 0;
  42   do {
  43     va_list args;
  44     va_start(args, fmt);
  45     size_needed = jio_vsnprintf(range_string, string_length, fmt, args);
  46     va_end(args);
  47 
  48     if (size_needed &lt; 0) {
  49       string_length += DEFAULT_RANGE_STR_CHUNK_SIZE;
  50       range_string = REALLOC_C_HEAP_ARRAY(char, range_string, string_length, mtLogging);
</pre>
<hr />
<pre>
  74 const char* JVMFlag::get_uint64_t_default_range_str() {
  75   return create_range_str(&quot;[ &quot; UINT64_FORMAT_W(-25) &quot; ... &quot; UINT64_FORMAT_W(25) &quot; ]&quot;, 0, uint64_t(max_juint));
  76 }
  77 
  78 const char* JVMFlag::get_size_t_default_range_str() {
  79   return create_range_str(&quot;[ &quot; SIZE_FORMAT_W(-25) &quot; ... &quot; SIZE_FORMAT_W(25) &quot; ]&quot;, 0, SIZE_MAX);
  80 }
  81 
  82 const char* JVMFlag::get_double_default_range_str() {
  83   return create_range_str(&quot;[ %-25.3f ... %25.3f ]&quot;, DBL_MIN, DBL_MAX);
  84 }
  85 
  86 static bool is_product_build() {
  87 #ifdef PRODUCT
  88   return true;
  89 #else
  90   return false;
  91 #endif
  92 }
  93 































  94 bool JVMFlag::is_bool() const {
  95   return strcmp(_type, &quot;bool&quot;) == 0;
  96 }
  97 












  98 bool JVMFlag::is_int() const {
  99   return strcmp(_type, &quot;int&quot;)  == 0;
 100 }
 101 












 102 bool JVMFlag::is_uint() const {
 103   return strcmp(_type, &quot;uint&quot;)  == 0;
 104 }
 105 












 106 bool JVMFlag::is_intx() const {
 107   return strcmp(_type, &quot;intx&quot;)  == 0;
 108 }
 109 












 110 bool JVMFlag::is_uintx() const {
 111   return strcmp(_type, &quot;uintx&quot;) == 0;
 112 }
 113 












 114 bool JVMFlag::is_uint64_t() const {
 115   return strcmp(_type, &quot;uint64_t&quot;) == 0;
 116 }
 117 












 118 bool JVMFlag::is_size_t() const {
 119   return strcmp(_type, &quot;size_t&quot;) == 0;
 120 }
 121 












 122 bool JVMFlag::is_double() const {
 123   return strcmp(_type, &quot;double&quot;) == 0;
 124 }
 125 












 126 bool JVMFlag::is_ccstr() const {
 127   return strcmp(_type, &quot;ccstr&quot;) == 0 || strcmp(_type, &quot;ccstrlist&quot;) == 0;
 128 }
 129 
 130 bool JVMFlag::ccstr_accumulates() const {
 131   return strcmp(_type, &quot;ccstrlist&quot;) == 0;
 132 }
 133 













 134 JVMFlag::Flags JVMFlag::get_origin() {
 135   return Flags(_flags &amp; VALUE_ORIGIN_MASK);
 136 }
 137 
 138 void JVMFlag::set_origin(Flags origin) {
 139   assert((origin &amp; VALUE_ORIGIN_MASK) == origin, &quot;sanity&quot;);
 140   Flags new_origin = Flags((origin == COMMAND_LINE) ? Flags(origin | ORIG_COMMAND_LINE) : origin);
 141   _flags = Flags((_flags &amp; ~VALUE_ORIGIN_MASK) | new_origin);
 142 }
 143 
 144 bool JVMFlag::is_default() {
 145   return (get_origin() == DEFAULT);
 146 }
 147 
 148 bool JVMFlag::is_ergonomic() {
 149   return (get_origin() == ERGONOMIC);
 150 }
 151 
 152 bool JVMFlag::is_command_line() {
 153   return (_flags &amp; ORIG_COMMAND_LINE) != 0;
</pre>
<hr />
<pre>
 181   return (_flags &amp; KIND_DEVELOP) != 0;
 182 }
 183 
 184 bool JVMFlag::is_read_write() const {
 185   return (_flags &amp; KIND_READ_WRITE) != 0;
 186 }
 187 
 188 /**
 189  * Returns if this flag is a constant in the binary.  Right now this is
 190  * true for notproduct and develop flags in product builds.
 191  */
 192 bool JVMFlag::is_constant_in_binary() const {
 193 #ifdef PRODUCT
 194   return is_notproduct() || is_develop();
 195 #else
 196   return false;
 197 #endif
 198 }
 199 
 200 bool JVMFlag::is_unlocker() const {
<span class="line-modified"> 201   return strcmp(_name, &quot;UnlockDiagnosticVMOptions&quot;) == 0 ||</span>
<span class="line-modified"> 202          strcmp(_name, &quot;UnlockExperimentalVMOptions&quot;) == 0;</span>

 203 }
 204 
 205 bool JVMFlag::is_unlocked() const {
 206   if (is_diagnostic()) {
 207     return UnlockDiagnosticVMOptions;
 208   }
 209   if (is_experimental()) {
 210     return UnlockExperimentalVMOptions;
 211   }
<span class="line-modified"> 212   return true;</span>
 213 }
 214 
 215 void JVMFlag::clear_diagnostic() {
 216   assert(is_diagnostic(), &quot;sanity&quot;);
 217   _flags = Flags(_flags &amp; ~KIND_DIAGNOSTIC);
 218   assert(!is_diagnostic(), &quot;sanity&quot;);
 219 }
 220 
<span class="line-added"> 221 void JVMFlag::clear_experimental() {</span>
<span class="line-added"> 222   assert(is_experimental(), &quot;sanity&quot;);</span>
<span class="line-added"> 223  _flags = Flags(_flags &amp; ~KIND_EXPERIMENTAL);</span>
<span class="line-added"> 224   assert(!is_experimental(), &quot;sanity&quot;);</span>
<span class="line-added"> 225 }</span>
<span class="line-added"> 226 </span>
<span class="line-added"> 227 void JVMFlag::set_product() {</span>
<span class="line-added"> 228   assert(!is_product(), &quot;sanity&quot;);</span>
<span class="line-added"> 229  _flags = Flags(_flags | KIND_PRODUCT);</span>
<span class="line-added"> 230   assert(is_product(), &quot;sanity&quot;);</span>
<span class="line-added"> 231 }</span>
<span class="line-added"> 232 </span>
 233 // Get custom message for this locked flag, or NULL if
 234 // none is available. Returns message type produced.
 235 JVMFlag::MsgType JVMFlag::get_locked_message(char* buf, int buflen) const {
 236   buf[0] = &#39;\0&#39;;
 237   if (is_diagnostic() &amp;&amp; !is_unlocked()) {
 238     jio_snprintf(buf, buflen,
 239                  &quot;Error: VM option &#39;%s&#39; is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions.\n&quot;
 240                  &quot;Error: The unlock option must precede &#39;%s&#39;.\n&quot;,
 241                  _name, _name);
 242     return JVMFlag::DIAGNOSTIC_FLAG_BUT_LOCKED;
 243   }
 244   if (is_experimental() &amp;&amp; !is_unlocked()) {
 245     jio_snprintf(buf, buflen,
 246                  &quot;Error: VM option &#39;%s&#39; is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions.\n&quot;
 247                  &quot;Error: The unlock option must precede &#39;%s&#39;.\n&quot;,
 248                  _name, _name);
 249     return JVMFlag::EXPERIMENTAL_FLAG_BUT_LOCKED;
 250   }
 251   if (is_develop() &amp;&amp; is_product_build()) {
 252     jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is develop and is available only in debug version of VM.\n&quot;,
 253                  _name);
 254     return JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD;
 255   }
 256   if (is_notproduct() &amp;&amp; is_product_build()) {
 257     jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is notproduct and is available only in debug version of VM.\n&quot;,
 258                  _name);
 259     return JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD;
 260   }
<span class="line-modified"> 261   return JVMFlag::NONE;</span>
 262 }
 263 
 264 bool JVMFlag::is_writeable() const {
<span class="line-modified"> 265   return is_manageable() || (is_product() &amp;&amp; is_read_write());</span>
 266 }
 267 
 268 // All flags except &quot;manageable&quot; are assumed to be internal flags.
 269 // Long term, we need to define a mechanism to specify which flags
 270 // are external/stable and change this function accordingly.
 271 bool JVMFlag::is_external() const {
<span class="line-modified"> 272   return is_manageable();</span>
 273 }
 274 
 275 // Helper function for JVMFlag::print_on().
 276 // Fills current line up to requested position.
 277 // Should the current position already be past the requested position,
 278 // one separator blank is enforced.
 279 void fill_to_pos(outputStream* st, unsigned int req_pos) {
 280   if ((unsigned int)st-&gt;position() &lt; req_pos) {
 281     st-&gt;fill_to(req_pos);  // need to fill with blanks to reach req_pos
 282   } else {
 283     st-&gt;print(&quot; &quot;);        // enforce blank separation. Previous field too long.
 284   }
 285 }
 286 
 287 void JVMFlag::print_on(outputStream* st, bool withComments, bool printRanges) {
 288   // Don&#39;t print notproduct and develop flags in a product build.
 289   if (is_constant_in_binary()) {
 290     return;
 291   }
 292 
 293   if (!printRanges) {
 294     // The command line options -XX:+PrintFlags* cause this function to be called
 295     // for each existing flag to print information pertinent to this flag. The data
 296     // is displayed in columnar form, with the following layout:
 297     //  col1 - data type, right-justified
 298     //  col2 - name,      left-justified
 299     //  col3 - &#39; =&#39;       double-char, leading space to align with possible &#39;+=&#39;
 300     //  col4 - value      left-justified
 301     //  col5 - kind       right-justified
 302     //  col6 - origin     left-justified
 303     //  col7 - comments   left-justified
 304     //
 305     //  The column widths are fixed. They are defined such that, for most cases,
 306     //  an eye-pleasing tabular output is created.
 307     //
 308     //  Sample output:
<span class="line-modified"> 309     //       bool ThreadPriorityVerbose                    = false                                     {product} {default}</span>
<span class="line-modified"> 310     //      uintx ThresholdTolerance                       = 10                                        {product} {default}</span>
<span class="line-modified"> 311     //     size_t TLABSize                                 = 0                                         {product} {default}</span>
<span class="line-modified"> 312     //      uintx SurvivorRatio                            = 8                                         {product} {default}</span>
<span class="line-modified"> 313     //     double InitialRAMPercentage                     = 1.562500                                  {product} {default}</span>
 314     //      ccstr CompileCommandFile                       = MyFile.cmd                                {product} {command line}
 315     //  ccstrlist CompileOnly                              = Method1
 316     //            CompileOnly                             += Method2                                   {product} {command line}
 317     //  |         |                                       |  |                              |                    |               |
 318     //  |         |                                       |  |                              |                    |               +-- col7
 319     //  |         |                                       |  |                              |                    +-- col6
 320     //  |         |                                       |  |                              +-- col5
 321     //  |         |                                       |  +-- col4
 322     //  |         |                                       +-- col3
 323     //  |         +-- col2
 324     //  +-- col1
 325 
 326     const unsigned int col_spacing = 1;
 327     const unsigned int col1_pos    = 0;
 328     const unsigned int col1_width  = 9;
 329     const unsigned int col2_pos    = col1_pos + col1_width + col_spacing;
 330     const unsigned int col2_width  = 39;
 331     const unsigned int col3_pos    = col2_pos + col2_width + col_spacing;
 332     const unsigned int col3_width  = 2;
 333     const unsigned int col4_pos    = col3_pos + col3_width + col_spacing;
</pre>
<hr />
<pre>
 457     RangeStrFunc func = NULL;
 458     if (is_int()) {
 459       func = JVMFlag::get_int_default_range_str;
 460     } else if (is_uint()) {
 461       func = JVMFlag::get_uint_default_range_str;
 462     } else if (is_intx()) {
 463       func = JVMFlag::get_intx_default_range_str;
 464     } else if (is_uintx()) {
 465       func = JVMFlag::get_uintx_default_range_str;
 466     } else if (is_uint64_t()) {
 467       func = JVMFlag::get_uint64_t_default_range_str;
 468     } else if (is_size_t()) {
 469       func = JVMFlag::get_size_t_default_range_str;
 470     } else if (is_double()) {
 471       func = JVMFlag::get_double_default_range_str;
 472     } else {
 473       st-&gt;print(&quot;unhandled  type %s&quot;, _type);
 474       st-&gt;cr();
 475       return;
 476     }
<span class="line-modified"> 477     JVMFlagRangeList::print(st, this, func);</span>
 478 
 479     fill_to_pos(st, col5_pos);
 480     print_kind(st, col5_width);
 481 
 482     fill_to_pos(st, col6_pos);
 483     print_origin(st, col6_width);
 484 
 485 #ifndef PRODUCT
 486     if (withComments) {
 487       fill_to_pos(st, col7_pos);
 488       st-&gt;print(&quot;%s&quot;, _doc);
 489     }
 490 #endif
 491     st-&gt;cr();
 492   }
 493 }
 494 
 495 void JVMFlag::print_kind(outputStream* st, unsigned int width) {
 496   struct Data {
 497     int flag;
</pre>
<hr />
<pre>
 551   switch(origin) {
 552     case DEFAULT:
 553       st-&gt;print(&quot;default&quot;); break;
 554     case COMMAND_LINE:
 555       st-&gt;print(&quot;command line&quot;); break;
 556     case ENVIRON_VAR:
 557       st-&gt;print(&quot;environment&quot;); break;
 558     case CONFIG_FILE:
 559       st-&gt;print(&quot;config file&quot;); break;
 560     case MANAGEMENT:
 561       st-&gt;print(&quot;management&quot;); break;
 562     case ERGONOMIC:
 563       if (_flags &amp; ORIG_COMMAND_LINE) {
 564         st-&gt;print(&quot;command line, &quot;);
 565       }
 566       st-&gt;print(&quot;ergonomic&quot;); break;
 567     case ATTACH_ON_DEMAND:
 568       st-&gt;print(&quot;attach&quot;); break;
 569     case INTERNAL:
 570       st-&gt;print(&quot;internal&quot;); break;
<span class="line-added"> 571     case JIMAGE_RESOURCE:</span>
<span class="line-added"> 572       st-&gt;print(&quot;jimage&quot;); break;</span>
 573   }
 574   st-&gt;print(&quot;}&quot;);
 575 }
 576 
 577 void JVMFlag::print_as_flag(outputStream* st) {
 578   if (is_bool()) {
 579     st-&gt;print(&quot;-XX:%s%s&quot;, get_bool() ? &quot;+&quot; : &quot;-&quot;, _name);
 580   } else if (is_int()) {
 581     st-&gt;print(&quot;-XX:%s=%d&quot;, _name, get_int());
 582   } else if (is_uint()) {
 583     st-&gt;print(&quot;-XX:%s=%u&quot;, _name, get_uint());
 584   } else if (is_intx()) {
 585     st-&gt;print(&quot;-XX:%s=&quot; INTX_FORMAT, _name, get_intx());
 586   } else if (is_uintx()) {
 587     st-&gt;print(&quot;-XX:%s=&quot; UINTX_FORMAT, _name, get_uintx());
 588   } else if (is_uint64_t()) {
 589     st-&gt;print(&quot;-XX:%s=&quot; UINT64_FORMAT, _name, get_uint64_t());
 590   } else if (is_size_t()) {
 591     st-&gt;print(&quot;-XX:%s=&quot; SIZE_FORMAT, _name, get_size_t());
 592   } else if (is_double()) {
</pre>
<hr />
<pre>
 677 
 678 #define ARCH_PRODUCT_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_PRODUCT) },
 679 #define ARCH_DIAGNOSTIC_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DIAGNOSTIC) },
 680 #define ARCH_EXPERIMENTAL_FLAG_STRUCT(   type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_EXPERIMENTAL) },
 681 #define ARCH_DEVELOP_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DEVELOP) },
 682 #define ARCH_NOTPRODUCT_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_NOT_PRODUCT) },
 683 
 684 static JVMFlag flagTable[] = {
 685   VM_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
 686            RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
 687            RUNTIME_PRODUCT_FLAG_STRUCT, \
 688            RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
 689            RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
 690            RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
 691            RUNTIME_EXPERIMENTAL_FLAG_STRUCT, \
 692            RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
 693            RUNTIME_MANAGEABLE_FLAG_STRUCT, \
 694            RUNTIME_PRODUCT_RW_FLAG_STRUCT, \
 695            RUNTIME_LP64_PRODUCT_FLAG_STRUCT, \
 696            IGNORE_RANGE, \
<span class="line-modified"> 697            IGNORE_CONSTRAINT)</span>

 698 
 699   RUNTIME_OS_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
 700                    RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
 701                    RUNTIME_PRODUCT_FLAG_STRUCT, \
 702                    RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
 703                    RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
 704                    RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
 705                    RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
 706                    IGNORE_RANGE, \
<span class="line-modified"> 707                    IGNORE_CONSTRAINT)</span>

 708 #if INCLUDE_JVMCI
 709   JVMCI_FLAGS(JVMCI_DEVELOP_FLAG_STRUCT, \
 710               JVMCI_PD_DEVELOP_FLAG_STRUCT, \
 711               JVMCI_PRODUCT_FLAG_STRUCT, \
 712               JVMCI_PD_PRODUCT_FLAG_STRUCT, \
 713               JVMCI_DIAGNOSTIC_FLAG_STRUCT, \
 714               JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT, \
 715               JVMCI_EXPERIMENTAL_FLAG_STRUCT, \
 716               JVMCI_NOTPRODUCT_FLAG_STRUCT, \
 717               IGNORE_RANGE, \
<span class="line-modified"> 718               IGNORE_CONSTRAINT)</span>

 719 #endif // INCLUDE_JVMCI
 720 #ifdef COMPILER1
 721   C1_FLAGS(C1_DEVELOP_FLAG_STRUCT, \
 722            C1_PD_DEVELOP_FLAG_STRUCT, \
 723            C1_PRODUCT_FLAG_STRUCT, \
 724            C1_PD_PRODUCT_FLAG_STRUCT, \
 725            C1_DIAGNOSTIC_FLAG_STRUCT, \
 726            C1_PD_DIAGNOSTIC_FLAG_STRUCT, \
 727            C1_NOTPRODUCT_FLAG_STRUCT, \
 728            IGNORE_RANGE, \
<span class="line-modified"> 729            IGNORE_CONSTRAINT)</span>

 730 #endif // COMPILER1
 731 #ifdef COMPILER2
 732   C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, \
 733            C2_PD_DEVELOP_FLAG_STRUCT, \
 734            C2_PRODUCT_FLAG_STRUCT, \
 735            C2_PD_PRODUCT_FLAG_STRUCT, \
 736            C2_DIAGNOSTIC_FLAG_STRUCT, \
 737            C2_PD_DIAGNOSTIC_FLAG_STRUCT, \
 738            C2_EXPERIMENTAL_FLAG_STRUCT, \
 739            C2_NOTPRODUCT_FLAG_STRUCT, \
 740            IGNORE_RANGE, \
<span class="line-modified"> 741            IGNORE_CONSTRAINT)</span>

 742 #endif // COMPILER2
 743   ARCH_FLAGS(ARCH_DEVELOP_FLAG_STRUCT, \
 744              ARCH_PRODUCT_FLAG_STRUCT, \
 745              ARCH_DIAGNOSTIC_FLAG_STRUCT, \
 746              ARCH_EXPERIMENTAL_FLAG_STRUCT, \
 747              ARCH_NOTPRODUCT_FLAG_STRUCT, \
 748              IGNORE_RANGE, \
<span class="line-modified"> 749              IGNORE_CONSTRAINT)</span>


 750   {0, NULL, NULL}
 751 };
 752 
 753 JVMFlag* JVMFlag::flags = flagTable;
 754 size_t JVMFlag::numFlags = (sizeof(flagTable) / sizeof(JVMFlag));
 755 
 756 inline bool str_equal(const char* s, size_t s_len, const char* q, size_t q_len) {
 757   if (s_len != q_len) return false;
 758   return memcmp(s, q, q_len) == 0;
 759 }
 760 
 761 // Search the flag table for a named flag
 762 JVMFlag* JVMFlag::find_flag(const char* name, size_t length, bool allow_locked, bool return_flag) {
 763   for (JVMFlag* current = &amp;flagTable[0]; current-&gt;_name != NULL; current++) {
 764     if (str_equal(current-&gt;_name, current-&gt;get_name_length(), name, length)) {
 765       // Found a matching entry.
 766       // Don&#39;t report notproduct and develop flags in product builds.
 767       if (current-&gt;is_constant_in_binary()) {
 768         return (return_flag ? current : NULL);
 769       }
</pre>
<hr />
<pre>
 805   }
 806 
 807   if (match == NULL) {
 808     return NULL;
 809   }
 810 
 811   if (!(match-&gt;is_unlocked() || match-&gt;is_unlocker())) {
 812     if (!allow_locked) {
 813       return NULL;
 814     }
 815   }
 816 
 817   if (max_score &lt; VMOptionsFuzzyMatchSimilarity) {
 818     return NULL;
 819   }
 820 
 821   return match;
 822 }
 823 
 824 // Returns the address of the index&#39;th element
<span class="line-modified"> 825 JVMFlag* JVMFlagEx::flag_from_enum(JVMFlagsEnum flag) {</span>
 826   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);
 827   return &amp;JVMFlag::flags[flag];
 828 }
 829 
<span class="line-modified"> 830 bool JVMFlagEx::is_default(JVMFlagsEnum flag) {</span>
<span class="line-modified"> 831   return flag_from_enum(flag)-&gt;is_default();</span>








 832 }
 833 
<span class="line-modified"> 834 bool JVMFlagEx::is_ergo(JVMFlagsEnum flag) {</span>
<span class="line-modified"> 835   return flag_from_enum(flag)-&gt;is_ergonomic();</span>


 836 }
 837 
<span class="line-modified"> 838 bool JVMFlagEx::is_cmdline(JVMFlagsEnum flag) {</span>
<span class="line-modified"> 839   return flag_from_enum(flag)-&gt;is_command_line();</span>



 840 }
 841 
<span class="line-modified"> 842 void JVMFlagEx::setOnCmdLine(JVMFlagsEnum flag) {</span>
<span class="line-modified"> 843   JVMFlag* faddr = flag_from_enum(flag);</span>
 844   assert(faddr != NULL, &quot;Unknown flag&quot;);
 845   faddr-&gt;set_command_line();
 846 }
 847 
 848 template&lt;class E, class T&gt;
<span class="line-modified"> 849 static void trace_flag_changed(const JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {</span>
 850   E e;
<span class="line-modified"> 851   e.set_name(flag-&gt;_name);</span>
 852   e.set_oldValue(old_value);
 853   e.set_newValue(new_value);
 854   e.set_origin(origin);
 855   e.commit();
 856 }
 857 
<span class="line-modified"> 858 static JVMFlag::Error apply_constraint_and_check_range_bool(const JVMFlag* flag, bool new_value, bool verbose) {</span>
 859   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified"> 860   JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
 861   if (constraint != NULL) {
 862     status = constraint-&gt;apply_bool(new_value, verbose);
 863   }
 864   return status;
 865 }
 866 
<span class="line-modified"> 867 JVMFlag::Error JVMFlag::boolAt(const JVMFlag* flag, bool* value) {</span>
<span class="line-modified"> 868   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified"> 869   if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified"> 870   *value = flag-&gt;get_bool();</span>

 871   return JVMFlag::SUCCESS;
 872 }
 873 
 874 JVMFlag::Error JVMFlag::boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin) {

 875   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 876   if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified"> 877   JVMFlag::Error check = apply_constraint_and_check_range_bool(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>

 878   if (check != JVMFlag::SUCCESS) return check;
 879   bool old_value = flag-&gt;get_bool();
<span class="line-modified"> 880   trace_flag_changed&lt;EventBooleanFlagChanged, bool&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified"> 881   flag-&gt;set_bool(*value);</span>
 882   *value = old_value;
 883   flag-&gt;set_origin(origin);
<span class="line-modified"> 884   return JVMFlag::SUCCESS;</span>





 885 }
 886 
<span class="line-modified"> 887 JVMFlag::Error JVMFlagEx::boolAtPut(JVMFlagsEnum flag, bool value, JVMFlag::Flags origin) {</span>
<span class="line-modified"> 888   JVMFlag* faddr = flag_from_enum(flag);</span>
 889   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_bool(), &quot;wrong flag type&quot;);
 890   return JVMFlag::boolAtPut(faddr, &amp;value, origin);
 891 }
 892 
<span class="line-modified"> 893 static JVMFlag::Error apply_constraint_and_check_range_int(const JVMFlag* flag, int new_value, bool verbose) {</span>
 894   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified"> 895   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
 896   if (range != NULL) {
 897     status = range-&gt;check_int(new_value, verbose);
 898   }
 899   if (status == JVMFlag::SUCCESS) {
<span class="line-modified"> 900     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
 901     if (constraint != NULL) {
 902       status = constraint-&gt;apply_int(new_value, verbose);
 903     }
 904   }
 905   return status;
 906 }
 907 
<span class="line-modified"> 908 JVMFlag::Error JVMFlag::intAt(const JVMFlag* flag, int* value) {</span>
<span class="line-modified"> 909   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified"> 910   if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified"> 911   *value = flag-&gt;get_int();</span>

 912   return JVMFlag::SUCCESS;
 913 }
 914 
 915 JVMFlag::Error JVMFlag::intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin) {

 916   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 917   if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified"> 918   JVMFlag::Error check = apply_constraint_and_check_range_int(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>

 919   if (check != JVMFlag::SUCCESS) return check;
 920   int old_value = flag-&gt;get_int();
<span class="line-modified"> 921   trace_flag_changed&lt;EventIntFlagChanged, s4&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified"> 922   flag-&gt;set_int(*value);</span>
 923   *value = old_value;
 924   flag-&gt;set_origin(origin);
<span class="line-modified"> 925   return JVMFlag::SUCCESS;</span>





 926 }
 927 
<span class="line-modified"> 928 JVMFlag::Error JVMFlagEx::intAtPut(JVMFlagsEnum flag, int value, JVMFlag::Flags origin) {</span>
<span class="line-modified"> 929   JVMFlag* faddr = flag_from_enum(flag);</span>
 930   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_int(), &quot;wrong flag type&quot;);
 931   return JVMFlag::intAtPut(faddr, &amp;value, origin);
 932 }
 933 
<span class="line-modified"> 934 static JVMFlag::Error apply_constraint_and_check_range_uint(const JVMFlag* flag, uint new_value, bool verbose) {</span>
 935   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified"> 936   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
 937   if (range != NULL) {
 938     status = range-&gt;check_uint(new_value, verbose);
 939   }
 940   if (status == JVMFlag::SUCCESS) {
<span class="line-modified"> 941     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
 942     if (constraint != NULL) {
 943       status = constraint-&gt;apply_uint(new_value, verbose);
 944     }
 945   }
 946   return status;
 947 }
 948 
<span class="line-modified"> 949 JVMFlag::Error JVMFlag::uintAt(const JVMFlag* flag, uint* value) {</span>
<span class="line-modified"> 950   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified"> 951   if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified"> 952   *value = flag-&gt;get_uint();</span>

 953   return JVMFlag::SUCCESS;
 954 }
 955 
 956 JVMFlag::Error JVMFlag::uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin) {

 957   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 958   if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified"> 959   JVMFlag::Error check = apply_constraint_and_check_range_uint(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>

 960   if (check != JVMFlag::SUCCESS) return check;
 961   uint old_value = flag-&gt;get_uint();
<span class="line-modified"> 962   trace_flag_changed&lt;EventUnsignedIntFlagChanged, u4&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified"> 963   flag-&gt;set_uint(*value);</span>
 964   *value = old_value;
 965   flag-&gt;set_origin(origin);
<span class="line-modified"> 966   return JVMFlag::SUCCESS;</span>





 967 }
 968 
<span class="line-modified"> 969 JVMFlag::Error JVMFlagEx::uintAtPut(JVMFlagsEnum flag, uint value, JVMFlag::Flags origin) {</span>
<span class="line-modified"> 970   JVMFlag* faddr = flag_from_enum(flag);</span>
 971   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint(), &quot;wrong flag type&quot;);
 972   return JVMFlag::uintAtPut(faddr, &amp;value, origin);
 973 }
 974 
<span class="line-modified"> 975 JVMFlag::Error JVMFlag::intxAt(const JVMFlag* flag, intx* value) {</span>
<span class="line-modified"> 976   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified"> 977   if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified"> 978   *value = flag-&gt;get_intx();</span>

 979   return JVMFlag::SUCCESS;
 980 }
 981 
<span class="line-modified"> 982 static JVMFlag::Error apply_constraint_and_check_range_intx(const JVMFlag* flag, intx new_value, bool verbose) {</span>
 983   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified"> 984   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
 985   if (range != NULL) {
 986     status = range-&gt;check_intx(new_value, verbose);
 987   }
 988   if (status == JVMFlag::SUCCESS) {
<span class="line-modified"> 989     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
 990     if (constraint != NULL) {
 991       status = constraint-&gt;apply_intx(new_value, verbose);
 992     }
 993   }
 994   return status;
 995 }
 996 
 997 JVMFlag::Error JVMFlag::intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin) {

 998   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 999   if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1000   JVMFlag::Error check = apply_constraint_and_check_range_intx(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>

1001   if (check != JVMFlag::SUCCESS) return check;
1002   intx old_value = flag-&gt;get_intx();
<span class="line-modified">1003   trace_flag_changed&lt;EventLongFlagChanged, intx&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">1004   flag-&gt;set_intx(*value);</span>
1005   *value = old_value;
1006   flag-&gt;set_origin(origin);
<span class="line-modified">1007   return JVMFlag::SUCCESS;</span>





1008 }
1009 
<span class="line-modified">1010 JVMFlag::Error JVMFlagEx::intxAtPut(JVMFlagsEnum flag, intx value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1011   JVMFlag* faddr = flag_from_enum(flag);</span>
1012   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_intx(), &quot;wrong flag type&quot;);
1013   return JVMFlag::intxAtPut(faddr, &amp;value, origin);
1014 }
1015 
<span class="line-modified">1016 JVMFlag::Error JVMFlag::uintxAt(const JVMFlag* flag, uintx* value) {</span>
<span class="line-modified">1017   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1018   if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">1019   *value = flag-&gt;get_uintx();</span>

1020   return JVMFlag::SUCCESS;
1021 }
1022 
<span class="line-modified">1023 static JVMFlag::Error apply_constraint_and_check_range_uintx(const JVMFlag* flag, uintx new_value, bool verbose) {</span>
1024   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1025   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
1026   if (range != NULL) {
1027     status = range-&gt;check_uintx(new_value, verbose);
1028   }
1029   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1030     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
1031     if (constraint != NULL) {
1032       status = constraint-&gt;apply_uintx(new_value, verbose);
1033     }
1034   }
1035   return status;
1036 }
1037 
1038 JVMFlag::Error JVMFlag::uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin) {

1039   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1040   if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1041   JVMFlag::Error check = apply_constraint_and_check_range_uintx(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>

1042   if (check != JVMFlag::SUCCESS) return check;
1043   uintx old_value = flag-&gt;get_uintx();
<span class="line-modified">1044   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">1045   flag-&gt;set_uintx(*value);</span>
1046   *value = old_value;
1047   flag-&gt;set_origin(origin);
<span class="line-modified">1048   return JVMFlag::SUCCESS;</span>





1049 }
1050 
<span class="line-modified">1051 JVMFlag::Error JVMFlagEx::uintxAtPut(JVMFlagsEnum flag, uintx value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1052   JVMFlag* faddr = flag_from_enum(flag);</span>
1053   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uintx(), &quot;wrong flag type&quot;);
1054   return JVMFlag::uintxAtPut(faddr, &amp;value, origin);
1055 }
1056 
<span class="line-modified">1057 JVMFlag::Error JVMFlag::uint64_tAt(const JVMFlag* flag, uint64_t* value) {</span>
<span class="line-modified">1058   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1059   if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">1060   *value = flag-&gt;get_uint64_t();</span>

1061   return JVMFlag::SUCCESS;
1062 }
1063 
<span class="line-modified">1064 static JVMFlag::Error apply_constraint_and_check_range_uint64_t(const JVMFlag* flag, uint64_t new_value, bool verbose) {</span>
1065   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1066   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
1067   if (range != NULL) {
1068     status = range-&gt;check_uint64_t(new_value, verbose);
1069   }
1070   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1071     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
1072     if (constraint != NULL) {
1073       status = constraint-&gt;apply_uint64_t(new_value, verbose);
1074     }
1075   }
1076   return status;
1077 }
1078 
1079 JVMFlag::Error JVMFlag::uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin) {

1080   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1081   if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1082   JVMFlag::Error check = apply_constraint_and_check_range_uint64_t(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>

1083   if (check != JVMFlag::SUCCESS) return check;
1084   uint64_t old_value = flag-&gt;get_uint64_t();
<span class="line-modified">1085   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">1086   flag-&gt;set_uint64_t(*value);</span>
1087   *value = old_value;
1088   flag-&gt;set_origin(origin);
<span class="line-modified">1089   return JVMFlag::SUCCESS;</span>





1090 }
1091 
<span class="line-modified">1092 JVMFlag::Error JVMFlagEx::uint64_tAtPut(JVMFlagsEnum flag, uint64_t value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1093   JVMFlag* faddr = flag_from_enum(flag);</span>
1094   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint64_t(), &quot;wrong flag type&quot;);
1095   return JVMFlag::uint64_tAtPut(faddr, &amp;value, origin);
1096 }
1097 
<span class="line-modified">1098 JVMFlag::Error JVMFlag::size_tAt(const JVMFlag* flag, size_t* value) {</span>
<span class="line-modified">1099   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1100   if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">1101   *value = flag-&gt;get_size_t();</span>

1102   return JVMFlag::SUCCESS;
1103 }
1104 
<span class="line-modified">1105 static JVMFlag::Error apply_constraint_and_check_range_size_t(const JVMFlag* flag, size_t new_value, bool verbose) {</span>
1106   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1107   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
1108   if (range != NULL) {
1109     status = range-&gt;check_size_t(new_value, verbose);
1110   }
1111   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1112     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
1113     if (constraint != NULL) {
1114       status = constraint-&gt;apply_size_t(new_value, verbose);
1115     }
1116   }
1117   return status;
1118 }
1119 
1120 
1121 JVMFlag::Error JVMFlag::size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin) {

1122   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1123   if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1124   JVMFlag::Error check = apply_constraint_and_check_range_size_t(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>

1125   if (check != JVMFlag::SUCCESS) return check;
1126   size_t old_value = flag-&gt;get_size_t();
<span class="line-modified">1127   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">1128   flag-&gt;set_size_t(*value);</span>
1129   *value = old_value;
1130   flag-&gt;set_origin(origin);
<span class="line-modified">1131   return JVMFlag::SUCCESS;</span>





1132 }
1133 
<span class="line-modified">1134 JVMFlag::Error JVMFlagEx::size_tAtPut(JVMFlagsEnum flag, size_t value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1135   JVMFlag* faddr = flag_from_enum(flag);</span>
1136   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_size_t(), &quot;wrong flag type&quot;);
1137   return JVMFlag::size_tAtPut(faddr, &amp;value, origin);
1138 }
1139 
<span class="line-modified">1140 JVMFlag::Error JVMFlag::doubleAt(const JVMFlag* flag, double* value) {</span>
<span class="line-modified">1141   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1142   if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">1143   *value = flag-&gt;get_double();</span>

1144   return JVMFlag::SUCCESS;
1145 }
1146 
<span class="line-modified">1147 static JVMFlag::Error apply_constraint_and_check_range_double(const JVMFlag* flag, double new_value, bool verbose) {</span>
1148   JVMFlag::Error status = JVMFlag::SUCCESS;
<span class="line-modified">1149   JVMFlagRange* range = JVMFlagRangeList::find(flag);</span>
1150   if (range != NULL) {
1151     status = range-&gt;check_double(new_value, verbose);
1152   }
1153   if (status == JVMFlag::SUCCESS) {
<span class="line-modified">1154     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);</span>
1155     if (constraint != NULL) {
1156       status = constraint-&gt;apply_double(new_value, verbose);
1157     }
1158   }
1159   return status;
1160 }
1161 
1162 JVMFlag::Error JVMFlag::doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin) {

1163   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1164   if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;
<span class="line-modified">1165   JVMFlag::Error check = apply_constraint_and_check_range_double(flag, *value, !JVMFlagConstraintList::validated_after_ergo());</span>

1166   if (check != JVMFlag::SUCCESS) return check;
1167   double old_value = flag-&gt;get_double();
<span class="line-modified">1168   trace_flag_changed&lt;EventDoubleFlagChanged, double&gt;(flag, old_value, *value, origin);</span>
<span class="line-modified">1169   flag-&gt;set_double(*value);</span>
1170   *value = old_value;
1171   flag-&gt;set_origin(origin);
<span class="line-modified">1172   return JVMFlag::SUCCESS;</span>





1173 }
1174 
<span class="line-modified">1175 JVMFlag::Error JVMFlagEx::doubleAtPut(JVMFlagsEnum flag, double value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1176   JVMFlag* faddr = flag_from_enum(flag);</span>
1177   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_double(), &quot;wrong flag type&quot;);
1178   return JVMFlag::doubleAtPut(faddr, &amp;value, origin);
1179 }
1180 
<span class="line-modified">1181 JVMFlag::Error JVMFlag::ccstrAt(const JVMFlag* flag, ccstr* value) {</span>
<span class="line-modified">1182   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1183   if (!flag-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">1184   *value = flag-&gt;get_ccstr();</span>

1185   return JVMFlag::SUCCESS;
1186 }
1187 
<span class="line-modified">1188 JVMFlag::Error JVMFlag::ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1189   if (flag == NULL) return JVMFlag::INVALID_FLAG;</span>
<span class="line-modified">1190   if (!flag-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;</span>
<span class="line-modified">1191   ccstr old_value = flag-&gt;get_ccstr();</span>
<span class="line-modified">1192   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(flag, old_value, *value, origin);</span>

1193   char* new_value = NULL;
1194   if (*value != NULL) {
1195     new_value = os::strdup_check_oom(*value);
1196   }
<span class="line-modified">1197   flag-&gt;set_ccstr(new_value);</span>
<span class="line-modified">1198   if (flag-&gt;is_default() &amp;&amp; old_value != NULL) {</span>
1199     // Prior value is NOT heap allocated, but was a literal constant.
1200     old_value = os::strdup_check_oom(old_value);
1201   }
1202   *value = old_value;
<span class="line-modified">1203   flag-&gt;set_origin(origin);</span>
<span class="line-modified">1204   return JVMFlag::SUCCESS;</span>
1205 }
1206 
<span class="line-modified">1207 JVMFlag::Error JVMFlagEx::ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin) {</span>
<span class="line-modified">1208   JVMFlag* faddr = flag_from_enum(flag);</span>
1209   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_ccstr(), &quot;wrong flag type&quot;);
1210   ccstr old_value = faddr-&gt;get_ccstr();
<span class="line-modified">1211   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(faddr, old_value, value, origin);</span>
1212   char* new_value = os::strdup_check_oom(value);
<span class="line-modified">1213   faddr-&gt;set_ccstr(new_value);</span>
1214   if (!faddr-&gt;is_default() &amp;&amp; old_value != NULL) {
1215     // Prior value is heap allocated so free it.
1216     FREE_C_HEAP_ARRAY(char, old_value);
1217   }
1218   faddr-&gt;set_origin(origin);
<span class="line-modified">1219   return JVMFlag::SUCCESS;</span>
1220 }
1221 
1222 extern &quot;C&quot; {
1223   static int compare_flags(const void* void_a, const void* void_b) {
1224     return strcmp((*((JVMFlag**) void_a))-&gt;_name, (*((JVMFlag**) void_b))-&gt;_name);
1225   }
1226 }
1227 
1228 void JVMFlag::printSetFlags(outputStream* out) {
1229   // Print which flags were set on the command line
1230   // note: this method is called before the thread structure is in place
1231   //       which means resource allocation cannot be used.
1232 
1233   // The last entry is the null entry.
1234   const size_t length = JVMFlag::numFlags - 1;
1235 
1236   // Sort
1237   JVMFlag** array = NEW_C_HEAP_ARRAY(JVMFlag*, length, mtArguments);
1238   for (size_t i = 0; i &lt; length; i++) {
1239     array[i] = &amp;flagTable[i];
</pre>
<hr />
<pre>
1244   for (size_t i = 0; i &lt; length; i++) {
1245     if (array[i]-&gt;get_origin() /* naked field! */) {
1246       array[i]-&gt;print_as_flag(out);
1247       out-&gt;print(&quot; &quot;);
1248     }
1249   }
1250   out-&gt;cr();
1251   FREE_C_HEAP_ARRAY(JVMFlag*, array);
1252 }
1253 
1254 #ifndef PRODUCT
1255 
1256 void JVMFlag::verify() {
1257   assert(Arguments::check_vm_args_consistency(), &quot;Some flag settings conflict&quot;);
1258 }
1259 
1260 #endif // PRODUCT
1261 
1262 void JVMFlag::printFlags(outputStream* out, bool withComments, bool printRanges, bool skipDefaults) {
1263   // Print the flags sorted by name
<span class="line-modified">1264   // Note: This method may be called before the thread structure is in place</span>
<span class="line-modified">1265   //       which means resource allocation cannot be used. Also, it may be</span>
<span class="line-added">1266   //       called as part of error reporting, so handle native OOMs gracefully.</span>
1267 
1268   // The last entry is the null entry.
1269   const size_t length = JVMFlag::numFlags - 1;
1270 







1271   // Print
1272   if (!printRanges) {
1273     out-&gt;print_cr(&quot;[Global flags]&quot;);
1274   } else {
1275     out-&gt;print_cr(&quot;[Global flags ranges]&quot;);
1276   }
1277 
<span class="line-modified">1278   // Sort</span>
<span class="line-modified">1279   JVMFlag** array = NEW_C_HEAP_ARRAY_RETURN_NULL(JVMFlag*, length, mtArguments);</span>
<span class="line-modified">1280   if (array != NULL) {</span>
<span class="line-added">1281     for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-added">1282       array[i] = &amp;flagTable[i];</span>
<span class="line-added">1283     }</span>
<span class="line-added">1284     qsort(array, length, sizeof(JVMFlag*), compare_flags);</span>
<span class="line-added">1285 </span>
<span class="line-added">1286     for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-added">1287       if (array[i]-&gt;is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; array[i]-&gt;is_default())) {</span>
<span class="line-added">1288         array[i]-&gt;print_on(out, withComments, printRanges);</span>
<span class="line-added">1289       }</span>
<span class="line-added">1290     }</span>
<span class="line-added">1291     FREE_C_HEAP_ARRAY(JVMFlag*, array);</span>
<span class="line-added">1292   } else {</span>
<span class="line-added">1293     // OOM? Print unsorted.</span>
<span class="line-added">1294     for (size_t i = 0; i &lt; length; i++) {</span>
<span class="line-added">1295       if (flagTable[i].is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; flagTable[i].is_default())) {</span>
<span class="line-added">1296         flagTable[i].print_on(out, withComments, printRanges);</span>
<span class="line-added">1297       }</span>
1298     }
1299   }

1300 }
1301 
1302 void JVMFlag::printError(bool verbose, const char* msg, ...) {
1303   if (verbose) {
1304     va_list listPointer;
1305     va_start(listPointer, msg);
1306     jio_vfprintf(defaultStream::error_stream(), msg, listPointer);
1307     va_end(listPointer);
1308   }
1309 }

</pre>
</td>
</tr>
</table>
<center><a href="../fieldDescriptor.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlag.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
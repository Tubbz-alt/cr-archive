diff a/src/hotspot/share/runtime/flags/jvmFlagRangeList.cpp b/src/hotspot/share/runtime/flags/jvmFlagRangeList.cpp
--- a/src/hotspot/share/runtime/flags/jvmFlagRangeList.cpp
+++ b/src/hotspot/share/runtime/flags/jvmFlagRangeList.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,32 +25,31 @@
 #include "precompiled.hpp"
 #include "jvm.h"
 #include "classfile/stringTable.hpp"
 #include "classfile/symbolTable.hpp"
 #include "gc/shared/referenceProcessor.hpp"
-#include "oops/markOop.hpp"
+#include "oops/markWord.hpp"
 #include "runtime/arguments.hpp"
 #include "runtime/flags/jvmFlag.hpp"
 #include "runtime/flags/jvmFlagConstraintList.hpp"
 #include "runtime/flags/jvmFlagRangeList.hpp"
+#include "runtime/globals.hpp"
 #include "runtime/globals_extension.hpp"
 #include "runtime/os.hpp"
 #include "runtime/task.hpp"
 #include "utilities/macros.hpp"
 
 class JVMFlagRange_int : public JVMFlagRange {
   int _min;
   int _max;
-  const int* _ptr;
 
 public:
-  // the "name" argument must be a string literal
-  JVMFlagRange_int(const char* name, const int* ptr, int min, int max)
-    : JVMFlagRange(name), _min(min), _max(max), _ptr(ptr) {}
+  JVMFlagRange_int(const JVMFlag* flag, int min, int max)
+    : JVMFlagRange(flag), _min(min), _max(max) {}
 
   JVMFlag::Error check(bool verbose = true) {
-    return check_int(*_ptr, verbose);
+    return check_int(_flag->get_int(), verbose);
   }
 
   JVMFlag::Error check_int(int value, bool verbose = true) {
     if ((value < _min) || (value > _max)) {
       JVMFlag::printError(verbose,
@@ -69,18 +68,17 @@
 };
 
 class JVMFlagRange_intx : public JVMFlagRange {
   intx _min;
   intx _max;
-  const intx* _ptr;
+
 public:
-  // the "name" argument must be a string literal
-  JVMFlagRange_intx(const char* name, const intx* ptr, intx min, intx max)
-    : JVMFlagRange(name), _min(min), _max(max), _ptr(ptr) {}
+  JVMFlagRange_intx(const JVMFlag* flag, intx min, intx max)
+    : JVMFlagRange(flag), _min(min), _max(max) {}
 
   JVMFlag::Error check(bool verbose = true) {
-    return check_intx(*_ptr, verbose);
+    return check_intx(_flag->get_intx(), verbose);
   }
 
   JVMFlag::Error check_intx(intx value, bool verbose = true) {
     if ((value < _min) || (value > _max)) {
       JVMFlag::printError(verbose,
@@ -99,19 +97,17 @@
 };
 
 class JVMFlagRange_uint : public JVMFlagRange {
   uint _min;
   uint _max;
-  const uint* _ptr;
 
 public:
-  // the "name" argument must be a string literal
-  JVMFlagRange_uint(const char* name, const uint* ptr, uint min, uint max)
-    : JVMFlagRange(name), _min(min), _max(max), _ptr(ptr) {}
+  JVMFlagRange_uint(const JVMFlag* flag, uint min, uint max)
+    : JVMFlagRange(flag), _min(min), _max(max) {}
 
   JVMFlag::Error check(bool verbose = true) {
-    return check_uint(*_ptr, verbose);
+    return check_uint(_flag->get_uint(), verbose);
   }
 
   JVMFlag::Error check_uint(uint value, bool verbose = true) {
     if ((value < _min) || (value > _max)) {
       JVMFlag::printError(verbose,
@@ -130,19 +126,17 @@
 };
 
 class JVMFlagRange_uintx : public JVMFlagRange {
   uintx _min;
   uintx _max;
-  const uintx* _ptr;
 
 public:
-  // the "name" argument must be a string literal
-  JVMFlagRange_uintx(const char* name, const uintx* ptr, uintx min, uintx max)
-    : JVMFlagRange(name), _min(min), _max(max), _ptr(ptr) {}
+  JVMFlagRange_uintx(const JVMFlag* flag, uintx min, uintx max)
+    : JVMFlagRange(flag), _min(min), _max(max) {}
 
   JVMFlag::Error check(bool verbose = true) {
-    return check_uintx(*_ptr, verbose);
+    return check_uintx(_flag->get_uintx(), verbose);
   }
 
   JVMFlag::Error check_uintx(uintx value, bool verbose = true) {
     if ((value < _min) || (value > _max)) {
       JVMFlag::printError(verbose,
@@ -161,19 +155,17 @@
 };
 
 class JVMFlagRange_uint64_t : public JVMFlagRange {
   uint64_t _min;
   uint64_t _max;
-  const uint64_t* _ptr;
 
 public:
-  // the "name" argument must be a string literal
-  JVMFlagRange_uint64_t(const char* name, const uint64_t* ptr, uint64_t min, uint64_t max)
-    : JVMFlagRange(name), _min(min), _max(max), _ptr(ptr) {}
+  JVMFlagRange_uint64_t(const JVMFlag* flag, uint64_t min, uint64_t max)
+    : JVMFlagRange(flag), _min(min), _max(max) {}
 
   JVMFlag::Error check(bool verbose = true) {
-    return check_uint64_t(*_ptr, verbose);
+    return check_uint64_t(_flag->get_uintx(), verbose);
   }
 
   JVMFlag::Error check_uint64_t(uint64_t value, bool verbose = true) {
     if ((value < _min) || (value > _max)) {
       JVMFlag::printError(verbose,
@@ -192,19 +184,17 @@
 };
 
 class JVMFlagRange_size_t : public JVMFlagRange {
   size_t _min;
   size_t _max;
-  const size_t* _ptr;
 
 public:
-  // the "name" argument must be a string literal
-  JVMFlagRange_size_t(const char* name, const size_t* ptr, size_t min, size_t max)
-    : JVMFlagRange(name), _min(min), _max(max), _ptr(ptr) {}
+  JVMFlagRange_size_t(const JVMFlag* flag, size_t min, size_t max)
+    : JVMFlagRange(flag), _min(min), _max(max) {}
 
   JVMFlag::Error check(bool verbose = true) {
-    return check_size_t(*_ptr, verbose);
+    return check_size_t(_flag->get_size_t(), verbose);
   }
 
   JVMFlag::Error check_size_t(size_t value, bool verbose = true) {
     if ((value < _min) || (value > _max)) {
       JVMFlag::printError(verbose,
@@ -223,19 +213,17 @@
 };
 
 class JVMFlagRange_double : public JVMFlagRange {
   double _min;
   double _max;
-  const double* _ptr;
 
 public:
-  // the "name" argument must be a string literal
-  JVMFlagRange_double(const char* name, const double* ptr, double min, double max)
-    : JVMFlagRange(name), _min(min), _max(max), _ptr(ptr) {}
+  JVMFlagRange_double(const JVMFlag* flag, double min, double max)
+    : JVMFlagRange(flag), _min(min), _max(max) {}
 
   JVMFlag::Error check(bool verbose = true) {
-    return check_double(*_ptr, verbose);
+    return check_double(_flag->get_double(), verbose);
   }
 
   JVMFlag::Error check_double(double value, bool verbose = true) {
     if ((value < _min) || (value > _max)) {
       JVMFlag::printError(verbose,
@@ -255,66 +243,70 @@
 
 // No constraint emitting
 void emit_range_no(...)                         { /* NOP */ }
 
 // No constraint emitting if function argument is NOT provided
-void emit_range_bool(const char* /*name*/, const bool* /*value*/)            { /* NOP */ }
-void emit_range_ccstr(const char* /*name*/, const ccstr* /*value*/)          { /* NOP */ }
-void emit_range_ccstrlist(const char* /*name*/, const ccstrlist* /*value*/)  { /* NOP */ }
-void emit_range_int(const char* /*name*/, const int* /*value*/)              { /* NOP */ }
-void emit_range_intx(const char* /*name*/, const intx* /*value*/)            { /* NOP */ }
-void emit_range_uint(const char* /*name*/, const uint* /*value*/)            { /* NOP */ }
-void emit_range_uintx(const char* /*name*/, const uintx* /*value*/)          { /* NOP */ }
-void emit_range_uint64_t(const char* /*name*/, const uint64_t* /*value*/)    { /* NOP */ }
-void emit_range_size_t(const char* /*name*/, const size_t* /*value*/)        { /* NOP */ }
-void emit_range_double(const char* /*name*/, const double* /*value*/)        { /* NOP */ }
+void emit_range_bool(const JVMFlag* /*flag*/)      { /* NOP */ }
+void emit_range_ccstr(const JVMFlag* /*flag*/)     { /* NOP */ }
+void emit_range_ccstrlist(const JVMFlag* /*flag*/) { /* NOP */ }
+void emit_range_int(const JVMFlag* /*flag*/)       { /* NOP */ }
+void emit_range_intx(const JVMFlag* /*flag*/)      { /* NOP */ }
+void emit_range_uint(const JVMFlag* /*flag*/)      { /* NOP */ }
+void emit_range_uintx(const JVMFlag* /*flag*/)     { /* NOP */ }
+void emit_range_uint64_t(const JVMFlag* /*flag*/)  { /* NOP */ }
+void emit_range_size_t(const JVMFlag* /*flag*/)    { /* NOP */ }
+void emit_range_double(const JVMFlag* /*flag*/)    { /* NOP */ }
 
 // JVMFlagRange emitting code functions if range arguments are provided
-void emit_range_int(const char* name, const int* ptr, int min, int max)       {
-  JVMFlagRangeList::add(new JVMFlagRange_int(name, ptr, min, max));
+void emit_range_int(const JVMFlag* flag, int min, int max)       {
+  JVMFlagRangeList::add(new JVMFlagRange_int(flag, min, max));
 }
-void emit_range_intx(const char* name, const intx* ptr, intx min, intx max) {
-  JVMFlagRangeList::add(new JVMFlagRange_intx(name, ptr, min, max));
+void emit_range_intx(const JVMFlag* flag, intx min, intx max) {
+  JVMFlagRangeList::add(new JVMFlagRange_intx(flag, min, max));
 }
-void emit_range_uint(const char* name, const uint* ptr, uint min, uint max) {
-  JVMFlagRangeList::add(new JVMFlagRange_uint(name, ptr, min, max));
+void emit_range_uint(const JVMFlag* flag, uint min, uint max) {
+  JVMFlagRangeList::add(new JVMFlagRange_uint(flag, min, max));
 }
-void emit_range_uintx(const char* name, const uintx* ptr, uintx min, uintx max) {
-  JVMFlagRangeList::add(new JVMFlagRange_uintx(name, ptr, min, max));
+void emit_range_uintx(const JVMFlag* flag, uintx min, uintx max) {
+  JVMFlagRangeList::add(new JVMFlagRange_uintx(flag, min, max));
 }
-void emit_range_uint64_t(const char* name, const uint64_t* ptr, uint64_t min, uint64_t max) {
-  JVMFlagRangeList::add(new JVMFlagRange_uint64_t(name, ptr, min, max));
+void emit_range_uint64_t(const JVMFlag* flag, uint64_t min, uint64_t max) {
+  JVMFlagRangeList::add(new JVMFlagRange_uint64_t(flag, min, max));
 }
-void emit_range_size_t(const char* name, const size_t* ptr, size_t min, size_t max) {
-  JVMFlagRangeList::add(new JVMFlagRange_size_t(name, ptr, min, max));
+void emit_range_size_t(const JVMFlag* flag, size_t min, size_t max) {
+  JVMFlagRangeList::add(new JVMFlagRange_size_t(flag, min, max));
 }
-void emit_range_double(const char* name, const double* ptr, double min, double max) {
-  JVMFlagRangeList::add(new JVMFlagRange_double(name, ptr, min, max));
+void emit_range_double(const JVMFlag* flag, double min, double max) {
+  JVMFlagRangeList::add(new JVMFlagRange_double(flag, min, max));
 }
 
 // Generate code to call emit_range_xxx function
-#define EMIT_RANGE_PRODUCT_FLAG(type, name, value, doc)      ); emit_range_##type(#name,&name
-#define EMIT_RANGE_DIAGNOSTIC_FLAG(type, name, value, doc)   ); emit_range_##type(#name,&name
-#define EMIT_RANGE_EXPERIMENTAL_FLAG(type, name, value, doc) ); emit_range_##type(#name,&name
-#define EMIT_RANGE_MANAGEABLE_FLAG(type, name, value, doc)   ); emit_range_##type(#name,&name
-#define EMIT_RANGE_PRODUCT_RW_FLAG(type, name, value, doc)   ); emit_range_##type(#name,&name
-#define EMIT_RANGE_PD_PRODUCT_FLAG(type, name, doc)          ); emit_range_##type(#name,&name
-#define EMIT_RANGE_PD_DIAGNOSTIC_FLAG(type, name, doc)       ); emit_range_##type(#name,&name
+#define EMIT_RANGE_START       (void)(0
+#define EMIT_RANGE(type, name) ); emit_range_##type(JVMFlagEx::flag_from_enum(FLAG_MEMBER_ENUM(name))
+#define EMIT_RANGE_NO          ); emit_range_no(0
+#define EMIT_RANGE_PRODUCT_FLAG(type, name, value, doc)      EMIT_RANGE(type, name)
+#define EMIT_RANGE_DIAGNOSTIC_FLAG(type, name, value, doc)   EMIT_RANGE(type, name)
+#define EMIT_RANGE_EXPERIMENTAL_FLAG(type, name, value, doc) EMIT_RANGE(type, name)
+#define EMIT_RANGE_MANAGEABLE_FLAG(type, name, value, doc)   EMIT_RANGE(type, name)
+#define EMIT_RANGE_PRODUCT_RW_FLAG(type, name, value, doc)   EMIT_RANGE(type, name)
+#define EMIT_RANGE_PD_PRODUCT_FLAG(type, name, doc)          EMIT_RANGE(type, name)
+#define EMIT_RANGE_PD_DIAGNOSTIC_FLAG(type, name, doc)       EMIT_RANGE(type, name)
 #ifndef PRODUCT
-#define EMIT_RANGE_DEVELOPER_FLAG(type, name, value, doc)    ); emit_range_##type(#name,&name
-#define EMIT_RANGE_PD_DEVELOPER_FLAG(type, name, doc)        ); emit_range_##type(#name,&name
-#define EMIT_RANGE_NOTPRODUCT_FLAG(type, name, value, doc)   ); emit_range_##type(#name,&name
+#define EMIT_RANGE_DEVELOPER_FLAG(type, name, value, doc)    EMIT_RANGE(type, name)
+#define EMIT_RANGE_PD_DEVELOPER_FLAG(type, name, doc)        EMIT_RANGE(type, name)
+#define EMIT_RANGE_NOTPRODUCT_FLAG(type, name, value, doc)   EMIT_RANGE(type, name)
 #else
-#define EMIT_RANGE_DEVELOPER_FLAG(type, name, value, doc)    ); emit_range_no(#name,&name
-#define EMIT_RANGE_PD_DEVELOPER_FLAG(type, name, doc)        ); emit_range_no(#name,&name
-#define EMIT_RANGE_NOTPRODUCT_FLAG(type, name, value, doc)   ); emit_range_no(#name,&name
+#define EMIT_RANGE_DEVELOPER_FLAG(type, name, value, doc)    EMIT_RANGE_NO
+#define EMIT_RANGE_PD_DEVELOPER_FLAG(type, name, doc)        EMIT_RANGE_NO
+#define EMIT_RANGE_NOTPRODUCT_FLAG(type, name, value, doc)   EMIT_RANGE_NO
 #endif
 #ifdef _LP64
-#define EMIT_RANGE_LP64_PRODUCT_FLAG(type, name, value, doc) ); emit_range_##type(#name,&name
+#define EMIT_RANGE_LP64_PRODUCT_FLAG(type, name, value, doc) EMIT_RANGE(type, name)
 #else
-#define EMIT_RANGE_LP64_PRODUCT_FLAG(type, name, value, doc) ); emit_range_no(#name,&name
+#define EMIT_RANGE_LP64_PRODUCT_FLAG(type, name, value, doc) EMIT_RANGE_NO
 #endif
+#define EMIT_RANGE_END         );
 
 // Generate func argument to pass into emit_range_xxx functions
 #define EMIT_RANGE_CHECK(a, b)                               , a, b
 
 #define INITIAL_RANGES_SIZE 379
@@ -323,96 +315,47 @@
 // Check the ranges of all flags that have them
 void JVMFlagRangeList::init(void) {
 
   _ranges = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JVMFlagRange*>(INITIAL_RANGES_SIZE, true);
 
-  emit_range_no(NULL VM_FLAGS(EMIT_RANGE_DEVELOPER_FLAG,
-                              EMIT_RANGE_PD_DEVELOPER_FLAG,
-                              EMIT_RANGE_PRODUCT_FLAG,
-                              EMIT_RANGE_PD_PRODUCT_FLAG,
-                              EMIT_RANGE_DIAGNOSTIC_FLAG,
-                              EMIT_RANGE_PD_DIAGNOSTIC_FLAG,
-                              EMIT_RANGE_EXPERIMENTAL_FLAG,
-                              EMIT_RANGE_NOTPRODUCT_FLAG,
-                              EMIT_RANGE_MANAGEABLE_FLAG,
-                              EMIT_RANGE_PRODUCT_RW_FLAG,
-                              EMIT_RANGE_LP64_PRODUCT_FLAG,
-                              EMIT_RANGE_CHECK,
-                              IGNORE_CONSTRAINT,
-                              IGNORE_WRITEABLE));
-
-  EMIT_RANGES_FOR_GLOBALS_EXT
-
-  emit_range_no(NULL ARCH_FLAGS(EMIT_RANGE_DEVELOPER_FLAG,
-                                EMIT_RANGE_PRODUCT_FLAG,
-                                EMIT_RANGE_DIAGNOSTIC_FLAG,
-                                EMIT_RANGE_EXPERIMENTAL_FLAG,
-                                EMIT_RANGE_NOTPRODUCT_FLAG,
-                                EMIT_RANGE_CHECK,
-                                IGNORE_CONSTRAINT,
-                                IGNORE_WRITEABLE));
-
-#if INCLUDE_JVMCI
-  emit_range_no(NULL JVMCI_FLAGS(EMIT_RANGE_DEVELOPER_FLAG,
-                                 EMIT_RANGE_PD_DEVELOPER_FLAG,
-                                 EMIT_RANGE_PRODUCT_FLAG,
-                                 EMIT_RANGE_PD_PRODUCT_FLAG,
-                                 EMIT_RANGE_DIAGNOSTIC_FLAG,
-                                 EMIT_RANGE_PD_DIAGNOSTIC_FLAG,
-                                 EMIT_RANGE_EXPERIMENTAL_FLAG,
-                                 EMIT_RANGE_NOTPRODUCT_FLAG,
-                                 EMIT_RANGE_CHECK,
-                                 IGNORE_CONSTRAINT,
-                                 IGNORE_WRITEABLE));
-#endif // INCLUDE_JVMCI
-
-#ifdef COMPILER1
-  emit_range_no(NULL C1_FLAGS(EMIT_RANGE_DEVELOPER_FLAG,
-                              EMIT_RANGE_PD_DEVELOPER_FLAG,
-                              EMIT_RANGE_PRODUCT_FLAG,
-                              EMIT_RANGE_PD_PRODUCT_FLAG,
-                              EMIT_RANGE_DIAGNOSTIC_FLAG,
-                              EMIT_RANGE_PD_DIAGNOSTIC_FLAG,
-                              EMIT_RANGE_NOTPRODUCT_FLAG,
-                              EMIT_RANGE_CHECK,
-                              IGNORE_CONSTRAINT,
-                              IGNORE_WRITEABLE));
-#endif // COMPILER1
-
-#ifdef COMPILER2
-  emit_range_no(NULL C2_FLAGS(EMIT_RANGE_DEVELOPER_FLAG,
-                              EMIT_RANGE_PD_DEVELOPER_FLAG,
-                              EMIT_RANGE_PRODUCT_FLAG,
-                              EMIT_RANGE_PD_PRODUCT_FLAG,
-                              EMIT_RANGE_DIAGNOSTIC_FLAG,
-                              EMIT_RANGE_PD_DIAGNOSTIC_FLAG,
-                              EMIT_RANGE_EXPERIMENTAL_FLAG,
-                              EMIT_RANGE_NOTPRODUCT_FLAG,
-                              EMIT_RANGE_CHECK,
-                              IGNORE_CONSTRAINT,
-                              IGNORE_WRITEABLE));
-#endif // COMPILER2
+  EMIT_RANGE_START
+
+  ALL_FLAGS(EMIT_RANGE_DEVELOPER_FLAG,
+            EMIT_RANGE_PD_DEVELOPER_FLAG,
+            EMIT_RANGE_PRODUCT_FLAG,
+            EMIT_RANGE_PD_PRODUCT_FLAG,
+            EMIT_RANGE_DIAGNOSTIC_FLAG,
+            EMIT_RANGE_PD_DIAGNOSTIC_FLAG,
+            EMIT_RANGE_EXPERIMENTAL_FLAG,
+            EMIT_RANGE_NOTPRODUCT_FLAG,
+            EMIT_RANGE_MANAGEABLE_FLAG,
+            EMIT_RANGE_PRODUCT_RW_FLAG,
+            EMIT_RANGE_LP64_PRODUCT_FLAG,
+            EMIT_RANGE_CHECK,
+            IGNORE_CONSTRAINT)
+
+  EMIT_RANGE_END
 }
 
-JVMFlagRange* JVMFlagRangeList::find(const char* name) {
+JVMFlagRange* JVMFlagRangeList::find(const JVMFlag* flag) {
   JVMFlagRange* found = NULL;
   for (int i=0; i<length(); i++) {
     JVMFlagRange* range = at(i);
-    if (strcmp(range->name(), name) == 0) {
+    if (range->flag() == flag) {
       found = range;
       break;
     }
   }
   return found;
 }
 
-void JVMFlagRangeList::print(outputStream* st, const char* name, RangeStrFunc default_range_str_func) {
-  JVMFlagRange* range = JVMFlagRangeList::find(name);
+void JVMFlagRangeList::print(outputStream* st, const JVMFlag* flag, RangeStrFunc default_range_str_func) {
+  JVMFlagRange* range = JVMFlagRangeList::find(flag);
   if (range != NULL) {
     range->print(st);
   } else {
-    JVMFlagConstraint* constraint = JVMFlagConstraintList::find(name);
+    JVMFlagConstraint* constraint = JVMFlagConstraintList::find(flag);
     if (constraint != NULL) {
       assert(default_range_str_func!=NULL, "default_range_str_func must be provided");
       st->print("%s", default_range_str_func());
     } else {
       st->print("[                           ...                           ]");

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/flags/jvmFlag.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="jvmFlag.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintList.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/flags/jvmFlag.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 27 
 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 class outputStream;
 32 
 33 // function type that will construct default range string
 34 typedef const char* (*RangeStrFunc)(void);
 35 
 36 struct JVMFlag {
 37   enum Flags {
 38     // latest value origin
 39     DEFAULT          = 0,
 40     COMMAND_LINE     = 1,
 41     ENVIRON_VAR      = 2,
 42     CONFIG_FILE      = 3,
 43     MANAGEMENT       = 4,
 44     ERGONOMIC        = 5,
 45     ATTACH_ON_DEMAND = 6,
 46     INTERNAL         = 7,

 47 
<span class="line-modified"> 48     LAST_VALUE_ORIGIN = INTERNAL,</span>
 49     VALUE_ORIGIN_BITS = 4,
 50     VALUE_ORIGIN_MASK = right_n_bits(VALUE_ORIGIN_BITS),
 51 
 52     // flag kind
 53     KIND_PRODUCT            = 1 &lt;&lt; 4,
 54     KIND_MANAGEABLE         = 1 &lt;&lt; 5,
 55     KIND_DIAGNOSTIC         = 1 &lt;&lt; 6,
 56     KIND_EXPERIMENTAL       = 1 &lt;&lt; 7,
 57     KIND_NOT_PRODUCT        = 1 &lt;&lt; 8,
 58     KIND_DEVELOP            = 1 &lt;&lt; 9,
 59     KIND_PLATFORM_DEPENDENT = 1 &lt;&lt; 10,
 60     KIND_READ_WRITE         = 1 &lt;&lt; 11,
 61     KIND_C1                 = 1 &lt;&lt; 12,
 62     KIND_C2                 = 1 &lt;&lt; 13,
 63     KIND_ARCH               = 1 &lt;&lt; 14,
 64     KIND_LP64_PRODUCT       = 1 &lt;&lt; 15,
 65     KIND_JVMCI              = 1 &lt;&lt; 16,
 66 
 67     // set this bit if the flag was set on the command line
 68     ORIG_COMMAND_LINE       = 1 &lt;&lt; 17,
</pre>
<hr />
<pre>
101     NONE = 0,
102     DIAGNOSTIC_FLAG_BUT_LOCKED,
103     EXPERIMENTAL_FLAG_BUT_LOCKED,
104     DEVELOPER_FLAG_BUT_PRODUCT_BUILD,
105     NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD
106   };
107 
108   const char* _type;
109   const char* _name;
110   void* _addr;
111   NOT_PRODUCT(const char* _doc;)
112   Flags _flags;
113   size_t _name_len;
114 
115   // points to all Flags static array
116   static JVMFlag* flags;
117 
118   // number of flags
119   static size_t numFlags;
120 
<span class="line-modified">121   static JVMFlag* find_flag(const char* name) { return find_flag(name, strlen(name), true, true); };</span>
<span class="line-modified">122   static JVMFlag* find_flag(const char* name, size_t length, bool allow_locked = false, bool return_flag = false);</span>












123   static JVMFlag* fuzzy_match(const char* name, size_t length, bool allow_locked = false);
124 
125   static const char* get_int_default_range_str();
126   static const char* get_uint_default_range_str();
127   static const char* get_intx_default_range_str();
128   static const char* get_uintx_default_range_str();
129   static const char* get_uint64_t_default_range_str();
130   static const char* get_size_t_default_range_str();
131   static const char* get_double_default_range_str();
132 
<span class="line-removed">133   JVMFlag::Error check_writable(bool changed);</span>
<span class="line-removed">134 </span>
135   bool is_bool() const;
<span class="line-modified">136   bool get_bool() const;</span>
<span class="line-modified">137   JVMFlag::Error set_bool(bool value);</span>
138 
139   bool is_int() const;
<span class="line-modified">140   int get_int() const;</span>
<span class="line-modified">141   JVMFlag::Error set_int(int value);</span>
142 
143   bool is_uint() const;
<span class="line-modified">144   uint get_uint() const;</span>
<span class="line-modified">145   JVMFlag::Error set_uint(uint value);</span>
146 
147   bool is_intx() const;
<span class="line-modified">148   intx get_intx() const;</span>
<span class="line-modified">149   JVMFlag::Error set_intx(intx value);</span>
150 
151   bool is_uintx() const;
<span class="line-modified">152   uintx get_uintx() const;</span>
<span class="line-modified">153   JVMFlag::Error set_uintx(uintx value);</span>
154 
155   bool is_uint64_t() const;
<span class="line-modified">156   uint64_t get_uint64_t() const;</span>
<span class="line-modified">157   JVMFlag::Error set_uint64_t(uint64_t value);</span>
158 
159   bool is_size_t() const;
<span class="line-modified">160   size_t get_size_t() const;</span>
<span class="line-modified">161   JVMFlag::Error set_size_t(size_t value);</span>
162 
163   bool is_double() const;
<span class="line-modified">164   double get_double() const;</span>
<span class="line-modified">165   JVMFlag::Error set_double(double value);</span>
166 
167   bool is_ccstr() const;
168   bool ccstr_accumulates() const;
<span class="line-modified">169   ccstr get_ccstr() const;</span>
<span class="line-modified">170   JVMFlag::Error set_ccstr(ccstr value);</span>
171 
172   Flags get_origin();
173   void set_origin(Flags origin);
174 
175   size_t get_name_length();
176 
177   bool is_default();
178   bool is_ergonomic();
179   bool is_command_line();
180   void set_command_line();
181 
182   bool is_product() const;
183   bool is_manageable() const;
184   bool is_diagnostic() const;
185   bool is_experimental() const;
186   bool is_notproduct() const;
187   bool is_develop() const;
188   bool is_read_write() const;
189 
190   bool is_constant_in_binary() const;
191 
192   bool is_unlocker() const;
193   bool is_unlocked() const;
194   bool is_writeable() const;
195   bool is_external() const;
196 
<span class="line-removed">197   bool is_unlocker_ext() const;</span>
<span class="line-removed">198   bool is_unlocked_ext() const;</span>
<span class="line-removed">199   bool is_writeable_ext() const;</span>
<span class="line-removed">200   bool is_external_ext() const;</span>
<span class="line-removed">201 </span>
202   void clear_diagnostic();


203 
204   JVMFlag::MsgType get_locked_message(char*, int) const;
205   JVMFlag::MsgType get_locked_message_ext(char*, int) const;
206 
207   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
208   void print_on(outputStream* st, bool withComments = false, bool printRanges = false);
209   void print_kind(outputStream* st, unsigned int width);
210   void print_origin(outputStream* st, unsigned int width);
211   void print_as_flag(outputStream* st);
212 
213   static const char* flag_error_str(JVMFlag::Error error);
214 
215 public:
<span class="line-modified">216   static JVMFlag::Error boolAt(const char* name, size_t len, bool* value, bool allow_locked = false, bool return_flag = false);</span>
<span class="line-removed">217   static JVMFlag::Error boolAt(const char* name, bool* value, bool allow_locked = false, bool return_flag = false)      { return boolAt(name, strlen(name), value, allow_locked, return_flag); }</span>
218   static JVMFlag::Error boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin);
<span class="line-removed">219   static JVMFlag::Error boolAtPut(const char* name, size_t len, bool* value, JVMFlag::Flags origin);</span>
<span class="line-removed">220   static JVMFlag::Error boolAtPut(const char* name, bool* value, JVMFlag::Flags origin)   { return boolAtPut(name, strlen(name), value, origin); }</span>
221 
<span class="line-modified">222   static JVMFlag::Error intAt(const char* name, size_t len, int* value, bool allow_locked = false, bool return_flag = false);</span>
<span class="line-removed">223   static JVMFlag::Error intAt(const char* name, int* value, bool allow_locked = false, bool return_flag = false)      { return intAt(name, strlen(name), value, allow_locked, return_flag); }</span>
224   static JVMFlag::Error intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin);
<span class="line-removed">225   static JVMFlag::Error intAtPut(const char* name, size_t len, int* value, JVMFlag::Flags origin);</span>
<span class="line-removed">226   static JVMFlag::Error intAtPut(const char* name, int* value, JVMFlag::Flags origin)   { return intAtPut(name, strlen(name), value, origin); }</span>
227 
<span class="line-modified">228   static JVMFlag::Error uintAt(const char* name, size_t len, uint* value, bool allow_locked = false, bool return_flag = false);</span>
<span class="line-removed">229   static JVMFlag::Error uintAt(const char* name, uint* value, bool allow_locked = false, bool return_flag = false)      { return uintAt(name, strlen(name), value, allow_locked, return_flag); }</span>
230   static JVMFlag::Error uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin);
<span class="line-removed">231   static JVMFlag::Error uintAtPut(const char* name, size_t len, uint* value, JVMFlag::Flags origin);</span>
<span class="line-removed">232   static JVMFlag::Error uintAtPut(const char* name, uint* value, JVMFlag::Flags origin)   { return uintAtPut(name, strlen(name), value, origin); }</span>
233 
<span class="line-modified">234   static JVMFlag::Error intxAt(const char* name, size_t len, intx* value, bool allow_locked = false, bool return_flag = false);</span>
<span class="line-removed">235   static JVMFlag::Error intxAt(const char* name, intx* value, bool allow_locked = false, bool return_flag = false)      { return intxAt(name, strlen(name), value, allow_locked, return_flag); }</span>
236   static JVMFlag::Error intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin);
<span class="line-removed">237   static JVMFlag::Error intxAtPut(const char* name, size_t len, intx* value, JVMFlag::Flags origin);</span>
<span class="line-removed">238   static JVMFlag::Error intxAtPut(const char* name, intx* value, JVMFlag::Flags origin)   { return intxAtPut(name, strlen(name), value, origin); }</span>
239 
<span class="line-modified">240   static JVMFlag::Error uintxAt(const char* name, size_t len, uintx* value, bool allow_locked = false, bool return_flag = false);</span>
<span class="line-removed">241   static JVMFlag::Error uintxAt(const char* name, uintx* value, bool allow_locked = false, bool return_flag = false)    { return uintxAt(name, strlen(name), value, allow_locked, return_flag); }</span>
242   static JVMFlag::Error uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin);
<span class="line-removed">243   static JVMFlag::Error uintxAtPut(const char* name, size_t len, uintx* value, JVMFlag::Flags origin);</span>
<span class="line-removed">244   static JVMFlag::Error uintxAtPut(const char* name, uintx* value, JVMFlag::Flags origin) { return uintxAtPut(name, strlen(name), value, origin); }</span>
245 
<span class="line-modified">246   static JVMFlag::Error size_tAt(const char* name, size_t len, size_t* value, bool allow_locked = false, bool return_flag = false);</span>
<span class="line-removed">247   static JVMFlag::Error size_tAt(const char* name, size_t* value, bool allow_locked = false, bool return_flag = false)    { return size_tAt(name, strlen(name), value, allow_locked, return_flag); }</span>
248   static JVMFlag::Error size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin);
<span class="line-removed">249   static JVMFlag::Error size_tAtPut(const char* name, size_t len, size_t* value, JVMFlag::Flags origin);</span>
<span class="line-removed">250   static JVMFlag::Error size_tAtPut(const char* name, size_t* value, JVMFlag::Flags origin) { return size_tAtPut(name, strlen(name), value, origin); }</span>
251 
<span class="line-modified">252   static JVMFlag::Error uint64_tAt(const char* name, size_t len, uint64_t* value, bool allow_locked = false, bool return_flag = false);</span>
<span class="line-removed">253   static JVMFlag::Error uint64_tAt(const char* name, uint64_t* value, bool allow_locked = false, bool return_flag = false) { return uint64_tAt(name, strlen(name), value, allow_locked, return_flag); }</span>
254   static JVMFlag::Error uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin);
<span class="line-removed">255   static JVMFlag::Error uint64_tAtPut(const char* name, size_t len, uint64_t* value, JVMFlag::Flags origin);</span>
<span class="line-removed">256   static JVMFlag::Error uint64_tAtPut(const char* name, uint64_t* value, JVMFlag::Flags origin) { return uint64_tAtPut(name, strlen(name), value, origin); }</span>
257 
<span class="line-modified">258   static JVMFlag::Error doubleAt(const char* name, size_t len, double* value, bool allow_locked = false, bool return_flag = false);</span>
<span class="line-removed">259   static JVMFlag::Error doubleAt(const char* name, double* value, bool allow_locked = false, bool return_flag = false)    { return doubleAt(name, strlen(name), value, allow_locked, return_flag); }</span>
260   static JVMFlag::Error doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin);
<span class="line-removed">261   static JVMFlag::Error doubleAtPut(const char* name, size_t len, double* value, JVMFlag::Flags origin);</span>
<span class="line-removed">262   static JVMFlag::Error doubleAtPut(const char* name, double* value, JVMFlag::Flags origin) { return doubleAtPut(name, strlen(name), value, origin); }</span>
263 
<span class="line-modified">264   static JVMFlag::Error ccstrAt(const char* name, size_t len, ccstr* value, bool allow_locked = false, bool return_flag = false);</span>
<span class="line-removed">265   static JVMFlag::Error ccstrAt(const char* name, ccstr* value, bool allow_locked = false, bool return_flag = false)    { return ccstrAt(name, strlen(name), value, allow_locked, return_flag); }</span>
266   // Contract:  JVMFlag will make private copy of the incoming value.
267   // Outgoing value is always malloc-ed, and caller MUST call free.
<span class="line-modified">268   static JVMFlag::Error ccstrAtPut(const char* name, size_t len, ccstr* value, JVMFlag::Flags origin);</span>
<span class="line-removed">269   static JVMFlag::Error ccstrAtPut(const char* name, ccstr* value, JVMFlag::Flags origin) { return ccstrAtPut(name, strlen(name), value, origin); }</span>
270 
<span class="line-removed">271   // Returns false if name is not a command line flag.</span>
<span class="line-removed">272   static bool wasSetOnCmdline(const char* name, bool* value);</span>
273   static void printSetFlags(outputStream* out);
274 
275   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
276   static void printFlags(outputStream* out, bool withComments, bool printRanges = false, bool skipDefaults = false);
277   static void printError(bool verbose, const char* msg, ...) ATTRIBUTE_PRINTF(2, 3);
278 
279   static void verify() PRODUCT_RETURN;
280 };
281 
282 #endif // SHARE_RUNTIME_FLAGS_JVMFLAG_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 27 
 28 #include &quot;utilities/globalDefinitions.hpp&quot;
 29 #include &quot;utilities/macros.hpp&quot;
 30 
 31 class outputStream;
 32 
 33 // function type that will construct default range string
 34 typedef const char* (*RangeStrFunc)(void);
 35 
 36 struct JVMFlag {
 37   enum Flags {
 38     // latest value origin
 39     DEFAULT          = 0,
 40     COMMAND_LINE     = 1,
 41     ENVIRON_VAR      = 2,
 42     CONFIG_FILE      = 3,
 43     MANAGEMENT       = 4,
 44     ERGONOMIC        = 5,
 45     ATTACH_ON_DEMAND = 6,
 46     INTERNAL         = 7,
<span class="line-added"> 47     JIMAGE_RESOURCE  = 8,</span>
 48 
<span class="line-modified"> 49     LAST_VALUE_ORIGIN = JIMAGE_RESOURCE,</span>
 50     VALUE_ORIGIN_BITS = 4,
 51     VALUE_ORIGIN_MASK = right_n_bits(VALUE_ORIGIN_BITS),
 52 
 53     // flag kind
 54     KIND_PRODUCT            = 1 &lt;&lt; 4,
 55     KIND_MANAGEABLE         = 1 &lt;&lt; 5,
 56     KIND_DIAGNOSTIC         = 1 &lt;&lt; 6,
 57     KIND_EXPERIMENTAL       = 1 &lt;&lt; 7,
 58     KIND_NOT_PRODUCT        = 1 &lt;&lt; 8,
 59     KIND_DEVELOP            = 1 &lt;&lt; 9,
 60     KIND_PLATFORM_DEPENDENT = 1 &lt;&lt; 10,
 61     KIND_READ_WRITE         = 1 &lt;&lt; 11,
 62     KIND_C1                 = 1 &lt;&lt; 12,
 63     KIND_C2                 = 1 &lt;&lt; 13,
 64     KIND_ARCH               = 1 &lt;&lt; 14,
 65     KIND_LP64_PRODUCT       = 1 &lt;&lt; 15,
 66     KIND_JVMCI              = 1 &lt;&lt; 16,
 67 
 68     // set this bit if the flag was set on the command line
 69     ORIG_COMMAND_LINE       = 1 &lt;&lt; 17,
</pre>
<hr />
<pre>
102     NONE = 0,
103     DIAGNOSTIC_FLAG_BUT_LOCKED,
104     EXPERIMENTAL_FLAG_BUT_LOCKED,
105     DEVELOPER_FLAG_BUT_PRODUCT_BUILD,
106     NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD
107   };
108 
109   const char* _type;
110   const char* _name;
111   void* _addr;
112   NOT_PRODUCT(const char* _doc;)
113   Flags _flags;
114   size_t _name_len;
115 
116   // points to all Flags static array
117   static JVMFlag* flags;
118 
119   // number of flags
120   static size_t numFlags;
121 
<span class="line-modified">122 private:</span>
<span class="line-modified">123   static JVMFlag* find_flag(const char* name, size_t length, bool allow_locked, bool return_flag);</span>
<span class="line-added">124 </span>
<span class="line-added">125 public:</span>
<span class="line-added">126   static JVMFlag* find_flag(const char* name) {</span>
<span class="line-added">127     return find_flag(name, strlen(name), false, false);</span>
<span class="line-added">128   }</span>
<span class="line-added">129   static const JVMFlag* find_declared_flag(const char* name, size_t length) {</span>
<span class="line-added">130     return find_flag(name, length, true, true);</span>
<span class="line-added">131   }</span>
<span class="line-added">132   static const JVMFlag* find_declared_flag(const char* name) {</span>
<span class="line-added">133     return find_declared_flag(name, strlen(name));</span>
<span class="line-added">134   }</span>
<span class="line-added">135 </span>
136   static JVMFlag* fuzzy_match(const char* name, size_t length, bool allow_locked = false);
137 
138   static const char* get_int_default_range_str();
139   static const char* get_uint_default_range_str();
140   static const char* get_intx_default_range_str();
141   static const char* get_uintx_default_range_str();
142   static const char* get_uint64_t_default_range_str();
143   static const char* get_size_t_default_range_str();
144   static const char* get_double_default_range_str();
145 


146   bool is_bool() const;
<span class="line-modified">147   bool get_bool() const                       { return *((bool*) _addr); }</span>
<span class="line-modified">148   void set_bool(bool value)                   { *((bool*) _addr) = value; }</span>
149 
150   bool is_int() const;
<span class="line-modified">151   int get_int() const                         { return *((int*) _addr); }</span>
<span class="line-modified">152   void set_int(int value)                     { *((int*) _addr) = value; }</span>
153 
154   bool is_uint() const;
<span class="line-modified">155   uint get_uint() const                       { return *((uint*) _addr); }</span>
<span class="line-modified">156   void set_uint(uint value)                   { *((uint*) _addr) = value; }</span>
157 
158   bool is_intx() const;
<span class="line-modified">159   intx get_intx() const                       { return *((intx*) _addr); }</span>
<span class="line-modified">160   void set_intx(intx value)                   { *((intx*) _addr) = value; }</span>
161 
162   bool is_uintx() const;
<span class="line-modified">163   uintx get_uintx() const                     { return *((uintx*) _addr); }</span>
<span class="line-modified">164   void set_uintx(uintx value)                 { *((uintx*) _addr) = value; }</span>
165 
166   bool is_uint64_t() const;
<span class="line-modified">167   uint64_t get_uint64_t() const               { return *((uint64_t*) _addr); }</span>
<span class="line-modified">168   void set_uint64_t(uint64_t value)           { *((uint64_t*) _addr) = value; }</span>
169 
170   bool is_size_t() const;
<span class="line-modified">171   size_t get_size_t() const                   { return *((size_t*) _addr); }</span>
<span class="line-modified">172   void set_size_t(size_t value)               { *((size_t*) _addr) = value; }</span>
173 
174   bool is_double() const;
<span class="line-modified">175   double get_double() const                   { return *((double*) _addr); }</span>
<span class="line-modified">176   void set_double(double value)               { *((double*) _addr) = value; }</span>
177 
178   bool is_ccstr() const;
179   bool ccstr_accumulates() const;
<span class="line-modified">180   ccstr get_ccstr() const                     { return *((ccstr*) _addr); }</span>
<span class="line-modified">181   void set_ccstr(ccstr value)                 { *((ccstr*) _addr) = value; }</span>
182 
183   Flags get_origin();
184   void set_origin(Flags origin);
185 
186   size_t get_name_length();
187 
188   bool is_default();
189   bool is_ergonomic();
190   bool is_command_line();
191   void set_command_line();
192 
193   bool is_product() const;
194   bool is_manageable() const;
195   bool is_diagnostic() const;
196   bool is_experimental() const;
197   bool is_notproduct() const;
198   bool is_develop() const;
199   bool is_read_write() const;
200 
201   bool is_constant_in_binary() const;
202 
203   bool is_unlocker() const;
204   bool is_unlocked() const;
205   bool is_writeable() const;
206   bool is_external() const;
207 





208   void clear_diagnostic();
<span class="line-added">209   void clear_experimental();</span>
<span class="line-added">210   void set_product();</span>
211 
212   JVMFlag::MsgType get_locked_message(char*, int) const;
213   JVMFlag::MsgType get_locked_message_ext(char*, int) const;
214 
215   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
216   void print_on(outputStream* st, bool withComments = false, bool printRanges = false);
217   void print_kind(outputStream* st, unsigned int width);
218   void print_origin(outputStream* st, unsigned int width);
219   void print_as_flag(outputStream* st);
220 
221   static const char* flag_error_str(JVMFlag::Error error);
222 
223 public:
<span class="line-modified">224   static JVMFlag::Error boolAt(const JVMFlag* flag, bool* value);</span>

225   static JVMFlag::Error boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin);


226 
<span class="line-modified">227   static JVMFlag::Error intAt(const JVMFlag* flag, int* value);</span>

228   static JVMFlag::Error intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin);


229 
<span class="line-modified">230   static JVMFlag::Error uintAt(const JVMFlag* flag, uint* value);</span>

231   static JVMFlag::Error uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin);


232 
<span class="line-modified">233   static JVMFlag::Error intxAt(const JVMFlag* flag, intx* value);</span>

234   static JVMFlag::Error intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin);


235 
<span class="line-modified">236   static JVMFlag::Error uintxAt(const JVMFlag* flag, uintx* value);</span>

237   static JVMFlag::Error uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin);


238 
<span class="line-modified">239   static JVMFlag::Error size_tAt(const JVMFlag* flag, size_t* value);</span>

240   static JVMFlag::Error size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin);


241 
<span class="line-modified">242   static JVMFlag::Error uint64_tAt(const JVMFlag* flag, uint64_t* value);</span>

243   static JVMFlag::Error uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin);


244 
<span class="line-modified">245   static JVMFlag::Error doubleAt(const JVMFlag* flag, double* value);</span>

246   static JVMFlag::Error doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin);


247 
<span class="line-modified">248   static JVMFlag::Error ccstrAt(const JVMFlag* flag, ccstr* value);</span>

249   // Contract:  JVMFlag will make private copy of the incoming value.
250   // Outgoing value is always malloc-ed, and caller MUST call free.
<span class="line-modified">251   static JVMFlag::Error ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin);</span>

252 


253   static void printSetFlags(outputStream* out);
254 
255   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
256   static void printFlags(outputStream* out, bool withComments, bool printRanges = false, bool skipDefaults = false);
257   static void printError(bool verbose, const char* msg, ...) ATTRIBUTE_PRINTF(2, 3);
258 
259   static void verify() PRODUCT_RETURN;
260 };
261 
262 #endif // SHARE_RUNTIME_FLAGS_JVMFLAG_HPP
</pre>
</td>
</tr>
</table>
<center><a href="jvmFlag.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintList.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
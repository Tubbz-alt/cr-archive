<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/stubCodeGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stackValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubCodeGenerator.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/stubCodeGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 43     p = p-&gt;_next;
 44   }
 45   return p;
 46 }
 47 
 48 const char* StubCodeDesc::name_for(address pc) {
 49   StubCodeDesc* p = desc_for(pc);
 50   return p == NULL ? NULL : p-&gt;name();
 51 }
 52 
 53 
 54 void StubCodeDesc::freeze() {
 55   assert(!_frozen, &quot;repeated freeze operation&quot;);
 56   _frozen = true;
 57 }
 58 
 59 void StubCodeDesc::print_on(outputStream* st) const {
 60   st-&gt;print(&quot;%s&quot;, group());
 61   st-&gt;print(&quot;::&quot;);
 62   st-&gt;print(&quot;%s&quot;, name());
<span class="line-modified"> 63   st-&gt;print(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;[ (%d bytes)&quot;, p2i(begin()), p2i(end()), size_in_bytes());</span>
 64 }
 65 


 66 // Implementation of StubCodeGenerator
 67 
 68 StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, bool print_code) {
 69   _masm = new MacroAssembler(code );
 70   _print_code = PrintStubCode || print_code;
 71 }
 72 
 73 StubCodeGenerator::~StubCodeGenerator() {
 74   if (PRODUCT_ONLY(_print_code) NOT_PRODUCT(true)) {
 75     CodeBuffer* cbuf = _masm-&gt;code();
 76     CodeBlob*   blob = CodeCache::find_blob_unsafe(cbuf-&gt;insts()-&gt;start());
 77     if (blob != NULL) {
 78       blob-&gt;set_strings(cbuf-&gt;strings());
 79     }
 80   }
 81 }
 82 
 83 void StubCodeGenerator::stub_prolog(StubCodeDesc* cdesc) {
 84   // default implementation - do nothing
 85 }
 86 
 87 void StubCodeGenerator::stub_epilog(StubCodeDesc* cdesc) {
 88   if (_print_code) {
 89     CodeStrings cs;
 90     ptrdiff_t offset = 0;
 91 #ifndef PRODUCT
 92     // Find the code strings in the outer CodeBuffer.
 93     CodeBuffer *outer_cbuf = _masm-&gt;code_section()-&gt;outer();
 94     cs = outer_cbuf-&gt;strings();
 95     // The offset from the start of the outer CodeBuffer to the start
 96     // of this stub.
 97     offset = cdesc-&gt;begin() - outer_cbuf-&gt;insts()-&gt;start();
 98 #endif
<span class="line-modified"> 99     cdesc-&gt;print();</span>


100     tty-&gt;cr();
<span class="line-modified">101     Disassembler::decode(cdesc-&gt;begin(), cdesc-&gt;end(), NULL, cs, offset);</span>

102     tty-&gt;cr();
103   }
104 }
105 
106 
107 // Implementation of CodeMark
108 
109 StubCodeMark::StubCodeMark(StubCodeGenerator* cgen, const char* group, const char* name) {
110   _cgen  = cgen;
111   _cdesc = new StubCodeDesc(group, name, _cgen-&gt;assembler()-&gt;pc());
112   _cgen-&gt;stub_prolog(_cdesc);
113   // define the stub&#39;s beginning (= entry point) to be after the prolog:
114   _cdesc-&gt;set_begin(_cgen-&gt;assembler()-&gt;pc());
115 }
116 
117 StubCodeMark::~StubCodeMark() {
118   _cgen-&gt;assembler()-&gt;flush();
119   _cdesc-&gt;set_end(_cgen-&gt;assembler()-&gt;pc());
120   assert(StubCodeDesc::_list == _cdesc, &quot;expected order on list&quot;);
121   _cgen-&gt;stub_epilog(_cdesc);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 43     p = p-&gt;_next;
 44   }
 45   return p;
 46 }
 47 
 48 const char* StubCodeDesc::name_for(address pc) {
 49   StubCodeDesc* p = desc_for(pc);
 50   return p == NULL ? NULL : p-&gt;name();
 51 }
 52 
 53 
 54 void StubCodeDesc::freeze() {
 55   assert(!_frozen, &quot;repeated freeze operation&quot;);
 56   _frozen = true;
 57 }
 58 
 59 void StubCodeDesc::print_on(outputStream* st) const {
 60   st-&gt;print(&quot;%s&quot;, group());
 61   st-&gt;print(&quot;::&quot;);
 62   st-&gt;print(&quot;%s&quot;, name());
<span class="line-modified"> 63   st-&gt;print(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;] (%d bytes)&quot;, p2i(begin()), p2i(end()), size_in_bytes());</span>
 64 }
 65 
<span class="line-added"> 66 void StubCodeDesc::print() const { print_on(tty); }</span>
<span class="line-added"> 67 </span>
 68 // Implementation of StubCodeGenerator
 69 
 70 StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, bool print_code) {
 71   _masm = new MacroAssembler(code );
 72   _print_code = PrintStubCode || print_code;
 73 }
 74 
 75 StubCodeGenerator::~StubCodeGenerator() {
 76   if (PRODUCT_ONLY(_print_code) NOT_PRODUCT(true)) {
 77     CodeBuffer* cbuf = _masm-&gt;code();
 78     CodeBlob*   blob = CodeCache::find_blob_unsafe(cbuf-&gt;insts()-&gt;start());
 79     if (blob != NULL) {
 80       blob-&gt;set_strings(cbuf-&gt;strings());
 81     }
 82   }
 83 }
 84 
 85 void StubCodeGenerator::stub_prolog(StubCodeDesc* cdesc) {
 86   // default implementation - do nothing
 87 }
 88 
 89 void StubCodeGenerator::stub_epilog(StubCodeDesc* cdesc) {
 90   if (_print_code) {
 91     CodeStrings cs;
 92     ptrdiff_t offset = 0;
 93 #ifndef PRODUCT
 94     // Find the code strings in the outer CodeBuffer.
 95     CodeBuffer *outer_cbuf = _masm-&gt;code_section()-&gt;outer();
 96     cs = outer_cbuf-&gt;strings();
 97     // The offset from the start of the outer CodeBuffer to the start
 98     // of this stub.
 99     offset = cdesc-&gt;begin() - outer_cbuf-&gt;insts()-&gt;start();
100 #endif
<span class="line-modified">101     ttyLocker ttyl;</span>
<span class="line-added">102     tty-&gt;print_cr(&quot;- - - [BEGIN] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&quot;);</span>
<span class="line-added">103     cdesc-&gt;print_on(tty);</span>
104     tty-&gt;cr();
<span class="line-modified">105     Disassembler::decode(cdesc-&gt;begin(), cdesc-&gt;end(), tty, cs /*, offset */);</span>
<span class="line-added">106     tty-&gt;print_cr(&quot;- - - [END] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&quot;);</span>
107     tty-&gt;cr();
108   }
109 }
110 
111 
112 // Implementation of CodeMark
113 
114 StubCodeMark::StubCodeMark(StubCodeGenerator* cgen, const char* group, const char* name) {
115   _cgen  = cgen;
116   _cdesc = new StubCodeDesc(group, name, _cgen-&gt;assembler()-&gt;pc());
117   _cgen-&gt;stub_prolog(_cdesc);
118   // define the stub&#39;s beginning (= entry point) to be after the prolog:
119   _cdesc-&gt;set_begin(_cgen-&gt;assembler()-&gt;pc());
120 }
121 
122 StubCodeMark::~StubCodeMark() {
123   _cgen-&gt;assembler()-&gt;flush();
124   _cdesc-&gt;set_end(_cgen-&gt;assembler()-&gt;pc());
125   assert(StubCodeDesc::_list == _cdesc, &quot;expected order on list&quot;);
126   _cgen-&gt;stub_epilog(_cdesc);
</pre>
</td>
</tr>
</table>
<center><a href="stackValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubCodeGenerator.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
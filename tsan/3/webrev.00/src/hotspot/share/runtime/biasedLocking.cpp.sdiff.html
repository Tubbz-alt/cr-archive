<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/biasedLocking.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="basicLock.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="biasedLocking.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/biasedLocking.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 27 #include &quot;jfr/jfrEvents.hpp&quot;
 28 #include &quot;jfr/support/jfrThreadId.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
 31 #include &quot;oops/klass.inline.hpp&quot;
<span class="line-modified"> 32 #include &quot;oops/markOop.hpp&quot;</span>
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/atomic.hpp&quot;
 35 #include &quot;runtime/basicLock.hpp&quot;
 36 #include &quot;runtime/biasedLocking.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;


 38 #include &quot;runtime/task.hpp&quot;
 39 #include &quot;runtime/threadSMR.hpp&quot;
 40 #include &quot;runtime/vframe.hpp&quot;
 41 #include &quot;runtime/vmThread.hpp&quot;
 42 #include &quot;runtime/vmOperations.hpp&quot;
 43 
 44 
 45 static bool _biased_locking_enabled = false;
 46 BiasedLockingCounters BiasedLocking::_counters;
 47 
<span class="line-modified"> 48 static GrowableArray&lt;Handle&gt;*  _preserved_oop_stack  = NULL;</span>
<span class="line-modified"> 49 static GrowableArray&lt;markOop&gt;* _preserved_mark_stack = NULL;</span>
 50 
 51 static void enable_biased_locking(InstanceKlass* k) {
<span class="line-modified"> 52   k-&gt;set_prototype_header(markOopDesc::biased_locking_prototype());</span>





 53 }
 54 
 55 class VM_EnableBiasedLocking: public VM_Operation {
<span class="line-removed"> 56  private:</span>
<span class="line-removed"> 57   bool _is_cheap_allocated;</span>
 58  public:
<span class="line-modified"> 59   VM_EnableBiasedLocking(bool is_cheap_allocated) { _is_cheap_allocated = is_cheap_allocated; }</span>
 60   VMOp_Type type() const          { return VMOp_EnableBiasedLocking; }
<span class="line-removed"> 61   Mode evaluation_mode() const    { return _is_cheap_allocated ? _async_safepoint : _safepoint; }</span>
<span class="line-removed"> 62   bool is_cheap_allocated() const { return _is_cheap_allocated; }</span>
 63 
 64   void doit() {
 65     // Iterate the class loader data dictionaries enabling biased locking for all
 66     // currently loaded classes.
 67     ClassLoaderDataGraph::dictionary_classes_do(enable_biased_locking);
 68     // Indicate that future instances should enable it as well
<span class="line-modified"> 69     _biased_locking_enabled = true;</span>
<span class="line-removed"> 70 </span>
<span class="line-removed"> 71     log_info(biasedlocking)(&quot;Biased locking enabled&quot;);</span>
 72   }
 73 
 74   bool allow_nested_vm_operations() const        { return false; }
 75 };
 76 
 77 
 78 // One-shot PeriodicTask subclass for enabling biased locking
 79 class EnableBiasedLockingTask : public PeriodicTask {
 80  public:
 81   EnableBiasedLockingTask(size_t interval_time) : PeriodicTask(interval_time) {}
 82 
 83   virtual void task() {
<span class="line-modified"> 84     // Use async VM operation to avoid blocking the Watcher thread.</span>
<span class="line-modified"> 85     // VM Thread will free C heap storage.</span>
<span class="line-removed"> 86     VM_EnableBiasedLocking *op = new VM_EnableBiasedLocking(true);</span>
<span class="line-removed"> 87     VMThread::execute(op);</span>
 88 
 89     // Reclaim our storage and disenroll ourself
 90     delete this;
 91   }
 92 };
 93 
 94 
 95 void BiasedLocking::init() {
<span class="line-modified"> 96   // If biased locking is enabled, schedule a task to fire a few</span>
<span class="line-modified"> 97   // seconds into the run which turns on biased locking for all</span>
<span class="line-modified"> 98   // currently loaded classes as well as future ones. This is a</span>
<span class="line-modified"> 99   // workaround for startup time regressions due to a large number of</span>
<span class="line-modified">100   // safepoints being taken during VM startup for bias revocation.</span>
<span class="line-modified">101   // Ideally we would have a lower cost for individual bias revocation</span>
<span class="line-removed">102   // and not need a mechanism like this.</span>
103   if (UseBiasedLocking) {
104     if (BiasedLockingStartupDelay &gt; 0) {
105       EnableBiasedLockingTask* task = new EnableBiasedLockingTask(BiasedLockingStartupDelay);
106       task-&gt;enroll();
107     } else {
<span class="line-modified">108       VM_EnableBiasedLocking op(false);</span>
<span class="line-removed">109       VMThread::execute(&amp;op);</span>
110     }
111   }
112 }
113 
114 
115 bool BiasedLocking::enabled() {
<span class="line-modified">116   return _biased_locking_enabled;</span>




117 }
118 

119 // Returns MonitorInfos for all objects locked on this thread in youngest to oldest order
120 static GrowableArray&lt;MonitorInfo*&gt;* get_or_compute_monitor_info(JavaThread* thread) {
121   GrowableArray&lt;MonitorInfo*&gt;* info = thread-&gt;cached_monitor_info();
122   if (info != NULL) {
123     return info;
124   }
125 
126   info = new GrowableArray&lt;MonitorInfo*&gt;();
127 
128   // It&#39;s possible for the thread to not have any Java frames on it,
129   // i.e., if it&#39;s the main thread and it&#39;s already returned from main()
130   if (thread-&gt;has_last_Java_frame()) {
131     RegisterMap rm(thread);
132     for (javaVFrame* vf = thread-&gt;last_java_vframe(&amp;rm); vf != NULL; vf = vf-&gt;java_sender()) {
133       GrowableArray&lt;MonitorInfo*&gt; *monitors = vf-&gt;monitors();
134       if (monitors != NULL) {
135         int len = monitors-&gt;length();
136         // Walk monitors youngest to oldest
137         for (int i = len - 1; i &gt;= 0; i--) {
138           MonitorInfo* mon_info = monitors-&gt;at(i);
139           if (mon_info-&gt;eliminated()) continue;
140           oop owner = mon_info-&gt;owner();
141           if (owner != NULL) {
142             info-&gt;append(mon_info);
143           }
144         }
145       }
146     }
147   }
148 
149   thread-&gt;set_cached_monitor_info(info);
150   return info;
151 }
152 

153 // After the call, *biased_locker will be set to obj-&gt;mark()-&gt;biased_locker() if biased_locker != NULL,
154 // AND it is a living thread. Otherwise it will not be updated, (i.e. the caller is responsible for initialization).
<span class="line-modified">155 static BiasedLocking::Condition revoke_bias(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread, JavaThread** biased_locker) {</span>
<span class="line-modified">156   markOop mark = obj-&gt;mark();</span>
<span class="line-modified">157   if (!mark-&gt;has_bias_pattern()) {</span>



158     if (log_is_enabled(Info, biasedlocking)) {
159       ResourceMark rm;
160       log_info(biasedlocking)(&quot;  (Skipping revocation of object &quot; INTPTR_FORMAT
161                               &quot;, mark &quot; INTPTR_FORMAT &quot;, type %s&quot;
162                               &quot;, requesting thread &quot; INTPTR_FORMAT
163                               &quot; because it&#39;s no longer biased)&quot;,
<span class="line-modified">164                               p2i((void *)obj), (intptr_t) mark,</span>
165                               obj-&gt;klass()-&gt;external_name(),
166                               (intptr_t) requesting_thread);
167     }
<span class="line-modified">168     return BiasedLocking::NOT_BIASED;</span>
169   }
170 
<span class="line-modified">171   uint age = mark-&gt;age();</span>
<span class="line-modified">172   markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);</span>
<span class="line-removed">173   markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);</span>
174 
175   // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
176   if (!is_bulk) {
177     ResourceMark rm;
178     log_info(biasedlocking)(&quot;Revoking bias of object &quot; INTPTR_FORMAT &quot;, mark &quot;
179                             INTPTR_FORMAT &quot;, type %s, prototype header &quot; INTPTR_FORMAT
<span class="line-modified">180                             &quot;, allow rebias %d, requesting thread &quot; INTPTR_FORMAT,</span>
181                             p2i((void *)obj),
<span class="line-modified">182                             (intptr_t) mark,</span>
183                             obj-&gt;klass()-&gt;external_name(),
<span class="line-modified">184                             (intptr_t) obj-&gt;klass()-&gt;prototype_header(),</span>
<span class="line-removed">185                             (allow_rebias ? 1 : 0),</span>
186                             (intptr_t) requesting_thread);
187   } else {
188     ResourceMark rm;
189     log_trace(biasedlocking)(&quot;Revoking bias of object &quot; INTPTR_FORMAT &quot; , mark &quot;
190                              INTPTR_FORMAT &quot; , type %s , prototype header &quot; INTPTR_FORMAT
<span class="line-modified">191                              &quot; , allow rebias %d , requesting thread &quot; INTPTR_FORMAT,</span>
192                              p2i((void *)obj),
<span class="line-modified">193                              (intptr_t) mark,</span>
194                              obj-&gt;klass()-&gt;external_name(),
<span class="line-modified">195                              (intptr_t) obj-&gt;klass()-&gt;prototype_header(),</span>
<span class="line-removed">196                              (allow_rebias ? 1 : 0),</span>
197                              (intptr_t) requesting_thread);
198   }
199 
<span class="line-modified">200   JavaThread* biased_thread = mark-&gt;biased_locker();</span>
201   if (biased_thread == NULL) {
202     // Object is anonymously biased. We can get here if, for
203     // example, we revoke the bias due to an identity hash code
204     // being computed for an object.
<span class="line-modified">205     if (!allow_rebias) {</span>
<span class="line-modified">206       obj-&gt;set_mark(unbiased_prototype);</span>
<span class="line-removed">207     }</span>
208     // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
209     if (!is_bulk) {
210       log_info(biasedlocking)(&quot;  Revoked bias of anonymously-biased object&quot;);
211     } else {
212       log_trace(biasedlocking)(&quot;  Revoked bias of anonymously-biased object&quot;);
213     }
<span class="line-modified">214     return BiasedLocking::BIAS_REVOKED;</span>
215   }
216 
217   // Handle case where the thread toward which the object was biased has exited
218   bool thread_is_alive = false;
219   if (requesting_thread == biased_thread) {
220     thread_is_alive = true;
221   } else {
222     ThreadsListHandle tlh;
223     thread_is_alive = tlh.includes(biased_thread);
224   }
225   if (!thread_is_alive) {
<span class="line-modified">226     if (allow_rebias) {</span>
<span class="line-removed">227       obj-&gt;set_mark(biased_prototype);</span>
<span class="line-removed">228     } else {</span>
<span class="line-removed">229       obj-&gt;set_mark(unbiased_prototype);</span>
<span class="line-removed">230     }</span>
231     // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
232     if (!is_bulk) {
233       log_info(biasedlocking)(&quot;  Revoked bias of object biased toward dead thread (&quot;
234                               PTR_FORMAT &quot;)&quot;, p2i(biased_thread));
235     } else {
236       log_trace(biasedlocking)(&quot;  Revoked bias of object biased toward dead thread (&quot;
237                                PTR_FORMAT &quot;)&quot;, p2i(biased_thread));
238     }
<span class="line-modified">239     return BiasedLocking::BIAS_REVOKED;</span>
240   }
241 
242   // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
243   if (!is_bulk) {
244     log_info(biasedlocking)(&quot;  Revoked bias of object biased toward live thread (&quot;
245                             PTR_FORMAT &quot;)&quot;, p2i(biased_thread));
246   } else {
247     log_trace(biasedlocking)(&quot;  Revoked bias of object biased toward live thread (&quot;
248                                PTR_FORMAT &quot;)&quot;, p2i(biased_thread));
249   }
250 
251   // Thread owning bias is alive.
252   // Check to see whether it currently owns the lock and, if so,
253   // write down the needed displaced headers to the thread&#39;s stack.
254   // Otherwise, restore the object&#39;s header either to the unlocked
255   // or unbiased state.
256   GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);
257   BasicLock* highest_lock = NULL;
258   for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
259     MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
<span class="line-modified">260     if (oopDesc::equals(mon_info-&gt;owner(), obj)) {</span>
261       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) == obj (&quot; PTR_FORMAT &quot;)&quot;,
262                                p2i((void *) mon_info-&gt;owner()),
263                                p2i((void *) obj));
<span class="line-modified">264       // Assume recursive case and fix up highest lock later</span>
<span class="line-modified">265       markOop mark = markOopDesc::encode((BasicLock*) NULL);</span>
266       highest_lock = mon_info-&gt;lock();
267       highest_lock-&gt;set_displaced_header(mark);
268     } else {
269       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) != obj (&quot; PTR_FORMAT &quot;)&quot;,
270                                p2i((void *) mon_info-&gt;owner()),
271                                p2i((void *) obj));
272     }
273   }
274   if (highest_lock != NULL) {
275     // Fix up highest lock to contain displaced header and point
276     // object at it
277     highest_lock-&gt;set_displaced_header(unbiased_prototype);
278     // Reset object header to point to displaced mark.
<span class="line-modified">279     // Must release storing the lock address for platforms without TSO</span>
280     // ordering (e.g. ppc).
<span class="line-modified">281     obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));</span>
<span class="line-modified">282     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;illegal mark state: stack lock used bias bit&quot;);</span>
283     // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
284     if (!is_bulk) {
285       log_info(biasedlocking)(&quot;  Revoked bias of currently-locked object&quot;);
286     } else {
287       log_trace(biasedlocking)(&quot;  Revoked bias of currently-locked object&quot;);
288     }
289   } else {
290     // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
291     if (!is_bulk) {
292       log_info(biasedlocking)(&quot;  Revoked bias of currently-unlocked object&quot;);
293     } else {
294       log_trace(biasedlocking)(&quot;  Revoked bias of currently-unlocked object&quot;);
295     }
<span class="line-modified">296     if (allow_rebias) {</span>
<span class="line-modified">297       obj-&gt;set_mark(biased_prototype);</span>
<span class="line-removed">298     } else {</span>
<span class="line-removed">299       // Store the unlocked value into the object&#39;s header.</span>
<span class="line-removed">300       obj-&gt;set_mark(unbiased_prototype);</span>
<span class="line-removed">301     }</span>
302   }
303 
304   // If requested, return information on which thread held the bias
305   if (biased_locker != NULL) {
306     *biased_locker = biased_thread;
307   }
<span class="line-removed">308 </span>
<span class="line-removed">309   return BiasedLocking::BIAS_REVOKED;</span>
310 }
311 
312 
313 enum HeuristicsResult {
314   HR_NOT_BIASED    = 1,
315   HR_SINGLE_REVOKE = 2,
316   HR_BULK_REBIAS   = 3,
317   HR_BULK_REVOKE   = 4
318 };
319 
320 
<span class="line-modified">321 static HeuristicsResult update_heuristics(oop o, bool allow_rebias) {</span>
<span class="line-modified">322   markOop mark = o-&gt;mark();</span>
<span class="line-modified">323   if (!mark-&gt;has_bias_pattern()) {</span>
324     return HR_NOT_BIASED;
325   }
326 
327   // Heuristics to attempt to throttle the number of revocations.
328   // Stages:
329   // 1. Revoke the biases of all objects in the heap of this type,
330   //    but allow rebiasing of those objects if unlocked.
331   // 2. Revoke the biases of all objects in the heap of this type
332   //    and don&#39;t allow rebiasing of these objects. Disable
333   //    allocation of objects of that type with the bias bit set.
334   Klass* k = o-&gt;klass();
<span class="line-modified">335   jlong cur_time = os::javaTimeMillis();</span>
336   jlong last_bulk_revocation_time = k-&gt;last_biased_lock_bulk_revocation_time();
337   int revocation_count = k-&gt;biased_lock_revocation_count();
338   if ((revocation_count &gt;= BiasedLockingBulkRebiasThreshold) &amp;&amp;
339       (revocation_count &lt;  BiasedLockingBulkRevokeThreshold) &amp;&amp;
340       (last_bulk_revocation_time != 0) &amp;&amp;
341       (cur_time - last_bulk_revocation_time &gt;= BiasedLockingDecayTime)) {
342     // This is the first revocation we&#39;ve seen in a while of an
343     // object of this type since the last time we performed a bulk
344     // rebiasing operation. The application is allocating objects in
345     // bulk which are biased toward a thread and then handing them
346     // off to another thread. We can cope with this allocation
347     // pattern via the bulk rebiasing mechanism so we reset the
348     // klass&#39;s revocation count rather than allow it to increase
349     // monotonically. If we see the need to perform another bulk
350     // rebias operation later, we will, and if subsequently we see
351     // many more revocation operations in a short period of time we
352     // will completely disable biasing for this type.
353     k-&gt;set_biased_lock_revocation_count(0);
354     revocation_count = 0;
355   }
356 
357   // Make revocation count saturate just beyond BiasedLockingBulkRevokeThreshold
358   if (revocation_count &lt;= BiasedLockingBulkRevokeThreshold) {
359     revocation_count = k-&gt;atomic_incr_biased_lock_revocation_count();
360   }
361 
362   if (revocation_count == BiasedLockingBulkRevokeThreshold) {
363     return HR_BULK_REVOKE;
364   }
365 
366   if (revocation_count == BiasedLockingBulkRebiasThreshold) {
367     return HR_BULK_REBIAS;
368   }
369 
370   return HR_SINGLE_REVOKE;
371 }
372 
373 
<span class="line-modified">374 static BiasedLocking::Condition bulk_revoke_or_rebias_at_safepoint(oop o,</span>
<span class="line-removed">375                                                                    bool bulk_rebias,</span>
<span class="line-removed">376                                                                    bool attempt_rebias_of_object,</span>
<span class="line-removed">377                                                                    JavaThread* requesting_thread) {</span>
378   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be done at safepoint&quot;);

379 
380   log_info(biasedlocking)(&quot;* Beginning bulk revocation (kind == %s) because of object &quot;
381                           INTPTR_FORMAT &quot; , mark &quot; INTPTR_FORMAT &quot; , type %s&quot;,
382                           (bulk_rebias ? &quot;rebias&quot; : &quot;revoke&quot;),
383                           p2i((void *) o),
<span class="line-modified">384                           (intptr_t) o-&gt;mark(),</span>
385                           o-&gt;klass()-&gt;external_name());
386 
<span class="line-modified">387   jlong cur_time = os::javaTimeMillis();</span>
388   o-&gt;klass()-&gt;set_last_biased_lock_bulk_revocation_time(cur_time);
389 
<span class="line-removed">390 </span>
391   Klass* k_o = o-&gt;klass();
392   Klass* klass = k_o;
393 
394   {
395     JavaThreadIteratorWithHandle jtiwh;
396 
397     if (bulk_rebias) {
398       // Use the epoch in the klass of the object to implicitly revoke
399       // all biases of objects of this data type and force them to be
400       // reacquired. However, we also need to walk the stacks of all
401       // threads and update the headers of lightweight locked objects
402       // with biases to have the current epoch.
403 
404       // If the prototype header doesn&#39;t have the bias pattern, don&#39;t
405       // try to update the epoch -- assume another VM operation came in
406       // and reset the header to the unbiased state, which will
407       // implicitly cause all existing biases to be revoked
<span class="line-modified">408       if (klass-&gt;prototype_header()-&gt;has_bias_pattern()) {</span>
<span class="line-modified">409         int prev_epoch = klass-&gt;prototype_header()-&gt;bias_epoch();</span>
<span class="line-modified">410         klass-&gt;set_prototype_header(klass-&gt;prototype_header()-&gt;incr_bias_epoch());</span>
<span class="line-modified">411         int cur_epoch = klass-&gt;prototype_header()-&gt;bias_epoch();</span>
412 
413         // Now walk all threads&#39; stacks and adjust epochs of any biased
414         // and locked objects of this data type we encounter
415         for (; JavaThread *thr = jtiwh.next(); ) {
416           GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(thr);
417           for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
418             MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
419             oop owner = mon_info-&gt;owner();
<span class="line-modified">420             markOop mark = owner-&gt;mark();</span>
<span class="line-modified">421             if ((owner-&gt;klass() == k_o) &amp;&amp; mark-&gt;has_bias_pattern()) {</span>
422               // We might have encountered this object already in the case of recursive locking
<span class="line-modified">423               assert(mark-&gt;bias_epoch() == prev_epoch || mark-&gt;bias_epoch() == cur_epoch, &quot;error in bias epoch adjustment&quot;);</span>
<span class="line-modified">424               owner-&gt;set_mark(mark-&gt;set_bias_epoch(cur_epoch));</span>
425             }
426           }
427         }
428       }
429 
430       // At this point we&#39;re done. All we have to do is potentially
431       // adjust the header of the given object to revoke its bias.
<span class="line-modified">432       revoke_bias(o, attempt_rebias_of_object &amp;&amp; klass-&gt;prototype_header()-&gt;has_bias_pattern(), true, requesting_thread, NULL);</span>
433     } else {
434       if (log_is_enabled(Info, biasedlocking)) {
435         ResourceMark rm;
436         log_info(biasedlocking)(&quot;* Disabling biased locking for type %s&quot;, klass-&gt;external_name());
437       }
438 
439       // Disable biased locking for this data type. Not only will this
440       // cause future instances to not be biased, but existing biased
441       // instances will notice that this implicitly caused their biases
442       // to be revoked.
<span class="line-modified">443       klass-&gt;set_prototype_header(markOopDesc::prototype());</span>
444 
445       // Now walk all threads&#39; stacks and forcibly revoke the biases of
446       // any locked and biased objects of this data type we encounter.
447       for (; JavaThread *thr = jtiwh.next(); ) {
448         GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(thr);
449         for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
450           MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
451           oop owner = mon_info-&gt;owner();
<span class="line-modified">452           markOop mark = owner-&gt;mark();</span>
<span class="line-modified">453           if ((owner-&gt;klass() == k_o) &amp;&amp; mark-&gt;has_bias_pattern()) {</span>
<span class="line-modified">454             revoke_bias(owner, false, true, requesting_thread, NULL);</span>
455           }
456         }
457       }
458 
459       // Must force the bias of the passed object to be forcibly revoked
460       // as well to ensure guarantees to callers
<span class="line-modified">461       revoke_bias(o, false, true, requesting_thread, NULL);</span>
462     }
463   } // ThreadsListHandle is destroyed here.
464 
465   log_info(biasedlocking)(&quot;* Ending bulk revocation&quot;);
466 
<span class="line-modified">467   BiasedLocking::Condition status_code = BiasedLocking::BIAS_REVOKED;</span>


468 
<span class="line-modified">469   if (attempt_rebias_of_object &amp;&amp;</span>
<span class="line-modified">470       o-&gt;mark()-&gt;has_bias_pattern() &amp;&amp;</span>
<span class="line-modified">471       klass-&gt;prototype_header()-&gt;has_bias_pattern()) {</span>
<span class="line-modified">472     markOop new_mark = markOopDesc::encode(requesting_thread, o-&gt;mark()-&gt;age(),</span>
<span class="line-modified">473                                            klass-&gt;prototype_header()-&gt;bias_epoch());</span>
<span class="line-modified">474     o-&gt;set_mark(new_mark);</span>
<span class="line-modified">475     status_code = BiasedLocking::BIAS_REVOKED_AND_REBIASED;</span>
<span class="line-modified">476     log_info(biasedlocking)(&quot;  Rebiased object toward thread &quot; INTPTR_FORMAT, (intptr_t) requesting_thread);</span>
477   }

478 
<span class="line-removed">479   assert(!o-&gt;mark()-&gt;has_bias_pattern() ||</span>
<span class="line-removed">480          (attempt_rebias_of_object &amp;&amp; (o-&gt;mark()-&gt;biased_locker() == requesting_thread)),</span>
<span class="line-removed">481          &quot;bug in bulk bias revocation&quot;);</span>
482 
<span class="line-modified">483   return status_code;</span>
<span class="line-modified">484 }</span>




485 







486 
<span class="line-modified">487 static void clean_up_cached_monitor_info() {</span>
<span class="line-modified">488   // Walk the thread list clearing out the cached monitors</span>
<span class="line-modified">489   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {</span>
<span class="line-modified">490     thr-&gt;set_cached_monitor_info(NULL);</span>


491   }
<span class="line-modified">492 }</span>








493 
494 
<span class="line-modified">495 class VM_RevokeBias : public VM_Operation {</span>
496 protected:
<span class="line-modified">497   Handle* _obj;</span>
<span class="line-removed">498   GrowableArray&lt;Handle&gt;* _objs;</span>
499   JavaThread* _requesting_thread;

500   BiasedLocking::Condition _status_code;
501   traceid _biased_locker_id;
502 
503 public:
<span class="line-modified">504   VM_RevokeBias(Handle* obj, JavaThread* requesting_thread)</span>
<span class="line-modified">505     : _obj(obj)</span>
<span class="line-modified">506     , _objs(NULL)</span>
507     , _requesting_thread(requesting_thread)

508     , _status_code(BiasedLocking::NOT_BIASED)
509     , _biased_locker_id(0) {}
510 
<span class="line-modified">511   VM_RevokeBias(GrowableArray&lt;Handle&gt;* objs, JavaThread* requesting_thread)</span>
<span class="line-modified">512     : _obj(NULL)</span>
<span class="line-removed">513     , _objs(objs)</span>
<span class="line-removed">514     , _requesting_thread(requesting_thread)</span>
<span class="line-removed">515     , _status_code(BiasedLocking::NOT_BIASED)</span>
<span class="line-removed">516     , _biased_locker_id(0) {}</span>
517 
<span class="line-modified">518   virtual VMOp_Type type() const { return VMOp_RevokeBias; }</span>

519 
<span class="line-modified">520   virtual bool doit_prologue() {</span>
<span class="line-modified">521     // Verify that there is actual work to do since the callers just</span>
<span class="line-removed">522     // give us locked object(s). If we don&#39;t find any biased objects</span>
<span class="line-removed">523     // there is nothing to do and we avoid a safepoint.</span>
<span class="line-removed">524     if (_obj != NULL) {</span>
<span class="line-removed">525       markOop mark = (*_obj)()-&gt;mark();</span>
<span class="line-removed">526       if (mark-&gt;has_bias_pattern()) {</span>
<span class="line-removed">527         return true;</span>
<span class="line-removed">528       }</span>
<span class="line-removed">529     } else {</span>
<span class="line-removed">530       for ( int i = 0 ; i &lt; _objs-&gt;length(); i++ ) {</span>
<span class="line-removed">531         markOop mark = (_objs-&gt;at(i))()-&gt;mark();</span>
<span class="line-removed">532         if (mark-&gt;has_bias_pattern()) {</span>
<span class="line-removed">533           return true;</span>
<span class="line-removed">534         }</span>
<span class="line-removed">535       }</span>
536     }
<span class="line-removed">537     return false;</span>
<span class="line-removed">538   }</span>
539 
<span class="line-modified">540   virtual void doit() {</span>
<span class="line-modified">541     if (_obj != NULL) {</span>
<span class="line-modified">542       log_info(biasedlocking)(&quot;Revoking bias with potentially per-thread safepoint:&quot;);</span>
<span class="line-modified">543       JavaThread* biased_locker = NULL;</span>
<span class="line-modified">544       _status_code = revoke_bias((*_obj)(), false, false, _requesting_thread, &amp;biased_locker);</span>
<span class="line-modified">545       if (biased_locker != NULL) {</span>
<span class="line-modified">546         _biased_locker_id = JFR_THREAD_ID(biased_locker);</span>



547       }
<span class="line-removed">548       clean_up_cached_monitor_info();</span>
549       return;
<span class="line-removed">550     } else {</span>
<span class="line-removed">551       log_info(biasedlocking)(&quot;Revoking bias with global safepoint:&quot;);</span>
<span class="line-removed">552       BiasedLocking::revoke_at_safepoint(_objs);</span>
553     }


























554   }
555 
556   BiasedLocking::Condition status_code() const {
557     return _status_code;
558   }
559 
560   traceid biased_locker() const {
561     return _biased_locker_id;
562   }
563 };
564 
565 
<span class="line-removed">566 class VM_BulkRevokeBias : public VM_RevokeBias {</span>
<span class="line-removed">567 private:</span>
<span class="line-removed">568   bool _bulk_rebias;</span>
<span class="line-removed">569   bool _attempt_rebias_of_object;</span>
<span class="line-removed">570 </span>
<span class="line-removed">571 public:</span>
<span class="line-removed">572   VM_BulkRevokeBias(Handle* obj, JavaThread* requesting_thread,</span>
<span class="line-removed">573                     bool bulk_rebias,</span>
<span class="line-removed">574                     bool attempt_rebias_of_object)</span>
<span class="line-removed">575     : VM_RevokeBias(obj, requesting_thread)</span>
<span class="line-removed">576     , _bulk_rebias(bulk_rebias)</span>
<span class="line-removed">577     , _attempt_rebias_of_object(attempt_rebias_of_object) {}</span>
<span class="line-removed">578 </span>
<span class="line-removed">579   virtual VMOp_Type type() const { return VMOp_BulkRevokeBias; }</span>
<span class="line-removed">580   virtual bool doit_prologue()   { return true; }</span>
<span class="line-removed">581 </span>
<span class="line-removed">582   virtual void doit() {</span>
<span class="line-removed">583     _status_code = bulk_revoke_or_rebias_at_safepoint((*_obj)(), _bulk_rebias, _attempt_rebias_of_object, _requesting_thread);</span>
<span class="line-removed">584     clean_up_cached_monitor_info();</span>
<span class="line-removed">585   }</span>
<span class="line-removed">586 };</span>
<span class="line-removed">587 </span>
<span class="line-removed">588 template &lt;typename E&gt;</span>
<span class="line-removed">589 static void set_safepoint_id(E* event) {</span>
<span class="line-removed">590   assert(event != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">591   // Subtract 1 to match the id of events committed inside the safepoint</span>
<span class="line-removed">592   event-&gt;set_safepointId(SafepointSynchronize::safepoint_counter() - 1);</span>
<span class="line-removed">593 }</span>
<span class="line-removed">594 </span>
595 static void post_self_revocation_event(EventBiasedLockSelfRevocation* event, Klass* k) {
596   assert(event != NULL, &quot;invariant&quot;);
597   assert(k != NULL, &quot;invariant&quot;);
598   assert(event-&gt;should_commit(), &quot;invariant&quot;);
599   event-&gt;set_lockClass(k);
600   event-&gt;commit();
601 }
602 
<span class="line-modified">603 static void post_revocation_event(EventBiasedLockRevocation* event, Klass* k, VM_RevokeBias* revoke) {</span>
604   assert(event != NULL, &quot;invariant&quot;);
605   assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified">606   assert(revoke != NULL, &quot;invariant&quot;);</span>
607   assert(event-&gt;should_commit(), &quot;invariant&quot;);
608   event-&gt;set_lockClass(k);
<span class="line-modified">609   set_safepoint_id(event);</span>
<span class="line-modified">610   event-&gt;set_previousOwner(revoke-&gt;biased_locker());</span>
611   event-&gt;commit();
612 }
613 
<span class="line-modified">614 static void post_class_revocation_event(EventBiasedLockClassRevocation* event, Klass* k, bool disabled_bias) {</span>
615   assert(event != NULL, &quot;invariant&quot;);
616   assert(k != NULL, &quot;invariant&quot;);

617   assert(event-&gt;should_commit(), &quot;invariant&quot;);
618   event-&gt;set_revokedClass(k);
<span class="line-modified">619   event-&gt;set_disableBiasing(disabled_bias);</span>
<span class="line-modified">620   set_safepoint_id(event);</span>
621   event-&gt;commit();
622 }
623 
<span class="line-removed">624 BiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS) {</span>
<span class="line-removed">625   assert(!SafepointSynchronize::is_at_safepoint(), &quot;must not be called while at safepoint&quot;);</span>
626 
<span class="line-modified">627   // We can revoke the biases of anonymously-biased objects</span>
<span class="line-modified">628   // efficiently enough that we should not cause these revocations to</span>
<span class="line-modified">629   // update the heuristics because doing so may cause unwanted bulk</span>
<span class="line-modified">630   // revocations (which are expensive) to occur.</span>
<span class="line-modified">631   markOop mark = obj-&gt;mark();</span>
<span class="line-modified">632   if (mark-&gt;is_biased_anonymously() &amp;&amp; !attempt_rebias) {</span>
<span class="line-modified">633     // We are probably trying to revoke the bias of this object due to</span>
<span class="line-modified">634     // an identity hash code computation. Try to revoke the bias</span>
<span class="line-modified">635     // without a safepoint. This is possible if we can successfully</span>
<span class="line-modified">636     // compare-and-exchange an unbiased header into the mark word of</span>
<span class="line-modified">637     // the object, meaning that no other thread has raced to acquire</span>
<span class="line-modified">638     // the bias of the object.</span>
<span class="line-modified">639     markOop biased_value       = mark;</span>
<span class="line-modified">640     markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span>
<span class="line-modified">641     markOop res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);</span>
<span class="line-modified">642     if (res_mark == biased_value) {</span>
<span class="line-modified">643       return BIAS_REVOKED;</span>



644     }
<span class="line-modified">645   } else if (mark-&gt;has_bias_pattern()) {</span>
<span class="line-modified">646     Klass* k = obj-&gt;klass();</span>
<span class="line-modified">647     markOop prototype_header = k-&gt;prototype_header();</span>
<span class="line-modified">648     if (!prototype_header-&gt;has_bias_pattern()) {</span>
<span class="line-modified">649       // This object has a stale bias from before the bulk revocation</span>
<span class="line-modified">650       // for this data type occurred. It&#39;s pointless to update the</span>
<span class="line-modified">651       // heuristics at this point so simply update the header with a</span>
<span class="line-modified">652       // CAS. If we fail this race, the object&#39;s bias has been revoked</span>
<span class="line-modified">653       // by another thread so we simply return and let the caller deal</span>
<span class="line-modified">654       // with it.</span>
<span class="line-modified">655       markOop biased_value       = mark;</span>
<span class="line-modified">656       markOop res_mark = obj-&gt;cas_set_mark(prototype_header, mark);</span>
<span class="line-modified">657       assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;even if we raced, should still be revoked&quot;);</span>
<span class="line-modified">658       return BIAS_REVOKED;</span>
<span class="line-modified">659     } else if (prototype_header-&gt;bias_epoch() != mark-&gt;bias_epoch()) {</span>
<span class="line-modified">660       // The epoch of this biasing has expired indicating that the</span>
<span class="line-modified">661       // object is effectively unbiased. Depending on whether we need</span>
<span class="line-modified">662       // to rebias or revoke the bias of this object we can do it</span>
<span class="line-modified">663       // efficiently enough with a CAS that we shouldn&#39;t update the</span>
<span class="line-modified">664       // heuristics. This is normally done in the assembly code but we</span>
<span class="line-modified">665       // can reach this point due to various points in the runtime</span>
<span class="line-removed">666       // needing to revoke biases.</span>
<span class="line-removed">667       if (attempt_rebias) {</span>
<span class="line-removed">668         assert(THREAD-&gt;is_Java_thread(), &quot;&quot;);</span>
<span class="line-removed">669         markOop biased_value       = mark;</span>
<span class="line-removed">670         markOop rebiased_prototype = markOopDesc::encode((JavaThread*) THREAD, mark-&gt;age(), prototype_header-&gt;bias_epoch());</span>
<span class="line-removed">671         markOop res_mark = obj-&gt;cas_set_mark(rebiased_prototype, mark);</span>
<span class="line-removed">672         if (res_mark == biased_value) {</span>
<span class="line-removed">673           return BIAS_REVOKED_AND_REBIASED;</span>
<span class="line-removed">674         }</span>
<span class="line-removed">675       } else {</span>
<span class="line-removed">676         markOop biased_value       = mark;</span>
<span class="line-removed">677         markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span>
<span class="line-removed">678         markOop res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);</span>
<span class="line-removed">679         if (res_mark == biased_value) {</span>
<span class="line-removed">680           return BIAS_REVOKED;</span>
681         }


682       }
683     }
684   }
685 
<span class="line-modified">686   HeuristicsResult heuristics = update_heuristics(obj(), attempt_rebias);</span>
<span class="line-modified">687   if (heuristics == HR_NOT_BIASED) {</span>
<span class="line-modified">688     return NOT_BIASED;</span>
<span class="line-modified">689   } else if (heuristics == HR_SINGLE_REVOKE) {</span>
<span class="line-modified">690     Klass *k = obj-&gt;klass();</span>
<span class="line-modified">691     markOop prototype_header = k-&gt;prototype_header();</span>
<span class="line-modified">692     if (mark-&gt;biased_locker() == THREAD &amp;&amp;</span>
<span class="line-modified">693         prototype_header-&gt;bias_epoch() == mark-&gt;bias_epoch()) {</span>
<span class="line-modified">694       // A thread is trying to revoke the bias of an object biased</span>
<span class="line-modified">695       // toward it, again likely due to an identity hash code</span>
<span class="line-modified">696       // computation. We can again avoid a safepoint in this case</span>
<span class="line-modified">697       // since we are only going to walk our own stack. There are no</span>
<span class="line-modified">698       // races with revocations occurring in other threads because we</span>
<span class="line-modified">699       // reach no safepoints in the revocation path.</span>
<span class="line-modified">700       // Also check the epoch because even if threads match, another thread</span>
<span class="line-modified">701       // can come in with a CAS to steal the bias of an object that has a</span>
<span class="line-modified">702       // stale epoch.</span>
<span class="line-modified">703       ResourceMark rm;</span>
<span class="line-modified">704       log_info(biasedlocking)(&quot;Revoking bias by walking my own stack:&quot;);</span>
<span class="line-modified">705       EventBiasedLockSelfRevocation event;</span>
<span class="line-modified">706       BiasedLocking::Condition cond = revoke_bias(obj(), false, false, (JavaThread*) THREAD, NULL);</span>
<span class="line-modified">707       ((JavaThread*) THREAD)-&gt;set_cached_monitor_info(NULL);</span>
<span class="line-modified">708       assert(cond == BIAS_REVOKED, &quot;why not?&quot;);</span>
<span class="line-modified">709       if (event.should_commit()) {</span>
<span class="line-modified">710         post_self_revocation_event(&amp;event, k);</span>
<span class="line-modified">711       }</span>
<span class="line-modified">712       return cond;</span>













713     } else {
<span class="line-modified">714       EventBiasedLockRevocation event;</span>
<span class="line-modified">715       VM_RevokeBias revoke(&amp;obj, (JavaThread*) THREAD);</span>
<span class="line-modified">716       VMThread::execute(&amp;revoke);</span>
<span class="line-removed">717       if (event.should_commit() &amp;&amp; revoke.status_code() != NOT_BIASED) {</span>
<span class="line-removed">718         post_revocation_event(&amp;event, k, &amp;revoke);</span>
<span class="line-removed">719       }</span>
<span class="line-removed">720       return revoke.status_code();</span>
721     }
722   }















723 
<span class="line-modified">724   assert((heuristics == HR_BULK_REVOKE) ||</span>
<span class="line-modified">725          (heuristics == HR_BULK_REBIAS), &quot;?&quot;);</span>
<span class="line-modified">726   EventBiasedLockClassRevocation event;</span>
<span class="line-modified">727   VM_BulkRevokeBias bulk_revoke(&amp;obj, (JavaThread*) THREAD,</span>
<span class="line-modified">728                                 (heuristics == HR_BULK_REBIAS),</span>
<span class="line-modified">729                                 attempt_rebias);</span>
<span class="line-modified">730   VMThread::execute(&amp;bulk_revoke);</span>















731   if (event.should_commit()) {
<span class="line-modified">732     post_class_revocation_event(&amp;event, obj-&gt;klass(), heuristics != HR_BULK_REBIAS);</span>
733   }
<span class="line-removed">734   return bulk_revoke.status_code();</span>
735 }
736 
<span class="line-modified">737 </span>
<span class="line-removed">738 void BiasedLocking::revoke(GrowableArray&lt;Handle&gt;* objs) {</span>
739   assert(!SafepointSynchronize::is_at_safepoint(), &quot;must not be called while at safepoint&quot;);
<span class="line-modified">740   if (objs-&gt;length() == 0) {</span>
<span class="line-modified">741     return;</span>















































































































742   }
<span class="line-removed">743   VM_RevokeBias revoke(objs, JavaThread::current());</span>
<span class="line-removed">744   VMThread::execute(&amp;revoke);</span>
745 }
746 
747 
748 void BiasedLocking::revoke_at_safepoint(Handle h_obj) {
749   assert(SafepointSynchronize::is_at_safepoint(), &quot;must only be called while at safepoint&quot;);
750   oop obj = h_obj();
<span class="line-modified">751   HeuristicsResult heuristics = update_heuristics(obj, false);</span>
752   if (heuristics == HR_SINGLE_REVOKE) {
<span class="line-modified">753     revoke_bias(obj, false, false, NULL, NULL);</span>




754   } else if ((heuristics == HR_BULK_REBIAS) ||
755              (heuristics == HR_BULK_REVOKE)) {
<span class="line-modified">756     bulk_revoke_or_rebias_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), false, NULL);</span>
<span class="line-modified">757   }</span>
<span class="line-removed">758   clean_up_cached_monitor_info();</span>
<span class="line-removed">759 }</span>
<span class="line-removed">760 </span>
<span class="line-removed">761 </span>
<span class="line-removed">762 void BiasedLocking::revoke_at_safepoint(GrowableArray&lt;Handle&gt;* objs) {</span>
<span class="line-removed">763   assert(SafepointSynchronize::is_at_safepoint(), &quot;must only be called while at safepoint&quot;);</span>
<span class="line-removed">764   int len = objs-&gt;length();</span>
<span class="line-removed">765   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-removed">766     oop obj = (objs-&gt;at(i))();</span>
<span class="line-removed">767     HeuristicsResult heuristics = update_heuristics(obj, false);</span>
<span class="line-removed">768     if (heuristics == HR_SINGLE_REVOKE) {</span>
<span class="line-removed">769       revoke_bias(obj, false, false, NULL, NULL);</span>
<span class="line-removed">770     } else if ((heuristics == HR_BULK_REBIAS) ||</span>
<span class="line-removed">771                (heuristics == HR_BULK_REVOKE)) {</span>
<span class="line-removed">772       bulk_revoke_or_rebias_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), false, NULL);</span>
<span class="line-removed">773     }</span>
774   }
<span class="line-removed">775   clean_up_cached_monitor_info();</span>
776 }
777 
778 
779 void BiasedLocking::preserve_marks() {
780   if (!UseBiasedLocking)
781     return;
782 
783   assert(SafepointSynchronize::is_at_safepoint(), &quot;must only be called while at safepoint&quot;);
784 
785   assert(_preserved_oop_stack  == NULL, &quot;double initialization&quot;);
786   assert(_preserved_mark_stack == NULL, &quot;double initialization&quot;);
787 
788   // In order to reduce the number of mark words preserved during GC
789   // due to the presence of biased locking, we reinitialize most mark
790   // words to the class&#39;s prototype during GC -- even those which have
791   // a currently valid bias owner. One important situation where we
792   // must not clobber a bias is when a biased object is currently
793   // locked. To handle this case we iterate over the currently-locked
794   // monitors in a prepass and, if they are biased, preserve their
795   // mark words here. This should be a relatively small set of objects
796   // especially compared to the number of objects in the heap.
<span class="line-modified">797   _preserved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;markOop&gt;(10, true);</span>
798   _preserved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;Handle&gt;(10, true);
799 
800   ResourceMark rm;
801   Thread* cur = Thread::current();
802   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
803     if (thread-&gt;has_last_Java_frame()) {
804       RegisterMap rm(thread);
805       for (javaVFrame* vf = thread-&gt;last_java_vframe(&amp;rm); vf != NULL; vf = vf-&gt;java_sender()) {
806         GrowableArray&lt;MonitorInfo*&gt; *monitors = vf-&gt;monitors();
807         if (monitors != NULL) {
808           int len = monitors-&gt;length();
809           // Walk monitors youngest to oldest
810           for (int i = len - 1; i &gt;= 0; i--) {
811             MonitorInfo* mon_info = monitors-&gt;at(i);
812             if (mon_info-&gt;owner_is_scalar_replaced()) continue;
813             oop owner = mon_info-&gt;owner();
814             if (owner != NULL) {
<span class="line-modified">815               markOop mark = owner-&gt;mark();</span>
<span class="line-modified">816               if (mark-&gt;has_bias_pattern()) {</span>
817                 _preserved_oop_stack-&gt;push(Handle(cur, owner));
818                 _preserved_mark_stack-&gt;push(mark);
819               }
820             }
821           }
822         }
823       }
824     }
825   }
826 }
827 
828 
829 void BiasedLocking::restore_marks() {
830   if (!UseBiasedLocking)
831     return;
832 
833   assert(_preserved_oop_stack  != NULL, &quot;double free&quot;);
834   assert(_preserved_mark_stack != NULL, &quot;double free&quot;);
835 
836   int len = _preserved_oop_stack-&gt;length();
837   for (int i = 0; i &lt; len; i++) {
838     Handle owner = _preserved_oop_stack-&gt;at(i);
<span class="line-modified">839     markOop mark = _preserved_mark_stack-&gt;at(i);</span>
840     owner-&gt;set_mark(mark);
841   }
842 
843   delete _preserved_oop_stack;
844   _preserved_oop_stack = NULL;
845   delete _preserved_mark_stack;
846   _preserved_mark_stack = NULL;
847 }
848 
849 
850 int* BiasedLocking::total_entry_count_addr()                   { return _counters.total_entry_count_addr(); }
851 int* BiasedLocking::biased_lock_entry_count_addr()             { return _counters.biased_lock_entry_count_addr(); }
852 int* BiasedLocking::anonymously_biased_lock_entry_count_addr() { return _counters.anonymously_biased_lock_entry_count_addr(); }
853 int* BiasedLocking::rebiased_lock_entry_count_addr()           { return _counters.rebiased_lock_entry_count_addr(); }
854 int* BiasedLocking::revoked_lock_entry_count_addr()            { return _counters.revoked_lock_entry_count_addr(); }

855 int* BiasedLocking::fast_path_entry_count_addr()               { return _counters.fast_path_entry_count_addr(); }
856 int* BiasedLocking::slow_path_entry_count_addr()               { return _counters.slow_path_entry_count_addr(); }
857 
858 
859 // BiasedLockingCounters
860 
<span class="line-modified">861 int BiasedLockingCounters::slow_path_entry_count() {</span>
862   if (_slow_path_entry_count != 0) {
863     return _slow_path_entry_count;
864   }
865   int sum = _biased_lock_entry_count   + _anonymously_biased_lock_entry_count +
866             _rebiased_lock_entry_count + _revoked_lock_entry_count +
867             _fast_path_entry_count;
868 
869   return _total_entry_count - sum;
870 }
871 
<span class="line-modified">872 void BiasedLockingCounters::print_on(outputStream* st) {</span>
873   tty-&gt;print_cr(&quot;# total entries: %d&quot;, _total_entry_count);
874   tty-&gt;print_cr(&quot;# biased lock entries: %d&quot;, _biased_lock_entry_count);
875   tty-&gt;print_cr(&quot;# anonymously biased lock entries: %d&quot;, _anonymously_biased_lock_entry_count);
876   tty-&gt;print_cr(&quot;# rebiased lock entries: %d&quot;, _rebiased_lock_entry_count);
877   tty-&gt;print_cr(&quot;# revoked lock entries: %d&quot;, _revoked_lock_entry_count);

878   tty-&gt;print_cr(&quot;# fast path lock entries: %d&quot;, _fast_path_entry_count);
879   tty-&gt;print_cr(&quot;# slow path lock entries: %d&quot;, slow_path_entry_count());
880 }


</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 27 #include &quot;jfr/jfrEvents.hpp&quot;
 28 #include &quot;jfr/support/jfrThreadId.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
 31 #include &quot;oops/klass.inline.hpp&quot;
<span class="line-modified"> 32 #include &quot;oops/markWord.hpp&quot;</span>
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/atomic.hpp&quot;
 35 #include &quot;runtime/basicLock.hpp&quot;
 36 #include &quot;runtime/biasedLocking.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-added"> 38 #include &quot;runtime/handshake.hpp&quot;</span>
<span class="line-added"> 39 #include &quot;runtime/safepointMechanism.hpp&quot;</span>
 40 #include &quot;runtime/task.hpp&quot;
 41 #include &quot;runtime/threadSMR.hpp&quot;
 42 #include &quot;runtime/vframe.hpp&quot;
 43 #include &quot;runtime/vmThread.hpp&quot;
 44 #include &quot;runtime/vmOperations.hpp&quot;
 45 
 46 
 47 static bool _biased_locking_enabled = false;
 48 BiasedLockingCounters BiasedLocking::_counters;
 49 
<span class="line-modified"> 50 static GrowableArray&lt;Handle&gt;*   _preserved_oop_stack  = NULL;</span>
<span class="line-modified"> 51 static GrowableArray&lt;markWord&gt;* _preserved_mark_stack = NULL;</span>
 52 
 53 static void enable_biased_locking(InstanceKlass* k) {
<span class="line-modified"> 54   k-&gt;set_prototype_header(markWord::biased_locking_prototype());</span>
<span class="line-added"> 55 }</span>
<span class="line-added"> 56 </span>
<span class="line-added"> 57 static void enable_biased_locking() {</span>
<span class="line-added"> 58   _biased_locking_enabled = true;</span>
<span class="line-added"> 59   log_info(biasedlocking)(&quot;Biased locking enabled&quot;);</span>
 60 }
 61 
 62 class VM_EnableBiasedLocking: public VM_Operation {


 63  public:
<span class="line-modified"> 64   VM_EnableBiasedLocking() {}</span>
 65   VMOp_Type type() const          { return VMOp_EnableBiasedLocking; }


 66 
 67   void doit() {
 68     // Iterate the class loader data dictionaries enabling biased locking for all
 69     // currently loaded classes.
 70     ClassLoaderDataGraph::dictionary_classes_do(enable_biased_locking);
 71     // Indicate that future instances should enable it as well
<span class="line-modified"> 72     enable_biased_locking();</span>


 73   }
 74 
 75   bool allow_nested_vm_operations() const        { return false; }
 76 };
 77 
 78 
 79 // One-shot PeriodicTask subclass for enabling biased locking
 80 class EnableBiasedLockingTask : public PeriodicTask {
 81  public:
 82   EnableBiasedLockingTask(size_t interval_time) : PeriodicTask(interval_time) {}
 83 
 84   virtual void task() {
<span class="line-modified"> 85     VM_EnableBiasedLocking op;</span>
<span class="line-modified"> 86     VMThread::execute(&amp;op);</span>


 87 
 88     // Reclaim our storage and disenroll ourself
 89     delete this;
 90   }
 91 };
 92 
 93 
 94 void BiasedLocking::init() {
<span class="line-modified"> 95   // If biased locking is enabled and BiasedLockingStartupDelay is set,</span>
<span class="line-modified"> 96   // schedule a task to fire after the specified delay which turns on</span>
<span class="line-modified"> 97   // biased locking for all currently loaded classes as well as future</span>
<span class="line-modified"> 98   // ones. This could be a workaround for startup time regressions</span>
<span class="line-modified"> 99   // due to large number of safepoints being taken during VM startup for</span>
<span class="line-modified">100   // bias revocation.</span>

101   if (UseBiasedLocking) {
102     if (BiasedLockingStartupDelay &gt; 0) {
103       EnableBiasedLockingTask* task = new EnableBiasedLockingTask(BiasedLockingStartupDelay);
104       task-&gt;enroll();
105     } else {
<span class="line-modified">106       enable_biased_locking();</span>

107     }
108   }
109 }
110 
111 
112 bool BiasedLocking::enabled() {
<span class="line-modified">113   assert(UseBiasedLocking, &quot;precondition&quot;);</span>
<span class="line-added">114   // We check &quot;BiasedLockingStartupDelay == 0&quot; here to cover the</span>
<span class="line-added">115   // possibility of calls to BiasedLocking::enabled() before</span>
<span class="line-added">116   // BiasedLocking::init().</span>
<span class="line-added">117   return _biased_locking_enabled || BiasedLockingStartupDelay == 0;</span>
118 }
119 
<span class="line-added">120 </span>
121 // Returns MonitorInfos for all objects locked on this thread in youngest to oldest order
122 static GrowableArray&lt;MonitorInfo*&gt;* get_or_compute_monitor_info(JavaThread* thread) {
123   GrowableArray&lt;MonitorInfo*&gt;* info = thread-&gt;cached_monitor_info();
124   if (info != NULL) {
125     return info;
126   }
127 
128   info = new GrowableArray&lt;MonitorInfo*&gt;();
129 
130   // It&#39;s possible for the thread to not have any Java frames on it,
131   // i.e., if it&#39;s the main thread and it&#39;s already returned from main()
132   if (thread-&gt;has_last_Java_frame()) {
133     RegisterMap rm(thread);
134     for (javaVFrame* vf = thread-&gt;last_java_vframe(&amp;rm); vf != NULL; vf = vf-&gt;java_sender()) {
135       GrowableArray&lt;MonitorInfo*&gt; *monitors = vf-&gt;monitors();
136       if (monitors != NULL) {
137         int len = monitors-&gt;length();
138         // Walk monitors youngest to oldest
139         for (int i = len - 1; i &gt;= 0; i--) {
140           MonitorInfo* mon_info = monitors-&gt;at(i);
141           if (mon_info-&gt;eliminated()) continue;
142           oop owner = mon_info-&gt;owner();
143           if (owner != NULL) {
144             info-&gt;append(mon_info);
145           }
146         }
147       }
148     }
149   }
150 
151   thread-&gt;set_cached_monitor_info(info);
152   return info;
153 }
154 
<span class="line-added">155 </span>
156 // After the call, *biased_locker will be set to obj-&gt;mark()-&gt;biased_locker() if biased_locker != NULL,
157 // AND it is a living thread. Otherwise it will not be updated, (i.e. the caller is responsible for initialization).
<span class="line-modified">158 void BiasedLocking::single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requesting_thread, JavaThread** biased_locker) {</span>
<span class="line-modified">159   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be done at safepoint&quot;);</span>
<span class="line-modified">160   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);</span>
<span class="line-added">161 </span>
<span class="line-added">162   markWord mark = obj-&gt;mark();</span>
<span class="line-added">163   if (!mark.has_bias_pattern()) {</span>
164     if (log_is_enabled(Info, biasedlocking)) {
165       ResourceMark rm;
166       log_info(biasedlocking)(&quot;  (Skipping revocation of object &quot; INTPTR_FORMAT
167                               &quot;, mark &quot; INTPTR_FORMAT &quot;, type %s&quot;
168                               &quot;, requesting thread &quot; INTPTR_FORMAT
169                               &quot; because it&#39;s no longer biased)&quot;,
<span class="line-modified">170                               p2i((void *)obj), mark.value(),</span>
171                               obj-&gt;klass()-&gt;external_name(),
172                               (intptr_t) requesting_thread);
173     }
<span class="line-modified">174     return;</span>
175   }
176 
<span class="line-modified">177   uint age = mark.age();</span>
<span class="line-modified">178   markWord unbiased_prototype = markWord::prototype().set_age(age);</span>

179 
180   // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
181   if (!is_bulk) {
182     ResourceMark rm;
183     log_info(biasedlocking)(&quot;Revoking bias of object &quot; INTPTR_FORMAT &quot;, mark &quot;
184                             INTPTR_FORMAT &quot;, type %s, prototype header &quot; INTPTR_FORMAT
<span class="line-modified">185                             &quot;, requesting thread &quot; INTPTR_FORMAT,</span>
186                             p2i((void *)obj),
<span class="line-modified">187                             mark.value(),</span>
188                             obj-&gt;klass()-&gt;external_name(),
<span class="line-modified">189                             obj-&gt;klass()-&gt;prototype_header().value(),</span>

190                             (intptr_t) requesting_thread);
191   } else {
192     ResourceMark rm;
193     log_trace(biasedlocking)(&quot;Revoking bias of object &quot; INTPTR_FORMAT &quot; , mark &quot;
194                              INTPTR_FORMAT &quot; , type %s , prototype header &quot; INTPTR_FORMAT
<span class="line-modified">195                              &quot; , requesting thread &quot; INTPTR_FORMAT,</span>
196                              p2i((void *)obj),
<span class="line-modified">197                              mark.value(),</span>
198                              obj-&gt;klass()-&gt;external_name(),
<span class="line-modified">199                              obj-&gt;klass()-&gt;prototype_header().value(),</span>

200                              (intptr_t) requesting_thread);
201   }
202 
<span class="line-modified">203   JavaThread* biased_thread = mark.biased_locker();</span>
204   if (biased_thread == NULL) {
205     // Object is anonymously biased. We can get here if, for
206     // example, we revoke the bias due to an identity hash code
207     // being computed for an object.
<span class="line-modified">208     obj-&gt;set_mark(unbiased_prototype);</span>
<span class="line-modified">209 </span>

210     // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
211     if (!is_bulk) {
212       log_info(biasedlocking)(&quot;  Revoked bias of anonymously-biased object&quot;);
213     } else {
214       log_trace(biasedlocking)(&quot;  Revoked bias of anonymously-biased object&quot;);
215     }
<span class="line-modified">216     return;</span>
217   }
218 
219   // Handle case where the thread toward which the object was biased has exited
220   bool thread_is_alive = false;
221   if (requesting_thread == biased_thread) {
222     thread_is_alive = true;
223   } else {
224     ThreadsListHandle tlh;
225     thread_is_alive = tlh.includes(biased_thread);
226   }
227   if (!thread_is_alive) {
<span class="line-modified">228     obj-&gt;set_mark(unbiased_prototype);</span>




229     // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
230     if (!is_bulk) {
231       log_info(biasedlocking)(&quot;  Revoked bias of object biased toward dead thread (&quot;
232                               PTR_FORMAT &quot;)&quot;, p2i(biased_thread));
233     } else {
234       log_trace(biasedlocking)(&quot;  Revoked bias of object biased toward dead thread (&quot;
235                                PTR_FORMAT &quot;)&quot;, p2i(biased_thread));
236     }
<span class="line-modified">237     return;</span>
238   }
239 
240   // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
241   if (!is_bulk) {
242     log_info(biasedlocking)(&quot;  Revoked bias of object biased toward live thread (&quot;
243                             PTR_FORMAT &quot;)&quot;, p2i(biased_thread));
244   } else {
245     log_trace(biasedlocking)(&quot;  Revoked bias of object biased toward live thread (&quot;
246                                PTR_FORMAT &quot;)&quot;, p2i(biased_thread));
247   }
248 
249   // Thread owning bias is alive.
250   // Check to see whether it currently owns the lock and, if so,
251   // write down the needed displaced headers to the thread&#39;s stack.
252   // Otherwise, restore the object&#39;s header either to the unlocked
253   // or unbiased state.
254   GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);
255   BasicLock* highest_lock = NULL;
256   for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
257     MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
<span class="line-modified">258     if (mon_info-&gt;owner() == obj) {</span>
259       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) == obj (&quot; PTR_FORMAT &quot;)&quot;,
260                                p2i((void *) mon_info-&gt;owner()),
261                                p2i((void *) obj));
<span class="line-modified">262       // Assume recursive case and fix up highest lock below</span>
<span class="line-modified">263       markWord mark = markWord::encode((BasicLock*) NULL);</span>
264       highest_lock = mon_info-&gt;lock();
265       highest_lock-&gt;set_displaced_header(mark);
266     } else {
267       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) != obj (&quot; PTR_FORMAT &quot;)&quot;,
268                                p2i((void *) mon_info-&gt;owner()),
269                                p2i((void *) obj));
270     }
271   }
272   if (highest_lock != NULL) {
273     // Fix up highest lock to contain displaced header and point
274     // object at it
275     highest_lock-&gt;set_displaced_header(unbiased_prototype);
276     // Reset object header to point to displaced mark.
<span class="line-modified">277     // Must release store the lock address for platforms without TSO</span>
278     // ordering (e.g. ppc).
<span class="line-modified">279     obj-&gt;release_set_mark(markWord::encode(highest_lock));</span>
<span class="line-modified">280     assert(!obj-&gt;mark().has_bias_pattern(), &quot;illegal mark state: stack lock used bias bit&quot;);</span>
281     // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
282     if (!is_bulk) {
283       log_info(biasedlocking)(&quot;  Revoked bias of currently-locked object&quot;);
284     } else {
285       log_trace(biasedlocking)(&quot;  Revoked bias of currently-locked object&quot;);
286     }
287   } else {
288     // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
289     if (!is_bulk) {
290       log_info(biasedlocking)(&quot;  Revoked bias of currently-unlocked object&quot;);
291     } else {
292       log_trace(biasedlocking)(&quot;  Revoked bias of currently-unlocked object&quot;);
293     }
<span class="line-modified">294     // Store the unlocked value into the object&#39;s header.</span>
<span class="line-modified">295     obj-&gt;set_mark(unbiased_prototype);</span>




296   }
297 
298   // If requested, return information on which thread held the bias
299   if (biased_locker != NULL) {
300     *biased_locker = biased_thread;
301   }


302 }
303 
304 
305 enum HeuristicsResult {
306   HR_NOT_BIASED    = 1,
307   HR_SINGLE_REVOKE = 2,
308   HR_BULK_REBIAS   = 3,
309   HR_BULK_REVOKE   = 4
310 };
311 
312 
<span class="line-modified">313 static HeuristicsResult update_heuristics(oop o) {</span>
<span class="line-modified">314   markWord mark = o-&gt;mark();</span>
<span class="line-modified">315   if (!mark.has_bias_pattern()) {</span>
316     return HR_NOT_BIASED;
317   }
318 
319   // Heuristics to attempt to throttle the number of revocations.
320   // Stages:
321   // 1. Revoke the biases of all objects in the heap of this type,
322   //    but allow rebiasing of those objects if unlocked.
323   // 2. Revoke the biases of all objects in the heap of this type
324   //    and don&#39;t allow rebiasing of these objects. Disable
325   //    allocation of objects of that type with the bias bit set.
326   Klass* k = o-&gt;klass();
<span class="line-modified">327   jlong cur_time = nanos_to_millis(os::javaTimeNanos());</span>
328   jlong last_bulk_revocation_time = k-&gt;last_biased_lock_bulk_revocation_time();
329   int revocation_count = k-&gt;biased_lock_revocation_count();
330   if ((revocation_count &gt;= BiasedLockingBulkRebiasThreshold) &amp;&amp;
331       (revocation_count &lt;  BiasedLockingBulkRevokeThreshold) &amp;&amp;
332       (last_bulk_revocation_time != 0) &amp;&amp;
333       (cur_time - last_bulk_revocation_time &gt;= BiasedLockingDecayTime)) {
334     // This is the first revocation we&#39;ve seen in a while of an
335     // object of this type since the last time we performed a bulk
336     // rebiasing operation. The application is allocating objects in
337     // bulk which are biased toward a thread and then handing them
338     // off to another thread. We can cope with this allocation
339     // pattern via the bulk rebiasing mechanism so we reset the
340     // klass&#39;s revocation count rather than allow it to increase
341     // monotonically. If we see the need to perform another bulk
342     // rebias operation later, we will, and if subsequently we see
343     // many more revocation operations in a short period of time we
344     // will completely disable biasing for this type.
345     k-&gt;set_biased_lock_revocation_count(0);
346     revocation_count = 0;
347   }
348 
349   // Make revocation count saturate just beyond BiasedLockingBulkRevokeThreshold
350   if (revocation_count &lt;= BiasedLockingBulkRevokeThreshold) {
351     revocation_count = k-&gt;atomic_incr_biased_lock_revocation_count();
352   }
353 
354   if (revocation_count == BiasedLockingBulkRevokeThreshold) {
355     return HR_BULK_REVOKE;
356   }
357 
358   if (revocation_count == BiasedLockingBulkRebiasThreshold) {
359     return HR_BULK_REBIAS;
360   }
361 
362   return HR_SINGLE_REVOKE;
363 }
364 
365 
<span class="line-modified">366 void BiasedLocking::bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requesting_thread) {</span>



367   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be done at safepoint&quot;);
<span class="line-added">368   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);</span>
369 
370   log_info(biasedlocking)(&quot;* Beginning bulk revocation (kind == %s) because of object &quot;
371                           INTPTR_FORMAT &quot; , mark &quot; INTPTR_FORMAT &quot; , type %s&quot;,
372                           (bulk_rebias ? &quot;rebias&quot; : &quot;revoke&quot;),
373                           p2i((void *) o),
<span class="line-modified">374                           o-&gt;mark().value(),</span>
375                           o-&gt;klass()-&gt;external_name());
376 
<span class="line-modified">377   jlong cur_time = nanos_to_millis(os::javaTimeNanos());</span>
378   o-&gt;klass()-&gt;set_last_biased_lock_bulk_revocation_time(cur_time);
379 

380   Klass* k_o = o-&gt;klass();
381   Klass* klass = k_o;
382 
383   {
384     JavaThreadIteratorWithHandle jtiwh;
385 
386     if (bulk_rebias) {
387       // Use the epoch in the klass of the object to implicitly revoke
388       // all biases of objects of this data type and force them to be
389       // reacquired. However, we also need to walk the stacks of all
390       // threads and update the headers of lightweight locked objects
391       // with biases to have the current epoch.
392 
393       // If the prototype header doesn&#39;t have the bias pattern, don&#39;t
394       // try to update the epoch -- assume another VM operation came in
395       // and reset the header to the unbiased state, which will
396       // implicitly cause all existing biases to be revoked
<span class="line-modified">397       if (klass-&gt;prototype_header().has_bias_pattern()) {</span>
<span class="line-modified">398         int prev_epoch = klass-&gt;prototype_header().bias_epoch();</span>
<span class="line-modified">399         klass-&gt;set_prototype_header(klass-&gt;prototype_header().incr_bias_epoch());</span>
<span class="line-modified">400         int cur_epoch = klass-&gt;prototype_header().bias_epoch();</span>
401 
402         // Now walk all threads&#39; stacks and adjust epochs of any biased
403         // and locked objects of this data type we encounter
404         for (; JavaThread *thr = jtiwh.next(); ) {
405           GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(thr);
406           for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
407             MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
408             oop owner = mon_info-&gt;owner();
<span class="line-modified">409             markWord mark = owner-&gt;mark();</span>
<span class="line-modified">410             if ((owner-&gt;klass() == k_o) &amp;&amp; mark.has_bias_pattern()) {</span>
411               // We might have encountered this object already in the case of recursive locking
<span class="line-modified">412               assert(mark.bias_epoch() == prev_epoch || mark.bias_epoch() == cur_epoch, &quot;error in bias epoch adjustment&quot;);</span>
<span class="line-modified">413               owner-&gt;set_mark(mark.set_bias_epoch(cur_epoch));</span>
414             }
415           }
416         }
417       }
418 
419       // At this point we&#39;re done. All we have to do is potentially
420       // adjust the header of the given object to revoke its bias.
<span class="line-modified">421       single_revoke_at_safepoint(o, true, requesting_thread, NULL);</span>
422     } else {
423       if (log_is_enabled(Info, biasedlocking)) {
424         ResourceMark rm;
425         log_info(biasedlocking)(&quot;* Disabling biased locking for type %s&quot;, klass-&gt;external_name());
426       }
427 
428       // Disable biased locking for this data type. Not only will this
429       // cause future instances to not be biased, but existing biased
430       // instances will notice that this implicitly caused their biases
431       // to be revoked.
<span class="line-modified">432       klass-&gt;set_prototype_header(markWord::prototype());</span>
433 
434       // Now walk all threads&#39; stacks and forcibly revoke the biases of
435       // any locked and biased objects of this data type we encounter.
436       for (; JavaThread *thr = jtiwh.next(); ) {
437         GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(thr);
438         for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
439           MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
440           oop owner = mon_info-&gt;owner();
<span class="line-modified">441           markWord mark = owner-&gt;mark();</span>
<span class="line-modified">442           if ((owner-&gt;klass() == k_o) &amp;&amp; mark.has_bias_pattern()) {</span>
<span class="line-modified">443             single_revoke_at_safepoint(owner, true, requesting_thread, NULL);</span>
444           }
445         }
446       }
447 
448       // Must force the bias of the passed object to be forcibly revoked
449       // as well to ensure guarantees to callers
<span class="line-modified">450       single_revoke_at_safepoint(o, true, requesting_thread, NULL);</span>
451     }
452   } // ThreadsListHandle is destroyed here.
453 
454   log_info(biasedlocking)(&quot;* Ending bulk revocation&quot;);
455 
<span class="line-modified">456   assert(!o-&gt;mark().has_bias_pattern(), &quot;bug in bulk bias revocation&quot;);</span>
<span class="line-added">457 }</span>
<span class="line-added">458 </span>
459 
<span class="line-modified">460 static void clean_up_cached_monitor_info(JavaThread* thread = NULL) {</span>
<span class="line-modified">461   if (thread != NULL) {</span>
<span class="line-modified">462     thread-&gt;set_cached_monitor_info(NULL);</span>
<span class="line-modified">463   } else {</span>
<span class="line-modified">464     // Walk the thread list clearing out the cached monitors</span>
<span class="line-modified">465     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {</span>
<span class="line-modified">466       thr-&gt;set_cached_monitor_info(NULL);</span>
<span class="line-modified">467     }</span>
468   }
<span class="line-added">469 }</span>
470 



471 
<span class="line-modified">472 class VM_BulkRevokeBias : public VM_Operation {</span>
<span class="line-modified">473 private:</span>
<span class="line-added">474   Handle* _obj;</span>
<span class="line-added">475   JavaThread* _requesting_thread;</span>
<span class="line-added">476   bool _bulk_rebias;</span>
<span class="line-added">477   uint64_t _safepoint_id;</span>
478 
<span class="line-added">479 public:</span>
<span class="line-added">480   VM_BulkRevokeBias(Handle* obj, JavaThread* requesting_thread,</span>
<span class="line-added">481                     bool bulk_rebias)</span>
<span class="line-added">482     : _obj(obj)</span>
<span class="line-added">483     , _requesting_thread(requesting_thread)</span>
<span class="line-added">484     , _bulk_rebias(bulk_rebias)</span>
<span class="line-added">485     , _safepoint_id(0) {}</span>
486 
<span class="line-modified">487   virtual VMOp_Type type() const { return VMOp_BulkRevokeBias; }</span>
<span class="line-modified">488 </span>
<span class="line-modified">489   virtual void doit() {</span>
<span class="line-modified">490     BiasedLocking::bulk_revoke_at_safepoint((*_obj)(), _bulk_rebias, _requesting_thread);</span>
<span class="line-added">491     _safepoint_id = SafepointSynchronize::safepoint_id();</span>
<span class="line-added">492     clean_up_cached_monitor_info();</span>
493   }
<span class="line-modified">494 </span>
<span class="line-added">495   bool is_bulk_rebias() const {</span>
<span class="line-added">496     return _bulk_rebias;</span>
<span class="line-added">497   }</span>
<span class="line-added">498 </span>
<span class="line-added">499   uint64_t safepoint_id() const {</span>
<span class="line-added">500     return _safepoint_id;</span>
<span class="line-added">501   }</span>
<span class="line-added">502 };</span>
503 
504 
<span class="line-modified">505 class RevokeOneBias : public HandshakeClosure {</span>
506 protected:
<span class="line-modified">507   Handle _obj;</span>

508   JavaThread* _requesting_thread;
<span class="line-added">509   JavaThread* _biased_locker;</span>
510   BiasedLocking::Condition _status_code;
511   traceid _biased_locker_id;
512 
513 public:
<span class="line-modified">514   RevokeOneBias(Handle obj, JavaThread* requesting_thread, JavaThread* biased_locker)</span>
<span class="line-modified">515     : HandshakeClosure(&quot;RevokeOneBias&quot;)</span>
<span class="line-modified">516     , _obj(obj)</span>
517     , _requesting_thread(requesting_thread)
<span class="line-added">518     , _biased_locker(biased_locker)</span>
519     , _status_code(BiasedLocking::NOT_BIASED)
520     , _biased_locker_id(0) {}
521 
<span class="line-modified">522   void do_thread(Thread* target) {</span>
<span class="line-modified">523     assert(target == _biased_locker, &quot;Wrong thread&quot;);</span>




524 
<span class="line-modified">525     oop o = _obj();</span>
<span class="line-added">526     markWord mark = o-&gt;mark();</span>
527 
<span class="line-modified">528     if (!mark.has_bias_pattern()) {</span>
<span class="line-modified">529       return;</span>














530     }


531 
<span class="line-modified">532     markWord prototype = o-&gt;klass()-&gt;prototype_header();</span>
<span class="line-modified">533     if (!prototype.has_bias_pattern()) {</span>
<span class="line-modified">534       // This object has a stale bias from before the handshake</span>
<span class="line-modified">535       // was requested. If we fail this race, the object&#39;s bias</span>
<span class="line-modified">536       // has been revoked by another thread so we simply return.</span>
<span class="line-modified">537       markWord biased_value = mark;</span>
<span class="line-modified">538       mark = o-&gt;cas_set_mark(markWord::prototype().set_age(mark.age()), mark);</span>
<span class="line-added">539       assert(!o-&gt;mark().has_bias_pattern(), &quot;even if we raced, should still be revoked&quot;);</span>
<span class="line-added">540       if (biased_value == mark) {</span>
<span class="line-added">541         _status_code = BiasedLocking::BIAS_REVOKED;</span>
542       }

543       return;



544     }
<span class="line-added">545 </span>
<span class="line-added">546     if (_biased_locker == mark.biased_locker()) {</span>
<span class="line-added">547       if (mark.bias_epoch() == prototype.bias_epoch()) {</span>
<span class="line-added">548         // Epoch is still valid. This means biaser could be currently</span>
<span class="line-added">549         // synchronized on this object. We must walk its stack looking</span>
<span class="line-added">550         // for monitor records associated with this object and change</span>
<span class="line-added">551         // them to be stack locks if any are found.</span>
<span class="line-added">552         ResourceMark rm;</span>
<span class="line-added">553         BiasedLocking::walk_stack_and_revoke(o, _biased_locker);</span>
<span class="line-added">554         _biased_locker-&gt;set_cached_monitor_info(NULL);</span>
<span class="line-added">555         assert(!o-&gt;mark().has_bias_pattern(), &quot;invariant&quot;);</span>
<span class="line-added">556         _biased_locker_id = JFR_THREAD_ID(_biased_locker);</span>
<span class="line-added">557         _status_code = BiasedLocking::BIAS_REVOKED;</span>
<span class="line-added">558         return;</span>
<span class="line-added">559       } else {</span>
<span class="line-added">560         markWord biased_value = mark;</span>
<span class="line-added">561         mark = o-&gt;cas_set_mark(markWord::prototype().set_age(mark.age()), mark);</span>
<span class="line-added">562         if (mark == biased_value || !mark.has_bias_pattern()) {</span>
<span class="line-added">563           assert(!o-&gt;mark().has_bias_pattern(), &quot;should be revoked&quot;);</span>
<span class="line-added">564           _status_code = (biased_value == mark) ? BiasedLocking::BIAS_REVOKED : BiasedLocking::NOT_BIASED;</span>
<span class="line-added">565           return;</span>
<span class="line-added">566         }</span>
<span class="line-added">567       }</span>
<span class="line-added">568     }</span>
<span class="line-added">569 </span>
<span class="line-added">570     _status_code = BiasedLocking::NOT_REVOKED;</span>
571   }
572 
573   BiasedLocking::Condition status_code() const {
574     return _status_code;
575   }
576 
577   traceid biased_locker() const {
578     return _biased_locker_id;
579   }
580 };
581 
582 





























583 static void post_self_revocation_event(EventBiasedLockSelfRevocation* event, Klass* k) {
584   assert(event != NULL, &quot;invariant&quot;);
585   assert(k != NULL, &quot;invariant&quot;);
586   assert(event-&gt;should_commit(), &quot;invariant&quot;);
587   event-&gt;set_lockClass(k);
588   event-&gt;commit();
589 }
590 
<span class="line-modified">591 static void post_revocation_event(EventBiasedLockRevocation* event, Klass* k, RevokeOneBias* op) {</span>
592   assert(event != NULL, &quot;invariant&quot;);
593   assert(k != NULL, &quot;invariant&quot;);
<span class="line-modified">594   assert(op != NULL, &quot;invariant&quot;);</span>
595   assert(event-&gt;should_commit(), &quot;invariant&quot;);
596   event-&gt;set_lockClass(k);
<span class="line-modified">597   event-&gt;set_safepointId(0);</span>
<span class="line-modified">598   event-&gt;set_previousOwner(op-&gt;biased_locker());</span>
599   event-&gt;commit();
600 }
601 
<span class="line-modified">602 static void post_class_revocation_event(EventBiasedLockClassRevocation* event, Klass* k, VM_BulkRevokeBias* op) {</span>
603   assert(event != NULL, &quot;invariant&quot;);
604   assert(k != NULL, &quot;invariant&quot;);
<span class="line-added">605   assert(op != NULL, &quot;invariant&quot;);</span>
606   assert(event-&gt;should_commit(), &quot;invariant&quot;);
607   event-&gt;set_revokedClass(k);
<span class="line-modified">608   event-&gt;set_disableBiasing(!op-&gt;is_bulk_rebias());</span>
<span class="line-modified">609   event-&gt;set_safepointId(op-&gt;safepoint_id());</span>
610   event-&gt;commit();
611 }
612 


613 
<span class="line-modified">614 BiasedLocking::Condition BiasedLocking::single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser) {</span>
<span class="line-modified">615 </span>
<span class="line-modified">616   EventBiasedLockRevocation event;</span>
<span class="line-modified">617   if (PrintBiasedLockingStatistics) {</span>
<span class="line-modified">618     Atomic::inc(handshakes_count_addr());</span>
<span class="line-modified">619   }</span>
<span class="line-modified">620   log_info(biasedlocking, handshake)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; handshaking JavaThread &quot;</span>
<span class="line-modified">621                                      INTPTR_FORMAT &quot; to revoke object &quot; INTPTR_FORMAT, p2i(requester),</span>
<span class="line-modified">622                                      p2i(biaser), p2i(obj()));</span>
<span class="line-modified">623 </span>
<span class="line-modified">624   RevokeOneBias revoke(obj, requester, biaser);</span>
<span class="line-modified">625   bool executed = Handshake::execute(&amp;revoke, biaser);</span>
<span class="line-modified">626   if (revoke.status_code() == NOT_REVOKED) {</span>
<span class="line-modified">627     return NOT_REVOKED;</span>
<span class="line-modified">628   }</span>
<span class="line-modified">629   if (executed) {</span>
<span class="line-modified">630     log_info(biasedlocking, handshake)(&quot;Handshake revocation for object &quot; INTPTR_FORMAT &quot; succeeded. Bias was %srevoked&quot;,</span>
<span class="line-added">631                                        p2i(obj()), (revoke.status_code() == BIAS_REVOKED ? &quot;&quot; : &quot;already &quot;));</span>
<span class="line-added">632     if (event.should_commit() &amp;&amp; revoke.status_code() == BIAS_REVOKED) {</span>
<span class="line-added">633       post_revocation_event(&amp;event, obj-&gt;klass(), &amp;revoke);</span>
634     }
<span class="line-modified">635     assert(!obj-&gt;mark().has_bias_pattern(), &quot;invariant&quot;);</span>
<span class="line-modified">636     return revoke.status_code();</span>
<span class="line-modified">637   } else {</span>
<span class="line-modified">638     // Thread was not alive.</span>
<span class="line-modified">639     // Grab Threads_lock before manually trying to revoke bias. This avoids race with a newly</span>
<span class="line-modified">640     // created JavaThread (that happens to get the same memory address as biaser) synchronizing</span>
<span class="line-modified">641     // on this object.</span>
<span class="line-modified">642     {</span>
<span class="line-modified">643       MutexLocker ml(Threads_lock);</span>
<span class="line-modified">644       markWord mark = obj-&gt;mark();</span>
<span class="line-modified">645       // Check if somebody else was able to revoke it before biased thread exited.</span>
<span class="line-modified">646       if (!mark.has_bias_pattern()) {</span>
<span class="line-modified">647         return NOT_BIASED;</span>
<span class="line-modified">648       }</span>
<span class="line-modified">649       ThreadsListHandle tlh;</span>
<span class="line-modified">650       markWord prototype = obj-&gt;klass()-&gt;prototype_header();</span>
<span class="line-modified">651       if (!prototype.has_bias_pattern() || (!tlh.includes(biaser) &amp;&amp; biaser == mark.biased_locker() &amp;&amp;</span>
<span class="line-modified">652                                             prototype.bias_epoch() == mark.bias_epoch())) {</span>
<span class="line-modified">653         obj-&gt;cas_set_mark(markWord::prototype().set_age(mark.age()), mark);</span>
<span class="line-modified">654         if (event.should_commit()) {</span>
<span class="line-modified">655           post_revocation_event(&amp;event, obj-&gt;klass(), &amp;revoke);</span>















656         }
<span class="line-added">657         assert(!obj-&gt;mark().has_bias_pattern(), &quot;bias should be revoked by now&quot;);</span>
<span class="line-added">658         return BIAS_REVOKED;</span>
659       }
660     }
661   }
662 
<span class="line-modified">663   return NOT_REVOKED;</span>
<span class="line-modified">664 }</span>
<span class="line-modified">665 </span>
<span class="line-modified">666 </span>
<span class="line-modified">667 // Caller should have instantiated a ResourceMark object before calling this method</span>
<span class="line-modified">668 void BiasedLocking::walk_stack_and_revoke(oop obj, JavaThread* biased_locker) {</span>
<span class="line-modified">669   assert(!SafepointSynchronize::is_at_safepoint() || !SafepointMechanism::uses_thread_local_poll(),</span>
<span class="line-modified">670          &quot;if SafepointMechanism::uses_thread_local_poll() is enabled this should always be executed outside safepoints&quot;);</span>
<span class="line-modified">671   assert(Thread::current() == biased_locker || Thread::current()-&gt;is_VM_thread(), &quot;wrong thread&quot;);</span>
<span class="line-modified">672 </span>
<span class="line-modified">673   markWord mark = obj-&gt;mark();</span>
<span class="line-modified">674   assert(mark.biased_locker() == biased_locker &amp;&amp;</span>
<span class="line-modified">675          obj-&gt;klass()-&gt;prototype_header().bias_epoch() == mark.bias_epoch(), &quot;invariant&quot;);</span>
<span class="line-modified">676 </span>
<span class="line-modified">677   log_trace(biasedlocking)(&quot;%s(&quot; INTPTR_FORMAT &quot;) revoking object &quot; INTPTR_FORMAT &quot;, mark &quot;</span>
<span class="line-modified">678                            INTPTR_FORMAT &quot;, type %s, prototype header &quot; INTPTR_FORMAT</span>
<span class="line-modified">679                            &quot;, biaser &quot; INTPTR_FORMAT &quot; %s&quot;,</span>
<span class="line-modified">680                            Thread::current()-&gt;is_VM_thread() ? &quot;VMThread&quot; : &quot;JavaThread&quot;,</span>
<span class="line-modified">681                            p2i(Thread::current()),</span>
<span class="line-modified">682                            p2i(obj),</span>
<span class="line-modified">683                            mark.value(),</span>
<span class="line-modified">684                            obj-&gt;klass()-&gt;external_name(),</span>
<span class="line-modified">685                            obj-&gt;klass()-&gt;prototype_header().value(),</span>
<span class="line-modified">686                            p2i(biased_locker),</span>
<span class="line-modified">687                            Thread::current()-&gt;is_VM_thread() ? &quot;&quot; : &quot;(walking own stack)&quot;);</span>
<span class="line-modified">688 </span>
<span class="line-modified">689   markWord unbiased_prototype = markWord::prototype().set_age(obj-&gt;mark().age());</span>
<span class="line-added">690 </span>
<span class="line-added">691   GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_locker);</span>
<span class="line-added">692   BasicLock* highest_lock = NULL;</span>
<span class="line-added">693   for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {</span>
<span class="line-added">694     MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span>
<span class="line-added">695     if (mon_info-&gt;owner() == obj) {</span>
<span class="line-added">696       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) == obj (&quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="line-added">697                                p2i(mon_info-&gt;owner()),</span>
<span class="line-added">698                                p2i(obj));</span>
<span class="line-added">699       // Assume recursive case and fix up highest lock below</span>
<span class="line-added">700       markWord mark = markWord::encode((BasicLock*) NULL);</span>
<span class="line-added">701       highest_lock = mon_info-&gt;lock();</span>
<span class="line-added">702       highest_lock-&gt;set_displaced_header(mark);</span>
703     } else {
<span class="line-modified">704       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) != obj (&quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="line-modified">705                                p2i(mon_info-&gt;owner()),</span>
<span class="line-modified">706                                p2i(obj));</span>




707     }
708   }
<span class="line-added">709   if (highest_lock != NULL) {</span>
<span class="line-added">710     // Fix up highest lock to contain displaced header and point</span>
<span class="line-added">711     // object at it</span>
<span class="line-added">712     highest_lock-&gt;set_displaced_header(unbiased_prototype);</span>
<span class="line-added">713     // Reset object header to point to displaced mark.</span>
<span class="line-added">714     // Must release store the lock address for platforms without TSO</span>
<span class="line-added">715     // ordering (e.g. ppc).</span>
<span class="line-added">716     obj-&gt;release_set_mark(markWord::encode(highest_lock));</span>
<span class="line-added">717     assert(!obj-&gt;mark().has_bias_pattern(), &quot;illegal mark state: stack lock used bias bit&quot;);</span>
<span class="line-added">718     log_info(biasedlocking)(&quot;  Revoked bias of currently-locked object&quot;);</span>
<span class="line-added">719   } else {</span>
<span class="line-added">720     log_info(biasedlocking)(&quot;  Revoked bias of currently-unlocked object&quot;);</span>
<span class="line-added">721     // Store the unlocked value into the object&#39;s header.</span>
<span class="line-added">722     obj-&gt;set_mark(unbiased_prototype);</span>
<span class="line-added">723   }</span>
724 
<span class="line-modified">725   assert(!obj-&gt;mark().has_bias_pattern(), &quot;must not be biased&quot;);</span>
<span class="line-modified">726 }</span>
<span class="line-modified">727 </span>
<span class="line-modified">728 void BiasedLocking::revoke_own_lock(Handle obj, TRAPS) {</span>
<span class="line-modified">729   assert(THREAD-&gt;is_Java_thread(), &quot;must be called by a JavaThread&quot;);</span>
<span class="line-modified">730   JavaThread* thread = (JavaThread*)THREAD;</span>
<span class="line-modified">731 </span>
<span class="line-added">732   markWord mark = obj-&gt;mark();</span>
<span class="line-added">733 </span>
<span class="line-added">734   if (!mark.has_bias_pattern()) {</span>
<span class="line-added">735     return;</span>
<span class="line-added">736   }</span>
<span class="line-added">737 </span>
<span class="line-added">738   Klass *k = obj-&gt;klass();</span>
<span class="line-added">739   assert(mark.biased_locker() == thread &amp;&amp;</span>
<span class="line-added">740          k-&gt;prototype_header().bias_epoch() == mark.bias_epoch(), &quot;Revoke failed, unhandled biased lock state&quot;);</span>
<span class="line-added">741   ResourceMark rm;</span>
<span class="line-added">742   log_info(biasedlocking)(&quot;Revoking bias by walking my own stack:&quot;);</span>
<span class="line-added">743   EventBiasedLockSelfRevocation event;</span>
<span class="line-added">744   BiasedLocking::walk_stack_and_revoke(obj(), (JavaThread*) thread);</span>
<span class="line-added">745   thread-&gt;set_cached_monitor_info(NULL);</span>
<span class="line-added">746   assert(!obj-&gt;mark().has_bias_pattern(), &quot;invariant&quot;);</span>
747   if (event.should_commit()) {
<span class="line-modified">748     post_self_revocation_event(&amp;event, k);</span>
749   }

750 }
751 
<span class="line-modified">752 void BiasedLocking::revoke(Handle obj, TRAPS) {</span>

753   assert(!SafepointSynchronize::is_at_safepoint(), &quot;must not be called while at safepoint&quot;);
<span class="line-modified">754 </span>
<span class="line-modified">755   while (true) {</span>
<span class="line-added">756     // We can revoke the biases of anonymously-biased objects</span>
<span class="line-added">757     // efficiently enough that we should not cause these revocations to</span>
<span class="line-added">758     // update the heuristics because doing so may cause unwanted bulk</span>
<span class="line-added">759     // revocations (which are expensive) to occur.</span>
<span class="line-added">760     markWord mark = obj-&gt;mark();</span>
<span class="line-added">761 </span>
<span class="line-added">762     if (!mark.has_bias_pattern()) {</span>
<span class="line-added">763       return;</span>
<span class="line-added">764     }</span>
<span class="line-added">765 </span>
<span class="line-added">766     if (mark.is_biased_anonymously()) {</span>
<span class="line-added">767       // We are probably trying to revoke the bias of this object due to</span>
<span class="line-added">768       // an identity hash code computation. Try to revoke the bias</span>
<span class="line-added">769       // without a safepoint. This is possible if we can successfully</span>
<span class="line-added">770       // compare-and-exchange an unbiased header into the mark word of</span>
<span class="line-added">771       // the object, meaning that no other thread has raced to acquire</span>
<span class="line-added">772       // the bias of the object.</span>
<span class="line-added">773       markWord biased_value       = mark;</span>
<span class="line-added">774       markWord unbiased_prototype = markWord::prototype().set_age(mark.age());</span>
<span class="line-added">775       markWord res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);</span>
<span class="line-added">776       if (res_mark == biased_value) {</span>
<span class="line-added">777         return;</span>
<span class="line-added">778       }</span>
<span class="line-added">779       mark = res_mark;  // Refresh mark with the latest value.</span>
<span class="line-added">780     } else {</span>
<span class="line-added">781       Klass* k = obj-&gt;klass();</span>
<span class="line-added">782       markWord prototype_header = k-&gt;prototype_header();</span>
<span class="line-added">783       if (!prototype_header.has_bias_pattern()) {</span>
<span class="line-added">784         // This object has a stale bias from before the bulk revocation</span>
<span class="line-added">785         // for this data type occurred. It&#39;s pointless to update the</span>
<span class="line-added">786         // heuristics at this point so simply update the header with a</span>
<span class="line-added">787         // CAS. If we fail this race, the object&#39;s bias has been revoked</span>
<span class="line-added">788         // by another thread so we simply return and let the caller deal</span>
<span class="line-added">789         // with it.</span>
<span class="line-added">790         obj-&gt;cas_set_mark(prototype_header.set_age(mark.age()), mark);</span>
<span class="line-added">791         assert(!obj-&gt;mark().has_bias_pattern(), &quot;even if we raced, should still be revoked&quot;);</span>
<span class="line-added">792         return;</span>
<span class="line-added">793       } else if (prototype_header.bias_epoch() != mark.bias_epoch()) {</span>
<span class="line-added">794         // The epoch of this biasing has expired indicating that the</span>
<span class="line-added">795         // object is effectively unbiased. We can revoke the bias of this</span>
<span class="line-added">796         // object efficiently enough with a CAS that we shouldn&#39;t update the</span>
<span class="line-added">797         // heuristics. This is normally done in the assembly code but we</span>
<span class="line-added">798         // can reach this point due to various points in the runtime</span>
<span class="line-added">799         // needing to revoke biases.</span>
<span class="line-added">800         markWord res_mark;</span>
<span class="line-added">801         markWord biased_value       = mark;</span>
<span class="line-added">802         markWord unbiased_prototype = markWord::prototype().set_age(mark.age());</span>
<span class="line-added">803         res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);</span>
<span class="line-added">804         if (res_mark == biased_value) {</span>
<span class="line-added">805           return;</span>
<span class="line-added">806         }</span>
<span class="line-added">807         mark = res_mark;  // Refresh mark with the latest value.</span>
<span class="line-added">808       }</span>
<span class="line-added">809     }</span>
<span class="line-added">810 </span>
<span class="line-added">811     HeuristicsResult heuristics = update_heuristics(obj());</span>
<span class="line-added">812     if (heuristics == HR_NOT_BIASED) {</span>
<span class="line-added">813       return;</span>
<span class="line-added">814     } else if (heuristics == HR_SINGLE_REVOKE) {</span>
<span class="line-added">815       JavaThread *blt = mark.biased_locker();</span>
<span class="line-added">816       assert(blt != NULL, &quot;invariant&quot;);</span>
<span class="line-added">817       if (blt == THREAD) {</span>
<span class="line-added">818         // A thread is trying to revoke the bias of an object biased</span>
<span class="line-added">819         // toward it, again likely due to an identity hash code</span>
<span class="line-added">820         // computation. We can again avoid a safepoint/handshake in this case</span>
<span class="line-added">821         // since we are only going to walk our own stack. There are no</span>
<span class="line-added">822         // races with revocations occurring in other threads because we</span>
<span class="line-added">823         // reach no safepoints in the revocation path.</span>
<span class="line-added">824         EventBiasedLockSelfRevocation event;</span>
<span class="line-added">825         ResourceMark rm;</span>
<span class="line-added">826         walk_stack_and_revoke(obj(), blt);</span>
<span class="line-added">827         blt-&gt;set_cached_monitor_info(NULL);</span>
<span class="line-added">828         assert(!obj-&gt;mark().has_bias_pattern(), &quot;invariant&quot;);</span>
<span class="line-added">829         if (event.should_commit()) {</span>
<span class="line-added">830           post_self_revocation_event(&amp;event, obj-&gt;klass());</span>
<span class="line-added">831         }</span>
<span class="line-added">832         return;</span>
<span class="line-added">833       } else {</span>
<span class="line-added">834         BiasedLocking::Condition cond = single_revoke_with_handshake(obj, (JavaThread*)THREAD, blt);</span>
<span class="line-added">835         if (cond != NOT_REVOKED) {</span>
<span class="line-added">836           return;</span>
<span class="line-added">837         }</span>
<span class="line-added">838       }</span>
<span class="line-added">839     } else {</span>
<span class="line-added">840       assert((heuristics == HR_BULK_REVOKE) ||</span>
<span class="line-added">841          (heuristics == HR_BULK_REBIAS), &quot;?&quot;);</span>
<span class="line-added">842       EventBiasedLockClassRevocation event;</span>
<span class="line-added">843       VM_BulkRevokeBias bulk_revoke(&amp;obj, (JavaThread*)THREAD,</span>
<span class="line-added">844                                     (heuristics == HR_BULK_REBIAS));</span>
<span class="line-added">845       VMThread::execute(&amp;bulk_revoke);</span>
<span class="line-added">846       if (event.should_commit()) {</span>
<span class="line-added">847         post_class_revocation_event(&amp;event, obj-&gt;klass(), &amp;bulk_revoke);</span>
<span class="line-added">848       }</span>
<span class="line-added">849       return;</span>
<span class="line-added">850     }</span>
<span class="line-added">851   }</span>
<span class="line-added">852 }</span>
<span class="line-added">853 </span>
<span class="line-added">854 // All objects in objs should be locked by biaser</span>
<span class="line-added">855 void BiasedLocking::revoke(GrowableArray&lt;Handle&gt;* objs, JavaThread *biaser) {</span>
<span class="line-added">856   bool clean_my_cache = false;</span>
<span class="line-added">857   for (int i = 0; i &lt; objs-&gt;length(); i++) {</span>
<span class="line-added">858     oop obj = (objs-&gt;at(i))();</span>
<span class="line-added">859     markWord mark = obj-&gt;mark();</span>
<span class="line-added">860     if (mark.has_bias_pattern()) {</span>
<span class="line-added">861       walk_stack_and_revoke(obj, biaser);</span>
<span class="line-added">862       clean_my_cache = true;</span>
<span class="line-added">863     }</span>
<span class="line-added">864   }</span>
<span class="line-added">865   if (clean_my_cache) {</span>
<span class="line-added">866     clean_up_cached_monitor_info(biaser);</span>
867   }


868 }
869 
870 
871 void BiasedLocking::revoke_at_safepoint(Handle h_obj) {
872   assert(SafepointSynchronize::is_at_safepoint(), &quot;must only be called while at safepoint&quot;);
873   oop obj = h_obj();
<span class="line-modified">874   HeuristicsResult heuristics = update_heuristics(obj);</span>
875   if (heuristics == HR_SINGLE_REVOKE) {
<span class="line-modified">876     JavaThread* biased_locker = NULL;</span>
<span class="line-added">877     single_revoke_at_safepoint(obj, false, NULL, &amp;biased_locker);</span>
<span class="line-added">878     if (biased_locker) {</span>
<span class="line-added">879       clean_up_cached_monitor_info(biased_locker);</span>
<span class="line-added">880     }</span>
881   } else if ((heuristics == HR_BULK_REBIAS) ||
882              (heuristics == HR_BULK_REVOKE)) {
<span class="line-modified">883     bulk_revoke_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), NULL);</span>
<span class="line-modified">884     clean_up_cached_monitor_info();</span>
















885   }

886 }
887 
888 
889 void BiasedLocking::preserve_marks() {
890   if (!UseBiasedLocking)
891     return;
892 
893   assert(SafepointSynchronize::is_at_safepoint(), &quot;must only be called while at safepoint&quot;);
894 
895   assert(_preserved_oop_stack  == NULL, &quot;double initialization&quot;);
896   assert(_preserved_mark_stack == NULL, &quot;double initialization&quot;);
897 
898   // In order to reduce the number of mark words preserved during GC
899   // due to the presence of biased locking, we reinitialize most mark
900   // words to the class&#39;s prototype during GC -- even those which have
901   // a currently valid bias owner. One important situation where we
902   // must not clobber a bias is when a biased object is currently
903   // locked. To handle this case we iterate over the currently-locked
904   // monitors in a prepass and, if they are biased, preserve their
905   // mark words here. This should be a relatively small set of objects
906   // especially compared to the number of objects in the heap.
<span class="line-modified">907   _preserved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;markWord&gt;(10, true);</span>
908   _preserved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;Handle&gt;(10, true);
909 
910   ResourceMark rm;
911   Thread* cur = Thread::current();
912   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
913     if (thread-&gt;has_last_Java_frame()) {
914       RegisterMap rm(thread);
915       for (javaVFrame* vf = thread-&gt;last_java_vframe(&amp;rm); vf != NULL; vf = vf-&gt;java_sender()) {
916         GrowableArray&lt;MonitorInfo*&gt; *monitors = vf-&gt;monitors();
917         if (monitors != NULL) {
918           int len = monitors-&gt;length();
919           // Walk monitors youngest to oldest
920           for (int i = len - 1; i &gt;= 0; i--) {
921             MonitorInfo* mon_info = monitors-&gt;at(i);
922             if (mon_info-&gt;owner_is_scalar_replaced()) continue;
923             oop owner = mon_info-&gt;owner();
924             if (owner != NULL) {
<span class="line-modified">925               markWord mark = owner-&gt;mark();</span>
<span class="line-modified">926               if (mark.has_bias_pattern()) {</span>
927                 _preserved_oop_stack-&gt;push(Handle(cur, owner));
928                 _preserved_mark_stack-&gt;push(mark);
929               }
930             }
931           }
932         }
933       }
934     }
935   }
936 }
937 
938 
939 void BiasedLocking::restore_marks() {
940   if (!UseBiasedLocking)
941     return;
942 
943   assert(_preserved_oop_stack  != NULL, &quot;double free&quot;);
944   assert(_preserved_mark_stack != NULL, &quot;double free&quot;);
945 
946   int len = _preserved_oop_stack-&gt;length();
947   for (int i = 0; i &lt; len; i++) {
948     Handle owner = _preserved_oop_stack-&gt;at(i);
<span class="line-modified">949     markWord mark = _preserved_mark_stack-&gt;at(i);</span>
950     owner-&gt;set_mark(mark);
951   }
952 
953   delete _preserved_oop_stack;
954   _preserved_oop_stack = NULL;
955   delete _preserved_mark_stack;
956   _preserved_mark_stack = NULL;
957 }
958 
959 
960 int* BiasedLocking::total_entry_count_addr()                   { return _counters.total_entry_count_addr(); }
961 int* BiasedLocking::biased_lock_entry_count_addr()             { return _counters.biased_lock_entry_count_addr(); }
962 int* BiasedLocking::anonymously_biased_lock_entry_count_addr() { return _counters.anonymously_biased_lock_entry_count_addr(); }
963 int* BiasedLocking::rebiased_lock_entry_count_addr()           { return _counters.rebiased_lock_entry_count_addr(); }
964 int* BiasedLocking::revoked_lock_entry_count_addr()            { return _counters.revoked_lock_entry_count_addr(); }
<span class="line-added">965 int* BiasedLocking::handshakes_count_addr()                    { return _counters.handshakes_count_addr(); }</span>
966 int* BiasedLocking::fast_path_entry_count_addr()               { return _counters.fast_path_entry_count_addr(); }
967 int* BiasedLocking::slow_path_entry_count_addr()               { return _counters.slow_path_entry_count_addr(); }
968 
969 
970 // BiasedLockingCounters
971 
<span class="line-modified">972 int BiasedLockingCounters::slow_path_entry_count() const {</span>
973   if (_slow_path_entry_count != 0) {
974     return _slow_path_entry_count;
975   }
976   int sum = _biased_lock_entry_count   + _anonymously_biased_lock_entry_count +
977             _rebiased_lock_entry_count + _revoked_lock_entry_count +
978             _fast_path_entry_count;
979 
980   return _total_entry_count - sum;
981 }
982 
<span class="line-modified">983 void BiasedLockingCounters::print_on(outputStream* st) const {</span>
984   tty-&gt;print_cr(&quot;# total entries: %d&quot;, _total_entry_count);
985   tty-&gt;print_cr(&quot;# biased lock entries: %d&quot;, _biased_lock_entry_count);
986   tty-&gt;print_cr(&quot;# anonymously biased lock entries: %d&quot;, _anonymously_biased_lock_entry_count);
987   tty-&gt;print_cr(&quot;# rebiased lock entries: %d&quot;, _rebiased_lock_entry_count);
988   tty-&gt;print_cr(&quot;# revoked lock entries: %d&quot;, _revoked_lock_entry_count);
<span class="line-added">989   tty-&gt;print_cr(&quot;# handshakes entries: %d&quot;, _handshakes_count);</span>
990   tty-&gt;print_cr(&quot;# fast path lock entries: %d&quot;, _fast_path_entry_count);
991   tty-&gt;print_cr(&quot;# slow path lock entries: %d&quot;, slow_path_entry_count());
992 }
<span class="line-added">993 </span>
<span class="line-added">994 void BiasedLockingCounters::print() const { print_on(tty); }</span>
</pre>
</td>
</tr>
</table>
<center><a href="basicLock.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="biasedLocking.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
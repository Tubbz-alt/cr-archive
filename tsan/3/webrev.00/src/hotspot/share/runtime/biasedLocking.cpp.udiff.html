<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/biasedLocking.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="basicLock.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="biasedLocking.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/biasedLocking.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27,50 +27,51 @@</span>
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;jfr/support/jfrThreadId.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;oops/markOop.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/basicLock.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/handshake.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/safepointMechanism.hpp&quot;</span>
  #include &quot;runtime/task.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
  #include &quot;runtime/vframe.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
  
  
  static bool _biased_locking_enabled = false;
  BiasedLockingCounters BiasedLocking::_counters;
  
<span class="udiff-line-modified-removed">- static GrowableArray&lt;Handle&gt;*  _preserved_oop_stack  = NULL;</span>
<span class="udiff-line-modified-removed">- static GrowableArray&lt;markOop&gt;* _preserved_mark_stack = NULL;</span>
<span class="udiff-line-modified-added">+ static GrowableArray&lt;Handle&gt;*   _preserved_oop_stack  = NULL;</span>
<span class="udiff-line-modified-added">+ static GrowableArray&lt;markWord&gt;* _preserved_mark_stack = NULL;</span>
  
  static void enable_biased_locking(InstanceKlass* k) {
<span class="udiff-line-modified-removed">-   k-&gt;set_prototype_header(markOopDesc::biased_locking_prototype());</span>
<span class="udiff-line-modified-added">+   k-&gt;set_prototype_header(markWord::biased_locking_prototype());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void enable_biased_locking() {</span>
<span class="udiff-line-added">+   _biased_locking_enabled = true;</span>
<span class="udiff-line-added">+   log_info(biasedlocking)(&quot;Biased locking enabled&quot;);</span>
  }
  
  class VM_EnableBiasedLocking: public VM_Operation {
<span class="udiff-line-removed">-  private:</span>
<span class="udiff-line-removed">-   bool _is_cheap_allocated;</span>
   public:
<span class="udiff-line-modified-removed">-   VM_EnableBiasedLocking(bool is_cheap_allocated) { _is_cheap_allocated = is_cheap_allocated; }</span>
<span class="udiff-line-modified-added">+   VM_EnableBiasedLocking() {}</span>
    VMOp_Type type() const          { return VMOp_EnableBiasedLocking; }
<span class="udiff-line-removed">-   Mode evaluation_mode() const    { return _is_cheap_allocated ? _async_safepoint : _safepoint; }</span>
<span class="udiff-line-removed">-   bool is_cheap_allocated() const { return _is_cheap_allocated; }</span>
  
    void doit() {
      // Iterate the class loader data dictionaries enabling biased locking for all
      // currently loaded classes.
      ClassLoaderDataGraph::dictionary_classes_do(enable_biased_locking);
      // Indicate that future instances should enable it as well
<span class="udiff-line-modified-removed">-     _biased_locking_enabled = true;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     log_info(biasedlocking)(&quot;Biased locking enabled&quot;);</span>
<span class="udiff-line-modified-added">+     enable_biased_locking();</span>
    }
  
    bool allow_nested_vm_operations() const        { return false; }
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79,45 +80,46 @@</span>
  class EnableBiasedLockingTask : public PeriodicTask {
   public:
    EnableBiasedLockingTask(size_t interval_time) : PeriodicTask(interval_time) {}
  
    virtual void task() {
<span class="udiff-line-modified-removed">-     // Use async VM operation to avoid blocking the Watcher thread.</span>
<span class="udiff-line-modified-removed">-     // VM Thread will free C heap storage.</span>
<span class="udiff-line-removed">-     VM_EnableBiasedLocking *op = new VM_EnableBiasedLocking(true);</span>
<span class="udiff-line-removed">-     VMThread::execute(op);</span>
<span class="udiff-line-modified-added">+     VM_EnableBiasedLocking op;</span>
<span class="udiff-line-modified-added">+     VMThread::execute(&amp;op);</span>
  
      // Reclaim our storage and disenroll ourself
      delete this;
    }
  };
  
  
  void BiasedLocking::init() {
<span class="udiff-line-modified-removed">-   // If biased locking is enabled, schedule a task to fire a few</span>
<span class="udiff-line-modified-removed">-   // seconds into the run which turns on biased locking for all</span>
<span class="udiff-line-modified-removed">-   // currently loaded classes as well as future ones. This is a</span>
<span class="udiff-line-modified-removed">-   // workaround for startup time regressions due to a large number of</span>
<span class="udiff-line-modified-removed">-   // safepoints being taken during VM startup for bias revocation.</span>
<span class="udiff-line-modified-removed">-   // Ideally we would have a lower cost for individual bias revocation</span>
<span class="udiff-line-removed">-   // and not need a mechanism like this.</span>
<span class="udiff-line-modified-added">+   // If biased locking is enabled and BiasedLockingStartupDelay is set,</span>
<span class="udiff-line-modified-added">+   // schedule a task to fire after the specified delay which turns on</span>
<span class="udiff-line-modified-added">+   // biased locking for all currently loaded classes as well as future</span>
<span class="udiff-line-modified-added">+   // ones. This could be a workaround for startup time regressions</span>
<span class="udiff-line-modified-added">+   // due to large number of safepoints being taken during VM startup for</span>
<span class="udiff-line-modified-added">+   // bias revocation.</span>
    if (UseBiasedLocking) {
      if (BiasedLockingStartupDelay &gt; 0) {
        EnableBiasedLockingTask* task = new EnableBiasedLockingTask(BiasedLockingStartupDelay);
        task-&gt;enroll();
      } else {
<span class="udiff-line-modified-removed">-       VM_EnableBiasedLocking op(false);</span>
<span class="udiff-line-removed">-       VMThread::execute(&amp;op);</span>
<span class="udiff-line-modified-added">+       enable_biased_locking();</span>
      }
    }
  }
  
  
  bool BiasedLocking::enabled() {
<span class="udiff-line-modified-removed">-   return _biased_locking_enabled;</span>
<span class="udiff-line-modified-added">+   assert(UseBiasedLocking, &quot;precondition&quot;);</span>
<span class="udiff-line-added">+   // We check &quot;BiasedLockingStartupDelay == 0&quot; here to cover the</span>
<span class="udiff-line-added">+   // possibility of calls to BiasedLocking::enabled() before</span>
<span class="udiff-line-added">+   // BiasedLocking::init().</span>
<span class="udiff-line-added">+   return _biased_locking_enabled || BiasedLockingStartupDelay == 0;</span>
  }
  
<span class="udiff-line-added">+ </span>
  // Returns MonitorInfos for all objects locked on this thread in youngest to oldest order
  static GrowableArray&lt;MonitorInfo*&gt;* get_or_compute_monitor_info(JavaThread* thread) {
    GrowableArray&lt;MonitorInfo*&gt;* info = thread-&gt;cached_monitor_info();
    if (info != NULL) {
      return info;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,72 +150,72 @@</span>
  
    thread-&gt;set_cached_monitor_info(info);
    return info;
  }
  
<span class="udiff-line-added">+ </span>
  // After the call, *biased_locker will be set to obj-&gt;mark()-&gt;biased_locker() if biased_locker != NULL,
  // AND it is a living thread. Otherwise it will not be updated, (i.e. the caller is responsible for initialization).
<span class="udiff-line-modified-removed">- static BiasedLocking::Condition revoke_bias(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread, JavaThread** biased_locker) {</span>
<span class="udiff-line-modified-removed">-   markOop mark = obj-&gt;mark();</span>
<span class="udiff-line-modified-removed">-   if (!mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+ void BiasedLocking::single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requesting_thread, JavaThread** biased_locker) {</span>
<span class="udiff-line-modified-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be done at safepoint&quot;);</span>
<span class="udiff-line-modified-added">+   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   markWord mark = obj-&gt;mark();</span>
<span class="udiff-line-added">+   if (!mark.has_bias_pattern()) {</span>
      if (log_is_enabled(Info, biasedlocking)) {
        ResourceMark rm;
        log_info(biasedlocking)(&quot;  (Skipping revocation of object &quot; INTPTR_FORMAT
                                &quot;, mark &quot; INTPTR_FORMAT &quot;, type %s&quot;
                                &quot;, requesting thread &quot; INTPTR_FORMAT
                                &quot; because it&#39;s no longer biased)&quot;,
<span class="udiff-line-modified-removed">-                               p2i((void *)obj), (intptr_t) mark,</span>
<span class="udiff-line-modified-added">+                               p2i((void *)obj), mark.value(),</span>
                                obj-&gt;klass()-&gt;external_name(),
                                (intptr_t) requesting_thread);
      }
<span class="udiff-line-modified-removed">-     return BiasedLocking::NOT_BIASED;</span>
<span class="udiff-line-modified-added">+     return;</span>
    }
  
<span class="udiff-line-modified-removed">-   uint age = mark-&gt;age();</span>
<span class="udiff-line-modified-removed">-   markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);</span>
<span class="udiff-line-removed">-   markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);</span>
<span class="udiff-line-modified-added">+   uint age = mark.age();</span>
<span class="udiff-line-modified-added">+   markWord unbiased_prototype = markWord::prototype().set_age(age);</span>
  
    // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
    if (!is_bulk) {
      ResourceMark rm;
      log_info(biasedlocking)(&quot;Revoking bias of object &quot; INTPTR_FORMAT &quot;, mark &quot;
                              INTPTR_FORMAT &quot;, type %s, prototype header &quot; INTPTR_FORMAT
<span class="udiff-line-modified-removed">-                             &quot;, allow rebias %d, requesting thread &quot; INTPTR_FORMAT,</span>
<span class="udiff-line-modified-added">+                             &quot;, requesting thread &quot; INTPTR_FORMAT,</span>
                              p2i((void *)obj),
<span class="udiff-line-modified-removed">-                             (intptr_t) mark,</span>
<span class="udiff-line-modified-added">+                             mark.value(),</span>
                              obj-&gt;klass()-&gt;external_name(),
<span class="udiff-line-modified-removed">-                             (intptr_t) obj-&gt;klass()-&gt;prototype_header(),</span>
<span class="udiff-line-removed">-                             (allow_rebias ? 1 : 0),</span>
<span class="udiff-line-modified-added">+                             obj-&gt;klass()-&gt;prototype_header().value(),</span>
                              (intptr_t) requesting_thread);
    } else {
      ResourceMark rm;
      log_trace(biasedlocking)(&quot;Revoking bias of object &quot; INTPTR_FORMAT &quot; , mark &quot;
                               INTPTR_FORMAT &quot; , type %s , prototype header &quot; INTPTR_FORMAT
<span class="udiff-line-modified-removed">-                              &quot; , allow rebias %d , requesting thread &quot; INTPTR_FORMAT,</span>
<span class="udiff-line-modified-added">+                              &quot; , requesting thread &quot; INTPTR_FORMAT,</span>
                               p2i((void *)obj),
<span class="udiff-line-modified-removed">-                              (intptr_t) mark,</span>
<span class="udiff-line-modified-added">+                              mark.value(),</span>
                               obj-&gt;klass()-&gt;external_name(),
<span class="udiff-line-modified-removed">-                              (intptr_t) obj-&gt;klass()-&gt;prototype_header(),</span>
<span class="udiff-line-removed">-                              (allow_rebias ? 1 : 0),</span>
<span class="udiff-line-modified-added">+                              obj-&gt;klass()-&gt;prototype_header().value(),</span>
                               (intptr_t) requesting_thread);
    }
  
<span class="udiff-line-modified-removed">-   JavaThread* biased_thread = mark-&gt;biased_locker();</span>
<span class="udiff-line-modified-added">+   JavaThread* biased_thread = mark.biased_locker();</span>
    if (biased_thread == NULL) {
      // Object is anonymously biased. We can get here if, for
      // example, we revoke the bias due to an identity hash code
      // being computed for an object.
<span class="udiff-line-modified-removed">-     if (!allow_rebias) {</span>
<span class="udiff-line-modified-removed">-       obj-&gt;set_mark(unbiased_prototype);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     obj-&gt;set_mark(unbiased_prototype);</span>
<span class="udiff-line-modified-added">+ </span>
      // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
      if (!is_bulk) {
        log_info(biasedlocking)(&quot;  Revoked bias of anonymously-biased object&quot;);
      } else {
        log_trace(biasedlocking)(&quot;  Revoked bias of anonymously-biased object&quot;);
      }
<span class="udiff-line-modified-removed">-     return BiasedLocking::BIAS_REVOKED;</span>
<span class="udiff-line-modified-added">+     return;</span>
    }
  
    // Handle case where the thread toward which the object was biased has exited
    bool thread_is_alive = false;
    if (requesting_thread == biased_thread) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -221,24 +223,20 @@</span>
    } else {
      ThreadsListHandle tlh;
      thread_is_alive = tlh.includes(biased_thread);
    }
    if (!thread_is_alive) {
<span class="udiff-line-modified-removed">-     if (allow_rebias) {</span>
<span class="udiff-line-removed">-       obj-&gt;set_mark(biased_prototype);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       obj-&gt;set_mark(unbiased_prototype);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     obj-&gt;set_mark(unbiased_prototype);</span>
      // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
      if (!is_bulk) {
        log_info(biasedlocking)(&quot;  Revoked bias of object biased toward dead thread (&quot;
                                PTR_FORMAT &quot;)&quot;, p2i(biased_thread));
      } else {
        log_trace(biasedlocking)(&quot;  Revoked bias of object biased toward dead thread (&quot;
                                 PTR_FORMAT &quot;)&quot;, p2i(biased_thread));
      }
<span class="udiff-line-modified-removed">-     return BiasedLocking::BIAS_REVOKED;</span>
<span class="udiff-line-modified-added">+     return;</span>
    }
  
    // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
    if (!is_bulk) {
      log_info(biasedlocking)(&quot;  Revoked bias of object biased toward live thread (&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -255,16 +253,16 @@</span>
    // or unbiased state.
    GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);
    BasicLock* highest_lock = NULL;
    for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
      MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
<span class="udiff-line-modified-removed">-     if (oopDesc::equals(mon_info-&gt;owner(), obj)) {</span>
<span class="udiff-line-modified-added">+     if (mon_info-&gt;owner() == obj) {</span>
        log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) == obj (&quot; PTR_FORMAT &quot;)&quot;,
                                 p2i((void *) mon_info-&gt;owner()),
                                 p2i((void *) obj));
<span class="udiff-line-modified-removed">-       // Assume recursive case and fix up highest lock later</span>
<span class="udiff-line-modified-removed">-       markOop mark = markOopDesc::encode((BasicLock*) NULL);</span>
<span class="udiff-line-modified-added">+       // Assume recursive case and fix up highest lock below</span>
<span class="udiff-line-modified-added">+       markWord mark = markWord::encode((BasicLock*) NULL);</span>
        highest_lock = mon_info-&gt;lock();
        highest_lock-&gt;set_displaced_header(mark);
      } else {
        log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) != obj (&quot; PTR_FORMAT &quot;)&quot;,
                                 p2i((void *) mon_info-&gt;owner()),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -274,14 +272,14 @@</span>
    if (highest_lock != NULL) {
      // Fix up highest lock to contain displaced header and point
      // object at it
      highest_lock-&gt;set_displaced_header(unbiased_prototype);
      // Reset object header to point to displaced mark.
<span class="udiff-line-modified-removed">-     // Must release storing the lock address for platforms without TSO</span>
<span class="udiff-line-modified-added">+     // Must release store the lock address for platforms without TSO</span>
      // ordering (e.g. ppc).
<span class="udiff-line-modified-removed">-     obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));</span>
<span class="udiff-line-modified-removed">-     assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;illegal mark state: stack lock used bias bit&quot;);</span>
<span class="udiff-line-modified-added">+     obj-&gt;release_set_mark(markWord::encode(highest_lock));</span>
<span class="udiff-line-modified-added">+     assert(!obj-&gt;mark().has_bias_pattern(), &quot;illegal mark state: stack lock used bias bit&quot;);</span>
      // Log at &quot;info&quot; level if not bulk, else &quot;trace&quot; level
      if (!is_bulk) {
        log_info(biasedlocking)(&quot;  Revoked bias of currently-locked object&quot;);
      } else {
        log_trace(biasedlocking)(&quot;  Revoked bias of currently-locked object&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -291,24 +289,18 @@</span>
      if (!is_bulk) {
        log_info(biasedlocking)(&quot;  Revoked bias of currently-unlocked object&quot;);
      } else {
        log_trace(biasedlocking)(&quot;  Revoked bias of currently-unlocked object&quot;);
      }
<span class="udiff-line-modified-removed">-     if (allow_rebias) {</span>
<span class="udiff-line-modified-removed">-       obj-&gt;set_mark(biased_prototype);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       // Store the unlocked value into the object&#39;s header.</span>
<span class="udiff-line-removed">-       obj-&gt;set_mark(unbiased_prototype);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     // Store the unlocked value into the object&#39;s header.</span>
<span class="udiff-line-modified-added">+     obj-&gt;set_mark(unbiased_prototype);</span>
    }
  
    // If requested, return information on which thread held the bias
    if (biased_locker != NULL) {
      *biased_locker = biased_thread;
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return BiasedLocking::BIAS_REVOKED;</span>
  }
  
  
  enum HeuristicsResult {
    HR_NOT_BIASED    = 1,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -316,13 +308,13 @@</span>
    HR_BULK_REBIAS   = 3,
    HR_BULK_REVOKE   = 4
  };
  
  
<span class="udiff-line-modified-removed">- static HeuristicsResult update_heuristics(oop o, bool allow_rebias) {</span>
<span class="udiff-line-modified-removed">-   markOop mark = o-&gt;mark();</span>
<span class="udiff-line-modified-removed">-   if (!mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+ static HeuristicsResult update_heuristics(oop o) {</span>
<span class="udiff-line-modified-added">+   markWord mark = o-&gt;mark();</span>
<span class="udiff-line-modified-added">+   if (!mark.has_bias_pattern()) {</span>
      return HR_NOT_BIASED;
    }
  
    // Heuristics to attempt to throttle the number of revocations.
    // Stages:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -330,11 +322,11 @@</span>
    //    but allow rebiasing of those objects if unlocked.
    // 2. Revoke the biases of all objects in the heap of this type
    //    and don&#39;t allow rebiasing of these objects. Disable
    //    allocation of objects of that type with the bias bit set.
    Klass* k = o-&gt;klass();
<span class="udiff-line-modified-removed">-   jlong cur_time = os::javaTimeMillis();</span>
<span class="udiff-line-modified-added">+   jlong cur_time = nanos_to_millis(os::javaTimeNanos());</span>
    jlong last_bulk_revocation_time = k-&gt;last_biased_lock_bulk_revocation_time();
    int revocation_count = k-&gt;biased_lock_revocation_count();
    if ((revocation_count &gt;= BiasedLockingBulkRebiasThreshold) &amp;&amp;
        (revocation_count &lt;  BiasedLockingBulkRevokeThreshold) &amp;&amp;
        (last_bulk_revocation_time != 0) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -369,27 +361,24 @@</span>
  
    return HR_SINGLE_REVOKE;
  }
  
  
<span class="udiff-line-modified-removed">- static BiasedLocking::Condition bulk_revoke_or_rebias_at_safepoint(oop o,</span>
<span class="udiff-line-removed">-                                                                    bool bulk_rebias,</span>
<span class="udiff-line-removed">-                                                                    bool attempt_rebias_of_object,</span>
<span class="udiff-line-removed">-                                                                    JavaThread* requesting_thread) {</span>
<span class="udiff-line-modified-added">+ void BiasedLocking::bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requesting_thread) {</span>
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must be done at safepoint&quot;);
<span class="udiff-line-added">+   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);</span>
  
    log_info(biasedlocking)(&quot;* Beginning bulk revocation (kind == %s) because of object &quot;
                            INTPTR_FORMAT &quot; , mark &quot; INTPTR_FORMAT &quot; , type %s&quot;,
                            (bulk_rebias ? &quot;rebias&quot; : &quot;revoke&quot;),
                            p2i((void *) o),
<span class="udiff-line-modified-removed">-                           (intptr_t) o-&gt;mark(),</span>
<span class="udiff-line-modified-added">+                           o-&gt;mark().value(),</span>
                            o-&gt;klass()-&gt;external_name());
  
<span class="udiff-line-modified-removed">-   jlong cur_time = os::javaTimeMillis();</span>
<span class="udiff-line-modified-added">+   jlong cur_time = nanos_to_millis(os::javaTimeNanos());</span>
    o-&gt;klass()-&gt;set_last_biased_lock_bulk_revocation_time(cur_time);
  
<span class="udiff-line-removed">- </span>
    Klass* k_o = o-&gt;klass();
    Klass* klass = k_o;
  
    {
      JavaThreadIteratorWithHandle jtiwh;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -403,156 +392,184 @@</span>
  
        // If the prototype header doesn&#39;t have the bias pattern, don&#39;t
        // try to update the epoch -- assume another VM operation came in
        // and reset the header to the unbiased state, which will
        // implicitly cause all existing biases to be revoked
<span class="udiff-line-modified-removed">-       if (klass-&gt;prototype_header()-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-removed">-         int prev_epoch = klass-&gt;prototype_header()-&gt;bias_epoch();</span>
<span class="udiff-line-modified-removed">-         klass-&gt;set_prototype_header(klass-&gt;prototype_header()-&gt;incr_bias_epoch());</span>
<span class="udiff-line-modified-removed">-         int cur_epoch = klass-&gt;prototype_header()-&gt;bias_epoch();</span>
<span class="udiff-line-modified-added">+       if (klass-&gt;prototype_header().has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+         int prev_epoch = klass-&gt;prototype_header().bias_epoch();</span>
<span class="udiff-line-modified-added">+         klass-&gt;set_prototype_header(klass-&gt;prototype_header().incr_bias_epoch());</span>
<span class="udiff-line-modified-added">+         int cur_epoch = klass-&gt;prototype_header().bias_epoch();</span>
  
          // Now walk all threads&#39; stacks and adjust epochs of any biased
          // and locked objects of this data type we encounter
          for (; JavaThread *thr = jtiwh.next(); ) {
            GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(thr);
            for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
              MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
              oop owner = mon_info-&gt;owner();
<span class="udiff-line-modified-removed">-             markOop mark = owner-&gt;mark();</span>
<span class="udiff-line-modified-removed">-             if ((owner-&gt;klass() == k_o) &amp;&amp; mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+             markWord mark = owner-&gt;mark();</span>
<span class="udiff-line-modified-added">+             if ((owner-&gt;klass() == k_o) &amp;&amp; mark.has_bias_pattern()) {</span>
                // We might have encountered this object already in the case of recursive locking
<span class="udiff-line-modified-removed">-               assert(mark-&gt;bias_epoch() == prev_epoch || mark-&gt;bias_epoch() == cur_epoch, &quot;error in bias epoch adjustment&quot;);</span>
<span class="udiff-line-modified-removed">-               owner-&gt;set_mark(mark-&gt;set_bias_epoch(cur_epoch));</span>
<span class="udiff-line-modified-added">+               assert(mark.bias_epoch() == prev_epoch || mark.bias_epoch() == cur_epoch, &quot;error in bias epoch adjustment&quot;);</span>
<span class="udiff-line-modified-added">+               owner-&gt;set_mark(mark.set_bias_epoch(cur_epoch));</span>
              }
            }
          }
        }
  
        // At this point we&#39;re done. All we have to do is potentially
        // adjust the header of the given object to revoke its bias.
<span class="udiff-line-modified-removed">-       revoke_bias(o, attempt_rebias_of_object &amp;&amp; klass-&gt;prototype_header()-&gt;has_bias_pattern(), true, requesting_thread, NULL);</span>
<span class="udiff-line-modified-added">+       single_revoke_at_safepoint(o, true, requesting_thread, NULL);</span>
      } else {
        if (log_is_enabled(Info, biasedlocking)) {
          ResourceMark rm;
          log_info(biasedlocking)(&quot;* Disabling biased locking for type %s&quot;, klass-&gt;external_name());
        }
  
        // Disable biased locking for this data type. Not only will this
        // cause future instances to not be biased, but existing biased
        // instances will notice that this implicitly caused their biases
        // to be revoked.
<span class="udiff-line-modified-removed">-       klass-&gt;set_prototype_header(markOopDesc::prototype());</span>
<span class="udiff-line-modified-added">+       klass-&gt;set_prototype_header(markWord::prototype());</span>
  
        // Now walk all threads&#39; stacks and forcibly revoke the biases of
        // any locked and biased objects of this data type we encounter.
        for (; JavaThread *thr = jtiwh.next(); ) {
          GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(thr);
          for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {
            MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);
            oop owner = mon_info-&gt;owner();
<span class="udiff-line-modified-removed">-           markOop mark = owner-&gt;mark();</span>
<span class="udiff-line-modified-removed">-           if ((owner-&gt;klass() == k_o) &amp;&amp; mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-removed">-             revoke_bias(owner, false, true, requesting_thread, NULL);</span>
<span class="udiff-line-modified-added">+           markWord mark = owner-&gt;mark();</span>
<span class="udiff-line-modified-added">+           if ((owner-&gt;klass() == k_o) &amp;&amp; mark.has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+             single_revoke_at_safepoint(owner, true, requesting_thread, NULL);</span>
            }
          }
        }
  
        // Must force the bias of the passed object to be forcibly revoked
        // as well to ensure guarantees to callers
<span class="udiff-line-modified-removed">-       revoke_bias(o, false, true, requesting_thread, NULL);</span>
<span class="udiff-line-modified-added">+       single_revoke_at_safepoint(o, true, requesting_thread, NULL);</span>
      }
    } // ThreadsListHandle is destroyed here.
  
    log_info(biasedlocking)(&quot;* Ending bulk revocation&quot;);
  
<span class="udiff-line-modified-removed">-   BiasedLocking::Condition status_code = BiasedLocking::BIAS_REVOKED;</span>
<span class="udiff-line-modified-added">+   assert(!o-&gt;mark().has_bias_pattern(), &quot;bug in bulk bias revocation&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  
<span class="udiff-line-modified-removed">-   if (attempt_rebias_of_object &amp;&amp;</span>
<span class="udiff-line-modified-removed">-       o-&gt;mark()-&gt;has_bias_pattern() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-       klass-&gt;prototype_header()-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-removed">-     markOop new_mark = markOopDesc::encode(requesting_thread, o-&gt;mark()-&gt;age(),</span>
<span class="udiff-line-modified-removed">-                                            klass-&gt;prototype_header()-&gt;bias_epoch());</span>
<span class="udiff-line-modified-removed">-     o-&gt;set_mark(new_mark);</span>
<span class="udiff-line-modified-removed">-     status_code = BiasedLocking::BIAS_REVOKED_AND_REBIASED;</span>
<span class="udiff-line-modified-removed">-     log_info(biasedlocking)(&quot;  Rebiased object toward thread &quot; INTPTR_FORMAT, (intptr_t) requesting_thread);</span>
<span class="udiff-line-modified-added">+ static void clean_up_cached_monitor_info(JavaThread* thread = NULL) {</span>
<span class="udiff-line-modified-added">+   if (thread != NULL) {</span>
<span class="udiff-line-modified-added">+     thread-&gt;set_cached_monitor_info(NULL);</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     // Walk the thread list clearing out the cached monitors</span>
<span class="udiff-line-modified-added">+     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {</span>
<span class="udiff-line-modified-added">+       thr-&gt;set_cached_monitor_info(NULL);</span>
<span class="udiff-line-modified-added">+     }</span>
    }
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-removed">-   assert(!o-&gt;mark()-&gt;has_bias_pattern() ||</span>
<span class="udiff-line-removed">-          (attempt_rebias_of_object &amp;&amp; (o-&gt;mark()-&gt;biased_locker() == requesting_thread)),</span>
<span class="udiff-line-removed">-          &quot;bug in bulk bias revocation&quot;);</span>
  
<span class="udiff-line-modified-removed">-   return status_code;</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+ class VM_BulkRevokeBias : public VM_Operation {</span>
<span class="udiff-line-modified-added">+ private:</span>
<span class="udiff-line-added">+   Handle* _obj;</span>
<span class="udiff-line-added">+   JavaThread* _requesting_thread;</span>
<span class="udiff-line-added">+   bool _bulk_rebias;</span>
<span class="udiff-line-added">+   uint64_t _safepoint_id;</span>
  
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   VM_BulkRevokeBias(Handle* obj, JavaThread* requesting_thread,</span>
<span class="udiff-line-added">+                     bool bulk_rebias)</span>
<span class="udiff-line-added">+     : _obj(obj)</span>
<span class="udiff-line-added">+     , _requesting_thread(requesting_thread)</span>
<span class="udiff-line-added">+     , _bulk_rebias(bulk_rebias)</span>
<span class="udiff-line-added">+     , _safepoint_id(0) {}</span>
  
<span class="udiff-line-modified-removed">- static void clean_up_cached_monitor_info() {</span>
<span class="udiff-line-modified-removed">-   // Walk the thread list clearing out the cached monitors</span>
<span class="udiff-line-modified-removed">-   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {</span>
<span class="udiff-line-modified-removed">-     thr-&gt;set_cached_monitor_info(NULL);</span>
<span class="udiff-line-modified-added">+   virtual VMOp_Type type() const { return VMOp_BulkRevokeBias; }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   virtual void doit() {</span>
<span class="udiff-line-modified-added">+     BiasedLocking::bulk_revoke_at_safepoint((*_obj)(), _bulk_rebias, _requesting_thread);</span>
<span class="udiff-line-added">+     _safepoint_id = SafepointSynchronize::safepoint_id();</span>
<span class="udiff-line-added">+     clean_up_cached_monitor_info();</span>
    }
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   bool is_bulk_rebias() const {</span>
<span class="udiff-line-added">+     return _bulk_rebias;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint64_t safepoint_id() const {</span>
<span class="udiff-line-added">+     return _safepoint_id;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
  
  
<span class="udiff-line-modified-removed">- class VM_RevokeBias : public VM_Operation {</span>
<span class="udiff-line-modified-added">+ class RevokeOneBias : public HandshakeClosure {</span>
  protected:
<span class="udiff-line-modified-removed">-   Handle* _obj;</span>
<span class="udiff-line-removed">-   GrowableArray&lt;Handle&gt;* _objs;</span>
<span class="udiff-line-modified-added">+   Handle _obj;</span>
    JavaThread* _requesting_thread;
<span class="udiff-line-added">+   JavaThread* _biased_locker;</span>
    BiasedLocking::Condition _status_code;
    traceid _biased_locker_id;
  
  public:
<span class="udiff-line-modified-removed">-   VM_RevokeBias(Handle* obj, JavaThread* requesting_thread)</span>
<span class="udiff-line-modified-removed">-     : _obj(obj)</span>
<span class="udiff-line-modified-removed">-     , _objs(NULL)</span>
<span class="udiff-line-modified-added">+   RevokeOneBias(Handle obj, JavaThread* requesting_thread, JavaThread* biased_locker)</span>
<span class="udiff-line-modified-added">+     : HandshakeClosure(&quot;RevokeOneBias&quot;)</span>
<span class="udiff-line-modified-added">+     , _obj(obj)</span>
      , _requesting_thread(requesting_thread)
<span class="udiff-line-added">+     , _biased_locker(biased_locker)</span>
      , _status_code(BiasedLocking::NOT_BIASED)
      , _biased_locker_id(0) {}
  
<span class="udiff-line-modified-removed">-   VM_RevokeBias(GrowableArray&lt;Handle&gt;* objs, JavaThread* requesting_thread)</span>
<span class="udiff-line-modified-removed">-     : _obj(NULL)</span>
<span class="udiff-line-removed">-     , _objs(objs)</span>
<span class="udiff-line-removed">-     , _requesting_thread(requesting_thread)</span>
<span class="udiff-line-removed">-     , _status_code(BiasedLocking::NOT_BIASED)</span>
<span class="udiff-line-removed">-     , _biased_locker_id(0) {}</span>
<span class="udiff-line-modified-added">+   void do_thread(Thread* target) {</span>
<span class="udiff-line-modified-added">+     assert(target == _biased_locker, &quot;Wrong thread&quot;);</span>
  
<span class="udiff-line-modified-removed">-   virtual VMOp_Type type() const { return VMOp_RevokeBias; }</span>
<span class="udiff-line-modified-added">+     oop o = _obj();</span>
<span class="udiff-line-added">+     markWord mark = o-&gt;mark();</span>
  
<span class="udiff-line-modified-removed">-   virtual bool doit_prologue() {</span>
<span class="udiff-line-modified-removed">-     // Verify that there is actual work to do since the callers just</span>
<span class="udiff-line-removed">-     // give us locked object(s). If we don&#39;t find any biased objects</span>
<span class="udiff-line-removed">-     // there is nothing to do and we avoid a safepoint.</span>
<span class="udiff-line-removed">-     if (_obj != NULL) {</span>
<span class="udiff-line-removed">-       markOop mark = (*_obj)()-&gt;mark();</span>
<span class="udiff-line-removed">-       if (mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       for ( int i = 0 ; i &lt; _objs-&gt;length(); i++ ) {</span>
<span class="udiff-line-removed">-         markOop mark = (_objs-&gt;at(i))()-&gt;mark();</span>
<span class="udiff-line-removed">-         if (mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-removed">-           return true;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+     if (!mark.has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+       return;</span>
      }
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
  
<span class="udiff-line-modified-removed">-   virtual void doit() {</span>
<span class="udiff-line-modified-removed">-     if (_obj != NULL) {</span>
<span class="udiff-line-modified-removed">-       log_info(biasedlocking)(&quot;Revoking bias with potentially per-thread safepoint:&quot;);</span>
<span class="udiff-line-modified-removed">-       JavaThread* biased_locker = NULL;</span>
<span class="udiff-line-modified-removed">-       _status_code = revoke_bias((*_obj)(), false, false, _requesting_thread, &amp;biased_locker);</span>
<span class="udiff-line-modified-removed">-       if (biased_locker != NULL) {</span>
<span class="udiff-line-modified-removed">-         _biased_locker_id = JFR_THREAD_ID(biased_locker);</span>
<span class="udiff-line-modified-added">+     markWord prototype = o-&gt;klass()-&gt;prototype_header();</span>
<span class="udiff-line-modified-added">+     if (!prototype.has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+       // This object has a stale bias from before the handshake</span>
<span class="udiff-line-modified-added">+       // was requested. If we fail this race, the object&#39;s bias</span>
<span class="udiff-line-modified-added">+       // has been revoked by another thread so we simply return.</span>
<span class="udiff-line-modified-added">+       markWord biased_value = mark;</span>
<span class="udiff-line-modified-added">+       mark = o-&gt;cas_set_mark(markWord::prototype().set_age(mark.age()), mark);</span>
<span class="udiff-line-added">+       assert(!o-&gt;mark().has_bias_pattern(), &quot;even if we raced, should still be revoked&quot;);</span>
<span class="udiff-line-added">+       if (biased_value == mark) {</span>
<span class="udiff-line-added">+         _status_code = BiasedLocking::BIAS_REVOKED;</span>
        }
<span class="udiff-line-removed">-       clean_up_cached_monitor_info();</span>
        return;
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       log_info(biasedlocking)(&quot;Revoking bias with global safepoint:&quot;);</span>
<span class="udiff-line-removed">-       BiasedLocking::revoke_at_safepoint(_objs);</span>
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (_biased_locker == mark.biased_locker()) {</span>
<span class="udiff-line-added">+       if (mark.bias_epoch() == prototype.bias_epoch()) {</span>
<span class="udiff-line-added">+         // Epoch is still valid. This means biaser could be currently</span>
<span class="udiff-line-added">+         // synchronized on this object. We must walk its stack looking</span>
<span class="udiff-line-added">+         // for monitor records associated with this object and change</span>
<span class="udiff-line-added">+         // them to be stack locks if any are found.</span>
<span class="udiff-line-added">+         ResourceMark rm;</span>
<span class="udiff-line-added">+         BiasedLocking::walk_stack_and_revoke(o, _biased_locker);</span>
<span class="udiff-line-added">+         _biased_locker-&gt;set_cached_monitor_info(NULL);</span>
<span class="udiff-line-added">+         assert(!o-&gt;mark().has_bias_pattern(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+         _biased_locker_id = JFR_THREAD_ID(_biased_locker);</span>
<span class="udiff-line-added">+         _status_code = BiasedLocking::BIAS_REVOKED;</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         markWord biased_value = mark;</span>
<span class="udiff-line-added">+         mark = o-&gt;cas_set_mark(markWord::prototype().set_age(mark.age()), mark);</span>
<span class="udiff-line-added">+         if (mark == biased_value || !mark.has_bias_pattern()) {</span>
<span class="udiff-line-added">+           assert(!o-&gt;mark().has_bias_pattern(), &quot;should be revoked&quot;);</span>
<span class="udiff-line-added">+           _status_code = (biased_value == mark) ? BiasedLocking::BIAS_REVOKED : BiasedLocking::NOT_BIASED;</span>
<span class="udiff-line-added">+           return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _status_code = BiasedLocking::NOT_REVOKED;</span>
    }
  
    BiasedLocking::Condition status_code() const {
      return _status_code;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -561,220 +578,313 @@</span>
      return _biased_locker_id;
    }
  };
  
  
<span class="udiff-line-removed">- class VM_BulkRevokeBias : public VM_RevokeBias {</span>
<span class="udiff-line-removed">- private:</span>
<span class="udiff-line-removed">-   bool _bulk_rebias;</span>
<span class="udiff-line-removed">-   bool _attempt_rebias_of_object;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-   VM_BulkRevokeBias(Handle* obj, JavaThread* requesting_thread,</span>
<span class="udiff-line-removed">-                     bool bulk_rebias,</span>
<span class="udiff-line-removed">-                     bool attempt_rebias_of_object)</span>
<span class="udiff-line-removed">-     : VM_RevokeBias(obj, requesting_thread)</span>
<span class="udiff-line-removed">-     , _bulk_rebias(bulk_rebias)</span>
<span class="udiff-line-removed">-     , _attempt_rebias_of_object(attempt_rebias_of_object) {}</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   virtual VMOp_Type type() const { return VMOp_BulkRevokeBias; }</span>
<span class="udiff-line-removed">-   virtual bool doit_prologue()   { return true; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   virtual void doit() {</span>
<span class="udiff-line-removed">-     _status_code = bulk_revoke_or_rebias_at_safepoint((*_obj)(), _bulk_rebias, _attempt_rebias_of_object, _requesting_thread);</span>
<span class="udiff-line-removed">-     clean_up_cached_monitor_info();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template &lt;typename E&gt;</span>
<span class="udiff-line-removed">- static void set_safepoint_id(E* event) {</span>
<span class="udiff-line-removed">-   assert(event != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-   // Subtract 1 to match the id of events committed inside the safepoint</span>
<span class="udiff-line-removed">-   event-&gt;set_safepointId(SafepointSynchronize::safepoint_counter() - 1);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  static void post_self_revocation_event(EventBiasedLockSelfRevocation* event, Klass* k) {
    assert(event != NULL, &quot;invariant&quot;);
    assert(k != NULL, &quot;invariant&quot;);
    assert(event-&gt;should_commit(), &quot;invariant&quot;);
    event-&gt;set_lockClass(k);
    event-&gt;commit();
  }
  
<span class="udiff-line-modified-removed">- static void post_revocation_event(EventBiasedLockRevocation* event, Klass* k, VM_RevokeBias* revoke) {</span>
<span class="udiff-line-modified-added">+ static void post_revocation_event(EventBiasedLockRevocation* event, Klass* k, RevokeOneBias* op) {</span>
    assert(event != NULL, &quot;invariant&quot;);
    assert(k != NULL, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   assert(revoke != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(op != NULL, &quot;invariant&quot;);</span>
    assert(event-&gt;should_commit(), &quot;invariant&quot;);
    event-&gt;set_lockClass(k);
<span class="udiff-line-modified-removed">-   set_safepoint_id(event);</span>
<span class="udiff-line-modified-removed">-   event-&gt;set_previousOwner(revoke-&gt;biased_locker());</span>
<span class="udiff-line-modified-added">+   event-&gt;set_safepointId(0);</span>
<span class="udiff-line-modified-added">+   event-&gt;set_previousOwner(op-&gt;biased_locker());</span>
    event-&gt;commit();
  }
  
<span class="udiff-line-modified-removed">- static void post_class_revocation_event(EventBiasedLockClassRevocation* event, Klass* k, bool disabled_bias) {</span>
<span class="udiff-line-modified-added">+ static void post_class_revocation_event(EventBiasedLockClassRevocation* event, Klass* k, VM_BulkRevokeBias* op) {</span>
    assert(event != NULL, &quot;invariant&quot;);
    assert(k != NULL, &quot;invariant&quot;);
<span class="udiff-line-added">+   assert(op != NULL, &quot;invariant&quot;);</span>
    assert(event-&gt;should_commit(), &quot;invariant&quot;);
    event-&gt;set_revokedClass(k);
<span class="udiff-line-modified-removed">-   event-&gt;set_disableBiasing(disabled_bias);</span>
<span class="udiff-line-modified-removed">-   set_safepoint_id(event);</span>
<span class="udiff-line-modified-added">+   event-&gt;set_disableBiasing(!op-&gt;is_bulk_rebias());</span>
<span class="udiff-line-modified-added">+   event-&gt;set_safepointId(op-&gt;safepoint_id());</span>
    event-&gt;commit();
  }
  
<span class="udiff-line-removed">- BiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS) {</span>
<span class="udiff-line-removed">-   assert(!SafepointSynchronize::is_at_safepoint(), &quot;must not be called while at safepoint&quot;);</span>
  
<span class="udiff-line-modified-removed">-   // We can revoke the biases of anonymously-biased objects</span>
<span class="udiff-line-modified-removed">-   // efficiently enough that we should not cause these revocations to</span>
<span class="udiff-line-modified-removed">-   // update the heuristics because doing so may cause unwanted bulk</span>
<span class="udiff-line-modified-removed">-   // revocations (which are expensive) to occur.</span>
<span class="udiff-line-modified-removed">-   markOop mark = obj-&gt;mark();</span>
<span class="udiff-line-modified-removed">-   if (mark-&gt;is_biased_anonymously() &amp;&amp; !attempt_rebias) {</span>
<span class="udiff-line-modified-removed">-     // We are probably trying to revoke the bias of this object due to</span>
<span class="udiff-line-modified-removed">-     // an identity hash code computation. Try to revoke the bias</span>
<span class="udiff-line-modified-removed">-     // without a safepoint. This is possible if we can successfully</span>
<span class="udiff-line-modified-removed">-     // compare-and-exchange an unbiased header into the mark word of</span>
<span class="udiff-line-modified-removed">-     // the object, meaning that no other thread has raced to acquire</span>
<span class="udiff-line-modified-removed">-     // the bias of the object.</span>
<span class="udiff-line-modified-removed">-     markOop biased_value       = mark;</span>
<span class="udiff-line-modified-removed">-     markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span>
<span class="udiff-line-modified-removed">-     markOop res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);</span>
<span class="udiff-line-modified-removed">-     if (res_mark == biased_value) {</span>
<span class="udiff-line-modified-removed">-       return BIAS_REVOKED;</span>
<span class="udiff-line-modified-added">+ BiasedLocking::Condition BiasedLocking::single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   EventBiasedLockRevocation event;</span>
<span class="udiff-line-modified-added">+   if (PrintBiasedLockingStatistics) {</span>
<span class="udiff-line-modified-added">+     Atomic::inc(handshakes_count_addr());</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   log_info(biasedlocking, handshake)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; handshaking JavaThread &quot;</span>
<span class="udiff-line-modified-added">+                                      INTPTR_FORMAT &quot; to revoke object &quot; INTPTR_FORMAT, p2i(requester),</span>
<span class="udiff-line-modified-added">+                                      p2i(biaser), p2i(obj()));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   RevokeOneBias revoke(obj, requester, biaser);</span>
<span class="udiff-line-modified-added">+   bool executed = Handshake::execute(&amp;revoke, biaser);</span>
<span class="udiff-line-modified-added">+   if (revoke.status_code() == NOT_REVOKED) {</span>
<span class="udiff-line-modified-added">+     return NOT_REVOKED;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if (executed) {</span>
<span class="udiff-line-modified-added">+     log_info(biasedlocking, handshake)(&quot;Handshake revocation for object &quot; INTPTR_FORMAT &quot; succeeded. Bias was %srevoked&quot;,</span>
<span class="udiff-line-added">+                                        p2i(obj()), (revoke.status_code() == BIAS_REVOKED ? &quot;&quot; : &quot;already &quot;));</span>
<span class="udiff-line-added">+     if (event.should_commit() &amp;&amp; revoke.status_code() == BIAS_REVOKED) {</span>
<span class="udiff-line-added">+       post_revocation_event(&amp;event, obj-&gt;klass(), &amp;revoke);</span>
      }
<span class="udiff-line-modified-removed">-   } else if (mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-removed">-     Klass* k = obj-&gt;klass();</span>
<span class="udiff-line-modified-removed">-     markOop prototype_header = k-&gt;prototype_header();</span>
<span class="udiff-line-modified-removed">-     if (!prototype_header-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-removed">-       // This object has a stale bias from before the bulk revocation</span>
<span class="udiff-line-modified-removed">-       // for this data type occurred. It&#39;s pointless to update the</span>
<span class="udiff-line-modified-removed">-       // heuristics at this point so simply update the header with a</span>
<span class="udiff-line-modified-removed">-       // CAS. If we fail this race, the object&#39;s bias has been revoked</span>
<span class="udiff-line-modified-removed">-       // by another thread so we simply return and let the caller deal</span>
<span class="udiff-line-modified-removed">-       // with it.</span>
<span class="udiff-line-modified-removed">-       markOop biased_value       = mark;</span>
<span class="udiff-line-modified-removed">-       markOop res_mark = obj-&gt;cas_set_mark(prototype_header, mark);</span>
<span class="udiff-line-modified-removed">-       assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;even if we raced, should still be revoked&quot;);</span>
<span class="udiff-line-modified-removed">-       return BIAS_REVOKED;</span>
<span class="udiff-line-modified-removed">-     } else if (prototype_header-&gt;bias_epoch() != mark-&gt;bias_epoch()) {</span>
<span class="udiff-line-modified-removed">-       // The epoch of this biasing has expired indicating that the</span>
<span class="udiff-line-modified-removed">-       // object is effectively unbiased. Depending on whether we need</span>
<span class="udiff-line-modified-removed">-       // to rebias or revoke the bias of this object we can do it</span>
<span class="udiff-line-modified-removed">-       // efficiently enough with a CAS that we shouldn&#39;t update the</span>
<span class="udiff-line-modified-removed">-       // heuristics. This is normally done in the assembly code but we</span>
<span class="udiff-line-modified-removed">-       // can reach this point due to various points in the runtime</span>
<span class="udiff-line-removed">-       // needing to revoke biases.</span>
<span class="udiff-line-removed">-       if (attempt_rebias) {</span>
<span class="udiff-line-removed">-         assert(THREAD-&gt;is_Java_thread(), &quot;&quot;);</span>
<span class="udiff-line-removed">-         markOop biased_value       = mark;</span>
<span class="udiff-line-removed">-         markOop rebiased_prototype = markOopDesc::encode((JavaThread*) THREAD, mark-&gt;age(), prototype_header-&gt;bias_epoch());</span>
<span class="udiff-line-removed">-         markOop res_mark = obj-&gt;cas_set_mark(rebiased_prototype, mark);</span>
<span class="udiff-line-removed">-         if (res_mark == biased_value) {</span>
<span class="udiff-line-removed">-           return BIAS_REVOKED_AND_REBIASED;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         markOop biased_value       = mark;</span>
<span class="udiff-line-removed">-         markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span>
<span class="udiff-line-removed">-         markOop res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);</span>
<span class="udiff-line-removed">-         if (res_mark == biased_value) {</span>
<span class="udiff-line-removed">-           return BIAS_REVOKED;</span>
<span class="udiff-line-modified-added">+     assert(!obj-&gt;mark().has_bias_pattern(), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+     return revoke.status_code();</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-modified-added">+     // Thread was not alive.</span>
<span class="udiff-line-modified-added">+     // Grab Threads_lock before manually trying to revoke bias. This avoids race with a newly</span>
<span class="udiff-line-modified-added">+     // created JavaThread (that happens to get the same memory address as biaser) synchronizing</span>
<span class="udiff-line-modified-added">+     // on this object.</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       MutexLocker ml(Threads_lock);</span>
<span class="udiff-line-modified-added">+       markWord mark = obj-&gt;mark();</span>
<span class="udiff-line-modified-added">+       // Check if somebody else was able to revoke it before biased thread exited.</span>
<span class="udiff-line-modified-added">+       if (!mark.has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+         return NOT_BIASED;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+       ThreadsListHandle tlh;</span>
<span class="udiff-line-modified-added">+       markWord prototype = obj-&gt;klass()-&gt;prototype_header();</span>
<span class="udiff-line-modified-added">+       if (!prototype.has_bias_pattern() || (!tlh.includes(biaser) &amp;&amp; biaser == mark.biased_locker() &amp;&amp;</span>
<span class="udiff-line-modified-added">+                                             prototype.bias_epoch() == mark.bias_epoch())) {</span>
<span class="udiff-line-modified-added">+         obj-&gt;cas_set_mark(markWord::prototype().set_age(mark.age()), mark);</span>
<span class="udiff-line-modified-added">+         if (event.should_commit()) {</span>
<span class="udiff-line-modified-added">+           post_revocation_event(&amp;event, obj-&gt;klass(), &amp;revoke);</span>
          }
<span class="udiff-line-added">+         assert(!obj-&gt;mark().has_bias_pattern(), &quot;bias should be revoked by now&quot;);</span>
<span class="udiff-line-added">+         return BIAS_REVOKED;</span>
        }
      }
    }
  
<span class="udiff-line-modified-removed">-   HeuristicsResult heuristics = update_heuristics(obj(), attempt_rebias);</span>
<span class="udiff-line-modified-removed">-   if (heuristics == HR_NOT_BIASED) {</span>
<span class="udiff-line-modified-removed">-     return NOT_BIASED;</span>
<span class="udiff-line-modified-removed">-   } else if (heuristics == HR_SINGLE_REVOKE) {</span>
<span class="udiff-line-modified-removed">-     Klass *k = obj-&gt;klass();</span>
<span class="udiff-line-modified-removed">-     markOop prototype_header = k-&gt;prototype_header();</span>
<span class="udiff-line-modified-removed">-     if (mark-&gt;biased_locker() == THREAD &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         prototype_header-&gt;bias_epoch() == mark-&gt;bias_epoch()) {</span>
<span class="udiff-line-modified-removed">-       // A thread is trying to revoke the bias of an object biased</span>
<span class="udiff-line-modified-removed">-       // toward it, again likely due to an identity hash code</span>
<span class="udiff-line-modified-removed">-       // computation. We can again avoid a safepoint in this case</span>
<span class="udiff-line-modified-removed">-       // since we are only going to walk our own stack. There are no</span>
<span class="udiff-line-modified-removed">-       // races with revocations occurring in other threads because we</span>
<span class="udiff-line-modified-removed">-       // reach no safepoints in the revocation path.</span>
<span class="udiff-line-modified-removed">-       // Also check the epoch because even if threads match, another thread</span>
<span class="udiff-line-modified-removed">-       // can come in with a CAS to steal the bias of an object that has a</span>
<span class="udiff-line-modified-removed">-       // stale epoch.</span>
<span class="udiff-line-modified-removed">-       ResourceMark rm;</span>
<span class="udiff-line-modified-removed">-       log_info(biasedlocking)(&quot;Revoking bias by walking my own stack:&quot;);</span>
<span class="udiff-line-modified-removed">-       EventBiasedLockSelfRevocation event;</span>
<span class="udiff-line-modified-removed">-       BiasedLocking::Condition cond = revoke_bias(obj(), false, false, (JavaThread*) THREAD, NULL);</span>
<span class="udiff-line-modified-removed">-       ((JavaThread*) THREAD)-&gt;set_cached_monitor_info(NULL);</span>
<span class="udiff-line-modified-removed">-       assert(cond == BIAS_REVOKED, &quot;why not?&quot;);</span>
<span class="udiff-line-modified-removed">-       if (event.should_commit()) {</span>
<span class="udiff-line-modified-removed">-         post_self_revocation_event(&amp;event, k);</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-       return cond;</span>
<span class="udiff-line-modified-added">+   return NOT_REVOKED;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ // Caller should have instantiated a ResourceMark object before calling this method</span>
<span class="udiff-line-modified-added">+ void BiasedLocking::walk_stack_and_revoke(oop obj, JavaThread* biased_locker) {</span>
<span class="udiff-line-modified-added">+   assert(!SafepointSynchronize::is_at_safepoint() || !SafepointMechanism::uses_thread_local_poll(),</span>
<span class="udiff-line-modified-added">+          &quot;if SafepointMechanism::uses_thread_local_poll() is enabled this should always be executed outside safepoints&quot;);</span>
<span class="udiff-line-modified-added">+   assert(Thread::current() == biased_locker || Thread::current()-&gt;is_VM_thread(), &quot;wrong thread&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   markWord mark = obj-&gt;mark();</span>
<span class="udiff-line-modified-added">+   assert(mark.biased_locker() == biased_locker &amp;&amp;</span>
<span class="udiff-line-modified-added">+          obj-&gt;klass()-&gt;prototype_header().bias_epoch() == mark.bias_epoch(), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   log_trace(biasedlocking)(&quot;%s(&quot; INTPTR_FORMAT &quot;) revoking object &quot; INTPTR_FORMAT &quot;, mark &quot;</span>
<span class="udiff-line-modified-added">+                            INTPTR_FORMAT &quot;, type %s, prototype header &quot; INTPTR_FORMAT</span>
<span class="udiff-line-modified-added">+                            &quot;, biaser &quot; INTPTR_FORMAT &quot; %s&quot;,</span>
<span class="udiff-line-modified-added">+                            Thread::current()-&gt;is_VM_thread() ? &quot;VMThread&quot; : &quot;JavaThread&quot;,</span>
<span class="udiff-line-modified-added">+                            p2i(Thread::current()),</span>
<span class="udiff-line-modified-added">+                            p2i(obj),</span>
<span class="udiff-line-modified-added">+                            mark.value(),</span>
<span class="udiff-line-modified-added">+                            obj-&gt;klass()-&gt;external_name(),</span>
<span class="udiff-line-modified-added">+                            obj-&gt;klass()-&gt;prototype_header().value(),</span>
<span class="udiff-line-modified-added">+                            p2i(biased_locker),</span>
<span class="udiff-line-modified-added">+                            Thread::current()-&gt;is_VM_thread() ? &quot;&quot; : &quot;(walking own stack)&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   markWord unbiased_prototype = markWord::prototype().set_age(obj-&gt;mark().age());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_locker);</span>
<span class="udiff-line-added">+   BasicLock* highest_lock = NULL;</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) {</span>
<span class="udiff-line-added">+     MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span>
<span class="udiff-line-added">+     if (mon_info-&gt;owner() == obj) {</span>
<span class="udiff-line-added">+       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) == obj (&quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="udiff-line-added">+                                p2i(mon_info-&gt;owner()),</span>
<span class="udiff-line-added">+                                p2i(obj));</span>
<span class="udiff-line-added">+       // Assume recursive case and fix up highest lock below</span>
<span class="udiff-line-added">+       markWord mark = markWord::encode((BasicLock*) NULL);</span>
<span class="udiff-line-added">+       highest_lock = mon_info-&gt;lock();</span>
<span class="udiff-line-added">+       highest_lock-&gt;set_displaced_header(mark);</span>
      } else {
<span class="udiff-line-modified-removed">-       EventBiasedLockRevocation event;</span>
<span class="udiff-line-modified-removed">-       VM_RevokeBias revoke(&amp;obj, (JavaThread*) THREAD);</span>
<span class="udiff-line-modified-removed">-       VMThread::execute(&amp;revoke);</span>
<span class="udiff-line-removed">-       if (event.should_commit() &amp;&amp; revoke.status_code() != NOT_BIASED) {</span>
<span class="udiff-line-removed">-         post_revocation_event(&amp;event, k, &amp;revoke);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       return revoke.status_code();</span>
<span class="udiff-line-modified-added">+       log_trace(biasedlocking)(&quot;   mon_info-&gt;owner (&quot; PTR_FORMAT &quot;) != obj (&quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="udiff-line-modified-added">+                                p2i(mon_info-&gt;owner()),</span>
<span class="udiff-line-modified-added">+                                p2i(obj));</span>
      }
    }
<span class="udiff-line-added">+   if (highest_lock != NULL) {</span>
<span class="udiff-line-added">+     // Fix up highest lock to contain displaced header and point</span>
<span class="udiff-line-added">+     // object at it</span>
<span class="udiff-line-added">+     highest_lock-&gt;set_displaced_header(unbiased_prototype);</span>
<span class="udiff-line-added">+     // Reset object header to point to displaced mark.</span>
<span class="udiff-line-added">+     // Must release store the lock address for platforms without TSO</span>
<span class="udiff-line-added">+     // ordering (e.g. ppc).</span>
<span class="udiff-line-added">+     obj-&gt;release_set_mark(markWord::encode(highest_lock));</span>
<span class="udiff-line-added">+     assert(!obj-&gt;mark().has_bias_pattern(), &quot;illegal mark state: stack lock used bias bit&quot;);</span>
<span class="udiff-line-added">+     log_info(biasedlocking)(&quot;  Revoked bias of currently-locked object&quot;);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     log_info(biasedlocking)(&quot;  Revoked bias of currently-unlocked object&quot;);</span>
<span class="udiff-line-added">+     // Store the unlocked value into the object&#39;s header.</span>
<span class="udiff-line-added">+     obj-&gt;set_mark(unbiased_prototype);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   assert((heuristics == HR_BULK_REVOKE) ||</span>
<span class="udiff-line-modified-removed">-          (heuristics == HR_BULK_REBIAS), &quot;?&quot;);</span>
<span class="udiff-line-modified-removed">-   EventBiasedLockClassRevocation event;</span>
<span class="udiff-line-modified-removed">-   VM_BulkRevokeBias bulk_revoke(&amp;obj, (JavaThread*) THREAD,</span>
<span class="udiff-line-modified-removed">-                                 (heuristics == HR_BULK_REBIAS),</span>
<span class="udiff-line-modified-removed">-                                 attempt_rebias);</span>
<span class="udiff-line-modified-removed">-   VMThread::execute(&amp;bulk_revoke);</span>
<span class="udiff-line-modified-added">+   assert(!obj-&gt;mark().has_bias_pattern(), &quot;must not be biased&quot;);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void BiasedLocking::revoke_own_lock(Handle obj, TRAPS) {</span>
<span class="udiff-line-modified-added">+   assert(THREAD-&gt;is_Java_thread(), &quot;must be called by a JavaThread&quot;);</span>
<span class="udiff-line-modified-added">+   JavaThread* thread = (JavaThread*)THREAD;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   markWord mark = obj-&gt;mark();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!mark.has_bias_pattern()) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Klass *k = obj-&gt;klass();</span>
<span class="udiff-line-added">+   assert(mark.biased_locker() == thread &amp;&amp;</span>
<span class="udiff-line-added">+          k-&gt;prototype_header().bias_epoch() == mark.bias_epoch(), &quot;Revoke failed, unhandled biased lock state&quot;);</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+   log_info(biasedlocking)(&quot;Revoking bias by walking my own stack:&quot;);</span>
<span class="udiff-line-added">+   EventBiasedLockSelfRevocation event;</span>
<span class="udiff-line-added">+   BiasedLocking::walk_stack_and_revoke(obj(), (JavaThread*) thread);</span>
<span class="udiff-line-added">+   thread-&gt;set_cached_monitor_info(NULL);</span>
<span class="udiff-line-added">+   assert(!obj-&gt;mark().has_bias_pattern(), &quot;invariant&quot;);</span>
    if (event.should_commit()) {
<span class="udiff-line-modified-removed">-     post_class_revocation_event(&amp;event, obj-&gt;klass(), heuristics != HR_BULK_REBIAS);</span>
<span class="udiff-line-modified-added">+     post_self_revocation_event(&amp;event, k);</span>
    }
<span class="udiff-line-removed">-   return bulk_revoke.status_code();</span>
  }
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- void BiasedLocking::revoke(GrowableArray&lt;Handle&gt;* objs) {</span>
<span class="udiff-line-modified-added">+ void BiasedLocking::revoke(Handle obj, TRAPS) {</span>
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;must not be called while at safepoint&quot;);
<span class="udiff-line-modified-removed">-   if (objs-&gt;length() == 0) {</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   while (true) {</span>
<span class="udiff-line-added">+     // We can revoke the biases of anonymously-biased objects</span>
<span class="udiff-line-added">+     // efficiently enough that we should not cause these revocations to</span>
<span class="udiff-line-added">+     // update the heuristics because doing so may cause unwanted bulk</span>
<span class="udiff-line-added">+     // revocations (which are expensive) to occur.</span>
<span class="udiff-line-added">+     markWord mark = obj-&gt;mark();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!mark.has_bias_pattern()) {</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (mark.is_biased_anonymously()) {</span>
<span class="udiff-line-added">+       // We are probably trying to revoke the bias of this object due to</span>
<span class="udiff-line-added">+       // an identity hash code computation. Try to revoke the bias</span>
<span class="udiff-line-added">+       // without a safepoint. This is possible if we can successfully</span>
<span class="udiff-line-added">+       // compare-and-exchange an unbiased header into the mark word of</span>
<span class="udiff-line-added">+       // the object, meaning that no other thread has raced to acquire</span>
<span class="udiff-line-added">+       // the bias of the object.</span>
<span class="udiff-line-added">+       markWord biased_value       = mark;</span>
<span class="udiff-line-added">+       markWord unbiased_prototype = markWord::prototype().set_age(mark.age());</span>
<span class="udiff-line-added">+       markWord res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);</span>
<span class="udiff-line-added">+       if (res_mark == biased_value) {</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       mark = res_mark;  // Refresh mark with the latest value.</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       Klass* k = obj-&gt;klass();</span>
<span class="udiff-line-added">+       markWord prototype_header = k-&gt;prototype_header();</span>
<span class="udiff-line-added">+       if (!prototype_header.has_bias_pattern()) {</span>
<span class="udiff-line-added">+         // This object has a stale bias from before the bulk revocation</span>
<span class="udiff-line-added">+         // for this data type occurred. It&#39;s pointless to update the</span>
<span class="udiff-line-added">+         // heuristics at this point so simply update the header with a</span>
<span class="udiff-line-added">+         // CAS. If we fail this race, the object&#39;s bias has been revoked</span>
<span class="udiff-line-added">+         // by another thread so we simply return and let the caller deal</span>
<span class="udiff-line-added">+         // with it.</span>
<span class="udiff-line-added">+         obj-&gt;cas_set_mark(prototype_header.set_age(mark.age()), mark);</span>
<span class="udiff-line-added">+         assert(!obj-&gt;mark().has_bias_pattern(), &quot;even if we raced, should still be revoked&quot;);</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       } else if (prototype_header.bias_epoch() != mark.bias_epoch()) {</span>
<span class="udiff-line-added">+         // The epoch of this biasing has expired indicating that the</span>
<span class="udiff-line-added">+         // object is effectively unbiased. We can revoke the bias of this</span>
<span class="udiff-line-added">+         // object efficiently enough with a CAS that we shouldn&#39;t update the</span>
<span class="udiff-line-added">+         // heuristics. This is normally done in the assembly code but we</span>
<span class="udiff-line-added">+         // can reach this point due to various points in the runtime</span>
<span class="udiff-line-added">+         // needing to revoke biases.</span>
<span class="udiff-line-added">+         markWord res_mark;</span>
<span class="udiff-line-added">+         markWord biased_value       = mark;</span>
<span class="udiff-line-added">+         markWord unbiased_prototype = markWord::prototype().set_age(mark.age());</span>
<span class="udiff-line-added">+         res_mark = obj-&gt;cas_set_mark(unbiased_prototype, mark);</span>
<span class="udiff-line-added">+         if (res_mark == biased_value) {</span>
<span class="udiff-line-added">+           return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         mark = res_mark;  // Refresh mark with the latest value.</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     HeuristicsResult heuristics = update_heuristics(obj());</span>
<span class="udiff-line-added">+     if (heuristics == HR_NOT_BIASED) {</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     } else if (heuristics == HR_SINGLE_REVOKE) {</span>
<span class="udiff-line-added">+       JavaThread *blt = mark.biased_locker();</span>
<span class="udiff-line-added">+       assert(blt != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+       if (blt == THREAD) {</span>
<span class="udiff-line-added">+         // A thread is trying to revoke the bias of an object biased</span>
<span class="udiff-line-added">+         // toward it, again likely due to an identity hash code</span>
<span class="udiff-line-added">+         // computation. We can again avoid a safepoint/handshake in this case</span>
<span class="udiff-line-added">+         // since we are only going to walk our own stack. There are no</span>
<span class="udiff-line-added">+         // races with revocations occurring in other threads because we</span>
<span class="udiff-line-added">+         // reach no safepoints in the revocation path.</span>
<span class="udiff-line-added">+         EventBiasedLockSelfRevocation event;</span>
<span class="udiff-line-added">+         ResourceMark rm;</span>
<span class="udiff-line-added">+         walk_stack_and_revoke(obj(), blt);</span>
<span class="udiff-line-added">+         blt-&gt;set_cached_monitor_info(NULL);</span>
<span class="udiff-line-added">+         assert(!obj-&gt;mark().has_bias_pattern(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+         if (event.should_commit()) {</span>
<span class="udiff-line-added">+           post_self_revocation_event(&amp;event, obj-&gt;klass());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         BiasedLocking::Condition cond = single_revoke_with_handshake(obj, (JavaThread*)THREAD, blt);</span>
<span class="udiff-line-added">+         if (cond != NOT_REVOKED) {</span>
<span class="udiff-line-added">+           return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       assert((heuristics == HR_BULK_REVOKE) ||</span>
<span class="udiff-line-added">+          (heuristics == HR_BULK_REBIAS), &quot;?&quot;);</span>
<span class="udiff-line-added">+       EventBiasedLockClassRevocation event;</span>
<span class="udiff-line-added">+       VM_BulkRevokeBias bulk_revoke(&amp;obj, (JavaThread*)THREAD,</span>
<span class="udiff-line-added">+                                     (heuristics == HR_BULK_REBIAS));</span>
<span class="udiff-line-added">+       VMThread::execute(&amp;bulk_revoke);</span>
<span class="udiff-line-added">+       if (event.should_commit()) {</span>
<span class="udiff-line-added">+         post_class_revocation_event(&amp;event, obj-&gt;klass(), &amp;bulk_revoke);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // All objects in objs should be locked by biaser</span>
<span class="udiff-line-added">+ void BiasedLocking::revoke(GrowableArray&lt;Handle&gt;* objs, JavaThread *biaser) {</span>
<span class="udiff-line-added">+   bool clean_my_cache = false;</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; objs-&gt;length(); i++) {</span>
<span class="udiff-line-added">+     oop obj = (objs-&gt;at(i))();</span>
<span class="udiff-line-added">+     markWord mark = obj-&gt;mark();</span>
<span class="udiff-line-added">+     if (mark.has_bias_pattern()) {</span>
<span class="udiff-line-added">+       walk_stack_and_revoke(obj, biaser);</span>
<span class="udiff-line-added">+       clean_my_cache = true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (clean_my_cache) {</span>
<span class="udiff-line-added">+     clean_up_cached_monitor_info(biaser);</span>
    }
<span class="udiff-line-removed">-   VM_RevokeBias revoke(objs, JavaThread::current());</span>
<span class="udiff-line-removed">-   VMThread::execute(&amp;revoke);</span>
  }
  
  
  void BiasedLocking::revoke_at_safepoint(Handle h_obj) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;must only be called while at safepoint&quot;);
    oop obj = h_obj();
<span class="udiff-line-modified-removed">-   HeuristicsResult heuristics = update_heuristics(obj, false);</span>
<span class="udiff-line-modified-added">+   HeuristicsResult heuristics = update_heuristics(obj);</span>
    if (heuristics == HR_SINGLE_REVOKE) {
<span class="udiff-line-modified-removed">-     revoke_bias(obj, false, false, NULL, NULL);</span>
<span class="udiff-line-modified-added">+     JavaThread* biased_locker = NULL;</span>
<span class="udiff-line-added">+     single_revoke_at_safepoint(obj, false, NULL, &amp;biased_locker);</span>
<span class="udiff-line-added">+     if (biased_locker) {</span>
<span class="udiff-line-added">+       clean_up_cached_monitor_info(biased_locker);</span>
<span class="udiff-line-added">+     }</span>
    } else if ((heuristics == HR_BULK_REBIAS) ||
               (heuristics == HR_BULK_REVOKE)) {
<span class="udiff-line-modified-removed">-     bulk_revoke_or_rebias_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), false, NULL);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-removed">-   clean_up_cached_monitor_info();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void BiasedLocking::revoke_at_safepoint(GrowableArray&lt;Handle&gt;* objs) {</span>
<span class="udiff-line-removed">-   assert(SafepointSynchronize::is_at_safepoint(), &quot;must only be called while at safepoint&quot;);</span>
<span class="udiff-line-removed">-   int len = objs-&gt;length();</span>
<span class="udiff-line-removed">-   for (int i = 0; i &lt; len; i++) {</span>
<span class="udiff-line-removed">-     oop obj = (objs-&gt;at(i))();</span>
<span class="udiff-line-removed">-     HeuristicsResult heuristics = update_heuristics(obj, false);</span>
<span class="udiff-line-removed">-     if (heuristics == HR_SINGLE_REVOKE) {</span>
<span class="udiff-line-removed">-       revoke_bias(obj, false, false, NULL, NULL);</span>
<span class="udiff-line-removed">-     } else if ((heuristics == HR_BULK_REBIAS) ||</span>
<span class="udiff-line-removed">-                (heuristics == HR_BULK_REVOKE)) {</span>
<span class="udiff-line-removed">-       bulk_revoke_or_rebias_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), false, NULL);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     bulk_revoke_at_safepoint(obj, (heuristics == HR_BULK_REBIAS), NULL);</span>
<span class="udiff-line-modified-added">+     clean_up_cached_monitor_info();</span>
    }
<span class="udiff-line-removed">-   clean_up_cached_monitor_info();</span>
  }
  
  
  void BiasedLocking::preserve_marks() {
    if (!UseBiasedLocking)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -792,11 +902,11 @@</span>
    // must not clobber a bias is when a biased object is currently
    // locked. To handle this case we iterate over the currently-locked
    // monitors in a prepass and, if they are biased, preserve their
    // mark words here. This should be a relatively small set of objects
    // especially compared to the number of objects in the heap.
<span class="udiff-line-modified-removed">-   _preserved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;markOop&gt;(10, true);</span>
<span class="udiff-line-modified-added">+   _preserved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;markWord&gt;(10, true);</span>
    _preserved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;Handle&gt;(10, true);
  
    ResourceMark rm;
    Thread* cur = Thread::current();
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -810,12 +920,12 @@</span>
            for (int i = len - 1; i &gt;= 0; i--) {
              MonitorInfo* mon_info = monitors-&gt;at(i);
              if (mon_info-&gt;owner_is_scalar_replaced()) continue;
              oop owner = mon_info-&gt;owner();
              if (owner != NULL) {
<span class="udiff-line-modified-removed">-               markOop mark = owner-&gt;mark();</span>
<span class="udiff-line-modified-removed">-               if (mark-&gt;has_bias_pattern()) {</span>
<span class="udiff-line-modified-added">+               markWord mark = owner-&gt;mark();</span>
<span class="udiff-line-modified-added">+               if (mark.has_bias_pattern()) {</span>
                  _preserved_oop_stack-&gt;push(Handle(cur, owner));
                  _preserved_mark_stack-&gt;push(mark);
                }
              }
            }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -834,11 +944,11 @@</span>
    assert(_preserved_mark_stack != NULL, &quot;double free&quot;);
  
    int len = _preserved_oop_stack-&gt;length();
    for (int i = 0; i &lt; len; i++) {
      Handle owner = _preserved_oop_stack-&gt;at(i);
<span class="udiff-line-modified-removed">-     markOop mark = _preserved_mark_stack-&gt;at(i);</span>
<span class="udiff-line-modified-added">+     markWord mark = _preserved_mark_stack-&gt;at(i);</span>
      owner-&gt;set_mark(mark);
    }
  
    delete _preserved_oop_stack;
    _preserved_oop_stack = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -850,31 +960,35 @@</span>
  int* BiasedLocking::total_entry_count_addr()                   { return _counters.total_entry_count_addr(); }
  int* BiasedLocking::biased_lock_entry_count_addr()             { return _counters.biased_lock_entry_count_addr(); }
  int* BiasedLocking::anonymously_biased_lock_entry_count_addr() { return _counters.anonymously_biased_lock_entry_count_addr(); }
  int* BiasedLocking::rebiased_lock_entry_count_addr()           { return _counters.rebiased_lock_entry_count_addr(); }
  int* BiasedLocking::revoked_lock_entry_count_addr()            { return _counters.revoked_lock_entry_count_addr(); }
<span class="udiff-line-added">+ int* BiasedLocking::handshakes_count_addr()                    { return _counters.handshakes_count_addr(); }</span>
  int* BiasedLocking::fast_path_entry_count_addr()               { return _counters.fast_path_entry_count_addr(); }
  int* BiasedLocking::slow_path_entry_count_addr()               { return _counters.slow_path_entry_count_addr(); }
  
  
  // BiasedLockingCounters
  
<span class="udiff-line-modified-removed">- int BiasedLockingCounters::slow_path_entry_count() {</span>
<span class="udiff-line-modified-added">+ int BiasedLockingCounters::slow_path_entry_count() const {</span>
    if (_slow_path_entry_count != 0) {
      return _slow_path_entry_count;
    }
    int sum = _biased_lock_entry_count   + _anonymously_biased_lock_entry_count +
              _rebiased_lock_entry_count + _revoked_lock_entry_count +
              _fast_path_entry_count;
  
    return _total_entry_count - sum;
  }
  
<span class="udiff-line-modified-removed">- void BiasedLockingCounters::print_on(outputStream* st) {</span>
<span class="udiff-line-modified-added">+ void BiasedLockingCounters::print_on(outputStream* st) const {</span>
    tty-&gt;print_cr(&quot;# total entries: %d&quot;, _total_entry_count);
    tty-&gt;print_cr(&quot;# biased lock entries: %d&quot;, _biased_lock_entry_count);
    tty-&gt;print_cr(&quot;# anonymously biased lock entries: %d&quot;, _anonymously_biased_lock_entry_count);
    tty-&gt;print_cr(&quot;# rebiased lock entries: %d&quot;, _rebiased_lock_entry_count);
    tty-&gt;print_cr(&quot;# revoked lock entries: %d&quot;, _revoked_lock_entry_count);
<span class="udiff-line-added">+   tty-&gt;print_cr(&quot;# handshakes entries: %d&quot;, _handshakes_count);</span>
    tty-&gt;print_cr(&quot;# fast path lock entries: %d&quot;, _fast_path_entry_count);
    tty-&gt;print_cr(&quot;# slow path lock entries: %d&quot;, slow_path_entry_count());
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void BiasedLockingCounters::print() const { print_on(tty); }</span>
</pre>
<center><a href="basicLock.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="biasedLocking.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
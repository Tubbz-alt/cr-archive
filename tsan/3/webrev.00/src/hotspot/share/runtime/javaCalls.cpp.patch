diff a/src/hotspot/share/runtime/javaCalls.cpp b/src/hotspot/share/runtime/javaCalls.cpp
--- a/src/hotspot/share/runtime/javaCalls.cpp
+++ b/src/hotspot/share/runtime/javaCalls.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,32 +24,28 @@
 
 #include "precompiled.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "code/nmethod.hpp"
+#include "compiler/compilationPolicy.hpp"
 #include "compiler/compileBroker.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/linkResolver.hpp"
 #include "memory/universe.hpp"
 #include "oops/method.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "prims/jniCheck.hpp"
-#include "runtime/compilationPolicy.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/javaCalls.hpp"
 #include "runtime/jniHandles.inline.hpp"
 #include "runtime/mutexLocker.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/signature.hpp"
 #include "runtime/stubRoutines.hpp"
 #include "runtime/thread.inline.hpp"
-#if INCLUDE_JVMCI
-#include "jvmci/jvmciJavaClasses.hpp"
-#include "jvmci/jvmciRuntime.hpp"
-#endif
 
 // -----------------------------------------------------
 // Implementation of JavaCallWrapper
 
 JavaCallWrapper::JavaCallWrapper(const methodHandle& callee_method, Handle receiver, JavaValue* result, TRAPS) {
@@ -188,11 +184,11 @@
   Handle receiver = args->receiver();
   Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver->klass();
   LinkInfo link_info(spec_klass, name, signature);
   LinkResolver::resolve_virtual_call(
           callinfo, receiver, recvrKlass, link_info, true, CHECK);
-  methodHandle method = callinfo.selected_method();
+  methodHandle method(THREAD, callinfo.selected_method());
   assert(method.not_null(), "should have thrown exception");
 
   // Invoke the method
   JavaCalls::call(result, method, args, CHECK);
 }
@@ -224,11 +220,11 @@
 
 void JavaCalls::call_special(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
   CallInfo callinfo;
   LinkInfo link_info(klass, name, signature);
   LinkResolver::resolve_special_call(callinfo, args->receiver(), link_info, CHECK);
-  methodHandle method = callinfo.selected_method();
+  methodHandle method(THREAD, callinfo.selected_method());
   assert(method.not_null(), "should have thrown exception");
 
   // Invoke the method
   JavaCalls::call(result, method, args, CHECK);
 }
@@ -259,11 +255,11 @@
 
 void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
   CallInfo callinfo;
   LinkInfo link_info(klass, name, signature);
   LinkResolver::resolve_static_call(callinfo, link_info, true, CHECK);
-  methodHandle method = callinfo.selected_method();
+  methodHandle method(THREAD, callinfo.selected_method());
   assert(method.not_null(), "should have thrown exception");
 
   // Invoke the method
   JavaCalls::call(result, method, args, CHECK);
 }
@@ -348,13 +344,10 @@
   assert(thread->is_Java_thread(), "must be called by a java thread");
   assert(method.not_null(), "must have a method to call");
   assert(!SafepointSynchronize::is_at_safepoint(), "call to Java code during VM operation");
   assert(!thread->handle_area()->no_handle_mark_active(), "cannot call out to Java here");
 
-
-  CHECK_UNHANDLED_OOPS_ONLY(thread->clear_unhandled_oops();)
-
 #if INCLUDE_JVMCI
   // Gets the nmethod (if any) that should be called instead of normal target
   nmethod* alternative_target = args->alternative_target();
   if (alternative_target == NULL) {
 #endif
@@ -395,15 +388,11 @@
   }
 
   // Figure out if the result value is an oop or not (Note: This is a different value
   // than result_type. result_type will be T_INT of oops. (it is about size)
   BasicType result_type = runtime_type_from(result);
-  bool oop_result_flag = (result->get_type() == T_OBJECT || result->get_type() == T_ARRAY);
-
-  // NOTE: if we move the computation of the result_val_address inside
-  // the call to call_stub, the optimizer produces wrong code.
-  intptr_t* result_val_address = (intptr_t*)(result->get_value_addr());
+  bool oop_result_flag = is_reference_type(result->get_type());
 
   // Find receiver
   Handle receiver = (!method->is_static()) ? args->receiver() : Handle();
 
   // When we reenter Java, we need to reenable the reserved/yellow zone which
@@ -438,18 +427,23 @@
 
   // do call
   { JavaCallWrapper link(method, receiver, result, CHECK);
     { HandleMark hm(thread);  // HandleMark used by HandleMarkCleaner
 
+      // NOTE: if we move the computation of the result_val_address inside
+      // the call to call_stub, the optimizer produces wrong code.
+      intptr_t* result_val_address = (intptr_t*)(result->get_value_addr());
+      intptr_t* parameter_address = args->parameters();
+
       StubRoutines::call_stub()(
         (address)&link,
         // (intptr_t*)&(result->_value), // see NOTE above (compiler problem)
         result_val_address,          // see NOTE above (compiler problem)
         result_type,
         method(),
         entry_point,
-        args->parameters(),
+        parameter_address,
         args->size_of_parameters(),
         CHECK
       );
 
       result = link.result();  // circumvent MS C++ 5.0 compiler bug (result is clobbered across call)
@@ -464,11 +458,11 @@
   // The following assert was not realistic.  Thread.stop can set that bit at any moment.
   //assert(!thread->has_special_runtime_exit_condition(), "no async. exceptions should be installed");
 
   // Restore possible oop return
   if (oop_result_flag) {
-    result->set_jobject((jobject)thread->vm_result());
+    result->set_jobject(cast_from_oop<jobject>(thread->vm_result()));
     thread->set_vm_result(NULL);
   }
 }
 
 
@@ -525,74 +519,56 @@
    BasicType _return_type;
    u_char* _value_state;
    intptr_t* _value;
 
  public:
-  bool _is_return;
-
   SignatureChekker(Symbol* signature,
                    BasicType return_type,
                    bool is_static,
                    u_char* value_state,
                    intptr_t* value) :
     SignatureIterator(signature),
     _pos(0),
     _return_type(return_type),
     _value_state(value_state),
-    _value(value),
-    _is_return(false)
+    _value(value)
   {
     if (!is_static) {
       check_value(true); // Receiver must be an oop
     }
+    do_parameters_on(this);
+    check_return_type(return_type);
   }
 
-  void check_value(bool type) {
+ private:
+  void check_value(bool is_reference) {
     uint state = _value_state[_pos++];
-    if (type) {
+    if (is_reference) {
       guarantee(is_value_state_indirect_oop(state),
                 "signature does not match pushed arguments: %u at %d",
                 state, _pos - 1);
     } else {
       guarantee(state == JavaCallArguments::value_state_primitive,
                 "signature does not match pushed arguments: %u at %d",
                 state, _pos - 1);
     }
   }
 
-  void check_doing_return(bool state) { _is_return = state; }
-
   void check_return_type(BasicType t) {
-    guarantee(_is_return && t == _return_type, "return type does not match");
+    guarantee(t == _return_type, "return type does not match");
   }
 
-  void check_int(BasicType t) {
-    if (_is_return) {
-      check_return_type(t);
-      return;
-    }
+  void check_single_word() {
     check_value(false);
   }
 
-  void check_double(BasicType t) { check_long(t); }
-
-  void check_long(BasicType t) {
-    if (_is_return) {
-      check_return_type(t);
-      return;
-    }
-
+  void check_double_word() {
     check_value(false);
     check_value(false);
   }
 
-  void check_obj(BasicType t) {
-    if (_is_return) {
-      check_return_type(t);
-      return;
-    }
-
+  void check_reference() {
     intptr_t v = _value[_pos];
     if (v != 0) {
       // v is a "handle" referring to an oop, cast to integral type.
       // There shouldn't be any handles in very low memory.
       guarantee((size_t)v >= (size_t)os::vm_page_size(),
@@ -605,37 +581,43 @@
     }
 
     check_value(true);          // Verify value state.
   }
 
-  void do_bool()                       { check_int(T_BOOLEAN);       }
-  void do_char()                       { check_int(T_CHAR);          }
-  void do_float()                      { check_int(T_FLOAT);         }
-  void do_double()                     { check_double(T_DOUBLE);     }
-  void do_byte()                       { check_int(T_BYTE);          }
-  void do_short()                      { check_int(T_SHORT);         }
-  void do_int()                        { check_int(T_INT);           }
-  void do_long()                       { check_long(T_LONG);         }
-  void do_void()                       { check_return_type(T_VOID);  }
-  void do_object(int begin, int end)   { check_obj(T_OBJECT);        }
-  void do_array(int begin, int end)    { check_obj(T_OBJECT);        }
+  friend class SignatureIterator;  // so do_parameters_on can call do_type
+  void do_type(BasicType type) {
+    switch (type) {
+    case T_BYTE:
+    case T_BOOLEAN:
+    case T_CHAR:
+    case T_SHORT:
+    case T_INT:
+    case T_FLOAT:  // this one also
+      check_single_word(); break;
+    case T_LONG:
+    case T_DOUBLE:
+      check_double_word(); break;
+    case T_ARRAY:
+    case T_OBJECT:
+      check_reference(); break;
+    default:
+      ShouldNotReachHere();
+    }
+  }
 };
 
 
 void JavaCallArguments::verify(const methodHandle& method, BasicType return_type) {
   guarantee(method->size_of_parameters() == size_of_parameters(), "wrong no. of arguments pushed");
 
   // Treat T_OBJECT and T_ARRAY as the same
-  if (return_type == T_ARRAY) return_type = T_OBJECT;
+  if (is_reference_type(return_type)) return_type = T_OBJECT;
 
   // Check that oop information is correct
   Symbol* signature = method->signature();
 
   SignatureChekker sc(signature,
                       return_type,
                       method->is_static(),
                       _value_state,
                       _value);
-  sc.iterate_parameters();
-  sc.check_doing_return(true);
-  sc.iterate_returntype();
 }

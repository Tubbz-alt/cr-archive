<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/runtime/vframe.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_VFRAME_INLINE_HPP
 26 #define SHARE_RUNTIME_VFRAME_INLINE_HPP
 27 
 28 #include &quot;runtime/frame.inline.hpp&quot;
 29 #include &quot;runtime/thread.inline.hpp&quot;
 30 #include &quot;runtime/vframe.hpp&quot;
 31 
 32 inline vframeStreamCommon::vframeStreamCommon(JavaThread* thread) : _reg_map(thread, false) {
 33   _thread = thread;
 34 }
 35 
 36 inline intptr_t* vframeStreamCommon::frame_id() const        { return _frame.id(); }
 37 
 38 inline bool vframeStreamCommon::is_interpreted_frame() const { return _frame.is_interpreted_frame(); }
 39 
 40 inline bool vframeStreamCommon::is_entry_frame() const       { return _frame.is_entry_frame(); }
 41 
 42 inline void vframeStreamCommon::next() {
 43   // handle frames with inlining
 44   if (_mode == compiled_mode    &amp;&amp; fill_in_compiled_inlined_sender()) return;
 45 
 46   // handle general case
 47   do {
 48     _prev_frame = _frame;
 49     _frame = _frame.sender(&amp;_reg_map);
 50   } while (!fill_from_frame());
 51 }
 52 
 53 inline vframeStream::vframeStream(JavaThread* thread, bool stop_at_java_call_stub)
 54   : vframeStreamCommon(thread) {
 55   _stop_at_java_call_stub = stop_at_java_call_stub;
 56 
 57   if (!thread-&gt;has_last_Java_frame()) {
 58     _mode = at_end_mode;
 59     return;
 60   }
 61 
 62   _frame = _thread-&gt;last_frame();
 63   while (!fill_from_frame()) {
 64     _prev_frame = _frame;
 65     _frame = _frame.sender(&amp;_reg_map);
 66   }
 67 }
 68 
 69 inline bool vframeStreamCommon::fill_in_compiled_inlined_sender() {
 70   if (_sender_decode_offset == DebugInformationRecorder::serialized_null) {
 71     return false;
 72   }
 73   fill_from_compiled_frame(_sender_decode_offset);
 74   ++_vframe_id;
 75   return true;
 76 }
 77 
 78 
 79 inline void vframeStreamCommon::fill_from_compiled_frame(int decode_offset) {
 80   _mode = compiled_mode;
 81   _decode_offset = decode_offset;
 82 
 83   // Range check to detect ridiculous offsets.
 84   if (decode_offset == DebugInformationRecorder::serialized_null ||
 85       decode_offset &lt; 0 ||
 86       decode_offset &gt;= nm()-&gt;scopes_data_size()) {
 87     // 6379830 AsyncGetCallTrace sometimes feeds us wild frames.
 88     // If we read nmethod::scopes_data at serialized_null (== 0)
 89     // or if read some at other invalid offset, invalid values will be decoded.
 90     // Based on these values, invalid heap locations could be referenced
 91     // that could lead to crashes in product mode.
 92     // Therefore, do not use the decode offset if invalid, but fill the frame
 93     // as it were a native compiled frame (no Java-level assumptions).
 94 #ifdef ASSERT
 95     if (WizardMode) {
 96       ttyLocker ttyl;
 97       tty-&gt;print_cr(&quot;Error in fill_from_frame: pc_desc for &quot;
 98                     INTPTR_FORMAT &quot; not found or invalid at %d&quot;,
 99                     p2i(_frame.pc()), decode_offset);
100       nm()-&gt;print();
101       nm()-&gt;method()-&gt;print_codes();
102       nm()-&gt;print_code();
103       nm()-&gt;print_pcs();
104     }
105     found_bad_method_frame();
106 #endif
107     // Provide a cheap fallback in product mode.  (See comment above.)
108     fill_from_compiled_native_frame();
109     return;
110   }
111 
112   // Decode first part of scopeDesc
113   DebugInfoReadStream buffer(nm(), decode_offset);
114   _sender_decode_offset = buffer.read_int();
115   _method               = buffer.read_method();
116   _bci                  = buffer.read_bci();
117 
118   assert(_method-&gt;is_method(), &quot;checking type of decoded method&quot;);
119 }
120 
121 // The native frames are handled specially. We do not rely on ScopeDesc info
122 // since the pc might not be exact due to the _last_native_pc trick.
123 inline void vframeStreamCommon::fill_from_compiled_native_frame() {
124   _mode = compiled_mode;
125   _sender_decode_offset = DebugInformationRecorder::serialized_null;
126   _decode_offset = DebugInformationRecorder::serialized_null;
127   _vframe_id = 0;
128   _method = nm()-&gt;method();
129   _bci = 0;
130 }
131 
132 inline bool vframeStreamCommon::fill_from_frame() {
133   // Interpreted frame
134   if (_frame.is_interpreted_frame()) {
135     fill_from_interpreter_frame();
136     return true;
137   }
138 
139   // Compiled frame
140 
141   if (cb() != NULL &amp;&amp; cb()-&gt;is_compiled()) {
142     if (nm()-&gt;is_native_method()) {
143       // Do not rely on scopeDesc since the pc might be unprecise due to the _last_native_pc trick.
144       fill_from_compiled_native_frame();
145     } else {
146       PcDesc* pc_desc = nm()-&gt;pc_desc_at(_frame.pc());
147       int decode_offset;
148       if (pc_desc == NULL) {
149         // Should not happen, but let fill_from_compiled_frame handle it.
150 
151         // If we are trying to walk the stack of a thread that is not
152         // at a safepoint (like AsyncGetCallTrace would do) then this is an
153         // acceptable result. [ This is assuming that safe_for_sender
154         // is so bullet proof that we can trust the frames it produced. ]
155         //
156         // So if we see that the thread is not safepoint safe
157         // then simply produce the method and a bci of zero
158         // and skip the possibility of decoding any inlining that
159         // may be present. That is far better than simply stopping (or
160         // asserting. If however the thread is safepoint safe this
161         // is the sign of a compiler bug  and we&#39;ll let
162         // fill_from_compiled_frame handle it.
163 
164 
165         JavaThreadState state = _thread-&gt;thread_state();
166 
167         // in_Java should be good enough to test safepoint safety
168         // if state were say in_Java_trans then we&#39;d expect that
169         // the pc would have already been slightly adjusted to
170         // one that would produce a pcDesc since the trans state
171         // would be one that might in fact anticipate a safepoint
172 
173         if (state == _thread_in_Java ) {
174           // This will get a method a zero bci and no inlining.
175           // Might be nice to have a unique bci to signify this
176           // particular case but for now zero will do.
177 
178           fill_from_compiled_native_frame();
179 
180           // There is something to be said for setting the mode to
181           // at_end_mode to prevent trying to walk further up the
182           // stack. There is evidence that if we walk any further
183           // that we could produce a bad stack chain. However until
184           // we see evidence that allowing this causes us to find
185           // frames bad enough to cause segv&#39;s or assertion failures
186           // we don&#39;t do it as while we may get a bad call chain the
187           // probability is much higher (several magnitudes) that we
188           // get good data.
189 
190           return true;
191         }
192         decode_offset = DebugInformationRecorder::serialized_null;
193       } else {
194         decode_offset = pc_desc-&gt;scope_decode_offset();
195       }
196       fill_from_compiled_frame(decode_offset);
197       _vframe_id = 0;
198     }
199     return true;
200   }
201 
202   // End of stack?
203   if (_frame.is_first_frame() || (_stop_at_java_call_stub &amp;&amp; _frame.is_entry_frame())) {
204     _mode = at_end_mode;
205     return true;
206   }
207 
208   return false;
209 }
210 
211 
212 inline void vframeStreamCommon::fill_from_interpreter_frame() {
213   Method* method = _frame.interpreter_frame_method();
214   address   bcp    = _frame.interpreter_frame_bcp();
215   int       bci    = method-&gt;validate_bci_from_bcp(bcp);
216   // 6379830 AsyncGetCallTrace sometimes feeds us wild frames.
217   // AsyncGetCallTrace interrupts the VM asynchronously. As a result
218   // it is possible to access an interpreter frame for which
219   // no Java-level information is yet available (e.g., becasue
220   // the frame was being created when the VM interrupted it).
221   // In this scenario, pretend that the interpreter is at the point
222   // of entering the method.
223   if (bci &lt; 0) {
224     DEBUG_ONLY(found_bad_method_frame();)
225     bci = 0;
226   }
227   _mode   = interpreted_mode;
228   _method = method;
229   _bci    = bci;
230 }
231 
232 #endif // SHARE_RUNTIME_VFRAME_INLINE_HPP
    </pre>
  </body>
</html>
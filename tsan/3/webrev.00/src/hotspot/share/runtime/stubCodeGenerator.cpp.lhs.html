<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/stubCodeGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;asm/macroAssembler.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;compiler/disassembler.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;prims/forte.hpp&quot;
 32 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 33 
 34 
 35 // Implementation of StubCodeDesc
 36 
 37 StubCodeDesc* StubCodeDesc::_list = NULL;
 38 bool          StubCodeDesc::_frozen = false;
 39 
 40 StubCodeDesc* StubCodeDesc::desc_for(address pc) {
 41   StubCodeDesc* p = _list;
 42   while (p != NULL &amp;&amp; !p-&gt;contains(pc)) {
 43     p = p-&gt;_next;
 44   }
 45   return p;
 46 }
 47 
 48 const char* StubCodeDesc::name_for(address pc) {
 49   StubCodeDesc* p = desc_for(pc);
 50   return p == NULL ? NULL : p-&gt;name();
 51 }
 52 
 53 
 54 void StubCodeDesc::freeze() {
 55   assert(!_frozen, &quot;repeated freeze operation&quot;);
 56   _frozen = true;
 57 }
 58 
 59 void StubCodeDesc::print_on(outputStream* st) const {
 60   st-&gt;print(&quot;%s&quot;, group());
 61   st-&gt;print(&quot;::&quot;);
 62   st-&gt;print(&quot;%s&quot;, name());
<a name="2" id="anc2"></a><span class="line-modified"> 63   st-&gt;print(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;[ (%d bytes)&quot;, p2i(begin()), p2i(end()), size_in_bytes());</span>
 64 }
 65 
<a name="3" id="anc3"></a>

 66 // Implementation of StubCodeGenerator
 67 
 68 StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, bool print_code) {
 69   _masm = new MacroAssembler(code );
 70   _print_code = PrintStubCode || print_code;
 71 }
 72 
 73 StubCodeGenerator::~StubCodeGenerator() {
 74   if (PRODUCT_ONLY(_print_code) NOT_PRODUCT(true)) {
 75     CodeBuffer* cbuf = _masm-&gt;code();
 76     CodeBlob*   blob = CodeCache::find_blob_unsafe(cbuf-&gt;insts()-&gt;start());
 77     if (blob != NULL) {
 78       blob-&gt;set_strings(cbuf-&gt;strings());
 79     }
 80   }
 81 }
 82 
 83 void StubCodeGenerator::stub_prolog(StubCodeDesc* cdesc) {
 84   // default implementation - do nothing
 85 }
 86 
 87 void StubCodeGenerator::stub_epilog(StubCodeDesc* cdesc) {
 88   if (_print_code) {
 89     CodeStrings cs;
 90     ptrdiff_t offset = 0;
 91 #ifndef PRODUCT
 92     // Find the code strings in the outer CodeBuffer.
 93     CodeBuffer *outer_cbuf = _masm-&gt;code_section()-&gt;outer();
 94     cs = outer_cbuf-&gt;strings();
 95     // The offset from the start of the outer CodeBuffer to the start
 96     // of this stub.
 97     offset = cdesc-&gt;begin() - outer_cbuf-&gt;insts()-&gt;start();
 98 #endif
<a name="4" id="anc4"></a><span class="line-modified"> 99     cdesc-&gt;print();</span>


100     tty-&gt;cr();
<a name="5" id="anc5"></a><span class="line-modified">101     Disassembler::decode(cdesc-&gt;begin(), cdesc-&gt;end(), NULL, cs, offset);</span>

102     tty-&gt;cr();
103   }
104 }
105 
106 
107 // Implementation of CodeMark
108 
109 StubCodeMark::StubCodeMark(StubCodeGenerator* cgen, const char* group, const char* name) {
110   _cgen  = cgen;
111   _cdesc = new StubCodeDesc(group, name, _cgen-&gt;assembler()-&gt;pc());
112   _cgen-&gt;stub_prolog(_cdesc);
113   // define the stub&#39;s beginning (= entry point) to be after the prolog:
114   _cdesc-&gt;set_begin(_cgen-&gt;assembler()-&gt;pc());
115 }
116 
117 StubCodeMark::~StubCodeMark() {
118   _cgen-&gt;assembler()-&gt;flush();
119   _cdesc-&gt;set_end(_cgen-&gt;assembler()-&gt;pc());
120   assert(StubCodeDesc::_list == _cdesc, &quot;expected order on list&quot;);
121   _cgen-&gt;stub_epilog(_cdesc);
122   Forte::register_stub(_cdesc-&gt;name(), _cdesc-&gt;begin(), _cdesc-&gt;end());
123 
124   if (JvmtiExport::should_post_dynamic_code_generated()) {
125     JvmtiExport::post_dynamic_code_generated(_cdesc-&gt;name(), _cdesc-&gt;begin(), _cdesc-&gt;end());
126   }
127 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/safepoint.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="rtmLocking.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepoint.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/safepoint.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,20 ***</span>
<span class="line-new-header">--- 22,23 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
<span class="line-added">+ #include &quot;classfile/dictionary.hpp&quot;</span>
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/icBuffer.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;code/pcDesc.hpp&quot;
  #include &quot;code/scopeDesc.hpp&quot;
<span class="line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;gc/shared/gcLocker.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/oopStorage.hpp&quot;</span>
  #include &quot;gc/shared/strongRootsScope.hpp&quot;
  #include &quot;gc/shared/workgroup.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,11 ***</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-new-header">--- 46,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,13 ***</span>
  #include &quot;runtime/threadSMR.hpp&quot;
  #include &quot;runtime/timerTrace.hpp&quot;
  #include &quot;services/runtimeService.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-removed">- #ifdef COMPILER1</span>
<span class="line-removed">- #include &quot;c1/c1_globals.hpp&quot;</span>
<span class="line-removed">- #endif</span>
  
  static void post_safepoint_begin_event(EventSafepointBegin&amp; event,
                                         uint64_t safepoint_id,
                                         int thread_count,
                                         int critical_thread_count) {
<span class="line-new-header">--- 66,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,16 ***</span>
<span class="line-new-header">--- 117,26 ---</span>
      event.set_safepointId(safepoint_id);
      event.commit();
    }
  }
  
<span class="line-added">+ // SafepointCheck</span>
<span class="line-added">+ SafepointStateTracker::SafepointStateTracker(uint64_t safepoint_id, bool at_safepoint)</span>
<span class="line-added">+   : _safepoint_id(safepoint_id), _at_safepoint(at_safepoint) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool SafepointStateTracker::safepoint_state_changed() {</span>
<span class="line-added">+   return _safepoint_id != SafepointSynchronize::safepoint_id() ||</span>
<span class="line-added">+     _at_safepoint != SafepointSynchronize::is_at_safepoint();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // --------------------------------------------------------------------------------------------------
  // Implementation of Safepoint begin/end
  
  SafepointSynchronize::SynchronizeState volatile SafepointSynchronize::_state = SafepointSynchronize::_not_synchronized;
  int SafepointSynchronize::_waiting_to_block = 0;
  volatile uint64_t SafepointSynchronize::_safepoint_counter = 0;
<span class="line-added">+ uint64_t SafepointSynchronize::_safepoint_id = 0;</span>
  const uint64_t SafepointSynchronize::InactiveSafepointCounter = 0;
  int SafepointSynchronize::_current_jni_active_count = 0;
  
  WaitBarrier* SafepointSynchronize::_wait_barrier;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,11 ***</span>
    assert(_waiting_to_block &gt; 0, &quot;sanity check&quot;);
    assert(Thread::current()-&gt;is_VM_thread(), &quot;Only VM thread may decrement&quot;);
    --_waiting_to_block;
  }
  
<span class="line-modified">! static bool thread_not_running(ThreadSafepointState *cur_state) {</span>
    if (!cur_state-&gt;is_running()) {
      return true;
    }
    cur_state-&gt;examine_state_of_thread(SafepointSynchronize::safepoint_counter());
    if (!cur_state-&gt;is_running()) {
<span class="line-new-header">--- 163,11 ---</span>
    assert(_waiting_to_block &gt; 0, &quot;sanity check&quot;);
    assert(Thread::current()-&gt;is_VM_thread(), &quot;Only VM thread may decrement&quot;);
    --_waiting_to_block;
  }
  
<span class="line-modified">! bool SafepointSynchronize::thread_not_running(ThreadSafepointState *cur_state) {</span>
    if (!cur_state-&gt;is_running()) {
      return true;
    }
    cur_state-&gt;examine_state_of_thread(SafepointSynchronize::safepoint_counter());
    if (!cur_state-&gt;is_running()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,20 ***</span>
    }
    assert(a == still_running, &quot;Must be the same&quot;);
  }
  #endif // ASSERT
  
<span class="line-modified">! static void back_off(int iteration) {</span>
<span class="line-modified">!   // iteration will be 1 the first time we enter this spin back-off.</span>
<span class="line-modified">!   // naked_short_nanosleep takes tenths of micros which means that</span>
<span class="line-modified">!   // number of nanoseconds is irrelevant if it&#39;s below that. We do</span>
<span class="line-modified">!   // 20 1 ns sleeps with a total cost of ~1 ms, then we do 1 ms sleeps.</span>
<span class="line-modified">!   jlong sleep_ns = 1;</span>
<span class="line-modified">!   if (iteration &gt; 20) {</span>
<span class="line-removed">-     sleep_ns = NANOUNITS / MILLIUNITS;  // 1 ms</span>
    }
<span class="line-removed">-   os::naked_short_nanosleep(sleep_ns);</span>
  }
  
  int SafepointSynchronize::synchronize_threads(jlong safepoint_limit_time, int nof_threads, int* initial_running)
  {
    JavaThreadIteratorWithHandle jtiwh;
<span class="line-new-header">--- 193,18 ---</span>
    }
    assert(a == still_running, &quot;Must be the same&quot;);
  }
  #endif // ASSERT
  
<span class="line-modified">! static void back_off(int64_t start_time) {</span>
<span class="line-modified">!   // We start with fine-grained nanosleeping until a millisecond has</span>
<span class="line-modified">!   // passed, at which point we resort to plain naked_short_sleep.</span>
<span class="line-modified">!   if (os::javaTimeNanos() - start_time &lt; NANOSECS_PER_MILLISEC) {</span>
<span class="line-modified">!     os::naked_short_nanosleep(10 * (NANOUNITS / MICROUNITS));</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     os::naked_short_sleep(1);</span>
    }
  }
  
  int SafepointSynchronize::synchronize_threads(jlong safepoint_limit_time, int nof_threads, int* initial_running)
  {
    JavaThreadIteratorWithHandle jtiwh;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,13 ***</span>
  
    DEBUG_ONLY(assert_list_is_valid(tss_head, still_running);)
  
    *initial_running = still_running;
  
    int iterations = 1; // The first iteration is above.
  
<span class="line-modified">!   while (still_running &gt; 0) {</span>
      // Check if this has taken too long:
      if (SafepointTimeout &amp;&amp; safepoint_limit_time &lt; os::javaTimeNanos()) {
        print_safepoint_timeout();
      }
      if (int(iterations) == -1) { // overflow - something is wrong.
<span class="line-new-header">--- 234,20 ---</span>
  
    DEBUG_ONLY(assert_list_is_valid(tss_head, still_running);)
  
    *initial_running = still_running;
  
<span class="line-added">+   // If there is no thread still running, we are already done.</span>
<span class="line-added">+   if (still_running &lt;= 0) {</span>
<span class="line-added">+     assert(tss_head == NULL, &quot;Must be empty&quot;);</span>
<span class="line-added">+     return 1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    int iterations = 1; // The first iteration is above.
<span class="line-added">+   int64_t start_time = os::javaTimeNanos();</span>
  
<span class="line-modified">!   do {</span>
      // Check if this has taken too long:
      if (SafepointTimeout &amp;&amp; safepoint_limit_time &lt; os::javaTimeNanos()) {
        print_safepoint_timeout();
      }
      if (int(iterations) == -1) { // overflow - something is wrong.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,15 ***</span>
      }
  
      DEBUG_ONLY(assert_list_is_valid(tss_head, still_running);)
  
      if (still_running &gt; 0) {
<span class="line-modified">!       back_off(iterations);</span>
      }
  
      iterations++;
<span class="line-modified">!   }</span>
  
    assert(tss_head == NULL, &quot;Must be empty&quot;);
  
    return iterations;
  }
<span class="line-new-header">--- 276,15 ---</span>
      }
  
      DEBUG_ONLY(assert_list_is_valid(tss_head, still_running);)
  
      if (still_running &gt; 0) {
<span class="line-modified">!       back_off(start_time);</span>
      }
  
      iterations++;
<span class="line-modified">!   } while (still_running &gt; 0);</span>
  
    assert(tss_head == NULL, &quot;Must be empty&quot;);
  
    return iterations;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 312,11 ***</span>
    // Arming must be done after resetting _current_jni_active_count, _waiting_to_block.
    _wait_barrier-&gt;arm(static_cast&lt;int&gt;(_safepoint_counter + 1));
  
    assert((_safepoint_counter &amp; 0x1) == 0, &quot;must be even&quot;);
    // The store to _safepoint_counter must happen after any stores in arming.
<span class="line-modified">!   OrderAccess::release_store(&amp;_safepoint_counter, _safepoint_counter + 1);</span>
  
    // We are synchronizing
    OrderAccess::storestore(); // Ordered with _safepoint_counter
    _state = _synchronizing;
  
<span class="line-new-header">--- 326,11 ---</span>
    // Arming must be done after resetting _current_jni_active_count, _waiting_to_block.
    _wait_barrier-&gt;arm(static_cast&lt;int&gt;(_safepoint_counter + 1));
  
    assert((_safepoint_counter &amp; 0x1) == 0, &quot;must be even&quot;);
    // The store to _safepoint_counter must happen after any stores in arming.
<span class="line-modified">!   Atomic::release_store(&amp;_safepoint_counter, _safepoint_counter + 1);</span>
  
    // We are synchronizing
    OrderAccess::storestore(); // Ordered with _safepoint_counter
    _state = _synchronizing;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,10 ***</span>
<span class="line-new-header">--- 417,13 ---</span>
    // Record state
    _state = _synchronized;
  
    OrderAccess::fence();
  
<span class="line-added">+   // Set the new id</span>
<span class="line-added">+   ++_safepoint_id;</span>
<span class="line-added">+ </span>
  #ifdef ASSERT
    // Make sure all the threads were visited.
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *cur = jtiwh.next(); ) {
      assert(cur-&gt;was_visited_for_critical_count(_safepoint_counter), &quot;missed a thread&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 414,28 ***</span>
  
    // Update the count of active JNI critical regions
    GCLocker::set_jni_lock_count(_current_jni_active_count);
  
    post_safepoint_synchronize_event(sync_event,
<span class="line-modified">!                                    _safepoint_counter,</span>
                                     initial_running,
                                     _waiting_to_block, iterations);
  
    SafepointTracing::synchronized(nof_threads, initial_running, _nof_threads_hit_polling_page);
  
    // We do the safepoint cleanup first since a GC related safepoint
    // needs cleanup to be completed before running the GC op.
    EventSafepointCleanup cleanup_event;
    do_cleanup_tasks();
<span class="line-modified">!   post_safepoint_cleanup_event(cleanup_event, _safepoint_counter);</span>
  
<span class="line-modified">!   post_safepoint_begin_event(begin_event, _safepoint_counter, nof_threads, _current_jni_active_count);</span>
    SafepointTracing::cleanup();
  }
  
  void SafepointSynchronize::disarm_safepoint() {
<span class="line-modified">!   uint64_t safepoint_id = _safepoint_counter;</span>
    {
      JavaThreadIteratorWithHandle jtiwh;
  #ifdef ASSERT
      // A pending_exception cannot be installed during a safepoint.  The threads
      // may install an async exception after they come back from a safepoint into
<span class="line-new-header">--- 431,28 ---</span>
  
    // Update the count of active JNI critical regions
    GCLocker::set_jni_lock_count(_current_jni_active_count);
  
    post_safepoint_synchronize_event(sync_event,
<span class="line-modified">!                                    _safepoint_id,</span>
                                     initial_running,
                                     _waiting_to_block, iterations);
  
    SafepointTracing::synchronized(nof_threads, initial_running, _nof_threads_hit_polling_page);
  
    // We do the safepoint cleanup first since a GC related safepoint
    // needs cleanup to be completed before running the GC op.
    EventSafepointCleanup cleanup_event;
    do_cleanup_tasks();
<span class="line-modified">!   post_safepoint_cleanup_event(cleanup_event, _safepoint_id);</span>
  
<span class="line-modified">!   post_safepoint_begin_event(begin_event, _safepoint_id, nof_threads, _current_jni_active_count);</span>
    SafepointTracing::cleanup();
  }
  
  void SafepointSynchronize::disarm_safepoint() {
<span class="line-modified">!   uint64_t active_safepoint_counter = _safepoint_counter;</span>
    {
      JavaThreadIteratorWithHandle jtiwh;
  #ifdef ASSERT
      // A pending_exception cannot be installed during a safepoint.  The threads
      // may install an async exception after they come back from a safepoint into
</pre>
<hr />
<pre>
<span class="line-old-header">*** 463,23 ***</span>
      // No threads should see _synchronized when running.
      _state = _not_synchronized;
  
      // Set the next dormant (even) safepoint id.
      assert((_safepoint_counter &amp; 0x1) == 1, &quot;must be odd&quot;);
<span class="line-modified">!     OrderAccess::release_store(&amp;_safepoint_counter, _safepoint_counter + 1);</span>
  
      OrderAccess::fence(); // Keep the local state from floating up.
  
      jtiwh.rewind();
      for (; JavaThread *current = jtiwh.next(); ) {
        // Clear the visited flag to ensure that the critical counts are collected properly.
<span class="line-modified">!       DEBUG_ONLY(current-&gt;reset_visited_for_critical_count(safepoint_id);)</span>
        ThreadSafepointState* cur_state = current-&gt;safepoint_state();
        assert(!cur_state-&gt;is_running(), &quot;Thread not suspended at safepoint&quot;);
        cur_state-&gt;restart(); // TSS _running
        assert(cur_state-&gt;is_running(), &quot;safepoint state has not been reset&quot;);
<span class="line-modified">!       SafepointMechanism::disarm_local_poll(current);</span>
      }
    } // ~JavaThreadIteratorWithHandle
  
    // Release threads lock, so threads can be created/destroyed again.
    Threads_lock-&gt;unlock();
<span class="line-new-header">--- 480,24 ---</span>
      // No threads should see _synchronized when running.
      _state = _not_synchronized;
  
      // Set the next dormant (even) safepoint id.
      assert((_safepoint_counter &amp; 0x1) == 1, &quot;must be odd&quot;);
<span class="line-modified">!     Atomic::release_store(&amp;_safepoint_counter, _safepoint_counter + 1);</span>
  
      OrderAccess::fence(); // Keep the local state from floating up.
  
      jtiwh.rewind();
      for (; JavaThread *current = jtiwh.next(); ) {
        // Clear the visited flag to ensure that the critical counts are collected properly.
<span class="line-modified">!       DEBUG_ONLY(current-&gt;reset_visited_for_critical_count(active_safepoint_counter);)</span>
        ThreadSafepointState* cur_state = current-&gt;safepoint_state();
        assert(!cur_state-&gt;is_running(), &quot;Thread not suspended at safepoint&quot;);
        cur_state-&gt;restart(); // TSS _running
        assert(cur_state-&gt;is_running(), &quot;safepoint state has not been reset&quot;);
<span class="line-modified">! </span>
<span class="line-added">+       SafepointMechanism::disarm_if_needed(current, false /* NO release */);</span>
      }
    } // ~JavaThreadIteratorWithHandle
  
    // Release threads lock, so threads can be created/destroyed again.
    Threads_lock-&gt;unlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 491,30 ***</span>
  // Wake up all threads, so they are ready to resume execution after the safepoint
  // operation has been carried out
  void SafepointSynchronize::end() {
    assert(Threads_lock-&gt;owned_by_self(), &quot;must hold Threads_lock&quot;);
    EventSafepointEnd event;
<span class="line-removed">-   uint64_t safepoint_id = _safepoint_counter;</span>
    assert(Thread::current()-&gt;is_VM_thread(), &quot;Only VM thread can execute a safepoint&quot;);
  
    disarm_safepoint();
  
    Universe::heap()-&gt;safepoint_synchronize_end();
  
    SafepointTracing::end();
  
<span class="line-modified">!   post_safepoint_end_event(event, safepoint_id);</span>
  }
  
  bool SafepointSynchronize::is_cleanup_needed() {
    // Need a safepoint if there are many monitors to deflate.
    if (ObjectSynchronizer::is_cleanup_needed()) return true;
    // Need a safepoint if some inline cache buffers is non-empty
    if (!InlineCacheBuffer::is_empty()) return true;
    return false;
  }
  
  class ParallelSPCleanupThreadClosure : public ThreadClosure {
  private:
    CodeBlobClosure* _nmethod_cl;
    DeflateMonitorCounters* _counters;
  
<span class="line-new-header">--- 509,35 ---</span>
  // Wake up all threads, so they are ready to resume execution after the safepoint
  // operation has been carried out
  void SafepointSynchronize::end() {
    assert(Threads_lock-&gt;owned_by_self(), &quot;must hold Threads_lock&quot;);
    EventSafepointEnd event;
    assert(Thread::current()-&gt;is_VM_thread(), &quot;Only VM thread can execute a safepoint&quot;);
  
    disarm_safepoint();
  
    Universe::heap()-&gt;safepoint_synchronize_end();
  
    SafepointTracing::end();
  
<span class="line-modified">!   post_safepoint_end_event(event, safepoint_id());</span>
  }
  
  bool SafepointSynchronize::is_cleanup_needed() {
    // Need a safepoint if there are many monitors to deflate.
    if (ObjectSynchronizer::is_cleanup_needed()) return true;
    // Need a safepoint if some inline cache buffers is non-empty
    if (!InlineCacheBuffer::is_empty()) return true;
<span class="line-added">+   if (StringTable::needs_rehashing()) return true;</span>
<span class="line-added">+   if (SymbolTable::needs_rehashing()) return true;</span>
    return false;
  }
  
<span class="line-added">+ bool SafepointSynchronize::is_forced_cleanup_needed() {</span>
<span class="line-added">+   return ObjectSynchronizer::needs_monitor_scavenge();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class ParallelSPCleanupThreadClosure : public ThreadClosure {
  private:
    CodeBlobClosure* _nmethod_cl;
    DeflateMonitorCounters* _counters;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 546,11 ***</span>
      _cleanup_threads_cl(ParallelSPCleanupThreadClosure(counters)),
      _num_workers(num_workers),
      _counters(counters) {}
  
    void work(uint worker_id) {
<span class="line-modified">!     uint64_t safepoint_id = SafepointSynchronize::safepoint_counter();</span>
      // All threads deflate monitors and mark nmethods (if necessary).
      Threads::possibly_parallel_threads_do(true, &amp;_cleanup_threads_cl);
  
      if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_DEFLATE_MONITORS)) {
        const char* name = &quot;deflating global idle monitors&quot;;
<span class="line-new-header">--- 569,11 ---</span>
      _cleanup_threads_cl(ParallelSPCleanupThreadClosure(counters)),
      _num_workers(num_workers),
      _counters(counters) {}
  
    void work(uint worker_id) {
<span class="line-modified">!     uint64_t safepoint_id = SafepointSynchronize::safepoint_id();</span>
      // All threads deflate monitors and mark nmethods (if necessary).
      Threads::possibly_parallel_threads_do(true, &amp;_cleanup_threads_cl);
  
      if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_DEFLATE_MONITORS)) {
        const char* name = &quot;deflating global idle monitors&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 599,28 ***</span>
  
          post_safepoint_cleanup_task_event(event, safepoint_id, name);
        }
      }
  
<span class="line-modified">!     if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_CLD_PURGE)) {</span>
<span class="line-modified">!       // CMS delays purging the CLDG until the beginning of the next safepoint and to</span>
<span class="line-modified">!       // make sure concurrent sweep is done</span>
<span class="line-modified">!       const char* name = &quot;purging class loader data graph&quot;;</span>
<span class="line-modified">!       EventSafepointCleanupTask event;</span>
<span class="line-modified">!       TraceTime timer(name, TRACETIME_LOG(Info, safepoint, cleanup));</span>
<span class="line-removed">-       ClassLoaderDataGraph::purge_if_needed();</span>
  
<span class="line-modified">!       post_safepoint_cleanup_task_event(event, safepoint_id, name);</span>
      }
  
<span class="line-modified">!     if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE)) {</span>
<span class="line-modified">!       const char* name = &quot;resizing system dictionaries&quot;;</span>
<span class="line-modified">!       EventSafepointCleanupTask event;</span>
<span class="line-modified">!       TraceTime timer(name, TRACETIME_LOG(Info, safepoint, cleanup));</span>
<span class="line-removed">-       ClassLoaderDataGraph::resize_if_needed();</span>
<span class="line-removed">- </span>
<span class="line-removed">-       post_safepoint_cleanup_task_event(event, safepoint_id, name);</span>
      }
  
      _subtasks.all_tasks_completed(_num_workers);
    }
  };
<span class="line-new-header">--- 622,25 ---</span>
  
          post_safepoint_cleanup_task_event(event, safepoint_id, name);
        }
      }
  
<span class="line-modified">!     if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE)) {</span>
<span class="line-modified">!       if (Dictionary::does_any_dictionary_needs_resizing()) {</span>
<span class="line-modified">!         const char* name = &quot;resizing system dictionaries&quot;;</span>
<span class="line-modified">!         EventSafepointCleanupTask event;</span>
<span class="line-modified">!         TraceTime timer(name, TRACETIME_LOG(Info, safepoint, cleanup));</span>
<span class="line-modified">!         ClassLoaderDataGraph::resize_dictionaries();</span>
  
<span class="line-modified">!         post_safepoint_cleanup_task_event(event, safepoint_id, name);</span>
<span class="line-added">+       }</span>
      }
  
<span class="line-modified">!     if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_REQUEST_OOPSTORAGE_CLEANUP)) {</span>
<span class="line-modified">!       // Don&#39;t bother reporting event or time for this very short operation.</span>
<span class="line-modified">!       // To have any utility we&#39;d also want to report whether needed.</span>
<span class="line-modified">!       OopStorage::trigger_cleanup_if_needed();</span>
      }
  
      _subtasks.all_tasks_completed(_num_workers);
    }
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 714,16 ***</span>
      return false;
    }
  }
  
  bool SafepointSynchronize::handshake_safe(JavaThread *thread) {
<span class="line-modified">!   // The polls must be armed otherwise the safe state can change to unsafe at any time.</span>
<span class="line-removed">-   assert(SafepointMechanism::should_block(thread), &quot;Must be armed&quot;);</span>
<span class="line-removed">-   // This function must be called with the Threads_lock held so an externally</span>
<span class="line-removed">-   // suspended thread cannot be resumed thus it is safe.</span>
<span class="line-removed">-   assert(Threads_lock-&gt;owned_by_self() &amp;&amp; Thread::current()-&gt;is_VM_thread(),</span>
<span class="line-removed">-          &quot;Must hold Threads_lock and be VMThread&quot;);</span>
    if (thread-&gt;is_ext_suspended() || thread-&gt;is_terminated()) {
      return true;
    }
    JavaThreadState stable_state;
    if (try_stable_load_state(&amp;stable_state, thread, InactiveSafepointCounter)) {
<span class="line-new-header">--- 734,11 ---</span>
      return false;
    }
  }
  
  bool SafepointSynchronize::handshake_safe(JavaThread *thread) {
<span class="line-modified">!   assert(Thread::current()-&gt;is_VM_thread(), &quot;Must be VMThread&quot;);</span>
    if (thread-&gt;is_ext_suspended() || thread-&gt;is_terminated()) {
      return true;
    }
    JavaThreadState stable_state;
    if (try_stable_load_state(&amp;stable_state, thread, InactiveSafepointCounter)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 804,13 ***</span>
        // Load dependent store, it must not pass loading of safepoint_id.
        thread-&gt;safepoint_state()-&gt;set_safepoint_id(safepoint_id); // Release store
  
        // This part we can skip if we notice we miss or are in a future safepoint.
        OrderAccess::storestore();
<span class="line-modified">!       thread-&gt;set_thread_state(_thread_blocked);</span>
  
<span class="line-removed">-       OrderAccess::fence(); // Load in wait barrier should not float up</span>
        _wait_barrier-&gt;wait(static_cast&lt;int&gt;(safepoint_id));
        assert(_state != _synchronized, &quot;Can&#39;t be&quot;);
  
        // If barrier is disarmed stop store from floating above loads in barrier.
        OrderAccess::loadstore();
<span class="line-new-header">--- 819,13 ---</span>
        // Load dependent store, it must not pass loading of safepoint_id.
        thread-&gt;safepoint_state()-&gt;set_safepoint_id(safepoint_id); // Release store
  
        // This part we can skip if we notice we miss or are in a future safepoint.
        OrderAccess::storestore();
<span class="line-modified">!       // Load in wait barrier should not float up</span>
<span class="line-added">+       thread-&gt;set_thread_state_fence(_thread_blocked);</span>
  
        _wait_barrier-&gt;wait(static_cast&lt;int&gt;(safepoint_id));
        assert(_state != _synchronized, &quot;Can&#39;t be&quot;);
  
        // If barrier is disarmed stop store from floating above loads in barrier.
        OrderAccess::loadstore();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 849,20 ***</span>
        state != _thread_in_vm_trans &amp;&amp;
        thread-&gt;has_special_runtime_exit_condition()) {
      thread-&gt;handle_special_runtime_exit_condition(
        !thread-&gt;is_at_poll_safepoint() &amp;&amp; (state != _thread_in_native_trans));
    }
  }
  
  // ------------------------------------------------------------------------------------------------------
  // Exception handlers
  
  
  void SafepointSynchronize::handle_polling_page_exception(JavaThread *thread) {
    assert(thread-&gt;is_Java_thread(), &quot;polling reference encountered by VM thread&quot;);
    assert(thread-&gt;thread_state() == _thread_in_Java, &quot;should come from Java code&quot;);
<span class="line-modified">!   if (!ThreadLocalHandshakes) {</span>
      assert(SafepointSynchronize::is_synchronizing(), &quot;polling encountered outside safepoint synchronization&quot;);
    }
  
    if (log_is_enabled(Info, safepoint, stats)) {
      Atomic::inc(&amp;_nof_threads_hit_polling_page);
<span class="line-new-header">--- 864,23 ---</span>
        state != _thread_in_vm_trans &amp;&amp;
        thread-&gt;has_special_runtime_exit_condition()) {
      thread-&gt;handle_special_runtime_exit_condition(
        !thread-&gt;is_at_poll_safepoint() &amp;&amp; (state != _thread_in_native_trans));
    }
<span class="line-added">+ </span>
<span class="line-added">+   // cross_modify_fence is done by SafepointMechanism::block_if_requested_slow</span>
<span class="line-added">+   // which is the only caller here.</span>
  }
  
  // ------------------------------------------------------------------------------------------------------
  // Exception handlers
  
  
  void SafepointSynchronize::handle_polling_page_exception(JavaThread *thread) {
    assert(thread-&gt;is_Java_thread(), &quot;polling reference encountered by VM thread&quot;);
    assert(thread-&gt;thread_state() == _thread_in_Java, &quot;should come from Java code&quot;);
<span class="line-modified">!   if (!SafepointMechanism::uses_thread_local_poll()) {</span>
      assert(SafepointSynchronize::is_synchronizing(), &quot;polling encountered outside safepoint synchronization&quot;);
    }
  
    if (log_is_enabled(Info, safepoint, stats)) {
      Atomic::inc(&amp;_nof_threads_hit_polling_page);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 907,11 ***</span>
        if (cur_thread-&gt;safepoint_state()-&gt;is_running()) {
          if (!os::signal_thread(cur_thread, SIGILL, &quot;blocking a safepoint&quot;)) {
            break; // Could not send signal. Report fatal error.
          }
          // Give cur_thread a chance to report the error and terminate the VM.
<span class="line-modified">!         os::sleep(Thread::current(), 3000, false);</span>
        }
      }
      fatal(&quot;Safepoint sync time longer than &quot; INTX_FORMAT &quot;ms detected when executing %s.&quot;,
            SafepointTimeoutDelay, VMThread::vm_operation()-&gt;name());
    }
<span class="line-new-header">--- 925,11 ---</span>
        if (cur_thread-&gt;safepoint_state()-&gt;is_running()) {
          if (!os::signal_thread(cur_thread, SIGILL, &quot;blocking a safepoint&quot;)) {
            break; // Could not send signal. Report fatal error.
          }
          // Give cur_thread a chance to report the error and terminate the VM.
<span class="line-modified">!         os::naked_sleep(3000);</span>
        }
      }
      fatal(&quot;Safepoint sync time longer than &quot; INTX_FORMAT &quot;ms detected when executing %s.&quot;,
            SafepointTimeoutDelay, VMThread::vm_operation()-&gt;name());
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 920,12 ***</span>
  // -------------------------------------------------------------------------------------------------------
  // Implementation of ThreadSafepointState
  
  ThreadSafepointState::ThreadSafepointState(JavaThread *thread)
    : _at_poll_safepoint(false), _thread(thread), _safepoint_safe(false),
<span class="line-modified">!     _safepoint_id(SafepointSynchronize::InactiveSafepointCounter),</span>
<span class="line-removed">-     _orig_thread_state(_thread_uninitialized), _next(NULL) {</span>
  }
  
  void ThreadSafepointState::create(JavaThread *thread) {
    ThreadSafepointState *state = new ThreadSafepointState(thread);
    thread-&gt;set_safepoint_state(state);
<span class="line-new-header">--- 938,11 ---</span>
  // -------------------------------------------------------------------------------------------------------
  // Implementation of ThreadSafepointState
  
  ThreadSafepointState::ThreadSafepointState(JavaThread *thread)
    : _at_poll_safepoint(false), _thread(thread), _safepoint_safe(false),
<span class="line-modified">!     _safepoint_id(SafepointSynchronize::InactiveSafepointCounter), _next(NULL) {</span>
  }
  
  void ThreadSafepointState::create(JavaThread *thread) {
    ThreadSafepointState *state = new ThreadSafepointState(thread);
    thread-&gt;set_safepoint_state(state);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,19 ***</span>
      thread-&gt;set_safepoint_state(NULL);
    }
  }
  
  uint64_t ThreadSafepointState::get_safepoint_id() const {
<span class="line-modified">!   return OrderAccess::load_acquire(&amp;_safepoint_id);</span>
  }
  
  void ThreadSafepointState::reset_safepoint_id() {
<span class="line-modified">!   OrderAccess::release_store(&amp;_safepoint_id, SafepointSynchronize::InactiveSafepointCounter);</span>
  }
  
  void ThreadSafepointState::set_safepoint_id(uint64_t safepoint_id) {
<span class="line-modified">!   OrderAccess::release_store(&amp;_safepoint_id, safepoint_id);</span>
  }
  
  void ThreadSafepointState::examine_state_of_thread(uint64_t safepoint_count) {
    assert(is_running(), &quot;better be running or just have hit safepoint poll&quot;);
  
<span class="line-new-header">--- 954,19 ---</span>
      thread-&gt;set_safepoint_state(NULL);
    }
  }
  
  uint64_t ThreadSafepointState::get_safepoint_id() const {
<span class="line-modified">!   return Atomic::load_acquire(&amp;_safepoint_id);</span>
  }
  
  void ThreadSafepointState::reset_safepoint_id() {
<span class="line-modified">!   Atomic::release_store(&amp;_safepoint_id, SafepointSynchronize::InactiveSafepointCounter);</span>
  }
  
  void ThreadSafepointState::set_safepoint_id(uint64_t safepoint_id) {
<span class="line-modified">!   Atomic::release_store(&amp;_safepoint_id, safepoint_id);</span>
  }
  
  void ThreadSafepointState::examine_state_of_thread(uint64_t safepoint_count) {
    assert(is_running(), &quot;better be running or just have hit safepoint poll&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 958,13 ***</span>
      // We could not get stable state of the JavaThread.
      // Consider it running and just return.
      return;
    }
  
<span class="line-removed">-   // Save the state at the start of safepoint processing.</span>
<span class="line-removed">-   _orig_thread_state = stable_state;</span>
<span class="line-removed">- </span>
    // Check for a thread that is suspended. Note that thread resume tries
    // to grab the Threads_lock which we own here, so a thread cannot be
    // resumed during safepoint synchronization.
  
    // We check to see if this thread is suspended without locking to
<span class="line-new-header">--- 975,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1129,11 ***</span>
  
  jlong SafepointTracing::_last_safepoint_begin_time_ns = 0;
  jlong SafepointTracing::_last_safepoint_sync_time_ns = 0;
  jlong SafepointTracing::_last_safepoint_cleanup_time_ns = 0;
  jlong SafepointTracing::_last_safepoint_end_time_ns = 0;
<span class="line-removed">- jlong SafepointTracing::_last_safepoint_end_time_epoch_ms = 0;</span>
  jlong SafepointTracing::_last_app_time_ns = 0;
  int SafepointTracing::_nof_threads = 0;
  int SafepointTracing::_nof_running = 0;
  int SafepointTracing::_page_trap = 0;
  VM_Operation::VMOp_Type SafepointTracing::_current_type;
<span class="line-new-header">--- 1143,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1142,12 ***</span>
  uint64_t  SafepointTracing::_op_count[VM_Operation::VMOp_Terminating] = {0};
  
  void SafepointTracing::init() {
    // Application start
    _last_safepoint_end_time_ns = os::javaTimeNanos();
<span class="line-removed">-   // amount of time since epoch</span>
<span class="line-removed">-   _last_safepoint_end_time_epoch_ms = os::javaTimeMillis();</span>
  }
  
  // Helper method to print the header.
  static void print_header(outputStream* st) {
    // The number of spaces is significant here, and should match the format
<span class="line-new-header">--- 1155,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1243,12 ***</span>
    _last_safepoint_cleanup_time_ns = os::javaTimeNanos();
  }
  
  void SafepointTracing::end() {
    _last_safepoint_end_time_ns = os::javaTimeNanos();
<span class="line-removed">-   // amount of time since epoch</span>
<span class="line-removed">-   _last_safepoint_end_time_epoch_ms = os::javaTimeMillis();</span>
  
    if (_max_sync_time &lt; (_last_safepoint_sync_time_ns - _last_safepoint_begin_time_ns)) {
      _max_sync_time = _last_safepoint_sync_time_ns - _last_safepoint_begin_time_ns;
    }
    if (_max_vmop_time &lt; (_last_safepoint_end_time_ns - _last_safepoint_sync_time_ns)) {
<span class="line-new-header">--- 1254,10 ---</span>
</pre>
<center><a href="rtmLocking.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepoint.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
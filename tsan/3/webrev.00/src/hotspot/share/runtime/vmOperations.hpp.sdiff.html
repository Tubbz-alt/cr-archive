<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/vmOperations.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vmOperations.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/vmOperations.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 25 #ifndef SHARE_RUNTIME_VMOPERATIONS_HPP
 26 #define SHARE_RUNTIME_VMOPERATIONS_HPP
 27 
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;oops/oop.hpp&quot;
 31 #include &quot;runtime/thread.hpp&quot;
 32 #include &quot;runtime/threadSMR.hpp&quot;
 33 #include &quot;code/codeCache.hpp&quot;
 34 
 35 // The following classes are used for operations
 36 // initiated by a Java thread but that must
 37 // take place in the VMThread.
 38 
 39 #define VM_OP_ENUM(type)   VMOp_##type,
 40 
 41 // Note: When new VM_XXX comes up, add &#39;XXX&#39; to the template table.
 42 #define VM_OPS_DO(template)                       \
 43   template(None)                                  \
 44   template(Cleanup)                               \
<span class="line-removed"> 45   template(ThreadStop)                            \</span>
 46   template(ThreadDump)                            \
 47   template(PrintThreads)                          \
 48   template(FindDeadlocks)                         \
 49   template(ClearICs)                              \
 50   template(ForceSafepoint)                        \
 51   template(ForceAsyncSafepoint)                   \
<span class="line-removed"> 52   template(Deoptimize)                            \</span>
 53   template(DeoptimizeFrame)                       \
 54   template(DeoptimizeAll)                         \
 55   template(ZombieAll)                             \
 56   template(Verify)                                \
 57   template(PrintJNI)                              \
 58   template(HeapDumper)                            \
 59   template(DeoptimizeTheWorld)                    \
 60   template(CollectForMetadataAllocation)          \
 61   template(GC_HeapInspection)                     \
 62   template(GenCollectFull)                        \
 63   template(GenCollectFullConcurrent)              \
 64   template(GenCollectForAllocation)               \
 65   template(ParallelGCFailedAllocation)            \
 66   template(ParallelGCSystemGC)                    \
<span class="line-removed"> 67   template(CMS_Initial_Mark)                      \</span>
<span class="line-removed"> 68   template(CMS_Final_Remark)                      \</span>
 69   template(G1CollectForAllocation)                \
 70   template(G1CollectFull)                         \
 71   template(G1Concurrent)                          \

 72   template(ZMarkStart)                            \
 73   template(ZMarkEnd)                              \
 74   template(ZRelocateStart)                        \

 75   template(HandshakeOneThread)                    \
 76   template(HandshakeAllThreads)                   \
 77   template(HandshakeFallback)                     \
 78   template(EnableBiasedLocking)                   \
<span class="line-removed"> 79   template(RevokeBias)                            \</span>
 80   template(BulkRevokeBias)                        \
 81   template(PopulateDumpSharedSpace)               \
 82   template(JNIFunctionTableCopier)                \
 83   template(RedefineClasses)                       \
 84   template(UpdateForPopTopFrame)                  \
 85   template(SetFramePop)                           \
 86   template(GetOwnedMonitorInfo)                   \
 87   template(GetObjectMonitorUsage)                 \
 88   template(GetCurrentContendedMonitor)            \
 89   template(GetStackTrace)                         \
 90   template(GetMultipleStackTraces)                \
 91   template(GetAllStackTraces)                     \
 92   template(GetThreadListStackTraces)              \
 93   template(GetFrameCount)                         \
 94   template(GetFrameLocation)                      \
 95   template(ChangeBreakpoints)                     \
 96   template(GetOrSetLocal)                         \
 97   template(GetCurrentLocation)                    \
 98   template(EnterInterpOnlyMode)                   \
 99   template(ChangeSingleStep)                      \
100   template(HeapWalkOperation)                     \
101   template(HeapIterateOperation)                  \
102   template(ReportJavaOutOfMemory)                 \
103   template(JFRCheckpoint)                         \
104   template(ShenandoahFullGC)                      \
105   template(ShenandoahInitMark)                    \
106   template(ShenandoahFinalMarkStartEvac)          \
107   template(ShenandoahFinalEvac)                   \
108   template(ShenandoahInitTraversalGC)             \
109   template(ShenandoahFinalTraversalGC)            \
110   template(ShenandoahInitUpdateRefs)              \
111   template(ShenandoahFinalUpdateRefs)             \
112   template(ShenandoahDegeneratedGC)               \
113   template(Exit)                                  \
114   template(LinuxDllLoad)                          \
115   template(RotateGCLog)                           \
116   template(WhiteBoxOperation)                     \

117   template(ClassLoaderStatsOperation)             \
118   template(ClassLoaderHierarchyOperation)         \
119   template(DumpHashtable)                         \
120   template(DumpTouchedMethods)                    \
121   template(MarkActiveNMethods)                    \
122   template(PrintCompileQueue)                     \
123   template(PrintClassHierarchy)                   \
124   template(ThreadSuspend)                         \
125   template(ThreadsSuspendJVMTI)                   \
126   template(ICBufferFull)                          \
127   template(ScavengeMonitors)                      \
128   template(PrintMetadata)                         \
129   template(GTestExecuteAtSafepoint)               \

130 
<span class="line-modified">131 class VM_Operation: public CHeapObj&lt;mtInternal&gt; {</span>
132  public:
<span class="line-removed">133   enum Mode {</span>
<span class="line-removed">134     _safepoint,       // blocking,        safepoint, vm_op C-heap allocated</span>
<span class="line-removed">135     _no_safepoint,    // blocking,     no safepoint, vm_op C-Heap allocated</span>
<span class="line-removed">136     _concurrent,      // non-blocking, no safepoint, vm_op C-Heap allocated</span>
<span class="line-removed">137     _async_safepoint  // non-blocking,    safepoint, vm_op C-Heap allocated</span>
<span class="line-removed">138   };</span>
<span class="line-removed">139 </span>
140   enum VMOp_Type {
141     VM_OPS_DO(VM_OP_ENUM)
142     VMOp_Terminating
143   };
144 
145  private:
146   Thread*         _calling_thread;
<span class="line-modified">147   ThreadPriority  _priority;</span>
<span class="line-removed">148   long            _timestamp;</span>
149   VM_Operation*   _next;
150   VM_Operation*   _prev;
151 
152   // The VM operation name array
153   static const char* _names[];
154 
155  public:
<span class="line-modified">156   VM_Operation()  { _calling_thread = NULL; _next = NULL; _prev = NULL; }</span>
<span class="line-removed">157   virtual ~VM_Operation() {}</span>
158 
159   // VM operation support (used by VM thread)
160   Thread* calling_thread() const                 { return _calling_thread; }
<span class="line-modified">161   ThreadPriority priority()                      { return _priority; }</span>
<span class="line-removed">162   void set_calling_thread(Thread* thread, ThreadPriority priority);</span>
163 
<span class="line-modified">164   long timestamp() const              { return _timestamp; }</span>
<span class="line-modified">165   void set_timestamp(long timestamp)  { _timestamp = timestamp; }</span>
166 
167   // Called by VM thread - does in turn invoke doit(). Do not override this
168   void evaluate();
169 
170   // evaluate() is called by the VMThread and in turn calls doit().
171   // If the thread invoking VMThread::execute((VM_Operation*) is a JavaThread,
172   // doit_prologue() is called in that thread before transferring control to
173   // the VMThread.
174   // If doit_prologue() returns true the VM operation will proceed, and
175   // doit_epilogue() will be called by the JavaThread once the VM operation
176   // completes. If doit_prologue() returns false the VM operation is cancelled.
177   virtual void doit()                            = 0;
178   virtual bool doit_prologue()                   { return true; };
<span class="line-modified">179   virtual void doit_epilogue()                   {}; // Note: Not called if mode is: _concurrent</span>
<span class="line-removed">180 </span>
<span class="line-removed">181   // Type test</span>
<span class="line-removed">182   virtual bool is_methodCompiler() const         { return false; }</span>
183 
184   // Linking
185   VM_Operation *next() const                     { return _next; }
186   VM_Operation *prev() const                     { return _prev; }
187   void set_next(VM_Operation *next)              { _next = next; }
188   void set_prev(VM_Operation *prev)              { _prev = prev; }
189 
190   // Configuration. Override these appropriately in subclasses.
191   virtual VMOp_Type type() const = 0;
<span class="line-removed">192   virtual Mode evaluation_mode() const            { return _safepoint; }</span>
193   virtual bool allow_nested_vm_operations() const { return false; }
<span class="line-removed">194   virtual bool is_cheap_allocated() const         { return false; }</span>
<span class="line-removed">195   virtual void oops_do(OopClosure* f)              { /* do nothing */ };</span>
<span class="line-removed">196 </span>
<span class="line-removed">197   // CAUTION: &lt;don&#39;t hang yourself with following rope&gt;</span>
<span class="line-removed">198   // If you override these methods, make sure that the evaluation</span>
<span class="line-removed">199   // of these methods is race-free and non-blocking, since these</span>
<span class="line-removed">200   // methods may be evaluated either by the mutators or by the</span>
<span class="line-removed">201   // vm thread, either concurrently with mutators or with the mutators</span>
<span class="line-removed">202   // stopped. In other words, taking locks is verboten, and if there</span>
<span class="line-removed">203   // are any races in evaluating the conditions, they&#39;d better be benign.</span>
<span class="line-removed">204   virtual bool evaluate_at_safepoint() const {</span>
<span class="line-removed">205     return evaluation_mode() == _safepoint  ||</span>
<span class="line-removed">206            evaluation_mode() == _async_safepoint;</span>
<span class="line-removed">207   }</span>
<span class="line-removed">208   virtual bool evaluate_concurrently() const {</span>
<span class="line-removed">209     return evaluation_mode() == _concurrent ||</span>
<span class="line-removed">210            evaluation_mode() == _async_safepoint;</span>
<span class="line-removed">211   }</span>
212 
<span class="line-modified">213   static const char* mode_to_string(Mode mode);</span>


214 
215   // Debugging
216   virtual void print_on_error(outputStream* st) const;
217   virtual const char* name() const  { return _names[type()]; }
218   static const char* name(int type) {
219     assert(type &gt;= 0 &amp;&amp; type &lt; VMOp_Terminating, &quot;invalid VM operation type&quot;);
220     return _names[type];
221   }
222 #ifndef PRODUCT
223   void print_on(outputStream* st) const { print_on_error(st); }
224 #endif
225 };
226 
227 class VM_None: public VM_Operation {
228   const char* _reason;
229  public:
230   VM_None(const char* reason) : _reason(reason) {}
231   const char* name() const { return _reason; }
232   VMOp_Type type() const { return VMOp_None; }
233   void doit() {};
234 };
235 
236 class VM_Cleanup: public VM_Operation {
237  public:
238   VMOp_Type type() const { return VMOp_Cleanup; }
239   void doit() {};
240 };
241 
<span class="line-removed">242 class VM_ThreadStop: public VM_Operation {</span>
<span class="line-removed">243  private:</span>
<span class="line-removed">244   oop     _thread;        // The Thread that the Throwable is thrown against</span>
<span class="line-removed">245   oop     _throwable;     // The Throwable thrown at the target Thread</span>
<span class="line-removed">246  public:</span>
<span class="line-removed">247   // All oops are passed as JNI handles, since there is no guarantee that a GC might happen before the</span>
<span class="line-removed">248   // VM operation is executed.</span>
<span class="line-removed">249   VM_ThreadStop(oop thread, oop throwable) {</span>
<span class="line-removed">250     _thread    = thread;</span>
<span class="line-removed">251     _throwable = throwable;</span>
<span class="line-removed">252   }</span>
<span class="line-removed">253   VMOp_Type type() const                         { return VMOp_ThreadStop; }</span>
<span class="line-removed">254   oop target_thread() const                      { return _thread; }</span>
<span class="line-removed">255   oop throwable() const                          { return _throwable;}</span>
<span class="line-removed">256   void doit();</span>
<span class="line-removed">257   // We deoptimize if top-most frame is compiled - this might require a C2I adapter to be generated</span>
<span class="line-removed">258   bool allow_nested_vm_operations() const        { return true; }</span>
<span class="line-removed">259   Mode evaluation_mode() const                   { return _async_safepoint; }</span>
<span class="line-removed">260   bool is_cheap_allocated() const                { return true; }</span>
<span class="line-removed">261 </span>
<span class="line-removed">262   // GC support</span>
<span class="line-removed">263   void oops_do(OopClosure* f) {</span>
<span class="line-removed">264     f-&gt;do_oop(&amp;_thread); f-&gt;do_oop(&amp;_throwable);</span>
<span class="line-removed">265   }</span>
<span class="line-removed">266 };</span>
<span class="line-removed">267 </span>
268 class VM_ClearICs: public VM_Operation {
269  private:
270   bool _preserve_static_stubs;
271  public:
272   VM_ClearICs(bool preserve_static_stubs) { _preserve_static_stubs = preserve_static_stubs; }
273   void doit();
274   VMOp_Type type() const { return VMOp_ClearICs; }
275 };
276 
277 // empty vm op, evaluated just to force a safepoint
278 class VM_ForceSafepoint: public VM_Operation {
279  public:
280   void doit()         {}
281   VMOp_Type type() const { return VMOp_ForceSafepoint; }
282 };
283 
284 // empty vm op, when forcing a safepoint to suspend a thread
285 class VM_ThreadSuspend: public VM_ForceSafepoint {
286  public:
287   VMOp_Type type() const { return VMOp_ThreadSuspend; }
288 };
289 
290 // empty vm op, when forcing a safepoint to suspend threads from jvmti
291 class VM_ThreadsSuspendJVMTI: public VM_ForceSafepoint {
292  public:
293   VMOp_Type type() const { return VMOp_ThreadsSuspendJVMTI; }
294 };
295 
296 // empty vm op, when forcing a safepoint due to inline cache buffers being full
297 class VM_ICBufferFull: public VM_ForceSafepoint {
298  public:
299   VMOp_Type type() const { return VMOp_ICBufferFull; }
300 };
301 
<span class="line-removed">302 // empty asynchronous vm op, when forcing a safepoint to scavenge monitors</span>
<span class="line-removed">303 class VM_ScavengeMonitors: public VM_ForceSafepoint {</span>
<span class="line-removed">304  public:</span>
<span class="line-removed">305   VMOp_Type type() const                         { return VMOp_ScavengeMonitors; }</span>
<span class="line-removed">306   Mode evaluation_mode() const                   { return _async_safepoint; }</span>
<span class="line-removed">307   bool is_cheap_allocated() const                { return true; }</span>
<span class="line-removed">308 };</span>
<span class="line-removed">309 </span>
310 // Base class for invoking parts of a gtest in a safepoint.
311 // Derived classes provide the doit method.
312 // Typically also need to transition the gtest thread from native to VM.
313 class VM_GTestExecuteAtSafepoint: public VM_Operation {
314  public:
315   VMOp_Type type() const                         { return VMOp_GTestExecuteAtSafepoint; }
316 
317  protected:
318   VM_GTestExecuteAtSafepoint() {}
319 };
320 
<span class="line-removed">321 class VM_Deoptimize: public VM_Operation {</span>
<span class="line-removed">322  public:</span>
<span class="line-removed">323   VM_Deoptimize() {}</span>
<span class="line-removed">324   VMOp_Type type() const                        { return VMOp_Deoptimize; }</span>
<span class="line-removed">325   void doit();</span>
<span class="line-removed">326   bool allow_nested_vm_operations() const        { return true; }</span>
<span class="line-removed">327 };</span>
<span class="line-removed">328 </span>
329 class VM_MarkActiveNMethods: public VM_Operation {
330  public:
331   VM_MarkActiveNMethods() {}
332   VMOp_Type type() const                         { return VMOp_MarkActiveNMethods; }
333   void doit();
334   bool allow_nested_vm_operations() const        { return true; }
335 };
336 
337 // Deopt helper that can deoptimize frames in threads other than the
338 // current thread.  Only used through Deoptimization::deoptimize_frame.
339 class VM_DeoptimizeFrame: public VM_Operation {
340   friend class Deoptimization;
341 
342  private:
343   JavaThread* _thread;
344   intptr_t*   _id;
345   int _reason;
346   VM_DeoptimizeFrame(JavaThread* thread, intptr_t* id, int reason);
347 
348  public:
</pre>
<hr />
<pre>
491   static int wait_for_threads_in_native_to_block();
492   static int set_vm_exited();
493   static bool vm_exited()                      { return _vm_exited; }
494   static Thread * shutdown_thread()            { return _shutdown_thread; }
495   static void block_if_vm_exited() {
496     if (_vm_exited) {
497       wait_if_vm_exited();
498     }
499   }
500   VMOp_Type type() const { return VMOp_Exit; }
501   void doit();
502 };
503 
504 class VM_PrintCompileQueue: public VM_Operation {
505  private:
506   outputStream* _out;
507 
508  public:
509   VM_PrintCompileQueue(outputStream* st) : _out(st) {}
510   VMOp_Type type() const { return VMOp_PrintCompileQueue; }
<span class="line-removed">511   Mode evaluation_mode() const { return _safepoint; }</span>
512   void doit();
513 };
514 
515 #if INCLUDE_SERVICES
516 class VM_PrintClassHierarchy: public VM_Operation {
517  private:
518   outputStream* _out;
519   bool _print_interfaces;
520   bool _print_subclasses;
521   char* _classname;
522 
523  public:
524   VM_PrintClassHierarchy(outputStream* st, bool print_interfaces, bool print_subclasses, char* classname) :
525     _out(st), _print_interfaces(print_interfaces), _print_subclasses(print_subclasses),
526     _classname(classname) {}
527   VMOp_Type type() const { return VMOp_PrintClassHierarchy; }
528   void doit();
529 };
530 #endif // INCLUDE_SERVICES
531 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 25 #ifndef SHARE_RUNTIME_VMOPERATIONS_HPP
 26 #define SHARE_RUNTIME_VMOPERATIONS_HPP
 27 
 28 #include &quot;classfile/javaClasses.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;oops/oop.hpp&quot;
 31 #include &quot;runtime/thread.hpp&quot;
 32 #include &quot;runtime/threadSMR.hpp&quot;
 33 #include &quot;code/codeCache.hpp&quot;
 34 
 35 // The following classes are used for operations
 36 // initiated by a Java thread but that must
 37 // take place in the VMThread.
 38 
 39 #define VM_OP_ENUM(type)   VMOp_##type,
 40 
 41 // Note: When new VM_XXX comes up, add &#39;XXX&#39; to the template table.
 42 #define VM_OPS_DO(template)                       \
 43   template(None)                                  \
 44   template(Cleanup)                               \

 45   template(ThreadDump)                            \
 46   template(PrintThreads)                          \
 47   template(FindDeadlocks)                         \
 48   template(ClearICs)                              \
 49   template(ForceSafepoint)                        \
 50   template(ForceAsyncSafepoint)                   \

 51   template(DeoptimizeFrame)                       \
 52   template(DeoptimizeAll)                         \
 53   template(ZombieAll)                             \
 54   template(Verify)                                \
 55   template(PrintJNI)                              \
 56   template(HeapDumper)                            \
 57   template(DeoptimizeTheWorld)                    \
 58   template(CollectForMetadataAllocation)          \
 59   template(GC_HeapInspection)                     \
 60   template(GenCollectFull)                        \
 61   template(GenCollectFullConcurrent)              \
 62   template(GenCollectForAllocation)               \
 63   template(ParallelGCFailedAllocation)            \
 64   template(ParallelGCSystemGC)                    \


 65   template(G1CollectForAllocation)                \
 66   template(G1CollectFull)                         \
 67   template(G1Concurrent)                          \
<span class="line-added"> 68   template(G1TryInitiateConcMark)                 \</span>
 69   template(ZMarkStart)                            \
 70   template(ZMarkEnd)                              \
 71   template(ZRelocateStart)                        \
<span class="line-added"> 72   template(ZVerify)                               \</span>
 73   template(HandshakeOneThread)                    \
 74   template(HandshakeAllThreads)                   \
 75   template(HandshakeFallback)                     \
 76   template(EnableBiasedLocking)                   \

 77   template(BulkRevokeBias)                        \
 78   template(PopulateDumpSharedSpace)               \
 79   template(JNIFunctionTableCopier)                \
 80   template(RedefineClasses)                       \
 81   template(UpdateForPopTopFrame)                  \
 82   template(SetFramePop)                           \
 83   template(GetOwnedMonitorInfo)                   \
 84   template(GetObjectMonitorUsage)                 \
 85   template(GetCurrentContendedMonitor)            \
 86   template(GetStackTrace)                         \
 87   template(GetMultipleStackTraces)                \
 88   template(GetAllStackTraces)                     \
 89   template(GetThreadListStackTraces)              \
 90   template(GetFrameCount)                         \
 91   template(GetFrameLocation)                      \
 92   template(ChangeBreakpoints)                     \
 93   template(GetOrSetLocal)                         \
 94   template(GetCurrentLocation)                    \
 95   template(EnterInterpOnlyMode)                   \
 96   template(ChangeSingleStep)                      \
 97   template(HeapWalkOperation)                     \
 98   template(HeapIterateOperation)                  \
 99   template(ReportJavaOutOfMemory)                 \
100   template(JFRCheckpoint)                         \
101   template(ShenandoahFullGC)                      \
102   template(ShenandoahInitMark)                    \
103   template(ShenandoahFinalMarkStartEvac)          \
104   template(ShenandoahFinalEvac)                   \
105   template(ShenandoahInitTraversalGC)             \
106   template(ShenandoahFinalTraversalGC)            \
107   template(ShenandoahInitUpdateRefs)              \
108   template(ShenandoahFinalUpdateRefs)             \
109   template(ShenandoahDegeneratedGC)               \
110   template(Exit)                                  \
111   template(LinuxDllLoad)                          \
112   template(RotateGCLog)                           \
113   template(WhiteBoxOperation)                     \
<span class="line-added">114   template(JVMCIResizeCounters)                   \</span>
115   template(ClassLoaderStatsOperation)             \
116   template(ClassLoaderHierarchyOperation)         \
117   template(DumpHashtable)                         \
118   template(DumpTouchedMethods)                    \
119   template(MarkActiveNMethods)                    \
120   template(PrintCompileQueue)                     \
121   template(PrintClassHierarchy)                   \
122   template(ThreadSuspend)                         \
123   template(ThreadsSuspendJVMTI)                   \
124   template(ICBufferFull)                          \
125   template(ScavengeMonitors)                      \
126   template(PrintMetadata)                         \
127   template(GTestExecuteAtSafepoint)               \
<span class="line-added">128   template(JFROldObject)                          \</span>
129 
<span class="line-modified">130 class VM_Operation : public StackObj {</span>
131  public:







132   enum VMOp_Type {
133     VM_OPS_DO(VM_OP_ENUM)
134     VMOp_Terminating
135   };
136 
137  private:
138   Thread*         _calling_thread;
<span class="line-modified">139   uint64_t        _timestamp;</span>

140   VM_Operation*   _next;
141   VM_Operation*   _prev;
142 
143   // The VM operation name array
144   static const char* _names[];
145 
146  public:
<span class="line-modified">147   VM_Operation() : _calling_thread(NULL), _timestamp(0),  _next(NULL), _prev(NULL) {}</span>

148 
149   // VM operation support (used by VM thread)
150   Thread* calling_thread() const                 { return _calling_thread; }
<span class="line-modified">151   void set_calling_thread(Thread* thread);</span>

152 
<span class="line-modified">153   uint64_t timestamp() const              { return _timestamp; }</span>
<span class="line-modified">154   void set_timestamp(uint64_t timestamp)  { _timestamp = timestamp; }</span>
155 
156   // Called by VM thread - does in turn invoke doit(). Do not override this
157   void evaluate();
158 
159   // evaluate() is called by the VMThread and in turn calls doit().
160   // If the thread invoking VMThread::execute((VM_Operation*) is a JavaThread,
161   // doit_prologue() is called in that thread before transferring control to
162   // the VMThread.
163   // If doit_prologue() returns true the VM operation will proceed, and
164   // doit_epilogue() will be called by the JavaThread once the VM operation
165   // completes. If doit_prologue() returns false the VM operation is cancelled.
166   virtual void doit()                            = 0;
167   virtual bool doit_prologue()                   { return true; };
<span class="line-modified">168   virtual void doit_epilogue()                   {};</span>



169 
170   // Linking
171   VM_Operation *next() const                     { return _next; }
172   VM_Operation *prev() const                     { return _prev; }
173   void set_next(VM_Operation *next)              { _next = next; }
174   void set_prev(VM_Operation *prev)              { _prev = prev; }
175 
176   // Configuration. Override these appropriately in subclasses.
177   virtual VMOp_Type type() const = 0;

178   virtual bool allow_nested_vm_operations() const { return false; }


















179 
<span class="line-modified">180   // An operation can either be done inside a safepoint</span>
<span class="line-added">181   // or concurrently with Java threads running.</span>
<span class="line-added">182   virtual bool evaluate_at_safepoint() const { return true; }</span>
183 
184   // Debugging
185   virtual void print_on_error(outputStream* st) const;
186   virtual const char* name() const  { return _names[type()]; }
187   static const char* name(int type) {
188     assert(type &gt;= 0 &amp;&amp; type &lt; VMOp_Terminating, &quot;invalid VM operation type&quot;);
189     return _names[type];
190   }
191 #ifndef PRODUCT
192   void print_on(outputStream* st) const { print_on_error(st); }
193 #endif
194 };
195 
196 class VM_None: public VM_Operation {
197   const char* _reason;
198  public:
199   VM_None(const char* reason) : _reason(reason) {}
200   const char* name() const { return _reason; }
201   VMOp_Type type() const { return VMOp_None; }
202   void doit() {};
203 };
204 
205 class VM_Cleanup: public VM_Operation {
206  public:
207   VMOp_Type type() const { return VMOp_Cleanup; }
208   void doit() {};
209 };
210 


























211 class VM_ClearICs: public VM_Operation {
212  private:
213   bool _preserve_static_stubs;
214  public:
215   VM_ClearICs(bool preserve_static_stubs) { _preserve_static_stubs = preserve_static_stubs; }
216   void doit();
217   VMOp_Type type() const { return VMOp_ClearICs; }
218 };
219 
220 // empty vm op, evaluated just to force a safepoint
221 class VM_ForceSafepoint: public VM_Operation {
222  public:
223   void doit()         {}
224   VMOp_Type type() const { return VMOp_ForceSafepoint; }
225 };
226 
227 // empty vm op, when forcing a safepoint to suspend a thread
228 class VM_ThreadSuspend: public VM_ForceSafepoint {
229  public:
230   VMOp_Type type() const { return VMOp_ThreadSuspend; }
231 };
232 
233 // empty vm op, when forcing a safepoint to suspend threads from jvmti
234 class VM_ThreadsSuspendJVMTI: public VM_ForceSafepoint {
235  public:
236   VMOp_Type type() const { return VMOp_ThreadsSuspendJVMTI; }
237 };
238 
239 // empty vm op, when forcing a safepoint due to inline cache buffers being full
240 class VM_ICBufferFull: public VM_ForceSafepoint {
241  public:
242   VMOp_Type type() const { return VMOp_ICBufferFull; }
243 };
244 








245 // Base class for invoking parts of a gtest in a safepoint.
246 // Derived classes provide the doit method.
247 // Typically also need to transition the gtest thread from native to VM.
248 class VM_GTestExecuteAtSafepoint: public VM_Operation {
249  public:
250   VMOp_Type type() const                         { return VMOp_GTestExecuteAtSafepoint; }
251 
252  protected:
253   VM_GTestExecuteAtSafepoint() {}
254 };
255 








256 class VM_MarkActiveNMethods: public VM_Operation {
257  public:
258   VM_MarkActiveNMethods() {}
259   VMOp_Type type() const                         { return VMOp_MarkActiveNMethods; }
260   void doit();
261   bool allow_nested_vm_operations() const        { return true; }
262 };
263 
264 // Deopt helper that can deoptimize frames in threads other than the
265 // current thread.  Only used through Deoptimization::deoptimize_frame.
266 class VM_DeoptimizeFrame: public VM_Operation {
267   friend class Deoptimization;
268 
269  private:
270   JavaThread* _thread;
271   intptr_t*   _id;
272   int _reason;
273   VM_DeoptimizeFrame(JavaThread* thread, intptr_t* id, int reason);
274 
275  public:
</pre>
<hr />
<pre>
418   static int wait_for_threads_in_native_to_block();
419   static int set_vm_exited();
420   static bool vm_exited()                      { return _vm_exited; }
421   static Thread * shutdown_thread()            { return _shutdown_thread; }
422   static void block_if_vm_exited() {
423     if (_vm_exited) {
424       wait_if_vm_exited();
425     }
426   }
427   VMOp_Type type() const { return VMOp_Exit; }
428   void doit();
429 };
430 
431 class VM_PrintCompileQueue: public VM_Operation {
432  private:
433   outputStream* _out;
434 
435  public:
436   VM_PrintCompileQueue(outputStream* st) : _out(st) {}
437   VMOp_Type type() const { return VMOp_PrintCompileQueue; }

438   void doit();
439 };
440 
441 #if INCLUDE_SERVICES
442 class VM_PrintClassHierarchy: public VM_Operation {
443  private:
444   outputStream* _out;
445   bool _print_interfaces;
446   bool _print_subclasses;
447   char* _classname;
448 
449  public:
450   VM_PrintClassHierarchy(outputStream* st, bool print_interfaces, bool print_subclasses, char* classname) :
451     _out(st), _print_interfaces(print_interfaces), _print_subclasses(print_subclasses),
452     _classname(classname) {}
453   VMOp_Type type() const { return VMOp_PrintClassHierarchy; }
454   void doit();
455 };
456 #endif // INCLUDE_SERVICES
457 
</pre>
</td>
</tr>
</table>
<center><a href="vmOperations.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
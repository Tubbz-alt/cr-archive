<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/frame.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="flags/jvmFlagRangeList.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/frame.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;

  26 #include &quot;code/codeCache.hpp&quot;
  27 #include &quot;code/vmreg.inline.hpp&quot;
  28 #include &quot;compiler/abstractCompiler.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;interpreter/oopMapCache.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
<span class="line-modified">  35 #include &quot;oops/markOop.hpp&quot;</span>
  36 #include &quot;oops/method.hpp&quot;
  37 #include &quot;oops/methodData.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;oops/verifyOopClosure.hpp&quot;
  40 #include &quot;prims/methodHandles.hpp&quot;
  41 #include &quot;runtime/frame.inline.hpp&quot;
  42 #include &quot;runtime/handles.inline.hpp&quot;
  43 #include &quot;runtime/javaCalls.hpp&quot;
  44 #include &quot;runtime/monitorChunk.hpp&quot;
  45 #include &quot;runtime/os.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/signature.hpp&quot;
  48 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  49 #include &quot;runtime/stubRoutines.hpp&quot;
  50 #include &quot;runtime/thread.inline.hpp&quot;
  51 #include &quot;utilities/debug.hpp&quot;
  52 #include &quot;utilities/decoder.hpp&quot;
  53 #include &quot;utilities/formatBuffer.hpp&quot;
  54 
  55 RegisterMap::RegisterMap(JavaThread *thread, bool update_map) {
</pre>
<hr />
<pre>
 253 
 254   if( !nm-&gt;is_marked_for_deoptimization() )
 255     return false;
 256 
 257   // If at the return point, then the frame has already been popped, and
 258   // only the return needs to be executed. Don&#39;t deoptimize here.
 259   return !nm-&gt;is_at_poll_return(pc());
 260 }
 261 
 262 bool frame::can_be_deoptimized() const {
 263   if (!is_compiled_frame()) return false;
 264   CompiledMethod* nm = (CompiledMethod*)_cb;
 265 
 266   if( !nm-&gt;can_be_deoptimized() )
 267     return false;
 268 
 269   return !nm-&gt;is_at_poll_return(pc());
 270 }
 271 
 272 void frame::deoptimize(JavaThread* thread) {


 273   // Schedule deoptimization of an nmethod activation with this frame.
 274   assert(_cb != NULL &amp;&amp; _cb-&gt;is_compiled(), &quot;must be&quot;);
 275 
<span class="line-removed"> 276   // This is a fix for register window patching race</span>
<span class="line-removed"> 277   if (NeedsDeoptSuspend &amp;&amp; Thread::current() != thread) {</span>
<span class="line-removed"> 278     assert(SafepointSynchronize::is_at_safepoint(),</span>
<span class="line-removed"> 279            &quot;patching other threads for deopt may only occur at a safepoint&quot;);</span>
<span class="line-removed"> 280 </span>
<span class="line-removed"> 281     // It is possible especially with DeoptimizeALot/DeoptimizeRandom that</span>
<span class="line-removed"> 282     // we could see the frame again and ask for it to be deoptimized since</span>
<span class="line-removed"> 283     // it might move for a long time. That is harmless and we just ignore it.</span>
<span class="line-removed"> 284     if (id() == thread-&gt;must_deopt_id()) {</span>
<span class="line-removed"> 285       assert(thread-&gt;is_deopt_suspend(), &quot;lost suspension&quot;);</span>
<span class="line-removed"> 286       return;</span>
<span class="line-removed"> 287     }</span>
<span class="line-removed"> 288 </span>
<span class="line-removed"> 289     // We are at a safepoint so the target thread can only be</span>
<span class="line-removed"> 290     // in 4 states:</span>
<span class="line-removed"> 291     //     blocked - no problem</span>
<span class="line-removed"> 292     //     blocked_trans - no problem (i.e. could have woken up from blocked</span>
<span class="line-removed"> 293     //                                 during a safepoint).</span>
<span class="line-removed"> 294     //     native - register window pc patching race</span>
<span class="line-removed"> 295     //     native_trans - momentary state</span>
<span class="line-removed"> 296     //</span>
<span class="line-removed"> 297     // We could just wait out a thread in native_trans to block.</span>
<span class="line-removed"> 298     // Then we&#39;d have all the issues that the safepoint code has as to</span>
<span class="line-removed"> 299     // whether to spin or block. It isn&#39;t worth it. Just treat it like</span>
<span class="line-removed"> 300     // native and be done with it.</span>
<span class="line-removed"> 301     //</span>
<span class="line-removed"> 302     // Examine the state of the thread at the start of safepoint since</span>
<span class="line-removed"> 303     // threads that were in native at the start of the safepoint could</span>
<span class="line-removed"> 304     // come to a halt during the safepoint, changing the current value</span>
<span class="line-removed"> 305     // of the safepoint_state.</span>
<span class="line-removed"> 306     JavaThreadState state = thread-&gt;safepoint_state()-&gt;orig_thread_state();</span>
<span class="line-removed"> 307     if (state == _thread_in_native || state == _thread_in_native_trans) {</span>
<span class="line-removed"> 308       // Since we are at a safepoint the target thread will stop itself</span>
<span class="line-removed"> 309       // before it can return to java as long as we remain at the safepoint.</span>
<span class="line-removed"> 310       // Therefore we can put an additional request for the thread to stop</span>
<span class="line-removed"> 311       // no matter what no (like a suspend). This will cause the thread</span>
<span class="line-removed"> 312       // to notice it needs to do the deopt on its own once it leaves native.</span>
<span class="line-removed"> 313       //</span>
<span class="line-removed"> 314       // The only reason we must do this is because on machine with register</span>
<span class="line-removed"> 315       // windows we have a race with patching the return address and the</span>
<span class="line-removed"> 316       // window coming live as the thread returns to the Java code (but still</span>
<span class="line-removed"> 317       // in native mode) and then blocks. It is only this top most frame</span>
<span class="line-removed"> 318       // that is at risk. So in truth we could add an additional check to</span>
<span class="line-removed"> 319       // see if this frame is one that is at risk.</span>
<span class="line-removed"> 320       RegisterMap map(thread, false);</span>
<span class="line-removed"> 321       frame at_risk =  thread-&gt;last_frame().sender(&amp;map);</span>
<span class="line-removed"> 322       if (id() == at_risk.id()) {</span>
<span class="line-removed"> 323         thread-&gt;set_must_deopt_id(id());</span>
<span class="line-removed"> 324         thread-&gt;set_deopt_suspend();</span>
<span class="line-removed"> 325         return;</span>
<span class="line-removed"> 326       }</span>
<span class="line-removed"> 327     }</span>
<span class="line-removed"> 328   } // NeedsDeoptSuspend</span>
<span class="line-removed"> 329 </span>
<span class="line-removed"> 330 </span>
 331   // If the call site is a MethodHandle call site use the MH deopt
 332   // handler.
 333   CompiledMethod* cm = (CompiledMethod*) _cb;
 334   address deopt = cm-&gt;is_method_handle_return(pc()) ?
 335                         cm-&gt;deopt_mh_handler_begin() :
 336                         cm-&gt;deopt_handler_begin();
 337 
 338   // Save the original pc before we patch in the new one
 339   cm-&gt;set_original_pc(this, pc());
 340   patch_pc(thread, deopt);
 341 
 342 #ifdef ASSERT
 343   {
 344     RegisterMap map(thread, false);
 345     frame check = thread-&gt;last_frame();
 346     while (id() != check.id()) {
 347       check = check.sender(&amp;map);
 348     }
 349     assert(check.is_deoptimized_frame(), &quot;missed deopt&quot;);
 350   }
</pre>
<hr />
<pre>
 664           nmethod* nm = cm-&gt;as_nmethod();
 665           st-&gt;print(&quot;J %d%s&quot;, nm-&gt;compile_id(), (nm-&gt;is_osr_method() ? &quot;%&quot; : &quot;&quot;));
 666           st-&gt;print(&quot; %s&quot;, nm-&gt;compiler_name());
 667         }
 668         m-&gt;name_and_sig_as_C_string(buf, buflen);
 669         st-&gt;print(&quot; %s&quot;, buf);
 670         ModuleEntry* module = m-&gt;method_holder()-&gt;module();
 671         if (module-&gt;is_named()) {
 672           module-&gt;name()-&gt;as_C_string(buf, buflen);
 673           st-&gt;print(&quot; %s&quot;, buf);
 674           if (module-&gt;version() != NULL) {
 675             module-&gt;version()-&gt;as_C_string(buf, buflen);
 676             st-&gt;print(&quot;@%s&quot;, buf);
 677           }
 678         }
 679         st-&gt;print(&quot; (%d bytes) @ &quot; PTR_FORMAT &quot; [&quot; PTR_FORMAT &quot;+&quot; INTPTR_FORMAT &quot;]&quot;,
 680                   m-&gt;code_size(), p2i(_pc), p2i(_cb-&gt;code_begin()), _pc - _cb-&gt;code_begin());
 681 #if INCLUDE_JVMCI
 682         if (cm-&gt;is_nmethod()) {
 683           nmethod* nm = cm-&gt;as_nmethod();
<span class="line-modified"> 684           char* jvmciName = nm-&gt;jvmci_installed_code_name(buf, buflen);</span>
 685           if (jvmciName != NULL) {
 686             st-&gt;print(&quot; (%s)&quot;, jvmciName);
 687           }
 688         }
 689 #endif
 690       } else {
 691         st-&gt;print(&quot;J  &quot; PTR_FORMAT, p2i(pc()));
 692       }
 693     } else if (_cb-&gt;is_runtime_stub()) {
 694       st-&gt;print(&quot;v  ~RuntimeStub::%s&quot;, ((RuntimeStub *)_cb)-&gt;name());
 695     } else if (_cb-&gt;is_deoptimization_stub()) {
 696       st-&gt;print(&quot;v  ~DeoptimizationBlob&quot;);
 697     } else if (_cb-&gt;is_exception_stub()) {
 698       st-&gt;print(&quot;v  ~ExceptionBlob&quot;);
 699     } else if (_cb-&gt;is_safepoint_stub()) {
 700       st-&gt;print(&quot;v  ~SafepointBlob&quot;);
 701     } else if (_cb-&gt;is_adapter_blob()) {
 702       st-&gt;print(&quot;v  ~AdapterBlob&quot;);
 703     } else if (_cb-&gt;is_vtable_blob()) {
 704       st-&gt;print(&quot;v  ~VtableBlob&quot;);
</pre>
<hr />
<pre>
 749       addr = (oop*) _fr-&gt;interpreter_frame_expression_stack_at((offset - _max_locals));
 750       // In case of exceptions, the expression stack is invalid and the esp will be reset to express
 751       // this condition. Therefore, we call f only if addr is &#39;inside&#39; the stack (i.e., addr &gt;= esp for Intel).
 752       bool in_stack;
 753       if (frame::interpreter_frame_expression_stack_direction() &gt; 0) {
 754         in_stack = (intptr_t*)addr &lt;= _fr-&gt;interpreter_frame_tos_address();
 755       } else {
 756         in_stack = (intptr_t*)addr &gt;= _fr-&gt;interpreter_frame_tos_address();
 757       }
 758       if (in_stack) {
 759         _f-&gt;do_oop(addr);
 760       }
 761     }
 762   }
 763 
 764   int max_locals()  { return _max_locals; }
 765   frame* fr()       { return _fr; }
 766 };
 767 
 768 
<span class="line-modified"> 769 class InterpretedArgumentOopFinder: public SignatureInfo {</span>
 770  private:
 771   OopClosure* _f;        // Closure to invoke
 772   int    _offset;        // TOS-relative offset, decremented with each argument
 773   bool   _has_receiver;  // true if the callee has a receiver
 774   frame* _fr;
 775 
<span class="line-modified"> 776   void set(int size, BasicType type) {</span>
<span class="line-modified"> 777     _offset -= size;</span>
<span class="line-modified"> 778     if (type == T_OBJECT || type == T_ARRAY) oop_offset_do();</span>
<span class="line-modified"> 779   }</span>

 780 
 781   void oop_offset_do() {
 782     oop* addr;
 783     addr = (oop*)_fr-&gt;interpreter_frame_tos_at(_offset);
 784     _f-&gt;do_oop(addr);
 785   }
 786 
 787  public:
<span class="line-modified"> 788   InterpretedArgumentOopFinder(Symbol* signature, bool has_receiver, frame* fr, OopClosure* f) : SignatureInfo(signature), _has_receiver(has_receiver) {</span>
 789     // compute size of arguments
 790     int args_size = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0);
 791     assert(!fr-&gt;is_interpreted_frame() ||
 792            args_size &lt;= fr-&gt;interpreter_frame_expression_stack_size(),
 793             &quot;args cannot be on stack anymore&quot;);
 794     // initialize InterpretedArgumentOopFinder
 795     _f         = f;
 796     _fr        = fr;
 797     _offset    = args_size;
 798   }
 799 
 800   void oops_do() {
 801     if (_has_receiver) {
 802       --_offset;
 803       oop_offset_do();
 804     }
<span class="line-modified"> 805     iterate_parameters();</span>
 806   }
 807 };
 808 
 809 
 810 // Entry frame has following form (n arguments)
 811 //         +-----------+
 812 //   sp -&gt; |  last arg |
 813 //         +-----------+
 814 //         :    :::    :
 815 //         +-----------+
 816 // (sp+n)-&gt;|  first arg|
 817 //         +-----------+
 818 
 819 
 820 
 821 // visits and GC&#39;s all the arguments in entry frame
<span class="line-modified"> 822 class EntryFrameOopFinder: public SignatureInfo {</span>
 823  private:
 824   bool   _is_static;
 825   int    _offset;
 826   frame* _fr;
 827   OopClosure* _f;
 828 
<span class="line-modified"> 829   void set(int size, BasicType type) {</span>



 830     assert (_offset &gt;= 0, &quot;illegal offset&quot;);
<span class="line-modified"> 831     if (type == T_OBJECT || type == T_ARRAY) oop_at_offset_do(_offset);</span>
<span class="line-modified"> 832     _offset -= size;</span>
<span class="line-removed"> 833   }</span>
 834 
 835   void oop_at_offset_do(int offset) {
 836     assert (offset &gt;= 0, &quot;illegal offset&quot;);
 837     oop* addr = (oop*) _fr-&gt;entry_frame_argument_at(offset);
 838     _f-&gt;do_oop(addr);
 839   }
 840 
 841  public:
<span class="line-modified"> 842    EntryFrameOopFinder(frame* frame, Symbol* signature, bool is_static) : SignatureInfo(signature) {</span>
<span class="line-modified"> 843      _f = NULL; // will be set later</span>
<span class="line-modified"> 844      _fr = frame;</span>
<span class="line-modified"> 845      _is_static = is_static;</span>
<span class="line-modified"> 846      _offset = ArgumentSizeComputer(signature).size() - 1; // last parameter is at index 0</span>
<span class="line-modified"> 847    }</span>
 848 
 849   void arguments_do(OopClosure* f) {
 850     _f = f;
<span class="line-modified"> 851     if (!_is_static) oop_at_offset_do(_offset+1); // do the receiver</span>
<span class="line-modified"> 852     iterate_parameters();</span>
 853   }
 854 
 855 };
 856 
 857 oop* frame::interpreter_callee_receiver_addr(Symbol* signature) {
 858   ArgumentSizeComputer asc(signature);
 859   int size = asc.size();
 860   return (oop *)interpreter_frame_tos_at(size);
 861 }
 862 
 863 
 864 void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) {
 865   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 866   assert(map != NULL, &quot;map must be set&quot;);
 867   Thread *thread = Thread::current();
 868   methodHandle m (thread, interpreter_frame_method());
 869   jint      bci = interpreter_frame_bci();
 870 
 871   assert(!Universe::heap()-&gt;is_in(m()),
 872           &quot;must be valid oop&quot;);
</pre>
<hr />
<pre>
 950 void frame::oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* reg_map) {
 951   assert(_cb != NULL, &quot;sanity check&quot;);
 952   if (_cb-&gt;oop_maps() != NULL) {
 953     OopMapSet::oops_do(this, reg_map, f);
 954 
 955     // Preserve potential arguments for a callee. We handle this by dispatching
 956     // on the codeblob. For c2i, we do
 957     if (reg_map-&gt;include_argument_oops()) {
 958       _cb-&gt;preserve_callee_argument_oops(*this, reg_map, f);
 959     }
 960   }
 961   // In cases where perm gen is collected, GC will want to mark
 962   // oops referenced from nmethods active on thread stacks so as to
 963   // prevent them from being collected. However, this visit should be
 964   // restricted to certain phases of the collection only. The
 965   // closure decides how it wants nmethods to be traced.
 966   if (cf != NULL)
 967     cf-&gt;do_code_blob(_cb);
 968 }
 969 
<span class="line-modified"> 970 class CompiledArgumentOopFinder: public SignatureInfo {</span>
 971  protected:
 972   OopClosure*     _f;
 973   int             _offset;        // the current offset, incremented with each argument
 974   bool            _has_receiver;  // true if the callee has a receiver
 975   bool            _has_appendix;  // true if the call has an appendix
 976   frame           _fr;
 977   RegisterMap*    _reg_map;
 978   int             _arg_size;
 979   VMRegPair*      _regs;        // VMReg list of arguments
 980 
<span class="line-modified"> 981   void set(int size, BasicType type) {</span>
<span class="line-modified"> 982     if (type == T_OBJECT || type == T_ARRAY) handle_oop_offset();</span>
<span class="line-modified"> 983     _offset += size;</span>

 984   }
 985 
 986   virtual void handle_oop_offset() {
 987     // Extract low order register number from register array.
 988     // In LP64-land, the high-order bits are valid but unhelpful.
 989     VMReg reg = _regs[_offset].first();
 990     oop *loc = _fr.oopmapreg_to_location(reg, _reg_map);
 991     _f-&gt;do_oop(loc);
 992   }
 993 
 994  public:
<span class="line-modified"> 995   CompiledArgumentOopFinder(Symbol* signature, bool has_receiver, bool has_appendix, OopClosure* f, frame fr,  const RegisterMap* reg_map)</span>
<span class="line-modified"> 996     : SignatureInfo(signature) {</span>
 997 
 998     // initialize CompiledArgumentOopFinder
 999     _f         = f;
1000     _offset    = 0;
1001     _has_receiver = has_receiver;
1002     _has_appendix = has_appendix;
1003     _fr        = fr;
1004     _reg_map   = (RegisterMap*)reg_map;
1005     _arg_size  = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0) + (has_appendix ? 1 : 0);
1006 
1007     int arg_size;
1008     _regs = SharedRuntime::find_callee_arguments(signature, has_receiver, has_appendix, &amp;arg_size);
1009     assert(arg_size == _arg_size, &quot;wrong arg size&quot;);
1010   }
1011 
1012   void oops_do() {
1013     if (_has_receiver) {
1014       handle_oop_offset();
1015       _offset++;
1016     }
<span class="line-modified">1017     iterate_parameters();</span>
1018     if (_has_appendix) {
1019       handle_oop_offset();
1020       _offset++;
1021     }
1022   }
1023 };
1024 
1025 void frame::oops_compiled_arguments_do(Symbol* signature, bool has_receiver, bool has_appendix,
1026                                        const RegisterMap* reg_map, OopClosure* f) {
1027   ResourceMark rm;
1028   CompiledArgumentOopFinder finder(signature, has_receiver, has_appendix, f, *this, reg_map);
1029   finder.oops_do();
1030 }
1031 
1032 
1033 // Get receiver out of callers frame, i.e. find parameter 0 in callers
1034 // frame.  Consult ADLC for where parameter 0 is to be found.  Then
1035 // check local reg_map for it being a callee-save register or argument
1036 // register, both of which are saved in the local frame.  If not found
1037 // there, it must be an in-stack argument of the caller.
</pre>
<hr />
<pre>
1098   }
1099 #endif
1100   if (is_interpreted_frame()) {
1101     oops_interpreted_do(f, map, use_interpreter_oop_map_cache);
1102   } else if (is_entry_frame()) {
1103     oops_entry_do(f, map);
1104   } else if (CodeCache::contains(pc())) {
1105     oops_code_blob_do(f, cf, map);
1106   } else {
1107     ShouldNotReachHere();
1108   }
1109 }
1110 
1111 void frame::nmethods_do(CodeBlobClosure* cf) {
1112   if (_cb != NULL &amp;&amp; _cb-&gt;is_nmethod()) {
1113     cf-&gt;do_code_blob(_cb);
1114   }
1115 }
1116 
1117 
<span class="line-modified">1118 // call f() on the interpreted Method*s in the stack.</span>
<span class="line-modified">1119 // Have to walk the entire code cache for the compiled frames Yuck.</span>
<span class="line-modified">1120 void frame::metadata_do(void f(Metadata*)) {</span>
1121   if (is_interpreted_frame()) {
1122     Method* m = this-&gt;interpreter_frame_method();
1123     assert(m != NULL, &quot;expecting a method in this frame&quot;);
<span class="line-modified">1124     f(m);</span>
1125   }
1126 }
1127 
1128 void frame::verify(const RegisterMap* map) {
1129   // for now make sure receiver type is correct
1130   if (is_interpreted_frame()) {
1131     Method* method = interpreter_frame_method();
1132     guarantee(method-&gt;is_method(), &quot;method is wrong in frame::verify&quot;);
1133     if (!method-&gt;is_static()) {
1134       // fetch the receiver
1135       oop* p = (oop*) interpreter_frame_local_at(0);
1136       // make sure we have the right receiver type
1137     }
1138   }
1139 #if COMPILER2_OR_JVMCI
1140   assert(DerivedPointerTable::is_empty(), &quot;must be empty before verify&quot;);
1141 #endif
1142   oops_do_internal(&amp;VerifyOopClosure::verify_oop, NULL, (RegisterMap*)map, false);
1143 }
1144 
</pre>
<hr />
<pre>
1199     int bci = interpreter_frame_bci();
1200 
1201     // Label the method and current bci
1202     values.describe(-1, info_address,
1203                     FormatBuffer&lt;1024&gt;(&quot;#%d method %s @ %d&quot;, frame_no, m-&gt;name_and_sig_as_C_string(), bci), 2);
1204     values.describe(-1, info_address,
1205                     err_msg(&quot;- %d locals %d max stack&quot;, m-&gt;max_locals(), m-&gt;max_stack()), 1);
1206     if (m-&gt;max_locals() &gt; 0) {
1207       intptr_t* l0 = interpreter_frame_local_at(0);
1208       intptr_t* ln = interpreter_frame_local_at(m-&gt;max_locals() - 1);
1209       values.describe(-1, MAX2(l0, ln), err_msg(&quot;locals for #%d&quot;, frame_no), 1);
1210       // Report each local and mark as owned by this frame
1211       for (int l = 0; l &lt; m-&gt;max_locals(); l++) {
1212         intptr_t* l0 = interpreter_frame_local_at(l);
1213         values.describe(frame_no, l0, err_msg(&quot;local %d&quot;, l));
1214       }
1215     }
1216 
1217     // Compute the actual expression stack size
1218     InterpreterOopMap mask;
<span class="line-modified">1219     OopMapCache::compute_one_oop_map(m, bci, &amp;mask);</span>
1220     intptr_t* tos = NULL;
1221     // Report each stack element and mark as owned by this frame
1222     for (int e = 0; e &lt; mask.expression_stack_size(); e++) {
1223       tos = MAX2(tos, interpreter_frame_expression_stack_at(e));
1224       values.describe(frame_no, interpreter_frame_expression_stack_at(e),
1225                       err_msg(&quot;stack %d&quot;, e));
1226     }
1227     if (tos != NULL) {
1228       values.describe(-1, tos, err_msg(&quot;expression stack for #%d&quot;, frame_no), 1);
1229     }
1230     if (interpreter_frame_monitor_begin() != interpreter_frame_monitor_end()) {
1231       values.describe(frame_no, (intptr_t*)interpreter_frame_monitor_begin(), &quot;monitors begin&quot;);
1232       values.describe(frame_no, (intptr_t*)interpreter_frame_monitor_end(), &quot;monitors end&quot;);
1233     }
1234   } else if (is_entry_frame()) {
1235     // For now just label the frame
1236     values.describe(-1, info_address, err_msg(&quot;#%d entry frame&quot;, frame_no), 2);
1237   } else if (is_compiled_frame()) {
1238     // For now just label the frame
1239     CompiledMethod* cm = (CompiledMethod*)cb();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
<span class="line-added">  26 #include &quot;classfile/moduleEntry.hpp&quot;</span>
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;code/vmreg.inline.hpp&quot;
  29 #include &quot;compiler/abstractCompiler.hpp&quot;
  30 #include &quot;compiler/disassembler.hpp&quot;
  31 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/oopMapCache.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
<span class="line-modified">  36 #include &quot;oops/markWord.hpp&quot;</span>
  37 #include &quot;oops/method.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;oops/verifyOopClosure.hpp&quot;
  41 #include &quot;prims/methodHandles.hpp&quot;
  42 #include &quot;runtime/frame.inline.hpp&quot;
  43 #include &quot;runtime/handles.inline.hpp&quot;
  44 #include &quot;runtime/javaCalls.hpp&quot;
  45 #include &quot;runtime/monitorChunk.hpp&quot;
  46 #include &quot;runtime/os.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/signature.hpp&quot;
  49 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  50 #include &quot;runtime/stubRoutines.hpp&quot;
  51 #include &quot;runtime/thread.inline.hpp&quot;
  52 #include &quot;utilities/debug.hpp&quot;
  53 #include &quot;utilities/decoder.hpp&quot;
  54 #include &quot;utilities/formatBuffer.hpp&quot;
  55 
  56 RegisterMap::RegisterMap(JavaThread *thread, bool update_map) {
</pre>
<hr />
<pre>
 254 
 255   if( !nm-&gt;is_marked_for_deoptimization() )
 256     return false;
 257 
 258   // If at the return point, then the frame has already been popped, and
 259   // only the return needs to be executed. Don&#39;t deoptimize here.
 260   return !nm-&gt;is_at_poll_return(pc());
 261 }
 262 
 263 bool frame::can_be_deoptimized() const {
 264   if (!is_compiled_frame()) return false;
 265   CompiledMethod* nm = (CompiledMethod*)_cb;
 266 
 267   if( !nm-&gt;can_be_deoptimized() )
 268     return false;
 269 
 270   return !nm-&gt;is_at_poll_return(pc());
 271 }
 272 
 273 void frame::deoptimize(JavaThread* thread) {
<span class="line-added"> 274   assert(thread-&gt;frame_anchor()-&gt;has_last_Java_frame() &amp;&amp;</span>
<span class="line-added"> 275          thread-&gt;frame_anchor()-&gt;walkable(), &quot;must be&quot;);</span>
 276   // Schedule deoptimization of an nmethod activation with this frame.
 277   assert(_cb != NULL &amp;&amp; _cb-&gt;is_compiled(), &quot;must be&quot;);
 278 























































 279   // If the call site is a MethodHandle call site use the MH deopt
 280   // handler.
 281   CompiledMethod* cm = (CompiledMethod*) _cb;
 282   address deopt = cm-&gt;is_method_handle_return(pc()) ?
 283                         cm-&gt;deopt_mh_handler_begin() :
 284                         cm-&gt;deopt_handler_begin();
 285 
 286   // Save the original pc before we patch in the new one
 287   cm-&gt;set_original_pc(this, pc());
 288   patch_pc(thread, deopt);
 289 
 290 #ifdef ASSERT
 291   {
 292     RegisterMap map(thread, false);
 293     frame check = thread-&gt;last_frame();
 294     while (id() != check.id()) {
 295       check = check.sender(&amp;map);
 296     }
 297     assert(check.is_deoptimized_frame(), &quot;missed deopt&quot;);
 298   }
</pre>
<hr />
<pre>
 612           nmethod* nm = cm-&gt;as_nmethod();
 613           st-&gt;print(&quot;J %d%s&quot;, nm-&gt;compile_id(), (nm-&gt;is_osr_method() ? &quot;%&quot; : &quot;&quot;));
 614           st-&gt;print(&quot; %s&quot;, nm-&gt;compiler_name());
 615         }
 616         m-&gt;name_and_sig_as_C_string(buf, buflen);
 617         st-&gt;print(&quot; %s&quot;, buf);
 618         ModuleEntry* module = m-&gt;method_holder()-&gt;module();
 619         if (module-&gt;is_named()) {
 620           module-&gt;name()-&gt;as_C_string(buf, buflen);
 621           st-&gt;print(&quot; %s&quot;, buf);
 622           if (module-&gt;version() != NULL) {
 623             module-&gt;version()-&gt;as_C_string(buf, buflen);
 624             st-&gt;print(&quot;@%s&quot;, buf);
 625           }
 626         }
 627         st-&gt;print(&quot; (%d bytes) @ &quot; PTR_FORMAT &quot; [&quot; PTR_FORMAT &quot;+&quot; INTPTR_FORMAT &quot;]&quot;,
 628                   m-&gt;code_size(), p2i(_pc), p2i(_cb-&gt;code_begin()), _pc - _cb-&gt;code_begin());
 629 #if INCLUDE_JVMCI
 630         if (cm-&gt;is_nmethod()) {
 631           nmethod* nm = cm-&gt;as_nmethod();
<span class="line-modified"> 632           const char* jvmciName = nm-&gt;jvmci_name();</span>
 633           if (jvmciName != NULL) {
 634             st-&gt;print(&quot; (%s)&quot;, jvmciName);
 635           }
 636         }
 637 #endif
 638       } else {
 639         st-&gt;print(&quot;J  &quot; PTR_FORMAT, p2i(pc()));
 640       }
 641     } else if (_cb-&gt;is_runtime_stub()) {
 642       st-&gt;print(&quot;v  ~RuntimeStub::%s&quot;, ((RuntimeStub *)_cb)-&gt;name());
 643     } else if (_cb-&gt;is_deoptimization_stub()) {
 644       st-&gt;print(&quot;v  ~DeoptimizationBlob&quot;);
 645     } else if (_cb-&gt;is_exception_stub()) {
 646       st-&gt;print(&quot;v  ~ExceptionBlob&quot;);
 647     } else if (_cb-&gt;is_safepoint_stub()) {
 648       st-&gt;print(&quot;v  ~SafepointBlob&quot;);
 649     } else if (_cb-&gt;is_adapter_blob()) {
 650       st-&gt;print(&quot;v  ~AdapterBlob&quot;);
 651     } else if (_cb-&gt;is_vtable_blob()) {
 652       st-&gt;print(&quot;v  ~VtableBlob&quot;);
</pre>
<hr />
<pre>
 697       addr = (oop*) _fr-&gt;interpreter_frame_expression_stack_at((offset - _max_locals));
 698       // In case of exceptions, the expression stack is invalid and the esp will be reset to express
 699       // this condition. Therefore, we call f only if addr is &#39;inside&#39; the stack (i.e., addr &gt;= esp for Intel).
 700       bool in_stack;
 701       if (frame::interpreter_frame_expression_stack_direction() &gt; 0) {
 702         in_stack = (intptr_t*)addr &lt;= _fr-&gt;interpreter_frame_tos_address();
 703       } else {
 704         in_stack = (intptr_t*)addr &gt;= _fr-&gt;interpreter_frame_tos_address();
 705       }
 706       if (in_stack) {
 707         _f-&gt;do_oop(addr);
 708       }
 709     }
 710   }
 711 
 712   int max_locals()  { return _max_locals; }
 713   frame* fr()       { return _fr; }
 714 };
 715 
 716 
<span class="line-modified"> 717 class InterpretedArgumentOopFinder: public SignatureIterator {</span>
 718  private:
 719   OopClosure* _f;        // Closure to invoke
 720   int    _offset;        // TOS-relative offset, decremented with each argument
 721   bool   _has_receiver;  // true if the callee has a receiver
 722   frame* _fr;
 723 
<span class="line-modified"> 724   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified"> 725   void do_type(BasicType type) {</span>
<span class="line-modified"> 726     _offset -= parameter_type_word_count(type);</span>
<span class="line-modified"> 727     if (is_reference_type(type)) oop_offset_do();</span>
<span class="line-added"> 728    }</span>
 729 
 730   void oop_offset_do() {
 731     oop* addr;
 732     addr = (oop*)_fr-&gt;interpreter_frame_tos_at(_offset);
 733     _f-&gt;do_oop(addr);
 734   }
 735 
 736  public:
<span class="line-modified"> 737   InterpretedArgumentOopFinder(Symbol* signature, bool has_receiver, frame* fr, OopClosure* f) : SignatureIterator(signature), _has_receiver(has_receiver) {</span>
 738     // compute size of arguments
 739     int args_size = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0);
 740     assert(!fr-&gt;is_interpreted_frame() ||
 741            args_size &lt;= fr-&gt;interpreter_frame_expression_stack_size(),
 742             &quot;args cannot be on stack anymore&quot;);
 743     // initialize InterpretedArgumentOopFinder
 744     _f         = f;
 745     _fr        = fr;
 746     _offset    = args_size;
 747   }
 748 
 749   void oops_do() {
 750     if (_has_receiver) {
 751       --_offset;
 752       oop_offset_do();
 753     }
<span class="line-modified"> 754     do_parameters_on(this);</span>
 755   }
 756 };
 757 
 758 
 759 // Entry frame has following form (n arguments)
 760 //         +-----------+
 761 //   sp -&gt; |  last arg |
 762 //         +-----------+
 763 //         :    :::    :
 764 //         +-----------+
 765 // (sp+n)-&gt;|  first arg|
 766 //         +-----------+
 767 
 768 
 769 
 770 // visits and GC&#39;s all the arguments in entry frame
<span class="line-modified"> 771 class EntryFrameOopFinder: public SignatureIterator {</span>
 772  private:
 773   bool   _is_static;
 774   int    _offset;
 775   frame* _fr;
 776   OopClosure* _f;
 777 
<span class="line-modified"> 778   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added"> 779   void do_type(BasicType type) {</span>
<span class="line-added"> 780     // decrement offset before processing the type</span>
<span class="line-added"> 781     _offset -= parameter_type_word_count(type);</span>
 782     assert (_offset &gt;= 0, &quot;illegal offset&quot;);
<span class="line-modified"> 783     if (is_reference_type(type))  oop_at_offset_do(_offset);</span>
<span class="line-modified"> 784  }</span>

 785 
 786   void oop_at_offset_do(int offset) {
 787     assert (offset &gt;= 0, &quot;illegal offset&quot;);
 788     oop* addr = (oop*) _fr-&gt;entry_frame_argument_at(offset);
 789     _f-&gt;do_oop(addr);
 790   }
 791 
 792  public:
<span class="line-modified"> 793   EntryFrameOopFinder(frame* frame, Symbol* signature, bool is_static) : SignatureIterator(signature) {</span>
<span class="line-modified"> 794     _f = NULL; // will be set later</span>
<span class="line-modified"> 795     _fr = frame;</span>
<span class="line-modified"> 796     _is_static = is_static;</span>
<span class="line-modified"> 797     _offset = ArgumentSizeComputer(signature).size();  // pre-decremented down to zero</span>
<span class="line-modified"> 798   }</span>
 799 
 800   void arguments_do(OopClosure* f) {
 801     _f = f;
<span class="line-modified"> 802     if (!_is_static)  oop_at_offset_do(_offset); // do the receiver</span>
<span class="line-modified"> 803     do_parameters_on(this);</span>
 804   }
 805 
 806 };
 807 
 808 oop* frame::interpreter_callee_receiver_addr(Symbol* signature) {
 809   ArgumentSizeComputer asc(signature);
 810   int size = asc.size();
 811   return (oop *)interpreter_frame_tos_at(size);
 812 }
 813 
 814 
 815 void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) {
 816   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 817   assert(map != NULL, &quot;map must be set&quot;);
 818   Thread *thread = Thread::current();
 819   methodHandle m (thread, interpreter_frame_method());
 820   jint      bci = interpreter_frame_bci();
 821 
 822   assert(!Universe::heap()-&gt;is_in(m()),
 823           &quot;must be valid oop&quot;);
</pre>
<hr />
<pre>
 901 void frame::oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* reg_map) {
 902   assert(_cb != NULL, &quot;sanity check&quot;);
 903   if (_cb-&gt;oop_maps() != NULL) {
 904     OopMapSet::oops_do(this, reg_map, f);
 905 
 906     // Preserve potential arguments for a callee. We handle this by dispatching
 907     // on the codeblob. For c2i, we do
 908     if (reg_map-&gt;include_argument_oops()) {
 909       _cb-&gt;preserve_callee_argument_oops(*this, reg_map, f);
 910     }
 911   }
 912   // In cases where perm gen is collected, GC will want to mark
 913   // oops referenced from nmethods active on thread stacks so as to
 914   // prevent them from being collected. However, this visit should be
 915   // restricted to certain phases of the collection only. The
 916   // closure decides how it wants nmethods to be traced.
 917   if (cf != NULL)
 918     cf-&gt;do_code_blob(_cb);
 919 }
 920 
<span class="line-modified"> 921 class CompiledArgumentOopFinder: public SignatureIterator {</span>
 922  protected:
 923   OopClosure*     _f;
 924   int             _offset;        // the current offset, incremented with each argument
 925   bool            _has_receiver;  // true if the callee has a receiver
 926   bool            _has_appendix;  // true if the call has an appendix
 927   frame           _fr;
 928   RegisterMap*    _reg_map;
 929   int             _arg_size;
 930   VMRegPair*      _regs;        // VMReg list of arguments
 931 
<span class="line-modified"> 932   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified"> 933   void do_type(BasicType type) {</span>
<span class="line-modified"> 934     if (is_reference_type(type))  handle_oop_offset();</span>
<span class="line-added"> 935     _offset += parameter_type_word_count(type);</span>
 936   }
 937 
 938   virtual void handle_oop_offset() {
 939     // Extract low order register number from register array.
 940     // In LP64-land, the high-order bits are valid but unhelpful.
 941     VMReg reg = _regs[_offset].first();
 942     oop *loc = _fr.oopmapreg_to_location(reg, _reg_map);
 943     _f-&gt;do_oop(loc);
 944   }
 945 
 946  public:
<span class="line-modified"> 947   CompiledArgumentOopFinder(Symbol* signature, bool has_receiver, bool has_appendix, OopClosure* f, frame fr, const RegisterMap* reg_map)</span>
<span class="line-modified"> 948     : SignatureIterator(signature) {</span>
 949 
 950     // initialize CompiledArgumentOopFinder
 951     _f         = f;
 952     _offset    = 0;
 953     _has_receiver = has_receiver;
 954     _has_appendix = has_appendix;
 955     _fr        = fr;
 956     _reg_map   = (RegisterMap*)reg_map;
 957     _arg_size  = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0) + (has_appendix ? 1 : 0);
 958 
 959     int arg_size;
 960     _regs = SharedRuntime::find_callee_arguments(signature, has_receiver, has_appendix, &amp;arg_size);
 961     assert(arg_size == _arg_size, &quot;wrong arg size&quot;);
 962   }
 963 
 964   void oops_do() {
 965     if (_has_receiver) {
 966       handle_oop_offset();
 967       _offset++;
 968     }
<span class="line-modified"> 969     do_parameters_on(this);</span>
 970     if (_has_appendix) {
 971       handle_oop_offset();
 972       _offset++;
 973     }
 974   }
 975 };
 976 
 977 void frame::oops_compiled_arguments_do(Symbol* signature, bool has_receiver, bool has_appendix,
 978                                        const RegisterMap* reg_map, OopClosure* f) {
 979   ResourceMark rm;
 980   CompiledArgumentOopFinder finder(signature, has_receiver, has_appendix, f, *this, reg_map);
 981   finder.oops_do();
 982 }
 983 
 984 
 985 // Get receiver out of callers frame, i.e. find parameter 0 in callers
 986 // frame.  Consult ADLC for where parameter 0 is to be found.  Then
 987 // check local reg_map for it being a callee-save register or argument
 988 // register, both of which are saved in the local frame.  If not found
 989 // there, it must be an in-stack argument of the caller.
</pre>
<hr />
<pre>
1050   }
1051 #endif
1052   if (is_interpreted_frame()) {
1053     oops_interpreted_do(f, map, use_interpreter_oop_map_cache);
1054   } else if (is_entry_frame()) {
1055     oops_entry_do(f, map);
1056   } else if (CodeCache::contains(pc())) {
1057     oops_code_blob_do(f, cf, map);
1058   } else {
1059     ShouldNotReachHere();
1060   }
1061 }
1062 
1063 void frame::nmethods_do(CodeBlobClosure* cf) {
1064   if (_cb != NULL &amp;&amp; _cb-&gt;is_nmethod()) {
1065     cf-&gt;do_code_blob(_cb);
1066   }
1067 }
1068 
1069 
<span class="line-modified">1070 // Call f closure on the interpreted Method*s in the stack.</span>
<span class="line-modified">1071 void frame::metadata_do(MetadataClosure* f) {</span>
<span class="line-modified">1072   ResourceMark rm;</span>
1073   if (is_interpreted_frame()) {
1074     Method* m = this-&gt;interpreter_frame_method();
1075     assert(m != NULL, &quot;expecting a method in this frame&quot;);
<span class="line-modified">1076     f-&gt;do_metadata(m);</span>
1077   }
1078 }
1079 
1080 void frame::verify(const RegisterMap* map) {
1081   // for now make sure receiver type is correct
1082   if (is_interpreted_frame()) {
1083     Method* method = interpreter_frame_method();
1084     guarantee(method-&gt;is_method(), &quot;method is wrong in frame::verify&quot;);
1085     if (!method-&gt;is_static()) {
1086       // fetch the receiver
1087       oop* p = (oop*) interpreter_frame_local_at(0);
1088       // make sure we have the right receiver type
1089     }
1090   }
1091 #if COMPILER2_OR_JVMCI
1092   assert(DerivedPointerTable::is_empty(), &quot;must be empty before verify&quot;);
1093 #endif
1094   oops_do_internal(&amp;VerifyOopClosure::verify_oop, NULL, (RegisterMap*)map, false);
1095 }
1096 
</pre>
<hr />
<pre>
1151     int bci = interpreter_frame_bci();
1152 
1153     // Label the method and current bci
1154     values.describe(-1, info_address,
1155                     FormatBuffer&lt;1024&gt;(&quot;#%d method %s @ %d&quot;, frame_no, m-&gt;name_and_sig_as_C_string(), bci), 2);
1156     values.describe(-1, info_address,
1157                     err_msg(&quot;- %d locals %d max stack&quot;, m-&gt;max_locals(), m-&gt;max_stack()), 1);
1158     if (m-&gt;max_locals() &gt; 0) {
1159       intptr_t* l0 = interpreter_frame_local_at(0);
1160       intptr_t* ln = interpreter_frame_local_at(m-&gt;max_locals() - 1);
1161       values.describe(-1, MAX2(l0, ln), err_msg(&quot;locals for #%d&quot;, frame_no), 1);
1162       // Report each local and mark as owned by this frame
1163       for (int l = 0; l &lt; m-&gt;max_locals(); l++) {
1164         intptr_t* l0 = interpreter_frame_local_at(l);
1165         values.describe(frame_no, l0, err_msg(&quot;local %d&quot;, l));
1166       }
1167     }
1168 
1169     // Compute the actual expression stack size
1170     InterpreterOopMap mask;
<span class="line-modified">1171     OopMapCache::compute_one_oop_map(methodHandle(Thread::current(), m), bci, &amp;mask);</span>
1172     intptr_t* tos = NULL;
1173     // Report each stack element and mark as owned by this frame
1174     for (int e = 0; e &lt; mask.expression_stack_size(); e++) {
1175       tos = MAX2(tos, interpreter_frame_expression_stack_at(e));
1176       values.describe(frame_no, interpreter_frame_expression_stack_at(e),
1177                       err_msg(&quot;stack %d&quot;, e));
1178     }
1179     if (tos != NULL) {
1180       values.describe(-1, tos, err_msg(&quot;expression stack for #%d&quot;, frame_no), 1);
1181     }
1182     if (interpreter_frame_monitor_begin() != interpreter_frame_monitor_end()) {
1183       values.describe(frame_no, (intptr_t*)interpreter_frame_monitor_begin(), &quot;monitors begin&quot;);
1184       values.describe(frame_no, (intptr_t*)interpreter_frame_monitor_end(), &quot;monitors end&quot;);
1185     }
1186   } else if (is_entry_frame()) {
1187     // For now just label the frame
1188     values.describe(-1, info_address, err_msg(&quot;#%d entry frame&quot;, frame_no), 2);
1189   } else if (is_compiled_frame()) {
1190     // For now just label the frame
1191     CompiledMethod* cm = (CompiledMethod*)cb();
</pre>
</td>
</tr>
</table>
<center><a href="flags/jvmFlagRangeList.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
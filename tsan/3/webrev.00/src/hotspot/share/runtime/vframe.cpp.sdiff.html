<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/vframe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="unhandledOops.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vframe.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/vframe.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
118          &quot;must be at safepoint or it&#39;s a java frame of the current thread&quot;);
119 
120   GrowableArray&lt;MonitorInfo*&gt;* mons = monitors();
121   GrowableArray&lt;MonitorInfo*&gt;* result = new GrowableArray&lt;MonitorInfo*&gt;(mons-&gt;length());
122   if (mons-&gt;is_empty()) return result;
123 
124   bool found_first_monitor = false;
125   ObjectMonitor *pending_monitor = thread()-&gt;current_pending_monitor();
126   ObjectMonitor *waiting_monitor = thread()-&gt;current_waiting_monitor();
127   oop pending_obj = (pending_monitor != NULL ? (oop) pending_monitor-&gt;object() : (oop) NULL);
128   oop waiting_obj = (waiting_monitor != NULL ? (oop) waiting_monitor-&gt;object() : (oop) NULL);
129 
130   for (int index = (mons-&gt;length()-1); index &gt;= 0; index--) {
131     MonitorInfo* monitor = mons-&gt;at(index);
132     if (monitor-&gt;eliminated() &amp;&amp; is_compiled_frame()) continue; // skip eliminated monitor
133     oop obj = monitor-&gt;owner();
134     if (obj == NULL) continue; // skip unowned monitor
135     //
136     // Skip the monitor that the thread is blocked to enter or waiting on
137     //
<span class="line-modified">138     if (!found_first_monitor &amp;&amp; (oopDesc::equals(obj, pending_obj) || oopDesc::equals(obj, waiting_obj))) {</span>
139       continue;
140     }
141     found_first_monitor = true;
142     result-&gt;append(monitor);
143   }
144   return result;
145 }
146 
147 void javaVFrame::print_locked_object_class_name(outputStream* st, Handle obj, const char* lock_state) {
148   if (obj.not_null()) {
149     st-&gt;print(&quot;\t- %s &lt;&quot; INTPTR_FORMAT &quot;&gt; &quot;, lock_state, p2i(obj()));
150     if (obj-&gt;klass() == SystemDictionary::Class_klass()) {
151       st-&gt;print_cr(&quot;(a java.lang.Class for %s)&quot;, java_lang_Class::as_external_name(obj()));
152     } else {
153       Klass* k = obj-&gt;klass();
154       st-&gt;print_cr(&quot;(a %s)&quot;, k-&gt;external_name());
155     }
156   }
157 }
158 
</pre>
<hr />
<pre>
194     else if (thread()-&gt;osthread()-&gt;get_state() == OBJECT_WAIT) {
195       // We are waiting on an Object monitor but Object.wait() isn&#39;t the
196       // top-frame, so we should be waiting on a Class initialization monitor.
197       InstanceKlass* k = thread()-&gt;class_to_be_initialized();
198       if (k != NULL) {
199         st-&gt;print_cr(&quot;\t- waiting on the Class initialization monitor for %s&quot;, k-&gt;external_name());
200       }
201     }
202   }
203 
204   // Print out all monitors that we have locked, or are trying to lock,
205   // including re-locking after being notified or timing out in a wait().
206   GrowableArray&lt;MonitorInfo*&gt;* mons = monitors();
207   if (!mons-&gt;is_empty()) {
208     bool found_first_monitor = false;
209     for (int index = (mons-&gt;length()-1); index &gt;= 0; index--) {
210       MonitorInfo* monitor = mons-&gt;at(index);
211       if (monitor-&gt;eliminated() &amp;&amp; is_compiled_frame()) { // Eliminated in compiled code
212         if (monitor-&gt;owner_is_scalar_replaced()) {
213           Klass* k = java_lang_Class::as_Klass(monitor-&gt;owner_klass());
<span class="line-removed">214           // format below for lockbits matches this one.</span>
215           st-&gt;print(&quot;\t- eliminated &lt;owner is scalar replaced&gt; (a %s)&quot;, k-&gt;external_name());
216         } else {
217           Handle obj(THREAD, monitor-&gt;owner());
218           if (obj() != NULL) {
219             print_locked_object_class_name(st, obj, &quot;eliminated&quot;);
220           }
221         }
222         continue;
223       }
224       if (monitor-&gt;owner() != NULL) {
225         // the monitor is associated with an object, i.e., it is locked
226 
<span class="line-removed">227         markOop mark = NULL;</span>
228         const char *lock_state = &quot;locked&quot;; // assume we have the monitor locked
229         if (!found_first_monitor &amp;&amp; frame_count == 0) {
230           // If this is the first frame and we haven&#39;t found an owned
231           // monitor before, then we need to see if we have completed
232           // the lock or if we are blocked trying to acquire it. Only
233           // an inflated monitor that is first on the monitor list in
234           // the first frame can block us on a monitor enter.
<span class="line-modified">235           mark = monitor-&gt;owner()-&gt;mark();</span>
<span class="line-modified">236           if (mark-&gt;has_monitor() &amp;&amp;</span>
237               ( // we have marked ourself as pending on this monitor
<span class="line-modified">238                 mark-&gt;monitor() == thread()-&gt;current_pending_monitor() ||</span>
239                 // we are not the owner of this monitor
<span class="line-modified">240                 !mark-&gt;monitor()-&gt;is_entered(thread())</span>
241               )) {
242             lock_state = &quot;waiting to lock&quot;;
<span class="line-removed">243           } else {</span>
<span class="line-removed">244             // We own the monitor which is not as interesting so</span>
<span class="line-removed">245             // disable the extra printing below.</span>
<span class="line-removed">246             mark = NULL;</span>
247           }
248         }
249         print_locked_object_class_name(st, Handle(THREAD, monitor-&gt;owner()), lock_state);
250 
251         found_first_monitor = true;
252       }
253     }
254   }
255 }
256 
257 // ------------- interpretedVFrame --------------
258 
259 u_char* interpretedVFrame::bcp() const {
260   return fr().interpreter_frame_bcp();
261 }
262 
263 void interpretedVFrame::set_bcp(u_char* bcp) {
264   fr().interpreter_frame_set_bcp(bcp);
265 }
266 
</pre>
</td>
<td>
<hr />
<pre>
118          &quot;must be at safepoint or it&#39;s a java frame of the current thread&quot;);
119 
120   GrowableArray&lt;MonitorInfo*&gt;* mons = monitors();
121   GrowableArray&lt;MonitorInfo*&gt;* result = new GrowableArray&lt;MonitorInfo*&gt;(mons-&gt;length());
122   if (mons-&gt;is_empty()) return result;
123 
124   bool found_first_monitor = false;
125   ObjectMonitor *pending_monitor = thread()-&gt;current_pending_monitor();
126   ObjectMonitor *waiting_monitor = thread()-&gt;current_waiting_monitor();
127   oop pending_obj = (pending_monitor != NULL ? (oop) pending_monitor-&gt;object() : (oop) NULL);
128   oop waiting_obj = (waiting_monitor != NULL ? (oop) waiting_monitor-&gt;object() : (oop) NULL);
129 
130   for (int index = (mons-&gt;length()-1); index &gt;= 0; index--) {
131     MonitorInfo* monitor = mons-&gt;at(index);
132     if (monitor-&gt;eliminated() &amp;&amp; is_compiled_frame()) continue; // skip eliminated monitor
133     oop obj = monitor-&gt;owner();
134     if (obj == NULL) continue; // skip unowned monitor
135     //
136     // Skip the monitor that the thread is blocked to enter or waiting on
137     //
<span class="line-modified">138     if (!found_first_monitor &amp;&amp; (obj == pending_obj || obj == waiting_obj)) {</span>
139       continue;
140     }
141     found_first_monitor = true;
142     result-&gt;append(monitor);
143   }
144   return result;
145 }
146 
147 void javaVFrame::print_locked_object_class_name(outputStream* st, Handle obj, const char* lock_state) {
148   if (obj.not_null()) {
149     st-&gt;print(&quot;\t- %s &lt;&quot; INTPTR_FORMAT &quot;&gt; &quot;, lock_state, p2i(obj()));
150     if (obj-&gt;klass() == SystemDictionary::Class_klass()) {
151       st-&gt;print_cr(&quot;(a java.lang.Class for %s)&quot;, java_lang_Class::as_external_name(obj()));
152     } else {
153       Klass* k = obj-&gt;klass();
154       st-&gt;print_cr(&quot;(a %s)&quot;, k-&gt;external_name());
155     }
156   }
157 }
158 
</pre>
<hr />
<pre>
194     else if (thread()-&gt;osthread()-&gt;get_state() == OBJECT_WAIT) {
195       // We are waiting on an Object monitor but Object.wait() isn&#39;t the
196       // top-frame, so we should be waiting on a Class initialization monitor.
197       InstanceKlass* k = thread()-&gt;class_to_be_initialized();
198       if (k != NULL) {
199         st-&gt;print_cr(&quot;\t- waiting on the Class initialization monitor for %s&quot;, k-&gt;external_name());
200       }
201     }
202   }
203 
204   // Print out all monitors that we have locked, or are trying to lock,
205   // including re-locking after being notified or timing out in a wait().
206   GrowableArray&lt;MonitorInfo*&gt;* mons = monitors();
207   if (!mons-&gt;is_empty()) {
208     bool found_first_monitor = false;
209     for (int index = (mons-&gt;length()-1); index &gt;= 0; index--) {
210       MonitorInfo* monitor = mons-&gt;at(index);
211       if (monitor-&gt;eliminated() &amp;&amp; is_compiled_frame()) { // Eliminated in compiled code
212         if (monitor-&gt;owner_is_scalar_replaced()) {
213           Klass* k = java_lang_Class::as_Klass(monitor-&gt;owner_klass());

214           st-&gt;print(&quot;\t- eliminated &lt;owner is scalar replaced&gt; (a %s)&quot;, k-&gt;external_name());
215         } else {
216           Handle obj(THREAD, monitor-&gt;owner());
217           if (obj() != NULL) {
218             print_locked_object_class_name(st, obj, &quot;eliminated&quot;);
219           }
220         }
221         continue;
222       }
223       if (monitor-&gt;owner() != NULL) {
224         // the monitor is associated with an object, i.e., it is locked
225 

226         const char *lock_state = &quot;locked&quot;; // assume we have the monitor locked
227         if (!found_first_monitor &amp;&amp; frame_count == 0) {
228           // If this is the first frame and we haven&#39;t found an owned
229           // monitor before, then we need to see if we have completed
230           // the lock or if we are blocked trying to acquire it. Only
231           // an inflated monitor that is first on the monitor list in
232           // the first frame can block us on a monitor enter.
<span class="line-modified">233           markWord mark = monitor-&gt;owner()-&gt;mark();</span>
<span class="line-modified">234           if (mark.has_monitor() &amp;&amp;</span>
235               ( // we have marked ourself as pending on this monitor
<span class="line-modified">236                 mark.monitor() == thread()-&gt;current_pending_monitor() ||</span>
237                 // we are not the owner of this monitor
<span class="line-modified">238                 !mark.monitor()-&gt;is_entered(thread())</span>
239               )) {
240             lock_state = &quot;waiting to lock&quot;;




241           }
242         }
243         print_locked_object_class_name(st, Handle(THREAD, monitor-&gt;owner()), lock_state);
244 
245         found_first_monitor = true;
246       }
247     }
248   }
249 }
250 
251 // ------------- interpretedVFrame --------------
252 
253 u_char* interpretedVFrame::bcp() const {
254   return fr().interpreter_frame_bcp();
255 }
256 
257 void interpretedVFrame::set_bcp(u_char* bcp) {
258   fr().interpreter_frame_set_bcp(bcp);
259 }
260 
</pre>
</td>
</tr>
</table>
<center><a href="unhandledOops.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vframe.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
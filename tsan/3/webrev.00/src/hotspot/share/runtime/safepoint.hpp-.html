<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/safepoint.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_SAFEPOINT_HPP
 26 #define SHARE_RUNTIME_SAFEPOINT_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/os.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 #include &quot;runtime/vmOperations.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 #include &quot;utilities/waitBarrier.hpp&quot;
 34 
 35 //
 36 // Safepoint synchronization
 37 ////
 38 // The VMThread uses the SafepointSynchronize::begin/end
 39 // methods to enter/exit a safepoint region. The begin method will roll
 40 // all JavaThreads forward to a safepoint.
 41 //
 42 // JavaThreads must use the ThreadSafepointState abstraction (defined in
 43 // thread.hpp) to indicate that that they are at a safepoint.
 44 //
 45 // The Mutex/Condition variable and ObjectLocker classes calls the enter/
 46 // exit safepoint methods, when a thread is blocked/restarted. Hence, all mutex exter/
 47 // exit points *must* be at a safepoint.
 48 
 49 class ThreadSafepointState;
 50 
 51 //
 52 // Implements roll-forward to safepoint (safepoint synchronization)
 53 //
 54 class SafepointSynchronize : AllStatic {
 55  public:
 56   enum SynchronizeState {
 57       _not_synchronized = 0,                   // Threads not synchronized at a safepoint. Keep this value 0.
 58       _synchronizing    = 1,                   // Synchronizing in progress
 59       _synchronized     = 2                    // All Java threads are running in native, blocked in OS or stopped at safepoint.
 60                                                // VM thread and any NonJavaThread may be running.
 61   };
 62 
 63   // The enums are listed in the order of the tasks when done serially.
 64   enum SafepointCleanupTasks {
 65     SAFEPOINT_CLEANUP_DEFLATE_MONITORS,
 66     SAFEPOINT_CLEANUP_UPDATE_INLINE_CACHES,
 67     SAFEPOINT_CLEANUP_COMPILATION_POLICY,
 68     SAFEPOINT_CLEANUP_SYMBOL_TABLE_REHASH,
 69     SAFEPOINT_CLEANUP_STRING_TABLE_REHASH,
 70     SAFEPOINT_CLEANUP_CLD_PURGE,
 71     SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE,
 72     // Leave this one last.
 73     SAFEPOINT_CLEANUP_NUM_TASKS
 74   };
 75 
 76  private:
 77   friend class SafepointMechanism;
 78   friend class ThreadSafepointState;
 79   friend class HandshakeState;
 80 
 81   // Threads might read this flag directly, without acquiring the Threads_lock:
 82   static volatile SynchronizeState _state;
 83   // Number of threads we are waiting for to block:
 84   static int              _waiting_to_block;
 85   // Counts the number of active critical natives during the safepoint:
 86   static int              _current_jni_active_count;
 87 
 88   // This counter is used for fast versions of jni_Get&lt;Primitive&gt;Field.
 89   // An even value means there are no ongoing safepoint operations.
 90   // The counter is incremented ONLY at the beginning and end of each
 91   // safepoint.
 92   static volatile uint64_t _safepoint_counter;
 93 
 94   // JavaThreads that need to block for the safepoint will stop on the
 95   // _wait_barrier, where they can quickly be started again.
 96   static WaitBarrier* _wait_barrier;
 97   static long         _end_of_last_safepoint;     // Time of last safepoint in milliseconds
 98   static julong       _coalesced_vmop_count;     // coalesced vmop count
 99 
100   // Statistics
101   static void begin_statistics(int nof_threads, int nof_running);
102   static void update_statistics_on_spin_end();
103   static void update_statistics_on_sync_end(jlong end_time);
104   static void update_statistics_on_cleanup_end(jlong end_time);
105   static void end_statistics(jlong end_time);
106   static void print_statistics();
107 
108   // For debug long safepoint
109   static void print_safepoint_timeout();
110 
111   // Helper methods for safepoint procedure:
112   static void arm_safepoint();
113   static int synchronize_threads(jlong safepoint_limit_time, int nof_threads, int* initial_running);
114   static void disarm_safepoint();
115   static void increment_jni_active_count();
116   static void decrement_waiting_to_block();
117 
118   // Used in safepoint_safe to do a stable load of the thread state.
119   static bool try_stable_load_state(JavaThreadState *state,
120                                     JavaThread *thread,
121                                     uint64_t safepoint_count);
122 
123   // Called when a thread voluntarily blocks
124   static void block(JavaThread *thread);
125 
126   // Called from VMThread during handshakes.
127   // If true the VMThread may safely process the handshake operation for the JavaThread.
128   static bool handshake_safe(JavaThread *thread);
129 
130 public:
131 
132   static void init(Thread* vmthread);
133 
134   // Roll all threads forward to safepoint. Must be called by the VMThread.
135   static void begin();
136   static void end();                    // Start all suspended threads again...
137 
138   // The value for a not set safepoint id.
139   static const uint64_t InactiveSafepointCounter;
140 
141   // Query
142   static bool is_at_safepoint()                   { return _state == _synchronized; }
143   static bool is_synchronizing()                  { return _state == _synchronizing; }
144   static uint64_t safepoint_counter()             { return _safepoint_counter; }
145   static bool is_same_safepoint(uint64_t counter) { return (SafepointSynchronize::safepoint_counter() - counter) &lt; 2; }
146   // Exception handling for page polling
147   static void handle_polling_page_exception(JavaThread *thread);
148 
149   static bool is_cleanup_needed();
150   static void do_cleanup_tasks();
151 
152   static void set_is_at_safepoint()             { _state = _synchronized; }
153   static void set_is_not_at_safepoint()         { _state = _not_synchronized; }
154 
155   // Assembly support
156   static address address_of_state()             { return (address)&amp;_state; }
157 
158   // Only used for making sure that no safepoint has happened in
159   // JNI_FastGetField. Therefore only the low 32-bits are needed
160   // even if this is a 64-bit counter.
161   static address safepoint_counter_addr() {
162 #ifdef VM_LITTLE_ENDIAN
163     return (address)&amp;_safepoint_counter;
164 #else /* BIG */
165     // Return pointer to the 32 LSB:
166     return (address) (((uint32_t*)(&amp;_safepoint_counter)) + 1);
167 #endif
168   }
169 };
170 
171 // Some helper assert macros for safepoint checks.
172 
173 #define assert_at_safepoint()                                           \
174   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;)
175 
176 #define assert_at_safepoint_msg(...)                                    \
177   assert(SafepointSynchronize::is_at_safepoint(), __VA_ARGS__)
178 
179 #define assert_not_at_safepoint()                                       \
180   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;)
181 
182 #define assert_not_at_safepoint_msg(...)                                \
183   assert(!SafepointSynchronize::is_at_safepoint(), __VA_ARGS__)
184 
185 // State class for a thread suspended at a safepoint
186 class ThreadSafepointState: public CHeapObj&lt;mtThread&gt; {
187  private:
188   // At polling page safepoint (NOT a poll return safepoint):
189   volatile bool                   _at_poll_safepoint;
190   JavaThread*                     _thread;
191   bool                            _safepoint_safe;
192   volatile uint64_t               _safepoint_id;
193   JavaThreadState                 _orig_thread_state;
194 
195   ThreadSafepointState*           _next;
196 
197   void account_safe_thread();
198 
199  public:
200   ThreadSafepointState(JavaThread *thread);
201 
202   // Linked list support:
203   ThreadSafepointState* get_next() const { return _next; }
204   void set_next(ThreadSafepointState* value) { _next = value; }
205   ThreadSafepointState** next_ptr() { return &amp;_next; }
206 
207   // examine/restart
208   void examine_state_of_thread(uint64_t safepoint_count);
209   void restart();
210 
211   // Query
212   JavaThread*  thread() const         { return _thread; }
213   bool         is_running() const     { return !_safepoint_safe; }
214 
215   uint64_t get_safepoint_id() const;
216   void     reset_safepoint_id();
217   void     set_safepoint_id(uint64_t sid);
218 
219   JavaThreadState orig_thread_state() const { return _orig_thread_state; }
220 
221   // Support for safepoint timeout (debugging)
222   bool is_at_poll_safepoint()           { return _at_poll_safepoint; }
223   void set_at_poll_safepoint(bool val)  { _at_poll_safepoint = val; }
224 
225   void handle_polling_page_exception();
226 
227   // debugging
228   void print_on(outputStream* st) const;
229   void print() const                        { print_on(tty); }
230 
231   // Initialize
232   static void create(JavaThread *thread);
233   static void destroy(JavaThread *thread);
234 };
235 
236 class SafepointTracing : public AllStatic {
237 private:
238   // Absolute
239   static jlong _last_safepoint_begin_time_ns;
240   static jlong _last_safepoint_sync_time_ns;
241   static jlong _last_safepoint_cleanup_time_ns;
242   static jlong _last_safepoint_end_time_ns;
243   // amount of ms since epoch
244   static jlong _last_safepoint_end_time_epoch_ms;
245   // Relative
246   static jlong _last_app_time_ns;
247 
248   static int _nof_threads;
249   static int _nof_running;
250   static int _page_trap;
251 
252   static VM_Operation::VMOp_Type _current_type;
253   static jlong     _max_sync_time;
254   static jlong     _max_vmop_time;
255   static uint64_t  _op_count[VM_Operation::VMOp_Terminating];
256 
257   static void statistics_log();
258 
259 public:
260   static void init();
261 
262   static void begin(VM_Operation::VMOp_Type type);
263   static void synchronized(int nof_threads, int nof_running, int traps);
264   static void cleanup();
265   static void end();
266 
267   static void statistics_exit_log();
268 
269   static jlong time_since_last_safepoint_ms() {
270     return (os::javaTimeNanos() - _last_safepoint_end_time_ns) / (NANOUNITS / MILLIUNITS);
271   }
272 
273   static jlong end_of_last_safepoint_epoch_ms() {
274     return _last_safepoint_end_time_epoch_ms;
275   }
276 
277   static jlong start_of_safepoint() {
278     return _last_safepoint_begin_time_ns;
279   }
280 };
281 
282 #endif // SHARE_RUNTIME_SAFEPOINT_HPP
    </pre>
  </body>
</html>
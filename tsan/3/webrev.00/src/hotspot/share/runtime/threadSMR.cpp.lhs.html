<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/threadSMR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;logging/logStream.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
<a name="2" id="anc2"></a>
  28 #include &quot;runtime/jniHandles.inline.hpp&quot;
<a name="3" id="anc3"></a>

  29 #include &quot;runtime/thread.inline.hpp&quot;
  30 #include &quot;runtime/threadSMR.inline.hpp&quot;
  31 #include &quot;runtime/vmOperations.hpp&quot;
<a name="4" id="anc4"></a>
  32 #include &quot;services/threadService.hpp&quot;
  33 #include &quot;utilities/copy.hpp&quot;
  34 #include &quot;utilities/globalDefinitions.hpp&quot;
  35 #include &quot;utilities/ostream.hpp&quot;
<a name="5" id="anc5"></a>
  36 #include &quot;utilities/resourceHash.hpp&quot;
  37 #include &quot;utilities/vmError.hpp&quot;
  38 
  39 // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
  40 // -XX:+EnableThreadSMRStatistics:
  41 
  42 // # of parallel threads in _delete_lock-&gt;wait().
  43 // Impl note: Hard to imagine &gt; 64K waiting threads so this could be 16-bit,
  44 // but there is no nice 16-bit _FORMAT support.
  45 uint                  ThreadsSMRSupport::_delete_lock_wait_cnt = 0;
  46 
  47 // Max # of parallel threads in _delete_lock-&gt;wait().
  48 // Impl note: See _delete_lock_wait_cnt note.
  49 uint                  ThreadsSMRSupport::_delete_lock_wait_max = 0;
  50 
  51 // Flag to indicate when an _delete_lock-&gt;notify() is needed.
  52 // Impl note: See _delete_lock_wait_cnt note.
  53 volatile uint         ThreadsSMRSupport::_delete_notify = 0;
  54 
  55 // # of threads deleted over VM lifetime.
  56 // Impl note: Atomically incremented over VM lifetime so use unsigned for more
  57 // range. Unsigned 64-bit would be more future proof, but 64-bit atomic inc
  58 // isn&#39;t available everywhere (or is it?).
  59 volatile uint         ThreadsSMRSupport::_deleted_thread_cnt = 0;
  60 
  61 // Max time in millis to delete a thread.
  62 // Impl note: 16-bit might be too small on an overloaded machine. Use
  63 // unsigned since this is a time value. Set via Atomic::cmpxchg() in a
  64 // loop for correctness.
  65 volatile uint         ThreadsSMRSupport::_deleted_thread_time_max = 0;
  66 
  67 // Cumulative time in millis to delete threads.
  68 // Impl note: Atomically added to over VM lifetime so use unsigned for more
  69 // range. Unsigned 64-bit would be more future proof, but 64-bit atomic inc
  70 // isn&#39;t available everywhere (or is it?).
  71 volatile uint         ThreadsSMRSupport::_deleted_thread_times = 0;
  72 
  73 // The bootstrap list is empty and cannot be freed.
  74 ThreadsList ThreadsSMRSupport::_bootstrap_list = ThreadsList(0);
  75 
  76 // This is the VM&#39;s current &quot;threads list&quot; and it contains all of
  77 // the JavaThreads the VM considers to be alive at this moment in
  78 // time. The other ThreadsList objects in the VM contain past
  79 // snapshots of the &quot;threads list&quot;. _java_thread_list is initially
  80 // set to _bootstrap_list so that we can detect when we have a very
  81 // early use of a ThreadsListHandle.
  82 ThreadsList* volatile ThreadsSMRSupport::_java_thread_list = &amp;_bootstrap_list;
  83 
  84 // # of ThreadsLists allocated over VM lifetime.
  85 // Impl note: We allocate a new ThreadsList for every thread create and
  86 // every thread delete so we need a bigger type than the
  87 // _deleted_thread_cnt field.
  88 uint64_t              ThreadsSMRSupport::_java_thread_list_alloc_cnt = 1;
  89 
  90 // # of ThreadsLists freed over VM lifetime.
  91 // Impl note: See _java_thread_list_alloc_cnt note.
  92 uint64_t              ThreadsSMRSupport::_java_thread_list_free_cnt = 0;
  93 
  94 // Max size ThreadsList allocated.
  95 // Impl note: Max # of threads alive at one time should fit in unsigned 32-bit.
  96 uint                  ThreadsSMRSupport::_java_thread_list_max = 0;
  97 
  98 // Max # of nested ThreadsLists for a thread.
  99 // Impl note: Hard to imagine &gt; 64K nested ThreadsLists so this could be
 100 // 16-bit, but there is no nice 16-bit _FORMAT support.
 101 uint                  ThreadsSMRSupport::_nested_thread_list_max = 0;
 102 
 103 // # of ThreadsListHandles deleted over VM lifetime.
 104 // Impl note: Atomically incremented over VM lifetime so use unsigned for
 105 // more range. There will be fewer ThreadsListHandles than threads so
 106 // unsigned 32-bit should be fine.
 107 volatile uint         ThreadsSMRSupport::_tlh_cnt = 0;
 108 
 109 // Max time in millis to delete a ThreadsListHandle.
 110 // Impl note: 16-bit might be too small on an overloaded machine. Use
 111 // unsigned since this is a time value. Set via Atomic::cmpxchg() in a
 112 // loop for correctness.
 113 volatile uint         ThreadsSMRSupport::_tlh_time_max = 0;
 114 
 115 // Cumulative time in millis to delete ThreadsListHandles.
 116 // Impl note: Atomically added to over VM lifetime so use unsigned for more
 117 // range. Unsigned 64-bit would be more future proof, but 64-bit atomic inc
 118 // isn&#39;t available everywhere (or is it?).
 119 volatile uint         ThreadsSMRSupport::_tlh_times = 0;
 120 
 121 ThreadsList*          ThreadsSMRSupport::_to_delete_list = NULL;
 122 
 123 // # of parallel ThreadsLists on the to-delete list.
 124 // Impl note: Hard to imagine &gt; 64K ThreadsLists needing to be deleted so
 125 // this could be 16-bit, but there is no nice 16-bit _FORMAT support.
 126 uint                  ThreadsSMRSupport::_to_delete_list_cnt = 0;
 127 
 128 // Max # of parallel ThreadsLists on the to-delete list.
 129 // Impl note: See _to_delete_list_cnt note.
 130 uint                  ThreadsSMRSupport::_to_delete_list_max = 0;
 131 
<a name="6" id="anc6"></a><span class="line-removed"> 132 </span>
 133 // &#39;inline&#39; functions first so the definitions are before first use:
 134 
 135 inline void ThreadsSMRSupport::add_deleted_thread_times(uint add_value) {
<a name="7" id="anc7"></a><span class="line-modified"> 136   Atomic::add(add_value, &amp;_deleted_thread_times);</span>
 137 }
 138 
 139 inline void ThreadsSMRSupport::inc_deleted_thread_cnt() {
 140   Atomic::inc(&amp;_deleted_thread_cnt);
 141 }
 142 
 143 inline void ThreadsSMRSupport::inc_java_thread_list_alloc_cnt() {
 144   _java_thread_list_alloc_cnt++;
 145 }
 146 
 147 inline bool ThreadsSMRSupport::is_bootstrap_list(ThreadsList* list) {
 148   return list == &amp;_bootstrap_list;
 149 }
 150 
 151 inline void ThreadsSMRSupport::update_deleted_thread_time_max(uint new_value) {
 152   while (true) {
 153     uint cur_value = _deleted_thread_time_max;
 154     if (new_value &lt;= cur_value) {
 155       // No need to update max value so we&#39;re done.
 156       break;
 157     }
<a name="8" id="anc8"></a><span class="line-modified"> 158     if (Atomic::cmpxchg(new_value, &amp;_deleted_thread_time_max, cur_value) == cur_value) {</span>
 159       // Updated max value so we&#39;re done. Otherwise try it all again.
 160       break;
 161     }
 162   }
 163 }
 164 
 165 inline void ThreadsSMRSupport::update_java_thread_list_max(uint new_value) {
 166   if (new_value &gt; _java_thread_list_max) {
 167     _java_thread_list_max = new_value;
 168   }
 169 }
 170 
 171 inline ThreadsList* ThreadsSMRSupport::xchg_java_thread_list(ThreadsList* new_list) {
<a name="9" id="anc9"></a><span class="line-modified"> 172   return (ThreadsList*)Atomic::xchg(new_list, &amp;_java_thread_list);</span>
 173 }
 174 
 175 // Hash table of pointers found by a scan. Used for collecting hazard
 176 // pointers (ThreadsList references). Also used for collecting JavaThreads
 177 // that are indirectly referenced by hazard ptrs. An instance of this
 178 // class only contains one type of pointer.
 179 //
 180 class ThreadScanHashtable : public CHeapObj&lt;mtThread&gt; {
 181  private:
 182   static bool ptr_equals(void * const&amp; s1, void * const&amp; s2) {
 183     return s1 == s2;
 184   }
 185 
 186   static unsigned int ptr_hash(void * const&amp; s1) {
 187     // 2654435761 = 2^32 * Phi (golden ratio)
 188     return (unsigned int)(((uint32_t)(uintptr_t)s1) * 2654435761u);
 189   }
 190 
 191   int _table_size;
 192   // ResourceHashtable SIZE is specified at compile time so our
 193   // dynamic _table_size is unused for now; 1031 is the first prime
 194   // after 1024.
 195   typedef ResourceHashtable&lt;void *, int, &amp;ThreadScanHashtable::ptr_hash,
 196                             &amp;ThreadScanHashtable::ptr_equals, 1031,
 197                             ResourceObj::C_HEAP, mtThread&gt; PtrTable;
 198   PtrTable * _ptrs;
 199 
 200  public:
 201   // ResourceHashtable is passed to various functions and populated in
 202   // different places so we allocate it using C_HEAP to make it immune
 203   // from any ResourceMarks that happen to be in the code paths.
 204   ThreadScanHashtable(int table_size) : _table_size(table_size), _ptrs(new (ResourceObj::C_HEAP, mtThread) PtrTable()) {}
 205 
 206   ~ThreadScanHashtable() { delete _ptrs; }
 207 
 208   bool has_entry(void *pointer) {
 209     int *val_ptr = _ptrs-&gt;get(pointer);
 210     return val_ptr != NULL &amp;&amp; *val_ptr == 1;
 211   }
 212 
 213   void add_entry(void *pointer) {
 214     _ptrs-&gt;put(pointer, 1);
 215   }
 216 };
 217 
 218 // Closure to gather JavaThreads indirectly referenced by hazard ptrs
 219 // (ThreadsList references) into a hash table. This closure handles part 2
 220 // of the dance - adding all the JavaThreads referenced by the hazard
 221 // pointer (ThreadsList reference) to the hash table.
 222 //
 223 class AddThreadHazardPointerThreadClosure : public ThreadClosure {
 224  private:
 225   ThreadScanHashtable *_table;
 226 
 227  public:
 228   AddThreadHazardPointerThreadClosure(ThreadScanHashtable *table) : _table(table) {}
 229 
 230   virtual void do_thread(Thread *thread) {
 231     if (!_table-&gt;has_entry((void*)thread)) {
 232       // The same JavaThread might be on more than one ThreadsList or
 233       // more than one thread might be using the same ThreadsList. In
 234       // either case, we only need a single entry for a JavaThread.
 235       _table-&gt;add_entry((void*)thread);
 236     }
 237   }
 238 };
 239 
 240 // Closure to gather JavaThreads indirectly referenced by hazard ptrs
 241 // (ThreadsList references) into a hash table. This closure handles part 1
 242 // of the dance - hazard ptr chain walking and dispatch to another
 243 // closure.
 244 //
 245 class ScanHazardPtrGatherProtectedThreadsClosure : public ThreadClosure {
 246  private:
 247   ThreadScanHashtable *_table;
 248  public:
 249   ScanHazardPtrGatherProtectedThreadsClosure(ThreadScanHashtable *table) : _table(table) {}
 250 
 251   virtual void do_thread(Thread *thread) {
 252     assert_locked_or_safepoint(Threads_lock);
 253 
 254     if (thread == NULL) return;
 255 
 256     // This code races with ThreadsSMRSupport::acquire_stable_list() which
 257     // is lock-free so we have to handle some special situations.
 258     //
 259     ThreadsList *current_list = NULL;
 260     while (true) {
 261       current_list = thread-&gt;get_threads_hazard_ptr();
 262       // No hazard ptr so nothing more to do.
 263       if (current_list == NULL) {
 264         return;
 265       }
 266 
 267       // If the hazard ptr is verified as stable (since it is not tagged),
 268       // then it is safe to use.
 269       if (!Thread::is_hazard_ptr_tagged(current_list)) break;
 270 
 271       // The hazard ptr is tagged as not yet verified as being stable
 272       // so we are racing with acquire_stable_list(). This exchange
 273       // attempts to invalidate the hazard ptr. If we win the race,
 274       // then we can ignore this unstable hazard ptr and the other
 275       // thread will retry the attempt to publish a stable hazard ptr.
 276       // If we lose the race, then we retry our attempt to look at the
 277       // hazard ptr.
 278       if (thread-&gt;cmpxchg_threads_hazard_ptr(NULL, current_list) == current_list) return;
 279     }
 280 
 281     // The current JavaThread has a hazard ptr (ThreadsList reference)
 282     // which might be _java_thread_list or it might be an older
 283     // ThreadsList that has been removed but not freed. In either case,
 284     // the hazard ptr is protecting all the JavaThreads on that
 285     // ThreadsList.
 286     AddThreadHazardPointerThreadClosure add_cl(_table);
 287     current_list-&gt;threads_do(&amp;add_cl);
 288   }
 289 };
 290 
 291 // Closure to gather hazard ptrs (ThreadsList references) into a hash table.
 292 //
 293 class ScanHazardPtrGatherThreadsListClosure : public ThreadClosure {
 294  private:
 295   ThreadScanHashtable *_table;
 296  public:
 297   ScanHazardPtrGatherThreadsListClosure(ThreadScanHashtable *table) : _table(table) {}
 298 
 299   virtual void do_thread(Thread* thread) {
 300     assert_locked_or_safepoint(Threads_lock);
 301 
 302     if (thread == NULL) return;
 303     ThreadsList *threads = thread-&gt;get_threads_hazard_ptr();
 304     if (threads == NULL) {
 305       return;
 306     }
 307     // In this closure we always ignore the tag that might mark this
 308     // hazard ptr as not yet verified. If we happen to catch an
 309     // unverified hazard ptr that is subsequently discarded (not
 310     // published), then the only side effect is that we might keep a
 311     // to-be-deleted ThreadsList alive a little longer.
 312     threads = Thread::untag_hazard_ptr(threads);
 313     if (!_table-&gt;has_entry((void*)threads)) {
 314       _table-&gt;add_entry((void*)threads);
 315     }
 316   }
 317 };
 318 
 319 // Closure to print JavaThreads that have a hazard ptr (ThreadsList
 320 // reference) that contains an indirect reference to a specific JavaThread.
 321 //
 322 class ScanHazardPtrPrintMatchingThreadsClosure : public ThreadClosure {
 323  private:
 324   JavaThread *_thread;
 325  public:
 326   ScanHazardPtrPrintMatchingThreadsClosure(JavaThread *thread) : _thread(thread) {}
 327 
 328   virtual void do_thread(Thread *thread) {
 329     assert_locked_or_safepoint(Threads_lock);
 330 
 331     if (thread == NULL) return;
 332     ThreadsList *current_list = thread-&gt;get_threads_hazard_ptr();
 333     if (current_list == NULL) {
 334       return;
 335     }
 336     // If the hazard ptr is unverified, then ignore it.
 337     if (Thread::is_hazard_ptr_tagged(current_list)) return;
 338 
 339     // The current JavaThread has a hazard ptr (ThreadsList reference)
 340     // which might be _java_thread_list or it might be an older
 341     // ThreadsList that has been removed but not freed. In either case,
 342     // the hazard ptr is protecting all the JavaThreads on that
 343     // ThreadsList, but we only care about matching a specific JavaThread.
 344     JavaThreadIterator jti(current_list);
 345     for (JavaThread *p = jti.first(); p != NULL; p = jti.next()) {
 346       if (p == _thread) {
 347         log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: thread1=&quot; INTPTR_FORMAT &quot; has a hazard pointer for thread2=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(thread), p2i(_thread));
 348         break;
 349       }
 350     }
 351   }
 352 };
 353 
 354 // Closure to determine if the specified JavaThread is found by
 355 // threads_do().
 356 //
 357 class VerifyHazardPtrThreadClosure : public ThreadClosure {
 358  private:
 359   bool _found;
 360   Thread *_self;
 361 
 362  public:
 363   VerifyHazardPtrThreadClosure(Thread *self) : _found(false), _self(self) {}
 364 
 365   bool found() const { return _found; }
 366 
 367   virtual void do_thread(Thread *thread) {
 368     if (thread == _self) {
 369       _found = true;
 370     }
 371   }
 372 };
 373 
 374 
 375 // Acquire a stable ThreadsList.
 376 //
 377 void SafeThreadsListPtr::acquire_stable_list() {
 378   assert(_thread != NULL, &quot;sanity check&quot;);
 379   _needs_release = true;
 380   _previous = _thread-&gt;_threads_list_ptr;
 381   _thread-&gt;_threads_list_ptr = this;
 382 
 383   if (_thread-&gt;get_threads_hazard_ptr() == NULL) {
 384     // The typical case is first.
 385     acquire_stable_list_fast_path();
 386     return;
 387   }
 388 
 389   // The nested case is rare.
 390   acquire_stable_list_nested_path();
 391 }
 392 
 393 // Fast path way to acquire a stable ThreadsList.
 394 //
 395 void SafeThreadsListPtr::acquire_stable_list_fast_path() {
 396   assert(_thread != NULL, &quot;sanity check&quot;);
 397   assert(_thread-&gt;get_threads_hazard_ptr() == NULL, &quot;sanity check&quot;);
 398 
 399   ThreadsList* threads;
 400 
 401   // Stable recording of a hazard ptr for SMR. This code does not use
 402   // locks so its use of the _smr_java_thread_list &amp; _threads_hazard_ptr
 403   // fields is racy relative to code that uses those fields with locks.
 404   // OrderAccess and Atomic functions are used to deal with those races.
 405   //
 406   while (true) {
 407     threads = ThreadsSMRSupport::get_java_thread_list();
 408 
 409     // Publish a tagged hazard ptr to denote that the hazard ptr is not
 410     // yet verified as being stable. Due to the fence after the hazard
 411     // ptr write, it will be sequentially consistent w.r.t. the
 412     // sequentially consistent writes of the ThreadsList, even on
 413     // non-multiple copy atomic machines where stores can be observed
 414     // in different order from different observer threads.
 415     ThreadsList* unverified_threads = Thread::tag_hazard_ptr(threads);
 416     _thread-&gt;set_threads_hazard_ptr(unverified_threads);
 417 
 418     // If _smr_java_thread_list has changed, we have lost a race with
 419     // Threads::add() or Threads::remove() and have to try again.
 420     if (ThreadsSMRSupport::get_java_thread_list() != threads) {
 421       continue;
 422     }
 423 
 424     // We try to remove the tag which will verify the hazard ptr as
 425     // being stable. This exchange can race with a scanning thread
 426     // which might invalidate the tagged hazard ptr to keep it from
 427     // being followed to access JavaThread ptrs. If we lose the race,
 428     // we simply retry. If we win the race, then the stable hazard
 429     // ptr is officially published.
 430     if (_thread-&gt;cmpxchg_threads_hazard_ptr(threads, unverified_threads) == unverified_threads) {
 431       break;
 432     }
 433   }
 434 
 435   // A stable hazard ptr has been published letting other threads know
 436   // that the ThreadsList and the JavaThreads reachable from this list
 437   // are protected and hence they should not be deleted until everyone
 438   // agrees it is safe to do so.
 439 
 440   _list = threads;
 441 
 442   verify_hazard_ptr_scanned();
 443 }
 444 
 445 // Acquire a nested stable ThreadsList; this is rare so it uses
 446 // reference counting.
 447 //
 448 void SafeThreadsListPtr::acquire_stable_list_nested_path() {
 449   assert(_thread != NULL, &quot;sanity check&quot;);
 450   assert(_thread-&gt;get_threads_hazard_ptr() != NULL,
 451          &quot;cannot have a NULL regular hazard ptr when acquiring a nested hazard ptr&quot;);
 452 
 453   // The thread already has a hazard ptr (ThreadsList ref) so we need
 454   // to create a nested ThreadsListHandle with the current ThreadsList
 455   // since it might be different than our current hazard ptr. To remedy
 456   // the situation, the ThreadsList pointed to by the pre-existing
 457   // stable hazard ptr is reference counted before the hazard ptr may
 458   // be released and moved to a new ThreadsList. The old ThreadsList
 459   // is remembered in the ThreadsListHandle.
 460 
 461   ThreadsList* current_list = _previous-&gt;_list;
 462   if (EnableThreadSMRStatistics) {
 463     _thread-&gt;inc_nested_threads_hazard_ptr_cnt();
 464   }
 465   current_list-&gt;inc_nested_handle_cnt();
 466   _previous-&gt;_has_ref_count = true;  // promote SafeThreadsListPtr to be reference counted
 467   _thread-&gt;_threads_hazard_ptr = NULL;  // clear the hazard ptr so we can go through the fast path below
 468 
 469   if (EnableThreadSMRStatistics &amp;&amp; _thread-&gt;nested_threads_hazard_ptr_cnt() &gt; ThreadsSMRSupport::_nested_thread_list_max) {
 470     ThreadsSMRSupport::_nested_thread_list_max = _thread-&gt;nested_threads_hazard_ptr_cnt();
 471   }
 472 
 473   acquire_stable_list_fast_path();
 474 
 475   verify_hazard_ptr_scanned();
 476 
 477   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: SafeThreadsListPtr::acquire_stable_list: add nested list pointer to ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(_list));
 478 }
 479 
 480 // Release a stable ThreadsList.
 481 //
 482 void SafeThreadsListPtr::release_stable_list() {
 483   assert(_thread != NULL, &quot;sanity check&quot;);
 484   assert(_thread-&gt;_threads_list_ptr == this, &quot;sanity check&quot;);
 485   _thread-&gt;_threads_list_ptr = _previous;
 486 
 487   if (_has_ref_count) {
 488     // If a SafeThreadsListPtr has been promoted to use reference counting
 489     // due to nesting of ThreadsListHandles, then the reference count must be
 490     // decremented, at which point it may be freed. The forgotten value of
 491     // the list no longer matters at this point and should already be NULL.
 492     assert(_thread-&gt;get_threads_hazard_ptr() == NULL, &quot;sanity check&quot;);
 493     if (EnableThreadSMRStatistics) {
 494       _thread-&gt;dec_nested_threads_hazard_ptr_cnt();
 495     }
 496     _list-&gt;dec_nested_handle_cnt();
 497 
 498     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: SafeThreadsListPtr::release_stable_list: delete nested list pointer to ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(_list));
 499   } else {
 500     // The normal case: a leaf ThreadsListHandle. This merely requires setting
 501     // the thread hazard ptr back to NULL.
 502     assert(_thread-&gt;get_threads_hazard_ptr() != NULL, &quot;sanity check&quot;);
 503     _thread-&gt;set_threads_hazard_ptr(NULL);
 504   }
 505 
 506   // After releasing the hazard ptr, other threads may go ahead and
 507   // free up some memory temporarily used by a ThreadsList snapshot.
 508 
 509   // We use double-check locking to reduce traffic on the system
 510   // wide Thread-SMR delete_lock.
 511   if (ThreadsSMRSupport::delete_notify()) {
 512     // An exiting thread might be waiting in smr_delete(); we need to
 513     // check with delete_lock to be sure.
 514     ThreadsSMRSupport::release_stable_list_wake_up(_has_ref_count);
 515   }
 516 }
 517 
 518 // Verify that the stable hazard ptr used to safely keep threads
 519 // alive is scanned by threads_do() which is a key piece of honoring
 520 // the Thread-SMR protocol.
 521 void SafeThreadsListPtr::verify_hazard_ptr_scanned() {
 522 #ifdef ASSERT
 523   assert(_list != NULL, &quot;_list must not be NULL&quot;);
 524 
 525   if (ThreadsSMRSupport::is_bootstrap_list(_list)) {
 526     // We are early in VM bootstrapping so nothing to do here.
 527     return;
 528   }
 529 
<a name="10" id="anc10"></a>















 530   // The closure will attempt to verify that the calling thread can
 531   // be found by threads_do() on the specified ThreadsList. If it
 532   // is successful, then the specified ThreadsList was acquired as
 533   // a stable hazard ptr by the calling thread in a way that honored
 534   // the Thread-SMR protocol.
 535   //
 536   // If the calling thread cannot be found by threads_do() and if
 537   // it is not the shutdown thread, then the calling thread is not
 538   // honoring the Thread-SMR ptotocol. This means that the specified
 539   // ThreadsList is not a stable hazard ptr and can be freed by
 540   // another thread from the to-be-deleted list at any time.
 541   //
<a name="11" id="anc11"></a><span class="line-removed"> 542   // Note: The shutdown thread has removed itself from the Threads</span>
<span class="line-removed"> 543   // list and is safe to have a waiver from this check because</span>
<span class="line-removed"> 544   // VM_Exit::_shutdown_thread is not set until after the VMThread</span>
<span class="line-removed"> 545   // has started the final safepoint which holds the Threads_lock</span>
<span class="line-removed"> 546   // for the remainder of the VM&#39;s life.</span>
<span class="line-removed"> 547   //</span>
 548   VerifyHazardPtrThreadClosure cl(_thread);
 549   ThreadsSMRSupport::threads_do(&amp;cl, _list);
 550 
 551   // If the calling thread is not honoring the Thread-SMR protocol,
 552   // then we will either crash in threads_do() above because &#39;threads&#39;
 553   // was freed by another thread or we will fail the assert() below.
 554   // In either case, we won&#39;t get past this point with a badly placed
 555   // ThreadsListHandle.
 556 
<a name="12" id="anc12"></a><span class="line-modified"> 557   assert(cl.found() || _thread == VM_Exit::shutdown_thread(), &quot;Acquired a ThreadsList snapshot from a thread not recognized by the Thread-SMR protocol.&quot;);</span>
 558 #endif
 559 }
 560 
 561 // &#39;entries + 1&#39; so we always have at least one entry.
 562 ThreadsList::ThreadsList(int entries) :
 563   _length(entries),
 564   _next_list(NULL),
 565   _threads(NEW_C_HEAP_ARRAY(JavaThread*, entries + 1, mtThread)),
 566   _nested_handle_cnt(0)
 567 {
 568   *(JavaThread**)(_threads + entries) = NULL;  // Make sure the extra entry is NULL.
 569 }
 570 
 571 ThreadsList::~ThreadsList() {
 572   FREE_C_HEAP_ARRAY(JavaThread*, _threads);
 573 }
 574 
 575 // Add a JavaThread to a ThreadsList. The returned ThreadsList is a
 576 // new copy of the specified ThreadsList with the specified JavaThread
 577 // appended to the end.
 578 ThreadsList *ThreadsList::add_thread(ThreadsList *list, JavaThread *java_thread) {
 579   const uint index = list-&gt;_length;
 580   const uint new_length = index + 1;
 581   const uint head_length = index;
 582   ThreadsList *const new_list = new ThreadsList(new_length);
 583 
 584   if (head_length &gt; 0) {
 585     Copy::disjoint_words((HeapWord*)list-&gt;_threads, (HeapWord*)new_list-&gt;_threads, head_length);
 586   }
 587   *(JavaThread**)(new_list-&gt;_threads + index) = java_thread;
 588 
 589   return new_list;
 590 }
 591 
 592 void ThreadsList::dec_nested_handle_cnt() {
<a name="13" id="anc13"></a><span class="line-modified"> 593   // The decrement needs to be MO_ACQ_REL. At the moment, the Atomic::dec</span>
<span class="line-removed"> 594   // backend on PPC does not yet conform to these requirements. Therefore</span>
<span class="line-removed"> 595   // the decrement is simulated with an Atomic::sub(1, &amp;addr).</span>
<span class="line-removed"> 596   // Without this MO_ACQ_REL Atomic::dec simulation, the nested SMR mechanism</span>
<span class="line-removed"> 597   // is not generally safe to use.</span>
<span class="line-removed"> 598   Atomic::sub(1, &amp;_nested_handle_cnt);</span>
 599 }
 600 
 601 int ThreadsList::find_index_of_JavaThread(JavaThread *target) {
 602   if (target == NULL) {
 603     return -1;
 604   }
 605   for (uint i = 0; i &lt; length(); i++) {
 606     if (target == thread_at(i)) {
 607       return (int)i;
 608     }
 609   }
 610   return -1;
 611 }
 612 
 613 JavaThread* ThreadsList::find_JavaThread_from_java_tid(jlong java_tid) const {
<a name="14" id="anc14"></a><span class="line-modified"> 614   for (uint i = 0; i &lt; length(); i++) {</span>
<span class="line-modified"> 615     JavaThread* thread = thread_at(i);</span>
<span class="line-modified"> 616     oop tobj = thread-&gt;threadObj();</span>
<span class="line-modified"> 617     // Ignore the thread if it hasn&#39;t run yet, has exited</span>
<span class="line-modified"> 618     // or is starting to exit.</span>
<span class="line-modified"> 619     if (tobj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp;</span>
<span class="line-modified"> 620         java_tid == java_lang_Thread::thread_id(tobj)) {</span>
<span class="line-modified"> 621       // found a match</span>
<span class="line-modified"> 622       return thread;</span>










 623     }
<a name="15" id="anc15"></a>

 624   }
 625   return NULL;
 626 }
 627 
 628 void ThreadsList::inc_nested_handle_cnt() {
<a name="16" id="anc16"></a><span class="line-modified"> 629   // The increment needs to be MO_SEQ_CST. At the moment, the Atomic::inc</span>
<span class="line-removed"> 630   // backend on PPC does not yet conform to these requirements. Therefore</span>
<span class="line-removed"> 631   // the increment is simulated with a load phi; cas phi + 1; loop.</span>
<span class="line-removed"> 632   // Without this MO_SEQ_CST Atomic::inc simulation, the nested SMR mechanism</span>
<span class="line-removed"> 633   // is not generally safe to use.</span>
<span class="line-removed"> 634   intx sample = OrderAccess::load_acquire(&amp;_nested_handle_cnt);</span>
<span class="line-removed"> 635   for (;;) {</span>
<span class="line-removed"> 636     if (Atomic::cmpxchg(sample + 1, &amp;_nested_handle_cnt, sample) == sample) {</span>
<span class="line-removed"> 637       return;</span>
<span class="line-removed"> 638     } else {</span>
<span class="line-removed"> 639       sample = OrderAccess::load_acquire(&amp;_nested_handle_cnt);</span>
<span class="line-removed"> 640     }</span>
<span class="line-removed"> 641   }</span>
 642 }
 643 
 644 bool ThreadsList::includes(const JavaThread * const p) const {
 645   if (p == NULL) {
 646     return false;
 647   }
 648   for (uint i = 0; i &lt; length(); i++) {
 649     if (thread_at(i) == p) {
 650       return true;
 651     }
 652   }
 653   return false;
 654 }
 655 
 656 // Remove a JavaThread from a ThreadsList. The returned ThreadsList is a
 657 // new copy of the specified ThreadsList with the specified JavaThread
 658 // removed.
 659 ThreadsList *ThreadsList::remove_thread(ThreadsList* list, JavaThread* java_thread) {
 660   assert(list-&gt;_length &gt; 0, &quot;sanity&quot;);
 661 
 662   uint i = (uint)list-&gt;find_index_of_JavaThread(java_thread);
 663   assert(i &lt; list-&gt;_length, &quot;did not find JavaThread on the list&quot;);
 664   const uint index = i;
 665   const uint new_length = list-&gt;_length - 1;
 666   const uint head_length = index;
 667   const uint tail_length = (new_length &gt;= index) ? (new_length - index) : 0;
 668   ThreadsList *const new_list = new ThreadsList(new_length);
 669 
 670   if (head_length &gt; 0) {
 671     Copy::disjoint_words((HeapWord*)list-&gt;_threads, (HeapWord*)new_list-&gt;_threads, head_length);
 672   }
 673   if (tail_length &gt; 0) {
 674     Copy::disjoint_words((HeapWord*)list-&gt;_threads + index + 1, (HeapWord*)new_list-&gt;_threads + index, tail_length);
 675   }
 676 
 677   return new_list;
 678 }
 679 
 680 ThreadsListHandle::ThreadsListHandle(Thread *self) : _list_ptr(self, /* acquire */ true) {
 681   assert(self == Thread::current(), &quot;sanity check&quot;);
 682   if (EnableThreadSMRStatistics) {
 683     _timer.start();
 684   }
 685 }
 686 
 687 ThreadsListHandle::~ThreadsListHandle() {
 688   if (EnableThreadSMRStatistics) {
 689     _timer.stop();
 690     uint millis = (uint)_timer.milliseconds();
 691     ThreadsSMRSupport::update_tlh_stats(millis);
 692   }
 693 }
 694 
 695 // Convert an internal thread reference to a JavaThread found on the
 696 // associated ThreadsList. This ThreadsListHandle &quot;protects&quot; the
 697 // returned JavaThread *.
 698 //
 699 // If thread_oop_p is not NULL, then the caller wants to use the oop
 700 // after this call so the oop is returned. On success, *jt_pp is set
 701 // to the converted JavaThread * and true is returned. On error,
 702 // returns false.
 703 //
 704 bool ThreadsListHandle::cv_internal_thread_to_JavaThread(jobject jthread,
 705                                                          JavaThread ** jt_pp,
 706                                                          oop * thread_oop_p) {
 707   assert(this-&gt;list() != NULL, &quot;must have a ThreadsList&quot;);
 708   assert(jt_pp != NULL, &quot;must have a return JavaThread pointer&quot;);
 709   // thread_oop_p is optional so no assert()
 710 
 711   // The JVM_* interfaces don&#39;t allow a NULL thread parameter; JVM/TI
 712   // allows a NULL thread parameter to signify &quot;current thread&quot; which
 713   // allows us to avoid calling cv_external_thread_to_JavaThread().
 714   // The JVM_* interfaces have no such leeway.
 715 
 716   oop thread_oop = JNIHandles::resolve_non_null(jthread);
 717   // Looks like an oop at this point.
 718   if (thread_oop_p != NULL) {
 719     // Return the oop to the caller; the caller may still want
 720     // the oop even if this function returns false.
 721     *thread_oop_p = thread_oop;
 722   }
 723 
 724   JavaThread *java_thread = java_lang_Thread::thread(thread_oop);
 725   if (java_thread == NULL) {
 726     // The java.lang.Thread does not contain a JavaThread * so it has
 727     // not yet run or it has died.
 728     return false;
 729   }
 730   // Looks like a live JavaThread at this point.
 731 
 732   if (java_thread != JavaThread::current()) {
 733     // jthread is not for the current JavaThread so have to verify
 734     // the JavaThread * against the ThreadsList.
 735     if (EnableThreadSMRExtraValidityChecks &amp;&amp; !includes(java_thread)) {
 736       // Not on the JavaThreads list so it is not alive.
 737       return false;
 738     }
 739   }
 740 
 741   // Return a live JavaThread that is &quot;protected&quot; by the
 742   // ThreadsListHandle in the caller.
 743   *jt_pp = java_thread;
 744   return true;
 745 }
 746 
 747 void ThreadsSMRSupport::add_thread(JavaThread *thread){
 748   ThreadsList *new_list = ThreadsList::add_thread(get_java_thread_list(), thread);
 749   if (EnableThreadSMRStatistics) {
 750     inc_java_thread_list_alloc_cnt();
 751     update_java_thread_list_max(new_list-&gt;length());
 752   }
 753   // Initial _java_thread_list will not generate a &quot;Threads::add&quot; mesg.
 754   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::add: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
 755 
 756   ThreadsList *old_list = xchg_java_thread_list(new_list);
 757   free_list(old_list);
<a name="17" id="anc17"></a>



 758 }
 759 
 760 // set_delete_notify() and clear_delete_notify() are called
 761 // under the protection of the delete_lock, but we also use an
 762 // Atomic operation to ensure the memory update is seen earlier than
 763 // when the delete_lock is dropped.
 764 //
 765 void ThreadsSMRSupport::clear_delete_notify() {
 766   Atomic::dec(&amp;_delete_notify);
 767 }
 768 
 769 bool ThreadsSMRSupport::delete_notify() {
 770   // Use load_acquire() in order to see any updates to _delete_notify
 771   // earlier than when delete_lock is grabbed.
<a name="18" id="anc18"></a><span class="line-modified"> 772   return (OrderAccess::load_acquire(&amp;_delete_notify) != 0);</span>
 773 }
 774 
 775 // Safely free a ThreadsList after a Threads::add() or Threads::remove().
 776 // The specified ThreadsList may not get deleted during this call if it
 777 // is still in-use (referenced by a hazard ptr). Other ThreadsLists
 778 // in the chain may get deleted by this call if they are no longer in-use.
 779 void ThreadsSMRSupport::free_list(ThreadsList* threads) {
 780   assert_locked_or_safepoint(Threads_lock);
 781 
 782   if (is_bootstrap_list(threads)) {
 783     // The bootstrap list cannot be freed and is empty so
 784     // it does not need to be scanned. Nothing to do here.
 785     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::free_list: bootstrap ThreadsList=&quot; INTPTR_FORMAT &quot; is no longer in use.&quot;, os::current_thread_id(), p2i(threads));
 786     return;
 787   }
 788 
 789   threads-&gt;set_next_list(_to_delete_list);
 790   _to_delete_list = threads;
 791   if (EnableThreadSMRStatistics) {
 792     _to_delete_list_cnt++;
 793     if (_to_delete_list_cnt &gt; _to_delete_list_max) {
 794       _to_delete_list_max = _to_delete_list_cnt;
 795     }
 796   }
 797 
 798   // Hash table size should be first power of two higher than twice the length of the ThreadsList
 799   int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
<a name="19" id="anc19"></a><span class="line-modified"> 800   hash_table_size--;</span>
<span class="line-removed"> 801   hash_table_size |= hash_table_size &gt;&gt; 1;</span>
<span class="line-removed"> 802   hash_table_size |= hash_table_size &gt;&gt; 2;</span>
<span class="line-removed"> 803   hash_table_size |= hash_table_size &gt;&gt; 4;</span>
<span class="line-removed"> 804   hash_table_size |= hash_table_size &gt;&gt; 8;</span>
<span class="line-removed"> 805   hash_table_size |= hash_table_size &gt;&gt; 16;</span>
<span class="line-removed"> 806   hash_table_size++;</span>
 807 
 808   // Gather a hash table of the current hazard ptrs:
 809   ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
 810   ScanHazardPtrGatherThreadsListClosure scan_cl(scan_table);
 811   threads_do(&amp;scan_cl);
 812   OrderAccess::acquire(); // Must order reads of hazard ptr before reads of
 813                           // nested reference counters
 814 
 815   // Walk through the linked list of pending freeable ThreadsLists
 816   // and free the ones that are not referenced from hazard ptrs.
 817   ThreadsList* current = _to_delete_list;
 818   ThreadsList* prev = NULL;
 819   ThreadsList* next = NULL;
 820   bool threads_is_freed = false;
 821   while (current != NULL) {
 822     next = current-&gt;next_list();
 823     if (!scan_table-&gt;has_entry((void*)current) &amp;&amp; current-&gt;_nested_handle_cnt == 0) {
 824       // This ThreadsList is not referenced by a hazard ptr.
 825       if (prev != NULL) {
 826         prev-&gt;set_next_list(next);
 827       }
 828       if (_to_delete_list == current) {
 829         _to_delete_list = next;
 830       }
 831 
 832       log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::free_list: threads=&quot; INTPTR_FORMAT &quot; is freed.&quot;, os::current_thread_id(), p2i(current));
 833       if (current == threads) threads_is_freed = true;
 834       delete current;
 835       if (EnableThreadSMRStatistics) {
 836         _java_thread_list_free_cnt++;
 837         _to_delete_list_cnt--;
 838       }
 839     } else {
 840       prev = current;
 841     }
 842     current = next;
 843   }
 844 
 845   if (!threads_is_freed) {
 846     // Only report &quot;is not freed&quot; on the original call to
 847     // free_list() for this ThreadsList.
 848     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::free_list: threads=&quot; INTPTR_FORMAT &quot; is not freed.&quot;, os::current_thread_id(), p2i(threads));
 849   }
 850 
 851   delete scan_table;
 852 }
 853 
 854 // Return true if the specified JavaThread is protected by a hazard
 855 // pointer (ThreadsList reference). Otherwise, returns false.
 856 //
 857 bool ThreadsSMRSupport::is_a_protected_JavaThread(JavaThread *thread) {
 858   assert_locked_or_safepoint(Threads_lock);
 859 
 860   // Hash table size should be first power of two higher than twice
 861   // the length of the Threads list.
 862   int hash_table_size = MIN2((int)get_java_thread_list()-&gt;length(), 32) &lt;&lt; 1;
<a name="20" id="anc20"></a><span class="line-modified"> 863   hash_table_size--;</span>
<span class="line-removed"> 864   hash_table_size |= hash_table_size &gt;&gt; 1;</span>
<span class="line-removed"> 865   hash_table_size |= hash_table_size &gt;&gt; 2;</span>
<span class="line-removed"> 866   hash_table_size |= hash_table_size &gt;&gt; 4;</span>
<span class="line-removed"> 867   hash_table_size |= hash_table_size &gt;&gt; 8;</span>
<span class="line-removed"> 868   hash_table_size |= hash_table_size &gt;&gt; 16;</span>
<span class="line-removed"> 869   hash_table_size++;</span>
 870 
 871   // Gather a hash table of the JavaThreads indirectly referenced by
 872   // hazard ptrs.
 873   ThreadScanHashtable *scan_table = new ThreadScanHashtable(hash_table_size);
 874   ScanHazardPtrGatherProtectedThreadsClosure scan_cl(scan_table);
 875   threads_do(&amp;scan_cl);
 876   OrderAccess::acquire(); // Must order reads of hazard ptr before reads of
 877                           // nested reference counters
 878 
 879   // Walk through the linked list of pending freeable ThreadsLists
 880   // and include the ones that are currently in use by a nested
 881   // ThreadsListHandle in the search set.
 882   ThreadsList* current = _to_delete_list;
 883   while (current != NULL) {
 884     if (current-&gt;_nested_handle_cnt != 0) {
 885       // &#39;current&#39; is in use by a nested ThreadsListHandle so the hazard
 886       // ptr is protecting all the JavaThreads on that ThreadsList.
 887       AddThreadHazardPointerThreadClosure add_cl(scan_table);
 888       current-&gt;threads_do(&amp;add_cl);
 889     }
 890     current = current-&gt;next_list();
 891   }
 892 
 893   bool thread_is_protected = false;
 894   if (scan_table-&gt;has_entry((void*)thread)) {
 895     thread_is_protected = true;
 896   }
 897   delete scan_table;
 898   return thread_is_protected;
 899 }
 900 
 901 // Wake up portion of the release stable ThreadsList protocol;
 902 // uses the delete_lock().
 903 //
 904 void ThreadsSMRSupport::release_stable_list_wake_up(bool is_nested) {
 905   const char* log_str = is_nested ? &quot;nested hazard ptr&quot; : &quot;regular hazard ptr&quot;;
 906 
 907   // Note: delete_lock is held in smr_delete() for the entire
 908   // hazard ptr search so that we do not lose this notify() if
 909   // the exiting thread has to wait. That code path also holds
 910   // Threads_lock (which was grabbed before delete_lock) so that
 911   // threads_do() can be called. This means the system can&#39;t start a
 912   // safepoint which means this thread can&#39;t take too long to get to
 913   // a safepoint because of being blocked on delete_lock.
 914   //
<a name="21" id="anc21"></a><span class="line-modified"> 915   MonitorLockerEx ml(ThreadsSMRSupport::delete_lock(), Monitor::_no_safepoint_check_flag);</span>
 916   if (ThreadsSMRSupport::delete_notify()) {
 917     // Notify any exiting JavaThreads that are waiting in smr_delete()
 918     // that we&#39;ve released a ThreadsList.
 919     ml.notify_all();
 920     log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::release_stable_list notified %s&quot;, os::current_thread_id(), log_str);
 921   }
 922 }
 923 
 924 void ThreadsSMRSupport::remove_thread(JavaThread *thread) {
<a name="22" id="anc22"></a>



 925   ThreadsList *new_list = ThreadsList::remove_thread(ThreadsSMRSupport::get_java_thread_list(), thread);
 926   if (EnableThreadSMRStatistics) {
 927     ThreadsSMRSupport::inc_java_thread_list_alloc_cnt();
 928     // This list is smaller so no need to check for a &quot;longest&quot; update.
 929   }
 930 
 931   // Final _java_thread_list will not generate a &quot;Threads::remove&quot; mesg.
 932   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: Threads::remove: new ThreadsList=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(new_list));
 933 
 934   ThreadsList *old_list = ThreadsSMRSupport::xchg_java_thread_list(new_list);
 935   ThreadsSMRSupport::free_list(old_list);
 936 }
 937 
 938 // See note for clear_delete_notify().
 939 //
 940 void ThreadsSMRSupport::set_delete_notify() {
 941   Atomic::inc(&amp;_delete_notify);
 942 }
 943 
 944 // Safely delete a JavaThread when it is no longer in use by a
 945 // ThreadsListHandle.
 946 //
 947 void ThreadsSMRSupport::smr_delete(JavaThread *thread) {
 948   assert(!Threads_lock-&gt;owned_by_self(), &quot;sanity&quot;);
 949 
 950   bool has_logged_once = false;
 951   elapsedTimer timer;
 952   if (EnableThreadSMRStatistics) {
 953     timer.start();
 954   }
 955 
 956   while (true) {
 957     {
<a name="23" id="anc23"></a><span class="line-modified"> 958       // No safepoint check because this JavaThread is not on the</span>
<span class="line-modified"> 959       // Threads list.</span>
<span class="line-modified"> 960       MutexLockerEx ml(Threads_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified"> 961       // Cannot use a MonitorLockerEx helper here because we have</span>
 962       // to drop the Threads_lock first if we wait.
 963       ThreadsSMRSupport::delete_lock()-&gt;lock_without_safepoint_check();
 964       // Set the delete_notify flag after we grab delete_lock
 965       // and before we scan hazard ptrs because we&#39;re doing
 966       // double-check locking in release_stable_list().
 967       ThreadsSMRSupport::set_delete_notify();
 968 
 969       if (!is_a_protected_JavaThread(thread)) {
 970         // This is the common case.
 971         ThreadsSMRSupport::clear_delete_notify();
 972         ThreadsSMRSupport::delete_lock()-&gt;unlock();
 973         break;
 974       }
 975       if (!has_logged_once) {
 976         has_logged_once = true;
 977         log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: thread=&quot; INTPTR_FORMAT &quot; is not deleted.&quot;, os::current_thread_id(), p2i(thread));
 978         if (log_is_enabled(Debug, os, thread)) {
 979           ScanHazardPtrPrintMatchingThreadsClosure scan_cl(thread);
 980           threads_do(&amp;scan_cl);
 981           ThreadsList* current = _to_delete_list;
 982           while (current != NULL) {
 983             if (current-&gt;_nested_handle_cnt != 0 &amp;&amp; current-&gt;includes(thread)) {
 984               log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: found nested hazard pointer to thread=&quot; INTPTR_FORMAT, os::current_thread_id(), p2i(thread));
 985             }
 986             current = current-&gt;next_list();
 987           }
 988         }
 989       }
 990     } // We have to drop the Threads_lock to wait or delete the thread
 991 
 992     if (EnableThreadSMRStatistics) {
 993       _delete_lock_wait_cnt++;
 994       if (_delete_lock_wait_cnt &gt; _delete_lock_wait_max) {
 995         _delete_lock_wait_max = _delete_lock_wait_cnt;
 996       }
 997     }
 998     // Wait for a release_stable_list() call before we check again. No
 999     // safepoint check, no timeout, and not as suspend equivalent flag
1000     // because this JavaThread is not on the Threads list.
<a name="24" id="anc24"></a><span class="line-modified">1001     ThreadsSMRSupport::delete_lock()-&gt;wait(Mutex::_no_safepoint_check_flag, 0,</span>
<span class="line-removed">1002                                      !Mutex::_as_suspend_equivalent_flag);</span>
1003     if (EnableThreadSMRStatistics) {
1004       _delete_lock_wait_cnt--;
1005     }
1006 
1007     ThreadsSMRSupport::clear_delete_notify();
1008     ThreadsSMRSupport::delete_lock()-&gt;unlock();
1009     // Retry the whole scenario.
1010   }
1011 
1012   delete thread;
1013   if (EnableThreadSMRStatistics) {
1014     timer.stop();
1015     uint millis = (uint)timer.milliseconds();
1016     ThreadsSMRSupport::inc_deleted_thread_cnt();
1017     ThreadsSMRSupport::add_deleted_thread_times(millis);
1018     ThreadsSMRSupport::update_deleted_thread_time_max(millis);
1019   }
1020 
1021   log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::smr_delete: thread=&quot; INTPTR_FORMAT &quot; is deleted.&quot;, os::current_thread_id(), p2i(thread));
1022 }
1023 
1024 // Apply the closure to all threads in the system, with a snapshot of
1025 // all JavaThreads provided by the list parameter.
1026 void ThreadsSMRSupport::threads_do(ThreadClosure *tc, ThreadsList *list) {
1027   list-&gt;threads_do(tc);
1028   Threads::non_java_threads_do(tc);
1029 }
1030 
1031 // Apply the closure to all threads in the system.
1032 void ThreadsSMRSupport::threads_do(ThreadClosure *tc) {
1033   threads_do(tc, _java_thread_list);
1034 }
1035 
1036 
1037 // Debug, logging, and printing stuff at the end:
1038 
1039 // Print SMR info for a SafeThreadsListPtr to a given output stream.
1040 void SafeThreadsListPtr::print_on(outputStream* st) {
1041   if (this == _thread-&gt;_threads_list_ptr) {
1042     // The top level hazard ptr.
1043     st-&gt;print(&quot; _threads_hazard_ptr=&quot; INTPTR_FORMAT, p2i(_list));
1044   } else {
1045     // Nested hazard ptrs.
1046     st-&gt;print(&quot;, _nested_threads_hazard_ptr=&quot; INTPTR_FORMAT, p2i(_list));
1047   }
1048 }
1049 
1050 // Log Threads class SMR info.
1051 void ThreadsSMRSupport::log_statistics() {
1052   LogTarget(Info, thread, smr) log;
1053   if (log.is_enabled()) {
1054     LogStream out(log);
1055     print_info_on(&amp;out);
1056   }
1057 }
1058 
1059 // Print SMR info for a thread to a given output stream.
1060 void ThreadsSMRSupport::print_info_on(const Thread* thread, outputStream* st) {
1061   if (thread-&gt;_threads_hazard_ptr != NULL) {
1062     st-&gt;print(&quot; _threads_hazard_ptr=&quot; INTPTR_FORMAT, p2i(thread-&gt;_threads_hazard_ptr));
1063   }
1064   if (EnableThreadSMRStatistics &amp;&amp; thread-&gt;_threads_list_ptr != NULL) {
1065     // The count is only interesting if we have a _threads_list_ptr.
1066     st-&gt;print(&quot;, _nested_threads_hazard_ptr_cnt=%u&quot;, thread-&gt;_nested_threads_hazard_ptr_cnt);
1067   }
1068   if (SafepointSynchronize::is_at_safepoint() || Thread::current() == thread) {
1069     // It is only safe to walk the list if we&#39;re at a safepoint or the
1070     // calling thread is walking its own list.
1071     SafeThreadsListPtr* current = thread-&gt;_threads_list_ptr;
1072     if (current != NULL) {
1073       // Skip the top nesting level as it is always printed above.
1074       current = current-&gt;previous();
1075     }
1076     while (current != NULL) {
1077       current-&gt;print_on(st);
1078       current = current-&gt;previous();
1079     }
1080   }
1081 }
1082 
1083 // Print Threads class SMR info.
1084 void ThreadsSMRSupport::print_info_on(outputStream* st) {
1085   // Only grab the Threads_lock if we don&#39;t already own it and if we
1086   // are not reporting an error.
1087   // Note: Not grabbing the Threads_lock during error reporting is
1088   // dangerous because the data structures we want to print can be
1089   // freed concurrently. However, grabbing the Threads_lock during
1090   // error reporting can be equally dangerous since this thread might
1091   // block during error reporting or a nested error could leave the
1092   // Threads_lock held. The classic no win scenario.
1093   //
<a name="25" id="anc25"></a><span class="line-modified">1094   MutexLockerEx ml((Threads_lock-&gt;owned_by_self() || VMError::is_error_reported()) ? NULL : Threads_lock);</span>
1095 
1096   st-&gt;print_cr(&quot;Threads class SMR info:&quot;);
1097   st-&gt;print_cr(&quot;_java_thread_list=&quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1098                &quot;elements={&quot;, p2i(_java_thread_list),
1099                _java_thread_list-&gt;length());
1100   print_info_elements_on(st, _java_thread_list);
1101   st-&gt;print_cr(&quot;}&quot;);
1102   if (_to_delete_list != NULL) {
1103     st-&gt;print_cr(&quot;_to_delete_list=&quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1104                  &quot;elements={&quot;, p2i(_to_delete_list),
1105                  _to_delete_list-&gt;length());
1106     print_info_elements_on(st, _to_delete_list);
1107     st-&gt;print_cr(&quot;}&quot;);
1108     for (ThreadsList *t_list = _to_delete_list-&gt;next_list();
1109          t_list != NULL; t_list = t_list-&gt;next_list()) {
1110       st-&gt;print(&quot;next-&gt; &quot; INTPTR_FORMAT &quot;, length=%u, &quot;
1111                 &quot;elements={&quot;, p2i(t_list), t_list-&gt;length());
1112       print_info_elements_on(st, t_list);
1113       st-&gt;print_cr(&quot;}&quot;);
1114     }
1115   }
1116   if (!EnableThreadSMRStatistics) {
1117     return;
1118   }
1119   st-&gt;print_cr(&quot;_java_thread_list_alloc_cnt=&quot; UINT64_FORMAT &quot;, &quot;
1120                &quot;_java_thread_list_free_cnt=&quot; UINT64_FORMAT &quot;, &quot;
1121                &quot;_java_thread_list_max=%u, &quot;
1122                &quot;_nested_thread_list_max=%u&quot;,
1123                _java_thread_list_alloc_cnt,
1124                _java_thread_list_free_cnt,
1125                _java_thread_list_max,
1126                _nested_thread_list_max);
1127   if (_tlh_cnt &gt; 0) {
1128     st-&gt;print_cr(&quot;_tlh_cnt=%u&quot;
1129                  &quot;, _tlh_times=%u&quot;
1130                  &quot;, avg_tlh_time=%0.2f&quot;
1131                  &quot;, _tlh_time_max=%u&quot;,
1132                  _tlh_cnt, _tlh_times,
1133                  ((double) _tlh_times / _tlh_cnt),
1134                  _tlh_time_max);
1135   }
1136   if (_deleted_thread_cnt &gt; 0) {
1137     st-&gt;print_cr(&quot;_deleted_thread_cnt=%u&quot;
1138                  &quot;, _deleted_thread_times=%u&quot;
1139                  &quot;, avg_deleted_thread_time=%0.2f&quot;
1140                  &quot;, _deleted_thread_time_max=%u&quot;,
1141                  _deleted_thread_cnt, _deleted_thread_times,
1142                  ((double) _deleted_thread_times / _deleted_thread_cnt),
1143                  _deleted_thread_time_max);
1144   }
1145   st-&gt;print_cr(&quot;_delete_lock_wait_cnt=%u, _delete_lock_wait_max=%u&quot;,
1146                _delete_lock_wait_cnt, _delete_lock_wait_max);
1147   st-&gt;print_cr(&quot;_to_delete_list_cnt=%u, _to_delete_list_max=%u&quot;,
1148                _to_delete_list_cnt, _to_delete_list_max);
1149 }
1150 
1151 // Print ThreadsList elements (4 per line).
1152 void ThreadsSMRSupport::print_info_elements_on(outputStream* st, ThreadsList* t_list) {
1153   uint cnt = 0;
1154   JavaThreadIterator jti(t_list);
1155   for (JavaThread *jt = jti.first(); jt != NULL; jt = jti.next()) {
1156     st-&gt;print(INTPTR_FORMAT, p2i(jt));
1157     if (cnt &lt; t_list-&gt;length() - 1) {
1158       // Separate with comma or comma-space except for the last one.
1159       if (((cnt + 1) % 4) == 0) {
1160         // Four INTPTR_FORMAT fit on an 80 column line so end the
1161         // current line with just a comma.
1162         st-&gt;print_cr(&quot;,&quot;);
1163       } else {
1164         // Not the last one on the current line so use comma-space:
1165         st-&gt;print(&quot;, &quot;);
1166       }
1167     } else {
1168       // Last one so just end the current line.
1169       st-&gt;cr();
1170     }
1171     cnt++;
1172   }
1173 }
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
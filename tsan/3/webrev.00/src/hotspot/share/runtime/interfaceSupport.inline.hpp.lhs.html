<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/interfaceSupport.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
 26 #define SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
 27 
 28 #include &quot;runtime/handles.inline.hpp&quot;
 29 #include &quot;runtime/mutexLocker.hpp&quot;
 30 #include &quot;runtime/orderAccess.hpp&quot;
 31 #include &quot;runtime/os.hpp&quot;
 32 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
 33 #include &quot;runtime/safepointVerifiers.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #include &quot;runtime/vmOperations.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
<a name="1" id="anc1"></a>
 37 #include &quot;utilities/macros.hpp&quot;
 38 #include &quot;utilities/preserveException.hpp&quot;
 39 
 40 // Wrapper for all entry points to the virtual machine.
 41 
 42 // InterfaceSupport provides functionality used by the VM_LEAF_BASE and
 43 // VM_ENTRY_BASE macros. These macros are used to guard entry points into
 44 // the VM and perform checks upon leave of the VM.
 45 
 46 
 47 class InterfaceSupport: AllStatic {
 48 # ifdef ASSERT
 49  public:
 50   static long _scavenge_alot_counter;
 51   static long _fullgc_alot_counter;
 52   static long _number_of_calls;
 53   static long _fullgc_alot_invocation;
 54 
 55   // Helper methods used to implement +ScavengeALot and +FullGCALot
 56   static void check_gc_alot() { if (ScavengeALot || FullGCALot) gc_alot(); }
 57   static void gc_alot();
 58 
 59   static void walk_stack_from(vframe* start_vf);
 60   static void walk_stack();
 61 
 62   static void zombieAll();
 63   static void deoptimizeAll();
<a name="2" id="anc2"></a><span class="line-removed"> 64   static void stress_derived_pointers();</span>
 65   static void verify_stack();
 66   static void verify_last_frame();
 67 # endif
<a name="3" id="anc3"></a><span class="line-removed"> 68 </span>
<span class="line-removed"> 69  public:</span>
<span class="line-removed"> 70   static void serialize_thread_state_with_handler(JavaThread* thread) {</span>
<span class="line-removed"> 71     serialize_thread_state_internal(thread, true);</span>
<span class="line-removed"> 72   }</span>
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74   // Should only call this if we know that we have a proper SEH set up.</span>
<span class="line-removed"> 75   static void serialize_thread_state(JavaThread* thread) {</span>
<span class="line-removed"> 76     serialize_thread_state_internal(thread, false);</span>
<span class="line-removed"> 77   }</span>
<span class="line-removed"> 78 </span>
<span class="line-removed"> 79  private:</span>
<span class="line-removed"> 80   static void serialize_thread_state_internal(JavaThread* thread, bool needs_exception_handler) {</span>
<span class="line-removed"> 81     // Make sure new state is seen by VM thread</span>
<span class="line-removed"> 82     OrderAccess::fence();</span>
<span class="line-removed"> 83   }</span>
 84 };
 85 
 86 
 87 // Basic class for all thread transition classes.
 88 
 89 class ThreadStateTransition : public StackObj {
 90  protected:
 91   JavaThread* _thread;
 92  public:
 93   ThreadStateTransition(JavaThread *thread) {
 94     _thread = thread;
 95     assert(thread != NULL &amp;&amp; thread-&gt;is_Java_thread(), &quot;must be Java thread&quot;);
 96   }
 97 
 98   // Change threadstate in a manner, so safepoint can detect changes.
 99   // Time-critical: called on exit from every runtime routine
100   static inline void transition(JavaThread *thread, JavaThreadState from, JavaThreadState to) {
101     assert(from != _thread_in_Java, &quot;use transition_from_java&quot;);
102     assert(from != _thread_in_native, &quot;use transition_from_native&quot;);
103     assert((from &amp; 1) == 0 &amp;&amp; (to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
104     assert(thread-&gt;thread_state() == from, &quot;coming from wrong thread state&quot;);
<a name="4" id="anc4"></a><span class="line-removed">105     // Change to transition state</span>
<span class="line-removed">106     thread-&gt;set_thread_state((JavaThreadState)(from + 1));</span>
107 
<a name="5" id="anc5"></a><span class="line-modified">108     InterfaceSupport::serialize_thread_state(thread);</span>


109 
<a name="6" id="anc6"></a><span class="line-modified">110     SafepointMechanism::block_if_requested(thread);</span>
<span class="line-modified">111     thread-&gt;set_thread_state(to);</span>
<span class="line-removed">112 </span>
<span class="line-removed">113     CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
<span class="line-removed">114   }</span>
<span class="line-removed">115 </span>
<span class="line-removed">116   // transition_and_fence must be used on any thread state transition</span>
<span class="line-removed">117   // where there might not be a Java call stub on the stack, in</span>
<span class="line-removed">118   // particular on Windows where the Structured Exception Handler is</span>
<span class="line-removed">119   // set up in the call stub.</span>
<span class="line-removed">120   static inline void transition_and_fence(JavaThread *thread, JavaThreadState from, JavaThreadState to) {</span>
<span class="line-removed">121     assert(thread-&gt;thread_state() == from, &quot;coming from wrong thread state&quot;);</span>
<span class="line-removed">122     assert((from &amp; 1) == 0 &amp;&amp; (to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);</span>
<span class="line-removed">123     // Change to transition state</span>
<span class="line-removed">124     thread-&gt;set_thread_state((JavaThreadState)(from + 1));</span>
<span class="line-removed">125 </span>
<span class="line-removed">126     InterfaceSupport::serialize_thread_state_with_handler(thread);</span>
127 
128     SafepointMechanism::block_if_requested(thread);
129     thread-&gt;set_thread_state(to);
<a name="7" id="anc7"></a><span class="line-removed">130 </span>
<span class="line-removed">131     CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
132   }
133 
134   // Same as above, but assumes from = _thread_in_Java. This is simpler, since we
135   // never block on entry to the VM. This will break the code, since e.g. preserve arguments
136   // have not been setup.
137   static inline void transition_from_java(JavaThread *thread, JavaThreadState to) {
138     assert(thread-&gt;thread_state() == _thread_in_Java, &quot;coming from wrong thread state&quot;);
139     thread-&gt;set_thread_state(to);
140   }
141 
142   static inline void transition_from_native(JavaThread *thread, JavaThreadState to) {
143     assert((to &amp; 1) == 0, &quot;odd numbers are transitions states&quot;);
144     assert(thread-&gt;thread_state() == _thread_in_native, &quot;coming from wrong thread state&quot;);
<a name="8" id="anc8"></a><span class="line-modified">145     // Change to transition state</span>
<span class="line-modified">146     thread-&gt;set_thread_state(_thread_in_native_trans);</span>
<span class="line-removed">147 </span>
<span class="line-removed">148     InterfaceSupport::serialize_thread_state_with_handler(thread);</span>
149 
150     // We never install asynchronous exceptions when coming (back) in
151     // to the runtime from native code because the runtime is not set
152     // up to handle exceptions floating around at arbitrary points.
153     if (SafepointMechanism::should_block(thread) || thread-&gt;is_suspend_after_native()) {
154       JavaThread::check_safepoint_and_suspend_for_native_trans(thread);
<a name="9" id="anc9"></a><span class="line-removed">155 </span>
<span class="line-removed">156       // Clear unhandled oops anywhere where we could block, even if we don&#39;t.</span>
<span class="line-removed">157       CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
158     }
159 
160     thread-&gt;set_thread_state(to);
161   }
162  protected:
163    void trans(JavaThreadState from, JavaThreadState to)  { transition(_thread, from, to); }
164    void trans_from_java(JavaThreadState to)              { transition_from_java(_thread, to); }
165    void trans_from_native(JavaThreadState to)            { transition_from_native(_thread, to); }
<a name="10" id="anc10"></a><span class="line-removed">166    void trans_and_fence(JavaThreadState from, JavaThreadState to) { transition_and_fence(_thread, from, to); }</span>
167 };
168 
169 class ThreadInVMForHandshake : public ThreadStateTransition {
170   const JavaThreadState _original_state;
171 
172   void transition_back() {
173     // This can be invoked from transition states and must return to the original state properly
174     assert(_thread-&gt;thread_state() == _thread_in_vm, &quot;should only call when leaving VM after handshake&quot;);
<a name="11" id="anc11"></a><span class="line-modified">175     _thread-&gt;set_thread_state(_thread_in_vm_trans);</span>
<span class="line-modified">176 </span>
<span class="line-removed">177     InterfaceSupport::serialize_thread_state(_thread);</span>
178 
179     SafepointMechanism::block_if_requested(_thread);
180 
181     _thread-&gt;set_thread_state(_original_state);
<a name="12" id="anc12"></a>





182   }
183 
184  public:
185 
186   ThreadInVMForHandshake(JavaThread* thread) : ThreadStateTransition(thread),
187       _original_state(thread-&gt;thread_state()) {
188 
189     if (thread-&gt;has_last_Java_frame()) {
190       thread-&gt;frame_anchor()-&gt;make_walkable(thread);
191     }
192 
193     thread-&gt;set_thread_state(_thread_in_vm);
194   }
195 
196   ~ThreadInVMForHandshake() {
197     transition_back();
198   }
199 
200 };
201 
202 class ThreadInVMfromJava : public ThreadStateTransition {
203  public:
204   ThreadInVMfromJava(JavaThread* thread) : ThreadStateTransition(thread) {
205     trans_from_java(_thread_in_vm);
206   }
207   ~ThreadInVMfromJava()  {
208     if (_thread-&gt;stack_yellow_reserved_zone_disabled()) {
209       _thread-&gt;enable_stack_yellow_reserved_zone();
210     }
211     trans(_thread_in_vm, _thread_in_Java);
212     // Check for pending. async. exceptions or suspends.
213     if (_thread-&gt;has_special_runtime_exit_condition()) _thread-&gt;handle_special_runtime_exit_condition();
214   }
215 };
216 
217 
218 class ThreadInVMfromUnknown {
<a name="13" id="anc13"></a><span class="line-removed">219  private:</span>
220   JavaThread* _thread;
221  public:
222   ThreadInVMfromUnknown() : _thread(NULL) {
223     Thread* t = Thread::current();
224     if (t-&gt;is_Java_thread()) {
225       JavaThread* t2 = (JavaThread*) t;
226       if (t2-&gt;thread_state() == _thread_in_native) {
227         _thread = t2;
228         ThreadStateTransition::transition_from_native(t2, _thread_in_vm);
229         // Used to have a HandleMarkCleaner but that is dangerous as
230         // it could free a handle in our (indirect, nested) caller.
231         // We expect any handles will be short lived and figure we
232         // don&#39;t need an actual HandleMark.
233       }
234     }
235   }
236   ~ThreadInVMfromUnknown()  {
237     if (_thread) {
<a name="14" id="anc14"></a><span class="line-modified">238       ThreadStateTransition::transition_and_fence(_thread, _thread_in_vm, _thread_in_native);</span>
239     }
240   }
241 };
242 
243 
244 class ThreadInVMfromNative : public ThreadStateTransition {
245  public:
246   ThreadInVMfromNative(JavaThread* thread) : ThreadStateTransition(thread) {
247     trans_from_native(_thread_in_vm);
248   }
249   ~ThreadInVMfromNative() {
<a name="15" id="anc15"></a><span class="line-modified">250     trans_and_fence(_thread_in_vm, _thread_in_native);</span>
251   }
252 };
253 
254 
255 class ThreadToNativeFromVM : public ThreadStateTransition {
256  public:
257   ThreadToNativeFromVM(JavaThread *thread) : ThreadStateTransition(thread) {
258     // We are leaving the VM at this point and going directly to native code.
259     // Block, if we are in the middle of a safepoint synchronization.
260     assert(!thread-&gt;owns_locks(), &quot;must release all locks when leaving VM&quot;);
261     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
<a name="16" id="anc16"></a><span class="line-modified">262     trans_and_fence(_thread_in_vm, _thread_in_native);</span>
263     // Check for pending. async. exceptions or suspends.
264     if (_thread-&gt;has_special_runtime_exit_condition()) _thread-&gt;handle_special_runtime_exit_condition(false);
265   }
266 
267   ~ThreadToNativeFromVM() {
268     trans_from_native(_thread_in_vm);
269     assert(!_thread-&gt;is_pending_jni_exception_check(), &quot;Pending JNI Exception Check&quot;);
270     // We don&#39;t need to clear_walkable because it will happen automagically when we return to java
271   }
272 };
273 
274 
275 class ThreadBlockInVM : public ThreadStateTransition {
276  public:
277   ThreadBlockInVM(JavaThread *thread)
278   : ThreadStateTransition(thread) {
279     // Once we are blocked vm expects stack to be walkable
280     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
<a name="17" id="anc17"></a><span class="line-modified">281     trans_and_fence(_thread_in_vm, _thread_blocked);</span>
282   }
283   ~ThreadBlockInVM() {
<a name="18" id="anc18"></a><span class="line-modified">284     trans_and_fence(_thread_blocked, _thread_in_vm);</span>

285     // We don&#39;t need to clear_walkable because it will happen automagically when we return to java
286   }
287 };
288 
289 // Unlike ThreadBlockInVM, this class is designed to avoid certain deadlock scenarios while making
<a name="19" id="anc19"></a><span class="line-modified">290 // transitions inside class Monitor in cases where we need to block for a safepoint or handshake. It</span>
<span class="line-modified">291 // receives an extra argument compared to ThreadBlockInVM, the address of a pointer to the monitor we</span>
<span class="line-modified">292 // are trying to acquire. This will be used to access and release the monitor if needed to avoid</span>
293 // said deadlocks.
294 // It works like ThreadBlockInVM but differs from it in two ways:
295 // - When transitioning in (constructor), it checks for safepoints without blocking, i.e., calls
296 //   back if needed to allow a pending safepoint to continue but does not block in it.
297 // - When transitioning back (destructor), if there is a pending safepoint or handshake it releases
<a name="20" id="anc20"></a><span class="line-modified">298 //   the monitor that is only partially acquired.</span>
299 class ThreadBlockInVMWithDeadlockCheck : public ThreadStateTransition {
300  private:
<a name="21" id="anc21"></a><span class="line-modified">301   Monitor** _in_flight_monitor_adr;</span>
<span class="line-modified">302 </span>
<span class="line-modified">303   void release_monitor() {</span>
<span class="line-modified">304     assert(_in_flight_monitor_adr != NULL, &quot;_in_flight_monitor_adr should have been set on constructor&quot;);</span>
<span class="line-modified">305     Monitor* in_flight_monitor = *_in_flight_monitor_adr;</span>
<span class="line-modified">306     if (in_flight_monitor != NULL) {</span>
<span class="line-modified">307       in_flight_monitor-&gt;release_for_safepoint();</span>
<span class="line-modified">308       *_in_flight_monitor_adr = NULL;</span>
309     }
310   }
311  public:
<a name="22" id="anc22"></a><span class="line-modified">312   ThreadBlockInVMWithDeadlockCheck(JavaThread* thread, Monitor** in_flight_monitor_adr)</span>
<span class="line-modified">313   : ThreadStateTransition(thread), _in_flight_monitor_adr(in_flight_monitor_adr) {</span>
314     // Once we are blocked vm expects stack to be walkable
315     thread-&gt;frame_anchor()-&gt;make_walkable(thread);
316 
317     // All unsafe states are treated the same by the VMThread
318     // so we can skip the _thread_in_vm_trans state here. Since
319     // we don&#39;t read poll, it&#39;s enough to order the stores.
320     OrderAccess::storestore();
321 
322     thread-&gt;set_thread_state(_thread_blocked);
<a name="23" id="anc23"></a><span class="line-removed">323 </span>
<span class="line-removed">324     CHECK_UNHANDLED_OOPS_ONLY(_thread-&gt;clear_unhandled_oops();)</span>
325   }
326   ~ThreadBlockInVMWithDeadlockCheck() {
<a name="24" id="anc24"></a><span class="line-modified">327     // Change to transition state</span>
<span class="line-modified">328     _thread-&gt;set_thread_state((JavaThreadState)(_thread_blocked_trans));</span>
<span class="line-removed">329 </span>
<span class="line-removed">330     InterfaceSupport::serialize_thread_state_with_handler(_thread);</span>
331 
332     if (SafepointMechanism::should_block(_thread)) {
<a name="25" id="anc25"></a><span class="line-modified">333       release_monitor();</span>
334       SafepointMechanism::block_if_requested(_thread);
335     }
336 
337     _thread-&gt;set_thread_state(_thread_in_vm);
<a name="26" id="anc26"></a><span class="line-modified">338     CHECK_UNHANDLED_OOPS_ONLY(_thread-&gt;clear_unhandled_oops();)</span>
339   }
340 };
341 
342 
343 // This special transition class is only used to prevent asynchronous exceptions
344 // from being installed on vm exit in situations where we can&#39;t tolerate them.
345 // See bugs: 4324348, 4854693, 4998314, 5040492, 5050705.
346 class ThreadInVMfromJavaNoAsyncException : public ThreadStateTransition {
347  public:
348   ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread) {
349     trans_from_java(_thread_in_vm);
350   }
351   ~ThreadInVMfromJavaNoAsyncException()  {
352     if (_thread-&gt;stack_yellow_reserved_zone_disabled()) {
353       _thread-&gt;enable_stack_yellow_reserved_zone();
354     }
355     trans(_thread_in_vm, _thread_in_Java);
356     // NOTE: We do not check for pending. async. exceptions.
357     // If we did and moved the pending async exception over into the
358     // pending exception field, we would need to deopt (currently C2
359     // only). However, to do so would require that we transition back
360     // to the _thread_in_vm state. Instead we postpone the handling of
361     // the async exception.
362 
363 
364     // Check for pending. suspends only.
365     if (_thread-&gt;has_special_runtime_exit_condition())
366       _thread-&gt;handle_special_runtime_exit_condition(false);
367   }
368 };
369 
<a name="27" id="anc27"></a><span class="line-modified">370 // Debug class instantiated in JRT_ENTRY and ITR_ENTRY macro.</span>
371 // Can be used to verify properties on enter/exit of the VM.
372 
373 #ifdef ASSERT
374 class VMEntryWrapper {
375  public:
376   VMEntryWrapper();
377   ~VMEntryWrapper();
378 };
379 
380 
381 class VMNativeEntryWrapper {
382  public:
<a name="28" id="anc28"></a><span class="line-modified">383   VMNativeEntryWrapper() {</span>
<span class="line-modified">384     if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();</span>
<span class="line-removed">385   }</span>
<span class="line-removed">386 </span>
<span class="line-removed">387   ~VMNativeEntryWrapper() {</span>
<span class="line-removed">388     if (GCALotAtAllSafepoints) InterfaceSupport::check_gc_alot();</span>
<span class="line-removed">389   }</span>
<span class="line-removed">390 };</span>
<span class="line-removed">391 </span>
<span class="line-removed">392 #endif</span>
<span class="line-removed">393 </span>
<span class="line-removed">394 </span>
<span class="line-removed">395 // VM-internal runtime interface support</span>
<span class="line-removed">396 </span>
<span class="line-removed">397 // Definitions for JRT (Java (Compiler/Shared) Runtime)</span>
<span class="line-removed">398 </span>
<span class="line-removed">399 // JRT_LEAF currently can be called from either _thread_in_Java or</span>
<span class="line-removed">400 // _thread_in_native mode. In _thread_in_native, it is ok</span>
<span class="line-removed">401 // for another thread to trigger GC. The rest of the JRT_LEAF</span>
<span class="line-removed">402 // rules apply.</span>
<span class="line-removed">403 class JRTLeafVerifier : public NoSafepointVerifier {</span>
<span class="line-removed">404   static bool should_verify_GC();</span>
<span class="line-removed">405  public:</span>
<span class="line-removed">406 #ifdef ASSERT</span>
<span class="line-removed">407   JRTLeafVerifier();</span>
<span class="line-removed">408   ~JRTLeafVerifier();</span>
<span class="line-removed">409 #else</span>
<span class="line-removed">410   JRTLeafVerifier() {}</span>
<span class="line-removed">411   ~JRTLeafVerifier() {}</span>
<span class="line-removed">412 #endif</span>
413 };
414 
<a name="29" id="anc29"></a><span class="line-removed">415 #ifdef ASSERT</span>
<span class="line-removed">416 </span>
417 class RuntimeHistogramElement : public HistogramElement {
418   public:
419    RuntimeHistogramElement(const char* name);
420 };
<a name="30" id="anc30"></a>
421 
<a name="31" id="anc31"></a>
422 #define TRACE_CALL(result_type, header)                            \
423   InterfaceSupport::_number_of_calls++;                            \
424   if (CountRuntimeCalls) {                                         \
425     static RuntimeHistogramElement* e = new RuntimeHistogramElement(#header); \
426     if (e != NULL) e-&gt;increment_count();                           \
427   }
428 #else
429 #define TRACE_CALL(result_type, header)                            \
430   /* do nothing */
<a name="32" id="anc32"></a><span class="line-modified">431 #endif</span>
432 
433 
434 // LEAF routines do not lock, GC or throw exceptions
435 
436 #define VM_LEAF_BASE(result_type, header)                            \
437   TRACE_CALL(result_type, header)                                    \
438   debug_only(NoHandleMark __hm;)                                     \
439   os::verify_stack_alignment();                                      \
440   /* begin of body */
441 
442 #define VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)         \
443   TRACE_CALL(result_type, header)                                    \
444   debug_only(ResetNoHandleMark __rnhm;)                              \
445   HandleMarkCleaner __hm(thread);                                    \
446   Thread* THREAD = thread;                                           \
447   os::verify_stack_alignment();                                      \
448   /* begin of body */
449 
450 
451 // ENTRY routines may lock, GC and throw exceptions
452 
453 #define VM_ENTRY_BASE(result_type, header, thread)                   \
454   TRACE_CALL(result_type, header)                                    \
455   HandleMarkCleaner __hm(thread);                                    \
456   Thread* THREAD = thread;                                           \
457   os::verify_stack_alignment();                                      \
458   /* begin of body */
459 
460 
<a name="33" id="anc33"></a><span class="line-removed">461 // QUICK_ENTRY routines behave like ENTRY but without a handle mark</span>
<span class="line-removed">462 </span>
<span class="line-removed">463 #define VM_QUICK_ENTRY_BASE(result_type, header, thread)             \</span>
<span class="line-removed">464   TRACE_CALL(result_type, header)                                    \</span>
<span class="line-removed">465   debug_only(NoHandleMark __hm;)                                     \</span>
<span class="line-removed">466   Thread* THREAD = thread;                                           \</span>
<span class="line-removed">467   os::verify_stack_alignment();                                      \</span>
<span class="line-removed">468   /* begin of body */</span>
<span class="line-removed">469 </span>
<span class="line-removed">470 </span>
<span class="line-removed">471 // Definitions for IRT (Interpreter Runtime)</span>
<span class="line-removed">472 // (thread is an argument passed in to all these routines)</span>
<span class="line-removed">473 </span>
<span class="line-removed">474 #define IRT_ENTRY(result_type, header)                               \</span>
<span class="line-removed">475   result_type header {                                               \</span>
<span class="line-removed">476     ThreadInVMfromJava __tiv(thread);                                \</span>
<span class="line-removed">477     VM_ENTRY_BASE(result_type, header, thread)                       \</span>
<span class="line-removed">478     debug_only(VMEntryWrapper __vew;)</span>
<span class="line-removed">479 </span>
<span class="line-removed">480 </span>
<span class="line-removed">481 #define IRT_LEAF(result_type, header)                                \</span>
<span class="line-removed">482   result_type header {                                               \</span>
<span class="line-removed">483     VM_LEAF_BASE(result_type, header)                                \</span>
<span class="line-removed">484     debug_only(NoSafepointVerifier __nspv(true);)</span>
<span class="line-removed">485 </span>
<span class="line-removed">486 </span>
<span class="line-removed">487 #define IRT_ENTRY_NO_ASYNC(result_type, header)                      \</span>
<span class="line-removed">488   result_type header {                                               \</span>
<span class="line-removed">489     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \</span>
<span class="line-removed">490     VM_ENTRY_BASE(result_type, header, thread)                       \</span>
<span class="line-removed">491     debug_only(VMEntryWrapper __vew;)</span>
<span class="line-removed">492 </span>
<span class="line-removed">493 #define IRT_END }</span>
<span class="line-removed">494 </span>
495 #define JRT_ENTRY(result_type, header)                               \
496   result_type header {                                               \
497     ThreadInVMfromJava __tiv(thread);                                \
498     VM_ENTRY_BASE(result_type, header, thread)                       \
499     debug_only(VMEntryWrapper __vew;)
500 
<a name="34" id="anc34"></a>












501 
502 #define JRT_LEAF(result_type, header)                                \
503   result_type header {                                               \
504   VM_LEAF_BASE(result_type, header)                                  \
<a name="35" id="anc35"></a><span class="line-modified">505   debug_only(JRTLeafVerifier __jlv;)</span>
506 
507 
508 #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
509   result_type header {                                               \
510     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
511     VM_ENTRY_BASE(result_type, header, thread)                       \
512     debug_only(VMEntryWrapper __vew;)
513 
514 // Same as JRT Entry but allows for return value after the safepoint
515 // to get back into Java from the VM
516 #define JRT_BLOCK_ENTRY(result_type, header)                         \
517   result_type header {                                               \
518     TRACE_CALL(result_type, header)                                  \
519     HandleMarkCleaner __hm(thread);
520 
521 #define JRT_BLOCK                                                    \
522     {                                                                \
523     ThreadInVMfromJava __tiv(thread);                                \
524     Thread* THREAD = thread;                                         \
525     debug_only(VMEntryWrapper __vew;)
526 
527 #define JRT_BLOCK_NO_ASYNC                                           \
528     {                                                                \
529     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
530     Thread* THREAD = thread;                                         \
531     debug_only(VMEntryWrapper __vew;)
532 
533 #define JRT_BLOCK_END }
534 
535 #define JRT_END }
536 
537 // Definitions for JNI
538 
539 #define JNI_ENTRY(result_type, header)                               \
540     JNI_ENTRY_NO_PRESERVE(result_type, header)                       \
541     WeakPreserveExceptionMark __wem(thread);
542 
543 #define JNI_ENTRY_NO_PRESERVE(result_type, header)                   \
544 extern &quot;C&quot; {                                                         \
545   result_type JNICALL header {                                       \
546     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
547     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \
548     ThreadInVMfromNative __tiv(thread);                              \
549     debug_only(VMNativeEntryWrapper __vew;)                          \
550     VM_ENTRY_BASE(result_type, header, thread)
551 
552 
<a name="36" id="anc36"></a><span class="line-removed">553 // Ensure that the VMNativeEntryWrapper constructor, which can cause</span>
<span class="line-removed">554 // a GC, is called outside the NoHandleMark (set via VM_QUICK_ENTRY_BASE).</span>
<span class="line-removed">555 #define JNI_QUICK_ENTRY(result_type, header)                         \</span>
<span class="line-removed">556 extern &quot;C&quot; {                                                         \</span>
<span class="line-removed">557   result_type JNICALL header {                                       \</span>
<span class="line-removed">558     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \</span>
<span class="line-removed">559     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \</span>
<span class="line-removed">560     ThreadInVMfromNative __tiv(thread);                              \</span>
<span class="line-removed">561     debug_only(VMNativeEntryWrapper __vew;)                          \</span>
<span class="line-removed">562     VM_QUICK_ENTRY_BASE(result_type, header, thread)</span>
<span class="line-removed">563 </span>
<span class="line-removed">564 </span>
565 #define JNI_LEAF(result_type, header)                                \
566 extern &quot;C&quot; {                                                         \
567   result_type JNICALL header {                                       \
568     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
569     assert( !VerifyJNIEnvThread || (thread == Thread::current()), &quot;JNIEnv is only valid in same thread&quot;); \
570     VM_LEAF_BASE(result_type, header)
571 
572 
573 // Close the routine and the extern &quot;C&quot;
574 #define JNI_END } }
575 
576 
577 
578 // Definitions for JVM
579 
580 #define JVM_ENTRY(result_type, header)                               \
581 extern &quot;C&quot; {                                                         \
582   result_type JNICALL header {                                       \
583     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
584     ThreadInVMfromNative __tiv(thread);                              \
585     debug_only(VMNativeEntryWrapper __vew;)                          \
586     VM_ENTRY_BASE(result_type, header, thread)
587 
588 
589 #define JVM_ENTRY_NO_ENV(result_type, header)                        \
590 extern &quot;C&quot; {                                                         \
591   result_type JNICALL header {                                       \
592     JavaThread* thread = JavaThread::current();                      \
593     ThreadInVMfromNative __tiv(thread);                              \
594     debug_only(VMNativeEntryWrapper __vew;)                          \
595     VM_ENTRY_BASE(result_type, header, thread)
596 
597 
<a name="37" id="anc37"></a><span class="line-removed">598 #define JVM_QUICK_ENTRY(result_type, header)                         \</span>
<span class="line-removed">599 extern &quot;C&quot; {                                                         \</span>
<span class="line-removed">600   result_type JNICALL header {                                       \</span>
<span class="line-removed">601     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \</span>
<span class="line-removed">602     ThreadInVMfromNative __tiv(thread);                              \</span>
<span class="line-removed">603     debug_only(VMNativeEntryWrapper __vew;)                          \</span>
<span class="line-removed">604     VM_QUICK_ENTRY_BASE(result_type, header, thread)</span>
<span class="line-removed">605 </span>
<span class="line-removed">606 </span>
607 #define JVM_LEAF(result_type, header)                                \
608 extern &quot;C&quot; {                                                         \
609   result_type JNICALL header {                                       \
610     VM_Exit::block_if_vm_exited();                                   \
611     VM_LEAF_BASE(result_type, header)
612 
613 
614 #define JVM_ENTRY_FROM_LEAF(env, result_type, header)                \
615   { {                                                                \
616     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
617     ThreadInVMfromNative __tiv(thread);                              \
618     debug_only(VMNativeEntryWrapper __vew;)                          \
619     VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)
620 
621 
622 #define JVM_END } }
623 
624 #endif // SHARE_RUNTIME_INTERFACESUPPORT_INLINE_HPP
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sharedRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="signature.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
187 
188   // exception handling and implicit exceptions
189   static address compute_compiled_exc_handler(CompiledMethod* nm, address ret_pc, Handle&amp; exception,
190                                               bool force_unwind, bool top_frame_only, bool&amp; recursive_exception_occurred);
191   enum ImplicitExceptionKind {
192     IMPLICIT_NULL,
193     IMPLICIT_DIVIDE_BY_ZERO,
194     STACK_OVERFLOW
195   };
196   static void    throw_AbstractMethodError(JavaThread* thread);
197   static void    throw_IncompatibleClassChangeError(JavaThread* thread);
198   static void    throw_ArithmeticException(JavaThread* thread);
199   static void    throw_NullPointerException(JavaThread* thread);
200   static void    throw_NullPointerException_at_call(JavaThread* thread);
201   static void    throw_StackOverflowError(JavaThread* thread);
202   static void    throw_delayed_StackOverflowError(JavaThread* thread);
203   static void    throw_StackOverflowError_common(JavaThread* thread, bool delayed);
204   static address continuation_for_implicit_exception(JavaThread* thread,
205                                                      address faulting_pc,
206                                                      ImplicitExceptionKind exception_kind);
<span class="line-removed">207 #if INCLUDE_JVMCI</span>
<span class="line-removed">208   static address deoptimize_for_implicit_exception(JavaThread* thread, address pc, CompiledMethod* nm, int deopt_reason);</span>
<span class="line-removed">209 #endif</span>
210 
211   // Post-slow-path-allocation, pre-initializing-stores step for
212   // implementing e.g. ReduceInitialCardMarks
213   static void on_slowpath_allocation_exit(JavaThread* thread);
214 
215   static void enable_stack_reserved_zone(JavaThread* thread);
216   static frame look_for_reserved_stack_annotated_method(JavaThread* thread, frame fr);
217 
218   // Shared stub locations
219   static address get_poll_stub(address pc);
220 
221   static address get_ic_miss_stub() {
222     assert(_ic_miss_blob!= NULL, &quot;oops&quot;);
223     return _ic_miss_blob-&gt;entry_point();
224   }
225 
226   static address get_handle_wrong_method_stub() {
227     assert(_wrong_method_blob!= NULL, &quot;oops&quot;);
228     return _wrong_method_blob-&gt;entry_point();
229   }
</pre>
<hr />
<pre>
414   // Resets a call-site in compiled code so it will get resolved again.
415   static methodHandle reresolve_call_site(JavaThread *thread, TRAPS);
416 
417   // In the code prolog, if the klass comparison fails, the inline cache
418   // misses and the call site is patched to megamorphic
419   static methodHandle handle_ic_miss_helper(JavaThread* thread, TRAPS);
420 
421   // Find the method that called us.
422   static methodHandle find_callee_method(JavaThread* thread, TRAPS);
423 
424 
425  private:
426   static Handle find_callee_info(JavaThread* thread,
427                                  Bytecodes::Code&amp; bc,
428                                  CallInfo&amp; callinfo, TRAPS);
429   static Handle find_callee_info_helper(JavaThread* thread,
430                                         vframeStream&amp; vfst,
431                                         Bytecodes::Code&amp; bc,
432                                         CallInfo&amp; callinfo, TRAPS);
433 
<span class="line-modified">434   static methodHandle extract_attached_method(vframeStream&amp; vfst);</span>
435 
436   static address clean_virtual_call_entry();
437   static address clean_opt_virtual_call_entry();
438   static address clean_static_call_entry();
439 
440 #if defined(X86) &amp;&amp; defined(COMPILER1)
441   // For Object.hashCode, System.identityHashCode try to pull hashCode from object header if available.
442   static void inline_check_hashcode_from_object_header(MacroAssembler* masm, const methodHandle&amp; method, Register obj_reg, Register result);
443 #endif // X86 &amp;&amp; COMPILER1
444 
445  public:
446 
447   // Read the array of BasicTypes from a Java signature, and compute where
448   // compiled Java code would like to put the results.  Values in reg_lo and
449   // reg_hi refer to 4-byte quantities.  Values less than SharedInfo::stack0 are
450   // registers, those above refer to 4-byte stack slots.  All stack slots are
451   // based off of the window top.  SharedInfo::stack0 refers to the first usable
452   // slot in the bottom of the frame. SharedInfo::stack0+1 refers to the memory word
453   // 4-bytes higher. So for sparc because the register window save area is at
454   // the bottom of the frame the first 16 words will be skipped and SharedInfo::stack0
</pre>
<hr />
<pre>
548   static bool is_wide_vector(int size);
549 
550   // Save and restore a native result
551   static void    save_native_result(MacroAssembler *_masm, BasicType ret_type, int frame_slots);
552   static void restore_native_result(MacroAssembler *_masm, BasicType ret_type, int frame_slots);
553 
554   // Generate a native wrapper for a given method.  The method takes arguments
555   // in the Java compiled code convention, marshals them to the native
556   // convention (handlizes oops, etc), transitions to native, makes the call,
557   // returns to java state (possibly blocking), unhandlizes any result and
558   // returns.
559   //
560   // The wrapper may contain special-case code if the given method
561   // is a JNI critical method, or a compiled method handle adapter,
562   // such as _invokeBasic, _linkToVirtual, etc.
563   static nmethod* generate_native_wrapper(MacroAssembler* masm,
564                                           const methodHandle&amp; method,
565                                           int compile_id,
566                                           BasicType* sig_bt,
567                                           VMRegPair* regs,
<span class="line-modified">568                                           BasicType ret_type);</span>

569 
570   // Block before entering a JNI critical method
571   static void block_for_jni_critical(JavaThread* thread);
572 
573   // Pin/Unpin object
574   static oopDesc* pin_object(JavaThread* thread, oopDesc* obj);
575   static void unpin_object(JavaThread* thread, oopDesc* obj);
576 
577   // A compiled caller has just called the interpreter, but compiled code
578   // exists.  Patch the caller so he no longer calls into the interpreter.
579   static void fixup_callers_callsite(Method* moop, address ret_pc);
580   static bool should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb);
581 
582   // Slow-path Locking and Unlocking
583   static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
584   static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
585 
586   // Resolving of calls
587   static address resolve_static_call_C     (JavaThread *thread);
588   static address resolve_virtual_call_C    (JavaThread *thread);
</pre>
<hr />
<pre>
699 // setup.  Compiled frames are fixed-size and the args are likely not in the
700 // right place.  Hence all the args will likely be copied into the
701 // interpreter&#39;s frame, forcing that frame to grow.  The compiled frame&#39;s
702 // outgoing stack args will be dead after the copy.
703 //
704 // Native wrappers, like adapters, marshal arguments.  Unlike adapters they
705 // also perform an official frame push &amp; pop.  They have a call to the native
706 // routine in their middles and end in a return (instead of ending in a jump).
707 // The native wrappers are stored in real nmethods instead of the BufferBlobs
708 // used by the adapters.  The code generation happens here because it&#39;s very
709 // similar to what the adapters have to do.
710 
711 class AdapterHandlerEntry : public BasicHashtableEntry&lt;mtCode&gt; {
712   friend class AdapterHandlerTable;
713 
714  private:
715   AdapterFingerPrint* _fingerprint;
716   address _i2c_entry;
717   address _c2i_entry;
718   address _c2i_unverified_entry;

719 
720 #ifdef ASSERT
721   // Captures code and signature used to generate this adapter when
722   // verifying adapter equivalence.
723   unsigned char* _saved_code;
724   int            _saved_code_length;
725 #endif
726 
<span class="line-modified">727   void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry) {</span>
728     _fingerprint = fingerprint;
729     _i2c_entry = i2c_entry;
730     _c2i_entry = c2i_entry;
731     _c2i_unverified_entry = c2i_unverified_entry;

732 #ifdef ASSERT
733     _saved_code = NULL;
734     _saved_code_length = 0;
735 #endif
736   }
737 
738   void deallocate();
739 
740   // should never be used
741   AdapterHandlerEntry();
742 
743  public:
<span class="line-modified">744   address get_i2c_entry()            const { return _i2c_entry; }</span>
<span class="line-modified">745   address get_c2i_entry()            const { return _c2i_entry; }</span>
<span class="line-modified">746   address get_c2i_unverified_entry() const { return _c2i_unverified_entry; }</span>


747   address base_address();
748   void relocate(address new_base);
749 
750   AdapterFingerPrint* fingerprint() const { return _fingerprint; }
751 
752   AdapterHandlerEntry* next() {
753     return (AdapterHandlerEntry*)BasicHashtableEntry&lt;mtCode&gt;::next();
754   }
755 
756 #ifdef ASSERT
757   // Used to verify that code generated for shared adapters is equivalent
758   void save_code   (unsigned char* code, int length);
759   bool compare_code(unsigned char* code, int length);
760 #endif
761 
762   //virtual void print_on(outputStream* st) const;  DO NOT USE
763   void print_adapter_on(outputStream* st) const;
764 };
765 
766 // This class is used only with DumpSharedSpaces==true. It holds extra information
</pre>
<hr />
<pre>
772 
773 public:
774   address get_c2i_entry_trampoline()             const { return _c2i_entry_trampoline; }
775   AdapterHandlerEntry** get_adapter_trampoline() const { return _adapter_trampoline; }
776   void init() NOT_CDS_RETURN;
777 };
778 
779 
780 class AdapterHandlerLibrary: public AllStatic {
781  private:
782   static BufferBlob* _buffer; // the temporary code buffer in CodeCache
783   static AdapterHandlerTable* _adapters;
784   static AdapterHandlerEntry* _abstract_method_handler;
785   static BufferBlob* buffer_blob();
786   static void initialize();
787   static AdapterHandlerEntry* get_adapter0(const methodHandle&amp; method);
788 
789  public:
790 
791   static AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint,
<span class="line-modified">792                                         address i2c_entry, address c2i_entry, address c2i_unverified_entry);</span>



793   static void create_native_wrapper(const methodHandle&amp; method);
794   static AdapterHandlerEntry* get_adapter(const methodHandle&amp; method);
795 
796   static void print_handler(const CodeBlob* b) { print_handler_on(tty, b); }
797   static void print_handler_on(outputStream* st, const CodeBlob* b);
798   static bool contains(const CodeBlob* b);
799 #ifndef PRODUCT
800   static void print_statistics();
801 #endif // PRODUCT
802 
803 };
804 
805 #endif // SHARE_RUNTIME_SHAREDRUNTIME_HPP
</pre>
</td>
<td>
<hr />
<pre>
187 
188   // exception handling and implicit exceptions
189   static address compute_compiled_exc_handler(CompiledMethod* nm, address ret_pc, Handle&amp; exception,
190                                               bool force_unwind, bool top_frame_only, bool&amp; recursive_exception_occurred);
191   enum ImplicitExceptionKind {
192     IMPLICIT_NULL,
193     IMPLICIT_DIVIDE_BY_ZERO,
194     STACK_OVERFLOW
195   };
196   static void    throw_AbstractMethodError(JavaThread* thread);
197   static void    throw_IncompatibleClassChangeError(JavaThread* thread);
198   static void    throw_ArithmeticException(JavaThread* thread);
199   static void    throw_NullPointerException(JavaThread* thread);
200   static void    throw_NullPointerException_at_call(JavaThread* thread);
201   static void    throw_StackOverflowError(JavaThread* thread);
202   static void    throw_delayed_StackOverflowError(JavaThread* thread);
203   static void    throw_StackOverflowError_common(JavaThread* thread, bool delayed);
204   static address continuation_for_implicit_exception(JavaThread* thread,
205                                                      address faulting_pc,
206                                                      ImplicitExceptionKind exception_kind);



207 
208   // Post-slow-path-allocation, pre-initializing-stores step for
209   // implementing e.g. ReduceInitialCardMarks
210   static void on_slowpath_allocation_exit(JavaThread* thread);
211 
212   static void enable_stack_reserved_zone(JavaThread* thread);
213   static frame look_for_reserved_stack_annotated_method(JavaThread* thread, frame fr);
214 
215   // Shared stub locations
216   static address get_poll_stub(address pc);
217 
218   static address get_ic_miss_stub() {
219     assert(_ic_miss_blob!= NULL, &quot;oops&quot;);
220     return _ic_miss_blob-&gt;entry_point();
221   }
222 
223   static address get_handle_wrong_method_stub() {
224     assert(_wrong_method_blob!= NULL, &quot;oops&quot;);
225     return _wrong_method_blob-&gt;entry_point();
226   }
</pre>
<hr />
<pre>
411   // Resets a call-site in compiled code so it will get resolved again.
412   static methodHandle reresolve_call_site(JavaThread *thread, TRAPS);
413 
414   // In the code prolog, if the klass comparison fails, the inline cache
415   // misses and the call site is patched to megamorphic
416   static methodHandle handle_ic_miss_helper(JavaThread* thread, TRAPS);
417 
418   // Find the method that called us.
419   static methodHandle find_callee_method(JavaThread* thread, TRAPS);
420 
421 
422  private:
423   static Handle find_callee_info(JavaThread* thread,
424                                  Bytecodes::Code&amp; bc,
425                                  CallInfo&amp; callinfo, TRAPS);
426   static Handle find_callee_info_helper(JavaThread* thread,
427                                         vframeStream&amp; vfst,
428                                         Bytecodes::Code&amp; bc,
429                                         CallInfo&amp; callinfo, TRAPS);
430 
<span class="line-modified">431   static Method* extract_attached_method(vframeStream&amp; vfst);</span>
432 
433   static address clean_virtual_call_entry();
434   static address clean_opt_virtual_call_entry();
435   static address clean_static_call_entry();
436 
437 #if defined(X86) &amp;&amp; defined(COMPILER1)
438   // For Object.hashCode, System.identityHashCode try to pull hashCode from object header if available.
439   static void inline_check_hashcode_from_object_header(MacroAssembler* masm, const methodHandle&amp; method, Register obj_reg, Register result);
440 #endif // X86 &amp;&amp; COMPILER1
441 
442  public:
443 
444   // Read the array of BasicTypes from a Java signature, and compute where
445   // compiled Java code would like to put the results.  Values in reg_lo and
446   // reg_hi refer to 4-byte quantities.  Values less than SharedInfo::stack0 are
447   // registers, those above refer to 4-byte stack slots.  All stack slots are
448   // based off of the window top.  SharedInfo::stack0 refers to the first usable
449   // slot in the bottom of the frame. SharedInfo::stack0+1 refers to the memory word
450   // 4-bytes higher. So for sparc because the register window save area is at
451   // the bottom of the frame the first 16 words will be skipped and SharedInfo::stack0
</pre>
<hr />
<pre>
545   static bool is_wide_vector(int size);
546 
547   // Save and restore a native result
548   static void    save_native_result(MacroAssembler *_masm, BasicType ret_type, int frame_slots);
549   static void restore_native_result(MacroAssembler *_masm, BasicType ret_type, int frame_slots);
550 
551   // Generate a native wrapper for a given method.  The method takes arguments
552   // in the Java compiled code convention, marshals them to the native
553   // convention (handlizes oops, etc), transitions to native, makes the call,
554   // returns to java state (possibly blocking), unhandlizes any result and
555   // returns.
556   //
557   // The wrapper may contain special-case code if the given method
558   // is a JNI critical method, or a compiled method handle adapter,
559   // such as _invokeBasic, _linkToVirtual, etc.
560   static nmethod* generate_native_wrapper(MacroAssembler* masm,
561                                           const methodHandle&amp; method,
562                                           int compile_id,
563                                           BasicType* sig_bt,
564                                           VMRegPair* regs,
<span class="line-modified">565                                           BasicType ret_type,</span>
<span class="line-added">566                                           address critical_entry);</span>
567 
568   // Block before entering a JNI critical method
569   static void block_for_jni_critical(JavaThread* thread);
570 
571   // Pin/Unpin object
572   static oopDesc* pin_object(JavaThread* thread, oopDesc* obj);
573   static void unpin_object(JavaThread* thread, oopDesc* obj);
574 
575   // A compiled caller has just called the interpreter, but compiled code
576   // exists.  Patch the caller so he no longer calls into the interpreter.
577   static void fixup_callers_callsite(Method* moop, address ret_pc);
578   static bool should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb);
579 
580   // Slow-path Locking and Unlocking
581   static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
582   static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
583 
584   // Resolving of calls
585   static address resolve_static_call_C     (JavaThread *thread);
586   static address resolve_virtual_call_C    (JavaThread *thread);
</pre>
<hr />
<pre>
697 // setup.  Compiled frames are fixed-size and the args are likely not in the
698 // right place.  Hence all the args will likely be copied into the
699 // interpreter&#39;s frame, forcing that frame to grow.  The compiled frame&#39;s
700 // outgoing stack args will be dead after the copy.
701 //
702 // Native wrappers, like adapters, marshal arguments.  Unlike adapters they
703 // also perform an official frame push &amp; pop.  They have a call to the native
704 // routine in their middles and end in a return (instead of ending in a jump).
705 // The native wrappers are stored in real nmethods instead of the BufferBlobs
706 // used by the adapters.  The code generation happens here because it&#39;s very
707 // similar to what the adapters have to do.
708 
709 class AdapterHandlerEntry : public BasicHashtableEntry&lt;mtCode&gt; {
710   friend class AdapterHandlerTable;
711 
712  private:
713   AdapterFingerPrint* _fingerprint;
714   address _i2c_entry;
715   address _c2i_entry;
716   address _c2i_unverified_entry;
<span class="line-added">717   address _c2i_no_clinit_check_entry;</span>
718 
719 #ifdef ASSERT
720   // Captures code and signature used to generate this adapter when
721   // verifying adapter equivalence.
722   unsigned char* _saved_code;
723   int            _saved_code_length;
724 #endif
725 
<span class="line-modified">726   void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {</span>
727     _fingerprint = fingerprint;
728     _i2c_entry = i2c_entry;
729     _c2i_entry = c2i_entry;
730     _c2i_unverified_entry = c2i_unverified_entry;
<span class="line-added">731     _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;</span>
732 #ifdef ASSERT
733     _saved_code = NULL;
734     _saved_code_length = 0;
735 #endif
736   }
737 
738   void deallocate();
739 
740   // should never be used
741   AdapterHandlerEntry();
742 
743  public:
<span class="line-modified">744   address get_i2c_entry()                  const { return _i2c_entry; }</span>
<span class="line-modified">745   address get_c2i_entry()                  const { return _c2i_entry; }</span>
<span class="line-modified">746   address get_c2i_unverified_entry()       const { return _c2i_unverified_entry; }</span>
<span class="line-added">747   address get_c2i_no_clinit_check_entry()  const { return _c2i_no_clinit_check_entry; }</span>
<span class="line-added">748 </span>
749   address base_address();
750   void relocate(address new_base);
751 
752   AdapterFingerPrint* fingerprint() const { return _fingerprint; }
753 
754   AdapterHandlerEntry* next() {
755     return (AdapterHandlerEntry*)BasicHashtableEntry&lt;mtCode&gt;::next();
756   }
757 
758 #ifdef ASSERT
759   // Used to verify that code generated for shared adapters is equivalent
760   void save_code   (unsigned char* code, int length);
761   bool compare_code(unsigned char* code, int length);
762 #endif
763 
764   //virtual void print_on(outputStream* st) const;  DO NOT USE
765   void print_adapter_on(outputStream* st) const;
766 };
767 
768 // This class is used only with DumpSharedSpaces==true. It holds extra information
</pre>
<hr />
<pre>
774 
775 public:
776   address get_c2i_entry_trampoline()             const { return _c2i_entry_trampoline; }
777   AdapterHandlerEntry** get_adapter_trampoline() const { return _adapter_trampoline; }
778   void init() NOT_CDS_RETURN;
779 };
780 
781 
782 class AdapterHandlerLibrary: public AllStatic {
783  private:
784   static BufferBlob* _buffer; // the temporary code buffer in CodeCache
785   static AdapterHandlerTable* _adapters;
786   static AdapterHandlerEntry* _abstract_method_handler;
787   static BufferBlob* buffer_blob();
788   static void initialize();
789   static AdapterHandlerEntry* get_adapter0(const methodHandle&amp; method);
790 
791  public:
792 
793   static AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint,
<span class="line-modified">794                                         address i2c_entry,</span>
<span class="line-added">795                                         address c2i_entry,</span>
<span class="line-added">796                                         address c2i_unverified_entry,</span>
<span class="line-added">797                                         address c2i_no_clinit_check_entry = NULL);</span>
798   static void create_native_wrapper(const methodHandle&amp; method);
799   static AdapterHandlerEntry* get_adapter(const methodHandle&amp; method);
800 
801   static void print_handler(const CodeBlob* b) { print_handler_on(tty, b); }
802   static void print_handler_on(outputStream* st, const CodeBlob* b);
803   static bool contains(const CodeBlob* b);
804 #ifndef PRODUCT
805   static void print_statistics();
806 #endif // PRODUCT
807 
808 };
809 
810 #endif // SHARE_RUNTIME_SHAREDRUNTIME_HPP
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="signature.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
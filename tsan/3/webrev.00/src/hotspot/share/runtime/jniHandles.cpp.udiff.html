<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/jniHandles.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaCalls.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniHandles.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/jniHandles.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,32 +22,38 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  
<span class="udiff-line-modified-removed">- OopStorage* JNIHandles::_global_handles = NULL;</span>
<span class="udiff-line-modified-removed">- OopStorage* JNIHandles::_weak_global_handles = NULL;</span>
<span class="udiff-line-modified-added">+ static OopStorage* global_handles() {</span>
<span class="udiff-line-modified-added">+   return OopStorageSet::jni_global();</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- OopStorage* JNIHandles::global_handles() {</span>
<span class="udiff-line-modified-removed">-   assert(_global_handles != NULL, &quot;Uninitialized JNI global handles&quot;);</span>
<span class="udiff-line-removed">-   return _global_handles;</span>
<span class="udiff-line-modified-added">+ static OopStorage* weak_global_handles() {</span>
<span class="udiff-line-modified-added">+   return OopStorageSet::jni_weak();</span>
  }
  
<span class="udiff-line-modified-removed">- OopStorage* JNIHandles::weak_global_handles() {</span>
<span class="udiff-line-modified-removed">-   assert(_weak_global_handles != NULL, &quot;Uninitialized JNI weak global handles&quot;);</span>
<span class="udiff-line-modified-removed">-   return _weak_global_handles;</span>
<span class="udiff-line-modified-added">+ // Serviceability agent support.</span>
<span class="udiff-line-modified-added">+ OopStorage* JNIHandles::_global_handles = NULL;</span>
<span class="udiff-line-modified-added">+ OopStorage* JNIHandles::_weak_global_handles = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void jni_handles_init() {</span>
<span class="udiff-line-added">+   JNIHandles::_global_handles = global_handles();</span>
<span class="udiff-line-added">+   JNIHandles::_weak_global_handles = weak_global_handles();</span>
  }
  
  
  jobject JNIHandles::make_local(oop obj) {
    if (obj == NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -112,12 +118,10 @@</span>
        NativeAccess&lt;&gt;::oop_store(ptr, obj());
        res = reinterpret_cast&lt;jobject&gt;(ptr);
      } else {
        report_handle_allocation_failure(alloc_failmode, &quot;global&quot;);
      }
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
    }
  
    return res;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -137,12 +141,10 @@</span>
        char* tptr = reinterpret_cast&lt;char*&gt;(ptr) + weak_tag_value;
        res = reinterpret_cast&lt;jobject&gt;(tptr);
      } else {
        report_handle_allocation_failure(alloc_failmode, &quot;weak global&quot;);
      }
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());</span>
    }
    return res;
  }
  
  // Resolve some erroneous cases to NULL, rather than treating them as
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -198,20 +200,10 @@</span>
  void JNIHandles::weak_oops_do(OopClosure* f) {
    weak_global_handles()-&gt;weak_oops_do(f);
  }
  
  
<span class="udiff-line-removed">- void JNIHandles::initialize() {</span>
<span class="udiff-line-removed">-   _global_handles = new OopStorage(&quot;JNI Global&quot;,</span>
<span class="udiff-line-removed">-                                    JNIGlobalAlloc_lock,</span>
<span class="udiff-line-removed">-                                    JNIGlobalActive_lock);</span>
<span class="udiff-line-removed">-   _weak_global_handles = new OopStorage(&quot;JNI Weak&quot;,</span>
<span class="udiff-line-removed">-                                         JNIWeakAlloc_lock,</span>
<span class="udiff-line-removed">-                                         JNIWeakActive_lock);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  inline bool is_storage_handle(const OopStorage* storage, const oop* ptr) {
    return storage-&gt;allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -307,10 +299,12 @@</span>
                 weak_global_handles()-&gt;allocation_count());
    st-&gt;cr();
    st-&gt;flush();
  }
  
<span class="udiff-line-added">+ void JNIHandles::print() { print_on(tty); }</span>
<span class="udiff-line-added">+ </span>
  class VerifyJNIHandles: public OopClosure {
  public:
    virtual void do_oop(oop* root) {
      guarantee(oopDesc::is_oop_or_null(RawAccess&lt;&gt;::oop_load(root)), &quot;Invalid oop&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -331,30 +325,43 @@</span>
    return (thread-&gt;is_Java_thread() &amp;&amp;
            JavaThread::current()-&gt;thread_state() == _thread_in_native);
  }
  
  
<span class="udiff-line-removed">- void jni_handles_init() {</span>
<span class="udiff-line-removed">-   JNIHandles::initialize();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  int             JNIHandleBlock::_blocks_allocated     = 0;
  JNIHandleBlock* JNIHandleBlock::_block_free_list      = NULL;
  #ifndef PRODUCT
  JNIHandleBlock* JNIHandleBlock::_block_list           = NULL;
  #endif
  
<span class="udiff-line-added">+ static inline bool is_tagged_free_list(uintptr_t value) {</span>
<span class="udiff-line-added">+   return (value &amp; 1u) != 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline uintptr_t tag_free_list(uintptr_t value) {</span>
<span class="udiff-line-added">+   return value | 1u;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline uintptr_t untag_free_list(uintptr_t value) {</span>
<span class="udiff-line-added">+   return value &amp; ~(uintptr_t)1u;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // There is a freelist of handles running through the JNIHandleBlock</span>
<span class="udiff-line-added">+ // with a tagged next pointer, distinguishing these next pointers from</span>
<span class="udiff-line-added">+ // oops. The freelist handling currently relies on the size of oops</span>
<span class="udiff-line-added">+ // being the same as a native pointer. If this ever changes, then</span>
<span class="udiff-line-added">+ // this freelist handling must change too.</span>
<span class="udiff-line-added">+ STATIC_ASSERT(sizeof(oop) == sizeof(uintptr_t));</span>
  
  #ifdef ASSERT
  void JNIHandleBlock::zap() {
    // Zap block values
    _top = 0;
    for (int index = 0; index &lt; block_size_in_oops; index++) {
      // NOT using Access here; just bare clobbering to NULL, since the
      // block no longer contains valid oops.
<span class="udiff-line-modified-removed">-     _handles[index] = NULL;</span>
<span class="udiff-line-modified-added">+     _handles[index] = 0;</span>
    }
  }
  #endif // ASSERT
  
  JNIHandleBlock* JNIHandleBlock::allocate_block(Thread* thread)  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -369,12 +376,12 @@</span>
    else {
      // locking with safepoint checking introduces a potential deadlock:
      // - we would hold JNIHandleBlockFreeList_lock and then Threads_lock
      // - another would hold Threads_lock (jni_AttachCurrentThread) and then
      //   JNIHandleBlockFreeList_lock (JNIHandleBlock::allocate_block)
<span class="udiff-line-modified-removed">-     MutexLockerEx ml(JNIHandleBlockFreeList_lock,</span>
<span class="udiff-line-modified-removed">-                      Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker ml(JNIHandleBlockFreeList_lock,</span>
<span class="udiff-line-modified-added">+                    Mutex::_no_safepoint_check_flag);</span>
      if (_block_free_list == NULL) {
        // Allocate new block
        block = new JNIHandleBlock();
        _blocks_allocated++;
        block-&gt;zap();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -425,12 +432,12 @@</span>
      // Return blocks to free list
      // locking with safepoint checking introduces a potential deadlock:
      // - we would hold JNIHandleBlockFreeList_lock and then Threads_lock
      // - another would hold Threads_lock (jni_AttachCurrentThread) and then
      //   JNIHandleBlockFreeList_lock (JNIHandleBlock::allocate_block)
<span class="udiff-line-modified-removed">-     MutexLockerEx ml(JNIHandleBlockFreeList_lock,</span>
<span class="udiff-line-modified-removed">-                      Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker ml(JNIHandleBlockFreeList_lock,</span>
<span class="udiff-line-modified-added">+                    Mutex::_no_safepoint_check_flag);</span>
      while (block != NULL) {
        block-&gt;zap();
        JNIHandleBlock* next = block-&gt;_next;
        block-&gt;_next = _block_free_list;
        _block_free_list = block;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -454,15 +461,16 @@</span>
      for (JNIHandleBlock* current = current_chain; current != NULL;
           current = current-&gt;_next) {
        assert(current == current_chain || current-&gt;pop_frame_link() == NULL,
          &quot;only blocks first in chain should have pop frame link set&quot;);
        for (int index = 0; index &lt; current-&gt;_top; index++) {
<span class="udiff-line-modified-removed">-         oop* root = &amp;(current-&gt;_handles)[index];</span>
<span class="udiff-line-modified-removed">-         oop value = *root;</span>
<span class="udiff-line-modified-added">+         uintptr_t* addr = &amp;(current-&gt;_handles)[index];</span>
<span class="udiff-line-modified-added">+         uintptr_t value = *addr;</span>
          // traverse heap pointers only, not deleted handles or free list
          // pointers
<span class="udiff-line-modified-removed">-         if (value != NULL &amp;&amp; Universe::heap()-&gt;is_in_reserved(value)) {</span>
<span class="udiff-line-modified-added">+         if (value != 0 &amp;&amp; !is_tagged_free_list(value)) {</span>
<span class="udiff-line-added">+           oop* root = (oop*)addr;</span>
            f-&gt;do_oop(root);
          }
        }
        // the next handle block is valid only if current block is full
        if (current-&gt;_top &lt; block_size_in_oops) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -473,11 +481,11 @@</span>
    }
  }
  
  
  jobject JNIHandleBlock::allocate_handle(oop obj) {
<span class="udiff-line-modified-removed">-   assert(Universe::heap()-&gt;is_in_reserved(obj), &quot;sanity check&quot;);</span>
<span class="udiff-line-modified-added">+   assert(Universe::heap()-&gt;is_in(obj), &quot;sanity check&quot;);</span>
    if (_top == 0) {
      // This is the first allocation or the initial block got zapped when
      // entering a native function. If we have any following blocks they are
      // not valid anymore.
      for (JNIHandleBlock* current = _next; current != NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -504,19 +512,19 @@</span>
      zap();
    }
  
    // Try last block
    if (_last-&gt;_top &lt; block_size_in_oops) {
<span class="udiff-line-modified-removed">-     oop* handle = &amp;(_last-&gt;_handles)[_last-&gt;_top++];</span>
<span class="udiff-line-modified-added">+     oop* handle = (oop*)&amp;(_last-&gt;_handles)[_last-&gt;_top++];</span>
      NativeAccess&lt;IS_DEST_UNINITIALIZED&gt;::oop_store(handle, obj);
      return (jobject) handle;
    }
  
    // Try free list
    if (_free_list != NULL) {
<span class="udiff-line-modified-removed">-     oop* handle = _free_list;</span>
<span class="udiff-line-modified-removed">-     _free_list = (oop*) *_free_list;</span>
<span class="udiff-line-modified-added">+     oop* handle = (oop*)_free_list;</span>
<span class="udiff-line-modified-added">+     _free_list = (uintptr_t*) untag_free_list(*_free_list);</span>
      NativeAccess&lt;IS_DEST_UNINITIALIZED&gt;::oop_store(handle, obj);
      return (jobject) handle;
    }
    // Check if unused block follow last
    if (_last-&gt;_next != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -545,14 +553,14 @@</span>
    assert(_allocate_before_rebuild == 0 &amp;&amp; _free_list == NULL, &quot;just checking&quot;);
    int free = 0;
    int blocks = 0;
    for (JNIHandleBlock* current = this; current != NULL; current = current-&gt;_next) {
      for (int index = 0; index &lt; current-&gt;_top; index++) {
<span class="udiff-line-modified-removed">-       oop* handle = &amp;(current-&gt;_handles)[index];</span>
<span class="udiff-line-modified-removed">-       if (*handle == NULL) {</span>
<span class="udiff-line-modified-added">+       uintptr_t* handle = &amp;(current-&gt;_handles)[index];</span>
<span class="udiff-line-modified-added">+       if (*handle == 0) {</span>
          // this handle was cleared out by a delete call, reuse it
<span class="udiff-line-modified-removed">-         *handle = (oop) _free_list;</span>
<span class="udiff-line-modified-added">+         *handle = _free_list == NULL ? 0 : tag_free_list((uintptr_t)_free_list);</span>
          _free_list = handle;
          free++;
        }
      }
      // we should not rebuild free list if there are unused handles at the end
</pre>
<center><a href="javaCalls.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniHandles.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
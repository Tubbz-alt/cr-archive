<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/runtime/perfMemory.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;memory/allocation.inline.hpp&quot;
 29 #include &quot;runtime/arguments.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;runtime/mutex.hpp&quot;
 33 #include &quot;runtime/mutexLocker.hpp&quot;
 34 #include &quot;runtime/os.hpp&quot;
 35 #include &quot;runtime/perfData.hpp&quot;
 36 #include &quot;runtime/perfMemory.hpp&quot;
 37 #include &quot;runtime/safepoint.hpp&quot;
 38 #include &quot;runtime/statSampler.hpp&quot;
 39 #include &quot;utilities/align.hpp&quot;
 40 #include &quot;utilities/globalDefinitions.hpp&quot;
 41 
 42 // Prefix of performance data file.
 43 const char               PERFDATA_NAME[] = &quot;hsperfdata&quot;;
 44 
 45 // Add 1 for the &#39;_&#39; character between PERFDATA_NAME and pid. The &#39;\0&#39; terminating
 46 // character will be included in the sizeof(PERFDATA_NAME) operation.
 47 static const size_t PERFDATA_FILENAME_LEN = sizeof(PERFDATA_NAME) +
 48                                             UINT_CHARS + 1;
 49 
 50 char*                    PerfMemory::_start = NULL;
 51 char*                    PerfMemory::_end = NULL;
 52 char*                    PerfMemory::_top = NULL;
 53 size_t                   PerfMemory::_capacity = 0;
 54 int                      PerfMemory::_initialized = false;
 55 PerfDataPrologue*        PerfMemory::_prologue = NULL;
 56 bool                     PerfMemory::_destroyed = false;
 57 
 58 void perfMemory_init() {
 59 
 60   if (!UsePerfData) return;
 61 
 62   PerfMemory::initialize();
 63 }
 64 
 65 void perfMemory_exit() {
 66 
 67   if (!UsePerfData) return;
 68   if (!PerfMemory::is_usable()) return;
 69 
 70   // Only destroy PerfData objects if we&#39;re at a safepoint and the
 71   // StatSampler is not active. Otherwise, we risk removing PerfData
 72   // objects that are currently being used by running JavaThreads
 73   // or the StatSampler. This method is invoked while we are not at
 74   // a safepoint during a VM abort so leaving the PerfData objects
 75   // around may also help diagnose the failure. In rare cases,
 76   // PerfData objects are used in parallel with a safepoint. See
 77   // the work around in PerfDataManager::destroy().
 78   //
 79   if (SafepointSynchronize::is_at_safepoint() &amp;&amp; !StatSampler::is_active()) {
 80     PerfDataManager::destroy();
 81   }
 82 
 83   // Remove the persistent external resources, if any. This method
 84   // does not unmap or invalidate any virtual memory allocated during
 85   // initialization.
 86   //
 87   PerfMemory::destroy();
 88 }
 89 
 90 void PerfMemory::initialize() {
 91 
 92   if (is_initialized())
 93     // initialization already performed
 94     return;
 95 
 96   size_t capacity = align_up(PerfDataMemorySize,
 97                              os::vm_allocation_granularity());
 98 
 99   log_debug(perf, memops)(&quot;PerfDataMemorySize = &quot; SIZE_FORMAT &quot;,&quot;
100                           &quot; os::vm_allocation_granularity = %d,&quot;
101                           &quot; adjusted size = &quot; SIZE_FORMAT,
102                           PerfDataMemorySize,
103                           os::vm_allocation_granularity(),
104                           capacity);
105 
106   // allocate PerfData memory region
107   create_memory_region(capacity);
108 
109   if (_start == NULL) {
110 
111     // the PerfMemory region could not be created as desired. Rather
112     // than terminating the JVM, we revert to creating the instrumentation
113     // on the C heap. When running in this mode, external monitoring
114     // clients cannot attach to and monitor this JVM.
115     //
116     // the warning is issued only in debug mode in order to avoid
117     // additional output to the stdout or stderr output streams.
118     //
119     if (PrintMiscellaneous &amp;&amp; Verbose) {
120       warning(&quot;Could not create PerfData Memory region, reverting to malloc&quot;);
121     }
122 
123     _prologue = NEW_C_HEAP_OBJ(PerfDataPrologue, mtInternal);
124   }
125   else {
126 
127     // the PerfMemory region was created as expected.
128 
129     log_debug(perf, memops)(&quot;PerfMemory created: address = &quot; INTPTR_FORMAT &quot;,&quot;
130                             &quot; size = &quot; SIZE_FORMAT,
131                             p2i(_start),
132                             _capacity);
133 
134     _prologue = (PerfDataPrologue *)_start;
135     _end = _start + _capacity;
136     _top = _start + sizeof(PerfDataPrologue);
137   }
138 
139   assert(_prologue != NULL, &quot;prologue pointer must be initialized&quot;);
140 
141 #ifdef VM_LITTLE_ENDIAN
142   _prologue-&gt;magic = (jint)0xc0c0feca;
143   _prologue-&gt;byte_order = PERFDATA_LITTLE_ENDIAN;
144 #else
145   _prologue-&gt;magic = (jint)0xcafec0c0;
146   _prologue-&gt;byte_order = PERFDATA_BIG_ENDIAN;
147 #endif
148 
149   _prologue-&gt;major_version = PERFDATA_MAJOR_VERSION;
150   _prologue-&gt;minor_version = PERFDATA_MINOR_VERSION;
151   _prologue-&gt;accessible = 0;
152 
153   _prologue-&gt;entry_offset = sizeof(PerfDataPrologue);
154   _prologue-&gt;num_entries = 0;
155   _prologue-&gt;used = 0;
156   _prologue-&gt;overflow = 0;
157   _prologue-&gt;mod_time_stamp = 0;
158 
159   Atomic::release_store(&amp;_initialized, 1);
160 }
161 
162 void PerfMemory::destroy() {
163 
164   if (!is_usable()) return;
165 
166   if (_start != NULL &amp;&amp; _prologue-&gt;overflow != 0) {
167 
168     // This state indicates that the contiguous memory region exists and
169     // that it wasn&#39;t large enough to hold all the counters. In this case,
170     // we output a warning message to the user on exit if the -XX:+Verbose
171     // flag is set (a debug only flag). External monitoring tools can detect
172     // this condition by monitoring the _prologue-&gt;overflow word.
173     //
174     // There are two tunables that can help resolve this issue:
175     //   - increase the size of the PerfMemory with -XX:PerfDataMemorySize=&lt;n&gt;
176     //   - decrease the maximum string constant length with
177     //     -XX:PerfMaxStringConstLength=&lt;n&gt;
178     //
179     if (PrintMiscellaneous &amp;&amp; Verbose) {
180       warning(&quot;PerfMemory Overflow Occurred.\n&quot;
181               &quot;\tCapacity = &quot; SIZE_FORMAT &quot; bytes&quot;
182               &quot;  Used = &quot; SIZE_FORMAT &quot; bytes&quot;
183               &quot;  Overflow = &quot; INT32_FORMAT &quot; bytes&quot;
184               &quot;\n\tUse -XX:PerfDataMemorySize=&lt;size&gt; to specify larger size.&quot;,
185               PerfMemory::capacity(),
186               PerfMemory::used(),
187               _prologue-&gt;overflow);
188     }
189   }
190 
191   if (_start != NULL) {
192 
193     // this state indicates that the contiguous memory region was successfully
194     // and that persistent resources may need to be cleaned up. This is
195     // expected to be the typical condition.
196     //
197     delete_memory_region();
198   }
199 
200   _destroyed = true;
201 }
202 
203 // allocate an aligned block of memory from the PerfData memory
204 // region. This method assumes that the PerfData memory region
205 // was aligned on a double word boundary when created.
206 //
207 char* PerfMemory::alloc(size_t size) {
208 
209   if (!UsePerfData) return NULL;
210 
211   MutexLocker ml(PerfDataMemAlloc_lock);
212 
213   assert(is_usable(), &quot;called before init or after destroy&quot;);
214 
215   // check that there is enough memory for this request
216   if ((_top + size) &gt;= _end) {
217 
218     _prologue-&gt;overflow += (jint)size;
219 
220     return NULL;
221   }
222 
223   char* result = _top;
224 
225   _top += size;
226 
227   assert(contains(result), &quot;PerfData memory pointer out of range&quot;);
228 
229   _prologue-&gt;used = (jint)used();
230   _prologue-&gt;num_entries = _prologue-&gt;num_entries + 1;
231 
232   return result;
233 }
234 
235 void PerfMemory::mark_updated() {
236   if (!UsePerfData) return;
237 
238   assert(is_usable(), &quot;called before init or after destroy&quot;);
239 
240   _prologue-&gt;mod_time_stamp = os::elapsed_counter();
241 }
242 
243 // Returns the complete path including the file name of performance data file.
244 // Caller is expected to release the allocated memory.
245 char* PerfMemory::get_perfdata_file_path() {
246   char* dest_file = NULL;
247 
248   if (PerfDataSaveFile != NULL) {
249     // dest_file_name stores the validated file name if file_name
250     // contains %p which will be replaced by pid.
251     dest_file = NEW_C_HEAP_ARRAY(char, JVM_MAXPATHLEN, mtInternal);
252     if(!Arguments::copy_expand_pid(PerfDataSaveFile, strlen(PerfDataSaveFile),
253                                    dest_file, JVM_MAXPATHLEN)) {
254       FREE_C_HEAP_ARRAY(char, dest_file);
255       if (PrintMiscellaneous &amp;&amp; Verbose) {
256         warning(&quot;Invalid performance data file path name specified, &quot;\
257                 &quot;fall back to a default name&quot;);
258       }
259     } else {
260       return dest_file;
261     }
262   }
263   // create the name of the file for retaining the instrumentation memory.
264   dest_file = NEW_C_HEAP_ARRAY(char, PERFDATA_FILENAME_LEN, mtInternal);
265   jio_snprintf(dest_file, PERFDATA_FILENAME_LEN,
266                &quot;%s_%d&quot;, PERFDATA_NAME, os::current_process_id());
267 
268   return dest_file;
269 }
270 
271 bool PerfMemory::is_initialized() {
272   return Atomic::load_acquire(&amp;_initialized) != 0;
273 }
    </pre>
  </body>
</html>
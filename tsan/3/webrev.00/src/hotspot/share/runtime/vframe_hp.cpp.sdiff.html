<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/vframe_hp.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vframeArray.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/vframe_hp.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 80 
 81 
 82 void compiledVFrame::set_locals(StackValueCollection* values) const {
 83 
 84   fatal(&quot;Should use update_local for each local update&quot;);
 85 }
 86 
 87 void compiledVFrame::update_local(BasicType type, int index, jvalue value) {
 88   assert(index &gt;= 0 &amp;&amp; index &lt; method()-&gt;max_locals(), &quot;out of bounds&quot;);
 89   update_deferred_value(type, index, value);
 90 }
 91 
 92 void compiledVFrame::update_stack(BasicType type, int index, jvalue value) {
 93   assert(index &gt;= 0 &amp;&amp; index &lt; method()-&gt;max_stack(), &quot;out of bounds&quot;);
 94   update_deferred_value(type, index + method()-&gt;max_locals(), value);
 95 }
 96 
 97 void compiledVFrame::update_monitor(int index, MonitorInfo* val) {
 98   assert(index &gt;= 0, &quot;out of bounds&quot;);
 99   jvalue value;
<span class="line-modified">100   value.l = (jobject) val-&gt;owner();</span>
101   update_deferred_value(T_OBJECT, index + method()-&gt;max_locals() + method()-&gt;max_stack(), value);
102 }
103 
104 void compiledVFrame::update_deferred_value(BasicType type, int index, jvalue value) {
<span class="line-modified">105   assert(fr().is_deoptimized_frame() || thread()-&gt;must_deopt_id() == fr().id(),</span>
<span class="line-removed">106          &quot;frame must be scheduled for deoptimization&quot;);</span>
107   GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt;* deferred = thread()-&gt;deferred_locals();
108   jvmtiDeferredLocalVariableSet* locals = NULL;
109   if (deferred != NULL ) {
110     // See if this vframe has already had locals with deferred writes
111     for (int f = 0; f &lt; deferred-&gt;length(); f++ ) {
112       if (deferred-&gt;at(f)-&gt;matches(this)) {
113         locals = deferred-&gt;at(f);
114         break;
115       }
116     }
117     // No matching vframe must push a new vframe
118   } else {
119     // No deferred updates pending for this thread.
120     // allocate in C heap
121     deferred =  new(ResourceObj::C_HEAP, mtCompiler) GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt; (1, true);
122     thread()-&gt;set_deferred_locals(deferred);
123   }
124   if (locals == NULL) {
125     locals = new jvmtiDeferredLocalVariableSet(method(), bci(), fr().id(), vframe_id());
126     deferred-&gt;push(locals);
</pre>
</td>
<td>
<hr />
<pre>
 80 
 81 
 82 void compiledVFrame::set_locals(StackValueCollection* values) const {
 83 
 84   fatal(&quot;Should use update_local for each local update&quot;);
 85 }
 86 
 87 void compiledVFrame::update_local(BasicType type, int index, jvalue value) {
 88   assert(index &gt;= 0 &amp;&amp; index &lt; method()-&gt;max_locals(), &quot;out of bounds&quot;);
 89   update_deferred_value(type, index, value);
 90 }
 91 
 92 void compiledVFrame::update_stack(BasicType type, int index, jvalue value) {
 93   assert(index &gt;= 0 &amp;&amp; index &lt; method()-&gt;max_stack(), &quot;out of bounds&quot;);
 94   update_deferred_value(type, index + method()-&gt;max_locals(), value);
 95 }
 96 
 97 void compiledVFrame::update_monitor(int index, MonitorInfo* val) {
 98   assert(index &gt;= 0, &quot;out of bounds&quot;);
 99   jvalue value;
<span class="line-modified">100   value.l = cast_from_oop&lt;jobject&gt;(val-&gt;owner());</span>
101   update_deferred_value(T_OBJECT, index + method()-&gt;max_locals() + method()-&gt;max_stack(), value);
102 }
103 
104 void compiledVFrame::update_deferred_value(BasicType type, int index, jvalue value) {
<span class="line-modified">105   assert(fr().is_deoptimized_frame(), &quot;frame must be scheduled for deoptimization&quot;);</span>

106   GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt;* deferred = thread()-&gt;deferred_locals();
107   jvmtiDeferredLocalVariableSet* locals = NULL;
108   if (deferred != NULL ) {
109     // See if this vframe has already had locals with deferred writes
110     for (int f = 0; f &lt; deferred-&gt;length(); f++ ) {
111       if (deferred-&gt;at(f)-&gt;matches(this)) {
112         locals = deferred-&gt;at(f);
113         break;
114       }
115     }
116     // No matching vframe must push a new vframe
117   } else {
118     // No deferred updates pending for this thread.
119     // allocate in C heap
120     deferred =  new(ResourceObj::C_HEAP, mtCompiler) GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt; (1, true);
121     thread()-&gt;set_deferred_locals(deferred);
122   }
123   if (locals == NULL) {
124     locals = new jvmtiDeferredLocalVariableSet(method(), bci(), fr().id(), vframe_id());
125     deferred-&gt;push(locals);
</pre>
</td>
</tr>
</table>
<center><a href="vframeArray.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
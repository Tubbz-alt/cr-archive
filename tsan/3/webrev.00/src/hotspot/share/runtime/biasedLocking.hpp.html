<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/runtime/biasedLocking.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_BIASEDLOCKING_HPP
 26 #define SHARE_RUNTIME_BIASEDLOCKING_HPP
 27 
 28 #include &quot;runtime/handles.hpp&quot;
 29 #include &quot;utilities/growableArray.hpp&quot;
 30 
 31 // This class describes operations to implement Store-Free Biased
 32 // Locking. The high-level properties of the scheme are similar to
 33 // IBM&#39;s lock reservation, Dice-Moir-Scherer QR locks, and other biased
 34 // locking mechanisms. The principal difference is in the handling of
 35 // recursive locking which is how this technique achieves a more
 36 // efficient fast path than these other schemes.
 37 //
 38 // The basic observation is that in HotSpot&#39;s current fast locking
 39 // scheme, recursive locking (in the fast path) causes no update to
 40 // the object header. The recursion is described simply by stack
 41 // records containing a specific value (NULL). Only the last unlock by
 42 // a given thread causes an update to the object header.
 43 //
 44 // This observation, coupled with the fact that HotSpot only compiles
 45 // methods for which monitor matching is obeyed (and which therefore
 46 // can not throw IllegalMonitorStateException), implies that we can
 47 // completely eliminate modifications to the object header for
 48 // recursive locking in compiled code, and perform similar recursion
 49 // checks and throwing of IllegalMonitorStateException in the
 50 // interpreter with little or no impact on the performance of the fast
 51 // path.
 52 //
 53 // The basic algorithm is as follows (note, see below for more details
 54 // and information). A pattern in the low three bits is reserved in
 55 // the object header to indicate whether biasing of a given object&#39;s
 56 // lock is currently being done or is allowed at all.  If the bias
 57 // pattern is present, the contents of the rest of the header are
 58 // either the JavaThread* of the thread to which the lock is biased,
 59 // or NULL, indicating that the lock is &quot;anonymously biased&quot;. The
 60 // first thread which locks an anonymously biased object biases the
 61 // lock toward that thread. If another thread subsequently attempts to
 62 // lock the same object, the bias is revoked.
 63 //
 64 // Because there are no updates to the object header at all during
 65 // recursive locking while the lock is biased, the biased lock entry
 66 // code is simply a test of the object header&#39;s value. If this test
 67 // succeeds, the lock has been acquired by the thread. If this test
 68 // fails, a bit test is done to see whether the bias bit is still
 69 // set. If not, we fall back to HotSpot&#39;s original CAS-based locking
 70 // scheme. If it is set, we attempt to CAS in a bias toward this
 71 // thread. The latter operation is expected to be the rarest operation
 72 // performed on these locks. We optimistically expect the biased lock
 73 // entry to hit most of the time, and want the CAS-based fallthrough
 74 // to occur quickly in the situations where the bias has been revoked.
 75 //
 76 // Revocation of the lock&#39;s bias is fairly straightforward. We want to
 77 // restore the object&#39;s header and stack-based BasicObjectLocks and
 78 // BasicLocks to the state they would have been in had the object been
 79 // locked by HotSpot&#39;s usual fast locking scheme. To do this, we execute
 80 // a handshake with the JavaThread that biased the lock. Inside the
 81 // handshake we walk the biaser stack searching for all of the lock
 82 // records corresponding to this object, in particular the first / &quot;highest&quot;
 83 // record. We fill in the highest lock record with the object&#39;s displaced
 84 // header (which is a well-known value given that we don&#39;t maintain an
 85 // identity hash nor age bits for the object while it&#39;s in the biased
 86 // state) and all other lock records with 0, the value for recursive locks.
 87 // Alternatively, we can revoke the bias of an object inside a safepoint
 88 // if we are already in one and we detect that we need to perform a
 89 // revocation.
 90 //
 91 // This scheme can not handle transfers of biases of single objects
 92 // from thread to thread efficiently, but it can handle bulk transfers
 93 // of such biases, which is a usage pattern showing up in some
 94 // applications and benchmarks. We implement &quot;bulk rebias&quot; and &quot;bulk
 95 // revoke&quot; operations using a &quot;bias epoch&quot; on a per-data-type basis.
 96 // If too many bias revocations are occurring for a particular data
 97 // type, the bias epoch for the data type is incremented at a
 98 // safepoint, effectively meaning that all previous biases are
 99 // invalid. The fast path locking case checks for an invalid epoch in
100 // the object header and attempts to rebias the object with a CAS if
101 // found, avoiding safepoints or bulk heap sweeps (the latter which
102 // was used in a prior version of this algorithm and did not scale
103 // well). If too many bias revocations persist, biasing is completely
104 // disabled for the data type by resetting the prototype header to the
105 // unbiased markWord. The fast-path locking code checks to see whether
106 // the instance&#39;s bias pattern differs from the prototype header&#39;s and
107 // causes the bias to be revoked without reaching a safepoint or,
108 // again, a bulk heap sweep.
109 
110 // Biased locking counters
111 class BiasedLockingCounters {
112  private:
113   int _total_entry_count;
114   int _biased_lock_entry_count;
115   int _anonymously_biased_lock_entry_count;
116   int _rebiased_lock_entry_count;
117   int _revoked_lock_entry_count;
118   int _handshakes_count;
119   int _fast_path_entry_count;
120   int _slow_path_entry_count;
121 
122  public:
123   BiasedLockingCounters() :
124     _total_entry_count(0),
125     _biased_lock_entry_count(0),
126     _anonymously_biased_lock_entry_count(0),
127     _rebiased_lock_entry_count(0),
128     _revoked_lock_entry_count(0),
129     _handshakes_count(0),
130     _fast_path_entry_count(0),
131     _slow_path_entry_count(0) {}
132 
133   int slow_path_entry_count() const; // Compute this field if necessary
134 
135   int* total_entry_count_addr()                   { return &amp;_total_entry_count; }
136   int* biased_lock_entry_count_addr()             { return &amp;_biased_lock_entry_count; }
137   int* anonymously_biased_lock_entry_count_addr() { return &amp;_anonymously_biased_lock_entry_count; }
138   int* rebiased_lock_entry_count_addr()           { return &amp;_rebiased_lock_entry_count; }
139   int* revoked_lock_entry_count_addr()            { return &amp;_revoked_lock_entry_count; }
140   int* handshakes_count_addr()                    { return &amp;_handshakes_count; }
141   int* fast_path_entry_count_addr()               { return &amp;_fast_path_entry_count; }
142   int* slow_path_entry_count_addr()               { return &amp;_slow_path_entry_count; }
143 
144   bool nonzero() { return _total_entry_count &gt; 0; }
145 
146   void print_on(outputStream* st) const;
147   void print() const;
148 };
149 
150 
151 class BiasedLocking : AllStatic {
152 friend class VM_BulkRevokeBias;
153 friend class RevokeOneBias;
154 
155 private:
156   static BiasedLockingCounters _counters;
157 
158 public:
159   static int* total_entry_count_addr();
160   static int* biased_lock_entry_count_addr();
161   static int* anonymously_biased_lock_entry_count_addr();
162   static int* rebiased_lock_entry_count_addr();
163   static int* revoked_lock_entry_count_addr();
164   static int* handshakes_count_addr();
165   static int* fast_path_entry_count_addr();
166   static int* slow_path_entry_count_addr();
167 
168   enum Condition {
169     NOT_BIASED = 1,
170     BIAS_REVOKED = 2,
171     NOT_REVOKED = 3
172   };
173 
174 private:
175   static void single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requester, JavaThread** biaser);
176   static void bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requester);
177   static Condition single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser);
178   static void walk_stack_and_revoke(oop obj, JavaThread* biased_locker);
179 
180 public:
181   // This initialization routine should only be called once and
182   // schedules a PeriodicTask to turn on biased locking a few seconds
183   // into the VM run to avoid startup time regressions
184   static void init();
185 
186   // This provides a global switch for leaving biased locking disabled
187   // for the first part of a run and enabling it later
188   static bool enabled();
189 
190   // This should be called by JavaThreads to revoke the bias of an object
191   static void revoke(Handle obj, TRAPS);
192 
193   // This must only be called by a JavaThread to revoke the bias of an owned object.
194   static void revoke_own_lock(Handle obj, TRAPS);
195 
196   static void revoke_at_safepoint(Handle obj);
197 
198   // These are used by deoptimization to ensure that monitors on the stack
199   // can be migrated
200   static void revoke(GrowableArray&lt;Handle&gt;* objs, JavaThread *biaser);
201 
202   static void print_counters() { _counters.print(); }
203   static BiasedLockingCounters* counters() { return &amp;_counters; }
204 
205   // These routines are GC-related and should not be called by end
206   // users. GCs which do not do preservation of mark words do not need
207   // to call these routines.
208   static void preserve_marks();
209   static void restore_marks();
210 };
211 
212 #endif // SHARE_RUNTIME_BIASEDLOCKING_HPP
    </pre>
  </body>
</html>
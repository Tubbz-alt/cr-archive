<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/compilationPolicy.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_COMPILATIONPOLICY_HPP
 26 #define SHARE_RUNTIME_COMPILATIONPOLICY_HPP
 27 
 28 #include &quot;code/nmethod.hpp&quot;
 29 #include &quot;compiler/compileBroker.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
 31 #include &quot;runtime/vmOperations.hpp&quot;
 32 #include &quot;utilities/growableArray.hpp&quot;
 33 
 34 // The CompilationPolicy selects which method (if any) should be compiled.
 35 // It also decides which methods must always be compiled (i.e., are never
 36 // interpreted).
 37 class CompileTask;
 38 class CompileQueue;
 39 class RFrame;
 40 
 41 class CompilationPolicy : public CHeapObj&lt;mtCompiler&gt; {
 42   static CompilationPolicy* _policy;
 43 
 44   // m must be compiled before executing it
 45   static bool must_be_compiled(const methodHandle&amp; m, int comp_level = CompLevel_all);
 46 
 47 public:
 48   // If m must_be_compiled then request a compilation from the CompileBroker.
 49   // This supports the -Xcomp option.
 50   static void compile_if_required(const methodHandle&amp; m, TRAPS);
 51 
 52   // m is allowed to be compiled
 53   static bool can_be_compiled(const methodHandle&amp; m, int comp_level = CompLevel_all);
 54   // m is allowed to be osr compiled
 55   static bool can_be_osr_compiled(const methodHandle&amp; m, int comp_level = CompLevel_all);
 56   static bool is_compilation_enabled();
 57   static void set_policy(CompilationPolicy* policy) { _policy = policy; }
 58   static CompilationPolicy* policy()                { return _policy; }
 59 
 60   static CompileTask* select_task_helper(CompileQueue* compile_queue);
 61 
 62   // Return initial compile level that is used with Xcomp
 63   virtual CompLevel initial_compile_level() = 0;
 64   virtual int compiler_count(CompLevel comp_level) = 0;
 65   // main notification entry, return a pointer to an nmethod if the OSR is required,
 66   // returns NULL otherwise.
 67   virtual nmethod* event(const methodHandle&amp; method, const methodHandle&amp; inlinee, int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, JavaThread* thread) = 0;
 68   // safepoint() is called at the end of the safepoint
 69   virtual void do_safepoint_work() = 0;
 70   // reprofile request
 71   virtual void reprofile(ScopeDesc* trap_scope, bool is_osr) = 0;
 72   // delay_compilation(method) can be called by any component of the runtime to notify the policy
 73   // that it&#39;s recommended to delay the compilation of this method.
 74   virtual void delay_compilation(Method* method) = 0;
 75   // disable_compilation() is called whenever the runtime decides to disable compilation of the
 76   // specified method.
 77   virtual void disable_compilation(Method* method) = 0;
 78   // Select task is called by CompileBroker. The queue is guaranteed to have at least one
 79   // element and is locked. The function should select one and return it.
 80   virtual CompileTask* select_task(CompileQueue* compile_queue) = 0;
 81   // Tell the runtime if we think a given method is adequately profiled.
 82   virtual bool is_mature(Method* method) = 0;
 83   // Do policy initialization
 84   virtual void initialize() = 0;
 85   virtual bool should_not_inline(ciEnv* env, ciMethod* method) { return false; }
 86 };
 87 
 88 // A base class for baseline policies.
 89 class NonTieredCompPolicy : public CompilationPolicy {
 90   int _compiler_count;
 91 protected:
 92   static void trace_frequency_counter_overflow(const methodHandle&amp; m, int branch_bci, int bci);
 93   static void trace_osr_request(const methodHandle&amp; method, nmethod* osr, int bci);
 94   static void trace_osr_completion(nmethod* osr_nm);
 95   void reset_counter_for_invocation_event(const methodHandle&amp; method);
 96   void reset_counter_for_back_branch_event(const methodHandle&amp; method);
 97 public:
 98   NonTieredCompPolicy() : _compiler_count(0) { }
 99   virtual CompLevel initial_compile_level() { return CompLevel_highest_tier; }
100   virtual int compiler_count(CompLevel comp_level);
101   virtual void do_safepoint_work();
102   virtual void reprofile(ScopeDesc* trap_scope, bool is_osr);
103   virtual void delay_compilation(Method* method);
104   virtual void disable_compilation(Method* method);
105   virtual bool is_mature(Method* method);
106   virtual void initialize();
107   virtual CompileTask* select_task(CompileQueue* compile_queue);
108   virtual nmethod* event(const methodHandle&amp; method, const methodHandle&amp; inlinee, int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, JavaThread* thread);
109   virtual void method_invocation_event(const methodHandle&amp; m, JavaThread* thread) = 0;
110   virtual void method_back_branch_event(const methodHandle&amp; m, int bci, JavaThread* thread) = 0;
111 };
112 
113 class SimpleCompPolicy : public NonTieredCompPolicy {
114  public:
115   virtual void method_invocation_event(const methodHandle&amp; m, JavaThread* thread);
116   virtual void method_back_branch_event(const methodHandle&amp; m, int bci, JavaThread* thread);
117 };
118 
119 // StackWalkCompPolicy - existing C2 policy
120 
121 #ifdef COMPILER2
122 class StackWalkCompPolicy : public NonTieredCompPolicy {
123  public:
124   virtual void method_invocation_event(const methodHandle&amp; m, JavaThread* thread);
125   virtual void method_back_branch_event(const methodHandle&amp; m, int bci, JavaThread* thread);
126 
127  private:
128   RFrame* findTopInlinableFrame(GrowableArray&lt;RFrame*&gt;* stack);
129   RFrame* senderOf(RFrame* rf, GrowableArray&lt;RFrame*&gt;* stack);
130 
131   // the following variables hold values computed by the last inlining decision
132   // they are used for performance debugging only (print better messages)
133   static const char* _msg;            // reason for not inlining
134 
135   static const char* shouldInline   (const methodHandle&amp; callee, float frequency, int cnt);
136   // positive filter: should send be inlined?  returns NULL (--&gt; yes) or rejection msg
137   static const char* shouldNotInline(const methodHandle&amp; callee);
138   // negative filter: should send NOT be inlined?  returns NULL (--&gt; inline) or rejection msg
139 
140 };
141 #endif
142 
143 #endif // SHARE_RUNTIME_COMPILATIONPOLICY_HPP
    </pre>
  </body>
</html>
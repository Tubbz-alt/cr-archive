<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/biasedLocking.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="biasedLocking.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/biasedLocking.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 74,21 ***</span>
  // to occur quickly in the situations where the bias has been revoked.
  //
  // Revocation of the lock&#39;s bias is fairly straightforward. We want to
  // restore the object&#39;s header and stack-based BasicObjectLocks and
  // BasicLocks to the state they would have been in had the object been
<span class="line-modified">! // locked by HotSpot&#39;s usual fast locking scheme. To do this, we bring</span>
<span class="line-modified">! // the system to a safepoint and walk the stack of the thread toward</span>
<span class="line-modified">! // which the lock is biased. We find all of the lock records on the</span>
<span class="line-modified">! // stack corresponding to this object, in particular the first /</span>
<span class="line-modified">! // &quot;highest&quot; record. We fill in the highest lock record with the</span>
<span class="line-modified">! // object&#39;s displaced header (which is a well-known value given that</span>
<span class="line-modified">! // we don&#39;t maintain an identity hash nor age bits for the object</span>
<span class="line-modified">! // while it&#39;s in the biased state) and all other lock records with 0,</span>
<span class="line-modified">! // the value for recursive locks. When the safepoint is released, the</span>
<span class="line-modified">! // formerly-biased thread and all other threads revert back to</span>
<span class="line-modified">! // HotSpot&#39;s CAS-based locking.</span>
  //
  // This scheme can not handle transfers of biases of single objects
  // from thread to thread efficiently, but it can handle bulk transfers
  // of such biases, which is a usage pattern showing up in some
  // applications and benchmarks. We implement &quot;bulk rebias&quot; and &quot;bulk
<span class="line-new-header">--- 74,21 ---</span>
  // to occur quickly in the situations where the bias has been revoked.
  //
  // Revocation of the lock&#39;s bias is fairly straightforward. We want to
  // restore the object&#39;s header and stack-based BasicObjectLocks and
  // BasicLocks to the state they would have been in had the object been
<span class="line-modified">! // locked by HotSpot&#39;s usual fast locking scheme. To do this, we execute</span>
<span class="line-modified">! // a handshake with the JavaThread that biased the lock. Inside the</span>
<span class="line-modified">! // handshake we walk the biaser stack searching for all of the lock</span>
<span class="line-modified">! // records corresponding to this object, in particular the first / &quot;highest&quot;</span>
<span class="line-modified">! // record. We fill in the highest lock record with the object&#39;s displaced</span>
<span class="line-modified">! // header (which is a well-known value given that we don&#39;t maintain an</span>
<span class="line-modified">! // identity hash nor age bits for the object while it&#39;s in the biased</span>
<span class="line-modified">! // state) and all other lock records with 0, the value for recursive locks.</span>
<span class="line-modified">! // Alternatively, we can revoke the bias of an object inside a safepoint</span>
<span class="line-modified">! // if we are already in one and we detect that we need to perform a</span>
<span class="line-modified">! // revocation.</span>
  //
  // This scheme can not handle transfers of biases of single objects
  // from thread to thread efficiently, but it can handle bulk transfers
  // of such biases, which is a usage pattern showing up in some
  // applications and benchmarks. We implement &quot;bulk rebias&quot; and &quot;bulk
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,11 ***</span>
  // the object header and attempts to rebias the object with a CAS if
  // found, avoiding safepoints or bulk heap sweeps (the latter which
  // was used in a prior version of this algorithm and did not scale
  // well). If too many bias revocations persist, biasing is completely
  // disabled for the data type by resetting the prototype header to the
<span class="line-modified">! // unbiased markOop. The fast-path locking code checks to see whether</span>
  // the instance&#39;s bias pattern differs from the prototype header&#39;s and
  // causes the bias to be revoked without reaching a safepoint or,
  // again, a bulk heap sweep.
  
  // Biased locking counters
<span class="line-new-header">--- 100,11 ---</span>
  // the object header and attempts to rebias the object with a CAS if
  // found, avoiding safepoints or bulk heap sweeps (the latter which
  // was used in a prior version of this algorithm and did not scale
  // well). If too many bias revocations persist, biasing is completely
  // disabled for the data type by resetting the prototype header to the
<span class="line-modified">! // unbiased markWord. The fast-path locking code checks to see whether</span>
  // the instance&#39;s bias pattern differs from the prototype header&#39;s and
  // causes the bias to be revoked without reaching a safepoint or,
  // again, a bulk heap sweep.
  
  // Biased locking counters
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,76 ***</span>
    int _total_entry_count;
    int _biased_lock_entry_count;
    int _anonymously_biased_lock_entry_count;
    int _rebiased_lock_entry_count;
    int _revoked_lock_entry_count;
    int _fast_path_entry_count;
    int _slow_path_entry_count;
  
   public:
    BiasedLockingCounters() :
      _total_entry_count(0),
      _biased_lock_entry_count(0),
      _anonymously_biased_lock_entry_count(0),
      _rebiased_lock_entry_count(0),
      _revoked_lock_entry_count(0),
      _fast_path_entry_count(0),
      _slow_path_entry_count(0) {}
  
<span class="line-modified">!   int slow_path_entry_count(); // Compute this field if necessary</span>
  
    int* total_entry_count_addr()                   { return &amp;_total_entry_count; }
    int* biased_lock_entry_count_addr()             { return &amp;_biased_lock_entry_count; }
    int* anonymously_biased_lock_entry_count_addr() { return &amp;_anonymously_biased_lock_entry_count; }
    int* rebiased_lock_entry_count_addr()           { return &amp;_rebiased_lock_entry_count; }
    int* revoked_lock_entry_count_addr()            { return &amp;_revoked_lock_entry_count; }
    int* fast_path_entry_count_addr()               { return &amp;_fast_path_entry_count; }
    int* slow_path_entry_count_addr()               { return &amp;_slow_path_entry_count; }
  
    bool nonzero() { return _total_entry_count &gt; 0; }
  
<span class="line-modified">!   void print_on(outputStream* st);</span>
<span class="line-modified">!   void print() { print_on(tty); }</span>
  };
  
  
  class BiasedLocking : AllStatic {
  private:
    static BiasedLockingCounters _counters;
  
  public:
    static int* total_entry_count_addr();
    static int* biased_lock_entry_count_addr();
    static int* anonymously_biased_lock_entry_count_addr();
    static int* rebiased_lock_entry_count_addr();
    static int* revoked_lock_entry_count_addr();
    static int* fast_path_entry_count_addr();
    static int* slow_path_entry_count_addr();
  
    enum Condition {
      NOT_BIASED = 1,
      BIAS_REVOKED = 2,
<span class="line-modified">!     BIAS_REVOKED_AND_REBIASED = 3</span>
    };
  
    // This initialization routine should only be called once and
    // schedules a PeriodicTask to turn on biased locking a few seconds
    // into the VM run to avoid startup time regressions
    static void init();
  
    // This provides a global switch for leaving biased locking disabled
    // for the first part of a run and enabling it later
    static bool enabled();
  
    // This should be called by JavaThreads to revoke the bias of an object
<span class="line-modified">!   static Condition revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS);</span>
  
<span class="line-removed">-   // These do not allow rebiasing; they are used by deoptimization to</span>
<span class="line-removed">-   // ensure that monitors on the stack can be migrated</span>
<span class="line-removed">-   static void revoke(GrowableArray&lt;Handle&gt;* objs);</span>
    static void revoke_at_safepoint(Handle obj);
<span class="line-modified">!   static void revoke_at_safepoint(GrowableArray&lt;Handle&gt;* objs);</span>
  
    static void print_counters() { _counters.print(); }
    static BiasedLockingCounters* counters() { return &amp;_counters; }
  
    // These routines are GC-related and should not be called by end
<span class="line-new-header">--- 113,93 ---</span>
    int _total_entry_count;
    int _biased_lock_entry_count;
    int _anonymously_biased_lock_entry_count;
    int _rebiased_lock_entry_count;
    int _revoked_lock_entry_count;
<span class="line-added">+   int _handshakes_count;</span>
    int _fast_path_entry_count;
    int _slow_path_entry_count;
  
   public:
    BiasedLockingCounters() :
      _total_entry_count(0),
      _biased_lock_entry_count(0),
      _anonymously_biased_lock_entry_count(0),
      _rebiased_lock_entry_count(0),
      _revoked_lock_entry_count(0),
<span class="line-added">+     _handshakes_count(0),</span>
      _fast_path_entry_count(0),
      _slow_path_entry_count(0) {}
  
<span class="line-modified">!   int slow_path_entry_count() const; // Compute this field if necessary</span>
  
    int* total_entry_count_addr()                   { return &amp;_total_entry_count; }
    int* biased_lock_entry_count_addr()             { return &amp;_biased_lock_entry_count; }
    int* anonymously_biased_lock_entry_count_addr() { return &amp;_anonymously_biased_lock_entry_count; }
    int* rebiased_lock_entry_count_addr()           { return &amp;_rebiased_lock_entry_count; }
    int* revoked_lock_entry_count_addr()            { return &amp;_revoked_lock_entry_count; }
<span class="line-added">+   int* handshakes_count_addr()                    { return &amp;_handshakes_count; }</span>
    int* fast_path_entry_count_addr()               { return &amp;_fast_path_entry_count; }
    int* slow_path_entry_count_addr()               { return &amp;_slow_path_entry_count; }
  
    bool nonzero() { return _total_entry_count &gt; 0; }
  
<span class="line-modified">!   void print_on(outputStream* st) const;</span>
<span class="line-modified">!   void print() const;</span>
  };
  
  
  class BiasedLocking : AllStatic {
<span class="line-added">+ friend class VM_BulkRevokeBias;</span>
<span class="line-added">+ friend class RevokeOneBias;</span>
<span class="line-added">+ </span>
  private:
    static BiasedLockingCounters _counters;
  
  public:
    static int* total_entry_count_addr();
    static int* biased_lock_entry_count_addr();
    static int* anonymously_biased_lock_entry_count_addr();
    static int* rebiased_lock_entry_count_addr();
    static int* revoked_lock_entry_count_addr();
<span class="line-added">+   static int* handshakes_count_addr();</span>
    static int* fast_path_entry_count_addr();
    static int* slow_path_entry_count_addr();
  
    enum Condition {
      NOT_BIASED = 1,
      BIAS_REVOKED = 2,
<span class="line-modified">!     NOT_REVOKED = 3</span>
    };
  
<span class="line-added">+ private:</span>
<span class="line-added">+   static void single_revoke_at_safepoint(oop obj, bool is_bulk, JavaThread* requester, JavaThread** biaser);</span>
<span class="line-added">+   static void bulk_revoke_at_safepoint(oop o, bool bulk_rebias, JavaThread* requester);</span>
<span class="line-added">+   static Condition single_revoke_with_handshake(Handle obj, JavaThread *requester, JavaThread *biaser);</span>
<span class="line-added">+   static void walk_stack_and_revoke(oop obj, JavaThread* biased_locker);</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
    // This initialization routine should only be called once and
    // schedules a PeriodicTask to turn on biased locking a few seconds
    // into the VM run to avoid startup time regressions
    static void init();
  
    // This provides a global switch for leaving biased locking disabled
    // for the first part of a run and enabling it later
    static bool enabled();
  
    // This should be called by JavaThreads to revoke the bias of an object
<span class="line-modified">!   static void revoke(Handle obj, TRAPS);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // This must only be called by a JavaThread to revoke the bias of an owned object.</span>
<span class="line-added">+   static void revoke_own_lock(Handle obj, TRAPS);</span>
  
    static void revoke_at_safepoint(Handle obj);
<span class="line-modified">! </span>
<span class="line-added">+   // These are used by deoptimization to ensure that monitors on the stack</span>
<span class="line-added">+   // can be migrated</span>
<span class="line-added">+   static void revoke(GrowableArray&lt;Handle&gt;* objs, JavaThread *biaser);</span>
  
    static void print_counters() { _counters.print(); }
    static BiasedLockingCounters* counters() { return &amp;_counters; }
  
    // These routines are GC-related and should not be called by end
</pre>
<center><a href="biasedLocking.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
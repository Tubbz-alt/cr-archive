<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/biasedLocking.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_BIASEDLOCKING_HPP
 26 #define SHARE_RUNTIME_BIASEDLOCKING_HPP
 27 
 28 #include &quot;runtime/handles.hpp&quot;
 29 #include &quot;utilities/growableArray.hpp&quot;
 30 
 31 // This class describes operations to implement Store-Free Biased
 32 // Locking. The high-level properties of the scheme are similar to
 33 // IBM&#39;s lock reservation, Dice-Moir-Scherer QR locks, and other biased
 34 // locking mechanisms. The principal difference is in the handling of
 35 // recursive locking which is how this technique achieves a more
 36 // efficient fast path than these other schemes.
 37 //
 38 // The basic observation is that in HotSpot&#39;s current fast locking
 39 // scheme, recursive locking (in the fast path) causes no update to
 40 // the object header. The recursion is described simply by stack
 41 // records containing a specific value (NULL). Only the last unlock by
 42 // a given thread causes an update to the object header.
 43 //
 44 // This observation, coupled with the fact that HotSpot only compiles
 45 // methods for which monitor matching is obeyed (and which therefore
 46 // can not throw IllegalMonitorStateException), implies that we can
 47 // completely eliminate modifications to the object header for
 48 // recursive locking in compiled code, and perform similar recursion
 49 // checks and throwing of IllegalMonitorStateException in the
 50 // interpreter with little or no impact on the performance of the fast
 51 // path.
 52 //
 53 // The basic algorithm is as follows (note, see below for more details
 54 // and information). A pattern in the low three bits is reserved in
 55 // the object header to indicate whether biasing of a given object&#39;s
 56 // lock is currently being done or is allowed at all.  If the bias
 57 // pattern is present, the contents of the rest of the header are
 58 // either the JavaThread* of the thread to which the lock is biased,
 59 // or NULL, indicating that the lock is &quot;anonymously biased&quot;. The
 60 // first thread which locks an anonymously biased object biases the
 61 // lock toward that thread. If another thread subsequently attempts to
 62 // lock the same object, the bias is revoked.
 63 //
 64 // Because there are no updates to the object header at all during
 65 // recursive locking while the lock is biased, the biased lock entry
 66 // code is simply a test of the object header&#39;s value. If this test
 67 // succeeds, the lock has been acquired by the thread. If this test
 68 // fails, a bit test is done to see whether the bias bit is still
 69 // set. If not, we fall back to HotSpot&#39;s original CAS-based locking
 70 // scheme. If it is set, we attempt to CAS in a bias toward this
 71 // thread. The latter operation is expected to be the rarest operation
 72 // performed on these locks. We optimistically expect the biased lock
 73 // entry to hit most of the time, and want the CAS-based fallthrough
 74 // to occur quickly in the situations where the bias has been revoked.
 75 //
 76 // Revocation of the lock&#39;s bias is fairly straightforward. We want to
 77 // restore the object&#39;s header and stack-based BasicObjectLocks and
 78 // BasicLocks to the state they would have been in had the object been
<a name="1" id="anc1"></a><span class="line-modified"> 79 // locked by HotSpot&#39;s usual fast locking scheme. To do this, we bring</span>
<span class="line-modified"> 80 // the system to a safepoint and walk the stack of the thread toward</span>
<span class="line-modified"> 81 // which the lock is biased. We find all of the lock records on the</span>
<span class="line-modified"> 82 // stack corresponding to this object, in particular the first /</span>
<span class="line-modified"> 83 // &quot;highest&quot; record. We fill in the highest lock record with the</span>
<span class="line-modified"> 84 // object&#39;s displaced header (which is a well-known value given that</span>
<span class="line-modified"> 85 // we don&#39;t maintain an identity hash nor age bits for the object</span>
<span class="line-modified"> 86 // while it&#39;s in the biased state) and all other lock records with 0,</span>
<span class="line-modified"> 87 // the value for recursive locks. When the safepoint is released, the</span>
<span class="line-modified"> 88 // formerly-biased thread and all other threads revert back to</span>
<span class="line-modified"> 89 // HotSpot&#39;s CAS-based locking.</span>
 90 //
 91 // This scheme can not handle transfers of biases of single objects
 92 // from thread to thread efficiently, but it can handle bulk transfers
 93 // of such biases, which is a usage pattern showing up in some
 94 // applications and benchmarks. We implement &quot;bulk rebias&quot; and &quot;bulk
 95 // revoke&quot; operations using a &quot;bias epoch&quot; on a per-data-type basis.
 96 // If too many bias revocations are occurring for a particular data
 97 // type, the bias epoch for the data type is incremented at a
 98 // safepoint, effectively meaning that all previous biases are
 99 // invalid. The fast path locking case checks for an invalid epoch in
100 // the object header and attempts to rebias the object with a CAS if
101 // found, avoiding safepoints or bulk heap sweeps (the latter which
102 // was used in a prior version of this algorithm and did not scale
103 // well). If too many bias revocations persist, biasing is completely
104 // disabled for the data type by resetting the prototype header to the
<a name="2" id="anc2"></a><span class="line-modified">105 // unbiased markOop. The fast-path locking code checks to see whether</span>
106 // the instance&#39;s bias pattern differs from the prototype header&#39;s and
107 // causes the bias to be revoked without reaching a safepoint or,
108 // again, a bulk heap sweep.
109 
110 // Biased locking counters
111 class BiasedLockingCounters {
112  private:
113   int _total_entry_count;
114   int _biased_lock_entry_count;
115   int _anonymously_biased_lock_entry_count;
116   int _rebiased_lock_entry_count;
117   int _revoked_lock_entry_count;
<a name="3" id="anc3"></a>
118   int _fast_path_entry_count;
119   int _slow_path_entry_count;
120 
121  public:
122   BiasedLockingCounters() :
123     _total_entry_count(0),
124     _biased_lock_entry_count(0),
125     _anonymously_biased_lock_entry_count(0),
126     _rebiased_lock_entry_count(0),
127     _revoked_lock_entry_count(0),
<a name="4" id="anc4"></a>
128     _fast_path_entry_count(0),
129     _slow_path_entry_count(0) {}
130 
<a name="5" id="anc5"></a><span class="line-modified">131   int slow_path_entry_count(); // Compute this field if necessary</span>
132 
133   int* total_entry_count_addr()                   { return &amp;_total_entry_count; }
134   int* biased_lock_entry_count_addr()             { return &amp;_biased_lock_entry_count; }
135   int* anonymously_biased_lock_entry_count_addr() { return &amp;_anonymously_biased_lock_entry_count; }
136   int* rebiased_lock_entry_count_addr()           { return &amp;_rebiased_lock_entry_count; }
137   int* revoked_lock_entry_count_addr()            { return &amp;_revoked_lock_entry_count; }
<a name="6" id="anc6"></a>
138   int* fast_path_entry_count_addr()               { return &amp;_fast_path_entry_count; }
139   int* slow_path_entry_count_addr()               { return &amp;_slow_path_entry_count; }
140 
141   bool nonzero() { return _total_entry_count &gt; 0; }
142 
<a name="7" id="anc7"></a><span class="line-modified">143   void print_on(outputStream* st);</span>
<span class="line-modified">144   void print() { print_on(tty); }</span>
145 };
146 
147 
148 class BiasedLocking : AllStatic {
<a name="8" id="anc8"></a>


149 private:
150   static BiasedLockingCounters _counters;
151 
152 public:
153   static int* total_entry_count_addr();
154   static int* biased_lock_entry_count_addr();
155   static int* anonymously_biased_lock_entry_count_addr();
156   static int* rebiased_lock_entry_count_addr();
157   static int* revoked_lock_entry_count_addr();
<a name="9" id="anc9"></a>
158   static int* fast_path_entry_count_addr();
159   static int* slow_path_entry_count_addr();
160 
161   enum Condition {
162     NOT_BIASED = 1,
163     BIAS_REVOKED = 2,
<a name="10" id="anc10"></a><span class="line-modified">164     BIAS_REVOKED_AND_REBIASED = 3</span>
165   };
166 
<a name="11" id="anc11"></a>






167   // This initialization routine should only be called once and
168   // schedules a PeriodicTask to turn on biased locking a few seconds
169   // into the VM run to avoid startup time regressions
170   static void init();
171 
172   // This provides a global switch for leaving biased locking disabled
173   // for the first part of a run and enabling it later
174   static bool enabled();
175 
176   // This should be called by JavaThreads to revoke the bias of an object
<a name="12" id="anc12"></a><span class="line-modified">177   static Condition revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS);</span>



178 
<a name="13" id="anc13"></a><span class="line-removed">179   // These do not allow rebiasing; they are used by deoptimization to</span>
<span class="line-removed">180   // ensure that monitors on the stack can be migrated</span>
<span class="line-removed">181   static void revoke(GrowableArray&lt;Handle&gt;* objs);</span>
182   static void revoke_at_safepoint(Handle obj);
<a name="14" id="anc14"></a><span class="line-modified">183   static void revoke_at_safepoint(GrowableArray&lt;Handle&gt;* objs);</span>



184 
185   static void print_counters() { _counters.print(); }
186   static BiasedLockingCounters* counters() { return &amp;_counters; }
187 
188   // These routines are GC-related and should not be called by end
189   // users. GCs which do not do preservation of mark words do not need
190   // to call these routines.
191   static void preserve_marks();
192   static void restore_marks();
193 };
194 
195 #endif // SHARE_RUNTIME_BIASEDLOCKING_HPP
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/perfData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/handles.inline.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/mutex.hpp&quot;
 34 #include &quot;runtime/mutexLocker.hpp&quot;
 35 #include &quot;runtime/os.hpp&quot;
 36 #include &quot;runtime/perfData.inline.hpp&quot;
 37 #include &quot;utilities/exceptions.hpp&quot;
 38 #include &quot;utilities/globalDefinitions.hpp&quot;
 39 
 40 PerfDataList*   PerfDataManager::_all = NULL;
 41 PerfDataList*   PerfDataManager::_sampled = NULL;
 42 PerfDataList*   PerfDataManager::_constants = NULL;
 43 volatile bool   PerfDataManager::_has_PerfData = 0;
 44 
 45 /*
 46  * The jvmstat global and subsystem jvmstat counter name spaces. The top
 47  * level name spaces imply the interface stability level of the counter,
 48  * which generally follows the Java package, class, and property naming
 49  * conventions. The CounterNS enumeration values should be used to index
 50  * into this array.
 51  */
 52 const char* PerfDataManager::_name_spaces[] = {
 53   // top level name spaces
 54   &quot;java&quot;,                   // stable and supported name space
 55   &quot;com.sun&quot;,                // unstable but supported name space
 56   &quot;sun&quot;,                    // unstable and unsupported name space
 57   // subsystem name spaces
 58   &quot;java.gc&quot;,                // Garbage Collection name spaces
 59   &quot;com.sun.gc&quot;,
 60   &quot;sun.gc&quot;,
 61   &quot;java.ci&quot;,                // Compiler name spaces
 62   &quot;com.sun.ci&quot;,
 63   &quot;sun.ci&quot;,
 64   &quot;java.cls&quot;,               // Class Loader name spaces
 65   &quot;com.sun.cls&quot;,
 66   &quot;sun.cls&quot;,
 67   &quot;java.rt&quot;,                // Runtime name spaces
 68   &quot;com.sun.rt&quot;,
 69   &quot;sun.rt&quot;,
 70   &quot;java.os&quot;,                // Operating System name spaces
 71   &quot;com.sun.os&quot;,
 72   &quot;sun.os&quot;,
 73   &quot;java.threads&quot;,           // Threads System name spaces
 74   &quot;com.sun.threads&quot;,
 75   &quot;sun.threads&quot;,
 76   &quot;java.property&quot;,          // Java Property name spaces
 77   &quot;com.sun.property&quot;,
 78   &quot;sun.property&quot;,
 79   &quot;&quot;,
 80 };
 81 
 82 PerfData::PerfData(CounterNS ns, const char* name, Units u, Variability v)
 83                   : _name(NULL), _v(v), _u(u), _on_c_heap(false), _valuep(NULL) {
 84 
 85   const char* prefix = PerfDataManager::ns_to_string(ns);
 86 
 87   _name = NEW_C_HEAP_ARRAY(char, strlen(name) + strlen(prefix) + 2, mtInternal);
<a name="2" id="anc2"></a><span class="line-modified"> 88   assert(_name != NULL &amp;&amp; strlen(name) != 0, &quot;invalid name&quot;);</span>
 89 
 90   if (ns == NULL_NS) {
 91      // No prefix is added to counters with the NULL_NS namespace.
 92      strcpy(_name, name);
 93      // set the F_Supported flag based on the counter name prefix.
 94      if (PerfDataManager::is_stable_supported(_name) ||
 95          PerfDataManager::is_unstable_supported(_name)) {
 96        _flags = F_Supported;
 97      }
 98      else {
 99        _flags = F_None;
100      }
101   }
102   else {
103     sprintf(_name, &quot;%s.%s&quot;, prefix, name);
104     // set the F_Supported flag based on the given namespace.
105     if (PerfDataManager::is_stable_supported(ns) ||
106         PerfDataManager::is_unstable_supported(ns)) {
107       _flags = F_Supported;
108     }
109     else {
110       _flags = F_None;
111     }
112   }
113 }
114 
115 PerfData::~PerfData() {
<a name="3" id="anc3"></a><span class="line-modified">116   if (_name != NULL) {</span>
<span class="line-removed">117     FREE_C_HEAP_ARRAY(char, _name);</span>
<span class="line-removed">118   }</span>
119   if (is_on_c_heap()) {
120     FREE_C_HEAP_ARRAY(PerfDataEntry, _pdep);
121   }
122 }
123 
124 void PerfData::create_entry(BasicType dtype, size_t dsize, size_t vlen) {
125 
126   size_t dlen = vlen==0 ? 1 : vlen;
127 
128   size_t namelen = strlen(name()) + 1;  // include null terminator
129   size_t size = sizeof(PerfDataEntry) + namelen;
130   size_t pad_length = ((size % dsize) == 0) ? 0 : dsize - (size % dsize);
131   size += pad_length;
132   size_t data_start = size;
133   size += (dsize * dlen);
134 
135   // align size to assure allocation in units of 8 bytes
136   int align = sizeof(jlong) - 1;
137   size = ((size + align) &amp; ~align);
138   char* psmp = PerfMemory::alloc(size);
139 
140   if (psmp == NULL) {
141     // out of PerfMemory memory resources. allocate on the C heap
142     // to avoid vm termination.
143     psmp = NEW_C_HEAP_ARRAY(char, size, mtInternal);
144     _on_c_heap = true;
145   }
146 
147   // compute the addresses for the name and data
148   char* cname = psmp + sizeof(PerfDataEntry);
149 
150   // data is in the last dsize*dlen bytes of the entry
151   void* valuep = (void*) (psmp + data_start);
152 
153   assert(is_on_c_heap() || PerfMemory::contains(cname), &quot;just checking&quot;);
154   assert(is_on_c_heap() || PerfMemory::contains((char*)valuep), &quot;just checking&quot;);
155 
156   // copy the name, including null terminator, into PerfData memory
157   strcpy(cname, name());
158 
159 
160   // set the header values in PerfData memory
161   PerfDataEntry* pdep = (PerfDataEntry*)psmp;
162   pdep-&gt;entry_length = (jint)size;
163   pdep-&gt;name_offset = (jint) ((uintptr_t) cname - (uintptr_t) psmp);
164   pdep-&gt;vector_length = (jint)vlen;
165   pdep-&gt;data_type = (jbyte) type2char(dtype);
166   pdep-&gt;data_units = units();
167   pdep-&gt;data_variability = variability();
168   pdep-&gt;flags = (jbyte)flags();
169   pdep-&gt;data_offset = (jint) data_start;
170 
171   log_debug(perf, datacreation)(&quot;name = %s, dtype = %d, variability = %d,&quot;
172                                 &quot; units = %d, dsize = &quot; SIZE_FORMAT &quot;, vlen = &quot; SIZE_FORMAT &quot;,&quot;
173                                 &quot; pad_length = &quot; SIZE_FORMAT &quot;, size = &quot; SIZE_FORMAT &quot;, on_c_heap = %s,&quot;
174                                 &quot; address = &quot; INTPTR_FORMAT &quot;,&quot;
175                                 &quot; data address = &quot; INTPTR_FORMAT,
176                                 cname, dtype, variability(),
177                                 units(), dsize, vlen,
178                                 pad_length, size, is_on_c_heap() ? &quot;TRUE&quot;:&quot;FALSE&quot;,
179                                 p2i(psmp), p2i(valuep));
180 
181   // record the start of the entry and the location of the data field.
182   _pdep = pdep;
183   _valuep = valuep;
184 
185   // mark the PerfData memory region as having been updated.
186   PerfMemory::mark_updated();
187 }
188 
189 PerfLong::PerfLong(CounterNS ns, const char* namep, Units u, Variability v)
190                  : PerfData(ns, namep, u, v) {
191 
192   create_entry(T_LONG, sizeof(jlong));
193 }
194 
195 int PerfLong::format(char* buffer, int length) {
196   return jio_snprintf(buffer, length, JLONG_FORMAT, *(jlong*)_valuep);
197 }
198 
199 PerfLongVariant::PerfLongVariant(CounterNS ns, const char* namep, Units u,
200                                  Variability v, jlong* sampled)
201                                 : PerfLong(ns, namep, u, v),
202                                   _sampled(sampled), _sample_helper(NULL) {
203 
204   sample();
205 }
206 
207 PerfLongVariant::PerfLongVariant(CounterNS ns, const char* namep, Units u,
208                                  Variability v, PerfLongSampleHelper* helper)
209                                 : PerfLong(ns, namep, u, v),
210                                   _sampled(NULL), _sample_helper(helper) {
211 
212   sample();
213 }
214 
215 void PerfLongVariant::sample() {
216   if (_sample_helper != NULL) {
217     *(jlong*)_valuep = _sample_helper-&gt;take_sample();
218   }
219 }
220 
221 PerfByteArray::PerfByteArray(CounterNS ns, const char* namep, Units u,
222                              Variability v, jint length)
223                             : PerfData(ns, namep, u, v), _length(length) {
224 
225   create_entry(T_BYTE, sizeof(jbyte), (size_t)_length);
226 }
227 
228 void PerfString::set_string(const char* s2) {
229 
230   // copy n bytes of the string, assuring the null string is
231   // copied if s2 == NULL.
232   strncpy((char *)_valuep, s2 == NULL ? &quot;&quot; : s2, _length);
233 
234   // assure the string is null terminated when strlen(s2) &gt;= _length
235   ((char*)_valuep)[_length-1] = &#39;\0&#39;;
236 }
237 
238 int PerfString::format(char* buffer, int length) {
239   return jio_snprintf(buffer, length, &quot;%s&quot;, (char*)_valuep);
240 }
241 
242 PerfStringConstant::PerfStringConstant(CounterNS ns, const char* namep,
243                                        const char* initial_value)
244                      : PerfString(ns, namep, V_Constant,
245                                   initial_value == NULL ? 1 :
246                                   MIN2((jint)(strlen((char*)initial_value)+1),
247                                        (jint)(PerfMaxStringConstLength+1)),
248                                   initial_value) {
249 
250   if (PrintMiscellaneous &amp;&amp; Verbose) {
251     if (is_valid() &amp;&amp; initial_value != NULL &amp;&amp;
252         ((jint)strlen(initial_value) &gt; (jint)PerfMaxStringConstLength)) {
253 
254       warning(&quot;Truncating PerfStringConstant: name = %s,&quot;
255               &quot; length = &quot; INT32_FORMAT &quot;,&quot;
256               &quot; PerfMaxStringConstLength = &quot; INT32_FORMAT &quot;\n&quot;,
257               namep,
258               (jint)strlen(initial_value),
259               (jint)PerfMaxStringConstLength);
260     }
261   }
262 }
263 
264 
265 void PerfDataManager::destroy() {
266 
267   if (_all == NULL)
268     // destroy already called, or initialization never happened
269     return;
270 
271   // Clear the flag before we free the PerfData counters. Thus begins
272   // the race between this thread and another thread that has just
273   // queried PerfDataManager::has_PerfData() and gotten back &#39;true&#39;.
274   // The hope is that the other thread will finish its PerfData
275   // manipulation before we free the memory. The two alternatives are
276   // 1) leak the PerfData memory or 2) do some form of synchronized
277   // access or check before every PerfData operation.
278   _has_PerfData = false;
279   os::naked_short_sleep(1);  // 1ms sleep to let other thread(s) run
280 
281   for (int index = 0; index &lt; _all-&gt;length(); index++) {
282     PerfData* p = _all-&gt;at(index);
283     delete p;
284   }
285 
286   delete(_all);
287   delete(_sampled);
288   delete(_constants);
289 
290   _all = NULL;
291   _sampled = NULL;
292   _constants = NULL;
293 }
294 
295 void PerfDataManager::add_item(PerfData* p, bool sampled) {
296 
297   MutexLocker ml(PerfDataManager_lock);
298 
299   if (_all == NULL) {
300     _all = new PerfDataList(100);
301     _has_PerfData = true;
302   }
303 
304   assert(!_all-&gt;contains(p-&gt;name()), &quot;duplicate name added&quot;);
305 
306   // add to the list of all perf data items
307   _all-&gt;append(p);
308 
309   if (p-&gt;variability() == PerfData::V_Constant) {
310     if (_constants == NULL) {
311       _constants = new PerfDataList(25);
312     }
313     _constants-&gt;append(p);
314     return;
315   }
316 
317   if (sampled) {
318     if (_sampled == NULL) {
319       _sampled = new PerfDataList(25);
320     }
321     _sampled-&gt;append(p);
322   }
323 }
324 
325 PerfData* PerfDataManager::find_by_name(const char* name) {
326   // if add_item hasn&#39;t been called the list won&#39;t be initialized
327   if (_all != NULL) {
328     return _all-&gt;find_by_name(name);
329   } else {
330     return NULL;
331   }
332 }
333 
334 PerfDataList* PerfDataManager::all() {
335 
336   MutexLocker ml(PerfDataManager_lock);
337 
338   if (_all == NULL)
339     return NULL;
340 
341   PerfDataList* clone = _all-&gt;clone();
342   return clone;
343 }
344 
345 PerfDataList* PerfDataManager::sampled() {
346 
347   MutexLocker ml(PerfDataManager_lock);
348 
349   if (_sampled == NULL)
350     return NULL;
351 
352   PerfDataList* clone = _sampled-&gt;clone();
353   return clone;
354 }
355 
356 PerfDataList* PerfDataManager::constants() {
357 
358   MutexLocker ml(PerfDataManager_lock);
359 
360   if (_constants == NULL)
361     return NULL;
362 
363   PerfDataList* clone = _constants-&gt;clone();
364   return clone;
365 }
366 
367 char* PerfDataManager::counter_name(const char* ns, const char* name) {
368    assert(ns != NULL, &quot;ns string required&quot;);
369    assert(name != NULL, &quot;name string required&quot;);
370 
371    size_t len = strlen(ns) + strlen(name) + 2;
372    char* result = NEW_RESOURCE_ARRAY(char, len);
373    sprintf(result, &quot;%s.%s&quot;, ns, name);
374    return result;
375 }
376 
377 char* PerfDataManager::name_space(const char* ns, const char* sub,
378                                   int instance) {
379    char intbuf[40];
380    jio_snprintf(intbuf, 40, UINT32_FORMAT, instance);
381    return name_space(ns, name_space(sub, intbuf));
382 }
383 
384 char *PerfDataManager::name_space(const char* ns, int instance) {
385    char intbuf[40];
386    jio_snprintf(intbuf, 40, UINT32_FORMAT, instance);
387    return name_space(ns, intbuf);
388 }
389 
390 PerfStringConstant* PerfDataManager::create_string_constant(CounterNS ns,
391                                                             const char* name,
392                                                             const char* s,
393                                                             TRAPS) {
394 
395   PerfStringConstant* p = new PerfStringConstant(ns, name, s);
396 
397   if (!p-&gt;is_valid()) {
398     // allocation of native resources failed.
399     delete p;
400     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
401   }
402 
403   add_item(p, false);
404 
405   return p;
406 }
407 
408 PerfLongConstant* PerfDataManager::create_long_constant(CounterNS ns,
409                                                         const char* name,
410                                                         PerfData::Units u,
411                                                         jlong val, TRAPS) {
412 
413   PerfLongConstant* p = new PerfLongConstant(ns, name, u, val);
414 
415   if (!p-&gt;is_valid()) {
416     // allocation of native resources failed.
417     delete p;
418     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
419   }
420 
421   add_item(p, false);
422 
423   return p;
424 }
425 
426 PerfStringVariable* PerfDataManager::create_string_variable(CounterNS ns,
427                                                             const char* name,
428                                                             int max_length,
429                                                             const char* s,
430                                                             TRAPS) {
431 
432   if (max_length == 0 &amp;&amp; s != NULL) max_length = (int)strlen(s);
433 
434   assert(max_length != 0, &quot;PerfStringVariable with length 0&quot;);
435 
436   PerfStringVariable* p = new PerfStringVariable(ns, name, max_length, s);
437 
438   if (!p-&gt;is_valid()) {
439     // allocation of native resources failed.
440     delete p;
441     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
442   }
443 
444   add_item(p, false);
445 
446   return p;
447 }
448 
449 PerfLongVariable* PerfDataManager::create_long_variable(CounterNS ns,
450                                                         const char* name,
451                                                         PerfData::Units u,
452                                                         jlong ival, TRAPS) {
453 
454   PerfLongVariable* p = new PerfLongVariable(ns, name, u, ival);
455 
456   if (!p-&gt;is_valid()) {
457     // allocation of native resources failed.
458     delete p;
459     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
460   }
461 
462   add_item(p, false);
463 
464   return p;
465 }
466 
467 PerfLongVariable* PerfDataManager::create_long_variable(CounterNS ns,
468                                                         const char* name,
469                                                         PerfData::Units u,
470                                                         jlong* sp, TRAPS) {
471 
472   // Sampled counters not supported if UsePerfData is false
473   if (!UsePerfData) return NULL;
474 
475   PerfLongVariable* p = new PerfLongVariable(ns, name, u, sp);
476 
477   if (!p-&gt;is_valid()) {
478     // allocation of native resources failed.
479     delete p;
480     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
481   }
482 
483   add_item(p, true);
484 
485   return p;
486 }
487 
488 PerfLongVariable* PerfDataManager::create_long_variable(CounterNS ns,
489                                                         const char* name,
490                                                         PerfData::Units u,
491                                                         PerfSampleHelper* sh,
492                                                         TRAPS) {
493 
494   // Sampled counters not supported if UsePerfData is false
495   if (!UsePerfData) return NULL;
496 
497   PerfLongVariable* p = new PerfLongVariable(ns, name, u, sh);
498 
499   if (!p-&gt;is_valid()) {
500     // allocation of native resources failed.
501     delete p;
502     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
503   }
504 
505   add_item(p, true);
506 
507   return p;
508 }
509 
510 PerfLongCounter* PerfDataManager::create_long_counter(CounterNS ns,
511                                                       const char* name,
512                                                       PerfData::Units u,
513                                                       jlong ival, TRAPS) {
514 
515   PerfLongCounter* p = new PerfLongCounter(ns, name, u, ival);
516 
517   if (!p-&gt;is_valid()) {
518     // allocation of native resources failed.
519     delete p;
520     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
521   }
522 
523   add_item(p, false);
524 
525   return p;
526 }
527 
528 PerfLongCounter* PerfDataManager::create_long_counter(CounterNS ns,
529                                                       const char* name,
530                                                       PerfData::Units u,
531                                                       jlong* sp, TRAPS) {
532 
533   // Sampled counters not supported if UsePerfData is false
534   if (!UsePerfData) return NULL;
535 
536   PerfLongCounter* p = new PerfLongCounter(ns, name, u, sp);
537 
538   if (!p-&gt;is_valid()) {
539     // allocation of native resources failed.
540     delete p;
541     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
542   }
543 
544   add_item(p, true);
545 
546   return p;
547 }
548 
549 PerfLongCounter* PerfDataManager::create_long_counter(CounterNS ns,
550                                                       const char* name,
551                                                       PerfData::Units u,
552                                                       PerfSampleHelper* sh,
553                                                       TRAPS) {
554 
555   // Sampled counters not supported if UsePerfData is false
556   if (!UsePerfData) return NULL;
557 
558   PerfLongCounter* p = new PerfLongCounter(ns, name, u, sh);
559 
560   if (!p-&gt;is_valid()) {
561     // allocation of native resources failed.
562     delete p;
563     THROW_0(vmSymbols::java_lang_OutOfMemoryError());
564   }
565 
566   add_item(p, true);
567 
568   return p;
569 }
570 
571 PerfDataList::PerfDataList(int length) {
572 
573   _set = new(ResourceObj::C_HEAP, mtInternal) PerfDataArray(length, true);
574 }
575 
576 PerfDataList::PerfDataList(PerfDataList* p) {
577 
578   _set = new(ResourceObj::C_HEAP, mtInternal) PerfDataArray(p-&gt;length(), true);
579 
580   _set-&gt;appendAll(p-&gt;get_impl());
581 }
582 
583 PerfDataList::~PerfDataList() {
584 
585   delete _set;
586 
587 }
588 
589 bool PerfDataList::by_name(void* name, PerfData* pd) {
590 
591   if (pd == NULL)
592     return false;
593 
594   return strcmp((const char*)name, pd-&gt;name()) == 0;
595 }
596 
597 PerfData* PerfDataList::find_by_name(const char* name) {
598 
599   int i = _set-&gt;find((void*)name, PerfDataList::by_name);
600 
601   if (i &gt;= 0 &amp;&amp; i &lt;= _set-&gt;length())
602     return _set-&gt;at(i);
603   else
604     return NULL;
605 }
606 
607 PerfDataList* PerfDataList::clone() {
608 
609   PerfDataList* copy = new PerfDataList(this);
610 
611   assert(copy != NULL, &quot;just checking&quot;);
612 
613   return copy;
614 }
615 
616 PerfTraceTime::~PerfTraceTime() {
617   if (!UsePerfData || (_recursion_counter != NULL &amp;&amp;
618       --(*_recursion_counter) &gt; 0)) return;
619   _t.stop();
620   _timerp-&gt;inc(_t.ticks());
621 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
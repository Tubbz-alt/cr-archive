<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/thread.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="thread.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadHeapSampler.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,18 ***</span>
  inline void Thread::set_suspend_flag(SuspendFlags f) {
    uint32_t flags;
    do {
      flags = _suspend_flags;
    }
<span class="line-modified">!   while (Atomic::cmpxchg((flags | f), &amp;_suspend_flags, flags) != flags);</span>
  }
  inline void Thread::clear_suspend_flag(SuspendFlags f) {
    uint32_t flags;
    do {
      flags = _suspend_flags;
    }
<span class="line-modified">!   while (Atomic::cmpxchg((flags &amp; ~f), &amp;_suspend_flags, flags) != flags);</span>
  }
  
  inline void Thread::set_has_async_exception() {
    set_suspend_flag(_has_async_exception);
  }
<span class="line-new-header">--- 35,18 ---</span>
  inline void Thread::set_suspend_flag(SuspendFlags f) {
    uint32_t flags;
    do {
      flags = _suspend_flags;
    }
<span class="line-modified">!   while (Atomic::cmpxchg(&amp;_suspend_flags, flags, (flags | f)) != flags);</span>
  }
  inline void Thread::clear_suspend_flag(SuspendFlags f) {
    uint32_t flags;
    do {
      flags = _suspend_flags;
    }
<span class="line-modified">!   while (Atomic::cmpxchg(&amp;_suspend_flags, flags, (flags &amp; ~f)) != flags);</span>
  }
  
  inline void Thread::set_has_async_exception() {
    set_suspend_flag(_has_async_exception);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,11 ***</span>
  inline void Thread::clear_trace_flag() {
    clear_suspend_flag(_trace_flag);
  }
  
  inline jlong Thread::cooked_allocated_bytes() {
<span class="line-modified">!   jlong allocated_bytes = OrderAccess::load_acquire(&amp;_allocated_bytes);</span>
    if (UseTLAB) {
      size_t used_bytes = tlab().used_bytes();
      if (used_bytes &lt;= ThreadLocalAllocBuffer::max_size_in_bytes()) {
        // Comparing used_bytes with the maximum allowed size will ensure
        // that we don&#39;t add the used bytes from a semi-initialized TLAB
<span class="line-new-header">--- 65,11 ---</span>
  inline void Thread::clear_trace_flag() {
    clear_suspend_flag(_trace_flag);
  }
  
  inline jlong Thread::cooked_allocated_bytes() {
<span class="line-modified">!   jlong allocated_bytes = Atomic::load_acquire(&amp;_allocated_bytes);</span>
    if (UseTLAB) {
      size_t used_bytes = tlab().used_bytes();
      if (used_bytes &lt;= ThreadLocalAllocBuffer::max_size_in_bytes()) {
        // Comparing used_bytes with the maximum allowed size will ensure
        // that we don&#39;t add the used bytes from a semi-initialized TLAB
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,19 ***</span>
    }
    return allocated_bytes;
  }
  
  inline ThreadsList* Thread::cmpxchg_threads_hazard_ptr(ThreadsList* exchange_value, ThreadsList* compare_value) {
<span class="line-modified">!   return (ThreadsList*)Atomic::cmpxchg(exchange_value, &amp;_threads_hazard_ptr, compare_value);</span>
  }
  
  inline ThreadsList* Thread::get_threads_hazard_ptr() {
<span class="line-modified">!   return (ThreadsList*)OrderAccess::load_acquire(&amp;_threads_hazard_ptr);</span>
  }
  
  inline void Thread::set_threads_hazard_ptr(ThreadsList* new_list) {
<span class="line-modified">!   OrderAccess::release_store_fence(&amp;_threads_hazard_ptr, new_list);</span>
  }
  
  inline void JavaThread::set_ext_suspended() {
    set_suspend_flag (_ext_suspended);
  }
<span class="line-new-header">--- 81,19 ---</span>
    }
    return allocated_bytes;
  }
  
  inline ThreadsList* Thread::cmpxchg_threads_hazard_ptr(ThreadsList* exchange_value, ThreadsList* compare_value) {
<span class="line-modified">!   return (ThreadsList*)Atomic::cmpxchg(&amp;_threads_hazard_ptr, compare_value, exchange_value);</span>
  }
  
  inline ThreadsList* Thread::get_threads_hazard_ptr() {
<span class="line-modified">!   return (ThreadsList*)Atomic::load_acquire(&amp;_threads_hazard_ptr);</span>
  }
  
  inline void Thread::set_threads_hazard_ptr(ThreadsList* new_list) {
<span class="line-modified">!   Atomic::release_store_fence(&amp;_threads_hazard_ptr, new_list);</span>
  }
  
  inline void JavaThread::set_ext_suspended() {
    set_suspend_flag (_ext_suspended);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,43 ***</span>
  }
  inline void JavaThread::clear_external_suspend() {
    clear_suspend_flag(_external_suspend);
  }
  
<span class="line-removed">- inline void JavaThread::set_deopt_suspend() {</span>
<span class="line-removed">-   set_suspend_flag(_deopt_suspend);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- inline void JavaThread::clear_deopt_suspend() {</span>
<span class="line-removed">-   clear_suspend_flag(_deopt_suspend);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  inline void JavaThread::set_pending_async_exception(oop e) {
    _pending_async_exception = e;
    _special_runtime_exit_condition = _async_exception;
    set_has_async_exception();
  }
  
  inline JavaThreadState JavaThread::thread_state() const    {
  #if defined(PPC64) || defined (AARCH64)
    // Use membars when accessing volatile _thread_state. See
    // Threads::create_vm() for size checks.
<span class="line-modified">!   return (JavaThreadState) OrderAccess::load_acquire((volatile jint*)&amp;_thread_state);</span>
  #else
    return _thread_state;
  #endif
  }
  
  inline void JavaThread::set_thread_state(JavaThreadState s) {
  #if defined(PPC64) || defined (AARCH64)
    // Use membars when accessing volatile _thread_state. See
    // Threads::create_vm() for size checks.
<span class="line-modified">!   OrderAccess::release_store((volatile jint*)&amp;_thread_state, (jint)s);</span>
  #else
    _thread_state = s;
  #endif
  }
  
  ThreadSafepointState* JavaThread::safepoint_state() const  {
    return _safepoint_state;
  }
  
  void JavaThread::set_safepoint_state(ThreadSafepointState *state) {
<span class="line-new-header">--- 106,43 ---</span>
  }
  inline void JavaThread::clear_external_suspend() {
    clear_suspend_flag(_external_suspend);
  }
  
  inline void JavaThread::set_pending_async_exception(oop e) {
    _pending_async_exception = e;
    _special_runtime_exit_condition = _async_exception;
    set_has_async_exception();
  }
  
  inline JavaThreadState JavaThread::thread_state() const    {
  #if defined(PPC64) || defined (AARCH64)
    // Use membars when accessing volatile _thread_state. See
    // Threads::create_vm() for size checks.
<span class="line-modified">!   return (JavaThreadState) Atomic::load_acquire((volatile jint*)&amp;_thread_state);</span>
  #else
    return _thread_state;
  #endif
  }
  
  inline void JavaThread::set_thread_state(JavaThreadState s) {
<span class="line-added">+   assert(current_or_null() == NULL || current_or_null() == this,</span>
<span class="line-added">+          &quot;state change should only be called by the current thread&quot;);</span>
  #if defined(PPC64) || defined (AARCH64)
    // Use membars when accessing volatile _thread_state. See
    // Threads::create_vm() for size checks.
<span class="line-modified">!   Atomic::release_store((volatile jint*)&amp;_thread_state, (jint)s);</span>
  #else
    _thread_state = s;
  #endif
  }
  
<span class="line-added">+ inline void JavaThread::set_thread_state_fence(JavaThreadState s) {</span>
<span class="line-added">+   set_thread_state(s);</span>
<span class="line-added">+   OrderAccess::fence();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  ThreadSafepointState* JavaThread::safepoint_state() const  {
    return _safepoint_state;
  }
  
  void JavaThread::set_safepoint_state(ThreadSafepointState *state) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,49 ***</span>
  }
  
  // The release make sure this store is done after storing the handshake
  // operation or global state
  inline void JavaThread::set_polling_page_release(void* poll_value) {
<span class="line-modified">!   OrderAccess::release_store(polling_page_addr(), poll_value);</span>
  }
  
  // Caller is responsible for using a memory barrier if needed.
  inline void JavaThread::set_polling_page(void* poll_value) {
    *polling_page_addr() = poll_value;
  }
  
  // The aqcquire make sure reading of polling page is done before
  // the reading the handshake operation or the global state
  inline volatile void* JavaThread::get_polling_page() {
<span class="line-modified">!   return OrderAccess::load_acquire(polling_page_addr());</span>
  }
  
  inline bool JavaThread::is_exiting() const {
    // Use load-acquire so that setting of _terminated by
    // JavaThread::exit() is seen more quickly.
    TerminatedTypes l_terminated = (TerminatedTypes)
<span class="line-modified">!       OrderAccess::load_acquire((volatile jint *) &amp;_terminated);</span>
    return l_terminated == _thread_exiting || check_is_terminated(l_terminated);
  }
  
  inline bool JavaThread::is_terminated() const {
    // Use load-acquire so that setting of _terminated by
    // JavaThread::exit() is seen more quickly.
    TerminatedTypes l_terminated = (TerminatedTypes)
<span class="line-modified">!       OrderAccess::load_acquire((volatile jint *) &amp;_terminated);</span>
    return check_is_terminated(l_terminated);
  }
  
  inline void JavaThread::set_terminated(TerminatedTypes t) {
    // use release-store so the setting of _terminated is seen more quickly
<span class="line-modified">!   OrderAccess::release_store((volatile jint *) &amp;_terminated, (jint) t);</span>
  }
  
  // special for Threads::remove() which is static:
  inline void JavaThread::set_terminated_value() {
    // use release-store so the setting of _terminated is seen more quickly
<span class="line-modified">!   OrderAccess::release_store((volatile jint *) &amp;_terminated, (jint) _thread_terminated);</span>
  }
  
  // Allow tracking of class initialization monitor use
  inline void JavaThread::set_class_to_be_initialized(InstanceKlass* k) {
    assert((k == NULL &amp;&amp; _class_to_be_initialized != NULL) ||
<span class="line-new-header">--- 200,49 ---</span>
  }
  
  // The release make sure this store is done after storing the handshake
  // operation or global state
  inline void JavaThread::set_polling_page_release(void* poll_value) {
<span class="line-modified">!   Atomic::release_store(polling_page_addr(), poll_value);</span>
  }
  
  // Caller is responsible for using a memory barrier if needed.
  inline void JavaThread::set_polling_page(void* poll_value) {
    *polling_page_addr() = poll_value;
  }
  
  // The aqcquire make sure reading of polling page is done before
  // the reading the handshake operation or the global state
  inline volatile void* JavaThread::get_polling_page() {
<span class="line-modified">!   return Atomic::load_acquire(polling_page_addr());</span>
  }
  
  inline bool JavaThread::is_exiting() const {
    // Use load-acquire so that setting of _terminated by
    // JavaThread::exit() is seen more quickly.
    TerminatedTypes l_terminated = (TerminatedTypes)
<span class="line-modified">!       Atomic::load_acquire((volatile jint *) &amp;_terminated);</span>
    return l_terminated == _thread_exiting || check_is_terminated(l_terminated);
  }
  
  inline bool JavaThread::is_terminated() const {
    // Use load-acquire so that setting of _terminated by
    // JavaThread::exit() is seen more quickly.
    TerminatedTypes l_terminated = (TerminatedTypes)
<span class="line-modified">!       Atomic::load_acquire((volatile jint *) &amp;_terminated);</span>
    return check_is_terminated(l_terminated);
  }
  
  inline void JavaThread::set_terminated(TerminatedTypes t) {
    // use release-store so the setting of _terminated is seen more quickly
<span class="line-modified">!   Atomic::release_store((volatile jint *) &amp;_terminated, (jint) t);</span>
  }
  
  // special for Threads::remove() which is static:
  inline void JavaThread::set_terminated_value() {
    // use release-store so the setting of _terminated is seen more quickly
<span class="line-modified">!   Atomic::release_store((volatile jint *) &amp;_terminated, (jint) _thread_terminated);</span>
  }
  
  // Allow tracking of class initialization monitor use
  inline void JavaThread::set_class_to_be_initialized(InstanceKlass* k) {
    assert((k == NULL &amp;&amp; _class_to_be_initialized != NULL) ||
</pre>
<center><a href="thread.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadHeapSampler.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
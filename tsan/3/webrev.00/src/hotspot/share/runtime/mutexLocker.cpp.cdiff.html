<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/mutexLocker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mutex.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutexLocker.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/mutexLocker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,10 ***</span>
<span class="line-new-header">--- 21,11 ---</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,27 ***</span>
  // Instead of using pointers to malloc()ed monitors and mutexes we should consider
  // eliminating the indirection and using instances instead.
  // Consider using GCC&#39;s __read_mostly.
  
  Mutex*   Patching_lock                = NULL;
  Monitor* SystemDictionary_lock        = NULL;
  Mutex*   ProtectionDomainSet_lock     = NULL;
  Mutex*   SharedDictionary_lock        = NULL;
  Mutex*   Module_lock                  = NULL;
  Mutex*   CompiledIC_lock              = NULL;
  Mutex*   InlineCacheBuffer_lock       = NULL;
  Mutex*   VMStatistic_lock             = NULL;
<span class="line-removed">- Mutex*   JNIGlobalAlloc_lock          = NULL;</span>
<span class="line-removed">- Mutex*   JNIGlobalActive_lock         = NULL;</span>
<span class="line-removed">- Mutex*   JNIWeakAlloc_lock            = NULL;</span>
<span class="line-removed">- Mutex*   JNIWeakActive_lock           = NULL;</span>
<span class="line-removed">- Mutex*   StringTableWeakAlloc_lock    = NULL;</span>
<span class="line-removed">- Mutex*   StringTableWeakActive_lock   = NULL;</span>
  Mutex*   JNIHandleBlockFreeList_lock  = NULL;
<span class="line-removed">- Mutex*   VMWeakAlloc_lock             = NULL;</span>
<span class="line-removed">- Mutex*   VMWeakActive_lock            = NULL;</span>
<span class="line-removed">- Mutex*   ResolvedMethodTable_lock     = NULL;</span>
  Mutex*   JmethodIdCreation_lock       = NULL;
  Mutex*   JfieldIdCreation_lock        = NULL;
  Monitor* JNICritical_lock             = NULL;
  Mutex*   JvmtiThreadState_lock        = NULL;
  Monitor* Heap_lock                    = NULL;
<span class="line-new-header">--- 37,19 ---</span>
  // Instead of using pointers to malloc()ed monitors and mutexes we should consider
  // eliminating the indirection and using instances instead.
  // Consider using GCC&#39;s __read_mostly.
  
  Mutex*   Patching_lock                = NULL;
<span class="line-added">+ Mutex*   CompiledMethod_lock          = NULL;</span>
  Monitor* SystemDictionary_lock        = NULL;
  Mutex*   ProtectionDomainSet_lock     = NULL;
  Mutex*   SharedDictionary_lock        = NULL;
  Mutex*   Module_lock                  = NULL;
  Mutex*   CompiledIC_lock              = NULL;
  Mutex*   InlineCacheBuffer_lock       = NULL;
  Mutex*   VMStatistic_lock             = NULL;
  Mutex*   JNIHandleBlockFreeList_lock  = NULL;
  Mutex*   JmethodIdCreation_lock       = NULL;
  Mutex*   JfieldIdCreation_lock        = NULL;
  Monitor* JNICritical_lock             = NULL;
  Mutex*   JvmtiThreadState_lock        = NULL;
  Monitor* Heap_lock                    = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,39 ***</span>
  Mutex*   MethodData_lock              = NULL;
  Mutex*   TouchedMethodLog_lock        = NULL;
  Mutex*   RetData_lock                 = NULL;
  Monitor* VMOperationQueue_lock        = NULL;
  Monitor* VMOperationRequest_lock      = NULL;
<span class="line-removed">- Monitor* SerializePage_lock           = NULL;</span>
  Monitor* Threads_lock                 = NULL;
  Mutex*   NonJavaThreadsList_lock      = NULL;
  Monitor* CGC_lock                     = NULL;
  Monitor* STS_lock                     = NULL;
  Monitor* FullGCCount_lock             = NULL;
<span class="line-modified">! Monitor* SATB_Q_CBL_mon               = NULL;</span>
<span class="line-removed">- Monitor* DirtyCardQ_CBL_mon           = NULL;</span>
  Mutex*   Shared_DirtyCardQ_lock       = NULL;
  Mutex*   MarkStackFreeList_lock       = NULL;
  Mutex*   MarkStackChunkList_lock      = NULL;
  Mutex*   MonitoringSupport_lock       = NULL;
  Mutex*   ParGCRareEvent_lock          = NULL;
<span class="line-removed">- Mutex*   DerivedPointerTableGC_lock   = NULL;</span>
  Monitor* CGCPhaseManager_lock         = NULL;
  Mutex*   Compile_lock                 = NULL;
  Monitor* MethodCompileQueue_lock      = NULL;
  Monitor* CompileThread_lock           = NULL;
  Monitor* Compilation_lock             = NULL;
  Mutex*   CompileTaskAlloc_lock        = NULL;
  Mutex*   CompileStatistics_lock       = NULL;
  Mutex*   DirectivesStack_lock         = NULL;
  Mutex*   MultiArray_lock              = NULL;
  Monitor* Terminator_lock              = NULL;
  Monitor* BeforeExit_lock              = NULL;
  Monitor* Notify_lock                  = NULL;
  Mutex*   ProfilePrint_lock            = NULL;
  Mutex*   ExceptionCache_lock          = NULL;
<span class="line-removed">- Mutex*   OsrList_lock                 = NULL;</span>
  Mutex*   NMethodSweeperStats_lock     = NULL;
  #ifndef PRODUCT
  Mutex*   FullGCALot_lock              = NULL;
  #endif
  
<span class="line-new-header">--- 64,37 ---</span>
  Mutex*   MethodData_lock              = NULL;
  Mutex*   TouchedMethodLog_lock        = NULL;
  Mutex*   RetData_lock                 = NULL;
  Monitor* VMOperationQueue_lock        = NULL;
  Monitor* VMOperationRequest_lock      = NULL;
  Monitor* Threads_lock                 = NULL;
  Mutex*   NonJavaThreadsList_lock      = NULL;
<span class="line-added">+ Mutex*   NonJavaThreadsListSync_lock  = NULL;</span>
  Monitor* CGC_lock                     = NULL;
  Monitor* STS_lock                     = NULL;
  Monitor* FullGCCount_lock             = NULL;
<span class="line-modified">! Monitor* G1OldGCCount_lock            = NULL;</span>
  Mutex*   Shared_DirtyCardQ_lock       = NULL;
  Mutex*   MarkStackFreeList_lock       = NULL;
  Mutex*   MarkStackChunkList_lock      = NULL;
  Mutex*   MonitoringSupport_lock       = NULL;
  Mutex*   ParGCRareEvent_lock          = NULL;
  Monitor* CGCPhaseManager_lock         = NULL;
  Mutex*   Compile_lock                 = NULL;
  Monitor* MethodCompileQueue_lock      = NULL;
  Monitor* CompileThread_lock           = NULL;
  Monitor* Compilation_lock             = NULL;
  Mutex*   CompileTaskAlloc_lock        = NULL;
  Mutex*   CompileStatistics_lock       = NULL;
  Mutex*   DirectivesStack_lock         = NULL;
  Mutex*   MultiArray_lock              = NULL;
  Monitor* Terminator_lock              = NULL;
<span class="line-added">+ Monitor* InitCompleted_lock           = NULL;</span>
  Monitor* BeforeExit_lock              = NULL;
  Monitor* Notify_lock                  = NULL;
  Mutex*   ProfilePrint_lock            = NULL;
  Mutex*   ExceptionCache_lock          = NULL;
  Mutex*   NMethodSweeperStats_lock     = NULL;
  #ifndef PRODUCT
  Mutex*   FullGCALot_lock              = NULL;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 120,16 ***</span>
  
  Mutex*   FreeList_lock                = NULL;
  Mutex*   OldSets_lock                 = NULL;
  Monitor* RootRegionScan_lock          = NULL;
  
<span class="line-removed">- Monitor* GCTaskManager_lock           = NULL;</span>
<span class="line-removed">- </span>
  Mutex*   Management_lock              = NULL;
  Monitor* Service_lock                 = NULL;
  Monitor* PeriodicTask_lock            = NULL;
  Monitor* RedefineClasses_lock         = NULL;
  
  #if INCLUDE_JFR
  Mutex*   JfrStacktrace_lock           = NULL;
  Monitor* JfrMsg_lock                  = NULL;
  Mutex*   JfrBuffer_lock               = NULL;
<span class="line-new-header">--- 111,16 ---</span>
  
  Mutex*   FreeList_lock                = NULL;
  Mutex*   OldSets_lock                 = NULL;
  Monitor* RootRegionScan_lock          = NULL;
  
  Mutex*   Management_lock              = NULL;
  Monitor* Service_lock                 = NULL;
<span class="line-added">+ Monitor* Notification_lock            = NULL;</span>
  Monitor* PeriodicTask_lock            = NULL;
  Monitor* RedefineClasses_lock         = NULL;
<span class="line-added">+ Mutex*   Verify_lock                  = NULL;</span>
  
  #if INCLUDE_JFR
  Mutex*   JfrStacktrace_lock           = NULL;
  Monitor* JfrMsg_lock                  = NULL;
  Mutex*   JfrBuffer_lock               = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,32 ***</span>
  #endif
  
  #ifndef SUPPORTS_NATIVE_CX8
  Mutex*   UnsafeJlong_lock             = NULL;
  #endif
<span class="line-modified">! Monitor* CodeHeapStateAnalytics_lock  = NULL;</span>
  
  Mutex*   MetaspaceExpand_lock         = NULL;
  Mutex*   ClassLoaderDataGraph_lock    = NULL;
  Monitor* ThreadsSMRDelete_lock        = NULL;
  Mutex*   SharedDecoder_lock           = NULL;
  Mutex*   DCmdFactory_lock             = NULL;
  #if INCLUDE_NMT
  Mutex*   NMTQuery_lock                = NULL;
  #endif
<span class="line-modified">! #if INCLUDE_CDS &amp;&amp; INCLUDE_JVMTI</span>
  Mutex*   CDSClassFileStream_lock      = NULL;
  #endif
  
  #define MAX_NUM_MUTEX 128
<span class="line-modified">! static Monitor * _mutex_array[MAX_NUM_MUTEX];</span>
  static int _num_mutex;
  
  #ifdef ASSERT
<span class="line-modified">! void assert_locked_or_safepoint(const Monitor * lock) {</span>
    // check if this thread owns the lock (common case)
<span class="line-removed">-   if (IgnoreLockingAssertions) return;</span>
    assert(lock != NULL, &quot;Need non-NULL lock&quot;);
    if (lock-&gt;owned_by_self()) return;
    if (SafepointSynchronize::is_at_safepoint()) return;
    if (!Universe::is_fully_initialized()) return;
    // see if invoker of VM operation owns it
<span class="line-new-header">--- 133,40 ---</span>
  #endif
  
  #ifndef SUPPORTS_NATIVE_CX8
  Mutex*   UnsafeJlong_lock             = NULL;
  #endif
<span class="line-modified">! Mutex*   CodeHeapStateAnalytics_lock  = NULL;</span>
  
  Mutex*   MetaspaceExpand_lock         = NULL;
  Mutex*   ClassLoaderDataGraph_lock    = NULL;
  Monitor* ThreadsSMRDelete_lock        = NULL;
<span class="line-added">+ Mutex*   ThreadIdTableCreate_lock     = NULL;</span>
  Mutex*   SharedDecoder_lock           = NULL;
  Mutex*   DCmdFactory_lock             = NULL;
  #if INCLUDE_NMT
  Mutex*   NMTQuery_lock                = NULL;
  #endif
<span class="line-modified">! #if INCLUDE_CDS</span>
<span class="line-added">+ #if INCLUDE_JVMTI</span>
  Mutex*   CDSClassFileStream_lock      = NULL;
  #endif
<span class="line-added">+ Mutex*   DumpTimeTable_lock           = NULL;</span>
<span class="line-added">+ #endif // INCLUDE_CDS</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+ Monitor* JVMCI_lock                   = NULL;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  
  #define MAX_NUM_MUTEX 128
<span class="line-modified">! static Mutex* _mutex_array[MAX_NUM_MUTEX];</span>
  static int _num_mutex;
  
  #ifdef ASSERT
<span class="line-modified">! void assert_locked_or_safepoint(const Mutex* lock) {</span>
    // check if this thread owns the lock (common case)
    assert(lock != NULL, &quot;Need non-NULL lock&quot;);
    if (lock-&gt;owned_by_self()) return;
    if (SafepointSynchronize::is_at_safepoint()) return;
    if (!Universe::is_fully_initialized()) return;
    // see if invoker of VM operation owns it
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,188 ***</span>
    if (op != NULL &amp;&amp; op-&gt;calling_thread() == lock-&gt;owner()) return;
    fatal(&quot;must own lock %s&quot;, lock-&gt;name());
  }
  
  // a weaker assertion than the above
<span class="line-modified">! void assert_locked_or_safepoint_weak(const Monitor * lock) {</span>
<span class="line-removed">-   if (IgnoreLockingAssertions) return;</span>
    assert(lock != NULL, &quot;Need non-NULL lock&quot;);
    if (lock-&gt;is_locked()) return;
    if (SafepointSynchronize::is_at_safepoint()) return;
    if (!Universe::is_fully_initialized()) return;
    fatal(&quot;must own lock %s&quot;, lock-&gt;name());
  }
  
  // a stronger assertion than the above
<span class="line-modified">! void assert_lock_strong(const Monitor * lock) {</span>
<span class="line-removed">-   if (IgnoreLockingAssertions) return;</span>
    assert(lock != NULL, &quot;Need non-NULL lock&quot;);
    if (lock-&gt;owned_by_self()) return;
    fatal(&quot;must own lock %s&quot;, lock-&gt;name());
  }
  #endif
  
  #define def(var, type, pri, vm_block, safepoint_check_allowed ) {      \
<span class="line-modified">!   var = new type(Mutex::pri, #var, vm_block, safepoint_check_allowed); \</span>
    assert(_num_mutex &lt; MAX_NUM_MUTEX, &quot;increase MAX_NUM_MUTEX&quot;);        \
    _mutex_array[_num_mutex++] = var;                                      \
  }
  
  // Using Padded subclasses to prevent false sharing of these global monitors and mutexes.
  void mutex_init() {
<span class="line-modified">!   def(tty_lock                     , PaddedMutex  , tty,         true,  Monitor::_safepoint_check_never);      // allow to lock in VM</span>
<span class="line-removed">- </span>
<span class="line-removed">-   def(CGC_lock                     , PaddedMonitor, special,     true,  Monitor::_safepoint_check_never);      // coordinate between fore- and background GC</span>
<span class="line-removed">-   def(STS_lock                     , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);</span>
  
<span class="line-modified">!   def(VMWeakAlloc_lock             , PaddedMutex  , vmweak,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(VMWeakActive_lock            , PaddedMutex  , vmweak-1,    true,  Monitor::_safepoint_check_never);</span>
  
<span class="line-modified">!   def(StringTableWeakAlloc_lock    , PaddedMutex  , vmweak,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">-   def(StringTableWeakActive_lock   , PaddedMutex  , vmweak-1,    true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (UseConcMarkSweepGC || UseG1GC) {</span>
<span class="line-removed">-     def(FullGCCount_lock           , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);      // in support of ExplicitGCInvokesConcurrent</span>
<span class="line-removed">-   }</span>
    if (UseG1GC) {
<span class="line-modified">!     def(SATB_Q_CBL_mon             , PaddedMonitor, access,      true,  Monitor::_safepoint_check_never);</span>
  
<span class="line-modified">!     def(DirtyCardQ_CBL_mon         , PaddedMonitor, access,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">-     def(Shared_DirtyCardQ_lock     , PaddedMutex  , access + 1,  true,  Monitor::_safepoint_check_never);</span>
  
<span class="line-modified">!     def(FreeList_lock              , PaddedMutex  , leaf     ,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!     def(OldSets_lock               , PaddedMutex  , leaf     ,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!     def(RootRegionScan_lock        , PaddedMonitor, leaf     ,   true,  Monitor::_safepoint_check_never);</span>
  
<span class="line-modified">!     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!     def(StringDedupTable_lock      , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
  
<span class="line-modified">!     def(MarkStackFreeList_lock     , PaddedMutex  , leaf     ,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!     def(MarkStackChunkList_lock    , PaddedMutex  , leaf     ,   true,  Monitor::_safepoint_check_never);</span>
  
<span class="line-modified">!     def(MonitoringSupport_lock     , PaddedMutex  , native   ,   true,  Monitor::_safepoint_check_never);      // used for serviceability monitoring support</span>
    }
    if (UseShenandoahGC) {
<span class="line-modified">!     def(SATB_Q_CBL_mon             , PaddedMonitor, access,      true,  Monitor::_safepoint_check_never);</span>
  
<span class="line-modified">!     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!     def(StringDedupTable_lock      , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
    }
<span class="line-modified">!   def(ParGCRareEvent_lock          , PaddedMutex  , leaf     ,   true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">!   def(DerivedPointerTableGC_lock   , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(CGCPhaseManager_lock         , PaddedMonitor, leaf,        false, Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">!   def(CodeCache_lock               , PaddedMutex  , special,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(RawMonitor_lock              , PaddedMutex  , special,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(OopMapCacheAlloc_lock        , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // used for oop_map_cache allocation.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(MetaspaceExpand_lock         , PaddedMutex  , leaf-1,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(ClassLoaderDataGraph_lock    , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(Patching_lock                , PaddedMutex  , special,     true,  Monitor::_safepoint_check_never);      // used for safepointing and code patching.</span>
<span class="line-modified">!   def(Service_lock                 , PaddedMonitor, special,     true,  Monitor::_safepoint_check_never);      // used for service thread operations</span>
<span class="line-modified">!   def(JmethodIdCreation_lock       , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // used for creating jmethodIDs.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(SystemDictionary_lock        , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_always);     // lookups done by VM thread</span>
<span class="line-modified">!   def(ProtectionDomainSet_lock     , PaddedMutex  , leaf-1,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">-   def(SharedDictionary_lock        , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // lookups done by VM thread</span>
<span class="line-removed">-   def(Module_lock                  , PaddedMutex  , leaf+2,      true,  Monitor::_safepoint_check_always);</span>
<span class="line-removed">-   def(InlineCacheBuffer_lock       , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">-   def(VMStatistic_lock             , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always);</span>
<span class="line-removed">-   def(ExpandHeap_lock              , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // Used during compilation by VM thread</span>
<span class="line-removed">-   def(JNIHandleBlockFreeList_lock  , PaddedMutex  , leaf-1,      true,  Monitor::_safepoint_check_never);      // handles are used by VM thread</span>
<span class="line-removed">-   def(SignatureHandlerLibrary_lock , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always);</span>
<span class="line-removed">-   def(SymbolArena_lock             , PaddedMutex  , leaf+2,      true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">-   def(ProfilePrint_lock            , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always);     // serial profile printing</span>
<span class="line-removed">-   def(ExceptionCache_lock          , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always);     // serial profile printing</span>
<span class="line-removed">-   def(OsrList_lock                 , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">-   def(Debug1_lock                  , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
  #ifndef PRODUCT
<span class="line-modified">!   def(FullGCALot_lock              , PaddedMutex  , leaf,        false, Monitor::_safepoint_check_always);     // a lock to make FullGCALot MT safe</span>
  #endif
<span class="line-modified">!   def(BeforeExit_lock              , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">!   def(PerfDataMemAlloc_lock        , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // used for allocating PerfData memory for performance data</span>
<span class="line-modified">!   def(PerfDataManager_lock         , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     // used for synchronized access to PerfDataManager resources</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // CMS_modUnionTable_lock                   leaf</span>
<span class="line-modified">!   // CMS_bitMap_lock                          leaf 1</span>
<span class="line-modified">!   // CMS_freeList_lock                        leaf 2</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(Threads_lock                 , PaddedMonitor, barrier,     true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">!   def(NonJavaThreadsList_lock      , PaddedMutex,   leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(VMOperationQueue_lock        , PaddedMonitor, nonleaf,     true,  Monitor::_safepoint_check_sometimes);  // VM_thread allowed to block on these</span>
<span class="line-modified">!   def(VMOperationRequest_lock      , PaddedMonitor, nonleaf,     true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">!   def(RetData_lock                 , PaddedMutex  , nonleaf,     false, Monitor::_safepoint_check_always);</span>
<span class="line-modified">!   def(Terminator_lock              , PaddedMonitor, nonleaf,     true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">!   def(VtableStubs_lock             , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(Notify_lock                  , PaddedMonitor, nonleaf,     true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">!   def(JNIGlobalAlloc_lock          , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(JNIGlobalActive_lock         , PaddedMutex  , nonleaf-1,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(JNIWeakAlloc_lock            , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(JNIWeakActive_lock           , PaddedMutex  , nonleaf-1,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(JNICritical_lock             , PaddedMonitor, nonleaf,     true,  Monitor::_safepoint_check_always);     // used for JNI critical regions</span>
<span class="line-modified">!   def(AdapterHandlerLibrary_lock   , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(Heap_lock                    , PaddedMonitor, nonleaf+1,   false, Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">!   def(JfieldIdCreation_lock        , PaddedMutex  , nonleaf+1,   true,  Monitor::_safepoint_check_always);     // jfieldID, Used in VM_Operation</span>
<span class="line-modified">!   def(ResolvedMethodTable_lock     , PaddedMutex  , nonleaf+1,   false, Monitor::_safepoint_check_always);     // Used to protect ResolvedMethodTable</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(CompiledIC_lock              , PaddedMutex  , nonleaf+2,   false, Monitor::_safepoint_check_never);      // locks VtableStubs_lock, InlineCacheBuffer_lock</span>
<span class="line-modified">!   def(CompileTaskAlloc_lock        , PaddedMutex  , nonleaf+2,   true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">!   def(CompileStatistics_lock       , PaddedMutex  , nonleaf+2,   false, Monitor::_safepoint_check_always);</span>
<span class="line-modified">!   def(DirectivesStack_lock         , PaddedMutex  , special,     true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(MultiArray_lock              , PaddedMutex  , nonleaf+2,   false, Monitor::_safepoint_check_always);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(JvmtiThreadState_lock        , PaddedMutex  , nonleaf+2,   false, Monitor::_safepoint_check_always);     // Used by JvmtiThreadState/JvmtiEventController</span>
<span class="line-modified">!   def(Management_lock              , PaddedMutex  , nonleaf+2,   false, Monitor::_safepoint_check_always);     // used for JVM management</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(Compile_lock                 , PaddedMutex  , nonleaf+3,   true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">!   def(MethodData_lock              , PaddedMutex  , nonleaf+3,   false, Monitor::_safepoint_check_always);</span>
<span class="line-modified">!   def(TouchedMethodLog_lock        , PaddedMutex  , nonleaf+3,   false, Monitor::_safepoint_check_always);</span>
<span class="line-modified">! </span>
<span class="line-removed">-   def(MethodCompileQueue_lock      , PaddedMonitor, nonleaf+4,   true,  Monitor::_safepoint_check_always);</span>
<span class="line-removed">-   def(Debug2_lock                  , PaddedMutex  , nonleaf+4,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">-   def(Debug3_lock                  , PaddedMutex  , nonleaf+4,   true,  Monitor::_safepoint_check_never);</span>
<span class="line-removed">-   def(CompileThread_lock           , PaddedMonitor, nonleaf+5,   false, Monitor::_safepoint_check_always);</span>
<span class="line-removed">-   def(PeriodicTask_lock            , PaddedMonitor, nonleaf+5,   true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-removed">-   def(RedefineClasses_lock         , PaddedMonitor, nonleaf+5,   true,  Monitor::_safepoint_check_always);</span>
  
    if (WhiteBoxAPI) {
<span class="line-modified">!     def(Compilation_lock           , PaddedMonitor, leaf,        false, Monitor::_safepoint_check_never);</span>
    }
  
  #if INCLUDE_JFR
<span class="line-modified">!   def(JfrMsg_lock                  , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_always);</span>
<span class="line-modified">!   def(JfrBuffer_lock               , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(JfrStream_lock               , PaddedMutex  , leaf+1,      true,  Monitor::_safepoint_check_never);      // ensure to rank lower than &#39;safepoint&#39;</span>
<span class="line-modified">!   def(JfrStacktrace_lock           , PaddedMutex  , special,     true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">!   def(JfrThreadSampler_lock        , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);</span>
  #endif
  
    TSAN_RUNTIME_ONLY(
<span class="line-modified">!     def(TsanOopMap_lock            , PaddedMutex  , special,     true,  Monitor::_safepoint_check_never);</span>
    );
  
  #ifndef SUPPORTS_NATIVE_CX8
<span class="line-modified">!   def(UnsafeJlong_lock             , PaddedMutex  , special,     false, Monitor::_safepoint_check_never);</span>
  #endif
  
<span class="line-modified">!   def(CodeHeapStateAnalytics_lock  , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(NMethodSweeperStats_lock     , PaddedMutex  , special,     true,  Monitor::_safepoint_check_sometimes);</span>
<span class="line-modified">!   def(ThreadsSMRDelete_lock        , PaddedMonitor, special,     false, Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(SharedDecoder_lock           , PaddedMutex  , native,      false, Monitor::_safepoint_check_never);</span>
<span class="line-modified">!   def(DCmdFactory_lock             , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);</span>
  #if INCLUDE_NMT
<span class="line-modified">!   def(NMTQuery_lock                , PaddedMutex  , max_nonleaf, false, Monitor::_safepoint_check_always);</span>
  #endif
<span class="line-modified">! #if INCLUDE_CDS &amp;&amp; INCLUDE_JVMTI</span>
<span class="line-modified">!   def(CDSClassFileStream_lock      , PaddedMutex  , max_nonleaf, false, Monitor::_safepoint_check_always);</span>
  #endif
  }
  
<span class="line-modified">! GCMutexLocker::GCMutexLocker(Monitor * mutex) {</span>
    if (SafepointSynchronize::is_at_safepoint()) {
      _locked = false;
    } else {
      _mutex = mutex;
      _locked = true;
<span class="line-new-header">--- 174,187 ---</span>
    if (op != NULL &amp;&amp; op-&gt;calling_thread() == lock-&gt;owner()) return;
    fatal(&quot;must own lock %s&quot;, lock-&gt;name());
  }
  
  // a weaker assertion than the above
<span class="line-modified">! void assert_locked_or_safepoint_weak(const Mutex* lock) {</span>
    assert(lock != NULL, &quot;Need non-NULL lock&quot;);
    if (lock-&gt;is_locked()) return;
    if (SafepointSynchronize::is_at_safepoint()) return;
    if (!Universe::is_fully_initialized()) return;
    fatal(&quot;must own lock %s&quot;, lock-&gt;name());
  }
  
  // a stronger assertion than the above
<span class="line-modified">! void assert_lock_strong(const Mutex* lock) {</span>
    assert(lock != NULL, &quot;Need non-NULL lock&quot;);
    if (lock-&gt;owned_by_self()) return;
    fatal(&quot;must own lock %s&quot;, lock-&gt;name());
  }
<span class="line-added">+ </span>
<span class="line-added">+ void assert_locked_or_safepoint_or_handshake(const Mutex* lock, const JavaThread* thread) {</span>
<span class="line-added">+   if (Thread::current()-&gt;is_VM_thread() &amp;&amp; thread-&gt;is_vmthread_processing_handshake()) return;</span>
<span class="line-added">+   assert_locked_or_safepoint(lock);</span>
<span class="line-added">+ }</span>
  #endif
  
  #define def(var, type, pri, vm_block, safepoint_check_allowed ) {      \
<span class="line-modified">!   var = new type(Mutex::pri, #var, vm_block, Mutex::safepoint_check_allowed); \</span>
    assert(_num_mutex &lt; MAX_NUM_MUTEX, &quot;increase MAX_NUM_MUTEX&quot;);        \
    _mutex_array[_num_mutex++] = var;                                      \
  }
  
  // Using Padded subclasses to prevent false sharing of these global monitors and mutexes.
  void mutex_init() {
<span class="line-modified">!   def(tty_lock                     , PaddedMutex  , tty,         true,  _safepoint_check_never);      // allow to lock in VM</span>
  
<span class="line-modified">!   def(CGC_lock                     , PaddedMonitor, special,     true,  _safepoint_check_never);      // coordinate between fore- and background GC</span>
<span class="line-modified">!   def(STS_lock                     , PaddedMonitor, leaf,        true,  _safepoint_check_never);</span>
  
<span class="line-modified">!   def(FullGCCount_lock             , PaddedMonitor, leaf,        true,  _safepoint_check_never);      // in support of ExplicitGCInvokesConcurrent</span>
    if (UseG1GC) {
<span class="line-modified">!     def(G1OldGCCount_lock          , PaddedMonitor, leaf,        true,  _safepoint_check_always);</span>
  
<span class="line-modified">!     def(Shared_DirtyCardQ_lock     , PaddedMutex  , access + 1,  true,  _safepoint_check_never);</span>
  
<span class="line-modified">!     def(FreeList_lock              , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);</span>
<span class="line-modified">!     def(OldSets_lock               , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);</span>
<span class="line-modified">!     def(RootRegionScan_lock        , PaddedMonitor, leaf     ,   true,  _safepoint_check_never);</span>
  
<span class="line-modified">!     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">!     def(StringDedupTable_lock      , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
  
<span class="line-modified">!     def(MarkStackFreeList_lock     , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);</span>
<span class="line-modified">!     def(MarkStackChunkList_lock    , PaddedMutex  , leaf     ,   true,  _safepoint_check_never);</span>
  
<span class="line-modified">!     def(MonitoringSupport_lock     , PaddedMutex  , native   ,   true,  _safepoint_check_never);      // used for serviceability monitoring support</span>
    }
    if (UseShenandoahGC) {
<span class="line-modified">!     def(StringDedupQueue_lock      , PaddedMonitor, leaf,        true,  _safepoint_check_never);</span>
<span class="line-added">+     def(StringDedupTable_lock      , PaddedMutex  , leaf + 1,    true,  _safepoint_check_never);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   def(ParGCRareEvent_lock          , PaddedMutex  , leaf     ,   true,  _safepoint_check_always);</span>
<span class="line-added">+   def(CGCPhaseManager_lock         , PaddedMonitor, leaf,        false, _safepoint_check_always);</span>
<span class="line-added">+   def(CodeCache_lock               , PaddedMonitor, special,     true,  _safepoint_check_never);</span>
<span class="line-added">+   def(RawMonitor_lock              , PaddedMutex  , special,     true,  _safepoint_check_never);</span>
<span class="line-added">+   def(OopMapCacheAlloc_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for oop_map_cache allocation.</span>
<span class="line-added">+ </span>
<span class="line-added">+   def(MetaspaceExpand_lock         , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);</span>
<span class="line-added">+   def(ClassLoaderDataGraph_lock    , PaddedMutex  , nonleaf,     false, _safepoint_check_always);</span>
  
<span class="line-modified">!   def(Patching_lock                , PaddedMutex  , special,     true,  _safepoint_check_never);      // used for safepointing and code patching.</span>
<span class="line-modified">!   def(CompiledMethod_lock          , PaddedMutex  , special-1,   true,  _safepoint_check_never);</span>
<span class="line-added">+   def(Service_lock                 , PaddedMonitor, special,     true,  _safepoint_check_never);      // used for service thread operations</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (UseNotificationThread) {</span>
<span class="line-added">+     def(Notification_lock            , PaddedMonitor, special,     true,  _safepoint_check_never);  // used for notification thread operations</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     Notification_lock = Service_lock;</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   def(JmethodIdCreation_lock       , PaddedMutex  , leaf,        true,  _safepoint_check_never); // used for creating jmethodIDs.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(SystemDictionary_lock        , PaddedMonitor, leaf,        true,  _safepoint_check_always);</span>
<span class="line-modified">!   def(ProtectionDomainSet_lock     , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(SharedDictionary_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always);</span>
<span class="line-modified">!   def(Module_lock                  , PaddedMutex  , leaf+2,      false, _safepoint_check_always);</span>
<span class="line-modified">!   def(InlineCacheBuffer_lock       , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(VMStatistic_lock             , PaddedMutex  , leaf,        false, _safepoint_check_always);</span>
<span class="line-modified">!   def(ExpandHeap_lock              , PaddedMutex  , leaf,        true,  _safepoint_check_always); // Used during compilation by VM thread</span>
<span class="line-modified">!   def(JNIHandleBlockFreeList_lock  , PaddedMutex  , leaf-1,      true,  _safepoint_check_never);      // handles are used by VM thread</span>
<span class="line-modified">!   def(SignatureHandlerLibrary_lock , PaddedMutex  , leaf,        false, _safepoint_check_always);</span>
<span class="line-modified">!   def(SymbolArena_lock             , PaddedMutex  , leaf+2,      true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(ProfilePrint_lock            , PaddedMutex  , leaf,        false, _safepoint_check_always); // serial profile printing</span>
<span class="line-modified">!   def(ExceptionCache_lock          , PaddedMutex  , leaf,        false, _safepoint_check_always); // serial profile printing</span>
<span class="line-modified">!   def(Debug1_lock                  , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
  #ifndef PRODUCT
<span class="line-modified">!   def(FullGCALot_lock              , PaddedMutex  , leaf,        false, _safepoint_check_always); // a lock to make FullGCALot MT safe</span>
  #endif
<span class="line-modified">!   def(BeforeExit_lock              , PaddedMonitor, leaf,        true,  _safepoint_check_always);</span>
<span class="line-modified">!   def(PerfDataMemAlloc_lock        , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for allocating PerfData memory for performance data</span>
<span class="line-modified">!   def(PerfDataManager_lock         , PaddedMutex  , leaf,        true,  _safepoint_check_always); // used for synchronized access to PerfDataManager resources</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(Threads_lock                 , PaddedMonitor, barrier,     true,  _safepoint_check_always);  // Used for safepoint protocol.</span>
<span class="line-modified">!   def(NonJavaThreadsList_lock      , PaddedMutex,   leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(NonJavaThreadsListSync_lock  , PaddedMutex,   leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(VMOperationQueue_lock        , PaddedMonitor, nonleaf,     true,  _safepoint_check_never);  // VM_thread allowed to block on these</span>
<span class="line-modified">!   def(VMOperationRequest_lock      , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);</span>
<span class="line-modified">!   def(RetData_lock                 , PaddedMutex  , nonleaf,     false, _safepoint_check_always);</span>
<span class="line-modified">!   def(Terminator_lock              , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);</span>
<span class="line-modified">!   def(InitCompleted_lock           , PaddedMonitor, leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(VtableStubs_lock             , PaddedMutex  , nonleaf,     true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(Notify_lock                  , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);</span>
<span class="line-modified">!   def(JNICritical_lock             , PaddedMonitor, nonleaf,     true,  _safepoint_check_always); // used for JNI critical regions</span>
<span class="line-modified">!   def(AdapterHandlerLibrary_lock   , PaddedMutex  , nonleaf,     true,  _safepoint_check_always);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(Heap_lock                    , PaddedMonitor, nonleaf+1,   false, _safepoint_check_sometimes);  // Doesn&#39;t safepoint check during termination.</span>
<span class="line-modified">!   def(JfieldIdCreation_lock        , PaddedMutex  , nonleaf+1,   true,  _safepoint_check_always); // jfieldID, Used in VM_Operation</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(CompiledIC_lock              , PaddedMutex  , nonleaf+2,   false, _safepoint_check_never);      // locks VtableStubs_lock, InlineCacheBuffer_lock</span>
<span class="line-modified">!   def(CompileTaskAlloc_lock        , PaddedMutex  , nonleaf+2,   true,  _safepoint_check_always);</span>
<span class="line-modified">!   def(CompileStatistics_lock       , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always);</span>
<span class="line-modified">!   def(DirectivesStack_lock         , PaddedMutex  , special,     true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(MultiArray_lock              , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(JvmtiThreadState_lock        , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always); // Used by JvmtiThreadState/JvmtiEventController</span>
<span class="line-modified">!   def(Management_lock              , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always); // used for JVM management</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(Compile_lock                 , PaddedMutex  , nonleaf+3,   false, _safepoint_check_always);</span>
<span class="line-modified">!   def(MethodData_lock              , PaddedMutex  , nonleaf+3,   false, _safepoint_check_always);</span>
<span class="line-modified">!   def(TouchedMethodLog_lock        , PaddedMutex  , nonleaf+3,   false, _safepoint_check_always);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   def(MethodCompileQueue_lock      , PaddedMonitor, nonleaf+4,   false, _safepoint_check_always);</span>
<span class="line-modified">!   def(Debug2_lock                  , PaddedMutex  , nonleaf+4,   true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(Debug3_lock                  , PaddedMutex  , nonleaf+4,   true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(CompileThread_lock           , PaddedMonitor, nonleaf+5,   false, _safepoint_check_always);</span>
<span class="line-modified">!   def(PeriodicTask_lock            , PaddedMonitor, nonleaf+5,   true,  _safepoint_check_always);</span>
<span class="line-modified">!   def(RedefineClasses_lock         , PaddedMonitor, nonleaf+5,   true,  _safepoint_check_always);</span>
<span class="line-modified">!   def(Verify_lock                  , PaddedMutex,   nonleaf+5,   true,  _safepoint_check_always);</span>
  
    if (WhiteBoxAPI) {
<span class="line-modified">!     def(Compilation_lock           , PaddedMonitor, leaf,        false, _safepoint_check_never);</span>
    }
  
  #if INCLUDE_JFR
<span class="line-modified">!   def(JfrMsg_lock                  , PaddedMonitor, leaf,        true,  _safepoint_check_always);</span>
<span class="line-modified">!   def(JfrBuffer_lock               , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(JfrStream_lock               , PaddedMutex  , nonleaf + 1, false, _safepoint_check_never);</span>
<span class="line-modified">!   def(JfrStacktrace_lock           , PaddedMutex  , special,     true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(JfrThreadSampler_lock        , PaddedMonitor, leaf,        true,  _safepoint_check_never);</span>
  #endif
  
    TSAN_RUNTIME_ONLY(
<span class="line-modified">!     def(TsanOopMap_lock            , PaddedMutex  , special,     true,  _safepoint_check_never);</span>
    );
  
  #ifndef SUPPORTS_NATIVE_CX8
<span class="line-modified">!   def(UnsafeJlong_lock             , PaddedMutex  , special,     false, _safepoint_check_never);</span>
  #endif
  
<span class="line-modified">!   def(CodeHeapStateAnalytics_lock  , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(NMethodSweeperStats_lock     , PaddedMutex  , special,     true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(ThreadsSMRDelete_lock        , PaddedMonitor, special,     true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(ThreadIdTableCreate_lock     , PaddedMutex  , leaf,        false, _safepoint_check_always);</span>
<span class="line-modified">!   def(SharedDecoder_lock           , PaddedMutex  , native,      true,  _safepoint_check_never);</span>
<span class="line-modified">!   def(DCmdFactory_lock             , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
  #if INCLUDE_NMT
<span class="line-modified">!   def(NMTQuery_lock                , PaddedMutex  , max_nonleaf, false, _safepoint_check_always);</span>
  #endif
<span class="line-modified">! #if INCLUDE_CDS</span>
<span class="line-modified">! #if INCLUDE_JVMTI</span>
<span class="line-added">+   def(CDSClassFileStream_lock      , PaddedMutex  , max_nonleaf, false, _safepoint_check_always);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   def(DumpTimeTable_lock           , PaddedMutex  , leaf,        true,  _safepoint_check_never);</span>
<span class="line-added">+ #endif // INCLUDE_CDS</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+   def(JVMCI_lock                   , PaddedMonitor, nonleaf+2,   true,  _safepoint_check_always);</span>
  #endif
  }
  
<span class="line-modified">! GCMutexLocker::GCMutexLocker(Mutex* mutex) {</span>
    if (SafepointSynchronize::is_at_safepoint()) {
      _locked = false;
    } else {
      _mutex = mutex;
      _locked = true;
</pre>
<center><a href="mutex.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="mutexLocker.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/threadSMR.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="threadSMR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadSMR.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/threadSMR.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69 //   oop thread_obj = ...;
 70 //   :
 71 //   JavaThread *jt = NULL;
 72 //   ThreadsListHandle tlh;
 73 //   jvmtiError err = JvmtiExport::cv_oop_to_JavaThread(tlh.list(), thread_obj, &amp;jt);
 74 //   if (err != JVMTI_ERROR_NONE) {
 75 //     return err;
 76 //   }
 77 //   :  // do stuff with &#39;jt&#39;...
 78 //
 79 // A JavaThread * that is included in the ThreadsList that is held by
 80 // a ThreadsListHandle is protected as long as the ThreadsListHandle
 81 // remains in scope. The target JavaThread * may have logically exited,
 82 // but that target JavaThread * will not be deleted until it is no
 83 // longer protected by a ThreadsListHandle.
 84 
 85 
 86 // SMR Support for the Threads class.
 87 //
 88 class ThreadsSMRSupport : AllStatic {

 89   friend class SafeThreadsListPtr;  // for _nested_thread_list_max, delete_notify(), release_stable_list_wake_up() access
 90 
 91   // The coordination between ThreadsSMRSupport::release_stable_list() and
 92   // ThreadsSMRSupport::smr_delete() uses the delete_lock in order to
 93   // reduce the traffic on the Threads_lock.
 94   static Monitor* delete_lock() { return ThreadsSMRDelete_lock; }
 95 
 96   // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
 97   // -XX:+EnableThreadSMRStatistics (see thread.cpp for a
 98   // description about each field):
 99   static uint                  _delete_lock_wait_cnt;
100   static uint                  _delete_lock_wait_max;
101   // The delete_notify flag is used for proper double-check
102   // locking in order to reduce the traffic on the system wide
103   // Thread-SMR delete_lock.
104   static volatile uint         _delete_notify;
105   static volatile uint         _deleted_thread_cnt;
106   static volatile uint         _deleted_thread_time_max;
107   static volatile uint         _deleted_thread_times;
108   static ThreadsList           _bootstrap_list;
</pre>
<hr />
<pre>
141 
142  public:
143   static void add_thread(JavaThread *thread);
144   static ThreadsList* get_java_thread_list();
145   static bool is_a_protected_JavaThread_with_lock(JavaThread *thread);
146   static bool is_bootstrap_list(ThreadsList* list);
147   static void remove_thread(JavaThread *thread);
148   static void smr_delete(JavaThread *thread);
149   static void update_tlh_stats(uint millis);
150 
151   // Logging and printing support:
152   static void log_statistics();
153   static void print_info_elements_on(outputStream* st, ThreadsList* t_list);
154   static void print_info_on(outputStream* st);
155   static void print_info_on(const Thread* thread, outputStream* st);
156 };
157 
158 // A fast list of JavaThreads.
159 //
160 class ThreadsList : public CHeapObj&lt;mtThread&gt; {

161   friend class SafeThreadsListPtr;  // for {dec,inc}_nested_handle_cnt() access
162   friend class ThreadsSMRSupport;  // for _nested_handle_cnt, {add,remove}_thread(), {,set_}next_list() access
163 
164   const uint _length;
165   ThreadsList* _next_list;
166   JavaThread *const *const _threads;
167   volatile intx _nested_handle_cnt;
168 
169   template &lt;class T&gt;
170   void threads_do_dispatch(T *cl, JavaThread *const thread) const;
171 
172   ThreadsList *next_list() const        { return _next_list; }
173   void set_next_list(ThreadsList *list) { _next_list = list; }
174 
175   void inc_nested_handle_cnt();
176   void dec_nested_handle_cnt();
177 
178   static ThreadsList* add_thread(ThreadsList* list, JavaThread* java_thread);
179   static ThreadsList* remove_thread(ThreadsList* list, JavaThread* java_thread);
180 
</pre>
<hr />
<pre>
280   ~ThreadsListHandle();
281 
282   ThreadsList *list() const {
283     return _list_ptr.list();
284   }
285 
286   template &lt;class T&gt;
287   void threads_do(T *cl) const {
288     return list()-&gt;threads_do(cl);
289   }
290 
291   bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread ** jt_pp, oop * thread_oop_p);
292 
293   bool includes(JavaThread* p) {
294     return list()-&gt;includes(p);
295   }
296 
297   uint length() const {
298     return list()-&gt;length();
299   }




300 };
301 
302 // This stack allocated JavaThreadIterator is used to walk the
303 // specified ThreadsList using the following style:
304 //
305 //   JavaThreadIterator jti(t_list);
306 //   for (JavaThread *jt = jti.first(); jt != NULL; jt = jti.next()) {
307 //     ...
308 //   }
309 //
310 class JavaThreadIterator : public StackObj {
311   ThreadsList * _list;
312   uint _index;
313 
314 public:
315   JavaThreadIterator(ThreadsList *list) : _list(list), _index(0) {
316     assert(list != NULL, &quot;ThreadsList must not be NULL.&quot;);
317   }
318 
319   JavaThread *first() {
</pre>
</td>
<td>
<hr />
<pre>
 69 //   oop thread_obj = ...;
 70 //   :
 71 //   JavaThread *jt = NULL;
 72 //   ThreadsListHandle tlh;
 73 //   jvmtiError err = JvmtiExport::cv_oop_to_JavaThread(tlh.list(), thread_obj, &amp;jt);
 74 //   if (err != JVMTI_ERROR_NONE) {
 75 //     return err;
 76 //   }
 77 //   :  // do stuff with &#39;jt&#39;...
 78 //
 79 // A JavaThread * that is included in the ThreadsList that is held by
 80 // a ThreadsListHandle is protected as long as the ThreadsListHandle
 81 // remains in scope. The target JavaThread * may have logically exited,
 82 // but that target JavaThread * will not be deleted until it is no
 83 // longer protected by a ThreadsListHandle.
 84 
 85 
 86 // SMR Support for the Threads class.
 87 //
 88 class ThreadsSMRSupport : AllStatic {
<span class="line-added"> 89   friend class VMStructs;</span>
 90   friend class SafeThreadsListPtr;  // for _nested_thread_list_max, delete_notify(), release_stable_list_wake_up() access
 91 
 92   // The coordination between ThreadsSMRSupport::release_stable_list() and
 93   // ThreadsSMRSupport::smr_delete() uses the delete_lock in order to
 94   // reduce the traffic on the Threads_lock.
 95   static Monitor* delete_lock() { return ThreadsSMRDelete_lock; }
 96 
 97   // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
 98   // -XX:+EnableThreadSMRStatistics (see thread.cpp for a
 99   // description about each field):
100   static uint                  _delete_lock_wait_cnt;
101   static uint                  _delete_lock_wait_max;
102   // The delete_notify flag is used for proper double-check
103   // locking in order to reduce the traffic on the system wide
104   // Thread-SMR delete_lock.
105   static volatile uint         _delete_notify;
106   static volatile uint         _deleted_thread_cnt;
107   static volatile uint         _deleted_thread_time_max;
108   static volatile uint         _deleted_thread_times;
109   static ThreadsList           _bootstrap_list;
</pre>
<hr />
<pre>
142 
143  public:
144   static void add_thread(JavaThread *thread);
145   static ThreadsList* get_java_thread_list();
146   static bool is_a_protected_JavaThread_with_lock(JavaThread *thread);
147   static bool is_bootstrap_list(ThreadsList* list);
148   static void remove_thread(JavaThread *thread);
149   static void smr_delete(JavaThread *thread);
150   static void update_tlh_stats(uint millis);
151 
152   // Logging and printing support:
153   static void log_statistics();
154   static void print_info_elements_on(outputStream* st, ThreadsList* t_list);
155   static void print_info_on(outputStream* st);
156   static void print_info_on(const Thread* thread, outputStream* st);
157 };
158 
159 // A fast list of JavaThreads.
160 //
161 class ThreadsList : public CHeapObj&lt;mtThread&gt; {
<span class="line-added">162   friend class VMStructs;</span>
163   friend class SafeThreadsListPtr;  // for {dec,inc}_nested_handle_cnt() access
164   friend class ThreadsSMRSupport;  // for _nested_handle_cnt, {add,remove}_thread(), {,set_}next_list() access
165 
166   const uint _length;
167   ThreadsList* _next_list;
168   JavaThread *const *const _threads;
169   volatile intx _nested_handle_cnt;
170 
171   template &lt;class T&gt;
172   void threads_do_dispatch(T *cl, JavaThread *const thread) const;
173 
174   ThreadsList *next_list() const        { return _next_list; }
175   void set_next_list(ThreadsList *list) { _next_list = list; }
176 
177   void inc_nested_handle_cnt();
178   void dec_nested_handle_cnt();
179 
180   static ThreadsList* add_thread(ThreadsList* list, JavaThread* java_thread);
181   static ThreadsList* remove_thread(ThreadsList* list, JavaThread* java_thread);
182 
</pre>
<hr />
<pre>
282   ~ThreadsListHandle();
283 
284   ThreadsList *list() const {
285     return _list_ptr.list();
286   }
287 
288   template &lt;class T&gt;
289   void threads_do(T *cl) const {
290     return list()-&gt;threads_do(cl);
291   }
292 
293   bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread ** jt_pp, oop * thread_oop_p);
294 
295   bool includes(JavaThread* p) {
296     return list()-&gt;includes(p);
297   }
298 
299   uint length() const {
300     return list()-&gt;length();
301   }
<span class="line-added">302 </span>
<span class="line-added">303   JavaThread *thread_at(uint i) const {</span>
<span class="line-added">304     return list()-&gt;thread_at(i);</span>
<span class="line-added">305   }</span>
306 };
307 
308 // This stack allocated JavaThreadIterator is used to walk the
309 // specified ThreadsList using the following style:
310 //
311 //   JavaThreadIterator jti(t_list);
312 //   for (JavaThread *jt = jti.first(); jt != NULL; jt = jti.next()) {
313 //     ...
314 //   }
315 //
316 class JavaThreadIterator : public StackObj {
317   ThreadsList * _list;
318   uint _index;
319 
320 public:
321   JavaThreadIterator(ThreadsList *list) : _list(list), _index(0) {
322     assert(list != NULL, &quot;ThreadsList must not be NULL.&quot;);
323   }
324 
325   JavaThread *first() {
</pre>
</td>
</tr>
</table>
<center><a href="threadSMR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadSMR.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
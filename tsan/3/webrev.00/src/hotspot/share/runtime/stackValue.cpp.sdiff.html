<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/stackValue.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="signature.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubCodeGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/stackValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/debugInfo.hpp&quot;
 27 #include &quot;oops/compressedOops.inline.hpp&quot;
 28 #include &quot;oops/oop.hpp&quot;
 29 #include &quot;runtime/frame.inline.hpp&quot;
 30 #include &quot;runtime/handles.inline.hpp&quot;
 31 #include &quot;runtime/stackValue.hpp&quot;
 32 #if INCLUDE_ZGC
 33 #include &quot;gc/z/zBarrier.inline.hpp&quot;
 34 #endif



 35 
 36 StackValue* StackValue::create_stack_value(const frame* fr, const RegisterMap* reg_map, ScopeValue* sv) {
 37   if (sv-&gt;is_location()) {
 38     // Stack or register value
 39     Location loc = ((LocationValue *)sv)-&gt;location();
 40 
 41 #ifdef SPARC
 42     // %%%%% Callee-save floats will NOT be working on a Sparc until we
 43     // handle the case of a 2 floats in a single double register.
 44     assert( !(loc.is_register() &amp;&amp; loc.type() == Location::float_in_dbl), &quot;Sparc does not handle callee-save floats yet&quot; );
 45 #endif // SPARC
 46 
 47     // First find address of value
 48 
 49     address value_addr = loc.is_register()
 50       // Value was in a callee-save register
 51       ? reg_map-&gt;location(VMRegImpl::as_VMReg(loc.register_number()))
 52       // Else value was directly saved on the stack. The frame&#39;s original stack pointer,
 53       // before any extension by its callee (due to Compiler1 linkage on SPARC), must be used.
 54       : ((address)fr-&gt;unextended_sp()) + loc.stack_offset();
</pre>
<hr />
<pre>
 89     }
 90 #ifdef _LP64
 91     case Location::dbl:
 92       // Double value in an aligned adjacent pair
 93       return new StackValue(*(intptr_t*)value_addr);
 94     case Location::lng:
 95       // Long   value in an aligned adjacent pair
 96       return new StackValue(*(intptr_t*)value_addr);
 97     case Location::narrowoop: {
 98       union { intptr_t p; narrowOop noop;} value;
 99       value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);
100       if (loc.is_register()) {
101         // The callee has no clue whether the register holds an int,
102         // long or is unused.  He always saves a long.  Here we know
103         // a long was saved, but we only want an int back.  Narrow the
104         // saved long to the int that the JVM wants.
105         value.noop =  (narrowOop) *(julong*) value_addr;
106       } else {
107         value.noop = *(narrowOop*) value_addr;
108       }
<span class="line-modified">109       // Decode narrowoop and wrap a handle around the oop</span>
<span class="line-modified">110       Handle h(Thread::current(), CompressedOops::decode(value.noop));</span>







111       return new StackValue(h);
112     }
113 #endif
114     case Location::oop: {
115       oop val = *(oop *)value_addr;
116 #ifdef _LP64
<span class="line-modified">117       if (Universe::is_narrow_oop_base(val)) {</span>
118          // Compiled code may produce decoded oop = narrow_oop_base
119          // when a narrow oop implicit null check is used.
120          // The narrow_oop_base could be NULL or be the address
121          // of the page below heap. Use NULL value for both cases.
122          val = (oop)NULL;
123       }
124 #endif
<span class="line-modified">125 #if INCLUDE_ZGC</span>
<span class="line-modified">126       // Deoptimization must make sure all oop have passed load barrier</span>
<span class="line-modified">127       if (UseZGC) {</span>
<span class="line-modified">128         val = ZBarrier::load_barrier_on_oop_field_preloaded((oop*)value_addr, val);</span>
129       }
130 #endif
<span class="line-modified">131 </span>
132       Handle h(Thread::current(), val); // Wrap a handle around the oop
133       return new StackValue(h);
134     }
135     case Location::addr: {
136       ShouldNotReachHere(); // both C1 and C2 now inline jsrs
137     }
138     case Location::normal: {
139       // Just copy all other bits straight through
140       union { intptr_t p; jint ji;} value;
141       value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);
142       value.ji = *(jint*)value_addr;
143       return new StackValue(value.p);
144     }
145     case Location::invalid:
146       return new StackValue();
147     default:
148       ShouldNotReachHere();
149     }
150 
151   } else if (sv-&gt;is_constant_int()) {
</pre>
<hr />
<pre>
194   // The frame&#39;s original stack pointer, before any extension by its callee
195   // (due to Compiler1 linkage on SPARC), must be used.
196   return (BasicLock*) (fr-&gt;unextended_sp() + word_offset);
197 }
198 
199 
200 #ifndef PRODUCT
201 
202 void StackValue::print_on(outputStream* st) const {
203   switch(_type) {
204     case T_INT:
205       st-&gt;print(&quot;%d (int) %f (float) %x (hex)&quot;,  *(int *)&amp;_integer_value, *(float *)&amp;_integer_value,  *(int *)&amp;_integer_value);
206       break;
207 
208     case T_OBJECT:
209       if (_handle_value() != NULL) {
210         _handle_value()-&gt;print_value_on(st);
211       } else {
212         st-&gt;print(&quot;NULL&quot;);
213       }
<span class="line-modified">214       st-&gt;print(&quot; &lt;&quot; INTPTR_FORMAT &quot;&gt;&quot;, p2i((address)_handle_value()));</span>
215      break;
216 
217     case T_CONFLICT:
218      st-&gt;print(&quot;conflict&quot;);
219      break;
220 
221     default:
222      ShouldNotReachHere();
223   }
224 }
225 
226 #endif
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/debugInfo.hpp&quot;
 27 #include &quot;oops/compressedOops.inline.hpp&quot;
 28 #include &quot;oops/oop.hpp&quot;
 29 #include &quot;runtime/frame.inline.hpp&quot;
 30 #include &quot;runtime/handles.inline.hpp&quot;
 31 #include &quot;runtime/stackValue.hpp&quot;
 32 #if INCLUDE_ZGC
 33 #include &quot;gc/z/zBarrier.inline.hpp&quot;
 34 #endif
<span class="line-added"> 35 #if INCLUDE_SHENANDOAHGC</span>
<span class="line-added"> 36 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;</span>
<span class="line-added"> 37 #endif</span>
 38 
 39 StackValue* StackValue::create_stack_value(const frame* fr, const RegisterMap* reg_map, ScopeValue* sv) {
 40   if (sv-&gt;is_location()) {
 41     // Stack or register value
 42     Location loc = ((LocationValue *)sv)-&gt;location();
 43 
 44 #ifdef SPARC
 45     // %%%%% Callee-save floats will NOT be working on a Sparc until we
 46     // handle the case of a 2 floats in a single double register.
 47     assert( !(loc.is_register() &amp;&amp; loc.type() == Location::float_in_dbl), &quot;Sparc does not handle callee-save floats yet&quot; );
 48 #endif // SPARC
 49 
 50     // First find address of value
 51 
 52     address value_addr = loc.is_register()
 53       // Value was in a callee-save register
 54       ? reg_map-&gt;location(VMRegImpl::as_VMReg(loc.register_number()))
 55       // Else value was directly saved on the stack. The frame&#39;s original stack pointer,
 56       // before any extension by its callee (due to Compiler1 linkage on SPARC), must be used.
 57       : ((address)fr-&gt;unextended_sp()) + loc.stack_offset();
</pre>
<hr />
<pre>
 92     }
 93 #ifdef _LP64
 94     case Location::dbl:
 95       // Double value in an aligned adjacent pair
 96       return new StackValue(*(intptr_t*)value_addr);
 97     case Location::lng:
 98       // Long   value in an aligned adjacent pair
 99       return new StackValue(*(intptr_t*)value_addr);
100     case Location::narrowoop: {
101       union { intptr_t p; narrowOop noop;} value;
102       value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);
103       if (loc.is_register()) {
104         // The callee has no clue whether the register holds an int,
105         // long or is unused.  He always saves a long.  Here we know
106         // a long was saved, but we only want an int back.  Narrow the
107         // saved long to the int that the JVM wants.
108         value.noop =  (narrowOop) *(julong*) value_addr;
109       } else {
110         value.noop = *(narrowOop*) value_addr;
111       }
<span class="line-modified">112       // Decode narrowoop</span>
<span class="line-modified">113       oop val = CompressedOops::decode(value.noop);</span>
<span class="line-added">114       // Deoptimization must make sure all oops have passed load barriers</span>
<span class="line-added">115 #if INCLUDE_SHENANDOAHGC</span>
<span class="line-added">116       if (UseShenandoahGC) {</span>
<span class="line-added">117         val = ShenandoahBarrierSet::barrier_set()-&gt;load_reference_barrier(val);</span>
<span class="line-added">118       }</span>
<span class="line-added">119 #endif</span>
<span class="line-added">120       Handle h(Thread::current(), val); // Wrap a handle around the oop</span>
121       return new StackValue(h);
122     }
123 #endif
124     case Location::oop: {
125       oop val = *(oop *)value_addr;
126 #ifdef _LP64
<span class="line-modified">127       if (CompressedOops::is_base(val)) {</span>
128          // Compiled code may produce decoded oop = narrow_oop_base
129          // when a narrow oop implicit null check is used.
130          // The narrow_oop_base could be NULL or be the address
131          // of the page below heap. Use NULL value for both cases.
132          val = (oop)NULL;
133       }
134 #endif
<span class="line-modified">135       // Deoptimization must make sure all oops have passed load barriers</span>
<span class="line-modified">136 #if INCLUDE_SHENANDOAHGC</span>
<span class="line-modified">137       if (UseShenandoahGC) {</span>
<span class="line-modified">138         val = ShenandoahBarrierSet::barrier_set()-&gt;load_reference_barrier(val);</span>
139       }
140 #endif
<span class="line-modified">141       assert(oopDesc::is_oop_or_null(val, false), &quot;bad oop found&quot;);</span>
142       Handle h(Thread::current(), val); // Wrap a handle around the oop
143       return new StackValue(h);
144     }
145     case Location::addr: {
146       ShouldNotReachHere(); // both C1 and C2 now inline jsrs
147     }
148     case Location::normal: {
149       // Just copy all other bits straight through
150       union { intptr_t p; jint ji;} value;
151       value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);
152       value.ji = *(jint*)value_addr;
153       return new StackValue(value.p);
154     }
155     case Location::invalid:
156       return new StackValue();
157     default:
158       ShouldNotReachHere();
159     }
160 
161   } else if (sv-&gt;is_constant_int()) {
</pre>
<hr />
<pre>
204   // The frame&#39;s original stack pointer, before any extension by its callee
205   // (due to Compiler1 linkage on SPARC), must be used.
206   return (BasicLock*) (fr-&gt;unextended_sp() + word_offset);
207 }
208 
209 
210 #ifndef PRODUCT
211 
212 void StackValue::print_on(outputStream* st) const {
213   switch(_type) {
214     case T_INT:
215       st-&gt;print(&quot;%d (int) %f (float) %x (hex)&quot;,  *(int *)&amp;_integer_value, *(float *)&amp;_integer_value,  *(int *)&amp;_integer_value);
216       break;
217 
218     case T_OBJECT:
219       if (_handle_value() != NULL) {
220         _handle_value()-&gt;print_value_on(st);
221       } else {
222         st-&gt;print(&quot;NULL&quot;);
223       }
<span class="line-modified">224       st-&gt;print(&quot; &lt;&quot; INTPTR_FORMAT &quot;&gt;&quot;, p2i(_handle_value()));</span>
225      break;
226 
227     case T_CONFLICT:
228      st-&gt;print(&quot;conflict&quot;);
229      break;
230 
231     default:
232      ShouldNotReachHere();
233   }
234 }
235 
236 #endif
</pre>
</td>
</tr>
</table>
<center><a href="signature.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubCodeGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
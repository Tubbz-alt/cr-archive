<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/rtmLocking.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_RTMLOCKING_HPP
 26 #define SHARE_RUNTIME_RTMLOCKING_HPP
 27 
 28 // Generate RTM (Restricted Transactional Memory) locking code for all inflated
 29 // locks when &quot;UseRTMLocking&quot; option is on with normal locking mechanism as fall back
 30 // handler.
 31 //
 32 // On abort/lock busy the lock will be retried a fixed number of times under RTM
 33 // as specified by &quot;RTMRetryCount&quot; option. The locks which abort too often
 34 // can be auto tuned or manually tuned.
 35 //
 36 // Auto-tuning can be done on an option like UseRTMDeopt and it will need abort
 37 // ratio calculation for each lock. The abort ratio will be calculated after
 38 // &quot;RTMAbortThreshold&quot; number of aborts is reached. The formulas are:
 39 //
 40 //     Aborted transactions = abort_count * 100
 41 //     All transactions = total_count *  RTMTotalCountIncrRate
 42 //
 43 //     Aborted transactions &gt;= All transactions * RTMAbortRatio
 44 //
 45 // If &quot;UseRTMDeopt&quot; is on and the aborts ratio reaches &quot;RTMAbortRatio&quot;
 46 // the method containing the lock will be deoptimized and recompiled with
 47 // all locks as normal locks. If the abort ratio continues to remain low after
 48 // &quot;RTMLockingThreshold&quot; locks are attempted, then the method will be deoptimized
 49 // and recompiled with all locks as RTM locks without abort ratio calculation code.
 50 // The abort ratio calculation can be delayed by specifying flag
 51 // -XX:RTMLockingCalculationDelay in millisecond.
 52 //
 53 // For manual tuning the abort statistics for each lock needs to be provided
 54 // to the user on some JVM option like &quot;PrintPreciseRTMLockingStatistics&quot;.
 55 // Based on the abort statistics users can create a .hotspot_compiler file
 56 // or use -XX:CompileCommand=option,class::method,NoRTMLockEliding
 57 // to specify for which methods to disable RTM locking.
 58 //
 59 // When UseRTMForStackLocks option is enabled along with UseRTMLocking option,
 60 // the RTM locking code is generated for stack locks too.
 61 // The retries, auto-tuning support and rtm locking statistics are all
 62 // supported for stack locks just like inflated locks.
 63 
 64 // RTM locking counters
 65 class RTMLockingCounters {
 66  private:
 67   uintx _total_count; // Total RTM locks count
 68   uintx _abort_count; // Total aborts count
 69 
 70  public:
 71   enum { ABORT_STATUS_LIMIT = 6 };
 72   // Counters per RTM Abort Status. Incremented with +PrintPreciseRTMLockingStatistics
 73   // RTM uses the EAX register to communicate abort status to software.
 74   // Following an RTM abort the EAX register has the following definition.
 75   //
 76   //   EAX register bit position   Meaning
 77   //     0     Set if abort caused by XABORT instruction.
 78   //     1     If set, the transaction may succeed on a retry. This bit is always clear if bit 0 is set.
 79   //     2     Set if another logical processor conflicted with a memory address that was part of the transaction that aborted.
 80   //     3     Set if an internal buffer overflowed.
 81   //     4     Set if a debug breakpoint was hit.
 82   //     5     Set if an abort occurred during execution of a nested transaction.
 83  private:
 84   uintx _abortX_count[ABORT_STATUS_LIMIT];
 85 
 86  public:
 87   static uintx _calculation_flag;
 88   static uintx* rtm_calculation_flag_addr() { return &amp;_calculation_flag; }
 89 
 90   static void init();
 91 
 92   RTMLockingCounters() : _total_count(0), _abort_count(0) {
 93     for (int i = 0; i &lt; ABORT_STATUS_LIMIT; i++) {
 94       _abortX_count[i] = 0;
 95     }
 96   }
 97 
 98   uintx* total_count_addr()               { return &amp;_total_count; }
 99   uintx* abort_count_addr()               { return &amp;_abort_count; }
100   uintx* abortX_count_addr()              { return &amp;_abortX_count[0]; }
101 
102   static int total_count_offset()         { return (int)offset_of(RTMLockingCounters, _total_count); }
103   static int abort_count_offset()         { return (int)offset_of(RTMLockingCounters, _abort_count); }
104   static int abortX_count_offset()        { return (int)offset_of(RTMLockingCounters, _abortX_count[0]); }
105 
106 
107   bool nonzero() {  return (_abort_count + _total_count) &gt; 0; }
108 
109   void print_on(outputStream* st);
110   void print() { print_on(tty); }
111 };
112 
113 #endif // SHARE_RUNTIME_RTMLOCKING_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/task.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;runtime/init.hpp&quot;
 28 #include &quot;runtime/task.hpp&quot;
 29 #include &quot;runtime/thread.inline.hpp&quot;
 30 #include &quot;runtime/timer.hpp&quot;
 31 
 32 int PeriodicTask::_num_tasks = 0;
 33 PeriodicTask* PeriodicTask::_tasks[PeriodicTask::max_tasks];
 34 
 35 void PeriodicTask::real_time_tick(int delay_time) {
 36   assert(Thread::current()-&gt;is_Watcher_thread(), &quot;must be WatcherThread&quot;);
 37 
 38   // The WatcherThread does not participate in the safepoint protocol
 39   // for the PeriodicTask_lock because it is not a JavaThread.
 40   MutexLockerEx ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);
 41   int orig_num_tasks = _num_tasks;
 42 
 43   for(int index = 0; index &lt; _num_tasks; index++) {
 44     _tasks[index]-&gt;execute_if_pending(delay_time);
 45     if (_num_tasks &lt; orig_num_tasks) { // task dis-enrolled itself
 46       index--;  // re-do current slot as it has changed
 47       orig_num_tasks = _num_tasks;
 48     }
 49   }
 50 }
 51 
 52 int PeriodicTask::time_to_wait() {
 53   assert(PeriodicTask_lock-&gt;owned_by_self(), &quot;PeriodicTask_lock required&quot;);
 54 
 55   if (_num_tasks == 0) {
 56     return 0; // sleep until shutdown or a task is enrolled
 57   }
 58 
 59   int delay = _tasks[0]-&gt;time_to_next_interval();
 60   for (int index = 1; index &lt; _num_tasks; index++) {
 61     delay = MIN2(delay, _tasks[index]-&gt;time_to_next_interval());
 62   }
 63   return delay;
 64 }
 65 
 66 
 67 PeriodicTask::PeriodicTask(size_t interval_time) :
 68   _counter(0), _interval((int) interval_time) {
 69   // Sanity check the interval time
 70   assert(_interval &gt;= PeriodicTask::min_interval &amp;&amp;
 71          _interval %  PeriodicTask::interval_gran == 0,
 72               &quot;improper PeriodicTask interval time&quot;);
 73 }
 74 
 75 PeriodicTask::~PeriodicTask() {
 76   // This PeriodicTask may have already been disenrolled by a call
 77   // to disenroll() before the PeriodicTask was deleted.
 78   disenroll();
 79 }
 80 
 81 // enroll the current PeriodicTask
 82 void PeriodicTask::enroll() {
 83   // Follow normal safepoint aware lock enter protocol if the caller does
 84   // not already own the PeriodicTask_lock. Otherwise, we don&#39;t try to
 85   // enter it again because VM internal Mutexes do not support recursion.
 86   //
 87   MutexLockerEx ml(PeriodicTask_lock-&gt;owned_by_self() ? NULL
 88                                                       : PeriodicTask_lock);
 89 
 90   if (_num_tasks == PeriodicTask::max_tasks) {
 91     fatal(&quot;Overflow in PeriodicTask table&quot;);
 92   } else {
 93     _tasks[_num_tasks++] = this;
 94   }
 95 
 96   WatcherThread* thread = WatcherThread::watcher_thread();
 97   if (thread != NULL) {
 98     thread-&gt;unpark();
 99   } else {
100     WatcherThread::start();
101   }
102 }
103 
104 // disenroll the current PeriodicTask
105 void PeriodicTask::disenroll() {
106   // Follow normal safepoint aware lock enter protocol if the caller does
107   // not already own the PeriodicTask_lock. Otherwise, we don&#39;t try to
108   // enter it again because VM internal Mutexes do not support recursion.
109   //
110   MutexLockerEx ml(PeriodicTask_lock-&gt;owned_by_self() ? NULL
111                                                       : PeriodicTask_lock);
112 
113   int index;
114   for(index = 0; index &lt; _num_tasks &amp;&amp; _tasks[index] != this; index++)
115     ;
116 
117   if (index == _num_tasks) {
118     return;
119   }
120 
121   _num_tasks--;
122 
123   for (; index &lt; _num_tasks; index++) {
124     _tasks[index] = _tasks[index+1];
125   }
126 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/rtmLocking.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="rtmLocking.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepoint.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/rtmLocking.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 65 class RTMLockingCounters {
 66  private:
 67   uintx _total_count; // Total RTM locks count
 68   uintx _abort_count; // Total aborts count
 69 
 70  public:
 71   enum { ABORT_STATUS_LIMIT = 6 };
 72   // Counters per RTM Abort Status. Incremented with +PrintPreciseRTMLockingStatistics
 73   // RTM uses the EAX register to communicate abort status to software.
 74   // Following an RTM abort the EAX register has the following definition.
 75   //
 76   //   EAX register bit position   Meaning
 77   //     0     Set if abort caused by XABORT instruction.
 78   //     1     If set, the transaction may succeed on a retry. This bit is always clear if bit 0 is set.
 79   //     2     Set if another logical processor conflicted with a memory address that was part of the transaction that aborted.
 80   //     3     Set if an internal buffer overflowed.
 81   //     4     Set if a debug breakpoint was hit.
 82   //     5     Set if an abort occurred during execution of a nested transaction.
 83  private:
 84   uintx _abortX_count[ABORT_STATUS_LIMIT];

 85 
 86  public:
 87   static uintx _calculation_flag;
 88   static uintx* rtm_calculation_flag_addr() { return &amp;_calculation_flag; }
 89 
 90   static void init();
 91 
 92   RTMLockingCounters() : _total_count(0), _abort_count(0) {
 93     for (int i = 0; i &lt; ABORT_STATUS_LIMIT; i++) {
 94       _abortX_count[i] = 0;
 95     }
 96   }
 97 
 98   uintx* total_count_addr()               { return &amp;_total_count; }
 99   uintx* abort_count_addr()               { return &amp;_abort_count; }
100   uintx* abortX_count_addr()              { return &amp;_abortX_count[0]; }
101 
102   static int total_count_offset()         { return (int)offset_of(RTMLockingCounters, _total_count); }
103   static int abort_count_offset()         { return (int)offset_of(RTMLockingCounters, _abort_count); }
104   static int abortX_count_offset()        { return (int)offset_of(RTMLockingCounters, _abortX_count[0]); }
105 
106 
107   bool nonzero() {  return (_abort_count + _total_count) &gt; 0; }
108 
<span class="line-modified">109   void print_on(outputStream* st);</span>
<span class="line-modified">110   void print() { print_on(tty); }</span>
111 };
112 
113 #endif // SHARE_RUNTIME_RTMLOCKING_HPP
</pre>
</td>
<td>
<hr />
<pre>
 65 class RTMLockingCounters {
 66  private:
 67   uintx _total_count; // Total RTM locks count
 68   uintx _abort_count; // Total aborts count
 69 
 70  public:
 71   enum { ABORT_STATUS_LIMIT = 6 };
 72   // Counters per RTM Abort Status. Incremented with +PrintPreciseRTMLockingStatistics
 73   // RTM uses the EAX register to communicate abort status to software.
 74   // Following an RTM abort the EAX register has the following definition.
 75   //
 76   //   EAX register bit position   Meaning
 77   //     0     Set if abort caused by XABORT instruction.
 78   //     1     If set, the transaction may succeed on a retry. This bit is always clear if bit 0 is set.
 79   //     2     Set if another logical processor conflicted with a memory address that was part of the transaction that aborted.
 80   //     3     Set if an internal buffer overflowed.
 81   //     4     Set if a debug breakpoint was hit.
 82   //     5     Set if an abort occurred during execution of a nested transaction.
 83  private:
 84   uintx _abortX_count[ABORT_STATUS_LIMIT];
<span class="line-added"> 85   static const char* _abortX_desc[ABORT_STATUS_LIMIT];</span>
 86 
 87  public:
 88   static uintx _calculation_flag;
 89   static uintx* rtm_calculation_flag_addr() { return &amp;_calculation_flag; }
 90 
 91   static void init();
 92 
 93   RTMLockingCounters() : _total_count(0), _abort_count(0) {
 94     for (int i = 0; i &lt; ABORT_STATUS_LIMIT; i++) {
 95       _abortX_count[i] = 0;
 96     }
 97   }
 98 
 99   uintx* total_count_addr()               { return &amp;_total_count; }
100   uintx* abort_count_addr()               { return &amp;_abort_count; }
101   uintx* abortX_count_addr()              { return &amp;_abortX_count[0]; }
102 
103   static int total_count_offset()         { return (int)offset_of(RTMLockingCounters, _total_count); }
104   static int abort_count_offset()         { return (int)offset_of(RTMLockingCounters, _abort_count); }
105   static int abortX_count_offset()        { return (int)offset_of(RTMLockingCounters, _abortX_count[0]); }
106 
107 
108   bool nonzero() {  return (_abort_count + _total_count) &gt; 0; }
109 
<span class="line-modified">110   void print_on(outputStream* st) const;</span>
<span class="line-modified">111   void print() const;</span>
112 };
113 
114 #endif // SHARE_RUNTIME_RTMLOCKING_HPP
</pre>
</td>
</tr>
</table>
<center><a href="rtmLocking.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepoint.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
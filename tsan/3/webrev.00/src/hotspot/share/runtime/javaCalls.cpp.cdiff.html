<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/javaCalls.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="java.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniHandles.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/javaCalls.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,32 ***</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jniCheck.hpp&quot;
<span class="line-removed">- #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/signature.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
<span class="line-removed">- #if INCLUDE_JVMCI</span>
<span class="line-removed">- #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
<span class="line-removed">- #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
<span class="line-removed">- #endif</span>
  
  // -----------------------------------------------------
  // Implementation of JavaCallWrapper
  
  JavaCallWrapper::JavaCallWrapper(const methodHandle&amp; callee_method, Handle receiver, JavaValue* result, TRAPS) {
<span class="line-new-header">--- 24,28 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
<span class="line-added">+ #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  #include &quot;compiler/compileBroker.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;prims/jniCheck.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/javaCalls.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/signature.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  
  // -----------------------------------------------------
  // Implementation of JavaCallWrapper
  
  JavaCallWrapper::JavaCallWrapper(const methodHandle&amp; callee_method, Handle receiver, JavaValue* result, TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,11 ***</span>
    Handle receiver = args-&gt;receiver();
    Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
    LinkInfo link_info(spec_klass, name, signature);
    LinkResolver::resolve_virtual_call(
            callinfo, receiver, recvrKlass, link_info, true, CHECK);
<span class="line-modified">!   methodHandle method = callinfo.selected_method();</span>
    assert(method.not_null(), &quot;should have thrown exception&quot;);
  
    // Invoke the method
    JavaCalls::call(result, method, args, CHECK);
  }
<span class="line-new-header">--- 184,11 ---</span>
    Handle receiver = args-&gt;receiver();
    Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
    LinkInfo link_info(spec_klass, name, signature);
    LinkResolver::resolve_virtual_call(
            callinfo, receiver, recvrKlass, link_info, true, CHECK);
<span class="line-modified">!   methodHandle method(THREAD, callinfo.selected_method());</span>
    assert(method.not_null(), &quot;should have thrown exception&quot;);
  
    // Invoke the method
    JavaCalls::call(result, method, args, CHECK);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,11 ***</span>
  
  void JavaCalls::call_special(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
    CallInfo callinfo;
    LinkInfo link_info(klass, name, signature);
    LinkResolver::resolve_special_call(callinfo, args-&gt;receiver(), link_info, CHECK);
<span class="line-modified">!   methodHandle method = callinfo.selected_method();</span>
    assert(method.not_null(), &quot;should have thrown exception&quot;);
  
    // Invoke the method
    JavaCalls::call(result, method, args, CHECK);
  }
<span class="line-new-header">--- 220,11 ---</span>
  
  void JavaCalls::call_special(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
    CallInfo callinfo;
    LinkInfo link_info(klass, name, signature);
    LinkResolver::resolve_special_call(callinfo, args-&gt;receiver(), link_info, CHECK);
<span class="line-modified">!   methodHandle method(THREAD, callinfo.selected_method());</span>
    assert(method.not_null(), &quot;should have thrown exception&quot;);
  
    // Invoke the method
    JavaCalls::call(result, method, args, CHECK);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,11 ***</span>
  
  void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
    CallInfo callinfo;
    LinkInfo link_info(klass, name, signature);
    LinkResolver::resolve_static_call(callinfo, link_info, true, CHECK);
<span class="line-modified">!   methodHandle method = callinfo.selected_method();</span>
    assert(method.not_null(), &quot;should have thrown exception&quot;);
  
    // Invoke the method
    JavaCalls::call(result, method, args, CHECK);
  }
<span class="line-new-header">--- 255,11 ---</span>
  
  void JavaCalls::call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
    CallInfo callinfo;
    LinkInfo link_info(klass, name, signature);
    LinkResolver::resolve_static_call(callinfo, link_info, true, CHECK);
<span class="line-modified">!   methodHandle method(THREAD, callinfo.selected_method());</span>
    assert(method.not_null(), &quot;should have thrown exception&quot;);
  
    // Invoke the method
    JavaCalls::call(result, method, args, CHECK);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 348,13 ***</span>
    assert(thread-&gt;is_Java_thread(), &quot;must be called by a java thread&quot;);
    assert(method.not_null(), &quot;must have a method to call&quot;);
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;call to Java code during VM operation&quot;);
    assert(!thread-&gt;handle_area()-&gt;no_handle_mark_active(), &quot;cannot call out to Java here&quot;);
  
<span class="line-removed">- </span>
<span class="line-removed">-   CHECK_UNHANDLED_OOPS_ONLY(thread-&gt;clear_unhandled_oops();)</span>
<span class="line-removed">- </span>
  #if INCLUDE_JVMCI
    // Gets the nmethod (if any) that should be called instead of normal target
    nmethod* alternative_target = args-&gt;alternative_target();
    if (alternative_target == NULL) {
  #endif
<span class="line-new-header">--- 344,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,15 ***</span>
    }
  
    // Figure out if the result value is an oop or not (Note: This is a different value
    // than result_type. result_type will be T_INT of oops. (it is about size)
    BasicType result_type = runtime_type_from(result);
<span class="line-modified">!   bool oop_result_flag = (result-&gt;get_type() == T_OBJECT || result-&gt;get_type() == T_ARRAY);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // NOTE: if we move the computation of the result_val_address inside</span>
<span class="line-removed">-   // the call to call_stub, the optimizer produces wrong code.</span>
<span class="line-removed">-   intptr_t* result_val_address = (intptr_t*)(result-&gt;get_value_addr());</span>
  
    // Find receiver
    Handle receiver = (!method-&gt;is_static()) ? args-&gt;receiver() : Handle();
  
    // When we reenter Java, we need to reenable the reserved/yellow zone which
<span class="line-new-header">--- 388,11 ---</span>
    }
  
    // Figure out if the result value is an oop or not (Note: This is a different value
    // than result_type. result_type will be T_INT of oops. (it is about size)
    BasicType result_type = runtime_type_from(result);
<span class="line-modified">!   bool oop_result_flag = is_reference_type(result-&gt;get_type());</span>
  
    // Find receiver
    Handle receiver = (!method-&gt;is_static()) ? args-&gt;receiver() : Handle();
  
    // When we reenter Java, we need to reenable the reserved/yellow zone which
</pre>
<hr />
<pre>
<span class="line-old-header">*** 438,18 ***</span>
  
    // do call
    { JavaCallWrapper link(method, receiver, result, CHECK);
      { HandleMark hm(thread);  // HandleMark used by HandleMarkCleaner
  
        StubRoutines::call_stub()(
          (address)&amp;link,
          // (intptr_t*)&amp;(result-&gt;_value), // see NOTE above (compiler problem)
          result_val_address,          // see NOTE above (compiler problem)
          result_type,
          method(),
          entry_point,
<span class="line-modified">!         args-&gt;parameters(),</span>
          args-&gt;size_of_parameters(),
          CHECK
        );
  
        result = link.result();  // circumvent MS C++ 5.0 compiler bug (result is clobbered across call)
<span class="line-new-header">--- 427,23 ---</span>
  
    // do call
    { JavaCallWrapper link(method, receiver, result, CHECK);
      { HandleMark hm(thread);  // HandleMark used by HandleMarkCleaner
  
<span class="line-added">+       // NOTE: if we move the computation of the result_val_address inside</span>
<span class="line-added">+       // the call to call_stub, the optimizer produces wrong code.</span>
<span class="line-added">+       intptr_t* result_val_address = (intptr_t*)(result-&gt;get_value_addr());</span>
<span class="line-added">+       intptr_t* parameter_address = args-&gt;parameters();</span>
<span class="line-added">+ </span>
        StubRoutines::call_stub()(
          (address)&amp;link,
          // (intptr_t*)&amp;(result-&gt;_value), // see NOTE above (compiler problem)
          result_val_address,          // see NOTE above (compiler problem)
          result_type,
          method(),
          entry_point,
<span class="line-modified">!         parameter_address,</span>
          args-&gt;size_of_parameters(),
          CHECK
        );
  
        result = link.result();  // circumvent MS C++ 5.0 compiler bug (result is clobbered across call)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 464,11 ***</span>
    // The following assert was not realistic.  Thread.stop can set that bit at any moment.
    //assert(!thread-&gt;has_special_runtime_exit_condition(), &quot;no async. exceptions should be installed&quot;);
  
    // Restore possible oop return
    if (oop_result_flag) {
<span class="line-modified">!     result-&gt;set_jobject((jobject)thread-&gt;vm_result());</span>
      thread-&gt;set_vm_result(NULL);
    }
  }
  
  
<span class="line-new-header">--- 458,11 ---</span>
    // The following assert was not realistic.  Thread.stop can set that bit at any moment.
    //assert(!thread-&gt;has_special_runtime_exit_condition(), &quot;no async. exceptions should be installed&quot;);
  
    // Restore possible oop return
    if (oop_result_flag) {
<span class="line-modified">!     result-&gt;set_jobject(cast_from_oop&lt;jobject&gt;(thread-&gt;vm_result()));</span>
      thread-&gt;set_vm_result(NULL);
    }
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 525,74 ***</span>
     BasicType _return_type;
     u_char* _value_state;
     intptr_t* _value;
  
   public:
<span class="line-removed">-   bool _is_return;</span>
<span class="line-removed">- </span>
    SignatureChekker(Symbol* signature,
                     BasicType return_type,
                     bool is_static,
                     u_char* value_state,
                     intptr_t* value) :
      SignatureIterator(signature),
      _pos(0),
      _return_type(return_type),
      _value_state(value_state),
<span class="line-modified">!     _value(value),</span>
<span class="line-removed">-     _is_return(false)</span>
    {
      if (!is_static) {
        check_value(true); // Receiver must be an oop
      }
    }
  
<span class="line-modified">!   void check_value(bool type) {</span>
      uint state = _value_state[_pos++];
<span class="line-modified">!     if (type) {</span>
        guarantee(is_value_state_indirect_oop(state),
                  &quot;signature does not match pushed arguments: %u at %d&quot;,
                  state, _pos - 1);
      } else {
        guarantee(state == JavaCallArguments::value_state_primitive,
                  &quot;signature does not match pushed arguments: %u at %d&quot;,
                  state, _pos - 1);
      }
    }
  
<span class="line-removed">-   void check_doing_return(bool state) { _is_return = state; }</span>
<span class="line-removed">- </span>
    void check_return_type(BasicType t) {
<span class="line-modified">!     guarantee(_is_return &amp;&amp; t == _return_type, &quot;return type does not match&quot;);</span>
    }
  
<span class="line-modified">!   void check_int(BasicType t) {</span>
<span class="line-removed">-     if (_is_return) {</span>
<span class="line-removed">-       check_return_type(t);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
      check_value(false);
    }
  
<span class="line-modified">!   void check_double(BasicType t) { check_long(t); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void check_long(BasicType t) {</span>
<span class="line-removed">-     if (_is_return) {</span>
<span class="line-removed">-       check_return_type(t);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      check_value(false);
      check_value(false);
    }
  
<span class="line-modified">!   void check_obj(BasicType t) {</span>
<span class="line-removed">-     if (_is_return) {</span>
<span class="line-removed">-       check_return_type(t);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      intptr_t v = _value[_pos];
      if (v != 0) {
        // v is a &quot;handle&quot; referring to an oop, cast to integral type.
        // There shouldn&#39;t be any handles in very low memory.
        guarantee((size_t)v &gt;= (size_t)os::vm_page_size(),
<span class="line-new-header">--- 519,56 ---</span>
     BasicType _return_type;
     u_char* _value_state;
     intptr_t* _value;
  
   public:
    SignatureChekker(Symbol* signature,
                     BasicType return_type,
                     bool is_static,
                     u_char* value_state,
                     intptr_t* value) :
      SignatureIterator(signature),
      _pos(0),
      _return_type(return_type),
      _value_state(value_state),
<span class="line-modified">!     _value(value)</span>
    {
      if (!is_static) {
        check_value(true); // Receiver must be an oop
      }
<span class="line-added">+     do_parameters_on(this);</span>
<span class="line-added">+     check_return_type(return_type);</span>
    }
  
<span class="line-modified">!  private:</span>
<span class="line-added">+   void check_value(bool is_reference) {</span>
      uint state = _value_state[_pos++];
<span class="line-modified">!     if (is_reference) {</span>
        guarantee(is_value_state_indirect_oop(state),
                  &quot;signature does not match pushed arguments: %u at %d&quot;,
                  state, _pos - 1);
      } else {
        guarantee(state == JavaCallArguments::value_state_primitive,
                  &quot;signature does not match pushed arguments: %u at %d&quot;,
                  state, _pos - 1);
      }
    }
  
    void check_return_type(BasicType t) {
<span class="line-modified">!     guarantee(t == _return_type, &quot;return type does not match&quot;);</span>
    }
  
<span class="line-modified">!   void check_single_word() {</span>
      check_value(false);
    }
  
<span class="line-modified">!   void check_double_word() {</span>
      check_value(false);
      check_value(false);
    }
  
<span class="line-modified">!   void check_reference() {</span>
      intptr_t v = _value[_pos];
      if (v != 0) {
        // v is a &quot;handle&quot; referring to an oop, cast to integral type.
        // There shouldn&#39;t be any handles in very low memory.
        guarantee((size_t)v &gt;= (size_t)os::vm_page_size(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 605,37 ***</span>
      }
  
      check_value(true);          // Verify value state.
    }
  
<span class="line-modified">!   void do_bool()                       { check_int(T_BOOLEAN);       }</span>
<span class="line-modified">!   void do_char()                       { check_int(T_CHAR);          }</span>
<span class="line-modified">!   void do_float()                      { check_int(T_FLOAT);         }</span>
<span class="line-modified">!   void do_double()                     { check_double(T_DOUBLE);     }</span>
<span class="line-modified">!   void do_byte()                       { check_int(T_BYTE);          }</span>
<span class="line-modified">!   void do_short()                      { check_int(T_SHORT);         }</span>
<span class="line-modified">!   void do_int()                        { check_int(T_INT);           }</span>
<span class="line-modified">!   void do_long()                       { check_long(T_LONG);         }</span>
<span class="line-modified">!   void do_void()                       { check_return_type(T_VOID);  }</span>
<span class="line-modified">!   void do_object(int begin, int end)   { check_obj(T_OBJECT);        }</span>
<span class="line-modified">!   void do_array(int begin, int end)    { check_obj(T_OBJECT);        }</span>
  };
  
  
  void JavaCallArguments::verify(const methodHandle&amp; method, BasicType return_type) {
    guarantee(method-&gt;size_of_parameters() == size_of_parameters(), &quot;wrong no. of arguments pushed&quot;);
  
    // Treat T_OBJECT and T_ARRAY as the same
<span class="line-modified">!   if (return_type == T_ARRAY) return_type = T_OBJECT;</span>
  
    // Check that oop information is correct
    Symbol* signature = method-&gt;signature();
  
    SignatureChekker sc(signature,
                        return_type,
                        method-&gt;is_static(),
                        _value_state,
                        _value);
<span class="line-removed">-   sc.iterate_parameters();</span>
<span class="line-removed">-   sc.check_doing_return(true);</span>
<span class="line-removed">-   sc.iterate_returntype();</span>
  }
<span class="line-new-header">--- 581,43 ---</span>
      }
  
      check_value(true);          // Verify value state.
    }
  
<span class="line-modified">!   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">!   void do_type(BasicType type) {</span>
<span class="line-modified">!     switch (type) {</span>
<span class="line-modified">!     case T_BYTE:</span>
<span class="line-modified">!     case T_BOOLEAN:</span>
<span class="line-modified">!     case T_CHAR:</span>
<span class="line-modified">!     case T_SHORT:</span>
<span class="line-modified">!     case T_INT:</span>
<span class="line-modified">!     case T_FLOAT:  // this one also</span>
<span class="line-modified">!       check_single_word(); break;</span>
<span class="line-modified">!     case T_LONG:</span>
<span class="line-added">+     case T_DOUBLE:</span>
<span class="line-added">+       check_double_word(); break;</span>
<span class="line-added">+     case T_ARRAY:</span>
<span class="line-added">+     case T_OBJECT:</span>
<span class="line-added">+       check_reference(); break;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       ShouldNotReachHere();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  };
  
  
  void JavaCallArguments::verify(const methodHandle&amp; method, BasicType return_type) {
    guarantee(method-&gt;size_of_parameters() == size_of_parameters(), &quot;wrong no. of arguments pushed&quot;);
  
    // Treat T_OBJECT and T_ARRAY as the same
<span class="line-modified">!   if (is_reference_type(return_type)) return_type = T_OBJECT;</span>
  
    // Check that oop information is correct
    Symbol* signature = method-&gt;signature();
  
    SignatureChekker sc(signature,
                        return_type,
                        method-&gt;is_static(),
                        _value_state,
                        _value);
  }
</pre>
<center><a href="java.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniHandles.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
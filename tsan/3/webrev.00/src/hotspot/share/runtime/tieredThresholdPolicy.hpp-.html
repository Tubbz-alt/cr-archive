<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/tieredThresholdPolicy.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_TIEREDTHRESHOLDPOLICY_HPP
 26 #define SHARE_RUNTIME_TIEREDTHRESHOLDPOLICY_HPP
 27 
 28 #include &quot;code/nmethod.hpp&quot;
 29 #include &quot;oops/methodData.hpp&quot;
 30 #include &quot;runtime/compilationPolicy.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 
 33 #ifdef TIERED
 34 
 35 class CompileTask;
 36 class CompileQueue;
 37 /*
 38  *  The system supports 5 execution levels:
 39  *  * level 0 - interpreter
 40  *  * level 1 - C1 with full optimization (no profiling)
 41  *  * level 2 - C1 with invocation and backedge counters
 42  *  * level 3 - C1 with full profiling (level 2 + MDO)
 43  *  * level 4 - C2
 44  *
 45  * Levels 0, 2 and 3 periodically notify the runtime about the current value of the counters
 46  * (invocation counters and backedge counters). The frequency of these notifications is
 47  * different at each level. These notifications are used by the policy to decide what transition
 48  * to make.
 49  *
 50  * Execution starts at level 0 (interpreter), then the policy can decide either to compile the
 51  * method at level 3 or level 2. The decision is based on the following factors:
 52  *    1. The length of the C2 queue determines the next level. The observation is that level 2
 53  * is generally faster than level 3 by about 30%, therefore we would want to minimize the time
 54  * a method spends at level 3. We should only spend the time at level 3 that is necessary to get
 55  * adequate profiling. So, if the C2 queue is long enough it is more beneficial to go first to
 56  * level 2, because if we transitioned to level 3 we would be stuck there until our C2 compile
 57  * request makes its way through the long queue. When the load on C2 recedes we are going to
 58  * recompile at level 3 and start gathering profiling information.
 59  *    2. The length of C1 queue is used to dynamically adjust the thresholds, so as to introduce
 60  * additional filtering if the compiler is overloaded. The rationale is that by the time a
 61  * method gets compiled it can become unused, so it doesn&#39;t make sense to put too much onto the
 62  * queue.
 63  *
 64  * After profiling is completed at level 3 the transition is made to level 4. Again, the length
 65  * of the C2 queue is used as a feedback to adjust the thresholds.
 66  *
 67  * After the first C1 compile some basic information is determined about the code like the number
 68  * of the blocks and the number of the loops. Based on that it can be decided that a method
 69  * is trivial and compiling it with C1 will yield the same code. In this case the method is
 70  * compiled at level 1 instead of 4.
 71  *
 72  * We also support profiling at level 0. If C1 is slow enough to produce the level 3 version of
 73  * the code and the C2 queue is sufficiently small we can decide to start profiling in the
 74  * interpreter (and continue profiling in the compiled code once the level 3 version arrives).
 75  * If the profiling at level 0 is fully completed before level 3 version is produced, a level 2
 76  * version is compiled instead in order to run faster waiting for a level 4 version.
 77  *
 78  * Compile queues are implemented as priority queues - for each method in the queue we compute
 79  * the event rate (the number of invocation and backedge counter increments per unit of time).
 80  * When getting an element off the queue we pick the one with the largest rate. Maintaining the
 81  * rate also allows us to remove stale methods (the ones that got on the queue but stopped
 82  * being used shortly after that).
 83 */
 84 
 85 /* Command line options:
 86  * - Tier?InvokeNotifyFreqLog and Tier?BackedgeNotifyFreqLog control the frequency of method
 87  *   invocation and backedge notifications. Basically every n-th invocation or backedge a mutator thread
 88  *   makes a call into the runtime.
 89  *
 90  * - Tier?InvocationThreshold, Tier?CompileThreshold, Tier?BackEdgeThreshold, Tier?MinInvocationThreshold control
 91  *   compilation thresholds.
 92  *   Level 2 thresholds are not used and are provided for option-compatibility and potential future use.
 93  *   Other thresholds work as follows:
 94  *
 95  *   Transition from interpreter (level 0) to C1 with full profiling (level 3) happens when
 96  *   the following predicate is true (X is the level):
 97  *
 98  *   i &gt; TierXInvocationThreshold * s || (i &gt; TierXMinInvocationThreshold * s  &amp;&amp; i + b &gt; TierXCompileThreshold * s),
 99  *
100  *   where $i$ is the number of method invocations, $b$ number of backedges and $s$ is the scaling
101  *   coefficient that will be discussed further.
102  *   The intuition is to equalize the time that is spend profiling each method.
103  *   The same predicate is used to control the transition from level 3 to level 4 (C2). It should be
104  *   noted though that the thresholds are relative. Moreover i and b for the 0-&gt;3 transition come
105  *   from Method* and for 3-&gt;4 transition they come from MDO (since profiled invocations are
106  *   counted separately). Finally, if a method does not contain anything worth profiling, a transition
107  *   from level 3 to level 4 occurs without considering thresholds (e.g., with fewer invocations than
108  *   what is specified by Tier4InvocationThreshold).
109  *
110  *   OSR transitions are controlled simply with b &gt; TierXBackEdgeThreshold * s predicates.
111  *
112  * - Tier?LoadFeedback options are used to automatically scale the predicates described above depending
113  *   on the compiler load. The scaling coefficients are computed as follows:
114  *
115  *   s = queue_size_X / (TierXLoadFeedback * compiler_count_X) + 1,
116  *
117  *   where queue_size_X is the current size of the compiler queue of level X, and compiler_count_X
118  *   is the number of level X compiler threads.
119  *
120  *   Basically these parameters describe how many methods should be in the compile queue
121  *   per compiler thread before the scaling coefficient increases by one.
122  *
123  *   This feedback provides the mechanism to automatically control the flow of compilation requests
124  *   depending on the machine speed, mutator load and other external factors.
125  *
126  * - Tier3DelayOn and Tier3DelayOff parameters control another important feedback loop.
127  *   Consider the following observation: a method compiled with full profiling (level 3)
128  *   is about 30% slower than a method at level 2 (just invocation and backedge counters, no MDO).
129  *   Normally, the following transitions will occur: 0-&gt;3-&gt;4. The problem arises when the C2 queue
130  *   gets congested and the 3-&gt;4 transition is delayed. While the method is the C2 queue it continues
131  *   executing at level 3 for much longer time than is required by the predicate and at suboptimal speed.
132  *   The idea is to dynamically change the behavior of the system in such a way that if a substantial
133  *   load on C2 is detected we would first do the 0-&gt;2 transition allowing a method to run faster.
134  *   And then when the load decreases to allow 2-&gt;3 transitions.
135  *
136  *   Tier3Delay* parameters control this switching mechanism.
137  *   Tier3DelayOn is the number of methods in the C2 queue per compiler thread after which the policy
138  *   no longer does 0-&gt;3 transitions but does 0-&gt;2 transitions instead.
139  *   Tier3DelayOff switches the original behavior back when the number of methods in the C2 queue
140  *   per compiler thread falls below the specified amount.
141  *   The hysteresis is necessary to avoid jitter.
142  *
143  * - TieredCompileTaskTimeout is the amount of time an idle method can spend in the compile queue.
144  *   Basically, since we use the event rate d(i + b)/dt as a value of priority when selecting a method to
145  *   compile from the compile queue, we also can detect stale methods for which the rate has been
146  *   0 for some time in the same iteration. Stale methods can appear in the queue when an application
147  *   abruptly changes its behavior.
148  *
149  * - TieredStopAtLevel, is used mostly for testing. It allows to bypass the policy logic and stick
150  *   to a given level. For example it&#39;s useful to set TieredStopAtLevel = 1 in order to compile everything
151  *   with pure c1.
152  *
153  * - Tier0ProfilingStartPercentage allows the interpreter to start profiling when the inequalities in the
154  *   0-&gt;3 predicate are already exceeded by the given percentage but the level 3 version of the
155  *   method is still not ready. We can even go directly from level 0 to 4 if c1 doesn&#39;t produce a compiled
156  *   version in time. This reduces the overall transition to level 4 and decreases the startup time.
157  *   Note that this behavior is also guarded by the Tier3Delay mechanism: when the c2 queue is too long
158  *   these is not reason to start profiling prematurely.
159  *
160  * - TieredRateUpdateMinTime and TieredRateUpdateMaxTime are parameters of the rate computation.
161  *   Basically, the rate is not computed more frequently than TieredRateUpdateMinTime and is considered
162  *   to be zero if no events occurred in TieredRateUpdateMaxTime.
163  */
164 
165 class TieredThresholdPolicy : public CompilationPolicy {
166   jlong _start_time;
167   int _c1_count, _c2_count;
168 
169   // Check if the counter is big enough and set carry (effectively infinity).
170   inline void set_carry_if_necessary(InvocationCounter *counter);
171   // Set carry flags in the counters (in Method* and MDO).
172   inline void handle_counter_overflow(Method* method);
173   // Call and loop predicates determine whether a transition to a higher compilation
174   // level should be performed (pointers to predicate functions are passed to common_TF().
175   // Predicates also take compiler load into account.
176   typedef bool (TieredThresholdPolicy::*Predicate)(int i, int b, CompLevel cur_level, Method* method);
177   bool call_predicate(int i, int b, CompLevel cur_level, Method* method);
178   bool loop_predicate(int i, int b, CompLevel cur_level, Method* method);
179   // Common transition function. Given a predicate determines if a method should transition to another level.
180   CompLevel common(Predicate p, Method* method, CompLevel cur_level, bool disable_feedback = false);
181   // Transition functions.
182   // call_event determines if a method should be compiled at a different
183   // level with a regular invocation entry.
184   CompLevel call_event(Method* method, CompLevel cur_level, JavaThread* thread);
185   // loop_event checks if a method should be OSR compiled at a different
186   // level.
187   CompLevel loop_event(Method* method, CompLevel cur_level, JavaThread* thread);
188   void print_counters(const char* prefix, const methodHandle&amp; mh);
189   // Has a method been long around?
190   // We don&#39;t remove old methods from the compile queue even if they have
191   // very low activity (see select_task()).
192   inline bool is_old(Method* method);
193   // Was a given method inactive for a given number of milliseconds.
194   // If it is, we would remove it from the queue (see select_task()).
195   inline bool is_stale(jlong t, jlong timeout, Method* m);
196   // Compute the weight of the method for the compilation scheduling
197   inline double weight(Method* method);
198   // Apply heuristics and return true if x should be compiled before y
199   inline bool compare_methods(Method* x, Method* y);
200   // Compute event rate for a given method. The rate is the number of event (invocations + backedges)
201   // per millisecond.
202   inline void update_rate(jlong t, Method* m);
203   // Compute threshold scaling coefficient
204   inline double threshold_scale(CompLevel level, int feedback_k);
205   // If a method is old enough and is still in the interpreter we would want to
206   // start profiling without waiting for the compiled method to arrive. This function
207   // determines whether we should do that.
208   inline bool should_create_mdo(Method* method, CompLevel cur_level);
209   // Create MDO if necessary.
210   void create_mdo(const methodHandle&amp; mh, JavaThread* thread);
211   // Is method profiled enough?
212   bool is_method_profiled(Method* method);
213 
214   double _increase_threshold_at_ratio;
215 
216   bool maybe_switch_to_aot(const methodHandle&amp; mh, CompLevel cur_level, CompLevel next_level, JavaThread* thread);
217 
218 protected:
219   int c1_count() const     { return _c1_count; }
220   int c2_count() const     { return _c2_count; }
221   void set_c1_count(int x) { _c1_count = x;    }
222   void set_c2_count(int x) { _c2_count = x;    }
223 
224   enum EventType { CALL, LOOP, COMPILE, REMOVE_FROM_QUEUE, UPDATE_IN_QUEUE, REPROFILE, MAKE_NOT_ENTRANT };
225   void print_event(EventType type, const methodHandle&amp; mh, const methodHandle&amp; imh, int bci, CompLevel level);
226   // Print policy-specific information if necessary
227   virtual void print_specific(EventType type, const methodHandle&amp; mh, const methodHandle&amp; imh, int bci, CompLevel level);
228   // Check if the method can be compiled, change level if necessary
229   void compile(const methodHandle&amp; mh, int bci, CompLevel level, JavaThread* thread);
230   // Submit a given method for compilation
231   virtual void submit_compile(const methodHandle&amp; mh, int bci, CompLevel level, JavaThread* thread);
232   // Simple methods are as good being compiled with C1 as C2.
233   // This function tells if it&#39;s such a function.
234   inline bool is_trivial(Method* method);
235 
236   // Predicate helpers are used by .*_predicate() methods as well as others.
237   // They check the given counter values, multiplied by the scale against the thresholds.
238   template&lt;CompLevel level&gt; static inline bool call_predicate_helper(int i, int b, double scale, Method* method);
239   template&lt;CompLevel level&gt; static inline bool loop_predicate_helper(int i, int b, double scale, Method* method);
240 
241   // Get a compilation level for a given method.
242   static CompLevel comp_level(Method* method);
243   virtual void method_invocation_event(const methodHandle&amp; method, const methodHandle&amp; inlinee,
244                                        CompLevel level, CompiledMethod* nm, JavaThread* thread);
245   virtual void method_back_branch_event(const methodHandle&amp; method, const methodHandle&amp; inlinee,
246                                         int bci, CompLevel level, CompiledMethod* nm, JavaThread* thread);
247 
248   void set_increase_threshold_at_ratio() { _increase_threshold_at_ratio = 100 / (100 - (double)IncreaseFirstTierCompileThresholdAt); }
249   void set_start_time(jlong t) { _start_time = t;    }
250   jlong start_time() const     { return _start_time; }
251 
252 public:
253   TieredThresholdPolicy() : _start_time(0), _c1_count(0), _c2_count(0) { }
254   virtual int compiler_count(CompLevel comp_level) {
255     if (is_c1_compile(comp_level)) return c1_count();
256     if (is_c2_compile(comp_level)) return c2_count();
257     return 0;
258   }
259   virtual CompLevel initial_compile_level() { return MIN2((CompLevel)TieredStopAtLevel, CompLevel_initial_compile); }
260   virtual void do_safepoint_work() { }
261   virtual void delay_compilation(Method* method) { }
262   virtual void disable_compilation(Method* method) { }
263   virtual void reprofile(ScopeDesc* trap_scope, bool is_osr);
264   virtual nmethod* event(const methodHandle&amp; method, const methodHandle&amp; inlinee,
265                          int branch_bci, int bci, CompLevel comp_level, CompiledMethod* nm, JavaThread* thread);
266   // Select task is called by CompileBroker. We should return a task or NULL.
267   virtual CompileTask* select_task(CompileQueue* compile_queue);
268   // Tell the runtime if we think a given method is adequately profiled.
269   virtual bool is_mature(Method* method);
270   // Initialize: set compiler thread count
271   virtual void initialize();
272   virtual bool should_not_inline(ciEnv* env, ciMethod* callee);
273 };
274 
275 #endif // TIERED
276 
277 #endif // SHARE_RUNTIME_TIEREDTHRESHOLDPOLICY_HPP
    </pre>
  </body>
</html>
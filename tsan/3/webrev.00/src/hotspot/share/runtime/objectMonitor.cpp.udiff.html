<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/objectMonitor.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mutexLocker.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objectMonitor.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/objectMonitor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,13 +24,15 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;jfr/support/jfrThreadId.hpp&quot;
<span class="udiff-line-added">+ #include &quot;logging/log.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;logging/logStream.hpp&quot;</span>
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;oops/markOop.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -241,30 +243,26 @@</span>
  void ObjectMonitor::enter(TRAPS) {
    // The following code is ordered to check the most common cases first
    // and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.
    Thread * const Self = THREAD;
  
<span class="udiff-line-modified-removed">-   void * cur = Atomic::cmpxchg(Self, &amp;_owner, (void*)NULL);</span>
<span class="udiff-line-modified-added">+   void* cur = try_set_owner_from(NULL, Self);</span>
    if (cur == NULL) {
<span class="udiff-line-removed">-     // Either ASSERT _recursions == 0 or explicitly set _recursions = 0.</span>
      assert(_recursions == 0, &quot;invariant&quot;);
<span class="udiff-line-removed">-     assert(_owner == Self, &quot;invariant&quot;);</span>
      return;
    }
  
    if (cur == Self) {
      // TODO-FIXME: check for integer overflow!  BUGID 6557169.
      _recursions++;
      return;
    }
  
<span class="udiff-line-modified-removed">-   if (Self-&gt;is_lock_owned ((address)cur)) {</span>
<span class="udiff-line-modified-added">+   if (Self-&gt;is_lock_owned((address)cur)) {</span>
      assert(_recursions == 0, &quot;internal state error&quot;);
      _recursions = 1;
<span class="udiff-line-modified-removed">-     // Commute owner from a thread-specific on-stack BasicLockObject address to</span>
<span class="udiff-line-removed">-     // a full-fledged &quot;Thread *&quot;.</span>
<span class="udiff-line-removed">-     _owner = Self;</span>
<span class="udiff-line-modified-added">+     set_owner_from_BasicLock(cur, Self);  // Convert from BasicLock* to Thread*.</span>
      return;
    }
  
    // We&#39;ve encountered genuine contention.
    assert(Self-&gt;_Stalled == 0, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -274,13 +272,16 @@</span>
    // and before going through the awkward and expensive state
    // transitions.  The following spin is strictly optional ...
    // Note that if we acquire the monitor from an initial spin
    // we forgo posting JVMTI events and firing DTRACE probes.
    if (TrySpin(Self) &gt; 0) {
<span class="udiff-line-modified-removed">-     assert(_owner == Self, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-     assert(_recursions == 0, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-     assert(((oop)(object()))-&gt;mark() == markOopDesc::encode(this), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+     assert(_owner == Self, &quot;must be Self: owner=&quot; INTPTR_FORMAT, p2i(_owner));</span>
<span class="udiff-line-modified-added">+     assert(_recursions == 0, &quot;must be 0: recursions=&quot; INTX_FORMAT, _recursions);</span>
<span class="udiff-line-modified-added">+     assert(((oop)object())-&gt;mark() == markWord::encode(this),</span>
<span class="udiff-line-added">+            &quot;object mark must match encoded this: mark=&quot; INTPTR_FORMAT</span>
<span class="udiff-line-added">+            &quot;, encoded this=&quot; INTPTR_FORMAT, ((oop)object())-&gt;mark().value(),</span>
<span class="udiff-line-added">+            markWord::encode(this).value());</span>
      Self-&gt;_Stalled = 0;
      return;
    }
  
    assert(_owner != Self, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -288,15 +289,15 @@</span>
    assert(Self-&gt;is_Java_thread(), &quot;invariant&quot;);
    JavaThread * jt = (JavaThread *) Self;
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
    assert(jt-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);
    assert(this-&gt;object() != NULL, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   assert(_count &gt;= 0, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(_contentions &gt;= 0, &quot;invariant&quot;);</span>
  
    // Prevent deflation at STW-time.  See deflate_idle_monitors() and is_busy().
    // Ensure the object-monitor relationship remains stable while there&#39;s contention.
<span class="udiff-line-modified-removed">-   Atomic::inc(&amp;_count);</span>
<span class="udiff-line-modified-added">+   Atomic::inc(&amp;_contentions);</span>
  
    JFR_ONLY(JfrConditionalFlushWithStacktrace&lt;EventJavaMonitorEnter&gt; flush(jt);)
    EventJavaMonitorEnter event;
    if (event.should_commit()) {
      event.set_monitorClass(((oop)this-&gt;object())-&gt;klass());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -353,19 +354,19 @@</span>
      // as having &quot;-locked&quot; the monitor, but the OS and java.lang.Thread
      // states will still report that the thread is blocked trying to
      // acquire it.
    }
  
<span class="udiff-line-modified-removed">-   Atomic::dec(&amp;_count);</span>
<span class="udiff-line-modified-removed">-   assert(_count &gt;= 0, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   Atomic::dec(&amp;_contentions);</span>
<span class="udiff-line-modified-added">+   assert(_contentions &gt;= 0, &quot;invariant&quot;);</span>
    Self-&gt;_Stalled = 0;
  
    // Must either set _recursions = 0 or ASSERT _recursions == 0.
    assert(_recursions == 0, &quot;invariant&quot;);
    assert(_owner == Self, &quot;invariant&quot;);
    assert(_succ != Self, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   assert(((oop)(object()))-&gt;mark() == markOopDesc::encode(this), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(((oop)(object()))-&gt;mark() == markWord::encode(this), &quot;invariant&quot;);</span>
  
    // The thread -- now the owner -- is back in vm mode.
    // Report the glorious news via TI,DTrace and jvmstat.
    // The probe effect is non-trivial.  All the reportage occurs
    // while we hold the monitor, increasing the length of the critical
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -398,23 +399,30 @@</span>
  // Callers must compensate as needed.
  
  int ObjectMonitor::TryLock(Thread * Self) {
    void * own = _owner;
    if (own != NULL) return 0;
<span class="udiff-line-modified-removed">-   if (Atomic::replace_if_null(Self, &amp;_owner)) {</span>
<span class="udiff-line-removed">-     // Either guarantee _recursions == 0 or set _recursions = 0.</span>
<span class="udiff-line-modified-added">+   if (try_set_owner_from(NULL, Self) == NULL) {</span>
      assert(_recursions == 0, &quot;invariant&quot;);
<span class="udiff-line-removed">-     assert(_owner == Self, &quot;invariant&quot;);</span>
      return 1;
    }
    // The lock had been free momentarily, but we lost the race to the lock.
    // Interference -- the CAS failed.
    // We can either return -1 or retry.
    // Retry doesn&#39;t make as much sense because the lock was just acquired.
    return -1;
  }
  
<span class="udiff-line-added">+ // Convert the fields used by is_busy() to a string that can be</span>
<span class="udiff-line-added">+ // used for diagnostic output.</span>
<span class="udiff-line-added">+ const char* ObjectMonitor::is_busy_to_string(stringStream* ss) {</span>
<span class="udiff-line-added">+   ss-&gt;print(&quot;is_busy: contentions=%d, waiters=%d, owner=&quot; INTPTR_FORMAT</span>
<span class="udiff-line-added">+             &quot;, cxq=&quot; INTPTR_FORMAT &quot;, EntryList=&quot; INTPTR_FORMAT, _contentions,</span>
<span class="udiff-line-added">+             _waiters, p2i(_owner), p2i(_cxq), p2i(_EntryList));</span>
<span class="udiff-line-added">+   return ss-&gt;base();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #define MAX_RECHECK_INTERVAL 1000
  
  void ObjectMonitor::EnterI(TRAPS) {
    Thread * const Self = THREAD;
    assert(Self-&gt;is_Java_thread(), &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -468,11 +476,11 @@</span>
    // Note that spinning tends to reduce the rate at which threads
    // enqueue and dequeue on EntryList|cxq.
    ObjectWaiter * nxt;
    for (;;) {
      node._next = nxt = _cxq;
<span class="udiff-line-modified-removed">-     if (Atomic::cmpxchg(&amp;node, &amp;_cxq, nxt) == nxt) break;</span>
<span class="udiff-line-modified-added">+     if (Atomic::cmpxchg(&amp;_cxq, nxt, &amp;node) == nxt) break;</span>
  
      // Interference - the CAS failed because _cxq changed.  Just retry.
      // As an optional optimization we retry the lock.
      if (TryLock (Self) &gt; 0) {
        assert(_succ != Self, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -506,11 +514,11 @@</span>
    // -- the checker -- parked on a timer.
  
    if (nxt == NULL &amp;&amp; _EntryList == NULL) {
      // Try to assume the role of responsible thread for the monitor.
      // CONSIDER:  ST vs CAS vs { if (Responsible==null) Responsible=Self }
<span class="udiff-line-modified-removed">-     Atomic::replace_if_null(Self, &amp;_Responsible);</span>
<span class="udiff-line-modified-added">+     Atomic::replace_if_null(&amp;_Responsible, Self);</span>
    }
  
    // The lock might have been released while this thread was occupied queueing
    // itself onto _cxq.  To close the race and avoid &quot;stranding&quot; and
    // progress-liveness failure we must resample-retry _owner before parking.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -582,11 +590,11 @@</span>
    // In addition, Self.TState is stable.
  
    assert(_owner == Self, &quot;invariant&quot;);
    assert(object() != NULL, &quot;invariant&quot;);
    // I&#39;d like to write:
<span class="udiff-line-modified-removed">-   //   guarantee (((oop)(object()))-&gt;mark() == markOopDesc::encode(this), &quot;invariant&quot;) ;</span>
<span class="udiff-line-modified-added">+   //   guarantee (((oop)(object()))-&gt;mark() == markWord::encode(this), &quot;invariant&quot;) ;</span>
    // but as we&#39;re at a safepoint that&#39;s not safe.
  
    UnlinkAfterAcquire(Self, &amp;node);
    if (_succ == Self) _succ = NULL;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -650,11 +658,11 @@</span>
  void ObjectMonitor::ReenterI(Thread * Self, ObjectWaiter * SelfNode) {
    assert(Self != NULL, &quot;invariant&quot;);
    assert(SelfNode != NULL, &quot;invariant&quot;);
    assert(SelfNode-&gt;_thread == Self, &quot;invariant&quot;);
    assert(_waiters &gt; 0, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   assert(((oop)(object()))-&gt;mark() == markOopDesc::encode(this), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(((oop)(object()))-&gt;mark() == markWord::encode(this), &quot;invariant&quot;);</span>
    assert(((JavaThread *)Self)-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;);
    JavaThread * jt = (JavaThread *) Self;
  
    int nWakeups = 0;
    for (;;) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -718,11 +726,11 @@</span>
    // EntryList is stable and cxq is prepend-only.
    // The head of cxq is volatile but the interior is stable.
    // In addition, Self.TState is stable.
  
    assert(_owner == Self, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   assert(((oop)(object()))-&gt;mark() == markOopDesc::encode(this), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(((oop)(object()))-&gt;mark() == markWord::encode(this), &quot;invariant&quot;);</span>
    UnlinkAfterAcquire(Self, SelfNode);
    if (_succ == Self) _succ = NULL;
    assert(_succ != Self, &quot;invariant&quot;);
    SelfNode-&gt;TState = ObjectWaiter::TS_RUN;
    OrderAccess::fence();      // see comments at the end of EnterI()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -761,11 +769,11 @@</span>
      // and then unlink Self from EntryList.  We have to drain eventually,
      // so it might as well be now.
  
      ObjectWaiter * v = _cxq;
      assert(v != NULL, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-     if (v != SelfNode || Atomic::cmpxchg(SelfNode-&gt;_next, &amp;_cxq, v) != v) {</span>
<span class="udiff-line-modified-added">+     if (v != SelfNode || Atomic::cmpxchg(&amp;_cxq, v, SelfNode-&gt;_next) != v) {</span>
        // The CAS above can fail from interference IFF a &quot;RAT&quot; arrived.
        // In that case Self must be in the interior and can no longer be
        // at the head of cxq.
        if (v == SelfNode) {
          assert(_cxq != v, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -807,11 +815,11 @@</span>
  //
  // We&#39;d like to assert that: (THREAD-&gt;thread_state() != _thread_blocked) ;
  // There&#39;s one exception to the claim above, however.  EnterI() can call
  // exit() to drop a lock if the acquirer has been externally suspended.
  // In that case exit() is called with _thread_state as _thread_blocked,
<span class="udiff-line-modified-removed">- // but the monitor&#39;s _count field is &gt; 0, which inhibits reclamation.</span>
<span class="udiff-line-modified-added">+ // but the monitor&#39;s _contentions field is &gt; 0, which inhibits reclamation.</span>
  //
  // 1-0 exit
  // ~~~~~~~~
  // ::exit() uses a canonical 1-1 idiom with a MEMBAR although some of
  // the fast-path operators have been optimized so the common ::exit()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -850,19 +858,16 @@</span>
  // then wake a thread unnecessarily. This is benign, and we&#39;ve
  // structured the code so the windows are short and the frequency
  // of such futile wakups is low.
  
  void ObjectMonitor::exit(bool not_suspended, TRAPS) {
<span class="udiff-line-modified-removed">-   Thread * const Self = THREAD;</span>
<span class="udiff-line-modified-removed">-   if (THREAD != _owner) {</span>
<span class="udiff-line-modified-removed">-     if (THREAD-&gt;is_lock_owned((address) _owner)) {</span>
<span class="udiff-line-modified-removed">-       // Transmute _owner from a BasicLock pointer to a Thread address.</span>
<span class="udiff-line-removed">-       // We don&#39;t need to hold _mutex for this transition.</span>
<span class="udiff-line-removed">-       // Non-null to Non-null is safe as long as all readers can</span>
<span class="udiff-line-removed">-       // tolerate either flavor.</span>
<span class="udiff-line-modified-added">+   Thread* const Self = THREAD;</span>
<span class="udiff-line-modified-added">+   void* cur = Atomic::load(&amp;_owner);</span>
<span class="udiff-line-modified-added">+   if (THREAD != cur) {</span>
<span class="udiff-line-modified-added">+     if (THREAD-&gt;is_lock_owned((address)cur)) {</span>
        assert(_recursions == 0, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-       _owner = THREAD;</span>
<span class="udiff-line-modified-added">+       set_owner_from_BasicLock(cur, Self);  // Convert from BasicLock* to Thread*.</span>
        _recursions = 0;
      } else {
        // Apparent unbalanced locking ...
        // Naively we&#39;d like to throw IllegalMonitorStateException.
        // As a practical matter we can neither allocate nor throw an
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -870,11 +875,18 @@</span>
        // see x86_32.ad Fast_Unlock() and the I1 and I2 properties.
        // Upon deeper reflection, however, in a properly run JVM the only
        // way we should encounter this situation is in the presence of
        // unbalanced JNI locking. TODO: CheckJNICalls.
        // See also: CR4414101
<span class="udiff-line-modified-removed">-       assert(false, &quot;Non-balanced monitor enter/exit! Likely JNI locking&quot;);</span>
<span class="udiff-line-modified-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+       LogStreamHandle(Error, monitorinflation) lsh;</span>
<span class="udiff-line-added">+       lsh.print_cr(&quot;ERROR: ObjectMonitor::exit(): thread=&quot; INTPTR_FORMAT</span>
<span class="udiff-line-added">+                     &quot; is exiting an ObjectMonitor it does not own.&quot;, p2i(THREAD));</span>
<span class="udiff-line-added">+       lsh.print_cr(&quot;The imbalance is possibly caused by JNI locking.&quot;);</span>
<span class="udiff-line-added">+       print_debug_style_on(&amp;lsh);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+       assert(false, &quot;Non-balanced monitor enter/exit!&quot;);</span>
        return;
      }
    }
  
    if (_recursions != 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -895,16 +907,19 @@</span>
  #endif
  
    for (;;) {
      assert(THREAD == _owner, &quot;invariant&quot;);
  
<span class="udiff-line-added">+     // Drop the lock.</span>
      // release semantics: prior loads and stores from within the critical section
      // must not float (reorder) past the following store that drops the lock.
<span class="udiff-line-modified-removed">-     // On SPARC that requires MEMBAR #loadstore|#storestore.</span>
<span class="udiff-line-modified-removed">-     // But of course in TSO #loadstore|#storestore is not required.</span>
<span class="udiff-line-modified-removed">-     OrderAccess::release_store(&amp;_owner, (void*)NULL);   // drop the lock</span>
<span class="udiff-line-modified-removed">-     OrderAccess::storeload();                        // See if we need to wake a successor</span>
<span class="udiff-line-modified-added">+     // Uses a storeload to separate release_store(owner) from the</span>
<span class="udiff-line-modified-added">+     // successor check. The try_set_owner() below uses cmpxchg() so</span>
<span class="udiff-line-modified-added">+     // we get the fence down there.</span>
<span class="udiff-line-modified-added">+     release_clear_owner(Self);</span>
<span class="udiff-line-added">+     OrderAccess::storeload();</span>
<span class="udiff-line-added">+ </span>
      if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != NULL) {
        return;
      }
      // Other threads are blocked trying to acquire the lock.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -942,11 +957,11 @@</span>
      // Only the current lock owner can manipulate the EntryList or
      // drain _cxq, so we need to reacquire the lock.  If we fail
      // to reacquire the lock the responsibility for ensuring succession
      // falls to the new owner.
      //
<span class="udiff-line-modified-removed">-     if (!Atomic::replace_if_null(THREAD, &amp;_owner)) {</span>
<span class="udiff-line-modified-added">+     if (try_set_owner_from(NULL, Self) != NULL) {</span>
        return;
      }
  
      guarantee(_owner == THREAD, &quot;invariant&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -978,11 +993,11 @@</span>
      // Drain _cxq into EntryList - bulk transfer.
      // First, detach _cxq.
      // The following loop is tantamount to: w = swap(&amp;cxq, NULL)
      for (;;) {
        assert(w != NULL, &quot;Invariant&quot;);
<span class="udiff-line-modified-removed">-       ObjectWaiter * u = Atomic::cmpxchg((ObjectWaiter*)NULL, &amp;_cxq, w);</span>
<span class="udiff-line-modified-added">+       ObjectWaiter * u = Atomic::cmpxchg(&amp;_cxq, w, (ObjectWaiter*)NULL);</span>
        if (u == w) break;
        w = u;
      }
  
      assert(w != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1075,12 +1090,13 @@</span>
    // The thread associated with Wakee may have grabbed the lock and &quot;Wakee&quot; may be
    // out-of-scope (non-extant).
    Wakee  = NULL;
  
    // Drop the lock
<span class="udiff-line-modified-removed">-   OrderAccess::release_store(&amp;_owner, (void*)NULL);</span>
<span class="udiff-line-modified-removed">-   OrderAccess::fence();                               // ST _owner vs LD in unpark()</span>
<span class="udiff-line-modified-added">+   // Uses a fence to separate release_store(owner) from the LD in unpark().</span>
<span class="udiff-line-modified-added">+   release_clear_owner(Self);</span>
<span class="udiff-line-added">+   OrderAccess::fence();</span>
  
    DTRACE_MONITOR_PROBE(contended__exit, this, object(), Self);
    Trigger-&gt;unpark();
  
    // Maintain stats and report events to JVMTI
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1095,36 +1111,37 @@</span>
  // complete_exit/reenter operate as a wait without waiting
  // complete_exit requires an inflated monitor
  // The _owner field is not always the Thread addr even with an
  // inflated monitor, e.g. the monitor can be inflated by a non-owning
  // thread due to contention.
<span class="udiff-line-modified-removed">- intptr_t ObjectMonitor::complete_exit(TRAPS) {</span>
<span class="udiff-line-modified-added">+ intx ObjectMonitor::complete_exit(TRAPS) {</span>
    Thread * const Self = THREAD;
    assert(Self-&gt;is_Java_thread(), &quot;Must be Java thread!&quot;);
    JavaThread *jt = (JavaThread *)THREAD;
  
    assert(InitDone, &quot;Unexpectedly not initialized&quot;);
  
<span class="udiff-line-modified-removed">-   if (THREAD != _owner) {</span>
<span class="udiff-line-modified-removed">-     if (THREAD-&gt;is_lock_owned ((address)_owner)) {</span>
<span class="udiff-line-modified-added">+   void* cur = Atomic::load(&amp;_owner);</span>
<span class="udiff-line-modified-added">+   if (THREAD != cur) {</span>
<span class="udiff-line-added">+     if (THREAD-&gt;is_lock_owned((address)cur)) {</span>
        assert(_recursions == 0, &quot;internal state error&quot;);
<span class="udiff-line-modified-removed">-       _owner = THREAD;   // Convert from basiclock addr to Thread addr</span>
<span class="udiff-line-modified-added">+       set_owner_from_BasicLock(cur, Self);  // Convert from BasicLock* to Thread*.</span>
        _recursions = 0;
      }
    }
  
    guarantee(Self == _owner, &quot;complete_exit not owner&quot;);
<span class="udiff-line-modified-removed">-   intptr_t save = _recursions; // record the old recursion count</span>
<span class="udiff-line-modified-added">+   intx save = _recursions; // record the old recursion count</span>
    _recursions = 0;        // set the recursion level to be 0
    exit(true, Self);           // exit the monitor
    guarantee(_owner != Self, &quot;invariant&quot;);
    return save;
  }
  
  // reenter() enters a lock and sets recursion count
  // complete_exit/reenter operate as a wait without waiting
<span class="udiff-line-modified-removed">- void ObjectMonitor::reenter(intptr_t recursions, TRAPS) {</span>
<span class="udiff-line-modified-added">+ void ObjectMonitor::reenter(intx recursions, TRAPS) {</span>
    Thread * const Self = THREAD;
    assert(Self-&gt;is_Java_thread(), &quot;Must be Java thread!&quot;);
    JavaThread *jt = (JavaThread *)THREAD;
  
    guarantee(_owner != Self, &quot;reenter already owner&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1132,35 +1149,39 @@</span>
    guarantee(_recursions == 0, &quot;reenter recursion&quot;);
    _recursions = recursions;
    return;
  }
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- // -----------------------------------------------------------------------------</span>
<span class="udiff-line-modified-removed">- // A macro is used below because there may already be a pending</span>
<span class="udiff-line-modified-removed">- // exception which should not abort the execution of the routines</span>
<span class="udiff-line-modified-removed">- // which use this (which is why we don&#39;t put this into check_slow and</span>
<span class="udiff-line-modified-removed">- // call it with a CHECK argument).</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- #define CHECK_OWNER()                                                       \</span>
<span class="udiff-line-modified-removed">-   do {                                                                      \</span>
<span class="udiff-line-modified-removed">-     if (THREAD != _owner) {                                                 \</span>
<span class="udiff-line-modified-removed">-       if (THREAD-&gt;is_lock_owned((address) _owner)) {                        \</span>
<span class="udiff-line-removed">-         _owner = THREAD;  /* Convert from basiclock addr to Thread addr */  \</span>
<span class="udiff-line-removed">-         _recursions = 0;                                                    \</span>
<span class="udiff-line-removed">-       } else {                                                              \</span>
<span class="udiff-line-removed">-         THROW(vmSymbols::java_lang_IllegalMonitorStateException());         \</span>
<span class="udiff-line-removed">-       }                                                                     \</span>
<span class="udiff-line-removed">-     }                                                                       \</span>
<span class="udiff-line-modified-added">+ // Checks that the current THREAD owns this monitor and causes an</span>
<span class="udiff-line-modified-added">+ // immediate return if it doesn&#39;t. We don&#39;t use the CHECK macro</span>
<span class="udiff-line-modified-added">+ // because we want the IMSE to be the only exception that is thrown</span>
<span class="udiff-line-modified-added">+ // from the call site when false is returned. Any other pending</span>
<span class="udiff-line-modified-added">+ // exception is ignored.</span>
<span class="udiff-line-modified-added">+ #define CHECK_OWNER()                                                  \</span>
<span class="udiff-line-modified-added">+   do {                                                                 \</span>
<span class="udiff-line-modified-added">+     if (!check_owner(THREAD)) {                                        \</span>
<span class="udiff-line-modified-added">+        assert(HAS_PENDING_EXCEPTION, &quot;expected a pending IMSE here.&quot;); \</span>
<span class="udiff-line-modified-added">+        return;                                                         \</span>
<span class="udiff-line-modified-added">+      }                                                                 \</span>
    } while (false)
  
<span class="udiff-line-modified-removed">- // check_slow() is a misnomer.  It&#39;s called to simply to throw an IMSX exception.</span>
<span class="udiff-line-modified-removed">- // TODO-FIXME: remove check_slow() -- it&#39;s likely dead.</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- void ObjectMonitor::check_slow(TRAPS) {</span>
<span class="udiff-line-modified-removed">-   assert(THREAD != _owner &amp;&amp; !THREAD-&gt;is_lock_owned((address) _owner), &quot;must not be owner&quot;);</span>
<span class="udiff-line-modified-removed">-   THROW_MSG(vmSymbols::java_lang_IllegalMonitorStateException(), &quot;current thread not owner&quot;);</span>
<span class="udiff-line-modified-added">+ // Returns true if the specified thread owns the ObjectMonitor.</span>
<span class="udiff-line-modified-added">+ // Otherwise returns false and throws IllegalMonitorStateException</span>
<span class="udiff-line-modified-added">+ // (IMSE). If there is a pending exception and the specified thread</span>
<span class="udiff-line-modified-added">+ // is not the owner, that exception will be replaced by the IMSE.</span>
<span class="udiff-line-modified-added">+ bool ObjectMonitor::check_owner(Thread* THREAD) {</span>
<span class="udiff-line-modified-added">+   void* cur = Atomic::load(&amp;_owner);</span>
<span class="udiff-line-added">+   if (cur == THREAD) {</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (THREAD-&gt;is_lock_owned((address)cur)) {</span>
<span class="udiff-line-added">+     set_owner_from_BasicLock(cur, THREAD);  // Convert from BasicLock* to Thread*.</span>
<span class="udiff-line-added">+     _recursions = 0;</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),</span>
<span class="udiff-line-added">+              &quot;current thread is not owner&quot;, false);</span>
  }
  
  static void post_monitor_wait_event(EventJavaMonitorWait* event,
                                      ObjectMonitor* monitor,
                                      jlong notifier_tid,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1186,17 +1207,16 @@</span>
    assert(Self-&gt;is_Java_thread(), &quot;Must be Java thread!&quot;);
    JavaThread *jt = (JavaThread *)THREAD;
  
    assert(InitDone, &quot;Unexpectedly not initialized&quot;);
  
<span class="udiff-line-modified-removed">-   // Throw IMSX or IEX.</span>
<span class="udiff-line-removed">-   CHECK_OWNER();</span>
<span class="udiff-line-modified-added">+   CHECK_OWNER();  // Throws IMSE if not owner.</span>
  
    EventJavaMonitorWait event;
  
    // check for a pending interrupt
<span class="udiff-line-modified-removed">-   if (interruptible &amp;&amp; Thread::is_interrupted(Self, true) &amp;&amp; !HAS_PENDING_EXCEPTION) {</span>
<span class="udiff-line-modified-added">+   if (interruptible &amp;&amp; jt-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {</span>
      // post monitor waited event.  Note that this is past-tense, we are done waiting.
      if (JvmtiExport::should_post_monitor_waited()) {
        // Note: &#39;false&#39; parameter is passed here because the
        // wait was not timed out due to thread interrupt.
        JvmtiExport::post_monitor_waited(jt, this, false);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1239,11 +1259,11 @@</span>
    AddWaiter(&amp;node);
    Thread::SpinRelease(&amp;_WaitSetLock);
  
    _Responsible = NULL;
  
<span class="udiff-line-modified-removed">-   intptr_t save = _recursions; // record the old recursion count</span>
<span class="udiff-line-modified-added">+   intx save = _recursions;     // record the old recursion count</span>
    _waiters++;                  // increment the number of waiters
    _recursions = 0;             // set the recursion level to be 1
    exit(true, Self);                    // exit the monitor
    guarantee(_owner != Self, &quot;invariant&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1254,19 +1274,23 @@</span>
    // TODO-FIXME: change the following logic to a loop of the form
    //   while (!timeout &amp;&amp; !interrupted &amp;&amp; _notified == 0) park()
  
    int ret = OS_OK;
    int WasNotified = 0;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Need to check interrupt state whilst still _thread_in_vm</span>
<span class="udiff-line-added">+   bool interrupted = interruptible &amp;&amp; jt-&gt;is_interrupted(false);</span>
<span class="udiff-line-added">+ </span>
    { // State transition wrappers
      OSThread* osthread = Self-&gt;osthread();
      OSThreadWaitState osts(osthread, true);
      {
        ThreadBlockInVM tbivm(jt);
        // Thread is in thread_blocked state and oop access is unsafe.
        jt-&gt;set_suspend_equivalent();
  
<span class="udiff-line-modified-removed">-       if (interruptible &amp;&amp; (Thread::is_interrupted(THREAD, false) || HAS_PENDING_EXCEPTION)) {</span>
<span class="udiff-line-modified-added">+       if (interrupted || HAS_PENDING_EXCEPTION) {</span>
          // Intentionally empty
        } else if (node._notified == 0) {
          if (millis &lt;= 0) {
            Self-&gt;_ParkEvent-&gt;park();
          } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1382,17 +1406,17 @@</span>
    _waiters--;             // decrement the number of waiters
  
    // Verify a few postconditions
    assert(_owner == Self, &quot;invariant&quot;);
    assert(_succ != Self, &quot;invariant&quot;);
<span class="udiff-line-modified-removed">-   assert(((oop)(object()))-&gt;mark() == markOopDesc::encode(this), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+   assert(((oop)(object()))-&gt;mark() == markWord::encode(this), &quot;invariant&quot;);</span>
  
    // check if the notification happened
    if (!WasNotified) {
      // no, it could be timeout or Thread.interrupt() or both
      // check for interrupt event, otherwise it is timeout
<span class="udiff-line-modified-removed">-     if (interruptible &amp;&amp; Thread::is_interrupted(Self, true) &amp;&amp; !HAS_PENDING_EXCEPTION) {</span>
<span class="udiff-line-modified-added">+     if (interruptible &amp;&amp; jt-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {</span>
        THROW(vmSymbols::java_lang_InterruptedException());
      }
    }
  
    // NOTE: Spurious wake up will be consider as timeout.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1436,11 +1460,11 @@</span>
      } else {
        iterator-&gt;TState = ObjectWaiter::TS_CXQ;
        for (;;) {
          ObjectWaiter * front = _cxq;
          iterator-&gt;_next = front;
<span class="udiff-line-modified-removed">-         if (Atomic::cmpxchg(iterator, &amp;_cxq, front) == front) {</span>
<span class="udiff-line-modified-added">+         if (Atomic::cmpxchg(&amp;_cxq, front, iterator) == front) {</span>
            break;
          }
        }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1466,11 +1490,11 @@</span>
  // When the &quot;minimum wait&quot; is set to a small non-zero timeout value
  // and the program does not hang whereas it did absent &quot;minimum wait&quot;,
  // that suggests a lost wakeup bug.
  
  void ObjectMonitor::notify(TRAPS) {
<span class="udiff-line-modified-removed">-   CHECK_OWNER();</span>
<span class="udiff-line-modified-added">+   CHECK_OWNER();  // Throws IMSE if not owner.</span>
    if (_WaitSet == NULL) {
      return;
    }
    DTRACE_MONITOR_PROBE(notify, this, object(), THREAD);
    INotify(THREAD);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1484,11 +1508,11 @@</span>
  // that in prepend-mode we invert the order of the waiters. Let&#39;s say that the
  // waitset is &quot;ABCD&quot; and the EntryList is &quot;XYZ&quot;. After a notifyAll() in prepend
  // mode the waitset will be empty and the EntryList will be &quot;DCBAXYZ&quot;.
  
  void ObjectMonitor::notifyAll(TRAPS) {
<span class="udiff-line-modified-removed">-   CHECK_OWNER();</span>
<span class="udiff-line-modified-added">+   CHECK_OWNER();  // Throws IMSE if not owner.</span>
    if (_WaitSet == NULL) {
      return;
    }
  
    DTRACE_MONITOR_PROBE(notifyAll, this, object(), THREAD);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1657,11 +1681,11 @@</span>
      // the spin without prejudice or apply a &quot;penalty&quot; to the
      // spin count-down variable &quot;ctr&quot;, reducing it by 100, say.
  
      Thread * ox = (Thread *) _owner;
      if (ox == NULL) {
<span class="udiff-line-modified-removed">-       ox = (Thread*)Atomic::cmpxchg(Self, &amp;_owner, (void*)NULL);</span>
<span class="udiff-line-modified-added">+       ox = (Thread*)try_set_owner_from(NULL, Self);</span>
        if (ox == NULL) {
          // The CAS succeeded -- this thread acquired ownership
          // Take care of some bookkeeping to exit spin state.
          if (_succ == Self) {
            _succ = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1920,5 +1944,68 @@</span>
  #undef NEWPERFVARIABLE
    }
  
    DEBUG_ONLY(InitDone = true;)
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ObjectMonitor::print_on(outputStream* st) const {</span>
<span class="udiff-line-added">+   // The minimal things to print for markWord printing, more can be added for debugging and logging.</span>
<span class="udiff-line-added">+   st-&gt;print(&quot;{contentions=0x%08x,waiters=0x%08x&quot;</span>
<span class="udiff-line-added">+             &quot;,recursions=&quot; INTX_FORMAT &quot;,owner=&quot; INTPTR_FORMAT &quot;}&quot;,</span>
<span class="udiff-line-added">+             contentions(), waiters(), recursions(),</span>
<span class="udiff-line-added">+             p2i(owner()));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ void ObjectMonitor::print() const { print_on(tty); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+ // Print the ObjectMonitor like a debugger would:</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // (ObjectMonitor) 0x00007fdfb6012e40 = {</span>
<span class="udiff-line-added">+ //   _header = 0x0000000000000001</span>
<span class="udiff-line-added">+ //   _object = 0x000000070ff45fd0</span>
<span class="udiff-line-added">+ //   _next_om = 0x0000000000000000</span>
<span class="udiff-line-added">+ //   _pad_buf0 = {</span>
<span class="udiff-line-added">+ //     [0] = &#39;\0&#39;</span>
<span class="udiff-line-added">+ //     ...</span>
<span class="udiff-line-added">+ //     [103] = &#39;\0&#39;</span>
<span class="udiff-line-added">+ //   }</span>
<span class="udiff-line-added">+ //   _owner = 0x0000000000000000</span>
<span class="udiff-line-added">+ //   _previous_owner_tid = 0</span>
<span class="udiff-line-added">+ //   _recursions = 0</span>
<span class="udiff-line-added">+ //   _EntryList = 0x0000000000000000</span>
<span class="udiff-line-added">+ //   _cxq = 0x0000000000000000</span>
<span class="udiff-line-added">+ //   _succ = 0x0000000000000000</span>
<span class="udiff-line-added">+ //   _Responsible = 0x0000000000000000</span>
<span class="udiff-line-added">+ //   _Spinner = 0</span>
<span class="udiff-line-added">+ //   _SpinDuration = 5000</span>
<span class="udiff-line-added">+ //   _contentions = 0</span>
<span class="udiff-line-added">+ //   _WaitSet = 0x0000700009756248</span>
<span class="udiff-line-added">+ //   _waiters = 1</span>
<span class="udiff-line-added">+ //   _WaitSetLock = 0</span>
<span class="udiff-line-added">+ // }</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ void ObjectMonitor::print_debug_style_on(outputStream* st) const {</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;(ObjectMonitor*) &quot; INTPTR_FORMAT &quot; = {&quot;, p2i(this));</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _header = &quot; INTPTR_FORMAT, header().value());</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _object = &quot; INTPTR_FORMAT, p2i(_object));</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _next_om = &quot; INTPTR_FORMAT, p2i(next_om()));</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _pad_buf0 = {&quot;);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;    [0] = &#39;\\0&#39;&quot;);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;    ...&quot;);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;    [%d] = &#39;\\0&#39;&quot;, (int)sizeof(_pad_buf0) - 1);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  }&quot;);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _owner = &quot; INTPTR_FORMAT, p2i(_owner));</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _previous_owner_tid = &quot; JLONG_FORMAT, _previous_owner_tid);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _recursions = &quot; INTX_FORMAT, _recursions);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _EntryList = &quot; INTPTR_FORMAT, p2i(_EntryList));</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _cxq = &quot; INTPTR_FORMAT, p2i(_cxq));</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _succ = &quot; INTPTR_FORMAT, p2i(_succ));</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _Responsible = &quot; INTPTR_FORMAT, p2i(_Responsible));</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _Spinner = %d&quot;, _Spinner);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _SpinDuration = %d&quot;, _SpinDuration);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _contentions = %d&quot;, _contentions);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _WaitSet = &quot; INTPTR_FORMAT, p2i(_WaitSet));</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _waiters = %d&quot;, _waiters);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;  _WaitSetLock = %d&quot;, _WaitSetLock);</span>
<span class="udiff-line-added">+   st-&gt;print_cr(&quot;}&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif</span>
</pre>
<center><a href="mutexLocker.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objectMonitor.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
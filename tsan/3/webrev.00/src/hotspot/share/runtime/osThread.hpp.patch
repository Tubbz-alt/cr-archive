diff a/src/hotspot/share/runtime/osThread.hpp b/src/hotspot/share/runtime/osThread.hpp
--- a/src/hotspot/share/runtime/osThread.hpp
+++ b/src/hotspot/share/runtime/osThread.hpp
@@ -60,16 +60,10 @@
   friend class JVMCIVMStructs;
  private:
   OSThreadStartFunc _start_proc;  // Thread start routine
   void* _start_parm;              // Thread start routine parameter
   volatile ThreadState _state;    // Thread state *hint*
-  volatile jint _interrupted;     // Thread.isInterrupted state
-
-  // Note:  _interrupted must be jint, so that Java intrinsics can access it.
-  // The value stored there must be either 0 or 1.  It must be possible
-  // for Java to emulate Thread.currentThread().isInterrupted() by performing
-  // the double indirection Thread::current()->_osthread->_interrupted.
 
   // Methods
  public:
   void set_state(ThreadState state)                { _state = state; }
   ThreadState get_state()                          { return _state; }
@@ -80,20 +74,17 @@
   // Accessors
   OSThreadStartFunc start_proc() const              { return _start_proc; }
   void set_start_proc(OSThreadStartFunc start_proc) { _start_proc = start_proc; }
   void* start_parm() const                          { return _start_parm; }
   void set_start_parm(void* start_parm)             { _start_parm = start_parm; }
-
-  volatile bool interrupted() const                 { return _interrupted != 0; }
-  void set_interrupted(bool z)                      { _interrupted = z ? 1 : 0; }
-
+  // This is specialized on Windows.
+#ifndef _WINDOWS
+  void set_interrupted(bool z)                      { /* nothing to do */ }
+#endif
   // Printing
   void print_on(outputStream* st) const;
-  void print() const                                { print_on(tty); }
-
-  // For java intrinsics:
-  static ByteSize interrupted_offset()            { return byte_offset_of(OSThread, _interrupted); }
+  void print() const;
 
   // Platform dependent stuff
 #include OS_HEADER(osThread)
 
  public:

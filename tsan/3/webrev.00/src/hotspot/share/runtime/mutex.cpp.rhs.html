<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/mutex.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 28 #include &quot;runtime/mutex.hpp&quot;
 29 #include &quot;runtime/osThread.hpp&quot;
 30 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
 31 #include &quot;runtime/thread.inline.hpp&quot;
 32 #include &quot;utilities/events.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 
<a name="1" id="anc1"></a><span class="line-added"> 35 #ifdef ASSERT</span>
<span class="line-added"> 36 void Mutex::check_block_state(Thread* thread) {</span>
<span class="line-added"> 37   if (!_allow_vm_block &amp;&amp; thread-&gt;is_VM_thread()) {</span>
<span class="line-added"> 38     // JavaThreads are checked to make sure that they do not hold _allow_vm_block locks during operations</span>
<span class="line-added"> 39     // that could safepoint.  Make sure the vm thread never uses locks with _allow_vm_block == false.</span>
<span class="line-added"> 40     fatal(&quot;VM thread could block on lock that may be held by a JavaThread during safepoint: %s&quot;, name());</span>
<span class="line-added"> 41   }</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43   assert(!os::ThreadCrashProtection::is_crash_protected(thread),</span>
<span class="line-added"> 44          &quot;locking not allowed when crash protection is set&quot;);</span>
<span class="line-added"> 45 }</span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47 void Mutex::check_safepoint_state(Thread* thread) {</span>
<span class="line-added"> 48   check_block_state(thread);</span>
 49 
<a name="2" id="anc2"></a><span class="line-modified"> 50   // If the JavaThread checks for safepoint, verify that the lock wasn&#39;t created with safepoint_check_never.</span>
<span class="line-modified"> 51   if (thread-&gt;is_active_Java_thread()) {</span>
<span class="line-modified"> 52     assert(_safepoint_check_required != _safepoint_check_never,</span>
<span class="line-modified"> 53            &quot;This lock should %s have a safepoint check for Java threads: %s&quot;,</span>
<span class="line-added"> 54            _safepoint_check_required ? &quot;always&quot; : &quot;never&quot;, name());</span>
 55 
<a name="3" id="anc3"></a><span class="line-modified"> 56     // Also check NoSafepointVerifier, and thread state is _thread_in_vm</span>
<span class="line-modified"> 57     thread-&gt;check_for_valid_safepoint_state();</span>
<span class="line-modified"> 58   } else {</span>
<span class="line-modified"> 59     // If initialized with safepoint_check_never, a NonJavaThread should never ask to safepoint check either.</span>
<span class="line-added"> 60     assert(_safepoint_check_required != _safepoint_check_never,</span>
<span class="line-added"> 61            &quot;NonJavaThread should not check for safepoint&quot;);</span>
 62   }
<a name="4" id="anc4"></a><span class="line-modified"> 63 }</span>
 64 
<a name="5" id="anc5"></a><span class="line-modified"> 65 void Mutex::check_no_safepoint_state(Thread* thread) {</span>
<span class="line-modified"> 66   check_block_state(thread);</span>
<span class="line-added"> 67   assert(!thread-&gt;is_active_Java_thread() || _safepoint_check_required != _safepoint_check_always,</span>
<span class="line-added"> 68          &quot;This lock should %s have a safepoint check for Java threads: %s&quot;,</span>
<span class="line-added"> 69          _safepoint_check_required ? &quot;always&quot; : &quot;never&quot;, name());</span>
<span class="line-added"> 70 }</span>
<span class="line-added"> 71 #endif // ASSERT</span>
 72 
<a name="6" id="anc6"></a><span class="line-modified"> 73 void Mutex::lock_contended(Thread* self) {</span>
<span class="line-added"> 74   Mutex *in_flight_mutex = NULL;</span>
 75   DEBUG_ONLY(int retry_cnt = 0;)
<a name="7" id="anc7"></a><span class="line-modified"> 76   bool is_active_Java_thread = self-&gt;is_active_Java_thread();</span>
<span class="line-modified"> 77   do {</span>
<span class="line-modified"> 78     #ifdef ASSERT</span>


 79     if (retry_cnt++ &gt; 3) {
<a name="8" id="anc8"></a><span class="line-modified"> 80       log_trace(vmmutex)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; on %d attempt trying to acquire vmmutex %s&quot;, p2i(self), retry_cnt, _name);</span>
 81     }
<a name="9" id="anc9"></a><span class="line-modified"> 82     #endif // ASSERT</span>
 83 
<a name="10" id="anc10"></a><span class="line-modified"> 84     // Is it a JavaThread participating in the safepoint protocol.</span>
<span class="line-added"> 85     if (is_active_Java_thread) {</span>
 86       assert(rank() &gt; Mutex::special, &quot;Potential deadlock with special or lesser rank mutex&quot;);
<a name="11" id="anc11"></a><span class="line-modified"> 87       { ThreadBlockInVMWithDeadlockCheck tbivmdc((JavaThread *) self, &amp;in_flight_mutex);</span>
<span class="line-modified"> 88         in_flight_mutex = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
 89         _lock.lock();
 90       }
<a name="12" id="anc12"></a><span class="line-modified"> 91       if (in_flight_mutex != NULL) {</span>
 92         // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck
 93         break;
 94       }
 95     } else {
 96       _lock.lock();
 97       break;
 98     }
<a name="13" id="anc13"></a><span class="line-added"> 99   } while (!_lock.try_lock());</span>
<span class="line-added">100 }</span>
<span class="line-added">101 </span>
<span class="line-added">102 void Mutex::lock(Thread* self) {</span>
<span class="line-added">103   check_safepoint_state(self);</span>
<span class="line-added">104 </span>
<span class="line-added">105   assert(_owner != self, &quot;invariant&quot;);</span>
<span class="line-added">106 </span>
<span class="line-added">107   if (!_lock.try_lock()) {</span>
<span class="line-added">108     // The lock is contended, use contended slow-path function to lock</span>
<span class="line-added">109     lock_contended(self);</span>
110   }
111 
112   assert_owner(NULL);
113   set_owner(self);
114 }
115 
<a name="14" id="anc14"></a><span class="line-modified">116 void Mutex::lock() {</span>
<span class="line-modified">117   lock(Thread::current());</span>
118 }
119 
120 // Lock without safepoint check - a degenerate variant of lock() for use by
121 // JavaThreads when it is known to be safe to not check for a safepoint when
122 // acquiring this lock. If the thread blocks acquiring the lock it is not
123 // safepoint-safe and so will prevent a safepoint from being reached. If used
124 // in the wrong way this can lead to a deadlock with the safepoint code.
125 
<a name="15" id="anc15"></a><span class="line-modified">126 void Mutex::lock_without_safepoint_check(Thread * self) {</span>
<span class="line-modified">127   check_no_safepoint_state(self);</span>


128   assert(_owner != self, &quot;invariant&quot;);
129   _lock.lock();
130   assert_owner(NULL);
131   set_owner(self);
132 }
133 
<a name="16" id="anc16"></a><span class="line-modified">134 void Mutex::lock_without_safepoint_check() {</span>
135   lock_without_safepoint_check(Thread::current());
136 }
137 
138 
139 // Returns true if thread succeeds in grabbing the lock, otherwise false.
140 
<a name="17" id="anc17"></a><span class="line-modified">141 bool Mutex::try_lock() {</span>
142   Thread * const self = Thread::current();
<a name="18" id="anc18"></a><span class="line-modified">143   // Some safepoint_check_always locks use try_lock, so cannot check</span>
<span class="line-modified">144   // safepoint state, but can check blocking state.</span>
<span class="line-added">145   check_block_state(self);</span>
146   if (_lock.try_lock()) {
147     assert_owner(NULL);
148     set_owner(self);
149     return true;
150   }
151   return false;
152 }
153 
<a name="19" id="anc19"></a><span class="line-modified">154 void Mutex::release_for_safepoint() {</span>
155   assert_owner(NULL);
156   _lock.unlock();
157 }
158 
<a name="20" id="anc20"></a><span class="line-modified">159 void Mutex::unlock() {</span>
<span class="line-modified">160   DEBUG_ONLY(assert_owner(Thread::current()));</span>
161   set_owner(NULL);
162   _lock.unlock();
163 }
164 
165 void Monitor::notify() {
<a name="21" id="anc21"></a><span class="line-modified">166   DEBUG_ONLY(assert_owner(Thread::current()));</span>
167   _lock.notify();
168 }
169 
170 void Monitor::notify_all() {
<a name="22" id="anc22"></a><span class="line-modified">171   DEBUG_ONLY(assert_owner(Thread::current()));</span>
172   _lock.notify_all();
173 }
174 
<a name="23" id="anc23"></a><span class="line-modified">175 #ifdef ASSERT</span>
<span class="line-modified">176 void Monitor::assert_wait_lock_state(Thread* self) {</span>
<span class="line-modified">177   Mutex* least = get_least_ranked_lock_besides_this(self-&gt;owned_locks());</span>


















178   assert(least != this, &quot;Specification of get_least_... call above&quot;);
179   if (least != NULL &amp;&amp; least-&gt;rank() &lt;= special) {
180     ::tty-&gt;print(&quot;Attempting to wait on monitor %s/%d while holding&quot;
181                &quot; lock %s/%d -- possible deadlock&quot;,
182                name(), rank(), least-&gt;name(), least-&gt;rank());
183     assert(false, &quot;Shouldn&#39;t block(wait) while holding a lock of rank special&quot;);
184   }
<a name="24" id="anc24"></a><span class="line-modified">185 }</span>
<span class="line-added">186 #endif // ASSERT</span>
<span class="line-added">187 </span>
<span class="line-added">188 bool Monitor::wait_without_safepoint_check(long timeout) {</span>
<span class="line-added">189   Thread* const self = Thread::current();</span>
<span class="line-added">190 </span>
<span class="line-added">191   // timeout is in milliseconds - with zero meaning never timeout</span>
<span class="line-added">192   assert(timeout &gt;= 0, &quot;negative timeout&quot;);</span>
<span class="line-added">193 </span>
<span class="line-added">194   assert_owner(self);</span>
<span class="line-added">195   assert_wait_lock_state(self);</span>
196 
<a name="25" id="anc25"></a>
197   // conceptually set the owner to NULL in anticipation of
198   // abdicating the lock in wait
199   set_owner(NULL);
<a name="26" id="anc26"></a><span class="line-modified">200   // Check safepoint state after resetting owner and possible NSV.</span>
<span class="line-modified">201   check_no_safepoint_state(self);</span>














202 
<a name="27" id="anc27"></a><span class="line-modified">203   int wait_status = _lock.wait(timeout);</span>
<span class="line-modified">204   set_owner(self);</span>
<span class="line-modified">205   return wait_status != 0;          // return true IFF timeout</span>
<span class="line-modified">206 }</span>
<span class="line-modified">207 </span>
<span class="line-modified">208 bool Monitor::wait(long timeout, bool as_suspend_equivalent) {</span>
<span class="line-modified">209   Thread* const self = Thread::current();</span>
<span class="line-modified">210 </span>
<span class="line-modified">211   // timeout is in milliseconds - with zero meaning never timeout</span>
<span class="line-modified">212   assert(timeout &gt;= 0, &quot;negative timeout&quot;);</span>
<span class="line-modified">213 </span>
<span class="line-modified">214   assert_owner(self);</span>
<span class="line-modified">215 </span>
<span class="line-added">216   // Safepoint checking logically implies an active JavaThread.</span>
<span class="line-added">217   guarantee(self-&gt;is_active_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-added">218   assert_wait_lock_state(self);</span>
<span class="line-added">219 </span>
<span class="line-added">220   int wait_status;</span>
<span class="line-added">221   // conceptually set the owner to NULL in anticipation of</span>
<span class="line-added">222   // abdicating the lock in wait</span>
<span class="line-added">223   set_owner(NULL);</span>
<span class="line-added">224   // Check safepoint state after resetting owner and possible NSV.</span>
<span class="line-added">225   check_safepoint_state(self);</span>
<span class="line-added">226   JavaThread *jt = (JavaThread *)self;</span>
<span class="line-added">227   Mutex* in_flight_mutex = NULL;</span>
<span class="line-added">228 </span>
<span class="line-added">229   {</span>
<span class="line-added">230     ThreadBlockInVMWithDeadlockCheck tbivmdc(jt, &amp;in_flight_mutex);</span>
<span class="line-added">231     OSThreadWaitState osts(self-&gt;osthread(), false /* not Object.wait() */);</span>
<span class="line-added">232     if (as_suspend_equivalent) {</span>
<span class="line-added">233       jt-&gt;set_suspend_equivalent();</span>
<span class="line-added">234       // cleared by handle_special_suspend_equivalent_condition() or</span>
<span class="line-added">235       // java_suspend_self()</span>
236     }
237 
<a name="28" id="anc28"></a><span class="line-modified">238     wait_status = _lock.wait(timeout);</span>
<span class="line-modified">239     in_flight_mutex = this;  // save for ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">240 </span>
<span class="line-modified">241     // were we externally suspended while we were waiting?</span>
<span class="line-modified">242     if (as_suspend_equivalent &amp;&amp; jt-&gt;handle_special_suspend_equivalent_condition()) {</span>
<span class="line-modified">243       // Our event wait has finished and we own the lock, but</span>
<span class="line-modified">244       // while we were waiting another thread suspended us. We don&#39;t</span>
<span class="line-added">245       // want to hold the lock while suspended because that</span>
<span class="line-added">246       // would surprise the thread that suspended us.</span>
<span class="line-added">247       _lock.unlock();</span>
<span class="line-added">248       jt-&gt;java_suspend_self();</span>
<span class="line-added">249       _lock.lock();</span>
250     }
251   }
<a name="29" id="anc29"></a>


252 
<a name="30" id="anc30"></a><span class="line-modified">253   if (in_flight_mutex != NULL) {</span>
<span class="line-modified">254     // Not unlocked by ~ThreadBlockInVMWithDeadlockCheck</span>
<span class="line-modified">255     assert_owner(NULL);</span>
<span class="line-modified">256     // Conceptually reestablish ownership of the lock.</span>
<span class="line-modified">257     set_owner(self);</span>
<span class="line-modified">258   } else {</span>
<span class="line-added">259     lock(self);</span>
<span class="line-added">260   }</span>
261 
<a name="31" id="anc31"></a><span class="line-modified">262   return wait_status != 0;          // return true IFF timeout</span>


263 }
264 
<a name="32" id="anc32"></a><span class="line-modified">265 Mutex::~Mutex() {</span>
266   assert_owner(NULL);
<a name="33" id="anc33"></a>
267 }
268 
<a name="34" id="anc34"></a><span class="line-modified">269 // Only Threads_lock, Heap_lock and SR_lock may be safepoint_check_sometimes.</span>
<span class="line-modified">270 bool is_sometimes_ok(const char* name) {</span>
<span class="line-added">271   return (strcmp(name, &quot;Threads_lock&quot;) == 0 || strcmp(name, &quot;Heap_lock&quot;) == 0 || strcmp(name, &quot;SR_lock&quot;) == 0);</span>
272 }
273 
<a name="35" id="anc35"></a><span class="line-modified">274 Mutex::Mutex(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-modified">275              SafepointCheckRequired safepoint_check_required) : _owner(NULL) {</span>
<span class="line-added">276   assert(os::mutex_init_done(), &quot;Too early!&quot;);</span>
277   if (name == NULL) {
<a name="36" id="anc36"></a><span class="line-modified">278     strcpy(_name, &quot;UNKNOWN&quot;);</span>
279   } else {
<a name="37" id="anc37"></a><span class="line-modified">280     strncpy(_name, name, MUTEX_NAME_LEN - 1);</span>
<span class="line-modified">281     _name[MUTEX_NAME_LEN - 1] = &#39;\0&#39;;</span>
282   }
<a name="38" id="anc38"></a>










283 #ifdef ASSERT
284   _allow_vm_block  = allow_vm_block;
285   _rank            = Rank;
<a name="39" id="anc39"></a><span class="line-modified">286   _safepoint_check_required = safepoint_check_required;</span>


287 
<a name="40" id="anc40"></a><span class="line-modified">288   assert(_safepoint_check_required != _safepoint_check_sometimes || is_sometimes_ok(name),</span>
<span class="line-modified">289          &quot;Lock has _safepoint_check_sometimes %s&quot;, name);</span>
<span class="line-modified">290 </span>
<span class="line-modified">291   assert(_rank &gt; special || _safepoint_check_required == _safepoint_check_never,</span>
<span class="line-modified">292          &quot;Special locks or below should never safepoint&quot;);</span>


293 #endif
294 }
295 
<a name="41" id="anc41"></a><span class="line-modified">296 Monitor::Monitor(int Rank, const char * name, bool allow_vm_block,</span>
<span class="line-added">297              SafepointCheckRequired safepoint_check_required) :</span>
<span class="line-added">298   Mutex(Rank, name, allow_vm_block, safepoint_check_required) {}</span>
<span class="line-added">299 </span>
<span class="line-added">300 bool Mutex::owned_by_self() const {</span>
301   return _owner == Thread::current();
302 }
303 
<a name="42" id="anc42"></a><span class="line-modified">304 void Mutex::print_on_error(outputStream* st) const {</span>
305   st-&gt;print(&quot;[&quot; PTR_FORMAT, p2i(this));
306   st-&gt;print(&quot;] %s&quot;, _name);
307   st-&gt;print(&quot; - owner thread: &quot; PTR_FORMAT, p2i(_owner));
308 }
309 
310 // ----------------------------------------------------------------------------------
311 // Non-product code
312 
313 #ifndef PRODUCT
<a name="43" id="anc43"></a><span class="line-modified">314 const char* print_safepoint_check(Mutex::SafepointCheckRequired safepoint_check) {</span>
<span class="line-modified">315   switch (safepoint_check) {</span>
<span class="line-modified">316   case Mutex::_safepoint_check_never:     return &quot;safepoint_check_never&quot;;</span>
<span class="line-added">317   case Mutex::_safepoint_check_sometimes: return &quot;safepoint_check_sometimes&quot;;</span>
<span class="line-added">318   case Mutex::_safepoint_check_always:    return &quot;safepoint_check_always&quot;;</span>
<span class="line-added">319   default: return &quot;&quot;;</span>
<span class="line-added">320   }</span>
<span class="line-added">321 }</span>
<span class="line-added">322 </span>
<span class="line-added">323 void Mutex::print_on(outputStream* st) const {</span>
<span class="line-added">324   st-&gt;print(&quot;Mutex: [&quot; PTR_FORMAT &quot;] %s - owner: &quot; PTR_FORMAT,</span>
<span class="line-added">325             p2i(this), _name, p2i(_owner));</span>
<span class="line-added">326   if (_allow_vm_block) {</span>
<span class="line-added">327     st-&gt;print(&quot;%s&quot;, &quot; allow_vm_block&quot;);</span>
<span class="line-added">328   }</span>
<span class="line-added">329   st-&gt;print(&quot; %s&quot;, print_safepoint_check(_safepoint_check_required));</span>
<span class="line-added">330   st-&gt;cr();</span>
331 }
332 #endif
333 
<a name="44" id="anc44"></a>
334 #ifdef ASSERT
<a name="45" id="anc45"></a><span class="line-modified">335 void Mutex::assert_owner(Thread * expected) {</span>

336   const char* msg = &quot;invalid owner&quot;;
337   if (expected == NULL) {
338     msg = &quot;should be un-owned&quot;;
339   }
340   else if (expected == Thread::current()) {
341     msg = &quot;should be owned by current thread&quot;;
342   }
343   assert(_owner == expected,
344          &quot;%s: owner=&quot; INTPTR_FORMAT &quot;, should be=&quot; INTPTR_FORMAT,
345          msg, p2i(_owner), p2i(expected));
346 }
347 
<a name="46" id="anc46"></a><span class="line-modified">348 Mutex* Mutex::get_least_ranked_lock(Mutex* locks) {</span>
<span class="line-modified">349   Mutex *res, *tmp;</span>
350   for (res = tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
351     if (tmp-&gt;rank() &lt; res-&gt;rank()) {
352       res = tmp;
353     }
354   }
355   if (!SafepointSynchronize::is_at_safepoint()) {
356     // In this case, we expect the held locks to be
357     // in increasing rank order (modulo any native ranks)
358     for (tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
359       if (tmp-&gt;next() != NULL) {
360         assert(tmp-&gt;rank() == Mutex::native ||
361                tmp-&gt;rank() &lt;= tmp-&gt;next()-&gt;rank(), &quot;mutex rank anomaly?&quot;);
362       }
363     }
364   }
365   return res;
366 }
367 
<a name="47" id="anc47"></a><span class="line-modified">368 Mutex* Mutex::get_least_ranked_lock_besides_this(Mutex* locks) {</span>
<span class="line-modified">369   Mutex *res, *tmp;</span>
370   for (res = NULL, tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
371     if (tmp != this &amp;&amp; (res == NULL || tmp-&gt;rank() &lt; res-&gt;rank())) {
372       res = tmp;
373     }
374   }
375   if (!SafepointSynchronize::is_at_safepoint()) {
376     // In this case, we expect the held locks to be
377     // in increasing rank order (modulo any native ranks)
378     for (tmp = locks; tmp != NULL; tmp = tmp-&gt;next()) {
379       if (tmp-&gt;next() != NULL) {
380         assert(tmp-&gt;rank() == Mutex::native ||
381                tmp-&gt;rank() &lt;= tmp-&gt;next()-&gt;rank(), &quot;mutex rank anomaly?&quot;);
382       }
383     }
384   }
385   return res;
386 }
387 
<a name="48" id="anc48"></a><span class="line-modified">388 bool Mutex::contains(Mutex* locks, Mutex* lock) {</span>

389   for (; locks != NULL; locks = locks-&gt;next()) {
390     if (locks == lock) {
391       return true;
392     }
393   }
394   return false;
395 }
<a name="49" id="anc49"></a><span class="line-modified">396 </span>
<span class="line-added">397 // NSV implied with locking allow_vm_block or !safepoint_check locks.</span>
<span class="line-added">398 void Mutex::no_safepoint_verifier(Thread* thread, bool enable) {</span>
<span class="line-added">399   // The tty_lock is special because it is released for the safepoint by</span>
<span class="line-added">400   // the safepoint mechanism.</span>
<span class="line-added">401   if (this == tty_lock) {</span>
<span class="line-added">402     return;</span>
<span class="line-added">403   }</span>
<span class="line-added">404 </span>
<span class="line-added">405   if (_allow_vm_block) {</span>
<span class="line-added">406     if (enable) {</span>
<span class="line-added">407       thread-&gt;_no_safepoint_count++;</span>
<span class="line-added">408     } else {</span>
<span class="line-added">409       thread-&gt;_no_safepoint_count--;</span>
<span class="line-added">410     }</span>
<span class="line-added">411   }</span>
<span class="line-added">412 }</span>
413 
414 // Called immediately after lock acquisition or release as a diagnostic
415 // to track the lock-set of the thread and test for rank violations that
416 // might indicate exposure to deadlock.
417 // Rather like an EventListener for _owner (:&gt;).
418 
<a name="50" id="anc50"></a><span class="line-modified">419 void Mutex::set_owner_implementation(Thread *new_owner) {</span>
420   // This function is solely responsible for maintaining
421   // and checking the invariant that threads and locks
422   // are in a 1/N relation, with some some locks unowned.
423   // It uses the Mutex::_owner, Mutex::_next, and
424   // Thread::_owned_locks fields, and no other function
425   // changes those fields.
426   // It is illegal to set the mutex from one non-NULL
427   // owner to another--it must be owned by NULL as an
428   // intermediate state.
429 
430   if (new_owner != NULL) {
431     // the thread is acquiring this lock
432 
433     assert(new_owner == Thread::current(), &quot;Should I be doing this?&quot;);
434     assert(_owner == NULL, &quot;setting the owner thread of an already owned mutex&quot;);
435     _owner = new_owner; // set the owner
436 
437     // link &quot;this&quot; into the owned locks list
438 
<a name="51" id="anc51"></a><span class="line-modified">439     Mutex* locks = get_least_ranked_lock(new_owner-&gt;owned_locks());</span>

440     // Mutex::set_owner_implementation is a friend of Thread
441 
442     assert(this-&gt;rank() &gt;= 0, &quot;bad lock rank&quot;);
443 
444     // Deadlock avoidance rules require us to acquire Mutexes only in
445     // a global total order. For example m1 is the lowest ranked mutex
446     // that the thread holds and m2 is the mutex the thread is trying
447     // to acquire, then deadlock avoidance rules require that the rank
448     // of m2 be less than the rank of m1.
449     // The rank Mutex::native  is an exception in that it is not subject
450     // to the verification rules.
451     if (this-&gt;rank() != Mutex::native &amp;&amp;
452         this-&gt;rank() != Mutex::suspend_resume &amp;&amp;
453         locks != NULL &amp;&amp; locks-&gt;rank() &lt;= this-&gt;rank() &amp;&amp;
454         !SafepointSynchronize::is_at_safepoint()) {
455       new_owner-&gt;print_owned_locks();
456       fatal(&quot;acquiring lock %s/%d out of order with lock %s/%d -- &quot;
457             &quot;possible deadlock&quot;, this-&gt;name(), this-&gt;rank(),
458             locks-&gt;name(), locks-&gt;rank());
459     }
460 
461     this-&gt;_next = new_owner-&gt;_owned_locks;
462     new_owner-&gt;_owned_locks = this;
<a name="52" id="anc52"></a><span class="line-modified">463 </span>
<span class="line-added">464     // NSV implied with locking allow_vm_block flag.</span>
<span class="line-added">465     no_safepoint_verifier(new_owner, true);</span>
466 
467   } else {
468     // the thread is releasing this lock
469 
470     Thread* old_owner = _owner;
<a name="53" id="anc53"></a><span class="line-modified">471     _last_owner = old_owner;</span>
472 
473     assert(old_owner != NULL, &quot;removing the owner thread of an unowned mutex&quot;);
474     assert(old_owner == Thread::current(), &quot;removing the owner thread of an unowned mutex&quot;);
475 
476     _owner = NULL; // set the owner
477 
<a name="54" id="anc54"></a><span class="line-modified">478     Mutex* locks = old_owner-&gt;owned_locks();</span>

479 
480     // remove &quot;this&quot; from the owned locks list
481 
<a name="55" id="anc55"></a><span class="line-modified">482     Mutex* prev = NULL;</span>
483     bool found = false;
484     for (; locks != NULL; prev = locks, locks = locks-&gt;next()) {
485       if (locks == this) {
486         found = true;
487         break;
488       }
489     }
490     assert(found, &quot;Removing a lock not owned&quot;);
491     if (prev == NULL) {
492       old_owner-&gt;_owned_locks = _next;
493     } else {
494       prev-&gt;_next = _next;
495     }
496     _next = NULL;
<a name="56" id="anc56"></a>


















497 
<a name="57" id="anc57"></a><span class="line-modified">498     // ~NSV implied with locking allow_vm_block flag.</span>
<span class="line-modified">499     no_safepoint_verifier(old_owner, false);</span>



500   }
<a name="58" id="anc58"></a>
501 }
<a name="59" id="anc59"></a><span class="line-modified">502 #endif // ASSERT</span>

<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
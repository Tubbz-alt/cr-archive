<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/jniHandles.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;memory/iterator.hpp&quot;
 29 #include &quot;oops/access.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/handles.inline.hpp&quot;
 32 #include &quot;runtime/jniHandles.inline.hpp&quot;
 33 #include &quot;runtime/mutexLocker.hpp&quot;
 34 #include &quot;runtime/thread.inline.hpp&quot;
 35 #include &quot;utilities/align.hpp&quot;
 36 #include &quot;utilities/debug.hpp&quot;
 37 
 38 OopStorage* JNIHandles::_global_handles = NULL;
 39 OopStorage* JNIHandles::_weak_global_handles = NULL;
 40 
 41 OopStorage* JNIHandles::global_handles() {
 42   assert(_global_handles != NULL, &quot;Uninitialized JNI global handles&quot;);
 43   return _global_handles;
 44 }
 45 
 46 OopStorage* JNIHandles::weak_global_handles() {
 47   assert(_weak_global_handles != NULL, &quot;Uninitialized JNI weak global handles&quot;);
 48   return _weak_global_handles;
 49 }
 50 
 51 
 52 jobject JNIHandles::make_local(oop obj) {
 53   if (obj == NULL) {
 54     return NULL;                // ignore null handles
 55   } else {
 56     Thread* thread = Thread::current();
 57     assert(oopDesc::is_oop(obj), &quot;not an oop&quot;);
 58     assert(!current_thread_in_native(), &quot;must not be in native&quot;);
 59     return thread-&gt;active_handles()-&gt;allocate_handle(obj);
 60   }
 61 }
 62 
 63 
 64 // optimized versions
 65 
 66 jobject JNIHandles::make_local(Thread* thread, oop obj) {
 67   if (obj == NULL) {
 68     return NULL;                // ignore null handles
 69   } else {
 70     assert(oopDesc::is_oop(obj), &quot;not an oop&quot;);
 71     assert(thread-&gt;is_Java_thread(), &quot;not a Java thread&quot;);
 72     assert(!current_thread_in_native(), &quot;must not be in native&quot;);
 73     return thread-&gt;active_handles()-&gt;allocate_handle(obj);
 74   }
 75 }
 76 
 77 
 78 jobject JNIHandles::make_local(JNIEnv* env, oop obj) {
 79   if (obj == NULL) {
 80     return NULL;                // ignore null handles
 81   } else {
 82     JavaThread* thread = JavaThread::thread_from_jni_environment(env);
 83     assert(oopDesc::is_oop(obj), &quot;not an oop&quot;);
 84     assert(!current_thread_in_native(), &quot;must not be in native&quot;);
 85     return thread-&gt;active_handles()-&gt;allocate_handle(obj);
 86   }
 87 }
 88 
 89 
 90 static void report_handle_allocation_failure(AllocFailType alloc_failmode,
 91                                              const char* handle_kind) {
 92   if (alloc_failmode == AllocFailStrategy::EXIT_OOM) {
 93     // Fake size value, since we don&#39;t know the min allocation size here.
 94     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,
 95                           &quot;Cannot create %s JNI handle&quot;, handle_kind);
 96   } else {
 97     assert(alloc_failmode == AllocFailStrategy::RETURN_NULL, &quot;invariant&quot;);
 98   }
 99 }
100 
101 jobject JNIHandles::make_global(Handle obj, AllocFailType alloc_failmode) {
102   assert(!Universe::heap()-&gt;is_gc_active(), &quot;can&#39;t extend the root set during GC&quot;);
103   assert(!current_thread_in_native(), &quot;must not be in native&quot;);
104   jobject res = NULL;
105   if (!obj.is_null()) {
106     // ignore null handles
107     assert(oopDesc::is_oop(obj()), &quot;not an oop&quot;);
108     oop* ptr = global_handles()-&gt;allocate();
109     // Return NULL on allocation failure.
110     if (ptr != NULL) {
111       assert(*ptr == NULL, &quot;invariant&quot;);
112       NativeAccess&lt;&gt;::oop_store(ptr, obj());
113       res = reinterpret_cast&lt;jobject&gt;(ptr);
114     } else {
115       report_handle_allocation_failure(alloc_failmode, &quot;global&quot;);
116     }
117   } else {
118     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());
119   }
120 
121   return res;
122 }
123 
124 
125 jobject JNIHandles::make_weak_global(Handle obj, AllocFailType alloc_failmode) {
126   assert(!Universe::heap()-&gt;is_gc_active(), &quot;can&#39;t extend the root set during GC&quot;);
127   assert(!current_thread_in_native(), &quot;must not be in native&quot;);
128   jobject res = NULL;
129   if (!obj.is_null()) {
130     // ignore null handles
131     assert(oopDesc::is_oop(obj()), &quot;not an oop&quot;);
132     oop* ptr = weak_global_handles()-&gt;allocate();
133     // Return NULL on allocation failure.
134     if (ptr != NULL) {
135       assert(*ptr == NULL, &quot;invariant&quot;);
136       NativeAccess&lt;ON_PHANTOM_OOP_REF&gt;::oop_store(ptr, obj());
137       char* tptr = reinterpret_cast&lt;char*&gt;(ptr) + weak_tag_value;
138       res = reinterpret_cast&lt;jobject&gt;(tptr);
139     } else {
140       report_handle_allocation_failure(alloc_failmode, &quot;weak global&quot;);
141     }
142   } else {
143     CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&gt;clear_unhandled_oops());
144   }
145   return res;
146 }
147 
148 // Resolve some erroneous cases to NULL, rather than treating them as
149 // possibly unchecked errors.  In particular, deleted handles are
150 // treated as NULL (though a deleted and later reallocated handle
151 // isn&#39;t detected).
152 oop JNIHandles::resolve_external_guard(jobject handle) {
153   oop result = NULL;
154   if (handle != NULL) {
155     result = resolve_impl&lt;DECORATORS_NONE, true /* external_guard */&gt;(handle);
156   }
157   return result;
158 }
159 
160 bool JNIHandles::is_global_weak_cleared(jweak handle) {
161   assert(handle != NULL, &quot;precondition&quot;);
162   assert(is_jweak(handle), &quot;not a weak handle&quot;);
163   oop* oop_ptr = jweak_ptr(handle);
164   oop value = NativeAccess&lt;ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(oop_ptr);
165   return value == NULL;
166 }
167 
168 void JNIHandles::destroy_global(jobject handle) {
169   if (handle != NULL) {
170     assert(!is_jweak(handle), &quot;wrong method for detroying jweak&quot;);
171     oop* oop_ptr = jobject_ptr(handle);
172     NativeAccess&lt;&gt;::oop_store(oop_ptr, (oop)NULL);
173     global_handles()-&gt;release(oop_ptr);
174   }
175 }
176 
177 
178 void JNIHandles::destroy_weak_global(jobject handle) {
179   if (handle != NULL) {
180     assert(is_jweak(handle), &quot;JNI handle not jweak&quot;);
181     oop* oop_ptr = jweak_ptr(handle);
182     NativeAccess&lt;ON_PHANTOM_OOP_REF&gt;::oop_store(oop_ptr, (oop)NULL);
183     weak_global_handles()-&gt;release(oop_ptr);
184   }
185 }
186 
187 
188 void JNIHandles::oops_do(OopClosure* f) {
189   global_handles()-&gt;oops_do(f);
190 }
191 
192 
193 void JNIHandles::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f) {
194   weak_global_handles()-&gt;weak_oops_do(is_alive, f);
195 }
196 
197 
198 void JNIHandles::weak_oops_do(OopClosure* f) {
199   weak_global_handles()-&gt;weak_oops_do(f);
200 }
201 
202 
203 void JNIHandles::initialize() {
204   _global_handles = new OopStorage(&quot;JNI Global&quot;,
205                                    JNIGlobalAlloc_lock,
206                                    JNIGlobalActive_lock);
207   _weak_global_handles = new OopStorage(&quot;JNI Weak&quot;,
208                                         JNIWeakAlloc_lock,
209                                         JNIWeakActive_lock);
210 }
211 
212 
213 inline bool is_storage_handle(const OopStorage* storage, const oop* ptr) {
214   return storage-&gt;allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;
215 }
216 
217 
218 jobjectRefType JNIHandles::handle_type(Thread* thread, jobject handle) {
219   assert(handle != NULL, &quot;precondition&quot;);
220   jobjectRefType result = JNIInvalidRefType;
221   if (is_jweak(handle)) {
222     if (is_storage_handle(weak_global_handles(), jweak_ptr(handle))) {
223       result = JNIWeakGlobalRefType;
224     }
225   } else {
226     switch (global_handles()-&gt;allocation_status(jobject_ptr(handle))) {
227     case OopStorage::ALLOCATED_ENTRY:
228       result = JNIGlobalRefType;
229       break;
230 
231     case OopStorage::UNALLOCATED_ENTRY:
232       break;                    // Invalid global handle
233 
234     case OopStorage::INVALID_ENTRY:
235       // Not in global storage.  Might be a local handle.
236       if (is_local_handle(thread, handle) ||
237           (thread-&gt;is_Java_thread() &amp;&amp;
238            is_frame_handle((JavaThread*)thread, handle))) {
239         result = JNILocalRefType;
240       }
241       break;
242 
243     default:
244       ShouldNotReachHere();
245     }
246   }
247   return result;
248 }
249 
250 
251 bool JNIHandles::is_local_handle(Thread* thread, jobject handle) {
252   assert(handle != NULL, &quot;precondition&quot;);
253   JNIHandleBlock* block = thread-&gt;active_handles();
254 
255   // Look back past possible native calls to jni_PushLocalFrame.
256   while (block != NULL) {
257     if (block-&gt;chain_contains(handle)) {
258       return true;
259     }
260     block = block-&gt;pop_frame_link();
261   }
262   return false;
263 }
264 
265 
266 // Determine if the handle is somewhere in the current thread&#39;s stack.
267 // We easily can&#39;t isolate any particular stack frame the handle might
268 // come from, so we&#39;ll check the whole stack.
269 
270 bool JNIHandles::is_frame_handle(JavaThread* thr, jobject handle) {
271   assert(handle != NULL, &quot;precondition&quot;);
272   // If there is no java frame, then this must be top level code, such
273   // as the java command executable, in which case, this type of handle
274   // is not permitted.
275   return (thr-&gt;has_last_Java_frame() &amp;&amp;
276          (void*)handle &lt; (void*)thr-&gt;stack_base() &amp;&amp;
277          (void*)handle &gt;= (void*)thr-&gt;last_Java_sp());
278 }
279 
280 
281 bool JNIHandles::is_global_handle(jobject handle) {
282   assert(handle != NULL, &quot;precondition&quot;);
283   return !is_jweak(handle) &amp;&amp; is_storage_handle(global_handles(), jobject_ptr(handle));
284 }
285 
286 
287 bool JNIHandles::is_weak_global_handle(jobject handle) {
288   assert(handle != NULL, &quot;precondition&quot;);
289   return is_jweak(handle) &amp;&amp; is_storage_handle(weak_global_handles(), jweak_ptr(handle));
290 }
291 
292 size_t JNIHandles::global_handle_memory_usage() {
293   return global_handles()-&gt;total_memory_usage();
294 }
295 
296 size_t JNIHandles::weak_global_handle_memory_usage() {
297   return weak_global_handles()-&gt;total_memory_usage();
298 }
299 
300 
301 // We assume this is called at a safepoint: no lock is needed.
302 void JNIHandles::print_on(outputStream* st) {
303   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
304 
305   st-&gt;print_cr(&quot;JNI global refs: &quot; SIZE_FORMAT &quot;, weak refs: &quot; SIZE_FORMAT,
306                global_handles()-&gt;allocation_count(),
307                weak_global_handles()-&gt;allocation_count());
308   st-&gt;cr();
309   st-&gt;flush();
310 }
311 
312 class VerifyJNIHandles: public OopClosure {
313 public:
314   virtual void do_oop(oop* root) {
315     guarantee(oopDesc::is_oop_or_null(RawAccess&lt;&gt;::oop_load(root)), &quot;Invalid oop&quot;);
316   }
317   virtual void do_oop(narrowOop* root) { ShouldNotReachHere(); }
318 };
319 
320 void JNIHandles::verify() {
321   VerifyJNIHandles verify_handle;
322 
323   oops_do(&amp;verify_handle);
324   weak_oops_do(&amp;verify_handle);
325 }
326 
327 // This method is implemented here to avoid circular includes between
328 // jniHandles.hpp and thread.hpp.
329 bool JNIHandles::current_thread_in_native() {
330   Thread* thread = Thread::current();
331   return (thread-&gt;is_Java_thread() &amp;&amp;
332           JavaThread::current()-&gt;thread_state() == _thread_in_native);
333 }
334 
335 
336 void jni_handles_init() {
337   JNIHandles::initialize();
338 }
339 
340 
341 int             JNIHandleBlock::_blocks_allocated     = 0;
342 JNIHandleBlock* JNIHandleBlock::_block_free_list      = NULL;
343 #ifndef PRODUCT
344 JNIHandleBlock* JNIHandleBlock::_block_list           = NULL;
345 #endif
346 
347 
348 #ifdef ASSERT
349 void JNIHandleBlock::zap() {
350   // Zap block values
351   _top = 0;
352   for (int index = 0; index &lt; block_size_in_oops; index++) {
353     // NOT using Access here; just bare clobbering to NULL, since the
354     // block no longer contains valid oops.
355     _handles[index] = NULL;
356   }
357 }
358 #endif // ASSERT
359 
360 JNIHandleBlock* JNIHandleBlock::allocate_block(Thread* thread)  {
361   assert(thread == NULL || thread == Thread::current(), &quot;sanity check&quot;);
362   JNIHandleBlock* block;
363   // Check the thread-local free list for a block so we don&#39;t
364   // have to acquire a mutex.
365   if (thread != NULL &amp;&amp; thread-&gt;free_handle_block() != NULL) {
366     block = thread-&gt;free_handle_block();
367     thread-&gt;set_free_handle_block(block-&gt;_next);
368   }
369   else {
370     // locking with safepoint checking introduces a potential deadlock:
371     // - we would hold JNIHandleBlockFreeList_lock and then Threads_lock
372     // - another would hold Threads_lock (jni_AttachCurrentThread) and then
373     //   JNIHandleBlockFreeList_lock (JNIHandleBlock::allocate_block)
374     MutexLockerEx ml(JNIHandleBlockFreeList_lock,
375                      Mutex::_no_safepoint_check_flag);
376     if (_block_free_list == NULL) {
377       // Allocate new block
378       block = new JNIHandleBlock();
379       _blocks_allocated++;
380       block-&gt;zap();
381       #ifndef PRODUCT
382       // Link new block to list of all allocated blocks
383       block-&gt;_block_list_link = _block_list;
384       _block_list = block;
385       #endif
386     } else {
387       // Get block from free list
388       block = _block_free_list;
389       _block_free_list = _block_free_list-&gt;_next;
390     }
391   }
392   block-&gt;_top = 0;
393   block-&gt;_next = NULL;
394   block-&gt;_pop_frame_link = NULL;
395   block-&gt;_planned_capacity = block_size_in_oops;
396   // _last, _free_list &amp; _allocate_before_rebuild initialized in allocate_handle
397   debug_only(block-&gt;_last = NULL);
398   debug_only(block-&gt;_free_list = NULL);
399   debug_only(block-&gt;_allocate_before_rebuild = -1);
400   return block;
401 }
402 
403 
404 void JNIHandleBlock::release_block(JNIHandleBlock* block, Thread* thread) {
405   assert(thread == NULL || thread == Thread::current(), &quot;sanity check&quot;);
406   JNIHandleBlock* pop_frame_link = block-&gt;pop_frame_link();
407   // Put returned block at the beginning of the thread-local free list.
408   // Note that if thread == NULL, we use it as an implicit argument that
409   // we _don&#39;t_ want the block to be kept on the free_handle_block.
410   // See for instance JavaThread::exit().
411   if (thread != NULL ) {
412     block-&gt;zap();
413     JNIHandleBlock* freelist = thread-&gt;free_handle_block();
414     block-&gt;_pop_frame_link = NULL;
415     thread-&gt;set_free_handle_block(block);
416 
417     // Add original freelist to end of chain
418     if ( freelist != NULL ) {
419       while ( block-&gt;_next != NULL ) block = block-&gt;_next;
420       block-&gt;_next = freelist;
421     }
422     block = NULL;
423   }
424   if (block != NULL) {
425     // Return blocks to free list
426     // locking with safepoint checking introduces a potential deadlock:
427     // - we would hold JNIHandleBlockFreeList_lock and then Threads_lock
428     // - another would hold Threads_lock (jni_AttachCurrentThread) and then
429     //   JNIHandleBlockFreeList_lock (JNIHandleBlock::allocate_block)
430     MutexLockerEx ml(JNIHandleBlockFreeList_lock,
431                      Mutex::_no_safepoint_check_flag);
432     while (block != NULL) {
433       block-&gt;zap();
434       JNIHandleBlock* next = block-&gt;_next;
435       block-&gt;_next = _block_free_list;
436       _block_free_list = block;
437       block = next;
438     }
439   }
440   if (pop_frame_link != NULL) {
441     // As a sanity check we release blocks pointed to by the pop_frame_link.
442     // This should never happen (only if PopLocalFrame is not called the
443     // correct number of times).
444     release_block(pop_frame_link, thread);
445   }
446 }
447 
448 
449 void JNIHandleBlock::oops_do(OopClosure* f) {
450   JNIHandleBlock* current_chain = this;
451   // Iterate over chain of blocks, followed by chains linked through the
452   // pop frame links.
453   while (current_chain != NULL) {
454     for (JNIHandleBlock* current = current_chain; current != NULL;
455          current = current-&gt;_next) {
456       assert(current == current_chain || current-&gt;pop_frame_link() == NULL,
457         &quot;only blocks first in chain should have pop frame link set&quot;);
458       for (int index = 0; index &lt; current-&gt;_top; index++) {
459         oop* root = &amp;(current-&gt;_handles)[index];
460         oop value = *root;
461         // traverse heap pointers only, not deleted handles or free list
462         // pointers
463         if (value != NULL &amp;&amp; Universe::heap()-&gt;is_in_reserved(value)) {
464           f-&gt;do_oop(root);
465         }
466       }
467       // the next handle block is valid only if current block is full
468       if (current-&gt;_top &lt; block_size_in_oops) {
469         break;
470       }
471     }
472     current_chain = current_chain-&gt;pop_frame_link();
473   }
474 }
475 
476 
477 jobject JNIHandleBlock::allocate_handle(oop obj) {
478   assert(Universe::heap()-&gt;is_in_reserved(obj), &quot;sanity check&quot;);
479   if (_top == 0) {
480     // This is the first allocation or the initial block got zapped when
481     // entering a native function. If we have any following blocks they are
482     // not valid anymore.
483     for (JNIHandleBlock* current = _next; current != NULL;
484          current = current-&gt;_next) {
485       assert(current-&gt;_last == NULL, &quot;only first block should have _last set&quot;);
486       assert(current-&gt;_free_list == NULL,
487              &quot;only first block should have _free_list set&quot;);
488       if (current-&gt;_top == 0) {
489         // All blocks after the first clear trailing block are already cleared.
490 #ifdef ASSERT
491         for (current = current-&gt;_next; current != NULL; current = current-&gt;_next) {
492           assert(current-&gt;_top == 0, &quot;trailing blocks must already be cleared&quot;);
493         }
494 #endif
495         break;
496       }
497       current-&gt;_top = 0;
498       current-&gt;zap();
499     }
500     // Clear initial block
501     _free_list = NULL;
502     _allocate_before_rebuild = 0;
503     _last = this;
504     zap();
505   }
506 
507   // Try last block
508   if (_last-&gt;_top &lt; block_size_in_oops) {
509     oop* handle = &amp;(_last-&gt;_handles)[_last-&gt;_top++];
510     NativeAccess&lt;IS_DEST_UNINITIALIZED&gt;::oop_store(handle, obj);
511     return (jobject) handle;
512   }
513 
514   // Try free list
515   if (_free_list != NULL) {
516     oop* handle = _free_list;
517     _free_list = (oop*) *_free_list;
518     NativeAccess&lt;IS_DEST_UNINITIALIZED&gt;::oop_store(handle, obj);
519     return (jobject) handle;
520   }
521   // Check if unused block follow last
522   if (_last-&gt;_next != NULL) {
523     // update last and retry
524     _last = _last-&gt;_next;
525     return allocate_handle(obj);
526   }
527 
528   // No space available, we have to rebuild free list or expand
529   if (_allocate_before_rebuild == 0) {
530       rebuild_free_list();        // updates _allocate_before_rebuild counter
531   } else {
532     // Append new block
533     Thread* thread = Thread::current();
534     Handle obj_handle(thread, obj);
535     // This can block, so we need to preserve obj across call.
536     _last-&gt;_next = JNIHandleBlock::allocate_block(thread);
537     _last = _last-&gt;_next;
538     _allocate_before_rebuild--;
539     obj = obj_handle();
540   }
541   return allocate_handle(obj);  // retry
542 }
543 
544 void JNIHandleBlock::rebuild_free_list() {
545   assert(_allocate_before_rebuild == 0 &amp;&amp; _free_list == NULL, &quot;just checking&quot;);
546   int free = 0;
547   int blocks = 0;
548   for (JNIHandleBlock* current = this; current != NULL; current = current-&gt;_next) {
549     for (int index = 0; index &lt; current-&gt;_top; index++) {
550       oop* handle = &amp;(current-&gt;_handles)[index];
551       if (*handle == NULL) {
552         // this handle was cleared out by a delete call, reuse it
553         *handle = (oop) _free_list;
554         _free_list = handle;
555         free++;
556       }
557     }
558     // we should not rebuild free list if there are unused handles at the end
559     assert(current-&gt;_top == block_size_in_oops, &quot;just checking&quot;);
560     blocks++;
561   }
562   // Heuristic: if more than half of the handles are free we rebuild next time
563   // as well, otherwise we append a corresponding number of new blocks before
564   // attempting a free list rebuild again.
565   int total = blocks * block_size_in_oops;
566   int extra = total - 2*free;
567   if (extra &gt; 0) {
568     // Not as many free handles as we would like - compute number of new blocks to append
569     _allocate_before_rebuild = (extra + block_size_in_oops - 1) / block_size_in_oops;
570   }
571 }
572 
573 
574 bool JNIHandleBlock::contains(jobject handle) const {
575   return ((jobject)&amp;_handles[0] &lt;= handle &amp;&amp; handle&lt;(jobject)&amp;_handles[_top]);
576 }
577 
578 
579 bool JNIHandleBlock::chain_contains(jobject handle) const {
580   for (JNIHandleBlock* current = (JNIHandleBlock*) this; current != NULL; current = current-&gt;_next) {
581     if (current-&gt;contains(handle)) {
582       return true;
583     }
584   }
585   return false;
586 }
587 
588 
589 size_t JNIHandleBlock::length() const {
590   size_t result = 1;
591   for (JNIHandleBlock* current = _next; current != NULL; current = current-&gt;_next) {
592     result++;
593   }
594   return result;
595 }
596 
597 class CountJNIHandleClosure: public OopClosure {
598 private:
599   int _count;
600 public:
601   CountJNIHandleClosure(): _count(0) {}
602   virtual void do_oop(oop* ooph) { _count++; }
603   virtual void do_oop(narrowOop* unused) { ShouldNotReachHere(); }
604   int count() { return _count; }
605 };
606 
607 const size_t JNIHandleBlock::get_number_of_live_handles() {
608   CountJNIHandleClosure counter;
609   oops_do(&amp;counter);
610   return counter.count();
611 }
612 
613 // This method is not thread-safe, i.e., must be called while holding a lock on the
614 // structure.
615 size_t JNIHandleBlock::memory_usage() const {
616   return length() * sizeof(JNIHandleBlock);
617 }
618 
619 
620 #ifndef PRODUCT
621 
622 bool JNIHandles::is_local_handle(jobject handle) {
623   return JNIHandleBlock::any_contains(handle);
624 }
625 
626 bool JNIHandleBlock::any_contains(jobject handle) {
627   assert(handle != NULL, &quot;precondition&quot;);
628   for (JNIHandleBlock* current = _block_list; current != NULL; current = current-&gt;_block_list_link) {
629     if (current-&gt;contains(handle)) {
630       return true;
631     }
632   }
633   return false;
634 }
635 
636 void JNIHandleBlock::print_statistics() {
637   int used_blocks = 0;
638   int free_blocks = 0;
639   int used_handles = 0;
640   int free_handles = 0;
641   JNIHandleBlock* block = _block_list;
642   while (block != NULL) {
643     if (block-&gt;_top &gt; 0) {
644       used_blocks++;
645     } else {
646       free_blocks++;
647     }
648     used_handles += block-&gt;_top;
649     free_handles += (block_size_in_oops - block-&gt;_top);
650     block = block-&gt;_block_list_link;
651   }
652   tty-&gt;print_cr(&quot;JNIHandleBlocks statistics&quot;);
653   tty-&gt;print_cr(&quot;- blocks allocated: %d&quot;, used_blocks + free_blocks);
654   tty-&gt;print_cr(&quot;- blocks in use:    %d&quot;, used_blocks);
655   tty-&gt;print_cr(&quot;- blocks free:      %d&quot;, free_blocks);
656   tty-&gt;print_cr(&quot;- handles in use:   %d&quot;, used_handles);
657   tty-&gt;print_cr(&quot;- handles free:     %d&quot;, free_handles);
658 }
659 
660 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/objectMonitor.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="objectMonitor.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="orderAccess.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/objectMonitor.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,32 +23,31 @@</span>
   */
  
  #ifndef SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
  #define SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
  
<span class="udiff-line-added">+ #include &quot;logging/log.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="udiff-line-added">+ </span>
  inline intptr_t ObjectMonitor::is_entered(TRAPS) const {
    if (THREAD == _owner || THREAD-&gt;is_lock_owned((address) _owner)) {
      return 1;
    }
    return 0;
  }
  
<span class="udiff-line-modified-removed">- inline markOop ObjectMonitor::header() const {</span>
<span class="udiff-line-modified-removed">-   return _header;</span>
<span class="udiff-line-modified-added">+ inline markWord ObjectMonitor::header() const {</span>
<span class="udiff-line-modified-added">+   return Atomic::load(&amp;_header);</span>
  }
  
<span class="udiff-line-modified-removed">- inline volatile markOop* ObjectMonitor::header_addr() {</span>
<span class="udiff-line-modified-added">+ inline volatile markWord* ObjectMonitor::header_addr() {</span>
    assert((intptr_t)this == (intptr_t)&amp;_header, &quot;sync code expects this&quot;);
    return &amp;_header;
  }
  
<span class="udiff-line-modified-removed">- inline void ObjectMonitor::set_header(markOop hdr) {</span>
<span class="udiff-line-modified-removed">-   _header = hdr;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline jint ObjectMonitor::count() const {</span>
<span class="udiff-line-removed">-   return _count;</span>
<span class="udiff-line-modified-added">+ inline void ObjectMonitor::set_header(markWord hdr) {</span>
<span class="udiff-line-modified-added">+   Atomic::store(&amp;_header, hdr);</span>
  }
  
  inline jint ObjectMonitor::waiters() const {
    return _waiters;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -56,18 +55,18 @@</span>
  inline void* ObjectMonitor::owner() const {
    return _owner;
  }
  
  inline void ObjectMonitor::clear() {
<span class="udiff-line-modified-removed">-   assert(_header != NULL, &quot;Fatal logic error in ObjectMonitor header!&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(_count == 0, &quot;Fatal logic error in ObjectMonitor count!&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(_waiters == 0, &quot;Fatal logic error in ObjectMonitor waiters!&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(_recursions == 0, &quot;Fatal logic error in ObjectMonitor recursions!&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(_object != NULL, &quot;Fatal logic error in ObjectMonitor object!&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(_owner == NULL, &quot;Fatal logic error in ObjectMonitor owner!&quot;);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   _header = NULL;</span>
<span class="udiff-line-modified-added">+   assert(Atomic::load(&amp;_header).value() != 0, &quot;must be non-zero&quot;);</span>
<span class="udiff-line-modified-added">+   assert(_contentions == 0, &quot;must be 0: contentions=%d&quot;, _contentions);</span>
<span class="udiff-line-modified-added">+   assert(_waiters == 0, &quot;must be 0: waiters=%d&quot;, _waiters);</span>
<span class="udiff-line-modified-added">+   assert(_recursions == 0, &quot;must be 0: recursions=&quot; INTX_FORMAT, _recursions);</span>
<span class="udiff-line-modified-added">+   assert(_object != NULL, &quot;must be non-NULL&quot;);</span>
<span class="udiff-line-modified-added">+   assert(_owner == NULL, &quot;must be NULL: owner=&quot; INTPTR_FORMAT, p2i(_owner));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   Atomic::store(&amp;_header, markWord::zero());</span>
    _object = NULL;
  }
  
  inline void* ObjectMonitor::object() const {
    return _object;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79,32 +78,83 @@</span>
  
  inline void ObjectMonitor::set_object(void* obj) {
    _object = obj;
  }
  
<span class="udiff-line-modified-removed">- inline bool ObjectMonitor::check(TRAPS) {</span>
<span class="udiff-line-modified-removed">-   if (THREAD != _owner) {</span>
<span class="udiff-line-modified-removed">-     if (THREAD-&gt;is_lock_owned((address) _owner)) {</span>
<span class="udiff-line-modified-removed">-       _owner = THREAD;  // regain ownership of inflated monitor</span>
<span class="udiff-line-modified-removed">-       assert (_recursions == 0, &quot;invariant&quot;) ;</span>
<span class="udiff-line-modified-removed">-     } else {</span>
<span class="udiff-line-modified-removed">-       check_slow(THREAD);</span>
<span class="udiff-line-modified-removed">-       return false;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+ // return number of threads contending for this monitor</span>
<span class="udiff-line-modified-added">+ inline jint ObjectMonitor::contentions() const {</span>
<span class="udiff-line-modified-added">+   return _contentions;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ // Clear _owner field; current value must match old_value.</span>
<span class="udiff-line-modified-added">+ inline void ObjectMonitor::release_clear_owner(void* old_value) {</span>
<span class="udiff-line-modified-added">+   DEBUG_ONLY(void* prev = Atomic::load(&amp;_owner);)</span>
<span class="udiff-line-modified-added">+   assert(prev == old_value, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="udiff-line-added">+          &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(old_value));</span>
<span class="udiff-line-added">+   Atomic::release_store(&amp;_owner, (void*)NULL);</span>
<span class="udiff-line-added">+   log_trace(monitorinflation, owner)(&quot;release_clear_owner(): mid=&quot;</span>
<span class="udiff-line-added">+                                      INTPTR_FORMAT &quot;, old_value=&quot; INTPTR_FORMAT,</span>
<span class="udiff-line-added">+                                      p2i(this), p2i(old_value));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Simply set _owner field to new_value; current value must match old_value.</span>
<span class="udiff-line-added">+ // (Simple means no memory sync needed.)</span>
<span class="udiff-line-added">+ inline void ObjectMonitor::set_owner_from(void* old_value, void* new_value) {</span>
<span class="udiff-line-added">+   DEBUG_ONLY(void* prev = Atomic::load(&amp;_owner);)</span>
<span class="udiff-line-added">+   assert(prev == old_value, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="udiff-line-added">+          &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(old_value));</span>
<span class="udiff-line-added">+   Atomic::store(&amp;_owner, new_value);</span>
<span class="udiff-line-added">+   log_trace(monitorinflation, owner)(&quot;set_owner_from(): mid=&quot;</span>
<span class="udiff-line-added">+                                      INTPTR_FORMAT &quot;, old_value=&quot; INTPTR_FORMAT</span>
<span class="udiff-line-added">+                                      &quot;, new_value=&quot; INTPTR_FORMAT, p2i(this),</span>
<span class="udiff-line-added">+                                      p2i(old_value), p2i(new_value));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Simply set _owner field to self; current value must match basic_lock_p.</span>
<span class="udiff-line-added">+ inline void ObjectMonitor::set_owner_from_BasicLock(void* basic_lock_p, Thread* self) {</span>
<span class="udiff-line-added">+   DEBUG_ONLY(void* prev = Atomic::load(&amp;_owner);)</span>
<span class="udiff-line-added">+   assert(prev == basic_lock_p, &quot;unexpected prev owner=&quot; INTPTR_FORMAT</span>
<span class="udiff-line-added">+          &quot;, expected=&quot; INTPTR_FORMAT, p2i(prev), p2i(basic_lock_p));</span>
<span class="udiff-line-added">+   // Non-null owner field to non-null owner field is safe without</span>
<span class="udiff-line-added">+   // cmpxchg() as long as all readers can tolerate either flavor.</span>
<span class="udiff-line-added">+   Atomic::store(&amp;_owner, self);</span>
<span class="udiff-line-added">+   log_trace(monitorinflation, owner)(&quot;set_owner_from_BasicLock(): mid=&quot;</span>
<span class="udiff-line-added">+                                      INTPTR_FORMAT &quot;, basic_lock_p=&quot;</span>
<span class="udiff-line-added">+                                      INTPTR_FORMAT &quot;, new_value=&quot; INTPTR_FORMAT,</span>
<span class="udiff-line-added">+                                      p2i(this), p2i(basic_lock_p), p2i(self));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Try to set _owner field to new_value if the current value matches</span>
<span class="udiff-line-added">+ // old_value. Otherwise, does not change the _owner field. Returns</span>
<span class="udiff-line-added">+ // the prior value of the _owner field.</span>
<span class="udiff-line-added">+ inline void* ObjectMonitor::try_set_owner_from(void* old_value, void* new_value) {</span>
<span class="udiff-line-added">+   void* prev = Atomic::cmpxchg(&amp;_owner, old_value, new_value);</span>
<span class="udiff-line-added">+   if (prev == old_value) {</span>
<span class="udiff-line-added">+     log_trace(monitorinflation, owner)(&quot;try_set_owner_from(): mid=&quot;</span>
<span class="udiff-line-added">+                                        INTPTR_FORMAT &quot;, prev=&quot; INTPTR_FORMAT</span>
<span class="udiff-line-added">+                                        &quot;, new=&quot; INTPTR_FORMAT, p2i(this),</span>
<span class="udiff-line-added">+                                        p2i(prev), p2i(new_value));</span>
    }
<span class="udiff-line-modified-removed">-   return true;</span>
<span class="udiff-line-modified-added">+   return prev;</span>
  }
  
<span class="udiff-line-modified-removed">- // return number of threads contending for this monitor</span>
<span class="udiff-line-modified-removed">- inline jint ObjectMonitor::contentions() const {</span>
<span class="udiff-line-modified-removed">-   return _count;</span>
<span class="udiff-line-modified-added">+ // The _next_om field can be concurrently read and modified so we</span>
<span class="udiff-line-modified-added">+ // use Atomic operations to disable compiler optimizations that</span>
<span class="udiff-line-modified-added">+ // might try to elide loading and/or storing this field.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline ObjectMonitor* ObjectMonitor::next_om() const {</span>
<span class="udiff-line-added">+   return Atomic::load(&amp;_next_om);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Simply set _next_om field to new_value.</span>
<span class="udiff-line-added">+ inline void ObjectMonitor::set_next_om(ObjectMonitor* new_value) {</span>
<span class="udiff-line-added">+   Atomic::store(&amp;_next_om, new_value);</span>
  }
  
<span class="udiff-line-modified-removed">- // Do NOT set _count = 0. There is a race such that _count could</span>
<span class="udiff-line-modified-removed">- // be set while inflating prior to setting _owner</span>
<span class="udiff-line-modified-removed">- // Just use Atomic::inc/dec and assert 0 when monitor put on free list</span>
<span class="udiff-line-modified-removed">- inline void ObjectMonitor::set_owner(void* owner) {</span>
<span class="udiff-line-modified-removed">-   _owner = owner;</span>
<span class="udiff-line-removed">-   _recursions = 0;</span>
<span class="udiff-line-modified-added">+ // Try to set _next_om field to new_value if the current value matches</span>
<span class="udiff-line-modified-added">+ // old_value. Otherwise, does not change the _next_om field. Returns</span>
<span class="udiff-line-modified-added">+ // the prior value of the _next_om field.</span>
<span class="udiff-line-modified-added">+ inline ObjectMonitor* ObjectMonitor::try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value) {</span>
<span class="udiff-line-modified-added">+   return Atomic::cmpxchg(&amp;_next_om, old_value, new_value);</span>
  }
  
  #endif // SHARE_RUNTIME_OBJECTMONITOR_INLINE_HPP
</pre>
<center><a href="objectMonitor.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="orderAccess.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
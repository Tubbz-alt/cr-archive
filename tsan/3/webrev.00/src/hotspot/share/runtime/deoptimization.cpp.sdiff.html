<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/deoptimization.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="biasedLocking.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/deoptimization.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>


   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;

  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;code/debugInfoRec.hpp&quot;
  30 #include &quot;code/nmethod.hpp&quot;
  31 #include &quot;code/pcDesc.hpp&quot;
  32 #include &quot;code/scopeDesc.hpp&quot;

  33 #include &quot;interpreter/bytecode.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;interpreter/oopMapCache.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/oopFactory.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;

  39 #include &quot;oops/constantPool.hpp&quot;
  40 #include &quot;oops/method.hpp&quot;

  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified">  43 #include &quot;oops/fieldStreams.hpp&quot;</span>
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;oops/verifyOopClosure.hpp&quot;
  46 #include &quot;prims/jvmtiThreadState.hpp&quot;

  47 #include &quot;runtime/biasedLocking.hpp&quot;
<span class="line-removed">  48 #include &quot;runtime/compilationPolicy.hpp&quot;</span>
  49 #include &quot;runtime/deoptimization.hpp&quot;


  50 #include &quot;runtime/frame.inline.hpp&quot;
  51 #include &quot;runtime/handles.inline.hpp&quot;
  52 #include &quot;runtime/interfaceSupport.inline.hpp&quot;

  53 #include &quot;runtime/safepointVerifiers.hpp&quot;
  54 #include &quot;runtime/sharedRuntime.hpp&quot;
  55 #include &quot;runtime/signature.hpp&quot;
  56 #include &quot;runtime/stubRoutines.hpp&quot;
  57 #include &quot;runtime/thread.hpp&quot;
  58 #include &quot;runtime/threadSMR.hpp&quot;
  59 #include &quot;runtime/vframe.hpp&quot;
  60 #include &quot;runtime/vframeArray.hpp&quot;
  61 #include &quot;runtime/vframe_hp.hpp&quot;
  62 #include &quot;utilities/events.hpp&quot;

  63 #include &quot;utilities/preserveException.hpp&quot;
  64 #include &quot;utilities/xmlstream.hpp&quot;
<span class="line-modified">  65 </span>
<span class="line-modified">  66 #if INCLUDE_JVMCI</span>
<span class="line-modified">  67 #include &quot;jvmci/jvmciRuntime.hpp&quot;</span>
<span class="line-removed">  68 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;</span>
  69 #endif
  70 
<span class="line-removed">  71 </span>
  72 bool DeoptimizationMarker::_is_active = false;
  73 
  74 Deoptimization::UnrollBlock::UnrollBlock(int  size_of_deoptimized_frame,
  75                                          int  caller_adjustment,
  76                                          int  caller_actual_parameters,
  77                                          int  number_of_frames,
  78                                          intptr_t* frame_sizes,
  79                                          address* frame_pcs,
  80                                          BasicType return_type,
  81                                          int exec_mode) {
  82   _size_of_deoptimized_frame = size_of_deoptimized_frame;
  83   _caller_adjustment         = caller_adjustment;
  84   _caller_actual_parameters  = caller_actual_parameters;
  85   _number_of_frames          = number_of_frames;
  86   _frame_sizes               = frame_sizes;
  87   _frame_pcs                 = frame_pcs;
  88   _register_block            = NEW_C_HEAP_ARRAY(intptr_t, RegisterMap::reg_count * 2, mtCompiler);
  89   _return_type               = return_type;
  90   _initial_info              = 0;
  91   // PD (x86 only)
</pre>
<hr />
<pre>
 139 // ResetNoHandleMark and HandleMark were removed from it. The actual reallocation
 140 // of previously eliminated objects occurs in realloc_objects, which is
 141 // called from the method fetch_unroll_info_helper below.
 142 JRT_BLOCK_ENTRY(Deoptimization::UnrollBlock*, Deoptimization::fetch_unroll_info(JavaThread* thread, int exec_mode))
 143   // It is actually ok to allocate handles in a leaf method. It causes no safepoints,
 144   // but makes the entry a little slower. There is however a little dance we have to
 145   // do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro
 146 
 147   // fetch_unroll_info() is called at the beginning of the deoptimization
 148   // handler. Note this fact before we start generating temporary frames
 149   // that can confuse an asynchronous stack walker. This counter is
 150   // decremented at the end of unpack_frames().
 151   if (TraceDeoptimization) {
 152     tty-&gt;print_cr(&quot;Deoptimizing thread &quot; INTPTR_FORMAT, p2i(thread));
 153   }
 154   thread-&gt;inc_in_deopt_handler();
 155 
 156   return fetch_unroll_info_helper(thread, exec_mode);
 157 JRT_END
 158 






















































































 159 
 160 // This is factored, since it is both called from a JRT_LEAF (deoptimization) and a JRT_ENTRY (uncommon_trap)
 161 Deoptimization::UnrollBlock* Deoptimization::fetch_unroll_info_helper(JavaThread* thread, int exec_mode) {
 162 
 163   // Note: there is a safepoint safety issue here. No matter whether we enter
 164   // via vanilla deopt or uncommon trap we MUST NOT stop at a safepoint once
 165   // the vframeArray is created.
 166   //
 167 
 168   // Allocate our special deoptimization ResourceMark
 169   DeoptResourceMark* dmark = new DeoptResourceMark(thread);
 170   assert(thread-&gt;deopt_mark() == NULL, &quot;Pending deopt!&quot;);
 171   thread-&gt;set_deopt_mark(dmark);
 172 
 173   frame stub_frame = thread-&gt;last_frame(); // Makes stack walkable as side effect
 174   RegisterMap map(thread, true);
 175   RegisterMap dummy_map(thread, false);
 176   // Now get the deoptee with a valid map
 177   frame deoptee = stub_frame.sender(&amp;map);
 178   // Set the deoptee nmethod
</pre>
<hr />
<pre>
 183   if (VerifyStack) {
 184     thread-&gt;validate_frame_layout();
 185   }
 186 
 187   // Create a growable array of VFrames where each VFrame represents an inlined
 188   // Java frame.  This storage is allocated with the usual system arena.
 189   assert(deoptee.is_compiled_frame(), &quot;Wrong frame type&quot;);
 190   GrowableArray&lt;compiledVFrame*&gt;* chunk = new GrowableArray&lt;compiledVFrame*&gt;(10);
 191   vframe* vf = vframe::new_vframe(&amp;deoptee, &amp;map, thread);
 192   while (!vf-&gt;is_top()) {
 193     assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
 194     chunk-&gt;push(compiledVFrame::cast(vf));
 195     vf = vf-&gt;sender();
 196   }
 197   assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
 198   chunk-&gt;push(compiledVFrame::cast(vf));
 199 
 200   bool realloc_failures = false;
 201 
 202 #if COMPILER2_OR_JVMCI






 203   // Reallocate the non-escaping objects and restore their fields. Then
 204   // relock objects if synchronization on them was eliminated.
<span class="line-modified"> 205 #if !INCLUDE_JVMCI</span>
<span class="line-modified"> 206   if (DoEscapeAnalysis || EliminateNestedLocks) {</span>
<span class="line-modified"> 207     if (EliminateAllocations) {</span>
<span class="line-modified"> 208 #endif // INCLUDE_JVMCI</span>
<span class="line-modified"> 209       assert (chunk-&gt;at(0)-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);</span>
<span class="line-modified"> 210       GrowableArray&lt;ScopeValue*&gt;* objects = chunk-&gt;at(0)-&gt;scope()-&gt;objects();</span>
<span class="line-modified"> 211 </span>
<span class="line-modified"> 212       // The flag return_oop() indicates call sites which return oop</span>
<span class="line-modified"> 213       // in compiled code. Such sites include java method calls,</span>
<span class="line-modified"> 214       // runtime calls (for example, used to allocate new objects/arrays</span>
<span class="line-modified"> 215       // on slow code path) and any other calls generated in compiled code.</span>
<span class="line-modified"> 216       // It is not guaranteed that we can get such information here only</span>
<span class="line-modified"> 217       // by analyzing bytecode in deoptimized frames. This is why this flag</span>
<span class="line-modified"> 218       // is set during method compilation (see Compile::Process_OopMap_Node()).</span>
<span class="line-modified"> 219       // If the previous frame was popped or if we are dispatching an exception,</span>
<span class="line-modified"> 220       // we don&#39;t have an oop result.</span>
<span class="line-modified"> 221       bool save_oop_result = chunk-&gt;at(0)-&gt;scope()-&gt;return_oop() &amp;&amp; !thread-&gt;popframe_forcing_deopt_reexecution() &amp;&amp; (exec_mode == Unpack_deopt);</span>
<span class="line-modified"> 222       Handle return_value;</span>
<span class="line-removed"> 223       if (save_oop_result) {</span>
<span class="line-removed"> 224         // Reallocation may trigger GC. If deoptimization happened on return from</span>
<span class="line-removed"> 225         // call which returns oop we need to save it since it is not in oopmap.</span>
<span class="line-removed"> 226         oop result = deoptee.saved_oop_result(&amp;map);</span>
<span class="line-removed"> 227         assert(oopDesc::is_oop_or_null(result), &quot;must be oop&quot;);</span>
<span class="line-removed"> 228         return_value = Handle(thread, result);</span>
<span class="line-removed"> 229         assert(Universe::heap()-&gt;is_in_or_null(result), &quot;must be heap pointer&quot;);</span>
<span class="line-removed"> 230         if (TraceDeoptimization) {</span>
<span class="line-removed"> 231           ttyLocker ttyl;</span>
<span class="line-removed"> 232           tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));</span>
<span class="line-removed"> 233         }</span>
<span class="line-removed"> 234       }</span>
<span class="line-removed"> 235       if (objects != NULL) {</span>
<span class="line-removed"> 236         JRT_BLOCK</span>
<span class="line-removed"> 237           realloc_failures = realloc_objects(thread, &amp;deoptee, objects, THREAD);</span>
<span class="line-removed"> 238         JRT_END</span>
<span class="line-removed"> 239         bool skip_internal = (cm != NULL) &amp;&amp; !cm-&gt;is_compiled_by_jvmci();</span>
<span class="line-removed"> 240         reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal);</span>
<span class="line-removed"> 241 #ifndef PRODUCT</span>
<span class="line-removed"> 242         if (TraceDeoptimization) {</span>
<span class="line-removed"> 243           ttyLocker ttyl;</span>
<span class="line-removed"> 244           tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));</span>
<span class="line-removed"> 245           print_objects(objects, realloc_failures);</span>
<span class="line-removed"> 246         }</span>
<span class="line-removed"> 247 #endif</span>
<span class="line-removed"> 248       }</span>
<span class="line-removed"> 249       if (save_oop_result) {</span>
<span class="line-removed"> 250         // Restore result.</span>
<span class="line-removed"> 251         deoptee.set_saved_oop_result(&amp;map, return_value());</span>
<span class="line-removed"> 252       }</span>
<span class="line-removed"> 253 #if !INCLUDE_JVMCI</span>
<span class="line-removed"> 254     }</span>
<span class="line-removed"> 255     if (EliminateLocks) {</span>
<span class="line-removed"> 256 #endif // INCLUDE_JVMCI</span>
<span class="line-removed"> 257 #ifndef PRODUCT</span>
<span class="line-removed"> 258       bool first = true;</span>
<span class="line-removed"> 259 #endif</span>
<span class="line-removed"> 260       for (int i = 0; i &lt; chunk-&gt;length(); i++) {</span>
<span class="line-removed"> 261         compiledVFrame* cvf = chunk-&gt;at(i);</span>
<span class="line-removed"> 262         assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);</span>
<span class="line-removed"> 263         GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();</span>
<span class="line-removed"> 264         if (monitors-&gt;is_nonempty()) {</span>
<span class="line-removed"> 265           relock_objects(monitors, thread, realloc_failures);</span>
<span class="line-removed"> 266 #ifndef PRODUCT</span>
<span class="line-removed"> 267           if (PrintDeoptimizationDetails) {</span>
<span class="line-removed"> 268             ttyLocker ttyl;</span>
<span class="line-removed"> 269             for (int j = 0; j &lt; monitors-&gt;length(); j++) {</span>
<span class="line-removed"> 270               MonitorInfo* mi = monitors-&gt;at(j);</span>
<span class="line-removed"> 271               if (mi-&gt;eliminated()) {</span>
<span class="line-removed"> 272                 if (first) {</span>
<span class="line-removed"> 273                   first = false;</span>
<span class="line-removed"> 274                   tty-&gt;print_cr(&quot;RELOCK OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));</span>
<span class="line-removed"> 275                 }</span>
<span class="line-removed"> 276                 if (mi-&gt;owner_is_scalar_replaced()) {</span>
<span class="line-removed"> 277                   Klass* k = java_lang_Class::as_Klass(mi-&gt;owner_klass());</span>
<span class="line-removed"> 278                   tty-&gt;print_cr(&quot;     failed reallocation for klass %s&quot;, k-&gt;external_name());</span>
<span class="line-removed"> 279                 } else {</span>
<span class="line-removed"> 280                   tty-&gt;print_cr(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; locked&quot;, p2i(mi-&gt;owner()));</span>
<span class="line-removed"> 281                 }</span>
<span class="line-removed"> 282               }</span>
<span class="line-removed"> 283             }</span>
<span class="line-removed"> 284           }</span>
<span class="line-removed"> 285 #endif // !PRODUCT</span>
<span class="line-removed"> 286         }</span>
<span class="line-removed"> 287       }</span>
<span class="line-removed"> 288 #if !INCLUDE_JVMCI</span>
<span class="line-removed"> 289     }</span>
 290   }
<span class="line-removed"> 291 #endif // INCLUDE_JVMCI</span>
 292 #endif // COMPILER2_OR_JVMCI
 293 
 294   ScopeDesc* trap_scope = chunk-&gt;at(0)-&gt;scope();
 295   Handle exceptionObject;
 296   if (trap_scope-&gt;rethrow_exception()) {
 297     if (PrintDeoptimizationDetails) {
 298       tty-&gt;print_cr(&quot;Exception to be rethrown in the interpreter for method %s::%s at bci %d&quot;, trap_scope-&gt;method()-&gt;method_holder()-&gt;name()-&gt;as_C_string(), trap_scope-&gt;method()-&gt;name()-&gt;as_C_string(), trap_scope-&gt;bci());
 299     }
 300     GrowableArray&lt;ScopeValue*&gt;* expressions = trap_scope-&gt;expressions();
 301     guarantee(expressions != NULL &amp;&amp; expressions-&gt;length() &gt; 0, &quot;must have exception to throw&quot;);
 302     ScopeValue* topOfStack = expressions-&gt;top();
 303     exceptionObject = StackValue::create_stack_value(&amp;deoptee, &amp;map, topOfStack)-&gt;get_obj();
 304     guarantee(exceptionObject() != NULL, &quot;exception oop can not be null&quot;);
 305   }
 306 
<span class="line-removed"> 307   // Ensure that no safepoint is taken after pointers have been stored</span>
<span class="line-removed"> 308   // in fields of rematerialized objects.  If a safepoint occurs from here on</span>
<span class="line-removed"> 309   // out the java state residing in the vframeArray will be missed.</span>
<span class="line-removed"> 310   NoSafepointVerifier no_safepoint;</span>
<span class="line-removed"> 311 </span>
 312   vframeArray* array = create_vframeArray(thread, deoptee, &amp;map, chunk, realloc_failures);
 313 #if COMPILER2_OR_JVMCI
 314   if (realloc_failures) {
 315     pop_frames_failed_reallocs(thread, array);
 316   }
 317 #endif
 318 
 319   assert(thread-&gt;vframe_array_head() == NULL, &quot;Pending deopt!&quot;);
 320   thread-&gt;set_vframe_array_head(array);
 321 
 322   // Now that the vframeArray has been created if we have any deferred local writes
 323   // added by jvmti then we can free up that structure as the data is now in the
 324   // vframeArray
 325 
 326   if (thread-&gt;deferred_locals() != NULL) {
 327     GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt;* list = thread-&gt;deferred_locals();
 328     int i = 0;
 329     do {
 330       // Because of inlining we could have multiple vframes for a single frame
 331       // and several of the vframes could have deferred writes. Find them all.
</pre>
<hr />
<pre>
 391   // PopFrame requires that the preserved incoming arguments from the recently-popped topmost
 392   // activation be put back on the expression stack of the caller for reexecution
 393   if (JvmtiExport::can_pop_frame() &amp;&amp; thread-&gt;popframe_forcing_deopt_reexecution()) {
 394     popframe_extra_args = in_words(thread-&gt;popframe_preserved_args_size_in_words());
 395   }
 396 
 397   // Find the current pc for sender of the deoptee. Since the sender may have been deoptimized
 398   // itself since the deoptee vframeArray was created we must get a fresh value of the pc rather
 399   // than simply use array-&gt;sender.pc(). This requires us to walk the current set of frames
 400   //
 401   frame deopt_sender = stub_frame.sender(&amp;dummy_map); // First is the deoptee frame
 402   deopt_sender = deopt_sender.sender(&amp;dummy_map);     // Now deoptee caller
 403 
 404   // It&#39;s possible that the number of parameters at the call site is
 405   // different than number of arguments in the callee when method
 406   // handles are used.  If the caller is interpreted get the real
 407   // value so that the proper amount of space can be added to it&#39;s
 408   // frame.
 409   bool caller_was_method_handle = false;
 410   if (deopt_sender.is_interpreted_frame()) {
<span class="line-modified"> 411     methodHandle method = deopt_sender.interpreter_frame_method();</span>
 412     Bytecode_invoke cur = Bytecode_invoke_check(method, deopt_sender.interpreter_frame_bci());
 413     if (cur.is_invokedynamic() || cur.is_invokehandle()) {
 414       // Method handle invokes may involve fairly arbitrary chains of
 415       // calls so it&#39;s impossible to know how much actual space the
 416       // caller has for locals.
 417       caller_was_method_handle = true;
 418     }
 419   }
 420 
 421   //
 422   // frame_sizes/frame_pcs[0] oldest frame (int or c2i)
 423   // frame_sizes/frame_pcs[1] next oldest frame (int)
 424   // frame_sizes/frame_pcs[n] youngest frame (int)
 425   //
 426   // Now a pc in frame_pcs is actually the return address to the frame&#39;s caller (a frame
 427   // owns the space for the return address to it&#39;s caller).  Confusing ain&#39;t it.
 428   //
 429   // The vframe array can address vframes with indices running from
 430   // 0.._frames-1. Index  0 is the youngest frame and _frame - 1 is the oldest (root) frame.
 431   // When we create the skeletal frames we need the oldest frame to be in the zero slot
</pre>
<hr />
<pre>
 614 
 615   // It is actually ok to allocate handles in a leaf method. It causes no safepoints,
 616   // but makes the entry a little slower. There is however a little dance we have to
 617   // do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro
 618   ResetNoHandleMark rnhm; // No-op in release/product versions
 619   HandleMark hm;
 620 
 621   frame stub_frame = thread-&gt;last_frame();
 622 
 623   // Since the frame to unpack is the top frame of this thread, the vframe_array_head
 624   // must point to the vframeArray for the unpack frame.
 625   vframeArray* array = thread-&gt;vframe_array_head();
 626 
 627 #ifndef PRODUCT
 628   if (TraceDeoptimization) {
 629     ttyLocker ttyl;
 630     tty-&gt;print_cr(&quot;DEOPT UNPACKING thread &quot; INTPTR_FORMAT &quot; vframeArray &quot; INTPTR_FORMAT &quot; mode %d&quot;,
 631                   p2i(thread), p2i(array), exec_mode);
 632   }
 633 #endif
<span class="line-modified"> 634   Events::log(thread, &quot;DEOPT UNPACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT &quot; mode %d&quot;,</span>
 635               p2i(stub_frame.pc()), p2i(stub_frame.sp()), exec_mode);
 636 
 637   UnrollBlock* info = array-&gt;unroll_block();
 638 
 639   // Unpack the interpreter frames and any adapter frame (c2 only) we might create.
 640   array-&gt;unpack_to_stack(stub_frame, exec_mode, info-&gt;caller_actual_parameters());
 641 
 642   BasicType bt = info-&gt;return_type();
 643 
 644   // If we have an exception pending, claim that the return type is an oop
 645   // so the deopt_blob does not overwrite the exception_oop.
 646 
 647   if (exec_mode == Unpack_exception)
 648     bt = T_OBJECT;
 649 
 650   // Cleanup thread deopt data
 651   cleanup_deopt_info(thread, array);
 652 
 653 #ifndef PRODUCT
 654   if (VerifyStack) {
</pre>
<hr />
<pre>
 662     // notions of expression stack and locals
 663     vframeArray* cur_array = thread-&gt;vframe_array_last();
 664     RegisterMap rm(thread, false);
 665     rm.set_include_argument_oops(false);
 666     bool is_top_frame = true;
 667     int callee_size_of_parameters = 0;
 668     int callee_max_locals = 0;
 669     for (int i = 0; i &lt; cur_array-&gt;frames(); i++) {
 670       vframeArrayElement* el = cur_array-&gt;element(i);
 671       frame* iframe = el-&gt;iframe();
 672       guarantee(iframe-&gt;is_interpreted_frame(), &quot;Wrong frame type&quot;);
 673 
 674       // Get the oop map for this bci
 675       InterpreterOopMap mask;
 676       int cur_invoke_parameter_size = 0;
 677       bool try_next_mask = false;
 678       int next_mask_expression_stack_size = -1;
 679       int top_frame_expression_stack_adjustment = 0;
 680       methodHandle mh(thread, iframe-&gt;interpreter_frame_method());
 681       OopMapCache::compute_one_oop_map(mh, iframe-&gt;interpreter_frame_bci(), &amp;mask);
<span class="line-modified"> 682       BytecodeStream str(mh);</span>
<span class="line-removed"> 683       str.set_start(iframe-&gt;interpreter_frame_bci());</span>
 684       int max_bci = mh-&gt;code_size();
 685       // Get to the next bytecode if possible
 686       assert(str.bci() &lt; max_bci, &quot;bci in interpreter frame out of bounds&quot;);
 687       // Check to see if we can grab the number of outgoing arguments
 688       // at an uncommon trap for an invoke (where the compiler
 689       // generates debug info before the invoke has executed)
 690       Bytecodes::Code cur_code = str.next();
 691       if (Bytecodes::is_invoke(cur_code)) {
 692         Bytecode_invoke invoke(mh, iframe-&gt;interpreter_frame_bci());
 693         cur_invoke_parameter_size = invoke.size_of_parameters();
 694         if (i != 0 &amp;&amp; !invoke.is_invokedynamic() &amp;&amp; MethodHandles::has_member_arg(invoke.klass(), invoke.name())) {
 695           callee_size_of_parameters++;
 696         }
 697       }
 698       if (str.bci() &lt; max_bci) {
 699         Bytecodes::Code next_code = str.next();
 700         if (next_code &gt;= 0) {
 701           // The interpreter oop map generator reports results before
 702           // the current bytecode has executed except in the case of
 703           // calls. It seems to be hard to tell whether the compiler
</pre>
<hr />
<pre>
 762             vframeArrayElement* el = cur_array-&gt;element(k);
 763             tty-&gt;print_cr(&quot;    %s (bci %d)&quot;, el-&gt;method()-&gt;name_and_sig_as_C_string(), el-&gt;bci());
 764           }
 765           cur_array-&gt;print_on_2(tty);
 766         } // release tty lock before calling guarantee
 767         guarantee(false, &quot;wrong number of expression stack elements during deopt&quot;);
 768       }
 769       VerifyOopClosure verify;
 770       iframe-&gt;oops_interpreted_do(&amp;verify, &amp;rm, false);
 771       callee_size_of_parameters = mh-&gt;size_of_parameters();
 772       callee_max_locals = mh-&gt;max_locals();
 773       is_top_frame = false;
 774     }
 775   }
 776 #endif /* !PRODUCT */
 777 
 778 
 779   return bt;
 780 JRT_END
 781 





















 782 
<span class="line-modified"> 783 int Deoptimization::deoptimize_dependents() {</span>
<span class="line-modified"> 784   Threads::deoptimized_wrt_marked_nmethods();</span>
<span class="line-modified"> 785   return 0;</span>



 786 }
 787 
 788 Deoptimization::DeoptAction Deoptimization::_unloaded_action
 789   = Deoptimization::Action_reinterpret;
 790 





































































































































 791 #if COMPILER2_OR_JVMCI
<span class="line-modified"> 792 bool Deoptimization::realloc_objects(JavaThread* thread, frame* fr, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {</span>
 793   Handle pending_exception(THREAD, thread-&gt;pending_exception());
 794   const char* exception_file = thread-&gt;exception_file();
 795   int exception_line = thread-&gt;exception_line();
 796   thread-&gt;clear_pending_exception();
 797 
 798   bool failures = false;
 799 
 800   for (int i = 0; i &lt; objects-&gt;length(); i++) {
 801     assert(objects-&gt;at(i)-&gt;is_object(), &quot;invalid debug information&quot;);
 802     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
 803 
 804     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
 805     oop obj = NULL;
 806 
 807     if (k-&gt;is_instance_klass()) {











 808       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified"> 809       obj = ik-&gt;allocate_instance(THREAD);</span>


 810     } else if (k-&gt;is_typeArray_klass()) {
 811       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
 812       assert(sv-&gt;field_size() % type2size[ak-&gt;element_type()] == 0, &quot;non-integral array length&quot;);
 813       int len = sv-&gt;field_size() / type2size[ak-&gt;element_type()];
 814       obj = ak-&gt;allocate(len, THREAD);
 815     } else if (k-&gt;is_objArray_klass()) {
 816       ObjArrayKlass* ak = ObjArrayKlass::cast(k);
 817       obj = ak-&gt;allocate(sv-&gt;field_size(), THREAD);
 818     }
 819 
 820     if (obj == NULL) {
 821       failures = true;
 822     }
 823 
 824     assert(sv-&gt;value().is_null(), &quot;redundant reallocation&quot;);
 825     assert(obj != NULL || HAS_PENDING_EXCEPTION, &quot;allocation should succeed or we should get an exception&quot;);
 826     CLEAR_PENDING_EXCEPTION;
 827     sv-&gt;set_value(obj);
 828   }
 829 
</pre>
<hr />
<pre>
 943 }
 944 
 945 class ReassignedField {
 946 public:
 947   int _offset;
 948   BasicType _type;
 949 public:
 950   ReassignedField() {
 951     _offset = 0;
 952     _type = T_ILLEGAL;
 953   }
 954 };
 955 
 956 int compare(ReassignedField* left, ReassignedField* right) {
 957   return left-&gt;_offset - right-&gt;_offset;
 958 }
 959 
 960 // Restore fields of an eliminated instance object using the same field order
 961 // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
 962 static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal) {
<span class="line-removed"> 963   if (klass-&gt;superklass() != NULL) {</span>
<span class="line-removed"> 964     svIndex = reassign_fields_by_klass(klass-&gt;superklass(), fr, reg_map, sv, svIndex, obj, skip_internal);</span>
<span class="line-removed"> 965   }</span>
<span class="line-removed"> 966 </span>
 967   GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
<span class="line-modified"> 968   for (AllFieldStream fs(klass); !fs.done(); fs.next()) {</span>
<span class="line-modified"> 969     if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {</span>
<span class="line-modified"> 970       ReassignedField field;</span>
<span class="line-modified"> 971       field._offset = fs.offset();</span>
<span class="line-modified"> 972       field._type = FieldType::basic_type(fs.signature());</span>
<span class="line-modified"> 973       fields-&gt;append(field);</span>



 974     }

 975   }
 976   fields-&gt;sort(compare);
 977   for (int i = 0; i &lt; fields-&gt;length(); i++) {
 978     intptr_t val;
 979     ScopeValue* scope_field = sv-&gt;field_at(svIndex);
 980     StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);
 981     int offset = fields-&gt;at(i)._offset;
 982     BasicType type = fields-&gt;at(i)._type;
 983     switch (type) {
 984       case T_OBJECT: case T_ARRAY:
 985         assert(value-&gt;type() == T_OBJECT, &quot;Agreement.&quot;);
 986         obj-&gt;obj_field_put(offset, value-&gt;get_obj()());
 987         break;
 988 
 989       // Have to cast to INT (32 bits) pointer to avoid little/big-endian problem.
 990       case T_INT: case T_FLOAT: { // 4 bytes.
 991         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
 992         bool big_value = false;
 993         if (i+1 &lt; fields-&gt;length() &amp;&amp; fields-&gt;at(i+1)._type == T_INT) {
 994           if (scope_field-&gt;is_location()) {
</pre>
<hr />
<pre>
1062         ShouldNotReachHere();
1063     }
1064     svIndex++;
1065   }
1066   return svIndex;
1067 }
1068 
1069 // restore fields of all eliminated objects and arrays
1070 void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal) {
1071   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1072     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1073     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1074     Handle obj = sv-&gt;value();
1075     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1076     if (PrintDeoptimizationDetails) {
1077       tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
1078     }
1079     if (obj.is_null()) {
1080       continue;
1081     }
<span class="line-modified">1082 </span>





1083     if (k-&gt;is_instance_klass()) {
1084       InstanceKlass* ik = InstanceKlass::cast(k);
1085       reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);
1086     } else if (k-&gt;is_typeArray_klass()) {
1087       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1088       reassign_type_array_elements(fr, reg_map, sv, (typeArrayOop) obj(), ak-&gt;element_type());
1089     } else if (k-&gt;is_objArray_klass()) {
1090       reassign_object_array_elements(fr, reg_map, sv, (objArrayOop) obj());
1091     }
1092   }
1093 }
1094 
1095 
1096 // relock objects for which synchronization was eliminated
1097 void Deoptimization::relock_objects(GrowableArray&lt;MonitorInfo*&gt;* monitors, JavaThread* thread, bool realloc_failures) {
1098   for (int i = 0; i &lt; monitors-&gt;length(); i++) {
1099     MonitorInfo* mon_info = monitors-&gt;at(i);
1100     if (mon_info-&gt;eliminated()) {
1101       assert(!mon_info-&gt;owner_is_scalar_replaced() || realloc_failures, &quot;reallocation was missed&quot;);
1102       if (!mon_info-&gt;owner_is_scalar_replaced()) {
1103         Handle obj(thread, mon_info-&gt;owner());
<span class="line-modified">1104         markOop mark = obj-&gt;mark();</span>
<span class="line-modified">1105         if (UseBiasedLocking &amp;&amp; mark-&gt;has_bias_pattern()) {</span>
1106           // New allocated objects may have the mark set to anonymously biased.
1107           // Also the deoptimized method may called methods with synchronization
1108           // where the thread-local object is bias locked to the current thread.
<span class="line-modified">1109           assert(mark-&gt;is_biased_anonymously() ||</span>
<span class="line-modified">1110                  mark-&gt;biased_locker() == thread, &quot;should be locked to current thread&quot;);</span>
1111           // Reset mark word to unbiased prototype.
<span class="line-modified">1112           markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span>
1113           obj-&gt;set_mark(unbiased_prototype);
1114         }
1115         BasicLock* lock = mon_info-&gt;lock();
<span class="line-modified">1116         ObjectSynchronizer::slow_enter(obj, lock, thread);</span>
1117         assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
1118       }
1119     }
1120   }
1121 }
1122 
1123 
1124 #ifndef PRODUCT
1125 // print information about reallocated objects
1126 void Deoptimization::print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures) {
1127   fieldDescriptor fd;
1128 
1129   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1130     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1131     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1132     Handle obj = sv-&gt;value();
1133 
1134     tty-&gt;print(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; of type &quot;, p2i(sv-&gt;value()()));
1135     k-&gt;print_value();
1136     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1137     if (obj.is_null()) {
1138       tty-&gt;print(&quot; allocation failed&quot;);
1139     } else {
1140       tty-&gt;print(&quot; allocated (%d bytes)&quot;, obj-&gt;size() * HeapWordSize);
1141     }
1142     tty-&gt;cr();
1143 
1144     if (Verbose &amp;&amp; !obj.is_null()) {
1145       k-&gt;oop_print_on(obj(), tty);
1146     }
1147   }
1148 }
1149 #endif
1150 #endif // COMPILER2_OR_JVMCI
1151 
1152 vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
<span class="line-modified">1153   Events::log(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));</span>
1154 
1155 #ifndef PRODUCT
1156   if (PrintDeoptimizationDetails) {
1157     ttyLocker ttyl;
1158     tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
1159     fr.print_on(tty);
1160     tty-&gt;print_cr(&quot;     Virtual frames (innermost first):&quot;);
1161     for (int index = 0; index &lt; chunk-&gt;length(); index++) {
1162       compiledVFrame* vf = chunk-&gt;at(index);
1163       tty-&gt;print(&quot;       %2d - &quot;, index);
1164       vf-&gt;print_value();
1165       int bci = chunk-&gt;at(index)-&gt;raw_bci();
1166       const char* code_name;
1167       if (bci == SynchronizationEntryBCI) {
1168         code_name = &quot;sync entry&quot;;
1169       } else {
1170         Bytecodes::Code code = vf-&gt;method()-&gt;code_at(bci);
1171         code_name = Bytecodes::name(code);
1172       }
1173       tty-&gt;print(&quot; - %s&quot;, code_name);
</pre>
<hr />
<pre>
1206 
1207   return array;
1208 }
1209 
1210 #if COMPILER2_OR_JVMCI
1211 void Deoptimization::pop_frames_failed_reallocs(JavaThread* thread, vframeArray* array) {
1212   // Reallocation of some scalar replaced objects failed. Record
1213   // that we need to pop all the interpreter frames for the
1214   // deoptimized compiled frame.
1215   assert(thread-&gt;frames_to_pop_failed_realloc() == 0, &quot;missed frames to pop?&quot;);
1216   thread-&gt;set_frames_to_pop_failed_realloc(array-&gt;frames());
1217   // Unlock all monitors here otherwise the interpreter will see a
1218   // mix of locked and unlocked monitors (because of failed
1219   // reallocations of synchronized objects) and be confused.
1220   for (int i = 0; i &lt; array-&gt;frames(); i++) {
1221     MonitorChunk* monitors = array-&gt;element(i)-&gt;monitors();
1222     if (monitors != NULL) {
1223       for (int j = 0; j &lt; monitors-&gt;number_of_monitors(); j++) {
1224         BasicObjectLock* src = monitors-&gt;at(j);
1225         if (src-&gt;obj() != NULL) {
<span class="line-modified">1226           ObjectSynchronizer::fast_exit(src-&gt;obj(), src-&gt;lock(), thread);</span>
1227         }
1228       }
1229       array-&gt;element(i)-&gt;free_monitors(thread);
1230 #ifdef ASSERT
1231       array-&gt;element(i)-&gt;set_removed_monitors();
1232 #endif
1233     }
1234   }
1235 }
1236 #endif
1237 
1238 static void collect_monitors(compiledVFrame* cvf, GrowableArray&lt;Handle&gt;* objects_to_revoke) {
1239   GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
1240   Thread* thread = Thread::current();
1241   for (int i = 0; i &lt; monitors-&gt;length(); i++) {
1242     MonitorInfo* mon_info = monitors-&gt;at(i);
1243     if (!mon_info-&gt;eliminated() &amp;&amp; mon_info-&gt;owner() != NULL) {
1244       objects_to_revoke-&gt;append(Handle(thread, mon_info-&gt;owner()));
1245     }
1246   }
1247 }
1248 
<span class="line-modified">1249 </span>
<span class="line-removed">1250 void Deoptimization::revoke_biases_of_monitors(JavaThread* thread, frame fr, RegisterMap* map) {</span>
<span class="line-removed">1251   if (!UseBiasedLocking) {</span>
<span class="line-removed">1252     return;</span>
<span class="line-removed">1253   }</span>
<span class="line-removed">1254 </span>
<span class="line-removed">1255   GrowableArray&lt;Handle&gt;* objects_to_revoke = new GrowableArray&lt;Handle&gt;();</span>
<span class="line-removed">1256 </span>
1257   // Unfortunately we don&#39;t have a RegisterMap available in most of
1258   // the places we want to call this routine so we need to walk the
1259   // stack again to update the register map.
1260   if (map == NULL || !map-&gt;update_map()) {
1261     StackFrameStream sfs(thread, true);
1262     bool found = false;
1263     while (!found &amp;&amp; !sfs.is_done()) {
1264       frame* cur = sfs.current();
1265       sfs.next();
1266       found = cur-&gt;id() == fr.id();
1267     }
1268     assert(found, &quot;frame to be deoptimized not found on target thread&#39;s stack&quot;);
1269     map = sfs.register_map();
1270   }
1271 
1272   vframe* vf = vframe::new_vframe(&amp;fr, map, thread);
1273   compiledVFrame* cvf = compiledVFrame::cast(vf);
1274   // Revoke monitors&#39; biases in all scopes
1275   while (!cvf-&gt;is_top()) {
1276     collect_monitors(cvf, objects_to_revoke);
1277     cvf = compiledVFrame::cast(cvf-&gt;sender());
1278   }
1279   collect_monitors(cvf, objects_to_revoke);

1280 
<span class="line-modified">1281   if (SafepointSynchronize::is_at_safepoint()) {</span>
<span class="line-modified">1282     BiasedLocking::revoke_at_safepoint(objects_to_revoke);</span>
<span class="line-modified">1283   } else {</span>
<span class="line-modified">1284     BiasedLocking::revoke(objects_to_revoke);</span>








1285   }
1286 }
1287 
1288 
1289 void Deoptimization::deoptimize_single_frame(JavaThread* thread, frame fr, Deoptimization::DeoptReason reason) {
1290   assert(fr.can_be_deoptimized(), &quot;checking frame type&quot;);
1291 
1292   gather_statistics(reason, Action_none, Bytecodes::_illegal);
1293 
1294   if (LogCompilation &amp;&amp; xtty != NULL) {
1295     CompiledMethod* cm = fr.cb()-&gt;as_compiled_method_or_null();
1296     assert(cm != NULL, &quot;only compiled methods can deopt&quot;);
1297 
1298     ttyLocker ttyl;
1299     xtty-&gt;begin_head(&quot;deoptimized thread=&#39;&quot; UINTX_FORMAT &quot;&#39; reason=&#39;%s&#39; pc=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;,(uintx)thread-&gt;osthread()-&gt;thread_id(), trap_reason_name(reason), p2i(fr.pc()));
1300     cm-&gt;log_identity(xtty);
1301     xtty-&gt;end_head();
1302     for (ScopeDesc* sd = cm-&gt;scope_desc_at(fr.pc()); ; sd = sd-&gt;sender()) {
1303       xtty-&gt;begin_elem(&quot;jvms bci=&#39;%d&#39;&quot;, sd-&gt;bci());
1304       xtty-&gt;method(sd-&gt;method());
1305       xtty-&gt;end_elem();
1306       if (sd-&gt;is_top())  break;
1307     }
1308     xtty-&gt;tail(&quot;deoptimized&quot;);
1309   }
1310 
1311   // Patch the compiled method so that when execution returns to it we will
1312   // deopt the execution state and return to the interpreter.
1313   fr.deoptimize(thread);
1314 }
1315 
<span class="line-modified">1316 void Deoptimization::deoptimize(JavaThread* thread, frame fr, RegisterMap *map) {</span>
<span class="line-removed">1317   deoptimize(thread, fr, map, Reason_constraint);</span>
<span class="line-removed">1318 }</span>
<span class="line-removed">1319 </span>
<span class="line-removed">1320 void Deoptimization::deoptimize(JavaThread* thread, frame fr, RegisterMap *map, DeoptReason reason) {</span>
1321   // Deoptimize only if the frame comes from compile code.
1322   // Do not deoptimize the frame which is already patched
1323   // during the execution of the loops below.
1324   if (!fr.is_compiled_frame() || fr.is_deoptimized_frame()) {
1325     return;
1326   }
1327   ResourceMark rm;
1328   DeoptimizationMarker dm;
<span class="line-removed">1329   if (UseBiasedLocking) {</span>
<span class="line-removed">1330     revoke_biases_of_monitors(thread, fr, map);</span>
<span class="line-removed">1331   }</span>
1332   deoptimize_single_frame(thread, fr, reason);
<span class="line-removed">1333 </span>
1334 }
1335 
1336 #if INCLUDE_JVMCI
1337 address Deoptimization::deoptimize_for_missing_exception_handler(CompiledMethod* cm) {
1338   // there is no exception handler for this pc =&gt; deoptimize
1339   cm-&gt;make_not_entrant();
1340 
1341   // Use Deoptimization::deoptimize for all of its side-effects:
<span class="line-modified">1342   // revoking biases of monitors, gathering traps statistics, logging...</span>
1343   // it also patches the return pc but we do not care about that
1344   // since we return a continuation to the deopt_blob below.
1345   JavaThread* thread = JavaThread::current();
<span class="line-modified">1346   RegisterMap reg_map(thread, UseBiasedLocking);</span>
1347   frame runtime_frame = thread-&gt;last_frame();
1348   frame caller_frame = runtime_frame.sender(&amp;reg_map);
1349   assert(caller_frame.cb()-&gt;as_compiled_method_or_null() == cm, &quot;expect top frame compiled method&quot;);
<span class="line-modified">1350   Deoptimization::deoptimize(thread, caller_frame, &amp;reg_map, Deoptimization::Reason_not_compiled_exception_handler);</span>
1351 
<span class="line-modified">1352   MethodData* trap_mdo = get_method_data(thread, cm-&gt;method(), true);</span>
1353   if (trap_mdo != NULL) {
1354     trap_mdo-&gt;inc_trap_count(Deoptimization::Reason_not_compiled_exception_handler);
1355   }
1356 
1357   return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
1358 }
1359 #endif
1360 
1361 void Deoptimization::deoptimize_frame_internal(JavaThread* thread, intptr_t* id, DeoptReason reason) {
1362   assert(thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),
1363          &quot;can only deoptimize other thread at a safepoint&quot;);
1364   // Compute frame and register map based on thread and sp.
<span class="line-modified">1365   RegisterMap reg_map(thread, UseBiasedLocking);</span>
1366   frame fr = thread-&gt;last_frame();
1367   while (fr.id() != id) {
1368     fr = fr.sender(&amp;reg_map);
1369   }
<span class="line-modified">1370   deoptimize(thread, fr, &amp;reg_map, reason);</span>
1371 }
1372 
1373 
1374 void Deoptimization::deoptimize_frame(JavaThread* thread, intptr_t* id, DeoptReason reason) {
1375   if (thread == Thread::current()) {
1376     Deoptimization::deoptimize_frame_internal(thread, id, reason);
1377   } else {
1378     VM_DeoptimizeFrame deopt(thread, id, reason);
1379     VMThread::execute(&amp;deopt);
1380   }
1381 }
1382 
1383 void Deoptimization::deoptimize_frame(JavaThread* thread, intptr_t* id) {
1384   deoptimize_frame(thread, id, Reason_constraint);
1385 }
1386 
1387 // JVMTI PopFrame support
1388 JRT_LEAF(void, Deoptimization::popframe_preserve_args(JavaThread* thread, int bytes_to_save, void* start_address))
1389 {
1390   thread-&gt;popframe_preserve_args(in_ByteSize(bytes_to_save), start_address);
</pre>
<hr />
<pre>
1394 MethodData*
1395 Deoptimization::get_method_data(JavaThread* thread, const methodHandle&amp; m,
1396                                 bool create_if_missing) {
1397   Thread* THREAD = thread;
1398   MethodData* mdo = m()-&gt;method_data();
1399   if (mdo == NULL &amp;&amp; create_if_missing &amp;&amp; !HAS_PENDING_EXCEPTION) {
1400     // Build an MDO.  Ignore errors like OutOfMemory;
1401     // that simply means we won&#39;t have an MDO to update.
1402     Method::build_interpreter_method_data(m, THREAD);
1403     if (HAS_PENDING_EXCEPTION) {
1404       assert((PENDING_EXCEPTION-&gt;is_a(SystemDictionary::OutOfMemoryError_klass())), &quot;we expect only an OOM error here&quot;);
1405       CLEAR_PENDING_EXCEPTION;
1406     }
1407     mdo = m()-&gt;method_data();
1408   }
1409   return mdo;
1410 }
1411 
1412 #if COMPILER2_OR_JVMCI
1413 void Deoptimization::load_class_by_index(const constantPoolHandle&amp; constant_pool, int index, TRAPS) {
<span class="line-modified">1414   // in case of an unresolved klass entry, load the class.</span>






1415   if (constant_pool-&gt;tag_at(index).is_unresolved_klass()) {
1416     Klass* tk = constant_pool-&gt;klass_at_ignore_error(index, CHECK);
1417     return;
1418   }
1419 
<span class="line-modified">1420   if (!constant_pool-&gt;tag_at(index).is_symbol()) return;</span>
<span class="line-modified">1421 </span>
<span class="line-removed">1422   Handle class_loader (THREAD, constant_pool-&gt;pool_holder()-&gt;class_loader());</span>
<span class="line-removed">1423   Symbol*  symbol  = constant_pool-&gt;symbol_at(index);</span>
<span class="line-removed">1424 </span>
<span class="line-removed">1425   // class name?</span>
<span class="line-removed">1426   if (symbol-&gt;char_at(0) != &#39;(&#39;) {</span>
<span class="line-removed">1427     Handle protection_domain (THREAD, constant_pool-&gt;pool_holder()-&gt;protection_domain());</span>
<span class="line-removed">1428     SystemDictionary::resolve_or_null(symbol, class_loader, protection_domain, CHECK);</span>
<span class="line-removed">1429     return;</span>
<span class="line-removed">1430   }</span>
<span class="line-removed">1431 </span>
<span class="line-removed">1432   // then it must be a signature!</span>
<span class="line-removed">1433   ResourceMark rm(THREAD);</span>
<span class="line-removed">1434   for (SignatureStream ss(symbol); !ss.is_done(); ss.next()) {</span>
<span class="line-removed">1435     if (ss.is_object()) {</span>
<span class="line-removed">1436       Symbol* class_name = ss.as_symbol(CHECK);</span>
<span class="line-removed">1437       Handle protection_domain (THREAD, constant_pool-&gt;pool_holder()-&gt;protection_domain());</span>
<span class="line-removed">1438       SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK);</span>
<span class="line-removed">1439     }</span>
<span class="line-removed">1440   }</span>
1441 }
1442 
1443 
1444 void Deoptimization::load_class_by_index(const constantPoolHandle&amp; constant_pool, int index) {
1445   EXCEPTION_MARK;
1446   load_class_by_index(constant_pool, index, THREAD);
1447   if (HAS_PENDING_EXCEPTION) {
1448     // Exception happened during classloading. We ignore the exception here, since it
1449     // is going to be rethrown since the current activation is going to be deoptimized and
1450     // the interpreter will re-execute the bytecode.
1451     CLEAR_PENDING_EXCEPTION;
1452     // Class loading called java code which may have caused a stack
1453     // overflow. If the exception was thrown right before the return
1454     // to the runtime the stack is no longer guarded. Reguard the
1455     // stack otherwise if we return to the uncommon trap blob and the
1456     // stack bang causes a stack overflow we crash.
1457     assert(THREAD-&gt;is_Java_thread(), &quot;only a java thread can be here&quot;);
1458     JavaThread* thread = (JavaThread*)THREAD;
1459     bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
1460     if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
1461     assert(guard_pages_enabled, &quot;stack banging in uncommon trap blob may cause crash&quot;);
1462   }
1463 }
1464 































































1465 JRT_ENTRY(void, Deoptimization::uncommon_trap_inner(JavaThread* thread, jint trap_request)) {
1466   HandleMark hm;
1467 
1468   // uncommon_trap() is called at the beginning of the uncommon trap
1469   // handler. Note this fact before we start generating temporary frames
1470   // that can confuse an asynchronous stack walker. This counter is
1471   // decremented at the end of unpack_frames().
1472   thread-&gt;inc_in_deopt_handler();
1473 
1474   // We need to update the map if we have biased locking.
1475 #if INCLUDE_JVMCI
1476   // JVMCI might need to get an exception from the stack, which in turn requires the register map to be valid
1477   RegisterMap reg_map(thread, true);
1478 #else
1479   RegisterMap reg_map(thread, UseBiasedLocking);
1480 #endif
1481   frame stub_frame = thread-&gt;last_frame();
1482   frame fr = stub_frame.sender(&amp;reg_map);
1483   // Make sure the calling nmethod is not getting deoptimized and removed
1484   // before we are done with it.
1485   nmethodLocker nl(fr.pc());
1486 
1487   // Log a message
<span class="line-modified">1488   Events::log(thread, &quot;Uncommon trap: trap_request=&quot; PTR32_FORMAT &quot; fr.pc=&quot; INTPTR_FORMAT &quot; relative=&quot; INTPTR_FORMAT,</span>
1489               trap_request, p2i(fr.pc()), fr.pc() - fr.cb()-&gt;code_begin());
1490 
1491   {
1492     ResourceMark rm;
1493 
<span class="line-removed">1494     // Revoke biases of any monitors in the frame to ensure we can migrate them</span>
<span class="line-removed">1495     revoke_biases_of_monitors(thread, fr, &amp;reg_map);</span>
<span class="line-removed">1496 </span>
1497     DeoptReason reason = trap_request_reason(trap_request);
1498     DeoptAction action = trap_request_action(trap_request);
1499 #if INCLUDE_JVMCI
1500     int debug_id = trap_request_debug_id(trap_request);
1501 #endif
1502     jint unloaded_class_index = trap_request_index(trap_request); // CP idx or -1
1503 
1504     vframe*  vf  = vframe::new_vframe(&amp;fr, &amp;reg_map, thread);
1505     compiledVFrame* cvf = compiledVFrame::cast(vf);
1506 
1507     CompiledMethod* nm = cvf-&gt;code();
1508 
1509     ScopeDesc*      trap_scope  = cvf-&gt;scope();
1510 
1511     if (TraceDeoptimization) {
1512       ttyLocker ttyl;
1513       tty-&gt;print_cr(&quot;  bci=%d pc=&quot; INTPTR_FORMAT &quot;, relative_pc=&quot; INTPTR_FORMAT &quot;, method=%s&quot; JVMCI_ONLY(&quot;, debug_id=%d&quot;), trap_scope-&gt;bci(), p2i(fr.pc()), fr.pc() - nm-&gt;code_begin(), trap_scope-&gt;method()-&gt;name_and_sig_as_C_string()
1514 #if INCLUDE_JVMCI
1515           , debug_id
1516 #endif
1517           );
1518     }
1519 
<span class="line-modified">1520     methodHandle    trap_method = trap_scope-&gt;method();</span>
1521     int             trap_bci    = trap_scope-&gt;bci();
1522 #if INCLUDE_JVMCI
<span class="line-modified">1523     long speculation = thread-&gt;pending_failed_speculation();</span>
<span class="line-modified">1524     if (nm-&gt;is_compiled_by_jvmci()) {</span>
<span class="line-modified">1525       if (speculation != 0) {</span>
<span class="line-removed">1526         oop speculation_log = nm-&gt;as_nmethod()-&gt;speculation_log();</span>
<span class="line-removed">1527         if (speculation_log != NULL) {</span>
<span class="line-removed">1528           if (TraceDeoptimization || TraceUncollectedSpeculations) {</span>
<span class="line-removed">1529             if (HotSpotSpeculationLog::lastFailed(speculation_log) != 0) {</span>
<span class="line-removed">1530               tty-&gt;print_cr(&quot;A speculation that was not collected by the compiler is being overwritten&quot;);</span>
<span class="line-removed">1531             }</span>
<span class="line-removed">1532           }</span>
<span class="line-removed">1533           if (TraceDeoptimization) {</span>
<span class="line-removed">1534             tty-&gt;print_cr(&quot;Saving speculation to speculation log&quot;);</span>
<span class="line-removed">1535           }</span>
<span class="line-removed">1536           HotSpotSpeculationLog::set_lastFailed(speculation_log, speculation);</span>
<span class="line-removed">1537         } else {</span>
<span class="line-removed">1538           if (TraceDeoptimization) {</span>
<span class="line-removed">1539             tty-&gt;print_cr(&quot;Speculation present but no speculation log&quot;);</span>
<span class="line-removed">1540           }</span>
<span class="line-removed">1541         }</span>
<span class="line-removed">1542         thread-&gt;set_pending_failed_speculation(0);</span>
<span class="line-removed">1543       } else {</span>
<span class="line-removed">1544         if (TraceDeoptimization) {</span>
<span class="line-removed">1545           tty-&gt;print_cr(&quot;No speculation&quot;);</span>
<span class="line-removed">1546         }</span>
<span class="line-removed">1547       }</span>
1548     } else {
<span class="line-modified">1549       assert(speculation == 0, &quot;There should not be a speculation for method compiled by non-JVMCI compilers&quot;);</span>
1550     }
1551 
1552     if (trap_bci == SynchronizationEntryBCI) {
1553       trap_bci = 0;
1554       thread-&gt;set_pending_monitorenter(true);
1555     }
1556 
1557     if (reason == Deoptimization::Reason_transfer_to_interpreter) {
1558       thread-&gt;set_pending_transfer_to_interpreter(true);
1559     }
1560 #endif
1561 
1562     Bytecodes::Code trap_bc     = trap_method-&gt;java_code_at(trap_bci);
1563     // Record this event in the histogram.
1564     gather_statistics(reason, action, trap_bc);
1565 
1566     // Ensure that we can record deopt. history:
1567     // Need MDO to record RTM code generation state.
1568     bool create_if_missing = ProfileTraps || UseCodeAging RTM_OPT_ONLY( || UseRTMLocking );
1569 
1570     methodHandle profiled_method;
1571 #if INCLUDE_JVMCI
1572     if (nm-&gt;is_compiled_by_jvmci()) {
<span class="line-modified">1573       profiled_method = nm-&gt;method();</span>
1574     } else {
1575       profiled_method = trap_method;
1576     }
1577 #else
1578     profiled_method = trap_method;
1579 #endif
1580 
1581     MethodData* trap_mdo =
1582       get_method_data(thread, profiled_method, create_if_missing);
1583 


1584     // Log a message
1585     Events::log_deopt_message(thread, &quot;Uncommon trap: reason=%s action=%s pc=&quot; INTPTR_FORMAT &quot; method=%s @ %d %s&quot;,
1586                               trap_reason_name(reason), trap_action_name(action), p2i(fr.pc()),
1587                               trap_method-&gt;name_and_sig_as_C_string(), trap_bci, nm-&gt;compiler_name());
1588 
1589     // Print a bunch of diagnostics, if requested.
1590     if (TraceDeoptimization || LogCompilation) {
1591       ResourceMark rm;
1592       ttyLocker ttyl;
1593       char buf[100];
1594       if (xtty != NULL) {
1595         xtty-&gt;begin_head(&quot;uncommon_trap thread=&#39;&quot; UINTX_FORMAT &quot;&#39; %s&quot;,
1596                          os::current_thread_id(),
1597                          format_trap_request(buf, sizeof(buf), trap_request));





1598         nm-&gt;log_identity(xtty);
1599       }
1600       Symbol* class_name = NULL;
1601       bool unresolved = false;
1602       if (unloaded_class_index &gt;= 0) {
1603         constantPoolHandle constants (THREAD, trap_method-&gt;constants());
1604         if (constants-&gt;tag_at(unloaded_class_index).is_unresolved_klass()) {
1605           class_name = constants-&gt;klass_name_at(unloaded_class_index);
1606           unresolved = true;
1607           if (xtty != NULL)
1608             xtty-&gt;print(&quot; unresolved=&#39;1&#39;&quot;);
1609         } else if (constants-&gt;tag_at(unloaded_class_index).is_symbol()) {
1610           class_name = constants-&gt;symbol_at(unloaded_class_index);
1611         }
1612         if (xtty != NULL)
1613           xtty-&gt;name(class_name);
1614       }
1615       if (xtty != NULL &amp;&amp; trap_mdo != NULL &amp;&amp; (int)reason &lt; (int)MethodData::_trap_hist_limit) {
1616         // Dump the relevant MDO state.
1617         // This is the deopt count for the current reason, any previous
</pre>
<hr />
<pre>
1623         int dos = (pdata == NULL)? 0: pdata-&gt;trap_state();
1624         if (dos != 0) {
1625           xtty-&gt;print(&quot; state=&#39;%s&#39;&quot;, format_trap_state(buf, sizeof(buf), dos));
1626           if (trap_state_is_recompiled(dos)) {
1627             int recnt2 = trap_mdo-&gt;overflow_recompile_count();
1628             if (recnt2 != 0)
1629               xtty-&gt;print(&quot; recompiles2=&#39;%d&#39;&quot;, recnt2);
1630           }
1631         }
1632       }
1633       if (xtty != NULL) {
1634         xtty-&gt;stamp();
1635         xtty-&gt;end_head();
1636       }
1637       if (TraceDeoptimization) {  // make noise on the tty
1638         tty-&gt;print(&quot;Uncommon trap occurred in&quot;);
1639         nm-&gt;method()-&gt;print_short_name(tty);
1640         tty-&gt;print(&quot; compiler=%s compile_id=%d&quot;, nm-&gt;compiler_name(), nm-&gt;compile_id());
1641 #if INCLUDE_JVMCI
1642         if (nm-&gt;is_nmethod()) {
<span class="line-modified">1643           char* installed_code_name = nm-&gt;as_nmethod()-&gt;jvmci_installed_code_name(buf, sizeof(buf));</span>
1644           if (installed_code_name != NULL) {
1645             tty-&gt;print(&quot; (JVMCI: installed code name=%s) &quot;, installed_code_name);
1646           }
1647         }
1648 #endif
1649         tty-&gt;print(&quot; (@&quot; INTPTR_FORMAT &quot;) thread=&quot; UINTX_FORMAT &quot; reason=%s action=%s unloaded_class_index=%d&quot; JVMCI_ONLY(&quot; debug_id=%d&quot;),
1650                    p2i(fr.pc()),
1651                    os::current_thread_id(),
1652                    trap_reason_name(reason),
1653                    trap_action_name(action),
1654                    unloaded_class_index
1655 #if INCLUDE_JVMCI
1656                    , debug_id
1657 #endif
1658                    );
1659         if (class_name != NULL) {
1660           tty-&gt;print(unresolved ? &quot; unresolved class: &quot; : &quot; symbol: &quot;);
1661           class_name-&gt;print_symbol_on(tty);
1662         }
1663         tty-&gt;cr();
</pre>
<hr />
<pre>
1885       if ((reason != Reason_rtm_state_change) &amp;&amp; (trap_mdo != NULL) &amp;&amp;
1886           UseRTMDeopt &amp;&amp; (nm-&gt;as_nmethod()-&gt;rtm_state() != ProfileRTM)) {
1887         trap_mdo-&gt;atomic_set_rtm_state(ProfileRTM);
1888       }
1889 #endif
1890       // For code aging we count traps separately here, using make_not_entrant()
1891       // as a guard against simultaneous deopts in multiple threads.
1892       if (reason == Reason_tenured &amp;&amp; trap_mdo != NULL) {
1893         trap_mdo-&gt;inc_tenure_traps();
1894       }
1895     }
1896 
1897     if (inc_recompile_count) {
1898       trap_mdo-&gt;inc_overflow_recompile_count();
1899       if ((uint)trap_mdo-&gt;overflow_recompile_count() &gt;
1900           (uint)PerBytecodeRecompilationCutoff) {
1901         // Give up on the method containing the bad BCI.
1902         if (trap_method() == nm-&gt;method()) {
1903           make_not_compilable = true;
1904         } else {
<span class="line-modified">1905           trap_method-&gt;set_not_compilable(CompLevel_full_optimization, true, &quot;overflow_recompile_count &gt; PerBytecodeRecompilationCutoff&quot;);</span>
1906           // But give grace to the enclosing nm-&gt;method().
1907         }
1908       }
1909     }
1910 
1911     // Reprofile
1912     if (reprofile) {
1913       CompilationPolicy::policy()-&gt;reprofile(trap_scope, nm-&gt;is_osr_method());
1914     }
1915 
1916     // Give up compiling
1917     if (make_not_compilable &amp;&amp; !nm-&gt;method()-&gt;is_not_compilable(CompLevel_full_optimization)) {
1918       assert(make_not_entrant, &quot;consistent&quot;);
<span class="line-modified">1919       nm-&gt;method()-&gt;set_not_compilable(CompLevel_full_optimization);</span>
1920     }
1921 
1922   } // Free marked resources
1923 
1924 }
1925 JRT_END
1926 
1927 ProfileData*
1928 Deoptimization::query_update_method_data(MethodData* trap_mdo,
1929                                          int trap_bci,
1930                                          Deoptimization::DeoptReason reason,
1931                                          bool update_total_trap_count,
1932 #if INCLUDE_JVMCI
1933                                          bool is_osr,
1934 #endif
1935                                          Method* compiled_method,
1936                                          //outputs:
1937                                          uint&amp; ret_this_trap_count,
1938                                          bool&amp; ret_maybe_prior_trap,
1939                                          bool&amp; ret_maybe_prior_recompile) {
</pre>
<hr />
<pre>
2129                        recomp_flag ? &quot; recompiled&quot; : &quot;&quot;);
2130   }
2131   return buf;
2132 }
2133 
2134 
2135 //--------------------------------statics--------------------------------------
2136 const char* Deoptimization::_trap_reason_name[] = {
2137   // Note:  Keep this in sync. with enum DeoptReason.
2138   &quot;none&quot;,
2139   &quot;null_check&quot;,
2140   &quot;null_assert&quot; JVMCI_ONLY(&quot;_or_unreached0&quot;),
2141   &quot;range_check&quot;,
2142   &quot;class_check&quot;,
2143   &quot;array_check&quot;,
2144   &quot;intrinsic&quot; JVMCI_ONLY(&quot;_or_type_checked_inlining&quot;),
2145   &quot;bimorphic&quot; JVMCI_ONLY(&quot;_or_optimized_type_check&quot;),
2146   &quot;profile_predicate&quot;,
2147   &quot;unloaded&quot;,
2148   &quot;uninitialized&quot;,

2149   &quot;unreached&quot;,
2150   &quot;unhandled&quot;,
2151   &quot;constraint&quot;,
2152   &quot;div0_check&quot;,
2153   &quot;age&quot;,
2154   &quot;predicate&quot;,
2155   &quot;loop_limit_check&quot;,
2156   &quot;speculate_class_check&quot;,
2157   &quot;speculate_null_check&quot;,
2158   &quot;speculate_null_assert&quot;,
2159   &quot;rtm_state_change&quot;,
2160   &quot;unstable_if&quot;,
2161   &quot;unstable_fused_if&quot;,
2162 #if INCLUDE_JVMCI
2163   &quot;aliasing&quot;,
2164   &quot;transfer_to_interpreter&quot;,
2165   &quot;not_compiled_exception_handler&quot;,
2166   &quot;unresolved&quot;,
2167   &quot;jsr_mismatch&quot;,
2168 #endif
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-added">   1 </span>
<span class="line-added">   2 </span>
   3 /*
<span class="line-modified">   4  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   5  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   6  *
   7  * This code is free software; you can redistribute it and/or modify it
   8  * under the terms of the GNU General Public License version 2 only, as
   9  * published by the Free Software Foundation.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  *
  25  */
  26 
  27 #include &quot;precompiled.hpp&quot;
  28 #include &quot;jvm.h&quot;
<span class="line-added">  29 #include &quot;classfile/symbolTable.hpp&quot;</span>
  30 #include &quot;classfile/systemDictionary.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/debugInfoRec.hpp&quot;
  33 #include &quot;code/nmethod.hpp&quot;
  34 #include &quot;code/pcDesc.hpp&quot;
  35 #include &quot;code/scopeDesc.hpp&quot;
<span class="line-added">  36 #include &quot;compiler/compilationPolicy.hpp&quot;</span>
  37 #include &quot;interpreter/bytecode.hpp&quot;
  38 #include &quot;interpreter/interpreter.hpp&quot;
  39 #include &quot;interpreter/oopMapCache.hpp&quot;
  40 #include &quot;memory/allocation.inline.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  43 #include &quot;memory/universe.hpp&quot;</span>
  44 #include &quot;oops/constantPool.hpp&quot;
  45 #include &quot;oops/method.hpp&quot;
<span class="line-added">  46 #include &quot;oops/objArrayKlass.hpp&quot;</span>
  47 #include &quot;oops/objArrayOop.inline.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-modified">  49 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  50 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  51 #include &quot;oops/verifyOopClosure.hpp&quot;
  52 #include &quot;prims/jvmtiThreadState.hpp&quot;
<span class="line-added">  53 #include &quot;runtime/atomic.hpp&quot;</span>
  54 #include &quot;runtime/biasedLocking.hpp&quot;

  55 #include &quot;runtime/deoptimization.hpp&quot;
<span class="line-added">  56 #include &quot;runtime/fieldDescriptor.hpp&quot;</span>
<span class="line-added">  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-added">  61 #include &quot;runtime/jniHandles.inline.hpp&quot;</span>
  62 #include &quot;runtime/safepointVerifiers.hpp&quot;
  63 #include &quot;runtime/sharedRuntime.hpp&quot;
  64 #include &quot;runtime/signature.hpp&quot;
  65 #include &quot;runtime/stubRoutines.hpp&quot;
  66 #include &quot;runtime/thread.hpp&quot;
  67 #include &quot;runtime/threadSMR.hpp&quot;
  68 #include &quot;runtime/vframe.hpp&quot;
  69 #include &quot;runtime/vframeArray.hpp&quot;
  70 #include &quot;runtime/vframe_hp.hpp&quot;
  71 #include &quot;utilities/events.hpp&quot;
<span class="line-added">  72 #include &quot;utilities/macros.hpp&quot;</span>
  73 #include &quot;utilities/preserveException.hpp&quot;
  74 #include &quot;utilities/xmlstream.hpp&quot;
<span class="line-modified">  75 #if INCLUDE_JFR</span>
<span class="line-modified">  76 #include &quot;jfr/jfrEvents.hpp&quot;</span>
<span class="line-modified">  77 #include &quot;jfr/metadata/jfrSerializer.hpp&quot;</span>

  78 #endif
  79 

  80 bool DeoptimizationMarker::_is_active = false;
  81 
  82 Deoptimization::UnrollBlock::UnrollBlock(int  size_of_deoptimized_frame,
  83                                          int  caller_adjustment,
  84                                          int  caller_actual_parameters,
  85                                          int  number_of_frames,
  86                                          intptr_t* frame_sizes,
  87                                          address* frame_pcs,
  88                                          BasicType return_type,
  89                                          int exec_mode) {
  90   _size_of_deoptimized_frame = size_of_deoptimized_frame;
  91   _caller_adjustment         = caller_adjustment;
  92   _caller_actual_parameters  = caller_actual_parameters;
  93   _number_of_frames          = number_of_frames;
  94   _frame_sizes               = frame_sizes;
  95   _frame_pcs                 = frame_pcs;
  96   _register_block            = NEW_C_HEAP_ARRAY(intptr_t, RegisterMap::reg_count * 2, mtCompiler);
  97   _return_type               = return_type;
  98   _initial_info              = 0;
  99   // PD (x86 only)
</pre>
<hr />
<pre>
 147 // ResetNoHandleMark and HandleMark were removed from it. The actual reallocation
 148 // of previously eliminated objects occurs in realloc_objects, which is
 149 // called from the method fetch_unroll_info_helper below.
 150 JRT_BLOCK_ENTRY(Deoptimization::UnrollBlock*, Deoptimization::fetch_unroll_info(JavaThread* thread, int exec_mode))
 151   // It is actually ok to allocate handles in a leaf method. It causes no safepoints,
 152   // but makes the entry a little slower. There is however a little dance we have to
 153   // do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro
 154 
 155   // fetch_unroll_info() is called at the beginning of the deoptimization
 156   // handler. Note this fact before we start generating temporary frames
 157   // that can confuse an asynchronous stack walker. This counter is
 158   // decremented at the end of unpack_frames().
 159   if (TraceDeoptimization) {
 160     tty-&gt;print_cr(&quot;Deoptimizing thread &quot; INTPTR_FORMAT, p2i(thread));
 161   }
 162   thread-&gt;inc_in_deopt_handler();
 163 
 164   return fetch_unroll_info_helper(thread, exec_mode);
 165 JRT_END
 166 
<span class="line-added"> 167 #if COMPILER2_OR_JVMCI</span>
<span class="line-added"> 168 static bool eliminate_allocations(JavaThread* thread, int exec_mode, CompiledMethod* compiled_method,</span>
<span class="line-added"> 169                                   frame&amp; deoptee, RegisterMap&amp; map, GrowableArray&lt;compiledVFrame*&gt;* chunk) {</span>
<span class="line-added"> 170   bool realloc_failures = false;</span>
<span class="line-added"> 171   assert (chunk-&gt;at(0)-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);</span>
<span class="line-added"> 172 </span>
<span class="line-added"> 173   GrowableArray&lt;ScopeValue*&gt;* objects = chunk-&gt;at(0)-&gt;scope()-&gt;objects();</span>
<span class="line-added"> 174 </span>
<span class="line-added"> 175   // The flag return_oop() indicates call sites which return oop</span>
<span class="line-added"> 176   // in compiled code. Such sites include java method calls,</span>
<span class="line-added"> 177   // runtime calls (for example, used to allocate new objects/arrays</span>
<span class="line-added"> 178   // on slow code path) and any other calls generated in compiled code.</span>
<span class="line-added"> 179   // It is not guaranteed that we can get such information here only</span>
<span class="line-added"> 180   // by analyzing bytecode in deoptimized frames. This is why this flag</span>
<span class="line-added"> 181   // is set during method compilation (see Compile::Process_OopMap_Node()).</span>
<span class="line-added"> 182   // If the previous frame was popped or if we are dispatching an exception,</span>
<span class="line-added"> 183   // we don&#39;t have an oop result.</span>
<span class="line-added"> 184   bool save_oop_result = chunk-&gt;at(0)-&gt;scope()-&gt;return_oop() &amp;&amp; !thread-&gt;popframe_forcing_deopt_reexecution() &amp;&amp; (exec_mode == Deoptimization::Unpack_deopt);</span>
<span class="line-added"> 185   Handle return_value;</span>
<span class="line-added"> 186   if (save_oop_result) {</span>
<span class="line-added"> 187     // Reallocation may trigger GC. If deoptimization happened on return from</span>
<span class="line-added"> 188     // call which returns oop we need to save it since it is not in oopmap.</span>
<span class="line-added"> 189     oop result = deoptee.saved_oop_result(&amp;map);</span>
<span class="line-added"> 190     assert(oopDesc::is_oop_or_null(result), &quot;must be oop&quot;);</span>
<span class="line-added"> 191     return_value = Handle(thread, result);</span>
<span class="line-added"> 192     assert(Universe::heap()-&gt;is_in_or_null(result), &quot;must be heap pointer&quot;);</span>
<span class="line-added"> 193     if (TraceDeoptimization) {</span>
<span class="line-added"> 194       ttyLocker ttyl;</span>
<span class="line-added"> 195       tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));</span>
<span class="line-added"> 196     }</span>
<span class="line-added"> 197   }</span>
<span class="line-added"> 198   if (objects != NULL) {</span>
<span class="line-added"> 199     JRT_BLOCK</span>
<span class="line-added"> 200       realloc_failures = Deoptimization::realloc_objects(thread, &amp;deoptee, &amp;map, objects, THREAD);</span>
<span class="line-added"> 201     JRT_END</span>
<span class="line-added"> 202     bool skip_internal = (compiled_method != NULL) &amp;&amp; !compiled_method-&gt;is_compiled_by_jvmci();</span>
<span class="line-added"> 203     Deoptimization::reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal);</span>
<span class="line-added"> 204 #ifndef PRODUCT</span>
<span class="line-added"> 205     if (TraceDeoptimization) {</span>
<span class="line-added"> 206       ttyLocker ttyl;</span>
<span class="line-added"> 207       tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));</span>
<span class="line-added"> 208       Deoptimization::print_objects(objects, realloc_failures);</span>
<span class="line-added"> 209     }</span>
<span class="line-added"> 210 #endif</span>
<span class="line-added"> 211   }</span>
<span class="line-added"> 212   if (save_oop_result) {</span>
<span class="line-added"> 213     // Restore result.</span>
<span class="line-added"> 214     deoptee.set_saved_oop_result(&amp;map, return_value());</span>
<span class="line-added"> 215   }</span>
<span class="line-added"> 216   return realloc_failures;</span>
<span class="line-added"> 217 }</span>
<span class="line-added"> 218 </span>
<span class="line-added"> 219 static void eliminate_locks(JavaThread* thread, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {</span>
<span class="line-added"> 220 #ifndef PRODUCT</span>
<span class="line-added"> 221   bool first = true;</span>
<span class="line-added"> 222 #endif</span>
<span class="line-added"> 223   for (int i = 0; i &lt; chunk-&gt;length(); i++) {</span>
<span class="line-added"> 224     compiledVFrame* cvf = chunk-&gt;at(i);</span>
<span class="line-added"> 225     assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);</span>
<span class="line-added"> 226     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();</span>
<span class="line-added"> 227     if (monitors-&gt;is_nonempty()) {</span>
<span class="line-added"> 228       Deoptimization::relock_objects(monitors, thread, realloc_failures);</span>
<span class="line-added"> 229 #ifndef PRODUCT</span>
<span class="line-added"> 230       if (PrintDeoptimizationDetails) {</span>
<span class="line-added"> 231         ttyLocker ttyl;</span>
<span class="line-added"> 232         for (int j = 0; j &lt; monitors-&gt;length(); j++) {</span>
<span class="line-added"> 233           MonitorInfo* mi = monitors-&gt;at(j);</span>
<span class="line-added"> 234           if (mi-&gt;eliminated()) {</span>
<span class="line-added"> 235             if (first) {</span>
<span class="line-added"> 236               first = false;</span>
<span class="line-added"> 237               tty-&gt;print_cr(&quot;RELOCK OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));</span>
<span class="line-added"> 238             }</span>
<span class="line-added"> 239             if (mi-&gt;owner_is_scalar_replaced()) {</span>
<span class="line-added"> 240               Klass* k = java_lang_Class::as_Klass(mi-&gt;owner_klass());</span>
<span class="line-added"> 241               tty-&gt;print_cr(&quot;     failed reallocation for klass %s&quot;, k-&gt;external_name());</span>
<span class="line-added"> 242             } else {</span>
<span class="line-added"> 243               tty-&gt;print_cr(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; locked&quot;, p2i(mi-&gt;owner()));</span>
<span class="line-added"> 244             }</span>
<span class="line-added"> 245           }</span>
<span class="line-added"> 246         }</span>
<span class="line-added"> 247       }</span>
<span class="line-added"> 248 #endif // !PRODUCT</span>
<span class="line-added"> 249     }</span>
<span class="line-added"> 250   }</span>
<span class="line-added"> 251 }</span>
<span class="line-added"> 252 #endif // COMPILER2_OR_JVMCI</span>
 253 
 254 // This is factored, since it is both called from a JRT_LEAF (deoptimization) and a JRT_ENTRY (uncommon_trap)
 255 Deoptimization::UnrollBlock* Deoptimization::fetch_unroll_info_helper(JavaThread* thread, int exec_mode) {
 256 
 257   // Note: there is a safepoint safety issue here. No matter whether we enter
 258   // via vanilla deopt or uncommon trap we MUST NOT stop at a safepoint once
 259   // the vframeArray is created.
 260   //
 261 
 262   // Allocate our special deoptimization ResourceMark
 263   DeoptResourceMark* dmark = new DeoptResourceMark(thread);
 264   assert(thread-&gt;deopt_mark() == NULL, &quot;Pending deopt!&quot;);
 265   thread-&gt;set_deopt_mark(dmark);
 266 
 267   frame stub_frame = thread-&gt;last_frame(); // Makes stack walkable as side effect
 268   RegisterMap map(thread, true);
 269   RegisterMap dummy_map(thread, false);
 270   // Now get the deoptee with a valid map
 271   frame deoptee = stub_frame.sender(&amp;map);
 272   // Set the deoptee nmethod
</pre>
<hr />
<pre>
 277   if (VerifyStack) {
 278     thread-&gt;validate_frame_layout();
 279   }
 280 
 281   // Create a growable array of VFrames where each VFrame represents an inlined
 282   // Java frame.  This storage is allocated with the usual system arena.
 283   assert(deoptee.is_compiled_frame(), &quot;Wrong frame type&quot;);
 284   GrowableArray&lt;compiledVFrame*&gt;* chunk = new GrowableArray&lt;compiledVFrame*&gt;(10);
 285   vframe* vf = vframe::new_vframe(&amp;deoptee, &amp;map, thread);
 286   while (!vf-&gt;is_top()) {
 287     assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
 288     chunk-&gt;push(compiledVFrame::cast(vf));
 289     vf = vf-&gt;sender();
 290   }
 291   assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
 292   chunk-&gt;push(compiledVFrame::cast(vf));
 293 
 294   bool realloc_failures = false;
 295 
 296 #if COMPILER2_OR_JVMCI
<span class="line-added"> 297 #if INCLUDE_JVMCI</span>
<span class="line-added"> 298   bool jvmci_enabled = true;</span>
<span class="line-added"> 299 #else</span>
<span class="line-added"> 300   bool jvmci_enabled = false;</span>
<span class="line-added"> 301 #endif</span>
<span class="line-added"> 302 </span>
 303   // Reallocate the non-escaping objects and restore their fields. Then
 304   // relock objects if synchronization on them was eliminated.
<span class="line-modified"> 305   if (jvmci_enabled COMPILER2_PRESENT( || (DoEscapeAnalysis &amp;&amp; EliminateAllocations) )) {</span>
<span class="line-modified"> 306     realloc_failures = eliminate_allocations(thread, exec_mode, cm, deoptee, map, chunk);</span>
<span class="line-modified"> 307   }</span>
<span class="line-modified"> 308 #endif // COMPILER2_OR_JVMCI</span>
<span class="line-modified"> 309 </span>
<span class="line-modified"> 310   // Revoke biases, done with in java state.</span>
<span class="line-modified"> 311   // No safepoints allowed after this</span>
<span class="line-modified"> 312   revoke_from_deopt_handler(thread, deoptee, &amp;map);</span>
<span class="line-modified"> 313 </span>
<span class="line-modified"> 314   // Ensure that no safepoint is taken after pointers have been stored</span>
<span class="line-modified"> 315   // in fields of rematerialized objects.  If a safepoint occurs from here on</span>
<span class="line-modified"> 316   // out the java state residing in the vframeArray will be missed.</span>
<span class="line-modified"> 317   // Locks may be rebaised in a safepoint.</span>
<span class="line-modified"> 318   NoSafepointVerifier no_safepoint;</span>
<span class="line-modified"> 319 </span>
<span class="line-modified"> 320 #if COMPILER2_OR_JVMCI</span>
<span class="line-modified"> 321   if (jvmci_enabled COMPILER2_PRESENT( || ((DoEscapeAnalysis || EliminateNestedLocks) &amp;&amp; EliminateLocks) )) {</span>
<span class="line-modified"> 322     eliminate_locks(thread, chunk, realloc_failures);</span>



































































 323   }

 324 #endif // COMPILER2_OR_JVMCI
 325 
 326   ScopeDesc* trap_scope = chunk-&gt;at(0)-&gt;scope();
 327   Handle exceptionObject;
 328   if (trap_scope-&gt;rethrow_exception()) {
 329     if (PrintDeoptimizationDetails) {
 330       tty-&gt;print_cr(&quot;Exception to be rethrown in the interpreter for method %s::%s at bci %d&quot;, trap_scope-&gt;method()-&gt;method_holder()-&gt;name()-&gt;as_C_string(), trap_scope-&gt;method()-&gt;name()-&gt;as_C_string(), trap_scope-&gt;bci());
 331     }
 332     GrowableArray&lt;ScopeValue*&gt;* expressions = trap_scope-&gt;expressions();
 333     guarantee(expressions != NULL &amp;&amp; expressions-&gt;length() &gt; 0, &quot;must have exception to throw&quot;);
 334     ScopeValue* topOfStack = expressions-&gt;top();
 335     exceptionObject = StackValue::create_stack_value(&amp;deoptee, &amp;map, topOfStack)-&gt;get_obj();
 336     guarantee(exceptionObject() != NULL, &quot;exception oop can not be null&quot;);
 337   }
 338 





 339   vframeArray* array = create_vframeArray(thread, deoptee, &amp;map, chunk, realloc_failures);
 340 #if COMPILER2_OR_JVMCI
 341   if (realloc_failures) {
 342     pop_frames_failed_reallocs(thread, array);
 343   }
 344 #endif
 345 
 346   assert(thread-&gt;vframe_array_head() == NULL, &quot;Pending deopt!&quot;);
 347   thread-&gt;set_vframe_array_head(array);
 348 
 349   // Now that the vframeArray has been created if we have any deferred local writes
 350   // added by jvmti then we can free up that structure as the data is now in the
 351   // vframeArray
 352 
 353   if (thread-&gt;deferred_locals() != NULL) {
 354     GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt;* list = thread-&gt;deferred_locals();
 355     int i = 0;
 356     do {
 357       // Because of inlining we could have multiple vframes for a single frame
 358       // and several of the vframes could have deferred writes. Find them all.
</pre>
<hr />
<pre>
 418   // PopFrame requires that the preserved incoming arguments from the recently-popped topmost
 419   // activation be put back on the expression stack of the caller for reexecution
 420   if (JvmtiExport::can_pop_frame() &amp;&amp; thread-&gt;popframe_forcing_deopt_reexecution()) {
 421     popframe_extra_args = in_words(thread-&gt;popframe_preserved_args_size_in_words());
 422   }
 423 
 424   // Find the current pc for sender of the deoptee. Since the sender may have been deoptimized
 425   // itself since the deoptee vframeArray was created we must get a fresh value of the pc rather
 426   // than simply use array-&gt;sender.pc(). This requires us to walk the current set of frames
 427   //
 428   frame deopt_sender = stub_frame.sender(&amp;dummy_map); // First is the deoptee frame
 429   deopt_sender = deopt_sender.sender(&amp;dummy_map);     // Now deoptee caller
 430 
 431   // It&#39;s possible that the number of parameters at the call site is
 432   // different than number of arguments in the callee when method
 433   // handles are used.  If the caller is interpreted get the real
 434   // value so that the proper amount of space can be added to it&#39;s
 435   // frame.
 436   bool caller_was_method_handle = false;
 437   if (deopt_sender.is_interpreted_frame()) {
<span class="line-modified"> 438     methodHandle method(thread, deopt_sender.interpreter_frame_method());</span>
 439     Bytecode_invoke cur = Bytecode_invoke_check(method, deopt_sender.interpreter_frame_bci());
 440     if (cur.is_invokedynamic() || cur.is_invokehandle()) {
 441       // Method handle invokes may involve fairly arbitrary chains of
 442       // calls so it&#39;s impossible to know how much actual space the
 443       // caller has for locals.
 444       caller_was_method_handle = true;
 445     }
 446   }
 447 
 448   //
 449   // frame_sizes/frame_pcs[0] oldest frame (int or c2i)
 450   // frame_sizes/frame_pcs[1] next oldest frame (int)
 451   // frame_sizes/frame_pcs[n] youngest frame (int)
 452   //
 453   // Now a pc in frame_pcs is actually the return address to the frame&#39;s caller (a frame
 454   // owns the space for the return address to it&#39;s caller).  Confusing ain&#39;t it.
 455   //
 456   // The vframe array can address vframes with indices running from
 457   // 0.._frames-1. Index  0 is the youngest frame and _frame - 1 is the oldest (root) frame.
 458   // When we create the skeletal frames we need the oldest frame to be in the zero slot
</pre>
<hr />
<pre>
 641 
 642   // It is actually ok to allocate handles in a leaf method. It causes no safepoints,
 643   // but makes the entry a little slower. There is however a little dance we have to
 644   // do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro
 645   ResetNoHandleMark rnhm; // No-op in release/product versions
 646   HandleMark hm;
 647 
 648   frame stub_frame = thread-&gt;last_frame();
 649 
 650   // Since the frame to unpack is the top frame of this thread, the vframe_array_head
 651   // must point to the vframeArray for the unpack frame.
 652   vframeArray* array = thread-&gt;vframe_array_head();
 653 
 654 #ifndef PRODUCT
 655   if (TraceDeoptimization) {
 656     ttyLocker ttyl;
 657     tty-&gt;print_cr(&quot;DEOPT UNPACKING thread &quot; INTPTR_FORMAT &quot; vframeArray &quot; INTPTR_FORMAT &quot; mode %d&quot;,
 658                   p2i(thread), p2i(array), exec_mode);
 659   }
 660 #endif
<span class="line-modified"> 661   Events::log_deopt_message(thread, &quot;DEOPT UNPACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT &quot; mode %d&quot;,</span>
 662               p2i(stub_frame.pc()), p2i(stub_frame.sp()), exec_mode);
 663 
 664   UnrollBlock* info = array-&gt;unroll_block();
 665 
 666   // Unpack the interpreter frames and any adapter frame (c2 only) we might create.
 667   array-&gt;unpack_to_stack(stub_frame, exec_mode, info-&gt;caller_actual_parameters());
 668 
 669   BasicType bt = info-&gt;return_type();
 670 
 671   // If we have an exception pending, claim that the return type is an oop
 672   // so the deopt_blob does not overwrite the exception_oop.
 673 
 674   if (exec_mode == Unpack_exception)
 675     bt = T_OBJECT;
 676 
 677   // Cleanup thread deopt data
 678   cleanup_deopt_info(thread, array);
 679 
 680 #ifndef PRODUCT
 681   if (VerifyStack) {
</pre>
<hr />
<pre>
 689     // notions of expression stack and locals
 690     vframeArray* cur_array = thread-&gt;vframe_array_last();
 691     RegisterMap rm(thread, false);
 692     rm.set_include_argument_oops(false);
 693     bool is_top_frame = true;
 694     int callee_size_of_parameters = 0;
 695     int callee_max_locals = 0;
 696     for (int i = 0; i &lt; cur_array-&gt;frames(); i++) {
 697       vframeArrayElement* el = cur_array-&gt;element(i);
 698       frame* iframe = el-&gt;iframe();
 699       guarantee(iframe-&gt;is_interpreted_frame(), &quot;Wrong frame type&quot;);
 700 
 701       // Get the oop map for this bci
 702       InterpreterOopMap mask;
 703       int cur_invoke_parameter_size = 0;
 704       bool try_next_mask = false;
 705       int next_mask_expression_stack_size = -1;
 706       int top_frame_expression_stack_adjustment = 0;
 707       methodHandle mh(thread, iframe-&gt;interpreter_frame_method());
 708       OopMapCache::compute_one_oop_map(mh, iframe-&gt;interpreter_frame_bci(), &amp;mask);
<span class="line-modified"> 709       BytecodeStream str(mh, iframe-&gt;interpreter_frame_bci());</span>

 710       int max_bci = mh-&gt;code_size();
 711       // Get to the next bytecode if possible
 712       assert(str.bci() &lt; max_bci, &quot;bci in interpreter frame out of bounds&quot;);
 713       // Check to see if we can grab the number of outgoing arguments
 714       // at an uncommon trap for an invoke (where the compiler
 715       // generates debug info before the invoke has executed)
 716       Bytecodes::Code cur_code = str.next();
 717       if (Bytecodes::is_invoke(cur_code)) {
 718         Bytecode_invoke invoke(mh, iframe-&gt;interpreter_frame_bci());
 719         cur_invoke_parameter_size = invoke.size_of_parameters();
 720         if (i != 0 &amp;&amp; !invoke.is_invokedynamic() &amp;&amp; MethodHandles::has_member_arg(invoke.klass(), invoke.name())) {
 721           callee_size_of_parameters++;
 722         }
 723       }
 724       if (str.bci() &lt; max_bci) {
 725         Bytecodes::Code next_code = str.next();
 726         if (next_code &gt;= 0) {
 727           // The interpreter oop map generator reports results before
 728           // the current bytecode has executed except in the case of
 729           // calls. It seems to be hard to tell whether the compiler
</pre>
<hr />
<pre>
 788             vframeArrayElement* el = cur_array-&gt;element(k);
 789             tty-&gt;print_cr(&quot;    %s (bci %d)&quot;, el-&gt;method()-&gt;name_and_sig_as_C_string(), el-&gt;bci());
 790           }
 791           cur_array-&gt;print_on_2(tty);
 792         } // release tty lock before calling guarantee
 793         guarantee(false, &quot;wrong number of expression stack elements during deopt&quot;);
 794       }
 795       VerifyOopClosure verify;
 796       iframe-&gt;oops_interpreted_do(&amp;verify, &amp;rm, false);
 797       callee_size_of_parameters = mh-&gt;size_of_parameters();
 798       callee_max_locals = mh-&gt;max_locals();
 799       is_top_frame = false;
 800     }
 801   }
 802 #endif /* !PRODUCT */
 803 
 804 
 805   return bt;
 806 JRT_END
 807 
<span class="line-added"> 808 class DeoptimizeMarkedClosure : public HandshakeClosure {</span>
<span class="line-added"> 809  public:</span>
<span class="line-added"> 810   DeoptimizeMarkedClosure() : HandshakeClosure(&quot;Deoptimize&quot;) {}</span>
<span class="line-added"> 811   void do_thread(Thread* thread) {</span>
<span class="line-added"> 812     JavaThread* jt = (JavaThread*)thread;</span>
<span class="line-added"> 813     jt-&gt;deoptimize_marked_methods();</span>
<span class="line-added"> 814   }</span>
<span class="line-added"> 815 };</span>
<span class="line-added"> 816 </span>
<span class="line-added"> 817 void Deoptimization::deoptimize_all_marked(nmethod* nmethod_only) {</span>
<span class="line-added"> 818   ResourceMark rm;</span>
<span class="line-added"> 819   DeoptimizationMarker dm;</span>
<span class="line-added"> 820 </span>
<span class="line-added"> 821   // Make the dependent methods not entrant</span>
<span class="line-added"> 822   if (nmethod_only != NULL) {</span>
<span class="line-added"> 823     nmethod_only-&gt;mark_for_deoptimization();</span>
<span class="line-added"> 824     nmethod_only-&gt;make_not_entrant();</span>
<span class="line-added"> 825   } else {</span>
<span class="line-added"> 826     MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added"> 827     CodeCache::make_marked_nmethods_not_entrant();</span>
<span class="line-added"> 828   }</span>
 829 
<span class="line-modified"> 830   DeoptimizeMarkedClosure deopt;</span>
<span class="line-modified"> 831   if (SafepointSynchronize::is_at_safepoint()) {</span>
<span class="line-modified"> 832     Threads::java_threads_do(&amp;deopt);</span>
<span class="line-added"> 833   } else {</span>
<span class="line-added"> 834     Handshake::execute(&amp;deopt);</span>
<span class="line-added"> 835   }</span>
 836 }
 837 
 838 Deoptimization::DeoptAction Deoptimization::_unloaded_action
 839   = Deoptimization::Action_reinterpret;
 840 
<span class="line-added"> 841 </span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843 #if INCLUDE_JVMCI || INCLUDE_AOT</span>
<span class="line-added"> 844 template&lt;typename CacheType&gt;</span>
<span class="line-added"> 845 class BoxCacheBase : public CHeapObj&lt;mtCompiler&gt; {</span>
<span class="line-added"> 846 protected:</span>
<span class="line-added"> 847   static InstanceKlass* find_cache_klass(Symbol* klass_name, TRAPS) {</span>
<span class="line-added"> 848     ResourceMark rm;</span>
<span class="line-added"> 849     char* klass_name_str = klass_name-&gt;as_C_string();</span>
<span class="line-added"> 850     Klass* k = SystemDictionary::find(klass_name, Handle(), Handle(), THREAD);</span>
<span class="line-added"> 851     guarantee(k != NULL, &quot;%s must be loaded&quot;, klass_name_str);</span>
<span class="line-added"> 852     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added"> 853     guarantee(ik-&gt;is_initialized(), &quot;%s must be initialized&quot;, klass_name_str);</span>
<span class="line-added"> 854     CacheType::compute_offsets(ik);</span>
<span class="line-added"> 855     return ik;</span>
<span class="line-added"> 856   }</span>
<span class="line-added"> 857 };</span>
<span class="line-added"> 858 </span>
<span class="line-added"> 859 template&lt;typename PrimitiveType, typename CacheType, typename BoxType&gt; class BoxCache  : public BoxCacheBase&lt;CacheType&gt; {</span>
<span class="line-added"> 860   PrimitiveType _low;</span>
<span class="line-added"> 861   PrimitiveType _high;</span>
<span class="line-added"> 862   jobject _cache;</span>
<span class="line-added"> 863 protected:</span>
<span class="line-added"> 864   static BoxCache&lt;PrimitiveType, CacheType, BoxType&gt; *_singleton;</span>
<span class="line-added"> 865   BoxCache(Thread* thread) {</span>
<span class="line-added"> 866     InstanceKlass* ik = BoxCacheBase&lt;CacheType&gt;::find_cache_klass(CacheType::symbol(), thread);</span>
<span class="line-added"> 867     objArrayOop cache = CacheType::cache(ik);</span>
<span class="line-added"> 868     assert(cache-&gt;length() &gt; 0, &quot;Empty cache&quot;);</span>
<span class="line-added"> 869     _low = BoxType::value(cache-&gt;obj_at(0));</span>
<span class="line-added"> 870     _high = _low + cache-&gt;length() - 1;</span>
<span class="line-added"> 871     _cache = JNIHandles::make_global(Handle(thread, cache));</span>
<span class="line-added"> 872   }</span>
<span class="line-added"> 873   ~BoxCache() {</span>
<span class="line-added"> 874     JNIHandles::destroy_global(_cache);</span>
<span class="line-added"> 875   }</span>
<span class="line-added"> 876 public:</span>
<span class="line-added"> 877   static BoxCache&lt;PrimitiveType, CacheType, BoxType&gt;* singleton(Thread* thread) {</span>
<span class="line-added"> 878     if (_singleton == NULL) {</span>
<span class="line-added"> 879       BoxCache&lt;PrimitiveType, CacheType, BoxType&gt;* s = new BoxCache&lt;PrimitiveType, CacheType, BoxType&gt;(thread);</span>
<span class="line-added"> 880       if (!Atomic::replace_if_null(&amp;_singleton, s)) {</span>
<span class="line-added"> 881         delete s;</span>
<span class="line-added"> 882       }</span>
<span class="line-added"> 883     }</span>
<span class="line-added"> 884     return _singleton;</span>
<span class="line-added"> 885   }</span>
<span class="line-added"> 886   oop lookup(PrimitiveType value) {</span>
<span class="line-added"> 887     if (_low &lt;= value &amp;&amp; value &lt;= _high) {</span>
<span class="line-added"> 888       int offset = value - _low;</span>
<span class="line-added"> 889       return objArrayOop(JNIHandles::resolve_non_null(_cache))-&gt;obj_at(offset);</span>
<span class="line-added"> 890     }</span>
<span class="line-added"> 891     return NULL;</span>
<span class="line-added"> 892   }</span>
<span class="line-added"> 893   oop lookup_raw(intptr_t raw_value) {</span>
<span class="line-added"> 894     // Have to cast to avoid little/big-endian problems.</span>
<span class="line-added"> 895     if (sizeof(PrimitiveType) &gt; sizeof(jint)) {</span>
<span class="line-added"> 896       jlong value = (jlong)raw_value;</span>
<span class="line-added"> 897       return lookup(value);</span>
<span class="line-added"> 898     }</span>
<span class="line-added"> 899     PrimitiveType value = (PrimitiveType)*((jint*)&amp;raw_value);</span>
<span class="line-added"> 900     return lookup(value);</span>
<span class="line-added"> 901   }</span>
<span class="line-added"> 902 };</span>
<span class="line-added"> 903 </span>
<span class="line-added"> 904 typedef BoxCache&lt;jint, java_lang_Integer_IntegerCache, java_lang_Integer&gt; IntegerBoxCache;</span>
<span class="line-added"> 905 typedef BoxCache&lt;jlong, java_lang_Long_LongCache, java_lang_Long&gt; LongBoxCache;</span>
<span class="line-added"> 906 typedef BoxCache&lt;jchar, java_lang_Character_CharacterCache, java_lang_Character&gt; CharacterBoxCache;</span>
<span class="line-added"> 907 typedef BoxCache&lt;jshort, java_lang_Short_ShortCache, java_lang_Short&gt; ShortBoxCache;</span>
<span class="line-added"> 908 typedef BoxCache&lt;jbyte, java_lang_Byte_ByteCache, java_lang_Byte&gt; ByteBoxCache;</span>
<span class="line-added"> 909 </span>
<span class="line-added"> 910 template&lt;&gt; BoxCache&lt;jint, java_lang_Integer_IntegerCache, java_lang_Integer&gt;* BoxCache&lt;jint, java_lang_Integer_IntegerCache, java_lang_Integer&gt;::_singleton = NULL;</span>
<span class="line-added"> 911 template&lt;&gt; BoxCache&lt;jlong, java_lang_Long_LongCache, java_lang_Long&gt;* BoxCache&lt;jlong, java_lang_Long_LongCache, java_lang_Long&gt;::_singleton = NULL;</span>
<span class="line-added"> 912 template&lt;&gt; BoxCache&lt;jchar, java_lang_Character_CharacterCache, java_lang_Character&gt;* BoxCache&lt;jchar, java_lang_Character_CharacterCache, java_lang_Character&gt;::_singleton = NULL;</span>
<span class="line-added"> 913 template&lt;&gt; BoxCache&lt;jshort, java_lang_Short_ShortCache, java_lang_Short&gt;* BoxCache&lt;jshort, java_lang_Short_ShortCache, java_lang_Short&gt;::_singleton = NULL;</span>
<span class="line-added"> 914 template&lt;&gt; BoxCache&lt;jbyte, java_lang_Byte_ByteCache, java_lang_Byte&gt;* BoxCache&lt;jbyte, java_lang_Byte_ByteCache, java_lang_Byte&gt;::_singleton = NULL;</span>
<span class="line-added"> 915 </span>
<span class="line-added"> 916 class BooleanBoxCache : public BoxCacheBase&lt;java_lang_Boolean&gt; {</span>
<span class="line-added"> 917   jobject _true_cache;</span>
<span class="line-added"> 918   jobject _false_cache;</span>
<span class="line-added"> 919 protected:</span>
<span class="line-added"> 920   static BooleanBoxCache *_singleton;</span>
<span class="line-added"> 921   BooleanBoxCache(Thread *thread) {</span>
<span class="line-added"> 922     InstanceKlass* ik = find_cache_klass(java_lang_Boolean::symbol(), thread);</span>
<span class="line-added"> 923     _true_cache = JNIHandles::make_global(Handle(thread, java_lang_Boolean::get_TRUE(ik)));</span>
<span class="line-added"> 924     _false_cache = JNIHandles::make_global(Handle(thread, java_lang_Boolean::get_FALSE(ik)));</span>
<span class="line-added"> 925   }</span>
<span class="line-added"> 926   ~BooleanBoxCache() {</span>
<span class="line-added"> 927     JNIHandles::destroy_global(_true_cache);</span>
<span class="line-added"> 928     JNIHandles::destroy_global(_false_cache);</span>
<span class="line-added"> 929   }</span>
<span class="line-added"> 930 public:</span>
<span class="line-added"> 931   static BooleanBoxCache* singleton(Thread* thread) {</span>
<span class="line-added"> 932     if (_singleton == NULL) {</span>
<span class="line-added"> 933       BooleanBoxCache* s = new BooleanBoxCache(thread);</span>
<span class="line-added"> 934       if (!Atomic::replace_if_null(&amp;_singleton, s)) {</span>
<span class="line-added"> 935         delete s;</span>
<span class="line-added"> 936       }</span>
<span class="line-added"> 937     }</span>
<span class="line-added"> 938     return _singleton;</span>
<span class="line-added"> 939   }</span>
<span class="line-added"> 940   oop lookup_raw(intptr_t raw_value) {</span>
<span class="line-added"> 941     // Have to cast to avoid little/big-endian problems.</span>
<span class="line-added"> 942     jboolean value = (jboolean)*((jint*)&amp;raw_value);</span>
<span class="line-added"> 943     return lookup(value);</span>
<span class="line-added"> 944   }</span>
<span class="line-added"> 945   oop lookup(jboolean value) {</span>
<span class="line-added"> 946     if (value != 0) {</span>
<span class="line-added"> 947       return JNIHandles::resolve_non_null(_true_cache);</span>
<span class="line-added"> 948     }</span>
<span class="line-added"> 949     return JNIHandles::resolve_non_null(_false_cache);</span>
<span class="line-added"> 950   }</span>
<span class="line-added"> 951 };</span>
<span class="line-added"> 952 </span>
<span class="line-added"> 953 BooleanBoxCache* BooleanBoxCache::_singleton = NULL;</span>
<span class="line-added"> 954 </span>
<span class="line-added"> 955 oop Deoptimization::get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, TRAPS) {</span>
<span class="line-added"> 956    Klass* k = java_lang_Class::as_Klass(bv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());</span>
<span class="line-added"> 957    BasicType box_type = SystemDictionary::box_klass_type(k);</span>
<span class="line-added"> 958    if (box_type != T_OBJECT) {</span>
<span class="line-added"> 959      StackValue* value = StackValue::create_stack_value(fr, reg_map, bv-&gt;field_at(box_type == T_LONG ? 1 : 0));</span>
<span class="line-added"> 960      switch(box_type) {</span>
<span class="line-added"> 961        case T_INT:     return IntegerBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added"> 962        case T_CHAR:    return CharacterBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added"> 963        case T_SHORT:   return ShortBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added"> 964        case T_BYTE:    return ByteBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added"> 965        case T_BOOLEAN: return BooleanBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added"> 966        case T_LONG:    return LongBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());</span>
<span class="line-added"> 967        default:;</span>
<span class="line-added"> 968      }</span>
<span class="line-added"> 969    }</span>
<span class="line-added"> 970    return NULL;</span>
<span class="line-added"> 971 }</span>
<span class="line-added"> 972 #endif // INCLUDE_JVMCI || INCLUDE_AOT</span>
<span class="line-added"> 973 </span>
 974 #if COMPILER2_OR_JVMCI
<span class="line-modified"> 975 bool Deoptimization::realloc_objects(JavaThread* thread, frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {</span>
 976   Handle pending_exception(THREAD, thread-&gt;pending_exception());
 977   const char* exception_file = thread-&gt;exception_file();
 978   int exception_line = thread-&gt;exception_line();
 979   thread-&gt;clear_pending_exception();
 980 
 981   bool failures = false;
 982 
 983   for (int i = 0; i &lt; objects-&gt;length(); i++) {
 984     assert(objects-&gt;at(i)-&gt;is_object(), &quot;invalid debug information&quot;);
 985     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
 986 
 987     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
 988     oop obj = NULL;
 989 
 990     if (k-&gt;is_instance_klass()) {
<span class="line-added"> 991 #if INCLUDE_JVMCI || INCLUDE_AOT</span>
<span class="line-added"> 992       CompiledMethod* cm = fr-&gt;cb()-&gt;as_compiled_method_or_null();</span>
<span class="line-added"> 993       if (cm-&gt;is_compiled_by_jvmci() &amp;&amp; sv-&gt;is_auto_box()) {</span>
<span class="line-added"> 994         AutoBoxObjectValue* abv = (AutoBoxObjectValue*) sv;</span>
<span class="line-added"> 995         obj = get_cached_box(abv, fr, reg_map, THREAD);</span>
<span class="line-added"> 996         if (obj != NULL) {</span>
<span class="line-added"> 997           // Set the flag to indicate the box came from a cache, so that we can skip the field reassignment for it.</span>
<span class="line-added"> 998           abv-&gt;set_cached(true);</span>
<span class="line-added"> 999         }</span>
<span class="line-added">1000       }</span>
<span class="line-added">1001 #endif // INCLUDE_JVMCI || INCLUDE_AOT</span>
1002       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1003       if (obj == NULL) {</span>
<span class="line-added">1004         obj = ik-&gt;allocate_instance(THREAD);</span>
<span class="line-added">1005       }</span>
1006     } else if (k-&gt;is_typeArray_klass()) {
1007       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1008       assert(sv-&gt;field_size() % type2size[ak-&gt;element_type()] == 0, &quot;non-integral array length&quot;);
1009       int len = sv-&gt;field_size() / type2size[ak-&gt;element_type()];
1010       obj = ak-&gt;allocate(len, THREAD);
1011     } else if (k-&gt;is_objArray_klass()) {
1012       ObjArrayKlass* ak = ObjArrayKlass::cast(k);
1013       obj = ak-&gt;allocate(sv-&gt;field_size(), THREAD);
1014     }
1015 
1016     if (obj == NULL) {
1017       failures = true;
1018     }
1019 
1020     assert(sv-&gt;value().is_null(), &quot;redundant reallocation&quot;);
1021     assert(obj != NULL || HAS_PENDING_EXCEPTION, &quot;allocation should succeed or we should get an exception&quot;);
1022     CLEAR_PENDING_EXCEPTION;
1023     sv-&gt;set_value(obj);
1024   }
1025 
</pre>
<hr />
<pre>
1139 }
1140 
1141 class ReassignedField {
1142 public:
1143   int _offset;
1144   BasicType _type;
1145 public:
1146   ReassignedField() {
1147     _offset = 0;
1148     _type = T_ILLEGAL;
1149   }
1150 };
1151 
1152 int compare(ReassignedField* left, ReassignedField* right) {
1153   return left-&gt;_offset - right-&gt;_offset;
1154 }
1155 
1156 // Restore fields of an eliminated instance object using the same field order
1157 // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
1158 static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal) {




1159   GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
<span class="line-modified">1160   InstanceKlass* ik = klass;</span>
<span class="line-modified">1161   while (ik != NULL) {</span>
<span class="line-modified">1162     for (AllFieldStream fs(ik); !fs.done(); fs.next()) {</span>
<span class="line-modified">1163       if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {</span>
<span class="line-modified">1164         ReassignedField field;</span>
<span class="line-modified">1165         field._offset = fs.offset();</span>
<span class="line-added">1166         field._type = Signature::basic_type(fs.signature());</span>
<span class="line-added">1167         fields-&gt;append(field);</span>
<span class="line-added">1168       }</span>
1169     }
<span class="line-added">1170     ik = ik-&gt;superklass();</span>
1171   }
1172   fields-&gt;sort(compare);
1173   for (int i = 0; i &lt; fields-&gt;length(); i++) {
1174     intptr_t val;
1175     ScopeValue* scope_field = sv-&gt;field_at(svIndex);
1176     StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);
1177     int offset = fields-&gt;at(i)._offset;
1178     BasicType type = fields-&gt;at(i)._type;
1179     switch (type) {
1180       case T_OBJECT: case T_ARRAY:
1181         assert(value-&gt;type() == T_OBJECT, &quot;Agreement.&quot;);
1182         obj-&gt;obj_field_put(offset, value-&gt;get_obj()());
1183         break;
1184 
1185       // Have to cast to INT (32 bits) pointer to avoid little/big-endian problem.
1186       case T_INT: case T_FLOAT: { // 4 bytes.
1187         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1188         bool big_value = false;
1189         if (i+1 &lt; fields-&gt;length() &amp;&amp; fields-&gt;at(i+1)._type == T_INT) {
1190           if (scope_field-&gt;is_location()) {
</pre>
<hr />
<pre>
1258         ShouldNotReachHere();
1259     }
1260     svIndex++;
1261   }
1262   return svIndex;
1263 }
1264 
1265 // restore fields of all eliminated objects and arrays
1266 void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal) {
1267   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1268     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1269     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1270     Handle obj = sv-&gt;value();
1271     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1272     if (PrintDeoptimizationDetails) {
1273       tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
1274     }
1275     if (obj.is_null()) {
1276       continue;
1277     }
<span class="line-modified">1278 #if INCLUDE_JVMCI || INCLUDE_AOT</span>
<span class="line-added">1279     // Don&#39;t reassign fields of boxes that came from a cache. Caches may be in CDS.</span>
<span class="line-added">1280     if (sv-&gt;is_auto_box() &amp;&amp; ((AutoBoxObjectValue*) sv)-&gt;is_cached()) {</span>
<span class="line-added">1281       continue;</span>
<span class="line-added">1282     }</span>
<span class="line-added">1283 #endif // INCLUDE_JVMCI || INCLUDE_AOT</span>
1284     if (k-&gt;is_instance_klass()) {
1285       InstanceKlass* ik = InstanceKlass::cast(k);
1286       reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);
1287     } else if (k-&gt;is_typeArray_klass()) {
1288       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1289       reassign_type_array_elements(fr, reg_map, sv, (typeArrayOop) obj(), ak-&gt;element_type());
1290     } else if (k-&gt;is_objArray_klass()) {
1291       reassign_object_array_elements(fr, reg_map, sv, (objArrayOop) obj());
1292     }
1293   }
1294 }
1295 
1296 
1297 // relock objects for which synchronization was eliminated
1298 void Deoptimization::relock_objects(GrowableArray&lt;MonitorInfo*&gt;* monitors, JavaThread* thread, bool realloc_failures) {
1299   for (int i = 0; i &lt; monitors-&gt;length(); i++) {
1300     MonitorInfo* mon_info = monitors-&gt;at(i);
1301     if (mon_info-&gt;eliminated()) {
1302       assert(!mon_info-&gt;owner_is_scalar_replaced() || realloc_failures, &quot;reallocation was missed&quot;);
1303       if (!mon_info-&gt;owner_is_scalar_replaced()) {
1304         Handle obj(thread, mon_info-&gt;owner());
<span class="line-modified">1305         markWord mark = obj-&gt;mark();</span>
<span class="line-modified">1306         if (UseBiasedLocking &amp;&amp; mark.has_bias_pattern()) {</span>
1307           // New allocated objects may have the mark set to anonymously biased.
1308           // Also the deoptimized method may called methods with synchronization
1309           // where the thread-local object is bias locked to the current thread.
<span class="line-modified">1310           assert(mark.is_biased_anonymously() ||</span>
<span class="line-modified">1311                  mark.biased_locker() == thread, &quot;should be locked to current thread&quot;);</span>
1312           // Reset mark word to unbiased prototype.
<span class="line-modified">1313           markWord unbiased_prototype = markWord::prototype().set_age(mark.age());</span>
1314           obj-&gt;set_mark(unbiased_prototype);
1315         }
1316         BasicLock* lock = mon_info-&gt;lock();
<span class="line-modified">1317         ObjectSynchronizer::enter(obj, lock, thread);</span>
1318         assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
1319       }
1320     }
1321   }
1322 }
1323 
1324 
1325 #ifndef PRODUCT
1326 // print information about reallocated objects
1327 void Deoptimization::print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures) {
1328   fieldDescriptor fd;
1329 
1330   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1331     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1332     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1333     Handle obj = sv-&gt;value();
1334 
1335     tty-&gt;print(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; of type &quot;, p2i(sv-&gt;value()()));
1336     k-&gt;print_value();
1337     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1338     if (obj.is_null()) {
1339       tty-&gt;print(&quot; allocation failed&quot;);
1340     } else {
1341       tty-&gt;print(&quot; allocated (%d bytes)&quot;, obj-&gt;size() * HeapWordSize);
1342     }
1343     tty-&gt;cr();
1344 
1345     if (Verbose &amp;&amp; !obj.is_null()) {
1346       k-&gt;oop_print_on(obj(), tty);
1347     }
1348   }
1349 }
1350 #endif
1351 #endif // COMPILER2_OR_JVMCI
1352 
1353 vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
<span class="line-modified">1354   Events::log_deopt_message(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));</span>
1355 
1356 #ifndef PRODUCT
1357   if (PrintDeoptimizationDetails) {
1358     ttyLocker ttyl;
1359     tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
1360     fr.print_on(tty);
1361     tty-&gt;print_cr(&quot;     Virtual frames (innermost first):&quot;);
1362     for (int index = 0; index &lt; chunk-&gt;length(); index++) {
1363       compiledVFrame* vf = chunk-&gt;at(index);
1364       tty-&gt;print(&quot;       %2d - &quot;, index);
1365       vf-&gt;print_value();
1366       int bci = chunk-&gt;at(index)-&gt;raw_bci();
1367       const char* code_name;
1368       if (bci == SynchronizationEntryBCI) {
1369         code_name = &quot;sync entry&quot;;
1370       } else {
1371         Bytecodes::Code code = vf-&gt;method()-&gt;code_at(bci);
1372         code_name = Bytecodes::name(code);
1373       }
1374       tty-&gt;print(&quot; - %s&quot;, code_name);
</pre>
<hr />
<pre>
1407 
1408   return array;
1409 }
1410 
1411 #if COMPILER2_OR_JVMCI
1412 void Deoptimization::pop_frames_failed_reallocs(JavaThread* thread, vframeArray* array) {
1413   // Reallocation of some scalar replaced objects failed. Record
1414   // that we need to pop all the interpreter frames for the
1415   // deoptimized compiled frame.
1416   assert(thread-&gt;frames_to_pop_failed_realloc() == 0, &quot;missed frames to pop?&quot;);
1417   thread-&gt;set_frames_to_pop_failed_realloc(array-&gt;frames());
1418   // Unlock all monitors here otherwise the interpreter will see a
1419   // mix of locked and unlocked monitors (because of failed
1420   // reallocations of synchronized objects) and be confused.
1421   for (int i = 0; i &lt; array-&gt;frames(); i++) {
1422     MonitorChunk* monitors = array-&gt;element(i)-&gt;monitors();
1423     if (monitors != NULL) {
1424       for (int j = 0; j &lt; monitors-&gt;number_of_monitors(); j++) {
1425         BasicObjectLock* src = monitors-&gt;at(j);
1426         if (src-&gt;obj() != NULL) {
<span class="line-modified">1427           ObjectSynchronizer::exit(src-&gt;obj(), src-&gt;lock(), thread);</span>
1428         }
1429       }
1430       array-&gt;element(i)-&gt;free_monitors(thread);
1431 #ifdef ASSERT
1432       array-&gt;element(i)-&gt;set_removed_monitors();
1433 #endif
1434     }
1435   }
1436 }
1437 #endif
1438 
1439 static void collect_monitors(compiledVFrame* cvf, GrowableArray&lt;Handle&gt;* objects_to_revoke) {
1440   GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
1441   Thread* thread = Thread::current();
1442   for (int i = 0; i &lt; monitors-&gt;length(); i++) {
1443     MonitorInfo* mon_info = monitors-&gt;at(i);
1444     if (!mon_info-&gt;eliminated() &amp;&amp; mon_info-&gt;owner() != NULL) {
1445       objects_to_revoke-&gt;append(Handle(thread, mon_info-&gt;owner()));
1446     }
1447   }
1448 }
1449 
<span class="line-modified">1450 static void get_monitors_from_stack(GrowableArray&lt;Handle&gt;* objects_to_revoke, JavaThread* thread, frame fr, RegisterMap* map) {</span>







1451   // Unfortunately we don&#39;t have a RegisterMap available in most of
1452   // the places we want to call this routine so we need to walk the
1453   // stack again to update the register map.
1454   if (map == NULL || !map-&gt;update_map()) {
1455     StackFrameStream sfs(thread, true);
1456     bool found = false;
1457     while (!found &amp;&amp; !sfs.is_done()) {
1458       frame* cur = sfs.current();
1459       sfs.next();
1460       found = cur-&gt;id() == fr.id();
1461     }
1462     assert(found, &quot;frame to be deoptimized not found on target thread&#39;s stack&quot;);
1463     map = sfs.register_map();
1464   }
1465 
1466   vframe* vf = vframe::new_vframe(&amp;fr, map, thread);
1467   compiledVFrame* cvf = compiledVFrame::cast(vf);
1468   // Revoke monitors&#39; biases in all scopes
1469   while (!cvf-&gt;is_top()) {
1470     collect_monitors(cvf, objects_to_revoke);
1471     cvf = compiledVFrame::cast(cvf-&gt;sender());
1472   }
1473   collect_monitors(cvf, objects_to_revoke);
<span class="line-added">1474 }</span>
1475 
<span class="line-modified">1476 void Deoptimization::revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map) {</span>
<span class="line-modified">1477   if (!UseBiasedLocking) {</span>
<span class="line-modified">1478     return;</span>
<span class="line-modified">1479   }</span>
<span class="line-added">1480   GrowableArray&lt;Handle&gt;* objects_to_revoke = new GrowableArray&lt;Handle&gt;();</span>
<span class="line-added">1481   get_monitors_from_stack(objects_to_revoke, thread, fr, map);</span>
<span class="line-added">1482 </span>
<span class="line-added">1483   int len = objects_to_revoke-&gt;length();</span>
<span class="line-added">1484   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-added">1485     oop obj = (objects_to_revoke-&gt;at(i))();</span>
<span class="line-added">1486     BiasedLocking::revoke_own_lock(objects_to_revoke-&gt;at(i), thread);</span>
<span class="line-added">1487     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);</span>
1488   }
1489 }
1490 
1491 
1492 void Deoptimization::deoptimize_single_frame(JavaThread* thread, frame fr, Deoptimization::DeoptReason reason) {
1493   assert(fr.can_be_deoptimized(), &quot;checking frame type&quot;);
1494 
1495   gather_statistics(reason, Action_none, Bytecodes::_illegal);
1496 
1497   if (LogCompilation &amp;&amp; xtty != NULL) {
1498     CompiledMethod* cm = fr.cb()-&gt;as_compiled_method_or_null();
1499     assert(cm != NULL, &quot;only compiled methods can deopt&quot;);
1500 
1501     ttyLocker ttyl;
1502     xtty-&gt;begin_head(&quot;deoptimized thread=&#39;&quot; UINTX_FORMAT &quot;&#39; reason=&#39;%s&#39; pc=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;,(uintx)thread-&gt;osthread()-&gt;thread_id(), trap_reason_name(reason), p2i(fr.pc()));
1503     cm-&gt;log_identity(xtty);
1504     xtty-&gt;end_head();
1505     for (ScopeDesc* sd = cm-&gt;scope_desc_at(fr.pc()); ; sd = sd-&gt;sender()) {
1506       xtty-&gt;begin_elem(&quot;jvms bci=&#39;%d&#39;&quot;, sd-&gt;bci());
1507       xtty-&gt;method(sd-&gt;method());
1508       xtty-&gt;end_elem();
1509       if (sd-&gt;is_top())  break;
1510     }
1511     xtty-&gt;tail(&quot;deoptimized&quot;);
1512   }
1513 
1514   // Patch the compiled method so that when execution returns to it we will
1515   // deopt the execution state and return to the interpreter.
1516   fr.deoptimize(thread);
1517 }
1518 
<span class="line-modified">1519 void Deoptimization::deoptimize(JavaThread* thread, frame fr, DeoptReason reason) {</span>




1520   // Deoptimize only if the frame comes from compile code.
1521   // Do not deoptimize the frame which is already patched
1522   // during the execution of the loops below.
1523   if (!fr.is_compiled_frame() || fr.is_deoptimized_frame()) {
1524     return;
1525   }
1526   ResourceMark rm;
1527   DeoptimizationMarker dm;



1528   deoptimize_single_frame(thread, fr, reason);

1529 }
1530 
1531 #if INCLUDE_JVMCI
1532 address Deoptimization::deoptimize_for_missing_exception_handler(CompiledMethod* cm) {
1533   // there is no exception handler for this pc =&gt; deoptimize
1534   cm-&gt;make_not_entrant();
1535 
1536   // Use Deoptimization::deoptimize for all of its side-effects:
<span class="line-modified">1537   // gathering traps statistics, logging...</span>
1538   // it also patches the return pc but we do not care about that
1539   // since we return a continuation to the deopt_blob below.
1540   JavaThread* thread = JavaThread::current();
<span class="line-modified">1541   RegisterMap reg_map(thread, false);</span>
1542   frame runtime_frame = thread-&gt;last_frame();
1543   frame caller_frame = runtime_frame.sender(&amp;reg_map);
1544   assert(caller_frame.cb()-&gt;as_compiled_method_or_null() == cm, &quot;expect top frame compiled method&quot;);
<span class="line-modified">1545   Deoptimization::deoptimize(thread, caller_frame, Deoptimization::Reason_not_compiled_exception_handler);</span>
1546 
<span class="line-modified">1547   MethodData* trap_mdo = get_method_data(thread, methodHandle(thread, cm-&gt;method()), true);</span>
1548   if (trap_mdo != NULL) {
1549     trap_mdo-&gt;inc_trap_count(Deoptimization::Reason_not_compiled_exception_handler);
1550   }
1551 
1552   return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
1553 }
1554 #endif
1555 
1556 void Deoptimization::deoptimize_frame_internal(JavaThread* thread, intptr_t* id, DeoptReason reason) {
1557   assert(thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),
1558          &quot;can only deoptimize other thread at a safepoint&quot;);
1559   // Compute frame and register map based on thread and sp.
<span class="line-modified">1560   RegisterMap reg_map(thread, false);</span>
1561   frame fr = thread-&gt;last_frame();
1562   while (fr.id() != id) {
1563     fr = fr.sender(&amp;reg_map);
1564   }
<span class="line-modified">1565   deoptimize(thread, fr, reason);</span>
1566 }
1567 
1568 
1569 void Deoptimization::deoptimize_frame(JavaThread* thread, intptr_t* id, DeoptReason reason) {
1570   if (thread == Thread::current()) {
1571     Deoptimization::deoptimize_frame_internal(thread, id, reason);
1572   } else {
1573     VM_DeoptimizeFrame deopt(thread, id, reason);
1574     VMThread::execute(&amp;deopt);
1575   }
1576 }
1577 
1578 void Deoptimization::deoptimize_frame(JavaThread* thread, intptr_t* id) {
1579   deoptimize_frame(thread, id, Reason_constraint);
1580 }
1581 
1582 // JVMTI PopFrame support
1583 JRT_LEAF(void, Deoptimization::popframe_preserve_args(JavaThread* thread, int bytes_to_save, void* start_address))
1584 {
1585   thread-&gt;popframe_preserve_args(in_ByteSize(bytes_to_save), start_address);
</pre>
<hr />
<pre>
1589 MethodData*
1590 Deoptimization::get_method_data(JavaThread* thread, const methodHandle&amp; m,
1591                                 bool create_if_missing) {
1592   Thread* THREAD = thread;
1593   MethodData* mdo = m()-&gt;method_data();
1594   if (mdo == NULL &amp;&amp; create_if_missing &amp;&amp; !HAS_PENDING_EXCEPTION) {
1595     // Build an MDO.  Ignore errors like OutOfMemory;
1596     // that simply means we won&#39;t have an MDO to update.
1597     Method::build_interpreter_method_data(m, THREAD);
1598     if (HAS_PENDING_EXCEPTION) {
1599       assert((PENDING_EXCEPTION-&gt;is_a(SystemDictionary::OutOfMemoryError_klass())), &quot;we expect only an OOM error here&quot;);
1600       CLEAR_PENDING_EXCEPTION;
1601     }
1602     mdo = m()-&gt;method_data();
1603   }
1604   return mdo;
1605 }
1606 
1607 #if COMPILER2_OR_JVMCI
1608 void Deoptimization::load_class_by_index(const constantPoolHandle&amp; constant_pool, int index, TRAPS) {
<span class="line-modified">1609   // In case of an unresolved klass entry, load the class.</span>
<span class="line-added">1610   // This path is exercised from case _ldc in Parse::do_one_bytecode,</span>
<span class="line-added">1611   // and probably nowhere else.</span>
<span class="line-added">1612   // Even that case would benefit from simply re-interpreting the</span>
<span class="line-added">1613   // bytecode, without paying special attention to the class index.</span>
<span class="line-added">1614   // So this whole &quot;class index&quot; feature should probably be removed.</span>
<span class="line-added">1615 </span>
1616   if (constant_pool-&gt;tag_at(index).is_unresolved_klass()) {
1617     Klass* tk = constant_pool-&gt;klass_at_ignore_error(index, CHECK);
1618     return;
1619   }
1620 
<span class="line-modified">1621   assert(!constant_pool-&gt;tag_at(index).is_symbol(),</span>
<span class="line-modified">1622          &quot;no symbolic names here, please&quot;);</span>



















1623 }
1624 
1625 
1626 void Deoptimization::load_class_by_index(const constantPoolHandle&amp; constant_pool, int index) {
1627   EXCEPTION_MARK;
1628   load_class_by_index(constant_pool, index, THREAD);
1629   if (HAS_PENDING_EXCEPTION) {
1630     // Exception happened during classloading. We ignore the exception here, since it
1631     // is going to be rethrown since the current activation is going to be deoptimized and
1632     // the interpreter will re-execute the bytecode.
1633     CLEAR_PENDING_EXCEPTION;
1634     // Class loading called java code which may have caused a stack
1635     // overflow. If the exception was thrown right before the return
1636     // to the runtime the stack is no longer guarded. Reguard the
1637     // stack otherwise if we return to the uncommon trap blob and the
1638     // stack bang causes a stack overflow we crash.
1639     assert(THREAD-&gt;is_Java_thread(), &quot;only a java thread can be here&quot;);
1640     JavaThread* thread = (JavaThread*)THREAD;
1641     bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
1642     if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
1643     assert(guard_pages_enabled, &quot;stack banging in uncommon trap blob may cause crash&quot;);
1644   }
1645 }
1646 
<span class="line-added">1647 #if INCLUDE_JFR</span>
<span class="line-added">1648 </span>
<span class="line-added">1649 class DeoptReasonSerializer : public JfrSerializer {</span>
<span class="line-added">1650  public:</span>
<span class="line-added">1651   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">1652     writer.write_count((u4)(Deoptimization::Reason_LIMIT + 1)); // + Reason::many (-1)</span>
<span class="line-added">1653     for (int i = -1; i &lt; Deoptimization::Reason_LIMIT; ++i) {</span>
<span class="line-added">1654       writer.write_key((u8)i);</span>
<span class="line-added">1655       writer.write(Deoptimization::trap_reason_name(i));</span>
<span class="line-added">1656     }</span>
<span class="line-added">1657   }</span>
<span class="line-added">1658 };</span>
<span class="line-added">1659 </span>
<span class="line-added">1660 class DeoptActionSerializer : public JfrSerializer {</span>
<span class="line-added">1661  public:</span>
<span class="line-added">1662   void serialize(JfrCheckpointWriter&amp; writer) {</span>
<span class="line-added">1663     static const u4 nof_actions = Deoptimization::Action_LIMIT;</span>
<span class="line-added">1664     writer.write_count(nof_actions);</span>
<span class="line-added">1665     for (u4 i = 0; i &lt; Deoptimization::Action_LIMIT; ++i) {</span>
<span class="line-added">1666       writer.write_key(i);</span>
<span class="line-added">1667       writer.write(Deoptimization::trap_action_name((int)i));</span>
<span class="line-added">1668     }</span>
<span class="line-added">1669   }</span>
<span class="line-added">1670 };</span>
<span class="line-added">1671 </span>
<span class="line-added">1672 static void register_serializers() {</span>
<span class="line-added">1673   static int critical_section = 0;</span>
<span class="line-added">1674   if (1 == critical_section || Atomic::cmpxchg(&amp;critical_section, 0, 1) == 1) {</span>
<span class="line-added">1675     return;</span>
<span class="line-added">1676   }</span>
<span class="line-added">1677   JfrSerializer::register_serializer(TYPE_DEOPTIMIZATIONREASON, true, new DeoptReasonSerializer());</span>
<span class="line-added">1678   JfrSerializer::register_serializer(TYPE_DEOPTIMIZATIONACTION, true, new DeoptActionSerializer());</span>
<span class="line-added">1679 }</span>
<span class="line-added">1680 </span>
<span class="line-added">1681 static void post_deoptimization_event(CompiledMethod* nm,</span>
<span class="line-added">1682                                       const Method* method,</span>
<span class="line-added">1683                                       int trap_bci,</span>
<span class="line-added">1684                                       int instruction,</span>
<span class="line-added">1685                                       Deoptimization::DeoptReason reason,</span>
<span class="line-added">1686                                       Deoptimization::DeoptAction action) {</span>
<span class="line-added">1687   assert(nm != NULL, &quot;invariant&quot;);</span>
<span class="line-added">1688   assert(method != NULL, &quot;invariant&quot;);</span>
<span class="line-added">1689   if (EventDeoptimization::is_enabled()) {</span>
<span class="line-added">1690     static bool serializers_registered = false;</span>
<span class="line-added">1691     if (!serializers_registered) {</span>
<span class="line-added">1692       register_serializers();</span>
<span class="line-added">1693       serializers_registered = true;</span>
<span class="line-added">1694     }</span>
<span class="line-added">1695     EventDeoptimization event;</span>
<span class="line-added">1696     event.set_compileId(nm-&gt;compile_id());</span>
<span class="line-added">1697     event.set_compiler(nm-&gt;compiler_type());</span>
<span class="line-added">1698     event.set_method(method);</span>
<span class="line-added">1699     event.set_lineNumber(method-&gt;line_number_from_bci(trap_bci));</span>
<span class="line-added">1700     event.set_bci(trap_bci);</span>
<span class="line-added">1701     event.set_instruction(instruction);</span>
<span class="line-added">1702     event.set_reason(reason);</span>
<span class="line-added">1703     event.set_action(action);</span>
<span class="line-added">1704     event.commit();</span>
<span class="line-added">1705   }</span>
<span class="line-added">1706 }</span>
<span class="line-added">1707 </span>
<span class="line-added">1708 #endif // INCLUDE_JFR</span>
<span class="line-added">1709 </span>
1710 JRT_ENTRY(void, Deoptimization::uncommon_trap_inner(JavaThread* thread, jint trap_request)) {
1711   HandleMark hm;
1712 
1713   // uncommon_trap() is called at the beginning of the uncommon trap
1714   // handler. Note this fact before we start generating temporary frames
1715   // that can confuse an asynchronous stack walker. This counter is
1716   // decremented at the end of unpack_frames().
1717   thread-&gt;inc_in_deopt_handler();
1718 
1719   // We need to update the map if we have biased locking.
1720 #if INCLUDE_JVMCI
1721   // JVMCI might need to get an exception from the stack, which in turn requires the register map to be valid
1722   RegisterMap reg_map(thread, true);
1723 #else
1724   RegisterMap reg_map(thread, UseBiasedLocking);
1725 #endif
1726   frame stub_frame = thread-&gt;last_frame();
1727   frame fr = stub_frame.sender(&amp;reg_map);
1728   // Make sure the calling nmethod is not getting deoptimized and removed
1729   // before we are done with it.
1730   nmethodLocker nl(fr.pc());
1731 
1732   // Log a message
<span class="line-modified">1733   Events::log_deopt_message(thread, &quot;Uncommon trap: trap_request=&quot; PTR32_FORMAT &quot; fr.pc=&quot; INTPTR_FORMAT &quot; relative=&quot; INTPTR_FORMAT,</span>
1734               trap_request, p2i(fr.pc()), fr.pc() - fr.cb()-&gt;code_begin());
1735 
1736   {
1737     ResourceMark rm;
1738 



1739     DeoptReason reason = trap_request_reason(trap_request);
1740     DeoptAction action = trap_request_action(trap_request);
1741 #if INCLUDE_JVMCI
1742     int debug_id = trap_request_debug_id(trap_request);
1743 #endif
1744     jint unloaded_class_index = trap_request_index(trap_request); // CP idx or -1
1745 
1746     vframe*  vf  = vframe::new_vframe(&amp;fr, &amp;reg_map, thread);
1747     compiledVFrame* cvf = compiledVFrame::cast(vf);
1748 
1749     CompiledMethod* nm = cvf-&gt;code();
1750 
1751     ScopeDesc*      trap_scope  = cvf-&gt;scope();
1752 
1753     if (TraceDeoptimization) {
1754       ttyLocker ttyl;
1755       tty-&gt;print_cr(&quot;  bci=%d pc=&quot; INTPTR_FORMAT &quot;, relative_pc=&quot; INTPTR_FORMAT &quot;, method=%s&quot; JVMCI_ONLY(&quot;, debug_id=%d&quot;), trap_scope-&gt;bci(), p2i(fr.pc()), fr.pc() - nm-&gt;code_begin(), trap_scope-&gt;method()-&gt;name_and_sig_as_C_string()
1756 #if INCLUDE_JVMCI
1757           , debug_id
1758 #endif
1759           );
1760     }
1761 
<span class="line-modified">1762     methodHandle    trap_method(THREAD, trap_scope-&gt;method());</span>
1763     int             trap_bci    = trap_scope-&gt;bci();
1764 #if INCLUDE_JVMCI
<span class="line-modified">1765     jlong           speculation = thread-&gt;pending_failed_speculation();</span>
<span class="line-modified">1766     if (nm-&gt;is_compiled_by_jvmci() &amp;&amp; nm-&gt;is_nmethod()) { // Exclude AOTed methods</span>
<span class="line-modified">1767       nm-&gt;as_nmethod()-&gt;update_speculation(thread);</span>






















1768     } else {
<span class="line-modified">1769       assert(speculation == 0, &quot;There should not be a speculation for methods compiled by non-JVMCI compilers&quot;);</span>
1770     }
1771 
1772     if (trap_bci == SynchronizationEntryBCI) {
1773       trap_bci = 0;
1774       thread-&gt;set_pending_monitorenter(true);
1775     }
1776 
1777     if (reason == Deoptimization::Reason_transfer_to_interpreter) {
1778       thread-&gt;set_pending_transfer_to_interpreter(true);
1779     }
1780 #endif
1781 
1782     Bytecodes::Code trap_bc     = trap_method-&gt;java_code_at(trap_bci);
1783     // Record this event in the histogram.
1784     gather_statistics(reason, action, trap_bc);
1785 
1786     // Ensure that we can record deopt. history:
1787     // Need MDO to record RTM code generation state.
1788     bool create_if_missing = ProfileTraps || UseCodeAging RTM_OPT_ONLY( || UseRTMLocking );
1789 
1790     methodHandle profiled_method;
1791 #if INCLUDE_JVMCI
1792     if (nm-&gt;is_compiled_by_jvmci()) {
<span class="line-modified">1793       profiled_method = methodHandle(THREAD, nm-&gt;method());</span>
1794     } else {
1795       profiled_method = trap_method;
1796     }
1797 #else
1798     profiled_method = trap_method;
1799 #endif
1800 
1801     MethodData* trap_mdo =
1802       get_method_data(thread, profiled_method, create_if_missing);
1803 
<span class="line-added">1804     JFR_ONLY(post_deoptimization_event(nm, trap_method(), trap_bci, trap_bc, reason, action);)</span>
<span class="line-added">1805 </span>
1806     // Log a message
1807     Events::log_deopt_message(thread, &quot;Uncommon trap: reason=%s action=%s pc=&quot; INTPTR_FORMAT &quot; method=%s @ %d %s&quot;,
1808                               trap_reason_name(reason), trap_action_name(action), p2i(fr.pc()),
1809                               trap_method-&gt;name_and_sig_as_C_string(), trap_bci, nm-&gt;compiler_name());
1810 
1811     // Print a bunch of diagnostics, if requested.
1812     if (TraceDeoptimization || LogCompilation) {
1813       ResourceMark rm;
1814       ttyLocker ttyl;
1815       char buf[100];
1816       if (xtty != NULL) {
1817         xtty-&gt;begin_head(&quot;uncommon_trap thread=&#39;&quot; UINTX_FORMAT &quot;&#39; %s&quot;,
1818                          os::current_thread_id(),
1819                          format_trap_request(buf, sizeof(buf), trap_request));
<span class="line-added">1820 #if INCLUDE_JVMCI</span>
<span class="line-added">1821         if (speculation != 0) {</span>
<span class="line-added">1822           xtty-&gt;print(&quot; speculation=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, speculation);</span>
<span class="line-added">1823         }</span>
<span class="line-added">1824 #endif</span>
1825         nm-&gt;log_identity(xtty);
1826       }
1827       Symbol* class_name = NULL;
1828       bool unresolved = false;
1829       if (unloaded_class_index &gt;= 0) {
1830         constantPoolHandle constants (THREAD, trap_method-&gt;constants());
1831         if (constants-&gt;tag_at(unloaded_class_index).is_unresolved_klass()) {
1832           class_name = constants-&gt;klass_name_at(unloaded_class_index);
1833           unresolved = true;
1834           if (xtty != NULL)
1835             xtty-&gt;print(&quot; unresolved=&#39;1&#39;&quot;);
1836         } else if (constants-&gt;tag_at(unloaded_class_index).is_symbol()) {
1837           class_name = constants-&gt;symbol_at(unloaded_class_index);
1838         }
1839         if (xtty != NULL)
1840           xtty-&gt;name(class_name);
1841       }
1842       if (xtty != NULL &amp;&amp; trap_mdo != NULL &amp;&amp; (int)reason &lt; (int)MethodData::_trap_hist_limit) {
1843         // Dump the relevant MDO state.
1844         // This is the deopt count for the current reason, any previous
</pre>
<hr />
<pre>
1850         int dos = (pdata == NULL)? 0: pdata-&gt;trap_state();
1851         if (dos != 0) {
1852           xtty-&gt;print(&quot; state=&#39;%s&#39;&quot;, format_trap_state(buf, sizeof(buf), dos));
1853           if (trap_state_is_recompiled(dos)) {
1854             int recnt2 = trap_mdo-&gt;overflow_recompile_count();
1855             if (recnt2 != 0)
1856               xtty-&gt;print(&quot; recompiles2=&#39;%d&#39;&quot;, recnt2);
1857           }
1858         }
1859       }
1860       if (xtty != NULL) {
1861         xtty-&gt;stamp();
1862         xtty-&gt;end_head();
1863       }
1864       if (TraceDeoptimization) {  // make noise on the tty
1865         tty-&gt;print(&quot;Uncommon trap occurred in&quot;);
1866         nm-&gt;method()-&gt;print_short_name(tty);
1867         tty-&gt;print(&quot; compiler=%s compile_id=%d&quot;, nm-&gt;compiler_name(), nm-&gt;compile_id());
1868 #if INCLUDE_JVMCI
1869         if (nm-&gt;is_nmethod()) {
<span class="line-modified">1870           const char* installed_code_name = nm-&gt;as_nmethod()-&gt;jvmci_name();</span>
1871           if (installed_code_name != NULL) {
1872             tty-&gt;print(&quot; (JVMCI: installed code name=%s) &quot;, installed_code_name);
1873           }
1874         }
1875 #endif
1876         tty-&gt;print(&quot; (@&quot; INTPTR_FORMAT &quot;) thread=&quot; UINTX_FORMAT &quot; reason=%s action=%s unloaded_class_index=%d&quot; JVMCI_ONLY(&quot; debug_id=%d&quot;),
1877                    p2i(fr.pc()),
1878                    os::current_thread_id(),
1879                    trap_reason_name(reason),
1880                    trap_action_name(action),
1881                    unloaded_class_index
1882 #if INCLUDE_JVMCI
1883                    , debug_id
1884 #endif
1885                    );
1886         if (class_name != NULL) {
1887           tty-&gt;print(unresolved ? &quot; unresolved class: &quot; : &quot; symbol: &quot;);
1888           class_name-&gt;print_symbol_on(tty);
1889         }
1890         tty-&gt;cr();
</pre>
<hr />
<pre>
2112       if ((reason != Reason_rtm_state_change) &amp;&amp; (trap_mdo != NULL) &amp;&amp;
2113           UseRTMDeopt &amp;&amp; (nm-&gt;as_nmethod()-&gt;rtm_state() != ProfileRTM)) {
2114         trap_mdo-&gt;atomic_set_rtm_state(ProfileRTM);
2115       }
2116 #endif
2117       // For code aging we count traps separately here, using make_not_entrant()
2118       // as a guard against simultaneous deopts in multiple threads.
2119       if (reason == Reason_tenured &amp;&amp; trap_mdo != NULL) {
2120         trap_mdo-&gt;inc_tenure_traps();
2121       }
2122     }
2123 
2124     if (inc_recompile_count) {
2125       trap_mdo-&gt;inc_overflow_recompile_count();
2126       if ((uint)trap_mdo-&gt;overflow_recompile_count() &gt;
2127           (uint)PerBytecodeRecompilationCutoff) {
2128         // Give up on the method containing the bad BCI.
2129         if (trap_method() == nm-&gt;method()) {
2130           make_not_compilable = true;
2131         } else {
<span class="line-modified">2132           trap_method-&gt;set_not_compilable(&quot;overflow_recompile_count &gt; PerBytecodeRecompilationCutoff&quot;, CompLevel_full_optimization);</span>
2133           // But give grace to the enclosing nm-&gt;method().
2134         }
2135       }
2136     }
2137 
2138     // Reprofile
2139     if (reprofile) {
2140       CompilationPolicy::policy()-&gt;reprofile(trap_scope, nm-&gt;is_osr_method());
2141     }
2142 
2143     // Give up compiling
2144     if (make_not_compilable &amp;&amp; !nm-&gt;method()-&gt;is_not_compilable(CompLevel_full_optimization)) {
2145       assert(make_not_entrant, &quot;consistent&quot;);
<span class="line-modified">2146       nm-&gt;method()-&gt;set_not_compilable(&quot;give up compiling&quot;, CompLevel_full_optimization);</span>
2147     }
2148 
2149   } // Free marked resources
2150 
2151 }
2152 JRT_END
2153 
2154 ProfileData*
2155 Deoptimization::query_update_method_data(MethodData* trap_mdo,
2156                                          int trap_bci,
2157                                          Deoptimization::DeoptReason reason,
2158                                          bool update_total_trap_count,
2159 #if INCLUDE_JVMCI
2160                                          bool is_osr,
2161 #endif
2162                                          Method* compiled_method,
2163                                          //outputs:
2164                                          uint&amp; ret_this_trap_count,
2165                                          bool&amp; ret_maybe_prior_trap,
2166                                          bool&amp; ret_maybe_prior_recompile) {
</pre>
<hr />
<pre>
2356                        recomp_flag ? &quot; recompiled&quot; : &quot;&quot;);
2357   }
2358   return buf;
2359 }
2360 
2361 
2362 //--------------------------------statics--------------------------------------
2363 const char* Deoptimization::_trap_reason_name[] = {
2364   // Note:  Keep this in sync. with enum DeoptReason.
2365   &quot;none&quot;,
2366   &quot;null_check&quot;,
2367   &quot;null_assert&quot; JVMCI_ONLY(&quot;_or_unreached0&quot;),
2368   &quot;range_check&quot;,
2369   &quot;class_check&quot;,
2370   &quot;array_check&quot;,
2371   &quot;intrinsic&quot; JVMCI_ONLY(&quot;_or_type_checked_inlining&quot;),
2372   &quot;bimorphic&quot; JVMCI_ONLY(&quot;_or_optimized_type_check&quot;),
2373   &quot;profile_predicate&quot;,
2374   &quot;unloaded&quot;,
2375   &quot;uninitialized&quot;,
<span class="line-added">2376   &quot;initialized&quot;,</span>
2377   &quot;unreached&quot;,
2378   &quot;unhandled&quot;,
2379   &quot;constraint&quot;,
2380   &quot;div0_check&quot;,
2381   &quot;age&quot;,
2382   &quot;predicate&quot;,
2383   &quot;loop_limit_check&quot;,
2384   &quot;speculate_class_check&quot;,
2385   &quot;speculate_null_check&quot;,
2386   &quot;speculate_null_assert&quot;,
2387   &quot;rtm_state_change&quot;,
2388   &quot;unstable_if&quot;,
2389   &quot;unstable_fused_if&quot;,
2390 #if INCLUDE_JVMCI
2391   &quot;aliasing&quot;,
2392   &quot;transfer_to_interpreter&quot;,
2393   &quot;not_compiled_exception_handler&quot;,
2394   &quot;unresolved&quot;,
2395   &quot;jsr_mismatch&quot;,
2396 #endif
</pre>
</td>
</tr>
</table>
<center><a href="biasedLocking.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
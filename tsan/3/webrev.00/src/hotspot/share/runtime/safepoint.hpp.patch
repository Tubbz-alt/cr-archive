diff a/src/hotspot/share/runtime/safepoint.hpp b/src/hotspot/share/runtime/safepoint.hpp
--- a/src/hotspot/share/runtime/safepoint.hpp
+++ b/src/hotspot/share/runtime/safepoint.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -46,10 +46,18 @@
 // exit safepoint methods, when a thread is blocked/restarted. Hence, all mutex exter/
 // exit points *must* be at a safepoint.
 
 class ThreadSafepointState;
 
+class SafepointStateTracker {
+  uint64_t _safepoint_id;
+  bool     _at_safepoint;
+public:
+  SafepointStateTracker(uint64_t safepoint_id, bool at_safepoint);
+  bool safepoint_state_changed();
+};
+
 //
 // Implements roll-forward to safepoint (safepoint synchronization)
 //
 class SafepointSynchronize : AllStatic {
  public:
@@ -65,20 +73,21 @@
     SAFEPOINT_CLEANUP_DEFLATE_MONITORS,
     SAFEPOINT_CLEANUP_UPDATE_INLINE_CACHES,
     SAFEPOINT_CLEANUP_COMPILATION_POLICY,
     SAFEPOINT_CLEANUP_SYMBOL_TABLE_REHASH,
     SAFEPOINT_CLEANUP_STRING_TABLE_REHASH,
-    SAFEPOINT_CLEANUP_CLD_PURGE,
     SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE,
+    SAFEPOINT_CLEANUP_REQUEST_OOPSTORAGE_CLEANUP,
     // Leave this one last.
     SAFEPOINT_CLEANUP_NUM_TASKS
   };
 
  private:
   friend class SafepointMechanism;
   friend class ThreadSafepointState;
   friend class HandshakeState;
+  friend class SafepointStateTracker;
 
   // Threads might read this flag directly, without acquiring the Threads_lock:
   static volatile SynchronizeState _state;
   // Number of threads we are waiting for to block:
   static int              _waiting_to_block;
@@ -89,33 +98,30 @@
   // An even value means there are no ongoing safepoint operations.
   // The counter is incremented ONLY at the beginning and end of each
   // safepoint.
   static volatile uint64_t _safepoint_counter;
 
+  // A change in this counter or a change in the result of
+  // is_at_safepoint() are used by SafepointStateTracker::
+  // safepoint_state_changed() to determine its answer.
+  static uint64_t _safepoint_id;
+
   // JavaThreads that need to block for the safepoint will stop on the
   // _wait_barrier, where they can quickly be started again.
   static WaitBarrier* _wait_barrier;
-  static long         _end_of_last_safepoint;     // Time of last safepoint in milliseconds
   static julong       _coalesced_vmop_count;     // coalesced vmop count
 
-  // Statistics
-  static void begin_statistics(int nof_threads, int nof_running);
-  static void update_statistics_on_spin_end();
-  static void update_statistics_on_sync_end(jlong end_time);
-  static void update_statistics_on_cleanup_end(jlong end_time);
-  static void end_statistics(jlong end_time);
-  static void print_statistics();
-
   // For debug long safepoint
   static void print_safepoint_timeout();
 
   // Helper methods for safepoint procedure:
   static void arm_safepoint();
   static int synchronize_threads(jlong safepoint_limit_time, int nof_threads, int* initial_running);
   static void disarm_safepoint();
   static void increment_jni_active_count();
   static void decrement_waiting_to_block();
+  static bool thread_not_running(ThreadSafepointState *cur_state);
 
   // Used in safepoint_safe to do a stable load of the thread state.
   static bool try_stable_load_state(JavaThreadState *state,
                                     JavaThread *thread,
                                     uint64_t safepoint_count);
@@ -125,10 +131,12 @@
 
   // Called from VMThread during handshakes.
   // If true the VMThread may safely process the handshake operation for the JavaThread.
   static bool handshake_safe(JavaThread *thread);
 
+  static uint64_t safepoint_counter()             { return _safepoint_counter; }
+
 public:
 
   static void init(Thread* vmthread);
 
   // Roll all threads forward to safepoint. Must be called by the VMThread.
@@ -139,16 +147,24 @@
   static const uint64_t InactiveSafepointCounter;
 
   // Query
   static bool is_at_safepoint()                   { return _state == _synchronized; }
   static bool is_synchronizing()                  { return _state == _synchronizing; }
-  static uint64_t safepoint_counter()             { return _safepoint_counter; }
-  static bool is_same_safepoint(uint64_t counter) { return (SafepointSynchronize::safepoint_counter() - counter) < 2; }
+
+  static uint64_t safepoint_id() {
+    return _safepoint_id;
+  }
+
+  static SafepointStateTracker safepoint_state_tracker() {
+    return SafepointStateTracker(safepoint_id(), is_at_safepoint());
+  }
+
   // Exception handling for page polling
   static void handle_polling_page_exception(JavaThread *thread);
 
   static bool is_cleanup_needed();
+  static bool is_forced_cleanup_needed();
   static void do_cleanup_tasks();
 
   static void set_is_at_safepoint()             { _state = _synchronized; }
   static void set_is_not_at_safepoint()         { _state = _not_synchronized; }
 
@@ -188,11 +204,10 @@
   // At polling page safepoint (NOT a poll return safepoint):
   volatile bool                   _at_poll_safepoint;
   JavaThread*                     _thread;
   bool                            _safepoint_safe;
   volatile uint64_t               _safepoint_id;
-  JavaThreadState                 _orig_thread_state;
 
   ThreadSafepointState*           _next;
 
   void account_safe_thread();
 
@@ -214,21 +229,18 @@
 
   uint64_t get_safepoint_id() const;
   void     reset_safepoint_id();
   void     set_safepoint_id(uint64_t sid);
 
-  JavaThreadState orig_thread_state() const { return _orig_thread_state; }
-
   // Support for safepoint timeout (debugging)
   bool is_at_poll_safepoint()           { return _at_poll_safepoint; }
   void set_at_poll_safepoint(bool val)  { _at_poll_safepoint = val; }
 
   void handle_polling_page_exception();
 
   // debugging
   void print_on(outputStream* st) const;
-  void print() const                        { print_on(tty); }
 
   // Initialize
   static void create(JavaThread *thread);
   static void destroy(JavaThread *thread);
 };
@@ -238,12 +250,11 @@
   // Absolute
   static jlong _last_safepoint_begin_time_ns;
   static jlong _last_safepoint_sync_time_ns;
   static jlong _last_safepoint_cleanup_time_ns;
   static jlong _last_safepoint_end_time_ns;
-  // amount of ms since epoch
-  static jlong _last_safepoint_end_time_epoch_ms;
+
   // Relative
   static jlong _last_app_time_ns;
 
   static int _nof_threads;
   static int _nof_running;
@@ -265,15 +276,15 @@
   static void end();
 
   static void statistics_exit_log();
 
   static jlong time_since_last_safepoint_ms() {
-    return (os::javaTimeNanos() - _last_safepoint_end_time_ns) / (NANOUNITS / MILLIUNITS);
+    return nanos_to_millis(os::javaTimeNanos() - _last_safepoint_end_time_ns);
   }
 
-  static jlong end_of_last_safepoint_epoch_ms() {
-    return _last_safepoint_end_time_epoch_ms;
+  static jlong end_of_last_safepoint_ms() {
+    return nanos_to_millis(_last_safepoint_end_time_ns);
   }
 
   static jlong start_of_safepoint() {
     return _last_safepoint_begin_time_ns;
   }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.sql/share/classes/java/sql/PreparedStatement.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.sql;
  27 
  28 import java.math.BigDecimal;
  29 import java.util.Calendar;
  30 import java.io.Reader;
  31 import java.io.InputStream;
  32 
  33 /**
  34  * An object that represents a precompiled SQL statement.
  35  * &lt;P&gt;A SQL statement is precompiled and stored in a
  36  * &lt;code&gt;PreparedStatement&lt;/code&gt; object. This object can then be used to
  37  * efficiently execute this statement multiple times.
  38  *
  39  * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; The setter methods (&lt;code&gt;setShort&lt;/code&gt;, &lt;code&gt;setString&lt;/code&gt;,
  40  * and so on) for setting IN parameter values
  41  * must specify types that are compatible with the defined SQL type of
  42  * the input parameter. For instance, if the IN parameter has SQL type
  43  * &lt;code&gt;INTEGER&lt;/code&gt;, then the method &lt;code&gt;setInt&lt;/code&gt; should be used.
  44  *
  45  * &lt;p&gt;If arbitrary parameter type conversions are required, the method
  46  * &lt;code&gt;setObject&lt;/code&gt; should be used with a target SQL type.
  47  * &lt;P&gt;
  48  * In the following example of setting a parameter, &lt;code&gt;con&lt;/code&gt; represents
  49  * an active connection:
<a name="1" id="anc1"></a><span class="line-modified">  50  * &lt;pre&gt;{@code</span>
<span class="line-added">  51  *   BigDecimal sal = new BigDecimal(&quot;153833.00&quot;);</span>
  52  *   PreparedStatement pstmt = con.prepareStatement(&quot;UPDATE EMPLOYEES
  53  *                                     SET SALARY = ? WHERE ID = ?&quot;);
<a name="2" id="anc2"></a><span class="line-modified">  54  *   pstmt.setBigDecimal(1, sal);</span>
<span class="line-modified">  55  *   pstmt.setInt(2, 110592);</span>
<span class="line-modified">  56  * }&lt;/pre&gt;</span>
  57  *
  58  * @see Connection#prepareStatement
  59  * @see ResultSet
  60  * @since 1.1
  61  */
  62 
  63 public interface PreparedStatement extends Statement {
  64 
  65     /**
  66      * Executes the SQL query in this &lt;code&gt;PreparedStatement&lt;/code&gt; object
  67      * and returns the &lt;code&gt;ResultSet&lt;/code&gt; object generated by the query.
  68      *
  69      * @return a &lt;code&gt;ResultSet&lt;/code&gt; object that contains the data produced by the
  70      *         query; never &lt;code&gt;null&lt;/code&gt;
  71      * @exception SQLException if a database access error occurs;
  72      * this method is called on a closed  &lt;code&gt;PreparedStatement&lt;/code&gt; or the SQL
  73      *            statement does not return a &lt;code&gt;ResultSet&lt;/code&gt; object
  74      * @throws SQLTimeoutException when the driver has determined that the
  75      * timeout value that was specified by the {@code setQueryTimeout}
  76      * method has been exceeded and has at least attempted to cancel
  77      * the currently running {@code Statement}
  78      */
  79     ResultSet executeQuery() throws SQLException;
  80 
  81     /**
  82      * Executes the SQL statement in this &lt;code&gt;PreparedStatement&lt;/code&gt; object,
  83      * which must be an SQL Data Manipulation Language (DML) statement, such as &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or
  84      * &lt;code&gt;DELETE&lt;/code&gt;; or an SQL statement that returns nothing,
  85      * such as a DDL statement.
  86      *
  87      * @return either (1) the row count for SQL Data Manipulation Language (DML) statements
  88      *         or (2) 0 for SQL statements that return nothing
  89      * @exception SQLException if a database access error occurs;
  90      * this method is called on a closed  &lt;code&gt;PreparedStatement&lt;/code&gt;
  91      * or the SQL statement returns a &lt;code&gt;ResultSet&lt;/code&gt; object
  92      * @throws SQLTimeoutException when the driver has determined that the
  93      * timeout value that was specified by the {@code setQueryTimeout}
  94      * method has been exceeded and has at least attempted to cancel
  95      * the currently running {@code Statement}
  96      */
  97     int executeUpdate() throws SQLException;
  98 
  99     /**
 100      * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
 101      *
 102      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; You must specify the parameter&#39;s SQL type.
 103      *
 104      * @param parameterIndex the first parameter is 1, the second is 2, ...
 105      * @param sqlType the SQL type code defined in &lt;code&gt;java.sql.Types&lt;/code&gt;
 106      * @exception SQLException if parameterIndex does not correspond to a parameter
 107      * marker in the SQL statement; if a database access error occurs or
 108      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 109      * @exception SQLFeatureNotSupportedException if &lt;code&gt;sqlType&lt;/code&gt; is
 110      * a &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;,
 111      * &lt;code&gt;DATALINK&lt;/code&gt;, &lt;code&gt;JAVA_OBJECT&lt;/code&gt;, &lt;code&gt;NCHAR&lt;/code&gt;,
 112      * &lt;code&gt;NCLOB&lt;/code&gt;, &lt;code&gt;NVARCHAR&lt;/code&gt;, &lt;code&gt;LONGNVARCHAR&lt;/code&gt;,
 113      *  &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;ROWID&lt;/code&gt;, &lt;code&gt;SQLXML&lt;/code&gt;
 114      * or  &lt;code&gt;STRUCT&lt;/code&gt; data type and the JDBC driver does not support
 115      * this data type
 116      */
 117     void setNull(int parameterIndex, int sqlType) throws SQLException;
 118 
 119     /**
 120      * Sets the designated parameter to the given Java &lt;code&gt;boolean&lt;/code&gt; value.
 121      * The driver converts this
 122      * to an SQL &lt;code&gt;BIT&lt;/code&gt; or &lt;code&gt;BOOLEAN&lt;/code&gt; value when it sends it to the database.
 123      *
 124      * @param parameterIndex the first parameter is 1, the second is 2, ...
 125      * @param x the parameter value
 126      * @exception SQLException if parameterIndex does not correspond to a parameter
 127      * marker in the SQL statement;
 128      * if a database access error occurs or
 129      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 130      */
 131     void setBoolean(int parameterIndex, boolean x) throws SQLException;
 132 
 133     /**
 134      * Sets the designated parameter to the given Java &lt;code&gt;byte&lt;/code&gt; value.
 135      * The driver converts this
 136      * to an SQL &lt;code&gt;TINYINT&lt;/code&gt; value when it sends it to the database.
 137      *
 138      * @param parameterIndex the first parameter is 1, the second is 2, ...
 139      * @param x the parameter value
 140      * @exception SQLException if parameterIndex does not correspond to a parameter
 141      * marker in the SQL statement; if a database access error occurs or
 142      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 143      */
 144     void setByte(int parameterIndex, byte x) throws SQLException;
 145 
 146     /**
 147      * Sets the designated parameter to the given Java &lt;code&gt;short&lt;/code&gt; value.
 148      * The driver converts this
 149      * to an SQL &lt;code&gt;SMALLINT&lt;/code&gt; value when it sends it to the database.
 150      *
 151      * @param parameterIndex the first parameter is 1, the second is 2, ...
 152      * @param x the parameter value
 153      * @exception SQLException if parameterIndex does not correspond to a parameter
 154      * marker in the SQL statement; if a database access error occurs or
 155      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 156      */
 157     void setShort(int parameterIndex, short x) throws SQLException;
 158 
 159     /**
 160      * Sets the designated parameter to the given Java &lt;code&gt;int&lt;/code&gt; value.
 161      * The driver converts this
 162      * to an SQL &lt;code&gt;INTEGER&lt;/code&gt; value when it sends it to the database.
 163      *
 164      * @param parameterIndex the first parameter is 1, the second is 2, ...
 165      * @param x the parameter value
 166      * @exception SQLException if parameterIndex does not correspond to a parameter
 167      * marker in the SQL statement; if a database access error occurs or
 168      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 169      */
 170     void setInt(int parameterIndex, int x) throws SQLException;
 171 
 172     /**
 173      * Sets the designated parameter to the given Java &lt;code&gt;long&lt;/code&gt; value.
 174      * The driver converts this
 175      * to an SQL &lt;code&gt;BIGINT&lt;/code&gt; value when it sends it to the database.
 176      *
 177      * @param parameterIndex the first parameter is 1, the second is 2, ...
 178      * @param x the parameter value
 179      * @exception SQLException if parameterIndex does not correspond to a parameter
 180      * marker in the SQL statement; if a database access error occurs or
 181      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 182      */
 183     void setLong(int parameterIndex, long x) throws SQLException;
 184 
 185     /**
 186      * Sets the designated parameter to the given Java &lt;code&gt;float&lt;/code&gt; value.
 187      * The driver converts this
 188      * to an SQL &lt;code&gt;REAL&lt;/code&gt; value when it sends it to the database.
 189      *
 190      * @param parameterIndex the first parameter is 1, the second is 2, ...
 191      * @param x the parameter value
 192      * @exception SQLException if parameterIndex does not correspond to a parameter
 193      * marker in the SQL statement; if a database access error occurs or
 194      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 195      */
 196     void setFloat(int parameterIndex, float x) throws SQLException;
 197 
 198     /**
 199      * Sets the designated parameter to the given Java &lt;code&gt;double&lt;/code&gt; value.
 200      * The driver converts this
 201      * to an SQL &lt;code&gt;DOUBLE&lt;/code&gt; value when it sends it to the database.
 202      *
 203      * @param parameterIndex the first parameter is 1, the second is 2, ...
 204      * @param x the parameter value
 205      * @exception SQLException if parameterIndex does not correspond to a parameter
 206      * marker in the SQL statement; if a database access error occurs or
 207      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 208      */
 209     void setDouble(int parameterIndex, double x) throws SQLException;
 210 
 211     /**
 212      * Sets the designated parameter to the given &lt;code&gt;java.math.BigDecimal&lt;/code&gt; value.
 213      * The driver converts this to an SQL &lt;code&gt;NUMERIC&lt;/code&gt; value when
 214      * it sends it to the database.
 215      *
 216      * @param parameterIndex the first parameter is 1, the second is 2, ...
 217      * @param x the parameter value
 218      * @exception SQLException if parameterIndex does not correspond to a parameter
 219      * marker in the SQL statement; if a database access error occurs or
 220      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 221      */
 222     void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException;
 223 
 224     /**
 225      * Sets the designated parameter to the given Java &lt;code&gt;String&lt;/code&gt; value.
 226      * The driver converts this
 227      * to an SQL &lt;code&gt;VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value
 228      * (depending on the argument&#39;s
 229      * size relative to the driver&#39;s limits on &lt;code&gt;VARCHAR&lt;/code&gt; values)
 230      * when it sends it to the database.
 231      *
 232      * @param parameterIndex the first parameter is 1, the second is 2, ...
 233      * @param x the parameter value
 234      * @exception SQLException if parameterIndex does not correspond to a parameter
 235      * marker in the SQL statement; if a database access error occurs or
 236      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 237      */
 238     void setString(int parameterIndex, String x) throws SQLException;
 239 
 240     /**
 241      * Sets the designated parameter to the given Java array of bytes.  The driver converts
 242      * this to an SQL &lt;code&gt;VARBINARY&lt;/code&gt; or &lt;code&gt;LONGVARBINARY&lt;/code&gt;
 243      * (depending on the argument&#39;s size relative to the driver&#39;s limits on
 244      * &lt;code&gt;VARBINARY&lt;/code&gt; values) when it sends it to the database.
 245      *
 246      * @param parameterIndex the first parameter is 1, the second is 2, ...
 247      * @param x the parameter value
 248      * @exception SQLException if parameterIndex does not correspond to a parameter
 249      * marker in the SQL statement; if a database access error occurs or
 250      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 251      */
 252     void setBytes(int parameterIndex, byte x[]) throws SQLException;
 253 
 254     /**
 255      * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt; value
 256      * using the default time zone of the virtual machine that is running
 257      * the application.
 258      * The driver converts this
 259      * to an SQL &lt;code&gt;DATE&lt;/code&gt; value when it sends it to the database.
 260      *
 261      * @param parameterIndex the first parameter is 1, the second is 2, ...
 262      * @param x the parameter value
 263      * @exception SQLException if parameterIndex does not correspond to a parameter
 264      * marker in the SQL statement; if a database access error occurs or
 265      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 266      */
 267     void setDate(int parameterIndex, java.sql.Date x)
 268             throws SQLException;
 269 
 270     /**
 271      * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt; value.
 272      * The driver converts this
 273      * to an SQL &lt;code&gt;TIME&lt;/code&gt; value when it sends it to the database.
 274      *
 275      * @param parameterIndex the first parameter is 1, the second is 2, ...
 276      * @param x the parameter value
 277      * @exception SQLException if parameterIndex does not correspond to a parameter
 278      * marker in the SQL statement; if a database access error occurs or
 279      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 280      */
 281     void setTime(int parameterIndex, java.sql.Time x)
 282             throws SQLException;
 283 
 284     /**
 285      * Sets the designated parameter to the given &lt;code&gt;java.sql.Timestamp&lt;/code&gt; value.
 286      * The driver
 287      * converts this to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value when it sends it to the
 288      * database.
 289      *
 290      * @param parameterIndex the first parameter is 1, the second is 2, ...
 291      * @param x the parameter value
 292      * @exception SQLException if parameterIndex does not correspond to a parameter
 293      * marker in the SQL statement; if a database access error occurs or
 294      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;     */
 295     void setTimestamp(int parameterIndex, java.sql.Timestamp x)
 296             throws SQLException;
 297 
 298     /**
 299      * Sets the designated parameter to the given input stream, which will have
 300      * the specified number of bytes.
 301      * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 302      * parameter, it may be more practical to send it via a
 303      * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
 304      * as needed until end-of-file is reached.  The JDBC driver will
 305      * do any necessary conversion from ASCII to the database char format.
 306      *
 307      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 308      * Java stream object or your own subclass that implements the
 309      * standard interface.
 310      *
 311      * @param parameterIndex the first parameter is 1, the second is 2, ...
 312      * @param x the Java input stream that contains the ASCII parameter value
 313      * @param length the number of bytes in the stream
 314      * @exception SQLException if parameterIndex does not correspond to a parameter
 315      * marker in the SQL statement; if a database access error occurs or
 316      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 317      */
 318     void setAsciiStream(int parameterIndex, java.io.InputStream x, int length)
 319             throws SQLException;
 320 
 321     /**
 322      * Sets the designated parameter to the given input stream, which
 323      * will have the specified number of bytes.
 324      *
 325      * When a very large Unicode value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 326      * parameter, it may be more practical to send it via a
 327      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the
 328      * stream as needed until end-of-file is reached.  The JDBC driver will
 329      * do any necessary conversion from Unicode to the database char format.
 330      *
 331      *The byte format of the Unicode stream must be a Java UTF-8, as defined in the
 332      *Java Virtual Machine Specification.
 333      *
 334      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 335      * Java stream object or your own subclass that implements the
 336      * standard interface.
 337      *
 338      * @param parameterIndex the first parameter is 1, the second is 2, ...
 339      * @param x a &lt;code&gt;java.io.InputStream&lt;/code&gt; object that contains the
 340      *        Unicode parameter value
 341      * @param length the number of bytes in the stream
 342      * @exception SQLException if parameterIndex does not correspond to a parameter
 343      * marker in the SQL statement; if a database access error occurs or
 344      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 345      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 346      * this method
 347      * @deprecated Use {@code setCharacterStream}
 348      */
 349     @Deprecated(since=&quot;1.2&quot;)
 350     void setUnicodeStream(int parameterIndex, java.io.InputStream x,
 351                           int length) throws SQLException;
 352 
 353     /**
 354      * Sets the designated parameter to the given input stream, which will have
 355      * the specified number of bytes.
 356      * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
 357      * parameter, it may be more practical to send it via a
 358      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the
 359      * stream as needed until end-of-file is reached.
 360      *
 361      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 362      * Java stream object or your own subclass that implements the
 363      * standard interface.
 364      *
 365      * @param parameterIndex the first parameter is 1, the second is 2, ...
 366      * @param x the java input stream which contains the binary parameter value
 367      * @param length the number of bytes in the stream
 368      * @exception SQLException if parameterIndex does not correspond to a parameter
 369      * marker in the SQL statement; if a database access error occurs or
 370      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 371      */
 372     void setBinaryStream(int parameterIndex, java.io.InputStream x,
 373                          int length) throws SQLException;
 374 
 375     /**
 376      * Clears the current parameter values immediately.
 377      * &lt;P&gt;In general, parameter values remain in force for repeated use of a
 378      * statement. Setting a parameter value automatically clears its
 379      * previous value.  However, in some cases it is useful to immediately
 380      * release the resources used by the current parameter values; this can
 381      * be done by calling the method &lt;code&gt;clearParameters&lt;/code&gt;.
 382      *
 383      * @exception SQLException if a database access error occurs or
 384      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 385      */
 386     void clearParameters() throws SQLException;
 387 
 388     //----------------------------------------------------------------------
 389     // Advanced features:
 390 
 391    /**
 392     * Sets the value of the designated parameter with the given object.
 393     *
 394     * This method is similar to {@link #setObject(int parameterIndex,
 395     * Object x, int targetSqlType, int scaleOrLength)},
 396     * except that it assumes a scale of zero.
 397     *
 398     * @param parameterIndex the first parameter is 1, the second is 2, ...
 399     * @param x the object containing the input parameter value
 400     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
 401     *                      sent to the database
 402     * @exception SQLException if parameterIndex does not correspond to a parameter
 403     * marker in the SQL statement; if a database access error occurs or this
 404     * method is called on a closed PreparedStatement
 405     * @exception SQLFeatureNotSupportedException if
 406     * the JDBC driver does not support the specified targetSqlType
 407     * @see Types
 408     */
 409     void setObject(int parameterIndex, Object x, int targetSqlType)
 410       throws SQLException;
 411 
 412     /**
 413      * &lt;p&gt;Sets the value of the designated parameter using the given object.
 414      *
 415      * &lt;p&gt;The JDBC specification specifies a standard mapping from
 416      * Java &lt;code&gt;Object&lt;/code&gt; types to SQL types.  The given argument
 417      * will be converted to the corresponding SQL type before being
 418      * sent to the database.
 419      *
 420      * &lt;p&gt;Note that this method may be used to pass database-
 421      * specific abstract data types, by using a driver-specific Java
 422      * type.
 423      *
 424      * If the object is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;,
 425      * the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;
 426      * to write it to the SQL data stream.
 427      * If, on the other hand, the object is of a class implementing
 428      * &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,  &lt;code&gt;NClob&lt;/code&gt;,
 429      *  &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;, &lt;code&gt;RowId&lt;/code&gt;, &lt;code&gt;SQLXML&lt;/code&gt;
 430      * or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a
 431      * value of the corresponding SQL type.
 432      * &lt;P&gt;
 433      *&lt;b&gt;Note:&lt;/b&gt; Not all databases allow for a non-typed Null to be sent to
 434      * the backend. For maximum portability, the &lt;code&gt;setNull&lt;/code&gt; or the
 435      * &lt;code&gt;setObject(int parameterIndex, Object x, int sqlType)&lt;/code&gt;
 436      * method should be used
 437      * instead of &lt;code&gt;setObject(int parameterIndex, Object x)&lt;/code&gt;.
 438      *&lt;p&gt;
 439      * &lt;b&gt;Note:&lt;/b&gt; This method throws an exception if there is an ambiguity, for example, if the
 440      * object is of a class implementing more than one of the interfaces named above.
 441      *
 442      * @param parameterIndex the first parameter is 1, the second is 2, ...
 443      * @param x the object containing the input parameter value
 444      * @exception SQLException if parameterIndex does not correspond to a parameter
 445      * marker in the SQL statement; if a database access error occurs;
 446      *  this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 447      * or the type of the given object is ambiguous
 448      */
 449     void setObject(int parameterIndex, Object x) throws SQLException;
 450 
 451     /**
 452      * Executes the SQL statement in this &lt;code&gt;PreparedStatement&lt;/code&gt; object,
 453      * which may be any kind of SQL statement.
 454      * Some prepared statements return multiple results; the &lt;code&gt;execute&lt;/code&gt;
 455      * method handles these complex statements as well as the simpler
 456      * form of statements handled by the methods &lt;code&gt;executeQuery&lt;/code&gt;
 457      * and &lt;code&gt;executeUpdate&lt;/code&gt;.
 458      * &lt;P&gt;
 459      * The &lt;code&gt;execute&lt;/code&gt; method returns a &lt;code&gt;boolean&lt;/code&gt; to
 460      * indicate the form of the first result.  You must call either the method
 461      * &lt;code&gt;getResultSet&lt;/code&gt; or &lt;code&gt;getUpdateCount&lt;/code&gt;
 462      * to retrieve the result; you must call &lt;code&gt;getMoreResults&lt;/code&gt; to
 463      * move to any subsequent result(s).
 464      *
 465      * @return &lt;code&gt;true&lt;/code&gt; if the first result is a &lt;code&gt;ResultSet&lt;/code&gt;
 466      *         object; &lt;code&gt;false&lt;/code&gt; if the first result is an update
 467      *         count or there is no result
 468      * @exception SQLException if a database access error occurs;
 469      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 470      * or an argument is supplied to this method
 471      * @throws SQLTimeoutException when the driver has determined that the
 472      * timeout value that was specified by the {@code setQueryTimeout}
 473      * method has been exceeded and has at least attempted to cancel
 474      * the currently running {@code Statement}
 475      * @see Statement#execute
 476      * @see Statement#getResultSet
 477      * @see Statement#getUpdateCount
 478      * @see Statement#getMoreResults
 479 
 480      */
 481     boolean execute() throws SQLException;
 482 
 483     //--------------------------JDBC 2.0-----------------------------
 484 
 485     /**
 486      * Adds a set of parameters to this &lt;code&gt;PreparedStatement&lt;/code&gt;
 487      * object&#39;s batch of commands.
 488      *
 489      * @exception SQLException if a database access error occurs or
 490      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 491      * @see Statement#addBatch
 492      * @since 1.2
 493      */
 494     void addBatch() throws SQLException;
 495 
 496     /**
 497      * Sets the designated parameter to the given &lt;code&gt;Reader&lt;/code&gt;
 498      * object, which is the given number of characters long.
 499      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 500      * parameter, it may be more practical to send it via a
 501      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 502      * as needed until end-of-file is reached.  The JDBC driver will
 503      * do any necessary conversion from UNICODE to the database char format.
 504      *
 505      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 506      * Java stream object or your own subclass that implements the
 507      * standard interface.
 508      *
 509      * @param parameterIndex the first parameter is 1, the second is 2, ...
 510      * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that contains the
 511      *        Unicode data
 512      * @param length the number of characters in the stream
 513      * @exception SQLException if parameterIndex does not correspond to a parameter
 514      * marker in the SQL statement; if a database access error occurs or
 515      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 516      * @since 1.2
 517      */
 518     void setCharacterStream(int parameterIndex,
 519                           java.io.Reader reader,
 520                           int length) throws SQLException;
 521 
 522     /**
 523      * Sets the designated parameter to the given
 524      *  &lt;code&gt;REF(&amp;lt;structured-type&amp;gt;)&lt;/code&gt; value.
 525      * The driver converts this to an SQL &lt;code&gt;REF&lt;/code&gt; value when it
 526      * sends it to the database.
 527      *
 528      * @param parameterIndex the first parameter is 1, the second is 2, ...
 529      * @param x an SQL &lt;code&gt;REF&lt;/code&gt; value
 530      * @exception SQLException if parameterIndex does not correspond to a parameter
 531      * marker in the SQL statement; if a database access error occurs or
 532      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 533      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 534      * @since 1.2
 535      */
 536     void setRef (int parameterIndex, Ref x) throws SQLException;
 537 
 538     /**
 539      * Sets the designated parameter to the given &lt;code&gt;java.sql.Blob&lt;/code&gt; object.
 540      * The driver converts this to an SQL &lt;code&gt;BLOB&lt;/code&gt; value when it
 541      * sends it to the database.
 542      *
 543      * @param parameterIndex the first parameter is 1, the second is 2, ...
 544      * @param x a &lt;code&gt;Blob&lt;/code&gt; object that maps an SQL &lt;code&gt;BLOB&lt;/code&gt; value
 545      * @exception SQLException if parameterIndex does not correspond to a parameter
 546      * marker in the SQL statement; if a database access error occurs or
 547      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 548      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 549      * @since 1.2
 550      */
 551     void setBlob (int parameterIndex, Blob x) throws SQLException;
 552 
 553     /**
 554      * Sets the designated parameter to the given &lt;code&gt;java.sql.Clob&lt;/code&gt; object.
 555      * The driver converts this to an SQL &lt;code&gt;CLOB&lt;/code&gt; value when it
 556      * sends it to the database.
 557      *
 558      * @param parameterIndex the first parameter is 1, the second is 2, ...
 559      * @param x a &lt;code&gt;Clob&lt;/code&gt; object that maps an SQL &lt;code&gt;CLOB&lt;/code&gt; value
 560      * @exception SQLException if parameterIndex does not correspond to a parameter
 561      * marker in the SQL statement; if a database access error occurs or
 562      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 563      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 564      * @since 1.2
 565      */
 566     void setClob (int parameterIndex, Clob x) throws SQLException;
 567 
 568     /**
 569      * Sets the designated parameter to the given &lt;code&gt;java.sql.Array&lt;/code&gt; object.
 570      * The driver converts this to an SQL &lt;code&gt;ARRAY&lt;/code&gt; value when it
 571      * sends it to the database.
 572      *
 573      * @param parameterIndex the first parameter is 1, the second is 2, ...
 574      * @param x an &lt;code&gt;Array&lt;/code&gt; object that maps an SQL &lt;code&gt;ARRAY&lt;/code&gt; value
 575      * @exception SQLException if parameterIndex does not correspond to a parameter
 576      * marker in the SQL statement; if a database access error occurs or
 577      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 578      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 579      * @since 1.2
 580      */
 581     void setArray (int parameterIndex, Array x) throws SQLException;
 582 
 583     /**
 584      * Retrieves a &lt;code&gt;ResultSetMetaData&lt;/code&gt; object that contains
 585      * information about the columns of the &lt;code&gt;ResultSet&lt;/code&gt; object
 586      * that will be returned when this &lt;code&gt;PreparedStatement&lt;/code&gt; object
 587      * is executed.
 588      * &lt;P&gt;
 589      * Because a &lt;code&gt;PreparedStatement&lt;/code&gt; object is precompiled, it is
 590      * possible to know about the &lt;code&gt;ResultSet&lt;/code&gt; object that it will
 591      * return without having to execute it.  Consequently, it is possible
 592      * to invoke the method &lt;code&gt;getMetaData&lt;/code&gt; on a
 593      * &lt;code&gt;PreparedStatement&lt;/code&gt; object rather than waiting to execute
 594      * it and then invoking the &lt;code&gt;ResultSet.getMetaData&lt;/code&gt; method
 595      * on the &lt;code&gt;ResultSet&lt;/code&gt; object that is returned.
 596      * &lt;P&gt;
 597      * &lt;B&gt;NOTE:&lt;/B&gt; Using this method may be expensive for some drivers due
 598      * to the lack of underlying DBMS support.
 599      *
 600      * @return the description of a &lt;code&gt;ResultSet&lt;/code&gt; object&#39;s columns or
 601      *         &lt;code&gt;null&lt;/code&gt; if the driver cannot return a
 602      *         &lt;code&gt;ResultSetMetaData&lt;/code&gt; object
 603      * @exception SQLException if a database access error occurs or
 604      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 605      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 606      * this method
 607      * @since 1.2
 608      */
 609     ResultSetMetaData getMetaData() throws SQLException;
 610 
 611     /**
 612      * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt; value,
 613      * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
 614      * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;DATE&lt;/code&gt; value,
 615      * which the driver then sends to the database.  With
 616      * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date
 617      * taking into account a custom timezone.  If no
 618      * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
 619      * timezone, which is that of the virtual machine running the application.
 620      *
 621      * @param parameterIndex the first parameter is 1, the second is 2, ...
 622      * @param x the parameter value
 623      * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
 624      *            to construct the date
 625      * @exception SQLException if parameterIndex does not correspond to a parameter
 626      * marker in the SQL statement; if a database access error occurs or
 627      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 628      * @since 1.2
 629      */
 630     void setDate(int parameterIndex, java.sql.Date x, Calendar cal)
 631             throws SQLException;
 632 
 633     /**
 634      * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt; value,
 635      * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
 636      * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;TIME&lt;/code&gt; value,
 637      * which the driver then sends to the database.  With
 638      * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the time
 639      * taking into account a custom timezone.  If no
 640      * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
 641      * timezone, which is that of the virtual machine running the application.
 642      *
 643      * @param parameterIndex the first parameter is 1, the second is 2, ...
 644      * @param x the parameter value
 645      * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
 646      *            to construct the time
 647      * @exception SQLException if parameterIndex does not correspond to a parameter
 648      * marker in the SQL statement; if a database access error occurs or
 649      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 650      * @since 1.2
 651      */
 652     void setTime(int parameterIndex, java.sql.Time x, Calendar cal)
 653             throws SQLException;
 654 
 655     /**
 656      * Sets the designated parameter to the given &lt;code&gt;java.sql.Timestamp&lt;/code&gt; value,
 657      * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
 658      * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value,
 659      * which the driver then sends to the database.  With a
 660      *  &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the timestamp
 661      * taking into account a custom timezone.  If no
 662      * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
 663      * timezone, which is that of the virtual machine running the application.
 664      *
 665      * @param parameterIndex the first parameter is 1, the second is 2, ...
 666      * @param x the parameter value
 667      * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
 668      *            to construct the timestamp
 669      * @exception SQLException if parameterIndex does not correspond to a parameter
 670      * marker in the SQL statement; if a database access error occurs or
 671      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 672      * @since 1.2
 673      */
 674     void setTimestamp(int parameterIndex, java.sql.Timestamp x, Calendar cal)
 675             throws SQLException;
 676 
 677     /**
 678      * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
 679      * This version of the method &lt;code&gt;setNull&lt;/code&gt; should
 680      * be used for user-defined types and REF type parameters.  Examples
 681      * of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
 682      * named array types.
 683      *
 684      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; To be portable, applications must give the
 685      * SQL type code and the fully-qualified SQL type name when specifying
 686      * a NULL user-defined or REF parameter.  In the case of a user-defined type
 687      * the name is the type name of the parameter itself.  For a REF
 688      * parameter, the name is the type name of the referenced type.  If
 689      * a JDBC driver does not need the type code or type name information,
 690      * it may ignore it.
 691      *
 692      * Although it is intended for user-defined and Ref parameters,
 693      * this method may be used to set a null parameter of any JDBC type.
 694      * If the parameter does not have a user-defined or REF type, the given
 695      * typeName is ignored.
 696      *
 697      *
 698      * @param parameterIndex the first parameter is 1, the second is 2, ...
 699      * @param sqlType a value from &lt;code&gt;java.sql.Types&lt;/code&gt;
 700      * @param typeName the fully-qualified name of an SQL user-defined type;
 701      *  ignored if the parameter is not a user-defined type or REF
 702      * @exception SQLException if parameterIndex does not correspond to a parameter
 703      * marker in the SQL statement; if a database access error occurs or
 704      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 705      * @exception SQLFeatureNotSupportedException if &lt;code&gt;sqlType&lt;/code&gt; is
 706      * a &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;,
 707      * &lt;code&gt;DATALINK&lt;/code&gt;, &lt;code&gt;JAVA_OBJECT&lt;/code&gt;, &lt;code&gt;NCHAR&lt;/code&gt;,
 708      * &lt;code&gt;NCLOB&lt;/code&gt;, &lt;code&gt;NVARCHAR&lt;/code&gt;, &lt;code&gt;LONGNVARCHAR&lt;/code&gt;,
 709      *  &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;ROWID&lt;/code&gt;, &lt;code&gt;SQLXML&lt;/code&gt;
 710      * or  &lt;code&gt;STRUCT&lt;/code&gt; data type and the JDBC driver does not support
 711      * this data type or if the JDBC driver does not support this method
 712      * @since 1.2
 713      */
 714   void setNull (int parameterIndex, int sqlType, String typeName)
 715     throws SQLException;
 716 
 717     //------------------------- JDBC 3.0 -----------------------------------
 718 
 719     /**
 720      * Sets the designated parameter to the given &lt;code&gt;java.net.URL&lt;/code&gt; value.
 721      * The driver converts this to an SQL &lt;code&gt;DATALINK&lt;/code&gt; value
 722      * when it sends it to the database.
 723      *
 724      * @param parameterIndex the first parameter is 1, the second is 2, ...
 725      * @param x the &lt;code&gt;java.net.URL&lt;/code&gt; object to be set
 726      * @exception SQLException if parameterIndex does not correspond to a parameter
 727      * marker in the SQL statement; if a database access error occurs or
 728      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 729      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 730      * @since 1.4
 731      */
 732     void setURL(int parameterIndex, java.net.URL x) throws SQLException;
 733 
 734     /**
 735      * Retrieves the number, types and properties of this
 736      * &lt;code&gt;PreparedStatement&lt;/code&gt; object&#39;s parameters.
 737      *
 738      * @return a &lt;code&gt;ParameterMetaData&lt;/code&gt; object that contains information
 739      *         about the number, types and properties for each
 740      *  parameter marker of this &lt;code&gt;PreparedStatement&lt;/code&gt; object
 741      * @exception SQLException if a database access error occurs or
 742      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 743      * @see ParameterMetaData
 744      * @since 1.4
 745      */
 746     ParameterMetaData getParameterMetaData() throws SQLException;
 747 
 748     //------------------------- JDBC 4.0 -----------------------------------
 749 
 750     /**
 751      * Sets the designated parameter to the given &lt;code&gt;java.sql.RowId&lt;/code&gt; object. The
 752      * driver converts this to a SQL &lt;code&gt;ROWID&lt;/code&gt; value when it sends it
 753      * to the database
 754      *
 755      * @param parameterIndex the first parameter is 1, the second is 2, ...
 756      * @param x the parameter value
 757      * @throws SQLException if parameterIndex does not correspond to a parameter
 758      * marker in the SQL statement; if a database access error occurs or
 759      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 760      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 761      *
 762      * @since 1.6
 763      */
 764     void setRowId(int parameterIndex, RowId x) throws SQLException;
 765 
 766 
 767     /**
 768      * Sets the designated parameter to the given &lt;code&gt;String&lt;/code&gt; object.
 769      * The driver converts this to a SQL &lt;code&gt;NCHAR&lt;/code&gt; or
 770      * &lt;code&gt;NVARCHAR&lt;/code&gt; or &lt;code&gt;LONGNVARCHAR&lt;/code&gt; value
 771      * (depending on the argument&#39;s
 772      * size relative to the driver&#39;s limits on &lt;code&gt;NVARCHAR&lt;/code&gt; values)
 773      * when it sends it to the database.
 774      *
 775      * @param parameterIndex of the first parameter is 1, the second is 2, ...
 776      * @param value the parameter value
 777      * @throws SQLException if parameterIndex does not correspond to a parameter
 778      * marker in the SQL statement; if the driver does not support national
 779      *         character sets;  if the driver can detect that a data conversion
 780      *  error could occur; if a database access error occurs; or
 781      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 782      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 783      * @since 1.6
 784      */
 785      void setNString(int parameterIndex, String value) throws SQLException;
 786 
 787     /**
 788      * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
 789      * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
 790      * driver does the necessary conversion from Java character format to
 791      * the national character set in the database.
 792      * @param parameterIndex of the first parameter is 1, the second is 2, ...
 793      * @param value the parameter value
 794      * @param length the number of characters in the parameter data.
 795      * @throws SQLException if parameterIndex does not correspond to a parameter
 796      * marker in the SQL statement; if the driver does not support national
 797      *         character sets;  if the driver can detect that a data conversion
 798      *  error could occur; if a database access error occurs; or
 799      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 800      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 801      * @since 1.6
 802      */
 803      void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException;
 804 
 805     /**
 806      * Sets the designated parameter to a &lt;code&gt;java.sql.NClob&lt;/code&gt; object. The driver converts this to a
 807      * SQL &lt;code&gt;NCLOB&lt;/code&gt; value when it sends it to the database.
 808      * @param parameterIndex of the first parameter is 1, the second is 2, ...
 809      * @param value the parameter value
 810      * @throws SQLException if parameterIndex does not correspond to a parameter
 811      * marker in the SQL statement; if the driver does not support national
 812      *         character sets;  if the driver can detect that a data conversion
 813      *  error could occur; if a database access error occurs; or
 814      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 815      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 816      * @since 1.6
 817      */
 818      void setNClob(int parameterIndex, NClob value) throws SQLException;
 819 
 820     /**
 821      * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.  The reader must contain  the number
 822      * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
 823      * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
 824      *This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
 825      * because it informs the driver that the parameter value should be sent to
 826      * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
 827      * driver may have to do extra work to determine whether the parameter
 828      * data should be sent to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
 829      * @param parameterIndex index of the first parameter is 1, the second is 2, ...
 830      * @param reader An object that contains the data to set the parameter value to.
 831      * @param length the number of characters in the parameter data.
 832      * @throws SQLException if parameterIndex does not correspond to a parameter
 833      * marker in the SQL statement; if a database access error occurs; this method is called on
 834      * a closed &lt;code&gt;PreparedStatement&lt;/code&gt; or if the length specified is less than zero.
 835      *
 836      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 837      * @since 1.6
 838      */
 839      void setClob(int parameterIndex, Reader reader, long length)
 840        throws SQLException;
 841 
 842     /**
 843      * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
 844      * The {@code Inputstream} must contain  the number
 845      * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
 846      * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
 847      * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream, int)&lt;/code&gt;
 848      * method because it informs the driver that the parameter value should be
 849      * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
 850      * the driver may have to do extra work to determine whether the parameter
 851      * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
 852      * @param parameterIndex index of the first parameter is 1,
 853      * the second is 2, ...
 854      * @param inputStream An object that contains the data to set the parameter
 855      * value to.
 856      * @param length the number of bytes in the parameter data.
 857      * @throws SQLException if parameterIndex does not correspond to a parameter
 858      * marker in the SQL statement; if a database access error occurs;
 859      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;;
 860      * if the length specified
 861      * is less than zero or if the number of bytes in the {@code InputStream} does not match
 862      * the specified length.
 863      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 864      *
 865      * @since 1.6
 866      */
 867      void setBlob(int parameterIndex, InputStream inputStream, long length)
 868         throws SQLException;
 869     /**
 870      * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.  The reader must contain  the number
 871      * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
 872      * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
 873      * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
 874      * because it informs the driver that the parameter value should be sent to
 875      * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
 876      * driver may have to do extra work to determine whether the parameter
 877      * data should be sent to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
 878      * @param parameterIndex index of the first parameter is 1, the second is 2, ...
 879      * @param reader An object that contains the data to set the parameter value to.
 880      * @param length the number of characters in the parameter data.
 881      * @throws SQLException if parameterIndex does not correspond to a parameter
 882      * marker in the SQL statement; if the length specified is less than zero;
 883      * if the driver does not support national character sets;
 884      * if the driver can detect that a data conversion
 885      *  error could occur;  if a database access error occurs or
 886      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 887      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 888      *
 889      * @since 1.6
 890      */
 891      void setNClob(int parameterIndex, Reader reader, long length)
 892        throws SQLException;
 893 
 894      /**
 895       * Sets the designated parameter to the given &lt;code&gt;java.sql.SQLXML&lt;/code&gt; object.
 896       * The driver converts this to an
 897       * SQL &lt;code&gt;XML&lt;/code&gt; value when it sends it to the database.
 898       *
 899       * @param parameterIndex index of the first parameter is 1, the second is 2, ...
 900       * @param xmlObject a &lt;code&gt;SQLXML&lt;/code&gt; object that maps an SQL &lt;code&gt;XML&lt;/code&gt; value
 901       * @throws SQLException if parameterIndex does not correspond to a parameter
 902      * marker in the SQL statement; if a database access error occurs;
 903       *  this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 904       * or the &lt;code&gt;java.xml.transform.Result&lt;/code&gt;,
 905       *  &lt;code&gt;Writer&lt;/code&gt; or &lt;code&gt;OutputStream&lt;/code&gt; has not been closed for
 906       * the &lt;code&gt;SQLXML&lt;/code&gt; object
 907       * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 908       *
 909       * @since 1.6
 910       */
 911      void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException;
 912 
 913     /**
 914      * &lt;p&gt;Sets the value of the designated parameter with the given object.
 915      *
 916      * If the second argument is an &lt;code&gt;InputStream&lt;/code&gt; then the stream must contain
 917      * the number of bytes specified by scaleOrLength.  If the second argument is a
 918      * &lt;code&gt;Reader&lt;/code&gt; then the reader must contain the number of characters specified
 919      * by scaleOrLength. If these conditions are not true the driver will generate a
 920      * &lt;code&gt;SQLException&lt;/code&gt; when the prepared statement is executed.
 921      *
 922      * &lt;p&gt;The given Java object will be converted to the given targetSqlType
 923      * before being sent to the database.
 924      *
 925      * If the object has a custom mapping (is of a class implementing the
 926      * interface &lt;code&gt;SQLData&lt;/code&gt;),
 927      * the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to
 928      * write it to the SQL data stream.
 929      * If, on the other hand, the object is of a class implementing
 930      * &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,  &lt;code&gt;NClob&lt;/code&gt;,
 931      *  &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;,
 932      * or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a
 933      * value of the corresponding SQL type.
 934      *
 935      * &lt;p&gt;Note that this method may be used to pass database-specific
 936      * abstract data types.
 937      *
 938      * @param parameterIndex the first parameter is 1, the second is 2, ...
 939      * @param x the object containing the input parameter value
 940      * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
 941      * sent to the database. The scale argument may further qualify this type.
 942      * @param scaleOrLength for &lt;code&gt;java.sql.Types.DECIMAL&lt;/code&gt;
 943      *          or &lt;code&gt;java.sql.Types.NUMERIC types&lt;/code&gt;,
 944      *          this is the number of digits after the decimal point. For
 945      *          Java Object types &lt;code&gt;InputStream&lt;/code&gt; and &lt;code&gt;Reader&lt;/code&gt;,
 946      *          this is the length
 947      *          of the data in the stream or reader.  For all other types,
 948      *          this value will be ignored.
 949      * @exception SQLException if parameterIndex does not correspond to a parameter
 950      * marker in the SQL statement; if a database access error occurs;
 951      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt; or
 952      *            if the Java Object specified by x is an InputStream
 953      *            or Reader object and the value of the scale parameter is less
 954      *            than zero
 955      * @exception SQLFeatureNotSupportedException if
 956      * the JDBC driver does not support the specified targetSqlType
 957      * @see Types
 958      *
 959      */
 960     void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength)
 961             throws SQLException;
 962    /**
 963      * Sets the designated parameter to the given input stream, which will have
 964      * the specified number of bytes.
 965      * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 966      * parameter, it may be more practical to send it via a
 967      * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
 968      * as needed until end-of-file is reached.  The JDBC driver will
 969      * do any necessary conversion from ASCII to the database char format.
 970      *
 971      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 972      * Java stream object or your own subclass that implements the
 973      * standard interface.
 974      *
 975      * @param parameterIndex the first parameter is 1, the second is 2, ...
 976      * @param x the Java input stream that contains the ASCII parameter value
 977      * @param length the number of bytes in the stream
 978      * @exception SQLException if parameterIndex does not correspond to a parameter
 979      * marker in the SQL statement; if a database access error occurs or
 980      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 981      * @since 1.6
 982     */
 983     void setAsciiStream(int parameterIndex, java.io.InputStream x, long length)
 984             throws SQLException;
 985     /**
 986      * Sets the designated parameter to the given input stream, which will have
 987      * the specified number of bytes.
 988      * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
 989      * parameter, it may be more practical to send it via a
 990      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the
 991      * stream as needed until end-of-file is reached.
 992      *
 993      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 994      * Java stream object or your own subclass that implements the
 995      * standard interface.
 996      *
 997      * @param parameterIndex the first parameter is 1, the second is 2, ...
 998      * @param x the java input stream which contains the binary parameter value
 999      * @param length the number of bytes in the stream
1000      * @exception SQLException if parameterIndex does not correspond to a parameter
1001      * marker in the SQL statement; if a database access error occurs or
1002      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
1003      * @since 1.6
1004      */
1005     void setBinaryStream(int parameterIndex, java.io.InputStream x,
1006                          long length) throws SQLException;
1007         /**
1008      * Sets the designated parameter to the given &lt;code&gt;Reader&lt;/code&gt;
1009      * object, which is the given number of characters long.
1010      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
1011      * parameter, it may be more practical to send it via a
1012      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
1013      * as needed until end-of-file is reached.  The JDBC driver will
1014      * do any necessary conversion from UNICODE to the database char format.
1015      *
1016      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
1017      * Java stream object or your own subclass that implements the
1018      * standard interface.
1019      *
1020      * @param parameterIndex the first parameter is 1, the second is 2, ...
1021      * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that contains the
1022      *        Unicode data
1023      * @param length the number of characters in the stream
1024      * @exception SQLException if parameterIndex does not correspond to a parameter
1025      * marker in the SQL statement; if a database access error occurs or
1026      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
1027      * @since 1.6
1028      */
1029     void setCharacterStream(int parameterIndex,
1030                           java.io.Reader reader,
1031                           long length) throws SQLException;
1032     //-----
1033     /**
1034      * Sets the designated parameter to the given input stream.
1035      * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
1036      * parameter, it may be more practical to send it via a
1037      * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
1038      * as needed until end-of-file is reached.  The JDBC driver will
1039      * do any necessary conversion from ASCII to the database char format.
1040      *
1041      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
1042      * Java stream object or your own subclass that implements the
1043      * standard interface.
1044      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
1045      * it might be more efficient to use a version of
1046      * &lt;code&gt;setAsciiStream&lt;/code&gt; which takes a length parameter.
1047      *
1048      * @param parameterIndex the first parameter is 1, the second is 2, ...
1049      * @param x the Java input stream that contains the ASCII parameter value
1050      * @exception SQLException if parameterIndex does not correspond to a parameter
1051      * marker in the SQL statement; if a database access error occurs or
1052      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
1053      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
1054        * @since 1.6
1055     */
1056     void setAsciiStream(int parameterIndex, java.io.InputStream x)
1057             throws SQLException;
1058     /**
1059      * Sets the designated parameter to the given input stream.
1060      * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
1061      * parameter, it may be more practical to send it via a
1062      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the
1063      * stream as needed until end-of-file is reached.
1064      *
1065      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
1066      * Java stream object or your own subclass that implements the
1067      * standard interface.
1068      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
1069      * it might be more efficient to use a version of
1070      * &lt;code&gt;setBinaryStream&lt;/code&gt; which takes a length parameter.
1071      *
1072      * @param parameterIndex the first parameter is 1, the second is 2, ...
1073      * @param x the java input stream which contains the binary parameter value
1074      * @exception SQLException if parameterIndex does not correspond to a parameter
1075      * marker in the SQL statement; if a database access error occurs or
1076      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
1077      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
1078      * @since 1.6
1079      */
1080     void setBinaryStream(int parameterIndex, java.io.InputStream x)
1081     throws SQLException;
1082         /**
1083      * Sets the designated parameter to the given &lt;code&gt;Reader&lt;/code&gt;
1084      * object.
1085      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
1086      * parameter, it may be more practical to send it via a
1087      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
1088      * as needed until end-of-file is reached.  The JDBC driver will
1089      * do any necessary conversion from UNICODE to the database char format.
1090      *
1091      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
1092      * Java stream object or your own subclass that implements the
1093      * standard interface.
1094      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
1095      * it might be more efficient to use a version of
1096      * &lt;code&gt;setCharacterStream&lt;/code&gt; which takes a length parameter.
1097      *
1098      * @param parameterIndex the first parameter is 1, the second is 2, ...
1099      * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that contains the
1100      *        Unicode data
1101      * @exception SQLException if parameterIndex does not correspond to a parameter
1102      * marker in the SQL statement; if a database access error occurs or
1103      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
1104      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
1105      * @since 1.6
1106      */
1107     void setCharacterStream(int parameterIndex,
1108                           java.io.Reader reader) throws SQLException;
1109   /**
1110      * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
1111      * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
1112      * driver does the necessary conversion from Java character format to
1113      * the national character set in the database.
1114 
1115      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
1116      * Java stream object or your own subclass that implements the
1117      * standard interface.
1118      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
1119      * it might be more efficient to use a version of
1120      * &lt;code&gt;setNCharacterStream&lt;/code&gt; which takes a length parameter.
1121      *
1122      * @param parameterIndex of the first parameter is 1, the second is 2, ...
1123      * @param value the parameter value
1124      * @throws SQLException if parameterIndex does not correspond to a parameter
1125      * marker in the SQL statement; if the driver does not support national
1126      *         character sets;  if the driver can detect that a data conversion
1127      *  error could occur; if a database access error occurs; or
1128      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
1129      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
1130      * @since 1.6
1131      */
1132      void setNCharacterStream(int parameterIndex, Reader value) throws SQLException;
1133 
1134     /**
1135      * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
1136      * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
1137      * because it informs the driver that the parameter value should be sent to
1138      * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
1139      * driver may have to do extra work to determine whether the parameter
1140      * data should be sent to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
1141      *
1142      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
1143      * it might be more efficient to use a version of
1144      * &lt;code&gt;setClob&lt;/code&gt; which takes a length parameter.
1145      *
1146      * @param parameterIndex index of the first parameter is 1, the second is 2, ...
1147      * @param reader An object that contains the data to set the parameter value to.
1148      * @throws SQLException if parameterIndex does not correspond to a parameter
1149      * marker in the SQL statement; if a database access error occurs; this method is called on
1150      * a closed &lt;code&gt;PreparedStatement&lt;/code&gt;or if parameterIndex does not correspond to a parameter
1151      * marker in the SQL statement
1152      *
1153      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
1154      * @since 1.6
1155      */
1156      void setClob(int parameterIndex, Reader reader)
1157        throws SQLException;
1158 
1159     /**
1160      * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
1161      * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream)&lt;/code&gt;
1162      * method because it informs the driver that the parameter value should be
1163      * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
1164      * the driver may have to do extra work to determine whether the parameter
1165      * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
1166      *
1167      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
1168      * it might be more efficient to use a version of
1169      * &lt;code&gt;setBlob&lt;/code&gt; which takes a length parameter.
1170      *
1171      * @param parameterIndex index of the first parameter is 1,
1172      * the second is 2, ...
1173      * @param inputStream An object that contains the data to set the parameter
1174      * value to.
1175      * @throws SQLException if parameterIndex does not correspond to a parameter
1176      * marker in the SQL statement; if a database access error occurs;
1177      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt; or
1178      * if parameterIndex does not correspond
1179      * to a parameter marker in the SQL statement,
1180      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
1181      *
1182      * @since 1.6
1183      */
1184      void setBlob(int parameterIndex, InputStream inputStream)
1185         throws SQLException;
1186     /**
1187      * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
1188      * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
1189      * because it informs the driver that the parameter value should be sent to
1190      * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
1191      * driver may have to do extra work to determine whether the parameter
1192      * data should be sent to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
1193      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
1194      * it might be more efficient to use a version of
1195      * &lt;code&gt;setNClob&lt;/code&gt; which takes a length parameter.
1196      *
1197      * @param parameterIndex index of the first parameter is 1, the second is 2, ...
1198      * @param reader An object that contains the data to set the parameter value to.
1199      * @throws SQLException if parameterIndex does not correspond to a parameter
1200      * marker in the SQL statement;
1201      * if the driver does not support national character sets;
1202      * if the driver can detect that a data conversion
1203      *  error could occur;  if a database access error occurs or
1204      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
1205      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
1206      *
1207      * @since 1.6
1208      */
1209      void setNClob(int parameterIndex, Reader reader)
1210        throws SQLException;
1211 
1212     //------------------------- JDBC 4.2 -----------------------------------
1213 
1214     /**
1215      * &lt;p&gt;Sets the value of the designated parameter with the given object.
1216      *
1217      * If the second argument is an {@code InputStream} then the stream
1218      * must contain the number of bytes specified by scaleOrLength.
1219      * If the second argument is a {@code Reader} then the reader must
1220      * contain the number of characters specified by scaleOrLength. If these
1221      * conditions are not true the driver will generate a
1222      * {@code SQLException} when the prepared statement is executed.
1223      *
1224      * &lt;p&gt;The given Java object will be converted to the given targetSqlType
1225      * before being sent to the database.
1226      *
1227      * If the object has a custom mapping (is of a class implementing the
1228      * interface {@code SQLData}),
1229      * the JDBC driver should call the method {@code SQLData.writeSQL} to
1230      * write it to the SQL data stream.
1231      * If, on the other hand, the object is of a class implementing
1232      * {@code Ref}, {@code Blob}, {@code Clob},  {@code NClob},
1233      *  {@code Struct}, {@code java.net.URL},
1234      * or {@code Array}, the driver should pass it to the database as a
1235      * value of the corresponding SQL type.
1236      *
1237      * &lt;p&gt;Note that this method may be used to pass database-specific
1238      * abstract data types.
1239      *&lt;P&gt;
1240      * The default implementation will throw {@code SQLFeatureNotSupportedException}
1241      *
1242      * @param parameterIndex the first parameter is 1, the second is 2, ...
1243      * @param x the object containing the input parameter value
1244      * @param targetSqlType the SQL type to be sent to the database. The
1245      * scale argument may further qualify this type.
1246      * @param scaleOrLength for {@code java.sql.JDBCType.DECIMAL}
1247      *          or {@code java.sql.JDBCType.NUMERIC types},
1248      *          this is the number of digits after the decimal point. For
1249      *          Java Object types {@code InputStream} and {@code Reader},
1250      *          this is the length
1251      *          of the data in the stream or reader.  For all other types,
1252      *          this value will be ignored.
1253      * @exception SQLException if parameterIndex does not correspond to a
1254      * parameter marker in the SQL statement; if a database access error occurs
1255      * or this method is called on a closed {@code PreparedStatement}  or
1256      *            if the Java Object specified by x is an InputStream
1257      *            or Reader object and the value of the scale parameter is less
1258      *            than zero
1259      * @exception SQLFeatureNotSupportedException if
1260      * the JDBC driver does not support the specified targetSqlType
1261      * @see JDBCType
1262      * @see SQLType
1263      * @since 1.8
1264      */
1265     default void setObject(int parameterIndex, Object x, SQLType targetSqlType,
1266              int scaleOrLength) throws SQLException {
1267         throw new SQLFeatureNotSupportedException(&quot;setObject not implemented&quot;);
1268     }
1269 
1270     /**
1271      * Sets the value of the designated parameter with the given object.
1272      *
1273      * This method is similar to {@link #setObject(int parameterIndex,
1274      * Object x, SQLType targetSqlType, int scaleOrLength)},
1275      * except that it assumes a scale of zero.
1276      *&lt;P&gt;
1277      * The default implementation will throw {@code SQLFeatureNotSupportedException}
1278      *
1279      * @param parameterIndex the first parameter is 1, the second is 2, ...
1280      * @param x the object containing the input parameter value
1281      * @param targetSqlType the SQL type to be sent to the database
1282      * @exception SQLException if parameterIndex does not correspond to a
1283      * parameter marker in the SQL statement; if a database access error occurs
1284      * or this method is called on a closed {@code PreparedStatement}
1285      * @exception SQLFeatureNotSupportedException if
1286      * the JDBC driver does not support the specified targetSqlType
1287      * @see JDBCType
1288      * @see SQLType
1289      * @since 1.8
1290      */
1291     default void setObject(int parameterIndex, Object x, SQLType targetSqlType)
1292       throws SQLException {
1293         throw new SQLFeatureNotSupportedException(&quot;setObject not implemented&quot;);
1294     }
1295 
1296     /**
1297      * Executes the SQL statement in this &lt;code&gt;PreparedStatement&lt;/code&gt; object,
1298      * which must be an SQL Data Manipulation Language (DML) statement,
1299      * such as &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or
1300      * &lt;code&gt;DELETE&lt;/code&gt;; or an SQL statement that returns nothing,
1301      * such as a DDL statement.
1302      * &lt;p&gt;
1303      * This method should be used when the returned row count may exceed
1304      * {@link Integer#MAX_VALUE}.
1305      * &lt;p&gt;
1306      * The default implementation will throw {@code UnsupportedOperationException}
1307      *
1308      * @return either (1) the row count for SQL Data Manipulation Language
1309      * (DML) statements or (2) 0 for SQL statements that return nothing
1310      * @exception SQLException if a database access error occurs;
1311      * this method is called on a closed  &lt;code&gt;PreparedStatement&lt;/code&gt;
1312      * or the SQL statement returns a &lt;code&gt;ResultSet&lt;/code&gt; object
1313      * @throws SQLTimeoutException when the driver has determined that the
1314      * timeout value that was specified by the {@code setQueryTimeout}
1315      * method has been exceeded and has at least attempted to cancel
1316      * the currently running {@code Statement}
1317      * @since 1.8
1318      */
1319     default long executeLargeUpdate() throws SQLException {
1320         throw new UnsupportedOperationException(&quot;executeLargeUpdate not implemented&quot;);
1321     }
1322 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
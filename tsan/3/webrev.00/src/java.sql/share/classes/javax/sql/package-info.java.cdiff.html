<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.sql/share/classes/javax/sql/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="XAConnectionBuilder.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/Init.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.sql/share/classes/javax/sql/package-info.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,260 ***</span>
  /**
<span class="line-modified">!  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
<span class="line-modified">!  * &lt;p&gt;</span>
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
   * particular file as subject to the &quot;Classpath&quot; exception as provided
   * by Oracle in the LICENSE file that accompanied this code.
<span class="line-modified">!  * &lt;p&gt;</span>
   * This code is distributed in the hope that it will be useful, but WITHOUT
   * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   * version 2 for more details (a copy is included in the LICENSE file that
   * accompanied this code).
<span class="line-modified">!  * &lt;p&gt;</span>
   * You should have received a copy of the GNU General Public License version
   * 2 along with this work; if not, write to the Free Software Foundation,
   * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
<span class="line-modified">!  * &lt;p&gt;</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  /**
   * Provides the API for server side data source access and processing from
   * the Java&amp;trade; programming language.
<span class="line-modified">!  * This package supplements the &lt;code&gt;java.sql&lt;/code&gt;</span>
   * package and, as of the version 1.4 release, is included in the
   * Java Platform, Standard Edition (Java SE&amp;trade;).
   * It remains an essential part of the Java Platform, Enterprise Edition
   * (Java EE&amp;trade;).
   * &lt;p&gt;
<span class="line-modified">!  * The &lt;code&gt;javax.sql&lt;/code&gt; package provides for the following:</span>
   * &lt;OL&gt;
<span class="line-modified">!  * &lt;LI&gt;The &lt;code&gt;DataSource&lt;/code&gt; interface as an alternative to the</span>
<span class="line-modified">!  * &lt;code&gt;DriverManager&lt;/code&gt; for establishing a</span>
   * connection with a data source
   * &lt;LI&gt;Connection pooling and Statement pooling
   * &lt;LI&gt;Distributed transactions
   * &lt;LI&gt;Rowsets
   * &lt;/OL&gt;
   * &lt;p&gt;
<span class="line-modified">!  * Applications use the &lt;code&gt;DataSource&lt;/code&gt; and &lt;code&gt;RowSet&lt;/code&gt;</span>
   * APIs directly, but the connection pooling and distributed transaction
   * APIs are used internally by the middle-tier infrastructure.
   *
<span class="line-modified">!  * &lt;H2&gt;Using a &lt;code&gt;DataSource&lt;/code&gt; Object to Make a Connection&lt;/H2&gt;</span>
   * &lt;p&gt;
<span class="line-modified">!  * The &lt;code&gt;javax.sql&lt;/code&gt; package provides the preferred</span>
<span class="line-modified">!  * way to make a connection with a data source.  The &lt;code&gt;DriverManager&lt;/code&gt;</span>
   * class, the original mechanism, is still valid, and code using it will
<span class="line-modified">!  * continue to run.  However, the newer &lt;code&gt;DataSource&lt;/code&gt; mechanism</span>
   * is preferred because it offers many advantages over the
<span class="line-modified">!  * &lt;code&gt;DriverManager&lt;/code&gt; mechanism.</span>
   * &lt;p&gt;
<span class="line-modified">!  * These are the main advantages of using a &lt;code&gt;DataSource&lt;/code&gt; object to</span>
   * make a connection:
   * &lt;UL&gt;
   *
   * &lt;LI&gt;Changes can be made to a data source&#39;s properties, which means
   * that it is not necessary to make changes in application code when
   * something about the data source or driver changes.
   * &lt;LI&gt;Connection  and Statement pooling and distributed transactions are available
<span class="line-modified">!  * through a &lt;code&gt;DataSource&lt;/code&gt; object that is</span>
   * implemented to work with the middle-tier infrastructure.
<span class="line-modified">!  * Connections made through the &lt;code&gt;DriverManager&lt;/code&gt;</span>
   * do not have connection and statement pooling or distributed transaction
   * capabilities.
   * &lt;/UL&gt;
   * &lt;p&gt;
<span class="line-modified">!  * Driver vendors provide &lt;code&gt;DataSource&lt;/code&gt; implementations. A</span>
<span class="line-modified">!  * particular &lt;code&gt;DataSource&lt;/code&gt; object represents a particular</span>
<span class="line-modified">!  * physical data source, and each connection the &lt;code&gt;DataSource&lt;/code&gt; object</span>
   * creates is a connection to that physical data source.
   * &lt;p&gt;
   * A logical name for the data source is registered with a naming service that
   * uses the Java Naming and Directory Interface&amp;trade;
   * (JNDI) API, usually by a system administrator or someone performing the
   * duties of a system administrator. An application can retrieve the
<span class="line-modified">!  * &lt;code&gt;DataSource&lt;/code&gt; object it wants by doing a lookup on the logical</span>
   * name that has been registered for it.  The application can then use the
<span class="line-modified">!  * &lt;code&gt;DataSource&lt;/code&gt; object to create a connection to the physical data</span>
   * source it represents.
   * &lt;p&gt;
<span class="line-modified">!  * A &lt;code&gt;DataSource&lt;/code&gt; object can be implemented to work with the</span>
   * middle tier infrastructure so that the connections it produces will be
<span class="line-modified">!  * pooled for reuse. An application that uses such a &lt;code&gt;DataSource&lt;/code&gt;</span>
   * implementation will automatically get a connection that participates in
   * connection pooling.
<span class="line-modified">!  * A &lt;code&gt;DataSource&lt;/code&gt; object can also be implemented to work with the</span>
   * middle tier infrastructure so that the connections it produces can be
   * used for distributed transactions without any special coding.
   *
   * &lt;H2&gt;Connection Pooling and Statement Pooling&lt;/H2&gt;
   * &lt;p&gt;
<span class="line-modified">!  * Connections made via a &lt;code&gt;DataSource&lt;/code&gt;</span>
   * object that is implemented to work with a middle tier connection pool manager
   * will participate in connection pooling.  This can improve performance
   * dramatically because creating new connections is very expensive.
   * Connection pooling allows a connection to be used and reused,
   * thus cutting down substantially on the number of new connections
   * that need to be created.
   * &lt;p&gt;
   * Connection pooling is totally transparent.  It is done automatically
   * in the middle tier of a Java EE configuration, so from an application&#39;s
   * viewpoint, no change in code is required. An application simply uses
<span class="line-modified">!  * the &lt;code&gt;DataSource.getConnection&lt;/code&gt; method to get the pooled</span>
<span class="line-modified">!  * connection and uses it the same way it uses any &lt;code&gt;Connection&lt;/code&gt;</span>
   * object.
   * &lt;p&gt;
   * The classes and interfaces used for connection pooling are:
   * &lt;UL&gt;
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;ConnectionPoolDataSource&lt;/code&gt;</span>
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;PooledConnection&lt;/code&gt;</span>
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;ConnectionEvent&lt;/code&gt;</span>
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;ConnectionEventListener&lt;/code&gt;</span>
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;StatementEvent&lt;/code&gt;</span>
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;StatementEventListener&lt;/code&gt;</span>
   * &lt;/UL&gt;
   * The connection pool manager, a facility in the middle tier of
   * a three-tier architecture, uses these classes and interfaces
<span class="line-modified">!  * behind the scenes.  When a &lt;code&gt;ConnectionPoolDataSource&lt;/code&gt; object</span>
<span class="line-modified">!  * is called on to create a &lt;code&gt;PooledConnection&lt;/code&gt; object, the</span>
<span class="line-modified">!  * connection pool manager will register as a &lt;code&gt;ConnectionEventListener&lt;/code&gt;</span>
<span class="line-modified">!  * object with the new &lt;code&gt;PooledConnection&lt;/code&gt; object.  When the connection</span>
   * is closed or there is an error, the connection pool manager (being a listener)
<span class="line-modified">!  * gets a notification that includes a &lt;code&gt;ConnectionEvent&lt;/code&gt; object.</span>
   * &lt;p&gt;
<span class="line-modified">!  * If the connection pool manager supports &lt;code&gt;Statement&lt;/code&gt; pooling, for</span>
<span class="line-modified">!  * &lt;code&gt;PreparedStatements&lt;/code&gt;, which can be determined by invoking the method</span>
<span class="line-modified">!  * &lt;code&gt;DatabaseMetaData.supportsStatementPooling&lt;/code&gt;,  the</span>
<span class="line-modified">!  * connection pool manager will register as a &lt;code&gt;StatementEventListener&lt;/code&gt;</span>
<span class="line-modified">!  * object with the new &lt;code&gt;PooledConnection&lt;/code&gt; object.  When the</span>
<span class="line-modified">!  * &lt;code&gt;PreparedStatement&lt;/code&gt; is closed or there is an error, the connection</span>
   * pool manager (being a listener)
<span class="line-modified">!  * gets a notification that includes a &lt;code&gt;StatementEvent&lt;/code&gt; object.</span>
   *
   * &lt;H2&gt;Distributed Transactions&lt;/H2&gt;
   * &lt;p&gt;
<span class="line-modified">!  * As with pooled connections, connections made via a &lt;code&gt;DataSource&lt;/code&gt;</span>
   * object that is implemented to work with the middle tier infrastructure
   * may participate in distributed transactions.  This gives an application
   * the ability to involve data sources on multiple servers in a single
   * transaction.
   * &lt;p&gt;
   * The classes and interfaces used for distributed transactions are:
   * &lt;UL&gt;
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;XADataSource&lt;/code&gt;</span>
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;XAConnection&lt;/code&gt;</span>
   * &lt;/UL&gt;
   * These interfaces are used by the transaction manager; an application does
   * not use them directly.
   * &lt;p&gt;
<span class="line-modified">!  * The &lt;code&gt;XAConnection&lt;/code&gt; interface is derived from the</span>
<span class="line-modified">!  * &lt;code&gt;PooledConnection&lt;/code&gt; interface, so what applies to a pooled connection</span>
   * also applies to a connection that is part of a distributed transaction.
   * A transaction manager in the middle tier handles everything transparently.
   * The only change in application code is that an application cannot do anything
   * that would interfere with the transaction manager&#39;s handling of the transaction.
<span class="line-modified">!  * Specifically, an application cannot call the methods &lt;code&gt;Connection.commit&lt;/code&gt;</span>
<span class="line-modified">!  * or &lt;code&gt;Connection.rollback&lt;/code&gt;, and it cannot set the connection to be in</span>
   * auto-commit mode (that is, it cannot call
<span class="line-modified">!  * &lt;code&gt;Connection.setAutoCommit(true)&lt;/code&gt;).</span>
   * &lt;p&gt;
   * An application does not need to do anything special to participate in a
   * distributed transaction.
   * It simply creates connections to the data sources it wants to use via
<span class="line-modified">!  * the &lt;code&gt;DataSource.getConnection&lt;/code&gt; method, just as it normally does.</span>
   * The transaction manager manages the transaction behind the scenes.  The
<span class="line-modified">!  * &lt;code&gt;XADataSource&lt;/code&gt; interface creates &lt;code&gt;XAConnection&lt;/code&gt; objects, and</span>
<span class="line-modified">!  * each &lt;code&gt;XAConnection&lt;/code&gt; object creates an &lt;code&gt;XAResource&lt;/code&gt; object</span>
   * that the transaction manager uses to manage the connection.
   *
   *
   * &lt;H2&gt;Rowsets&lt;/H2&gt;
<span class="line-modified">!  * The &lt;code&gt;RowSet&lt;/code&gt; interface works with various other classes and</span>
   * interfaces behind the scenes. These can be grouped into three categories.
   * &lt;OL&gt;
   * &lt;LI&gt;Event Notification
   * &lt;UL&gt;
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;RowSetListener&lt;/code&gt;&lt;br&gt;</span>
<span class="line-modified">!  * A &lt;code&gt;RowSet&lt;/code&gt; object is a JavaBeans&amp;trade;</span>
   * component because it has properties and participates in the JavaBeans
<span class="line-modified">!  * event notification mechanism. The &lt;code&gt;RowSetListener&lt;/code&gt; interface</span>
   * is implemented by a component that wants to be notified about events that
<span class="line-modified">!  * occur to a particular &lt;code&gt;RowSet&lt;/code&gt; object.  Such a component registers</span>
<span class="line-modified">!  * itself as a listener with a rowset via the &lt;code&gt;RowSet.addRowSetListener&lt;/code&gt;</span>
   * method.
   * &lt;p&gt;
<span class="line-modified">!  * When the &lt;code&gt;RowSet&lt;/code&gt; object changes one of its rows, changes all of</span>
   * it rows, or moves its cursor, it also notifies each listener that is registered
   * with it.  The listener reacts by carrying out its implementation of the
   * notification method called on it.
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;RowSetEvent&lt;/code&gt;&lt;br&gt;</span>
<span class="line-modified">!  * As part of its internal notification process, a &lt;code&gt;RowSet&lt;/code&gt; object</span>
<span class="line-modified">!  * creates an instance of &lt;code&gt;RowSetEvent&lt;/code&gt; and passes it to the listener.</span>
<span class="line-modified">!  * The listener can use this &lt;code&gt;RowSetEvent&lt;/code&gt; object to find out which rowset</span>
   * had the event.
   * &lt;/UL&gt;
   * &lt;LI&gt;Metadata
   * &lt;UL&gt;
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;RowSetMetaData&lt;/code&gt;&lt;br&gt;</span>
   * This interface, derived from the
<span class="line-modified">!  * &lt;code&gt;ResultSetMetaData&lt;/code&gt; interface, provides information about</span>
<span class="line-modified">!  * the columns in a &lt;code&gt;RowSet&lt;/code&gt; object.  An application can use</span>
<span class="line-modified">!  * &lt;code&gt;RowSetMetaData&lt;/code&gt; methods to find out how many columns the</span>
   * rowset contains and what kind of data each column can contain.
   * &lt;p&gt;
<span class="line-modified">!  * The &lt;code&gt;RowSetMetaData&lt;/code&gt; interface provides methods for</span>
   * setting the information about columns, but an application would not
<span class="line-modified">!  * normally use these methods.  When an application calls the &lt;code&gt;RowSet&lt;/code&gt;</span>
<span class="line-modified">!  * method &lt;code&gt;execute&lt;/code&gt;, the &lt;code&gt;RowSet&lt;/code&gt; object will contain</span>
<span class="line-modified">!  * a new set of rows, and its &lt;code&gt;RowSetMetaData&lt;/code&gt; object will have been</span>
   * internally updated to contain information about the new columns.
   * &lt;/UL&gt;
   * &lt;LI&gt;The Reader/Writer Facility&lt;br&gt;
<span class="line-modified">!  * A &lt;code&gt;RowSet&lt;/code&gt; object that implements the &lt;code&gt;RowSetInternal&lt;/code&gt;</span>
<span class="line-modified">!  * interface can call on the &lt;code&gt;RowSetReader&lt;/code&gt; object associated with it</span>
<span class="line-modified">!  * to populate itself with data.  It can also call on the &lt;code&gt;RowSetWriter&lt;/code&gt;</span>
   * object associated with it to write any changes to its rows back to the
   * data source from which it originally got the rows.
   * A rowset that remains connected to its data source does not need to use a
   * reader and writer because it can simply operate on the data source directly.
   *
   * &lt;UL&gt;
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;RowSetInternal&lt;/code&gt;&lt;br&gt;</span>
<span class="line-modified">!  * By implementing the &lt;code&gt;RowSetInternal&lt;/code&gt; interface, a</span>
<span class="line-modified">!  * &lt;code&gt;RowSet&lt;/code&gt; object gets access to</span>
   * its internal state and is able to call on its reader and writer. A rowset
   * keeps track of the values in its current rows and of the values that immediately
   * preceded the current ones, referred to as the &lt;i&gt;original&lt;/i&gt; values.  A rowset
   * also keeps track of (1) the parameters that have been set for its command and
   * (2) the connection that was passed to it, if any.  A rowset uses the
<span class="line-modified">!  * &lt;code&gt;RowSetInternal&lt;/code&gt; methods behind the scenes to get access to</span>
   * this information.  An application does not normally invoke these methods directly.
   *
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;RowSetReader&lt;/code&gt;&lt;br&gt;</span>
<span class="line-modified">!  * A disconnected &lt;code&gt;RowSet&lt;/code&gt; object that has implemented the</span>
<span class="line-modified">!  * &lt;code&gt;RowSetInternal&lt;/code&gt; interface can call on its reader (the</span>
<span class="line-modified">!  * &lt;code&gt;RowSetReader&lt;/code&gt; object associated with it) to populate it with</span>
<span class="line-modified">!  * data.  When an application calls the &lt;code&gt;RowSet.execute&lt;/code&gt; method,</span>
   * that method calls on the rowset&#39;s reader to do much of the work. Implementations
   * can vary widely, but generally a reader makes a connection to the data source,
   * reads data from the data source and populates the rowset with it, and closes
<span class="line-modified">!  * the connection. A reader may also update the &lt;code&gt;RowSetMetaData&lt;/code&gt; object</span>
   * for its rowset.  The rowset&#39;s internal state is also updated, either by the
<span class="line-modified">!  * reader or directly by the method &lt;code&gt;RowSet.execute&lt;/code&gt;.</span>
   *
   *
<span class="line-modified">!  * &lt;LI&gt;&lt;code&gt;RowSetWriter&lt;/code&gt;&lt;br&gt;</span>
<span class="line-modified">!  * A disconnected &lt;code&gt;RowSet&lt;/code&gt; object that has implemented the</span>
<span class="line-modified">!  * &lt;code&gt;RowSetInternal&lt;/code&gt; interface can call on its writer (the</span>
<span class="line-modified">!  * &lt;code&gt;RowSetWriter&lt;/code&gt; object associated with it) to write changes</span>
   * back to the underlying data source.  Implementations may vary widely, but
   * generally, a writer will do the following:
   *
   * &lt;UL&gt;
   * &lt;LI&gt;Make a connection to the data source
<span class="line-new-header">--- 1,260 ---</span>
  /**
<span class="line-modified">!  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
<span class="line-modified">!  *</span>
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
   * particular file as subject to the &quot;Classpath&quot; exception as provided
   * by Oracle in the LICENSE file that accompanied this code.
<span class="line-modified">!  *</span>
   * This code is distributed in the hope that it will be useful, but WITHOUT
   * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   * version 2 for more details (a copy is included in the LICENSE file that
   * accompanied this code).
<span class="line-modified">!  *</span>
   * You should have received a copy of the GNU General Public License version
   * 2 along with this work; if not, write to the Free Software Foundation,
   * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
<span class="line-modified">!  *</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  /**
   * Provides the API for server side data source access and processing from
   * the Java&amp;trade; programming language.
<span class="line-modified">!  * This package supplements the {@code java.sql}</span>
   * package and, as of the version 1.4 release, is included in the
   * Java Platform, Standard Edition (Java SE&amp;trade;).
   * It remains an essential part of the Java Platform, Enterprise Edition
   * (Java EE&amp;trade;).
   * &lt;p&gt;
<span class="line-modified">!  * The {@code javax.sql} package provides for the following:</span>
   * &lt;OL&gt;
<span class="line-modified">!  * &lt;LI&gt;The {@code DataSource} interface as an alternative to the</span>
<span class="line-modified">!  * {@code DriverManager} for establishing a</span>
   * connection with a data source
   * &lt;LI&gt;Connection pooling and Statement pooling
   * &lt;LI&gt;Distributed transactions
   * &lt;LI&gt;Rowsets
   * &lt;/OL&gt;
   * &lt;p&gt;
<span class="line-modified">!  * Applications use the {@code DataSource} and {@code RowSet}</span>
   * APIs directly, but the connection pooling and distributed transaction
   * APIs are used internally by the middle-tier infrastructure.
   *
<span class="line-modified">!  * &lt;H2&gt;Using a {@code DataSource} Object to Make a Connection&lt;/H2&gt;</span>
   * &lt;p&gt;
<span class="line-modified">!  * The {@code javax.sql} package provides the preferred</span>
<span class="line-modified">!  * way to make a connection with a data source.  The {@code DriverManager}</span>
   * class, the original mechanism, is still valid, and code using it will
<span class="line-modified">!  * continue to run.  However, the newer {@code DataSource} mechanism</span>
   * is preferred because it offers many advantages over the
<span class="line-modified">!  * {@code DriverManager} mechanism.</span>
   * &lt;p&gt;
<span class="line-modified">!  * These are the main advantages of using a {@code DataSource} object to</span>
   * make a connection:
   * &lt;UL&gt;
   *
   * &lt;LI&gt;Changes can be made to a data source&#39;s properties, which means
   * that it is not necessary to make changes in application code when
   * something about the data source or driver changes.
   * &lt;LI&gt;Connection  and Statement pooling and distributed transactions are available
<span class="line-modified">!  * through a {@code DataSource} object that is</span>
   * implemented to work with the middle-tier infrastructure.
<span class="line-modified">!  * Connections made through the {@code DriverManager}</span>
   * do not have connection and statement pooling or distributed transaction
   * capabilities.
   * &lt;/UL&gt;
   * &lt;p&gt;
<span class="line-modified">!  * Driver vendors provide {@code DataSource} implementations. A</span>
<span class="line-modified">!  * particular {@code DataSource} object represents a particular</span>
<span class="line-modified">!  * physical data source, and each connection the {@code DataSource} object</span>
   * creates is a connection to that physical data source.
   * &lt;p&gt;
   * A logical name for the data source is registered with a naming service that
   * uses the Java Naming and Directory Interface&amp;trade;
   * (JNDI) API, usually by a system administrator or someone performing the
   * duties of a system administrator. An application can retrieve the
<span class="line-modified">!  * {@code DataSource} object it wants by doing a lookup on the logical</span>
   * name that has been registered for it.  The application can then use the
<span class="line-modified">!  * {@code DataSource} object to create a connection to the physical data</span>
   * source it represents.
   * &lt;p&gt;
<span class="line-modified">!  * A {@code DataSource} object can be implemented to work with the</span>
   * middle tier infrastructure so that the connections it produces will be
<span class="line-modified">!  * pooled for reuse. An application that uses such a {@code DataSource}</span>
   * implementation will automatically get a connection that participates in
   * connection pooling.
<span class="line-modified">!  * A {@code DataSource} object can also be implemented to work with the</span>
   * middle tier infrastructure so that the connections it produces can be
   * used for distributed transactions without any special coding.
   *
   * &lt;H2&gt;Connection Pooling and Statement Pooling&lt;/H2&gt;
   * &lt;p&gt;
<span class="line-modified">!  * Connections made via a {@code DataSource}</span>
   * object that is implemented to work with a middle tier connection pool manager
   * will participate in connection pooling.  This can improve performance
   * dramatically because creating new connections is very expensive.
   * Connection pooling allows a connection to be used and reused,
   * thus cutting down substantially on the number of new connections
   * that need to be created.
   * &lt;p&gt;
   * Connection pooling is totally transparent.  It is done automatically
   * in the middle tier of a Java EE configuration, so from an application&#39;s
   * viewpoint, no change in code is required. An application simply uses
<span class="line-modified">!  * the {@code DataSource.getConnection} method to get the pooled</span>
<span class="line-modified">!  * connection and uses it the same way it uses any {@code Connection}</span>
   * object.
   * &lt;p&gt;
   * The classes and interfaces used for connection pooling are:
   * &lt;UL&gt;
<span class="line-modified">!  * &lt;LI&gt;{@code ConnectionPoolDataSource}</span>
<span class="line-modified">!  * &lt;LI&gt;{@code PooledConnection}</span>
<span class="line-modified">!  * &lt;LI&gt;{@code ConnectionEvent}</span>
<span class="line-modified">!  * &lt;LI&gt;{@code ConnectionEventListener}</span>
<span class="line-modified">!  * &lt;LI&gt;{@code StatementEvent}</span>
<span class="line-modified">!  * &lt;LI&gt;{@code StatementEventListener}</span>
   * &lt;/UL&gt;
   * The connection pool manager, a facility in the middle tier of
   * a three-tier architecture, uses these classes and interfaces
<span class="line-modified">!  * behind the scenes.  When a {@code ConnectionPoolDataSource} object</span>
<span class="line-modified">!  * is called on to create a {@code PooledConnection} object, the</span>
<span class="line-modified">!  * connection pool manager will register as a {@code ConnectionEventListener}</span>
<span class="line-modified">!  * object with the new {@code PooledConnection} object.  When the connection</span>
   * is closed or there is an error, the connection pool manager (being a listener)
<span class="line-modified">!  * gets a notification that includes a {@code ConnectionEvent} object.</span>
   * &lt;p&gt;
<span class="line-modified">!  * If the connection pool manager supports {@code Statement} pooling, for</span>
<span class="line-modified">!  * {@code PreparedStatements}, which can be determined by invoking the method</span>
<span class="line-modified">!  * {@code DatabaseMetaData.supportsStatementPooling},  the</span>
<span class="line-modified">!  * connection pool manager will register as a {@code StatementEventListener}</span>
<span class="line-modified">!  * object with the new {@code PooledConnection} object.  When the</span>
<span class="line-modified">!  * {@code PreparedStatement} is closed or there is an error, the connection</span>
   * pool manager (being a listener)
<span class="line-modified">!  * gets a notification that includes a {@code StatementEvent} object.</span>
   *
   * &lt;H2&gt;Distributed Transactions&lt;/H2&gt;
   * &lt;p&gt;
<span class="line-modified">!  * As with pooled connections, connections made via a {@code DataSource}</span>
   * object that is implemented to work with the middle tier infrastructure
   * may participate in distributed transactions.  This gives an application
   * the ability to involve data sources on multiple servers in a single
   * transaction.
   * &lt;p&gt;
   * The classes and interfaces used for distributed transactions are:
   * &lt;UL&gt;
<span class="line-modified">!  * &lt;LI&gt;{@code XADataSource}</span>
<span class="line-modified">!  * &lt;LI&gt;{@code XAConnection}</span>
   * &lt;/UL&gt;
   * These interfaces are used by the transaction manager; an application does
   * not use them directly.
   * &lt;p&gt;
<span class="line-modified">!  * The {@code XAConnection} interface is derived from the</span>
<span class="line-modified">!  * {@code PooledConnection} interface, so what applies to a pooled connection</span>
   * also applies to a connection that is part of a distributed transaction.
   * A transaction manager in the middle tier handles everything transparently.
   * The only change in application code is that an application cannot do anything
   * that would interfere with the transaction manager&#39;s handling of the transaction.
<span class="line-modified">!  * Specifically, an application cannot call the methods {@code Connection.commit}</span>
<span class="line-modified">!  * or {@code Connection.rollback}, and it cannot set the connection to be in</span>
   * auto-commit mode (that is, it cannot call
<span class="line-modified">!  * {@code Connection.setAutoCommit(true)}).</span>
   * &lt;p&gt;
   * An application does not need to do anything special to participate in a
   * distributed transaction.
   * It simply creates connections to the data sources it wants to use via
<span class="line-modified">!  * the {@code DataSource.getConnection} method, just as it normally does.</span>
   * The transaction manager manages the transaction behind the scenes.  The
<span class="line-modified">!  * {@code XADataSource} interface creates {@code XAConnection} objects, and</span>
<span class="line-modified">!  * each {@code XAConnection} object creates an {@code XAResource} object</span>
   * that the transaction manager uses to manage the connection.
   *
   *
   * &lt;H2&gt;Rowsets&lt;/H2&gt;
<span class="line-modified">!  * The {@code RowSet} interface works with various other classes and</span>
   * interfaces behind the scenes. These can be grouped into three categories.
   * &lt;OL&gt;
   * &lt;LI&gt;Event Notification
   * &lt;UL&gt;
<span class="line-modified">!  * &lt;LI&gt;{@code RowSetListener}&lt;br&gt;</span>
<span class="line-modified">!  * A {@code RowSet} object is a JavaBeans&amp;trade;</span>
   * component because it has properties and participates in the JavaBeans
<span class="line-modified">!  * event notification mechanism. The {@code RowSetListener} interface</span>
   * is implemented by a component that wants to be notified about events that
<span class="line-modified">!  * occur to a particular {@code RowSet} object.  Such a component registers</span>
<span class="line-modified">!  * itself as a listener with a rowset via the {@code RowSet.addRowSetListener}</span>
   * method.
   * &lt;p&gt;
<span class="line-modified">!  * When the {@code RowSet} object changes one of its rows, changes all of</span>
   * it rows, or moves its cursor, it also notifies each listener that is registered
   * with it.  The listener reacts by carrying out its implementation of the
   * notification method called on it.
<span class="line-modified">!  * &lt;LI&gt;{@code RowSetEvent}&lt;br&gt;</span>
<span class="line-modified">!  * As part of its internal notification process, a {@code RowSet} object</span>
<span class="line-modified">!  * creates an instance of {@code RowSetEvent} and passes it to the listener.</span>
<span class="line-modified">!  * The listener can use this {@code RowSetEvent} object to find out which rowset</span>
   * had the event.
   * &lt;/UL&gt;
   * &lt;LI&gt;Metadata
   * &lt;UL&gt;
<span class="line-modified">!  * &lt;LI&gt;{@code RowSetMetaData}&lt;br&gt;</span>
   * This interface, derived from the
<span class="line-modified">!  * {@code ResultSetMetaData} interface, provides information about</span>
<span class="line-modified">!  * the columns in a {@code RowSet} object.  An application can use</span>
<span class="line-modified">!  * {@code RowSetMetaData} methods to find out how many columns the</span>
   * rowset contains and what kind of data each column can contain.
   * &lt;p&gt;
<span class="line-modified">!  * The {@code RowSetMetaData} interface provides methods for</span>
   * setting the information about columns, but an application would not
<span class="line-modified">!  * normally use these methods.  When an application calls the {@code RowSet}</span>
<span class="line-modified">!  * method {@code execute}, the {@code RowSet} object will contain</span>
<span class="line-modified">!  * a new set of rows, and its {@code RowSetMetaData} object will have been</span>
   * internally updated to contain information about the new columns.
   * &lt;/UL&gt;
   * &lt;LI&gt;The Reader/Writer Facility&lt;br&gt;
<span class="line-modified">!  * A {@code RowSet} object that implements the {@code RowSetInternal}</span>
<span class="line-modified">!  * interface can call on the {@code RowSetReader} object associated with it</span>
<span class="line-modified">!  * to populate itself with data.  It can also call on the {@code RowSetWriter}</span>
   * object associated with it to write any changes to its rows back to the
   * data source from which it originally got the rows.
   * A rowset that remains connected to its data source does not need to use a
   * reader and writer because it can simply operate on the data source directly.
   *
   * &lt;UL&gt;
<span class="line-modified">!  * &lt;LI&gt;{@code RowSetInternal}&lt;br&gt;</span>
<span class="line-modified">!  * By implementing the {@code RowSetInternal} interface, a</span>
<span class="line-modified">!  * {@code RowSet} object gets access to</span>
   * its internal state and is able to call on its reader and writer. A rowset
   * keeps track of the values in its current rows and of the values that immediately
   * preceded the current ones, referred to as the &lt;i&gt;original&lt;/i&gt; values.  A rowset
   * also keeps track of (1) the parameters that have been set for its command and
   * (2) the connection that was passed to it, if any.  A rowset uses the
<span class="line-modified">!  * {@code RowSetInternal} methods behind the scenes to get access to</span>
   * this information.  An application does not normally invoke these methods directly.
   *
<span class="line-modified">!  * &lt;LI&gt;{@code RowSetReader}&lt;br&gt;</span>
<span class="line-modified">!  * A disconnected {@code RowSet} object that has implemented the</span>
<span class="line-modified">!  * {@code RowSetInternal} interface can call on its reader (the</span>
<span class="line-modified">!  * {@code RowSetReader} object associated with it) to populate it with</span>
<span class="line-modified">!  * data.  When an application calls the {@code RowSet.execute} method,</span>
   * that method calls on the rowset&#39;s reader to do much of the work. Implementations
   * can vary widely, but generally a reader makes a connection to the data source,
   * reads data from the data source and populates the rowset with it, and closes
<span class="line-modified">!  * the connection. A reader may also update the {@code RowSetMetaData} object</span>
   * for its rowset.  The rowset&#39;s internal state is also updated, either by the
<span class="line-modified">!  * reader or directly by the method {@code RowSet.execute}.</span>
   *
   *
<span class="line-modified">!  * &lt;LI&gt;{@code RowSetWriter}&lt;br&gt;</span>
<span class="line-modified">!  * A disconnected {@code RowSet} object that has implemented the</span>
<span class="line-modified">!  * {@code RowSetInternal} interface can call on its writer (the</span>
<span class="line-modified">!  * {@code RowSetWriter} object associated with it) to write changes</span>
   * back to the underlying data source.  Implementations may vary widely, but
   * generally, a writer will do the following:
   *
   * &lt;UL&gt;
   * &lt;LI&gt;Make a connection to the data source
</pre>
<hr />
<pre>
<span class="line-old-header">*** 267,11 ***</span>
   *
   *
   * &lt;/UL&gt;
   * &lt;/OL&gt;
   * &lt;p&gt;
<span class="line-modified">!  * The &lt;code&gt;RowSet&lt;/code&gt; interface may be implemented in any number of</span>
   * ways, and anyone may write an implementation. Developers are encouraged
   * to use their imaginations in coming up with new ways to use rowsets.
   *
   *
   * &lt;h2&gt;Package Specification&lt;/h2&gt;
<span class="line-new-header">--- 267,11 ---</span>
   *
   *
   * &lt;/UL&gt;
   * &lt;/OL&gt;
   * &lt;p&gt;
<span class="line-modified">!  * The {@code RowSet} interface may be implemented in any number of</span>
   * ways, and anyone may write an implementation. Developers are encouraged
   * to use their imaginations in coming up with new ways to use rowsets.
   *
   *
   * &lt;h2&gt;Package Specification&lt;/h2&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 281,14 ***</span>
   * &lt;/ul&gt;
   *
   * &lt;h2&gt;Related Documentation&lt;/h2&gt;
   * &lt;p&gt;
   * The Java Series book published by Addison-Wesley Longman provides detailed
<span class="line-modified">!  * information about the classes and interfaces in the &lt;code&gt;javax.sql&lt;/code&gt;</span>
   * package:
   *
   * &lt;ul&gt;
<span class="line-modified">!  * &lt;li&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/index-142838.html&quot;&gt;</span>
<span class="line-removed">-  * &lt;i&gt;JDBC&amp;#8482;API Tutorial and Reference, Third Edition&lt;/i&gt;&lt;/a&gt;</span>
   * &lt;/ul&gt;
   */
  package javax.sql;
<span class="line-new-header">--- 281,13 ---</span>
   * &lt;/ul&gt;
   *
   * &lt;h2&gt;Related Documentation&lt;/h2&gt;
   * &lt;p&gt;
   * The Java Series book published by Addison-Wesley Longman provides detailed
<span class="line-modified">!  * information about the classes and interfaces in the {@code javax.sql}</span>
   * package:
   *
   * &lt;ul&gt;
<span class="line-modified">!  * &lt;li&gt;&amp;ldquo;&lt;i&gt;JDBC&amp;#8482;API Tutorial and Reference, Third Edition&lt;/i&gt;&amp;rdquo;</span>
   * &lt;/ul&gt;
   */
  package javax.sql;
</pre>
<center><a href="XAConnectionBuilder.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/Init.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.instrument/share/native/libinstrument/InvocationAdapter.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Copyright 2003 Wily Technology, Inc.
 28  */
 29 
 30 #include    &lt;string.h&gt;
 31 #include    &lt;stdlib.h&gt;
 32 
 33 #include    &quot;jni.h&quot;
 34 
<a name="2" id="anc2"></a><span class="line-added"> 35 #include    &quot;jdk_util.h&quot;</span>
<span class="line-added"> 36 </span>
 37 #include    &quot;Utilities.h&quot;
 38 #include    &quot;JPLISAssert.h&quot;
 39 #include    &quot;JPLISAgent.h&quot;
 40 #include    &quot;JavaExceptions.h&quot;
 41 
 42 #include    &quot;EncodingSupport.h&quot;
 43 #include    &quot;FileSystemSupport.h&quot;
 44 #include    &quot;JarFacade.h&quot;
 45 #include    &quot;PathCharsValidator.h&quot;
 46 
 47 /**
 48  * This module contains the direct interface points with the JVMTI.
 49  * The OnLoad handler is here, along with the various event handlers.
 50  */
 51 
 52 static int
 53 appendClassPath(JPLISAgent* agent,
 54                 const char* jarfile);
 55 
 56 static void
 57 appendBootClassPath(JPLISAgent* agent,
 58                     const char* jarfile,
 59                     const char* pathList);
 60 
 61 
 62 /*
 63  * Parse -javaagent tail, of the form name[=options], into name
 64  * and options. Returned values are heap allocated and options maybe
 65  * NULL. Returns 0 if parse succeeds, -1 if allocation fails.
 66  */
 67 static int
 68 parseArgumentTail(char* tail, char** name, char** options) {
 69     int len;
 70     char* pos;
 71 
 72     pos = strchr(tail, &#39;=&#39;);
 73     len = (pos == NULL) ? (int)strlen(tail) : (int)(pos - tail);
 74 
 75     *name = (char*)malloc(len+1);
 76     if (*name == NULL) {
 77         return -1;
 78     }
 79     memcpy(*name, tail, len);
 80     (*name)[len] = &#39;\0&#39;;
 81 
 82     if (pos == NULL) {
 83         *options = NULL;
 84     } else {
 85         char * str = (char*)malloc( (int)strlen(pos + 1) + 1 );
 86         if (str == NULL) {
 87             free(*name);
 88             return -1;
 89         }
 90         strcpy(str, pos +1);
 91         *options = str;
 92     }
 93     return 0;
 94 }
 95 
 96 /*
 97  * Get the value of an attribute in an attribute list. Returns NULL
 98  * if attribute not found.
 99  */
100 jboolean
101 getBooleanAttribute(const jarAttribute* attributes, const char* name) {
102     char* attributeValue = getAttribute(attributes, name);
103     return attributeValue != NULL &amp;&amp; strcasecmp(attributeValue, &quot;true&quot;) == 0;
104 }
105 
106 /*
107  * Parse any capability settings in the JAR manifest and
108  * convert them to JVM TI capabilities.
109  */
110 void
111 convertCapabilityAttributes(const jarAttribute* attributes, JPLISAgent* agent) {
112     /* set redefineClasses capability */
113     if (getBooleanAttribute(attributes, &quot;Can-Redefine-Classes&quot;)) {
114         addRedefineClassesCapability(agent);
115     }
116 
117     /* create an environment which has the retransformClasses capability */
118     if (getBooleanAttribute(attributes, &quot;Can-Retransform-Classes&quot;)) {
119         retransformableEnvironment(agent);
120     }
121 
122     /* set setNativeMethodPrefix capability */
123     if (getBooleanAttribute(attributes, &quot;Can-Set-Native-Method-Prefix&quot;)) {
124         addNativeMethodPrefixCapability(agent);
125     }
126 
127     /* for retransformClasses testing, set capability to use original method order */
128     if (getBooleanAttribute(attributes, &quot;Can-Maintain-Original-Method-Order&quot;)) {
129         addOriginalMethodOrderCapability(agent);
130     }
131 }
132 
133 /*
134  *  This will be called once for every -javaagent on the command line.
135  *  Each call to Agent_OnLoad will create its own agent and agent data.
136  *
137  *  The argument tail string provided to Agent_OnLoad will be of form
138  *  &lt;jarfile&gt;[=&lt;options&gt;]. The tail string is split into the jarfile and
139  *  options components. The jarfile manifest is parsed and the value of the
140  *  Premain-Class attribute will become the agent&#39;s premain class. The jar
141  *  file is then added to the system class path, and if the Boot-Class-Path
142  *  attribute is present then all relative URLs in the value are processed
143  *  to create boot class path segments to append to the boot class path.
144  */
145 JNIEXPORT jint JNICALL
146 DEF_Agent_OnLoad(JavaVM *vm, char *tail, void * reserved) {
147     JPLISInitializationError initerror  = JPLIS_INIT_ERROR_NONE;
148     jint                     result     = JNI_OK;
149     JPLISAgent *             agent      = NULL;
150 
151     initerror = createNewJPLISAgent(vm, &amp;agent);
152     if ( initerror == JPLIS_INIT_ERROR_NONE ) {
153         int             oldLen, newLen;
154         char *          jarfile;
155         char *          options;
156         jarAttribute*   attributes;
157         char *          premainClass;
158         char *          bootClassPath;
159 
160         /*
161          * Parse &lt;jarfile&gt;[=options] into jarfile and options
162          */
163         if (parseArgumentTail(tail, &amp;jarfile, &amp;options) != 0) {
164             fprintf(stderr, &quot;-javaagent: memory allocation failure.\n&quot;);
165             return JNI_ERR;
166         }
167 
168         /*
169          * Agent_OnLoad is specified to provide the agent options
170          * argument tail in modified UTF8. However for 1.5.0 this is
171          * actually in the platform encoding - see 5049313.
172          *
173          * Open zip/jar file and parse archive. If can&#39;t be opened or
174          * not a zip file return error. Also if Premain-Class attribute
175          * isn&#39;t present we return an error.
176          */
177         attributes = readAttributes(jarfile);
178         if (attributes == NULL) {
179             fprintf(stderr, &quot;Error opening zip file or JAR manifest missing : %s\n&quot;, jarfile);
180             free(jarfile);
181             if (options != NULL) free(options);
182             return JNI_ERR;
183         }
184 
185         premainClass = getAttribute(attributes, &quot;Premain-Class&quot;);
186         if (premainClass == NULL) {
187             fprintf(stderr, &quot;Failed to find Premain-Class manifest attribute in %s\n&quot;,
188                 jarfile);
189             free(jarfile);
190             if (options != NULL) free(options);
191             freeAttributes(attributes);
192             return JNI_ERR;
193         }
194 
195         /* Save the jarfile name */
196         agent-&gt;mJarfile = jarfile;
197 
198         /*
199          * The value of the Premain-Class attribute becomes the agent
200          * class name. The manifest is in UTF8 so need to convert to
201          * modified UTF8 (see JNI spec).
202          */
203         oldLen = (int)strlen(premainClass);
204         newLen = modifiedUtf8LengthOfUtf8(premainClass, oldLen);
205         if (newLen == oldLen) {
206             premainClass = strdup(premainClass);
207         } else {
208             char* str = (char*)malloc( newLen+1 );
209             if (str != NULL) {
210                 convertUtf8ToModifiedUtf8(premainClass, oldLen, str, newLen);
211             }
212             premainClass = str;
213         }
214         if (premainClass == NULL) {
215             fprintf(stderr, &quot;-javaagent: memory allocation failed\n&quot;);
216             free(jarfile);
217             if (options != NULL) free(options);
218             freeAttributes(attributes);
219             return JNI_ERR;
220         }
221 
222         /*
223          * If the Boot-Class-Path attribute is specified then we process
224          * each relative URL and add it to the bootclasspath.
225          */
226         bootClassPath = getAttribute(attributes, &quot;Boot-Class-Path&quot;);
227         if (bootClassPath != NULL) {
228             appendBootClassPath(agent, jarfile, bootClassPath);
229         }
230 
231         /*
232          * Convert JAR attributes into agent capabilities
233          */
234         convertCapabilityAttributes(attributes, agent);
235 
236         /*
237          * Track (record) the agent class name and options data
238          */
239         initerror = recordCommandLineData(agent, premainClass, options);
240 
241         /*
242          * Clean-up
243          */
244         if (options != NULL) free(options);
245         freeAttributes(attributes);
246         free(premainClass);
247     }
248 
249     switch (initerror) {
250     case JPLIS_INIT_ERROR_NONE:
251       result = JNI_OK;
252       break;
253     case JPLIS_INIT_ERROR_CANNOT_CREATE_NATIVE_AGENT:
254       result = JNI_ERR;
255       fprintf(stderr, &quot;java.lang.instrument/-javaagent: cannot create native agent.\n&quot;);
256       break;
257     case JPLIS_INIT_ERROR_FAILURE:
258       result = JNI_ERR;
259       fprintf(stderr, &quot;java.lang.instrument/-javaagent: initialization of native agent failed.\n&quot;);
260       break;
261     case JPLIS_INIT_ERROR_ALLOCATION_FAILURE:
262       result = JNI_ERR;
263       fprintf(stderr, &quot;java.lang.instrument/-javaagent: allocation failure.\n&quot;);
264       break;
265     case JPLIS_INIT_ERROR_AGENT_CLASS_NOT_SPECIFIED:
266       result = JNI_ERR;
267       fprintf(stderr, &quot;-javaagent: agent class not specified.\n&quot;);
268       break;
269     default:
270       result = JNI_ERR;
271       fprintf(stderr, &quot;java.lang.instrument/-javaagent: unknown error\n&quot;);
272       break;
273     }
274     return result;
275 }
276 
277 /*
278  * Agent_OnAttach returns a jint. 0/JNI_OK indicates success and non-0
279  * indicates an error. To allow the attach mechanism throw an
280  * AgentInitializationException with a reasonable exception message we define
281  * a few specific errors here.
282  */
283 #define AGENT_ERROR_BADJAR    ((jint)100)  /* Agent JAR not found or no Agent-Class attribute */
284 #define AGENT_ERROR_NOTONCP   ((jint)101)  /* Unable to add JAR file to system class path */
285 #define AGENT_ERROR_STARTFAIL ((jint)102)  /* No agentmain method or agentmain failed */
286 
287 /*
288  *  This will be called once each time a tool attaches to the VM and loads
289  *  the JPLIS library.
290  */
291 JNIEXPORT jint JNICALL
292 DEF_Agent_OnAttach(JavaVM* vm, char *args, void * reserved) {
293     JPLISInitializationError initerror  = JPLIS_INIT_ERROR_NONE;
294     jint                     result     = JNI_OK;
295     JPLISAgent *             agent      = NULL;
296     JNIEnv *                 jni_env    = NULL;
297 
298     /*
299      * Need JNIEnv - guaranteed to be called from thread that is already
300      * attached to VM
301      */
302     result = (*vm)-&gt;GetEnv(vm, (void**)&amp;jni_env, JNI_VERSION_1_2);
303     jplis_assert(result==JNI_OK);
304 
305     initerror = createNewJPLISAgent(vm, &amp;agent);
306     if ( initerror == JPLIS_INIT_ERROR_NONE ) {
307         int             oldLen, newLen;
308         char *          jarfile;
309         char *          options;
310         jarAttribute*   attributes;
311         char *          agentClass;
312         char *          bootClassPath;
313         jboolean        success;
314 
315         /*
316          * Parse &lt;jarfile&gt;[=options] into jarfile and options
317          */
318         if (parseArgumentTail(args, &amp;jarfile, &amp;options) != 0) {
319             return JNI_ENOMEM;
320         }
321 
322         /*
323          * Open the JAR file and parse the manifest
324          */
325         attributes = readAttributes( jarfile );
326         if (attributes == NULL) {
327             fprintf(stderr, &quot;Error opening zip file or JAR manifest missing: %s\n&quot;, jarfile);
328             free(jarfile);
329             if (options != NULL) free(options);
330             return AGENT_ERROR_BADJAR;
331         }
332 
333         agentClass = getAttribute(attributes, &quot;Agent-Class&quot;);
334         if (agentClass == NULL) {
335             fprintf(stderr, &quot;Failed to find Agent-Class manifest attribute from %s\n&quot;,
336                 jarfile);
337             free(jarfile);
338             if (options != NULL) free(options);
339             freeAttributes(attributes);
340             return AGENT_ERROR_BADJAR;
341         }
342 
343         /*
344          * Add the jarfile to the system class path
345          */
346         if (appendClassPath(agent, jarfile)) {
347             fprintf(stderr, &quot;Unable to add %s to system class path &quot;
348                 &quot;- not supported by system class loader or configuration error!\n&quot;,
349                 jarfile);
350             free(jarfile);
351             if (options != NULL) free(options);
352             freeAttributes(attributes);
353             return AGENT_ERROR_NOTONCP;
354         }
355 
356         /*
357          * The value of the Agent-Class attribute becomes the agent
358          * class name. The manifest is in UTF8 so need to convert to
359          * modified UTF8 (see JNI spec).
360          */
361         oldLen = (int)strlen(agentClass);
362         newLen = modifiedUtf8LengthOfUtf8(agentClass, oldLen);
363         if (newLen == oldLen) {
364             agentClass = strdup(agentClass);
365         } else {
366             char* str = (char*)malloc( newLen+1 );
367             if (str != NULL) {
368                 convertUtf8ToModifiedUtf8(agentClass, oldLen, str, newLen);
369             }
370             agentClass = str;
371         }
372         if (agentClass == NULL) {
373             free(jarfile);
374             if (options != NULL) free(options);
375             freeAttributes(attributes);
376             return JNI_ENOMEM;
377         }
378 
379         /*
380          * If the Boot-Class-Path attribute is specified then we process
381          * each URL - in the live phase only JAR files will be added.
382          */
383         bootClassPath = getAttribute(attributes, &quot;Boot-Class-Path&quot;);
384         if (bootClassPath != NULL) {
385             appendBootClassPath(agent, jarfile, bootClassPath);
386         }
387 
388         /*
389          * Convert JAR attributes into agent capabilities
390          */
391         convertCapabilityAttributes(attributes, agent);
392 
393         /*
394          * Create the java.lang.instrument.Instrumentation instance
395          */
396         success = createInstrumentationImpl(jni_env, agent);
397         jplis_assert(success);
398 
399         /*
400          * Setup ClassFileLoadHook handler.
401          */
402         if (success) {
403             success = setLivePhaseEventHandlers(agent);
404             jplis_assert(success);
405         }
406 
407         /*
408          * Start the agent
409          */
410         if (success) {
411             success = startJavaAgent(agent,
412                                      jni_env,
413                                      agentClass,
414                                      options,
415                                      agent-&gt;mAgentmainCaller);
416         }
417 
418         if (!success) {
419             fprintf(stderr, &quot;Agent failed to start!\n&quot;);
420             result = AGENT_ERROR_STARTFAIL;
421         }
422 
423         /*
424          * Clean-up
425          */
426         free(jarfile);
427         if (options != NULL) free(options);
428         free(agentClass);
429         freeAttributes(attributes);
430     }
431 
432     return result;
433 }
434 
435 
436 JNIEXPORT void JNICALL
437 DEF_Agent_OnUnload(JavaVM *vm) {
438 }
439 
440 /**
441  * Invoked by the java launcher to load an agent in the main executable JAR.
442  * The Launcher-Agent-Class attribute in the main manifest of the JAR file
443  * is the agent class.
444  *
445  * Returns JNI_OK if the agent is loaded and initialized; JNI_ERR if this
446  * function fails, possibly with a pending exception.
447  */
448 jint loadAgent(JNIEnv* env, jstring path) {
449     JavaVM* vm;
450     JPLISAgent* agent;
451     const char* jarfile = NULL;
452     jarAttribute* attributes = NULL;
453     char* agentClass = NULL;
454     char* bootClassPath;
455     int oldLen, newLen;
456     jint result = JNI_ERR;
457 
458     if ((*env)-&gt;GetJavaVM(env, &amp;vm) &lt; 0) {
459         return JNI_ERR;
460     }
461 
462     // create JPLISAgent with JVMTI environment
463     if (createNewJPLISAgent(vm, &amp;agent) != JPLIS_INIT_ERROR_NONE) {
464         return JNI_ERR;
465     }
466 
467     // get path to JAR file as UTF-8 string
468     jarfile = (*env)-&gt;GetStringUTFChars(env, path, NULL);
469     if (jarfile == NULL) {
470         return JNI_ERR;
471     }
472 
473     // read the attributes in the main section of JAR manifest
474     attributes = readAttributes(jarfile);
475     if (attributes == NULL) {
476         goto releaseAndReturn;
477     }
478 
479     // Launcher-Agent-Class is required
480     agentClass = getAttribute(attributes, &quot;Launcher-Agent-Class&quot;);
481     if (agentClass == NULL) {
482         goto releaseAndReturn;
483     }
484 
485     // The value of Launcher-Agent-Class is in UTF-8, convert it to modified UTF-8
486     oldLen = (int) strlen(agentClass);
487     newLen = modifiedUtf8LengthOfUtf8(agentClass, oldLen);
488     if (newLen == oldLen) {
489         agentClass = strdup(agentClass);
490     } else {
491         char* str = (char*) malloc(newLen + 1);
492         if (str != NULL) {
493             convertUtf8ToModifiedUtf8(agentClass, oldLen, str, newLen);
494         }
495         agentClass = str;
496     }
497     if (agentClass == NULL) {
498          jthrowable oome = createThrowable(env, &quot;java/lang/OutOfMemoryError&quot;, NULL);
499          if (oome != NULL) (*env)-&gt;Throw(env, oome);
500          goto releaseAndReturn;
501     }
502 
503     // Boot-Class-Path
504     bootClassPath = getAttribute(attributes, &quot;Boot-Class-Path&quot;);
505     if (bootClassPath != NULL) {
506         appendBootClassPath(agent, jarfile, bootClassPath);
507     }
508 
509     // Can-XXXX capabilities
510     convertCapabilityAttributes(attributes, agent);
511 
512     // Create the java.lang.instrument.Instrumentation object
513     if (!createInstrumentationImpl(env, agent)) {
514         goto releaseAndReturn;
515     }
516 
517     // Enable the ClassFileLoadHook
518     if (!setLivePhaseEventHandlers(agent)) {
519         goto releaseAndReturn;
520     }
521 
522     // invoke the agentmain method
523     if (!startJavaAgent(agent, env, agentClass, &quot;&quot;, agent-&gt;mAgentmainCaller)) {
524         goto releaseAndReturn;
525     }
526 
527     // initialization complete
528     result = JNI_OK;
529 
530     releaseAndReturn:
531         if (agentClass != NULL) {
532             free(agentClass);
533         }
534         if (attributes != NULL) {
535             freeAttributes(attributes);
536         }
537         if (jarfile != NULL) {
538             (*env)-&gt;ReleaseStringUTFChars(env, path, jarfile);
539         }
540 
541     return result;
542 }
543 
544 /*
545  *  JVMTI callback support
546  *
547  *  We have two &quot;stages&quot; of callback support.
548  *  At OnLoad time, we install a VMInit handler.
549  *  When the VMInit handler runs, we remove the VMInit handler and install a
550  *  ClassFileLoadHook handler.
551  */
552 
553 void JNICALL
554 eventHandlerVMInit( jvmtiEnv *      jvmtienv,
555                     JNIEnv *        jnienv,
556                     jthread         thread) {
557     JPLISEnvironment * environment  = NULL;
558     jboolean           success      = JNI_FALSE;
559 
560     environment = getJPLISEnvironment(jvmtienv);
561 
562     /* process the premain calls on the all the JPL agents */
<a name="3" id="anc3"></a><span class="line-modified">563     if (environment == NULL) {</span>
<span class="line-modified">564         abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART &quot;, getting JPLIS environment failed&quot;);</span>
<span class="line-modified">565     }</span>
<span class="line-modified">566     jthrowable outstandingException = NULL;</span>
<span class="line-modified">567     /*</span>
<span class="line-modified">568      * Add the jarfile to the system class path</span>
<span class="line-modified">569      */</span>
<span class="line-modified">570     JPLISAgent * agent = environment-&gt;mAgent;</span>
<span class="line-modified">571     if (appendClassPath(agent, agent-&gt;mJarfile)) {</span>
<span class="line-modified">572         fprintf(stderr, &quot;Unable to add %s to system class path - &quot;</span>
<span class="line-modified">573                 &quot;the system class loader does not define the &quot;</span>
<span class="line-modified">574                 &quot;appendToClassPathForInstrumentation method or the method failed\n&quot;,</span>
<span class="line-modified">575                 agent-&gt;mJarfile);</span>

576         free((void *)agent-&gt;mJarfile);
<a name="4" id="anc4"></a><span class="line-modified">577         abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART &quot;, appending to system class path failed&quot;);</span>





578     }
<a name="5" id="anc5"></a><span class="line-added">579     free((void *)agent-&gt;mJarfile);</span>
<span class="line-added">580     agent-&gt;mJarfile = NULL;</span>
<span class="line-added">581 </span>
<span class="line-added">582     outstandingException = preserveThrowable(jnienv);</span>
<span class="line-added">583     success = processJavaStart( environment-&gt;mAgent, jnienv);</span>
<span class="line-added">584     restoreThrowable(jnienv, outstandingException);</span>
585 
586     /* if we fail to start cleanly, bring down the JVM */
587     if ( !success ) {
<a name="6" id="anc6"></a><span class="line-modified">588         abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART &quot;, processJavaStart failed&quot;);</span>
589     }
590 }
591 
592 void JNICALL
593 eventHandlerClassFileLoadHook(  jvmtiEnv *              jvmtienv,
594                                 JNIEnv *                jnienv,
595                                 jclass                  class_being_redefined,
596                                 jobject                 loader,
597                                 const char*             name,
598                                 jobject                 protectionDomain,
599                                 jint                    class_data_len,
600                                 const unsigned char*    class_data,
601                                 jint*                   new_class_data_len,
602                                 unsigned char**         new_class_data) {
603     JPLISEnvironment * environment  = NULL;
604 
605     environment = getJPLISEnvironment(jvmtienv);
606 
607     /* if something is internally inconsistent (no agent), just silently return without touching the buffer */
608     if ( environment != NULL ) {
609         jthrowable outstandingException = preserveThrowable(jnienv);
610         transformClassFile( environment-&gt;mAgent,
611                             jnienv,
612                             loader,
613                             name,
614                             class_being_redefined,
615                             protectionDomain,
616                             class_data_len,
617                             class_data,
618                             new_class_data_len,
619                             new_class_data,
620                             environment-&gt;mIsRetransformer);
621         restoreThrowable(jnienv, outstandingException);
622     }
623 }
624 
625 
626 
627 
628 /*
629  * URLs in Boot-Class-Path attributes are separated by one or more spaces.
630  * This function splits the attribute value into a list of path segments.
631  * The attribute value is in UTF8 but cannot contain NUL. Also non US-ASCII
632  * characters must be escaped (URI syntax) so safe to iterate through the
633  * value as a C string.
634  */
635 static void
636 splitPathList(const char* str, int* pathCount, char*** paths) {
637     int count = 0;
638     char** segments = NULL;
639     char** new_segments;
640     char* c = (char*) str;
641     while (*c != &#39;\0&#39;) {
642         while (*c == &#39; &#39;) c++;          /* skip leading spaces */
643         if (*c == &#39;\0&#39;) {
644             break;
645         }
646         new_segments = (char**)realloc(segments, (count+1)*sizeof(char*));
647         if (new_segments == NULL) {
648             jplis_assert(0);
649             free(segments);
650             count = 0;
651             segments = NULL;
652             break;
653         }
654         segments = new_segments;
655         segments[count++] = c;
656         c = strchr(c, &#39; &#39;);
657         if (c == NULL) {
658             break;
659         }
660         *c = &#39;\0&#39;;
661         c++;
662     }
663     *pathCount = count;
664     *paths = segments;
665 }
666 
667 
668 /* URI path decoding - ported from src/share/classes/java/net/URI.java */
669 
670 static int
671 decodeNibble(char c) {
672     if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
673         return c - &#39;0&#39;;
674     if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;f&#39;))
675         return c - &#39;a&#39; + 10;
676     if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;F&#39;))
677         return c - &#39;A&#39; + 10;
678     return -1;
679 }
680 
681 static int
682 decodeByte(char c1, char c2) {
683     return (((decodeNibble(c1) &amp; 0xf) &lt;&lt; 4) | ((decodeNibble(c2) &amp; 0xf) &lt;&lt; 0));
684 }
685 
686 /*
687  * Evaluates all escapes in s.  Assumes that escapes are well-formed
688  * syntactically, i.e., of the form %XX.
689  * If the path does not require decoding the original path is
690  * returned. Otherwise the decoded path (heap allocated) is returned,
691  * along with the length of the decoded path. Note that the return
692  * string will not be null terminated after decoding.
693  */
694 static
695 char *decodePath(const char *s, int* decodedLen) {
696     int n;
697     char *result;
698     char *resultp;
699     int c;
700     int i;
701 
702     n = (int)strlen(s);
703     if (n == 0) {
704         *decodedLen = 0;
705         return (char*)s;
706     }
707     if (strchr(s, &#39;%&#39;) == NULL) {
708         *decodedLen = n;
709         return (char*)s; /* no escapes, we are done */
710     }
711 
712     resultp = result = calloc(n+1, 1);
<a name="7" id="anc7"></a><span class="line-added">713     if (result == NULL) {</span>
<span class="line-added">714         *decodedLen = 0;</span>
<span class="line-added">715         return NULL;</span>
<span class="line-added">716     }</span>
717     c = s[0];
718     for (i = 0; i &lt; n;) {
719         if (c != &#39;%&#39;) {
720             *resultp++ = c;
721             if (++i &gt;= n)
722                 break;
723             c = s[i];
724             continue;
725         }
726         for (;;) {
727             char b1 = s[++i];
728             char b2 = s[++i];
729             int decoded = decodeByte(b1, b2);
730             *resultp++ = decoded;
731             if (++i &gt;= n)
732                 break;
733             c = s[i];
734             if (c != &#39;%&#39;)
735                 break;
736         }
737     }
738     *decodedLen = (int)(resultp - result);
739     return result; // not null terminated.
740 }
741 
742 /*
743  * Append the given jar file to the system class path. This should succeed in the
744  * onload phase but may fail in the live phase if the system class loader doesn&#39;t
745  * support appending to the class path.
746  */
747 static int
748 appendClassPath( JPLISAgent* agent,
749                  const char* jarfile ) {
750     jvmtiEnv* jvmtienv = jvmti(agent);
751     jvmtiError jvmtierr;
752 
753     jvmtierr = (*jvmtienv)-&gt;AddToSystemClassLoaderSearch(jvmtienv, jarfile);
754     check_phase_ret_1(jvmtierr);
755 
756     switch (jvmtierr) {
757         case JVMTI_ERROR_NONE :
758             return 0;
759         case JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED :
760             fprintf(stderr, &quot;System class loader does not define &quot;
761                 &quot;the appendToClassPathForInstrumentation method\n&quot;);
762             break;
763         default:
764             fprintf(stderr, &quot;Unexpected error (%d) returned by &quot;
765                 &quot;AddToSystemClassLoaderSearch\n&quot;, jvmtierr);
766             break;
767     }
768     return -1;
769 }
770 
771 
772 /*
773  * res = func, free&#39;ing the previous value of &#39;res&#39; if function
774  * returns a new result.
775  */
776 #define TRANSFORM(res,func) {    \
777     char* tmp = func;            \
778     if (tmp != res) {            \
779         free(res);               \
780         res = tmp;               \
781     }                            \
782     jplis_assert((void*)res != (void*)NULL);     \
783 }
784 
<a name="8" id="anc8"></a>







785 /*
786  * This function takes the value of the Boot-Class-Path attribute,
787  * splits it into the individual path segments, and then combines it
788  * with the path to the jar file to create the path to be added
789  * to the bootclasspath.
790  *
791  * Each individual path segment starts out as a UTF8 string. Additionally
792  * as the path is specified to use URI path syntax all non US-ASCII
793  * characters are escaped. Once the URI path is decoded we get a UTF8
794  * string which must then be converted to the platform encoding (as it
795  * will be combined with the platform path of the jar file). Once
796  * converted it is then normalized (remove duplicate slashes, etc.).
797  * If the resulting path is an absolute path (starts with a slash for
798  * example) then the path will be added to the bootclasspath. Otherwise
799  * if it&#39;s not absolute then we get the canoncial path of the agent jar
800  * file and then resolve the path in the context of the base path of
801  * the agent jar.
802  */
803 static void
804 appendBootClassPath( JPLISAgent* agent,
805                      const char* jarfile,
806                      const char* pathList ) {
807     char canonicalPath[MAXPATHLEN];
808     char *parent = NULL;
809     int haveBasePath = 0;
810 
811     int count, i;
812     char **paths;
813     jvmtiEnv* jvmtienv = jvmti(agent);
814     jvmtiError jvmtierr;
815 
816     /*
817      * Split the attribute value into the individual path segments
818      * and process each in sequence
819      */
820     splitPathList(pathList, &amp;count, &amp;paths);
821 
822     for (i=0; i&lt;count; i++) {
823         int len;
824         char* path;
825         char* pos;
826 
827         /*
828          * The path segment at this point is a pointer into the attribute
829          * value. As it will go through a number of transformation (tossing away
830          * the previous results as we go along) it make it easier if the path
831          * starts out as a heap allocated string.
832          */
833         path = strdup(paths[i]);
834         jplis_assert(path != (char*)NULL);
835 
836         /*
837          * The attribute is specified to be a list of relative URIs so in theory
838          * there could be a query component - if so, get rid of it.
839          */
840         pos = strchr(path, &#39;?&#39;);
841         if (pos != NULL) {
842             *pos = &#39;\0&#39;;
843         }
844 
845         /*
846          * Check for characters that are not allowed in the path component of
847          * a URI.
848          */
849         if (validatePathChars(path)) {
850             fprintf(stderr, &quot;WARNING: illegal character in Boot-Class-Path value: %s\n&quot;,
851                path);
852             free(path);
853             continue;
854         }
855 
856 
857         /*
858          * Next decode any escaped characters. The result is a UTF8 string.
859          */
860         TRANSFORM(path, decodePath(path,&amp;len));
861 
862         /*
863          * Convert to the platform encoding
864          */
865         {
866             char platform[MAXPATHLEN];
867             int new_len = convertUft8ToPlatformString(path, len, platform, MAXPATHLEN);
868             free(path);
869             if (new_len  &lt; 0) {
870                 /* bogus value - exceeds maximum path size or unable to convert */
871                 continue;
872             }
873             path = strdup(platform);
874             jplis_assert(path != (char*)NULL);
875         }
876 
877         /*
878          * Post-process the URI path - needed on Windows to transform
879          * /c:/foo to c:/foo.
880          */
881         TRANSFORM(path, fromURIPath(path));
882 
883         /*
884          * Normalize the path - no duplicate slashes (except UNCs on Windows), trailing
885          * slash removed.
886          */
887         TRANSFORM(path, normalize(path));
888 
889         /*
890          * If the path is an absolute path then add to the bootclassloader
891          * search path. Otherwise we get the canonical path of the agent jar
892          * and then use its base path (directory) to resolve the given path
893          * segment.
894          *
895          * NOTE: JVMTI is specified to use modified UTF8 strings (like JNI).
896          * In 1.5.0 the AddToBootstrapClassLoaderSearch takes a platform string
897          * - see 5049313.
898          */
899         if (isAbsolute(path)) {
900             jvmtierr = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, path);
901         } else {
902             char* resolved;
903 
904             if (!haveBasePath) {
<a name="9" id="anc9"></a><span class="line-modified">905                 if (JDK_Canonicalize((char*)jarfile, canonicalPath, sizeof(canonicalPath)) != 0) {</span>

906                     fprintf(stderr, &quot;WARNING: unable to canonicalize %s\n&quot;, jarfile);
907                     free(path);
908                     continue;
909                 }
910                 parent = basePath(canonicalPath);
911                 jplis_assert(parent != (char*)NULL);
912                 haveBasePath = 1;
913             }
914 
915             resolved = resolve(parent, path);
916             jvmtierr = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, resolved);
917         }
918 
919         /* print warning if boot class path not updated */
920         if (jvmtierr != JVMTI_ERROR_NONE) {
921             check_phase_blob_ret(jvmtierr, free(path));
922 
923             fprintf(stderr, &quot;WARNING: %s not added to bootstrap class loader search: &quot;, path);
924             switch (jvmtierr) {
925                 case JVMTI_ERROR_ILLEGAL_ARGUMENT :
926                     fprintf(stderr, &quot;Illegal argument or not JAR file\n&quot;);
927                     break;
928                 default:
929                     fprintf(stderr, &quot;Unexpected error: %d\n&quot;, jvmtierr);
930             }
931         }
932 
933         /* finished with the path */
934         free(path);
935     }
936 
937 
938     /* clean-up */
939     if (haveBasePath &amp;&amp; parent != canonicalPath) {
940         free(parent);
941     }
942 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
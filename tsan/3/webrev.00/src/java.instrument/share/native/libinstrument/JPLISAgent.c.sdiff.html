<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.instrument/share/native/libinstrument/JPLISAgent.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="InvocationAdapter.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="JavaExceptions.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.instrument/share/native/libinstrument/JPLISAgent.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 372 /*
 373  *  VMInit processing code.
 374  */
 375 
 376 
 377 /*
 378  * If this call fails, the JVM launch will ultimately be aborted,
 379  * so we don&#39;t have to be super-careful to clean up in partial failure
 380  * cases.
 381  */
 382 jboolean
 383 processJavaStart(   JPLISAgent *    agent,
 384                     JNIEnv *        jnienv) {
 385     jboolean    result;
 386 
 387     /*
 388      *  OK, Java is up now. We can start everything that needs Java.
 389      */
 390 
 391     /*
<span class="line-modified"> 392      *  First make our emergency fallback InternalError throwable.</span>
 393      */
 394     result = initializeFallbackError(jnienv);
<span class="line-modified"> 395     jplis_assert(result);</span>
 396 
 397     /*
 398      *  Now make the InstrumentationImpl instance.
 399      */
 400     if ( result ) {
 401         result = createInstrumentationImpl(jnienv, agent);
<span class="line-modified"> 402         jplis_assert(result);</span>
 403     }
 404 
 405 
 406     /*
 407      *  Register a handler for ClassFileLoadHook (without enabling this event).
 408      *  Turn off the VMInit handler.
 409      */
 410     if ( result ) {
 411         result = setLivePhaseEventHandlers(agent);
<span class="line-modified"> 412         jplis_assert(result);</span>
 413     }
 414 
 415     /*
 416      *  Load the Java agent, and call the premain.
 417      */
 418     if ( result ) {
 419         result = startJavaAgent(agent, jnienv,
 420                                 agent-&gt;mAgentClassName, agent-&gt;mOptionsString,
 421                                 agent-&gt;mPremainCaller);

 422     }
 423 
 424     /*
 425      * Finally surrender all of the tracking data that we don&#39;t need any more.
 426      * If something is wrong, skip it, we will be aborting the JVM anyway.
 427      */
 428     if ( result ) {
 429         deallocateCommandLineData(agent);
 430     }
 431 
 432     return result;
 433 }
 434 
 435 jboolean
 436 startJavaAgent( JPLISAgent *    agent,
 437                 JNIEnv *        jnienv,
 438                 const char *    classname,
 439                 const char *    optionsString,
 440                 jmethodID       agentMainMethod) {
 441     jboolean    success = JNI_FALSE;
</pre>
<hr />
<pre>
1468     jsize       utf8Len;
1469     jboolean    isCopy;
1470     char        platformChars[MAXPATHLEN];
1471     int         platformLen;
1472 
1473     utf8Len = (*jnienv)-&gt;GetStringUTFLength(jnienv, jarFile);
1474     errorOutstanding = checkForAndClearThrowable(jnienv);
1475 
1476     if (!errorOutstanding) {
1477         utf8Chars = (*jnienv)-&gt;GetStringUTFChars(jnienv, jarFile, &amp;isCopy);
1478         errorOutstanding = checkForAndClearThrowable(jnienv);
1479 
1480         if (!errorOutstanding &amp;&amp; utf8Chars != NULL) {
1481             /*
1482              * JVMTI spec&#39;ed to use modified UTF8. At this time this is not implemented
1483              * the platform encoding is used.
1484              */
1485             platformLen = convertUft8ToPlatformString((char*)utf8Chars, utf8Len, platformChars, MAXPATHLEN);
1486             if (platformLen &lt; 0) {
1487                 createAndThrowInternalError(jnienv);

1488                 return;
1489             }
1490 
1491             (*jnienv)-&gt;ReleaseStringUTFChars(jnienv, jarFile, utf8Chars);
1492             errorOutstanding = checkForAndClearThrowable(jnienv);
1493 
1494             if (!errorOutstanding) {
1495 
1496                 if (isBootLoader) {
1497                     jvmtierror = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, platformChars);
1498                 } else {
1499                     jvmtierror = (*jvmtienv)-&gt;AddToSystemClassLoaderSearch(jvmtienv, platformChars);
1500                 }
1501                 check_phase_ret(jvmtierror);
1502 
1503                 if ( jvmtierror != JVMTI_ERROR_NONE ) {
1504                     createAndThrowThrowableFromJVMTIErrorCode(jnienv, jvmtierror);
1505                 }
1506             }
1507         }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 372 /*
 373  *  VMInit processing code.
 374  */
 375 
 376 
 377 /*
 378  * If this call fails, the JVM launch will ultimately be aborted,
 379  * so we don&#39;t have to be super-careful to clean up in partial failure
 380  * cases.
 381  */
 382 jboolean
 383 processJavaStart(   JPLISAgent *    agent,
 384                     JNIEnv *        jnienv) {
 385     jboolean    result;
 386 
 387     /*
 388      *  OK, Java is up now. We can start everything that needs Java.
 389      */
 390 
 391     /*
<span class="line-modified"> 392      *  First make our fallback InternalError throwable.</span>
 393      */
 394     result = initializeFallbackError(jnienv);
<span class="line-modified"> 395     jplis_assert_msg(result, &quot;fallback init failed&quot;);</span>
 396 
 397     /*
 398      *  Now make the InstrumentationImpl instance.
 399      */
 400     if ( result ) {
 401         result = createInstrumentationImpl(jnienv, agent);
<span class="line-modified"> 402         jplis_assert_msg(result, &quot;instrumentation instance creation failed&quot;);</span>
 403     }
 404 
 405 
 406     /*
 407      *  Register a handler for ClassFileLoadHook (without enabling this event).
 408      *  Turn off the VMInit handler.
 409      */
 410     if ( result ) {
 411         result = setLivePhaseEventHandlers(agent);
<span class="line-modified"> 412         jplis_assert_msg(result, &quot;setting of live phase VM handlers failed&quot;);</span>
 413     }
 414 
 415     /*
 416      *  Load the Java agent, and call the premain.
 417      */
 418     if ( result ) {
 419         result = startJavaAgent(agent, jnienv,
 420                                 agent-&gt;mAgentClassName, agent-&gt;mOptionsString,
 421                                 agent-&gt;mPremainCaller);
<span class="line-added"> 422         jplis_assert_msg(result, &quot;agent load/premain call failed&quot;);</span>
 423     }
 424 
 425     /*
 426      * Finally surrender all of the tracking data that we don&#39;t need any more.
 427      * If something is wrong, skip it, we will be aborting the JVM anyway.
 428      */
 429     if ( result ) {
 430         deallocateCommandLineData(agent);
 431     }
 432 
 433     return result;
 434 }
 435 
 436 jboolean
 437 startJavaAgent( JPLISAgent *    agent,
 438                 JNIEnv *        jnienv,
 439                 const char *    classname,
 440                 const char *    optionsString,
 441                 jmethodID       agentMainMethod) {
 442     jboolean    success = JNI_FALSE;
</pre>
<hr />
<pre>
1469     jsize       utf8Len;
1470     jboolean    isCopy;
1471     char        platformChars[MAXPATHLEN];
1472     int         platformLen;
1473 
1474     utf8Len = (*jnienv)-&gt;GetStringUTFLength(jnienv, jarFile);
1475     errorOutstanding = checkForAndClearThrowable(jnienv);
1476 
1477     if (!errorOutstanding) {
1478         utf8Chars = (*jnienv)-&gt;GetStringUTFChars(jnienv, jarFile, &amp;isCopy);
1479         errorOutstanding = checkForAndClearThrowable(jnienv);
1480 
1481         if (!errorOutstanding &amp;&amp; utf8Chars != NULL) {
1482             /*
1483              * JVMTI spec&#39;ed to use modified UTF8. At this time this is not implemented
1484              * the platform encoding is used.
1485              */
1486             platformLen = convertUft8ToPlatformString((char*)utf8Chars, utf8Len, platformChars, MAXPATHLEN);
1487             if (platformLen &lt; 0) {
1488                 createAndThrowInternalError(jnienv);
<span class="line-added">1489                 (*jnienv)-&gt;ReleaseStringUTFChars(jnienv, jarFile, utf8Chars);</span>
1490                 return;
1491             }
1492 
1493             (*jnienv)-&gt;ReleaseStringUTFChars(jnienv, jarFile, utf8Chars);
1494             errorOutstanding = checkForAndClearThrowable(jnienv);
1495 
1496             if (!errorOutstanding) {
1497 
1498                 if (isBootLoader) {
1499                     jvmtierror = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, platformChars);
1500                 } else {
1501                     jvmtierror = (*jvmtienv)-&gt;AddToSystemClassLoaderSearch(jvmtienv, platformChars);
1502                 }
1503                 check_phase_ret(jvmtierror);
1504 
1505                 if ( jvmtierror != JVMTI_ERROR_NONE ) {
1506                     createAndThrowThrowableFromJVMTIErrorCode(jnienv, jvmtierror);
1507                 }
1508             }
1509         }
</pre>
</td>
</tr>
</table>
<center><a href="InvocationAdapter.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="JavaExceptions.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.instrument/share/native/libinstrument/InvocationAdapter.c b/src/java.instrument/share/native/libinstrument/InvocationAdapter.c
--- a/src/java.instrument/share/native/libinstrument/InvocationAdapter.c
+++ b/src/java.instrument/share/native/libinstrument/InvocationAdapter.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,10 +30,12 @@
 #include    <string.h>
 #include    <stdlib.h>
 
 #include    "jni.h"
 
+#include    "jdk_util.h"
+
 #include    "Utilities.h"
 #include    "JPLISAssert.h"
 #include    "JPLISAgent.h"
 #include    "JavaExceptions.h"
 
@@ -556,36 +558,36 @@
     jboolean           success      = JNI_FALSE;
 
     environment = getJPLISEnvironment(jvmtienv);
 
     /* process the premain calls on the all the JPL agents */
-    if ( environment != NULL ) {
-        jthrowable outstandingException = NULL;
-        /*
-         * Add the jarfile to the system class path
-         */
-        JPLISAgent * agent = environment->mAgent;
-        if (appendClassPath(agent, agent->mJarfile)) {
-            fprintf(stderr, "Unable to add %s to system class path - "
-                    "the system class loader does not define the "
-                    "appendToClassPathForInstrumentation method or the method failed\n",
-                    agent->mJarfile);
-            free((void *)agent->mJarfile);
-            abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART);
-        }
+    if (environment == NULL) {
+        abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART ", getting JPLIS environment failed");
+    }
+    jthrowable outstandingException = NULL;
+    /*
+     * Add the jarfile to the system class path
+     */
+    JPLISAgent * agent = environment->mAgent;
+    if (appendClassPath(agent, agent->mJarfile)) {
+        fprintf(stderr, "Unable to add %s to system class path - "
+                "the system class loader does not define the "
+                "appendToClassPathForInstrumentation method or the method failed\n",
+                agent->mJarfile);
         free((void *)agent->mJarfile);
-        agent->mJarfile = NULL;
-
-        outstandingException = preserveThrowable(jnienv);
-        success = processJavaStart( environment->mAgent,
-                                    jnienv);
-        restoreThrowable(jnienv, outstandingException);
+        abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART ", appending to system class path failed");
     }
+    free((void *)agent->mJarfile);
+    agent->mJarfile = NULL;
+
+    outstandingException = preserveThrowable(jnienv);
+    success = processJavaStart( environment->mAgent, jnienv);
+    restoreThrowable(jnienv, outstandingException);
 
     /* if we fail to start cleanly, bring down the JVM */
     if ( !success ) {
-        abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART);
+        abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART ", processJavaStart failed");
     }
 }
 
 void JNICALL
 eventHandlerClassFileLoadHook(  jvmtiEnv *              jvmtienv,
@@ -706,10 +708,14 @@
         *decodedLen = n;
         return (char*)s; /* no escapes, we are done */
     }
 
     resultp = result = calloc(n+1, 1);
+    if (result == NULL) {
+        *decodedLen = 0;
+        return NULL;
+    }
     c = s[0];
     for (i = 0; i < n;) {
         if (c != '%') {
             *resultp++ = c;
             if (++i >= n)
@@ -774,18 +780,10 @@
         res = tmp;               \
     }                            \
     jplis_assert((void*)res != (void*)NULL);     \
 }
 
-/**
- * Convert a pathname to canonical form.
- * This method is exported from libjava.
- */
-extern int
-Canonicalize(JNIEnv *unused, char *orig, char *out, int len);
-
-
 /*
  * This function takes the value of the Boot-Class-Path attribute,
  * splits it into the individual path segments, and then combines it
  * with the path to the jar file to create the path to be added
  * to the bootclasspath.
@@ -902,12 +900,11 @@
             jvmtierr = (*jvmtienv)->AddToBootstrapClassLoaderSearch(jvmtienv, path);
         } else {
             char* resolved;
 
             if (!haveBasePath) {
-                /* Use NULL as the JNIEnv since we know that Canonicalize does not use it. */
-                if (Canonicalize(NULL, (char*)jarfile, canonicalPath, sizeof(canonicalPath)) != 0) {
+                if (JDK_Canonicalize((char*)jarfile, canonicalPath, sizeof(canonicalPath)) != 0) {
                     fprintf(stderr, "WARNING: unable to canonicalize %s\n", jarfile);
                     free(path);
                     continue;
                 }
                 parent = basePath(canonicalPath);

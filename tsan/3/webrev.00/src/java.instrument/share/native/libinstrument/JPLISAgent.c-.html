<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.instrument/share/native/libinstrument/JPLISAgent.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * Copyright 2003 Wily Technology, Inc.
  28  */
  29 
  30 #include    &lt;jni.h&gt;
  31 #include    &lt;jvm.h&gt;
  32 #include    &lt;jvmti.h&gt;
  33 #include    &lt;stdlib.h&gt;
  34 #include    &lt;string.h&gt;
  35 #include    &quot;JPLISAgent.h&quot;
  36 #include    &quot;JPLISAssert.h&quot;
  37 #include    &quot;Utilities.h&quot;
  38 #include    &quot;Reentrancy.h&quot;
  39 #include    &quot;JavaExceptions.h&quot;
  40 
  41 #include    &quot;EncodingSupport.h&quot;
  42 #include    &quot;FileSystemSupport.h&quot;    /* For MAXPATHLEN &amp; uintptr_t */
  43 
  44 #include    &quot;sun_instrument_InstrumentationImpl.h&quot;
  45 
  46 /*
  47  *  The JPLISAgent manages the initialization all of the Java programming language Agents.
  48  *  It also supports the native method bridge between the JPLIS and the JVMTI.
  49  *  It maintains a single JVMTI Env that all JPL agents share.
  50  *  It parses command line requests and creates individual Java agents.
  51  */
  52 
  53 
  54 /*
  55  *  private prototypes
  56  */
  57 
  58 /* Allocates an unformatted JPLIS agent data structure. Returns NULL if allocation fails. */
  59 JPLISAgent *
  60 allocateJPLISAgent(jvmtiEnv *       jvmtiEnv);
  61 
  62 /* Initializes an already-allocated JPLIS agent data structure. */
  63 JPLISInitializationError
  64 initializeJPLISAgent(   JPLISAgent *    agent,
  65                         JavaVM *        vm,
  66                         jvmtiEnv *      jvmtienv);
  67 /* De-allocates a JPLIS agent data structure. Only used in partial-failure cases at startup;
  68  * in normal usage the JPLIS agent lives forever
  69  */
  70 void
  71 deallocateJPLISAgent(   jvmtiEnv *      jvmtienv,
  72                         JPLISAgent *    agent);
  73 
  74 /* Does one-time work to interrogate the JVM about capabilities and cache the answers. */
  75 void
  76 checkCapabilities(JPLISAgent * agent);
  77 
  78 /* Takes the elements of the command string (agent class name and options string) and
  79  * create java strings for them.
  80  * Returns true if a classname was found. Makes no promises beyond the textual; says nothing about whether
  81  * the class exists or can be loaded.
  82  * If return value is true, sets outputClassname to a non-NULL local JNI reference.
  83  * If return value is true, sets outputOptionsString either to NULL or to a non-NULL local JNI reference.
  84  * If return value is false, neither output parameter is set.
  85  */
  86 jboolean
  87 commandStringIntoJavaStrings(  JNIEnv *        jnienv,
  88                                const char *    classname,
  89                                const char *    optionsString,
  90                                jstring *       outputClassname,
  91                                jstring *       outputOptionsString);
  92 
  93 /* Start one Java agent from the supplied parameters.
  94  * Most of the logic lives in a helper function that lives over in Java code--
  95  * we pass parameters out to Java and use our own Java helper to actually
  96  * load the agent and call the premain.
  97  * Returns true if the Java agent class is loaded and the premain/agentmain method completes
  98  * with no exceptions, false otherwise.
  99  */
 100 jboolean
 101 invokeJavaAgentMainMethod( JNIEnv *    jnienv,
 102                            jobject     instrumentationImpl,
 103                            jmethodID   agentMainMethod,
 104                            jstring     className,
 105                            jstring     optionsString);
 106 
 107 /* Once we have loaded the Java agent and called the premain,
 108  * we can release the copies we have been keeping of the command line
 109  * data (agent class name and option strings).
 110  */
 111 void
 112 deallocateCommandLineData(JPLISAgent * agent);
 113 
 114 /*
 115  *  Common support for various class list fetchers.
 116  */
 117 typedef jvmtiError (*ClassListFetcher)
 118     (   jvmtiEnv *  jvmtiEnv,
 119         jobject     classLoader,
 120         jint *      classCount,
 121         jclass **   classes);
 122 
 123 /* Fetcher that ignores the class loader parameter, and uses the JVMTI to get a list of all classes.
 124  * Returns a jvmtiError according to the underlying JVMTI service.
 125  */
 126 jvmtiError
 127 getAllLoadedClassesClassListFetcher(    jvmtiEnv *  jvmtiEnv,
 128                                         jobject     classLoader,
 129                                         jint *      classCount,
 130                                         jclass **   classes);
 131 
 132 /* Fetcher that uses the class loader parameter, and uses the JVMTI to get a list of all classes
 133  * for which the supplied loader is the initiating loader.
 134  * Returns a jvmtiError according to the underlying JVMTI service.
 135  */
 136 jvmtiError
 137 getInitiatedClassesClassListFetcher(    jvmtiEnv *  jvmtiEnv,
 138                                         jobject     classLoader,
 139                                         jint *      classCount,
 140                                         jclass **   classes);
 141 
 142 /*
 143  * Common guts for two native methods, which are the same except for the policy for fetching
 144  * the list of classes.
 145  * Either returns a local JNI reference to an array of references to java.lang.Class.
 146  * Can throw, if it does will alter the JNIEnv with an outstanding exception.
 147  */
 148 jobjectArray
 149 commonGetClassList( JNIEnv *            jnienv,
 150                     JPLISAgent *        agent,
 151                     jobject             classLoader,
 152                     ClassListFetcher    fetcher);
 153 
 154 
 155 /*
 156  *  Misc. utilities.
 157  */
 158 
 159 /* Checked exception mapper used by the redefine classes implementation.
 160  * Allows ClassNotFoundException or UnmodifiableClassException; maps others
 161  * to InternalError. Can return NULL in an error case.
 162  */
 163 jthrowable
 164 redefineClassMapper(    JNIEnv *    jnienv,
 165                         jthrowable  throwableToMap);
 166 
 167 /* Turns a buffer of jclass * into a Java array whose elements are java.lang.Class.
 168  * Can throw, if it does will alter the JNIEnv with an outstanding exception.
 169  */
 170 jobjectArray
 171 getObjectArrayFromClasses(JNIEnv* jnienv, jclass* classes, jint classCount);
 172 
 173 
 174 JPLISEnvironment *
 175 getJPLISEnvironment(jvmtiEnv * jvmtienv) {
 176     JPLISEnvironment * environment  = NULL;
 177     jvmtiError         jvmtierror   = JVMTI_ERROR_NONE;
 178 
 179     jvmtierror = (*jvmtienv)-&gt;GetEnvironmentLocalStorage(
 180                                             jvmtienv,
 181                                             (void**)&amp;environment);
 182     /* can be called from any phase */
 183     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 184 
 185     if (jvmtierror == JVMTI_ERROR_NONE) {
 186         jplis_assert(environment != NULL);
 187         jplis_assert(environment-&gt;mJVMTIEnv == jvmtienv);
 188     } else {
 189         environment = NULL;
 190     }
 191     return environment;
 192 }
 193 
 194 /*
 195  *  OnLoad processing code.
 196  */
 197 
 198 /*
 199  *  Creates a new JPLISAgent.
 200  *  Returns error if the agent cannot be created and initialized.
 201  *  The JPLISAgent* pointed to by agent_ptr is set to the new broker,
 202  *  or NULL if an error has occurred.
 203  */
 204 JPLISInitializationError
 205 createNewJPLISAgent(JavaVM * vm, JPLISAgent **agent_ptr) {
 206     JPLISInitializationError initerror       = JPLIS_INIT_ERROR_NONE;
 207     jvmtiEnv *               jvmtienv        = NULL;
 208     jint                     jnierror        = JNI_OK;
 209 
 210     *agent_ptr = NULL;
 211     jnierror = (*vm)-&gt;GetEnv(  vm,
 212                                (void **) &amp;jvmtienv,
 213                                JVMTI_VERSION_1_1);
 214     if ( jnierror != JNI_OK ) {
 215         initerror = JPLIS_INIT_ERROR_CANNOT_CREATE_NATIVE_AGENT;
 216     } else {
 217         JPLISAgent * agent = allocateJPLISAgent(jvmtienv);
 218         if ( agent == NULL ) {
 219             initerror = JPLIS_INIT_ERROR_ALLOCATION_FAILURE;
 220         } else {
 221             initerror = initializeJPLISAgent(  agent,
 222                                                vm,
 223                                                jvmtienv);
 224             if ( initerror == JPLIS_INIT_ERROR_NONE ) {
 225                 *agent_ptr = agent;
 226             } else {
 227                 deallocateJPLISAgent(jvmtienv, agent);
 228             }
 229         }
 230 
 231         /* don&#39;t leak envs */
 232         if ( initerror != JPLIS_INIT_ERROR_NONE ) {
 233             jvmtiError jvmtierror = (*jvmtienv)-&gt;DisposeEnvironment(jvmtienv);
 234             /* can be called from any phase */
 235             jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 236         }
 237     }
 238 
 239     return initerror;
 240 }
 241 
 242 /*
 243  *  Allocates a JPLISAgent. Returns NULL if it cannot be allocated
 244  */
 245 JPLISAgent *
 246 allocateJPLISAgent(jvmtiEnv * jvmtienv) {
 247   return (JPLISAgent *) allocate( jvmtienv,
 248                                     sizeof(JPLISAgent));
 249 }
 250 
 251 JPLISInitializationError
 252 initializeJPLISAgent(   JPLISAgent *    agent,
 253                         JavaVM *        vm,
 254                         jvmtiEnv *      jvmtienv) {
 255     jvmtiError      jvmtierror = JVMTI_ERROR_NONE;
 256     jvmtiPhase      phase;
 257 
 258     agent-&gt;mJVM                                      = vm;
 259     agent-&gt;mNormalEnvironment.mJVMTIEnv              = jvmtienv;
 260     agent-&gt;mNormalEnvironment.mAgent                 = agent;
 261     agent-&gt;mNormalEnvironment.mIsRetransformer       = JNI_FALSE;
 262     agent-&gt;mRetransformEnvironment.mJVMTIEnv         = NULL;        /* NULL until needed */
 263     agent-&gt;mRetransformEnvironment.mAgent            = agent;
 264     agent-&gt;mRetransformEnvironment.mIsRetransformer  = JNI_FALSE;   /* JNI_FALSE until mJVMTIEnv is set */
 265     agent-&gt;mAgentmainCaller                          = NULL;
 266     agent-&gt;mInstrumentationImpl                      = NULL;
 267     agent-&gt;mPremainCaller                            = NULL;
 268     agent-&gt;mTransform                                = NULL;
 269     agent-&gt;mRedefineAvailable                        = JNI_FALSE;   /* assume no for now */
 270     agent-&gt;mRedefineAdded                            = JNI_FALSE;
 271     agent-&gt;mNativeMethodPrefixAvailable              = JNI_FALSE;   /* assume no for now */
 272     agent-&gt;mNativeMethodPrefixAdded                  = JNI_FALSE;
 273     agent-&gt;mAgentClassName                           = NULL;
 274     agent-&gt;mOptionsString                            = NULL;
 275     agent-&gt;mJarfile                                  = NULL;
 276 
 277     /* make sure we can recover either handle in either direction.
 278      * the agent has a ref to the jvmti; make it mutual
 279      */
 280     jvmtierror = (*jvmtienv)-&gt;SetEnvironmentLocalStorage(
 281                                             jvmtienv,
 282                                             &amp;(agent-&gt;mNormalEnvironment));
 283     /* can be called from any phase */
 284     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 285 
 286     /* check what capabilities are available */
 287     checkCapabilities(agent);
 288 
 289     /* check phase - if live phase then we don&#39;t need the VMInit event */
 290     jvmtierror = (*jvmtienv)-&gt;GetPhase(jvmtienv, &amp;phase);
 291     /* can be called from any phase */
 292     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 293     if (phase == JVMTI_PHASE_LIVE) {
 294         return JPLIS_INIT_ERROR_NONE;
 295     }
 296 
 297     if (phase != JVMTI_PHASE_ONLOAD) {
 298         /* called too early or called too late; either way bail out */
 299         return JPLIS_INIT_ERROR_FAILURE;
 300     }
 301 
 302     /* now turn on the VMInit event */
 303     if ( jvmtierror == JVMTI_ERROR_NONE ) {
 304         jvmtiEventCallbacks callbacks;
 305         memset(&amp;callbacks, 0, sizeof(callbacks));
 306         callbacks.VMInit = &amp;eventHandlerVMInit;
 307 
 308         jvmtierror = (*jvmtienv)-&gt;SetEventCallbacks( jvmtienv,
 309                                                      &amp;callbacks,
 310                                                      sizeof(callbacks));
 311         check_phase_ret_blob(jvmtierror, JPLIS_INIT_ERROR_FAILURE);
 312         jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 313     }
 314 
 315     if ( jvmtierror == JVMTI_ERROR_NONE ) {
 316         jvmtierror = (*jvmtienv)-&gt;SetEventNotificationMode(
 317                                                 jvmtienv,
 318                                                 JVMTI_ENABLE,
 319                                                 JVMTI_EVENT_VM_INIT,
 320                                                 NULL /* all threads */);
 321         check_phase_ret_blob(jvmtierror, JPLIS_INIT_ERROR_FAILURE);
 322         jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 323     }
 324 
 325     return (jvmtierror == JVMTI_ERROR_NONE)? JPLIS_INIT_ERROR_NONE : JPLIS_INIT_ERROR_FAILURE;
 326 }
 327 
 328 void
 329 deallocateJPLISAgent(jvmtiEnv * jvmtienv, JPLISAgent * agent) {
 330     deallocate(jvmtienv, agent);
 331 }
 332 
 333 
 334 JPLISInitializationError
 335 recordCommandLineData(  JPLISAgent *    agent,
 336                         const char *    agentClassName,
 337                         const char *    optionsString ) {
 338     JPLISInitializationError    initerror   = JPLIS_INIT_ERROR_NONE;
 339     char *      ourCopyOfAgentClassName     = NULL;
 340     char *      ourCopyOfOptionsString      = NULL;
 341 
 342     /* if no actual params, bail out now */
 343     if ((agentClassName == NULL) || (*agentClassName == 0)) {
 344         initerror = JPLIS_INIT_ERROR_AGENT_CLASS_NOT_SPECIFIED;
 345     } else {
 346         ourCopyOfAgentClassName = allocate(jvmti(agent), strlen(agentClassName)+1);
 347         if (ourCopyOfAgentClassName == NULL) {
 348             initerror = JPLIS_INIT_ERROR_ALLOCATION_FAILURE;
 349         } else {
 350             if (optionsString != NULL) {
 351                 ourCopyOfOptionsString = allocate(jvmti(agent), strlen(optionsString)+1);
 352                 if (ourCopyOfOptionsString == NULL) {
 353                     deallocate(jvmti(agent), ourCopyOfAgentClassName);
 354                     initerror = JPLIS_INIT_ERROR_ALLOCATION_FAILURE;
 355                 }
 356             }
 357         }
 358     }
 359 
 360     if (initerror == JPLIS_INIT_ERROR_NONE) {
 361         strcpy(ourCopyOfAgentClassName, agentClassName);
 362         if (optionsString != NULL) {
 363             strcpy(ourCopyOfOptionsString, optionsString);
 364         }
 365         agent-&gt;mAgentClassName = ourCopyOfAgentClassName;
 366         agent-&gt;mOptionsString = ourCopyOfOptionsString;
 367     }
 368 
 369     return initerror;
 370 }
 371 
 372 /*
 373  *  VMInit processing code.
 374  */
 375 
 376 
 377 /*
 378  * If this call fails, the JVM launch will ultimately be aborted,
 379  * so we don&#39;t have to be super-careful to clean up in partial failure
 380  * cases.
 381  */
 382 jboolean
 383 processJavaStart(   JPLISAgent *    agent,
 384                     JNIEnv *        jnienv) {
 385     jboolean    result;
 386 
 387     /*
 388      *  OK, Java is up now. We can start everything that needs Java.
 389      */
 390 
 391     /*
 392      *  First make our emergency fallback InternalError throwable.
 393      */
 394     result = initializeFallbackError(jnienv);
 395     jplis_assert(result);
 396 
 397     /*
 398      *  Now make the InstrumentationImpl instance.
 399      */
 400     if ( result ) {
 401         result = createInstrumentationImpl(jnienv, agent);
 402         jplis_assert(result);
 403     }
 404 
 405 
 406     /*
 407      *  Register a handler for ClassFileLoadHook (without enabling this event).
 408      *  Turn off the VMInit handler.
 409      */
 410     if ( result ) {
 411         result = setLivePhaseEventHandlers(agent);
 412         jplis_assert(result);
 413     }
 414 
 415     /*
 416      *  Load the Java agent, and call the premain.
 417      */
 418     if ( result ) {
 419         result = startJavaAgent(agent, jnienv,
 420                                 agent-&gt;mAgentClassName, agent-&gt;mOptionsString,
 421                                 agent-&gt;mPremainCaller);
 422     }
 423 
 424     /*
 425      * Finally surrender all of the tracking data that we don&#39;t need any more.
 426      * If something is wrong, skip it, we will be aborting the JVM anyway.
 427      */
 428     if ( result ) {
 429         deallocateCommandLineData(agent);
 430     }
 431 
 432     return result;
 433 }
 434 
 435 jboolean
 436 startJavaAgent( JPLISAgent *    agent,
 437                 JNIEnv *        jnienv,
 438                 const char *    classname,
 439                 const char *    optionsString,
 440                 jmethodID       agentMainMethod) {
 441     jboolean    success = JNI_FALSE;
 442     jstring classNameObject = NULL;
 443     jstring optionsStringObject = NULL;
 444 
 445     success = commandStringIntoJavaStrings(    jnienv,
 446                                                classname,
 447                                                optionsString,
 448                                                &amp;classNameObject,
 449                                                &amp;optionsStringObject);
 450 
 451     if (success) {
 452         success = invokeJavaAgentMainMethod(   jnienv,
 453                                                agent-&gt;mInstrumentationImpl,
 454                                                agentMainMethod,
 455                                                classNameObject,
 456                                                optionsStringObject);
 457     }
 458 
 459     return success;
 460 }
 461 
 462 void
 463 deallocateCommandLineData( JPLISAgent * agent) {
 464     deallocate(jvmti(agent), (void*)agent-&gt;mAgentClassName);
 465     deallocate(jvmti(agent), (void*)agent-&gt;mOptionsString);
 466 
 467     /* zero things out so it is easier to see what is going on */
 468     agent-&gt;mAgentClassName = NULL;
 469     agent-&gt;mOptionsString = NULL;
 470 }
 471 
 472 /*
 473  * Create the java.lang.instrument.Instrumentation instance
 474  * and access information for it (method IDs, etc)
 475  */
 476 jboolean
 477 createInstrumentationImpl( JNIEnv *        jnienv,
 478                            JPLISAgent *    agent) {
 479     jclass      implClass               = NULL;
 480     jboolean    errorOutstanding        = JNI_FALSE;
 481     jobject     resultImpl              = NULL;
 482     jmethodID   premainCallerMethodID   = NULL;
 483     jmethodID   agentmainCallerMethodID = NULL;
 484     jmethodID   transformMethodID       = NULL;
 485     jmethodID   constructorID           = NULL;
 486     jobject     localReference          = NULL;
 487 
 488     /* First find the class of our implementation */
 489     implClass = (*jnienv)-&gt;FindClass(   jnienv,
 490                                         JPLIS_INSTRUMENTIMPL_CLASSNAME);
 491     errorOutstanding = checkForAndClearThrowable(jnienv);
 492     errorOutstanding = errorOutstanding || (implClass == NULL);
 493     jplis_assert_msg(!errorOutstanding, &quot;find class on InstrumentationImpl failed&quot;);
 494 
 495     if ( !errorOutstanding ) {
 496         constructorID = (*jnienv)-&gt;GetMethodID( jnienv,
 497                                                 implClass,
 498                                                 JPLIS_INSTRUMENTIMPL_CONSTRUCTOR_METHODNAME,
 499                                                 JPLIS_INSTRUMENTIMPL_CONSTRUCTOR_METHODSIGNATURE);
 500         errorOutstanding = checkForAndClearThrowable(jnienv);
 501         errorOutstanding = errorOutstanding || (constructorID == NULL);
 502         jplis_assert_msg(!errorOutstanding, &quot;find constructor on InstrumentationImpl failed&quot;);
 503         }
 504 
 505     if ( !errorOutstanding ) {
 506         jlong   peerReferenceAsScalar = (jlong)(intptr_t) agent;
 507         localReference = (*jnienv)-&gt;NewObject(  jnienv,
 508                                                 implClass,
 509                                                 constructorID,
 510                                                 peerReferenceAsScalar,
 511                                                 agent-&gt;mRedefineAdded,
 512                                                 agent-&gt;mNativeMethodPrefixAdded);
 513         errorOutstanding = checkForAndClearThrowable(jnienv);
 514         errorOutstanding = errorOutstanding || (localReference == NULL);
 515         jplis_assert_msg(!errorOutstanding, &quot;call constructor on InstrumentationImpl failed&quot;);
 516     }
 517 
 518     if ( !errorOutstanding ) {
 519         resultImpl = (*jnienv)-&gt;NewGlobalRef(jnienv, localReference);
 520         errorOutstanding = checkForAndClearThrowable(jnienv);
 521         jplis_assert_msg(!errorOutstanding, &quot;copy local ref to global ref&quot;);
 522     }
 523 
 524     /* Now look up the method ID for the pre-main caller (we will need this more than once) */
 525     if ( !errorOutstanding ) {
 526         premainCallerMethodID = (*jnienv)-&gt;GetMethodID( jnienv,
 527                                                         implClass,
 528                                                         JPLIS_INSTRUMENTIMPL_PREMAININVOKER_METHODNAME,
 529                                                         JPLIS_INSTRUMENTIMPL_PREMAININVOKER_METHODSIGNATURE);
 530         errorOutstanding = checkForAndClearThrowable(jnienv);
 531         errorOutstanding = errorOutstanding || (premainCallerMethodID == NULL);
 532         jplis_assert_msg(!errorOutstanding, &quot;can&#39;t find premain invoker methodID&quot;);
 533     }
 534 
 535     /* Now look up the method ID for the agent-main caller */
 536     if ( !errorOutstanding ) {
 537         agentmainCallerMethodID = (*jnienv)-&gt;GetMethodID( jnienv,
 538                                                           implClass,
 539                                                           JPLIS_INSTRUMENTIMPL_AGENTMAININVOKER_METHODNAME,
 540                                                           JPLIS_INSTRUMENTIMPL_AGENTMAININVOKER_METHODSIGNATURE);
 541         errorOutstanding = checkForAndClearThrowable(jnienv);
 542         errorOutstanding = errorOutstanding || (agentmainCallerMethodID == NULL);
 543         jplis_assert_msg(!errorOutstanding, &quot;can&#39;t find agentmain invoker methodID&quot;);
 544     }
 545 
 546     /* Now look up the method ID for the transform method (we will need this constantly) */
 547     if ( !errorOutstanding ) {
 548         transformMethodID = (*jnienv)-&gt;GetMethodID( jnienv,
 549                                                     implClass,
 550                                                     JPLIS_INSTRUMENTIMPL_TRANSFORM_METHODNAME,
 551                                                     JPLIS_INSTRUMENTIMPL_TRANSFORM_METHODSIGNATURE);
 552         errorOutstanding = checkForAndClearThrowable(jnienv);
 553         errorOutstanding = errorOutstanding || (transformMethodID == NULL);
 554         jplis_assert_msg(!errorOutstanding, &quot;can&#39;t find transform methodID&quot;);
 555     }
 556 
 557     if ( !errorOutstanding ) {
 558         agent-&gt;mInstrumentationImpl = resultImpl;
 559         agent-&gt;mPremainCaller       = premainCallerMethodID;
 560         agent-&gt;mAgentmainCaller     = agentmainCallerMethodID;
 561         agent-&gt;mTransform           = transformMethodID;
 562     }
 563 
 564     return !errorOutstanding;
 565 }
 566 
 567 jboolean
 568 commandStringIntoJavaStrings(  JNIEnv *        jnienv,
 569                                const char *    classname,
 570                                const char *    optionsString,
 571                                jstring *       outputClassname,
 572                                jstring *       outputOptionsString) {
 573     jstring     classnameJavaString     = NULL;
 574     jstring     optionsJavaString       = NULL;
 575     jboolean    errorOutstanding        = JNI_TRUE;
 576 
 577     classnameJavaString = (*jnienv)-&gt;NewStringUTF(jnienv, classname);
 578     errorOutstanding = checkForAndClearThrowable(jnienv);
 579     jplis_assert_msg(!errorOutstanding, &quot;can&#39;t create class name java string&quot;);
 580 
 581     if ( !errorOutstanding ) {
 582         if ( optionsString != NULL) {
 583             optionsJavaString = (*jnienv)-&gt;NewStringUTF(jnienv, optionsString);
 584             errorOutstanding = checkForAndClearThrowable(jnienv);
 585             jplis_assert_msg(!errorOutstanding, &quot;can&#39;t create options java string&quot;);
 586         }
 587 
 588         if ( !errorOutstanding ) {
 589             *outputClassname        = classnameJavaString;
 590             *outputOptionsString    = optionsJavaString;
 591         }
 592     }
 593 
 594     return !errorOutstanding;
 595 }
 596 
 597 
 598 jboolean
 599 invokeJavaAgentMainMethod( JNIEnv *    jnienv,
 600                            jobject     instrumentationImpl,
 601                            jmethodID   mainCallingMethod,
 602                            jstring     className,
 603                            jstring     optionsString) {
 604     jboolean errorOutstanding = JNI_FALSE;
 605 
 606     jplis_assert(mainCallingMethod != NULL);
 607     if ( mainCallingMethod != NULL ) {
 608         (*jnienv)-&gt;CallVoidMethod(  jnienv,
 609                                     instrumentationImpl,
 610                                     mainCallingMethod,
 611                                     className,
 612                                     optionsString);
 613         errorOutstanding = checkForThrowable(jnienv);
 614         if ( errorOutstanding ) {
 615             logThrowable(jnienv);
 616         }
 617         checkForAndClearThrowable(jnienv);
 618     }
 619     return !errorOutstanding;
 620 }
 621 
 622 jboolean
 623 setLivePhaseEventHandlers(  JPLISAgent * agent) {
 624     jvmtiEventCallbacks callbacks;
 625     jvmtiEnv *          jvmtienv = jvmti(agent);
 626     jvmtiError          jvmtierror;
 627 
 628     /* first swap out the handlers (switch from the VMInit handler, which we do not need,
 629      * to the ClassFileLoadHook handler, which is what the agents need from now on)
 630      */
 631     memset(&amp;callbacks, 0, sizeof(callbacks));
 632     callbacks.ClassFileLoadHook = &amp;eventHandlerClassFileLoadHook;
 633 
 634     jvmtierror = (*jvmtienv)-&gt;SetEventCallbacks( jvmtienv,
 635                                                  &amp;callbacks,
 636                                                  sizeof(callbacks));
 637     check_phase_ret_false(jvmtierror);
 638     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 639 
 640 
 641     if ( jvmtierror == JVMTI_ERROR_NONE ) {
 642         /* turn off VMInit */
 643         jvmtierror = (*jvmtienv)-&gt;SetEventNotificationMode(
 644                                                     jvmtienv,
 645                                                     JVMTI_DISABLE,
 646                                                     JVMTI_EVENT_VM_INIT,
 647                                                     NULL /* all threads */);
 648         check_phase_ret_false(jvmtierror);
 649         jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 650     }
 651 
 652     return (jvmtierror == JVMTI_ERROR_NONE);
 653 }
 654 
 655 /**
 656  *  Check if the can_redefine_classes capability is available.
 657  */
 658 void
 659 checkCapabilities(JPLISAgent * agent) {
 660     jvmtiEnv *          jvmtienv = jvmti(agent);
 661     jvmtiCapabilities   potentialCapabilities;
 662     jvmtiError          jvmtierror;
 663 
 664     memset(&amp;potentialCapabilities, 0, sizeof(potentialCapabilities));
 665 
 666     jvmtierror = (*jvmtienv)-&gt;GetPotentialCapabilities(jvmtienv, &amp;potentialCapabilities);
 667     check_phase_ret(jvmtierror);
 668     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 669 
 670     if ( jvmtierror == JVMTI_ERROR_NONE ) {
 671         if ( potentialCapabilities.can_redefine_classes == 1 ) {
 672             agent-&gt;mRedefineAvailable = JNI_TRUE;
 673         }
 674         if ( potentialCapabilities.can_set_native_method_prefix == 1 ) {
 675             agent-&gt;mNativeMethodPrefixAvailable = JNI_TRUE;
 676         }
 677     }
 678 }
 679 
 680 /**
 681  * Enable native method prefix in one JVM TI environment
 682  */
 683 void
 684 enableNativeMethodPrefixCapability(jvmtiEnv * jvmtienv) {
 685     jvmtiCapabilities   desiredCapabilities;
 686     jvmtiError          jvmtierror;
 687 
 688         jvmtierror = (*jvmtienv)-&gt;GetCapabilities(jvmtienv, &amp;desiredCapabilities);
 689         /* can be called from any phase */
 690         jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 691         desiredCapabilities.can_set_native_method_prefix = 1;
 692         jvmtierror = (*jvmtienv)-&gt;AddCapabilities(jvmtienv, &amp;desiredCapabilities);
 693         check_phase_ret(jvmtierror);
 694         jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 695 }
 696 
 697 
 698 /**
 699  * Add the can_set_native_method_prefix capability
 700  */
 701 void
 702 addNativeMethodPrefixCapability(JPLISAgent * agent) {
 703     if (agent-&gt;mNativeMethodPrefixAvailable &amp;&amp; !agent-&gt;mNativeMethodPrefixAdded) {
 704         jvmtiEnv * jvmtienv = agent-&gt;mNormalEnvironment.mJVMTIEnv;
 705         enableNativeMethodPrefixCapability(jvmtienv);
 706 
 707         jvmtienv = agent-&gt;mRetransformEnvironment.mJVMTIEnv;
 708         if (jvmtienv != NULL) {
 709             enableNativeMethodPrefixCapability(jvmtienv);
 710         }
 711         agent-&gt;mNativeMethodPrefixAdded = JNI_TRUE;
 712     }
 713 }
 714 
 715 /**
 716  * Add the can_maintain_original_method_order capability (for testing)
 717  */
 718 void
 719 addOriginalMethodOrderCapability(JPLISAgent * agent) {
 720     jvmtiEnv *          jvmtienv = jvmti(agent);
 721     jvmtiCapabilities   desiredCapabilities;
 722     jvmtiError          jvmtierror;
 723 
 724     jvmtierror = (*jvmtienv)-&gt;GetCapabilities(jvmtienv, &amp;desiredCapabilities);
 725     /* can be called from any phase */
 726     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 727     desiredCapabilities.can_maintain_original_method_order = 1;
 728     jvmtierror = (*jvmtienv)-&gt;AddCapabilities(jvmtienv, &amp;desiredCapabilities);
 729     check_phase_ret(jvmtierror);
 730     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 731 }
 732 
 733 /**
 734  * Add the can_redefine_classes capability
 735  */
 736 void
 737 addRedefineClassesCapability(JPLISAgent * agent) {
 738     jvmtiEnv *          jvmtienv = jvmti(agent);
 739     jvmtiCapabilities   desiredCapabilities;
 740     jvmtiError          jvmtierror;
 741 
 742     if (agent-&gt;mRedefineAvailable &amp;&amp; !agent-&gt;mRedefineAdded) {
 743         jvmtierror = (*jvmtienv)-&gt;GetCapabilities(jvmtienv, &amp;desiredCapabilities);
 744         /* can be called from any phase */
 745         jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
 746         desiredCapabilities.can_redefine_classes = 1;
 747         jvmtierror = (*jvmtienv)-&gt;AddCapabilities(jvmtienv, &amp;desiredCapabilities);
 748         check_phase_ret(jvmtierror);
 749 
 750         /*
 751          * With mixed premain/agentmain agents then it&#39;s possible that the
 752          * capability was potentially available in the onload phase but
 753          * subsequently unavailable in the live phase.
 754          */
 755         jplis_assert(jvmtierror == JVMTI_ERROR_NONE ||
 756                      jvmtierror == JVMTI_ERROR_NOT_AVAILABLE);
 757         if (jvmtierror == JVMTI_ERROR_NONE) {
 758             agent-&gt;mRedefineAdded = JNI_TRUE;
 759         }
 760     }
 761 }
 762 
 763 static jobject
 764 getModuleObject(jvmtiEnv*               jvmti,
 765                 jobject                 loaderObject,
 766                 const char*             cname) {
 767     jvmtiError err = JVMTI_ERROR_NONE;
 768     jobject moduleObject = NULL;
 769 
 770     /* find last slash in the class name */
 771     char* last_slash = (cname == NULL) ? NULL : strrchr(cname, &#39;/&#39;);
 772     int len = (last_slash == NULL) ? 0 : (int)(last_slash - cname);
 773     char* pkg_name_buf = (char*)malloc(len + 1);
 774 
 775     if (pkg_name_buf == NULL) {
 776         fprintf(stderr, &quot;OOM error in native tmp buffer allocation&quot;);
 777         return NULL;
 778     }
 779     if (last_slash != NULL) {
 780         strncpy(pkg_name_buf, cname, len);
 781     }
 782     pkg_name_buf[len] = &#39;\0&#39;;
 783 
 784     err = (*jvmti)-&gt;GetNamedModule(jvmti, loaderObject, pkg_name_buf, &amp;moduleObject);
 785     free((void*)pkg_name_buf);
 786     check_phase_ret_blob(err, NULL);
 787     jplis_assert_msg(err == JVMTI_ERROR_NONE, &quot;error in the JVMTI GetNamedModule&quot;);
 788 
 789     return moduleObject;
 790 }
 791 
 792 /*
 793  *  Support for the JVMTI callbacks
 794  */
 795 
 796 void
 797 transformClassFile(             JPLISAgent *            agent,
 798                                 JNIEnv *                jnienv,
 799                                 jobject                 loaderObject,
 800                                 const char*             name,
 801                                 jclass                  classBeingRedefined,
 802                                 jobject                 protectionDomain,
 803                                 jint                    class_data_len,
 804                                 const unsigned char*    class_data,
 805                                 jint*                   new_class_data_len,
 806                                 unsigned char**         new_class_data,
 807                                 jboolean                is_retransformer) {
 808     jboolean        errorOutstanding        = JNI_FALSE;
 809     jstring         classNameStringObject   = NULL;
 810     jarray          classFileBufferObject   = NULL;
 811     jarray          transformedBufferObject = NULL;
 812     jsize           transformedBufferSize   = 0;
 813     unsigned char * resultBuffer            = NULL;
 814     jboolean        shouldRun               = JNI_FALSE;
 815 
 816     /* only do this if we aren&#39;t already in the middle of processing a class on this thread */
 817     shouldRun = tryToAcquireReentrancyToken(
 818                                 jvmti(agent),
 819                                 NULL);  /* this thread */
 820 
 821     if ( shouldRun ) {
 822         /* first marshall all the parameters */
 823         classNameStringObject = (*jnienv)-&gt;NewStringUTF(jnienv,
 824                                                         name);
 825         errorOutstanding = checkForAndClearThrowable(jnienv);
 826         jplis_assert_msg(!errorOutstanding, &quot;can&#39;t create name string&quot;);
 827 
 828         if ( !errorOutstanding ) {
 829             classFileBufferObject = (*jnienv)-&gt;NewByteArray(jnienv,
 830                                                             class_data_len);
 831             errorOutstanding = checkForAndClearThrowable(jnienv);
 832             jplis_assert_msg(!errorOutstanding, &quot;can&#39;t create byte array&quot;);
 833         }
 834 
 835         if ( !errorOutstanding ) {
 836             jbyte * typedBuffer = (jbyte *) class_data; /* nasty cast, dumb JNI interface, const missing */
 837                                                         /* The sign cast is safe. The const cast is dumb. */
 838             (*jnienv)-&gt;SetByteArrayRegion(  jnienv,
 839                                             classFileBufferObject,
 840                                             0,
 841                                             class_data_len,
 842                                             typedBuffer);
 843             errorOutstanding = checkForAndClearThrowable(jnienv);
 844             jplis_assert_msg(!errorOutstanding, &quot;can&#39;t set byte array region&quot;);
 845         }
 846 
 847         /*  now call the JPL agents to do the transforming */
 848         /*  potential future optimization: may want to skip this if there are none */
 849         if ( !errorOutstanding ) {
 850             jobject moduleObject = NULL;
 851 
 852             if (classBeingRedefined == NULL) {
 853                 moduleObject = getModuleObject(jvmti(agent), loaderObject, name);
 854             } else {
 855                 // Redefine or retransform, InstrumentationImpl.transform() will use
 856                 // classBeingRedefined.getModule() to get the module.
 857             }
 858             jplis_assert(agent-&gt;mInstrumentationImpl != NULL);
 859             jplis_assert(agent-&gt;mTransform != NULL);
 860             transformedBufferObject = (*jnienv)-&gt;CallObjectMethod(
 861                                                 jnienv,
 862                                                 agent-&gt;mInstrumentationImpl,
 863                                                 agent-&gt;mTransform,
 864                                                 moduleObject,
 865                                                 loaderObject,
 866                                                 classNameStringObject,
 867                                                 classBeingRedefined,
 868                                                 protectionDomain,
 869                                                 classFileBufferObject,
 870                                                 is_retransformer);
 871             errorOutstanding = checkForAndClearThrowable(jnienv);
 872             jplis_assert_msg(!errorOutstanding, &quot;transform method call failed&quot;);
 873         }
 874 
 875         /* Finally, unmarshall the parameters (if someone touched the buffer, tell the JVM) */
 876         if ( !errorOutstanding ) {
 877             if ( transformedBufferObject != NULL ) {
 878                 transformedBufferSize = (*jnienv)-&gt;GetArrayLength(  jnienv,
 879                                                                     transformedBufferObject);
 880                 errorOutstanding = checkForAndClearThrowable(jnienv);
 881                 jplis_assert_msg(!errorOutstanding, &quot;can&#39;t get array length&quot;);
 882 
 883                 if ( !errorOutstanding ) {
 884                     /* allocate the response buffer with the JVMTI allocate call.
 885                      *  This is what the JVMTI spec says to do for Class File Load hook responses
 886                      */
 887                     jvmtiError  allocError = (*(jvmti(agent)))-&gt;Allocate(jvmti(agent),
 888                                                                              transformedBufferSize,
 889                                                                              &amp;resultBuffer);
 890                     errorOutstanding = (allocError != JVMTI_ERROR_NONE);
 891                     jplis_assert_msg(!errorOutstanding, &quot;can&#39;t allocate result buffer&quot;);
 892                 }
 893 
 894                 if ( !errorOutstanding ) {
 895                     (*jnienv)-&gt;GetByteArrayRegion(  jnienv,
 896                                                     transformedBufferObject,
 897                                                     0,
 898                                                     transformedBufferSize,
 899                                                     (jbyte *) resultBuffer);
 900                     errorOutstanding = checkForAndClearThrowable(jnienv);
 901                     jplis_assert_msg(!errorOutstanding, &quot;can&#39;t get byte array region&quot;);
 902 
 903                     /* in this case, we will not return the buffer to the JVMTI,
 904                      * so we need to deallocate it ourselves
 905                      */
 906                     if ( errorOutstanding ) {
 907                         deallocate( jvmti(agent),
 908                                    (void*)resultBuffer);
 909                     }
 910                 }
 911 
 912                 if ( !errorOutstanding ) {
 913                     *new_class_data_len = (transformedBufferSize);
 914                     *new_class_data     = resultBuffer;
 915                 }
 916             }
 917         }
 918 
 919         /* release the token */
 920         releaseReentrancyToken( jvmti(agent),
 921                                 NULL);      /* this thread */
 922 
 923     }
 924 
 925     return;
 926 }
 927 
 928 /*
 929  *  Misc. internal utilities.
 930  */
 931 
 932 /*
 933  *  The only checked exceptions we can throw are ClassNotFoundException and
 934  *  UnmodifiableClassException. All others map to InternalError.
 935  */
 936 jthrowable
 937 redefineClassMapper(    JNIEnv *    jnienv,
 938                         jthrowable  throwableToMap) {
 939     jthrowable  mappedThrowable = NULL;
 940 
 941     jplis_assert(isSafeForJNICalls(jnienv));
 942     jplis_assert(!isUnchecked(jnienv, throwableToMap));
 943 
 944     if ( isInstanceofClassName( jnienv,
 945                                 throwableToMap,
 946                                 &quot;java/lang/ClassNotFoundException&quot;) ) {
 947         mappedThrowable = throwableToMap;
 948     } else {
 949         if ( isInstanceofClassName( jnienv,
 950                                 throwableToMap,
 951                                 &quot;java/lang/instrument/UnmodifiableClassException&quot;)) {
 952             mappedThrowable = throwableToMap;
 953         } else {
 954             jstring message = NULL;
 955 
 956             message = getMessageFromThrowable(jnienv, throwableToMap);
 957             mappedThrowable = createInternalError(jnienv, message);
 958         }
 959     }
 960 
 961     jplis_assert(isSafeForJNICalls(jnienv));
 962     return mappedThrowable;
 963 }
 964 
 965 jobjectArray
 966 getObjectArrayFromClasses(JNIEnv* jnienv, jclass* classes, jint classCount) {
 967     jclass          classArrayClass = NULL;
 968     jobjectArray    localArray      = NULL;
 969     jint            classIndex      = 0;
 970     jboolean        errorOccurred   = JNI_FALSE;
 971 
 972     /* get the class array class */
 973     classArrayClass = (*jnienv)-&gt;FindClass(jnienv, &quot;java/lang/Class&quot;);
 974     errorOccurred = checkForThrowable(jnienv);
 975 
 976     if (!errorOccurred) {
 977         jplis_assert_msg(classArrayClass != NULL, &quot;FindClass returned null class&quot;);
 978 
 979         /* create the array for the classes */
 980         localArray = (*jnienv)-&gt;NewObjectArray(jnienv, classCount, classArrayClass, NULL);
 981         errorOccurred = checkForThrowable(jnienv);
 982 
 983         if (!errorOccurred) {
 984             jplis_assert_msg(localArray != NULL, &quot;NewObjectArray returned null array&quot;);
 985 
 986             /* now copy refs to all the classes and put them into the array */
 987             for (classIndex = 0; classIndex &lt; classCount; classIndex++) {
 988                 /* put class into array */
 989                 (*jnienv)-&gt;SetObjectArrayElement(jnienv, localArray, classIndex, classes[classIndex]);
 990                 errorOccurred = checkForThrowable(jnienv);
 991 
 992                 if (errorOccurred) {
 993                     localArray = NULL;
 994                     break;
 995                 }
 996             }
 997         }
 998     }
 999 
1000     return localArray;
1001 }
1002 
1003 
1004 /* Return the environment with the retransformation capability.
1005  * Create it if it doesn&#39;t exist.
1006  * Return NULL if it can&#39;t be created.
1007  */
1008 jvmtiEnv *
1009 retransformableEnvironment(JPLISAgent * agent) {
1010     jvmtiEnv *          retransformerEnv     = NULL;
1011     jint                jnierror             = JNI_OK;
1012     jvmtiCapabilities   desiredCapabilities;
1013     jvmtiEventCallbacks callbacks;
1014     jvmtiError          jvmtierror;
1015 
1016     if (agent-&gt;mRetransformEnvironment.mJVMTIEnv != NULL) {
1017         return agent-&gt;mRetransformEnvironment.mJVMTIEnv;
1018     }
1019     jnierror = (*agent-&gt;mJVM)-&gt;GetEnv(  agent-&gt;mJVM,
1020                                (void **) &amp;retransformerEnv,
1021                                JVMTI_VERSION_1_1);
1022     if ( jnierror != JNI_OK ) {
1023         return NULL;
1024     }
1025     jvmtierror = (*retransformerEnv)-&gt;GetCapabilities(retransformerEnv, &amp;desiredCapabilities);
1026     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
1027     desiredCapabilities.can_retransform_classes = 1;
1028     if (agent-&gt;mNativeMethodPrefixAdded) {
1029         desiredCapabilities.can_set_native_method_prefix = 1;
1030     }
1031 
1032     jvmtierror = (*retransformerEnv)-&gt;AddCapabilities(retransformerEnv, &amp;desiredCapabilities);
1033     if (jvmtierror != JVMTI_ERROR_NONE) {
1034          /* cannot get the capability, dispose of the retransforming environment */
1035         jvmtierror = (*retransformerEnv)-&gt;DisposeEnvironment(retransformerEnv);
1036         jplis_assert(jvmtierror == JVMTI_ERROR_NOT_AVAILABLE);
1037         return NULL;
1038     }
1039     memset(&amp;callbacks, 0, sizeof(callbacks));
1040     callbacks.ClassFileLoadHook = &amp;eventHandlerClassFileLoadHook;
1041 
1042     jvmtierror = (*retransformerEnv)-&gt;SetEventCallbacks(retransformerEnv,
1043                                                         &amp;callbacks,
1044                                                         sizeof(callbacks));
1045     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
1046     if (jvmtierror == JVMTI_ERROR_NONE) {
1047         // install the retransforming environment
1048         agent-&gt;mRetransformEnvironment.mJVMTIEnv = retransformerEnv;
1049         agent-&gt;mRetransformEnvironment.mIsRetransformer = JNI_TRUE;
1050 
1051         // Make it for ClassFileLoadHook handling
1052         jvmtierror = (*retransformerEnv)-&gt;SetEnvironmentLocalStorage(
1053                                                        retransformerEnv,
1054                                                        &amp;(agent-&gt;mRetransformEnvironment));
1055         jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
1056         if (jvmtierror == JVMTI_ERROR_NONE) {
1057             return retransformerEnv;
1058         }
1059     }
1060     return NULL;
1061 }
1062 
1063 
1064 /*
1065  *  Underpinnings for native methods
1066  */
1067 
1068 jboolean
1069 isModifiableClass(JNIEnv * jnienv, JPLISAgent * agent, jclass clazz) {
1070     jvmtiEnv *          jvmtienv = jvmti(agent);
1071     jvmtiError          jvmtierror;
1072     jboolean            is_modifiable = JNI_FALSE;
1073 
1074     jvmtierror = (*jvmtienv)-&gt;IsModifiableClass( jvmtienv,
1075                                                  clazz,
1076                                                  &amp;is_modifiable);
1077     check_phase_ret_false(jvmtierror);
1078     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
1079 
1080     return is_modifiable;
1081 }
1082 
1083 jboolean
1084 isRetransformClassesSupported(JNIEnv * jnienv, JPLISAgent * agent) {
1085     return agent-&gt;mRetransformEnvironment.mIsRetransformer;
1086 }
1087 
1088 void
1089 setHasTransformers(JNIEnv * jnienv, JPLISAgent * agent, jboolean has) {
1090     jvmtiEnv *          jvmtienv = jvmti(agent);
1091     jvmtiError          jvmtierror;
1092 
1093     jplis_assert(jvmtienv != NULL);
1094     jvmtierror = (*jvmtienv)-&gt;SetEventNotificationMode(
1095                                             jvmtienv,
1096                                             has? JVMTI_ENABLE : JVMTI_DISABLE,
1097                                             JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,
1098                                             NULL /* all threads */);
1099     check_phase_ret(jvmtierror);
1100     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
1101 }
1102 
1103 void
1104 setHasRetransformableTransformers(JNIEnv * jnienv, JPLISAgent * agent, jboolean has) {
1105     jvmtiEnv *          retransformerEnv     = retransformableEnvironment(agent);
1106     jvmtiError          jvmtierror;
1107 
1108     jplis_assert(retransformerEnv != NULL);
1109     jvmtierror = (*retransformerEnv)-&gt;SetEventNotificationMode(
1110                                                     retransformerEnv,
1111                                                     has? JVMTI_ENABLE : JVMTI_DISABLE,
1112                                                     JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,
1113                                                     NULL /* all threads */);
1114     check_phase_ret(jvmtierror);
1115     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
1116 }
1117 
1118 void
1119 retransformClasses(JNIEnv * jnienv, JPLISAgent * agent, jobjectArray classes) {
1120     jvmtiEnv *  retransformerEnv     = retransformableEnvironment(agent);
1121     jboolean    errorOccurred        = JNI_FALSE;
1122     jvmtiError  errorCode            = JVMTI_ERROR_NONE;
1123     jsize       numClasses           = 0;
1124     jclass *    classArray           = NULL;
1125 
1126     /* This is supposed to be checked by caller, but just to be sure */
1127     if (retransformerEnv == NULL) {
1128         jplis_assert(retransformerEnv != NULL);
1129         errorOccurred = JNI_TRUE;
1130         errorCode = JVMTI_ERROR_MUST_POSSESS_CAPABILITY;
1131     }
1132 
1133     /* This was supposed to be checked by caller too */
1134     if (!errorOccurred &amp;&amp; classes == NULL) {
1135         jplis_assert(classes != NULL);
1136         errorOccurred = JNI_TRUE;
1137         errorCode = JVMTI_ERROR_NULL_POINTER;
1138     }
1139 
1140     if (!errorOccurred) {
1141         numClasses = (*jnienv)-&gt;GetArrayLength(jnienv, classes);
1142         errorOccurred = checkForThrowable(jnienv);
1143         jplis_assert(!errorOccurred);
1144 
1145         if (!errorOccurred &amp;&amp; numClasses == 0) {
1146             jplis_assert(numClasses != 0);
1147             errorOccurred = JNI_TRUE;
1148             errorCode = JVMTI_ERROR_NULL_POINTER;
1149         }
1150     }
1151 
1152     if (!errorOccurred) {
1153         classArray = (jclass *) allocate(retransformerEnv,
1154                                          numClasses * sizeof(jclass));
1155         errorOccurred = (classArray == NULL);
1156         jplis_assert(!errorOccurred);
1157         if (errorOccurred) {
1158             errorCode = JVMTI_ERROR_OUT_OF_MEMORY;
1159         }
1160     }
1161 
1162     if (!errorOccurred) {
1163         jint index;
1164         for (index = 0; index &lt; numClasses; index++) {
1165             classArray[index] = (*jnienv)-&gt;GetObjectArrayElement(jnienv, classes, index);
1166             errorOccurred = checkForThrowable(jnienv);
1167             jplis_assert(!errorOccurred);
1168             if (errorOccurred) {
1169                 break;
1170             }
1171 
1172             if (classArray[index] == NULL) {
1173                 jplis_assert(classArray[index] != NULL);
1174                 errorOccurred = JNI_TRUE;
1175                 errorCode = JVMTI_ERROR_NULL_POINTER;
1176                 break;
1177             }
1178         }
1179     }
1180 
1181     if (!errorOccurred) {
1182         errorCode = (*retransformerEnv)-&gt;RetransformClasses(retransformerEnv,
1183                                                             numClasses, classArray);
1184         errorOccurred = (errorCode != JVMTI_ERROR_NONE);
1185     }
1186 
1187     /* Give back the buffer if we allocated it.  Throw any exceptions after.
1188      */
1189     if (classArray != NULL) {
1190         deallocate(retransformerEnv, (void*)classArray);
1191     }
1192 
1193     /* Return back if we executed the JVMTI API in a wrong phase
1194      */
1195     check_phase_ret(errorCode);
1196 
1197     if (errorCode != JVMTI_ERROR_NONE) {
1198         createAndThrowThrowableFromJVMTIErrorCode(jnienv, errorCode);
1199     }
1200 
1201     mapThrownThrowableIfNecessary(jnienv, redefineClassMapper);
1202 }
1203 
1204 /*
1205  *  Java code must not call this with a null list or a zero-length list.
1206  */
1207 void
1208 redefineClasses(JNIEnv * jnienv, JPLISAgent * agent, jobjectArray classDefinitions) {
1209     jvmtiEnv*   jvmtienv                        = jvmti(agent);
1210     jboolean    errorOccurred                   = JNI_FALSE;
1211     jclass      classDefClass                   = NULL;
1212     jmethodID   getDefinitionClassMethodID      = NULL;
1213     jmethodID   getDefinitionClassFileMethodID  = NULL;
1214     jvmtiClassDefinition* classDefs             = NULL;
1215     jbyteArray* targetFiles                     = NULL;
1216     jsize       numDefs                         = 0;
1217 
1218     jplis_assert(classDefinitions != NULL);
1219 
1220     numDefs = (*jnienv)-&gt;GetArrayLength(jnienv, classDefinitions);
1221     errorOccurred = checkForThrowable(jnienv);
1222     jplis_assert(!errorOccurred);
1223 
1224     if (!errorOccurred) {
1225         jplis_assert(numDefs &gt; 0);
1226         /* get method IDs for methods to call on class definitions */
1227         classDefClass = (*jnienv)-&gt;FindClass(jnienv, &quot;java/lang/instrument/ClassDefinition&quot;);
1228         errorOccurred = checkForThrowable(jnienv);
1229         jplis_assert(!errorOccurred);
1230     }
1231 
1232     if (!errorOccurred) {
1233         getDefinitionClassMethodID = (*jnienv)-&gt;GetMethodID(    jnienv,
1234                                                 classDefClass,
1235                                                 &quot;getDefinitionClass&quot;,
1236                                                 &quot;()Ljava/lang/Class;&quot;);
1237         errorOccurred = checkForThrowable(jnienv);
1238         jplis_assert(!errorOccurred);
1239     }
1240 
1241     if (!errorOccurred) {
1242         getDefinitionClassFileMethodID = (*jnienv)-&gt;GetMethodID(    jnienv,
1243                                                     classDefClass,
1244                                                     &quot;getDefinitionClassFile&quot;,
1245                                                     &quot;()[B&quot;);
1246         errorOccurred = checkForThrowable(jnienv);
1247         jplis_assert(!errorOccurred);
1248     }
1249 
1250     if (!errorOccurred) {
1251         classDefs = (jvmtiClassDefinition *) allocate(
1252                                                 jvmtienv,
1253                                                 numDefs * sizeof(jvmtiClassDefinition));
1254         errorOccurred = (classDefs == NULL);
1255         jplis_assert(!errorOccurred);
1256         if ( errorOccurred ) {
1257             createAndThrowThrowableFromJVMTIErrorCode(jnienv, JVMTI_ERROR_OUT_OF_MEMORY);
1258         }
1259 
1260         else {
1261             /*
1262              * We have to save the targetFile values that we compute so
1263              * that we can release the class_bytes arrays that are
1264              * returned by GetByteArrayElements(). In case of a JNI
1265              * error, we can&#39;t (easily) recompute the targetFile values
1266              * and we still want to free any memory we allocated.
1267              */
1268             targetFiles = (jbyteArray *) allocate(jvmtienv,
1269                                                   numDefs * sizeof(jbyteArray));
1270             errorOccurred = (targetFiles == NULL);
1271             jplis_assert(!errorOccurred);
1272             if ( errorOccurred ) {
1273                 deallocate(jvmtienv, (void*)classDefs);
1274                 createAndThrowThrowableFromJVMTIErrorCode(jnienv,
1275                     JVMTI_ERROR_OUT_OF_MEMORY);
1276             }
1277             else {
1278                 jint i, j;
1279 
1280                 // clear classDefs so we can correctly free memory during errors
1281                 memset(classDefs, 0, numDefs * sizeof(jvmtiClassDefinition));
1282 
1283                 for (i = 0; i &lt; numDefs; i++) {
1284                     jclass      classDef    = NULL;
1285 
1286                     classDef = (*jnienv)-&gt;GetObjectArrayElement(jnienv, classDefinitions, i);
1287                     errorOccurred = checkForThrowable(jnienv);
1288                     jplis_assert(!errorOccurred);
1289                     if (errorOccurred) {
1290                         break;
1291                     }
1292 
1293                     classDefs[i].klass = (*jnienv)-&gt;CallObjectMethod(jnienv, classDef, getDefinitionClassMethodID);
1294                     errorOccurred = checkForThrowable(jnienv);
1295                     jplis_assert(!errorOccurred);
1296                     if (errorOccurred) {
1297                         break;
1298                     }
1299 
1300                     targetFiles[i] = (*jnienv)-&gt;CallObjectMethod(jnienv, classDef, getDefinitionClassFileMethodID);
1301                     errorOccurred = checkForThrowable(jnienv);
1302                     jplis_assert(!errorOccurred);
1303                     if (errorOccurred) {
1304                         break;
1305                     }
1306 
1307                     classDefs[i].class_byte_count = (*jnienv)-&gt;GetArrayLength(jnienv, targetFiles[i]);
1308                     errorOccurred = checkForThrowable(jnienv);
1309                     jplis_assert(!errorOccurred);
1310                     if (errorOccurred) {
1311                         break;
1312                     }
1313 
1314                     /*
1315                      * Allocate class_bytes last so we don&#39;t have to free
1316                      * memory on a partial row error.
1317                      */
1318                     classDefs[i].class_bytes = (unsigned char*)(*jnienv)-&gt;GetByteArrayElements(jnienv, targetFiles[i], NULL);
1319                     errorOccurred = checkForThrowable(jnienv);
1320                     jplis_assert(!errorOccurred);
1321                     if (errorOccurred) {
1322                         break;
1323                     }
1324                 }
1325 
1326                 if (!errorOccurred) {
1327                     jvmtiError  errorCode = JVMTI_ERROR_NONE;
1328                     errorCode = (*jvmtienv)-&gt;RedefineClasses(jvmtienv, numDefs, classDefs);
1329                     if (errorCode == JVMTI_ERROR_WRONG_PHASE) {
1330                         /* insulate caller from the wrong phase error */
1331                         errorCode = JVMTI_ERROR_NONE;
1332                     } else {
1333                         errorOccurred = (errorCode != JVMTI_ERROR_NONE);
1334                         if ( errorOccurred ) {
1335                             createAndThrowThrowableFromJVMTIErrorCode(jnienv, errorCode);
1336                         }
1337                     }
1338                 }
1339 
1340                 /*
1341                  * Cleanup memory that we allocated above. If we had a
1342                  * JNI error, a JVM/TI error or no errors, index &#39;i&#39;
1343                  * tracks how far we got in processing the classDefs
1344                  * array. Note:  ReleaseByteArrayElements() is safe to
1345                  * call with a JNI exception pending.
1346                  */
1347                 for (j = 0; j &lt; i; j++) {
1348                     if ((jbyte *)classDefs[j].class_bytes != NULL) {
1349                         (*jnienv)-&gt;ReleaseByteArrayElements(jnienv,
1350                             targetFiles[j], (jbyte *)classDefs[j].class_bytes,
1351                             0 /* copy back and free */);
1352                         /*
1353                          * Only check for error if we didn&#39;t already have one
1354                          * so we don&#39;t overwrite errorOccurred.
1355                          */
1356                         if (!errorOccurred) {
1357                             errorOccurred = checkForThrowable(jnienv);
1358                             jplis_assert(!errorOccurred);
1359                         }
1360                     }
1361                 }
1362                 deallocate(jvmtienv, (void*)targetFiles);
1363                 deallocate(jvmtienv, (void*)classDefs);
1364             }
1365         }
1366     }
1367 
1368     mapThrownThrowableIfNecessary(jnienv, redefineClassMapper);
1369 }
1370 
1371 /* Cheesy sharing. ClassLoader may be null. */
1372 jobjectArray
1373 commonGetClassList( JNIEnv *            jnienv,
1374                     JPLISAgent *        agent,
1375                     jobject             classLoader,
1376                     ClassListFetcher    fetcher) {
1377     jvmtiEnv *      jvmtienv        = jvmti(agent);
1378     jboolean        errorOccurred   = JNI_FALSE;
1379     jvmtiError      jvmtierror      = JVMTI_ERROR_NONE;
1380     jint            classCount      = 0;
1381     jclass *        classes         = NULL;
1382     jobjectArray    localArray      = NULL;
1383 
1384     /* retrieve the classes from the JVMTI agent */
1385     jvmtierror = (*fetcher)( jvmtienv,
1386                         classLoader,
1387                         &amp;classCount,
1388                         &amp;classes);
1389     check_phase_ret_blob(jvmtierror, localArray);
1390     errorOccurred = (jvmtierror != JVMTI_ERROR_NONE);
1391     jplis_assert(!errorOccurred);
1392 
1393     if ( errorOccurred ) {
1394         createAndThrowThrowableFromJVMTIErrorCode(jnienv, jvmtierror);
1395     } else {
1396         localArray = getObjectArrayFromClasses( jnienv,
1397                                                 classes,
1398                                                 classCount);
1399         errorOccurred = checkForThrowable(jnienv);
1400         jplis_assert(!errorOccurred);
1401 
1402         /* do this whether or not we saw a problem */
1403         deallocate(jvmtienv, (void*)classes);
1404     }
1405 
1406     mapThrownThrowableIfNecessary(jnienv, mapAllCheckedToInternalErrorMapper);
1407     return localArray;
1408 
1409 }
1410 
1411 jvmtiError
1412 getAllLoadedClassesClassListFetcher(    jvmtiEnv *  jvmtienv,
1413                                         jobject     classLoader,
1414                                         jint *      classCount,
1415                                         jclass **   classes) {
1416     return (*jvmtienv)-&gt;GetLoadedClasses(jvmtienv, classCount, classes);
1417 }
1418 
1419 jobjectArray
1420 getAllLoadedClasses(JNIEnv * jnienv, JPLISAgent * agent) {
1421     return commonGetClassList(  jnienv,
1422                                 agent,
1423                                 NULL,
1424                                 getAllLoadedClassesClassListFetcher);
1425 }
1426 
1427 jvmtiError
1428 getInitiatedClassesClassListFetcher(    jvmtiEnv *  jvmtienv,
1429                                         jobject     classLoader,
1430                                         jint *      classCount,
1431                                         jclass **   classes) {
1432     return (*jvmtienv)-&gt;GetClassLoaderClasses(jvmtienv, classLoader, classCount, classes);
1433 }
1434 
1435 
1436 jobjectArray
1437 getInitiatedClasses(JNIEnv * jnienv, JPLISAgent * agent, jobject classLoader) {
1438     return commonGetClassList(  jnienv,
1439                                 agent,
1440                                 classLoader,
1441                                 getInitiatedClassesClassListFetcher);
1442 }
1443 
1444 jlong
1445 getObjectSize(JNIEnv * jnienv, JPLISAgent * agent, jobject objectToSize) {
1446     jvmtiEnv *  jvmtienv    = jvmti(agent);
1447     jlong       objectSize  = -1;
1448     jvmtiError  jvmtierror  = JVMTI_ERROR_NONE;
1449 
1450     jvmtierror = (*jvmtienv)-&gt;GetObjectSize(jvmtienv, objectToSize, &amp;objectSize);
1451     check_phase_ret_0(jvmtierror);
1452     jplis_assert(jvmtierror == JVMTI_ERROR_NONE);
1453     if ( jvmtierror != JVMTI_ERROR_NONE ) {
1454         createAndThrowThrowableFromJVMTIErrorCode(jnienv, jvmtierror);
1455     }
1456 
1457     mapThrownThrowableIfNecessary(jnienv, mapAllCheckedToInternalErrorMapper);
1458     return objectSize;
1459 }
1460 
1461 void
1462 appendToClassLoaderSearch(JNIEnv * jnienv, JPLISAgent * agent, jstring jarFile, jboolean isBootLoader)
1463 {
1464     jvmtiEnv *  jvmtienv    = jvmti(agent);
1465     jboolean    errorOutstanding;
1466     jvmtiError  jvmtierror;
1467     const char* utf8Chars;
1468     jsize       utf8Len;
1469     jboolean    isCopy;
1470     char        platformChars[MAXPATHLEN];
1471     int         platformLen;
1472 
1473     utf8Len = (*jnienv)-&gt;GetStringUTFLength(jnienv, jarFile);
1474     errorOutstanding = checkForAndClearThrowable(jnienv);
1475 
1476     if (!errorOutstanding) {
1477         utf8Chars = (*jnienv)-&gt;GetStringUTFChars(jnienv, jarFile, &amp;isCopy);
1478         errorOutstanding = checkForAndClearThrowable(jnienv);
1479 
1480         if (!errorOutstanding &amp;&amp; utf8Chars != NULL) {
1481             /*
1482              * JVMTI spec&#39;ed to use modified UTF8. At this time this is not implemented
1483              * the platform encoding is used.
1484              */
1485             platformLen = convertUft8ToPlatformString((char*)utf8Chars, utf8Len, platformChars, MAXPATHLEN);
1486             if (platformLen &lt; 0) {
1487                 createAndThrowInternalError(jnienv);
1488                 return;
1489             }
1490 
1491             (*jnienv)-&gt;ReleaseStringUTFChars(jnienv, jarFile, utf8Chars);
1492             errorOutstanding = checkForAndClearThrowable(jnienv);
1493 
1494             if (!errorOutstanding) {
1495 
1496                 if (isBootLoader) {
1497                     jvmtierror = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, platformChars);
1498                 } else {
1499                     jvmtierror = (*jvmtienv)-&gt;AddToSystemClassLoaderSearch(jvmtienv, platformChars);
1500                 }
1501                 check_phase_ret(jvmtierror);
1502 
1503                 if ( jvmtierror != JVMTI_ERROR_NONE ) {
1504                     createAndThrowThrowableFromJVMTIErrorCode(jnienv, jvmtierror);
1505                 }
1506             }
1507         }
1508     }
1509 
1510     mapThrownThrowableIfNecessary(jnienv, mapAllCheckedToInternalErrorMapper);
1511 }
1512 
1513 /*
1514  *  Set the prefixes used to wrap native methods (so they can be instrumented).
1515  *  Each transform can set a prefix, any that have been set come in as prefixArray.
1516  *  Convert them in native strings in a native array then call JVM TI.
1517  *  One a given call, this function handles either the prefixes for retransformable
1518  *  transforms or for normal transforms.
1519  */
1520 void
1521 setNativeMethodPrefixes(JNIEnv * jnienv, JPLISAgent * agent, jobjectArray prefixArray,
1522                         jboolean isRetransformable) {
1523     jvmtiEnv*   jvmtienv;
1524     jvmtiError  err                             = JVMTI_ERROR_NONE;
1525     jsize       arraySize;
1526     jboolean    errorOccurred                   = JNI_FALSE;
1527 
1528     jplis_assert(prefixArray != NULL);
1529 
1530     if (isRetransformable) {
1531         jvmtienv = agent-&gt;mRetransformEnvironment.mJVMTIEnv;
1532     } else {
1533         jvmtienv = agent-&gt;mNormalEnvironment.mJVMTIEnv;
1534     }
1535     arraySize = (*jnienv)-&gt;GetArrayLength(jnienv, prefixArray);
1536     errorOccurred = checkForThrowable(jnienv);
1537     jplis_assert(!errorOccurred);
1538 
1539     if (!errorOccurred) {
1540         /* allocate the native to hold the native prefixes */
1541         const char** prefixes = (const char**) allocate(jvmtienv,
1542                                                         arraySize * sizeof(char*));
1543         /* since JNI ReleaseStringUTFChars needs the jstring from which the native
1544          * string was allocated, we store them in a parallel array */
1545         jstring* originForRelease = (jstring*) allocate(jvmtienv,
1546                                                         arraySize * sizeof(jstring));
1547         errorOccurred = (prefixes == NULL || originForRelease == NULL);
1548         jplis_assert(!errorOccurred);
1549         if ( errorOccurred ) {
1550             createAndThrowThrowableFromJVMTIErrorCode(jnienv, JVMTI_ERROR_OUT_OF_MEMORY);
1551         }
1552         else {
1553             jint inx = 0;
1554             jint i;
1555             for (i = 0; i &lt; arraySize; i++) {
1556                 jstring      prefixStr  = NULL;
1557                 const char*  prefix;
1558                 jsize        prefixLen;
1559                 jboolean     isCopy;
1560 
1561                 prefixStr = (jstring) ((*jnienv)-&gt;GetObjectArrayElement(jnienv,
1562                                                                         prefixArray, i));
1563                 errorOccurred = checkForThrowable(jnienv);
1564                 jplis_assert(!errorOccurred);
1565                 if (errorOccurred) {
1566                     break;
1567                 }
1568                 if (prefixStr == NULL) {
1569                     continue;
1570                 }
1571 
1572                 prefixLen = (*jnienv)-&gt;GetStringUTFLength(jnienv, prefixStr);
1573                 errorOccurred = checkForThrowable(jnienv);
1574                 jplis_assert(!errorOccurred);
1575                 if (errorOccurred) {
1576                     break;
1577                 }
1578 
1579                 if (prefixLen &gt; 0) {
1580                     prefix = (*jnienv)-&gt;GetStringUTFChars(jnienv, prefixStr, &amp;isCopy);
1581                     errorOccurred = checkForThrowable(jnienv);
1582                     jplis_assert(!errorOccurred);
1583                     if (!errorOccurred &amp;&amp; prefix != NULL) {
1584                         prefixes[inx] = prefix;
1585                         originForRelease[inx] = prefixStr;
1586                         ++inx;
1587                     }
1588                 }
1589             }
1590 
1591             err = (*jvmtienv)-&gt;SetNativeMethodPrefixes(jvmtienv, inx, (char**)prefixes);
1592             /* can be called from any phase */
1593             jplis_assert(err == JVMTI_ERROR_NONE);
1594 
1595             for (i = 0; i &lt; inx; i++) {
1596               (*jnienv)-&gt;ReleaseStringUTFChars(jnienv, originForRelease[i], prefixes[i]);
1597             }
1598         }
1599         deallocate(jvmtienv, (void*)prefixes);
1600         deallocate(jvmtienv, (void*)originForRelease);
1601     }
1602 }
    </pre>
  </body>
</html>
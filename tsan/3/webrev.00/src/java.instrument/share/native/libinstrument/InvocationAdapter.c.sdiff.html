<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.instrument/share/native/libinstrument/InvocationAdapter.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="FileSystemSupport.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="JPLISAgent.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.instrument/share/native/libinstrument/InvocationAdapter.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Copyright 2003 Wily Technology, Inc.
 28  */
 29 
 30 #include    &lt;string.h&gt;
 31 #include    &lt;stdlib.h&gt;
 32 
 33 #include    &quot;jni.h&quot;
 34 


 35 #include    &quot;Utilities.h&quot;
 36 #include    &quot;JPLISAssert.h&quot;
 37 #include    &quot;JPLISAgent.h&quot;
 38 #include    &quot;JavaExceptions.h&quot;
 39 
 40 #include    &quot;EncodingSupport.h&quot;
 41 #include    &quot;FileSystemSupport.h&quot;
 42 #include    &quot;JarFacade.h&quot;
 43 #include    &quot;PathCharsValidator.h&quot;
 44 
 45 /**
 46  * This module contains the direct interface points with the JVMTI.
 47  * The OnLoad handler is here, along with the various event handlers.
 48  */
 49 
 50 static int
 51 appendClassPath(JPLISAgent* agent,
 52                 const char* jarfile);
 53 
 54 static void
</pre>
<hr />
<pre>
541 
542 /*
543  *  JVMTI callback support
544  *
545  *  We have two &quot;stages&quot; of callback support.
546  *  At OnLoad time, we install a VMInit handler.
547  *  When the VMInit handler runs, we remove the VMInit handler and install a
548  *  ClassFileLoadHook handler.
549  */
550 
551 void JNICALL
552 eventHandlerVMInit( jvmtiEnv *      jvmtienv,
553                     JNIEnv *        jnienv,
554                     jthread         thread) {
555     JPLISEnvironment * environment  = NULL;
556     jboolean           success      = JNI_FALSE;
557 
558     environment = getJPLISEnvironment(jvmtienv);
559 
560     /* process the premain calls on the all the JPL agents */
<span class="line-modified">561     if ( environment != NULL ) {</span>
<span class="line-modified">562         jthrowable outstandingException = NULL;</span>
<span class="line-modified">563         /*</span>
<span class="line-modified">564          * Add the jarfile to the system class path</span>
<span class="line-modified">565          */</span>
<span class="line-modified">566         JPLISAgent * agent = environment-&gt;mAgent;</span>
<span class="line-modified">567         if (appendClassPath(agent, agent-&gt;mJarfile)) {</span>
<span class="line-modified">568             fprintf(stderr, &quot;Unable to add %s to system class path - &quot;</span>
<span class="line-modified">569                     &quot;the system class loader does not define the &quot;</span>
<span class="line-modified">570                     &quot;appendToClassPathForInstrumentation method or the method failed\n&quot;,</span>
<span class="line-modified">571                     agent-&gt;mJarfile);</span>
<span class="line-modified">572             free((void *)agent-&gt;mJarfile);</span>
<span class="line-modified">573             abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART);</span>
<span class="line-removed">574         }</span>
575         free((void *)agent-&gt;mJarfile);
<span class="line-modified">576         agent-&gt;mJarfile = NULL;</span>
<span class="line-removed">577 </span>
<span class="line-removed">578         outstandingException = preserveThrowable(jnienv);</span>
<span class="line-removed">579         success = processJavaStart( environment-&gt;mAgent,</span>
<span class="line-removed">580                                     jnienv);</span>
<span class="line-removed">581         restoreThrowable(jnienv, outstandingException);</span>
582     }






583 
584     /* if we fail to start cleanly, bring down the JVM */
585     if ( !success ) {
<span class="line-modified">586         abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART);</span>
587     }
588 }
589 
590 void JNICALL
591 eventHandlerClassFileLoadHook(  jvmtiEnv *              jvmtienv,
592                                 JNIEnv *                jnienv,
593                                 jclass                  class_being_redefined,
594                                 jobject                 loader,
595                                 const char*             name,
596                                 jobject                 protectionDomain,
597                                 jint                    class_data_len,
598                                 const unsigned char*    class_data,
599                                 jint*                   new_class_data_len,
600                                 unsigned char**         new_class_data) {
601     JPLISEnvironment * environment  = NULL;
602 
603     environment = getJPLISEnvironment(jvmtienv);
604 
605     /* if something is internally inconsistent (no agent), just silently return without touching the buffer */
606     if ( environment != NULL ) {
</pre>
<hr />
<pre>
691  */
692 static
693 char *decodePath(const char *s, int* decodedLen) {
694     int n;
695     char *result;
696     char *resultp;
697     int c;
698     int i;
699 
700     n = (int)strlen(s);
701     if (n == 0) {
702         *decodedLen = 0;
703         return (char*)s;
704     }
705     if (strchr(s, &#39;%&#39;) == NULL) {
706         *decodedLen = n;
707         return (char*)s; /* no escapes, we are done */
708     }
709 
710     resultp = result = calloc(n+1, 1);




711     c = s[0];
712     for (i = 0; i &lt; n;) {
713         if (c != &#39;%&#39;) {
714             *resultp++ = c;
715             if (++i &gt;= n)
716                 break;
717             c = s[i];
718             continue;
719         }
720         for (;;) {
721             char b1 = s[++i];
722             char b2 = s[++i];
723             int decoded = decodeByte(b1, b2);
724             *resultp++ = decoded;
725             if (++i &gt;= n)
726                 break;
727             c = s[i];
728             if (c != &#39;%&#39;)
729                 break;
730         }
</pre>
<hr />
<pre>
759                 &quot;AddToSystemClassLoaderSearch\n&quot;, jvmtierr);
760             break;
761     }
762     return -1;
763 }
764 
765 
766 /*
767  * res = func, free&#39;ing the previous value of &#39;res&#39; if function
768  * returns a new result.
769  */
770 #define TRANSFORM(res,func) {    \
771     char* tmp = func;            \
772     if (tmp != res) {            \
773         free(res);               \
774         res = tmp;               \
775     }                            \
776     jplis_assert((void*)res != (void*)NULL);     \
777 }
778 
<span class="line-removed">779 /**</span>
<span class="line-removed">780  * Convert a pathname to canonical form.</span>
<span class="line-removed">781  * This method is exported from libjava.</span>
<span class="line-removed">782  */</span>
<span class="line-removed">783 extern int</span>
<span class="line-removed">784 Canonicalize(JNIEnv *unused, char *orig, char *out, int len);</span>
<span class="line-removed">785 </span>
<span class="line-removed">786 </span>
787 /*
788  * This function takes the value of the Boot-Class-Path attribute,
789  * splits it into the individual path segments, and then combines it
790  * with the path to the jar file to create the path to be added
791  * to the bootclasspath.
792  *
793  * Each individual path segment starts out as a UTF8 string. Additionally
794  * as the path is specified to use URI path syntax all non US-ASCII
795  * characters are escaped. Once the URI path is decoded we get a UTF8
796  * string which must then be converted to the platform encoding (as it
797  * will be combined with the platform path of the jar file). Once
798  * converted it is then normalized (remove duplicate slashes, etc.).
799  * If the resulting path is an absolute path (starts with a slash for
800  * example) then the path will be added to the bootclasspath. Otherwise
801  * if it&#39;s not absolute then we get the canoncial path of the agent jar
802  * file and then resolve the path in the context of the base path of
803  * the agent jar.
804  */
805 static void
806 appendBootClassPath( JPLISAgent* agent,
</pre>
<hr />
<pre>
887          * slash removed.
888          */
889         TRANSFORM(path, normalize(path));
890 
891         /*
892          * If the path is an absolute path then add to the bootclassloader
893          * search path. Otherwise we get the canonical path of the agent jar
894          * and then use its base path (directory) to resolve the given path
895          * segment.
896          *
897          * NOTE: JVMTI is specified to use modified UTF8 strings (like JNI).
898          * In 1.5.0 the AddToBootstrapClassLoaderSearch takes a platform string
899          * - see 5049313.
900          */
901         if (isAbsolute(path)) {
902             jvmtierr = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, path);
903         } else {
904             char* resolved;
905 
906             if (!haveBasePath) {
<span class="line-modified">907                 /* Use NULL as the JNIEnv since we know that Canonicalize does not use it. */</span>
<span class="line-removed">908                 if (Canonicalize(NULL, (char*)jarfile, canonicalPath, sizeof(canonicalPath)) != 0) {</span>
909                     fprintf(stderr, &quot;WARNING: unable to canonicalize %s\n&quot;, jarfile);
910                     free(path);
911                     continue;
912                 }
913                 parent = basePath(canonicalPath);
914                 jplis_assert(parent != (char*)NULL);
915                 haveBasePath = 1;
916             }
917 
918             resolved = resolve(parent, path);
919             jvmtierr = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, resolved);
920         }
921 
922         /* print warning if boot class path not updated */
923         if (jvmtierr != JVMTI_ERROR_NONE) {
924             check_phase_blob_ret(jvmtierr, free(path));
925 
926             fprintf(stderr, &quot;WARNING: %s not added to bootstrap class loader search: &quot;, path);
927             switch (jvmtierr) {
928                 case JVMTI_ERROR_ILLEGAL_ARGUMENT :
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Copyright 2003 Wily Technology, Inc.
 28  */
 29 
 30 #include    &lt;string.h&gt;
 31 #include    &lt;stdlib.h&gt;
 32 
 33 #include    &quot;jni.h&quot;
 34 
<span class="line-added"> 35 #include    &quot;jdk_util.h&quot;</span>
<span class="line-added"> 36 </span>
 37 #include    &quot;Utilities.h&quot;
 38 #include    &quot;JPLISAssert.h&quot;
 39 #include    &quot;JPLISAgent.h&quot;
 40 #include    &quot;JavaExceptions.h&quot;
 41 
 42 #include    &quot;EncodingSupport.h&quot;
 43 #include    &quot;FileSystemSupport.h&quot;
 44 #include    &quot;JarFacade.h&quot;
 45 #include    &quot;PathCharsValidator.h&quot;
 46 
 47 /**
 48  * This module contains the direct interface points with the JVMTI.
 49  * The OnLoad handler is here, along with the various event handlers.
 50  */
 51 
 52 static int
 53 appendClassPath(JPLISAgent* agent,
 54                 const char* jarfile);
 55 
 56 static void
</pre>
<hr />
<pre>
543 
544 /*
545  *  JVMTI callback support
546  *
547  *  We have two &quot;stages&quot; of callback support.
548  *  At OnLoad time, we install a VMInit handler.
549  *  When the VMInit handler runs, we remove the VMInit handler and install a
550  *  ClassFileLoadHook handler.
551  */
552 
553 void JNICALL
554 eventHandlerVMInit( jvmtiEnv *      jvmtienv,
555                     JNIEnv *        jnienv,
556                     jthread         thread) {
557     JPLISEnvironment * environment  = NULL;
558     jboolean           success      = JNI_FALSE;
559 
560     environment = getJPLISEnvironment(jvmtienv);
561 
562     /* process the premain calls on the all the JPL agents */
<span class="line-modified">563     if (environment == NULL) {</span>
<span class="line-modified">564         abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART &quot;, getting JPLIS environment failed&quot;);</span>
<span class="line-modified">565     }</span>
<span class="line-modified">566     jthrowable outstandingException = NULL;</span>
<span class="line-modified">567     /*</span>
<span class="line-modified">568      * Add the jarfile to the system class path</span>
<span class="line-modified">569      */</span>
<span class="line-modified">570     JPLISAgent * agent = environment-&gt;mAgent;</span>
<span class="line-modified">571     if (appendClassPath(agent, agent-&gt;mJarfile)) {</span>
<span class="line-modified">572         fprintf(stderr, &quot;Unable to add %s to system class path - &quot;</span>
<span class="line-modified">573                 &quot;the system class loader does not define the &quot;</span>
<span class="line-modified">574                 &quot;appendToClassPathForInstrumentation method or the method failed\n&quot;,</span>
<span class="line-modified">575                 agent-&gt;mJarfile);</span>

576         free((void *)agent-&gt;mJarfile);
<span class="line-modified">577         abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART &quot;, appending to system class path failed&quot;);</span>





578     }
<span class="line-added">579     free((void *)agent-&gt;mJarfile);</span>
<span class="line-added">580     agent-&gt;mJarfile = NULL;</span>
<span class="line-added">581 </span>
<span class="line-added">582     outstandingException = preserveThrowable(jnienv);</span>
<span class="line-added">583     success = processJavaStart( environment-&gt;mAgent, jnienv);</span>
<span class="line-added">584     restoreThrowable(jnienv, outstandingException);</span>
585 
586     /* if we fail to start cleanly, bring down the JVM */
587     if ( !success ) {
<span class="line-modified">588         abortJVM(jnienv, JPLIS_ERRORMESSAGE_CANNOTSTART &quot;, processJavaStart failed&quot;);</span>
589     }
590 }
591 
592 void JNICALL
593 eventHandlerClassFileLoadHook(  jvmtiEnv *              jvmtienv,
594                                 JNIEnv *                jnienv,
595                                 jclass                  class_being_redefined,
596                                 jobject                 loader,
597                                 const char*             name,
598                                 jobject                 protectionDomain,
599                                 jint                    class_data_len,
600                                 const unsigned char*    class_data,
601                                 jint*                   new_class_data_len,
602                                 unsigned char**         new_class_data) {
603     JPLISEnvironment * environment  = NULL;
604 
605     environment = getJPLISEnvironment(jvmtienv);
606 
607     /* if something is internally inconsistent (no agent), just silently return without touching the buffer */
608     if ( environment != NULL ) {
</pre>
<hr />
<pre>
693  */
694 static
695 char *decodePath(const char *s, int* decodedLen) {
696     int n;
697     char *result;
698     char *resultp;
699     int c;
700     int i;
701 
702     n = (int)strlen(s);
703     if (n == 0) {
704         *decodedLen = 0;
705         return (char*)s;
706     }
707     if (strchr(s, &#39;%&#39;) == NULL) {
708         *decodedLen = n;
709         return (char*)s; /* no escapes, we are done */
710     }
711 
712     resultp = result = calloc(n+1, 1);
<span class="line-added">713     if (result == NULL) {</span>
<span class="line-added">714         *decodedLen = 0;</span>
<span class="line-added">715         return NULL;</span>
<span class="line-added">716     }</span>
717     c = s[0];
718     for (i = 0; i &lt; n;) {
719         if (c != &#39;%&#39;) {
720             *resultp++ = c;
721             if (++i &gt;= n)
722                 break;
723             c = s[i];
724             continue;
725         }
726         for (;;) {
727             char b1 = s[++i];
728             char b2 = s[++i];
729             int decoded = decodeByte(b1, b2);
730             *resultp++ = decoded;
731             if (++i &gt;= n)
732                 break;
733             c = s[i];
734             if (c != &#39;%&#39;)
735                 break;
736         }
</pre>
<hr />
<pre>
765                 &quot;AddToSystemClassLoaderSearch\n&quot;, jvmtierr);
766             break;
767     }
768     return -1;
769 }
770 
771 
772 /*
773  * res = func, free&#39;ing the previous value of &#39;res&#39; if function
774  * returns a new result.
775  */
776 #define TRANSFORM(res,func) {    \
777     char* tmp = func;            \
778     if (tmp != res) {            \
779         free(res);               \
780         res = tmp;               \
781     }                            \
782     jplis_assert((void*)res != (void*)NULL);     \
783 }
784 








785 /*
786  * This function takes the value of the Boot-Class-Path attribute,
787  * splits it into the individual path segments, and then combines it
788  * with the path to the jar file to create the path to be added
789  * to the bootclasspath.
790  *
791  * Each individual path segment starts out as a UTF8 string. Additionally
792  * as the path is specified to use URI path syntax all non US-ASCII
793  * characters are escaped. Once the URI path is decoded we get a UTF8
794  * string which must then be converted to the platform encoding (as it
795  * will be combined with the platform path of the jar file). Once
796  * converted it is then normalized (remove duplicate slashes, etc.).
797  * If the resulting path is an absolute path (starts with a slash for
798  * example) then the path will be added to the bootclasspath. Otherwise
799  * if it&#39;s not absolute then we get the canoncial path of the agent jar
800  * file and then resolve the path in the context of the base path of
801  * the agent jar.
802  */
803 static void
804 appendBootClassPath( JPLISAgent* agent,
</pre>
<hr />
<pre>
885          * slash removed.
886          */
887         TRANSFORM(path, normalize(path));
888 
889         /*
890          * If the path is an absolute path then add to the bootclassloader
891          * search path. Otherwise we get the canonical path of the agent jar
892          * and then use its base path (directory) to resolve the given path
893          * segment.
894          *
895          * NOTE: JVMTI is specified to use modified UTF8 strings (like JNI).
896          * In 1.5.0 the AddToBootstrapClassLoaderSearch takes a platform string
897          * - see 5049313.
898          */
899         if (isAbsolute(path)) {
900             jvmtierr = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, path);
901         } else {
902             char* resolved;
903 
904             if (!haveBasePath) {
<span class="line-modified">905                 if (JDK_Canonicalize((char*)jarfile, canonicalPath, sizeof(canonicalPath)) != 0) {</span>

906                     fprintf(stderr, &quot;WARNING: unable to canonicalize %s\n&quot;, jarfile);
907                     free(path);
908                     continue;
909                 }
910                 parent = basePath(canonicalPath);
911                 jplis_assert(parent != (char*)NULL);
912                 haveBasePath = 1;
913             }
914 
915             resolved = resolve(parent, path);
916             jvmtierr = (*jvmtienv)-&gt;AddToBootstrapClassLoaderSearch(jvmtienv, resolved);
917         }
918 
919         /* print warning if boot class path not updated */
920         if (jvmtierr != JVMTI_ERROR_NONE) {
921             check_phase_blob_ret(jvmtierr, free(path));
922 
923             fprintf(stderr, &quot;WARNING: %s not added to bootstrap class loader search: &quot;, path);
924             switch (jvmtierr) {
925                 case JVMTI_ERROR_ILLEGAL_ARGUMENT :
</pre>
</td>
</tr>
</table>
<center><a href="FileSystemSupport.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="JPLISAgent.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
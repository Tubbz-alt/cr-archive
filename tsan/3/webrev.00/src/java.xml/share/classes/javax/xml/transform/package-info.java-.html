<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/javax/xml/transform/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * Defines the generic APIs for processing transformation instructions,
 28  * and performing a transformation from source to result. These interfaces have no
 29  * dependencies on SAX or the DOM standard, and try to make as few assumptions as
 30  * possible about the details of the source and result of a transformation. It
 31  * achieves this by defining {@link javax.xml.transform.Source} and
 32  * {@link javax.xml.transform.Result} interfaces.
 33  *
 34  * &lt;p&gt;
 35  * To provide concrete classes for the user, the API defines specializations
 36  * of the interfaces found at the root level. These interfaces are found in
 37  * {@link javax.xml.transform.sax}, {@link javax.xml.transform.dom},
 38  * {@link javax.xml.transform.stax}, and {@link javax.xml.transform.stream}.
 39  *
 40  *
 41  * &lt;h2&gt;Creating Objects&lt;/h2&gt;
 42  *
 43  * &lt;p&gt;
 44  * The API allows a concrete {@link javax.xml.transform.TransformerFactory}
 45  * object to be created from the static function
 46  * {@link javax.xml.transform.TransformerFactory#newInstance}.
 47  *
 48  *
 49  * &lt;h2&gt;Specification of Inputs and Outputs&lt;/h2&gt;
 50  *
 51  * &lt;p&gt;
 52  * This API defines two interface objects called {@link javax.xml.transform.Source}
 53  * and {@link javax.xml.transform.Result}. In order to pass Source and Result
 54  * objects to the interfaces, concrete classes must be used. The following concrete
 55  * representations are defined for each of these objects:
 56  * {@link javax.xml.transform.stream.StreamSource} and
 57  * {@link javax.xml.transform.stream.StreamResult},
 58  * {@link javax.xml.transform.stax.StAXSource} and
 59  * {@link javax.xml.transform.stax.StAXResult}, and
 60  * {@link javax.xml.transform.sax.SAXSource} and
 61  * {@link javax.xml.transform.sax.SAXResult}, and
 62  * {@link javax.xml.transform.dom.DOMSource} and
 63  * {@link javax.xml.transform.dom.DOMResult}. Each of these objects defines a
 64  * FEATURE string (which is in the form of a URL), which can be passed into
 65  * {@link javax.xml.transform.TransformerFactory#getFeature} to see if the given
 66  * type of Source or Result object is supported. For instance, to test if a
 67  * DOMSource and a StreamResult is supported, you can apply the following test.
 68  *
 69  * &lt;pre&gt;
 70  * &lt;code&gt;
 71  * TransformerFactory tfactory = TransformerFactory.newInstance();
 72  * if (tfactory.getFeature(DOMSource.FEATURE) &amp;amp;&amp;amp;
 73  *     tfactory.getFeature(StreamResult.FEATURE)) {
 74  *     ...
 75  * }
 76  * &lt;/code&gt;
 77  * &lt;/pre&gt;
 78  *
 79  *
 80  * &lt;h2&gt;&lt;a id=&quot;qname-delimiter&quot;&gt;Qualified Name Representation&lt;/a&gt;&lt;/h2&gt;
 81  *
 82  * &lt;p&gt;
 83  * &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names&quot;&gt;Namespaces&lt;/a&gt; present something
 84  * of a problem area when dealing with XML objects. Qualified Names appear in XML
 85  * markup as prefixed names. But the prefixes themselves do not hold identity.
 86  * Rather, it is the URIs that they contextually map to that hold the identity.
 87  * Therefore, when passing a Qualified Name like &quot;xyz:foo&quot; among Java programs,
 88  * one must provide a means to map &quot;xyz&quot; to a namespace.
 89  *
 90  * &lt;p&gt;
 91  * One solution has been to create a &quot;QName&quot; object that holds the namespace URI,
 92  * as well as the prefix and local name, but this is not always an optimal solution,
 93  * as when, for example, you want to use unique strings as keys in a dictionary
 94  * object. Not having a string representation also makes it difficult to specify
 95  * a namespaced identity outside the context of an XML document.
 96  *
 97  * &lt;p&gt;
 98  * In order to pass namespaced values to transformations, for instance when setting
 99  * a property or a parameter on a {@link javax.xml.transform.Transformer} object,
100  * this specification defines that a String &quot;qname&quot; object parameter be passed as
101  * two-part string, the namespace URI enclosed in curly braces ({}), followed by
102  * the local name. If the qname has a null URI, then the String object only
103  * contains the local name. An application can safely check for a non-null URI by
104  * testing to see if the first character of the name is a &#39;{&#39; character.
105  *
106  * &lt;p&gt;
107  * For example, if a URI and local name were obtained from an element defined with
108  * &amp;lt;xyz:foo xmlns:xyz=&quot;http://xyz.foo.com/yada/baz.html&quot;/&amp;gt;, then the
109  * Qualified Name would be &quot;{http://xyz.foo.com/yada/baz.html}foo&quot;. Note that the
110  * prefix is lost.
111  *
112  *
113  * &lt;h2&gt;Result Tree Serialization&lt;/h2&gt;
114  *
115  * &lt;p&gt;
116  * Serialization of the result tree to a stream can be controlled with the
117  * {@link javax.xml.transform.Transformer#setOutputProperties} and the
118  * {@link javax.xml.transform.Transformer#setOutputProperty} methods.
119  * These properties only apply to stream results, they have no effect when
120  * the result is a DOM tree or SAX event stream.
121  *
122  * &lt;p&gt;
123  * Strings that match the &lt;a href=&quot;http://www.w3.org/TR/xslt#output&quot;&gt;XSLT
124  * specification for xsl:output attributes&lt;/a&gt; can be referenced from the
125  * {@link javax.xml.transform.OutputKeys} class. Other strings can be
126  * specified as well.
127  * If the transformer does not recognize an output key, a
128  * {@link java.lang.IllegalArgumentException} is thrown, unless the key name
129  * is &lt;a href=&quot;#qname-delimiter&quot;&gt;namespace qualified&lt;/a&gt;. Output key names
130  * that are namespace qualified are always allowed, although they may be
131  * ignored by some implementations.
132  *
133  * &lt;p&gt;
134  * If all that is desired is the simple identity transformation of a
135  * source to a result, then {@link javax.xml.transform.TransformerFactory}
136  * provides a
137  * {@link javax.xml.transform.TransformerFactory#newTransformer()} method
138  * with no arguments. This method creates a Transformer that effectively copies
139  * the source to the result. This method may be used to create a DOM from SAX
140  * events or to create an XML or HTML stream from a DOM or SAX events.
141  *
142  * &lt;h2&gt;Exceptions and Error Reporting&lt;/h2&gt;
143  *
144  * &lt;p&gt;
145  * The transformation API throw three types of specialized exceptions. A
146  * {@link javax.xml.transform.TransformerFactoryConfigurationError} is parallel to
147  * the {@link javax.xml.parsers.FactoryConfigurationError}, and is thrown
148  * when a configuration problem with the TransformerFactory exists. This error
149  * will typically be thrown when the transformation factory class specified with
150  * the &quot;javax.xml.transform.TransformerFactory&quot; system property cannot be found or
151  * instantiated.
152  *
153  * &lt;p&gt;
154  * A {@link javax.xml.transform.TransformerConfigurationException}
155  * may be thrown if for any reason a Transformer can not be created. A
156  * TransformerConfigurationException may be thrown if there is a syntax error in
157  * the transformation instructions, for example when
158  * {@link javax.xml.transform.TransformerFactory#newTransformer} is
159  * called.
160  *
161  * &lt;p&gt;
162  * {@link javax.xml.transform.TransformerException} is a general
163  * exception that occurs during the course of a transformation. A transformer
164  * exception may wrap another exception, and if any of the
165  * {@link javax.xml.transform.TransformerException#printStackTrace()}
166  * methods are called on it, it will produce a list of stack dumps, starting from
167  * the most recent. The transformer exception also provides a
168  * {@link javax.xml.transform.SourceLocator} object which indicates where
169  * in the source tree or transformation instructions the error occurred.
170  * {@link javax.xml.transform.TransformerException#getMessageAndLocation()}
171  * may be called to get an error message with location info, and
172  * {@link javax.xml.transform.TransformerException#getLocationAsString()}
173  * may be called to get just the location string.
174  *
175  * &lt;p&gt;
176  * Transformation warnings and errors are sent to an
177  * {@link javax.xml.transform.ErrorListener}, at which point the application may
178  * decide to report the error or warning, and may decide to throw an
179  * &lt;code&gt;Exception&lt;/code&gt; for a non-fatal error. The &lt;code&gt;ErrorListener&lt;/code&gt;
180  * may be set via {@link javax.xml.transform.TransformerFactory#setErrorListener}
181  * for reporting errors that have to do with syntax errors in the transformation
182  * instructions, or via {@link javax.xml.transform.Transformer#setErrorListener}
183  * to report errors that occur during the transformation. The &lt;code&gt;ErrorListener&lt;/code&gt;
184  * on both objects will always be valid and non-&lt;code&gt;null&lt;/code&gt;, whether set by
185  * the application or a default implementation provided by the processor.
186  * The default implementation provided by the processor will report all warnings
187  * and errors to &lt;code&gt;System.err&lt;/code&gt; and does not throw any &lt;code&gt;Exception&lt;/code&gt;s.
188  * Applications are &lt;em&gt;strongly&lt;/em&gt; encouraged to register and use
189  * &lt;code&gt;ErrorListener&lt;/code&gt;s that insure proper behavior for warnings and
190  * errors.
191  *
192  *
193  * &lt;h2&gt;Resolution of URIs within a transformation&lt;/h2&gt;
194  *
195  * &lt;p&gt;
196  * The API provides a way for URIs referenced from within the stylesheet
197  * instructions or within the transformation to be resolved by the calling
198  * application. This can be done by creating a class that implements the
199  * {@link javax.xml.transform.URIResolver} interface, with its one method,
200  * {@link javax.xml.transform.URIResolver#resolve}, and use this class to
201  * set the URI resolution for the transformation instructions or transformation
202  * with {@link javax.xml.transform.TransformerFactory#setURIResolver} or
203  * {@link javax.xml.transform.Transformer#setURIResolver}. The
204  * &lt;code&gt;URIResolver.resolve&lt;/code&gt; method takes two String arguments, the URI
205  * found in the stylesheet instructions or built as part of the transformation
206  * process, and the base URI against which the first argument will be made absolute
207  * if the absolute URI is required.
208  * The returned {@link javax.xml.transform.Source} object must be usable by
209  * the transformer, as specified in its implemented features.
210  *
211  * @since 1.5
212  */
213 
214 package javax.xml.transform;
    </pre>
  </body>
</html>
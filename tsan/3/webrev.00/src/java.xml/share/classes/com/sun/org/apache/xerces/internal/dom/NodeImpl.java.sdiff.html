<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/NodeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ElementNSImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="PSVIDOMImplementationImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/NodeImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2017 Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4  /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 import java.io.IOException;
  24 import java.io.ObjectOutputStream;
  25 import java.io.Serializable;
  26 import java.util.Map;
  27 import org.w3c.dom.DOMException;
  28 import org.w3c.dom.Document;
  29 import org.w3c.dom.DocumentType;

  30 import org.w3c.dom.NamedNodeMap;
  31 import org.w3c.dom.Node;
  32 import org.w3c.dom.NodeList;
  33 import org.w3c.dom.UserDataHandler;
  34 import org.w3c.dom.events.Event;
  35 import org.w3c.dom.events.EventListener;
  36 import org.w3c.dom.events.EventTarget;
  37 
  38 /**
  39  * NodeImpl provides the basic structure of a DOM tree. It is never used
  40  * directly, but instead is subclassed to add type and data
  41  * information, and additional methods, appropriate to each node of
  42  * the tree. Only its subclasses should be instantiated -- and those,
  43  * with the exception of Document itself, only through a specific
  44  * Document&#39;s factory methods.
  45  * &lt;P&gt;
  46  * The Node interface provides shared behaviors such as siblings and
  47  * children, both for consistancy and so that the most common tree
  48  * operations may be performed without constantly having to downcast
  49  * to specific node types. When there is no obvious mapping for one of
</pre>
<hr />
<pre>
  61  * in that document. (Note that this is much tighter than &quot;must be
  62  * same implementation&quot;) Nodes are all aware of their ownerDocument,
  63  * and attempts to mismatch will throw WRONG_DOCUMENT_ERR.
  64  * &lt;P&gt;
  65  * However, to save memory not all nodes always have a direct reference
  66  * to their ownerDocument. When a node is owned by another node it relies
  67  * on its owner to store its ownerDocument. Parent nodes always store it
  68  * though, so there is never more than one level of indirection.
  69  * And when a node doesn&#39;t have an owner, ownerNode refers to its
  70  * ownerDocument.
  71  * &lt;p&gt;
  72  * This class doesn&#39;t directly support mutation events, however, it still
  73  * implements the EventTarget interface and forward all related calls to the
  74  * document so that the document class do so.
  75  *
  76  * @xerces.internal
  77  *
  78  * @author Arnaud  Le Hors, IBM
  79  * @author Joe Kesselman, IBM
  80  * @since  PR-DOM-Level-1-19980818.

  81  */
  82 public abstract class NodeImpl
  83     implements Node, NodeList, EventTarget, Cloneable, Serializable{
  84 
  85     //
  86     // Constants
  87     //
  88 
  89 
  90     // TreePosition Constants.
  91     // Taken from DOM L3 Node interface.
  92     /**
  93      * The node precedes the reference node.
  94      */
  95     public static final short TREE_POSITION_PRECEDING   = 0x01;
  96     /**
  97      * The node follows the reference node.
  98      */
  99     public static final short TREE_POSITION_FOLLOWING   = 0x02;
 100     /**
</pre>
<hr />
<pre>
 105      * The node is a descendant of the reference node.
 106      */
 107     public static final short TREE_POSITION_DESCENDANT  = 0x08;
 108     /**
 109      * The two nodes have an equivalent position. This is the case of two
 110      * attributes that have the same &lt;code&gt;ownerElement&lt;/code&gt;, and two
 111      * nodes that are the same.
 112      */
 113     public static final short TREE_POSITION_EQUIVALENT  = 0x10;
 114     /**
 115      * The two nodes are the same. Two nodes that are the same have an
 116      * equivalent position, though the reverse may not be true.
 117      */
 118     public static final short TREE_POSITION_SAME_NODE   = 0x20;
 119     /**
 120      * The two nodes are disconnected, they do not have any common ancestor.
 121      * This is the case of two nodes that are not in the same document.
 122      */
 123     public static final short TREE_POSITION_DISCONNECTED = 0x00;
 124 
<span class="line-removed"> 125 </span>
<span class="line-removed"> 126     // DocumentPosition</span>
<span class="line-removed"> 127     public static final short DOCUMENT_POSITION_DISCONNECTED = 0x01;</span>
<span class="line-removed"> 128     public static final short DOCUMENT_POSITION_PRECEDING = 0x02;</span>
<span class="line-removed"> 129     public static final short DOCUMENT_POSITION_FOLLOWING = 0x04;</span>
<span class="line-removed"> 130     public static final short DOCUMENT_POSITION_CONTAINS = 0x08;</span>
<span class="line-removed"> 131     public static final short DOCUMENT_POSITION_IS_CONTAINED = 0x10;</span>
<span class="line-removed"> 132     public static final short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;</span>
<span class="line-removed"> 133 </span>
 134     /** Serialization version. */
 135     static final long serialVersionUID = -6316591992167219696L;
 136 
 137     // public
 138 
 139     /** Element definition node type. */
 140     public static final short ELEMENT_DEFINITION_NODE = 21;
 141 
 142     //
 143     // Data
 144     //
 145 
 146     // links
 147 
 148     protected NodeImpl ownerNode; // typically the parent but not always!
 149 
 150     // data
 151 
 152     protected short flags;
 153 
</pre>
<hr />
<pre>
 307     }
 308 
 309     /**
 310      * same as above but returns internal type and this one is not overridden
 311      * by CoreDocumentImpl to return null
 312      */
 313     CoreDocumentImpl ownerDocument() {
 314         // if we have an owner simply forward the request
 315         // otherwise ownerNode is our ownerDocument
 316         if (isOwned()) {
 317             return ownerNode.ownerDocument();
 318         } else {
 319             return (CoreDocumentImpl) ownerNode;
 320         }
 321     }
 322 
 323     /**
 324      * NON-DOM
 325      * set the ownerDocument of this node
 326      */
<span class="line-modified"> 327     void setOwnerDocument(CoreDocumentImpl doc) {</span>
 328         if (needsSyncData()) {
 329             synchronizeData();
 330         }
 331         // if we have an owner we rely on it to have it right
 332         // otherwise ownerNode is our ownerDocument
 333         if (!isOwned()) {
 334             ownerNode = doc;
 335         }
 336     }
 337 
 338     /**
 339      * Returns the node number
 340      */
 341     protected int getNodeNumber() {
 342         int nodeNumber;
 343         CoreDocumentImpl cd = (CoreDocumentImpl)(this.getOwnerDocument());
 344         nodeNumber = cd.getNodeNumber(this);
 345         return nodeNumber;
 346     }
 347 
</pre>
<hr />
<pre>
 542     /**
 543      * NodeList method: Count the immediate children of this node
 544      * &lt;P&gt;
 545      * By default we do not have any children, ParentNode overrides this.
 546      * @see ParentNode
 547      *
 548      * @return int
 549      */
 550     public int getLength() {
 551         return 0;
 552     }
 553 
 554     /**
 555      * NodeList method: Return the Nth immediate child of this node, or
 556      * null if the index is out of bounds.
 557      * &lt;P&gt;
 558      * By default we do not have any children, ParentNode overrides this.
 559      * @see ParentNode
 560      *
 561      * @return org.w3c.dom.Node
<span class="line-modified"> 562      * @param Index int</span>
 563      */
 564     public Node item(int index) {
 565         return null;
 566     }
 567 
 568     //
 569     // DOM2: methods, getters, setters
 570     //
 571 
 572     /**
 573      * Puts all &lt;code&gt;Text&lt;/code&gt; nodes in the full depth of the sub-tree
 574      * underneath this &lt;code&gt;Node&lt;/code&gt;, including attribute nodes, into a
 575      * &quot;normal&quot; form where only markup (e.g., tags, comments, processing
 576      * instructions, CDATA sections, and entity references) separates
 577      * &lt;code&gt;Text&lt;/code&gt; nodes, i.e., there are no adjacent &lt;code&gt;Text&lt;/code&gt;
 578      * nodes.  This can be used to ensure that the DOM view of a document is
 579      * the same as if it were saved and re-loaded, and is useful when
 580      * operations (such as XPointer lookups) that depend on a particular
 581      * document tree structure are to be used.In cases where the document
 582      * contains &lt;code&gt;CDATASections&lt;/code&gt;, the normalize operation alone may
</pre>
<hr />
<pre>
 959         // REVISIT:  shouldn&#39;t get here.   Should probably throw an
 960         // exception
 961         return 0;
 962 
 963     }
 964     /**
 965      * Compares a node with this node with regard to their position in the
 966      * document.
 967      * @param other The node to compare against this node.
 968      * @return Returns how the given node is positioned relatively to this
 969      *   node.
 970      * @since DOM Level 3
 971      */
 972     public short compareDocumentPosition(Node other) throws DOMException {
 973 
 974         // If the nodes are the same, no flags should be set
 975         if (this==other)
 976           return 0;
 977 
 978         // check if other is from a different implementation
<span class="line-modified"> 979         try {</span>
<span class="line-removed"> 980             NodeImpl node = (NodeImpl) other;</span>
<span class="line-removed"> 981         } catch (ClassCastException e) {</span>
 982             // other comes from a different implementation
 983             String msg = DOMMessageFormatter.formatMessage(
 984                DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_SUPPORTED_ERR&quot;, null);
 985             throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
 986         }
 987 
 988         Document thisOwnerDoc, otherOwnerDoc;
 989         // get the respective Document owners.
 990         if (this.getNodeType() == Node.DOCUMENT_NODE)
 991           thisOwnerDoc = (Document)this;
 992         else
 993           thisOwnerDoc = this.getOwnerDocument();
 994         if (other.getNodeType() == Node.DOCUMENT_NODE)
 995           otherOwnerDoc = (Document)other;
 996         else
 997           otherOwnerDoc = other.getOwnerDocument();
 998 
 999         // If from different documents, we know they are disconnected.
1000         // and have an implementation dependent order
1001         if (thisOwnerDoc != otherOwnerDoc &amp;&amp;
</pre>
<hr />
<pre>
1024 
1025         Node node;
1026         Node thisAncestor = this;
1027         Node otherAncestor = other;
1028 
1029         int thisDepth=0;
1030         int otherDepth=0;
1031         for (node=this; node != null; node = node.getParentNode()) {
1032             thisDepth +=1;
1033             if (node == other)
1034               // The other node is an ancestor of this one.
1035               return (DOCUMENT_POSITION_CONTAINS |
1036                       DOCUMENT_POSITION_PRECEDING);
1037             thisAncestor = node;
1038         }
1039 
1040         for (node=other; node!=null; node=node.getParentNode()) {
1041             otherDepth +=1;
1042             if (node == this)
1043               // The other node is a descendent of the reference node.
<span class="line-modified">1044               return (DOCUMENT_POSITION_IS_CONTAINED |</span>
1045                       DOCUMENT_POSITION_FOLLOWING);
1046             otherAncestor = node;
1047         }
1048 
1049 
1050 
1051         int thisAncestorType = thisAncestor.getNodeType();
1052         int otherAncestorType = otherAncestor.getNodeType();
1053         Node thisNode = this;
1054         Node otherNode = other;
1055 
1056         // Special casing for ENTITY, NOTATION, DOCTYPE and ATTRIBUTES
1057         // LM:  should rewrite this.
1058         switch (thisAncestorType) {
1059           case Node.NOTATION_NODE:
1060           case Node.ENTITY_NODE: {
1061             DocumentType container = thisOwnerDoc.getDoctype();
1062             if (container == otherAncestor) return
1063                    (DOCUMENT_POSITION_CONTAINS | DOCUMENT_POSITION_PRECEDING);
1064             switch (otherAncestorType) {
</pre>
<hr />
<pre>
1114             }
1115 
1116             // Now, find the ancestor of the element
1117             thisDepth=0;
1118             for (node=thisNode; node != null; node=node.getParentNode()) {
1119                 thisDepth +=1;
1120                 if (node == otherNode)
1121                   {
1122                   // The other node is an ancestor of the owning element
1123                   return (DOCUMENT_POSITION_CONTAINS |
1124                           DOCUMENT_POSITION_PRECEDING);
1125                   }
1126                 thisAncestor = node;
1127             }
1128           }
1129         }
1130         switch (otherAncestorType) {
1131           case Node.NOTATION_NODE:
1132           case Node.ENTITY_NODE: {
1133           DocumentType container = thisOwnerDoc.getDoctype();
<span class="line-modified">1134             if (container == this) return (DOCUMENT_POSITION_IS_CONTAINED |</span>
1135                                           DOCUMENT_POSITION_FOLLOWING);
1136             otherNode = otherAncestor = thisOwnerDoc;
1137             break;
1138           }
1139           case Node.DOCUMENT_TYPE_NODE: {
1140             if (thisNode == otherOwnerDoc)
1141               return (DOCUMENT_POSITION_FOLLOWING |
<span class="line-modified">1142                       DOCUMENT_POSITION_IS_CONTAINED);</span>
1143             else if (otherOwnerDoc!=null &amp;&amp; thisOwnerDoc==otherOwnerDoc)
1144               return (DOCUMENT_POSITION_PRECEDING);
1145             break;
1146           }
1147           case Node.ATTRIBUTE_NODE: {
1148             otherDepth=0;
1149             otherNode = ((AttrImpl)otherAncestor).getOwnerElement();
1150             for (node=otherNode; node != null; node=node.getParentNode()) {
1151                 otherDepth +=1;
1152                 if (node == thisNode)
1153                   // The other node is a descendent of the reference
1154                   // node&#39;s element
1155                   return DOCUMENT_POSITION_FOLLOWING |
<span class="line-modified">1156                          DOCUMENT_POSITION_IS_CONTAINED;</span>
1157                 otherAncestor = node;
1158             }
1159 
1160           }
1161         }
1162 
1163         // thisAncestor and otherAncestor must be the same at this point,
1164         // otherwise, the original nodes are disconnected
1165         if (thisAncestor != otherAncestor) {
1166           int thisAncestorNum, otherAncestorNum;
1167           thisAncestorNum = ((NodeImpl)thisAncestor).getNodeNumber();
1168           otherAncestorNum = ((NodeImpl)otherAncestor).getNodeNumber();
1169 
1170           if (thisAncestorNum &gt; otherAncestorNum)
1171             return DOCUMENT_POSITION_DISCONNECTED |
1172                    DOCUMENT_POSITION_FOLLOWING |
1173                    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
1174           else
1175             return DOCUMENT_POSITION_DISCONNECTED |
1176                    DOCUMENT_POSITION_PRECEDING |
</pre>
<hr />
<pre>
1285      * &lt;code&gt;nodeValue&lt;/code&gt;&lt;/td&gt;
1286      * &lt;/tr&gt;
1287      * &lt;tr&gt;
1288      * &lt;td valign=&#39;top&#39; rowspan=&#39;1&#39; colspan=&#39;1&#39;&gt;DOCUMENT_NODE, DOCUMENT_TYPE_NODE, NOTATION_NODE&lt;/td&gt;
1289      * &lt;td valign=&#39;top&#39; rowspan=&#39;1&#39; colspan=&#39;1&#39;&gt;
1290      * null&lt;/td&gt;
1291      * &lt;/tr&gt;
1292      * &lt;/table&gt;
1293      * @exception DOMException
1294      *   NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
1295      * @exception DOMException
1296      *   DOMSTRING_SIZE_ERR: Raised when it would return more characters than
1297      *   fit in a &lt;code&gt;DOMString&lt;/code&gt; variable on the implementation
1298      *   platform.
1299      * @since DOM Level 3
1300      */
1301     public String getTextContent() throws DOMException {
1302         return getNodeValue();  // overriden in some subclasses
1303     }
1304 
<span class="line-modified">1305     // internal method taking a StringBuffer in parameter</span>
<span class="line-modified">1306     void getTextContent(StringBuffer buf) throws DOMException {</span>
1307         String content = getNodeValue();
1308         if (content != null) {
1309             buf.append(content);
1310         }
1311     }
1312 
1313     /**
1314      * This attribute returns the text content of this node and its
1315      * descendants. When it is defined to be null, setting it has no effect.
1316      * When set, any possible children this node may have are removed and
1317      * replaced by a single &lt;code&gt;Text&lt;/code&gt; node containing the string
1318      * this attribute is set to. On getting, no serialization is performed,
1319      * the returned string does not contain any markup. No whitespace
1320      * normalization is performed, the returned string does not contain the
1321      * element content whitespaces . Similarly, on setting, no parsing is
1322      * performed either, the input string is taken as pure textual content.
1323      * &lt;br&gt;The string returned is made of the text content of this node
1324      * depending on its type, as defined below:
1325      * &lt;table border=&#39;1&#39;&gt;
1326      * &lt;tr&gt;
</pre>
<hr />
<pre>
1408             }
1409             if (this.hasAttributes()) {
1410                 ElementImpl elem = (ElementImpl)this;
1411                 NodeImpl attr = (NodeImpl)elem.getAttributeNodeNS(&quot;http://www.w3.org/2000/xmlns/&quot;, &quot;xmlns&quot;);
1412                 if (attr != null) {
1413                     String value = attr.getNodeValue();
1414                     if (namespaceURI == null) {
1415                         return (namespace == value);
1416                     }
1417                     return namespaceURI.equals(value);
1418                 }
1419             }
1420 
1421             NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1422             if (ancestor != null) {
1423                 return ancestor.isDefaultNamespace(namespaceURI);
1424             }
1425             return false;
1426         }
1427         case Node.DOCUMENT_NODE:{
<span class="line-modified">1428                 return((NodeImpl)((Document)this).getDocumentElement()).isDefaultNamespace(namespaceURI);</span>




1429             }
1430 
1431         case Node.ENTITY_NODE :
1432         case Node.NOTATION_NODE:
1433         case Node.DOCUMENT_FRAGMENT_NODE:
1434         case Node.DOCUMENT_TYPE_NODE:
1435             // type is unknown
1436             return false;
1437         case Node.ATTRIBUTE_NODE:{
1438                 if (this.ownerNode.getNodeType() == Node.ELEMENT_NODE) {
1439                     return ownerNode.isDefaultNamespace(namespaceURI);
1440 
1441                 }
1442                 return false;
1443             }
1444         default:{
1445                 NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1446                 if (ancestor != null) {
1447                     return ancestor.isDefaultNamespace(namespaceURI);
1448                 }
</pre>
<hr />
<pre>
1458     /**
1459      *
1460      * DOM Level 3 - Experimental:
1461      * Look up the prefix associated to the given namespace URI, starting from this node.
1462      *
1463      * @param namespaceURI
1464      * @return the prefix for the namespace
1465      */
1466     public String lookupPrefix(String namespaceURI){
1467 
1468         // REVISIT: When Namespaces 1.1 comes out this may not be true
1469         // Prefix can&#39;t be bound to null namespace
1470         if (namespaceURI == null) {
1471             return null;
1472         }
1473 
1474         short type = this.getNodeType();
1475 
1476         switch (type) {
1477         case Node.ELEMENT_NODE: {
<span class="line-modified">1478 </span>
<span class="line-removed">1479                 String namespace = this.getNamespaceURI(); // to flip out children</span>
1480                 return lookupNamespacePrefix(namespaceURI, (ElementImpl)this);
1481             }
1482         case Node.DOCUMENT_NODE:{
<span class="line-modified">1483                 return((NodeImpl)((Document)this).getDocumentElement()).lookupPrefix(namespaceURI);</span>




1484             }
1485 
1486         case Node.ENTITY_NODE :
1487         case Node.NOTATION_NODE:
1488         case Node.DOCUMENT_FRAGMENT_NODE:
1489         case Node.DOCUMENT_TYPE_NODE:
1490             // type is unknown
1491             return null;
1492         case Node.ATTRIBUTE_NODE:{
1493                 if (this.ownerNode.getNodeType() == Node.ELEMENT_NODE) {
1494                     return ownerNode.lookupPrefix(namespaceURI);
1495 
1496                 }
1497                 return null;
1498             }
1499         default:{
1500                 NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1501                 if (ancestor != null) {
1502                     return ancestor.lookupPrefix(namespaceURI);
1503                 }
1504                 return null;
1505             }
1506 
1507         }
1508     }
1509     /**
1510      * DOM Level 3 - Experimental:
1511      * Look up the namespace URI associated to the given prefix, starting from this node.
1512      * Use lookupNamespaceURI(null) to lookup the default namespace
1513      *
<span class="line-modified">1514      * @param namespaceURI</span>
<span class="line-modified">1515      * @return th URI for the namespace</span>
1516      * @since DOM Level 3
1517      */
1518     public String lookupNamespaceURI(String specifiedPrefix) {
1519         short type = this.getNodeType();
1520         switch (type) {
1521         case Node.ELEMENT_NODE : {
1522 
1523                 String namespace = this.getNamespaceURI();
1524                 String prefix = this.getPrefix();
1525                 if (namespace !=null) {
1526                     // REVISIT: is it possible that prefix is empty string?
1527                     if (specifiedPrefix== null &amp;&amp; prefix==specifiedPrefix) {
1528                         // looking for default namespace
1529                         return namespace;
1530                     } else if (prefix != null &amp;&amp; prefix.equals(specifiedPrefix)) {
1531                         // non default namespace
1532                         return namespace;
1533                     }
1534                 }
1535                 if (this.hasAttributes()) {
1536                     NamedNodeMap map = this.getAttributes();
1537                     int length = map.getLength();
1538                     for (int i=0;i&lt;length;i++) {
1539                         Node attr = map.item(i);
<span class="line-removed">1540                         String attrPrefix = attr.getPrefix();</span>
<span class="line-removed">1541                         String value = attr.getNodeValue();</span>
1542                         namespace = attr.getNamespaceURI();
1543                         if (namespace !=null &amp;&amp; namespace.equals(&quot;http://www.w3.org/2000/xmlns/&quot;)) {


1544                             // at this point we are dealing with DOM Level 2 nodes only
1545                             if (specifiedPrefix == null &amp;&amp;
1546                                 attr.getNodeName().equals(&quot;xmlns&quot;)) {
1547                                 // default namespace
<span class="line-modified">1548                                 return value;</span>
1549                             } else if (attrPrefix !=null &amp;&amp;
1550                                        attrPrefix.equals(&quot;xmlns&quot;) &amp;&amp;
1551                                        attr.getLocalName().equals(specifiedPrefix)) {
1552                                 // non default namespace
<span class="line-modified">1553                                 return value;</span>
1554                             }
1555                         }
1556                     }
1557                 }
1558                 NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1559                 if (ancestor != null) {
1560                     return ancestor.lookupNamespaceURI(specifiedPrefix);
1561                 }
1562 
1563                 return null;
1564 
1565 
1566             }
1567         case Node.DOCUMENT_NODE : {
<span class="line-modified">1568                 return((NodeImpl)((Document)this).getDocumentElement()).lookupNamespaceURI(specifiedPrefix);</span>




1569             }
1570         case Node.ENTITY_NODE :
1571         case Node.NOTATION_NODE:
1572         case Node.DOCUMENT_FRAGMENT_NODE:
1573         case Node.DOCUMENT_TYPE_NODE:
1574             // type is unknown
1575             return null;
1576         case Node.ATTRIBUTE_NODE:{
1577                 if (this.ownerNode.getNodeType() == Node.ELEMENT_NODE) {
1578                     return ownerNode.lookupNamespaceURI(specifiedPrefix);
1579 
1580                 }
1581                 return null;
1582             }
1583         default:{
1584                 NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1585                 if (ancestor != null) {
1586                     return ancestor.lookupNamespaceURI(specifiedPrefix);
1587                 }
1588                 return null;
1589             }
1590 
1591         }
1592     }
1593 
<span class="line-modified">1594 </span>
<span class="line-removed">1595     Node getElementAncestor (Node currentNode){</span>
1596         Node parent = currentNode.getParentNode();
<span class="line-modified">1597         if (parent != null) {</span>
1598             short type = parent.getNodeType();
1599             if (type == Node.ELEMENT_NODE) {
1600                 return parent;
1601             }
<span class="line-modified">1602             return getElementAncestor(parent);</span>
1603         }
1604         return null;
1605     }
1606 
1607     String lookupNamespacePrefix(String namespaceURI, ElementImpl el){
1608         String namespace = this.getNamespaceURI();
1609         // REVISIT: if no prefix is available is it null or empty string, or
1610         //          could be both?
1611         String prefix = this.getPrefix();
1612 
1613         if (namespace!=null &amp;&amp; namespace.equals(namespaceURI)) {
1614             if (prefix != null) {
1615                 String foundNamespace =  el.lookupNamespaceURI(prefix);
1616                 if (foundNamespace !=null &amp;&amp; foundNamespace.equals(namespaceURI)) {
1617                     return prefix;
1618                 }
1619 
1620             }
1621         }
1622         if (this.hasAttributes()) {
1623             NamedNodeMap map = this.getAttributes();
1624             int length = map.getLength();
1625             for (int i=0;i&lt;length;i++) {
1626                 Node attr = map.item(i);
<span class="line-removed">1627                 String attrPrefix = attr.getPrefix();</span>
<span class="line-removed">1628                 String value = attr.getNodeValue();</span>
1629                 namespace = attr.getNamespaceURI();
1630                 if (namespace !=null &amp;&amp; namespace.equals(&quot;http://www.w3.org/2000/xmlns/&quot;)) {


1631                     // DOM Level 2 nodes
1632                     if (((attr.getNodeName().equals(&quot;xmlns&quot;)) ||
1633                          (attrPrefix !=null &amp;&amp; attrPrefix.equals(&quot;xmlns&quot;)) &amp;&amp;
1634                          value.equals(namespaceURI))) {
1635 
1636                         String localname= attr.getLocalName();
1637                         String foundNamespace = el.lookupNamespaceURI(localname);
1638                         if (foundNamespace !=null &amp;&amp; foundNamespace.equals(namespaceURI)) {
1639                             return localname;
1640                         }
1641                     }
1642 
1643 
1644                 }
1645             }
1646         }
1647         NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1648 
1649         if (ancestor != null) {
1650             return ancestor.lookupNamespacePrefix(namespaceURI, el);
</pre>
<hr />
<pre>
1670      * exists in the other map and is equal, although not necessarily at the
1671      * same index.The &lt;code&gt;childNodes&lt;/code&gt; &lt;code&gt;NodeLists&lt;/code&gt; are
1672      * equal. This is: they are both &lt;code&gt;null&lt;/code&gt;, or they have the
1673      * same length and contain equal nodes at the same index. This is true
1674      * for &lt;code&gt;Attr&lt;/code&gt; nodes as for any other type of node. Note that
1675      * normalization can affect equality; to avoid this, nodes should be
1676      * normalized before being compared.
1677      * &lt;br&gt;For two &lt;code&gt;DocumentType&lt;/code&gt; nodes to be equal, the following
1678      * conditions must also be satisfied: The following string attributes
1679      * are equal: &lt;code&gt;publicId&lt;/code&gt;, &lt;code&gt;systemId&lt;/code&gt;,
1680      * &lt;code&gt;internalSubset&lt;/code&gt;.The &lt;code&gt;entities&lt;/code&gt;
1681      * &lt;code&gt;NamedNodeMaps&lt;/code&gt; are equal.The &lt;code&gt;notations&lt;/code&gt;
1682      * &lt;code&gt;NamedNodeMaps&lt;/code&gt; are equal.
1683      * &lt;br&gt;On the other hand, the following do not affect equality: the
1684      * &lt;code&gt;ownerDocument&lt;/code&gt; attribute, the &lt;code&gt;specified&lt;/code&gt;
1685      * attribute for &lt;code&gt;Attr&lt;/code&gt; nodes, the
1686      * &lt;code&gt;isWhitespaceInElementContent&lt;/code&gt; attribute for
1687      * &lt;code&gt;Text&lt;/code&gt; nodes, as well as any user data or event listeners
1688      * registered on the nodes.
1689      * @param arg The node to compare equality with.
<span class="line-removed">1690      * @param deep If &lt;code&gt;true&lt;/code&gt;, recursively compare the subtrees; if</span>
<span class="line-removed">1691      *   &lt;code&gt;false&lt;/code&gt;, compare only the nodes themselves (and its</span>
<span class="line-removed">1692      *   attributes, if it is an &lt;code&gt;Element&lt;/code&gt;).</span>
1693      * @return If the nodes, and possibly subtrees are equal,
1694      *   &lt;code&gt;true&lt;/code&gt; otherwise &lt;code&gt;false&lt;/code&gt;.
1695      * @since DOM Level 3
1696      */
1697     public boolean isEqualNode(Node arg) {
1698         if (arg == this) {
1699             return true;
1700         }
1701         if (arg.getNodeType() != getNodeType()) {
1702             return false;
1703         }
1704         // in theory nodeName can&#39;t be null but better be careful
1705         // who knows what other implementations may be doing?...
1706         if (getNodeName() == null) {
1707             if (arg.getNodeName() != null) {
1708                 return false;
1709             }
1710         }
1711         else if (!getNodeName().equals(arg.getNodeName())) {
1712             return false;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4  /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 import java.io.IOException;
  24 import java.io.ObjectOutputStream;
  25 import java.io.Serializable;
  26 import java.util.Map;
  27 import org.w3c.dom.DOMException;
  28 import org.w3c.dom.Document;
  29 import org.w3c.dom.DocumentType;
<span class="line-added">  30 import org.w3c.dom.Element;</span>
  31 import org.w3c.dom.NamedNodeMap;
  32 import org.w3c.dom.Node;
  33 import org.w3c.dom.NodeList;
  34 import org.w3c.dom.UserDataHandler;
  35 import org.w3c.dom.events.Event;
  36 import org.w3c.dom.events.EventListener;
  37 import org.w3c.dom.events.EventTarget;
  38 
  39 /**
  40  * NodeImpl provides the basic structure of a DOM tree. It is never used
  41  * directly, but instead is subclassed to add type and data
  42  * information, and additional methods, appropriate to each node of
  43  * the tree. Only its subclasses should be instantiated -- and those,
  44  * with the exception of Document itself, only through a specific
  45  * Document&#39;s factory methods.
  46  * &lt;P&gt;
  47  * The Node interface provides shared behaviors such as siblings and
  48  * children, both for consistancy and so that the most common tree
  49  * operations may be performed without constantly having to downcast
  50  * to specific node types. When there is no obvious mapping for one of
</pre>
<hr />
<pre>
  62  * in that document. (Note that this is much tighter than &quot;must be
  63  * same implementation&quot;) Nodes are all aware of their ownerDocument,
  64  * and attempts to mismatch will throw WRONG_DOCUMENT_ERR.
  65  * &lt;P&gt;
  66  * However, to save memory not all nodes always have a direct reference
  67  * to their ownerDocument. When a node is owned by another node it relies
  68  * on its owner to store its ownerDocument. Parent nodes always store it
  69  * though, so there is never more than one level of indirection.
  70  * And when a node doesn&#39;t have an owner, ownerNode refers to its
  71  * ownerDocument.
  72  * &lt;p&gt;
  73  * This class doesn&#39;t directly support mutation events, however, it still
  74  * implements the EventTarget interface and forward all related calls to the
  75  * document so that the document class do so.
  76  *
  77  * @xerces.internal
  78  *
  79  * @author Arnaud  Le Hors, IBM
  80  * @author Joe Kesselman, IBM
  81  * @since  PR-DOM-Level-1-19980818.
<span class="line-added">  82  * @LastModified: Apr 2019</span>
  83  */
  84 public abstract class NodeImpl
  85     implements Node, NodeList, EventTarget, Cloneable, Serializable{
  86 
  87     //
  88     // Constants
  89     //
  90 
  91 
  92     // TreePosition Constants.
  93     // Taken from DOM L3 Node interface.
  94     /**
  95      * The node precedes the reference node.
  96      */
  97     public static final short TREE_POSITION_PRECEDING   = 0x01;
  98     /**
  99      * The node follows the reference node.
 100      */
 101     public static final short TREE_POSITION_FOLLOWING   = 0x02;
 102     /**
</pre>
<hr />
<pre>
 107      * The node is a descendant of the reference node.
 108      */
 109     public static final short TREE_POSITION_DESCENDANT  = 0x08;
 110     /**
 111      * The two nodes have an equivalent position. This is the case of two
 112      * attributes that have the same &lt;code&gt;ownerElement&lt;/code&gt;, and two
 113      * nodes that are the same.
 114      */
 115     public static final short TREE_POSITION_EQUIVALENT  = 0x10;
 116     /**
 117      * The two nodes are the same. Two nodes that are the same have an
 118      * equivalent position, though the reverse may not be true.
 119      */
 120     public static final short TREE_POSITION_SAME_NODE   = 0x20;
 121     /**
 122      * The two nodes are disconnected, they do not have any common ancestor.
 123      * This is the case of two nodes that are not in the same document.
 124      */
 125     public static final short TREE_POSITION_DISCONNECTED = 0x00;
 126 









 127     /** Serialization version. */
 128     static final long serialVersionUID = -6316591992167219696L;
 129 
 130     // public
 131 
 132     /** Element definition node type. */
 133     public static final short ELEMENT_DEFINITION_NODE = 21;
 134 
 135     //
 136     // Data
 137     //
 138 
 139     // links
 140 
 141     protected NodeImpl ownerNode; // typically the parent but not always!
 142 
 143     // data
 144 
 145     protected short flags;
 146 
</pre>
<hr />
<pre>
 300     }
 301 
 302     /**
 303      * same as above but returns internal type and this one is not overridden
 304      * by CoreDocumentImpl to return null
 305      */
 306     CoreDocumentImpl ownerDocument() {
 307         // if we have an owner simply forward the request
 308         // otherwise ownerNode is our ownerDocument
 309         if (isOwned()) {
 310             return ownerNode.ownerDocument();
 311         } else {
 312             return (CoreDocumentImpl) ownerNode;
 313         }
 314     }
 315 
 316     /**
 317      * NON-DOM
 318      * set the ownerDocument of this node
 319      */
<span class="line-modified"> 320     protected void setOwnerDocument(CoreDocumentImpl doc) {</span>
 321         if (needsSyncData()) {
 322             synchronizeData();
 323         }
 324         // if we have an owner we rely on it to have it right
 325         // otherwise ownerNode is our ownerDocument
 326         if (!isOwned()) {
 327             ownerNode = doc;
 328         }
 329     }
 330 
 331     /**
 332      * Returns the node number
 333      */
 334     protected int getNodeNumber() {
 335         int nodeNumber;
 336         CoreDocumentImpl cd = (CoreDocumentImpl)(this.getOwnerDocument());
 337         nodeNumber = cd.getNodeNumber(this);
 338         return nodeNumber;
 339     }
 340 
</pre>
<hr />
<pre>
 535     /**
 536      * NodeList method: Count the immediate children of this node
 537      * &lt;P&gt;
 538      * By default we do not have any children, ParentNode overrides this.
 539      * @see ParentNode
 540      *
 541      * @return int
 542      */
 543     public int getLength() {
 544         return 0;
 545     }
 546 
 547     /**
 548      * NodeList method: Return the Nth immediate child of this node, or
 549      * null if the index is out of bounds.
 550      * &lt;P&gt;
 551      * By default we do not have any children, ParentNode overrides this.
 552      * @see ParentNode
 553      *
 554      * @return org.w3c.dom.Node
<span class="line-modified"> 555      * @param index int</span>
 556      */
 557     public Node item(int index) {
 558         return null;
 559     }
 560 
 561     //
 562     // DOM2: methods, getters, setters
 563     //
 564 
 565     /**
 566      * Puts all &lt;code&gt;Text&lt;/code&gt; nodes in the full depth of the sub-tree
 567      * underneath this &lt;code&gt;Node&lt;/code&gt;, including attribute nodes, into a
 568      * &quot;normal&quot; form where only markup (e.g., tags, comments, processing
 569      * instructions, CDATA sections, and entity references) separates
 570      * &lt;code&gt;Text&lt;/code&gt; nodes, i.e., there are no adjacent &lt;code&gt;Text&lt;/code&gt;
 571      * nodes.  This can be used to ensure that the DOM view of a document is
 572      * the same as if it were saved and re-loaded, and is useful when
 573      * operations (such as XPointer lookups) that depend on a particular
 574      * document tree structure are to be used.In cases where the document
 575      * contains &lt;code&gt;CDATASections&lt;/code&gt;, the normalize operation alone may
</pre>
<hr />
<pre>
 952         // REVISIT:  shouldn&#39;t get here.   Should probably throw an
 953         // exception
 954         return 0;
 955 
 956     }
 957     /**
 958      * Compares a node with this node with regard to their position in the
 959      * document.
 960      * @param other The node to compare against this node.
 961      * @return Returns how the given node is positioned relatively to this
 962      *   node.
 963      * @since DOM Level 3
 964      */
 965     public short compareDocumentPosition(Node other) throws DOMException {
 966 
 967         // If the nodes are the same, no flags should be set
 968         if (this==other)
 969           return 0;
 970 
 971         // check if other is from a different implementation
<span class="line-modified"> 972         if (other != null &amp;&amp; !(other instanceof NodeImpl)) {</span>


 973             // other comes from a different implementation
 974             String msg = DOMMessageFormatter.formatMessage(
 975                DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_SUPPORTED_ERR&quot;, null);
 976             throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
 977         }
 978 
 979         Document thisOwnerDoc, otherOwnerDoc;
 980         // get the respective Document owners.
 981         if (this.getNodeType() == Node.DOCUMENT_NODE)
 982           thisOwnerDoc = (Document)this;
 983         else
 984           thisOwnerDoc = this.getOwnerDocument();
 985         if (other.getNodeType() == Node.DOCUMENT_NODE)
 986           otherOwnerDoc = (Document)other;
 987         else
 988           otherOwnerDoc = other.getOwnerDocument();
 989 
 990         // If from different documents, we know they are disconnected.
 991         // and have an implementation dependent order
 992         if (thisOwnerDoc != otherOwnerDoc &amp;&amp;
</pre>
<hr />
<pre>
1015 
1016         Node node;
1017         Node thisAncestor = this;
1018         Node otherAncestor = other;
1019 
1020         int thisDepth=0;
1021         int otherDepth=0;
1022         for (node=this; node != null; node = node.getParentNode()) {
1023             thisDepth +=1;
1024             if (node == other)
1025               // The other node is an ancestor of this one.
1026               return (DOCUMENT_POSITION_CONTAINS |
1027                       DOCUMENT_POSITION_PRECEDING);
1028             thisAncestor = node;
1029         }
1030 
1031         for (node=other; node!=null; node=node.getParentNode()) {
1032             otherDepth +=1;
1033             if (node == this)
1034               // The other node is a descendent of the reference node.
<span class="line-modified">1035               return (DOCUMENT_POSITION_CONTAINED_BY |</span>
1036                       DOCUMENT_POSITION_FOLLOWING);
1037             otherAncestor = node;
1038         }
1039 
1040 
1041 
1042         int thisAncestorType = thisAncestor.getNodeType();
1043         int otherAncestorType = otherAncestor.getNodeType();
1044         Node thisNode = this;
1045         Node otherNode = other;
1046 
1047         // Special casing for ENTITY, NOTATION, DOCTYPE and ATTRIBUTES
1048         // LM:  should rewrite this.
1049         switch (thisAncestorType) {
1050           case Node.NOTATION_NODE:
1051           case Node.ENTITY_NODE: {
1052             DocumentType container = thisOwnerDoc.getDoctype();
1053             if (container == otherAncestor) return
1054                    (DOCUMENT_POSITION_CONTAINS | DOCUMENT_POSITION_PRECEDING);
1055             switch (otherAncestorType) {
</pre>
<hr />
<pre>
1105             }
1106 
1107             // Now, find the ancestor of the element
1108             thisDepth=0;
1109             for (node=thisNode; node != null; node=node.getParentNode()) {
1110                 thisDepth +=1;
1111                 if (node == otherNode)
1112                   {
1113                   // The other node is an ancestor of the owning element
1114                   return (DOCUMENT_POSITION_CONTAINS |
1115                           DOCUMENT_POSITION_PRECEDING);
1116                   }
1117                 thisAncestor = node;
1118             }
1119           }
1120         }
1121         switch (otherAncestorType) {
1122           case Node.NOTATION_NODE:
1123           case Node.ENTITY_NODE: {
1124           DocumentType container = thisOwnerDoc.getDoctype();
<span class="line-modified">1125             if (container == this) return (DOCUMENT_POSITION_CONTAINED_BY |</span>
1126                                           DOCUMENT_POSITION_FOLLOWING);
1127             otherNode = otherAncestor = thisOwnerDoc;
1128             break;
1129           }
1130           case Node.DOCUMENT_TYPE_NODE: {
1131             if (thisNode == otherOwnerDoc)
1132               return (DOCUMENT_POSITION_FOLLOWING |
<span class="line-modified">1133                       DOCUMENT_POSITION_CONTAINED_BY);</span>
1134             else if (otherOwnerDoc!=null &amp;&amp; thisOwnerDoc==otherOwnerDoc)
1135               return (DOCUMENT_POSITION_PRECEDING);
1136             break;
1137           }
1138           case Node.ATTRIBUTE_NODE: {
1139             otherDepth=0;
1140             otherNode = ((AttrImpl)otherAncestor).getOwnerElement();
1141             for (node=otherNode; node != null; node=node.getParentNode()) {
1142                 otherDepth +=1;
1143                 if (node == thisNode)
1144                   // The other node is a descendent of the reference
1145                   // node&#39;s element
1146                   return DOCUMENT_POSITION_FOLLOWING |
<span class="line-modified">1147                          DOCUMENT_POSITION_CONTAINED_BY;</span>
1148                 otherAncestor = node;
1149             }
1150 
1151           }
1152         }
1153 
1154         // thisAncestor and otherAncestor must be the same at this point,
1155         // otherwise, the original nodes are disconnected
1156         if (thisAncestor != otherAncestor) {
1157           int thisAncestorNum, otherAncestorNum;
1158           thisAncestorNum = ((NodeImpl)thisAncestor).getNodeNumber();
1159           otherAncestorNum = ((NodeImpl)otherAncestor).getNodeNumber();
1160 
1161           if (thisAncestorNum &gt; otherAncestorNum)
1162             return DOCUMENT_POSITION_DISCONNECTED |
1163                    DOCUMENT_POSITION_FOLLOWING |
1164                    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
1165           else
1166             return DOCUMENT_POSITION_DISCONNECTED |
1167                    DOCUMENT_POSITION_PRECEDING |
</pre>
<hr />
<pre>
1276      * &lt;code&gt;nodeValue&lt;/code&gt;&lt;/td&gt;
1277      * &lt;/tr&gt;
1278      * &lt;tr&gt;
1279      * &lt;td valign=&#39;top&#39; rowspan=&#39;1&#39; colspan=&#39;1&#39;&gt;DOCUMENT_NODE, DOCUMENT_TYPE_NODE, NOTATION_NODE&lt;/td&gt;
1280      * &lt;td valign=&#39;top&#39; rowspan=&#39;1&#39; colspan=&#39;1&#39;&gt;
1281      * null&lt;/td&gt;
1282      * &lt;/tr&gt;
1283      * &lt;/table&gt;
1284      * @exception DOMException
1285      *   NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
1286      * @exception DOMException
1287      *   DOMSTRING_SIZE_ERR: Raised when it would return more characters than
1288      *   fit in a &lt;code&gt;DOMString&lt;/code&gt; variable on the implementation
1289      *   platform.
1290      * @since DOM Level 3
1291      */
1292     public String getTextContent() throws DOMException {
1293         return getNodeValue();  // overriden in some subclasses
1294     }
1295 
<span class="line-modified">1296     // internal method taking a StringBuilder in parameter</span>
<span class="line-modified">1297     void getTextContent(StringBuilder buf) throws DOMException {</span>
1298         String content = getNodeValue();
1299         if (content != null) {
1300             buf.append(content);
1301         }
1302     }
1303 
1304     /**
1305      * This attribute returns the text content of this node and its
1306      * descendants. When it is defined to be null, setting it has no effect.
1307      * When set, any possible children this node may have are removed and
1308      * replaced by a single &lt;code&gt;Text&lt;/code&gt; node containing the string
1309      * this attribute is set to. On getting, no serialization is performed,
1310      * the returned string does not contain any markup. No whitespace
1311      * normalization is performed, the returned string does not contain the
1312      * element content whitespaces . Similarly, on setting, no parsing is
1313      * performed either, the input string is taken as pure textual content.
1314      * &lt;br&gt;The string returned is made of the text content of this node
1315      * depending on its type, as defined below:
1316      * &lt;table border=&#39;1&#39;&gt;
1317      * &lt;tr&gt;
</pre>
<hr />
<pre>
1399             }
1400             if (this.hasAttributes()) {
1401                 ElementImpl elem = (ElementImpl)this;
1402                 NodeImpl attr = (NodeImpl)elem.getAttributeNodeNS(&quot;http://www.w3.org/2000/xmlns/&quot;, &quot;xmlns&quot;);
1403                 if (attr != null) {
1404                     String value = attr.getNodeValue();
1405                     if (namespaceURI == null) {
1406                         return (namespace == value);
1407                     }
1408                     return namespaceURI.equals(value);
1409                 }
1410             }
1411 
1412             NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1413             if (ancestor != null) {
1414                 return ancestor.isDefaultNamespace(namespaceURI);
1415             }
1416             return false;
1417         }
1418         case Node.DOCUMENT_NODE:{
<span class="line-modified">1419                 Element docElement = ((Document)this).getDocumentElement();</span>
<span class="line-added">1420                 if (docElement != null) {</span>
<span class="line-added">1421                     return docElement.isDefaultNamespace(namespaceURI);</span>
<span class="line-added">1422                 }</span>
<span class="line-added">1423                 return false;</span>
1424             }
1425 
1426         case Node.ENTITY_NODE :
1427         case Node.NOTATION_NODE:
1428         case Node.DOCUMENT_FRAGMENT_NODE:
1429         case Node.DOCUMENT_TYPE_NODE:
1430             // type is unknown
1431             return false;
1432         case Node.ATTRIBUTE_NODE:{
1433                 if (this.ownerNode.getNodeType() == Node.ELEMENT_NODE) {
1434                     return ownerNode.isDefaultNamespace(namespaceURI);
1435 
1436                 }
1437                 return false;
1438             }
1439         default:{
1440                 NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1441                 if (ancestor != null) {
1442                     return ancestor.isDefaultNamespace(namespaceURI);
1443                 }
</pre>
<hr />
<pre>
1453     /**
1454      *
1455      * DOM Level 3 - Experimental:
1456      * Look up the prefix associated to the given namespace URI, starting from this node.
1457      *
1458      * @param namespaceURI
1459      * @return the prefix for the namespace
1460      */
1461     public String lookupPrefix(String namespaceURI){
1462 
1463         // REVISIT: When Namespaces 1.1 comes out this may not be true
1464         // Prefix can&#39;t be bound to null namespace
1465         if (namespaceURI == null) {
1466             return null;
1467         }
1468 
1469         short type = this.getNodeType();
1470 
1471         switch (type) {
1472         case Node.ELEMENT_NODE: {
<span class="line-modified">1473                 this.getNamespaceURI(); // to flip out children</span>

1474                 return lookupNamespacePrefix(namespaceURI, (ElementImpl)this);
1475             }
1476         case Node.DOCUMENT_NODE:{
<span class="line-modified">1477                 Element docElement = ((Document)this).getDocumentElement();</span>
<span class="line-added">1478                 if (docElement != null) {</span>
<span class="line-added">1479                     return docElement.lookupPrefix(namespaceURI);</span>
<span class="line-added">1480                 }</span>
<span class="line-added">1481                 return null;</span>
1482             }
1483 
1484         case Node.ENTITY_NODE :
1485         case Node.NOTATION_NODE:
1486         case Node.DOCUMENT_FRAGMENT_NODE:
1487         case Node.DOCUMENT_TYPE_NODE:
1488             // type is unknown
1489             return null;
1490         case Node.ATTRIBUTE_NODE:{
1491                 if (this.ownerNode.getNodeType() == Node.ELEMENT_NODE) {
1492                     return ownerNode.lookupPrefix(namespaceURI);
1493 
1494                 }
1495                 return null;
1496             }
1497         default:{
1498                 NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1499                 if (ancestor != null) {
1500                     return ancestor.lookupPrefix(namespaceURI);
1501                 }
1502                 return null;
1503             }
1504 
1505         }
1506     }
1507     /**
1508      * DOM Level 3 - Experimental:
1509      * Look up the namespace URI associated to the given prefix, starting from this node.
1510      * Use lookupNamespaceURI(null) to lookup the default namespace
1511      *
<span class="line-modified">1512      * @param specifiedPrefix</span>
<span class="line-modified">1513      * @return the URI for the namespace</span>
1514      * @since DOM Level 3
1515      */
1516     public String lookupNamespaceURI(String specifiedPrefix) {
1517         short type = this.getNodeType();
1518         switch (type) {
1519         case Node.ELEMENT_NODE : {
1520 
1521                 String namespace = this.getNamespaceURI();
1522                 String prefix = this.getPrefix();
1523                 if (namespace !=null) {
1524                     // REVISIT: is it possible that prefix is empty string?
1525                     if (specifiedPrefix== null &amp;&amp; prefix==specifiedPrefix) {
1526                         // looking for default namespace
1527                         return namespace;
1528                     } else if (prefix != null &amp;&amp; prefix.equals(specifiedPrefix)) {
1529                         // non default namespace
1530                         return namespace;
1531                     }
1532                 }
1533                 if (this.hasAttributes()) {
1534                     NamedNodeMap map = this.getAttributes();
1535                     int length = map.getLength();
1536                     for (int i=0;i&lt;length;i++) {
1537                         Node attr = map.item(i);


1538                         namespace = attr.getNamespaceURI();
1539                         if (namespace !=null &amp;&amp; namespace.equals(&quot;http://www.w3.org/2000/xmlns/&quot;)) {
<span class="line-added">1540                             String attrPrefix = attr.getPrefix();</span>
<span class="line-added">1541                             String value = attr.getNodeValue();</span>
1542                             // at this point we are dealing with DOM Level 2 nodes only
1543                             if (specifiedPrefix == null &amp;&amp;
1544                                 attr.getNodeName().equals(&quot;xmlns&quot;)) {
1545                                 // default namespace
<span class="line-modified">1546                                 return value.length() &gt; 0 ? value : null;</span>
1547                             } else if (attrPrefix !=null &amp;&amp;
1548                                        attrPrefix.equals(&quot;xmlns&quot;) &amp;&amp;
1549                                        attr.getLocalName().equals(specifiedPrefix)) {
1550                                 // non default namespace
<span class="line-modified">1551                                 return value.length() &gt; 0 ? value : null;</span>
1552                             }
1553                         }
1554                     }
1555                 }
1556                 NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1557                 if (ancestor != null) {
1558                     return ancestor.lookupNamespaceURI(specifiedPrefix);
1559                 }
1560 
1561                 return null;
1562 
1563 
1564             }
1565         case Node.DOCUMENT_NODE : {
<span class="line-modified">1566                 Element docElement = ((Document)this).getDocumentElement();</span>
<span class="line-added">1567                 if (docElement != null) {</span>
<span class="line-added">1568                     return docElement.lookupNamespaceURI(specifiedPrefix);</span>
<span class="line-added">1569                 }</span>
<span class="line-added">1570                 return null;</span>
1571             }
1572         case Node.ENTITY_NODE :
1573         case Node.NOTATION_NODE:
1574         case Node.DOCUMENT_FRAGMENT_NODE:
1575         case Node.DOCUMENT_TYPE_NODE:
1576             // type is unknown
1577             return null;
1578         case Node.ATTRIBUTE_NODE:{
1579                 if (this.ownerNode.getNodeType() == Node.ELEMENT_NODE) {
1580                     return ownerNode.lookupNamespaceURI(specifiedPrefix);
1581 
1582                 }
1583                 return null;
1584             }
1585         default:{
1586                 NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1587                 if (ancestor != null) {
1588                     return ancestor.lookupNamespaceURI(specifiedPrefix);
1589                 }
1590                 return null;
1591             }
1592 
1593         }
1594     }
1595 
<span class="line-modified">1596     Node getElementAncestor(Node currentNode) {</span>

1597         Node parent = currentNode.getParentNode();
<span class="line-modified">1598         while (parent != null) {</span>
1599             short type = parent.getNodeType();
1600             if (type == Node.ELEMENT_NODE) {
1601                 return parent;
1602             }
<span class="line-modified">1603             parent = parent.getParentNode();</span>
1604         }
1605         return null;
1606     }
1607 
1608     String lookupNamespacePrefix(String namespaceURI, ElementImpl el){
1609         String namespace = this.getNamespaceURI();
1610         // REVISIT: if no prefix is available is it null or empty string, or
1611         //          could be both?
1612         String prefix = this.getPrefix();
1613 
1614         if (namespace!=null &amp;&amp; namespace.equals(namespaceURI)) {
1615             if (prefix != null) {
1616                 String foundNamespace =  el.lookupNamespaceURI(prefix);
1617                 if (foundNamespace !=null &amp;&amp; foundNamespace.equals(namespaceURI)) {
1618                     return prefix;
1619                 }
1620 
1621             }
1622         }
1623         if (this.hasAttributes()) {
1624             NamedNodeMap map = this.getAttributes();
1625             int length = map.getLength();
1626             for (int i=0;i&lt;length;i++) {
1627                 Node attr = map.item(i);


1628                 namespace = attr.getNamespaceURI();
1629                 if (namespace !=null &amp;&amp; namespace.equals(&quot;http://www.w3.org/2000/xmlns/&quot;)) {
<span class="line-added">1630                     String attrPrefix = attr.getPrefix();</span>
<span class="line-added">1631                     String value = attr.getNodeValue();</span>
1632                     // DOM Level 2 nodes
1633                     if (((attr.getNodeName().equals(&quot;xmlns&quot;)) ||
1634                          (attrPrefix !=null &amp;&amp; attrPrefix.equals(&quot;xmlns&quot;)) &amp;&amp;
1635                          value.equals(namespaceURI))) {
1636 
1637                         String localname= attr.getLocalName();
1638                         String foundNamespace = el.lookupNamespaceURI(localname);
1639                         if (foundNamespace !=null &amp;&amp; foundNamespace.equals(namespaceURI)) {
1640                             return localname;
1641                         }
1642                     }
1643 
1644 
1645                 }
1646             }
1647         }
1648         NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
1649 
1650         if (ancestor != null) {
1651             return ancestor.lookupNamespacePrefix(namespaceURI, el);
</pre>
<hr />
<pre>
1671      * exists in the other map and is equal, although not necessarily at the
1672      * same index.The &lt;code&gt;childNodes&lt;/code&gt; &lt;code&gt;NodeLists&lt;/code&gt; are
1673      * equal. This is: they are both &lt;code&gt;null&lt;/code&gt;, or they have the
1674      * same length and contain equal nodes at the same index. This is true
1675      * for &lt;code&gt;Attr&lt;/code&gt; nodes as for any other type of node. Note that
1676      * normalization can affect equality; to avoid this, nodes should be
1677      * normalized before being compared.
1678      * &lt;br&gt;For two &lt;code&gt;DocumentType&lt;/code&gt; nodes to be equal, the following
1679      * conditions must also be satisfied: The following string attributes
1680      * are equal: &lt;code&gt;publicId&lt;/code&gt;, &lt;code&gt;systemId&lt;/code&gt;,
1681      * &lt;code&gt;internalSubset&lt;/code&gt;.The &lt;code&gt;entities&lt;/code&gt;
1682      * &lt;code&gt;NamedNodeMaps&lt;/code&gt; are equal.The &lt;code&gt;notations&lt;/code&gt;
1683      * &lt;code&gt;NamedNodeMaps&lt;/code&gt; are equal.
1684      * &lt;br&gt;On the other hand, the following do not affect equality: the
1685      * &lt;code&gt;ownerDocument&lt;/code&gt; attribute, the &lt;code&gt;specified&lt;/code&gt;
1686      * attribute for &lt;code&gt;Attr&lt;/code&gt; nodes, the
1687      * &lt;code&gt;isWhitespaceInElementContent&lt;/code&gt; attribute for
1688      * &lt;code&gt;Text&lt;/code&gt; nodes, as well as any user data or event listeners
1689      * registered on the nodes.
1690      * @param arg The node to compare equality with.



1691      * @return If the nodes, and possibly subtrees are equal,
1692      *   &lt;code&gt;true&lt;/code&gt; otherwise &lt;code&gt;false&lt;/code&gt;.
1693      * @since DOM Level 3
1694      */
1695     public boolean isEqualNode(Node arg) {
1696         if (arg == this) {
1697             return true;
1698         }
1699         if (arg.getNodeType() != getNodeType()) {
1700             return false;
1701         }
1702         // in theory nodeName can&#39;t be null but better be careful
1703         // who knows what other implementations may be doing?...
1704         if (getNodeName() == null) {
1705             if (arg.getNodeName() != null) {
1706                 return false;
1707             }
1708         }
1709         else if (!getNodeName().equals(arg.getNodeName())) {
1710             return false;
</pre>
</td>
</tr>
</table>
<center><a href="ElementNSImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="PSVIDOMImplementationImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ParentNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PSVIDOMImplementationImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="TextImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ParentNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
</pre>
<hr />
<pre>
  51  * point we used to have ParentNode inheriting from NodeImpl and another class
  52  * called ChildAndParentNode that inherited from ChildNode. But due to the lack
  53  * of multiple inheritance a lot of code had to be duplicated which led to a
  54  * maintenance nightmare. At the same time only a few nodes (Document,
  55  * DocumentFragment, Entity, and Attribute) cannot be a child so the gain in
  56  * memory wasn&#39;t really worth it. The only type for which this would be the
  57  * case is Attribute, but we deal with there in another special way, so this is
  58  * not applicable.
  59  * &lt;p&gt;
  60  * This class doesn&#39;t directly support mutation events, however, it notifies
  61  * the document when mutations are performed so that the document class do so.
  62  *
  63  * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: Some of the code here is partially duplicated in
  64  * AttrImpl, be careful to keep these two classes in sync!
  65  *
  66  * @xerces.internal
  67  *
  68  * @author Arnaud  Le Hors, IBM
  69  * @author Joe Kesselman, IBM
  70  * @author Andy Clark, IBM

  71  */
  72 public abstract class ParentNode
  73     extends ChildNode {
  74 
  75     /** Serialization version. */
  76     static final long serialVersionUID = 2815829867152120872L;
  77 
  78     /** Owner document. */
  79     protected CoreDocumentImpl ownerDocument;
  80 
  81     /** First child. */
  82     protected ChildNode firstChild = null;
  83 
  84     // transients
  85 
  86     /** NodeList cache */
  87     protected transient NodeListCache fNodeListCache = null;
  88 
  89     //
  90     // Constructors
</pre>
<hr />
<pre>
 157      * Find the Document that this Node belongs to (the document in
 158      * whose context the Node was created). The Node may or may not
 159      * currently be part of that Document&#39;s actual contents.
 160      */
 161     public Document getOwnerDocument() {
 162         return ownerDocument;
 163     }
 164 
 165     /**
 166      * same as above but returns internal type and this one is not overridden
 167      * by CoreDocumentImpl to return null
 168      */
 169     CoreDocumentImpl ownerDocument() {
 170         return ownerDocument;
 171     }
 172 
 173     /**
 174      * NON-DOM
 175      * set the ownerDocument of this node and its children
 176      */
<span class="line-modified"> 177     void setOwnerDocument(CoreDocumentImpl doc) {</span>
 178         if (needsSyncChildren()) {
 179             synchronizeChildren();
 180         }
<span class="line-removed"> 181        for (ChildNode child = firstChild;</span>
<span class="line-removed"> 182              child != null; child = child.nextSibling) {</span>
<span class="line-removed"> 183              child.setOwnerDocument(doc);</span>
<span class="line-removed"> 184         }</span>
<span class="line-removed"> 185         /* setting the owner document of self, after it&#39;s children makes the</span>
<span class="line-removed"> 186            data of children available to the new document. */</span>
 187         super.setOwnerDocument(doc);
 188         ownerDocument = doc;




 189     }
 190 
 191     /**
 192      * Test whether this node has any children. Convenience shorthand
 193      * for (Node.getFirstChild()!=null)
 194      */
 195     public boolean hasChildNodes() {
 196         if (needsSyncChildren()) {
 197             synchronizeChildren();
 198         }
 199         return firstChild != null;
 200     }
 201 
 202     /**
 203      * Obtain a NodeList enumerating all children of this node. If there
 204      * are none, an (initially) empty NodeList is returned.
 205      * &lt;p&gt;
 206      * NodeLists are &quot;live&quot;; as children are added/removed the NodeList
 207      * will immediately reflect those changes. Also, the NodeList refers
 208      * to the actual nodes, so changes to those nodes made via the DOM tree
</pre>
<hr />
<pre>
 351                               DOMException.NO_MODIFICATION_ALLOWED_ERR,
 352                               DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null));
 353             }
 354             if (newChild.getOwnerDocument() != ownerDocument &amp;&amp; newChild != ownerDocument) {
 355                 throw new DOMException(DOMException.WRONG_DOCUMENT_ERR,
 356                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;WRONG_DOCUMENT_ERR&quot;, null));
 357             }
 358             if (!ownerDocument.isKidOK(this, newChild)) {
 359                 throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,
 360                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null));
 361             }
 362             // refChild must be a child of this node (or null)
 363             if (refChild != null &amp;&amp; refChild.getParentNode() != this) {
 364                 throw new DOMException(DOMException.NOT_FOUND_ERR,
 365                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null));
 366             }
 367 
 368             // Prevent cycles in the tree
 369             // newChild cannot be ancestor of this Node,
 370             // and actually cannot be this
<span class="line-modified"> 371             if (ownerDocument.ancestorChecking) {</span>
<span class="line-modified"> 372                 boolean treeSafe = true;</span>
<span class="line-modified"> 373                 for (NodeImpl a = this; treeSafe &amp;&amp; a != null; a = a.parentNode())</span>
<span class="line-modified"> 374                 {</span>
<span class="line-modified"> 375                     treeSafe = newChild != a;</span>
<span class="line-modified"> 376                 }</span>
<span class="line-modified"> 377                 if(!treeSafe) {</span>
<span class="line-modified"> 378                     throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,</span>
<span class="line-removed"> 379                                 DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null));</span>
<span class="line-removed"> 380                 }</span>
 381             }
 382         }
 383 
 384         // notify document
 385         ownerDocument.insertingNode(this, replace);
 386 
 387         // Convert to internal type, to avoid repeated casting
 388         ChildNode newInternal = (ChildNode)newChild;
 389 
 390         Node oldparent = newInternal.parentNode();
 391         if (oldparent != null) {
 392             oldparent.removeChild(newInternal);
 393         }
 394 
 395         // Convert to internal type, to avoid repeated casting
 396         ChildNode refInternal = (ChildNode)refChild;
 397 
 398         // Attach up
 399         newInternal.ownerNode = this;
 400         newInternal.isOwned(true);
</pre>
<hr />
<pre>
 492         throws DOMException {
 493 
 494         CoreDocumentImpl ownerDocument = ownerDocument();
 495         if (ownerDocument.errorChecking) {
 496             if (isReadOnly()) {
 497                 throw new DOMException(
 498                             DOMException.NO_MODIFICATION_ALLOWED_ERR,
 499                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null));
 500             }
 501             if (oldChild != null &amp;&amp; oldChild.getParentNode() != this) {
 502                 throw new DOMException(DOMException.NOT_FOUND_ERR,
 503                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null));
 504             }
 505         }
 506 
 507         ChildNode oldInternal = (ChildNode) oldChild;
 508 
 509         // notify document
 510         ownerDocument.removingNode(this, oldInternal, replace);
 511 



 512         // update cached length if we have any
 513         if (fNodeListCache != null) {
 514             if (fNodeListCache.fLength != -1) {
 515                 fNodeListCache.fLength--;
 516             }
 517             if (fNodeListCache.fChildIndex != -1) {
 518                 // if the removed node is the cached node
 519                 // move the cache to its (soon former) previous sibling
 520                 if (fNodeListCache.fChild == oldInternal) {
 521                     fNodeListCache.fChildIndex--;
<span class="line-modified"> 522                     fNodeListCache.fChild = oldInternal.previousSibling();</span>
 523                 } else {
 524                     // otherwise just invalidate the cache
 525                     fNodeListCache.fChildIndex = -1;
 526                 }
 527             }
 528         }
 529 
 530         // Patch linked list around oldChild
 531         // Note: lastChild == firstChild.previousSibling
 532         if (oldInternal == firstChild) {
 533             // removing first child
 534             oldInternal.isFirstChild(false);
 535             firstChild = oldInternal.nextSibling;
 536             if (firstChild != null) {
 537                 firstChild.isFirstChild(true);
 538                 firstChild.previousSibling = oldInternal.previousSibling;
 539             }
 540         } else {
 541             ChildNode prev = oldInternal.previousSibling;
 542             ChildNode next = oldInternal.nextSibling;
 543             prev.nextSibling = next;
 544             if (next == null) {
 545                 // removing last child
 546                 firstChild.previousSibling = prev;
 547             } else {
 548                 // removing some other child in the middle
 549                 next.previousSibling = prev;
 550             }
 551         }
 552 
<span class="line-removed"> 553         // Save previous sibling for normalization checking.</span>
<span class="line-removed"> 554         ChildNode oldPreviousSibling = oldInternal.previousSibling();</span>
<span class="line-removed"> 555 </span>
 556         // Remove oldInternal&#39;s references to tree
 557         oldInternal.ownerNode       = ownerDocument;
 558         oldInternal.isOwned(false);
 559         oldInternal.nextSibling     = null;
 560         oldInternal.previousSibling = null;
 561 
 562         changed();
 563 
 564         // notify document
 565         ownerDocument.removedNode(this, replace);
 566 
 567         checkNormalizationAfterRemove(oldPreviousSibling);
 568 
 569         return oldInternal;
 570 
 571     } // internalRemoveChild(Node,boolean):Node
 572 
 573     /**
 574      * Make newChild occupy the location that oldChild used to
 575      * have. Note that newChild will first be removed from its previous
</pre>
<hr />
<pre>
 607             internalRemoveChild(oldChild, true);
 608         }
 609 
 610         // notify document
 611         ownerDocument.replacedNode(this);
 612 
 613         return oldChild;
 614     }
 615 
 616     /*
 617      * Get Node text content
 618      * @since DOM Level 3
 619      */
 620     public String getTextContent() throws DOMException {
 621         Node child = getFirstChild();
 622         if (child != null) {
 623             Node next = child.getNextSibling();
 624             if (next == null) {
 625                 return hasTextContent(child) ? ((NodeImpl) child).getTextContent() : &quot;&quot;;
 626             }
<span class="line-modified"> 627             if (fBufferStr == null){</span>
<span class="line-modified"> 628                 fBufferStr = new StringBuffer();</span>
<span class="line-modified"> 629             }</span>
<span class="line-removed"> 630             else {</span>
<span class="line-removed"> 631                 fBufferStr.setLength(0);</span>
<span class="line-removed"> 632             }</span>
<span class="line-removed"> 633             getTextContent(fBufferStr);</span>
<span class="line-removed"> 634             return fBufferStr.toString();</span>
 635         }
 636         return &quot;&quot;;
 637     }
 638 
<span class="line-modified"> 639     // internal method taking a StringBuffer in parameter</span>
<span class="line-modified"> 640     void getTextContent(StringBuffer buf) throws DOMException {</span>
 641         Node child = getFirstChild();
 642         while (child != null) {
 643             if (hasTextContent(child)) {
 644                 ((NodeImpl) child).getTextContent(buf);
 645             }
 646             child = child.getNextSibling();
 647         }
 648     }
 649 
 650     // internal method returning whether to take the given node&#39;s text content
 651     final boolean hasTextContent(Node child) {
 652         return child.getNodeType() != Node.COMMENT_NODE &amp;&amp;
 653             child.getNodeType() != Node.PROCESSING_INSTRUCTION_NODE &amp;&amp;
 654             (child.getNodeType() != Node.TEXT_NODE ||
 655              ((TextImpl) child).isIgnorableWhitespace() == false);
 656     }
 657 
 658     /*
 659      * Set Node text content
 660      * @since DOM Level 3
</pre>
<hr />
<pre>
 667             removeChild(child);
 668         }
 669         // create a Text node to hold the given content
 670         if (textContent != null &amp;&amp; textContent.length() != 0){
 671             appendChild(ownerDocument().createTextNode(textContent));
 672         }
 673     }
 674 
 675     //
 676     // NodeList methods
 677     //
 678 
 679     /**
 680      * Count the immediate children of this node.  Use to implement
 681      * NodeList.getLength().
 682      * @return int
 683      */
 684     private int nodeListGetLength() {
 685 
 686         if (fNodeListCache == null) {



 687             // get rid of trivial cases
 688             if (firstChild == null) {
 689                 return 0;
 690             }
 691             if (firstChild == lastChild()) {
 692                 return 1;
 693             }
 694             // otherwise request a cache object
 695             fNodeListCache = ownerDocument.getNodeListCache(this);
 696         }
 697         if (fNodeListCache.fLength == -1) { // is the cached length invalid ?
 698             int l;
 699             ChildNode n;
 700             // start from the cached node if we have one
 701             if (fNodeListCache.fChildIndex != -1 &amp;&amp;
 702                 fNodeListCache.fChild != null) {
 703                 l = fNodeListCache.fChildIndex;
 704                 n = fNodeListCache.fChild;
 705             } else {
 706                 n = firstChild;
</pre>
<hr />
<pre>
 716         return fNodeListCache.fLength;
 717 
 718     } // nodeListGetLength():int
 719 
 720     /**
 721      * NodeList method: Count the immediate children of this node
 722      * @return int
 723      */
 724     public int getLength() {
 725         return nodeListGetLength();
 726     }
 727 
 728     /**
 729      * Return the Nth immediate child of this node, or null if the index is
 730      * out of bounds.  Use to implement NodeList.item().
 731      * @param index int
 732      */
 733     private Node nodeListItem(int index) {
 734 
 735         if (fNodeListCache == null) {



 736             // get rid of trivial case
 737             if (firstChild == lastChild()) {
 738                 return index == 0 ? firstChild : null;
 739             }
 740             // otherwise request a cache object
 741             fNodeListCache = ownerDocument.getNodeListCache(this);
 742         }
 743         int i = fNodeListCache.fChildIndex;
 744         ChildNode n = fNodeListCache.fChild;
 745         boolean firstAccess = true;
 746         // short way
 747         if (i != -1 &amp;&amp; n != null) {
 748             firstAccess = false;
 749             if (i &lt; index) {
 750                 while (i &lt; index &amp;&amp; n != null) {
 751                     i++;
 752                     n = n.nextSibling;
 753                 }
 754             }
 755             else if (i &gt; index) {
</pre>
<hr />
<pre>
 853         for (kid = firstChild; kid != null; kid = kid.nextSibling) {
 854             kid.normalize();
 855         }
 856         isNormalized(true);
 857     }
 858 
 859     /**
 860      * DOM Level 3 WD- Experimental.
 861      * Override inherited behavior from NodeImpl to support deep equal.
 862      */
 863     public boolean isEqualNode(Node arg) {
 864         if (!super.isEqualNode(arg)) {
 865             return false;
 866         }
 867         // there are many ways to do this test, and there isn&#39;t any way
 868         // better than another. Performance may vary greatly depending on
 869         // the implementations involved. This one should work fine for us.
 870         Node child1 = getFirstChild();
 871         Node child2 = arg.getFirstChild();
 872         while (child1 != null &amp;&amp; child2 != null) {
<span class="line-modified"> 873             if (!((NodeImpl) child1).isEqualNode(child2)) {</span>
 874                 return false;
 875             }
 876             child1 = child1.getNextSibling();
 877             child2 = child2.getNextSibling();
 878         }
 879         if (child1 != child2) {
 880             return false;
 881         }
 882         return true;
 883     }
 884 
 885     //
 886     // Public methods
 887     //
 888 
 889     /**
 890      * Override default behavior so that if deep is true, children are also
 891      * toggled.
 892      * @see Node
 893      * &lt;P&gt;
</pre>
<hr />
<pre>
 980         // See if removal caused this node to be unnormalized.
 981         // If the adjacent siblings of the removed child were both text nodes,
 982         // flag this node as unnormalized.
 983         if (previousSibling != null &amp;&amp;
 984             previousSibling.getNodeType() == Node.TEXT_NODE) {
 985 
 986             ChildNode next = previousSibling.nextSibling;
 987             if (next != null &amp;&amp; next.getNodeType() == Node.TEXT_NODE) {
 988                 isNormalized(false);
 989             }
 990         }
 991     } // checkNormalizationAfterRemove(Node)
 992 
 993     //
 994     // Serialization methods
 995     //
 996 
 997     /** Serialize object. */
 998     private void writeObject(ObjectOutputStream out) throws IOException {
 999 
<span class="line-modified">1000         // synchronize chilren</span>
1001         if (needsSyncChildren()) {
1002             synchronizeChildren();
1003         }
1004         // write object
1005         out.defaultWriteObject();
1006 
1007     } // writeObject(ObjectOutputStream)
1008 
1009     /** Deserialize object. */
1010     private void readObject(ObjectInputStream ois)
1011         throws ClassNotFoundException, IOException {
1012 
1013         // perform default deseralization
1014         ois.defaultReadObject();
1015 
1016         // hardset synchildren - so we don&#39;t try to sync - it does not make any
1017         // sense to try to synchildren when we just deserialize object.
1018         needsSyncChildren(false);
1019 
1020     } // readObject(ObjectInputStream)
1021 
1022     /*
1023      * a class to store some user data along with its handler
1024      */
<span class="line-modified">1025     protected class UserDataRecord implements Serializable {</span>
1026         /** Serialization version. */
1027         private static final long serialVersionUID = 3258126977134310455L;
1028 
1029         Object fData;
1030         UserDataHandler fHandler;
1031         UserDataRecord(Object data, UserDataHandler handler) {
1032             fData = data;
1033             fHandler = handler;
1034         }
1035     }
1036 } // class ParentNode
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
</pre>
<hr />
<pre>
  51  * point we used to have ParentNode inheriting from NodeImpl and another class
  52  * called ChildAndParentNode that inherited from ChildNode. But due to the lack
  53  * of multiple inheritance a lot of code had to be duplicated which led to a
  54  * maintenance nightmare. At the same time only a few nodes (Document,
  55  * DocumentFragment, Entity, and Attribute) cannot be a child so the gain in
  56  * memory wasn&#39;t really worth it. The only type for which this would be the
  57  * case is Attribute, but we deal with there in another special way, so this is
  58  * not applicable.
  59  * &lt;p&gt;
  60  * This class doesn&#39;t directly support mutation events, however, it notifies
  61  * the document when mutations are performed so that the document class do so.
  62  *
  63  * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: Some of the code here is partially duplicated in
  64  * AttrImpl, be careful to keep these two classes in sync!
  65  *
  66  * @xerces.internal
  67  *
  68  * @author Arnaud  Le Hors, IBM
  69  * @author Joe Kesselman, IBM
  70  * @author Andy Clark, IBM
<span class="line-added">  71  * @LastModified: Apr 2019</span>
  72  */
  73 public abstract class ParentNode
  74     extends ChildNode {
  75 
  76     /** Serialization version. */
  77     static final long serialVersionUID = 2815829867152120872L;
  78 
  79     /** Owner document. */
  80     protected CoreDocumentImpl ownerDocument;
  81 
  82     /** First child. */
  83     protected ChildNode firstChild = null;
  84 
  85     // transients
  86 
  87     /** NodeList cache */
  88     protected transient NodeListCache fNodeListCache = null;
  89 
  90     //
  91     // Constructors
</pre>
<hr />
<pre>
 158      * Find the Document that this Node belongs to (the document in
 159      * whose context the Node was created). The Node may or may not
 160      * currently be part of that Document&#39;s actual contents.
 161      */
 162     public Document getOwnerDocument() {
 163         return ownerDocument;
 164     }
 165 
 166     /**
 167      * same as above but returns internal type and this one is not overridden
 168      * by CoreDocumentImpl to return null
 169      */
 170     CoreDocumentImpl ownerDocument() {
 171         return ownerDocument;
 172     }
 173 
 174     /**
 175      * NON-DOM
 176      * set the ownerDocument of this node and its children
 177      */
<span class="line-modified"> 178     protected void setOwnerDocument(CoreDocumentImpl doc) {</span>
 179         if (needsSyncChildren()) {
 180             synchronizeChildren();
 181         }






 182         super.setOwnerDocument(doc);
 183         ownerDocument = doc;
<span class="line-added"> 184         for (ChildNode child = firstChild;</span>
<span class="line-added"> 185         child != null; child = child.nextSibling) {</span>
<span class="line-added"> 186             child.setOwnerDocument(doc);</span>
<span class="line-added"> 187         }</span>
 188     }
 189 
 190     /**
 191      * Test whether this node has any children. Convenience shorthand
 192      * for (Node.getFirstChild()!=null)
 193      */
 194     public boolean hasChildNodes() {
 195         if (needsSyncChildren()) {
 196             synchronizeChildren();
 197         }
 198         return firstChild != null;
 199     }
 200 
 201     /**
 202      * Obtain a NodeList enumerating all children of this node. If there
 203      * are none, an (initially) empty NodeList is returned.
 204      * &lt;p&gt;
 205      * NodeLists are &quot;live&quot;; as children are added/removed the NodeList
 206      * will immediately reflect those changes. Also, the NodeList refers
 207      * to the actual nodes, so changes to those nodes made via the DOM tree
</pre>
<hr />
<pre>
 350                               DOMException.NO_MODIFICATION_ALLOWED_ERR,
 351                               DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null));
 352             }
 353             if (newChild.getOwnerDocument() != ownerDocument &amp;&amp; newChild != ownerDocument) {
 354                 throw new DOMException(DOMException.WRONG_DOCUMENT_ERR,
 355                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;WRONG_DOCUMENT_ERR&quot;, null));
 356             }
 357             if (!ownerDocument.isKidOK(this, newChild)) {
 358                 throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,
 359                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null));
 360             }
 361             // refChild must be a child of this node (or null)
 362             if (refChild != null &amp;&amp; refChild.getParentNode() != this) {
 363                 throw new DOMException(DOMException.NOT_FOUND_ERR,
 364                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null));
 365             }
 366 
 367             // Prevent cycles in the tree
 368             // newChild cannot be ancestor of this Node,
 369             // and actually cannot be this
<span class="line-modified"> 370             boolean treeSafe = true;</span>
<span class="line-modified"> 371             for (NodeImpl a = this; treeSafe &amp;&amp; a != null; a = a.parentNode())</span>
<span class="line-modified"> 372             {</span>
<span class="line-modified"> 373                 treeSafe = newChild != a;</span>
<span class="line-modified"> 374             }</span>
<span class="line-modified"> 375             if(!treeSafe) {</span>
<span class="line-modified"> 376                 throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,</span>
<span class="line-modified"> 377                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null));</span>


 378             }
 379         }
 380 
 381         // notify document
 382         ownerDocument.insertingNode(this, replace);
 383 
 384         // Convert to internal type, to avoid repeated casting
 385         ChildNode newInternal = (ChildNode)newChild;
 386 
 387         Node oldparent = newInternal.parentNode();
 388         if (oldparent != null) {
 389             oldparent.removeChild(newInternal);
 390         }
 391 
 392         // Convert to internal type, to avoid repeated casting
 393         ChildNode refInternal = (ChildNode)refChild;
 394 
 395         // Attach up
 396         newInternal.ownerNode = this;
 397         newInternal.isOwned(true);
</pre>
<hr />
<pre>
 489         throws DOMException {
 490 
 491         CoreDocumentImpl ownerDocument = ownerDocument();
 492         if (ownerDocument.errorChecking) {
 493             if (isReadOnly()) {
 494                 throw new DOMException(
 495                             DOMException.NO_MODIFICATION_ALLOWED_ERR,
 496                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null));
 497             }
 498             if (oldChild != null &amp;&amp; oldChild.getParentNode() != this) {
 499                 throw new DOMException(DOMException.NOT_FOUND_ERR,
 500                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null));
 501             }
 502         }
 503 
 504         ChildNode oldInternal = (ChildNode) oldChild;
 505 
 506         // notify document
 507         ownerDocument.removingNode(this, oldInternal, replace);
 508 
<span class="line-added"> 509         // Save previous sibling for normalization checking.</span>
<span class="line-added"> 510         final ChildNode oldPreviousSibling = oldInternal.previousSibling();</span>
<span class="line-added"> 511 </span>
 512         // update cached length if we have any
 513         if (fNodeListCache != null) {
 514             if (fNodeListCache.fLength != -1) {
 515                 fNodeListCache.fLength--;
 516             }
 517             if (fNodeListCache.fChildIndex != -1) {
 518                 // if the removed node is the cached node
 519                 // move the cache to its (soon former) previous sibling
 520                 if (fNodeListCache.fChild == oldInternal) {
 521                     fNodeListCache.fChildIndex--;
<span class="line-modified"> 522                     fNodeListCache.fChild = oldPreviousSibling;</span>
 523                 } else {
 524                     // otherwise just invalidate the cache
 525                     fNodeListCache.fChildIndex = -1;
 526                 }
 527             }
 528         }
 529 
 530         // Patch linked list around oldChild
 531         // Note: lastChild == firstChild.previousSibling
 532         if (oldInternal == firstChild) {
 533             // removing first child
 534             oldInternal.isFirstChild(false);
 535             firstChild = oldInternal.nextSibling;
 536             if (firstChild != null) {
 537                 firstChild.isFirstChild(true);
 538                 firstChild.previousSibling = oldInternal.previousSibling;
 539             }
 540         } else {
 541             ChildNode prev = oldInternal.previousSibling;
 542             ChildNode next = oldInternal.nextSibling;
 543             prev.nextSibling = next;
 544             if (next == null) {
 545                 // removing last child
 546                 firstChild.previousSibling = prev;
 547             } else {
 548                 // removing some other child in the middle
 549                 next.previousSibling = prev;
 550             }
 551         }
 552 



 553         // Remove oldInternal&#39;s references to tree
 554         oldInternal.ownerNode       = ownerDocument;
 555         oldInternal.isOwned(false);
 556         oldInternal.nextSibling     = null;
 557         oldInternal.previousSibling = null;
 558 
 559         changed();
 560 
 561         // notify document
 562         ownerDocument.removedNode(this, replace);
 563 
 564         checkNormalizationAfterRemove(oldPreviousSibling);
 565 
 566         return oldInternal;
 567 
 568     } // internalRemoveChild(Node,boolean):Node
 569 
 570     /**
 571      * Make newChild occupy the location that oldChild used to
 572      * have. Note that newChild will first be removed from its previous
</pre>
<hr />
<pre>
 604             internalRemoveChild(oldChild, true);
 605         }
 606 
 607         // notify document
 608         ownerDocument.replacedNode(this);
 609 
 610         return oldChild;
 611     }
 612 
 613     /*
 614      * Get Node text content
 615      * @since DOM Level 3
 616      */
 617     public String getTextContent() throws DOMException {
 618         Node child = getFirstChild();
 619         if (child != null) {
 620             Node next = child.getNextSibling();
 621             if (next == null) {
 622                 return hasTextContent(child) ? ((NodeImpl) child).getTextContent() : &quot;&quot;;
 623             }
<span class="line-modified"> 624             StringBuilder buf = new StringBuilder();</span>
<span class="line-modified"> 625             getTextContent(buf);</span>
<span class="line-modified"> 626             return buf.toString();</span>





 627         }
 628         return &quot;&quot;;
 629     }
 630 
<span class="line-modified"> 631     // internal method taking a StringBuilder in parameter</span>
<span class="line-modified"> 632     void getTextContent(StringBuilder buf) throws DOMException {</span>
 633         Node child = getFirstChild();
 634         while (child != null) {
 635             if (hasTextContent(child)) {
 636                 ((NodeImpl) child).getTextContent(buf);
 637             }
 638             child = child.getNextSibling();
 639         }
 640     }
 641 
 642     // internal method returning whether to take the given node&#39;s text content
 643     final boolean hasTextContent(Node child) {
 644         return child.getNodeType() != Node.COMMENT_NODE &amp;&amp;
 645             child.getNodeType() != Node.PROCESSING_INSTRUCTION_NODE &amp;&amp;
 646             (child.getNodeType() != Node.TEXT_NODE ||
 647              ((TextImpl) child).isIgnorableWhitespace() == false);
 648     }
 649 
 650     /*
 651      * Set Node text content
 652      * @since DOM Level 3
</pre>
<hr />
<pre>
 659             removeChild(child);
 660         }
 661         // create a Text node to hold the given content
 662         if (textContent != null &amp;&amp; textContent.length() != 0){
 663             appendChild(ownerDocument().createTextNode(textContent));
 664         }
 665     }
 666 
 667     //
 668     // NodeList methods
 669     //
 670 
 671     /**
 672      * Count the immediate children of this node.  Use to implement
 673      * NodeList.getLength().
 674      * @return int
 675      */
 676     private int nodeListGetLength() {
 677 
 678         if (fNodeListCache == null) {
<span class="line-added"> 679             if (needsSyncChildren()) {</span>
<span class="line-added"> 680                 synchronizeChildren();</span>
<span class="line-added"> 681             }</span>
 682             // get rid of trivial cases
 683             if (firstChild == null) {
 684                 return 0;
 685             }
 686             if (firstChild == lastChild()) {
 687                 return 1;
 688             }
 689             // otherwise request a cache object
 690             fNodeListCache = ownerDocument.getNodeListCache(this);
 691         }
 692         if (fNodeListCache.fLength == -1) { // is the cached length invalid ?
 693             int l;
 694             ChildNode n;
 695             // start from the cached node if we have one
 696             if (fNodeListCache.fChildIndex != -1 &amp;&amp;
 697                 fNodeListCache.fChild != null) {
 698                 l = fNodeListCache.fChildIndex;
 699                 n = fNodeListCache.fChild;
 700             } else {
 701                 n = firstChild;
</pre>
<hr />
<pre>
 711         return fNodeListCache.fLength;
 712 
 713     } // nodeListGetLength():int
 714 
 715     /**
 716      * NodeList method: Count the immediate children of this node
 717      * @return int
 718      */
 719     public int getLength() {
 720         return nodeListGetLength();
 721     }
 722 
 723     /**
 724      * Return the Nth immediate child of this node, or null if the index is
 725      * out of bounds.  Use to implement NodeList.item().
 726      * @param index int
 727      */
 728     private Node nodeListItem(int index) {
 729 
 730         if (fNodeListCache == null) {
<span class="line-added"> 731             if (needsSyncChildren()) {</span>
<span class="line-added"> 732                 synchronizeChildren();</span>
<span class="line-added"> 733             }</span>
 734             // get rid of trivial case
 735             if (firstChild == lastChild()) {
 736                 return index == 0 ? firstChild : null;
 737             }
 738             // otherwise request a cache object
 739             fNodeListCache = ownerDocument.getNodeListCache(this);
 740         }
 741         int i = fNodeListCache.fChildIndex;
 742         ChildNode n = fNodeListCache.fChild;
 743         boolean firstAccess = true;
 744         // short way
 745         if (i != -1 &amp;&amp; n != null) {
 746             firstAccess = false;
 747             if (i &lt; index) {
 748                 while (i &lt; index &amp;&amp; n != null) {
 749                     i++;
 750                     n = n.nextSibling;
 751                 }
 752             }
 753             else if (i &gt; index) {
</pre>
<hr />
<pre>
 851         for (kid = firstChild; kid != null; kid = kid.nextSibling) {
 852             kid.normalize();
 853         }
 854         isNormalized(true);
 855     }
 856 
 857     /**
 858      * DOM Level 3 WD- Experimental.
 859      * Override inherited behavior from NodeImpl to support deep equal.
 860      */
 861     public boolean isEqualNode(Node arg) {
 862         if (!super.isEqualNode(arg)) {
 863             return false;
 864         }
 865         // there are many ways to do this test, and there isn&#39;t any way
 866         // better than another. Performance may vary greatly depending on
 867         // the implementations involved. This one should work fine for us.
 868         Node child1 = getFirstChild();
 869         Node child2 = arg.getFirstChild();
 870         while (child1 != null &amp;&amp; child2 != null) {
<span class="line-modified"> 871             if (!child1.isEqualNode(child2)) {</span>
 872                 return false;
 873             }
 874             child1 = child1.getNextSibling();
 875             child2 = child2.getNextSibling();
 876         }
 877         if (child1 != child2) {
 878             return false;
 879         }
 880         return true;
 881     }
 882 
 883     //
 884     // Public methods
 885     //
 886 
 887     /**
 888      * Override default behavior so that if deep is true, children are also
 889      * toggled.
 890      * @see Node
 891      * &lt;P&gt;
</pre>
<hr />
<pre>
 978         // See if removal caused this node to be unnormalized.
 979         // If the adjacent siblings of the removed child were both text nodes,
 980         // flag this node as unnormalized.
 981         if (previousSibling != null &amp;&amp;
 982             previousSibling.getNodeType() == Node.TEXT_NODE) {
 983 
 984             ChildNode next = previousSibling.nextSibling;
 985             if (next != null &amp;&amp; next.getNodeType() == Node.TEXT_NODE) {
 986                 isNormalized(false);
 987             }
 988         }
 989     } // checkNormalizationAfterRemove(Node)
 990 
 991     //
 992     // Serialization methods
 993     //
 994 
 995     /** Serialize object. */
 996     private void writeObject(ObjectOutputStream out) throws IOException {
 997 
<span class="line-modified"> 998         // synchronize children</span>
 999         if (needsSyncChildren()) {
1000             synchronizeChildren();
1001         }
1002         // write object
1003         out.defaultWriteObject();
1004 
1005     } // writeObject(ObjectOutputStream)
1006 
1007     /** Deserialize object. */
1008     private void readObject(ObjectInputStream ois)
1009         throws ClassNotFoundException, IOException {
1010 
1011         // perform default deseralization
1012         ois.defaultReadObject();
1013 
1014         // hardset synchildren - so we don&#39;t try to sync - it does not make any
1015         // sense to try to synchildren when we just deserialize object.
1016         needsSyncChildren(false);
1017 
1018     } // readObject(ObjectInputStream)
1019 
1020     /*
1021      * a class to store some user data along with its handler
1022      */
<span class="line-modified">1023     class UserDataRecord implements Serializable {</span>
1024         /** Serialization version. */
1025         private static final long serialVersionUID = 3258126977134310455L;
1026 
1027         Object fData;
1028         UserDataHandler fHandler;
1029         UserDataRecord(Object data, UserDataHandler handler) {
1030             fData = data;
1031             fHandler = handler;
1032         }
1033     }
1034 } // class ParentNode
</pre>
</td>
</tr>
</table>
<center><a href="PSVIDOMImplementationImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="TextImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
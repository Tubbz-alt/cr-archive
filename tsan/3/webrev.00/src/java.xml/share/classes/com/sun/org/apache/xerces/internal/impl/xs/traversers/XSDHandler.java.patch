diff a/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java b/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java
--- a/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDHandler.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -58,10 +58,11 @@
 import com.sun.org.apache.xerces.internal.util.StAXInputSource;
 import com.sun.org.apache.xerces.internal.util.StAXLocationWrapper;
 import com.sun.org.apache.xerces.internal.util.SymbolHash;
 import com.sun.org.apache.xerces.internal.util.SymbolTable;
 import com.sun.org.apache.xerces.internal.util.URI.MalformedURIException;
+import com.sun.org.apache.xerces.internal.util.XMLChar;
 import com.sun.org.apache.xerces.internal.util.XMLSymbols;
 import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;
 import com.sun.org.apache.xerces.internal.utils.XMLSecurityPropertyManager;
 import com.sun.org.apache.xerces.internal.xni.QName;
 import com.sun.org.apache.xerces.internal.xni.XNIException;
@@ -127,11 +128,11 @@
  * @xerces.internal
  *
  * @author Neil Graham, IBM
  * @author Pavani Mukthipudi, Sun Microsystems
  *
- * @LastModified: Nov 2017
+ * @LastModified: Apr 2019
  */
 @SuppressWarnings("deprecation") //org.xml.sax.helpers.XMLReaderFactory
 public class XSDHandler {
 
     /** Feature identifier: validation. */
@@ -589,14 +590,31 @@
                   referType, null);
 
         } //is instanceof XMLInputSource
 
         if (schemaRoot == null) {
-            // something went wrong right off the hop
             if (is instanceof XSInputSource) {
-                return fGrammarBucket.getGrammar(desc.getTargetNamespace());
+                // Need to return a grammar. If the XSInputSource has a list
+                // of grammar objects, then get the first one and return it.
+                // If it has a list of components, then get the grammar that
+                // contains the first component and return it.
+                // If we return null, the XMLSchemaLoader will think nothing
+                // was loaded, and will not try to put the grammar objects
+                // into the grammar pool.
+                XSInputSource xsinput = (XSInputSource)is;
+                SchemaGrammar[] grammars = xsinput.getGrammars();
+                if (grammars != null && grammars.length > 0) {
+                    grammar = fGrammarBucket.getGrammar(grammars[0].getTargetNamespace());
+                }
+                else {
+                    XSObject[] components = xsinput.getComponents();
+                    if (components != null && components.length > 0) {
+                        grammar = fGrammarBucket.getGrammar(components[0].getNamespace());
+                    }
+                }
             }
+            // something went wrong right off the hop
             return grammar;
         }
 
         if (referType == XSDDescription.CONTEXT_PREPARSE) {
                 Element schemaElem = schemaRoot;
@@ -1297,10 +1315,11 @@
                         if (lName.length() == 0) // an error we'll catch later
                             continue;
                         String qName = currSchemaDoc.fTargetNamespace == null ?
                                 ","+lName:
                                     currSchemaDoc.fTargetNamespace +","+lName;
+                        qName = XMLChar.trim(qName);
                         String componentType = DOMUtil.getLocalName(redefineComp);
                         if (componentType.equals(SchemaSymbols.ELT_ATTRIBUTEGROUP)) {
                             checkForDuplicateNames(qName, ATTRIBUTEGROUP_TYPE, fUnparsedAttributeGroupRegistry, fUnparsedAttributeGroupRegistrySub, redefineComp, currSchemaDoc);
                             // the check will have changed our name;
                             String targetLName = DOMUtil.getAttrValue(redefineComp, SchemaSymbols.ATT_NAME)+REDEF_IDENTIFIER;
@@ -1341,10 +1360,11 @@
                     if (lName.length() == 0) // an error we'll catch later
                         continue;
                     String qName = currSchemaDoc.fTargetNamespace == null?
                             ","+lName:
                                 currSchemaDoc.fTargetNamespace +","+lName;
+                    qName = XMLChar.trim(qName);
                     String componentType = DOMUtil.getLocalName(globalComp);
 
                     if (componentType.equals(SchemaSymbols.ELT_ATTRIBUTE)) {
                         checkForDuplicateNames(qName, ATTRIBUTE_TYPE, fUnparsedAttributeRegistry, fUnparsedAttributeRegistrySub, globalComp, currSchemaDoc);
                     }
@@ -2464,13 +2484,19 @@
             Document schemaDocument = fStAXSchemaParser.getDocument();
             schemaElement = schemaDocument != null ? DOMUtil.getRoot(schemaDocument) : null;
             return getSchemaDocument0(key, schemaId, schemaElement);
         }
         catch (XMLStreamException e) {
-            StAXLocationWrapper slw = new StAXLocationWrapper();
-            slw.setLocation(e.getLocation());
-            throw new XMLParseException(slw, e.getMessage(), e);
+            Throwable t = e.getNestedException();
+            if (t instanceof IOException) {
+                exception = (IOException) t;
+            }
+            else {
+                StAXLocationWrapper slw = new StAXLocationWrapper();
+                slw.setLocation(e.getLocation());
+                throw new XMLParseException(slw, e.getMessage(), e);
+            }
         }
         catch (IOException e) {
             exception = e;
         }
         return getSchemaDocument1(mustResolve, true, schemaSource, referElement, exception);
@@ -2739,20 +2765,33 @@
         }
     }
 
     @SuppressWarnings("unchecked")
     private void addNewImportedGrammars(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
-        final ArrayList<SchemaGrammar> igs1 = (ArrayList<SchemaGrammar>)srcGrammar.getImportedGrammars();
-        if (igs1 != null) {
-           ArrayList<SchemaGrammar> igs2 = (ArrayList<SchemaGrammar>)dstGrammar.getImportedGrammars();
-
-            if (igs2 == null) {
-                igs2 = (ArrayList<SchemaGrammar>)igs1.clone();
-                dstGrammar.setImportedGrammars(igs2);
-            }
-            else {
-                updateImportList(igs1, igs2);
+        final ArrayList<SchemaGrammar> src = (ArrayList<SchemaGrammar>)srcGrammar.getImportedGrammars();
+        if (src != null) {
+            ArrayList<SchemaGrammar> dst = (ArrayList<SchemaGrammar>)dstGrammar.getImportedGrammars();
+            if (dst == null) {
+                dst = new ArrayList<>();
+                dstGrammar.setImportedGrammars(dst);
+            }
+            for (SchemaGrammar sg :src) {
+                // Can't use the object from the source import list directly.
+                // It's possible there is already a grammar with the same
+                // namespace in the bucket but a different object.
+                // This can happen if the bucket has grammar A1, and we try
+                // to add B and A2, where A2 imports B. When B is added, we
+                // create a new object B' and store it in the bucket. Then we
+                // try to merge A2 and A1. We can't use B. Need to get B' from
+                // the bucket and store it in A's import list.
+                SchemaGrammar sg1 = fGrammarBucket.getGrammar(sg.getTargetNamespace());
+                if (sg1 != null) {
+                    sg = sg1;
+                }
+                if (!containedImportedGrammar(dst, sg)) {
+                    dst.add(sg);
+                }
             }
         }
     }
 
     private void updateImportList(List<SchemaGrammar> importedSrc, List<SchemaGrammar> importedDst)
@@ -3160,11 +3199,11 @@
         }
     }
 
     private void addRelatedType(XSTypeDefinition type, List<XSObject> componentList, String namespace, Map<String, List<String>> dependencies) {
         if (!type.getAnonymous()) {
-            if (!type.getNamespace().equals(SchemaSymbols.URI_SCHEMAFORSCHEMA)) { //REVISIT - do we use == instead
+            if (!SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(type.getNamespace())) { //REVISIT - do we use == instead
                 if (!componentList.contains(type)) {
                     final List<String> importedNamespaces = findDependentNamespaces(namespace, dependencies);
                     addNamespaceDependency(namespace, type.getNamespace(), importedNamespaces);
                     componentList.add(type);
                 }

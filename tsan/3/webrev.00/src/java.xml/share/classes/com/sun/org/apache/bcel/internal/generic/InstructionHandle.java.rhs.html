<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.Collection;
 23 import java.util.HashMap;
 24 import java.util.HashSet;
 25 import java.util.Map;
 26 import java.util.Set;
 27 
 28 import com.sun.org.apache.bcel.internal.classfile.Utility;
 29 
 30 /**
 31  * Instances of this class give users a handle to the instructions contained in
 32  * an InstructionList. Instruction objects may be used more than once within a
 33  * list, this is useful because it saves memory and may be much faster.
 34  *
<a name="2" id="anc2"></a><span class="line-modified"> 35  * Within an InstructionList an InstructionHandle object is wrapped</span>
<span class="line-modified"> 36  * around all instructions, i.e., it implements a cell in a</span>
<span class="line-modified"> 37  * doubly-linked list. From the outside only the next and the</span>
<span class="line-modified"> 38  * previous instruction (handle) are accessible. One</span>
<span class="line-added"> 39  * can traverse the list via an Enumeration returned by</span>
 40  * InstructionList.elements().
 41  *
<a name="3" id="anc3"></a>
 42  * @see Instruction
 43  * @see BranchHandle
 44  * @see InstructionList
<a name="4" id="anc4"></a><span class="line-added"> 45  * @LastModified: Jan 2020</span>
 46  */
 47 public class InstructionHandle {
 48 
 49     private InstructionHandle next;
 50     private InstructionHandle prev;
 51     private Instruction instruction;
 52 
 53     private int i_position = -1; // byte code offset of instruction
 54 
 55     private Set&lt;InstructionTargeter&gt; targeters;
 56     private Map&lt;Object, Object&gt; attributes;
 57 
<a name="5" id="anc5"></a><span class="line-added"> 58 </span>
<span class="line-added"> 59     /**</span>
<span class="line-added"> 60      * Does nothing.</span>
<span class="line-added"> 61      *</span>
<span class="line-added"> 62      * @deprecated Does nothing as of 6.3.1.</span>
<span class="line-added"> 63      */</span>
<span class="line-added"> 64     @Deprecated</span>
<span class="line-added"> 65     protected void addHandle() {</span>
<span class="line-added"> 66         // noop</span>
<span class="line-added"> 67     }</span>
<span class="line-added"> 68 </span>
 69     public final InstructionHandle getNext() {
 70         return next;
 71     }
 72 
<a name="6" id="anc6"></a><span class="line-added"> 73 </span>
 74     public final InstructionHandle getPrev() {
 75         return prev;
 76     }
 77 
<a name="7" id="anc7"></a><span class="line-added"> 78 </span>
 79     public final Instruction getInstruction() {
 80         return instruction;
 81     }
 82 
<a name="8" id="anc8"></a><span class="line-added"> 83 </span>
 84     /**
<a name="9" id="anc9"></a><span class="line-modified"> 85      * Replace current instruction contained in this handle.</span>
<span class="line-modified"> 86      * Old instruction is disposed using Instruction.dispose().</span>
 87      */
<a name="10" id="anc10"></a><span class="line-modified"> 88     public void setInstruction( final Instruction i ) { // Overridden in BranchHandle TODO could be package-protected?</span>
 89         if (i == null) {
 90             throw new ClassGenException(&quot;Assigning null to handle&quot;);
 91         }
 92         if ((this.getClass() != BranchHandle.class) &amp;&amp; (i instanceof BranchInstruction)) {
 93             throw new ClassGenException(&quot;Assigning branch instruction &quot; + i + &quot; to plain handle&quot;);
 94         }
 95         if (instruction != null) {
 96             instruction.dispose();
 97         }
 98         instruction = i;
 99     }
100 
<a name="11" id="anc11"></a><span class="line-added">101 </span>
102     /**
<a name="12" id="anc12"></a><span class="line-modified">103      * Temporarily swap the current instruction, without disturbing</span>
<span class="line-modified">104      * anything. Meant to be used by a debugger, implementing</span>
<span class="line-modified">105      * breakpoints. Current instruction is returned.</span>
106      * &lt;p&gt;
107      * Warning: if this is used on a BranchHandle then some methods such as
<a name="13" id="anc13"></a><span class="line-modified">108      * getPosition() will still refer to the original cached instruction, whereas</span>
<span class="line-modified">109      * other BH methods may affect the cache and the replacement instruction.</span>

110      */
111     // See BCEL-273
112     // TODO remove this method in any redesign of BCEL
<a name="14" id="anc14"></a><span class="line-modified">113     public Instruction swapInstruction( final Instruction i ) {</span>
114         final Instruction oldInstruction = instruction;
115         instruction = i;
116         return oldInstruction;
117     }
118 
119 
<a name="15" id="anc15"></a><span class="line-modified">120     /*private*/protected InstructionHandle(final Instruction i) {</span>

121         setInstruction(i);
122     }
123 
<a name="16" id="anc16"></a><span class="line-modified">124     /** Factory method.</span>



125      */
<a name="17" id="anc17"></a><span class="line-modified">126     static InstructionHandle getInstructionHandle( final Instruction i ) {</span>
<span class="line-modified">127         return new InstructionHandle(i);</span>






128     }
129 
<a name="18" id="anc18"></a><span class="line-added">130 </span>
131     /**
<a name="19" id="anc19"></a><span class="line-modified">132      * Called by InstructionList.setPositions when setting the position for every</span>
<span class="line-modified">133      * instruction. In the presence of variable length instructions `setPositions()&#39;</span>
<span class="line-modified">134      * performs multiple passes over the instruction list to calculate the</span>
<span class="line-modified">135      * correct (byte) positions and offsets by calling this function.</span>

136      *
<a name="20" id="anc20"></a><span class="line-modified">137      * @param offset additional offset caused by preceding (variable length) instructions</span>
<span class="line-modified">138      * @param max_offset the maximum offset that may be caused by these instructions</span>
<span class="line-modified">139      * @return additional offset caused by possible change of this instruction&#39;s length</span>



140      */
<a name="21" id="anc21"></a><span class="line-modified">141     protected int updatePosition( final int offset, final int max_offset ) {</span>
142         i_position += offset;
143         return 0;
144     }
145 
<a name="22" id="anc22"></a><span class="line-modified">146 </span>
<span class="line-modified">147     /** @return the position, i.e., the byte code offset of the contained</span>
<span class="line-modified">148      * instruction. This is accurate only after</span>
<span class="line-modified">149      * InstructionList.setPositions() has been called.</span>
150      */
151     public int getPosition() {
152         return i_position;
153     }
154 
<a name="23" id="anc23"></a><span class="line-modified">155 </span>
<span class="line-modified">156     /** Set the position, i.e., the byte code offset of the contained</span>
157      * instruction.
158      */
<a name="24" id="anc24"></a><span class="line-modified">159     void setPosition( final int pos ) {</span>
160         i_position = pos;
161     }
162 
<a name="25" id="anc25"></a>






163 
164     /**
<a name="26" id="anc26"></a><span class="line-modified">165      * Delete contents, i.e., remove user access.</span>
166      */
167     void dispose() {
168         next = prev = null;
169         instruction.dispose();
170         instruction = null;
171         i_position = -1;
172         attributes = null;
173         removeAllTargeters();
<a name="27" id="anc27"></a>
174     }
175 
<a name="28" id="anc28"></a><span class="line-modified">176 </span>
<span class="line-modified">177     /** Remove all targeters, if any.</span>
178      */
179     public void removeAllTargeters() {
180         if (targeters != null) {
181             targeters.clear();
182         }
183     }
184 
<a name="29" id="anc29"></a><span class="line-added">185 </span>
186     /**
187      * Denote this handle isn&#39;t referenced anymore by t.
188      */
<a name="30" id="anc30"></a><span class="line-modified">189     public void removeTargeter( final InstructionTargeter t ) {</span>
190         if (targeters != null) {
191             targeters.remove(t);
192         }
193     }
194 
<a name="31" id="anc31"></a><span class="line-added">195 </span>
196     /**
197      * Denote this handle is being referenced by t.
198      */
<a name="32" id="anc32"></a><span class="line-modified">199     public void addTargeter( final InstructionTargeter t ) {</span>
200         if (targeters == null) {
201             targeters = new HashSet&lt;&gt;();
202         }
203         //if(!targeters.contains(t))
204         targeters.add(t);
205     }
206 
<a name="33" id="anc33"></a><span class="line-added">207 </span>
208     public boolean hasTargeters() {
209         return (targeters != null) &amp;&amp; (targeters.size() &gt; 0);
210     }
211 
<a name="34" id="anc34"></a><span class="line-added">212 </span>
213     /**
214      * @return null, if there are no targeters
215      */
216     public InstructionTargeter[] getTargeters() {
217         if (!hasTargeters()) {
218             return new InstructionTargeter[0];
219         }
220         final InstructionTargeter[] t = new InstructionTargeter[targeters.size()];
221         targeters.toArray(t);
222         return t;
223     }
224 
<a name="35" id="anc35"></a><span class="line-modified">225 </span>
<span class="line-modified">226     /** @return a (verbose) string representation of the contained instruction.</span>
227      */
<a name="36" id="anc36"></a><span class="line-modified">228     public String toString( final boolean verbose ) {</span>
229         return Utility.format(i_position, 4, false, &#39; &#39;) + &quot;: &quot; + instruction.toString(verbose);
230     }
231 
<a name="37" id="anc37"></a><span class="line-modified">232 </span>
<span class="line-modified">233     /** @return a string representation of the contained instruction.</span>
234      */
235     @Override
236     public String toString() {
237         return toString(true);
238     }
239 
<a name="38" id="anc38"></a><span class="line-modified">240 </span>
<span class="line-modified">241     /** Add an attribute to an instruction handle.</span>
242      *
243      * @param key the key object to store/retrieve the attribute
244      * @param attr the attribute to associate with this handle
245      */
<a name="39" id="anc39"></a><span class="line-modified">246     public void addAttribute( final Object key, final Object attr ) {</span>
247         if (attributes == null) {
248             attributes = new HashMap&lt;&gt;(3);
249         }
250         attributes.put(key, attr);
251     }
252 
<a name="40" id="anc40"></a><span class="line-modified">253 </span>
<span class="line-modified">254     /** Delete an attribute of an instruction handle.</span>
255      *
256      * @param key the key object to retrieve the attribute
257      */
<a name="41" id="anc41"></a><span class="line-modified">258     public void removeAttribute( final Object key ) {</span>
259         if (attributes != null) {
260             attributes.remove(key);
261         }
262     }
263 
<a name="42" id="anc42"></a><span class="line-modified">264 </span>
<span class="line-modified">265     /** Get attribute of an instruction handle.</span>
266      *
267      * @param key the key object to store/retrieve the attribute
268      */
<a name="43" id="anc43"></a><span class="line-modified">269     public Object getAttribute( final Object key ) {</span>
270         if (attributes != null) {
271             return attributes.get(key);
272         }
273         return null;
274     }
275 
<a name="44" id="anc44"></a><span class="line-modified">276 </span>
<span class="line-modified">277     /** @return all attributes associated with this handle</span>
278      */
279     public Collection&lt;Object&gt; getAttributes() {
280         if (attributes == null) {
281             attributes = new HashMap&lt;&gt;(3);
282         }
283         return attributes.values();
284     }
285 
<a name="45" id="anc45"></a><span class="line-modified">286 </span>
<span class="line-modified">287     /** Convenience method, simply calls accept() on the contained instruction.</span>
288      *
289      * @param v Visitor object
290      */
<a name="46" id="anc46"></a><span class="line-modified">291     public void accept( final Visitor v ) {</span>
292         instruction.accept(v);
293     }
294 
<a name="47" id="anc47"></a><span class="line-added">295 </span>
296     /**
297      * @param next the next to set
298      * @ since 6.0
299      */
300     final InstructionHandle setNext(final InstructionHandle next) {
301         this.next = next;
302         return next;
303     }
304 
<a name="48" id="anc48"></a><span class="line-added">305 </span>
306     /**
307      * @param prev the prev to set
308      * @ since 6.0
309      */
310     final InstructionHandle setPrev(final InstructionHandle prev) {
311         this.prev = prev;
312         return prev;
313     }
314 }
<a name="49" id="anc49"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="49" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/Constant.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CodeException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantCP.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/Constant.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,34 ***</span>
  package com.sun.org.apache.bcel.internal.classfile;
  
  import java.io.DataInput;
  import java.io.DataOutputStream;
  import java.io.IOException;
  
  import com.sun.org.apache.bcel.internal.Const;
  import com.sun.org.apache.bcel.internal.util.BCELComparator;
  
  /**
<span class="line-modified">!  * Abstract superclass for classes to represent the different constant types in</span>
<span class="line-modified">!  * the constant pool of a class file. The classes keep closely to the JVM</span>
<span class="line-modified">!  * specification.</span>
   *
<span class="line-modified">!  * @version $Id: Constant.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
   */
  public abstract class Constant implements Cloneable, Node {
  
      private static BCELComparator bcelComparator = new BCELComparator() {
  
          @Override
<span class="line-modified">!         public boolean equals(final Object o1, final Object o2) {</span>
              final Constant THIS = (Constant) o1;
              final Constant THAT = (Constant) o2;
<span class="line-modified">!             return THIS.toString().equals(THAT.toString());</span>
          }
  
          @Override
<span class="line-modified">!         public int hashCode(final Object o) {</span>
              final Constant THIS = (Constant) o;
              return THIS.toString().hashCode();
          }
      };
  
<span class="line-new-header">--- 20,36 ---</span>
  package com.sun.org.apache.bcel.internal.classfile;
  
  import java.io.DataInput;
  import java.io.DataOutputStream;
  import java.io.IOException;
<span class="line-added">+ import java.util.Objects;</span>
  
  import com.sun.org.apache.bcel.internal.Const;
  import com.sun.org.apache.bcel.internal.util.BCELComparator;
  
  /**
<span class="line-modified">!  * Abstract superclass for classes to represent the different constant types</span>
<span class="line-modified">!  * in the constant pool of a class file. The classes keep closely to</span>
<span class="line-modified">!  * the JVM specification.</span>
   *
<span class="line-modified">!  * @LastModified: Jan 2020</span>
   */
  public abstract class Constant implements Cloneable, Node {
  
      private static BCELComparator bcelComparator = new BCELComparator() {
  
          @Override
<span class="line-modified">!         public boolean equals( final Object o1, final Object o2 ) {</span>
              final Constant THIS = (Constant) o1;
              final Constant THAT = (Constant) o2;
<span class="line-modified">!             return Objects.equals(THIS.toString(), THAT.toString());</span>
          }
  
<span class="line-added">+ </span>
          @Override
<span class="line-modified">!         public int hashCode( final Object o ) {</span>
              final Constant THIS = (Constant) o;
              return THIS.toString().hashCode();
          }
      };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,13 ***</span>
       * fields, attributes, etc. spawns a tree of objects.
       *
       * @param v Visitor object
       */
      @Override
<span class="line-modified">!     public abstract void accept(Visitor v);</span>
  
<span class="line-modified">!     public abstract void dump(DataOutputStream file) throws IOException;</span>
  
      /**
       * @return Tag of constant, i.e., its type. No setTag() method to avoid
       * confusion.
       */
<span class="line-new-header">--- 73,13 ---</span>
       * fields, attributes, etc. spawns a tree of objects.
       *
       * @param v Visitor object
       */
      @Override
<span class="line-modified">!     public abstract void accept( Visitor v );</span>
  
<span class="line-modified">!     public abstract void dump( DataOutputStream file ) throws IOException;</span>
  
      /**
       * @return Tag of constant, i.e., its type. No setTag() method to avoid
       * confusion.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,50 ***</span>
              throw new Error(&quot;Clone Not Supported&quot;); // never happens
          }
      }
  
      /**
<span class="line-modified">!      * Read one constant from the given input, the type depends on a tag byte.</span>
       *
<span class="line-modified">!      * @param input Input stream</span>
       * @return Constant object
       * @since 6.0 made public
       */
<span class="line-modified">!     public static Constant readConstant(final DataInput input) throws IOException,</span>
<span class="line-modified">!             ClassFormatException {</span>
<span class="line-removed">-         final byte b = input.readByte(); // Read tag byte</span>
          switch (b) {
<span class="line-modified">!             case Const.CONSTANT_Class:</span>
<span class="line-modified">!                 return new ConstantClass(input);</span>
<span class="line-modified">!             case Const.CONSTANT_Fieldref:</span>
<span class="line-modified">!                 return new ConstantFieldref(input);</span>
<span class="line-modified">!             case Const.CONSTANT_Methodref:</span>
<span class="line-modified">!                 return new ConstantMethodref(input);</span>
<span class="line-modified">!             case Const.CONSTANT_InterfaceMethodref:</span>
<span class="line-modified">!                 return new ConstantInterfaceMethodref(input);</span>
<span class="line-modified">!             case Const.CONSTANT_String:</span>
<span class="line-modified">!                 return new ConstantString(input);</span>
<span class="line-modified">!             case Const.CONSTANT_Integer:</span>
<span class="line-modified">!                 return new ConstantInteger(input);</span>
<span class="line-modified">!             case Const.CONSTANT_Float:</span>
<span class="line-modified">!                 return new ConstantFloat(input);</span>
<span class="line-modified">!             case Const.CONSTANT_Long:</span>
<span class="line-modified">!                 return new ConstantLong(input);</span>
<span class="line-modified">!             case Const.CONSTANT_Double:</span>
<span class="line-modified">!                 return new ConstantDouble(input);</span>
<span class="line-modified">!             case Const.CONSTANT_NameAndType:</span>
<span class="line-modified">!                 return new ConstantNameAndType(input);</span>
<span class="line-modified">!             case Const.CONSTANT_Utf8:</span>
<span class="line-modified">!                 return ConstantUtf8.getInstance(input);</span>
<span class="line-modified">!             case Const.CONSTANT_MethodHandle:</span>
<span class="line-modified">!                 return new ConstantMethodHandle(input);</span>
<span class="line-modified">!             case Const.CONSTANT_MethodType:</span>
<span class="line-modified">!                 return new ConstantMethodType(input);</span>
<span class="line-modified">!             case Const.CONSTANT_InvokeDynamic:</span>
<span class="line-modified">!                 return new ConstantInvokeDynamic(input);</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 throw new ClassFormatException(&quot;Invalid byte tag in constant pool: &quot; + b);</span>
          }
      }
  
      /**
       * @return Comparison strategy object
<span class="line-new-header">--- 115,57 ---</span>
              throw new Error(&quot;Clone Not Supported&quot;); // never happens
          }
      }
  
      /**
<span class="line-modified">!      * Reads one constant from the given input, the type depends on a tag byte.</span>
       *
<span class="line-modified">!      * @param dataInput Input stream</span>
       * @return Constant object
<span class="line-added">+      * @throws IOException if an I/O error occurs reading from the given {@code dataInput}.</span>
<span class="line-added">+      * @throws ClassFormatException if the next byte is not recognized</span>
       * @since 6.0 made public
       */
<span class="line-modified">!     public static Constant readConstant(final DataInput dataInput) throws IOException, ClassFormatException {</span>
<span class="line-modified">!         final byte b = dataInput.readByte(); // Read tag byte</span>
          switch (b) {
<span class="line-modified">!         case Const.CONSTANT_Class:</span>
<span class="line-modified">!             return new ConstantClass(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_Fieldref:</span>
<span class="line-modified">!             return new ConstantFieldref(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_Methodref:</span>
<span class="line-modified">!             return new ConstantMethodref(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_InterfaceMethodref:</span>
<span class="line-modified">!             return new ConstantInterfaceMethodref(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_String:</span>
<span class="line-modified">!             return new ConstantString(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_Integer:</span>
<span class="line-modified">!             return new ConstantInteger(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_Float:</span>
<span class="line-modified">!             return new ConstantFloat(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_Long:</span>
<span class="line-modified">!             return new ConstantLong(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_Double:</span>
<span class="line-modified">!             return new ConstantDouble(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_NameAndType:</span>
<span class="line-modified">!             return new ConstantNameAndType(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_Utf8:</span>
<span class="line-modified">!             return ConstantUtf8.getInstance(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_MethodHandle:</span>
<span class="line-modified">!             return new ConstantMethodHandle(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_MethodType:</span>
<span class="line-modified">!             return new ConstantMethodType(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_Dynamic:</span>
<span class="line-modified">!             return new ConstantDynamic(dataInput);</span>
<span class="line-modified">!         case Const.CONSTANT_InvokeDynamic:</span>
<span class="line-modified">!             return new ConstantInvokeDynamic(dataInput);</span>
<span class="line-added">+         case Const.CONSTANT_Module:</span>
<span class="line-added">+             return new ConstantModule(dataInput);</span>
<span class="line-added">+         case Const.CONSTANT_Package:</span>
<span class="line-added">+             return new ConstantPackage(dataInput);</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             throw new ClassFormatException(&quot;Invalid byte tag in constant pool: &quot; + b);</span>
          }
      }
  
      /**
       * @return Comparison strategy object
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,29 ***</span>
      }
  
      /**
       * @param comparator Comparison strategy object
       */
<span class="line-modified">!     public static void setComparator(final BCELComparator comparator) {</span>
          bcelComparator = comparator;
      }
  
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">!      * Constant objects are said to be equal when the result of toString() is</span>
<span class="line-modified">!      * equal.</span>
       *
       * @see java.lang.Object#equals(java.lang.Object)
       */
      @Override
<span class="line-modified">!     public boolean equals(final Object obj) {</span>
          return bcelComparator.equals(this, obj);
      }
  
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">!      * return the hashcode of the result of toString().</span>
       *
       * @see java.lang.Object#hashCode()
       */
      @Override
      public int hashCode() {
<span class="line-new-header">--- 175,29 ---</span>
      }
  
      /**
       * @param comparator Comparison strategy object
       */
<span class="line-modified">!     public static void setComparator( final BCELComparator comparator ) {</span>
          bcelComparator = comparator;
      }
  
      /**
<span class="line-modified">!      * Returns value as defined by given BCELComparator strategy.</span>
<span class="line-modified">!      * By default two Constant objects are said to be equal when</span>
<span class="line-modified">!      * the result of toString() is equal.</span>
       *
       * @see java.lang.Object#equals(java.lang.Object)
       */
      @Override
<span class="line-modified">!     public boolean equals( final Object obj ) {</span>
          return bcelComparator.equals(this, obj);
      }
  
      /**
<span class="line-modified">!      * Returns value as defined by given BCELComparator strategy.</span>
<span class="line-modified">!      * By default return the hashcode of the result of toString().</span>
       *
       * @see java.lang.Object#hashCode()
       */
      @Override
      public int hashCode() {
</pre>
<center><a href="CodeException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantCP.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
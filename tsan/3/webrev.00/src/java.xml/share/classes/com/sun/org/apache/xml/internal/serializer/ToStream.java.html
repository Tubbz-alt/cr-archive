<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *     http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xml.internal.serializer;
  22 
  23 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
  24 import com.sun.org.apache.xml.internal.serializer.utils.Utils;
  25 import com.sun.org.apache.xml.internal.serializer.utils.WrappedRuntimeException;
  26 import java.io.IOException;
  27 import java.io.OutputStream;
  28 import java.io.OutputStreamWriter;
  29 import java.io.UnsupportedEncodingException;
  30 import java.io.Writer;
  31 import java.util.ArrayList;
  32 import java.util.Arrays;
  33 import java.util.EmptyStackException;
  34 import java.util.Enumeration;
  35 import java.util.Iterator;
  36 import java.util.List;
  37 import java.util.Properties;
  38 import java.util.Set;
  39 import java.util.StringTokenizer;
  40 import javax.xml.transform.ErrorListener;
  41 import javax.xml.transform.OutputKeys;
  42 import javax.xml.transform.Transformer;
  43 import javax.xml.transform.TransformerException;
  44 import org.w3c.dom.Node;
  45 import org.xml.sax.Attributes;
  46 import org.xml.sax.ContentHandler;
  47 import org.xml.sax.SAXException;
  48 
  49 /**
  50  * This abstract class is a base class for other stream
  51  * serializers (xml, html, text ...) that write output to a stream.
  52  *
  53  * @xsl.usage internal
  54  * @LastModified: Aug 2019
  55  */
  56 abstract public class ToStream extends SerializerBase {
  57 
  58     private static final String COMMENT_BEGIN = &quot;&lt;!--&quot;;
  59     private static final String COMMENT_END = &quot;--&gt;&quot;;
  60 
  61     /** Stack to keep track of disabling output escaping. */
  62     protected BoolStack m_disableOutputEscapingStates = new BoolStack();
  63 
  64     /**
  65      * The encoding information associated with this serializer.
  66      * Although initially there is no encoding,
  67      * there is a dummy EncodingInfo object that will say
  68      * that every character is in the encoding. This is useful
  69      * for a serializer that is in temporary output state and has
  70      * no associated encoding. A serializer in final output state
  71      * will have an encoding, and will worry about whether
  72      * single chars or surrogate pairs of high/low chars form
  73      * characters in the output encoding.
  74      */
  75     EncodingInfo m_encodingInfo = new EncodingInfo(null,null);
  76 
  77     /**
  78      * Method reference to the sun.io.CharToByteConverter#canConvert method
  79      * for this encoding.  Invalid if m_charToByteConverter is null.
  80      */
  81     java.lang.reflect.Method m_canConvertMeth;
  82 
  83     /**
  84      * Boolean that tells if we already tried to get the converter.
  85      */
  86     boolean m_triedToGetConverter = false;
  87 
  88     /**
  89      * Opaque reference to the sun.io.CharToByteConverter for this
  90      * encoding.
  91      */
  92     Object m_charToByteConverter = null;
  93 
  94     /**
  95      * Used to buffer the text nodes and the entity reference nodes if
  96      * indentation is on.
  97      */
  98     protected CharacterBuffer m_charactersBuffer = new CharacterBuffer();
  99 
 100     /**
 101      * Used to decide if a text node is pretty-printed with indentation.
 102      * If m_childNodeNum &gt; 1, the text node will be indented.
 103      *
 104      */
 105     protected List&lt;Integer&gt; m_childNodeNumStack = new ArrayList&lt;&gt;();
 106 
 107     protected int m_childNodeNum = 0;
 108 
 109     /**
 110      * Used to handle xml:space attribute
 111      *
 112      */
 113     protected BoolStack m_preserveSpaces = new BoolStack();
 114 
 115     protected boolean m_ispreserveSpace = false;
 116 
 117 
 118     /**
 119      * State flag that tells if the previous node processed
 120      * was text, so we can tell if we should preserve whitespace.
 121      *
 122      * Used in endDocument() and shouldIndent() but
 123      * only if m_doIndent is true.
 124      * If m_doIndent is false this flag has no impact.
 125      */
 126     protected boolean m_isprevtext = false;
 127 
 128     /**
 129      * The maximum character size before we have to resort
 130      * to escaping.
 131      */
 132     protected int m_maxCharacter = Encodings.getLastPrintable();
 133 
 134     /**
 135      * The system line separator for writing out line breaks.
 136      * The default value is from the system property,
 137      * but this value can be set through the xsl:output
 138      * extension attribute xalan:line-separator.
 139      */
 140     protected char[] m_lineSep = System.lineSeparator().toCharArray();
 141 
 142     /**
 143      * True if the the system line separator is to be used.
 144      */
 145     protected boolean m_lineSepUse = true;
 146 
 147     /**
 148      * The length of the line seperator, since the write is done
 149      * one character at a time.
 150      */
 151     protected int m_lineSepLen = m_lineSep.length;
 152 
 153     /**
 154      * Map that tells which characters should have special treatment, and it
 155      *  provides character to entity name lookup.
 156      */
 157     protected CharInfo m_charInfo;
 158 
 159     /** True if we control the buffer, and we should flush the output on endDocument. */
 160     boolean m_shouldFlush = true;
 161 
 162     /**
 163      * Add space before &#39;/&gt;&#39; for XHTML.
 164      */
 165     protected boolean m_spaceBeforeClose = false;
 166 
 167     /**
 168      * Flag to signal that a newline should be added.
 169      *
 170      * Used only in indent() which is called only if m_doIndent is true.
 171      * If m_doIndent is false this flag has no impact.
 172      */
 173     boolean m_startNewLine;
 174 
 175     /**
 176      * Tells if we&#39;re in an internal document type subset.
 177      */
 178     protected boolean m_inDoctype = false;
 179 
 180     /**
 181      * Flag to quickly tell if the encoding is UTF8.
 182      */
 183     boolean m_isUTF8 = false;
 184 
 185     /**
 186      * remembers if we are in between the startCDATA() and endCDATA() callbacks
 187      */
 188     protected boolean m_cdataStartCalled = false;
 189 
 190     /**
 191      * If this flag is true DTD entity references are not left as-is,
 192      * which is exiting older behavior.
 193      */
 194     private boolean m_expandDTDEntities = true;
 195 
 196     private char m_highSurrogate = 0;
 197 
 198     /**
 199      * Default constructor
 200      */
 201     public ToStream() {
 202         this(null);
 203     }
 204 
 205     public ToStream(ErrorListener l) {
 206         m_errListener = l;
 207     }
 208 
 209     /**
 210      * This helper method to writes out &quot;]]&gt;&quot; when closing a CDATA section.
 211      *
 212      * @throws org.xml.sax.SAXException
 213      */
 214     protected void closeCDATA() throws org.xml.sax.SAXException {
 215         try {
 216             m_writer.write(CDATA_DELIMITER_CLOSE);
 217             // write out a CDATA section closing &quot;]]&gt;&quot;
 218             m_cdataTagOpen = false; // Remember that we have done so.
 219         }
 220         catch (IOException e) {
 221             throw new SAXException(e);
 222         }
 223     }
 224 
 225     /**
 226      * Serializes the DOM node. Throws an exception only if an I/O
 227      * exception occured while serializing.
 228      *
 229      * @param node Node to serialize.
 230      * @throws IOException An I/O exception occured while serializing
 231      */
 232     public void serialize(Node node) throws IOException {
 233         try {
 234             TreeWalker walker = new TreeWalker(this);
 235             walker.traverse(node);
 236         } catch (org.xml.sax.SAXException se) {
 237             throw new WrappedRuntimeException(se);
 238         }
 239     }
 240 
 241     /**
 242      * Return true if the character is the high member of a surrogate pair.
 243      *
 244      * NEEDSDOC @param c
 245      *
 246      * NEEDSDOC ($objectName$) @return
 247      */
 248     static final boolean isUTF16Surrogate(char c) {
 249         return (c &amp; 0xFC00) == 0xD800;
 250     }
 251 
 252     /**
 253      * Taken from XSLTC
 254      */
 255     private boolean m_escaping = true;
 256 
 257     /**
 258      * Flush the formatter&#39;s result stream.
 259      *
 260      * @throws org.xml.sax.SAXException
 261      */
 262     protected final void flushWriter() throws org.xml.sax.SAXException {
 263         final Writer writer = m_writer;
 264         if (null != writer) {
 265             try {
 266                 if (writer instanceof WriterToUTF8Buffered) {
 267                     if (m_shouldFlush)
 268                         ((WriterToUTF8Buffered)writer).flush();
 269                     else
 270                         ((WriterToUTF8Buffered)writer).flushBuffer();
 271                 }
 272                 if (writer instanceof WriterToASCI) {
 273                     if (m_shouldFlush)
 274                         writer.flush();
 275                 } else {
 276                     // Flush always.
 277                     // Not a great thing if the writer was created
 278                     // by this class, but don&#39;t have a choice.
 279                     writer.flush();
 280                 }
 281             } catch (IOException ioe) {
 282                 throw new org.xml.sax.SAXException(ioe);
 283             }
 284         }
 285     }
 286 
 287     OutputStream m_outputStream;
 288 
 289     /**
 290      * Get the output stream where the events will be serialized to.
 291      *
 292      * @return reference to the result stream, or null of only a writer was
 293      * set.
 294      */
 295     public OutputStream getOutputStream() {
 296         return m_outputStream;
 297     }
 298 
 299     // Implement DeclHandler
 300 
 301     /**
 302      *   Report an element type declaration.
 303      *
 304      *   &lt;p&gt;The content model will consist of the string &quot;EMPTY&quot;, the
 305      *   string &quot;ANY&quot;, or a parenthesised group, optionally followed
 306      *   by an occurrence indicator.  The model will be normalized so
 307      *   that all whitespace is removed,and will include the enclosing
 308      *   parentheses.&lt;/p&gt;
 309      *
 310      *   @param name The element type name.
 311      *   @param model The content model as a normalized string.
 312      *   @exception SAXException The application may raise an exception.
 313      */
 314     public void elementDecl(String name, String model) throws SAXException
 315     {
 316         // Do not inline external DTD
 317         if (m_inExternalDTD)
 318             return;
 319         try {
 320             final Writer writer = m_writer;
 321             DTDprolog();
 322 
 323             writer.write(&quot;&lt;!ELEMENT &quot;);
 324             writer.write(name);
 325             writer.write(&#39; &#39;);
 326             writer.write(model);
 327             writer.write(&#39;&gt;&#39;);
 328             writer.write(m_lineSep, 0, m_lineSepLen);
 329         }
 330         catch (IOException e)
 331         {
 332             throw new SAXException(e);
 333         }
 334 
 335     }
 336 
 337     /**
 338      * Report an internal entity declaration.
 339      *
 340      * &lt;p&gt;Only the effective (first) declaration for each entity
 341      * will be reported.&lt;/p&gt;
 342      *
 343      * @param name The name of the entity.  If it is a parameter
 344      *        entity, the name will begin with &#39;%&#39;.
 345      * @param value The replacement text of the entity.
 346      * @exception SAXException The application may raise an exception.
 347      * @see #externalEntityDecl
 348      * @see org.xml.sax.DTDHandler#unparsedEntityDecl
 349      */
 350     public void internalEntityDecl(String name, String value)
 351         throws SAXException
 352     {
 353         // Do not inline external DTD
 354         if (m_inExternalDTD)
 355             return;
 356         try {
 357             DTDprolog();
 358             outputEntityDecl(name, value);
 359         } catch (IOException e) {
 360             throw new SAXException(e);
 361         }
 362 
 363     }
 364 
 365     /**
 366      * Output the doc type declaration.
 367      *
 368      * @param name non-null reference to document type name.
 369      * NEEDSDOC @param value
 370      *
 371      * @throws org.xml.sax.SAXException
 372      */
 373     void outputEntityDecl(String name, String value) throws IOException
 374     {
 375         final Writer writer = m_writer;
 376         writer.write(&quot;&lt;!ENTITY &quot;);
 377         writer.write(name);
 378         writer.write(&quot; \&quot;&quot;);
 379         writer.write(value);
 380         writer.write(&quot;\&quot;&gt;&quot;);
 381         writer.write(m_lineSep, 0, m_lineSepLen);
 382     }
 383 
 384     /**
 385      * Output a system-dependent line break.
 386      *
 387      * @throws org.xml.sax.SAXException
 388      */
 389     protected final void outputLineSep() throws IOException {
 390         m_writer.write(m_lineSep, 0, m_lineSepLen);
 391     }
 392 
 393     void setProp(String name, String val, boolean defaultVal) {
 394         if (val != null) {
 395 
 396             char first = getFirstCharLocName(name);
 397             switch (first) {
 398             case &#39;c&#39;:
 399                 if (OutputKeys.CDATA_SECTION_ELEMENTS.equals(name)) {
 400                     addCdataSectionElements(val); // val is cdataSectionNames
 401                 }
 402                 break;
 403             case &#39;d&#39;:
 404                 if (OutputKeys.DOCTYPE_SYSTEM.equals(name)) {
 405                     this.m_doctypeSystem = val;
 406                 } else if (OutputKeys.DOCTYPE_PUBLIC.equals(name)) {
 407                     this.m_doctypePublic = val;
 408                     if (val.startsWith(&quot;-//W3C//DTD XHTML&quot;))
 409                         m_spaceBeforeClose = true;
 410                 }
 411                 break;
 412             case &#39;e&#39;:
 413                 String newEncoding = val;
 414                 if (OutputKeys.ENCODING.equals(name)) {
 415                     String possible_encoding = Encodings.getMimeEncoding(val);
 416                     if (possible_encoding != null) {
 417                         // if the encoding is being set, try to get the
 418                         // preferred
 419                         // mime-name and set it too.
 420                         super.setProp(&quot;mime-name&quot;, possible_encoding,
 421                                 defaultVal);
 422                     }
 423                     final String oldExplicitEncoding = getOutputPropertyNonDefault(OutputKeys.ENCODING);
 424                     final String oldDefaultEncoding  = getOutputPropertyDefault(OutputKeys.ENCODING);
 425                     if ( (defaultVal &amp;&amp; ( oldDefaultEncoding == null || !oldDefaultEncoding.equalsIgnoreCase(newEncoding)))
 426                             || ( !defaultVal &amp;&amp; (oldExplicitEncoding == null || !oldExplicitEncoding.equalsIgnoreCase(newEncoding) ))) {
 427                        // We are trying to change the default or the non-default setting of the encoding to a different value
 428                        // from what it was
 429 
 430                        EncodingInfo encodingInfo = Encodings.getEncodingInfo(newEncoding);
 431                        if (encodingInfo.name == null) {
 432                             // We tried to get an EncodingInfo for Object for the given
 433                             // encoding, but it came back with an internall null name
 434                             // so the encoding is not supported by the JDK, issue a message.
 435                             final String msg = Utils.messages.createMessage(
 436                                     MsgKey.ER_ENCODING_NOT_SUPPORTED,new Object[]{ newEncoding });
 437 
 438                             final String msg2 =
 439                                 &quot;Warning: encoding \&quot;&quot; + newEncoding + &quot;\&quot; not supported, using &quot;
 440                                        + Encodings.DEFAULT_MIME_ENCODING;
 441                             try {
 442                                 // refer to JDK-8229005, should throw Exception instead of warning and
 443                                 // then falling back to the default encoding. Keep it for now.
 444                                 if (m_errListener != null) {
 445                                     m_errListener.warning(new TransformerException(msg, m_sourceLocator));
 446                                     m_errListener.warning(new TransformerException(msg2, m_sourceLocator));
 447                                 }
 448                             } catch (Exception e) {
 449                             }
 450 
 451                             // We said we are using UTF-8, so use it
 452                             newEncoding = Encodings.DEFAULT_MIME_ENCODING;
 453                             // to store the modified value into the properties a little later
 454                             val = Encodings.DEFAULT_MIME_ENCODING;
 455                             encodingInfo = Encodings.getEncodingInfo(newEncoding);
 456                         }
 457                        // The encoding was good, or was forced to UTF-8 above
 458 
 459 
 460                        // If there is already a non-default set encoding and we
 461                        // are trying to set the default encoding, skip the this block
 462                        // as the non-default value is already the one to use.
 463                        if (defaultVal == false || oldExplicitEncoding == null) {
 464                            m_encodingInfo = encodingInfo;
 465                            if (newEncoding != null)
 466                                m_isUTF8 = newEncoding.equals(Encodings.DEFAULT_MIME_ENCODING);
 467 
 468                            // if there was a previously set OutputStream
 469                            OutputStream os = getOutputStream();
 470                            if (os != null) {
 471                                Writer w = getWriter();
 472 
 473                                // If the writer was previously set, but
 474                                // set by the user, or if the new encoding is the same
 475                                // as the old encoding, skip this block
 476                                String oldEncoding = getOutputProperty(OutputKeys.ENCODING);
 477                                if ((w == null || !m_writer_set_by_user)
 478                                        &amp;&amp; !newEncoding.equalsIgnoreCase(oldEncoding)) {
 479                                    // Make the change of encoding in our internal
 480                                    // table, then call setOutputStreamInternal
 481                                    // which will stomp on the old Writer (if any)
 482                                    // with a new Writer with the new encoding.
 483                                    super.setProp(name, val, defaultVal);
 484                                    setOutputStreamInternal(os,false);
 485                                }
 486                            }
 487                        }
 488                     }
 489                 }
 490                 break;
 491             case &#39;i&#39;:
 492                 if (OutputPropertiesFactory.S_KEY_INDENT_AMOUNT.equals(name)) {
 493                     setIndentAmount(Integer.parseInt(val));
 494                 } else if (OutputKeys.INDENT.equals(name)) {
 495                     boolean b = val.endsWith(&quot;yes&quot;) ? true : false;
 496                     m_doIndent = b;
 497                 }
 498 
 499                 break;
 500             case &#39;l&#39;:
 501                 if (OutputPropertiesFactory.S_KEY_LINE_SEPARATOR.equals(name)) {
 502                     m_lineSep = val.toCharArray();
 503                     m_lineSepLen = m_lineSep.length;
 504                 }
 505 
 506                 break;
 507             case &#39;m&#39;:
 508                 if (OutputKeys.MEDIA_TYPE.equals(name)) {
 509                     m_mediatype = val;
 510                 }
 511                 break;
 512             case &#39;o&#39;:
 513                 if (OutputKeys.OMIT_XML_DECLARATION.equals(name)) {
 514                     boolean b = val.endsWith(&quot;yes&quot;) ? true : false;
 515                     this.m_shouldNotWriteXMLHeader = b;
 516                 }
 517                 break;
 518             case &#39;s&#39;:
 519                 // if standalone was explicitly specified
 520                 if (OutputKeys.STANDALONE.equals(name)) {
 521                     if (defaultVal) {
 522                         setStandaloneInternal(val);
 523                     } else {
 524                         m_standaloneWasSpecified = true;
 525                         setStandaloneInternal(val);
 526                     }
 527                 }
 528 
 529                 break;
 530             case &#39;v&#39;:
 531                 if (OutputKeys.VERSION.equals(name)) {
 532                     m_version = val;
 533                 }
 534                 break;
 535             default:
 536                 break;
 537 
 538             }
 539             super.setProp(name, val, defaultVal);
 540         }
 541     }
 542 
 543     /**
 544      * Specifies an output format for this serializer. It the
 545      * serializer has already been associated with an output format,
 546      * it will switch to the new format. This method should not be
 547      * called while the serializer is in the process of serializing
 548      * a document.
 549      *
 550      * @param format The output format to use
 551      */
 552     public void setOutputFormat(Properties format) {
 553         boolean shouldFlush = m_shouldFlush;
 554 
 555         if (format != null) {
 556             // Set the default values first,
 557             // and the non-default values after that,
 558             // just in case there is some unexpected
 559             // residual values left over from over-ridden default values
 560             Enumeration&lt;?&gt; propNames;
 561             propNames = format.propertyNames();
 562             while (propNames.hasMoreElements()) {
 563                 String key = (String) propNames.nextElement();
 564                 // Get the value, possibly a default value
 565                 String value = format.getProperty(key);
 566                 // Get the non-default value (if any).
 567                 String explicitValue = (String) format.get(key);
 568                 if (explicitValue == null &amp;&amp; value != null) {
 569                     // This is a default value
 570                     this.setOutputPropertyDefault(key,value);
 571                 }
 572                 if (explicitValue != null) {
 573                     // This is an explicit non-default value
 574                     this.setOutputProperty(key,explicitValue);
 575                 }
 576             }
 577         }
 578 
 579         // Access this only from the Hashtable level... we don&#39;t want to
 580         // get default properties.
 581         String entitiesFileName =
 582             (String) format.get(OutputPropertiesFactory.S_KEY_ENTITIES);
 583 
 584         if (null != entitiesFileName) {
 585             String method = (String) format.get(OutputKeys.METHOD);
 586             m_charInfo = CharInfo.getCharInfo(entitiesFileName, method);
 587         }
 588 
 589         m_shouldFlush = shouldFlush;
 590     }
 591 
 592     /**
 593      * Returns the output format for this serializer.
 594      *
 595      * @return The output format in use
 596      */
 597     public Properties getOutputFormat() {
 598         Properties def = new Properties();
 599         {
 600             Set&lt;String&gt; s = getOutputPropDefaultKeys();
 601             for (String key : s) {
 602                 String val = getOutputPropertyDefault(key);
 603                 def.put(key, val);
 604             }
 605         }
 606 
 607         Properties props = new Properties(def);
 608         {
 609             Set&lt;String&gt; s = getOutputPropKeys();
 610             for (String key : s) {
 611                 String val = getOutputPropertyNonDefault(key);
 612                 if (val != null)
 613                     props.put(key, val);
 614             }
 615         }
 616         return props;
 617     }
 618 
 619     /**
 620      * Specifies a writer to which the document should be serialized.
 621      * This method should not be called while the serializer is in
 622      * the process of serializing a document.
 623      *
 624      * @param writer The output writer stream
 625      */
 626     public void setWriter(Writer writer) {
 627         setWriterInternal(writer, true);
 628     }
 629 
 630     private boolean m_writer_set_by_user;
 631     private void setWriterInternal(Writer writer, boolean setByUser) {
 632         m_writer_set_by_user = setByUser;
 633         m_writer = writer;
 634         // if we are tracing events we need to trace what
 635         // characters are written to the output writer.
 636         if (m_tracer != null) {
 637             boolean noTracerYet = true;
 638             Writer w2 = m_writer;
 639             while (w2 instanceof WriterChain) {
 640                 if (w2 instanceof SerializerTraceWriter) {
 641                     noTracerYet = false;
 642                     break;
 643                 }
 644                 w2 = ((WriterChain)w2).getWriter();
 645             }
 646             if (noTracerYet)
 647                 m_writer = new SerializerTraceWriter(m_writer, m_tracer);
 648         }
 649     }
 650 
 651     /**
 652      * Set if the operating systems end-of-line line separator should
 653      * be used when serializing.  If set false NL character
 654      * (decimal 10) is left alone, otherwise the new-line will be replaced on
 655      * output with the systems line separator. For example on UNIX this is
 656      * NL, while on Windows it is two characters, CR NL, where CR is the
 657      * carriage-return (decimal 13).
 658      *
 659      * @param use_sytem_line_break True if an input NL is replaced with the
 660      * operating systems end-of-line separator.
 661      * @return The previously set value of the serializer.
 662      */
 663     public boolean setLineSepUse(boolean use_sytem_line_break) {
 664         boolean oldValue = m_lineSepUse;
 665         m_lineSepUse = use_sytem_line_break;
 666         return oldValue;
 667     }
 668 
 669     /**
 670      * Specifies an output stream to which the document should be
 671      * serialized. This method should not be called while the
 672      * serializer is in the process of serializing a document.
 673      * &lt;p&gt;
 674      * The encoding specified in the output properties is used, or
 675      * if no encoding was specified, the default for the selected
 676      * output method.
 677      *
 678      * @param output The output stream
 679      */
 680     public void setOutputStream(OutputStream output) {
 681         setOutputStreamInternal(output, true);
 682     }
 683 
 684     private void setOutputStreamInternal(OutputStream output, boolean setByUser)
 685     {
 686         m_outputStream = output;
 687         String encoding = getOutputProperty(OutputKeys.ENCODING);
 688         if (Encodings.DEFAULT_MIME_ENCODING.equalsIgnoreCase(encoding))
 689         {
 690             // We wrap the OutputStream with a writer, but
 691             // not one set by the user
 692             try {
 693                 setWriterInternal(new WriterToUTF8Buffered(output), false);
 694             } catch (UnsupportedEncodingException e) {
 695                 e.printStackTrace();
 696             }
 697         } else if (
 698                 &quot;WINDOWS-1250&quot;.equals(encoding)
 699                 || &quot;US-ASCII&quot;.equals(encoding)
 700                 || &quot;ASCII&quot;.equals(encoding))
 701         {
 702             setWriterInternal(new WriterToASCI(output), false);
 703         } else if (encoding != null) {
 704             Writer osw = null;
 705                 try
 706                 {
 707                     osw = Encodings.getWriter(output, encoding);
 708                 }
 709                 catch (UnsupportedEncodingException uee)
 710                 {
 711                     osw = null;
 712                 }
 713 
 714 
 715             if (osw == null) {
 716                 System.out.println(
 717                     &quot;Warning: encoding \&quot;&quot;
 718                         + encoding
 719                         + &quot;\&quot; not supported&quot;
 720                         + &quot;, using &quot;
 721                         + Encodings.DEFAULT_MIME_ENCODING);
 722 
 723                 encoding = Encodings.DEFAULT_MIME_ENCODING;
 724                 setEncoding(encoding);
 725                 try {
 726                     osw = Encodings.getWriter(output, encoding);
 727                 } catch (UnsupportedEncodingException e) {
 728                     // We can&#39;t really get here, UTF-8 is always supported
 729                     // This try-catch exists to make the compiler happy
 730                     e.printStackTrace();
 731                 }
 732             }
 733             setWriterInternal(osw,false);
 734         }
 735         else {
 736             // don&#39;t have any encoding, but we have an OutputStream
 737             Writer osw = new OutputStreamWriter(output);
 738             setWriterInternal(osw,false);
 739         }
 740     }
 741 
 742 
 743     /**
 744      * @see SerializationHandler#setEscaping(boolean)
 745      */
 746     public boolean setEscaping(boolean escape)
 747     {
 748         final boolean temp = m_escaping;
 749         m_escaping = escape;
 750         return temp;
 751 
 752     }
 753 
 754 
 755     /**
 756      * Might print a newline character and the indentation amount
 757      * of the given depth.
 758      *
 759      * @param depth the indentation depth (element nesting depth)
 760      *
 761      * @throws org.xml.sax.SAXException if an error occurs during writing.
 762      */
 763     protected void indent(int depth) throws IOException
 764     {
 765 
 766         if (m_startNewLine)
 767             outputLineSep();
 768         /*
 769          * Default value is 4, so printSpace directly.
 770          */
 771         printSpace(depth * m_indentAmount);
 772 
 773     }
 774 
 775     /**
 776      * Indent at the current element nesting depth.
 777      * @throws IOException
 778      */
 779     protected void indent() throws IOException
 780     {
 781         indent(m_elemContext.m_currentElemDepth);
 782     }
 783     /**
 784      * Prints &lt;var&gt;n&lt;/var&gt; spaces.
 785      * @param n         Number of spaces to print.
 786      *
 787      * @throws org.xml.sax.SAXException if an error occurs when writing.
 788      */
 789     private void printSpace(int n) throws IOException
 790     {
 791         final Writer writer = m_writer;
 792         for (int i = 0; i &lt; n; i++)
 793         {
 794             writer.write(&#39; &#39;);
 795         }
 796 
 797     }
 798 
 799     /**
 800      * Report an attribute type declaration.
 801      *
 802      * &lt;p&gt;Only the effective (first) declaration for an attribute will
 803      * be reported.  The type will be one of the strings &quot;CDATA&quot;,
 804      * &quot;ID&quot;, &quot;IDREF&quot;, &quot;IDREFS&quot;, &quot;NMTOKEN&quot;, &quot;NMTOKENS&quot;, &quot;ENTITY&quot;,
 805      * &quot;ENTITIES&quot;, or &quot;NOTATION&quot;, or a parenthesized token group with
 806      * the separator &quot;|&quot; and all whitespace removed.&lt;/p&gt;
 807      *
 808      * @param eName The name of the associated element.
 809      * @param aName The name of the attribute.
 810      * @param type A string representing the attribute type.
 811      * @param valueDefault A string representing the attribute default
 812      *        (&quot;#IMPLIED&quot;, &quot;#REQUIRED&quot;, or &quot;#FIXED&quot;) or null if
 813      *        none of these applies.
 814      * @param value A string representing the attribute&#39;s default value,
 815      *        or null if there is none.
 816      * @exception SAXException The application may raise an exception.
 817      */
 818     public void attributeDecl(
 819         String eName,
 820         String aName,
 821         String type,
 822         String valueDefault,
 823         String value)
 824         throws SAXException
 825     {
 826         // Do not inline external DTD
 827         if (m_inExternalDTD)
 828             return;
 829         try
 830         {
 831             final Writer writer = m_writer;
 832             DTDprolog();
 833 
 834             writer.write(&quot;&lt;!ATTLIST &quot;);
 835             writer.write(eName);
 836             writer.write(&#39; &#39;);
 837 
 838             writer.write(aName);
 839             writer.write(&#39; &#39;);
 840             writer.write(type);
 841             if (valueDefault != null)
 842             {
 843                 writer.write(&#39; &#39;);
 844                 writer.write(valueDefault);
 845             }
 846 
 847             //writer.write(&quot; &quot;);
 848             //writer.write(value);
 849             writer.write(&#39;&gt;&#39;);
 850             writer.write(m_lineSep, 0, m_lineSepLen);
 851         }
 852         catch (IOException e)
 853         {
 854             throw new SAXException(e);
 855         }
 856     }
 857 
 858     /**
 859      * Get the character stream where the events will be serialized to.
 860      *
 861      * @return Reference to the result Writer, or null.
 862      */
 863     public Writer getWriter()
 864     {
 865         return m_writer;
 866     }
 867 
 868     /**
 869      * Report a parsed external entity declaration.
 870      *
 871      * &lt;p&gt;Only the effective (first) declaration for each entity
 872      * will be reported.&lt;/p&gt;
 873      *
 874      * @param name The name of the entity.  If it is a parameter
 875      *        entity, the name will begin with &#39;%&#39;.
 876      * @param publicId The declared public identifier of the entity, or
 877      *        null if none was declared.
 878      * @param systemId The declared system identifier of the entity.
 879      * @exception SAXException The application may raise an exception.
 880      * @see #internalEntityDecl
 881      * @see org.xml.sax.DTDHandler#unparsedEntityDecl
 882      */
 883     public void externalEntityDecl(
 884         String name,
 885         String publicId,
 886         String systemId)
 887         throws SAXException
 888     {
 889         try {
 890             DTDprolog();
 891 
 892             m_writer.write(&quot;&lt;!ENTITY &quot;);
 893             m_writer.write(name);
 894             if (publicId != null) {
 895                 m_writer.write(&quot; PUBLIC \&quot;&quot;);
 896                 m_writer.write(publicId);
 897 
 898             }
 899             else {
 900                 m_writer.write(&quot; SYSTEM \&quot;&quot;);
 901                 m_writer.write(systemId);
 902             }
 903             m_writer.write(&quot;\&quot; &gt;&quot;);
 904             m_writer.write(m_lineSep, 0, m_lineSepLen);
 905         } catch (IOException e) {
 906             // TODO Auto-generated catch block
 907             e.printStackTrace();
 908         }
 909 
 910     }
 911 
 912     /**
 913      * Tell if this character can be written without escaping.
 914      */
 915     protected boolean escapingNotNeeded(char ch)
 916     {
 917         final boolean ret;
 918         if (ch &lt; 127)
 919         {
 920             // This is the old/fast code here, but is this
 921             // correct for all encodings?
 922             if (ch &gt;= 0x20 || (0x0A == ch || 0x0D == ch || 0x09 == ch))
 923                 ret= true;
 924             else
 925                 ret = false;
 926         }
 927         else {
 928             ret = m_encodingInfo.isInEncoding(ch);
 929         }
 930         return ret;
 931     }
 932 
 933     /**
 934      * Once a surrogate has been detected, write out the pair of
 935      * characters if it is in the encoding, or if there is no
 936      * encoding, otherwise write out an entity reference
 937      * of the value of the unicode code point of the character
 938      * represented by the high/low surrogate pair.
 939      * &lt;p&gt;
 940      * An exception is thrown if there is no low surrogate in the pair,
 941      * because the array ends unexpectely, or if the low char is there
 942      * but its value is such that it is not a low surrogate.
 943      *
 944      * @param c the first (high) part of the surrogate, which
 945      * must be confirmed before calling this method.
 946      * @param ch Character array.
 947      * @param i position Where the surrogate was detected.
 948      * @param end The end index of the significant characters.
 949      * @return the status of writing a surrogate pair.
 950      *        -1 -- nothing is written
 951      *         0 -- the pair is written as-is
 952      *         code point -- the pair is written as an entity reference
 953      *
 954      * @throws IOException
 955      * @throws org.xml.sax.SAXException if invalid UTF-16 surrogate detected.
 956      */
 957     protected int writeUTF16Surrogate(char c, char ch[], int i, int end)
 958         throws IOException, SAXException
 959     {
 960         int status = -1;
 961         if (i + 1 &gt;= end)
 962         {
 963             m_highSurrogate = c;
 964             return status;
 965         }
 966 
 967         char high, low;
 968         if (m_highSurrogate == 0) {
 969             high = c;
 970             low = ch[i+1];
 971             status = 0;
 972         } else {
 973             high = m_highSurrogate;
 974             low = c;
 975             m_highSurrogate = 0;
 976         }
 977 
 978         if (!Encodings.isLowUTF16Surrogate(low)) {
 979             throwIOE(high, low);
 980         }
 981 
 982         final Writer writer = m_writer;
 983 
 984         // If we make it to here we have a valid high, low surrogate pair
 985         if (m_encodingInfo.isInEncoding(high,low)) {
 986             // If the character formed by the surrogate pair
 987             // is in the encoding, so just write it out
 988             writer.write(new char[]{high, low}, 0, 2);
 989         }
 990         else {
 991             // Don&#39;t know what to do with this char, it is
 992             // not in the encoding and not a high char in
 993             // a surrogate pair, so write out as an entity ref
 994             final String encoding = getEncoding();
 995             if (encoding != null) {
 996                 status = writeCharRef(writer, high, low);
 997             } else {
 998                 /* The output encoding is not known,
 999                  * so just write it out as-is.
1000                  */
1001                 writer.write(new char[]{high, low}, 0, 2);
1002             }
1003         }
1004         // non-zero only if character reference was written out.
1005         return status;
1006     }
1007 
1008     /**
1009      * Handle one of the default entities, return false if it
1010      * is not a default entity.
1011      *
1012      * @param ch character to be escaped.
1013      * @param i index into character array.
1014      * @param chars non-null reference to character array.
1015      * @param len length of chars.
1016      * @param fromTextNode true if the characters being processed
1017      * are from a text node, false if they are from an attribute value
1018      * @param escLF true if the linefeed should be escaped.
1019      *
1020      * @return i+1 if the character was written, else i.
1021      *
1022      * @throws java.io.IOException
1023      */
1024     protected int accumDefaultEntity(
1025         Writer writer,
1026         char ch,
1027         int i,
1028         char[] chars,
1029         int len,
1030         boolean fromTextNode,
1031         boolean escLF)
1032         throws IOException
1033     {
1034 
1035         if (!escLF &amp;&amp; CharInfo.S_LINEFEED == ch)
1036         {
1037             writer.write(m_lineSep, 0, m_lineSepLen);
1038         }
1039         else
1040         {
1041             // if this is text node character and a special one of those,
1042             // or if this is a character from attribute value and a special one of those
1043             if ((fromTextNode &amp;&amp; m_charInfo.isSpecialTextChar(ch)) || (!fromTextNode &amp;&amp; m_charInfo.isSpecialAttrChar(ch)))
1044             {
1045                 String outputStringForChar = m_charInfo.getOutputStringForChar(ch);
1046 
1047                 if (null != outputStringForChar)
1048                 {
1049                     writer.write(outputStringForChar);
1050                 }
1051                 else
1052                     return i;
1053             }
1054             else
1055                 return i;
1056         }
1057 
1058         return i + 1;
1059 
1060     }
1061     /**
1062      * Normalize the characters, but don&#39;t escape.
1063      *
1064      * @param ch The characters from the XML document.
1065      * @param start The start position in the array.
1066      * @param length The number of characters to read from the array.
1067      * @param isCData true if a CDATA block should be built around the characters.
1068      * @param useSystemLineSeparator true if the operating systems
1069      * end-of-line separator should be output rather than a new-line character.
1070      *
1071      * @throws IOException
1072      * @throws org.xml.sax.SAXException
1073      */
1074     void writeNormalizedChars(
1075         char ch[],
1076         int start,
1077         int length,
1078         boolean isCData,
1079         boolean useSystemLineSeparator)
1080         throws IOException, org.xml.sax.SAXException
1081     {
1082         final Writer writer = m_writer;
1083         int end = start + length;
1084 
1085         for (int i = start; i &lt; end; i++)
1086         {
1087             char c = ch[i];
1088 
1089             if (CharInfo.S_LINEFEED == c &amp;&amp; useSystemLineSeparator)
1090             {
1091                 writer.write(m_lineSep, 0, m_lineSepLen);
1092             }
1093             else if (isCData &amp;&amp; (!escapingNotNeeded(c)))
1094             {
1095                 i = handleEscaping(writer, c, ch, i, end);
1096             }
1097             else if (
1098                 isCData
1099                     &amp;&amp; ((i &lt; (end - 2))
1100                         &amp;&amp; (&#39;]&#39; == c)
1101                         &amp;&amp; (&#39;]&#39; == ch[i + 1])
1102                         &amp;&amp; (&#39;&gt;&#39; == ch[i + 2])))
1103             {
1104                 writer.write(CDATA_CONTINUE);
1105 
1106                 i += 2;
1107             }
1108             else
1109             {
1110                 if (escapingNotNeeded(c))
1111                 {
1112                     if (isCData &amp;&amp; !m_cdataTagOpen)
1113                     {
1114                         writer.write(CDATA_DELIMITER_OPEN);
1115                         m_cdataTagOpen = true;
1116                     }
1117                     writer.write(c);
1118                 }
1119                 else {
1120                     i = handleEscaping(writer, c, ch, i, end);
1121                 }
1122             }
1123         }
1124 
1125     }
1126 
1127     /**
1128      * Handles escaping, writes either with a surrogate pair or a character
1129      * reference.
1130      *
1131      * @param c the current char
1132      * @param ch the character array
1133      * @param i the current position
1134      * @param end the end index of the array
1135      * @return the next index
1136      *
1137      * @throws IOException
1138      * @throws org.xml.sax.SAXException if invalid UTF-16 surrogate detected.
1139      */
1140     private int handleEscaping(Writer writer, char c, char ch[], int i, int end)
1141             throws IOException, SAXException {
1142         if (Encodings.isHighUTF16Surrogate(c) || Encodings.isLowUTF16Surrogate(c))
1143         {
1144             if (writeUTF16Surrogate(c, ch, i, end) &gt;= 0) {
1145                 // move the index if the low surrogate is consumed
1146                 // as writeUTF16Surrogate has written the pair
1147                 if (Encodings.isHighUTF16Surrogate(c)) {
1148                     i++ ;
1149                 }
1150             }
1151         }
1152         else
1153         {
1154             writeCharRef(writer, c);
1155         }
1156         return i;
1157     }
1158 
1159     /**
1160      * Ends an un-escaping section.
1161      *
1162      * @see #startNonEscaping
1163      *
1164      * @throws org.xml.sax.SAXException
1165      */
1166     public void endNonEscaping() throws org.xml.sax.SAXException
1167     {
1168         m_disableOutputEscapingStates.pop();
1169     }
1170 
1171     /**
1172      * Starts an un-escaping section. All characters printed within an un-
1173      * escaping section are printed as is, without escaping special characters
1174      * into entity references. Only XML and HTML serializers need to support
1175      * this method.
1176      * &lt;p&gt; The contents of the un-escaping section will be delivered through the
1177      * regular &lt;tt&gt;characters&lt;/tt&gt; event.
1178      *
1179      * @throws org.xml.sax.SAXException
1180      */
1181     public void startNonEscaping() throws org.xml.sax.SAXException
1182     {
1183         m_disableOutputEscapingStates.push(true);
1184     }
1185 
1186     /**
1187      * Receive notification of cdata.
1188      *
1189      * &lt;p&gt;The Parser will call this method to report each chunk of
1190      * character data.  SAX parsers may return all contiguous character
1191      * data in a single chunk, or they may split it into several
1192      * chunks; however, all of the characters in any single event
1193      * must come from the same external entity, so that the Locator
1194      * provides useful information.&lt;/p&gt;
1195      *
1196      * &lt;p&gt;The application must not attempt to read from the array
1197      * outside of the specified range.&lt;/p&gt;
1198      *
1199      * &lt;p&gt;Note that some parsers will report whitespace using the
1200      * ignorableWhitespace() method rather than this one (validating
1201      * parsers must do so).&lt;/p&gt;
1202      *
1203      * @param ch The characters from the XML document.
1204      * @param start The start position in the array.
1205      * @param length The number of characters to read from the array.
1206      * @throws org.xml.sax.SAXException Any SAX exception, possibly
1207      *            wrapping another exception.
1208      * @see #ignorableWhitespace
1209      * @see org.xml.sax.Locator
1210      *
1211      * @throws org.xml.sax.SAXException
1212      */
1213     protected void cdata(char ch[], int start, final int length)
1214         throws org.xml.sax.SAXException
1215     {
1216         try
1217         {
1218             final int old_start = start;
1219             if (m_elemContext.m_startTagOpen)
1220             {
1221                 closeStartTag();
1222                 m_elemContext.m_startTagOpen = false;
1223             }
1224 
1225             if (!m_cdataTagOpen &amp;&amp; shouldIndentForText())
1226                 indent();
1227 
1228             boolean writeCDataBrackets =
1229                 (((length &gt;= 1) &amp;&amp; escapingNotNeeded(ch[start])));
1230 
1231             /* Write out the CDATA opening delimiter only if
1232              * we are supposed to, and if we are not already in
1233              * the middle of a CDATA section
1234              */
1235             if (writeCDataBrackets &amp;&amp; !m_cdataTagOpen)
1236             {
1237                 m_writer.write(CDATA_DELIMITER_OPEN);
1238                 m_cdataTagOpen = true;
1239             }
1240 
1241             // writer.write(ch, start, length);
1242             if (isEscapingDisabled())
1243             {
1244                 charactersRaw(ch, start, length);
1245             }
1246             else
1247                 writeNormalizedChars(ch, start, length, true, m_lineSepUse);
1248 
1249             /* used to always write out CDATA closing delimiter here,
1250              * but now we delay, so that we can merge CDATA sections on output.
1251              * need to write closing delimiter later
1252              */
1253             if (writeCDataBrackets)
1254             {
1255                 /* if the CDATA section ends with ] don&#39;t leave it open
1256                  * as there is a chance that an adjacent CDATA sections
1257                  * starts with ]&gt;.
1258                  * We don&#39;t want to merge ]] with &gt; , or ] with ]&gt;
1259                  */
1260                 if (ch[start + length - 1] == &#39;]&#39;)
1261                     closeCDATA();
1262             }
1263 
1264             m_isprevtext = true;
1265             // time to fire off CDATA event
1266             if (m_tracer != null)
1267                 super.fireCDATAEvent(ch, old_start, length);
1268         }
1269         catch (IOException ioe)
1270         {
1271             throw new org.xml.sax.SAXException(
1272                 Utils.messages.createMessage(
1273                     MsgKey.ER_OIERROR,
1274                     null),
1275                 ioe);
1276             //&quot;IO error&quot;, ioe);
1277         }
1278     }
1279 
1280     /**
1281      * Tell if the character escaping should be disabled for the current state.
1282      *
1283      * @return true if the character escaping should be disabled.
1284      */
1285     private boolean isEscapingDisabled()
1286     {
1287         return m_disableOutputEscapingStates.peekOrFalse();
1288     }
1289 
1290     /**
1291      * If available, when the disable-output-escaping attribute is used,
1292      * output raw text without escaping.
1293      *
1294      * @param ch The characters from the XML document.
1295      * @param start The start position in the array.
1296      * @param length The number of characters to read from the array.
1297      *
1298      * @throws org.xml.sax.SAXException
1299      */
1300     protected void charactersRaw(char ch[], int start, int length)
1301         throws org.xml.sax.SAXException
1302     {
1303 
1304         if (isInEntityRef())
1305             return;
1306         try
1307         {
1308             if (m_elemContext.m_startTagOpen)
1309             {
1310                 closeStartTag();
1311                 m_elemContext.m_startTagOpen = false;
1312             }
1313 
1314             m_writer.write(ch, start, length);
1315         }
1316         catch (IOException e)
1317         {
1318             throw new SAXException(e);
1319         }
1320 
1321     }
1322 
1323     /**
1324      * Receive notification of character data.
1325      *
1326      * &lt;p&gt;The Parser will call this method to report each chunk of
1327      * character data.  SAX parsers may return all contiguous character
1328      * data in a single chunk, or they may split it into several
1329      * chunks; however, all of the characters in any single event
1330      * must come from the same external entity, so that the Locator
1331      * provides useful information.&lt;/p&gt;
1332      *
1333      * &lt;p&gt;The application must not attempt to read from the array
1334      * outside of the specified range.&lt;/p&gt;
1335      *
1336      * &lt;p&gt;Note that some parsers will report whitespace using the
1337      * ignorableWhitespace() method rather than this one (validating
1338      * parsers must do so).&lt;/p&gt;
1339      *
1340      * @param chars The characters from the XML document.
1341      * @param start The start position in the array.
1342      * @param length The number of characters to read from the array.
1343      * @throws org.xml.sax.SAXException Any SAX exception, possibly
1344      *            wrapping another exception.
1345      * @see #ignorableWhitespace
1346      * @see org.xml.sax.Locator
1347      *
1348      * @throws org.xml.sax.SAXException
1349      */
1350     public void characters(final char chars[], final int start, final int length)
1351         throws org.xml.sax.SAXException
1352     {
1353         // It does not make sense to continue with rest of the method if the number of
1354         // characters to read from array is 0.
1355         // Section 7.6.1 of XSLT 1.0 (http://www.w3.org/TR/xslt#value-of) suggest no text node
1356         // is created if string is empty.
1357         if (length == 0 || (isInEntityRef()))
1358             return;
1359 
1360         final boolean shouldNotFormat = !shouldFormatOutput();
1361         if (m_elemContext.m_startTagOpen)
1362         {
1363             closeStartTag();
1364             m_elemContext.m_startTagOpen = false;
1365         }
1366         else if (m_needToCallStartDocument)
1367         {
1368             startDocumentInternal();
1369         }
1370 
1371         if (m_cdataStartCalled || m_elemContext.m_isCdataSection)
1372         {
1373             /* either due to startCDATA() being called or due to
1374              * cdata-section-elements atribute, we need this as cdata
1375              */
1376             cdata(chars, start, length);
1377 
1378             return;
1379         }
1380 
1381         if (m_cdataTagOpen)
1382             closeCDATA();
1383         // the check with _escaping is a bit of a hack for XLSTC
1384 
1385         if (m_disableOutputEscapingStates.peekOrFalse() || (!m_escaping))
1386         {
1387             if (shouldNotFormat) {
1388                 charactersRaw(chars, start, length);
1389                 m_isprevtext = true;
1390             } else {
1391                 m_charactersBuffer.addRawText(chars, start, length);
1392             }
1393             // time to fire off characters generation event
1394             if (m_tracer != null)
1395                 super.fireCharEvent(chars, start, length);
1396 
1397             return;
1398         }
1399 
1400         if (m_elemContext.m_startTagOpen)
1401         {
1402             closeStartTag();
1403             m_elemContext.m_startTagOpen = false;
1404         }
1405 
1406         if (shouldNotFormat) {
1407             outputCharacters(chars, start, length);
1408         } else {
1409             m_charactersBuffer.addText(chars, start, length);
1410         }
1411 
1412         // time to fire off characters generation event
1413         if (m_tracer != null)
1414             super.fireCharEvent(chars, start, length);
1415     }
1416 
1417 
1418     /**
1419      * This method checks if the content in current element should be formatted.
1420      *
1421      * @return True if the content should be formatted.
1422      */
1423     protected boolean shouldFormatOutput() {
1424         return m_doIndent &amp;&amp; !m_ispreserveSpace;
1425     }
1426 
1427     /**
1428      * @return True if the content in current element should be formatted.
1429      */
1430     public boolean getIndent() {
1431         return shouldFormatOutput();
1432     }
1433 
1434     /**
1435      * Write out the characters.
1436      *
1437      * @param chars The characters of the text.
1438      * @param start The start position in the char array.
1439      * @param length The number of characters from the char array.
1440      */
1441     private void outputCharacters(final char chars[], final int start, final int length) throws SAXException {
1442         try
1443         {
1444             int i;
1445             char ch1;
1446             int startClean;
1447 
1448             // skip any leading whitspace
1449             // don&#39;t go off the end and use a hand inlined version
1450             // of isWhitespace(ch)
1451             final int end = start + length;
1452             int lastDirty = start - 1; // last character that needed processing
1453             for (i = start;
1454                 ((i &lt; end)
1455                     &amp;&amp; ((ch1 = chars[i]) == 0x20
1456                         || (ch1 == 0xA &amp;&amp; m_lineSepUse)
1457                         || ch1 == 0xD
1458                         || ch1 == 0x09));
1459                 i++)
1460             {
1461                 /*
1462                  * We are processing leading whitespace, but are doing the same
1463                  * processing for dirty characters here as for non-whitespace.
1464                  *
1465                  */
1466                 if (!m_charInfo.isTextASCIIClean(ch1))
1467                 {
1468                     lastDirty = processDirty(chars,end, i,ch1, lastDirty, true);
1469                     i = lastDirty;
1470                 }
1471             }
1472 
1473 //          int lengthClean;    // number of clean characters in a row
1474 //          final boolean[] isAsciiClean = m_charInfo.getASCIIClean();
1475 
1476             final boolean isXML10 = XMLVERSION10.equals(getVersion());
1477             // we&#39;ve skipped the leading whitespace, now deal with the rest
1478             for (; i &lt; end; i++)
1479             {
1480                 {
1481                     // A tight loop to skip over common clean chars
1482                     // This tight loop makes it easier for the JIT
1483                     // to optimize.
1484                     char ch2;
1485                     while (i&lt;end
1486                             &amp;&amp; ((ch2 = chars[i])&lt;127)
1487                             &amp;&amp; m_charInfo.isTextASCIIClean(ch2))
1488                             i++;
1489                     if (i == end)
1490                         break;
1491                 }
1492 
1493                 final char ch = chars[i];
1494                 /*  The check for isCharacterInC0orC1Ranger and
1495                  *  isNELorLSEPCharacter has been added
1496                  *  to support Control Characters in XML 1.1
1497                  */
1498                 if (!isCharacterInC0orC1Range(ch) &amp;&amp;
1499                     (isXML10 || !isNELorLSEPCharacter(ch)) &amp;&amp;
1500                     (escapingNotNeeded(ch) &amp;&amp; (!m_charInfo.isSpecialTextChar(ch)))
1501                         || (&#39;&quot;&#39; == ch))
1502                 {
1503                     ; // a character needing no special processing
1504                 }
1505                 else
1506                 {
1507                     lastDirty = processDirty(chars,end, i, ch, lastDirty, true);
1508                     i = lastDirty;
1509                 }
1510             }
1511 
1512             // we&#39;ve reached the end. Any clean characters at the
1513             // end of the array than need to be written out?
1514             startClean = lastDirty + 1;
1515             if (i &gt; startClean)
1516             {
1517                 int lengthClean = i - startClean;
1518                 m_writer.write(chars, startClean, lengthClean);
1519             }
1520 
1521             // For indentation purposes, mark that we&#39;ve just writen text out
1522             m_isprevtext = true;
1523         }
1524         catch (IOException e)
1525         {
1526             throw new SAXException(e);
1527         }
1528     }
1529 
1530     /**
1531      * Flushes the buffered characters when indentation is on. This method
1532      * is called before the next node is traversed.
1533      *
1534      * @param isText indicates whether the node to be traversed is text
1535      * @throws org.xml.sax.SAXException
1536      */
1537     final protected void flushCharactersBuffer(boolean isText) throws SAXException {
1538         try {
1539             if (shouldFormatOutput() &amp;&amp; m_charactersBuffer.isAnyCharactersBuffered()) {
1540                 if (m_elemContext.m_isCdataSection) {
1541                     /*
1542                      * due to cdata-section-elements atribute, we need this as
1543                      * cdata
1544                      */
1545                     char[] chars = m_charactersBuffer.toChars();
1546                     cdata(chars, 0, chars.length);
1547                     return;
1548                 }
1549 
1550                 if (!isText) {
1551                     m_childNodeNum++;
1552                 }
1553                 boolean skipBeginningNewlines = false;
1554                 if (shouldIndentForText()) {
1555                     indent();
1556                     m_startNewLine = true;
1557                     // newline has always been added here because if this is the
1558                     // text before the first element, shouldIndent() won&#39;t
1559                     // return true.
1560                     skipBeginningNewlines = true;
1561                 }
1562                 m_charactersBuffer.flush(skipBeginningNewlines);
1563             }
1564         } catch (IOException e) {
1565             throw new SAXException(e);
1566         } finally {
1567             m_charactersBuffer.clear();
1568         }
1569     }
1570 
1571     /**
1572      * True if should indent in flushCharactersBuffer method.
1573      * This method may be overridden in sub-class.
1574      *
1575      */
1576     protected boolean shouldIndentForText() {
1577         return (shouldIndent() &amp;&amp; m_childNodeNum &gt; 1);
1578     }
1579 
1580     /**
1581      * This method checks if a given character is between C0 or C1 range
1582      * of Control characters.
1583      * This method is added to support Control Characters for XML 1.1
1584      * If a given character is TAB (0x09), LF (0x0A) or CR (0x0D), this method
1585      * return false. Since they are whitespace characters, no special processing is needed.
1586      *
1587      * @param ch
1588      * @return boolean
1589      */
1590     private static boolean isCharacterInC0orC1Range(char ch)
1591     {
1592         if(ch == 0x09 || ch == 0x0A || ch == 0x0D)
1593                 return false;
1594         else
1595                 return (ch &gt;= 0x7F &amp;&amp; ch &lt;= 0x9F)|| (ch &gt;= 0x01 &amp;&amp; ch &lt;= 0x1F);
1596     }
1597     /**
1598      * This method checks if a given character either NEL (0x85) or LSEP (0x2028)
1599      * These are new end of line charcters added in XML 1.1.  These characters must be
1600      * written as Numeric Character References (NCR) in XML 1.1 output document.
1601      *
1602      * @param ch
1603      * @return boolean
1604      */
1605     private static boolean isNELorLSEPCharacter(char ch)
1606     {
1607         return (ch == 0x85 || ch == 0x2028);
1608     }
1609     /**
1610      * Process a dirty character and any preeceding clean characters
1611      * that were not yet processed.
1612      * @param chars array of characters being processed
1613      * @param end one (1) beyond the last character
1614      * in chars to be processed
1615      * @param i the index of the dirty character
1616      * @param ch the character in chars[i]
1617      * @param lastDirty the last dirty character previous to i
1618      * @param fromTextNode true if the characters being processed are
1619      * from a text node, false if they are from an attribute value.
1620      * @return the index of the last character processed
1621      */
1622     private int processDirty(
1623         char[] chars,
1624         int end,
1625         int i,
1626         char ch,
1627         int lastDirty,
1628         boolean fromTextNode) throws IOException, SAXException
1629     {
1630         int startClean = lastDirty + 1;
1631         // if we have some clean characters accumulated
1632         // process them before the dirty one.
1633         if (i &gt; startClean)
1634         {
1635             int lengthClean = i - startClean;
1636             m_writer.write(chars, startClean, lengthClean);
1637         }
1638 
1639         // process the &quot;dirty&quot; character
1640         if (CharInfo.S_LINEFEED == ch &amp;&amp; fromTextNode)
1641         {
1642             m_writer.write(m_lineSep, 0, m_lineSepLen);
1643         }
1644         else
1645         {
1646             startClean =
1647                 accumDefaultEscape(
1648                     m_writer,
1649                     ch,
1650                     i,
1651                     chars,
1652                     end,
1653                     fromTextNode,
1654                     false);
1655             i = startClean - 1;
1656         }
1657         // Return the index of the last character that we just processed
1658         // which is a dirty character.
1659         return i;
1660     }
1661 
1662     /**
1663      * Receive notification of character data.
1664      *
1665      * @param s The string of characters to process.
1666      *
1667      * @throws org.xml.sax.SAXException
1668      */
1669     public void characters(String s) throws org.xml.sax.SAXException
1670     {
1671         if (isInEntityRef())
1672             return;
1673         final int length = s.length();
1674         if (length &gt; m_charsBuff.length)
1675         {
1676             m_charsBuff = new char[length * 2 + 1];
1677         }
1678         s.getChars(0, length, m_charsBuff, 0);
1679         characters(m_charsBuff, 0, length);
1680     }
1681 
1682     /**
1683      * Escape and writer.write a character.
1684      *
1685      * @param ch character to be escaped.
1686      * @param i index into character array.
1687      * @param chars non-null reference to character array.
1688      * @param len length of chars.
1689      * @param fromTextNode true if the characters being processed are
1690      * from a text node, false if the characters being processed are from
1691      * an attribute value.
1692      * @param escLF true if the linefeed should be escaped.
1693      *
1694      * @return i+1 if a character was written, i+2 if two characters
1695      * were written out, else return i.
1696      *
1697      * @throws org.xml.sax.SAXException
1698      */
1699     protected int accumDefaultEscape(
1700         Writer writer,
1701         char ch,
1702         int i,
1703         char[] chars,
1704         int len,
1705         boolean fromTextNode,
1706         boolean escLF)
1707         throws IOException, SAXException
1708     {
1709 
1710         int pos = accumDefaultEntity(writer, ch, i, chars, len, fromTextNode, escLF);
1711 
1712         if (i == pos)
1713         {
1714             if (m_highSurrogate != 0) {
1715                 if (!(Encodings.isLowUTF16Surrogate(ch))) {
1716                     throwIOE(m_highSurrogate, ch);
1717                 }
1718                 writeCharRef(writer, m_highSurrogate, ch);
1719                 m_highSurrogate = 0;
1720                 return ++pos;
1721             }
1722 
1723             if (Encodings.isHighUTF16Surrogate(ch))
1724             {
1725                 if (i + 1 &gt;= len)
1726                 {
1727                     // save for the next read
1728                     m_highSurrogate = ch;
1729                     pos++;
1730                 }
1731                 else
1732                 {
1733                     // the next should be the UTF-16 low surrogate of the hig/low pair.
1734                     char next = chars[++i];
1735                     if (!(Encodings.isLowUTF16Surrogate(next)))
1736                         throwIOE(ch, next);
1737 
1738                     writeCharRef(writer, ch, next);
1739                     pos += 2; // count the two characters that went into writing out this entity
1740                 }
1741             }
1742             else
1743             {
1744                 /*  This if check is added to support control characters in XML 1.1.
1745                  *  If a character is a Control Character within C0 and C1 range, it is desirable
1746                  *  to write it out as Numeric Character Reference(NCR) regardless of XML Version
1747                  *  being used for output document.
1748                  */
1749                 if (isCharacterInC0orC1Range(ch) ||
1750                         (XMLVERSION11.equals(getVersion()) &amp;&amp; isNELorLSEPCharacter(ch)))
1751                 {
1752                     writeCharRef(writer, ch);
1753                 }
1754                 else if ((!escapingNotNeeded(ch) ||
1755                     (  (fromTextNode &amp;&amp; m_charInfo.isSpecialTextChar(ch))
1756                      || (!fromTextNode &amp;&amp; m_charInfo.isSpecialAttrChar(ch))))
1757                      &amp;&amp; m_elemContext.m_currentElemDepth &gt; 0)
1758                 {
1759                     writeCharRef(writer, ch);
1760                 }
1761                 else
1762                 {
1763                     writer.write(ch);
1764                 }
1765                 pos++;  // count the single character that was processed
1766             }
1767 
1768         }
1769         return pos;
1770     }
1771 
1772     /**
1773      * Writes out a character reference.
1774      * @param writer the writer
1775      * @param c the character
1776      * @throws IOException
1777      */
1778     private void writeCharRef(Writer writer, char c) throws IOException, SAXException {
1779         if (m_cdataTagOpen)
1780             closeCDATA();
1781         writer.write(&quot;&amp;#&quot;);
1782         writer.write(Integer.toString(c));
1783         writer.write(&#39;;&#39;);
1784     }
1785 
1786     /**
1787      * Writes out a pair of surrogates as a character reference
1788      * @param writer the writer
1789      * @param high the high surrogate
1790      * @param low the low surrogate
1791      * @throws IOException
1792      */
1793     private int writeCharRef(Writer writer, char high, char low) throws IOException, SAXException {
1794         if (m_cdataTagOpen)
1795             closeCDATA();
1796         // Unicode code point formed from the high/low pair.
1797         int codePoint = Encodings.toCodePoint(high, low);
1798         writer.write(&quot;&amp;#&quot;);
1799         writer.write(Integer.toString(codePoint));
1800         writer.write(&#39;;&#39;);
1801         return codePoint;
1802     }
1803 
1804     private void throwIOE(char ch, char next) throws IOException {
1805         throw new IOException(Utils.messages.createMessage(
1806                 MsgKey.ER_INVALID_UTF16_SURROGATE,
1807                 new Object[] {Integer.toHexString(ch) + &quot; &quot;
1808                         + Integer.toHexString(next)}));
1809     }
1810 
1811     /**
1812      * Receive notification of the beginning of an element, although this is a
1813      * SAX method additional namespace or attribute information can occur before
1814      * or after this call, that is associated with this element.
1815      *
1816      *
1817      * @param namespaceURI The Namespace URI, or the empty string if the
1818      *        element has no Namespace URI or if Namespace
1819      *        processing is not being performed.
1820      * @param localName The local name (without prefix), or the
1821      *        empty string if Namespace processing is not being
1822      *        performed.
1823      * @param name The element type name.
1824      * @param atts The attributes attached to the element, if any.
1825      * @throws org.xml.sax.SAXException Any SAX exception, possibly
1826      *            wrapping another exception.
1827      * @see org.xml.sax.ContentHandler#startElement
1828      * @see org.xml.sax.ContentHandler#endElement
1829      * @see org.xml.sax.AttributeList
1830      *
1831      * @throws org.xml.sax.SAXException
1832      */
1833     public void startElement(
1834         String namespaceURI,
1835         String localName,
1836         String name,
1837         Attributes atts)
1838         throws org.xml.sax.SAXException
1839     {
1840         if (isInEntityRef())
1841             return;
1842 
1843         if (m_doIndent) {
1844             m_childNodeNum++;
1845             flushCharactersBuffer(false);
1846         }
1847 
1848         if (m_needToCallStartDocument)
1849         {
1850             startDocumentInternal();
1851             m_needToCallStartDocument = false;
1852         }
1853         else if (m_cdataTagOpen)
1854             closeCDATA();
1855         try
1856         {
1857             if ((true == m_needToOutputDocTypeDecl)
1858                 &amp;&amp; (null != getDoctypeSystem()))
1859             {
1860                 outputDocTypeDecl(name, true);
1861             }
1862 
1863             m_needToOutputDocTypeDecl = false;
1864 
1865             /* before we over-write the current elementLocalName etc.
1866              * lets close out the old one (if we still need to)
1867              */
1868             if (m_elemContext.m_startTagOpen)
1869             {
1870                 closeStartTag();
1871                 m_elemContext.m_startTagOpen = false;
1872             }
1873 
1874             if (namespaceURI != null)
1875                 ensurePrefixIsDeclared(namespaceURI, name);
1876 
1877             if (shouldIndent() &amp;&amp; m_startNewLine)
1878             {
1879                 indent();
1880             }
1881 
1882             m_startNewLine = true;
1883 
1884             final Writer writer = m_writer;
1885             writer.write(&#39;&lt;&#39;);
1886             writer.write(name);
1887         }
1888         catch (IOException e)
1889         {
1890             throw new SAXException(e);
1891         }
1892 
1893         // process the attributes now, because after this SAX call they might be gone
1894         if (atts != null)
1895             addAttributes(atts);
1896 
1897         if (m_doIndent) {
1898             m_ispreserveSpace = m_preserveSpaces.peekOrFalse();
1899             m_preserveSpaces.push(m_ispreserveSpace);
1900 
1901             m_childNodeNumStack.add(m_childNodeNum);
1902             m_childNodeNum = 0;
1903         }
1904 
1905         m_elemContext = m_elemContext.push(namespaceURI,localName,name);
1906         m_isprevtext = false;
1907 
1908         if (m_tracer != null){
1909             firePseudoAttributes();
1910         }
1911 
1912     }
1913 
1914     /**
1915       * Receive notification of the beginning of an element, additional
1916       * namespace or attribute information can occur before or after this call,
1917       * that is associated with this element.
1918       *
1919       *
1920       * @param elementNamespaceURI The Namespace URI, or the empty string if the
1921       *        element has no Namespace URI or if Namespace
1922       *        processing is not being performed.
1923       * @param elementLocalName The local name (without prefix), or the
1924       *        empty string if Namespace processing is not being
1925       *        performed.
1926       * @param elementName The element type name.
1927       * @throws org.xml.sax.SAXException Any SAX exception, possibly
1928       *            wrapping another exception.
1929       * @see org.xml.sax.ContentHandler#startElement
1930       * @see org.xml.sax.ContentHandler#endElement
1931       * @see org.xml.sax.AttributeList
1932       *
1933       * @throws org.xml.sax.SAXException
1934       */
1935     public void startElement(
1936         String elementNamespaceURI,
1937         String elementLocalName,
1938         String elementName)
1939         throws SAXException
1940     {
1941         startElement(elementNamespaceURI, elementLocalName, elementName, null);
1942     }
1943 
1944     public void startElement(String elementName) throws SAXException
1945     {
1946         startElement(null, null, elementName, null);
1947     }
1948 
1949     /**
1950      * Output the doc type declaration.
1951      *
1952      * @param name non-null reference to document type name.
1953      * NEEDSDOC @param closeDecl
1954      *
1955      * @throws java.io.IOException
1956      */
1957     void outputDocTypeDecl(String name, boolean closeDecl) throws SAXException
1958     {
1959         if (m_cdataTagOpen)
1960             closeCDATA();
1961         try
1962         {
1963             final Writer writer = m_writer;
1964             writer.write(&quot;&lt;!DOCTYPE &quot;);
1965             writer.write(name);
1966 
1967             String doctypePublic = getDoctypePublic();
1968             if (null != doctypePublic)
1969             {
1970                 writer.write(&quot; PUBLIC \&quot;&quot;);
1971                 writer.write(doctypePublic);
1972                 writer.write(&#39;\&quot;&#39;);
1973             }
1974 
1975             String doctypeSystem = getDoctypeSystem();
1976             if (null != doctypeSystem)
1977             {
1978                 if (null == doctypePublic)
1979                     writer.write(&quot; SYSTEM \&quot;&quot;);
1980                 else
1981                     writer.write(&quot; \&quot;&quot;);
1982 
1983                 writer.write(doctypeSystem);
1984 
1985                 if (closeDecl)
1986                 {
1987                     writer.write(&quot;\&quot;&gt;&quot;);
1988                     writer.write(m_lineSep, 0, m_lineSepLen);
1989                     closeDecl = false; // done closing
1990                 }
1991                 else
1992                     writer.write(&#39;\&quot;&#39;);
1993             }
1994             boolean dothis = false;
1995             if (dothis)
1996             {
1997                 // at one point this code seemed right,
1998                 // but not anymore - Brian M.
1999                 if (closeDecl)
2000                 {
2001                     writer.write(&#39;&gt;&#39;);
2002                     writer.write(m_lineSep, 0, m_lineSepLen);
2003                 }
2004             }
2005         }
2006         catch (IOException e)
2007         {
2008             throw new SAXException(e);
2009         }
2010     }
2011 
2012     /**
2013      * Process the attributes, which means to write out the currently
2014      * collected attributes to the writer. The attributes are not
2015      * cleared by this method
2016      *
2017      * @param writer the writer to write processed attributes to.
2018      * @param nAttrs the number of attributes in m_attributes
2019      * to be processed
2020      *
2021      * @throws java.io.IOException
2022      * @throws org.xml.sax.SAXException
2023      */
2024     public void processAttributes(Writer writer, int nAttrs) throws IOException, SAXException
2025     {
2026             /* real SAX attributes are not passed in, so process the
2027              * attributes that were collected after the startElement call.
2028              * _attribVector is a &quot;cheap&quot; list for Stream serializer output
2029              * accumulated over a series of calls to attribute(name,value)
2030              */
2031             String encoding = getEncoding();
2032             for (int i = 0; i &lt; nAttrs; i++)
2033             {
2034                 // elementAt is JDK 1.1.8
2035                 final String name = m_attributes.getQName(i);
2036                 final String value = m_attributes.getValue(i);
2037                 writer.write(&#39; &#39;);
2038                 writer.write(name);
2039                 writer.write(&quot;=\&quot;&quot;);
2040                 writeAttrString(writer, value, encoding);
2041                 writer.write(&#39;\&quot;&#39;);
2042             }
2043     }
2044 
2045     /**
2046      * Returns the specified &lt;var&gt;string&lt;/var&gt; after substituting &lt;VAR&gt;specials&lt;/VAR&gt;,
2047      * and UTF-16 surrogates for chracter references &lt;CODE&gt;&amp;amp;#xnn&lt;/CODE&gt;.
2048      *
2049      * @param   string      String to convert to XML format.
2050      * @param   encoding    CURRENTLY NOT IMPLEMENTED.
2051      *
2052      * @throws java.io.IOException
2053      */
2054     public void writeAttrString(
2055         Writer writer,
2056         String string,
2057         String encoding)
2058         throws IOException, SAXException
2059     {
2060         final int len = string.length();
2061         if (len &gt; m_attrBuff.length)
2062         {
2063            m_attrBuff = new char[len*2 + 1];
2064         }
2065         string.getChars(0,len, m_attrBuff, 0);
2066         final char[] stringChars = m_attrBuff;
2067 
2068         for (int i = 0; i &lt; len; )
2069         {
2070             char ch = stringChars[i];
2071             if (escapingNotNeeded(ch) &amp;&amp; (!m_charInfo.isSpecialAttrChar(ch)))
2072             {
2073                 writer.write(ch);
2074                 i++;
2075             }
2076             else
2077             { // I guess the parser doesn&#39;t normalize cr/lf in attributes. -sb
2078 //                if ((CharInfo.S_CARRIAGERETURN == ch)
2079 //                    &amp;&amp; ((i + 1) &lt; len)
2080 //                    &amp;&amp; (CharInfo.S_LINEFEED == stringChars[i + 1]))
2081 //                {
2082 //                    i++;
2083 //                    ch = CharInfo.S_LINEFEED;
2084 //                }
2085 
2086                 i = accumDefaultEscape(writer, ch, i, stringChars, len, false, true);
2087             }
2088         }
2089 
2090     }
2091 
2092     /**
2093      * Receive notification of the end of an element.
2094      *
2095      *
2096      * @param namespaceURI The Namespace URI, or the empty string if the
2097      *        element has no Namespace URI or if Namespace
2098      *        processing is not being performed.
2099      * @param localName The local name (without prefix), or the
2100      *        empty string if Namespace processing is not being
2101      *        performed.
2102      * @param name The element type name
2103      * @throws org.xml.sax.SAXException Any SAX exception, possibly
2104      *            wrapping another exception.
2105      *
2106      * @throws org.xml.sax.SAXException
2107      */
2108     public void endElement(String namespaceURI, String localName, String name)
2109         throws org.xml.sax.SAXException
2110     {
2111 
2112         if (isInEntityRef())
2113             return;
2114 
2115         if (m_doIndent) {
2116             flushCharactersBuffer(false);
2117         }
2118         // namespaces declared at the current depth are no longer valid
2119         // so get rid of them
2120         m_prefixMap.popNamespaces(m_elemContext.m_currentElemDepth, null);
2121 
2122         try
2123         {
2124             final Writer writer = m_writer;
2125             if (m_elemContext.m_startTagOpen)
2126             {
2127                 if (m_tracer != null)
2128                     super.fireStartElem(m_elemContext.m_elementName);
2129                 int nAttrs = m_attributes.getLength();
2130                 if (nAttrs &gt; 0)
2131                 {
2132                     processAttributes(m_writer, nAttrs);
2133                     // clear attributes object for re-use with next element
2134                     m_attributes.clear();
2135                 }
2136                 if (m_spaceBeforeClose)
2137                     writer.write(&quot; /&gt;&quot;);
2138                 else
2139                     writer.write(&quot;/&gt;&quot;);
2140                 /* don&#39;t need to pop cdataSectionState because
2141                  * this element ended so quickly that we didn&#39;t get
2142                  * to push the state.
2143                  */
2144 
2145             }
2146             else
2147             {
2148                 if (m_cdataTagOpen)
2149                     closeCDATA();
2150 
2151                 if (shouldIndent() &amp;&amp; (m_childNodeNum &gt; 1 || !m_isprevtext))
2152                     indent(m_elemContext.m_currentElemDepth - 1);
2153                 writer.write(&#39;&lt;&#39;);
2154                 writer.write(&#39;/&#39;);
2155                 writer.write(name);
2156                 writer.write(&#39;&gt;&#39;);
2157             }
2158         }
2159         catch (IOException e)
2160         {
2161             throw new SAXException(e);
2162         }
2163 
2164         if (m_doIndent) {
2165             m_ispreserveSpace = m_preserveSpaces.popAndTop();
2166             m_childNodeNum = m_childNodeNumStack.remove(m_childNodeNumStack.size() - 1);
2167 
2168             m_isprevtext = false;
2169         }
2170 
2171         // fire off the end element event
2172         if (m_tracer != null)
2173             super.fireEndElem(name);
2174         m_elemContext = m_elemContext.m_prev;
2175     }
2176 
2177     /**
2178      * Receive notification of the end of an element.
2179      * @param name The element type name
2180      * @throws org.xml.sax.SAXException Any SAX exception, possibly
2181      *     wrapping another exception.
2182      */
2183     public void endElement(String name) throws org.xml.sax.SAXException
2184     {
2185         endElement(null, null, name);
2186     }
2187 
2188     /**
2189      * Begin the scope of a prefix-URI Namespace mapping
2190      * just before another element is about to start.
2191      * This call will close any open tags so that the prefix mapping
2192      * will not apply to the current element, but the up comming child.
2193      *
2194      * @see org.xml.sax.ContentHandler#startPrefixMapping
2195      *
2196      * @param prefix The Namespace prefix being declared.
2197      * @param uri The Namespace URI the prefix is mapped to.
2198      *
2199      * @throws org.xml.sax.SAXException The client may throw
2200      *            an exception during processing.
2201      *
2202      */
2203     public void startPrefixMapping(String prefix, String uri)
2204         throws org.xml.sax.SAXException
2205     {
2206         // the &quot;true&quot; causes the flush of any open tags
2207         startPrefixMapping(prefix, uri, true);
2208     }
2209 
2210     /**
2211      * Handle a prefix/uri mapping, which is associated with a startElement()
2212      * that is soon to follow. Need to close any open start tag to make
2213      * sure than any name space attributes due to this event are associated wih
2214      * the up comming element, not the current one.
2215      * @see ExtendedContentHandler#startPrefixMapping
2216      *
2217      * @param prefix The Namespace prefix being declared.
2218      * @param uri The Namespace URI the prefix is mapped to.
2219      * @param shouldFlush true if any open tags need to be closed first, this
2220      * will impact which element the mapping applies to (open parent, or its up
2221      * comming child)
2222      * @return returns true if the call made a change to the current
2223      * namespace information, false if it did not change anything, e.g. if the
2224      * prefix/namespace mapping was already in scope from before.
2225      *
2226      * @throws org.xml.sax.SAXException The client may throw
2227      *            an exception during processing.
2228      *
2229      *
2230      */
2231     public boolean startPrefixMapping(
2232         String prefix,
2233         String uri,
2234         boolean shouldFlush)
2235         throws org.xml.sax.SAXException
2236     {
2237 
2238         /* Remember the mapping, and at what depth it was declared
2239          * This is one greater than the current depth because these
2240          * mappings will apply to the next depth. This is in
2241          * consideration that startElement() will soon be called
2242          */
2243 
2244         boolean pushed;
2245         int pushDepth;
2246         if (shouldFlush)
2247         {
2248             flushPending();
2249             // the prefix mapping applies to the child element (one deeper)
2250             pushDepth = m_elemContext.m_currentElemDepth + 1;
2251         }
2252         else
2253         {
2254             // the prefix mapping applies to the current element
2255             pushDepth = m_elemContext.m_currentElemDepth;
2256         }
2257         pushed = m_prefixMap.pushNamespace(prefix, uri, pushDepth);
2258 
2259         if (pushed)
2260         {
2261             /* Brian M.: don&#39;t know if we really needto do this. The
2262              * callers of this object should have injected both
2263              * startPrefixMapping and the attributes.  We are
2264              * just covering our butt here.
2265              */
2266             String name;
2267             if (EMPTYSTRING.equals(prefix))
2268             {
2269                 name = &quot;xmlns&quot;;
2270                 addAttributeAlways(XMLNS_URI, name, name, &quot;CDATA&quot;, uri, false);
2271             }
2272             else
2273             {
2274                 if (!EMPTYSTRING.equals(uri))
2275                     // hack for XSLTC attribset16 test
2276                 { // that maps ns1 prefix to &quot;&quot; URI
2277                     name = &quot;xmlns:&quot; + prefix;
2278 
2279                     /* for something like xmlns:abc=&quot;w3.pretend.org&quot;
2280                      *  the      uri is the value, that is why we pass it in the
2281                      * value, or 5th slot of addAttributeAlways()
2282                      */
2283                     addAttributeAlways(XMLNS_URI, prefix, name, &quot;CDATA&quot;, uri, false);
2284                 }
2285             }
2286         }
2287         return pushed;
2288     }
2289 
2290     /**
2291      * Receive notification of an XML comment anywhere in the document. This
2292      * callback will be used for comments inside or outside the document
2293      * element, including comments in the external DTD subset (if read).
2294      * @param ch An array holding the characters in the comment.
2295      * @param start The starting position in the array.
2296      * @param length The number of characters to use from the array.
2297      * @throws org.xml.sax.SAXException The application may raise an exception.
2298      */
2299     public void comment(char ch[], int start, int length)
2300         throws org.xml.sax.SAXException
2301     {
2302 
2303         int start_old = start;
2304         if (isInEntityRef())
2305             return;
2306         if (m_doIndent) {
2307             m_childNodeNum++;
2308             flushCharactersBuffer(false);
2309         }
2310         if (m_elemContext.m_startTagOpen)
2311         {
2312             closeStartTag();
2313             m_elemContext.m_startTagOpen = false;
2314         }
2315         else if (m_needToCallStartDocument)
2316         {
2317             startDocumentInternal();
2318             m_needToCallStartDocument = false;
2319         }
2320 
2321         try
2322         {
2323             if (shouldIndent() &amp;&amp; m_isStandalone)
2324                 indent();
2325 
2326             final int limit = start + length;
2327             boolean wasDash = false;
2328             if (m_cdataTagOpen)
2329                 closeCDATA();
2330 
2331             if (shouldIndent() &amp;&amp; !m_isStandalone)
2332                 indent();
2333 
2334             final Writer writer = m_writer;
2335             writer.write(COMMENT_BEGIN);
2336             // Detect occurrences of two consecutive dashes, handle as necessary.
2337             for (int i = start; i &lt; limit; i++)
2338             {
2339                 if (wasDash &amp;&amp; ch[i] == &#39;-&#39;)
2340                 {
2341                     writer.write(ch, start, i - start);
2342                     writer.write(&quot; -&quot;);
2343                     start = i + 1;
2344                 }
2345                 wasDash = (ch[i] == &#39;-&#39;);
2346             }
2347 
2348             // if we have some chars in the comment
2349             if (length &gt; 0)
2350             {
2351                 // Output the remaining characters (if any)
2352                 final int remainingChars = (limit - start);
2353                 if (remainingChars &gt; 0)
2354                     writer.write(ch, start, remainingChars);
2355                 // Protect comment end from a single trailing dash
2356                 if (ch[limit - 1] == &#39;-&#39;)
2357                     writer.write(&#39; &#39;);
2358             }
2359             writer.write(COMMENT_END);
2360         }
2361         catch (IOException e)
2362         {
2363             throw new SAXException(e);
2364         }
2365 
2366         /*
2367          * Don&#39;t write out any indentation whitespace now,
2368          * because there may be non-whitespace text after this.
2369          *
2370          * Simply mark that at this point if we do decide
2371          * to indent that we should
2372          * add a newline on the end of the current line before
2373          * the indentation at the start of the next line.
2374          */
2375         m_startNewLine = true;
2376         // time to generate comment event
2377         if (m_tracer != null)
2378             super.fireCommentEvent(ch, start_old,length);
2379     }
2380 
2381     /**
2382      * Report the end of a CDATA section.
2383      * @throws org.xml.sax.SAXException The application may raise an exception.
2384      *
2385      *  @see  #startCDATA
2386      */
2387     public void endCDATA() throws org.xml.sax.SAXException
2388     {
2389         if (m_cdataTagOpen)
2390             closeCDATA();
2391         m_cdataStartCalled = false;
2392     }
2393 
2394     /**
2395      * Report the end of DTD declarations.
2396      * @throws org.xml.sax.SAXException The application may raise an exception.
2397      * @see #startDTD
2398      */
2399     public void endDTD() throws org.xml.sax.SAXException
2400     {
2401         try
2402         {
2403             // Don&#39;t output doctype declaration until startDocumentInternal
2404             // has been called. Otherwise, it can appear before XML decl.
2405             if (m_needToCallStartDocument) {
2406                 return;
2407             }
2408 
2409             if (m_needToOutputDocTypeDecl)
2410             {
2411                 outputDocTypeDecl(m_elemContext.m_elementName, false);
2412                 m_needToOutputDocTypeDecl = false;
2413             }
2414             final Writer writer = m_writer;
2415             if (!m_inDoctype)
2416                 writer.write(&quot;]&gt;&quot;);
2417             else
2418             {
2419                 writer.write(&#39;&gt;&#39;);
2420             }
2421 
2422             writer.write(m_lineSep, 0, m_lineSepLen);
2423         }
2424         catch (IOException e)
2425         {
2426             throw new SAXException(e);
2427         }
2428 
2429     }
2430 
2431     /**
2432      * End the scope of a prefix-URI Namespace mapping.
2433      * @see org.xml.sax.ContentHandler#endPrefixMapping
2434      *
2435      * @param prefix The prefix that was being mapping.
2436      * @throws org.xml.sax.SAXException The client may throw
2437      *            an exception during processing.
2438      */
2439     public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException
2440     { // do nothing
2441     }
2442 
2443     /**
2444      * Receive notification of ignorable whitespace in element content.
2445      *
2446      * Not sure how to get this invoked quite yet.
2447      *
2448      * @param ch The characters from the XML document.
2449      * @param start The start position in the array.
2450      * @param length The number of characters to read from the array.
2451      * @throws org.xml.sax.SAXException Any SAX exception, possibly
2452      *            wrapping another exception.
2453      * @see #characters
2454      *
2455      * @throws org.xml.sax.SAXException
2456      */
2457     public void ignorableWhitespace(char ch[], int start, int length)
2458         throws org.xml.sax.SAXException
2459     {
2460 
2461         if (0 == length)
2462             return;
2463         characters(ch, start, length);
2464     }
2465 
2466     /**
2467      * Receive notification of a skipped entity.
2468      * @see org.xml.sax.ContentHandler#skippedEntity
2469      *
2470      * @param name The name of the skipped entity.  If it is a
2471      *       parameter                   entity, the name will begin with &#39;%&#39;,
2472      * and if it is the external DTD subset, it will be the string
2473      * &quot;[dtd]&quot;.
2474      * @throws org.xml.sax.SAXException Any SAX exception, possibly wrapping
2475      * another exception.
2476      */
2477     public void skippedEntity(String name) throws org.xml.sax.SAXException
2478     { // TODO: Should handle
2479     }
2480 
2481     /**
2482      * Report the start of a CDATA section.
2483      *
2484      * @throws org.xml.sax.SAXException The application may raise an exception.
2485      * @see #endCDATA
2486      */
2487     public void startCDATA() throws org.xml.sax.SAXException
2488     {
2489         if (m_doIndent) {
2490             flushCharactersBuffer(true);
2491         }
2492 
2493         m_cdataStartCalled = true;
2494     }
2495 
2496     /**
2497      * Report the beginning of an entity.
2498      *
2499      * The start and end of the document entity are not reported.
2500      * The start and end of the external DTD subset are reported
2501      * using the pseudo-name &quot;[dtd]&quot;.  All other events must be
2502      * properly nested within start/end entity events.
2503      *
2504      * @param name The name of the entity.  If it is a parameter
2505      *        entity, the name will begin with &#39;%&#39;.
2506      * @throws org.xml.sax.SAXException The application may raise an exception.
2507      * @see #endEntity
2508      * @see org.xml.sax.ext.DeclHandler#internalEntityDecl
2509      * @see org.xml.sax.ext.DeclHandler#externalEntityDecl
2510      */
2511     public void startEntity(String name) throws org.xml.sax.SAXException
2512     {
2513         if (name.equals(&quot;[dtd]&quot;))
2514             m_inExternalDTD = true;
2515 
2516         // if this is not the magic [dtd] name
2517         if (!m_inExternalDTD) {
2518             // if it&#39;s not in nested entity reference
2519             if (!isInEntityRef()) {
2520                 if (shouldFormatOutput()) {
2521                     m_charactersBuffer.addEntityReference(name);
2522                 } else {
2523                     outputEntityReference(name);
2524                 }
2525             }
2526             m_inEntityRef++;
2527         }
2528     }
2529 
2530     /**
2531      * Write out the entity reference with the form as &quot;&amp;amp;entityName;&quot;.
2532      *
2533      * @param name The name of the entity.
2534      */
2535     private void outputEntityReference(String name) throws SAXException {
2536         startNonEscaping();
2537         characters(&quot;&amp;&quot; + name + &#39;;&#39;);
2538         endNonEscaping();
2539         m_isprevtext = true;
2540     }
2541 
2542     /**
2543      * For the enclosing elements starting tag write out
2544      * out any attributes followed by &quot;&gt;&quot;
2545      *
2546      * @throws org.xml.sax.SAXException
2547      */
2548     protected void closeStartTag() throws SAXException
2549     {
2550         if (m_elemContext.m_startTagOpen)
2551         {
2552 
2553             try
2554             {
2555                 if (m_tracer != null)
2556                     super.fireStartElem(m_elemContext.m_elementName);
2557                 int nAttrs = m_attributes.getLength();
2558                 if (nAttrs &gt; 0)
2559                 {
2560                      processAttributes(m_writer, nAttrs);
2561                     // clear attributes object for re-use with next element
2562                     m_attributes.clear();
2563                 }
2564                 m_writer.write(&#39;&gt;&#39;);
2565             }
2566             catch (IOException e)
2567             {
2568                 throw new SAXException(e);
2569             }
2570 
2571             /* whether Xalan or XSLTC, we have the prefix mappings now, so
2572              * lets determine if the current element is specified in the cdata-
2573              * section-elements list.
2574              */
2575             if (m_StringOfCDATASections != null)
2576                 m_elemContext.m_isCdataSection = isCdataSection();
2577         }
2578 
2579     }
2580 
2581     /**
2582      * Report the start of DTD declarations, if any.
2583      *
2584      * Any declarations are assumed to be in the internal subset unless
2585      * otherwise indicated.
2586      *
2587      * @param name The document type name.
2588      * @param publicId The declared public identifier for the
2589      *        external DTD subset, or null if none was declared.
2590      * @param systemId The declared system identifier for the
2591      *        external DTD subset, or null if none was declared.
2592      * @throws org.xml.sax.SAXException The application may raise an
2593      *            exception.
2594      * @see #endDTD
2595      * @see #startEntity
2596      */
2597     public void startDTD(String name, String publicId, String systemId)
2598         throws org.xml.sax.SAXException
2599     {
2600         setDoctypeSystem(systemId);
2601         setDoctypePublic(publicId);
2602 
2603         m_elemContext.m_elementName = name;
2604         m_inDoctype = true;
2605     }
2606 
2607     /**
2608      * Returns the m_indentAmount.
2609      * @return int
2610      */
2611     public int getIndentAmount()
2612     {
2613         return m_indentAmount;
2614     }
2615 
2616     /**
2617      * Sets the m_indentAmount.
2618      *
2619      * @param m_indentAmount The m_indentAmount to set
2620      */
2621     public void setIndentAmount(int m_indentAmount)
2622     {
2623         this.m_indentAmount = m_indentAmount;
2624     }
2625 
2626     /**
2627      * Tell if, based on space preservation constraints and the doIndent property,
2628      * if an indent should occur.
2629      *
2630      * @return True if an indent should occur.
2631      */
2632     protected boolean shouldIndent()
2633     {
2634         return shouldFormatOutput() &amp;&amp; (m_elemContext.m_currentElemDepth &gt; 0 || m_isStandalone);
2635     }
2636 
2637     /**
2638      * Searches for the list of qname properties with the specified key in the
2639      * property list. If the key is not found in this property list, the default
2640      * property list, and its defaults, recursively, are then checked. The
2641      * method returns &lt;code&gt;null&lt;/code&gt; if the property is not found.
2642      *
2643      * @param   key   the property key.
2644      * @param props the list of properties to search in.
2645      *
2646      * Sets the ArrayList of local-name/URI pairs of the cdata section elements
2647      * specified in the cdata-section-elements property.
2648      *
2649      * This method is essentially a copy of getQNameProperties() from
2650      * OutputProperties. Eventually this method should go away and a call
2651      * to setCdataSectionElements(List&lt;String&gt; v) should be made directly.
2652      */
2653     private void setCdataSectionElements(String key, Properties props) {
2654         String s = props.getProperty(key);
2655 
2656         if (null != s) {
2657             // List&lt;String&gt; of URI/LocalName pairs
2658             List&lt;String&gt; al = new ArrayList&lt;&gt;();
2659             int l = s.length();
2660             boolean inCurly = false;
2661             StringBuilder buf = new StringBuilder();
2662 
2663             // parse through string, breaking on whitespaces.  I do this instead
2664             // of a tokenizer so I can track whitespace inside of curly brackets,
2665             // which theoretically shouldn&#39;t happen if they contain legal URLs.
2666             for (int i = 0; i &lt; l; i++)
2667             {
2668                 char c = s.charAt(i);
2669 
2670                 if (Character.isWhitespace(c))
2671                 {
2672                     if (!inCurly)
2673                     {
2674                         if (buf.length() &gt; 0)
2675                         {
2676                             addCdataSectionElement(buf.toString(), al);
2677                             buf.setLength(0);
2678                         }
2679                         continue;
2680                     }
2681                 }
2682                 else if (&#39;{&#39; == c)
2683                     inCurly = true;
2684                 else if (&#39;}&#39; == c)
2685                     inCurly = false;
2686 
2687                 buf.append(c);
2688             }
2689 
2690             if (buf.length() &gt; 0)
2691             {
2692                 addCdataSectionElement(buf.toString(), al);
2693                 buf.setLength(0);
2694             }
2695             // call the official, public method to set the collected names
2696             setCdataSectionElements(al);
2697         }
2698 
2699     }
2700 
2701     /**
2702      * Adds a URI/LocalName pair of strings to the list.
2703      *
2704      * @param URI_and_localName String of the form &quot;{uri}local&quot; or &quot;local&quot;
2705      *
2706      * @return a QName object
2707      */
2708     private void addCdataSectionElement(String URI_and_localName, List&lt;String&gt; al) {
2709         StringTokenizer tokenizer = new StringTokenizer(URI_and_localName, &quot;{}&quot;, false);
2710         String s1 = tokenizer.nextToken();
2711         String s2 = tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;
2712 
2713         if (null == s2) {
2714             // add null URI and the local name
2715             al.add(null);
2716             al.add(s1);
2717         } else {
2718             // add URI, then local name
2719             al.add(s1);
2720             al.add(s2);
2721         }
2722     }
2723 
2724     /**
2725      * Remembers the cdata sections specified in the cdata-section-elements.
2726      * The &quot;official way to set URI and localName pairs.
2727      * This method should be used by both Xalan and XSLTC.
2728      *
2729      * @param URI_and_localNames an ArrayList of pairs of Strings (URI/local)
2730      */
2731     public void setCdataSectionElements(List&lt;String&gt; URI_and_localNames) {
2732         // convert to the new way.
2733         if (URI_and_localNames != null) {
2734             final int len = URI_and_localNames.size() - 1;
2735             if (len &gt; 0) {
2736                 final StringBuilder sb = new StringBuilder();
2737                 for (int i = 0; i &lt; len; i += 2) {
2738                     // whitspace separated &quot;{uri1}local1 {uri2}local2 ...&quot;
2739                     if (i != 0)
2740                         sb.append(&#39; &#39;);
2741                     final String uri = URI_and_localNames.get(i);
2742                     final String localName = URI_and_localNames.get(i + 1);
2743                     if (uri != null) {
2744                         // If there is no URI don&#39;t put this in, just the localName then.
2745                         sb.append(&#39;{&#39;);
2746                         sb.append(uri);
2747                         sb.append(&#39;}&#39;);
2748                     }
2749                     sb.append(localName);
2750                 }
2751                 m_StringOfCDATASections = sb.toString();
2752             }
2753         }
2754         initCdataElems(m_StringOfCDATASections);
2755     }
2756 
2757     /**
2758      * Makes sure that the namespace URI for the given qualified attribute name
2759      * is declared.
2760      * @param ns the namespace URI
2761      * @param rawName the qualified name
2762      * @return returns null if no action is taken, otherwise it returns the
2763      * prefix used in declaring the namespace.
2764      * @throws SAXException
2765      */
2766     protected String ensureAttributesNamespaceIsDeclared(
2767         String ns,
2768         String localName,
2769         String rawName)
2770         throws org.xml.sax.SAXException
2771     {
2772 
2773         if (ns != null &amp;&amp; ns.length() &gt; 0)
2774         {
2775 
2776             // extract the prefix in front of the raw name
2777             int index = 0;
2778             String prefixFromRawName =
2779                 (index = rawName.indexOf(&quot;:&quot;)) &lt; 0
2780                     ? &quot;&quot;
2781                     : rawName.substring(0, index);
2782 
2783             if (index &gt; 0)
2784             {
2785                 // we have a prefix, lets see if it maps to a namespace
2786                 String uri = m_prefixMap.lookupNamespace(prefixFromRawName);
2787                 if (uri != null &amp;&amp; uri.equals(ns))
2788                 {
2789                     // the prefix in the raw name is already maps to the given namespace uri
2790                     // so we don&#39;t need to do anything
2791                     return null;
2792                 }
2793                 else
2794                 {
2795                     // The uri does not map to the prefix in the raw name,
2796                     // so lets make the mapping.
2797                     this.startPrefixMapping(prefixFromRawName, ns, false);
2798                     this.addAttribute(
2799                         &quot;http://www.w3.org/2000/xmlns/&quot;,
2800                         prefixFromRawName,
2801                         &quot;xmlns:&quot; + prefixFromRawName,
2802                         &quot;CDATA&quot;,
2803                         ns, false);
2804                     return prefixFromRawName;
2805                 }
2806             }
2807             else
2808             {
2809                 // we don&#39;t have a prefix in the raw name.
2810                 // Does the URI map to a prefix already?
2811                 String prefix = m_prefixMap.lookupPrefix(ns);
2812                 if (prefix == null)
2813                 {
2814                     // uri is not associated with a prefix,
2815                     // so lets generate a new prefix to use
2816                     prefix = m_prefixMap.generateNextPrefix();
2817                     this.startPrefixMapping(prefix, ns, false);
2818                     this.addAttribute(
2819                         &quot;http://www.w3.org/2000/xmlns/&quot;,
2820                         prefix,
2821                         &quot;xmlns:&quot; + prefix,
2822                         &quot;CDATA&quot;,
2823                         ns, false);
2824                 }
2825 
2826                 return prefix;
2827 
2828             }
2829         }
2830         return null;
2831     }
2832 
2833     void ensurePrefixIsDeclared(String ns, String rawName)
2834         throws org.xml.sax.SAXException
2835     {
2836 
2837         if (ns != null &amp;&amp; ns.length() &gt; 0)
2838         {
2839             int index;
2840             final boolean no_prefix = ((index = rawName.indexOf(&quot;:&quot;)) &lt; 0);
2841             String prefix = (no_prefix) ? &quot;&quot; : rawName.substring(0, index);
2842 
2843             if (null != prefix)
2844             {
2845                 String foundURI = m_prefixMap.lookupNamespace(prefix);
2846 
2847                 if ((null == foundURI) || !foundURI.equals(ns))
2848                 {
2849                     this.startPrefixMapping(prefix, ns);
2850 
2851                     // Bugzilla1133: Generate attribute as well as namespace event.
2852                     // SAX does expect both.
2853 
2854                     this.addAttributeAlways(
2855                         &quot;http://www.w3.org/2000/xmlns/&quot;,
2856                         no_prefix ? &quot;xmlns&quot; : prefix,  // local name
2857                         no_prefix ? &quot;xmlns&quot; : (&quot;xmlns:&quot;+ prefix), // qname
2858                         &quot;CDATA&quot;,
2859                         ns,
2860                         false);
2861                 }
2862 
2863             }
2864         }
2865     }
2866 
2867     /**
2868      * This method flushes any pending events, which can be startDocument()
2869      * closing the opening tag of an element, or closing an open CDATA section.
2870      */
2871     public void flushPending() throws SAXException
2872     {
2873             if (m_needToCallStartDocument)
2874             {
2875                 startDocumentInternal();
2876                 m_needToCallStartDocument = false;
2877             }
2878             if (m_elemContext.m_startTagOpen)
2879             {
2880                 closeStartTag();
2881                 m_elemContext.m_startTagOpen = false;
2882             }
2883 
2884             if (m_cdataTagOpen)
2885             {
2886                 closeCDATA();
2887                 m_cdataTagOpen = false;
2888             }
2889     }
2890 
2891     public void setContentHandler(ContentHandler ch)
2892     {
2893         // this method is really only useful in the ToSAXHandler classes but it is
2894         // in the interface.  If the method defined here is ever called
2895         // we are probably in trouble.
2896     }
2897 
2898     /**
2899      * Adds the given attribute to the set of attributes, even if there is
2900      * no currently open element. This is useful if a SAX startPrefixMapping()
2901      * should need to add an attribute before the element name is seen.
2902      *
2903      * This method is a copy of its super classes method, except that some
2904      * tracing of events is done.  This is so the tracing is only done for
2905      * stream serializers, not for SAX ones.
2906      *
2907      * @param uri the URI of the attribute
2908      * @param localName the local name of the attribute
2909      * @param rawName   the qualified name of the attribute
2910      * @param type the type of the attribute (probably CDATA)
2911      * @param value the value of the attribute
2912      * @param xslAttribute true if this attribute is coming from an xsl:attribute element.
2913      * @return true if the attribute value was added,
2914      * false if the attribute already existed and the value was
2915      * replaced with the new value.
2916      */
2917     public boolean addAttributeAlways(
2918         String uri,
2919         String localName,
2920         String rawName,
2921         String type,
2922         String value,
2923         boolean xslAttribute)
2924     {
2925         if (!m_charactersBuffer.isAnyCharactersBuffered()) {
2926             return doAddAttributeAlways(uri, localName, rawName, type, value, xslAttribute);
2927         } else {
2928             /*
2929              * If stylesheet includes xsl:copy-of an attribute node, XSLTC will
2930              * fire an addAttribute event. When a text node is handling in
2931              * ToStream, addAttribute has no effect. But closeStartTag call is
2932              * delayed to flushCharactersBuffer() method if the text node is
2933              * buffered, so here we ignore the attribute to avoid corrupting the
2934              * start tag content.
2935              *
2936              */
2937             return m_attributes.getIndex(rawName) &lt; 0;
2938         }
2939     }
2940 
2941     /**
2942      * Does really add the attribute to the set of attributes.
2943      */
2944     private boolean doAddAttributeAlways(
2945         String uri,
2946         String localName,
2947         String rawName,
2948         String type,
2949         String value,
2950         boolean xslAttribute)
2951     {
2952         boolean was_added;
2953         int index;
2954         //if (uri == null || localName == null || uri.length() == 0)
2955         index = m_attributes.getIndex(rawName);
2956         // Don&#39;t use &#39;localName&#39; as it gives incorrect value, rely only on &#39;rawName&#39;
2957         /*else {
2958             index = m_attributes.getIndex(uri, localName);
2959         }*/
2960         if (index &gt;= 0)
2961         {
2962             String old_value = null;
2963             if (m_tracer != null)
2964             {
2965                 old_value = m_attributes.getValue(index);
2966                 if (value.equals(old_value))
2967                     old_value = null;
2968             }
2969 
2970             /* We&#39;ve seen the attribute before.
2971              * We may have a null uri or localName, but all we really
2972              * want to re-set is the value anyway.
2973              */
2974             m_attributes.setValue(index, value);
2975             was_added = false;
2976             if (old_value != null){
2977                 firePseudoAttributes();
2978             }
2979 
2980         }
2981         else
2982         {
2983             // the attribute doesn&#39;t exist yet, create it
2984             if (xslAttribute)
2985             {
2986                 /*
2987                  * This attribute is from an xsl:attribute element so we take some care in
2988                  * adding it, e.g.
2989                  *   &lt;elem1  foo:attr1=&quot;1&quot; xmlns:foo=&quot;uri1&quot;&gt;
2990                  *       &lt;xsl:attribute name=&quot;foo:attr2&quot;&gt;2&lt;/xsl:attribute&gt;
2991                  *   &lt;/elem1&gt;
2992                  *
2993                  * We are adding attr1 and attr2 both as attributes of elem1,
2994                  * and this code is adding attr2 (the xsl:attribute ).
2995                  * We could have a collision with the prefix like in the example above.
2996                  */
2997 
2998                 // In the example above, is there a prefix like foo ?
2999                 final int colonIndex = rawName.indexOf(&#39;:&#39;);
3000                 if (colonIndex &gt; 0)
3001                 {
3002                     String prefix = rawName.substring(0,colonIndex);
3003                     NamespaceMappings.MappingRecord existing_mapping = m_prefixMap.getMappingFromPrefix(prefix);
3004 
3005                     /* Before adding this attribute (foo:attr2),
3006                      * is the prefix for it (foo) already mapped at the current depth?
3007                      */
3008                     if (existing_mapping != null
3009                     &amp;&amp; existing_mapping.m_declarationDepth == m_elemContext.m_currentElemDepth
3010                     &amp;&amp; !existing_mapping.m_uri.equals(uri))
3011                     {
3012                         /*
3013                          * There is an existing mapping of this prefix,
3014                          * it differs from the one we need,
3015                          * and unfortunately it is at the current depth so we
3016                          * can not over-ride it.
3017                          */
3018 
3019                         /*
3020                          * Are we lucky enough that an existing other prefix maps to this URI ?
3021                          */
3022                         prefix = m_prefixMap.lookupPrefix(uri);
3023                         if (prefix == null)
3024                         {
3025                             /* Unfortunately there is no existing prefix that happens to map to ours,
3026                              * so to avoid a prefix collision we must generated a new prefix to use.
3027                              * This is OK because the prefix URI mapping
3028                              * defined in the xsl:attribute is short in scope,
3029                              * just the xsl:attribute element itself,
3030                              * and at this point in serialization the body of the
3031                              * xsl:attribute, if any, is just a String. Right?
3032                              *   . . . I sure hope so - Brian M.
3033                              */
3034                             prefix = m_prefixMap.generateNextPrefix();
3035                         }
3036 
3037                         rawName = prefix + &#39;:&#39; + localName;
3038                     }
3039                 }
3040 
3041                 try
3042                 {
3043                     /* This is our last chance to make sure the namespace for this
3044                      * attribute is declared, especially if we just generated an alternate
3045                      * prefix to avoid a collision (the new prefix/rawName will go out of scope
3046                      * soon and be lost ...  last chance here.
3047                      */
3048                     String prefixUsed =
3049                         ensureAttributesNamespaceIsDeclared(
3050                             uri,
3051                             localName,
3052                             rawName);
3053                 }
3054                 catch (SAXException e)
3055                 {
3056                     // TODO Auto-generated catch block
3057                     e.printStackTrace();
3058                 }
3059             }
3060 
3061             m_attributes.addAttribute(uri, localName, rawName, type, value);
3062             was_added = true;
3063             if (m_tracer != null){
3064                 firePseudoAttributes();
3065             }
3066         }
3067 
3068         if (m_doIndent &amp;&amp; rawName.equals(&quot;xml:space&quot;)) {
3069             if (value.equals(&quot;preserve&quot;)) {
3070                 m_ispreserveSpace = true;
3071                 if (m_preserveSpaces.size() &gt; 0)
3072                     m_preserveSpaces.setTop(m_ispreserveSpace);
3073             } else if (value.equals(&quot;default&quot;)) {
3074                 m_ispreserveSpace = false;
3075                 if (m_preserveSpaces.size() &gt; 0)
3076                     m_preserveSpaces.setTop(m_ispreserveSpace);
3077             }
3078         }
3079 
3080         return was_added;
3081     }
3082 
3083     /**
3084      * To fire off the pseudo characters of attributes, as they currently
3085      * exist. This method should be called everytime an attribute is added,
3086      * or when an attribute value is changed, or an element is created.
3087      */
3088     protected void firePseudoAttributes() {
3089         if (m_tracer != null) {
3090             try {
3091                 // flush out the &quot;&lt;elemName&quot; if not already flushed
3092                 m_writer.flush();
3093 
3094                 // make a StringBuffer to write the name=&quot;value&quot; pairs to.
3095                 StringBuffer sb = new StringBuffer();
3096                 int nAttrs = m_attributes.getLength();
3097                 if (nAttrs &gt; 0) {
3098                     // make a writer that internally appends to the same
3099                     // StringBuffer
3100                     Writer writer = new ToStream.WritertoStringBuffer(sb);
3101 
3102                     processAttributes(writer, nAttrs);
3103                     // Don&#39;t clear the attributes!
3104                     // We only want to see what would be written out
3105                     // at this point, we don&#39;t want to loose them.
3106                 }
3107                 sb.append(&#39;&gt;&#39;);  // the potential &gt; after the attributes.
3108                 // convert the StringBuffer to a char array and
3109                 // emit the trace event that these characters &quot;might&quot;
3110                 // be written
3111                 char ch[] = sb.toString().toCharArray();
3112                 m_tracer.fireGenerateEvent(
3113                     SerializerTrace.EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS,
3114                     ch,
3115                     0,
3116                     ch.length);
3117             } catch (IOException ioe) {
3118                 // ignore ?
3119             } catch (SAXException se) {
3120                 // ignore ?
3121             }
3122         }
3123     }
3124 
3125     /**
3126      * This inner class is used only to collect attribute values
3127      * written by the method writeAttrString() into a string buffer.
3128      * In this manner trace events, and the real writing of attributes will use
3129      * the same code.
3130      */
3131     private class WritertoStringBuffer extends Writer {
3132         final private StringBuffer m_stringbuf;
3133 
3134         /**
3135          * @see java.io.Writer#write(char[], int, int)
3136          */
3137         WritertoStringBuffer(StringBuffer sb) {
3138             m_stringbuf = sb;
3139         }
3140 
3141         public void write(char[] arg0, int arg1, int arg2) throws IOException {
3142             m_stringbuf.append(arg0, arg1, arg2);
3143         }
3144 
3145         /**
3146          * @see java.io.Writer#flush()
3147          */
3148         public void flush() throws IOException {}
3149 
3150         /**
3151          * @see java.io.Writer#close()
3152          */
3153         public void close() throws IOException {}
3154 
3155         public void write(int i) {
3156             m_stringbuf.append((char) i);
3157         }
3158 
3159         public void write(String s) {
3160             m_stringbuf.append(s);
3161         }
3162     }
3163 
3164     /**
3165      * @see SerializationHandler#setTransformer(Transformer)
3166      */
3167     public void setTransformer(Transformer transformer) {
3168         super.setTransformer(transformer);
3169         if (m_tracer != null &amp;&amp; !(m_writer instanceof SerializerTraceWriter)) {
3170             m_writer = new SerializerTraceWriter(m_writer, m_tracer);
3171         }
3172     }
3173 
3174     /**
3175      * Try&#39;s to reset the super class and reset this class for
3176      * re-use, so that you don&#39;t need to create a new serializer
3177      * (mostly for performance reasons).
3178      *
3179      * @return true if the class was successfuly reset.
3180      */
3181     public boolean reset() {
3182         boolean wasReset = false;
3183         if (super.reset()) {
3184             resetToStream();
3185             wasReset = true;
3186         }
3187         return wasReset;
3188     }
3189 
3190     /**
3191      * Reset all of the fields owned by ToStream class
3192      *
3193      */
3194     private void resetToStream() {
3195          this.m_cdataStartCalled = false;
3196          /* The stream is being reset. It is one of
3197           * ToXMLStream, ToHTMLStream ... and this type can&#39;t be changed
3198           * so neither should m_charInfo which is associated with the
3199           * type of Stream. Just leave m_charInfo as-is for the next re-use.
3200           */
3201          // this.m_charInfo = null; // don&#39;t set to null
3202 
3203          this.m_disableOutputEscapingStates.clear();
3204 
3205          this.m_escaping = true;
3206          // Leave m_format alone for now - Brian M.
3207          // this.m_format = null;
3208          this.m_inDoctype = false;
3209          this.m_ispreserveSpace = false;
3210          this.m_preserveSpaces.clear();
3211          this.m_childNodeNum = 0;
3212          this.m_childNodeNumStack.clear();
3213          this.m_charactersBuffer.clear();
3214          this.m_isprevtext = false;
3215          this.m_isUTF8 = false; //  ?? used anywhere ??
3216          this.m_shouldFlush = true;
3217          this.m_spaceBeforeClose = false;
3218          this.m_startNewLine = false;
3219          this.m_lineSepUse = true;
3220          // DON&#39;T SET THE WRITER TO NULL, IT MAY BE REUSED !!
3221          // this.m_writer = null;
3222          this.m_expandDTDEntities = true;
3223 
3224     }
3225 
3226     /**
3227       * Sets the character encoding coming from the xsl:output encoding stylesheet attribute.
3228       * @param encoding the character encoding
3229       */
3230      public void setEncoding(String encoding)
3231      {
3232          setOutputProperty(OutputKeys.ENCODING,encoding);
3233      }
3234 
3235     /**
3236      * Simple stack for boolean values.
3237      *
3238      * This class is a copy of the one in com.sun.org.apache.xml.internal.utils.
3239      * It exists to cut the serializers dependancy on that package.
3240      * A minor changes from that package are:
3241      * doesn&#39;t implement Clonable
3242      *
3243      * @xsl.usage internal
3244      */
3245     static final class BoolStack {
3246         /** Array of boolean values */
3247         private boolean m_values[];
3248 
3249         /** Array size allocated */
3250         private int m_allocatedSize;
3251 
3252         /** Index into the array of booleans */
3253         private int m_index;
3254 
3255         /**
3256          * Default constructor.  Note that the default
3257          * block size is very small, for small lists.
3258          */
3259         public BoolStack() {
3260             this(32);
3261         }
3262 
3263         /**
3264          * Construct a IntVector, using the given block size.
3265          *
3266          * @param size array size to allocate
3267          */
3268         public BoolStack(int size) {
3269             m_allocatedSize = size;
3270             m_values = new boolean[size];
3271             m_index = -1;
3272         }
3273 
3274         /**
3275          * Get the length of the list.
3276          *
3277          * @return Current length of the list
3278          */
3279         public final int size() {
3280             return m_index + 1;
3281         }
3282 
3283         /**
3284          * Clears the stack.
3285          *
3286          */
3287         public final void clear() {
3288             m_index = -1;
3289         }
3290 
3291         /**
3292          * Pushes an item onto the top of this stack.
3293          *
3294          *
3295          * @param val the boolean to be pushed onto this stack.
3296          * @return  the &lt;code&gt;item&lt;/code&gt; argument.
3297          */
3298         public final boolean push(boolean val) {
3299             if (m_index == m_allocatedSize - 1)
3300                 grow();
3301 
3302             return (m_values[++m_index] = val);
3303         }
3304 
3305         /**
3306          * Removes the object at the top of this stack and returns that
3307          * object as the value of this function.
3308          *
3309          * @return     The object at the top of this stack.
3310          * @throws  EmptyStackException  if this stack is empty.
3311          */
3312         public final boolean pop() {
3313             return m_values[m_index--];
3314         }
3315 
3316         /**
3317          * Removes the object at the top of this stack and returns the
3318          * next object at the top as the value of this function.
3319          *
3320          *
3321          * @return Next object to the top or false if none there
3322          */
3323         public final boolean popAndTop() {
3324             m_index--;
3325             return (m_index &gt;= 0) ? m_values[m_index] : false;
3326         }
3327 
3328         /**
3329          * Set the item at the top of this stack
3330          *
3331          *
3332          * @param b Object to set at the top of this stack
3333          */
3334         public final void setTop(boolean b) {
3335             m_values[m_index] = b;
3336         }
3337 
3338         /**
3339          * Looks at the object at the top of this stack without removing it
3340          * from the stack.
3341          *
3342          * @return     the object at the top of this stack.
3343          * @throws  EmptyStackException  if this stack is empty.
3344          */
3345         public final boolean peek() {
3346             return m_values[m_index];
3347         }
3348 
3349         /**
3350          * Looks at the object at the top of this stack without removing it
3351          * from the stack.  If the stack is empty, it returns false.
3352          *
3353          * @return     the object at the top of this stack.
3354          */
3355         public final boolean peekOrFalse() {
3356             return (m_index &gt; -1) ? m_values[m_index] : false;
3357         }
3358 
3359         /**
3360          * Looks at the object at the top of this stack without removing it
3361          * from the stack.  If the stack is empty, it returns true.
3362          *
3363          * @return     the object at the top of this stack.
3364          */
3365         public final boolean peekOrTrue() {
3366             return (m_index &gt; -1) ? m_values[m_index] : true;
3367         }
3368 
3369         /**
3370          * Tests if this stack is empty.
3371          *
3372          * @return  &lt;code&gt;true&lt;/code&gt; if this stack is empty;
3373          *          &lt;code&gt;false&lt;/code&gt; otherwise.
3374          */
3375         public boolean isEmpty() {
3376             return (m_index == -1);
3377         }
3378 
3379         /**
3380          * Grows the size of the stack
3381          *
3382          */
3383         private void grow() {
3384             m_allocatedSize *= 2;
3385             boolean newVector[] = new boolean[m_allocatedSize];
3386             System.arraycopy(m_values, 0, newVector, 0, m_index + 1);
3387             m_values = newVector;
3388         }
3389     }
3390 
3391 
3392     /**
3393      * This inner class is used to buffer the text nodes and the entity
3394      * reference nodes if indentation is on. There is only one CharacterBuffer
3395      * instance in ToStream, it contains a queue of GenericCharacters,
3396      * GenericCharacters can be a text node or an entity reference node. The
3397      * text nodes and entity reference nodes are joined together and then are
3398      * flushed.
3399      */
3400     private class CharacterBuffer {
3401         /**
3402          * GenericCharacters is immutable.
3403          */
3404         private abstract class GenericCharacters {
3405             /**
3406              * @return True if all characters in this Text are newlines.
3407              */
3408             abstract boolean flush(boolean skipBeginningNewlines) throws SAXException;
3409 
3410             /**
3411              * Converts this GenericCharacters to a new character array. This
3412              * method is used to handle cdata-section-elements attribute in
3413              * xsl:output. Therefore it doesn&#39;t need to consider
3414              * skipBeginningNewlines because the text will be involved with CDATA
3415              * tag.
3416              */
3417             abstract char[] toChars();
3418         }
3419 
3420         private List&lt;GenericCharacters&gt; bufferedCharacters = new ArrayList&lt;&gt;();
3421 
3422         /**
3423          * Append a text node to the buffer.
3424          */
3425         public void addText(final char chars[], final int start, final int length) {
3426             bufferedCharacters.add(new GenericCharacters() {
3427                 char[] text;
3428 
3429                 {
3430                     text = Arrays.copyOfRange(chars, start, start + length);
3431                 }
3432 
3433                 boolean flush(boolean skipBeginningNewlines) throws SAXException {
3434                     int start = 0;
3435                     while (skipBeginningNewlines &amp;&amp; text[start] == &#39;\n&#39;) {
3436                         start++;
3437                         if (start == text.length) {
3438                             return true;
3439                         }
3440                     }
3441                     outputCharacters(text, start, text.length - start);
3442                     return false;
3443                 }
3444 
3445                 char[] toChars() {
3446                     return text;
3447                 }
3448             });
3449         }
3450 
3451         /**
3452          * Append an entity reference to the buffer.
3453          */
3454         public void addEntityReference(String entityName) {
3455             bufferedCharacters.add(new GenericCharacters() {
3456                 boolean flush(boolean skipBeginningNewlines) throws SAXException {
3457                     if (m_elemContext.m_startTagOpen)
3458                     {
3459                         closeStartTag();
3460                         m_elemContext.m_startTagOpen = false;
3461                     }
3462                     if (m_cdataTagOpen)
3463                         closeCDATA();
3464                     char[] cs = toChars();
3465                     try {
3466                         m_writer.write(cs, 0, cs.length);
3467                         m_isprevtext = true;
3468                     } catch (IOException e) {
3469                         throw new SAXException(e);
3470                     }
3471                     return false;
3472                 }
3473 
3474                 char[] toChars() {
3475                     return (&quot;&amp;&quot; + entityName + &quot;;&quot;).toCharArray();
3476                 }
3477             });
3478         }
3479 
3480         /**
3481          * Append a raw text to the buffer. Used to handle raw characters event.
3482          */
3483         public void addRawText(final char chars[], final int start, final int length) {
3484             bufferedCharacters.add(new GenericCharacters() {
3485                 char[] text;
3486 
3487                 {
3488                     text = Arrays.copyOfRange(chars, start, start + length);
3489                 }
3490 
3491                 boolean flush(boolean skipBeginningNewlines) throws SAXException {
3492                     try {
3493                         int start = 0;
3494                         while (skipBeginningNewlines &amp;&amp; text[start] == &#39;\n&#39;) {
3495                             start++;
3496                             if (start == text.length) {
3497                                 return true;
3498                             }
3499                         }
3500                         m_writer.write(text, start, text.length - start);
3501                         m_isprevtext = true;
3502                     } catch (IOException e) {
3503                         throw new SAXException(e);
3504                     }
3505                     return false;
3506                 }
3507 
3508                 char[] toChars() {
3509                     return text;
3510                 }
3511             });
3512         }
3513 
3514         /**
3515          * @return True if any GenericCharacters are buffered.
3516          */
3517         public boolean isAnyCharactersBuffered() {
3518             return bufferedCharacters.size() &gt; 0;
3519         }
3520 
3521         /**
3522          * Flush all buffered GenericCharacters.
3523          */
3524         public void flush(boolean skipBeginningNewlines) throws SAXException {
3525             Iterator&lt;GenericCharacters&gt; itr = bufferedCharacters.iterator();
3526 
3527             boolean continueSkipBeginningNewlines = skipBeginningNewlines;
3528             while (itr.hasNext()) {
3529                 GenericCharacters element = itr.next();
3530                 continueSkipBeginningNewlines = element.flush(continueSkipBeginningNewlines);
3531                 itr.remove();
3532             }
3533         }
3534 
3535         /**
3536          * Converts all buffered GenericCharacters to a new character array.
3537          */
3538         public char[] toChars() {
3539             StringBuilder sb = new StringBuilder();
3540             for (GenericCharacters element : bufferedCharacters) {
3541                 sb.append(element.toChars());
3542             }
3543             return sb.toString().toCharArray();
3544         }
3545 
3546         /**
3547          * Clear the buffer.
3548          */
3549         public void clear() {
3550             bufferedCharacters.clear();
3551         }
3552     }
3553 
3554 
3555     // Implement DTDHandler
3556     /**
3557      * If this method is called, the serializer is used as a
3558      * DTDHandler, which changes behavior how the serializer
3559      * handles document entities.
3560      * @see org.xml.sax.DTDHandler#notationDecl(java.lang.String, java.lang.String, java.lang.String)
3561      */
3562     public void notationDecl(String name, String pubID, String sysID) throws SAXException {
3563         // TODO Auto-generated method stub
3564         try {
3565             DTDprolog();
3566 
3567             m_writer.write(&quot;&lt;!NOTATION &quot;);
3568             m_writer.write(name);
3569             if (pubID != null) {
3570                 m_writer.write(&quot; PUBLIC \&quot;&quot;);
3571                 m_writer.write(pubID);
3572 
3573             }
3574             else {
3575                 m_writer.write(&quot; SYSTEM \&quot;&quot;);
3576                 m_writer.write(sysID);
3577             }
3578             m_writer.write(&quot;\&quot; &gt;&quot;);
3579             m_writer.write(m_lineSep, 0, m_lineSepLen);
3580         } catch (IOException e) {
3581             // TODO Auto-generated catch block
3582             e.printStackTrace();
3583         }
3584     }
3585 
3586     /**
3587      * If this method is called, the serializer is used as a
3588      * DTDHandler, which changes behavior how the serializer
3589      * handles document entities.
3590      * @see org.xml.sax.DTDHandler#unparsedEntityDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
3591      */
3592     public void unparsedEntityDecl(String name, String pubID, String sysID, String notationName) throws SAXException {
3593         // TODO Auto-generated method stub
3594         try {
3595             DTDprolog();
3596 
3597             m_writer.write(&quot;&lt;!ENTITY &quot;);
3598             m_writer.write(name);
3599             if (pubID != null) {
3600                 m_writer.write(&quot; PUBLIC \&quot;&quot;);
3601                 m_writer.write(pubID);
3602 
3603             }
3604             else {
3605                 m_writer.write(&quot; SYSTEM \&quot;&quot;);
3606                 m_writer.write(sysID);
3607             }
3608             m_writer.write(&quot;\&quot; NDATA &quot;);
3609             m_writer.write(notationName);
3610             m_writer.write(&quot; &gt;&quot;);
3611             m_writer.write(m_lineSep, 0, m_lineSepLen);
3612         } catch (IOException e) {
3613             // TODO Auto-generated catch block
3614             e.printStackTrace();
3615         }
3616     }
3617 
3618     /**
3619      * A private helper method to output the
3620      * @throws SAXException
3621      * @throws IOException
3622      */
3623     private void DTDprolog() throws SAXException, IOException {
3624         final Writer writer = m_writer;
3625         if (m_needToOutputDocTypeDecl) {
3626             outputDocTypeDecl(m_elemContext.m_elementName, false);
3627             m_needToOutputDocTypeDecl = false;
3628         }
3629         if (m_inDoctype) {
3630             writer.write(&quot; [&quot;);
3631             writer.write(m_lineSep, 0, m_lineSepLen);
3632             m_inDoctype = false;
3633         }
3634     }
3635 
3636     /**
3637      * If set to false the serializer does not expand DTD entities,
3638      * but leaves them as is, the default value is true;
3639      */
3640     public void setDTDEntityExpansion(boolean expand) {
3641         m_expandDTDEntities = expand;
3642     }
3643 
3644     /**
3645      * Remembers the cdata sections specified in the cdata-section-elements by appending the given
3646      * cdata section elements to the list. This method can be called multiple times, but once an
3647      * element is put in the list of cdata section elements it can not be removed.
3648      * This method should be used by both Xalan and XSLTC.
3649      *
3650      * @param URI_and_localNames a whitespace separated list of element names, each element
3651      * is a URI in curly braces (optional) and a local name. An example of such a parameter is:
3652      * &quot;{http://company.com}price {myURI2}book chapter&quot;
3653      */
3654     public void addCdataSectionElements(String URI_and_localNames)
3655     {
3656         if (URI_and_localNames != null)
3657             initCdataElems(URI_and_localNames);
3658         if (m_StringOfCDATASections == null)
3659             m_StringOfCDATASections = URI_and_localNames;
3660         else
3661             m_StringOfCDATASections += (&quot; &quot; + URI_and_localNames);
3662     }
3663 }
    </pre>
  </body>
</html>
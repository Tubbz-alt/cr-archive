<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ElementNSImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.xerces.internal.dom;
 23 
 24 import com.sun.org.apache.xerces.internal.xs.XSSimpleTypeDefinition;
 25 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
 26 import com.sun.org.apache.xerces.internal.impl.dv.xs.XSSimpleTypeDecl;
 27 import com.sun.org.apache.xerces.internal.impl.xs.XSComplexTypeDecl;
 28 import com.sun.org.apache.xerces.internal.util.URI;
 29 import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
 30 import org.w3c.dom.Attr;
 31 import org.w3c.dom.DOMException;
 32 
 33 
 34 
 35 /**
 36  * ElementNSImpl inherits from ElementImpl and adds namespace support.
 37  * &lt;P&gt;
 38  * The qualified name is the node name, and we store localName which is also
 39  * used in all queries. On the other hand we recompute the prefix when
 40  * necessary.
 41  *
 42  * @xerces.internal
 43  *
 44  * @author Elena litani, IBM
 45  * @author Neeraj Bajaj, Sun Microsystems
 46  */
 47 public class ElementNSImpl
 48     extends ElementImpl {
 49 
 50     //
 51     // Constants
 52     //
 53 
 54     /** Serialization version. */
 55     static final long serialVersionUID = -9142310625494392642L;
 56     static final String xmlURI = &quot;http://www.w3.org/XML/1998/namespace&quot;;
 57 
 58     //
 59     // Data
 60     //
 61 
 62     /** DOM2: Namespace URI. */
 63     protected String namespaceURI;
 64 
 65     /** DOM2: localName. */
 66     protected String localName;
 67 
 68     /** DOM3: type information */
 69     // REVISIT: we are losing the type information in DOM during serialization
 70     transient XSTypeDefinition type;
 71 
 72     protected ElementNSImpl() {
 73         super();
 74     }
 75     /**
 76      * DOM2: Constructor for Namespace implementation.
 77      */
 78     protected ElementNSImpl(CoreDocumentImpl ownerDocument,
 79                             String namespaceURI,
 80                             String qualifiedName)
 81         throws DOMException
 82     {
 83         super(ownerDocument, qualifiedName);
 84         setName(namespaceURI, qualifiedName);
 85     }
 86 
 87         private void setName(String namespaceURI, String qname) {
 88 
<a name="1" id="anc1"></a><span class="line-modified"> 89             String prefix;</span>
<span class="line-modified"> 90             // DOM Level 3: namespace URI is never empty string.</span>
<span class="line-modified"> 91             this.namespaceURI = namespaceURI;</span>
<span class="line-modified"> 92             if (namespaceURI != null) {</span>
 93             //convert the empty string to &#39;null&#39;
<a name="2" id="anc2"></a><span class="line-modified"> 94             this.namespaceURI = (namespaceURI.length() == 0) ? null : namespaceURI;</span>
<span class="line-modified"> 95             }</span>
 96 
 97         int colon1, colon2 ;
 98 
 99         //NAMESPACE_ERR:
100         //1. if the qualified name is &#39;null&#39; it is malformed.
101         //2. or if the qualifiedName is null and the namespaceURI is different from null,
102         // We dont need to check for namespaceURI != null, if qualified name is null throw DOMException.
103         if(qname == null){
104                                 String msg =
105                                         DOMMessageFormatter.formatMessage(
106                                                 DOMMessageFormatter.DOM_DOMAIN,
107                                                 &quot;NAMESPACE_ERR&quot;,
108                                                 null);
109                                 throw new DOMException(DOMException.NAMESPACE_ERR, msg);
110         }
111         else{
112                     colon1 = qname.indexOf(&#39;:&#39;);
113                     colon2 = qname.lastIndexOf(&#39;:&#39;);
114         }
115 
116                 ownerDocument.checkNamespaceWF(qname, colon1, colon2);
117                 if (colon1 &lt; 0) {
118                         // there is no prefix
119                         localName = qname;
120                         if (ownerDocument.errorChecking) {
121                             ownerDocument.checkQName(null, localName);
122                             if (qname.equals(&quot;xmlns&quot;)
123                                 &amp;&amp; (namespaceURI == null
124                                 || !namespaceURI.equals(NamespaceContext.XMLNS_URI))
125                                 || (namespaceURI!=null &amp;&amp; namespaceURI.equals(NamespaceContext.XMLNS_URI)
126                                 &amp;&amp; !qname.equals(&quot;xmlns&quot;))) {
127                                 String msg =
128                                     DOMMessageFormatter.formatMessage(
129                                             DOMMessageFormatter.DOM_DOMAIN,
130                                             &quot;NAMESPACE_ERR&quot;,
131                                             null);
132                                 throw new DOMException(DOMException.NAMESPACE_ERR, msg);
133                             }
134                         }
135                 }//there is a prefix
136                 else {
137                     prefix = qname.substring(0, colon1);
138                     localName = qname.substring(colon2 + 1);
139 
140                     //NAMESPACE_ERR:
141                     //1. if the qualifiedName has a prefix and the namespaceURI is null,
142 
143                     //2. or if the qualifiedName has a prefix that is &quot;xml&quot; and the namespaceURI
144                     //is different from &quot; http://www.w3.org/XML/1998/namespace&quot;
145 
146                     if (ownerDocument.errorChecking) {
147                         if( namespaceURI == null || ( prefix.equals(&quot;xml&quot;) &amp;&amp; !namespaceURI.equals(NamespaceContext.XML_URI) )){
148                             String msg =
149                                 DOMMessageFormatter.formatMessage(
150                                         DOMMessageFormatter.DOM_DOMAIN,
151                                         &quot;NAMESPACE_ERR&quot;,
152                                         null);
153                             throw new DOMException(DOMException.NAMESPACE_ERR, msg);
154                         }
155 
156                         ownerDocument.checkQName(prefix, localName);
157                         ownerDocument.checkDOMNSErr(prefix, namespaceURI);
158                     }
159                 }
160         }
161 
162     // when local name is known
163     protected ElementNSImpl(CoreDocumentImpl ownerDocument,
164                             String namespaceURI, String qualifiedName,
165                             String localName)
166         throws DOMException
167     {
168         super(ownerDocument, qualifiedName);
169 
170         this.localName = localName;
171         this.namespaceURI = namespaceURI;
172     }
173 
174     // for DeferredElementImpl
175     protected ElementNSImpl(CoreDocumentImpl ownerDocument,
176                             String value) {
177         super(ownerDocument, value);
178     }
179 
180     // Support for DOM Level 3 renameNode method.
181     // Note: This only deals with part of the pb. CoreDocumentImpl
182     // does all the work.
183     void rename(String namespaceURI, String qualifiedName)
184     {
185         if (needsSyncData()) {
186             synchronizeData();
187         }
188                 this.name = qualifiedName;
189         setName(namespaceURI, qualifiedName);
190         reconcileDefaultAttributes();
191     }
192 
<a name="3" id="anc3"></a>






























193     //
194     // Node methods
195     //
196 
197 
198 
199     //
200     //DOM2: Namespace methods.
201     //
202 
203     /**
204      * Introduced in DOM Level 2. &lt;p&gt;
205      *
206      * The namespace URI of this node, or null if it is unspecified.&lt;p&gt;
207      *
208      * This is not a computed value that is the result of a namespace lookup based on
209      * an examination of the namespace declarations in scope. It is merely the
210      * namespace URI given at creation time.&lt;p&gt;
211      *
212      * For nodes created with a DOM Level 1 method, such as createElement
213      * from the Document interface, this is null.
214      * @since WD-DOM-Level-2-19990923
215      */
216     public String getNamespaceURI()
217     {
218         if (needsSyncData()) {
219             synchronizeData();
220         }
221         return namespaceURI;
222     }
223 
224     /**
225      * Introduced in DOM Level 2. &lt;p&gt;
226      *
227      * The namespace prefix of this node, or null if it is unspecified. &lt;p&gt;
228      *
229      * For nodes created with a DOM Level 1 method, such as createElement
230      * from the Document interface, this is null. &lt;p&gt;
231      *
232      * @since WD-DOM-Level-2-19990923
233      */
234     public String getPrefix()
235     {
236 
237         if (needsSyncData()) {
238             synchronizeData();
239         }
240         int index = name.indexOf(&#39;:&#39;);
241         return index &lt; 0 ? null : name.substring(0, index);
242     }
243 
244     /**
245      * Introduced in DOM Level 2. &lt;p&gt;
246      *
247      * Note that setting this attribute changes the nodeName attribute, which holds the
248      * qualified name, as well as the tagName and name attributes of the Element
249      * and Attr interfaces, when applicable.&lt;p&gt;
250      *
251      * @param prefix The namespace prefix of this node, or null(empty string) if it is unspecified.
252      *
253      * @exception INVALID_CHARACTER_ERR
254      *                   Raised if the specified
255      *                   prefix contains an invalid character.
256      * @exception DOMException
257      * @since WD-DOM-Level-2-19990923
258      */
259     public void setPrefix(String prefix)
260         throws DOMException
261     {
262         if (needsSyncData()) {
263             synchronizeData();
264         }
265         if (ownerDocument.errorChecking) {
266             if (isReadOnly()) {
267                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
268                 throw new DOMException(
269                                      DOMException.NO_MODIFICATION_ALLOWED_ERR,
270                                      msg);
271             }
272             if (prefix != null &amp;&amp; prefix.length() != 0) {
273                 if (!CoreDocumentImpl.isXMLName(prefix,ownerDocument.isXML11Version())) {
274                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;INVALID_CHARACTER_ERR&quot;, null);
275                     throw new DOMException(DOMException.INVALID_CHARACTER_ERR, msg);
276                 }
277                 if (namespaceURI == null || prefix.indexOf(&#39;:&#39;) &gt;=0) {
278                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NAMESPACE_ERR&quot;, null);
279                     throw new DOMException(DOMException.NAMESPACE_ERR, msg);
280                 } else if (prefix.equals(&quot;xml&quot;)) {
281                      if (!namespaceURI.equals(xmlURI)) {
282                          String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NAMESPACE_ERR&quot;, null);
283                          throw new DOMException(DOMException.NAMESPACE_ERR, msg);
284                      }
285                 }
286             }
287 
288         }
289         // update node name with new qualifiedName
290         if (prefix !=null &amp;&amp; prefix.length() != 0) {
291             name = prefix + &quot;:&quot; + localName;
292         }
293         else {
294             name = localName;
295         }
296     }
297 
298     /**
299      * Introduced in DOM Level 2. &lt;p&gt;
300      *
301      * Returns the local part of the qualified name of this node.
302      * @since WD-DOM-Level-2-19990923
303      */
304     public String getLocalName()
305     {
306         if (needsSyncData()) {
307             synchronizeData();
308         }
309         return localName;
310     }
311 
<a name="4" id="anc4"></a><span class="line-modified">312     /**</span>
<span class="line-modified">313      * NON-DOM</span>
<span class="line-modified">314      * Returns the xml:base attribute.</span>

315      */
<a name="5" id="anc5"></a><span class="line-modified">316     protected Attr getXMLBaseAttribute() {</span>
<span class="line-modified">317         return (Attr) attributes.getNamedItemNS(&quot;http://www.w3.org/XML/1998/namespace&quot;, &quot;base&quot;);</span>
<span class="line-modified">318     } // getXMLBaseAttribute():Attr</span>










































































319 
320     /**
321      * @see org.w3c.dom.TypeInfo#getTypeName()
322      */
323     public String getTypeName() {
324         if (type !=null){
325             if (type instanceof XSSimpleTypeDecl) {
326                 return ((XSSimpleTypeDecl) type).getTypeName();
327             } else if (type instanceof XSComplexTypeDecl) {
328                 return ((XSComplexTypeDecl) type).getTypeName();
329             }
330         }
331         return null;
332     }
333 
334     /**
335      * @see org.w3c.dom.TypeInfo#getTypeNamespace()
336      */
337     public String getTypeNamespace() {
338         if (type !=null){
339             return type.getNamespace();
340         }
341         return null;
342     }
343 
344     /**
345      * Introduced in DOM Level 2. &lt;p&gt;
346      * Checks if a type is derived from another by restriction. See:
347      * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom
348      *
<a name="6" id="anc6"></a><span class="line-modified">349      * @param typeNamespaceArg</span>
350      *        The namspace of the ancestor type declaration
<a name="7" id="anc7"></a><span class="line-modified">351      * @param typeNameArg</span>
352      *        The name of the ancestor type declaration
<a name="8" id="anc8"></a><span class="line-modified">353      * @param derivationMethod</span>
<span class="line-modified">354      *        The derivation method</span>
355      *
356      * @return boolean True if the type is derived by restriciton for the
357      *         reference type
358      */
359     public boolean isDerivedFrom(String typeNamespaceArg, String typeNameArg,
360             int derivationMethod) {
361         if(needsSyncData()) {
362             synchronizeData();
363         }
364         if (type != null) {
365             if (type instanceof XSSimpleTypeDecl) {
366                 return ((XSSimpleTypeDecl) type).isDOMDerivedFrom(
367                         typeNamespaceArg, typeNameArg, derivationMethod);
368             } else if (type instanceof XSComplexTypeDecl) {
369                 return ((XSComplexTypeDecl) type).isDOMDerivedFrom(
370                         typeNamespaceArg, typeNameArg, derivationMethod);
371             }
372         }
373         return false;
374     }
375 
376     /**
377      * NON-DOM: setting type used by the DOM parser
378      * @see NodeImpl#setReadOnly
379      */
380     public void setType(XSTypeDefinition type) {
381         this.type = type;
382     }
383 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
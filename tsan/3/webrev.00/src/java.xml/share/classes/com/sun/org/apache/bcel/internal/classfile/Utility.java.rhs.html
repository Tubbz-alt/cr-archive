<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/Utility.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 package com.sun.org.apache.bcel.internal.classfile;
  21 
  22 import java.io.ByteArrayInputStream;
  23 import java.io.ByteArrayOutputStream;
  24 import java.io.CharArrayReader;
  25 import java.io.CharArrayWriter;
  26 import java.io.FilterReader;
  27 import java.io.FilterWriter;
  28 import java.io.IOException;
  29 import java.io.PrintStream;
  30 import java.io.PrintWriter;
  31 import java.io.Reader;
  32 import java.io.Writer;
  33 import java.util.ArrayList;
  34 import java.util.List;
  35 import java.util.Locale;
  36 import java.util.zip.GZIPInputStream;
  37 import java.util.zip.GZIPOutputStream;
  38 
  39 import com.sun.org.apache.bcel.internal.Const;
  40 import com.sun.org.apache.bcel.internal.util.ByteSequence;
  41 
  42 /**
  43  * Utility functions that do not really belong to any class in particular.
  44  *
<a name="2" id="anc2"></a><span class="line-modified">  45  * @LastModified: Jan 2020</span>

  46  */
  47 // @since 6.0 methods are no longer final
  48 public abstract class Utility {
  49 
<a name="3" id="anc3"></a><span class="line-modified">  50     private static int unwrap( final ThreadLocal&lt;Integer&gt; tl ) {</span>
<span class="line-modified">  51         return tl.get();</span>
  52     }
  53 
<a name="4" id="anc4"></a><span class="line-modified">  54     private static void wrap( final ThreadLocal&lt;Integer&gt; tl, final int value ) {</span>
<span class="line-modified">  55         tl.set(value);</span>
  56     }
  57 
<a name="5" id="anc5"></a><span class="line-added">  58     /* How many chars have been consumed</span>
<span class="line-added">  59      * during parsing in typeSignatureToString().</span>
<span class="line-added">  60      * Read by methodSignatureToString().</span>
<span class="line-added">  61      * Set by side effect, but only internally.</span>
<span class="line-added">  62      */</span>
  63     private static ThreadLocal&lt;Integer&gt; consumed_chars = new ThreadLocal&lt;Integer&gt;() {
<a name="6" id="anc6"></a>
  64         @Override
  65         protected Integer initialValue() {
<a name="7" id="anc7"></a><span class="line-modified">  66             return 0;</span>
  67         }
<a name="8" id="anc8"></a><span class="line-modified">  68     };</span>




  69 
<a name="9" id="anc9"></a><span class="line-modified">  70     /* The `WIDE&#39; instruction is used in the</span>
  71      * byte code to allow 16-bit wide indices
  72      * for local variables. This opcode
  73      * precedes an `ILOAD&#39;, e.g.. The opcode
  74      * immediately following takes an extra
  75      * byte which is combined with the
  76      * following byte to form a
  77      * 16-bit value.
  78      */
<a name="10" id="anc10"></a><span class="line-added">  79     private static boolean wide = false;</span>
  80 
  81 
  82     /**
  83      * Convert bit field of flags into string such as `static final&#39;.
  84      *
<a name="11" id="anc11"></a><span class="line-modified">  85      * @param  access_flags Access flags</span>
  86      * @return String representation of flags
  87      */
<a name="12" id="anc12"></a><span class="line-modified">  88     public static String accessToString( final int access_flags ) {</span>
  89         return accessToString(access_flags, false);
  90     }
  91 
<a name="13" id="anc13"></a><span class="line-added">  92 </span>
  93     /**
  94      * Convert bit field of flags into string such as `static final&#39;.
  95      *
  96      * Special case: Classes compiled with new compilers and with the
<a name="14" id="anc14"></a><span class="line-modified">  97      * `ACC_SUPER&#39; flag would be said to be &quot;synchronized&quot;. This is</span>
<span class="line-modified">  98      * because SUN used the same value for the flags `ACC_SUPER&#39; and</span>
<span class="line-added">  99      * `ACC_SYNCHRONIZED&#39;.</span>
 100      *
<a name="15" id="anc15"></a><span class="line-modified"> 101      * @param  access_flags Access flags</span>
<span class="line-modified"> 102      * @param  for_class access flags are for class qualifiers ?</span>
 103      * @return String representation of flags
 104      */
<a name="16" id="anc16"></a><span class="line-modified"> 105     public static String accessToString( final int access_flags, final boolean for_class ) {</span>
 106         final StringBuilder buf = new StringBuilder();
 107         int p = 0;
<a name="17" id="anc17"></a><span class="line-modified"> 108         for (int i = 0; p &lt; Const.MAX_ACC_FLAG_I; i++) { // Loop through known flags</span>
 109             p = pow2(i);
 110             if ((access_flags &amp; p) != 0) {
 111                 /* Special case: Classes compiled with new compilers and with the
 112                  * `ACC_SUPER&#39; flag would be said to be &quot;synchronized&quot;. This is
 113                  * because SUN used the same value for the flags `ACC_SUPER&#39; and
 114                  * `ACC_SYNCHRONIZED&#39;.
 115                  */
 116                 if (for_class &amp;&amp; ((p == Const.ACC_SUPER) || (p == Const.ACC_INTERFACE))) {
 117                     continue;
 118                 }
 119                 buf.append(Const.getAccessName(i)).append(&quot; &quot;);
 120             }
 121         }
 122         return buf.toString().trim();
 123     }
 124 
<a name="18" id="anc18"></a><span class="line-added"> 125 </span>
 126     /**
 127      * @param access_flags the class flags
 128      *
 129      * @return &quot;class&quot; or &quot;interface&quot;, depending on the ACC_INTERFACE flag
 130      */
<a name="19" id="anc19"></a><span class="line-modified"> 131     public static String classOrInterface( final int access_flags ) {</span>
 132         return ((access_flags &amp; Const.ACC_INTERFACE) != 0) ? &quot;interface&quot; : &quot;class&quot;;
 133     }
 134 
<a name="20" id="anc20"></a><span class="line-added"> 135 </span>
 136     /**
 137      * Disassemble a byte array of JVM byte codes starting from code line
 138      * `index&#39; and return the disassembled string representation. Decode only
<a name="21" id="anc21"></a><span class="line-modified"> 139      * `num&#39; opcodes (including their operands), use -1 if you want to</span>
<span class="line-modified"> 140      * decompile everything.</span>
 141      *
<a name="22" id="anc22"></a><span class="line-modified"> 142      * @param  code byte code array</span>
<span class="line-modified"> 143      * @param  constant_pool Array of constants</span>
<span class="line-modified"> 144      * @param  index offset in `code&#39; array</span>
 145      * &lt;EM&gt;(number of opcodes, not bytes!)&lt;/EM&gt;
<a name="23" id="anc23"></a><span class="line-modified"> 146      * @param  length number of opcodes to decompile, -1 for all</span>
<span class="line-modified"> 147      * @param  verbose be verbose, e.g. print constant pool index</span>
 148      * @return String representation of byte codes
 149      */
<a name="24" id="anc24"></a><span class="line-modified"> 150     public static String codeToString( final byte[] code, final ConstantPool constant_pool, final int index,</span>
<span class="line-modified"> 151             final int length, final boolean verbose ) {</span>
<span class="line-modified"> 152         final StringBuilder buf = new StringBuilder(code.length * 20); // Should be sufficient // CHECKSTYLE IGNORE MagicNumber</span>

 153         try (ByteSequence stream = new ByteSequence(code)) {
 154             for (int i = 0; i &lt; index; i++) {
 155                 codeToString(stream, constant_pool, verbose);
 156             }
 157             for (int i = 0; stream.available() &gt; 0; i++) {
 158                 if ((length &lt; 0) || (i &lt; length)) {
 159                     final String indices = fillup(stream.getIndex() + &quot;:&quot;, 6, true, &#39; &#39;);
<a name="25" id="anc25"></a><span class="line-modified"> 160                     buf.append(indices).append(codeToString(stream, constant_pool, verbose)).append(&#39;\n&#39;);</span>


 161                 }
 162             }
 163         } catch (final IOException e) {
 164             throw new ClassFormatException(&quot;Byte code error: &quot; + buf.toString(), e);
 165         }
 166         return buf.toString();
 167     }
 168 
<a name="26" id="anc26"></a><span class="line-modified"> 169 </span>
<span class="line-modified"> 170     public static String codeToString( final byte[] code, final ConstantPool constant_pool, final int index, final int length ) {</span>
 171         return codeToString(code, constant_pool, index, length, true);
 172     }
 173 
<a name="27" id="anc27"></a><span class="line-added"> 174 </span>
 175     /**
<a name="28" id="anc28"></a><span class="line-modified"> 176      * Disassemble a stream of byte codes and return the</span>
<span class="line-added"> 177      * string representation.</span>
 178      *
<a name="29" id="anc29"></a><span class="line-modified"> 179      * @param  bytes stream of bytes</span>
<span class="line-modified"> 180      * @param  constant_pool Array of constants</span>
<span class="line-modified"> 181      * @param  verbose be verbose, e.g. print constant pool index</span>
 182      * @return String representation of byte code
 183      *
<a name="30" id="anc30"></a><span class="line-modified"> 184      * @throws IOException if a failure from reading from the bytes argument occurs</span>

 185      */
 186     @SuppressWarnings(&quot;fallthrough&quot;) // by design for case Const.INSTANCEOF
 187     public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool,
 188             final boolean verbose) throws IOException {
 189         final short opcode = (short) bytes.readUnsignedByte();
 190         int default_offset = 0;
 191         int low;
 192         int high;
 193         int npairs;
 194         int index;
 195         int vindex;
 196         int constant;
 197         int[] match;
 198         int[] jump_table;
 199         int no_pad_bytes = 0;
 200         int offset;
 201         final StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
 202         /* Special case: Skip (0-3) padding bytes, i.e., the
 203          * following bytes are 4-byte-aligned
 204          */
 205         if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
 206             final int remainder = bytes.getIndex() % 4;
 207             no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
 208             for (int i = 0; i &lt; no_pad_bytes; i++) {
 209                 byte b;
 210                 if ((b = bytes.readByte()) != 0) {
 211                     System.err.println(&quot;Warning: Padding byte != 0 in &quot;
 212                             + Const.getOpcodeName(opcode) + &quot;:&quot; + b);
 213                 }
 214             }
 215             // Both cases have a field default_offset in common
 216             default_offset = bytes.readInt();
 217         }
 218         switch (opcode) {
 219             /* Table switch has variable length arguments.
 220              */
 221             case Const.TABLESWITCH:
 222                 low = bytes.readInt();
 223                 high = bytes.readInt();
 224                 offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
 225                 default_offset += offset;
 226                 buf.append(&quot;\tdefault = &quot;).append(default_offset).append(&quot;, low = &quot;).append(low)
 227                         .append(&quot;, high = &quot;).append(high).append(&quot;(&quot;);
 228                 jump_table = new int[high - low + 1];
 229                 for (int i = 0; i &lt; jump_table.length; i++) {
 230                     jump_table[i] = offset + bytes.readInt();
 231                     buf.append(jump_table[i]);
 232                     if (i &lt; jump_table.length - 1) {
 233                         buf.append(&quot;, &quot;);
 234                     }
 235                 }
 236                 buf.append(&quot;)&quot;);
 237                 break;
 238             /* Lookup switch has variable length arguments.
 239              */
 240             case Const.LOOKUPSWITCH: {
 241                 npairs = bytes.readInt();
 242                 offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
 243                 match = new int[npairs];
 244                 jump_table = new int[npairs];
 245                 default_offset += offset;
 246                 buf.append(&quot;\tdefault = &quot;).append(default_offset).append(&quot;, npairs = &quot;).append(
 247                         npairs).append(&quot; (&quot;);
 248                 for (int i = 0; i &lt; npairs; i++) {
 249                     match[i] = bytes.readInt();
 250                     jump_table[i] = offset + bytes.readInt();
 251                     buf.append(&quot;(&quot;).append(match[i]).append(&quot;, &quot;).append(jump_table[i]).append(&quot;)&quot;);
 252                     if (i &lt; npairs - 1) {
 253                         buf.append(&quot;, &quot;);
 254                     }
 255                 }
 256                 buf.append(&quot;)&quot;);
 257             }
<a name="31" id="anc31"></a><span class="line-modified"> 258                 break;</span>
 259             /* Two address bytes + offset from start of byte stream form the
 260              * jump target
 261              */
 262             case Const.GOTO:
 263             case Const.IFEQ:
 264             case Const.IFGE:
 265             case Const.IFGT:
 266             case Const.IFLE:
 267             case Const.IFLT:
 268             case Const.JSR:
 269             case Const.IFNE:
 270             case Const.IFNONNULL:
 271             case Const.IFNULL:
 272             case Const.IF_ACMPEQ:
 273             case Const.IF_ACMPNE:
 274             case Const.IF_ICMPEQ:
 275             case Const.IF_ICMPGE:
 276             case Const.IF_ICMPGT:
 277             case Const.IF_ICMPLE:
 278             case Const.IF_ICMPLT:
 279             case Const.IF_ICMPNE:
 280                 buf.append(&quot;\t\t#&quot;).append((bytes.getIndex() - 1) + bytes.readShort());
 281                 break;
 282             /* 32-bit wide jumps
 283              */
 284             case Const.GOTO_W:
 285             case Const.JSR_W:
 286                 buf.append(&quot;\t\t#&quot;).append((bytes.getIndex() - 1) + bytes.readInt());
 287                 break;
 288             /* Index byte references local variable (register)
 289              */
 290             case Const.ALOAD:
 291             case Const.ASTORE:
 292             case Const.DLOAD:
 293             case Const.DSTORE:
 294             case Const.FLOAD:
 295             case Const.FSTORE:
 296             case Const.ILOAD:
 297             case Const.ISTORE:
 298             case Const.LLOAD:
 299             case Const.LSTORE:
 300             case Const.RET:
 301                 if (wide) {
 302                     vindex = bytes.readUnsignedShort();
 303                     wide = false; // Clear flag
 304                 } else {
 305                     vindex = bytes.readUnsignedByte();
 306                 }
 307                 buf.append(&quot;\t\t%&quot;).append(vindex);
 308                 break;
 309             /*
 310              * Remember wide byte which is used to form a 16-bit address in the
 311              * following instruction. Relies on that the method is called again with
 312              * the following opcode.
 313              */
 314             case Const.WIDE:
 315                 wide = true;
 316                 buf.append(&quot;\t(wide)&quot;);
 317                 break;
 318             /* Array of basic type.
 319              */
 320             case Const.NEWARRAY:
 321                 buf.append(&quot;\t\t&lt;&quot;).append(Const.getTypeName(bytes.readByte())).append(&quot;&gt;&quot;);
 322                 break;
 323             /* Access object/class fields.
 324              */
 325             case Const.GETFIELD:
 326             case Const.GETSTATIC:
 327             case Const.PUTFIELD:
 328             case Const.PUTSTATIC:
 329                 index = bytes.readUnsignedShort();
 330                 buf.append(&quot;\t\t&quot;).append(
 331                         constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(
<a name="32" id="anc32"></a><span class="line-modified"> 332                         verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);</span>
 333                 break;
 334             /* Operands are references to classes in constant pool
 335              */
 336             case Const.NEW:
 337             case Const.CHECKCAST:
 338                 buf.append(&quot;\t&quot;);
<a name="33" id="anc33"></a><span class="line-modified"> 339                 //$FALL-THROUGH$</span>
 340             case Const.INSTANCEOF:
 341                 index = bytes.readUnsignedShort();
 342                 buf.append(&quot;\t&lt;&quot;).append(
 343                         constant_pool.constantToString(index, Const.CONSTANT_Class))
 344                         .append(&quot;&gt;&quot;).append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 345                 break;
 346             /* Operands are references to methods in constant pool
 347              */
 348             case Const.INVOKESPECIAL:
 349             case Const.INVOKESTATIC:
 350                 index = bytes.readUnsignedShort();
 351                 final Constant c = constant_pool.getConstant(index);
 352                 // With Java8 operand may be either a CONSTANT_Methodref
 353                 // or a CONSTANT_InterfaceMethodref.   (markro)
 354                 buf.append(&quot;\t&quot;).append(
 355                         constant_pool.constantToString(index, c.getTag()))
 356                         .append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 357                 break;
 358             case Const.INVOKEVIRTUAL:
 359                 index = bytes.readUnsignedShort();
 360                 buf.append(&quot;\t&quot;).append(
 361                         constant_pool.constantToString(index, Const.CONSTANT_Methodref))
 362                         .append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 363                 break;
 364             case Const.INVOKEINTERFACE:
 365                 index = bytes.readUnsignedShort();
 366                 final int nargs = bytes.readUnsignedByte(); // historical, redundant
 367                 buf.append(&quot;\t&quot;).append(
 368                         constant_pool
<a name="34" id="anc34"></a><span class="line-modified"> 369                                 .constantToString(index, Const.CONSTANT_InterfaceMethodref))</span>
 370                         .append(verbose ? &quot; (&quot; + index + &quot;)\t&quot; : &quot;&quot;).append(nargs).append(&quot;\t&quot;)
 371                         .append(bytes.readUnsignedByte()); // Last byte is a reserved space
 372                 break;
 373             case Const.INVOKEDYNAMIC:
 374                 index = bytes.readUnsignedShort();
 375                 buf.append(&quot;\t&quot;).append(
 376                         constant_pool
<a name="35" id="anc35"></a><span class="line-modified"> 377                                 .constantToString(index, Const.CONSTANT_InvokeDynamic))</span>
 378                         .append(verbose ? &quot; (&quot; + index + &quot;)\t&quot; : &quot;&quot;)
<a name="36" id="anc36"></a><span class="line-modified"> 379                         .append(bytes.readUnsignedByte())  // Thrid byte is a reserved space</span>
 380                         .append(bytes.readUnsignedByte()); // Last byte is a reserved space
 381                 break;
 382             /* Operands are references to items in constant pool
 383              */
 384             case Const.LDC_W:
 385             case Const.LDC2_W:
 386                 index = bytes.readUnsignedShort();
 387                 buf.append(&quot;\t\t&quot;).append(
 388                         constant_pool.constantToString(index, constant_pool.getConstant(index)
 389                                 .getTag())).append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 390                 break;
 391             case Const.LDC:
 392                 index = bytes.readUnsignedByte();
 393                 buf.append(&quot;\t\t&quot;).append(
 394                         constant_pool.constantToString(index, constant_pool.getConstant(index)
 395                                 .getTag())).append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 396                 break;
 397             /* Array of references.
 398              */
 399             case Const.ANEWARRAY:
 400                 index = bytes.readUnsignedShort();
 401                 buf.append(&quot;\t\t&lt;&quot;).append(
 402                         compactClassName(constant_pool.getConstantString(index,
<a name="37" id="anc37"></a><span class="line-modified"> 403                                 Const.CONSTANT_Class), false)).append(&quot;&gt;&quot;).append(</span>
<span class="line-modified"> 404                         verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);</span>
 405                 break;
 406             /* Multidimensional array of references.
 407              */
 408             case Const.MULTIANEWARRAY: {
 409                 index = bytes.readUnsignedShort();
 410                 final int dimensions = bytes.readUnsignedByte();
 411                 buf.append(&quot;\t&lt;&quot;).append(
 412                         compactClassName(constant_pool.getConstantString(index,
<a name="38" id="anc38"></a><span class="line-modified"> 413                                 Const.CONSTANT_Class), false)).append(&quot;&gt;\t&quot;).append(dimensions)</span>
 414                         .append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 415             }
<a name="39" id="anc39"></a><span class="line-modified"> 416                 break;</span>
 417             /* Increment local variable.
 418              */
 419             case Const.IINC:
 420                 if (wide) {
 421                     vindex = bytes.readUnsignedShort();
 422                     constant = bytes.readShort();
 423                     wide = false;
 424                 } else {
 425                     vindex = bytes.readUnsignedByte();
 426                     constant = bytes.readByte();
 427                 }
 428                 buf.append(&quot;\t\t%&quot;).append(vindex).append(&quot;\t&quot;).append(constant);
 429                 break;
 430             default:
 431                 if (Const.getNoOfOperands(opcode) &gt; 0) {
 432                     for (int i = 0; i &lt; Const.getOperandTypeCount(opcode); i++) {
 433                         buf.append(&quot;\t\t&quot;);
 434                         switch (Const.getOperandType(opcode, i)) {
 435                             case Const.T_BYTE:
 436                                 buf.append(bytes.readByte());
 437                                 break;
 438                             case Const.T_SHORT:
 439                                 buf.append(bytes.readShort());
 440                                 break;
 441                             case Const.T_INT:
 442                                 buf.append(bytes.readInt());
 443                                 break;
 444                             default: // Never reached
 445                                 throw new IllegalStateException(&quot;Unreachable default case reached!&quot;);
 446                         }
 447                     }
 448                 }
 449         }
 450         return buf.toString();
 451     }
 452 
<a name="40" id="anc40"></a><span class="line-modified"> 453 </span>
<span class="line-added"> 454     public static String codeToString( final ByteSequence bytes, final ConstantPool constant_pool )</span>
 455             throws IOException {
 456         return codeToString(bytes, constant_pool, true);
 457     }
 458 
<a name="41" id="anc41"></a><span class="line-added"> 459 </span>
 460     /**
 461      * Shorten long class names, &lt;em&gt;java/lang/String&lt;/em&gt; becomes
 462      * &lt;em&gt;String&lt;/em&gt;.
 463      *
 464      * @param str The long class name
 465      * @return Compacted class name
 466      */
<a name="42" id="anc42"></a><span class="line-modified"> 467     public static String compactClassName( final String str ) {</span>
 468         return compactClassName(str, true);
 469     }
 470 
<a name="43" id="anc43"></a><span class="line-added"> 471 </span>
<span class="line-added"> 472     /**</span>
<span class="line-added"> 473      * Shorten long class names, &lt;em&gt;java/lang/String&lt;/em&gt; becomes</span>
<span class="line-added"> 474      * &lt;em&gt;java.lang.String&lt;/em&gt;,</span>
<span class="line-added"> 475      * e.g.. If &lt;em&gt;chopit&lt;/em&gt; is &lt;em&gt;true&lt;/em&gt; the prefix &lt;em&gt;java.lang&lt;/em&gt;</span>
<span class="line-added"> 476      * is also removed.</span>
<span class="line-added"> 477      *</span>
<span class="line-added"> 478      * @param str The long class name</span>
<span class="line-added"> 479      * @param chopit flag that determines whether chopping is executed or not</span>
<span class="line-added"> 480      * @return Compacted class name</span>
<span class="line-added"> 481      */</span>
<span class="line-added"> 482     public static String compactClassName( final String str, final boolean chopit ) {</span>
<span class="line-added"> 483         return compactClassName(str, &quot;java.lang.&quot;, chopit);</span>
<span class="line-added"> 484     }</span>
<span class="line-added"> 485 </span>
<span class="line-added"> 486 </span>
 487     /**
 488      * Shorten long class name &lt;em&gt;str&lt;/em&gt;, i.e., chop off the &lt;em&gt;prefix&lt;/em&gt;,
<a name="44" id="anc44"></a><span class="line-modified"> 489      * if the</span>
<span class="line-modified"> 490      * class name starts with this string and the flag &lt;em&gt;chopit&lt;/em&gt; is true.</span>
<span class="line-added"> 491      * Slashes &lt;em&gt;/&lt;/em&gt; are converted to dots &lt;em&gt;.&lt;/em&gt;.</span>
 492      *
 493      * @param str The long class name
 494      * @param prefix The prefix the get rid off
<a name="45" id="anc45"></a><span class="line-modified"> 495      * @param chopit flag that determines whether chopping is executed or not</span>
 496      * @return Compacted class name
 497      */
<a name="46" id="anc46"></a><span class="line-modified"> 498     public static String compactClassName( String str, final String prefix, final boolean chopit ) {</span>
 499         final int len = prefix.length();
 500         str = str.replace(&#39;/&#39;, &#39;.&#39;); // Is `/&#39; on all systems, even DOS
 501         if (chopit) {
 502             // If string starts with `prefix&#39; and contains no further dots
 503             if (str.startsWith(prefix) &amp;&amp; (str.substring(len).indexOf(&#39;.&#39;) == -1)) {
 504                 str = str.substring(len);
 505             }
 506         }
 507         return str;
 508     }
 509 
<a name="47" id="anc47"></a>












 510 
 511     /**
 512      * @return `flag&#39; with bit `i&#39; set to 1
 513      */
<a name="48" id="anc48"></a><span class="line-modified"> 514     public static int setBit( final int flag, final int i ) {</span>
 515         return flag | pow2(i);
 516     }
 517 
<a name="49" id="anc49"></a><span class="line-added"> 518 </span>
 519     /**
 520      * @return `flag&#39; with bit `i&#39; set to 0
 521      */
<a name="50" id="anc50"></a><span class="line-modified"> 522     public static int clearBit( final int flag, final int i ) {</span>
 523         final int bit = pow2(i);
 524         return (flag &amp; bit) == 0 ? flag : flag ^ bit;
 525     }
 526 
<a name="51" id="anc51"></a><span class="line-added"> 527 </span>
 528     /**
 529      * @return true, if bit `i&#39; in `flag&#39; is set
 530      */
<a name="52" id="anc52"></a><span class="line-modified"> 531     public static boolean isSet( final int flag, final int i ) {</span>
 532         return (flag &amp; pow2(i)) != 0;
 533     }
 534 
<a name="53" id="anc53"></a><span class="line-added"> 535 </span>
 536     /**
<a name="54" id="anc54"></a><span class="line-modified"> 537      * Converts string containing the method return and argument types</span>
<span class="line-modified"> 538      * to a byte code method signature.</span>
 539      *
<a name="55" id="anc55"></a><span class="line-modified"> 540      * @param  ret Return type of method</span>
<span class="line-modified"> 541      * @param  argv Types of method arguments</span>
 542      * @return Byte code representation of method signature
 543      *
 544      * @throws ClassFormatException if the signature is for Void
 545      */
<a name="56" id="anc56"></a><span class="line-modified"> 546     public static String methodTypeToSignature( final String ret, final String[] argv )</span>
 547             throws ClassFormatException {
 548         final StringBuilder buf = new StringBuilder(&quot;(&quot;);
 549         String str;
 550         if (argv != null) {
 551             for (final String element : argv) {
 552                 str = getSignature(element);
 553                 if (str.endsWith(&quot;V&quot;)) {
 554                     throw new ClassFormatException(&quot;Invalid type: &quot; + element);
 555                 }
 556                 buf.append(str);
 557             }
 558         }
 559         str = getSignature(ret);
 560         buf.append(&quot;)&quot;).append(str);
 561         return buf.toString();
 562     }
 563 
<a name="57" id="anc57"></a><span class="line-added"> 564 </span>
 565     /**
<a name="58" id="anc58"></a><span class="line-modified"> 566      * Converts argument list portion of method signature to string with all class names compacted.</span>
<span class="line-modified"> 567      *</span>
<span class="line-added"> 568      * @param  signature    Method signature</span>
<span class="line-added"> 569      * @return String Array of argument types</span>
 570      * @throws ClassFormatException
 571      */
<a name="59" id="anc59"></a><span class="line-modified"> 572     public static String[] methodSignatureArgumentTypes( final String signature )</span>
 573             throws ClassFormatException {
 574         return methodSignatureArgumentTypes(signature, true);
 575     }
 576 
<a name="60" id="anc60"></a><span class="line-added"> 577 </span>
 578     /**
<a name="61" id="anc61"></a><span class="line-modified"> 579      * Converts argument list portion of method signature to string.</span>
<span class="line-modified"> 580      *</span>
<span class="line-modified"> 581      * @param  signature    Method signature</span>
<span class="line-added"> 582      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-added"> 583      * @return String Array of argument types</span>
 584      * @throws ClassFormatException
 585      */
<a name="62" id="anc62"></a><span class="line-modified"> 586     public static String[] methodSignatureArgumentTypes( final String signature, final boolean chopit )</span>
 587             throws ClassFormatException {
 588         final List&lt;String&gt; vec = new ArrayList&lt;&gt;();
 589         int index;
<a name="63" id="anc63"></a><span class="line-modified"> 590         try {</span>
<span class="line-modified"> 591             // Skip any type arguments to read argument declarations between `(&#39; and `)&#39;</span>
<span class="line-added"> 592             index = signature.indexOf(&#39;(&#39;) + 1;</span>
<span class="line-added"> 593             if (index &lt;= 0) {</span>
 594                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
 595             }
<a name="64" id="anc64"></a>
 596             while (signature.charAt(index) != &#39;)&#39;) {
<a name="65" id="anc65"></a><span class="line-modified"> 597                 vec.add(typeSignatureToString(signature.substring(index), chopit));</span>
 598                 //corrected concurrent private static field acess
 599                 index += unwrap(consumed_chars); // update position
 600             }
 601         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
 602             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
 603         }
 604         return vec.toArray(new String[vec.size()]);
 605     }
 606 
<a name="66" id="anc66"></a><span class="line-added"> 607 </span>
 608     /**
<a name="67" id="anc67"></a><span class="line-modified"> 609      * Converts return type portion of method signature to string with all class names compacted.</span>
<span class="line-modified"> 610      *</span>
<span class="line-added"> 611      * @param  signature    Method signature</span>
<span class="line-added"> 612      * @return String representation of method return type</span>
 613      * @throws ClassFormatException
 614      */
<a name="68" id="anc68"></a><span class="line-modified"> 615     public static String methodSignatureReturnType( final String signature ) throws ClassFormatException {</span>

 616         return methodSignatureReturnType(signature, true);
 617     }
 618 
<a name="69" id="anc69"></a><span class="line-added"> 619 </span>
 620     /**
<a name="70" id="anc70"></a><span class="line-modified"> 621      * Converts return type portion of method signature to string.</span>
<span class="line-modified"> 622      *</span>
<span class="line-modified"> 623      * @param  signature    Method signature</span>
<span class="line-added"> 624      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-added"> 625      * @return String representation of method return type</span>
 626      * @throws ClassFormatException
 627      */
<a name="71" id="anc71"></a><span class="line-modified"> 628     public static String methodSignatureReturnType( final String signature, final boolean chopit ) throws ClassFormatException {</span>

 629         int index;
 630         String type;
 631         try {
 632             // Read return type after `)&#39;
 633             index = signature.lastIndexOf(&#39;)&#39;) + 1;
<a name="72" id="anc72"></a><span class="line-modified"> 634             if (index &lt;= 0) {</span>
<span class="line-added"> 635                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);</span>
<span class="line-added"> 636             }</span>
<span class="line-added"> 637             type = typeSignatureToString(signature.substring(index), chopit);</span>
 638         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
 639             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
 640         }
 641         return type;
 642     }
 643 
<a name="73" id="anc73"></a><span class="line-added"> 644 </span>
 645     /**
 646      * Converts method signature to string with all class names compacted.
 647      *
<a name="74" id="anc74"></a><span class="line-modified"> 648      * @param  signature to convert</span>
<span class="line-modified"> 649      * @param  name of method</span>
<span class="line-modified"> 650      * @param  access flags of method</span>
 651      * @return Human readable signature
 652      */
<a name="75" id="anc75"></a><span class="line-modified"> 653     public static String methodSignatureToString( final String signature, final String name, final String access ) {</span>

 654         return methodSignatureToString(signature, name, access, true);
 655     }
 656 
<a name="76" id="anc76"></a><span class="line-modified"> 657 </span>
<span class="line-modified"> 658     /**</span>
<span class="line-added"> 659      * Converts method signature to string.</span>
<span class="line-added"> 660      *</span>
<span class="line-added"> 661      * @param  signature to convert</span>
<span class="line-added"> 662      * @param  name of method</span>
<span class="line-added"> 663      * @param  access flags of method</span>
<span class="line-added"> 664      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-added"> 665      * @return Human readable signature</span>
<span class="line-added"> 666      */</span>
<span class="line-added"> 667     public static String methodSignatureToString( final String signature, final String name, final String access, final boolean chopit ) {</span>
 668         return methodSignatureToString(signature, name, access, chopit, null);
 669     }
 670 
<a name="77" id="anc77"></a><span class="line-added"> 671 </span>
 672     /**
<a name="78" id="anc78"></a><span class="line-modified"> 673      * This method converts a method signature string into a Java type declaration like</span>






















 674      * `void main(String[])&#39; and throws a `ClassFormatException&#39; when the parsed
 675      * type is invalid.
 676      *
<a name="79" id="anc79"></a><span class="line-modified"> 677      * @param  signature    Method signature</span>
<span class="line-modified"> 678      * @param  name         Method name</span>
<span class="line-modified"> 679      * @param  access       Method access rights</span>
<span class="line-modified"> 680      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-modified"> 681      * @param  vars the LocalVariableTable for the method</span>
 682      * @return Java type declaration
 683      * @throws ClassFormatException
 684      */
<a name="80" id="anc80"></a><span class="line-modified"> 685     public static String methodSignatureToString( final String signature, final String name,</span>
<span class="line-modified"> 686             final String access, final boolean chopit, final LocalVariableTable vars ) throws ClassFormatException {</span>

 687         final StringBuilder buf = new StringBuilder(&quot;(&quot;);
 688         String type;
 689         int index;
 690         int var_index = access.contains(&quot;static&quot;) ? 0 : 1;
<a name="81" id="anc81"></a><span class="line-modified"> 691         try {</span>
<span class="line-modified"> 692             // Skip any type arguments to read argument declarations between `(&#39; and `)&#39;</span>
<span class="line-added"> 693             index = signature.indexOf(&#39;(&#39;) + 1;</span>
<span class="line-added"> 694             if (index &lt;= 0) {</span>
 695                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
 696             }
<a name="82" id="anc82"></a>
 697             while (signature.charAt(index) != &#39;)&#39;) {
<a name="83" id="anc83"></a><span class="line-modified"> 698                 final String param_type = typeSignatureToString(signature.substring(index), chopit);</span>
 699                 buf.append(param_type);
 700                 if (vars != null) {
 701                     final LocalVariable l = vars.getLocalVariable(var_index, 0);
 702                     if (l != null) {
 703                         buf.append(&quot; &quot;).append(l.getName());
 704                     }
 705                 } else {
 706                     buf.append(&quot; arg&quot;).append(var_index);
 707                 }
 708                 if (&quot;double&quot;.equals(param_type) || &quot;long&quot;.equals(param_type)) {
 709                     var_index += 2;
 710                 } else {
 711                     var_index++;
 712                 }
 713                 buf.append(&quot;, &quot;);
 714                 //corrected concurrent private static field acess
 715                 index += unwrap(consumed_chars); // update position
 716             }
 717             index++; // update position
 718             // Read return type after `)&#39;
<a name="84" id="anc84"></a><span class="line-modified"> 719             type = typeSignatureToString(signature.substring(index), chopit);</span>
 720         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
 721             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
 722         }
<a name="85" id="anc85"></a><span class="line-added"> 723         // ignore any throws information in the signature</span>
 724         if (buf.length() &gt; 1) {
 725             buf.setLength(buf.length() - 2);
 726         }
 727         buf.append(&quot;)&quot;);
 728         return access + ((access.length() &gt; 0) ? &quot; &quot; : &quot;&quot;) + // May be an empty string
 729                 type + &quot; &quot; + name + buf.toString();
 730     }
 731 
<a name="86" id="anc86"></a><span class="line-modified"> 732 </span>
<span class="line-modified"> 733     private static int pow2( final int n ) {</span>
 734         return 1 &lt;&lt; n;
 735     }
 736 
<a name="87" id="anc87"></a><span class="line-added"> 737 </span>
 738     /**
<a name="88" id="anc88"></a><span class="line-modified"> 739      * Replace all occurrences of &lt;em&gt;old&lt;/em&gt; in &lt;em&gt;str&lt;/em&gt; with &lt;em&gt;new&lt;/em&gt;.</span>

 740      *
 741      * @param str String to permute
 742      * @param old String to be replaced
 743      * @param new_ Replacement string
 744      * @return new String object
 745      */
<a name="89" id="anc89"></a><span class="line-modified"> 746     public static String replace( String str, final String old, final String new_ ) {</span>
 747         int index;
 748         int old_index;
 749         try {
 750             if (str.contains(old)) { // `old&#39; found in str
 751                 final StringBuilder buf = new StringBuilder();
 752                 old_index = 0; // String start offset
 753                 // While we have something to replace
 754                 while ((index = str.indexOf(old, old_index)) != -1) {
 755                     buf.append(str.substring(old_index, index)); // append prefix
 756                     buf.append(new_); // append replacement
 757                     old_index = index + old.length(); // Skip `old&#39;.length chars
 758                 }
 759                 buf.append(str.substring(old_index)); // append rest of string
 760                 str = buf.toString();
 761             }
 762         } catch (final StringIndexOutOfBoundsException e) { // Should not occur
 763             System.err.println(e);
 764         }
 765         return str;
 766     }
 767 
<a name="90" id="anc90"></a><span class="line-added"> 768 </span>
 769     /**
<a name="91" id="anc91"></a><span class="line-modified"> 770      * WARNING:</span>
 771      *
<a name="92" id="anc92"></a><span class="line-modified"> 772      * There is some nomenclature confusion through much of the BCEL code base with</span>
<span class="line-modified"> 773      * respect to the terms Descriptor and Signature.  For the offical definitions see:</span>
<span class="line-added"> 774      *</span>
<span class="line-added"> 775      * @see &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3&quot;&gt;</span>
<span class="line-added"> 776      * Descriptors in The Java Virtual Machine Specification&lt;/a&gt;</span>
<span class="line-added"> 777      *</span>
<span class="line-added"> 778      * @see &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9.1&quot;&gt;</span>
<span class="line-added"> 779      * Signatures in The Java Virtual Machine Specification&lt;/a&gt;</span>
<span class="line-added"> 780      *</span>
<span class="line-added"> 781      * In brief, a descriptor is a string representing the type of a field or method.</span>
<span class="line-added"> 782      * Signatures are similar, but more complex.  Signatures are used to encode declarations</span>
<span class="line-added"> 783      * written in the Java programming language that use types outside the type system of the</span>
<span class="line-added"> 784      * Java Virtual Machine.  They are used to describe the type of any class, interface,</span>
<span class="line-added"> 785      * constructor, method or field whose declaration uses type variables or parameterized types.</span>
<span class="line-added"> 786      *</span>
<span class="line-added"> 787      * To parse a descriptor, call typeSignatureToString.</span>
<span class="line-added"> 788      * To parse a signature, call signatureToString.</span>
<span class="line-added"> 789      *</span>
<span class="line-added"> 790      * Note that if the signature string is a single, non-generic item, the call to</span>
<span class="line-added"> 791      * signatureToString reduces to a call to typeSignatureToString.</span>
<span class="line-added"> 792      * Also note, that if you only wish to parse the first item in a longer signature</span>
<span class="line-added"> 793      * string, you should call typeSignatureToString directly.</span>
 794      */
<a name="93" id="anc93"></a><span class="line-modified"> 795 </span>
<span class="line-added"> 796 </span>
<span class="line-added"> 797     /**</span>
<span class="line-added"> 798      * Converts a signature to a string with all class names compacted.</span>
<span class="line-added"> 799      * Class, Method and Type signatures are supported.</span>
<span class="line-added"> 800      * Enum and Interface signatures are not supported.</span>
<span class="line-added"> 801      *</span>
<span class="line-added"> 802      * @param  signature signature to convert</span>
<span class="line-added"> 803      * @return String containg human readable signature</span>
<span class="line-added"> 804      */</span>
<span class="line-added"> 805     public static String signatureToString( final String signature ) {</span>
 806         return signatureToString(signature, true);
 807     }
 808 
<a name="94" id="anc94"></a><span class="line-added"> 809 </span>
 810     /**
<a name="95" id="anc95"></a><span class="line-modified"> 811      * Converts a signature to a string.</span>
<span class="line-modified"> 812      * Class, Method and Type signatures are supported.</span>
<span class="line-modified"> 813      * Enum and Interface signatures are not supported.</span>
 814      *
<a name="96" id="anc96"></a><span class="line-modified"> 815      * @param  signature signature to convert</span>
<span class="line-modified"> 816      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-modified"> 817      * @return String containg human readable signature</span>
<span class="line-modified"> 818      */</span>
<span class="line-modified"> 819     public static String signatureToString( final String signature, final boolean chopit ) {</span>
<span class="line-modified"> 820         String type = &quot;&quot;;</span>
<span class="line-added"> 821         String typeParams = &quot;&quot;;</span>
<span class="line-added"> 822         int index = 0;</span>
<span class="line-added"> 823         if (signature.charAt(0) == &#39;&lt;&#39;) {</span>
<span class="line-added"> 824             // we have type paramters</span>
<span class="line-added"> 825             typeParams = typeParamTypesToString(signature, chopit);</span>
<span class="line-added"> 826             index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 827         }</span>
<span class="line-added"> 828         if (signature.charAt(index) == &#39;(&#39;) {</span>
<span class="line-added"> 829             // We have a Method signature.</span>
<span class="line-added"> 830             // add types of arguments</span>
<span class="line-added"> 831             type = typeParams + typeSignaturesToString(signature.substring(index), chopit, &#39;)&#39;);</span>
<span class="line-added"> 832             index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 833             // add return type</span>
<span class="line-added"> 834             type = type + typeSignatureToString(signature.substring(index), chopit);</span>
<span class="line-added"> 835             index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 836             // ignore any throws information in the signature</span>
<span class="line-added"> 837             return type;</span>
<span class="line-added"> 838         } else {</span>
<span class="line-added"> 839             // Could be Class or Type...</span>
<span class="line-added"> 840             type = typeSignatureToString(signature.substring(index), chopit);</span>
<span class="line-added"> 841             index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 842             if ((typeParams.length() == 0) &amp;&amp; (index == signature.length())) {</span>
<span class="line-added"> 843                 // We have a Type signature.</span>
<span class="line-added"> 844                 return type;</span>
<span class="line-added"> 845             }</span>
<span class="line-added"> 846             // We have a Class signature.</span>
<span class="line-added"> 847             final StringBuilder typeClass = new StringBuilder(typeParams);</span>
<span class="line-added"> 848             typeClass.append(&quot; extends &quot;);</span>
<span class="line-added"> 849             typeClass.append(type);</span>
<span class="line-added"> 850             if (index &lt; signature.length()) {</span>
<span class="line-added"> 851                 typeClass.append(&quot; implements &quot;);</span>
<span class="line-added"> 852                 typeClass.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added"> 853                 index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 854             }</span>
<span class="line-added"> 855             while (index &lt; signature.length()) {</span>
<span class="line-added"> 856                 typeClass.append(&quot;, &quot;);</span>
<span class="line-added"> 857                 typeClass.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added"> 858                 index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 859             }</span>
<span class="line-added"> 860             return typeClass.toString();</span>
<span class="line-added"> 861         }</span>
<span class="line-added"> 862     }</span>
<span class="line-added"> 863 </span>
<span class="line-added"> 864 </span>
<span class="line-added"> 865     /**</span>
<span class="line-added"> 866      * Converts a type parameter list signature to a string.</span>
<span class="line-added"> 867      *</span>
<span class="line-added"> 868      * @param  signature signature to convert</span>
<span class="line-added"> 869      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-added"> 870      * @return String containg human readable signature</span>
<span class="line-added"> 871      */</span>
<span class="line-added"> 872     private static String typeParamTypesToString( final String signature, final boolean chopit ) {</span>
<span class="line-added"> 873         // The first character is guranteed to be &#39;&lt;&#39;</span>
<span class="line-added"> 874         final StringBuilder typeParams = new StringBuilder(&quot;&lt;&quot;);</span>
<span class="line-added"> 875         int index = 1;  // skip the &#39;&lt;&#39;</span>
<span class="line-added"> 876         // get the first TypeParameter</span>
<span class="line-added"> 877         typeParams.append(typeParamTypeToString(signature.substring(index), chopit));</span>
<span class="line-added"> 878         index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 879         // are there more TypeParameters?</span>
<span class="line-added"> 880         while (signature.charAt(index) != &#39;&gt;&#39;) {</span>
<span class="line-added"> 881             typeParams.append(&quot;, &quot;);</span>
<span class="line-added"> 882             typeParams.append(typeParamTypeToString(signature.substring(index), chopit));</span>
<span class="line-added"> 883             index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 884         }</span>
<span class="line-added"> 885         wrap(consumed_chars, index + 1); // account for the &#39;&gt;&#39; char</span>
<span class="line-added"> 886         return typeParams.append(&quot;&gt;&quot;).toString();</span>
<span class="line-added"> 887     }</span>
<span class="line-added"> 888 </span>
<span class="line-added"> 889 </span>
<span class="line-added"> 890     /**</span>
<span class="line-added"> 891      * Converts a type parameter signature to a string.</span>
<span class="line-added"> 892      *</span>
<span class="line-added"> 893      * @param  signature signature to convert</span>
<span class="line-added"> 894      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-added"> 895      * @return String containg human readable signature</span>
<span class="line-added"> 896      */</span>
<span class="line-added"> 897     private static String typeParamTypeToString( final String signature, final boolean chopit ) {</span>
<span class="line-added"> 898         int index = signature.indexOf(&#39;:&#39;);</span>
<span class="line-added"> 899         if (index &lt;= 0) {</span>
<span class="line-added"> 900             throw new ClassFormatException(&quot;Invalid type parameter signature: &quot; + signature);</span>
<span class="line-added"> 901         }</span>
<span class="line-added"> 902         // get the TypeParameter identifier</span>
<span class="line-added"> 903         final StringBuilder typeParam = new StringBuilder(signature.substring(0, index));</span>
<span class="line-added"> 904         index++;  // account for the &#39;:&#39;</span>
<span class="line-added"> 905         if (signature.charAt(index) != &#39;:&#39;) {</span>
<span class="line-added"> 906             // we have a class bound</span>
<span class="line-added"> 907             typeParam.append(&quot; extends &quot;);</span>
<span class="line-added"> 908             typeParam.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added"> 909             index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 910         }</span>
<span class="line-added"> 911         // look for interface bounds</span>
<span class="line-added"> 912         while (signature.charAt(index) == &#39;:&#39;) {</span>
<span class="line-added"> 913             index++;  // skip over the &#39;:&#39;</span>
<span class="line-added"> 914             typeParam.append(&quot; &amp; &quot;);</span>
<span class="line-added"> 915             typeParam.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added"> 916             index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 917         }</span>
<span class="line-added"> 918         wrap(consumed_chars, index);</span>
<span class="line-added"> 919         return typeParam.toString();</span>
<span class="line-added"> 920     }</span>
<span class="line-added"> 921 </span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923     /**</span>
<span class="line-added"> 924      * Converts a list of type signatures to a string.</span>
 925      *
<a name="97" id="anc97"></a><span class="line-modified"> 926      * @param  signature signature to convert</span>
<span class="line-modified"> 927      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-modified"> 928      * @param  term character indicating the end of the list</span>
<span class="line-modified"> 929      * @return String containg human readable signature</span>
<span class="line-modified"> 930      */</span>
<span class="line-modified"> 931     private static String typeSignaturesToString( final String signature, final boolean chopit, final char term ) {</span>
<span class="line-modified"> 932         // The first character will be an &#39;open&#39; that matches the &#39;close&#39; contained in term.</span>
<span class="line-modified"> 933         final StringBuilder typeList = new StringBuilder(signature.substring(0, 1));</span>
<span class="line-modified"> 934         int index = 1;  // skip the &#39;open&#39; character</span>
<span class="line-modified"> 935         // get the first Type in the list</span>
<span class="line-modified"> 936         if (signature.charAt(index) != term) {</span>
<span class="line-modified"> 937             typeList.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added"> 938             index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 939         }</span>
<span class="line-added"> 940         // are there more types in the list?</span>
<span class="line-added"> 941         while (signature.charAt(index) != term) {</span>
<span class="line-added"> 942             typeList.append(&quot;, &quot;);</span>
<span class="line-added"> 943             typeList.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added"> 944             index += unwrap(consumed_chars); // update position</span>
<span class="line-added"> 945         }</span>
<span class="line-added"> 946         wrap(consumed_chars, index + 1); // account for the term char</span>
<span class="line-added"> 947         return typeList.append(term).toString();</span>
<span class="line-added"> 948     }</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950 </span>
<span class="line-added"> 951     /**</span>
 952      *
<a name="98" id="anc98"></a><span class="line-modified"> 953      * This method converts a type signature string into a Java type declaration such as</span>
<span class="line-modified"> 954      * `String[]&#39; and throws a `ClassFormatException&#39; when the parsed type is invalid.</span>

 955      *
<a name="99" id="anc99"></a><span class="line-modified"> 956      * @param  signature type signature</span>
<span class="line-modified"> 957      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-modified"> 958      * @return string containing human readable type signature</span>
 959      * @throws ClassFormatException
<a name="100" id="anc100"></a><span class="line-added"> 960      * @since 6.4.0</span>
 961      */
<a name="101" id="anc101"></a><span class="line-modified"> 962     public static String typeSignatureToString( final String signature, final boolean chopit ) throws ClassFormatException {</span>
 963         //corrected concurrent private static field acess
 964         wrap(consumed_chars, 1); // This is the default, read just one char like `B&#39;
 965         try {
 966             switch (signature.charAt(0)) {
 967                 case &#39;B&#39;:
 968                     return &quot;byte&quot;;
 969                 case &#39;C&#39;:
 970                     return &quot;char&quot;;
 971                 case &#39;D&#39;:
 972                     return &quot;double&quot;;
 973                 case &#39;F&#39;:
 974                     return &quot;float&quot;;
 975                 case &#39;I&#39;:
 976                     return &quot;int&quot;;
 977                 case &#39;J&#39;:
 978                     return &quot;long&quot;;
 979                 case &#39;T&#39;: { // TypeVariableSignature
 980                     final int index = signature.indexOf(&#39;;&#39;); // Look for closing `;&#39;
 981                     if (index &lt; 0) {
<a name="102" id="anc102"></a><span class="line-modified"> 982                         throw new ClassFormatException(&quot;Invalid type variable signature: &quot; + signature);</span>
 983                     }
 984                     //corrected concurrent private static field acess
 985                     wrap(consumed_chars, index + 1); // &quot;Tblabla;&quot; `T&#39; and `;&#39; are removed
 986                     return compactClassName(signature.substring(1, index), chopit);
 987                 }
 988                 case &#39;L&#39;: { // Full class name
 989                     // should this be a while loop? can there be more than
 990                     // one generic clause?  (markro)
 991                     int fromIndex = signature.indexOf(&#39;&lt;&#39;); // generic type?
 992                     if (fromIndex &lt; 0) {
 993                         fromIndex = 0;
 994                     } else {
 995                         fromIndex = signature.indexOf(&#39;&gt;&#39;, fromIndex);
 996                         if (fromIndex &lt; 0) {
 997                             throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
 998                         }
 999                     }
1000                     final int index = signature.indexOf(&#39;;&#39;, fromIndex); // Look for closing `;&#39;
1001                     if (index &lt; 0) {
1002                         throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
1003                     }
<a name="103" id="anc103"></a><span class="line-added">1004 </span>
1005                     // check to see if there are any TypeArguments
1006                     final int bracketIndex = signature.substring(0, index).indexOf(&#39;&lt;&#39;);
1007                     if (bracketIndex &lt; 0) {
1008                         // just a class identifier
1009                         wrap(consumed_chars, index + 1); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed
1010                         return compactClassName(signature.substring(1, index), chopit);
1011                     }
<a name="104" id="anc104"></a><span class="line-added">1012                     // but make sure we are not looking past the end of the current item</span>
<span class="line-added">1013                     fromIndex = signature.indexOf(&#39;;&#39;);</span>
<span class="line-added">1014                     if (fromIndex &lt; 0) {</span>
<span class="line-added">1015                         throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);</span>
<span class="line-added">1016                     }</span>
<span class="line-added">1017                     if (fromIndex &lt; bracketIndex) {</span>
<span class="line-added">1018                         // just a class identifier</span>
<span class="line-added">1019                         wrap(consumed_chars, fromIndex + 1); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed</span>
<span class="line-added">1020                         return compactClassName(signature.substring(1, fromIndex), chopit);</span>
<span class="line-added">1021                     }</span>
1022 
1023                     // we have TypeArguments; build up partial result
1024                     // as we recurse for each TypeArgument
<a name="105" id="anc105"></a><span class="line-modified">1025                     final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append(&quot;&lt;&quot;);</span>


1026                     int consumed_chars = bracketIndex + 1; // Shadows global var
1027 
1028                     // check for wildcards
1029                     if (signature.charAt(consumed_chars) == &#39;+&#39;) {
1030                         type.append(&quot;? extends &quot;);
1031                         consumed_chars++;
1032                     } else if (signature.charAt(consumed_chars) == &#39;-&#39;) {
1033                         type.append(&quot;? super &quot;);
1034                         consumed_chars++;
<a name="106" id="anc106"></a>









1035                     }
1036 
1037                     // get the first TypeArgument
<a name="107" id="anc107"></a><span class="line-modified">1038                     if (signature.charAt(consumed_chars) == &#39;*&#39;) {</span>
<span class="line-modified">1039                         type.append(&quot;?&quot;);</span>
<span class="line-modified">1040                         consumed_chars++;</span>
<span class="line-modified">1041                     } else {</span>
<span class="line-added">1042                         type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));</span>
<span class="line-added">1043                         // update our consumed count by the number of characters the for type argument</span>
<span class="line-added">1044                         consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;</span>
<span class="line-added">1045                         wrap(Utility.consumed_chars, consumed_chars);</span>
<span class="line-added">1046                     }</span>
1047 
1048                     // are there more TypeArguments?
1049                     while (signature.charAt(consumed_chars) != &#39;&gt;&#39;) {
<a name="108" id="anc108"></a><span class="line-modified">1050                         type.append(&quot;, &quot;);</span>
<span class="line-added">1051                         // check for wildcards</span>
<span class="line-added">1052                         if (signature.charAt(consumed_chars) == &#39;+&#39;) {</span>
<span class="line-added">1053                             type.append(&quot;? extends &quot;);</span>
<span class="line-added">1054                             consumed_chars++;</span>
<span class="line-added">1055                         } else if (signature.charAt(consumed_chars) == &#39;-&#39;) {</span>
<span class="line-added">1056                             type.append(&quot;? super &quot;);</span>
<span class="line-added">1057                             consumed_chars++;</span>
<span class="line-added">1058                         }</span>
<span class="line-added">1059                         if (signature.charAt(consumed_chars) == &#39;*&#39;) {</span>
<span class="line-added">1060                             type.append(&quot;?&quot;);</span>
<span class="line-added">1061                             consumed_chars++;</span>
<span class="line-added">1062                         } else {</span>
<span class="line-added">1063                             type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));</span>
<span class="line-added">1064                             // update our consumed count by the number of characters the for type argument</span>
<span class="line-added">1065                             consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;</span>
<span class="line-added">1066                             wrap(Utility.consumed_chars, consumed_chars);</span>
<span class="line-added">1067                         }</span>
<span class="line-added">1068                     }</span>
<span class="line-added">1069 </span>
<span class="line-added">1070                     // process the closing &quot;&gt;&quot;</span>
<span class="line-added">1071                     consumed_chars++;</span>
<span class="line-added">1072                     type.append(&quot;&gt;&quot;);</span>
<span class="line-added">1073 </span>
<span class="line-added">1074                     if (signature.charAt(consumed_chars) == &#39;.&#39;) {</span>
<span class="line-added">1075                         // we have a ClassTypeSignatureSuffix</span>
<span class="line-added">1076                         type.append(&quot;.&quot;);</span>
<span class="line-added">1077                         // convert SimpleClassTypeSignature to fake ClassTypeSignature</span>
<span class="line-added">1078                         // and then recurse to parse it</span>
<span class="line-added">1079                         type.append(typeSignatureToString(&quot;L&quot; + signature.substring(consumed_chars+1), chopit));</span>
1080                         // update our consumed count by the number of characters the for type argument
<a name="109" id="anc109"></a><span class="line-added">1081                         // note that this count includes the &quot;L&quot; we added, but that is ok</span>
<span class="line-added">1082                         // as it accounts for the &quot;.&quot; we didn&#39;t consume</span>
1083                         consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;
1084                         wrap(Utility.consumed_chars, consumed_chars);
<a name="110" id="anc110"></a><span class="line-added">1085                         return type.toString();</span>
1086                     }
<a name="111" id="anc111"></a><span class="line-modified">1087                     if (signature.charAt(consumed_chars) != &#39;;&#39;) {</span>

1088                         throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
1089                     }
<a name="112" id="anc112"></a><span class="line-modified">1090                     wrap(Utility.consumed_chars, consumed_chars + 1); // remove final &quot;;&quot;</span>
<span class="line-modified">1091                     return type.toString();</span>
1092                 }
1093                 case &#39;S&#39;:
1094                     return &quot;short&quot;;
1095                 case &#39;Z&#39;:
1096                     return &quot;boolean&quot;;
1097                 case &#39;[&#39;: { // Array declaration
1098                     int n;
1099                     StringBuilder brackets;
1100                     String type;
1101                     int consumed_chars; // Shadows global var
1102                     brackets = new StringBuilder(); // Accumulate []&#39;s
1103                     // Count opening brackets and look for optional size argument
1104                     for (n = 0; signature.charAt(n) == &#39;[&#39;; n++) {
1105                         brackets.append(&quot;[]&quot;);
1106                     }
1107                     consumed_chars = n; // Remember value
1108                     // The rest of the string denotes a `&lt;field_type&gt;&#39;
<a name="113" id="anc113"></a><span class="line-modified">1109                     type = typeSignatureToString(signature.substring(n), chopit);</span>
1110                     //corrected concurrent private static field acess
1111                     //Utility.consumed_chars += consumed_chars; is replaced by:
1112                     final int _temp = unwrap(Utility.consumed_chars) + consumed_chars;
1113                     wrap(Utility.consumed_chars, _temp);
1114                     return type + brackets.toString();
1115                 }
1116                 case &#39;V&#39;:
1117                     return &quot;void&quot;;
1118                 default:
1119                     throw new ClassFormatException(&quot;Invalid signature: `&quot; + signature + &quot;&#39;&quot;);
1120             }
1121         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
1122             throw new ClassFormatException(&quot;Invalid signature: &quot; + signature, e);
1123         }
1124     }
1125 
<a name="114" id="anc114"></a><span class="line-modified">1126 </span>
<span class="line-modified">1127     /** Parse Java type such as &quot;char&quot;, or &quot;java.lang.String[]&quot; and return the</span>
<span class="line-modified">1128      * signature in byte code format, e.g. &quot;C&quot; or &quot;[Ljava/lang/String;&quot; respectively.</span>

1129      *
<a name="115" id="anc115"></a><span class="line-modified">1130      * @param  type Java type</span>
1131      * @return byte code signature
1132      */
<a name="116" id="anc116"></a><span class="line-modified">1133     public static String getSignature( String type ) {</span>
1134         final StringBuilder buf = new StringBuilder();
1135         final char[] chars = type.toCharArray();
1136         boolean char_found = false;
1137         boolean delim = false;
1138         int index = -1;
<a name="117" id="anc117"></a><span class="line-modified">1139         loop: for (int i = 0; i &lt; chars.length; i++) {</span>

1140             switch (chars[i]) {
1141                 case &#39; &#39;:
1142                 case &#39;\t&#39;:
1143                 case &#39;\n&#39;:
1144                 case &#39;\r&#39;:
1145                 case &#39;\f&#39;:
1146                     if (char_found) {
1147                         delim = true;
1148                     }
1149                     break;
1150                 case &#39;[&#39;:
1151                     if (!char_found) {
1152                         throw new RuntimeException(&quot;Illegal type: &quot; + type);
1153                     }
1154                     index = i;
1155                     break loop;
1156                 default:
1157                     char_found = true;
1158                     if (!delim) {
1159                         buf.append(chars[i]);
1160                     }
1161             }
1162         }
1163         int brackets = 0;
1164         if (index &gt; 0) {
1165             brackets = countBrackets(type.substring(index));
1166         }
1167         type = buf.toString();
1168         buf.setLength(0);
1169         for (int i = 0; i &lt; brackets; i++) {
1170             buf.append(&#39;[&#39;);
1171         }
1172         boolean found = false;
1173         for (int i = Const.T_BOOLEAN; (i &lt;= Const.T_VOID) &amp;&amp; !found; i++) {
1174             if (Const.getTypeName(i).equals(type)) {
1175                 found = true;
1176                 buf.append(Const.getShortTypeName(i));
1177             }
1178         }
1179         if (!found) {
1180             buf.append(&#39;L&#39;).append(type.replace(&#39;.&#39;, &#39;/&#39;)).append(&#39;;&#39;);
1181         }
1182         return buf.toString();
1183     }
1184 
<a name="118" id="anc118"></a><span class="line-modified">1185 </span>
<span class="line-added">1186     private static int countBrackets( final String brackets ) {</span>
1187         final char[] chars = brackets.toCharArray();
1188         int count = 0;
1189         boolean open = false;
1190         for (final char c : chars) {
1191             switch (c) {
1192                 case &#39;[&#39;:
1193                     if (open) {
1194                         throw new RuntimeException(&quot;Illegally nested brackets:&quot; + brackets);
1195                     }
1196                     open = true;
1197                     break;
1198                 case &#39;]&#39;:
1199                     if (!open) {
1200                         throw new RuntimeException(&quot;Illegally nested brackets:&quot; + brackets);
1201                     }
1202                     open = false;
1203                     count++;
1204                     break;
1205                 default:
1206                     // Don&#39;t care
1207                     break;
1208             }
1209         }
1210         if (open) {
1211             throw new RuntimeException(&quot;Illegally nested brackets:&quot; + brackets);
1212         }
1213         return count;
1214     }
1215 
<a name="119" id="anc119"></a><span class="line-added">1216 </span>
1217     /**
<a name="120" id="anc120"></a><span class="line-modified">1218      * Return type of method signature as a byte value as defined in &lt;em&gt;Constants&lt;/em&gt;</span>

1219      *
<a name="121" id="anc121"></a><span class="line-modified">1220      * @param  signature in format described above</span>
1221      * @return type of method signature
<a name="122" id="anc122"></a><span class="line-modified">1222      * @see    Const</span>
1223      *
1224      * @throws ClassFormatException if signature is not a method signature
1225      */
<a name="123" id="anc123"></a><span class="line-modified">1226     public static byte typeOfMethodSignature( final String signature ) throws ClassFormatException {</span>
1227         int index;
1228         try {
1229             if (signature.charAt(0) != &#39;(&#39;) {
1230                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
1231             }
1232             index = signature.lastIndexOf(&#39;)&#39;) + 1;
1233             return typeOfSignature(signature.substring(index));
1234         } catch (final StringIndexOutOfBoundsException e) {
1235             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
1236         }
1237     }
1238 
<a name="124" id="anc124"></a><span class="line-added">1239 </span>
1240     /**
1241      * Return type of signature as a byte value as defined in &lt;em&gt;Constants&lt;/em&gt;
1242      *
<a name="125" id="anc125"></a><span class="line-modified">1243      * @param  signature in format described above</span>
1244      * @return type of signature
<a name="126" id="anc126"></a><span class="line-modified">1245      * @see    Const</span>
1246      *
1247      * @throws ClassFormatException if signature isn&#39;t a known type
1248      */
<a name="127" id="anc127"></a><span class="line-modified">1249     public static byte typeOfSignature( final String signature ) throws ClassFormatException {</span>
1250         try {
1251             switch (signature.charAt(0)) {
1252                 case &#39;B&#39;:
1253                     return Const.T_BYTE;
1254                 case &#39;C&#39;:
1255                     return Const.T_CHAR;
1256                 case &#39;D&#39;:
1257                     return Const.T_DOUBLE;
1258                 case &#39;F&#39;:
1259                     return Const.T_FLOAT;
1260                 case &#39;I&#39;:
1261                     return Const.T_INT;
1262                 case &#39;J&#39;:
1263                     return Const.T_LONG;
1264                 case &#39;L&#39;:
1265                 case &#39;T&#39;:
1266                     return Const.T_REFERENCE;
1267                 case &#39;[&#39;:
1268                     return Const.T_ARRAY;
1269                 case &#39;V&#39;:
1270                     return Const.T_VOID;
1271                 case &#39;Z&#39;:
1272                     return Const.T_BOOLEAN;
1273                 case &#39;S&#39;:
1274                     return Const.T_SHORT;
1275                 case &#39;!&#39;:
1276                 case &#39;+&#39;:
1277                 case &#39;*&#39;:
1278                     return typeOfSignature(signature.substring(1));
1279                 default:
1280                     throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
1281             }
1282         } catch (final StringIndexOutOfBoundsException e) {
1283             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
1284         }
1285     }
1286 
<a name="128" id="anc128"></a><span class="line-modified">1287 </span>
<span class="line-modified">1288     /** Map opcode names to opcode numbers. E.g., return Constants.ALOAD for &quot;aload&quot;</span>

1289      */
<a name="129" id="anc129"></a><span class="line-modified">1290     public static short searchOpcode( String name ) {</span>
1291         name = name.toLowerCase(Locale.ENGLISH);
1292         for (short i = 0; i &lt; Const.OPCODE_NAMES_LENGTH; i++) {
1293             if (Const.getOpcodeName(i).equals(name)) {
1294                 return i;
1295             }
1296         }
1297         return -1;
1298     }
1299 
<a name="130" id="anc130"></a><span class="line-added">1300 </span>
1301     /**
1302      * Convert (signed) byte to (unsigned) short value, i.e., all negative
1303      * values become positive.
1304      */
<a name="131" id="anc131"></a><span class="line-modified">1305     private static short byteToShort( final byte b ) {</span>
1306         return (b &lt; 0) ? (short) (256 + b) : (short) b;
1307     }
1308 
<a name="132" id="anc132"></a><span class="line-modified">1309 </span>
<span class="line-modified">1310     /** Convert bytes into hexadecimal string</span>
1311      *
1312      * @param bytes an array of bytes to convert to hexadecimal
1313      *
1314      * @return bytes as hexadecimal string, e.g. 00 fa 12 ...
1315      */
<a name="133" id="anc133"></a><span class="line-modified">1316     public static String toHexString( final byte[] bytes ) {</span>
1317         final StringBuilder buf = new StringBuilder();
1318         for (int i = 0; i &lt; bytes.length; i++) {
1319             final short b = byteToShort(bytes[i]);
1320             final String hex = Integer.toHexString(b);
1321             if (b &lt; 0x10) {
1322                 buf.append(&#39;0&#39;);
1323             }
1324             buf.append(hex);
1325             if (i &lt; bytes.length - 1) {
1326                 buf.append(&#39; &#39;);
1327             }
1328         }
1329         return buf.toString();
1330     }
1331 
<a name="134" id="anc134"></a><span class="line-added">1332 </span>
1333     /**
1334      * Return a string for an integer justified left or right and filled up with
1335      * `fill&#39; characters if necessary.
1336      *
1337      * @param i integer to format
1338      * @param length length of desired string
1339      * @param left_justify format left or right
1340      * @param fill fill character
1341      * @return formatted int
1342      */
<a name="135" id="anc135"></a><span class="line-modified">1343     public static String format( final int i, final int length, final boolean left_justify, final char fill ) {</span>

1344         return fillup(Integer.toString(i), length, left_justify, fill);
1345     }
1346 
<a name="136" id="anc136"></a><span class="line-added">1347 </span>
1348     /**
<a name="137" id="anc137"></a><span class="line-modified">1349      * Fillup char with up to length characters with char `fill&#39; and justify it left or right.</span>

1350      *
1351      * @param str string to format
1352      * @param length length of desired string
1353      * @param left_justify format left or right
1354      * @param fill fill character
1355      * @return formatted string
1356      */
<a name="138" id="anc138"></a><span class="line-modified">1357     public static String fillup( final String str, final int length, final boolean left_justify, final char fill ) {</span>

1358         final int len = length - str.length();
1359         final char[] buf = new char[(len &lt; 0) ? 0 : len];
1360         for (int j = 0; j &lt; buf.length; j++) {
1361             buf[j] = fill;
1362         }
1363         if (left_justify) {
1364             return str + new String(buf);
1365         }
1366         return new String(buf) + str;
1367     }
1368 
<a name="139" id="anc139"></a><span class="line-modified">1369 </span>
<span class="line-added">1370     static boolean equals( final byte[] a, final byte[] b ) {</span>
1371         int size;
1372         if ((size = a.length) != b.length) {
1373             return false;
1374         }
1375         for (int i = 0; i &lt; size; i++) {
1376             if (a[i] != b[i]) {
1377                 return false;
1378             }
1379         }
1380         return true;
1381     }
1382 
<a name="140" id="anc140"></a><span class="line-modified">1383 </span>
<span class="line-added">1384     public static void printArray( final PrintStream out, final Object[] obj ) {</span>
1385         out.println(printArray(obj, true));
1386     }
1387 
<a name="141" id="anc141"></a><span class="line-modified">1388 </span>
<span class="line-added">1389     public static void printArray( final PrintWriter out, final Object[] obj ) {</span>
1390         out.println(printArray(obj, true));
1391     }
1392 
<a name="142" id="anc142"></a><span class="line-modified">1393 </span>
<span class="line-added">1394     public static String printArray( final Object[] obj ) {</span>
1395         return printArray(obj, true);
1396     }
1397 
<a name="143" id="anc143"></a><span class="line-modified">1398 </span>
<span class="line-added">1399     public static String printArray( final Object[] obj, final boolean braces ) {</span>
1400         return printArray(obj, braces, false);
1401     }
1402 
<a name="144" id="anc144"></a><span class="line-modified">1403 </span>
<span class="line-added">1404     public static String printArray( final Object[] obj, final boolean braces, final boolean quote ) {</span>
1405         if (obj == null) {
1406             return null;
1407         }
1408         final StringBuilder buf = new StringBuilder();
1409         if (braces) {
1410             buf.append(&#39;{&#39;);
1411         }
1412         for (int i = 0; i &lt; obj.length; i++) {
1413             if (obj[i] != null) {
1414                 buf.append(quote ? &quot;\&quot;&quot; : &quot;&quot;).append(obj[i]).append(quote ? &quot;\&quot;&quot; : &quot;&quot;);
1415             } else {
1416                 buf.append(&quot;null&quot;);
1417             }
1418             if (i &lt; obj.length - 1) {
1419                 buf.append(&quot;, &quot;);
1420             }
1421         }
1422         if (braces) {
1423             buf.append(&#39;}&#39;);
1424         }
1425         return buf.toString();
1426     }
1427 
<a name="145" id="anc145"></a><span class="line-added">1428 </span>
1429     /**
1430      * @param ch the character to test if it&#39;s part of an identifier
1431      *
1432      * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)
1433      */
<a name="146" id="anc146"></a><span class="line-modified">1434     public static boolean isJavaIdentifierPart( final char ch ) {</span>
1435         return ((ch &gt;= &#39;a&#39;) &amp;&amp; (ch &lt;= &#39;z&#39;)) || ((ch &gt;= &#39;A&#39;) &amp;&amp; (ch &lt;= &#39;Z&#39;))
1436                 || ((ch &gt;= &#39;0&#39;) &amp;&amp; (ch &lt;= &#39;9&#39;)) || (ch == &#39;_&#39;);
1437     }
1438 
<a name="147" id="anc147"></a><span class="line-added">1439 </span>
1440     /**
<a name="148" id="anc148"></a><span class="line-modified">1441      * Encode byte array it into Java identifier string, i.e., a string</span>
<span class="line-modified">1442      * that only contains the following characters: (a, ... z, A, ... Z,</span>
<span class="line-modified">1443      * 0, ... 9, _, $).  The encoding algorithm itself is not too</span>
<span class="line-modified">1444      * clever: if the current byte&#39;s ASCII value already is a valid Java</span>
<span class="line-modified">1445      * identifier part, leave it as it is. Otherwise it writes the</span>
<span class="line-added">1446      * escape character($) followed by:</span>
1447      *
1448      * &lt;ul&gt;
<a name="149" id="anc149"></a><span class="line-modified">1449      *   &lt;li&gt; the ASCII value as a hexadecimal string, if the value is not in the range 200..247&lt;/li&gt;</span>
<span class="line-modified">1450      *   &lt;li&gt;a Java identifier char not used in a lowercase hexadecimal string, if the value is in the range 200..247&lt;/li&gt;</span>


1451      * &lt;/ul&gt;
1452      *
<a name="150" id="anc150"></a><span class="line-modified">1453      * &lt;p&gt;This operation inflates the original byte array by roughly 40-50%&lt;/p&gt;</span>

1454      *
1455      * @param bytes the byte array to convert
1456      * @param compress use gzip to minimize string
1457      *
1458      * @throws IOException if there&#39;s a gzip exception
1459      */
1460     public static String encode(byte[] bytes, final boolean compress) throws IOException {
1461         if (compress) {
1462             try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
1463                     GZIPOutputStream gos = new GZIPOutputStream(baos)) {
1464                 gos.write(bytes, 0, bytes.length);
1465                 bytes = baos.toByteArray();
1466             }
1467         }
1468         final CharArrayWriter caw = new CharArrayWriter();
1469         try (JavaWriter jw = new JavaWriter(caw)) {
1470             for (final byte b : bytes) {
1471                 final int in = b &amp; 0x000000ff; // Normalize to unsigned
1472                 jw.write(in);
1473             }
1474         }
1475         return caw.toString();
1476     }
1477 
<a name="151" id="anc151"></a><span class="line-added">1478 </span>
1479     /**
1480      * Decode a string back to a byte array.
1481      *
1482      * @param s the string to convert
1483      * @param uncompress use gzip to uncompress the stream of bytes
1484      *
1485      * @throws IOException if there&#39;s a gzip exception
1486      */
1487     public static byte[] decode(final String s, final boolean uncompress) throws IOException {
1488         byte[] bytes;
1489         try (JavaReader jr = new JavaReader(new CharArrayReader(s.toCharArray()));
1490                 ByteArrayOutputStream bos = new ByteArrayOutputStream()) {
1491             int ch;
1492             while ((ch = jr.read()) &gt;= 0) {
1493                 bos.write(ch);
1494             }
1495             bytes = bos.toByteArray();
1496         }
1497         if (uncompress) {
1498             final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));
1499             final byte[] tmp = new byte[bytes.length * 3]; // Rough estimate
1500             int count = 0;
1501             int b;
1502             while ((b = gis.read()) &gt;= 0) {
1503                 tmp[count++] = (byte) b;
1504             }
1505             bytes = new byte[count];
1506             System.arraycopy(tmp, 0, bytes, 0, count);
1507         }
1508         return bytes;
1509     }
1510 
1511     // A-Z, g-z, _, $
1512     private static final int FREE_CHARS = 48;
1513     private static int[] CHAR_MAP = new int[FREE_CHARS];
1514     private static int[] MAP_CHAR = new int[256]; // Reverse map
1515     private static final char ESCAPE_CHAR = &#39;$&#39;;
<a name="152" id="anc152"></a>
1516     static {
1517         int j = 0;
1518         for (int i = &#39;A&#39;; i &lt;= &#39;Z&#39;; i++) {
1519             CHAR_MAP[j] = i;
1520             MAP_CHAR[i] = j;
1521             j++;
1522         }
1523         for (int i = &#39;g&#39;; i &lt;= &#39;z&#39;; i++) {
1524             CHAR_MAP[j] = i;
1525             MAP_CHAR[i] = j;
1526             j++;
1527         }
1528         CHAR_MAP[j] = &#39;$&#39;;
1529         MAP_CHAR[&#39;$&#39;] = j;
1530         j++;
1531         CHAR_MAP[j] = &#39;_&#39;;
1532         MAP_CHAR[&#39;_&#39;] = j;
1533     }
1534 
1535     /**
<a name="153" id="anc153"></a><span class="line-modified">1536      * Decode characters into bytes.</span>
<span class="line-modified">1537      * Used by &lt;a href=&quot;Utility.html#decode(java.lang.String, boolean)&quot;&gt;decode()&lt;/a&gt;</span>
1538      */
1539     private static class JavaReader extends FilterReader {
1540 
1541         public JavaReader(final Reader in) {
1542             super(in);
1543         }
1544 
<a name="154" id="anc154"></a><span class="line-added">1545 </span>
1546         @Override
1547         public int read() throws IOException {
1548             final int b = in.read();
1549             if (b != ESCAPE_CHAR) {
1550                 return b;
1551             }
1552             final int i = in.read();
1553             if (i &lt; 0) {
1554                 return -1;
1555             }
1556             if (((i &gt;= &#39;0&#39;) &amp;&amp; (i &lt;= &#39;9&#39;)) || ((i &gt;= &#39;a&#39;) &amp;&amp; (i &lt;= &#39;f&#39;))) { // Normal escape
1557                 final int j = in.read();
1558                 if (j &lt; 0) {
1559                     return -1;
1560                 }
1561                 final char[] tmp = {
<a name="155" id="anc155"></a><span class="line-modified">1562                         (char) i, (char) j</span>
1563                 };
1564                 final int s = Integer.parseInt(new String(tmp), 16);
1565                 return s;
1566             }
1567             return MAP_CHAR[i];
1568         }
1569 
<a name="156" id="anc156"></a><span class="line-added">1570 </span>
1571         @Override
<a name="157" id="anc157"></a><span class="line-modified">1572         public int read( final char[] cbuf, final int off, final int len ) throws IOException {</span>
1573             for (int i = 0; i &lt; len; i++) {
1574                 cbuf[off + i] = (char) read();
1575             }
1576             return len;
1577         }
1578     }
1579 
1580     /**
<a name="158" id="anc158"></a><span class="line-modified">1581      * Encode bytes into valid java identifier characters.</span>
<span class="line-modified">1582      * Used by &lt;a href=&quot;Utility.html#encode(byte[], boolean)&quot;&gt;encode()&lt;/a&gt;</span>
1583      */
1584     private static class JavaWriter extends FilterWriter {
1585 
1586         public JavaWriter(final Writer out) {
1587             super(out);
1588         }
1589 
<a name="159" id="anc159"></a><span class="line-added">1590 </span>
1591         @Override
<a name="160" id="anc160"></a><span class="line-modified">1592         public void write( final int b ) throws IOException {</span>
1593             if (isJavaIdentifierPart((char) b) &amp;&amp; (b != ESCAPE_CHAR)) {
1594                 out.write(b);
1595             } else {
1596                 out.write(ESCAPE_CHAR); // Escape character
1597                 // Special escape
1598                 if (b &gt;= 0 &amp;&amp; b &lt; FREE_CHARS) {
1599                     out.write(CHAR_MAP[b]);
1600                 } else { // Normal escape
1601                     final char[] tmp = Integer.toHexString(b).toCharArray();
1602                     if (tmp.length == 1) {
1603                         out.write(&#39;0&#39;);
1604                         out.write(tmp[0]);
1605                     } else {
1606                         out.write(tmp[0]);
1607                         out.write(tmp[1]);
1608                     }
1609                 }
1610             }
1611         }
1612 
<a name="161" id="anc161"></a><span class="line-added">1613 </span>
1614         @Override
<a name="162" id="anc162"></a><span class="line-modified">1615         public void write( final char[] cbuf, final int off, final int len ) throws IOException {</span>
1616             for (int i = 0; i &lt; len; i++) {
1617                 write(cbuf[off + i]);
1618             }
1619         }
1620 
<a name="163" id="anc163"></a><span class="line-added">1621 </span>
1622         @Override
<a name="164" id="anc164"></a><span class="line-modified">1623         public void write( final String str, final int off, final int len ) throws IOException {</span>
1624             write(str.toCharArray(), off, len);
1625         }
1626     }
1627 
<a name="165" id="anc165"></a><span class="line-added">1628 </span>
1629     /**
1630      * Escape all occurences of newline chars &#39;\n&#39;, quotes \&quot;, etc.
1631      */
<a name="166" id="anc166"></a><span class="line-modified">1632     public static String convertString( final String label ) {</span>
1633         final char[] ch = label.toCharArray();
1634         final StringBuilder buf = new StringBuilder();
1635         for (final char element : ch) {
1636             switch (element) {
1637                 case &#39;\n&#39;:
1638                     buf.append(&quot;\\n&quot;);
1639                     break;
1640                 case &#39;\r&#39;:
1641                     buf.append(&quot;\\r&quot;);
1642                     break;
1643                 case &#39;\&quot;&#39;:
1644                     buf.append(&quot;\\\&quot;&quot;);
1645                     break;
1646                 case &#39;\&#39;&#39;:
1647                     buf.append(&quot;\\&#39;&quot;);
1648                     break;
1649                 case &#39;\\&#39;:
1650                     buf.append(&quot;\\\\&quot;);
1651                     break;
1652                 default:
1653                     buf.append(element);
1654                     break;
1655             }
1656         }
1657         return buf.toString();
1658     }
<a name="167" id="anc167"></a><span class="line-added">1659 </span>
1660 }
<a name="168" id="anc168"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="168" type="hidden" />
</body>
</html>
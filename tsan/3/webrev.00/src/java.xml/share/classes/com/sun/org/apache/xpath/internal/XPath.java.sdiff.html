<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xpath/internal/XPath.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../xml/internal/serializer/dom3/LSSerializerImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="axes/FilterExprWalker.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xpath/internal/XPath.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xpath.internal;
 22 
 23 import com.sun.org.apache.xalan.internal.res.XSLMessages;
 24 import com.sun.org.apache.xml.internal.dtm.DTM;
 25 import com.sun.org.apache.xml.internal.utils.PrefixResolver;
 26 import com.sun.org.apache.xml.internal.utils.QName;
 27 import com.sun.org.apache.xml.internal.utils.SAXSourceLocator;
 28 import com.sun.org.apache.xpath.internal.compiler.Compiler;
 29 import com.sun.org.apache.xpath.internal.compiler.FunctionTable;
 30 import com.sun.org.apache.xpath.internal.compiler.XPathParser;
 31 import com.sun.org.apache.xpath.internal.objects.XObject;
 32 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
 33 import java.io.Serializable;
 34 import java.util.List;
 35 import javax.xml.transform.ErrorListener;
 36 import javax.xml.transform.SourceLocator;
 37 import javax.xml.transform.TransformerException;
 38 
 39 /**
 40  * The XPath class wraps an expression object and provides general services
 41  * for execution of that expression.
 42  * @xsl.usage advanced
<span class="line-modified"> 43  * @LastModified: Oct 2017</span>
 44  */
 45 public class XPath implements Serializable, ExpressionOwner
 46 {
 47     static final long serialVersionUID = 3976493477939110553L;
 48 
 49   /** The top of the expression tree.
 50    *  @serial */
 51   private Expression m_mainExp;
 52 
 53   /**
 54    * The function table for xpath build-in functions
 55    */
 56   private transient FunctionTable m_funcTable = null;
 57 
 58   /**
 59    * initial the function table
 60    */
 61   private void initFunctionTable(){
 62               m_funcTable = new FunctionTable();
 63   }
</pre>
<hr />
<pre>
162    */
163   public XPath(
164           String exprString, SourceLocator locator, PrefixResolver prefixResolver, int type,
165           ErrorListener errorListener)
166             throws javax.xml.transform.TransformerException
167   {
168     initFunctionTable();
169     if(null == errorListener)
170       errorListener = new com.sun.org.apache.xml.internal.utils.DefaultErrorHandler();
171 
172     m_patternString = exprString;
173 
174     XPathParser parser = new XPathParser(errorListener, locator);
175     Compiler compiler = new Compiler(errorListener, locator, m_funcTable);
176 
177     if (SELECT == type)
178       parser.initXPath(compiler, exprString, prefixResolver);
179     else if (MATCH == type)
180       parser.initMatchPattern(compiler, exprString, prefixResolver);
181     else
<span class="line-modified">182       throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANNOT_DEAL_XPATH_TYPE, new Object[]{Integer.toString(type)})); //&quot;Can not deal with XPath type: &quot; + type);</span>


183 
184     // System.out.println(&quot;----------------&quot;);
<span class="line-modified">185     Expression expr = compiler.compile(0);</span>
186 
187     // System.out.println(&quot;expr: &quot;+expr);
188     this.setExpression(expr);
189 
190     if((null != locator) &amp;&amp; locator instanceof ExpressionNode)
191     {
192         expr.exprSetParent((ExpressionNode)locator);
193     }
194 
195   }
196 
197   /**
198    * Construct an XPath object.
199    *
200    * (Needs review -sc) This method initializes an XPathParser/
201    * Compiler and compiles the expression.
202    * @param exprString The XPath expression.
203    * @param locator The location of the expression, may be null.
204    * @param prefixResolver A prefix resolver to use to resolve prefixes to
205    *                       namespace URIs.
</pre>
<hr />
<pre>
217     m_funcTable = aTable;
218     if(null == errorListener)
219       errorListener = new com.sun.org.apache.xml.internal.utils.DefaultErrorHandler();
220 
221     m_patternString = exprString;
222 
223     XPathParser parser = new XPathParser(errorListener, locator);
224     Compiler compiler = new Compiler(errorListener, locator, m_funcTable);
225 
226     if (SELECT == type)
227       parser.initXPath(compiler, exprString, prefixResolver);
228     else if (MATCH == type)
229       parser.initMatchPattern(compiler, exprString, prefixResolver);
230     else
231       throw new RuntimeException(XSLMessages.createXPATHMessage(
232             XPATHErrorResources.ER_CANNOT_DEAL_XPATH_TYPE,
233             new Object[]{Integer.toString(type)}));
234             //&quot;Can not deal with XPath type: &quot; + type);
235 
236     // System.out.println(&quot;----------------&quot;);
<span class="line-modified">237     Expression expr = compiler.compile(0);</span>
238 
239     // System.out.println(&quot;expr: &quot;+expr);
240     this.setExpression(expr);
241 
242     if((null != locator) &amp;&amp; locator instanceof ExpressionNode)
243     {
244         expr.exprSetParent((ExpressionNode)locator);
245     }
246 
247   }
248 
249   /**
250    * Construct an XPath object.
251    *
252    * (Needs review -sc) This method initializes an XPathParser/
253    * Compiler and compiles the expression.
254    * @param exprString The XPath expression.
255    * @param locator The location of the expression, may be null.
256    * @param prefixResolver A prefix resolver to use to resolve prefixes to
257    *                       namespace URIs.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xpath.internal;
 22 
 23 import com.sun.org.apache.xalan.internal.res.XSLMessages;
 24 import com.sun.org.apache.xml.internal.dtm.DTM;
 25 import com.sun.org.apache.xml.internal.utils.PrefixResolver;
 26 import com.sun.org.apache.xml.internal.utils.QName;
 27 import com.sun.org.apache.xml.internal.utils.SAXSourceLocator;
 28 import com.sun.org.apache.xpath.internal.compiler.Compiler;
 29 import com.sun.org.apache.xpath.internal.compiler.FunctionTable;
 30 import com.sun.org.apache.xpath.internal.compiler.XPathParser;
 31 import com.sun.org.apache.xpath.internal.objects.XObject;
 32 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
 33 import java.io.Serializable;
 34 import java.util.List;
 35 import javax.xml.transform.ErrorListener;
 36 import javax.xml.transform.SourceLocator;
 37 import javax.xml.transform.TransformerException;
 38 
 39 /**
 40  * The XPath class wraps an expression object and provides general services
 41  * for execution of that expression.
 42  * @xsl.usage advanced
<span class="line-modified"> 43  * @LastModified: May 2019</span>
 44  */
 45 public class XPath implements Serializable, ExpressionOwner
 46 {
 47     static final long serialVersionUID = 3976493477939110553L;
 48 
 49   /** The top of the expression tree.
 50    *  @serial */
 51   private Expression m_mainExp;
 52 
 53   /**
 54    * The function table for xpath build-in functions
 55    */
 56   private transient FunctionTable m_funcTable = null;
 57 
 58   /**
 59    * initial the function table
 60    */
 61   private void initFunctionTable(){
 62               m_funcTable = new FunctionTable();
 63   }
</pre>
<hr />
<pre>
162    */
163   public XPath(
164           String exprString, SourceLocator locator, PrefixResolver prefixResolver, int type,
165           ErrorListener errorListener)
166             throws javax.xml.transform.TransformerException
167   {
168     initFunctionTable();
169     if(null == errorListener)
170       errorListener = new com.sun.org.apache.xml.internal.utils.DefaultErrorHandler();
171 
172     m_patternString = exprString;
173 
174     XPathParser parser = new XPathParser(errorListener, locator);
175     Compiler compiler = new Compiler(errorListener, locator, m_funcTable);
176 
177     if (SELECT == type)
178       parser.initXPath(compiler, exprString, prefixResolver);
179     else if (MATCH == type)
180       parser.initMatchPattern(compiler, exprString, prefixResolver);
181     else
<span class="line-modified">182       throw new RuntimeException(XSLMessages.createXPATHMessage(</span>
<span class="line-added">183               XPATHErrorResources.ER_CANNOT_DEAL_XPATH_TYPE,</span>
<span class="line-added">184               new Object[]{Integer.toString(type)}));</span>
185 
186     // System.out.println(&quot;----------------&quot;);
<span class="line-modified">187     Expression expr = compiler.compileExpression(0);</span>
188 
189     // System.out.println(&quot;expr: &quot;+expr);
190     this.setExpression(expr);
191 
192     if((null != locator) &amp;&amp; locator instanceof ExpressionNode)
193     {
194         expr.exprSetParent((ExpressionNode)locator);
195     }
196 
197   }
198 
199   /**
200    * Construct an XPath object.
201    *
202    * (Needs review -sc) This method initializes an XPathParser/
203    * Compiler and compiles the expression.
204    * @param exprString The XPath expression.
205    * @param locator The location of the expression, may be null.
206    * @param prefixResolver A prefix resolver to use to resolve prefixes to
207    *                       namespace URIs.
</pre>
<hr />
<pre>
219     m_funcTable = aTable;
220     if(null == errorListener)
221       errorListener = new com.sun.org.apache.xml.internal.utils.DefaultErrorHandler();
222 
223     m_patternString = exprString;
224 
225     XPathParser parser = new XPathParser(errorListener, locator);
226     Compiler compiler = new Compiler(errorListener, locator, m_funcTable);
227 
228     if (SELECT == type)
229       parser.initXPath(compiler, exprString, prefixResolver);
230     else if (MATCH == type)
231       parser.initMatchPattern(compiler, exprString, prefixResolver);
232     else
233       throw new RuntimeException(XSLMessages.createXPATHMessage(
234             XPATHErrorResources.ER_CANNOT_DEAL_XPATH_TYPE,
235             new Object[]{Integer.toString(type)}));
236             //&quot;Can not deal with XPath type: &quot; + type);
237 
238     // System.out.println(&quot;----------------&quot;);
<span class="line-modified">239     Expression expr = compiler.compileExpression(0);</span>
240 
241     // System.out.println(&quot;expr: &quot;+expr);
242     this.setExpression(expr);
243 
244     if((null != locator) &amp;&amp; locator instanceof ExpressionNode)
245     {
246         expr.exprSetParent((ExpressionNode)locator);
247     }
248 
249   }
250 
251   /**
252    * Construct an XPath object.
253    *
254    * (Needs review -sc) This method initializes an XPathParser/
255    * Compiler and compiles the expression.
256    * @param exprString The XPath expression.
257    * @param locator The location of the expression, may be null.
258    * @param prefixResolver A prefix resolver to use to resolve prefixes to
259    *                       namespace URIs.
</pre>
</td>
</tr>
</table>
<center><a href="../../xml/internal/serializer/dom3/LSSerializerImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="axes/FilterExprWalker.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToUnknownStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *     http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xml.internal.serializer;
  22 
  23 import java.io.IOException;
  24 import java.io.OutputStream;
  25 import java.io.Writer;
  26 import java.util.ArrayList;
  27 import java.util.List;
  28 import java.util.Properties;
  29 import javax.xml.transform.ErrorListener;
  30 import javax.xml.transform.SourceLocator;
  31 import javax.xml.transform.Transformer;
  32 import org.w3c.dom.Node;
  33 import org.xml.sax.Attributes;
  34 import org.xml.sax.ContentHandler;
  35 import org.xml.sax.Locator;
  36 import org.xml.sax.SAXException;
  37 
  38 /**
  39  *This class wraps another SerializationHandler. The wrapped object will either
  40  * handler XML or HTML, which is not known until a little later when the first XML
  41  * tag is seen.  If the first tag is &lt;html&gt; then the wrapped object is an HTML
  42  * handler, otherwise it is an XML handler.
  43  *
  44  * This class effectively caches the first few calls to it then passes them
  45  * on to the wrapped handler (once it exists).  After that subsequent calls a
  46  * simply passed directly to the wrapped handler.
  47  *
  48  * The user of this class doesn&#39;t know if the output is ultimatley XML or HTML.
  49  *
  50  * This class is not a public API, it is public because it is used within Xalan.
  51  * @xsl.usage internal
  52  * @LastModified: Aug 2019
  53  */
  54 public final class ToUnknownStream extends SerializerBase
  55 {
  56     /**
  57      * The wrapped handler, initially XML but possibly switched to HTML
  58      */
  59     private SerializationHandler m_handler;
  60 
  61     /**
  62      * A String with no characters
  63      */
  64     private static final String EMPTYSTRING = &quot;&quot;;
  65 
  66     /**
  67      * true if the underlying handler (XML or HTML) is fully initialized
  68      */
  69     private boolean m_wrapped_handler_not_initialized = false;
  70 
  71     /**
  72      * the prefix of the very first tag in the document
  73      */
  74     private String m_firstElementPrefix;
  75 
  76     /**
  77      * the element name (including any prefix) of the very first tag in the document
  78      */
  79     private String m_firstElementName;
  80 
  81     /**
  82      * the namespace URI associated with the first element
  83      */
  84     private String m_firstElementURI;
  85 
  86     /**
  87      * the local name (no prefix) associated with the first element
  88      */
  89     private String m_firstElementLocalName = null;
  90 
  91     /**
  92      * true if the first tag has been emitted to the wrapped handler
  93      */
  94     private boolean m_firstTagNotEmitted = true;
  95 
  96     /**
  97      * A collection of namespace URI&#39;s (only for first element).
  98      * _namespacePrefix has the matching prefix for these URI&#39;s
  99      */
 100     private List&lt;String&gt; m_namespaceURI = null;
 101 
 102     /**
 103      * A collection of namespace Prefix (only for first element)
 104      * _namespaceURI has the matching URIs for these prefix&#39;
 105      */
 106     private List&lt;String&gt; m_namespacePrefix = null;
 107 
 108     /**
 109      * true if startDocument() was called before the underlying handler
 110      * was initialized
 111      */
 112     private boolean m_needToCallStartDocument = false;
 113 
 114     /**
 115      * Default constructor.
 116      * Initially this object wraps an XML Stream object, so _handler is never null.
 117      * That may change later to an HTML Stream object.
 118      */
 119     public ToUnknownStream() {
 120         this(null);
 121     }
 122 
 123     public ToUnknownStream(ErrorListener l) {
 124         m_handler = new ToXMLStream(l);
 125     }
 126 
 127     /**
 128      * @see Serializer#asContentHandler()
 129      * @return the wrapped XML or HTML handler
 130      */
 131     public ContentHandler asContentHandler() throws IOException {
 132         /* don&#39;t return the real handler ( m_handler ) because
 133          * that would expose the real handler to the outside.
 134          * Keep m_handler private so it can be internally swapped
 135          * to an HTML handler.
 136          */
 137         return this;
 138     }
 139 
 140     /**
 141      * @see SerializationHandler#close()
 142      */
 143     public void close() {
 144         m_handler.close();
 145     }
 146 
 147     /**
 148      * @see Serializer#getOutputFormat()
 149      * @return the properties of the underlying handler
 150      */
 151     public Properties getOutputFormat() {
 152         return m_handler.getOutputFormat();
 153     }
 154 
 155     /**
 156      * @see Serializer#getOutputStream()
 157      * @return the OutputStream of the underlying XML or HTML handler
 158      */
 159     public OutputStream getOutputStream() {
 160         return m_handler.getOutputStream();
 161     }
 162 
 163     /**
 164      * @see Serializer#getWriter()
 165      * @return the Writer of the underlying XML or HTML handler
 166      */
 167     public Writer getWriter() {
 168         return m_handler.getWriter();
 169     }
 170 
 171     /**
 172      * passes the call on to the underlying HTML or XML handler
 173      * @see Serializer#reset()
 174      * @return ???
 175      */
 176     public boolean reset() {
 177         return m_handler.reset();
 178     }
 179 
 180     /**
 181      * Converts the DOM node to output
 182      * @param node the DOM node to transform to output
 183      * @see DOMSerializer#serialize(Node)
 184      *
 185      */
 186     public void serialize(Node node) throws IOException {
 187         if (m_firstTagNotEmitted) {
 188             flush();
 189         }
 190         m_handler.serialize(node);
 191     }
 192 
 193     /**
 194      * @see SerializationHandler#setEscaping(boolean)
 195      */
 196     public boolean setEscaping(boolean escape) throws SAXException {
 197         return m_handler.setEscaping(escape);
 198     }
 199 
 200     /**
 201      * Set the properties of the handler
 202      * @param format the output properties to set
 203      * @see Serializer#setOutputFormat(Properties)
 204      */
 205     public void setOutputFormat(Properties format) {
 206         m_handler.setOutputFormat(format);
 207     }
 208 
 209     /**
 210      * Sets the output stream to write to
 211      * @param output the OutputStream to write to
 212      * @see Serializer#setOutputStream(OutputStream)
 213      */
 214     public void setOutputStream(OutputStream output) {
 215         m_handler.setOutputStream(output);
 216     }
 217 
 218     /**
 219      * Sets the writer to write to
 220      * @param writer the writer to write to
 221      * @see Serializer#setWriter(Writer)
 222      */
 223     public void setWriter(Writer writer) {
 224         m_handler.setWriter(writer);
 225     }
 226 
 227     /**
 228      * Adds an attribute to the currenly open tag
 229      * @param uri the URI of a namespace
 230      * @param localName the attribute name, without prefix
 231      * @param rawName the attribute name, with prefix (if any)
 232      * @param type the type of the attribute, typically &quot;CDATA&quot;
 233      * @param value the value of the parameter
 234      * @param XSLAttribute true if this attribute is coming from an xsl:attribute element
 235      * @see ExtendedContentHandler#addAttribute(String, String, String, String, String)
 236      */
 237     public void addAttribute(String uri, String localName, String rawName,
 238                              String type, String value)
 239         throws SAXException
 240     {
 241         addAttribute(uri, localName, rawName, type, value, false);
 242     }
 243 
 244     /**
 245      * Adds an attribute to the currenly open tag
 246      * @param uri the URI of a namespace
 247      * @param localName the attribute name, without prefix
 248      * @param rawName the attribute name, with prefix (if any)
 249      * @param type the type of the attribute, typically &quot;CDATA&quot;
 250      * @param value the value of the parameter
 251      * @param XSLAttribute true if this attribute is coming from an xsl:attribute element
 252      * @see ExtendedContentHandler#addAttribute(String, String, String, String, String)
 253      */
 254     public void addAttribute(String uri, String localName, String rawName,
 255                              String type, String value, boolean XSLAttribute)
 256         throws SAXException
 257     {
 258         if (m_firstTagNotEmitted) {
 259             flush();
 260         }
 261         m_handler.addAttribute(uri, localName, rawName, type, value, XSLAttribute);
 262     }
 263 
 264     /**
 265      * Adds an attribute to the currenly open tag
 266      * @param rawName the attribute name, with prefix (if any)
 267      * @param value the value of the parameter
 268      * @see ExtendedContentHandler#addAttribute(String, String)
 269      */
 270     public void addAttribute(String rawName, String value) {
 271         if (m_firstTagNotEmitted) {
 272             flush();
 273         }
 274         m_handler.addAttribute(rawName, value);
 275     }
 276 
 277     /**
 278      * Adds a unique attribute to the currenly open tag
 279      */
 280     public void addUniqueAttribute(String rawName, String value, int flags)
 281         throws SAXException
 282     {
 283         if (m_firstTagNotEmitted) {
 284             flush();
 285         }
 286         m_handler.addUniqueAttribute(rawName, value, flags);
 287     }
 288 
 289     /**
 290      * Converts the String to a character array and calls the SAX method
 291      * characters(char[],int,int);
 292      *
 293      * @param chars The string of characters to process.
 294      *
 295      * @throws org.xml.sax.SAXException
 296      *
 297      * @see ExtendedContentHandler#characters(String)
 298      */
 299     public void characters(String chars) throws SAXException {
 300         final int len = (chars == null) ? 0 : chars.length();
 301         if (len &gt; m_charsBuff.length) {
 302             m_charsBuff = new char[len * 2 + 1];
 303         }
 304         if (len &gt; 0) {
 305             chars.getChars(0, len, m_charsBuff, 0);
 306         }
 307         this.characters(m_charsBuff, 0, len);
 308     }
 309 
 310     /**
 311      * Pass the call on to the underlying handler
 312      * @see ExtendedContentHandler#endElement(String)
 313      */
 314     public void endElement(String elementName) throws SAXException {
 315         if (m_firstTagNotEmitted) {
 316             flush();
 317         }
 318         m_handler.endElement(elementName);
 319     }
 320 
 321     /**
 322      * @see org.xml.sax.ContentHandler#startPrefixMapping(String, String)
 323      * @param prefix The prefix that maps to the URI
 324      * @param uri The URI for the namespace
 325      */
 326     public void startPrefixMapping(String prefix, String uri) throws SAXException {
 327         this.startPrefixMapping(prefix,uri, true);
 328     }
 329 
 330     /**
 331      * This method is used when a prefix/uri namespace mapping
 332      * is indicated after the element was started with a
 333      * startElement() and before and endElement().
 334      * startPrefixMapping(prefix,uri) would be used before the
 335      * startElement() call.
 336      * @param uri the URI of the namespace
 337      * @param prefix the prefix associated with the given URI.
 338      *
 339      * @see ExtendedContentHandler#namespaceAfterStartElement(String, String)
 340      */
 341     public void namespaceAfterStartElement(String prefix, String uri)
 342         throws SAXException
 343     {
 344         // hack for XSLTC with finding URI for default namespace
 345         if (m_firstTagNotEmitted &amp;&amp;
 346             m_firstElementURI == null &amp;&amp;
 347             m_firstElementName != null)
 348         {
 349             String prefix1 = getPrefixPart(m_firstElementName);
 350             if (prefix1 == null &amp;&amp; EMPTYSTRING.equals(prefix)) {
 351                 // the elements URI is not known yet, and it
 352                 // doesn&#39;t have a prefix, and we are currently
 353                 // setting the uri for prefix &quot;&quot;, so we have
 354                 // the uri for the element... lets remember it
 355                 m_firstElementURI = uri;
 356             }
 357         }
 358         startPrefixMapping(prefix, uri, false);
 359     }
 360 
 361     public boolean startPrefixMapping(String prefix, String uri, boolean shouldFlush)
 362         throws SAXException
 363     {
 364         boolean pushed = false;
 365         if (m_firstTagNotEmitted) {
 366             if (m_firstElementName != null &amp;&amp; shouldFlush) {
 367                 /* we&#39;ve already seen a startElement, and this is a prefix mapping
 368                  * for the up coming element, so flush the old element
 369                  * then send this event on its way.
 370                  */
 371                 flush();
 372                 pushed = m_handler.startPrefixMapping(prefix, uri, shouldFlush);
 373             } else {
 374                 if (m_namespacePrefix == null) {
 375                     m_namespacePrefix = new ArrayList&lt;&gt;();
 376                     m_namespaceURI = new ArrayList&lt;&gt;();
 377                 }
 378                 m_namespacePrefix.add(prefix);
 379                 m_namespaceURI.add(uri);
 380 
 381                 if (m_firstElementURI == null) {
 382                     if (prefix.equals(m_firstElementPrefix))
 383                         m_firstElementURI = uri;
 384                 }
 385             }
 386         } else {
 387             pushed = m_handler.startPrefixMapping(prefix, uri, shouldFlush);
 388         }
 389         return pushed;
 390     }
 391 
 392     /**
 393       * This method cannot be cached because default is different in
 394       * HTML and XML (we need more than a boolean).
 395       */
 396     public void setVersion(String version) {
 397         m_handler.setVersion(version);
 398     }
 399 
 400     /**
 401      * @see org.xml.sax.ContentHandler#startDocument()
 402      */
 403     public void startDocument() throws SAXException {
 404         m_needToCallStartDocument = true;
 405     }
 406 
 407     public void startElement(String qName) throws SAXException {
 408         this.startElement(null, null, qName, null);
 409     }
 410 
 411     public void startElement(String namespaceURI, String localName,
 412                              String qName) throws SAXException {
 413         this.startElement(namespaceURI, localName, qName, null);
 414     }
 415 
 416     public void startElement(String namespaceURI, String localName,
 417                              String elementName, Attributes atts)
 418         throws SAXException
 419     {
 420         if (m_needToCallSetDocumentInfo) {
 421             super.setDocumentInfo();
 422             m_needToCallSetDocumentInfo = false;
 423         }
 424 
 425         /* we are notified of the start of an element */
 426         if (m_firstTagNotEmitted) {
 427             /* we have not yet sent the first element on its way */
 428             if (m_firstElementName != null) {
 429                 /* this is not the first element, but a later one.
 430                  * But we have the old element pending, so flush it out,
 431                  * then send this one on its way.
 432                  */
 433                 flush();
 434                 m_handler.startElement(namespaceURI, localName, elementName,  atts);
 435             }
 436             else
 437             {
 438                 /* this is the very first element that we have seen,
 439                  * so save it for flushing later.  We may yet get to know its
 440                  * URI due to added attributes.
 441                  */
 442 
 443                 m_wrapped_handler_not_initialized = true;
 444                 m_firstElementName = elementName;
 445 
 446                 // null if not known
 447                 m_firstElementPrefix = getPrefixPartUnknown(elementName);
 448 
 449                 // null if not known
 450                 m_firstElementURI = namespaceURI;
 451 
 452                 // null if not known
 453                 m_firstElementLocalName = localName;
 454 
 455                 if (m_tracer != null)
 456                     firePseudoElement(elementName);
 457 
 458                 /* we don&#39;t want to call our own addAttributes, which
 459                  * merely delegates to the wrapped handler, but we want to
 460                  * add these attributes to m_attributes. So me must call super.
 461                  * addAttributes() In this case m_attributes is only used for the
 462                  * first element, after that this class totally delegates to the
 463                  * wrapped handler which is either XML or HTML.
 464                  */
 465                 if (atts != null)
 466                     super.addAttributes(atts);
 467 
 468                 // if there are attributes, then lets make the flush()
 469                 // call the startElement on the handler and send the
 470                 // attributes on their way.
 471                 if (atts != null)
 472                     flush();
 473 
 474             }
 475         }
 476         else
 477         {
 478             // this is not the first element, but a later one, so just
 479             // send it on its way.
 480             m_handler.startElement(namespaceURI, localName, elementName,  atts);
 481         }
 482     }
 483 
 484     /**
 485      * Pass the call on to the underlying handler
 486      * @see ExtendedLexicalHandler#comment(String)
 487      */
 488     public void comment(String comment) throws SAXException
 489     {
 490         if (m_firstTagNotEmitted &amp;&amp; m_firstElementName != null)
 491         {
 492             emitFirstTag();
 493         }
 494         else if (m_needToCallStartDocument)
 495         {
 496             m_handler.startDocument();
 497             m_needToCallStartDocument = false;
 498         }
 499 
 500         m_handler.comment(comment);
 501     }
 502 
 503     /**
 504      * Pass the call on to the underlying handler
 505      * @see XSLOutputAttributes#getDoctypePublic()
 506      */
 507     public String getDoctypePublic()
 508     {
 509 
 510         return m_handler.getDoctypePublic();
 511     }
 512 
 513     /**
 514      * Pass the call on to the underlying handler
 515      * @see XSLOutputAttributes#getDoctypeSystem()
 516      */
 517     public String getDoctypeSystem()
 518     {
 519         return m_handler.getDoctypeSystem();
 520     }
 521 
 522     /**
 523      * Pass the call on to the underlying handler
 524      * @see XSLOutputAttributes#getEncoding()
 525      */
 526     public String getEncoding()
 527     {
 528         return m_handler.getEncoding();
 529     }
 530 
 531     /**
 532      * Pass the call on to the underlying handler
 533      * @see XSLOutputAttributes#getIndent()
 534      */
 535     public boolean getIndent()
 536     {
 537         return m_handler.getIndent();
 538     }
 539 
 540     /**
 541      * Pass the call on to the underlying handler
 542      * @see XSLOutputAttributes#getIndentAmount()
 543      */
 544     public int getIndentAmount()
 545     {
 546         return m_handler.getIndentAmount();
 547     }
 548 
 549     /**
 550      * Pass the call on to the underlying handler
 551      * @see XSLOutputAttributes#getMediaType()
 552      */
 553     public String getMediaType()
 554     {
 555         return m_handler.getMediaType();
 556     }
 557 
 558     /**
 559      * Pass the call on to the underlying handler
 560      * @see XSLOutputAttributes#getOmitXMLDeclaration()
 561      */
 562     public boolean getOmitXMLDeclaration()
 563     {
 564         return m_handler.getOmitXMLDeclaration();
 565     }
 566 
 567     /**
 568      * Pass the call on to the underlying handler
 569      * @see XSLOutputAttributes#getStandalone()
 570      */
 571     public String getStandalone()
 572     {
 573         return m_handler.getStandalone();
 574     }
 575 
 576     /**
 577      * Pass the call on to the underlying handler
 578      * @see XSLOutputAttributes#getVersion()
 579      */
 580     public String getVersion() {
 581         return m_handler.getVersion();
 582     }
 583 
 584     /**
 585      * @see XSLOutputAttributes#setDoctype(String, String)
 586      */
 587     public void setDoctype(String system, String pub) {
 588         m_handler.setDoctypePublic(pub);
 589         m_handler.setDoctypeSystem(system);
 590     }
 591 
 592     /**
 593      * Set the doctype in the underlying XML handler. Remember that this method
 594      * was called, just in case we need to transfer this doctype to an HTML handler
 595      * @param doctype the public doctype to set
 596      * @see XSLOutputAttributes#setDoctypePublic(String)
 597      */
 598     public void setDoctypePublic(String doctype) {
 599         m_handler.setDoctypePublic(doctype);
 600     }
 601 
 602     /**
 603      * Set the doctype in the underlying XML handler. Remember that this method
 604      * was called, just in case we need to transfer this doctype to an HTML handler
 605      * @param doctype the system doctype to set
 606      * @see XSLOutputAttributes#setDoctypeSystem(String)
 607      */
 608     public void setDoctypeSystem(String doctype) {
 609         m_handler.setDoctypeSystem(doctype);
 610     }
 611 
 612     /**
 613      * Pass the call on to the underlying handler
 614      * @see XSLOutputAttributes#setEncoding(String)
 615      */
 616     public void setEncoding(String encoding) {
 617         m_handler.setEncoding(encoding);
 618     }
 619 
 620     /**
 621      * Pass the call on to the underlying handler
 622      * @see XSLOutputAttributes#setIndent(boolean)
 623      */
 624     public void setIndent(boolean indent) {
 625         m_handler.setIndent(indent);
 626     }
 627 
 628     /**
 629      * Pass the call on to the underlying handler
 630      */
 631     public void setIndentAmount(int value) {
 632         m_handler.setIndentAmount(value);
 633     }
 634 
 635     /**
 636      * @see XSLOutputAttributes#setMediaType(String)
 637      */
 638     public void setMediaType(String mediaType) {
 639         m_handler.setMediaType(mediaType);
 640     }
 641 
 642     /**
 643      * Pass the call on to the underlying handler
 644      * @see XSLOutputAttributes#setOmitXMLDeclaration(boolean)
 645      */
 646     public void setOmitXMLDeclaration(boolean b) {
 647         m_handler.setOmitXMLDeclaration(b);
 648     }
 649 
 650     /**
 651      * Pass the call on to the underlying handler
 652      * @see XSLOutputAttributes#setStandalone(String)
 653      */
 654     public void setStandalone(String standalone) {
 655         m_handler.setStandalone(standalone);
 656     }
 657 
 658     /**
 659      * Pass the call on to the underlying handler
 660      * @see org.xml.sax.ext.DeclHandler#attributeDecl(String, String, String, String, String)
 661      */
 662     public void attributeDecl(String arg0, String arg1, String arg2,
 663                               String arg3, String arg4) throws SAXException {
 664         m_handler.attributeDecl(arg0, arg1, arg2, arg3, arg4);
 665     }
 666 
 667     /**
 668      * Pass the call on to the underlying handler
 669      * @see org.xml.sax.ext.DeclHandler#elementDecl(String, String)
 670      */
 671     public void elementDecl(String arg0, String arg1) throws SAXException
 672     {
 673         if (m_firstTagNotEmitted) {
 674             emitFirstTag();
 675         }
 676         m_handler.elementDecl(arg0, arg1);
 677     }
 678 
 679     /**
 680      * Pass the call on to the underlying handler
 681      * @see org.xml.sax.ext.DeclHandler#externalEntityDecl(String, String, String)
 682      */
 683     public void externalEntityDecl(
 684         String name,
 685         String publicId,
 686         String systemId)
 687         throws SAXException
 688     {
 689         if (m_firstTagNotEmitted) {
 690             flush();
 691         }
 692         m_handler.externalEntityDecl(name, publicId, systemId);
 693     }
 694 
 695     /**
 696      * Pass the call on to the underlying handler
 697      * @see org.xml.sax.ext.DeclHandler#internalEntityDecl(String, String)
 698      */
 699     public void internalEntityDecl(String arg0, String arg1)
 700         throws SAXException
 701     {
 702         if (m_firstTagNotEmitted) {
 703             flush();
 704         }
 705         m_handler.internalEntityDecl(arg0, arg1);
 706     }
 707 
 708     /**
 709      * Pass the call on to the underlying handler
 710      * @see org.xml.sax.ContentHandler#characters(char[], int, int)
 711      */
 712     public void characters(char[] characters, int offset, int length)
 713         throws SAXException
 714     {
 715         if (m_firstTagNotEmitted) {
 716             flush();
 717         }
 718         m_handler.characters(characters, offset, length);
 719     }
 720 
 721     /**
 722      * Pass the call on to the underlying handler
 723      * @see org.xml.sax.ContentHandler#endDocument()
 724      */
 725     public void endDocument() throws SAXException {
 726         if (m_firstTagNotEmitted) {
 727             flush();
 728         }
 729         m_handler.endDocument();
 730     }
 731 
 732     /**
 733      * Pass the call on to the underlying handler
 734      * @see org.xml.sax.ContentHandler#endElement(String, String, String)
 735      */
 736     public void endElement(String namespaceURI, String localName, String qName)
 737         throws SAXException
 738     {
 739         if (m_firstTagNotEmitted) {
 740             flush();
 741             if (namespaceURI == null &amp;&amp; m_firstElementURI != null)
 742                 namespaceURI = m_firstElementURI;
 743 
 744             if (localName == null &amp;&amp; m_firstElementLocalName != null)
 745                 localName = m_firstElementLocalName;
 746         }
 747         m_handler.endElement(namespaceURI, localName, qName);
 748     }
 749 
 750     /**
 751      * Pass the call on to the underlying handler
 752      * @see org.xml.sax.ContentHandler#endPrefixMapping(String)
 753      */
 754     public void endPrefixMapping(String prefix) throws SAXException {
 755         m_handler.endPrefixMapping(prefix);
 756     }
 757 
 758     /**
 759      * Pass the call on to the underlying handler
 760      * @see org.xml.sax.ContentHandler#ignorableWhitespace(char[], int, int)
 761      */
 762     public void ignorableWhitespace(char[] ch, int start, int length)
 763         throws SAXException
 764     {
 765         if (m_firstTagNotEmitted)
 766         {
 767             flush();
 768         }
 769         m_handler.ignorableWhitespace(ch, start, length);
 770     }
 771 
 772     /**
 773      * Pass the call on to the underlying handler
 774      * @see org.xml.sax.ContentHandler#processingInstruction(String, String)
 775      */
 776     public void processingInstruction(String target, String data)
 777         throws SAXException
 778     {
 779           if (m_firstTagNotEmitted)
 780         {
 781             flush();
 782         }
 783 
 784         m_handler.processingInstruction(target, data);
 785     }
 786 
 787     /**
 788      * Pass the call on to the underlying handler
 789      * @see org.xml.sax.ContentHandler#setDocumentLocator(Locator)
 790      */
 791     public void setDocumentLocator(Locator locator)
 792     {
 793         super.setDocumentLocator(locator);
 794         m_handler.setDocumentLocator(locator);
 795     }
 796 
 797     /**
 798      * Pass the call on to the underlying handler
 799      * @see org.xml.sax.ContentHandler#skippedEntity(String)
 800      */
 801     public void skippedEntity(String name) throws SAXException
 802     {
 803         m_handler.skippedEntity(name);
 804     }
 805 
 806 
 807 
 808     /**
 809      * Pass the call on to the underlying handler
 810      * @see org.xml.sax.ext.LexicalHandler#comment(char[], int, int)
 811      */
 812     public void comment(char[] ch, int start, int length) throws SAXException
 813     {
 814         if (m_firstTagNotEmitted)
 815         {
 816             flush();
 817         }
 818 
 819         m_handler.comment(ch, start, length);
 820     }
 821 
 822     /**
 823      * Pass the call on to the underlying handler
 824      * @see org.xml.sax.ext.LexicalHandler#endCDATA()
 825      */
 826     public void endCDATA() throws SAXException
 827     {
 828 
 829         m_handler.endCDATA();
 830     }
 831 
 832     /**
 833      * Pass the call on to the underlying handler
 834      * @see org.xml.sax.ext.LexicalHandler#endDTD()
 835      */
 836     public void endDTD() throws SAXException
 837     {
 838 
 839         m_handler.endDTD();
 840     }
 841 
 842     /**
 843      * Pass the call on to the underlying handler
 844      * @see org.xml.sax.ext.LexicalHandler#endEntity(String)
 845      */
 846     public void endEntity(String name) throws SAXException
 847     {
 848         if (m_firstTagNotEmitted)
 849         {
 850             emitFirstTag();
 851         }
 852         m_handler.endEntity(name);
 853     }
 854 
 855     /**
 856      * Pass the call on to the underlying handler
 857      * @see org.xml.sax.ext.LexicalHandler#startCDATA()
 858      */
 859     public void startCDATA() throws SAXException
 860     {
 861         m_handler.startCDATA();
 862     }
 863 
 864     /**
 865      * Pass the call on to the underlying handler
 866      * @see org.xml.sax.ext.LexicalHandler#startDTD(String, String, String)
 867      */
 868     public void startDTD(String name, String publicId, String systemId)
 869         throws SAXException
 870     {
 871         m_handler.startDTD(name, publicId, systemId);
 872     }
 873 
 874     /**
 875      * Pass the call on to the underlying handler
 876      * @see org.xml.sax.ext.LexicalHandler#startEntity(String)
 877      */
 878     public void startEntity(String name) throws SAXException
 879     {
 880         m_handler.startEntity(name);
 881     }
 882 
 883     /**
 884      * Initialize the wrapped output stream (XML or HTML).
 885      * If the stream handler should be HTML, then replace the XML handler with
 886      * an HTML handler. After than send the starting method calls that were cached
 887      * to the wrapped handler.
 888      *
 889      */
 890     private void initStreamOutput() throws SAXException
 891     {
 892 
 893         // Try to rule out if this is an not to be an HTML document based on prefix
 894         boolean firstElementIsHTML = isFirstElemHTML();
 895 
 896         if (firstElementIsHTML)
 897         {
 898             // create an HTML output handler, and initialize it
 899 
 900             // keep a reference to the old handler, ... it will soon be gone
 901             SerializationHandler oldHandler = m_handler;
 902 
 903             /* We have to make sure we get an output properties with the proper
 904              * defaults for the HTML method.  The easiest way to do this is to
 905              * have the OutputProperties class do it.
 906              */
 907 
 908             Properties htmlProperties =
 909                 OutputPropertiesFactory.getDefaultMethodProperties(Method.HTML);
 910             Serializer serializer =
 911                 SerializerFactory.getSerializer(htmlProperties);
 912 
 913             // The factory should be returning a ToStream
 914             // Don&#39;t know what to do if it doesn&#39;t
 915             // i.e. the user has over-ridden the content-handler property
 916             // for html
 917             m_handler = (SerializationHandler) serializer;
 918             //m_handler = new ToHTMLStream();
 919 
 920             Writer writer = oldHandler.getWriter();
 921 
 922             if (null != writer)
 923                 m_handler.setWriter(writer);
 924             else
 925             {
 926                 OutputStream os = oldHandler.getOutputStream();
 927 
 928                 if (null != os)
 929                     m_handler.setOutputStream(os);
 930             }
 931 
 932             // need to copy things from the old handler to the new one here
 933 
 934             //            if (_setVersion_called)
 935             //            {
 936             m_handler.setVersion(oldHandler.getVersion());
 937             //            }
 938             //            if (_setDoctypeSystem_called)
 939             //            {
 940             m_handler.setDoctypeSystem(oldHandler.getDoctypeSystem());
 941             //            }
 942             //            if (_setDoctypePublic_called)
 943             //            {
 944             m_handler.setDoctypePublic(oldHandler.getDoctypePublic());
 945             //            }
 946             //            if (_setMediaType_called)
 947             //            {
 948             m_handler.setMediaType(oldHandler.getMediaType());
 949             //            }
 950 
 951             m_handler.setTransformer(oldHandler.getTransformer());
 952         }
 953 
 954         /* Now that we have a real wrapped handler (XML or HTML) lets
 955          * pass any cached calls to it
 956          */
 957         // Call startDocument() if necessary
 958         if (m_needToCallStartDocument)
 959         {
 960             m_handler.startDocument();
 961             m_needToCallStartDocument = false;
 962         }
 963 
 964         // the wrapped handler is now fully initialized
 965         m_wrapped_handler_not_initialized = false;
 966     }
 967 
 968     private void emitFirstTag() throws SAXException {
 969         if (m_firstElementName != null) {
 970             if (m_wrapped_handler_not_initialized) {
 971                 initStreamOutput();
 972                 m_wrapped_handler_not_initialized = false;
 973             }
 974             // Output first tag
 975             m_handler.startElement(m_firstElementURI, null, m_firstElementName, m_attributes);
 976             // don&#39;t need the collected attributes of the first element anymore.
 977             m_attributes = null;
 978 
 979             // Output namespaces of first tag
 980             if (m_namespacePrefix != null) {
 981                 final int n = m_namespacePrefix.size();
 982                 for (int i = 0; i &lt; n; i++) {
 983                     final String prefix = m_namespacePrefix.get(i);
 984                     final String uri = m_namespaceURI.get(i);
 985                     m_handler.startPrefixMapping(prefix, uri, false);
 986                 }
 987                 m_namespacePrefix = null;
 988                 m_namespaceURI = null;
 989             }
 990             m_firstTagNotEmitted = false;
 991         }
 992     }
 993 
 994     /**
 995      * Utility function for calls to local-name().
 996      *
 997      * Don&#39;t want to override static function on SerializerBase
 998      * So added Unknown suffix to method name.
 999      */
1000     private String getLocalNameUnknown(String value) {
1001         int idx = value.lastIndexOf(&#39;:&#39;);
1002         if (idx &gt;= 0)
1003             value = value.substring(idx + 1);
1004         idx = value.lastIndexOf(&#39;@&#39;);
1005         if (idx &gt;= 0)
1006             value = value.substring(idx + 1);
1007         return (value);
1008     }
1009 
1010     /**
1011      * Utility function to return prefix
1012      *
1013      * Don&#39;t want to override static function on SerializerBase
1014      * So added Unknown suffix to method name.
1015      */
1016     private String getPrefixPartUnknown(String qname) {
1017         final int index = qname.indexOf(&#39;:&#39;);
1018         return (index &gt; 0) ? qname.substring(0, index) : EMPTYSTRING;
1019     }
1020 
1021     /**
1022      * Determine if the firts element in the document is &lt;html&gt; or &lt;HTML&gt;
1023      * This uses the cached first element name, first element prefix and the
1024      * cached namespaces from previous method calls
1025      *
1026      * @return true if the first element is an opening &lt;html&gt; tag
1027      */
1028     private boolean isFirstElemHTML() {
1029         boolean isHTML;
1030 
1031         // is the first tag html, not considering the prefix ?
1032         isHTML =
1033             getLocalNameUnknown(m_firstElementName).equalsIgnoreCase(&quot;html&quot;);
1034 
1035         // Try to rule out if this is not to be an HTML document based on URI
1036         if (isHTML &amp;&amp;
1037             m_firstElementURI != null &amp;&amp;
1038             !EMPTYSTRING.equals(m_firstElementURI))
1039         {
1040             // the &lt;html&gt; element has a non-trivial namespace
1041             isHTML = false;
1042         }
1043         // Try to rule out if this is an not to be an HTML document based on prefix
1044         if (isHTML &amp;&amp; m_namespacePrefix != null) {
1045             /* the first element has a name of &quot;html&quot;, but lets check the prefix.
1046              * If the prefix points to a namespace with a URL that is not &quot;&quot;
1047              * then the doecument doesn&#39;t start with an &lt;html&gt; tag, and isn&#39;t html
1048              */
1049             final int max = m_namespacePrefix.size();
1050             for (int i = 0; i &lt; max; i++) {
1051                 final String prefix = m_namespacePrefix.get(i);
1052                 final String uri = m_namespaceURI.get(i);
1053 
1054                 if (m_firstElementPrefix != null &amp;&amp;
1055                     m_firstElementPrefix.equals(prefix) &amp;&amp;
1056                     !EMPTYSTRING.equals(uri))
1057                 {
1058                     // The first element has a prefix, so it can&#39;t be &lt;html&gt;
1059                     isHTML = false;
1060                     break;
1061                 }
1062             }
1063 
1064         }
1065         return isHTML;
1066     }
1067 
1068     /**
1069      * @see Serializer#asDOMSerializer()
1070      */
1071     public DOMSerializer asDOMSerializer() throws IOException {
1072         return m_handler.asDOMSerializer();
1073     }
1074 
1075     /**
1076      * @param URI_and_localNames a list of pairs of URI/localName
1077      * specified in the cdata-section-elements attribute.
1078      * @see SerializationHandler#setCdataSectionElements(List)
1079      */
1080     public void setCdataSectionElements(List&lt;String&gt; URI_and_localNames) {
1081         m_handler.setCdataSectionElements(URI_and_localNames);
1082     }
1083 
1084     /**
1085      * @see ExtendedContentHandler#addAttributes(org.xml.sax.Attributes)
1086      */
1087     public void addAttributes(Attributes atts) throws SAXException {
1088         m_handler.addAttributes(atts);
1089     }
1090 
1091     /**
1092      * Get the current namespace mappings.
1093      * Simply returns the mappings of the wrapped handler.
1094      * @see ExtendedContentHandler#getNamespaceMappings()
1095      */
1096     public NamespaceMappings getNamespaceMappings() {
1097         NamespaceMappings mappings = null;
1098         if (m_handler != null) {
1099             mappings = m_handler.getNamespaceMappings();
1100         }
1101         return mappings;
1102     }
1103 
1104     /**
1105      * @see SerializationHandler#flushPending()
1106      */
1107     public void flushPending() throws SAXException {
1108         flush();
1109         m_handler.flushPending();
1110     }
1111 
1112     private void flush() {
1113         try {
1114             if (m_firstTagNotEmitted) {
1115                 emitFirstTag();
1116             }
1117             if (m_needToCallStartDocument) {
1118                 m_handler.startDocument();
1119                 m_needToCallStartDocument = false;
1120             }
1121         } catch(SAXException e) {
1122             throw new RuntimeException(e.toString());
1123         }
1124     }
1125 
1126     /**
1127      * @see ExtendedContentHandler#getPrefix
1128      */
1129     public String getPrefix(String namespaceURI) {
1130         return m_handler.getPrefix(namespaceURI);
1131     }
1132 
1133     /**
1134      * @see ExtendedContentHandler#entityReference(java.lang.String)
1135      */
1136     public void entityReference(String entityName) throws SAXException {
1137         m_handler.entityReference(entityName);
1138     }
1139 
1140     /**
1141      * @see ExtendedContentHandler#getNamespaceURI(java.lang.String, boolean)
1142      */
1143     public String getNamespaceURI(String qname, boolean isElement) {
1144         return m_handler.getNamespaceURI(qname, isElement);
1145     }
1146 
1147     public String getNamespaceURIFromPrefix(String prefix) {
1148         return m_handler.getNamespaceURIFromPrefix(prefix);
1149     }
1150 
1151     public void setTransformer(Transformer t) {
1152         m_handler.setTransformer(t);
1153         if ((t instanceof SerializerTrace) &amp;&amp;
1154             (((SerializerTrace) t).hasTraceListeners()))
1155         {
1156             m_tracer = (SerializerTrace) t;
1157         } else {
1158             m_tracer = null;
1159         }
1160     }
1161 
1162     public Transformer getTransformer() {
1163         return m_handler.getTransformer();
1164     }
1165 
1166     /**
1167      * @see SerializationHandler#setContentHandler(org.xml.sax.ContentHandler)
1168      */
1169     public void setContentHandler(ContentHandler ch) {
1170         m_handler.setContentHandler(ch);
1171     }
1172 
1173     /**
1174      * This method is used to set the source locator, which might be used to
1175      * generated an error message.
1176      * @param locator the source locator
1177      *
1178      * @see ExtendedContentHandler#setSourceLocator(javax.xml.transform.SourceLocator)
1179      */
1180     public void setSourceLocator(SourceLocator locator) {
1181         m_handler.setSourceLocator(locator);
1182     }
1183 
1184     protected void firePseudoElement(String elementName) {
1185         if (m_tracer != null) {
1186             StringBuffer sb = new StringBuffer();
1187 
1188             sb.append(&#39;&lt;&#39;);
1189             sb.append(elementName);
1190 
1191             // convert the StringBuffer to a char array and
1192             // emit the trace event that these characters &quot;might&quot;
1193             // be written
1194             char ch[] = sb.toString().toCharArray();
1195             m_tracer.fireGenerateEvent(
1196                 SerializerTrace.EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS,
1197                 ch,
1198                 0,
1199                 ch.length);
1200         }
1201     }
1202 
1203     /**
1204      * @see org.apache.xml.serializer.Serializer#asDOM3Serializer()
1205      */
1206     public Object asDOM3Serializer() throws IOException
1207     {
1208         return m_handler.asDOM3Serializer();
1209     }
1210 }
    </pre>
  </body>
</html>
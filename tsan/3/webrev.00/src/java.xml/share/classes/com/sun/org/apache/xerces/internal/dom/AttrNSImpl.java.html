<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/AttrNSImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.xerces.internal.dom;
 23 
 24 import com.sun.org.apache.xerces.internal.impl.dv.xs.XSSimpleTypeDecl;
 25 import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
 26 import com.sun.org.apache.xerces.internal.xs.XSSimpleTypeDefinition;
 27 import org.w3c.dom.DOMException;
 28 
 29 /**
 30  * AttrNSImpl inherits from AttrImpl and adds namespace support.
 31  * &lt;P&gt;
 32  * The qualified name is the node name, and we store localName which is also
 33  * used in all queries. On the other hand we recompute the prefix when
 34  * necessary.
 35  *
 36  * @xerces.internal
 37  *
 38  * @author Arnaud  Le Hors, IBM
 39  * @author Andy Clark, IBM
 40  * @author Ralf Pfeiffer, IBM
 41  */
 42 public class AttrNSImpl
 43     extends AttrImpl {
 44 
 45     //
 46     // Constants
 47     //
 48 
 49     /** Serialization version. */
 50     static final long serialVersionUID = -781906615369795414L;
 51 
 52     static final String xmlnsURI = &quot;http://www.w3.org/2000/xmlns/&quot;;
 53     static final String xmlURI = &quot;http://www.w3.org/XML/1998/namespace&quot;;
 54 
 55     //
 56     // Data
 57     //
 58 
 59     /** DOM2: Namespace URI. */
 60     protected String namespaceURI;
 61 
 62     /** DOM2: localName. */
 63     protected String localName;
 64 
 65     /*
 66      * Default constructor
 67      */
 68     public AttrNSImpl(){}
 69 
 70    /**
 71      * DOM2: Constructor for Namespace implementation.
 72      */
 73     protected AttrNSImpl(CoreDocumentImpl ownerDocument,
 74                          String namespaceURI,
 75                          String qualifiedName) {
 76 
 77         super(ownerDocument, qualifiedName);
 78         setName(namespaceURI, qualifiedName);
 79     }
 80 
 81     private void setName(String namespaceURI, String qname){
 82         CoreDocumentImpl ownerDocument = ownerDocument();
 83         String prefix;
 84         // DOM Level 3: namespace URI is never empty string.
 85         this.namespaceURI = namespaceURI;
 86         if (namespaceURI !=null) {
 87             this.namespaceURI = (namespaceURI.length() == 0)? null
 88                     : namespaceURI;
 89 
 90         }
 91         int colon1 = qname.indexOf(&#39;:&#39;);
 92         int colon2 = qname.lastIndexOf(&#39;:&#39;);
 93         ownerDocument.checkNamespaceWF(qname, colon1, colon2);
 94         if (colon1 &lt; 0) {
 95             // there is no prefix
 96             localName = qname;
 97             if (ownerDocument.errorChecking) {
 98                 ownerDocument.checkQName(null, localName);
 99 
100                 if (qname.equals(&quot;xmlns&quot;) &amp;&amp; (namespaceURI == null
101                     || !namespaceURI.equals(NamespaceContext.XMLNS_URI))
102                     || (namespaceURI!=null &amp;&amp; namespaceURI.equals(NamespaceContext.XMLNS_URI)
103                     &amp;&amp; !qname.equals(&quot;xmlns&quot;))) {
104                     String msg =
105                         DOMMessageFormatter.formatMessage(
106                                 DOMMessageFormatter.DOM_DOMAIN,
107                                 &quot;NAMESPACE_ERR&quot;,
108                                 null);
109                     throw new DOMException(DOMException.NAMESPACE_ERR, msg);
110                 }
111             }
112         }
113         else {
114             prefix = qname.substring(0, colon1);
115             localName = qname.substring(colon2+1);
116             ownerDocument.checkQName(prefix, localName);
117             ownerDocument.checkDOMNSErr(prefix, namespaceURI);
118         }
119     }
120 
121     // when local name is known
122     public AttrNSImpl(CoreDocumentImpl ownerDocument,
123                          String namespaceURI,
124                          String qualifiedName,
125                          String localName) {
126         super(ownerDocument, qualifiedName);
127 
128         this.localName = localName;
129         this.namespaceURI = namespaceURI;
130     }
131 
132     // for DeferredAttrImpl
133     protected AttrNSImpl(CoreDocumentImpl ownerDocument,
134                          String value) {
135         super(ownerDocument, value);
136     }
137 
138     // Support for DOM Level 3 renameNode method.
139     // Note: This only deals with part of the pb. It is expected to be
140     // called after the Attr has been detached for one thing.
141     // CoreDocumentImpl does all the work.
142     void rename(String namespaceURI, String qualifiedName) {
143         if (needsSyncData()) {
144             synchronizeData();
145         }
146                 this.name = qualifiedName;
147         setName(namespaceURI, qualifiedName);
148     }
149 
150     //
151     // DOM2: Namespace methods
152     //
153 
154     /**
155      * Introduced in DOM Level 2. &lt;p&gt;
156      *
157      * The namespace URI of this node, or null if it is unspecified.&lt;p&gt;
158      *
159      * This is not a computed value that is the result of a namespace lookup
160      * based on an examination of the namespace declarations in scope. It is
161      * merely the namespace URI given at creation time.&lt;p&gt;
162      *
163      * For nodes created with a DOM Level 1 method, such as createElement
164      * from the Document interface, this is null.
165      * @since WD-DOM-Level-2-19990923
166      */
167     public String getNamespaceURI()
168     {
169         if (needsSyncData()) {
170             synchronizeData();
171         }
172         // REVIST: This code could/should be done at a lower-level, such that
173         // the namespaceURI is set properly upon creation. However, there still
174         // seems to be some DOM spec interpretation grey-area.
175         return namespaceURI;
176     }
177 
178     /**
179      * Introduced in DOM Level 2. &lt;p&gt;
180      *
181      * The namespace prefix of this node, or null if it is unspecified. &lt;p&gt;
182      *
183      * For nodes created with a DOM Level 1 method, such as createElement
184      * from the Document interface, this is null. &lt;p&gt;
185      *
186      * @since WD-DOM-Level-2-19990923
187      */
188     public String getPrefix()
189     {
190         if (needsSyncData()) {
191             synchronizeData();
192         }
193         int index = name.indexOf(&#39;:&#39;);
194         return index &lt; 0 ? null : name.substring(0, index);
195     }
196 
197     /**
198      * Introduced in DOM Level 2. &lt;p&gt;
199      *
200      * Note that setting this attribute changes the nodeName attribute, which
201      * holds the qualified name, as well as the tagName and name attributes of
202      * the Element and Attr interfaces, when applicable.&lt;p&gt;
203      *
204      * @param prefix The namespace prefix of this node, or null(empty string) if it is unspecified.
205      *
206      * @exception INVALID_CHARACTER_ERR
207      *                   Raised if the specified
208      *                   prefix contains an invalid character.
209      * @exception DOMException
210      * @since WD-DOM-Level-2-19990923
211      */
212     public void setPrefix(String prefix)
213         throws DOMException
214     {
215         if (needsSyncData()) {
216             synchronizeData();
217         }
218         if (ownerDocument().errorChecking) {
219             if (isReadOnly()) {
220                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
221                 throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);
222             }
223             if (prefix != null &amp;&amp; prefix.length() != 0) {
224 
225                 if (!CoreDocumentImpl.isXMLName(prefix,ownerDocument().isXML11Version())) {
226                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;INVALID_CHARACTER_ERR&quot;, null);
227                     throw new DOMException(DOMException.INVALID_CHARACTER_ERR, msg);
228                 }
229                 if (namespaceURI == null || prefix.indexOf(&#39;:&#39;) &gt;=0) {
230                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NAMESPACE_ERR&quot;, null);
231                     throw new DOMException(DOMException.NAMESPACE_ERR, msg);
232 
233                 }
234                if (prefix.equals(&quot;xmlns&quot;)) {
235                     if (!namespaceURI.equals(xmlnsURI)){
236                         String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NAMESPACE_ERR&quot;, null);
237                         throw new DOMException(DOMException.NAMESPACE_ERR, msg);
238                     }
239                 } else if (prefix.equals(&quot;xml&quot;)) {
240                     if (!namespaceURI.equals(xmlURI)) {
241                         String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NAMESPACE_ERR&quot;, null);
242                         throw new DOMException(DOMException.NAMESPACE_ERR, msg);
243                     }
244                 }else if (name.equals(&quot;xmlns&quot;)) {
245                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NAMESPACE_ERR&quot;, null);
246                     throw new DOMException(DOMException.NAMESPACE_ERR, msg);
247                 }
248             }
249         }
250 
251         // update node name with new qualifiedName
252         if (prefix !=null &amp;&amp; prefix.length() != 0) {
253             name = prefix + &quot;:&quot; + localName;
254         }
255         else {
256             name = localName;
257         }
258     }
259 
260     /**
261      * Introduced in DOM Level 2. &lt;p&gt;
262      *
263      * Returns the local part of the qualified name of this node.
264      * @since WD-DOM-Level-2-19990923
265      */
266     public String getLocalName()
267     {
268         if (needsSyncData()) {
269             synchronizeData();
270         }
271         return localName;
272     }
273 
274 
275     /**
276      * @see org.w3c.dom.TypeInfo#getTypeName()
277      */
278     public String getTypeName() {
279         if (type !=null){
280             if (type instanceof XSSimpleTypeDecl){
281                 return ((XSSimpleTypeDecl)type).getName();
282             }
283             return (String)type;
284         }
285         return null;
286     }
287 
288     /**
289      * Introduced in DOM Level 3. &lt;p&gt;
290      * Checks if a type is derived from another by restriction. See:
291      * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom
292      *
293      * @param typeNamespaceArg
294      *        The namspace of the ancestor type declaration
295      * @param typeNameArg
296      *        The name of the ancestor type declaration
297      * @param derivationMethod
298      *        The derivation method
299      *
300      * @return boolean True if the type is derived by restriction for the
301      *         reference type
302      */
303     public boolean isDerivedFrom(String typeNamespaceArg,
304                                  String typeNameArg,
305                                  int derivationMethod) {
306         if (type != null) {
307             if (type instanceof XSSimpleTypeDecl) {
308                 return ((XSSimpleTypeDecl) type).isDOMDerivedFrom(
309                         typeNamespaceArg, typeNameArg, derivationMethod);
310             }
311         }
312         return false;
313     }
314 
315     /**
316      * @see org.w3c.dom.TypeInfo#getTypeNamespace()
317      */
318     public String getTypeNamespace() {
319         if (type !=null) {
320             if (type instanceof XSSimpleTypeDecl){
321                 return ((XSSimpleTypeDecl)type).getNamespace();
322             }
323             return DTD_URI;
324         }
325         return null;
326     }
327 
328 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TargetLostException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="TypedInstruction.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Type.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,14 ***</span>
  import com.sun.org.apache.bcel.internal.Const;
  import com.sun.org.apache.bcel.internal.classfile.ClassFormatException;
  import com.sun.org.apache.bcel.internal.classfile.Utility;
  
  /**
<span class="line-modified">!  * Abstract super class for all possible java types, namely basic types such as</span>
<span class="line-modified">!  * int, object types like String and array types, e.g. int[]</span>
   *
<span class="line-modified">!  * @version $Id: Type.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
   */
  public abstract class Type {
  
      private final byte type;
      private String signature; // signature for the type
<span class="line-new-header">--- 25,14 ---</span>
  import com.sun.org.apache.bcel.internal.Const;
  import com.sun.org.apache.bcel.internal.classfile.ClassFormatException;
  import com.sun.org.apache.bcel.internal.classfile.Utility;
  
  /**
<span class="line-modified">!  * Abstract super class for all possible java types, namely basic types</span>
<span class="line-modified">!  * such as int, object types like String and array types, e.g. int[]</span>
   *
<span class="line-modified">!  * @LastModified: Jan 2020</span>
   */
  public abstract class Type {
  
      private final byte type;
      private String signature; // signature for the type
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,67 ***</span>
      public static final ReferenceType NULL = new ReferenceType() {
      };
      public static final Type UNKNOWN = new Type(Const.T_UNKNOWN, &quot;&lt;unknown object&gt;&quot;) {
      };
  
      protected Type(final byte t, final String s) {
          type = t;
          signature = s;
      }
  
      /**
       * @return hashcode of Type
       */
      @Override
      public int hashCode() {
          return type ^ signature.hashCode();
      }
  
      /**
       * @return whether the Types are equal
       */
      @Override
      public boolean equals(final Object o) {
<span class="line-modified">!         if (o instanceof Type) {</span>
<span class="line-modified">!             final Type t = (Type) o;</span>
<span class="line-modified">!             return (type == t.type) &amp;&amp; signature.equals(t.signature);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return false;</span>
      }
  
      /**
       * @return signature for given type.
       */
      public String getSignature() {
          return signature;
      }
  
      /**
       * @return type as defined in Constants
       */
      public byte getType() {
          return type;
      }
  
      /**
<span class="line-modified">!      * boolean, short and char variable are considered as int in the stack or</span>
<span class="line-modified">!      * local variable area. Returns {@link Type#INT} for</span>
<span class="line-removed">-      * {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise</span>
       * returns the given type.
<span class="line-removed">-      *</span>
       * @since 6.0
       */
      public Type normalizeForStackOrLocal() {
          if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {
              return Type.INT;
          }
          return this;
      }
  
      /**
<span class="line-modified">!      * @return stack size of this type (2 for long and double, 0 for void, 1</span>
<span class="line-removed">-      * otherwise)</span>
       */
      public int getSize() {
          switch (type) {
              case Const.T_DOUBLE:
              case Const.T_LONG:
<span class="line-new-header">--- 57,69 ---</span>
      public static final ReferenceType NULL = new ReferenceType() {
      };
      public static final Type UNKNOWN = new Type(Const.T_UNKNOWN, &quot;&lt;unknown object&gt;&quot;) {
      };
  
<span class="line-added">+ </span>
      protected Type(final byte t, final String s) {
          type = t;
          signature = s;
      }
  
<span class="line-added">+ </span>
      /**
       * @return hashcode of Type
       */
      @Override
      public int hashCode() {
          return type ^ signature.hashCode();
      }
  
<span class="line-added">+ </span>
      /**
       * @return whether the Types are equal
       */
      @Override
      public boolean equals(final Object o) {
<span class="line-modified">!           if (o instanceof Type) {</span>
<span class="line-modified">!               final Type t = (Type)o;</span>
<span class="line-modified">!               return (type == t.type) &amp;&amp; signature.equals(t.signature);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           return false;</span>
      }
  
<span class="line-added">+ </span>
      /**
       * @return signature for given type.
       */
      public String getSignature() {
          return signature;
      }
  
<span class="line-added">+ </span>
      /**
       * @return type as defined in Constants
       */
      public byte getType() {
          return type;
      }
  
      /**
<span class="line-modified">!      * boolean, short and char variable are considered as int in the stack or local variable area.</span>
<span class="line-modified">!      * Returns {@link Type#INT} for {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise</span>
       * returns the given type.
       * @since 6.0
       */
      public Type normalizeForStackOrLocal() {
          if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {
              return Type.INT;
          }
          return this;
      }
  
      /**
<span class="line-modified">!      * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)</span>
       */
      public int getSize() {
          switch (type) {
              case Const.T_DOUBLE:
              case Const.T_LONG:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,28 ***</span>
              default:
                  return 1;
          }
      }
  
      /**
       * @return Type string, e.g. `int[]&#39;
       */
      @Override
      public String toString() {
          return ((this.equals(Type.NULL) || (type &gt;= Const.T_UNKNOWN))) ? signature : Utility
                  .signatureToString(signature, false);
      }
  
      /**
       * Convert type to Java method signature, e.g. int[] f(java.lang.String x)
       * becomes (Ljava/lang/String;)[I
       *
       * @param return_type what the method returns
       * @param arg_types what are the argument types
       * @return method signature for given type(s).
       */
<span class="line-modified">!     public static String getMethodSignature(final Type return_type, final Type[] arg_types) {</span>
          final StringBuilder buf = new StringBuilder(&quot;(&quot;);
          if (arg_types != null) {
              for (final Type arg_type : arg_types) {
                  buf.append(arg_type.getSignature());
              }
<span class="line-new-header">--- 129,30 ---</span>
              default:
                  return 1;
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @return Type string, e.g. `int[]&#39;
       */
      @Override
      public String toString() {
          return ((this.equals(Type.NULL) || (type &gt;= Const.T_UNKNOWN))) ? signature : Utility
                  .signatureToString(signature, false);
      }
  
<span class="line-added">+ </span>
      /**
       * Convert type to Java method signature, e.g. int[] f(java.lang.String x)
       * becomes (Ljava/lang/String;)[I
       *
       * @param return_type what the method returns
       * @param arg_types what are the argument types
       * @return method signature for given type(s).
       */
<span class="line-modified">!     public static String getMethodSignature( final Type return_type, final Type[] arg_types ) {</span>
          final StringBuilder buf = new StringBuilder(&quot;(&quot;);
          if (arg_types != null) {
              for (final Type arg_type : arg_types) {
                  buf.append(arg_type.getSignature());
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,26 ***</span>
          protected Integer initialValue() {
              return Integer.valueOf(0);
          }
      };//int consumed_chars=0; // Remember position in string, see getArgumentTypes
  
<span class="line-modified">!     private static int unwrap(final ThreadLocal&lt;Integer&gt; tl) {</span>
          return tl.get().intValue();
      }
  
<span class="line-modified">!     private static void wrap(final ThreadLocal&lt;Integer&gt; tl, final int value) {</span>
          tl.set(Integer.valueOf(value));
      }
  
      /**
       * Convert signature to a Type object.
<span class="line-removed">-      *</span>
       * @param signature signature string such as Ljava/lang/String;
       * @return type object
       */
      // @since 6.0 no longer final
<span class="line-modified">!     public static Type getType(final String signature) throws StringIndexOutOfBoundsException {</span>
          final byte type = Utility.typeOfSignature(signature);
          if (type &lt;= Const.T_VOID) {
              //corrected concurrent private static field acess
              wrap(consumed_chars, 1);
              return BasicType.getType(type);
<span class="line-new-header">--- 168,28 ---</span>
          protected Integer initialValue() {
              return Integer.valueOf(0);
          }
      };//int consumed_chars=0; // Remember position in string, see getArgumentTypes
  
<span class="line-modified">! </span>
<span class="line-added">+     private static int unwrap( final ThreadLocal&lt;Integer&gt; tl ) {</span>
          return tl.get().intValue();
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private static void wrap( final ThreadLocal&lt;Integer&gt; tl, final int value ) {</span>
          tl.set(Integer.valueOf(value));
      }
  
<span class="line-added">+ </span>
      /**
       * Convert signature to a Type object.
       * @param signature signature string such as Ljava/lang/String;
       * @return type object
       */
      // @since 6.0 no longer final
<span class="line-modified">!     public static Type getType( final String signature ) throws StringIndexOutOfBoundsException {</span>
          final byte type = Utility.typeOfSignature(signature);
          if (type &lt;= Const.T_VOID) {
              //corrected concurrent private static field acess
              wrap(consumed_chars, 1);
              return BasicType.getType(type);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,49 ***</span>
              //  consumed_chars += dim; // update counter - is replaced by
              final int _temp = unwrap(consumed_chars) + dim;
              wrap(consumed_chars, _temp);
              return new ArrayType(t, dim);
          } else { // type == T_REFERENCE
<span class="line-modified">!             // Utility.signatureToString understands how to parse</span>
<span class="line-modified">!             // generic types.</span>
<span class="line-removed">-             final String parsedSignature = Utility.signatureToString(signature, false);</span>
              wrap(consumed_chars, parsedSignature.length() + 2); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed
              return ObjectType.getInstance(parsedSignature.replace(&#39;/&#39;, &#39;.&#39;));
          }
      }
  
      /**
       * Convert return value of a method (signature) to a Type object.
       *
       * @param signature signature string such as (Ljava/lang/String;)V
       * @return return type
       */
<span class="line-modified">!     public static Type getReturnType(final String signature) {</span>
          try {
              // Read return type after `)&#39;
              final int index = signature.lastIndexOf(&#39;)&#39;) + 1;
              return getType(signature.substring(index));
          } catch (final StringIndexOutOfBoundsException e) { // Should never occur
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
      }
  
      /**
       * Convert arguments of a method (signature) to an array of Type objects.
<span class="line-removed">-      *</span>
       * @param signature signature string such as (Ljava/lang/String;)V
       * @return array of argument types
       */
<span class="line-modified">!     public static Type[] getArgumentTypes(final String signature) {</span>
          final List&lt;Type&gt; vec = new ArrayList&lt;&gt;();
          int index;
          Type[] types;
<span class="line-modified">!         try { // Read all declarations between for `(&#39; and `)&#39;</span>
<span class="line-modified">!             if (signature.charAt(0) != &#39;(&#39;) {</span>
                  throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
              }
<span class="line-removed">-             index = 1; // current string position</span>
              while (signature.charAt(index) != &#39;)&#39;) {
                  vec.add(getType(signature.substring(index)));
                  //corrected concurrent private static field acess
                  index += unwrap(consumed_chars); // update position
              }
<span class="line-new-header">--- 204,50 ---</span>
              //  consumed_chars += dim; // update counter - is replaced by
              final int _temp = unwrap(consumed_chars) + dim;
              wrap(consumed_chars, _temp);
              return new ArrayType(t, dim);
          } else { // type == T_REFERENCE
<span class="line-modified">!             // Utility.typeSignatureToString understands how to parse generic types.</span>
<span class="line-modified">!             final String parsedSignature = Utility.typeSignatureToString(signature, false);</span>
              wrap(consumed_chars, parsedSignature.length() + 2); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed
              return ObjectType.getInstance(parsedSignature.replace(&#39;/&#39;, &#39;.&#39;));
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Convert return value of a method (signature) to a Type object.
       *
       * @param signature signature string such as (Ljava/lang/String;)V
       * @return return type
       */
<span class="line-modified">!     public static Type getReturnType( final String signature ) {</span>
          try {
              // Read return type after `)&#39;
              final int index = signature.lastIndexOf(&#39;)&#39;) + 1;
              return getType(signature.substring(index));
          } catch (final StringIndexOutOfBoundsException e) { // Should never occur
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Convert arguments of a method (signature) to an array of Type objects.
       * @param signature signature string such as (Ljava/lang/String;)V
       * @return array of argument types
       */
<span class="line-modified">!     public static Type[] getArgumentTypes( final String signature ) {</span>
          final List&lt;Type&gt; vec = new ArrayList&lt;&gt;();
          int index;
          Type[] types;
<span class="line-modified">!         try {</span>
<span class="line-modified">!             // Skip any type arguments to read argument declarations between `(&#39; and `)&#39;</span>
<span class="line-added">+             index = signature.indexOf(&#39;(&#39;) + 1;</span>
<span class="line-added">+             if (index &lt;= 0) {</span>
                  throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
              }
              while (signature.charAt(index) != &#39;)&#39;) {
                  vec.add(getType(signature.substring(index)));
                  //corrected concurrent private static field acess
                  index += unwrap(consumed_chars); // update position
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 250,17 ***</span>
          types = new Type[vec.size()];
          vec.toArray(types);
          return types;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Convert runtime java.lang.Class to BCEL Type object.</span>
<span class="line-removed">-      *</span>
       * @param cl Java class
       * @return corresponding Type object
       */
<span class="line-modified">!     public static Type getType(final java.lang.Class&lt;?&gt; cl) {</span>
          if (cl == null) {
              throw new IllegalArgumentException(&quot;Class must not be null&quot;);
          }
          /* That&#39;s an amzingly easy case, because getName() returns
           * the signature. That&#39;s what we would have liked anyway.
<span class="line-new-header">--- 257,16 ---</span>
          types = new Type[vec.size()];
          vec.toArray(types);
          return types;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Convert runtime java.lang.Class to BCEL Type object.</span>
       * @param cl Java class
       * @return corresponding Type object
       */
<span class="line-modified">!     public static Type getType( final java.lang.Class&lt;?&gt; cl ) {</span>
          if (cl == null) {
              throw new IllegalArgumentException(&quot;Class must not be null&quot;);
          }
          /* That&#39;s an amzingly easy case, because getName() returns
           * the signature. That&#39;s what we would have liked anyway.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 294,25 ***</span>
          } else { // &quot;Real&quot; class
              return ObjectType.getInstance(cl.getName());
          }
      }
  
      /**
       * Convert runtime java.lang.Class[] to BCEL Type objects.
<span class="line-removed">-      *</span>
       * @param classes an array of runtime class objects
       * @return array of corresponding Type objects
       */
<span class="line-modified">!     public static Type[] getTypes(final java.lang.Class&lt;?&gt;[] classes) {</span>
          final Type[] ret = new Type[classes.length];
          for (int i = 0; i &lt; ret.length; i++) {
              ret[i] = getType(classes[i]);
          }
          return ret;
      }
  
<span class="line-modified">!     public static String getSignature(final java.lang.reflect.Method meth) {</span>
          final StringBuilder sb = new StringBuilder(&quot;(&quot;);
          final Class&lt;?&gt;[] params = meth.getParameterTypes(); // avoid clone
          for (final Class&lt;?&gt; param : params) {
              sb.append(getType(param).getSignature());
          }
<span class="line-new-header">--- 300,26 ---</span>
          } else { // &quot;Real&quot; class
              return ObjectType.getInstance(cl.getName());
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Convert runtime java.lang.Class[] to BCEL Type objects.
       * @param classes an array of runtime class objects
       * @return array of corresponding Type objects
       */
<span class="line-modified">!     public static Type[] getTypes( final java.lang.Class&lt;?&gt;[] classes ) {</span>
          final Type[] ret = new Type[classes.length];
          for (int i = 0; i &lt; ret.length; i++) {
              ret[i] = getType(classes[i]);
          }
          return ret;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public static String getSignature( final java.lang.reflect.Method meth ) {</span>
          final StringBuilder sb = new StringBuilder(&quot;(&quot;);
          final Class&lt;?&gt;[] params = meth.getParameterTypes(); // avoid clone
          for (final Class&lt;?&gt; param : params) {
              sb.append(getType(param).getSignature());
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 331,18 ***</span>
  
      static int encode(final int size, final int consumed) {
          return consumed &lt;&lt; 2 | size;
      }
  
<span class="line-modified">!     static int getArgumentTypesSize(final String signature) {</span>
          int res = 0;
          int index;
<span class="line-modified">!         try { // Read all declarations between for `(&#39; and `)&#39;</span>
<span class="line-modified">!             if (signature.charAt(0) != &#39;(&#39;) {</span>
                  throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
              }
<span class="line-removed">-             index = 1; // current string position</span>
              while (signature.charAt(index) != &#39;)&#39;) {
                  final int coded = getTypeSize(signature.substring(index));
                  res += size(coded);
                  index += consumed(coded);
              }
<span class="line-new-header">--- 338,19 ---</span>
  
      static int encode(final int size, final int consumed) {
          return consumed &lt;&lt; 2 | size;
      }
  
<span class="line-modified">!     static int getArgumentTypesSize( final String signature ) {</span>
          int res = 0;
          int index;
<span class="line-modified">!         try {</span>
<span class="line-modified">!             // Skip any type arguments to read argument declarations between `(&#39; and `)&#39;</span>
<span class="line-added">+             index = signature.indexOf(&#39;(&#39;) + 1;</span>
<span class="line-added">+             if (index &lt;= 0) {</span>
                  throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
              }
              while (signature.charAt(index) != &#39;)&#39;) {
                  final int coded = getTypeSize(signature.substring(index));
                  res += size(coded);
                  index += consumed(coded);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,11 ***</span>
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
          return res;
      }
  
<span class="line-modified">!     static int getTypeSize(final String signature) throws StringIndexOutOfBoundsException {</span>
          final byte type = Utility.typeOfSignature(signature);
          if (type &lt;= Const.T_VOID) {
              return encode(BasicType.getType(type).getSize(), 1);
          } else if (type == Const.T_ARRAY) {
              int dim = 0;
<span class="line-new-header">--- 358,11 ---</span>
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
          return res;
      }
  
<span class="line-modified">!     static int getTypeSize( final String signature ) throws StringIndexOutOfBoundsException {</span>
          final byte type = Utility.typeOfSignature(signature);
          if (type &lt;= Const.T_VOID) {
              return encode(BasicType.getType(type).getSize(), 1);
          } else if (type == Const.T_ARRAY) {
              int dim = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 371,10 ***</span>
<span class="line-new-header">--- 379,11 ---</span>
              }
              return encode(1, index + 1);
          }
      }
  
<span class="line-added">+ </span>
      static int getReturnTypeSize(final String signature) {
          final int index = signature.lastIndexOf(&#39;)&#39;) + 1;
          return Type.size(getTypeSize(signature.substring(index)));
      }
  
</pre>
<center><a href="TargetLostException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="TypedInstruction.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
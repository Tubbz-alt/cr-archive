<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/MethodGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MULTIANEWARRAY.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MethodObserver.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/MethodGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 package com.sun.org.apache.bcel.internal.generic;
  21 
  22 import com.sun.org.apache.bcel.internal.Const;
  23 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
  24 import com.sun.org.apache.bcel.internal.classfile.Annotations;
  25 import com.sun.org.apache.bcel.internal.classfile.Attribute;
  26 import com.sun.org.apache.bcel.internal.classfile.Code;
  27 import com.sun.org.apache.bcel.internal.classfile.CodeException;
  28 import com.sun.org.apache.bcel.internal.classfile.ExceptionTable;
  29 import com.sun.org.apache.bcel.internal.classfile.LineNumber;
  30 import com.sun.org.apache.bcel.internal.classfile.LineNumberTable;
  31 import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
  32 import com.sun.org.apache.bcel.internal.classfile.LocalVariableTable;
  33 import com.sun.org.apache.bcel.internal.classfile.LocalVariableTypeTable;
  34 import com.sun.org.apache.bcel.internal.classfile.Method;
  35 import com.sun.org.apache.bcel.internal.classfile.ParameterAnnotationEntry;
  36 import com.sun.org.apache.bcel.internal.classfile.ParameterAnnotations;
  37 import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleParameterAnnotations;
  38 import com.sun.org.apache.bcel.internal.classfile.Utility;
  39 import com.sun.org.apache.bcel.internal.util.BCELComparator;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
<span class="line-removed">  42 import java.util.Comparator;</span>
  43 import java.util.HashMap;
  44 import java.util.List;
  45 import java.util.Map;

  46 import java.util.Stack;
  47 
  48 /**
  49  * Template class for building up a method. This is done by defining exception
  50  * handlers, adding thrown exceptions, local variables and attributes, whereas
  51  * the `LocalVariableTable&#39; and `LineNumberTable&#39; attributes will be set
  52  * automatically for the code. Use stripAttributes() if you don&#39;t like this.
  53  *
  54  * While generating code it may be necessary to insert NOP operations. You can
<span class="line-modified">  55  * use the `removeNOPs&#39; method to get rid off them. The resulting method object</span>
<span class="line-modified">  56  * can be obtained via the `getMethod()&#39; method.</span>
  57  *
<span class="line-modified">  58  * @version $Id: MethodGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
<span class="line-modified">  59  * @see InstructionList</span>
<span class="line-modified">  60  * @see Method</span>
<span class="line-removed">  61  * @LastModified: Oct 2017</span>
  62  */
  63 public class MethodGen extends FieldGenOrMethodGen {
  64 
  65     private String class_name;
  66     private Type[] arg_types;
  67     private String[] arg_names;
  68     private int max_locals;
  69     private int max_stack;
  70     private InstructionList il;
  71     private boolean strip_attributes;

  72     private final List&lt;LocalVariableGen&gt; variable_vec = new ArrayList&lt;&gt;();
<span class="line-removed">  73     private final List&lt;LocalVariableGen&gt; type_vec = new ArrayList&lt;&gt;();</span>
  74     private final List&lt;LineNumberGen&gt; line_number_vec = new ArrayList&lt;&gt;();
  75     private final List&lt;CodeExceptionGen&gt; exception_vec = new ArrayList&lt;&gt;();
  76     private final List&lt;String&gt; throws_vec = new ArrayList&lt;&gt;();
  77     private final List&lt;Attribute&gt; code_attrs_vec = new ArrayList&lt;&gt;();
  78 
  79     private List&lt;AnnotationEntryGen&gt;[] param_annotations; // Array of lists containing AnnotationGen objects
  80     private boolean hasParameterAnnotations = false;
  81     private boolean haveUnpackedParameterAnnotations = false;
  82 
  83     private static BCELComparator bcelComparator = new BCELComparator() {
  84 
  85         @Override
<span class="line-modified">  86         public boolean equals(final Object o1, final Object o2) {</span>
  87             final MethodGen THIS = (MethodGen) o1;
  88             final MethodGen THAT = (MethodGen) o2;
<span class="line-modified">  89             return THIS.getName().equals(THAT.getName())</span>
<span class="line-modified">  90                     &amp;&amp; THIS.getSignature().equals(THAT.getSignature());</span>
  91         }
  92 

  93         @Override
<span class="line-modified">  94         public int hashCode(final Object o) {</span>
  95             final MethodGen THIS = (MethodGen) o;
  96             return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
  97         }
  98     };
  99 

 100     /**
<span class="line-modified"> 101      * Declare method. If the method is non-static the constructor automatically</span>
<span class="line-modified"> 102      * declares a local variable `$this&#39; in slot 0. The actual code is contained</span>
<span class="line-modified"> 103      * in the `il&#39; parameter, which may further manipulated by the user. But he</span>
<span class="line-modified"> 104      * must take care not to remove any instruction (handles) that are still</span>
<span class="line-modified"> 105      * referenced from this object.</span>
 106      *
 107      * For example one may not add a local variable and later remove the
<span class="line-modified"> 108      * instructions it refers to without causing havoc. It is safe however if</span>
<span class="line-modified"> 109      * you remove that local variable, too.</span>
 110      *
 111      * @param access_flags access qualifiers
<span class="line-modified"> 112      * @param return_type method type</span>
 113      * @param arg_types argument types
<span class="line-modified"> 114      * @param arg_names argument names (if this is null, default names will be</span>
<span class="line-modified"> 115      * provided for them)</span>
 116      * @param method_name name of method
<span class="line-modified"> 117      * @param class_name class name containing this method (may be null, if you</span>
<span class="line-modified"> 118      * don&#39;t care)</span>
<span class="line-modified"> 119      * @param il instruction list associated with this method, may be null only</span>
<span class="line-removed"> 120      * for abstract or native methods</span>
 121      * @param cp constant pool
 122      */
 123     public MethodGen(final int access_flags, final Type return_type, final Type[] arg_types, String[] arg_names,
 124             final String method_name, final String class_name, final InstructionList il, final ConstantPoolGen cp) {
 125         super(access_flags);
 126         setType(return_type);
 127         setArgumentTypes(arg_types);
 128         setArgumentNames(arg_names);
 129         setName(method_name);
 130         setClassName(class_name);
 131         setInstructionList(il);
 132         setConstantPool(cp);
 133         final boolean abstract_ = isAbstract() || isNative();
 134         InstructionHandle start = null;
<span class="line-modified"> 135         InstructionHandle end = null;</span>
 136         if (!abstract_) {
 137             start = il.getStart();
<span class="line-modified"> 138             end = il.getEnd();</span>
 139             /* Add local variables, namely the implicit `this&#39; and the arguments
 140              */
 141             if (!isStatic() &amp;&amp; (class_name != null)) { // Instance method -&gt; `this&#39; is local var 0
<span class="line-modified"> 142                 addLocalVariable(&quot;this&quot;, ObjectType.getInstance(class_name), start, end);</span>
 143             }
 144         }
 145         if (arg_types != null) {
 146             final int size = arg_types.length;
 147             for (final Type arg_type : arg_types) {
 148                 if (Type.VOID == arg_type) {
 149                     throw new ClassGenException(&quot;&#39;void&#39; is an illegal argument type for a method&quot;);
 150                 }
 151             }
 152             if (arg_names != null) { // Names for variables provided?
 153                 if (size != arg_names.length) {
 154                     throw new ClassGenException(&quot;Mismatch in argument array lengths: &quot; + size
 155                             + &quot; vs. &quot; + arg_names.length);
 156                 }
 157             } else { // Give them dummy names
 158                 arg_names = new String[size];
 159                 for (int i = 0; i &lt; size; i++) {
 160                     arg_names[i] = &quot;arg&quot; + i;
 161                 }
 162                 setArgumentNames(arg_names);
 163             }
 164             if (!abstract_) {
 165                 for (int i = 0; i &lt; size; i++) {
 166                     addLocalVariable(arg_names[i], arg_types[i], start, end);
 167                 }
 168             }
 169         }
 170     }
 171 

 172     /**
 173      * Instantiate from existing method.
 174      *
 175      * @param m method
 176      * @param class_name class name containing this method
 177      * @param cp constant pool
 178      */
 179     public MethodGen(final Method m, final String class_name, final ConstantPoolGen cp) {
 180         this(m.getAccessFlags(), Type.getReturnType(m.getSignature()), Type.getArgumentTypes(m
<span class="line-modified"> 181                 .getSignature()), null /* may be overridden anyway */, m.getName(), class_name,</span>

 182                 ((m.getAccessFlags() &amp; (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0)
<span class="line-modified"> 183                 ? new InstructionList(m.getCode().getCode())</span>
<span class="line-modified"> 184                 : null, cp);</span>
 185         final Attribute[] attributes = m.getAttributes();
 186         for (final Attribute attribute : attributes) {
 187             Attribute a = attribute;
 188             if (a instanceof Code) {
 189                 final Code c = (Code) a;
 190                 setMaxStack(c.getMaxStack());
 191                 setMaxLocals(c.getMaxLocals());
 192                 final CodeException[] ces = c.getExceptionTable();
 193                 if (ces != null) {
 194                     for (final CodeException ce : ces) {
 195                         final int type = ce.getCatchType();
 196                         ObjectType c_type = null;
 197                         if (type &gt; 0) {
 198                             final String cen = m.getConstantPool().getConstantString(type,
 199                                     Const.CONSTANT_Class);
<span class="line-modified"> 200                             c_type = ObjectType.getInstance(cen);</span>
 201                         }
 202                         final int end_pc = ce.getEndPC();
 203                         final int length = m.getCode().getCode().length;
 204                         InstructionHandle end;
 205                         if (length == end_pc) { // May happen, because end_pc is exclusive
 206                             end = il.getEnd();
 207                         } else {
 208                             end = il.findHandle(end_pc);
 209                             end = end.getPrev(); // Make it inclusive
 210                         }
 211                         addExceptionHandler(il.findHandle(ce.getStartPC()), end, il.findHandle(ce
 212                                 .getHandlerPC()), c_type);
 213                     }
 214                 }
 215                 final Attribute[] c_attributes = c.getAttributes();
 216                 for (final Attribute c_attribute : c_attributes) {
 217                     a = c_attribute;
 218                     if (a instanceof LineNumberTable) {
 219                         final LineNumber[] ln = ((LineNumberTable) a).getLineNumberTable();
 220                         for (final LineNumber l : ln) {
 221                             final InstructionHandle ih = il.findHandle(l.getStartPC());
 222                             if (ih != null) {
 223                                 addLineNumber(ih, l.getLineNumber());
 224                             }
 225                         }
 226                     } else if (a instanceof LocalVariableTable) {
<span class="line-modified"> 227                         final LocalVariable[] lv = ((LocalVariableTable) a).getLocalVariableTable();</span>
<span class="line-removed"> 228                         removeLocalVariables();</span>
<span class="line-removed"> 229                         repairHandles(lv, false);</span>
 230                     } else if (a instanceof LocalVariableTypeTable) {
<span class="line-modified"> 231                         LocalVariable[] lv = ((LocalVariableTypeTable) a).getLocalVariableTypeTable();</span>
<span class="line-removed"> 232                         removeLocalVariableTypes();</span>
<span class="line-removed"> 233                         repairHandles(lv, true);</span>
 234                     } else {
 235                         addCodeAttribute(a);
 236                     }
 237                 }
 238             } else if (a instanceof ExceptionTable) {
 239                 final String[] names = ((ExceptionTable) a).getExceptionNames();
 240                 for (final String name2 : names) {
 241                     addException(name2);
 242                 }
 243             } else if (a instanceof Annotations) {
 244                 final Annotations runtimeAnnotations = (Annotations) a;
 245                 final AnnotationEntry[] aes = runtimeAnnotations.getAnnotationEntries();
 246                 for (final AnnotationEntry element : aes) {
 247                     addAnnotationEntry(new AnnotationEntryGen(element, cp, false));
 248                 }
 249             } else {
 250                 addAttribute(a);
 251             }
 252         }
 253     }
 254 
<span class="line-removed"> 255     private void repairHandles(final LocalVariable[] lv, boolean isLVT) {</span>
<span class="line-removed"> 256         for (int k = 0; k &lt; lv.length; k++) {</span>
<span class="line-removed"> 257             LocalVariable l = lv[k];</span>
<span class="line-removed"> 258             InstructionHandle start = il.findHandle(l.getStartPC());</span>
<span class="line-removed"> 259             InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());</span>
<span class="line-removed"> 260             // Repair malformed handles</span>
<span class="line-removed"> 261             if (null == start) {</span>
<span class="line-removed"> 262                 start = il.getStart();</span>
<span class="line-removed"> 263             }</span>
<span class="line-removed"> 264             if (null == end) {</span>
<span class="line-removed"> 265                 end = il.getEnd();</span>
<span class="line-removed"> 266             }</span>
<span class="line-removed"> 267             if (isLVT) {</span>
<span class="line-removed"> 268                 addLocalVariableType(l.getName(), Type.getType(l.getSignature()),</span>
<span class="line-removed"> 269                         l.getIndex(), start, end);</span>
<span class="line-removed"> 270             } else {</span>
<span class="line-removed"> 271                 addLocalVariable(l.getName(), Type.getType(l.getSignature()),</span>
<span class="line-removed"> 272                         l.getIndex(), start, end);</span>
<span class="line-removed"> 273             }</span>
<span class="line-removed"> 274         }</span>
<span class="line-removed"> 275     }</span>
<span class="line-removed"> 276 </span>
 277     /**
 278      * Adds a local variable to this method.
 279      *
 280      * @param name variable name
 281      * @param type variable type
<span class="line-modified"> 282      * @param slot the index of the local variable, if type is long or double,</span>
<span class="line-modified"> 283      * the next available index is slot+2</span>
 284      * @param start from where the variable is valid
 285      * @param end until where the variable is valid

 286      * @return new local variable object
 287      * @see LocalVariable
 288      */
<span class="line-modified"> 289     public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot,</span>
<span class="line-modified"> 290             final InstructionHandle start, final InstructionHandle end) {</span>
<span class="line-removed"> 291 </span>
 292         final byte t = type.getType();
 293         if (t != Const.T_ADDRESS) {
 294             final int add = type.getSize();
 295             if (slot + add &gt; max_locals) {
 296                 max_locals = slot + add;
 297             }
<span class="line-modified"> 298             final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end);</span>
 299             int i;
 300             if ((i = variable_vec.indexOf(l)) &gt;= 0) {
 301                 variable_vec.set(i, l);
 302             } else {
 303                 variable_vec.add(l);
 304             }
 305             return l;
 306         }
 307         throw new IllegalArgumentException(&quot;Can not use &quot; + type
 308                 + &quot; as type for local variable&quot;);
 309     }
 310 


















 311     /**
 312      * Adds a local variable to this method and assigns an index automatically.
 313      *
 314      * @param name variable name
 315      * @param type variable type
<span class="line-modified"> 316      * @param start from where the variable is valid, if this is null, it is</span>
<span class="line-modified"> 317      * valid from the start</span>
<span class="line-modified"> 318      * @param end until where the variable is valid, if this is null, it is</span>
<span class="line-modified"> 319      * valid to the end</span>
 320      * @return new local variable object
 321      * @see LocalVariable
 322      */
<span class="line-modified"> 323     public LocalVariableGen addLocalVariable(final String name, final Type type,</span>
<span class="line-modified"> 324             final InstructionHandle start, final InstructionHandle end) {</span>
 325         return addLocalVariable(name, type, max_locals, start, end);
 326     }
 327 

 328     /**
 329      * Remove a local variable, its slot will not be reused, if you do not use
 330      * addLocalVariable with an explicit index argument.
 331      */
 332     public void removeLocalVariable(final LocalVariableGen l) {
 333         variable_vec.remove(l);
 334     }
 335 

 336     /**
 337      * Remove all local variables.
 338      */
 339     public void removeLocalVariables() {
 340         variable_vec.clear();
 341     }
 342 

 343     /*
 344      * If the range of the variable has not been set yet, it will be set to be valid from
 345      * the start to the end of the instruction list.
 346      *
 347      * @return array of declared local variables sorted by index
 348      */
 349     public LocalVariableGen[] getLocalVariables() {
<span class="line-modified"> 350         return getLocalVariableOrTypes(false);</span>
<span class="line-modified"> 351     }</span>
<span class="line-modified"> 352 </span>
<span class="line-removed"> 353     /*</span>
<span class="line-removed"> 354      * If the range of the variable has not been set yet, it will be set to be</span>
<span class="line-removed"> 355      * valid from the start to the end of the instruction list.</span>
<span class="line-removed"> 356      *</span>
<span class="line-removed"> 357      * @return array of declared local variable types sorted by index</span>
<span class="line-removed"> 358      */</span>
<span class="line-removed"> 359     private LocalVariableGen[] getLocalVariableTypes() {</span>
<span class="line-removed"> 360         return getLocalVariableOrTypes(true);</span>
<span class="line-removed"> 361     }</span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363     /*</span>
<span class="line-removed"> 364      * If the range of the variable or type has not been set yet, it will be set</span>
<span class="line-removed"> 365      * to be valid from the start to the end of the instruction list.</span>
<span class="line-removed"> 366      *</span>
<span class="line-removed"> 367      * @return array of declared local variables or types sorted by index</span>
<span class="line-removed"> 368      */</span>
<span class="line-removed"> 369     private LocalVariableGen[] getLocalVariableOrTypes(boolean isLVT) {</span>
<span class="line-removed"> 370         int size = (isLVT) ? type_vec.size() : variable_vec.size();</span>
<span class="line-removed"> 371         LocalVariableGen[] lg = new LocalVariableGen[size];</span>
<span class="line-removed"> 372         if (isLVT) {</span>
<span class="line-removed"> 373             type_vec.toArray(lg);</span>
<span class="line-removed"> 374         } else {</span>
<span class="line-removed"> 375             variable_vec.toArray(lg);</span>
<span class="line-removed"> 376         }</span>
<span class="line-removed"> 377 </span>
 378         for (int i = 0; i &lt; size; i++) {
<span class="line-modified"> 379             if (lg[i].getStart() == null) {</span>
 380                 lg[i].setStart(il.getStart());
 381             }
<span class="line-modified"> 382 </span>
<span class="line-removed"> 383             if (lg[i].getEnd() == null) {</span>
 384                 lg[i].setEnd(il.getEnd());
 385             }
 386         }
<span class="line-removed"> 387 </span>
 388         if (size &gt; 1) {
<span class="line-modified"> 389             Arrays.sort(lg, new Comparator&lt;LocalVariableGen&gt;() {</span>
<span class="line-removed"> 390                 @Override</span>
<span class="line-removed"> 391                 public int compare(final LocalVariableGen o1, final LocalVariableGen o2) {</span>
<span class="line-removed"> 392                     return o1.getIndex() - o2.getIndex();</span>
<span class="line-removed"> 393                 }</span>
<span class="line-removed"> 394             });</span>
 395         }
<span class="line-removed"> 396 </span>
 397         return lg;
 398     }
 399 

 400     /**
<span class="line-modified"> 401      * @return `LocalVariableTable&#39; attribute of all the local variables of this</span>
<span class="line-removed"> 402      * method.</span>
 403      */
<span class="line-modified"> 404     public LocalVariableTable getLocalVariableTable(final ConstantPoolGen cp) {</span>
 405         final LocalVariableGen[] lg = getLocalVariables();
 406         final int size = lg.length;
 407         final LocalVariable[] lv = new LocalVariable[size];
 408         for (int i = 0; i &lt; size; i++) {
 409             lv[i] = lg[i].getLocalVariable(cp);
 410         }
 411         return new LocalVariableTable(cp.addUtf8(&quot;LocalVariableTable&quot;), 2 + lv.length * 10, lv, cp
 412                 .getConstantPool());
 413     }
 414 
 415     /**
<span class="line-modified"> 416      * @return `LocalVariableTypeTable&#39; attribute of all the local variable</span>
<span class="line-removed"> 417      * types of this method.</span>
 418      */
<span class="line-modified"> 419     public LocalVariableTypeTable getLocalVariableTypeTable(ConstantPoolGen cp) {</span>
<span class="line-modified"> 420         LocalVariableGen[] lg = getLocalVariableTypes();</span>
<span class="line-removed"> 421         int size = lg.length;</span>
<span class="line-removed"> 422         LocalVariable[] lv = new LocalVariable[size];</span>
<span class="line-removed"> 423 </span>
<span class="line-removed"> 424         for (int i = 0; i &lt; size; i++) {</span>
<span class="line-removed"> 425             lv[i] = lg[i].getLocalVariable(cp);</span>
<span class="line-removed"> 426         }</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428         return new LocalVariableTypeTable(cp.addUtf8(&quot;LocalVariableTypeTable&quot;),</span>
<span class="line-removed"> 429                 2 + lv.length * 10, lv, cp.getConstantPool());</span>
<span class="line-removed"> 430     }</span>
<span class="line-removed"> 431 </span>
<span class="line-removed"> 432     /**</span>
<span class="line-removed"> 433      * Adds a local variable type to this method.</span>
<span class="line-removed"> 434      *</span>
<span class="line-removed"> 435      * @param name variable name</span>
<span class="line-removed"> 436      * @param type variable type</span>
<span class="line-removed"> 437      * @param slot the index of the local variable, if type is long or double,</span>
<span class="line-removed"> 438      * the next available index is slot+2</span>
<span class="line-removed"> 439      * @param start from where the variable is valid</span>
<span class="line-removed"> 440      * @param end until where the variable is valid</span>
<span class="line-removed"> 441      * @return new local variable object</span>
<span class="line-removed"> 442      * @see LocalVariable</span>
<span class="line-removed"> 443      */</span>
<span class="line-removed"> 444     private LocalVariableGen addLocalVariableType(String name, Type type, int slot,</span>
<span class="line-removed"> 445             InstructionHandle start,</span>
<span class="line-removed"> 446             InstructionHandle end) {</span>
<span class="line-removed"> 447         byte t = type.getType();</span>
<span class="line-removed"> 448 </span>
<span class="line-removed"> 449         if (t != Const.T_ADDRESS) {</span>
<span class="line-removed"> 450             int add = type.getSize();</span>
<span class="line-removed"> 451 </span>
<span class="line-removed"> 452             if (slot + add &gt; max_locals) {</span>
<span class="line-removed"> 453                 max_locals = slot + add;</span>
<span class="line-removed"> 454             }</span>
<span class="line-removed"> 455 </span>
<span class="line-removed"> 456             LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end);</span>
<span class="line-removed"> 457             int i;</span>
<span class="line-removed"> 458 </span>
<span class="line-removed"> 459             if ((i = type_vec.indexOf(l)) &gt;= 0) // Overwrite if necessary</span>
<span class="line-removed"> 460             {</span>
<span class="line-removed"> 461                 type_vec.set(i, l);</span>
<span class="line-removed"> 462             } else {</span>
<span class="line-removed"> 463                 type_vec.add(l);</span>
<span class="line-removed"> 464             }</span>
<span class="line-removed"> 465 </span>
<span class="line-removed"> 466             return l;</span>
<span class="line-removed"> 467         } else {</span>
<span class="line-removed"> 468             throw new IllegalArgumentException(&quot;Can not use &quot; + type</span>
<span class="line-removed"> 469                     + &quot; as type for local variable&quot;);</span>
<span class="line-removed"> 470         }</span>
<span class="line-removed"> 471     }</span>
<span class="line-removed"> 472 </span>
<span class="line-removed"> 473     /**</span>
<span class="line-removed"> 474      * Remove all local variable types.</span>
<span class="line-removed"> 475      */</span>
<span class="line-removed"> 476     private void removeLocalVariableTypes() {</span>
<span class="line-removed"> 477         type_vec.clear();</span>
 478     }
 479 
 480     /**
 481      * Give an instruction a line number corresponding to the source code line.
 482      *
 483      * @param ih instruction to tag
 484      * @return new line number object
 485      * @see LineNumber
 486      */
<span class="line-modified"> 487     public LineNumberGen addLineNumber(final InstructionHandle ih, final int src_line) {</span>
 488         final LineNumberGen l = new LineNumberGen(ih, src_line);
 489         line_number_vec.add(l);
 490         return l;
 491     }
 492 

 493     /**
 494      * Remove a line number.
 495      */
<span class="line-modified"> 496     public void removeLineNumber(final LineNumberGen l) {</span>
 497         line_number_vec.remove(l);
 498     }
 499 

 500     /**
 501      * Remove all line numbers.
 502      */
 503     public void removeLineNumbers() {
 504         line_number_vec.clear();
 505     }
 506 

 507     /*
 508      * @return array of line numbers
 509      */
 510     public LineNumberGen[] getLineNumbers() {
 511         final LineNumberGen[] lg = new LineNumberGen[line_number_vec.size()];
 512         line_number_vec.toArray(lg);
 513         return lg;
 514     }
 515 

 516     /**
<span class="line-modified"> 517      * @return `LineNumberTable&#39; attribute of all the local variables of this</span>
<span class="line-removed"> 518      * method.</span>
 519      */
<span class="line-modified"> 520     public LineNumberTable getLineNumberTable(final ConstantPoolGen cp) {</span>
 521         final int size = line_number_vec.size();
 522         final LineNumber[] ln = new LineNumber[size];
 523         for (int i = 0; i &lt; size; i++) {
 524             ln[i] = line_number_vec.get(i).getLineNumber();
 525         }
 526         return new LineNumberTable(cp.addUtf8(&quot;LineNumberTable&quot;), 2 + ln.length * 4, ln, cp
 527                 .getConstantPool());
 528     }
 529 

 530     /**
<span class="line-modified"> 531      * Add an exception handler, i.e., specify region where a handler is active</span>
<span class="line-modified"> 532      * and an instruction where the actual handling is done.</span>
 533      *
 534      * @param start_pc Start of region (inclusive)
 535      * @param end_pc End of region (inclusive)
 536      * @param handler_pc Where handling is done
 537      * @param catch_type class type of handled exception or null if any
 538      * exception is handled
 539      * @return new exception handler object
 540      */
<span class="line-modified"> 541     public CodeExceptionGen addExceptionHandler(final InstructionHandle start_pc,</span>
<span class="line-modified"> 542             final InstructionHandle end_pc, final InstructionHandle handler_pc, final ObjectType catch_type) {</span>
 543         if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {
 544             throw new ClassGenException(&quot;Exception handler target is null instruction&quot;);
 545         }
 546         final CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);
 547         exception_vec.add(c);
 548         return c;
 549     }
 550 

 551     /**
 552      * Remove an exception handler.
 553      */
<span class="line-modified"> 554     public void removeExceptionHandler(final CodeExceptionGen c) {</span>
 555         exception_vec.remove(c);
 556     }
 557 

 558     /**
 559      * Remove all line numbers.
 560      */
 561     public void removeExceptionHandlers() {
 562         exception_vec.clear();
 563     }
 564 

 565     /*
 566      * @return array of declared exception handlers
 567      */
 568     public CodeExceptionGen[] getExceptionHandlers() {
 569         final CodeExceptionGen[] cg = new CodeExceptionGen[exception_vec.size()];
 570         exception_vec.toArray(cg);
 571         return cg;
 572     }
 573 

 574     /**
 575      * @return code exceptions for `Code&#39; attribute
 576      */
 577     private CodeException[] getCodeExceptions() {
 578         final int size = exception_vec.size();
 579         final CodeException[] c_exc = new CodeException[size];
 580         for (int i = 0; i &lt; size; i++) {
<span class="line-modified"> 581             final CodeExceptionGen c = exception_vec.get(i);</span>
 582             c_exc[i] = c.getCodeException(super.getConstantPool());
 583         }
 584         return c_exc;
 585     }
 586 

 587     /**
 588      * Add an exception possibly thrown by this method.
 589      *
 590      * @param class_name (fully qualified) name of exception
 591      */
<span class="line-modified"> 592     public void addException(final String class_name) {</span>
 593         throws_vec.add(class_name);
 594     }
 595 

 596     /**
 597      * Remove an exception.
 598      */
<span class="line-modified"> 599     public void removeException(final String c) {</span>
 600         throws_vec.remove(c);
 601     }
 602 

 603     /**
 604      * Remove all exceptions.
 605      */
 606     public void removeExceptions() {
 607         throws_vec.clear();
 608     }
 609 

 610     /*
 611      * @return array of thrown exceptions
 612      */
 613     public String[] getExceptions() {
 614         final String[] e = new String[throws_vec.size()];
 615         throws_vec.toArray(e);
 616         return e;
 617     }
 618 

 619     /**
<span class="line-modified"> 620      * @return `Exceptions&#39; attribute of all the exceptions thrown by this</span>
<span class="line-removed"> 621      * method.</span>
 622      */
<span class="line-modified"> 623     private ExceptionTable getExceptionTable(final ConstantPoolGen cp) {</span>
 624         final int size = throws_vec.size();
 625         final int[] ex = new int[size];
 626         for (int i = 0; i &lt; size; i++) {
 627             ex[i] = cp.addClass(throws_vec.get(i));
 628         }
 629         return new ExceptionTable(cp.addUtf8(&quot;Exceptions&quot;), 2 + 2 * size, ex, cp.getConstantPool());
 630     }
 631 

 632     /**
 633      * Add an attribute to the code. Currently, the JVM knows about the
<span class="line-modified"> 634      * LineNumberTable, LocalVariableTable and StackMap attributes, where the</span>
<span class="line-modified"> 635      * former two will be generated automatically and the latter is used for the</span>
<span class="line-modified"> 636      * MIDP only. Other attributes will be ignored by the JVM but do no harm.</span>

 637      *
 638      * @param a attribute to be added
 639      */
<span class="line-modified"> 640     public void addCodeAttribute(final Attribute a) {</span>
 641         code_attrs_vec.add(a);
 642     }
 643 








 644     /**
 645      * Remove a code attribute.
 646      */
<span class="line-modified"> 647     public void removeCodeAttribute(final Attribute a) {</span>
 648         code_attrs_vec.remove(a);
 649     }
 650 

 651     /**
 652      * Remove all code attributes.
 653      */
 654     public void removeCodeAttributes() {

 655         code_attrs_vec.clear();
 656     }
 657 

 658     /**
 659      * @return all attributes of this method.
 660      */
 661     public Attribute[] getCodeAttributes() {
 662         final Attribute[] attributes = new Attribute[code_attrs_vec.size()];
 663         code_attrs_vec.toArray(attributes);
 664         return attributes;
 665     }
 666 
 667     /**
 668      * @since 6.0
 669      */
 670     public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<span class="line-modified"> 671         final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
 672         for (final Attribute attr : attrs) {
 673             addAttribute(attr);
 674         }
<span class="line-modified"> 675     }</span>
 676 
 677     /**
 678      * @since 6.0
 679      */
<span class="line-modified"> 680     public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {</span>
<span class="line-modified"> 681         if (!hasParameterAnnotations) {</span>
<span class="line-modified"> 682             return;</span>
<span class="line-modified"> 683         }</span>
<span class="line-modified"> 684         final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, param_annotations);</span>
<span class="line-modified"> 685         if (attrs != null) {</span>
<span class="line-modified"> 686             for (final Attribute attr : attrs) {</span>
<span class="line-modified"> 687                 addAttribute(attr);</span>
<span class="line-modified"> 688             }</span>
<span class="line-modified"> 689         }</span>
<span class="line-modified"> 690     }</span>

 691 
 692     /**
<span class="line-modified"> 693      * Get method object. Never forget to call setMaxStack() or</span>
<span class="line-modified"> 694      * setMaxStack(max), respectively, before calling this method (the same</span>
<span class="line-removed"> 695      * applies for max locals).</span>
 696      *
 697      * @return method object
 698      */
 699     public Method getMethod() {
 700         final String signature = getSignature();
 701         final ConstantPoolGen _cp = super.getConstantPool();
 702         final int name_index = _cp.addUtf8(super.getName());
 703         final int signature_index = _cp.addUtf8(signature);
 704         /* Also updates positions of instructions, i.e., their indices
 705          */
 706         byte[] byte_code = null;
 707         if (il != null) {
 708             byte_code = il.getByteCode();
 709         }
 710         LineNumberTable lnt = null;
 711         LocalVariableTable lvt = null;
<span class="line-modified"> 712         LocalVariableTypeTable lvtt = null;</span>
<span class="line-removed"> 713 </span>
<span class="line-removed"> 714         /* Create LocalVariableTable, LocalvariableTypeTable, and LineNumberTable</span>
<span class="line-removed"> 715          * attributes (for debuggers, e.g.)</span>
 716          */
 717         if ((variable_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {

 718             addCodeAttribute(lvt = getLocalVariableTable(_cp));
 719         }
<span class="line-modified"> 720 </span>
<span class="line-modified"> 721         if ((type_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {</span>
<span class="line-modified"> 722             addCodeAttribute(lvtt = getLocalVariableTypeTable(_cp));</span>



 723         }
<span class="line-removed"> 724 </span>
 725         if ((line_number_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
 726             addCodeAttribute(lnt = getLineNumberTable(_cp));
 727         }
 728         final Attribute[] code_attrs = getCodeAttributes();
 729         /* Each attribute causes 6 additional header bytes
 730          */
 731         int attrs_len = 0;
 732         for (final Attribute code_attr : code_attrs) {
 733             attrs_len += code_attr.getLength() + 6;
 734         }
 735         final CodeException[] c_exc = getCodeExceptions();
 736         final int exc_len = c_exc.length * 8; // Every entry takes 8 bytes
 737         Code code = null;
 738         if ((il != null) &amp;&amp; !isAbstract() &amp;&amp; !isNative()) {
 739             // Remove any stale code attribute
 740             final Attribute[] attributes = getAttributes();
 741             for (final Attribute a : attributes) {
 742                 if (a instanceof Code) {
 743                     removeAttribute(a);
 744                 }
 745             }
 746             code = new Code(_cp.addUtf8(&quot;Code&quot;), 8 + byte_code.length + // prologue byte code
 747                     2 + exc_len + // exceptions
 748                     2 + attrs_len, // attributes
 749                     max_stack, max_locals, byte_code, c_exc, code_attrs, _cp.getConstantPool());
 750             addAttribute(code);
 751         }
 752         addAnnotationsAsAttribute(_cp);
 753         addParameterAnnotationsAsAttribute(_cp);
 754         ExceptionTable et = null;
 755         if (throws_vec.size() &gt; 0) {
 756             addAttribute(et = getExceptionTable(_cp));
 757             // Add `Exceptions&#39; if there are &quot;throws&quot; clauses
 758         }
 759         final Method m = new Method(super.getAccessFlags(), name_index, signature_index, getAttributes(), _cp
 760                 .getConstantPool());
 761         // Undo effects of adding attributes
 762         if (lvt != null) {
 763             removeCodeAttribute(lvt);
 764         }
<span class="line-modified"> 765         if (lvtt != null) {</span>
<span class="line-modified"> 766             removeCodeAttribute(lvtt);</span>
 767         }
 768         if (lnt != null) {
 769             removeCodeAttribute(lnt);
 770         }
 771         if (code != null) {
 772             removeAttribute(code);
 773         }
 774         if (et != null) {
 775             removeAttribute(et);
 776         }
 777         return m;
 778     }
 779 



































 780     /**
 781      * Remove all NOPs from the instruction list (if possible) and update every
 782      * object referring to them, i.e., branch instructions, local variables and
 783      * exception handlers.
 784      */
 785     public void removeNOPs() {
 786         if (il != null) {
 787             InstructionHandle next;
 788             /* Check branch instructions.
 789              */
 790             for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {
 791                 next = ih.getNext();
 792                 if ((next != null) &amp;&amp; (ih.getInstruction() instanceof NOP)) {
 793                     try {
 794                         il.delete(ih);
 795                     } catch (final TargetLostException e) {
 796                         for (final InstructionHandle target : e.getTargets()) {
 797                             for (final InstructionTargeter targeter : target.getTargeters()) {
 798                                 targeter.updateTarget(target, next);
 799                             }
 800                         }
 801                     }
 802                 }
 803             }
 804         }
 805     }
 806 

 807     /**
 808      * Set maximum number of local variables.
 809      */
<span class="line-modified"> 810     public void setMaxLocals(final int m) {</span>
 811         max_locals = m;
 812     }
 813 

 814     public int getMaxLocals() {
 815         return max_locals;
 816     }
 817 

 818     /**
 819      * Set maximum stack size for this method.
 820      */
<span class="line-modified"> 821     public void setMaxStack(final int m) { // TODO could be package-protected?</span>
 822         max_stack = m;
 823     }
 824 

 825     public int getMaxStack() {
 826         return max_stack;
 827     }
 828 
<span class="line-modified"> 829     /**</span>
<span class="line-modified"> 830      * @return class that contains this method</span>
 831      */
 832     public String getClassName() {
 833         return class_name;
 834     }
 835 
<span class="line-modified"> 836     public void setClassName(final String class_name) { // TODO could be package-protected?</span>

 837         this.class_name = class_name;
 838     }
 839 
<span class="line-modified"> 840     public void setReturnType(final Type return_type) {</span>

 841         setType(return_type);
 842     }
 843 

 844     public Type getReturnType() {
 845         return getType();
 846     }
 847 
<span class="line-modified"> 848     public void setArgumentTypes(final Type[] arg_types) {</span>

 849         this.arg_types = arg_types;
 850     }
 851 

 852     public Type[] getArgumentTypes() {
 853         return arg_types.clone();
 854     }
 855 
<span class="line-modified"> 856     public void setArgumentType(final int i, final Type type) {</span>

 857         arg_types[i] = type;
 858     }
 859 
<span class="line-modified"> 860     public Type getArgumentType(final int i) {</span>

 861         return arg_types[i];
 862     }
 863 
<span class="line-modified"> 864     public void setArgumentNames(final String[] arg_names) {</span>

 865         this.arg_names = arg_names;
 866     }
 867 

 868     public String[] getArgumentNames() {
 869         return arg_names.clone();
 870     }
 871 
<span class="line-modified"> 872     public void setArgumentName(final int i, final String name) {</span>

 873         arg_names[i] = name;
 874     }
 875 
<span class="line-modified"> 876     public String getArgumentName(final int i) {</span>

 877         return arg_names[i];
 878     }
 879 

 880     public InstructionList getInstructionList() {
 881         return il;
 882     }
 883 
<span class="line-modified"> 884     public void setInstructionList(final InstructionList il) { // TODO could be package-protected?</span>

 885         this.il = il;
 886     }
 887 

 888     @Override
 889     public String getSignature() {
 890         return Type.getMethodSignature(super.getType(), arg_types);
 891     }
 892 

 893     /**
 894      * Computes max. stack size by performing control flow analysis.
 895      */
 896     public void setMaxStack() { // TODO could be package-protected? (some tests would need repackaging)
 897         if (il != null) {
 898             max_stack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());
 899         } else {
 900             max_stack = 0;
 901         }
 902     }
 903 

 904     /**
 905      * Compute maximum number of local variables.
 906      */
 907     public void setMaxLocals() { // TODO could be package-protected? (some tests would need repackaging)
 908         if (il != null) {
 909             int max = isStatic() ? 0 : 1;
 910             if (arg_types != null) {
 911                 for (final Type arg_type : arg_types) {
 912                     max += arg_type.getSize();
 913                 }
 914             }
 915             for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
 916                 final Instruction ins = ih.getInstruction();
 917                 if ((ins instanceof LocalVariableInstruction) || (ins instanceof RET)
 918                         || (ins instanceof IINC)) {
 919                     final int index = ((IndexedInstruction) ins).getIndex()
 920                             + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();
 921                     if (index &gt; max) {
 922                         max = index;
 923                     }
 924                 }
 925             }
 926             max_locals = max;
 927         } else {
 928             max_locals = 0;
 929         }
 930     }
 931 
<span class="line-modified"> 932     /**</span>
<span class="line-modified"> 933      * Do not/Do produce attributes code attributesLineNumberTable and</span>
 934      * LocalVariableTable, like javac -O
 935      */
<span class="line-modified"> 936     public void stripAttributes(final boolean flag) {</span>
 937         strip_attributes = flag;
 938     }
 939 
 940     static final class BranchTarget {
 941 
 942         final InstructionHandle target;
 943         final int stackDepth;
 944 

 945         BranchTarget(final InstructionHandle target, final int stackDepth) {
 946             this.target = target;
 947             this.stackDepth = stackDepth;
 948         }
 949     }
 950 
 951     static final class BranchStack {
 952 
 953         private final Stack&lt;BranchTarget&gt; branchTargets = new Stack&lt;&gt;();
 954         private final Map&lt;InstructionHandle, BranchTarget&gt; visitedTargets = new HashMap&lt;&gt;();
 955 
<span class="line-modified"> 956         public void push(final InstructionHandle target, final int stackDepth) {</span>

 957             if (visited(target)) {
 958                 return;
 959             }
 960             branchTargets.push(visit(target, stackDepth));
 961         }
 962 

 963         public BranchTarget pop() {
 964             if (!branchTargets.empty()) {
 965                 final BranchTarget bt = branchTargets.pop();
 966                 return bt;
 967             }
 968             return null;
 969         }
 970 
<span class="line-modified"> 971         private BranchTarget visit(final InstructionHandle target, final int stackDepth) {</span>

 972             final BranchTarget bt = new BranchTarget(target, stackDepth);
 973             visitedTargets.put(target, bt);
 974             return bt;
 975         }
 976 
<span class="line-modified"> 977         private boolean visited(final InstructionHandle target) {</span>

 978             return visitedTargets.get(target) != null;
 979         }
 980     }
 981 

 982     /**
<span class="line-modified"> 983      * Computes stack usage of an instruction list by performing control flow</span>
<span class="line-removed"> 984      * analysis.</span>
 985      *
 986      * @return maximum stack depth used by method
 987      */
<span class="line-modified"> 988     public static int getMaxStack(final ConstantPoolGen cp, final InstructionList il,</span>
<span class="line-removed"> 989             final CodeExceptionGen[] et) {</span>
 990         final BranchStack branchTargets = new BranchStack();
 991         /* Initially, populate the branch stack with the exception
 992          * handlers, because these aren&#39;t (necessarily) branched to
 993          * explicitly. in each case, the stack will have depth 1,
 994          * containing the exception object.
 995          */
 996         for (final CodeExceptionGen element : et) {
 997             final InstructionHandle handler_pc = element.getHandlerPC();
 998             if (handler_pc != null) {
 999                 branchTargets.push(handler_pc, 1);
1000             }
1001         }
1002         int stackDepth = 0;
1003         int maxStackDepth = 0;
1004         InstructionHandle ih = il.getStart();
1005         while (ih != null) {
1006             final Instruction instruction = ih.getInstruction();
1007             final short opcode = instruction.getOpcode();
1008             final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);
1009             stackDepth += delta;
</pre>
<hr />
<pre>
1042                 }
1043             }
1044             // normal case, go to the next instruction.
1045             if (ih != null) {
1046                 ih = ih.getNext();
1047             }
1048             // if we have no more instructions, see if there are any deferred branches to explore.
1049             if (ih == null) {
1050                 final BranchTarget bt = branchTargets.pop();
1051                 if (bt != null) {
1052                     ih = bt.target;
1053                     stackDepth = bt.stackDepth;
1054                 }
1055             }
1056         }
1057         return maxStackDepth;
1058     }
1059 
1060     private List&lt;MethodObserver&gt; observers;
1061 
<span class="line-modified">1062     /**</span>
<span class="line-modified">1063      * Add observer for this object.</span>
1064      */
<span class="line-modified">1065     public void addObserver(final MethodObserver o) {</span>
1066         if (observers == null) {
1067             observers = new ArrayList&lt;&gt;();
1068         }
1069         observers.add(o);
1070     }
1071 
<span class="line-modified">1072     /**</span>
<span class="line-modified">1073      * Remove observer for this object.</span>
1074      */
<span class="line-modified">1075     public void removeObserver(final MethodObserver o) {</span>
1076         if (observers != null) {
1077             observers.remove(o);
1078         }
1079     }
1080 
<span class="line-modified">1081     /**</span>
<span class="line-modified">1082      * Call notify() method on all observers. This method is not called</span>
<span class="line-modified">1083      * automatically whenever the state has changed, but has to be called by the</span>
<span class="line-modified">1084      * user after he has finished editing the object.</span>
1085      */
1086     public void update() {
1087         if (observers != null) {
1088             for (final MethodObserver observer : observers) {
1089                 observer.notify(this);
1090             }
1091         }
1092     }
1093 

1094     /**
<span class="line-modified">1095      * Return string representation close to declaration format, e.g. public</span>
<span class="line-modified">1096      * static void main(String[]) throws IOException&#39;</span>
1097      *
1098      * @return String representation of the method.
1099      */
1100     @Override
1101     public final String toString() {
1102         final String access = Utility.accessToString(super.getAccessFlags());
1103         String signature = Type.getMethodSignature(super.getType(), arg_types);
1104         signature = Utility.methodSignatureToString(signature, super.getName(), access, true,
1105                 getLocalVariableTable(super.getConstantPool()));
1106         final StringBuilder buf = new StringBuilder(signature);
1107         for (final Attribute a : getAttributes()) {
1108             if (!((a instanceof Code) || (a instanceof ExceptionTable))) {
1109                 buf.append(&quot; [&quot;).append(a).append(&quot;]&quot;);
1110             }
1111         }
1112 
1113         if (throws_vec.size() &gt; 0) {
1114             for (final String throwsDescriptor : throws_vec) {
1115                 buf.append(&quot;\n\t\tthrows &quot;).append(throwsDescriptor);
1116             }
1117         }
1118         return buf.toString();
1119     }
1120 
<span class="line-modified">1121     /**</span>
<span class="line-modified">1122      * @return deep copy of this method</span>
1123      */
<span class="line-modified">1124     public MethodGen copy(final String class_name, final ConstantPoolGen cp) {</span>
1125         final Method m = ((MethodGen) clone()).getMethod();
1126         final MethodGen mg = new MethodGen(m, class_name, super.getConstantPool());
1127         if (super.getConstantPool() != cp) {
1128             mg.setConstantPool(cp);
1129             mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);
1130         }
1131         return mg;
1132     }
1133 
1134     //J5TODO: Should param_annotations be an array of arrays? Rather than an array of lists, this
1135     // is more likely to suggest to the caller it is readonly (which a List does not).
1136     /**
1137      * Return a list of AnnotationGen objects representing parameter annotations
<span class="line-removed">1138      *</span>
1139      * @since 6.0
1140      */
1141     public List&lt;AnnotationEntryGen&gt; getAnnotationsOnParameter(final int i) {
1142         ensureExistingParameterAnnotationsUnpacked();
1143         if (!hasParameterAnnotations || i &gt; arg_types.length) {
1144             return null;
1145         }
1146         return param_annotations[i];
1147     }
1148 
1149     /**
1150      * Goes through the attributes on the method and identifies any that are
1151      * RuntimeParameterAnnotations, extracting their contents and storing them
1152      * as parameter annotations. There are two kinds of parameter annotation -
1153      * visible and invisible. Once they have been unpacked, these attributes are
1154      * deleted. (The annotations will be rebuilt as attributes when someone
1155      * builds a Method object out of this MethodGen object).
1156      */
<span class="line-modified">1157     private void ensureExistingParameterAnnotationsUnpacked() {</span>

1158         if (haveUnpackedParameterAnnotations) {
1159             return;
1160         }
1161         // Find attributes that contain parameter annotation data
1162         final Attribute[] attrs = getAttributes();
1163         ParameterAnnotations paramAnnVisAttr = null;
1164         ParameterAnnotations paramAnnInvisAttr = null;
1165         for (final Attribute attribute : attrs) {
<span class="line-modified">1166             if (attribute instanceof ParameterAnnotations) {</span>

1167                 // Initialize param_annotations
<span class="line-modified">1168                 if (!hasParameterAnnotations) {</span>

1169                     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1170                     final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
1171                     param_annotations = parmList;
1172                     for (int j = 0; j &lt; arg_types.length; j++) {
1173                         param_annotations[j] = new ArrayList&lt;&gt;();
1174                     }
1175                 }
1176                 hasParameterAnnotations = true;
1177                 final ParameterAnnotations rpa = (ParameterAnnotations) attribute;
1178                 if (rpa instanceof RuntimeVisibleParameterAnnotations) {
1179                     paramAnnVisAttr = rpa;
1180                 } else {
1181                     paramAnnInvisAttr = rpa;
1182                 }
<span class="line-modified">1183                 for (int j = 0; j &lt; arg_types.length; j++) {</span>


1184                     // This returns Annotation[] ...
<span class="line-modified">1185                     final ParameterAnnotationEntry immutableArray = rpa</span>
<span class="line-removed">1186                             .getParameterAnnotationEntries()[j];</span>
1187                     // ... which needs transforming into an AnnotationGen[] ...
<span class="line-modified">1188                     final List&lt;AnnotationEntryGen&gt; mutable</span>
<span class="line-removed">1189                             = makeMutableVersion(immutableArray.getAnnotationEntries());</span>
1190                     // ... then add these to any we already know about
1191                     param_annotations[j].addAll(mutable);
1192                 }
1193             }
1194         }
1195         if (paramAnnVisAttr != null) {
1196             removeAttribute(paramAnnVisAttr);
1197         }
1198         if (paramAnnInvisAttr != null) {
1199             removeAttribute(paramAnnInvisAttr);
1200         }
1201         haveUnpackedParameterAnnotations = true;
1202     }
1203 
<span class="line-modified">1204     private List&lt;AnnotationEntryGen&gt; makeMutableVersion(final AnnotationEntry[] mutableArray) {</span>

1205         final List&lt;AnnotationEntryGen&gt; result = new ArrayList&lt;&gt;();
1206         for (final AnnotationEntry element : mutableArray) {
1207             result.add(new AnnotationEntryGen(element, getConstantPool(),
1208                     false));
1209         }
1210         return result;
1211     }
1212 
1213     public void addParameterAnnotation(final int parameterIndex,
<span class="line-modified">1214             final AnnotationEntryGen annotation) {</span>

1215         ensureExistingParameterAnnotationsUnpacked();
<span class="line-modified">1216         if (!hasParameterAnnotations) {</span>

1217             @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1218             final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
1219             param_annotations = parmList;
1220             hasParameterAnnotations = true;
1221         }
1222         final List&lt;AnnotationEntryGen&gt; existingAnnotations = param_annotations[parameterIndex];
<span class="line-modified">1223         if (existingAnnotations != null) {</span>

1224             existingAnnotations.add(annotation);
<span class="line-modified">1225         } else {</span>


1226             final List&lt;AnnotationEntryGen&gt; l = new ArrayList&lt;&gt;();
1227             l.add(annotation);
1228             param_annotations[parameterIndex] = l;
1229         }
1230     }
1231 
1232     /**
1233      * @return Comparison strategy object
1234      */
1235     public static BCELComparator getComparator() {
1236         return bcelComparator;
1237     }
1238 

1239     /**
1240      * @param comparator Comparison strategy object
1241      */
<span class="line-modified">1242     public static void setComparator(final BCELComparator comparator) {</span>
1243         bcelComparator = comparator;
1244     }
1245 

1246     /**
<span class="line-modified">1247      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">1248      * MethodGen objects are said to be equal when their names and signatures</span>
<span class="line-modified">1249      * are equal.</span>
1250      *
1251      * @see java.lang.Object#equals(java.lang.Object)
1252      */
1253     @Override
<span class="line-modified">1254     public boolean equals(final Object obj) {</span>
1255         return bcelComparator.equals(this, obj);
1256     }
1257 

1258     /**
<span class="line-modified">1259      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">1260      * return the hashcode of the method&#39;s name XOR signature.</span>
1261      *
1262      * @see java.lang.Object#hashCode()
1263      */
1264     @Override
1265     public int hashCode() {
1266         return bcelComparator.hashCode(this);
1267     }
1268 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 package com.sun.org.apache.bcel.internal.generic;
  21 
  22 import com.sun.org.apache.bcel.internal.Const;
  23 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
  24 import com.sun.org.apache.bcel.internal.classfile.Annotations;
  25 import com.sun.org.apache.bcel.internal.classfile.Attribute;
  26 import com.sun.org.apache.bcel.internal.classfile.Code;
  27 import com.sun.org.apache.bcel.internal.classfile.CodeException;
  28 import com.sun.org.apache.bcel.internal.classfile.ExceptionTable;
  29 import com.sun.org.apache.bcel.internal.classfile.LineNumber;
  30 import com.sun.org.apache.bcel.internal.classfile.LineNumberTable;
  31 import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
  32 import com.sun.org.apache.bcel.internal.classfile.LocalVariableTable;
  33 import com.sun.org.apache.bcel.internal.classfile.LocalVariableTypeTable;
  34 import com.sun.org.apache.bcel.internal.classfile.Method;
  35 import com.sun.org.apache.bcel.internal.classfile.ParameterAnnotationEntry;
  36 import com.sun.org.apache.bcel.internal.classfile.ParameterAnnotations;
  37 import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleParameterAnnotations;
  38 import com.sun.org.apache.bcel.internal.classfile.Utility;
  39 import com.sun.org.apache.bcel.internal.util.BCELComparator;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;

  42 import java.util.HashMap;
  43 import java.util.List;
  44 import java.util.Map;
<span class="line-added">  45 import java.util.Objects;</span>
  46 import java.util.Stack;
  47 
  48 /**
  49  * Template class for building up a method. This is done by defining exception
  50  * handlers, adding thrown exceptions, local variables and attributes, whereas
  51  * the `LocalVariableTable&#39; and `LineNumberTable&#39; attributes will be set
  52  * automatically for the code. Use stripAttributes() if you don&#39;t like this.
  53  *
  54  * While generating code it may be necessary to insert NOP operations. You can
<span class="line-modified">  55  * use the `removeNOPs&#39; method to get rid off them.</span>
<span class="line-modified">  56  * The resulting method object can be obtained via the `getMethod()&#39; method.</span>
  57  *
<span class="line-modified">  58  * @see     InstructionList</span>
<span class="line-modified">  59  * @see     Method</span>
<span class="line-modified">  60  * @LastModified: Jan 2020</span>

  61  */
  62 public class MethodGen extends FieldGenOrMethodGen {
  63 
  64     private String class_name;
  65     private Type[] arg_types;
  66     private String[] arg_names;
  67     private int max_locals;
  68     private int max_stack;
  69     private InstructionList il;
  70     private boolean strip_attributes;
<span class="line-added">  71     private LocalVariableTypeTable local_variable_type_table = null;</span>
  72     private final List&lt;LocalVariableGen&gt; variable_vec = new ArrayList&lt;&gt;();

  73     private final List&lt;LineNumberGen&gt; line_number_vec = new ArrayList&lt;&gt;();
  74     private final List&lt;CodeExceptionGen&gt; exception_vec = new ArrayList&lt;&gt;();
  75     private final List&lt;String&gt; throws_vec = new ArrayList&lt;&gt;();
  76     private final List&lt;Attribute&gt; code_attrs_vec = new ArrayList&lt;&gt;();
  77 
  78     private List&lt;AnnotationEntryGen&gt;[] param_annotations; // Array of lists containing AnnotationGen objects
  79     private boolean hasParameterAnnotations = false;
  80     private boolean haveUnpackedParameterAnnotations = false;
  81 
  82     private static BCELComparator bcelComparator = new BCELComparator() {
  83 
  84         @Override
<span class="line-modified">  85         public boolean equals( final Object o1, final Object o2 ) {</span>
  86             final MethodGen THIS = (MethodGen) o1;
  87             final MethodGen THAT = (MethodGen) o2;
<span class="line-modified">  88             return Objects.equals(THIS.getName(), THAT.getName())</span>
<span class="line-modified">  89                     &amp;&amp; Objects.equals(THIS.getSignature(), THAT.getSignature());</span>
  90         }
  91 
<span class="line-added">  92 </span>
  93         @Override
<span class="line-modified">  94         public int hashCode( final Object o ) {</span>
  95             final MethodGen THIS = (MethodGen) o;
  96             return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
  97         }
  98     };
  99 
<span class="line-added"> 100 </span>
 101     /**
<span class="line-modified"> 102      * Declare method. If the method is non-static the constructor</span>
<span class="line-modified"> 103      * automatically declares a local variable `$this&#39; in slot 0. The</span>
<span class="line-modified"> 104      * actual code is contained in the `il&#39; parameter, which may further</span>
<span class="line-modified"> 105      * manipulated by the user. But he must take care not to remove any</span>
<span class="line-modified"> 106      * instruction (handles) that are still referenced from this object.</span>
 107      *
 108      * For example one may not add a local variable and later remove the
<span class="line-modified"> 109      * instructions it refers to without causing havoc. It is safe</span>
<span class="line-modified"> 110      * however if you remove that local variable, too.</span>
 111      *
 112      * @param access_flags access qualifiers
<span class="line-modified"> 113      * @param return_type  method type</span>
 114      * @param arg_types argument types
<span class="line-modified"> 115      * @param arg_names argument names (if this is null, default names will be provided</span>
<span class="line-modified"> 116      * for them)</span>
 117      * @param method_name name of method
<span class="line-modified"> 118      * @param class_name class name containing this method (may be null, if you don&#39;t care)</span>
<span class="line-modified"> 119      * @param il instruction list associated with this method, may be null only for</span>
<span class="line-modified"> 120      * abstract or native methods</span>

 121      * @param cp constant pool
 122      */
 123     public MethodGen(final int access_flags, final Type return_type, final Type[] arg_types, String[] arg_names,
 124             final String method_name, final String class_name, final InstructionList il, final ConstantPoolGen cp) {
 125         super(access_flags);
 126         setType(return_type);
 127         setArgumentTypes(arg_types);
 128         setArgumentNames(arg_names);
 129         setName(method_name);
 130         setClassName(class_name);
 131         setInstructionList(il);
 132         setConstantPool(cp);
 133         final boolean abstract_ = isAbstract() || isNative();
 134         InstructionHandle start = null;
<span class="line-modified"> 135         final InstructionHandle end = null;</span>
 136         if (!abstract_) {
 137             start = il.getStart();
<span class="line-modified"> 138             // end == null =&gt; live to end of method</span>
 139             /* Add local variables, namely the implicit `this&#39; and the arguments
 140              */
 141             if (!isStatic() &amp;&amp; (class_name != null)) { // Instance method -&gt; `this&#39; is local var 0
<span class="line-modified"> 142                 addLocalVariable(&quot;this&quot;,  ObjectType.getInstance(class_name), start, end);</span>
 143             }
 144         }
 145         if (arg_types != null) {
 146             final int size = arg_types.length;
 147             for (final Type arg_type : arg_types) {
 148                 if (Type.VOID == arg_type) {
 149                     throw new ClassGenException(&quot;&#39;void&#39; is an illegal argument type for a method&quot;);
 150                 }
 151             }
 152             if (arg_names != null) { // Names for variables provided?
 153                 if (size != arg_names.length) {
 154                     throw new ClassGenException(&quot;Mismatch in argument array lengths: &quot; + size
 155                             + &quot; vs. &quot; + arg_names.length);
 156                 }
 157             } else { // Give them dummy names
 158                 arg_names = new String[size];
 159                 for (int i = 0; i &lt; size; i++) {
 160                     arg_names[i] = &quot;arg&quot; + i;
 161                 }
 162                 setArgumentNames(arg_names);
 163             }
 164             if (!abstract_) {
 165                 for (int i = 0; i &lt; size; i++) {
 166                     addLocalVariable(arg_names[i], arg_types[i], start, end);
 167                 }
 168             }
 169         }
 170     }
 171 
<span class="line-added"> 172 </span>
 173     /**
 174      * Instantiate from existing method.
 175      *
 176      * @param m method
 177      * @param class_name class name containing this method
 178      * @param cp constant pool
 179      */
 180     public MethodGen(final Method m, final String class_name, final ConstantPoolGen cp) {
 181         this(m.getAccessFlags(), Type.getReturnType(m.getSignature()), Type.getArgumentTypes(m
<span class="line-modified"> 182                 .getSignature()), null /* may be overridden anyway */</span>
<span class="line-added"> 183         , m.getName(), class_name,</span>
 184                 ((m.getAccessFlags() &amp; (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0)
<span class="line-modified"> 185                         ? new InstructionList(m.getCode().getCode())</span>
<span class="line-modified"> 186                         : null, cp);</span>
 187         final Attribute[] attributes = m.getAttributes();
 188         for (final Attribute attribute : attributes) {
 189             Attribute a = attribute;
 190             if (a instanceof Code) {
 191                 final Code c = (Code) a;
 192                 setMaxStack(c.getMaxStack());
 193                 setMaxLocals(c.getMaxLocals());
 194                 final CodeException[] ces = c.getExceptionTable();
 195                 if (ces != null) {
 196                     for (final CodeException ce : ces) {
 197                         final int type = ce.getCatchType();
 198                         ObjectType c_type = null;
 199                         if (type &gt; 0) {
 200                             final String cen = m.getConstantPool().getConstantString(type,
 201                                     Const.CONSTANT_Class);
<span class="line-modified"> 202                             c_type =  ObjectType.getInstance(cen);</span>
 203                         }
 204                         final int end_pc = ce.getEndPC();
 205                         final int length = m.getCode().getCode().length;
 206                         InstructionHandle end;
 207                         if (length == end_pc) { // May happen, because end_pc is exclusive
 208                             end = il.getEnd();
 209                         } else {
 210                             end = il.findHandle(end_pc);
 211                             end = end.getPrev(); // Make it inclusive
 212                         }
 213                         addExceptionHandler(il.findHandle(ce.getStartPC()), end, il.findHandle(ce
 214                                 .getHandlerPC()), c_type);
 215                     }
 216                 }
 217                 final Attribute[] c_attributes = c.getAttributes();
 218                 for (final Attribute c_attribute : c_attributes) {
 219                     a = c_attribute;
 220                     if (a instanceof LineNumberTable) {
 221                         final LineNumber[] ln = ((LineNumberTable) a).getLineNumberTable();
 222                         for (final LineNumber l : ln) {
 223                             final InstructionHandle ih = il.findHandle(l.getStartPC());
 224                             if (ih != null) {
 225                                 addLineNumber(ih, l.getLineNumber());
 226                             }
 227                         }
 228                     } else if (a instanceof LocalVariableTable) {
<span class="line-modified"> 229                         updateLocalVariableTable((LocalVariableTable) a);</span>


 230                     } else if (a instanceof LocalVariableTypeTable) {
<span class="line-modified"> 231                         this.local_variable_type_table = (LocalVariableTypeTable) a.copy(cp.getConstantPool());</span>


 232                     } else {
 233                         addCodeAttribute(a);
 234                     }
 235                 }
 236             } else if (a instanceof ExceptionTable) {
 237                 final String[] names = ((ExceptionTable) a).getExceptionNames();
 238                 for (final String name2 : names) {
 239                     addException(name2);
 240                 }
 241             } else if (a instanceof Annotations) {
 242                 final Annotations runtimeAnnotations = (Annotations) a;
 243                 final AnnotationEntry[] aes = runtimeAnnotations.getAnnotationEntries();
 244                 for (final AnnotationEntry element : aes) {
 245                     addAnnotationEntry(new AnnotationEntryGen(element, cp, false));
 246                 }
 247             } else {
 248                 addAttribute(a);
 249             }
 250         }
 251     }
 252 






















 253     /**
 254      * Adds a local variable to this method.
 255      *
 256      * @param name variable name
 257      * @param type variable type
<span class="line-modified"> 258      * @param slot the index of the local variable, if type is long or double, the next available</span>
<span class="line-modified"> 259      * index is slot+2</span>
 260      * @param start from where the variable is valid
 261      * @param end until where the variable is valid
<span class="line-added"> 262      * @param orig_index the index of the local variable prior to any modifications</span>
 263      * @return new local variable object
 264      * @see LocalVariable
 265      */
<span class="line-modified"> 266     public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,</span>
<span class="line-modified"> 267             final InstructionHandle start, final InstructionHandle end, final int orig_index ) {</span>

 268         final byte t = type.getType();
 269         if (t != Const.T_ADDRESS) {
 270             final int add = type.getSize();
 271             if (slot + add &gt; max_locals) {
 272                 max_locals = slot + add;
 273             }
<span class="line-modified"> 274             final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, orig_index);</span>
 275             int i;
 276             if ((i = variable_vec.indexOf(l)) &gt;= 0) {
 277                 variable_vec.set(i, l);
 278             } else {
 279                 variable_vec.add(l);
 280             }
 281             return l;
 282         }
 283         throw new IllegalArgumentException(&quot;Can not use &quot; + type
 284                 + &quot; as type for local variable&quot;);
 285     }
 286 
<span class="line-added"> 287 </span>
<span class="line-added"> 288     /**</span>
<span class="line-added"> 289      * Adds a local variable to this method.</span>
<span class="line-added"> 290      *</span>
<span class="line-added"> 291      * @param name variable name</span>
<span class="line-added"> 292      * @param type variable type</span>
<span class="line-added"> 293      * @param slot the index of the local variable, if type is long or double, the next available</span>
<span class="line-added"> 294      * index is slot+2</span>
<span class="line-added"> 295      * @param start from where the variable is valid</span>
<span class="line-added"> 296      * @param end until where the variable is valid</span>
<span class="line-added"> 297      * @return new local variable object</span>
<span class="line-added"> 298      * @see LocalVariable</span>
<span class="line-added"> 299      */</span>
<span class="line-added"> 300     public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,</span>
<span class="line-added"> 301             final InstructionHandle start, final InstructionHandle end ) {</span>
<span class="line-added"> 302         return addLocalVariable(name, type, slot, start, end, slot);</span>
<span class="line-added"> 303     }</span>
<span class="line-added"> 304 </span>
 305     /**
 306      * Adds a local variable to this method and assigns an index automatically.
 307      *
 308      * @param name variable name
 309      * @param type variable type
<span class="line-modified"> 310      * @param start from where the variable is valid, if this is null,</span>
<span class="line-modified"> 311      * it is valid from the start</span>
<span class="line-modified"> 312      * @param end until where the variable is valid, if this is null,</span>
<span class="line-modified"> 313      * it is valid to the end</span>
 314      * @return new local variable object
 315      * @see LocalVariable
 316      */
<span class="line-modified"> 317     public LocalVariableGen addLocalVariable( final String name, final Type type, final InstructionHandle start,</span>
<span class="line-modified"> 318             final InstructionHandle end ) {</span>
 319         return addLocalVariable(name, type, max_locals, start, end);
 320     }
 321 
<span class="line-added"> 322 </span>
 323     /**
 324      * Remove a local variable, its slot will not be reused, if you do not use
 325      * addLocalVariable with an explicit index argument.
 326      */
 327     public void removeLocalVariable(final LocalVariableGen l) {
 328         variable_vec.remove(l);
 329     }
 330 
<span class="line-added"> 331 </span>
 332     /**
 333      * Remove all local variables.
 334      */
 335     public void removeLocalVariables() {
 336         variable_vec.clear();
 337     }
 338 
<span class="line-added"> 339 </span>
 340     /*
 341      * If the range of the variable has not been set yet, it will be set to be valid from
 342      * the start to the end of the instruction list.
 343      *
 344      * @return array of declared local variables sorted by index
 345      */
 346     public LocalVariableGen[] getLocalVariables() {
<span class="line-modified"> 347         final int size = variable_vec.size();</span>
<span class="line-modified"> 348         final LocalVariableGen[] lg = new LocalVariableGen[size];</span>
<span class="line-modified"> 349         variable_vec.toArray(lg);</span>

























 350         for (int i = 0; i &lt; size; i++) {
<span class="line-modified"> 351             if ((lg[i].getStart() == null) &amp;&amp; (il != null)) {</span>
 352                 lg[i].setStart(il.getStart());
 353             }
<span class="line-modified"> 354             if ((lg[i].getEnd() == null) &amp;&amp; (il != null)) {</span>

 355                 lg[i].setEnd(il.getEnd());
 356             }
 357         }

 358         if (size &gt; 1) {
<span class="line-modified"> 359             Arrays.sort(lg, (o1, o2) -&gt; o1.getIndex() - o2.getIndex());</span>





 360         }

 361         return lg;
 362     }
 363 
<span class="line-added"> 364 </span>
 365     /**
<span class="line-modified"> 366      * @return `LocalVariableTable&#39; attribute of all the local variables of this method.</span>

 367      */
<span class="line-modified"> 368     public LocalVariableTable getLocalVariableTable( final ConstantPoolGen cp ) {</span>
 369         final LocalVariableGen[] lg = getLocalVariables();
 370         final int size = lg.length;
 371         final LocalVariable[] lv = new LocalVariable[size];
 372         for (int i = 0; i &lt; size; i++) {
 373             lv[i] = lg[i].getLocalVariable(cp);
 374         }
 375         return new LocalVariableTable(cp.addUtf8(&quot;LocalVariableTable&quot;), 2 + lv.length * 10, lv, cp
 376                 .getConstantPool());
 377     }
 378 
 379     /**
<span class="line-modified"> 380      * @return `LocalVariableTypeTable&#39; attribute of this method.</span>

 381      */
<span class="line-modified"> 382     public LocalVariableTypeTable getLocalVariableTypeTable() {</span>
<span class="line-modified"> 383         return local_variable_type_table;</span>

























































 384     }
 385 
 386     /**
 387      * Give an instruction a line number corresponding to the source code line.
 388      *
 389      * @param ih instruction to tag
 390      * @return new line number object
 391      * @see LineNumber
 392      */
<span class="line-modified"> 393     public LineNumberGen addLineNumber( final InstructionHandle ih, final int src_line ) {</span>
 394         final LineNumberGen l = new LineNumberGen(ih, src_line);
 395         line_number_vec.add(l);
 396         return l;
 397     }
 398 
<span class="line-added"> 399 </span>
 400     /**
 401      * Remove a line number.
 402      */
<span class="line-modified"> 403     public void removeLineNumber( final LineNumberGen l ) {</span>
 404         line_number_vec.remove(l);
 405     }
 406 
<span class="line-added"> 407 </span>
 408     /**
 409      * Remove all line numbers.
 410      */
 411     public void removeLineNumbers() {
 412         line_number_vec.clear();
 413     }
 414 
<span class="line-added"> 415 </span>
 416     /*
 417      * @return array of line numbers
 418      */
 419     public LineNumberGen[] getLineNumbers() {
 420         final LineNumberGen[] lg = new LineNumberGen[line_number_vec.size()];
 421         line_number_vec.toArray(lg);
 422         return lg;
 423     }
 424 
<span class="line-added"> 425 </span>
 426     /**
<span class="line-modified"> 427      * @return `LineNumberTable&#39; attribute of all the local variables of this method.</span>

 428      */
<span class="line-modified"> 429     public LineNumberTable getLineNumberTable( final ConstantPoolGen cp ) {</span>
 430         final int size = line_number_vec.size();
 431         final LineNumber[] ln = new LineNumber[size];
 432         for (int i = 0; i &lt; size; i++) {
 433             ln[i] = line_number_vec.get(i).getLineNumber();
 434         }
 435         return new LineNumberTable(cp.addUtf8(&quot;LineNumberTable&quot;), 2 + ln.length * 4, ln, cp
 436                 .getConstantPool());
 437     }
 438 
<span class="line-added"> 439 </span>
 440     /**
<span class="line-modified"> 441      * Add an exception handler, i.e., specify region where a handler is active and an</span>
<span class="line-modified"> 442      * instruction where the actual handling is done.</span>
 443      *
 444      * @param start_pc Start of region (inclusive)
 445      * @param end_pc End of region (inclusive)
 446      * @param handler_pc Where handling is done
 447      * @param catch_type class type of handled exception or null if any
 448      * exception is handled
 449      * @return new exception handler object
 450      */
<span class="line-modified"> 451     public CodeExceptionGen addExceptionHandler( final InstructionHandle start_pc,</span>
<span class="line-modified"> 452             final InstructionHandle end_pc, final InstructionHandle handler_pc, final ObjectType catch_type ) {</span>
 453         if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {
 454             throw new ClassGenException(&quot;Exception handler target is null instruction&quot;);
 455         }
 456         final CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);
 457         exception_vec.add(c);
 458         return c;
 459     }
 460 
<span class="line-added"> 461 </span>
 462     /**
 463      * Remove an exception handler.
 464      */
<span class="line-modified"> 465     public void removeExceptionHandler( final CodeExceptionGen c ) {</span>
 466         exception_vec.remove(c);
 467     }
 468 
<span class="line-added"> 469 </span>
 470     /**
 471      * Remove all line numbers.
 472      */
 473     public void removeExceptionHandlers() {
 474         exception_vec.clear();
 475     }
 476 
<span class="line-added"> 477 </span>
 478     /*
 479      * @return array of declared exception handlers
 480      */
 481     public CodeExceptionGen[] getExceptionHandlers() {
 482         final CodeExceptionGen[] cg = new CodeExceptionGen[exception_vec.size()];
 483         exception_vec.toArray(cg);
 484         return cg;
 485     }
 486 
<span class="line-added"> 487 </span>
 488     /**
 489      * @return code exceptions for `Code&#39; attribute
 490      */
 491     private CodeException[] getCodeExceptions() {
 492         final int size = exception_vec.size();
 493         final CodeException[] c_exc = new CodeException[size];
 494         for (int i = 0; i &lt; size; i++) {
<span class="line-modified"> 495             final CodeExceptionGen c =  exception_vec.get(i);</span>
 496             c_exc[i] = c.getCodeException(super.getConstantPool());
 497         }
 498         return c_exc;
 499     }
 500 
<span class="line-added"> 501 </span>
 502     /**
 503      * Add an exception possibly thrown by this method.
 504      *
 505      * @param class_name (fully qualified) name of exception
 506      */
<span class="line-modified"> 507     public void addException( final String class_name ) {</span>
 508         throws_vec.add(class_name);
 509     }
 510 
<span class="line-added"> 511 </span>
 512     /**
 513      * Remove an exception.
 514      */
<span class="line-modified"> 515     public void removeException( final String c ) {</span>
 516         throws_vec.remove(c);
 517     }
 518 
<span class="line-added"> 519 </span>
 520     /**
 521      * Remove all exceptions.
 522      */
 523     public void removeExceptions() {
 524         throws_vec.clear();
 525     }
 526 
<span class="line-added"> 527 </span>
 528     /*
 529      * @return array of thrown exceptions
 530      */
 531     public String[] getExceptions() {
 532         final String[] e = new String[throws_vec.size()];
 533         throws_vec.toArray(e);
 534         return e;
 535     }
 536 
<span class="line-added"> 537 </span>
 538     /**
<span class="line-modified"> 539      * @return `Exceptions&#39; attribute of all the exceptions thrown by this method.</span>

 540      */
<span class="line-modified"> 541     private ExceptionTable getExceptionTable( final ConstantPoolGen cp ) {</span>
 542         final int size = throws_vec.size();
 543         final int[] ex = new int[size];
 544         for (int i = 0; i &lt; size; i++) {
 545             ex[i] = cp.addClass(throws_vec.get(i));
 546         }
 547         return new ExceptionTable(cp.addUtf8(&quot;Exceptions&quot;), 2 + 2 * size, ex, cp.getConstantPool());
 548     }
 549 
<span class="line-added"> 550 </span>
 551     /**
 552      * Add an attribute to the code. Currently, the JVM knows about the
<span class="line-modified"> 553      * LineNumberTable, LocalVariableTable and StackMap attributes,</span>
<span class="line-modified"> 554      * where the former two will be generated automatically and the</span>
<span class="line-modified"> 555      * latter is used for the MIDP only. Other attributes will be</span>
<span class="line-added"> 556      * ignored by the JVM but do no harm.</span>
 557      *
 558      * @param a attribute to be added
 559      */
<span class="line-modified"> 560     public void addCodeAttribute( final Attribute a ) {</span>
 561         code_attrs_vec.add(a);
 562     }
 563 
<span class="line-added"> 564 </span>
<span class="line-added"> 565     /**</span>
<span class="line-added"> 566      * Remove the LocalVariableTypeTable</span>
<span class="line-added"> 567      */</span>
<span class="line-added"> 568     public void removeLocalVariableTypeTable( ) {</span>
<span class="line-added"> 569         local_variable_type_table = null;</span>
<span class="line-added"> 570     }</span>
<span class="line-added"> 571 </span>
 572     /**
 573      * Remove a code attribute.
 574      */
<span class="line-modified"> 575     public void removeCodeAttribute( final Attribute a ) {</span>
 576         code_attrs_vec.remove(a);
 577     }
 578 
<span class="line-added"> 579 </span>
 580     /**
 581      * Remove all code attributes.
 582      */
 583     public void removeCodeAttributes() {
<span class="line-added"> 584         local_variable_type_table = null;</span>
 585         code_attrs_vec.clear();
 586     }
 587 
<span class="line-added"> 588 </span>
 589     /**
 590      * @return all attributes of this method.
 591      */
 592     public Attribute[] getCodeAttributes() {
 593         final Attribute[] attributes = new Attribute[code_attrs_vec.size()];
 594         code_attrs_vec.toArray(attributes);
 595         return attributes;
 596     }
 597 
 598     /**
 599      * @since 6.0
 600      */
 601     public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<span class="line-modified"> 602           final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
 603         for (final Attribute attr : attrs) {
 604             addAttribute(attr);
 605         }
<span class="line-modified"> 606       }</span>
 607 
 608     /**
 609      * @since 6.0
 610      */
<span class="line-modified"> 611       public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {</span>
<span class="line-modified"> 612           if (!hasParameterAnnotations) {</span>
<span class="line-modified"> 613               return;</span>
<span class="line-modified"> 614           }</span>
<span class="line-modified"> 615           final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp,param_annotations);</span>
<span class="line-modified"> 616           if (attrs != null) {</span>
<span class="line-modified"> 617               for (final Attribute attr : attrs) {</span>
<span class="line-modified"> 618                   addAttribute(attr);</span>
<span class="line-modified"> 619               }</span>
<span class="line-modified"> 620           }</span>
<span class="line-modified"> 621       }</span>
<span class="line-added"> 622 </span>
 623 
 624     /**
<span class="line-modified"> 625      * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively,</span>
<span class="line-modified"> 626      * before calling this method (the same applies for max locals).</span>

 627      *
 628      * @return method object
 629      */
 630     public Method getMethod() {
 631         final String signature = getSignature();
 632         final ConstantPoolGen _cp = super.getConstantPool();
 633         final int name_index = _cp.addUtf8(super.getName());
 634         final int signature_index = _cp.addUtf8(signature);
 635         /* Also updates positions of instructions, i.e., their indices
 636          */
 637         byte[] byte_code = null;
 638         if (il != null) {
 639             byte_code = il.getByteCode();
 640         }
 641         LineNumberTable lnt = null;
 642         LocalVariableTable lvt = null;
<span class="line-modified"> 643         /* Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)</span>



 644          */
 645         if ((variable_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
<span class="line-added"> 646             updateLocalVariableTable(getLocalVariableTable(_cp));</span>
 647             addCodeAttribute(lvt = getLocalVariableTable(_cp));
 648         }
<span class="line-modified"> 649         if (local_variable_type_table != null) {</span>
<span class="line-modified"> 650             // LocalVariable length in LocalVariableTypeTable is not updated automatically. It&#39;s a difference with LocalVariableTable.</span>
<span class="line-modified"> 651             if (lvt != null) {</span>
<span class="line-added"> 652                 adjustLocalVariableTypeTable(lvt);</span>
<span class="line-added"> 653             }</span>
<span class="line-added"> 654             addCodeAttribute(local_variable_type_table);</span>
 655         }

 656         if ((line_number_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
 657             addCodeAttribute(lnt = getLineNumberTable(_cp));
 658         }
 659         final Attribute[] code_attrs = getCodeAttributes();
 660         /* Each attribute causes 6 additional header bytes
 661          */
 662         int attrs_len = 0;
 663         for (final Attribute code_attr : code_attrs) {
 664             attrs_len += code_attr.getLength() + 6;
 665         }
 666         final CodeException[] c_exc = getCodeExceptions();
 667         final int exc_len = c_exc.length * 8; // Every entry takes 8 bytes
 668         Code code = null;
 669         if ((il != null) &amp;&amp; !isAbstract() &amp;&amp; !isNative()) {
 670             // Remove any stale code attribute
 671             final Attribute[] attributes = getAttributes();
 672             for (final Attribute a : attributes) {
 673                 if (a instanceof Code) {
 674                     removeAttribute(a);
 675                 }
 676             }
 677             code = new Code(_cp.addUtf8(&quot;Code&quot;), 8 + byte_code.length + // prologue byte code
 678                     2 + exc_len + // exceptions
 679                     2 + attrs_len, // attributes
 680                     max_stack, max_locals, byte_code, c_exc, code_attrs, _cp.getConstantPool());
 681             addAttribute(code);
 682         }
 683         addAnnotationsAsAttribute(_cp);
 684         addParameterAnnotationsAsAttribute(_cp);
 685         ExceptionTable et = null;
 686         if (throws_vec.size() &gt; 0) {
 687             addAttribute(et = getExceptionTable(_cp));
 688             // Add `Exceptions&#39; if there are &quot;throws&quot; clauses
 689         }
 690         final Method m = new Method(super.getAccessFlags(), name_index, signature_index, getAttributes(), _cp
 691                 .getConstantPool());
 692         // Undo effects of adding attributes
 693         if (lvt != null) {
 694             removeCodeAttribute(lvt);
 695         }
<span class="line-modified"> 696         if (local_variable_type_table != null) {</span>
<span class="line-modified"> 697             removeCodeAttribute(local_variable_type_table);</span>
 698         }
 699         if (lnt != null) {
 700             removeCodeAttribute(lnt);
 701         }
 702         if (code != null) {
 703             removeAttribute(code);
 704         }
 705         if (et != null) {
 706             removeAttribute(et);
 707         }
 708         return m;
 709     }
 710 
<span class="line-added"> 711     private void updateLocalVariableTable(final LocalVariableTable a) {</span>
<span class="line-added"> 712         final LocalVariable[] lv = a.getLocalVariableTable();</span>
<span class="line-added"> 713         removeLocalVariables();</span>
<span class="line-added"> 714         for (final LocalVariable l : lv) {</span>
<span class="line-added"> 715             InstructionHandle start = il.findHandle(l.getStartPC());</span>
<span class="line-added"> 716             final InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());</span>
<span class="line-added"> 717             // Repair malformed handles</span>
<span class="line-added"> 718             if (null == start) {</span>
<span class="line-added"> 719                 start = il.getStart();</span>
<span class="line-added"> 720             }</span>
<span class="line-added"> 721             // end == null =&gt; live to end of method</span>
<span class="line-added"> 722             // Since we are recreating the LocalVaraible, we must</span>
<span class="line-added"> 723             // propagate the orig_index to new copy.</span>
<span class="line-added"> 724             addLocalVariable(l.getName(), Type.getType(l.getSignature()), l</span>
<span class="line-added"> 725                     .getIndex(), start, end, l.getOrigIndex());</span>
<span class="line-added"> 726         }</span>
<span class="line-added"> 727     }</span>
<span class="line-added"> 728 </span>
<span class="line-added"> 729     private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {</span>
<span class="line-added"> 730         final LocalVariable[] lv = lvt.getLocalVariableTable();</span>
<span class="line-added"> 731         final LocalVariable[] lvg = local_variable_type_table.getLocalVariableTypeTable();</span>
<span class="line-added"> 732 </span>
<span class="line-added"> 733         for (final LocalVariable element : lvg) {</span>
<span class="line-added"> 734             for (final LocalVariable l : lv) {</span>
<span class="line-added"> 735                 if (element.getName().equals(l.getName()) &amp;&amp; element.getIndex() == l.getOrigIndex()) {</span>
<span class="line-added"> 736                     element.setLength(l.getLength());</span>
<span class="line-added"> 737                     element.setStartPC(l.getStartPC());</span>
<span class="line-added"> 738                     element.setIndex(l.getIndex());</span>
<span class="line-added"> 739                     break;</span>
<span class="line-added"> 740                 }</span>
<span class="line-added"> 741             }</span>
<span class="line-added"> 742         }</span>
<span class="line-added"> 743     }</span>
<span class="line-added"> 744 </span>
<span class="line-added"> 745 </span>
 746     /**
 747      * Remove all NOPs from the instruction list (if possible) and update every
 748      * object referring to them, i.e., branch instructions, local variables and
 749      * exception handlers.
 750      */
 751     public void removeNOPs() {
 752         if (il != null) {
 753             InstructionHandle next;
 754             /* Check branch instructions.
 755              */
 756             for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {
 757                 next = ih.getNext();
 758                 if ((next != null) &amp;&amp; (ih.getInstruction() instanceof NOP)) {
 759                     try {
 760                         il.delete(ih);
 761                     } catch (final TargetLostException e) {
 762                         for (final InstructionHandle target : e.getTargets()) {
 763                             for (final InstructionTargeter targeter : target.getTargeters()) {
 764                                 targeter.updateTarget(target, next);
 765                             }
 766                         }
 767                     }
 768                 }
 769             }
 770         }
 771     }
 772 
<span class="line-added"> 773 </span>
 774     /**
 775      * Set maximum number of local variables.
 776      */
<span class="line-modified"> 777     public void setMaxLocals( final int m ) {</span>
 778         max_locals = m;
 779     }
 780 
<span class="line-added"> 781 </span>
 782     public int getMaxLocals() {
 783         return max_locals;
 784     }
 785 
<span class="line-added"> 786 </span>
 787     /**
 788      * Set maximum stack size for this method.
 789      */
<span class="line-modified"> 790     public void setMaxStack( final int m ) { // TODO could be package-protected?</span>
 791         max_stack = m;
 792     }
 793 
<span class="line-added"> 794 </span>
 795     public int getMaxStack() {
 796         return max_stack;
 797     }
 798 
<span class="line-modified"> 799 </span>
<span class="line-modified"> 800     /** @return class that contains this method</span>
 801      */
 802     public String getClassName() {
 803         return class_name;
 804     }
 805 
<span class="line-modified"> 806 </span>
<span class="line-added"> 807     public void setClassName( final String class_name ) { // TODO could be package-protected?</span>
 808         this.class_name = class_name;
 809     }
 810 
<span class="line-modified"> 811 </span>
<span class="line-added"> 812     public void setReturnType( final Type return_type ) {</span>
 813         setType(return_type);
 814     }
 815 
<span class="line-added"> 816 </span>
 817     public Type getReturnType() {
 818         return getType();
 819     }
 820 
<span class="line-modified"> 821 </span>
<span class="line-added"> 822     public void setArgumentTypes( final Type[] arg_types ) {</span>
 823         this.arg_types = arg_types;
 824     }
 825 
<span class="line-added"> 826 </span>
 827     public Type[] getArgumentTypes() {
 828         return arg_types.clone();
 829     }
 830 
<span class="line-modified"> 831 </span>
<span class="line-added"> 832     public void setArgumentType( final int i, final Type type ) {</span>
 833         arg_types[i] = type;
 834     }
 835 
<span class="line-modified"> 836 </span>
<span class="line-added"> 837     public Type getArgumentType( final int i ) {</span>
 838         return arg_types[i];
 839     }
 840 
<span class="line-modified"> 841 </span>
<span class="line-added"> 842     public void setArgumentNames( final String[] arg_names ) {</span>
 843         this.arg_names = arg_names;
 844     }
 845 
<span class="line-added"> 846 </span>
 847     public String[] getArgumentNames() {
 848         return arg_names.clone();
 849     }
 850 
<span class="line-modified"> 851 </span>
<span class="line-added"> 852     public void setArgumentName( final int i, final String name ) {</span>
 853         arg_names[i] = name;
 854     }
 855 
<span class="line-modified"> 856 </span>
<span class="line-added"> 857     public String getArgumentName( final int i ) {</span>
 858         return arg_names[i];
 859     }
 860 
<span class="line-added"> 861 </span>
 862     public InstructionList getInstructionList() {
 863         return il;
 864     }
 865 
<span class="line-modified"> 866 </span>
<span class="line-added"> 867     public void setInstructionList( final InstructionList il ) { // TODO could be package-protected?</span>
 868         this.il = il;
 869     }
 870 
<span class="line-added"> 871 </span>
 872     @Override
 873     public String getSignature() {
 874         return Type.getMethodSignature(super.getType(), arg_types);
 875     }
 876 
<span class="line-added"> 877 </span>
 878     /**
 879      * Computes max. stack size by performing control flow analysis.
 880      */
 881     public void setMaxStack() { // TODO could be package-protected? (some tests would need repackaging)
 882         if (il != null) {
 883             max_stack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());
 884         } else {
 885             max_stack = 0;
 886         }
 887     }
 888 
<span class="line-added"> 889 </span>
 890     /**
 891      * Compute maximum number of local variables.
 892      */
 893     public void setMaxLocals() { // TODO could be package-protected? (some tests would need repackaging)
 894         if (il != null) {
 895             int max = isStatic() ? 0 : 1;
 896             if (arg_types != null) {
 897                 for (final Type arg_type : arg_types) {
 898                     max += arg_type.getSize();
 899                 }
 900             }
 901             for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
 902                 final Instruction ins = ih.getInstruction();
 903                 if ((ins instanceof LocalVariableInstruction) || (ins instanceof RET)
 904                         || (ins instanceof IINC)) {
 905                     final int index = ((IndexedInstruction) ins).getIndex()
 906                             + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();
 907                     if (index &gt; max) {
 908                         max = index;
 909                     }
 910                 }
 911             }
 912             max_locals = max;
 913         } else {
 914             max_locals = 0;
 915         }
 916     }
 917 
<span class="line-modified"> 918 </span>
<span class="line-modified"> 919     /** Do not/Do produce attributes code attributesLineNumberTable and</span>
 920      * LocalVariableTable, like javac -O
 921      */
<span class="line-modified"> 922     public void stripAttributes( final boolean flag ) {</span>
 923         strip_attributes = flag;
 924     }
 925 
 926     static final class BranchTarget {
 927 
 928         final InstructionHandle target;
 929         final int stackDepth;
 930 
<span class="line-added"> 931 </span>
 932         BranchTarget(final InstructionHandle target, final int stackDepth) {
 933             this.target = target;
 934             this.stackDepth = stackDepth;
 935         }
 936     }
 937 
 938     static final class BranchStack {
 939 
 940         private final Stack&lt;BranchTarget&gt; branchTargets = new Stack&lt;&gt;();
 941         private final Map&lt;InstructionHandle, BranchTarget&gt; visitedTargets = new HashMap&lt;&gt;();
 942 
<span class="line-modified"> 943 </span>
<span class="line-added"> 944         public void push( final InstructionHandle target, final int stackDepth ) {</span>
 945             if (visited(target)) {
 946                 return;
 947             }
 948             branchTargets.push(visit(target, stackDepth));
 949         }
 950 
<span class="line-added"> 951 </span>
 952         public BranchTarget pop() {
 953             if (!branchTargets.empty()) {
 954                 final BranchTarget bt = branchTargets.pop();
 955                 return bt;
 956             }
 957             return null;
 958         }
 959 
<span class="line-modified"> 960 </span>
<span class="line-added"> 961         private BranchTarget visit( final InstructionHandle target, final int stackDepth ) {</span>
 962             final BranchTarget bt = new BranchTarget(target, stackDepth);
 963             visitedTargets.put(target, bt);
 964             return bt;
 965         }
 966 
<span class="line-modified"> 967 </span>
<span class="line-added"> 968         private boolean visited( final InstructionHandle target ) {</span>
 969             return visitedTargets.get(target) != null;
 970         }
 971     }
 972 
<span class="line-added"> 973 </span>
 974     /**
<span class="line-modified"> 975      * Computes stack usage of an instruction list by performing control flow analysis.</span>

 976      *
 977      * @return maximum stack depth used by method
 978      */
<span class="line-modified"> 979     public static int getMaxStack( final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et ) {</span>

 980         final BranchStack branchTargets = new BranchStack();
 981         /* Initially, populate the branch stack with the exception
 982          * handlers, because these aren&#39;t (necessarily) branched to
 983          * explicitly. in each case, the stack will have depth 1,
 984          * containing the exception object.
 985          */
 986         for (final CodeExceptionGen element : et) {
 987             final InstructionHandle handler_pc = element.getHandlerPC();
 988             if (handler_pc != null) {
 989                 branchTargets.push(handler_pc, 1);
 990             }
 991         }
 992         int stackDepth = 0;
 993         int maxStackDepth = 0;
 994         InstructionHandle ih = il.getStart();
 995         while (ih != null) {
 996             final Instruction instruction = ih.getInstruction();
 997             final short opcode = instruction.getOpcode();
 998             final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);
 999             stackDepth += delta;
</pre>
<hr />
<pre>
1032                 }
1033             }
1034             // normal case, go to the next instruction.
1035             if (ih != null) {
1036                 ih = ih.getNext();
1037             }
1038             // if we have no more instructions, see if there are any deferred branches to explore.
1039             if (ih == null) {
1040                 final BranchTarget bt = branchTargets.pop();
1041                 if (bt != null) {
1042                     ih = bt.target;
1043                     stackDepth = bt.stackDepth;
1044                 }
1045             }
1046         }
1047         return maxStackDepth;
1048     }
1049 
1050     private List&lt;MethodObserver&gt; observers;
1051 
<span class="line-modified">1052 </span>
<span class="line-modified">1053     /** Add observer for this object.</span>
1054      */
<span class="line-modified">1055     public void addObserver( final MethodObserver o ) {</span>
1056         if (observers == null) {
1057             observers = new ArrayList&lt;&gt;();
1058         }
1059         observers.add(o);
1060     }
1061 
<span class="line-modified">1062 </span>
<span class="line-modified">1063     /** Remove observer for this object.</span>
1064      */
<span class="line-modified">1065     public void removeObserver( final MethodObserver o ) {</span>
1066         if (observers != null) {
1067             observers.remove(o);
1068         }
1069     }
1070 
<span class="line-modified">1071 </span>
<span class="line-modified">1072     /** Call notify() method on all observers. This method is not called</span>
<span class="line-modified">1073      * automatically whenever the state has changed, but has to be</span>
<span class="line-modified">1074      * called by the user after he has finished editing the object.</span>
1075      */
1076     public void update() {
1077         if (observers != null) {
1078             for (final MethodObserver observer : observers) {
1079                 observer.notify(this);
1080             }
1081         }
1082     }
1083 
<span class="line-added">1084 </span>
1085     /**
<span class="line-modified">1086      * Return string representation close to declaration format,</span>
<span class="line-modified">1087      * `public static void main(String[]) throws IOException&#39;, e.g.</span>
1088      *
1089      * @return String representation of the method.
1090      */
1091     @Override
1092     public final String toString() {
1093         final String access = Utility.accessToString(super.getAccessFlags());
1094         String signature = Type.getMethodSignature(super.getType(), arg_types);
1095         signature = Utility.methodSignatureToString(signature, super.getName(), access, true,
1096                 getLocalVariableTable(super.getConstantPool()));
1097         final StringBuilder buf = new StringBuilder(signature);
1098         for (final Attribute a : getAttributes()) {
1099             if (!((a instanceof Code) || (a instanceof ExceptionTable))) {
1100                 buf.append(&quot; [&quot;).append(a).append(&quot;]&quot;);
1101             }
1102         }
1103 
1104         if (throws_vec.size() &gt; 0) {
1105             for (final String throwsDescriptor : throws_vec) {
1106                 buf.append(&quot;\n\t\tthrows &quot;).append(throwsDescriptor);
1107             }
1108         }
1109         return buf.toString();
1110     }
1111 
<span class="line-modified">1112 </span>
<span class="line-modified">1113     /** @return deep copy of this method</span>
1114      */
<span class="line-modified">1115     public MethodGen copy( final String class_name, final ConstantPoolGen cp ) {</span>
1116         final Method m = ((MethodGen) clone()).getMethod();
1117         final MethodGen mg = new MethodGen(m, class_name, super.getConstantPool());
1118         if (super.getConstantPool() != cp) {
1119             mg.setConstantPool(cp);
1120             mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);
1121         }
1122         return mg;
1123     }
1124 
1125     //J5TODO: Should param_annotations be an array of arrays? Rather than an array of lists, this
1126     // is more likely to suggest to the caller it is readonly (which a List does not).
1127     /**
1128      * Return a list of AnnotationGen objects representing parameter annotations

1129      * @since 6.0
1130      */
1131     public List&lt;AnnotationEntryGen&gt; getAnnotationsOnParameter(final int i) {
1132         ensureExistingParameterAnnotationsUnpacked();
1133         if (!hasParameterAnnotations || i &gt; arg_types.length) {
1134             return null;
1135         }
1136         return param_annotations[i];
1137     }
1138 
1139     /**
1140      * Goes through the attributes on the method and identifies any that are
1141      * RuntimeParameterAnnotations, extracting their contents and storing them
1142      * as parameter annotations. There are two kinds of parameter annotation -
1143      * visible and invisible. Once they have been unpacked, these attributes are
1144      * deleted. (The annotations will be rebuilt as attributes when someone
1145      * builds a Method object out of this MethodGen object).
1146      */
<span class="line-modified">1147     private void ensureExistingParameterAnnotationsUnpacked()</span>
<span class="line-added">1148     {</span>
1149         if (haveUnpackedParameterAnnotations) {
1150             return;
1151         }
1152         // Find attributes that contain parameter annotation data
1153         final Attribute[] attrs = getAttributes();
1154         ParameterAnnotations paramAnnVisAttr = null;
1155         ParameterAnnotations paramAnnInvisAttr = null;
1156         for (final Attribute attribute : attrs) {
<span class="line-modified">1157             if (attribute instanceof ParameterAnnotations)</span>
<span class="line-added">1158             {</span>
1159                 // Initialize param_annotations
<span class="line-modified">1160                 if (!hasParameterAnnotations)</span>
<span class="line-added">1161                 {</span>
1162                     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1163                     final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
1164                     param_annotations = parmList;
1165                     for (int j = 0; j &lt; arg_types.length; j++) {
1166                         param_annotations[j] = new ArrayList&lt;&gt;();
1167                     }
1168                 }
1169                 hasParameterAnnotations = true;
1170                 final ParameterAnnotations rpa = (ParameterAnnotations) attribute;
1171                 if (rpa instanceof RuntimeVisibleParameterAnnotations) {
1172                     paramAnnVisAttr = rpa;
1173                 } else {
1174                     paramAnnInvisAttr = rpa;
1175                 }
<span class="line-modified">1176                 final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();</span>
<span class="line-added">1177                 for (int j = 0; j &lt; parameterAnnotationEntries.length; j++)</span>
<span class="line-added">1178                 {</span>
1179                     // This returns Annotation[] ...
<span class="line-modified">1180                     final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];</span>

1181                     // ... which needs transforming into an AnnotationGen[] ...
<span class="line-modified">1182                     final List&lt;AnnotationEntryGen&gt; mutable = makeMutableVersion(immutableArray.getAnnotationEntries());</span>

1183                     // ... then add these to any we already know about
1184                     param_annotations[j].addAll(mutable);
1185                 }
1186             }
1187         }
1188         if (paramAnnVisAttr != null) {
1189             removeAttribute(paramAnnVisAttr);
1190         }
1191         if (paramAnnInvisAttr != null) {
1192             removeAttribute(paramAnnInvisAttr);
1193         }
1194         haveUnpackedParameterAnnotations = true;
1195     }
1196 
<span class="line-modified">1197     private List&lt;AnnotationEntryGen&gt; makeMutableVersion(final AnnotationEntry[] mutableArray)</span>
<span class="line-added">1198     {</span>
1199         final List&lt;AnnotationEntryGen&gt; result = new ArrayList&lt;&gt;();
1200         for (final AnnotationEntry element : mutableArray) {
1201             result.add(new AnnotationEntryGen(element, getConstantPool(),
1202                     false));
1203         }
1204         return result;
1205     }
1206 
1207     public void addParameterAnnotation(final int parameterIndex,
<span class="line-modified">1208             final AnnotationEntryGen annotation)</span>
<span class="line-added">1209     {</span>
1210         ensureExistingParameterAnnotationsUnpacked();
<span class="line-modified">1211         if (!hasParameterAnnotations)</span>
<span class="line-added">1212         {</span>
1213             @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1214             final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
1215             param_annotations = parmList;
1216             hasParameterAnnotations = true;
1217         }
1218         final List&lt;AnnotationEntryGen&gt; existingAnnotations = param_annotations[parameterIndex];
<span class="line-modified">1219         if (existingAnnotations != null)</span>
<span class="line-added">1220         {</span>
1221             existingAnnotations.add(annotation);
<span class="line-modified">1222         }</span>
<span class="line-added">1223         else</span>
<span class="line-added">1224         {</span>
1225             final List&lt;AnnotationEntryGen&gt; l = new ArrayList&lt;&gt;();
1226             l.add(annotation);
1227             param_annotations[parameterIndex] = l;
1228         }
1229     }
1230 
1231     /**
1232      * @return Comparison strategy object
1233      */
1234     public static BCELComparator getComparator() {
1235         return bcelComparator;
1236     }
1237 
<span class="line-added">1238 </span>
1239     /**
1240      * @param comparator Comparison strategy object
1241      */
<span class="line-modified">1242     public static void setComparator( final BCELComparator comparator ) {</span>
1243         bcelComparator = comparator;
1244     }
1245 
<span class="line-added">1246 </span>
1247     /**
<span class="line-modified">1248      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">1249      * By default two MethodGen objects are said to be equal when</span>
<span class="line-modified">1250      * their names and signatures are equal.</span>
1251      *
1252      * @see java.lang.Object#equals(java.lang.Object)
1253      */
1254     @Override
<span class="line-modified">1255     public boolean equals( final Object obj ) {</span>
1256         return bcelComparator.equals(this, obj);
1257     }
1258 
<span class="line-added">1259 </span>
1260     /**
<span class="line-modified">1261      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">1262      * By default return the hashcode of the method&#39;s name XOR signature.</span>
1263      *
1264      * @see java.lang.Object#hashCode()
1265      */
1266     @Override
1267     public int hashCode() {
1268         return bcelComparator.hashCode(this);
1269     }
1270 }
</pre>
</td>
</tr>
</table>
<center><a href="MULTIANEWARRAY.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MethodObserver.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
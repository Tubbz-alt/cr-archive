<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/JavaClass.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.classfile;
 21 
 22 import java.io.ByteArrayOutputStream;
 23 import java.io.DataOutputStream;
 24 import java.io.File;
 25 import java.io.FileOutputStream;
 26 import java.io.IOException;
 27 import java.io.OutputStream;
 28 import java.util.ArrayList;
<a name="2" id="anc2"></a><span class="line-added"> 29 import java.util.Objects;</span>
<span class="line-added"> 30 import java.util.StringTokenizer;</span>
 31 import java.util.List;
 32 import java.util.Set;
<a name="3" id="anc3"></a>
 33 import java.util.TreeSet;
 34 
 35 import com.sun.org.apache.bcel.internal.Const;
 36 import com.sun.org.apache.bcel.internal.generic.Type;
 37 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 38 import com.sun.org.apache.bcel.internal.util.ClassQueue;
 39 import com.sun.org.apache.bcel.internal.util.SyntheticRepository;
<a name="4" id="anc4"></a>
 40 
 41 /**
<a name="5" id="anc5"></a><span class="line-modified"> 42  * Represents a Java class, i.e., the data structures, constant pool,</span>
<span class="line-modified"> 43  * fields, methods and commands contained in a Java .class file.</span>
<span class="line-modified"> 44  * See &lt;a href=&quot;http://docs.oracle.com/javase/specs/&quot;&gt;JVM specification&lt;/a&gt; for details.</span>
<span class="line-modified"> 45  * The intent of this class is to represent a parsed or otherwise existing</span>
<span class="line-modified"> 46  * class file.  Those interested in programatically generating classes</span>
 47  * should see the &lt;a href=&quot;../generic/ClassGen.html&quot;&gt;ClassGen&lt;/a&gt; class.
<a name="6" id="anc6"></a><span class="line-modified"> 48 </span>

 49  * @see com.sun.org.apache.bcel.internal.generic.ClassGen
<a name="7" id="anc7"></a><span class="line-added"> 50  * @LastModified: Jan 2020</span>
 51  */
 52 public class JavaClass extends AccessFlags implements Cloneable, Node, Comparable&lt;JavaClass&gt; {
 53 
 54     private String file_name;
 55     private String package_name;
 56     private String source_file_name = &quot;&lt;Unknown&gt;&quot;;
 57     private int class_name_index;
 58     private int superclass_name_index;
 59     private String class_name;
 60     private String superclass_name;
 61     private int major;
 62     private int minor; // Compiler version
 63     private ConstantPool constant_pool; // Constant pool
 64     private int[] interfaces; // implemented interfaces
 65     private String[] interface_names;
 66     private Field[] fields; // Fields, i.e., variables of class
 67     private Method[] methods; // methods defined in the class
 68     private Attribute[] attributes; // attributes defined in the class
 69     private AnnotationEntry[] annotations;   // annotations defined on the class
 70     private byte source = HEAP; // Generated in memory
 71     private boolean isAnonymous = false;
 72     private boolean isNested = false;
 73     private boolean computedNestedTypeStatus = false;
 74     public static final byte HEAP = 1;
 75     public static final byte FILE = 2;
 76     public static final byte ZIP = 3;
<a name="8" id="anc8"></a><span class="line-added"> 77     private static final boolean debug = false;</span>
 78 
 79     private static BCELComparator bcelComparator = new BCELComparator() {
 80 
 81         @Override
<a name="9" id="anc9"></a><span class="line-modified"> 82         public boolean equals( final Object o1, final Object o2 ) {</span>
 83             final JavaClass THIS = (JavaClass) o1;
 84             final JavaClass THAT = (JavaClass) o2;
<a name="10" id="anc10"></a><span class="line-modified"> 85             return Objects.equals(THIS.getClassName(), THAT.getClassName());</span>
 86         }
 87 
<a name="11" id="anc11"></a><span class="line-added"> 88 </span>
 89         @Override
<a name="12" id="anc12"></a><span class="line-modified"> 90         public int hashCode( final Object o ) {</span>
 91             final JavaClass THIS = (JavaClass) o;
 92             return THIS.getClassName().hashCode();
 93         }
 94     };
 95     /**
<a name="13" id="anc13"></a><span class="line-modified"> 96      * In cases where we go ahead and create something,</span>
<span class="line-modified"> 97      * use the default SyntheticRepository, because we</span>
<span class="line-added"> 98      * don&#39;t know any better.</span>
 99      */
100     private transient com.sun.org.apache.bcel.internal.util.Repository repository
101             = SyntheticRepository.getInstance();
102 
<a name="14" id="anc14"></a><span class="line-added">103 </span>
104     /**
105      * Constructor gets all contents as arguments.
106      *
107      * @param class_name_index Index into constant pool referencing a
108      * ConstantClass that represents this class.
109      * @param superclass_name_index Index into constant pool referencing a
110      * ConstantClass that represents this class&#39;s superclass.
111      * @param file_name File name
112      * @param major Major compiler version
113      * @param minor Minor compiler version
114      * @param access_flags Access rights defined by bit flags
115      * @param constant_pool Array of constants
116      * @param interfaces Implemented interfaces
117      * @param fields Class fields
118      * @param methods Class methods
119      * @param attributes Class attributes
120      * @param source Read from file or generated in memory?
121      */
122     public JavaClass(final int class_name_index, final int superclass_name_index,
123             final String file_name, final int major, final int minor, final int access_flags,
124             final ConstantPool constant_pool, int[] interfaces, Field[] fields,
125             Method[] methods, Attribute[] attributes, final byte source) {
126         super(access_flags);
127         if (interfaces == null) {
128             interfaces = new int[0];
129         }
130         if (attributes == null) {
131             attributes = new Attribute[0];
132         }
133         if (fields == null) {
134             fields = new Field[0];
135         }
136         if (methods == null) {
137             methods = new Method[0];
138         }
139         this.class_name_index = class_name_index;
140         this.superclass_name_index = superclass_name_index;
141         this.file_name = file_name;
142         this.major = major;
143         this.minor = minor;
144         this.constant_pool = constant_pool;
145         this.interfaces = interfaces;
146         this.fields = fields;
147         this.methods = methods;
148         this.attributes = attributes;
149         this.source = source;
150         // Get source file name if available
151         for (final Attribute attribute : attributes) {
152             if (attribute instanceof SourceFile) {
153                 source_file_name = ((SourceFile) attribute).getSourceFileName();
154                 break;
155             }
156         }
157         /* According to the specification the following entries must be of type
158          * `ConstantClass&#39; but we check that anyway via the
159          * `ConstPool.getConstant&#39; method.
160          */
161         class_name = constant_pool.getConstantString(class_name_index, Const.CONSTANT_Class);
162         class_name = Utility.compactClassName(class_name, false);
163         final int index = class_name.lastIndexOf(&#39;.&#39;);
164         if (index &lt; 0) {
165             package_name = &quot;&quot;;
166         } else {
167             package_name = class_name.substring(0, index);
168         }
169         if (superclass_name_index &gt; 0) {
170             // May be zero -&gt; class is java.lang.Object
171             superclass_name = constant_pool.getConstantString(superclass_name_index,
172                     Const.CONSTANT_Class);
173             superclass_name = Utility.compactClassName(superclass_name, false);
174         } else {
175             superclass_name = &quot;java.lang.Object&quot;;
176         }
177         interface_names = new String[interfaces.length];
178         for (int i = 0; i &lt; interfaces.length; i++) {
179             final String str = constant_pool.getConstantString(interfaces[i], Const.CONSTANT_Class);
180             interface_names[i] = Utility.compactClassName(str, false);
181         }
182     }
183 
<a name="15" id="anc15"></a><span class="line-added">184 </span>
185     /**
186      * Constructor gets all contents as arguments.
187      *
188      * @param class_name_index Class name
189      * @param superclass_name_index Superclass name
190      * @param file_name File name
191      * @param major Major compiler version
192      * @param minor Minor compiler version
193      * @param access_flags Access rights defined by bit flags
194      * @param constant_pool Array of constants
195      * @param interfaces Implemented interfaces
196      * @param fields Class fields
197      * @param methods Class methods
198      * @param attributes Class attributes
199      */
200     public JavaClass(final int class_name_index, final int superclass_name_index,
201             final String file_name, final int major, final int minor, final int access_flags,
202             final ConstantPool constant_pool, final int[] interfaces, final Field[] fields,
203             final Method[] methods, final Attribute[] attributes) {
204         this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,
205                 constant_pool, interfaces, fields, methods, attributes, HEAP);
206     }
207 
<a name="16" id="anc16"></a><span class="line-added">208 </span>
209     /**
<a name="17" id="anc17"></a><span class="line-modified">210      * Called by objects that are traversing the nodes of the tree implicitely</span>
211      * defined by the contents of a Java class. I.e., the hierarchy of methods,
212      * fields, attributes, etc. spawns a tree of objects.
213      *
214      * @param v Visitor object
215      */
216     @Override
<a name="18" id="anc18"></a><span class="line-modified">217     public void accept( final Visitor v ) {</span>
218         v.visitJavaClass(this);
219     }
220 
<a name="19" id="anc19"></a><span class="line-added">221 </span>
<span class="line-added">222     /* Print debug information depending on `JavaClass.debug&#39;</span>
<span class="line-added">223      */</span>
<span class="line-added">224     static void Debug( final String str ) {</span>
<span class="line-added">225         if (debug) {</span>
<span class="line-added">226             System.out.println(str);</span>
<span class="line-added">227         }</span>
<span class="line-added">228     }</span>
<span class="line-added">229 </span>
<span class="line-added">230 </span>
231     /**
232      * Dump class to a file.
233      *
234      * @param file Output file
235      * @throws IOException
236      */
237     public void dump(final File file) throws IOException {
238         final String parent = file.getParent();
239         if (parent != null) {
240             final File dir = new File(parent);
241             if (!dir.mkdirs()) { // either was not created or already existed
<a name="20" id="anc20"></a><span class="line-modified">242                 if (!dir.isDirectory()) {</span>
243                     throw new IOException(&quot;Could not create the directory &quot; + dir);
244                 }
245             }
246         }
247         try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {
248             dump(dos);
249         }
250     }
251 
<a name="21" id="anc21"></a><span class="line-added">252 </span>
253     /**
254      * Dump class to a file named file_name.
255      *
256      * @param _file_name Output file name
257      * @throws IOException
258      */
<a name="22" id="anc22"></a><span class="line-modified">259     public void dump( final String _file_name ) throws IOException {</span>
260         dump(new File(_file_name));
261     }
262 
<a name="23" id="anc23"></a><span class="line-added">263 </span>
264     /**
265      * @return class in binary format
266      */
267     public byte[] getBytes() {
268         final ByteArrayOutputStream s = new ByteArrayOutputStream();
269         final DataOutputStream ds = new DataOutputStream(s);
270         try {
271             dump(ds);
272         } catch (final IOException e) {
273             System.err.println(&quot;Error dumping class: &quot; + e.getMessage());
274         } finally {
275             try {
276                 ds.close();
277             } catch (final IOException e2) {
278                 System.err.println(&quot;Error dumping class: &quot; + e2.getMessage());
279             }
280         }
281         return s.toByteArray();
282     }
283 
<a name="24" id="anc24"></a><span class="line-added">284 </span>
285     /**
286      * Dump Java class to output stream in binary format.
287      *
288      * @param file Output stream
289      * @throws IOException
290      */
<a name="25" id="anc25"></a><span class="line-modified">291     public void dump( final OutputStream file ) throws IOException {</span>
292         dump(new DataOutputStream(file));
293     }
294 
<a name="26" id="anc26"></a><span class="line-added">295 </span>
296     /**
297      * Dump Java class to output stream in binary format.
298      *
299      * @param file Output stream
300      * @throws IOException
301      */
<a name="27" id="anc27"></a><span class="line-modified">302     public void dump( final DataOutputStream file ) throws IOException {</span>
303         file.writeInt(Const.JVM_CLASSFILE_MAGIC);
304         file.writeShort(minor);
305         file.writeShort(major);
306         constant_pool.dump(file);
307         file.writeShort(super.getAccessFlags());
308         file.writeShort(class_name_index);
309         file.writeShort(superclass_name_index);
310         file.writeShort(interfaces.length);
311         for (final int interface1 : interfaces) {
312             file.writeShort(interface1);
313         }
314         file.writeShort(fields.length);
315         for (final Field field : fields) {
316             field.dump(file);
317         }
318         file.writeShort(methods.length);
319         for (final Method method : methods) {
320             method.dump(file);
321         }
322         if (attributes != null) {
323             file.writeShort(attributes.length);
324             for (final Attribute attribute : attributes) {
325                 attribute.dump(file);
326             }
327         } else {
328             file.writeShort(0);
329         }
330         file.flush();
331     }
332 
<a name="28" id="anc28"></a><span class="line-added">333 </span>
334     /**
335      * @return Attributes of the class.
336      */
337     public Attribute[] getAttributes() {
338         return attributes;
339     }
340 
341     /**
342      * @return Annotations on the class
343      * @since 6.0
344      */
345     public AnnotationEntry[] getAnnotationEntries() {
346         if (annotations == null) {
347             annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
348         }
349 
350         return annotations;
351     }
352 
353     /**
354      * @return Class name.
355      */
356     public String getClassName() {
357         return class_name;
358     }
359 
<a name="29" id="anc29"></a><span class="line-added">360 </span>
361     /**
362      * @return Package name.
363      */
364     public String getPackageName() {
365         return package_name;
366     }
367 
<a name="30" id="anc30"></a><span class="line-added">368 </span>
369     /**
370      * @return Class name index.
371      */
372     public int getClassNameIndex() {
373         return class_name_index;
374     }
375 
<a name="31" id="anc31"></a><span class="line-added">376 </span>
377     /**
378      * @return Constant pool.
379      */
380     public ConstantPool getConstantPool() {
381         return constant_pool;
382     }
383 
<a name="32" id="anc32"></a><span class="line-added">384 </span>
385     /**
<a name="33" id="anc33"></a><span class="line-modified">386      * @return Fields, i.e., variables of the class. Like the JVM spec</span>
<span class="line-modified">387      * mandates for the classfile format, these fields are those specific to</span>
<span class="line-modified">388      * this class, and not those of the superclass or superinterfaces.</span>
389      */
390     public Field[] getFields() {
391         return fields;
392     }
393 
<a name="34" id="anc34"></a><span class="line-added">394 </span>
395     /**
396      * @return File name of class, aka SourceFile attribute value
397      */
398     public String getFileName() {
399         return file_name;
400     }
401 
<a name="35" id="anc35"></a><span class="line-added">402 </span>
403     /**
404      * @return Names of implemented interfaces.
405      */
406     public String[] getInterfaceNames() {
407         return interface_names;
408     }
409 
<a name="36" id="anc36"></a><span class="line-added">410 </span>
411     /**
412      * @return Indices in constant pool of implemented interfaces.
413      */
414     public int[] getInterfaceIndices() {
415         return interfaces;
416     }
417 
<a name="37" id="anc37"></a><span class="line-added">418 </span>
419     /**
420      * @return Major number of class file version.
421      */
422     public int getMajor() {
423         return major;
424     }
425 
<a name="38" id="anc38"></a><span class="line-added">426 </span>
427     /**
428      * @return Methods of the class.
429      */
430     public Method[] getMethods() {
431         return methods;
432     }
433 
<a name="39" id="anc39"></a><span class="line-added">434 </span>
435     /**
<a name="40" id="anc40"></a><span class="line-modified">436      * @return A {@link Method} corresponding to</span>
<span class="line-added">437      * java.lang.reflect.Method if any</span>
438      */
<a name="41" id="anc41"></a><span class="line-modified">439     public Method getMethod( final java.lang.reflect.Method m ) {</span>
440         for (final Method method : methods) {
441             if (m.getName().equals(method.getName()) &amp;&amp; (m.getModifiers() == method.getModifiers())
442                     &amp;&amp; Type.getSignature(m).equals(method.getSignature())) {
443                 return method;
444             }
445         }
446         return null;
447     }
448 
<a name="42" id="anc42"></a><span class="line-added">449 </span>
450     /**
451      * @return Minor number of class file version.
452      */
453     public int getMinor() {
454         return minor;
455     }
456 
<a name="43" id="anc43"></a><span class="line-added">457 </span>
458     /**
459      * @return sbsolute path to file where this class was read from
460      */
461     public String getSourceFileName() {
462         return source_file_name;
463     }
464 
<a name="44" id="anc44"></a><span class="line-added">465 </span>
466     /**
<a name="45" id="anc45"></a><span class="line-modified">467      * returns the super class name of this class. In the case that this class is</span>
<span class="line-modified">468      * java.lang.Object, it will return itself (java.lang.Object). This is probably incorrect</span>
<span class="line-modified">469      * but isn&#39;t fixed at this time to not break existing clients.</span>

470      *
471      * @return Superclass name.
472      */
473     public String getSuperclassName() {
474         return superclass_name;
475     }
476 
<a name="46" id="anc46"></a><span class="line-added">477 </span>
478     /**
479      * @return Class name index.
480      */
481     public int getSuperclassNameIndex() {
482         return superclass_name_index;
483     }
484 
485     /**
486      * @param attributes .
487      */
<a name="47" id="anc47"></a><span class="line-modified">488     public void setAttributes( final Attribute[] attributes ) {</span>
489         this.attributes = attributes;
490     }
491 
<a name="48" id="anc48"></a><span class="line-added">492 </span>
493     /**
494      * @param class_name .
495      */
<a name="49" id="anc49"></a><span class="line-modified">496     public void setClassName( final String class_name ) {</span>
497         this.class_name = class_name;
498     }
499 
<a name="50" id="anc50"></a><span class="line-added">500 </span>
501     /**
502      * @param class_name_index .
503      */
<a name="51" id="anc51"></a><span class="line-modified">504     public void setClassNameIndex( final int class_name_index ) {</span>
505         this.class_name_index = class_name_index;
506     }
507 
<a name="52" id="anc52"></a><span class="line-added">508 </span>
509     /**
510      * @param constant_pool .
511      */
<a name="53" id="anc53"></a><span class="line-modified">512     public void setConstantPool( final ConstantPool constant_pool ) {</span>
513         this.constant_pool = constant_pool;
514     }
515 
<a name="54" id="anc54"></a><span class="line-added">516 </span>
517     /**
518      * @param fields .
519      */
<a name="55" id="anc55"></a><span class="line-modified">520     public void setFields( final Field[] fields ) {</span>
521         this.fields = fields;
522     }
523 
<a name="56" id="anc56"></a><span class="line-added">524 </span>
525     /**
526      * Set File name of class, aka SourceFile attribute value
527      */
<a name="57" id="anc57"></a><span class="line-modified">528     public void setFileName( final String file_name ) {</span>
529         this.file_name = file_name;
530     }
531 
<a name="58" id="anc58"></a><span class="line-added">532 </span>
533     /**
534      * @param interface_names .
535      */
<a name="59" id="anc59"></a><span class="line-modified">536     public void setInterfaceNames( final String[] interface_names ) {</span>
537         this.interface_names = interface_names;
538     }
539 
<a name="60" id="anc60"></a><span class="line-added">540 </span>
541     /**
542      * @param interfaces .
543      */
<a name="61" id="anc61"></a><span class="line-modified">544     public void setInterfaces( final int[] interfaces ) {</span>
545         this.interfaces = interfaces;
546     }
547 
<a name="62" id="anc62"></a><span class="line-added">548 </span>
549     /**
550      * @param major .
551      */
<a name="63" id="anc63"></a><span class="line-modified">552     public void setMajor( final int major ) {</span>
553         this.major = major;
554     }
555 
<a name="64" id="anc64"></a><span class="line-added">556 </span>
557     /**
558      * @param methods .
559      */
<a name="65" id="anc65"></a><span class="line-modified">560     public void setMethods( final Method[] methods ) {</span>
561         this.methods = methods;
562     }
563 
<a name="66" id="anc66"></a><span class="line-added">564 </span>
565     /**
566      * @param minor .
567      */
<a name="67" id="anc67"></a><span class="line-modified">568     public void setMinor( final int minor ) {</span>
569         this.minor = minor;
570     }
571 
<a name="68" id="anc68"></a><span class="line-added">572 </span>
573     /**
574      * Set absolute path to file this class was read from.
575      */
<a name="69" id="anc69"></a><span class="line-modified">576     public void setSourceFileName( final String source_file_name ) {</span>
577         this.source_file_name = source_file_name;
578     }
579 
<a name="70" id="anc70"></a><span class="line-added">580 </span>
581     /**
582      * @param superclass_name .
583      */
<a name="71" id="anc71"></a><span class="line-modified">584     public void setSuperclassName( final String superclass_name ) {</span>
585         this.superclass_name = superclass_name;
586     }
587 
<a name="72" id="anc72"></a><span class="line-added">588 </span>
589     /**
590      * @param superclass_name_index .
591      */
<a name="73" id="anc73"></a><span class="line-modified">592     public void setSuperclassNameIndex( final int superclass_name_index ) {</span>
593         this.superclass_name_index = superclass_name_index;
594     }
595 
<a name="74" id="anc74"></a><span class="line-added">596 </span>
597     /**
598      * @return String representing class contents.
599      */
600     @Override
601     public String toString() {
602         String access = Utility.accessToString(super.getAccessFlags(), true);
603         access = access.isEmpty() ? &quot;&quot; : (access + &quot; &quot;);
604         final StringBuilder buf = new StringBuilder(128);
605         buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(&quot; &quot;).append(
606                 class_name).append(&quot; extends &quot;).append(
<a name="75" id="anc75"></a><span class="line-modified">607                 Utility.compactClassName(superclass_name, false)).append(&#39;\n&#39;);</span>
608         final int size = interfaces.length;
609         if (size &gt; 0) {
610             buf.append(&quot;implements\t\t&quot;);
611             for (int i = 0; i &lt; size; i++) {
612                 buf.append(interface_names[i]);
613                 if (i &lt; size - 1) {
614                     buf.append(&quot;, &quot;);
615                 }
616             }
617             buf.append(&#39;\n&#39;);
618         }
<a name="76" id="anc76"></a><span class="line-modified">619         buf.append(&quot;file name\t\t&quot;).append(file_name).append(&#39;\n&#39;);</span>
620         buf.append(&quot;compiled from\t\t&quot;).append(source_file_name).append(&#39;\n&#39;);
621         buf.append(&quot;compiler version\t&quot;).append(major).append(&quot;.&quot;).append(minor).append(&#39;\n&#39;);
622         buf.append(&quot;access flags\t\t&quot;).append(super.getAccessFlags()).append(&#39;\n&#39;);
623         buf.append(&quot;constant pool\t\t&quot;).append(constant_pool.getLength()).append(&quot; entries\n&quot;);
624         buf.append(&quot;ACC_SUPER flag\t\t&quot;).append(isSuper()).append(&quot;\n&quot;);
625         if (attributes.length &gt; 0) {
626             buf.append(&quot;\nAttribute(s):\n&quot;);
627             for (final Attribute attribute : attributes) {
628                 buf.append(indent(attribute));
629             }
630         }
631         final AnnotationEntry[] annotations = getAnnotationEntries();
<a name="77" id="anc77"></a><span class="line-modified">632         if (annotations!=null &amp;&amp; annotations.length&gt;0) {</span>
633             buf.append(&quot;\nAnnotation(s):\n&quot;);
634             for (final AnnotationEntry annotation : annotations) {
635                 buf.append(indent(annotation));
636             }
637         }
638         if (fields.length &gt; 0) {
639             buf.append(&quot;\n&quot;).append(fields.length).append(&quot; fields:\n&quot;);
640             for (final Field field : fields) {
641                 buf.append(&quot;\t&quot;).append(field).append(&#39;\n&#39;);
642             }
643         }
644         if (methods.length &gt; 0) {
645             buf.append(&quot;\n&quot;).append(methods.length).append(&quot; methods:\n&quot;);
646             for (final Method method : methods) {
647                 buf.append(&quot;\t&quot;).append(method).append(&#39;\n&#39;);
648             }
649         }
650         return buf.toString();
651     }
652 
<a name="78" id="anc78"></a><span class="line-modified">653 </span>
<span class="line-added">654     private static String indent( final Object obj ) {</span>
655         final StringTokenizer tok = new StringTokenizer(obj.toString(), &quot;\n&quot;);
656         final StringBuilder buf = new StringBuilder();
657         while (tok.hasMoreTokens()) {
658             buf.append(&quot;\t&quot;).append(tok.nextToken()).append(&quot;\n&quot;);
659         }
660         return buf.toString();
661     }
662 
<a name="79" id="anc79"></a><span class="line-added">663 </span>
664     /**
665      * @return deep copy of this class
666      */
667     public JavaClass copy() {
668         JavaClass c = null;
669         try {
670             c = (JavaClass) clone();
671             c.constant_pool = constant_pool.copy();
672             c.interfaces = interfaces.clone();
673             c.interface_names = interface_names.clone();
674             c.fields = new Field[fields.length];
675             for (int i = 0; i &lt; fields.length; i++) {
676                 c.fields[i] = fields[i].copy(c.constant_pool);
677             }
678             c.methods = new Method[methods.length];
679             for (int i = 0; i &lt; methods.length; i++) {
680                 c.methods[i] = methods[i].copy(c.constant_pool);
681             }
682             c.attributes = new Attribute[attributes.length];
683             for (int i = 0; i &lt; attributes.length; i++) {
684                 c.attributes[i] = attributes[i].copy(c.constant_pool);
685             }
686         } catch (final CloneNotSupportedException e) {
687             // TODO should this throw?
688         }
689         return c;
690     }
691 
<a name="80" id="anc80"></a><span class="line-added">692 </span>
693     public final boolean isSuper() {
694         return (super.getAccessFlags() &amp; Const.ACC_SUPER) != 0;
695     }
696 
<a name="81" id="anc81"></a><span class="line-added">697 </span>
698     public final boolean isClass() {
699         return (super.getAccessFlags() &amp; Const.ACC_INTERFACE) == 0;
700     }
701 
702     /**
703      * @since 6.0
704      */
705     public final boolean isAnonymous() {
706         computeNestedTypeStatus();
707         return this.isAnonymous;
708     }
709 
710     /**
711      * @since 6.0
712      */
713     public final boolean isNested() {
714         computeNestedTypeStatus();
715         return this.isNested;
716     }
717 
718     private void computeNestedTypeStatus() {
719         if (computedNestedTypeStatus) {
720             return;
721         }
722         for (final Attribute attribute : this.attributes) {
<a name="82" id="anc82"></a><span class="line-modified">723               if (attribute instanceof InnerClasses) {</span>
<span class="line-modified">724                   final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();</span>
<span class="line-modified">725                   for (final InnerClass innerClasse : innerClasses) {</span>
<span class="line-modified">726                       boolean innerClassAttributeRefersToMe = false;</span>
<span class="line-modified">727                       String inner_class_name = constant_pool.getConstantString(innerClasse.getInnerClassIndex(),</span>
<span class="line-modified">728                                  Const.CONSTANT_Class);</span>
<span class="line-modified">729                       inner_class_name = Utility.compactClassName(inner_class_name, false);</span>
<span class="line-modified">730                       if (inner_class_name.equals(getClassName())) {</span>
<span class="line-modified">731                           innerClassAttributeRefersToMe = true;</span>
<span class="line-modified">732                       }</span>
<span class="line-modified">733                       if (innerClassAttributeRefersToMe) {</span>
<span class="line-modified">734                           this.isNested = true;</span>
<span class="line-modified">735                           if (innerClasse.getInnerNameIndex() == 0) {</span>
<span class="line-modified">736                               this.isAnonymous = true;</span>
<span class="line-modified">737                           }</span>
<span class="line-modified">738                       }</span>
<span class="line-modified">739                   }</span>
<span class="line-modified">740               }</span>
741         }
742         this.computedNestedTypeStatus = true;
743     }
744 
<a name="83" id="anc83"></a><span class="line-modified">745 </span>
<span class="line-modified">746     /** @return returns either HEAP (generated), FILE, or ZIP</span>
747      */
748     public final byte getSource() {
749         return source;
750     }
751 
<a name="84" id="anc84"></a><span class="line-added">752 </span>
<span class="line-added">753     /********************* New repository functionality *********************/</span>
754     /**
<a name="85" id="anc85"></a><span class="line-modified">755      * Gets the ClassRepository which holds its definition. By default</span>
<span class="line-modified">756      * this is the same as SyntheticRepository.getInstance();</span>



757      */
758     public com.sun.org.apache.bcel.internal.util.Repository getRepository() {
759         return repository;
760     }
761 
<a name="86" id="anc86"></a><span class="line-added">762 </span>
763     /**
<a name="87" id="anc87"></a><span class="line-modified">764      * Sets the ClassRepository which loaded the JavaClass.</span>
<span class="line-modified">765      * Should be called immediately after parsing is done.</span>
766      */
<a name="88" id="anc88"></a><span class="line-modified">767     public void setRepository( final com.sun.org.apache.bcel.internal.util.Repository repository ) { // TODO make protected?</span>
768         this.repository = repository;
769     }
770 
<a name="89" id="anc89"></a><span class="line-modified">771 </span>
<span class="line-modified">772     /** Equivalent to runtime &quot;instanceof&quot; operator.</span>
773      *
774      * @return true if this JavaClass is derived from the super class
<a name="90" id="anc90"></a><span class="line-modified">775      * @throws ClassNotFoundException if superclasses or superinterfaces</span>
<span class="line-modified">776      *   of this object can&#39;t be found</span>
777      */
<a name="91" id="anc91"></a><span class="line-modified">778     public final boolean instanceOf( final JavaClass super_class ) throws ClassNotFoundException {</span>
779         if (this.equals(super_class)) {
780             return true;
781         }
782         final JavaClass[] super_classes = getSuperClasses();
783         for (final JavaClass super_classe : super_classes) {
784             if (super_classe.equals(super_class)) {
785                 return true;
786             }
787         }
788         if (super_class.isInterface()) {
789             return implementationOf(super_class);
790         }
791         return false;
792     }
793 
<a name="92" id="anc92"></a><span class="line-added">794 </span>
795     /**
796      * @return true, if this class is an implementation of interface inter
<a name="93" id="anc93"></a><span class="line-modified">797      * @throws ClassNotFoundException if superclasses or superinterfaces</span>
<span class="line-modified">798      *   of this class can&#39;t be found</span>
799      */
<a name="94" id="anc94"></a><span class="line-modified">800     public boolean implementationOf( final JavaClass inter ) throws ClassNotFoundException {</span>
801         if (!inter.isInterface()) {
802             throw new IllegalArgumentException(inter.getClassName() + &quot; is no interface&quot;);
803         }
804         if (this.equals(inter)) {
805             return true;
806         }
807         final JavaClass[] super_interfaces = getAllInterfaces();
808         for (final JavaClass super_interface : super_interfaces) {
809             if (super_interface.equals(inter)) {
810                 return true;
811             }
812         }
813         return false;
814     }
815 
<a name="95" id="anc95"></a><span class="line-added">816 </span>
817     /**
<a name="96" id="anc96"></a><span class="line-modified">818      * @return the superclass for this JavaClass object, or null if this</span>
<span class="line-modified">819      * is java.lang.Object</span>
820      * @throws ClassNotFoundException if the superclass can&#39;t be found
821      */
822     public JavaClass getSuperClass() throws ClassNotFoundException {
823         if (&quot;java.lang.Object&quot;.equals(getClassName())) {
824             return null;
825         }
826         return repository.loadClass(getSuperclassName());
827     }
828 
<a name="97" id="anc97"></a><span class="line-added">829 </span>
830     /**
831      * @return list of super classes of this class in ascending order, i.e.,
832      * java.lang.Object is always the last element
833      * @throws ClassNotFoundException if any of the superclasses can&#39;t be found
834      */
835     public JavaClass[] getSuperClasses() throws ClassNotFoundException {
836         JavaClass clazz = this;
837         final List&lt;JavaClass&gt; allSuperClasses = new ArrayList&lt;&gt;();
838         for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {
839             allSuperClasses.add(clazz);
840         }
841         return allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);
842     }
843 
<a name="98" id="anc98"></a><span class="line-added">844 </span>
845     /**
846      * Get interfaces directly implemented by this JavaClass.
847      */
848     public JavaClass[] getInterfaces() throws ClassNotFoundException {
849         final String[] _interfaces = getInterfaceNames();
850         final JavaClass[] classes = new JavaClass[_interfaces.length];
851         for (int i = 0; i &lt; _interfaces.length; i++) {
852             classes[i] = repository.loadClass(_interfaces[i]);
853         }
854         return classes;
855     }
856 
<a name="99" id="anc99"></a><span class="line-added">857 </span>
858     /**
859      * Get all interfaces implemented by this JavaClass (transitively).
860      */
861     public JavaClass[] getAllInterfaces() throws ClassNotFoundException {
862         final ClassQueue queue = new ClassQueue();
863         final Set&lt;JavaClass&gt; allInterfaces = new TreeSet&lt;&gt;();
864         queue.enqueue(this);
865         while (!queue.empty()) {
866             final JavaClass clazz = queue.dequeue();
867             final JavaClass souper = clazz.getSuperClass();
868             final JavaClass[] _interfaces = clazz.getInterfaces();
869             if (clazz.isInterface()) {
870                 allInterfaces.add(clazz);
871             } else {
872                 if (souper != null) {
873                     queue.enqueue(souper);
874                 }
875             }
876             for (final JavaClass _interface : _interfaces) {
877                 queue.enqueue(_interface);
878             }
879         }
880         return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);
881     }
882 
<a name="100" id="anc100"></a><span class="line-added">883 </span>
884     /**
885      * @return Comparison strategy object
886      */
887     public static BCELComparator getComparator() {
888         return bcelComparator;
889     }
890 
<a name="101" id="anc101"></a><span class="line-added">891 </span>
892     /**
893      * @param comparator Comparison strategy object
894      */
<a name="102" id="anc102"></a><span class="line-modified">895     public static void setComparator( final BCELComparator comparator ) {</span>
896         bcelComparator = comparator;
897     }
898 
<a name="103" id="anc103"></a><span class="line-added">899 </span>
900     /**
<a name="104" id="anc104"></a><span class="line-modified">901      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">902      * By default two JavaClass objects are said to be equal when</span>
<span class="line-added">903      * their class names are equal.</span>
904      *
905      * @see java.lang.Object#equals(java.lang.Object)
906      */
907     @Override
<a name="105" id="anc105"></a><span class="line-modified">908     public boolean equals( final Object obj ) {</span>
909         return bcelComparator.equals(this, obj);
910     }
911 
<a name="106" id="anc106"></a><span class="line-added">912 </span>
913     /**
<a name="107" id="anc107"></a><span class="line-modified">914      * Return the natural ordering of two JavaClasses.</span>
<span class="line-modified">915      * This ordering is based on the class name</span>

916      * @since 6.0
917      */
918     @Override
<a name="108" id="anc108"></a><span class="line-modified">919     public int compareTo( final JavaClass obj ) {</span>
920         return getClassName().compareTo(obj.getClassName());
921     }
922 
<a name="109" id="anc109"></a><span class="line-added">923 </span>
924     /**
<a name="110" id="anc110"></a><span class="line-modified">925      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">926      * By default return the hashcode of the class name.</span>
927      *
928      * @see java.lang.Object#hashCode()
929      */
930     @Override
931     public int hashCode() {
932         return bcelComparator.hashCode(this);
933     }
934 }
<a name="111" id="anc111"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="111" type="hidden" />
</body>
</html>
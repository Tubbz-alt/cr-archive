<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Instruction.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.io.DataOutputStream;
 23 import java.io.IOException;
 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 27 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 28 
 29 /**
 30  * Abstract super class for all Java byte codes.
 31  *
 32  * @version $Id: Instruction.java 1750029 2016-06-23 22:14:38Z sebb $
 33  */
 34 public abstract class Instruction implements Cloneable {
 35 
 36     private short length = 1; // Length of instruction in bytes
 37     private short opcode = -1; // Opcode number
 38 
 39     private static InstructionComparator cmp = InstructionComparator.DEFAULT;
 40 
 41     /**
 42      * Empty constructor needed for the Class.newInstance() statement in
 43      * Instruction.readInstruction(). Not to be used otherwise.
 44      */
 45     Instruction() {
 46     }
 47 
 48     public Instruction(final short opcode, final short length) {
 49         this.length = length;
 50         this.opcode = opcode;
 51     }
 52 
 53     /**
 54      * Dump instruction as byte code to stream out.
 55      *
 56      * @param out Output stream
 57      */
 58     public void dump(final DataOutputStream out) throws IOException {
 59         out.writeByte(opcode); // Common for all instructions
 60     }
 61 
 62     /**
 63      * @return name of instruction, i.e., opcode name
 64      */
 65     public String getName() {
 66         return Const.getOpcodeName(opcode);
 67     }
 68 
 69     /**
 70      * Long output format:
 71      *
 72      * &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode number&amp;gt;&quot;]&quot; &quot;(&quot;&amp;lt;length of
 73      * instruction&amp;gt;&quot;)&quot;
 74      *
 75      * @param verbose long/short format switch
 76      * @return mnemonic for instruction
 77      */
 78     public String toString(final boolean verbose) {
 79         if (verbose) {
 80             return getName() + &quot;[&quot; + opcode + &quot;](&quot; + length + &quot;)&quot;;
 81         }
 82         return getName();
 83     }
 84 
 85     /**
 86      * @return mnemonic for instruction in verbose format
 87      */
 88     @Override
 89     public String toString() {
 90         return toString(true);
 91     }
 92 
 93     /**
 94      * @return mnemonic for instruction with sumbolic references resolved
 95      */
 96     public String toString(final ConstantPool cp) {
 97         return toString(false);
 98     }
 99 
100     /**
101      * Use with caution, since `BranchInstruction&#39;s have a `target&#39; reference
102      * which is not copied correctly (only basic types are). This also applies
103      * for `Select&#39; instructions with their multiple branch targets.
104      *
105      * @see BranchInstruction
106      * @return (shallow) copy of an instruction
107      */
108     public Instruction copy() {
109         Instruction i = null;
110         // &quot;Constant&quot; instruction, no need to duplicate
111         if (InstructionConst.getInstruction(this.getOpcode()) != null) {
112             i = this;
113         } else {
114             try {
115                 i = (Instruction) clone();
116             } catch (final CloneNotSupportedException e) {
117                 System.err.println(e);
118             }
119         }
120         return i;
121     }
122 
123     /**
124      * Read needed data (e.g. index) from file.
125      *
126      * @param bytes byte sequence to read from
127      * @param wide &quot;wide&quot; instruction flag
128      * @throws IOException may be thrown if the implementation needs to read
129      * data from the file
130      */
131     protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {
132     }
133 
134     /**
135      * Read an instruction from (byte code) input stream and return the
136      * appropiate object.
137      * &lt;p&gt;
138      * If the Instruction is defined in {@link InstructionConst}, then the
139      * singleton instance is returned.
140      *
141      * @param bytes input stream bytes
142      * @return instruction object being read
143      * @see InstructionConst#getInstruction(int)
144      */
145     // @since 6.0 no longer final
146     public static Instruction readInstruction(final ByteSequence bytes) throws IOException {
147         boolean wide = false;
148         short opcode = (short) bytes.readUnsignedByte();
149         Instruction obj = null;
150         if (opcode == Const.WIDE) { // Read next opcode after wide byte
151             wide = true;
152             opcode = (short) bytes.readUnsignedByte();
153         }
154         final Instruction instruction = InstructionConst.getInstruction(opcode);
155         if (instruction != null) {
156             return instruction; // Used predefined immutable object, if available
157         }
158 
159         switch (opcode) {
160             case Const.BIPUSH:
161                 obj = new BIPUSH();
162                 break;
163             case Const.SIPUSH:
164                 obj = new SIPUSH();
165                 break;
166             case Const.LDC:
167                 obj = new LDC();
168                 break;
169             case Const.LDC_W:
170                 obj = new LDC_W();
171                 break;
172             case Const.LDC2_W:
173                 obj = new LDC2_W();
174                 break;
175             case Const.ILOAD:
176                 obj = new ILOAD();
177                 break;
178             case Const.LLOAD:
179                 obj = new LLOAD();
180                 break;
181             case Const.FLOAD:
182                 obj = new FLOAD();
183                 break;
184             case Const.DLOAD:
185                 obj = new DLOAD();
186                 break;
187             case Const.ALOAD:
188                 obj = new ALOAD();
189                 break;
190             case Const.ILOAD_0:
191                 obj = new ILOAD(0);
192                 break;
193             case Const.ILOAD_1:
194                 obj = new ILOAD(1);
195                 break;
196             case Const.ILOAD_2:
197                 obj = new ILOAD(2);
198                 break;
199             case Const.ILOAD_3:
200                 obj = new ILOAD(3);
201                 break;
202             case Const.LLOAD_0:
203                 obj = new LLOAD(0);
204                 break;
205             case Const.LLOAD_1:
206                 obj = new LLOAD(1);
207                 break;
208             case Const.LLOAD_2:
209                 obj = new LLOAD(2);
210                 break;
211             case Const.LLOAD_3:
212                 obj = new LLOAD(3);
213                 break;
214             case Const.FLOAD_0:
215                 obj = new FLOAD(0);
216                 break;
217             case Const.FLOAD_1:
218                 obj = new FLOAD(1);
219                 break;
220             case Const.FLOAD_2:
221                 obj = new FLOAD(2);
222                 break;
223             case Const.FLOAD_3:
224                 obj = new FLOAD(3);
225                 break;
226             case Const.DLOAD_0:
227                 obj = new DLOAD(0);
228                 break;
229             case Const.DLOAD_1:
230                 obj = new DLOAD(1);
231                 break;
232             case Const.DLOAD_2:
233                 obj = new DLOAD(2);
234                 break;
235             case Const.DLOAD_3:
236                 obj = new DLOAD(3);
237                 break;
238             case Const.ALOAD_0:
239                 obj = new ALOAD(0);
240                 break;
241             case Const.ALOAD_1:
242                 obj = new ALOAD(1);
243                 break;
244             case Const.ALOAD_2:
245                 obj = new ALOAD(2);
246                 break;
247             case Const.ALOAD_3:
248                 obj = new ALOAD(3);
249                 break;
250             case Const.ISTORE:
251                 obj = new ISTORE();
252                 break;
253             case Const.LSTORE:
254                 obj = new LSTORE();
255                 break;
256             case Const.FSTORE:
257                 obj = new FSTORE();
258                 break;
259             case Const.DSTORE:
260                 obj = new DSTORE();
261                 break;
262             case Const.ASTORE:
263                 obj = new ASTORE();
264                 break;
265             case Const.ISTORE_0:
266                 obj = new ISTORE(0);
267                 break;
268             case Const.ISTORE_1:
269                 obj = new ISTORE(1);
270                 break;
271             case Const.ISTORE_2:
272                 obj = new ISTORE(2);
273                 break;
274             case Const.ISTORE_3:
275                 obj = new ISTORE(3);
276                 break;
277             case Const.LSTORE_0:
278                 obj = new LSTORE(0);
279                 break;
280             case Const.LSTORE_1:
281                 obj = new LSTORE(1);
282                 break;
283             case Const.LSTORE_2:
284                 obj = new LSTORE(2);
285                 break;
286             case Const.LSTORE_3:
287                 obj = new LSTORE(3);
288                 break;
289             case Const.FSTORE_0:
290                 obj = new FSTORE(0);
291                 break;
292             case Const.FSTORE_1:
293                 obj = new FSTORE(1);
294                 break;
295             case Const.FSTORE_2:
296                 obj = new FSTORE(2);
297                 break;
298             case Const.FSTORE_3:
299                 obj = new FSTORE(3);
300                 break;
301             case Const.DSTORE_0:
302                 obj = new DSTORE(0);
303                 break;
304             case Const.DSTORE_1:
305                 obj = new DSTORE(1);
306                 break;
307             case Const.DSTORE_2:
308                 obj = new DSTORE(2);
309                 break;
310             case Const.DSTORE_3:
311                 obj = new DSTORE(3);
312                 break;
313             case Const.ASTORE_0:
314                 obj = new ASTORE(0);
315                 break;
316             case Const.ASTORE_1:
317                 obj = new ASTORE(1);
318                 break;
319             case Const.ASTORE_2:
320                 obj = new ASTORE(2);
321                 break;
322             case Const.ASTORE_3:
323                 obj = new ASTORE(3);
324                 break;
325             case Const.IINC:
326                 obj = new IINC();
327                 break;
328             case Const.IFEQ:
329                 obj = new IFEQ();
330                 break;
331             case Const.IFNE:
332                 obj = new IFNE();
333                 break;
334             case Const.IFLT:
335                 obj = new IFLT();
336                 break;
337             case Const.IFGE:
338                 obj = new IFGE();
339                 break;
340             case Const.IFGT:
341                 obj = new IFGT();
342                 break;
343             case Const.IFLE:
344                 obj = new IFLE();
345                 break;
346             case Const.IF_ICMPEQ:
347                 obj = new IF_ICMPEQ();
348                 break;
349             case Const.IF_ICMPNE:
350                 obj = new IF_ICMPNE();
351                 break;
352             case Const.IF_ICMPLT:
353                 obj = new IF_ICMPLT();
354                 break;
355             case Const.IF_ICMPGE:
356                 obj = new IF_ICMPGE();
357                 break;
358             case Const.IF_ICMPGT:
359                 obj = new IF_ICMPGT();
360                 break;
361             case Const.IF_ICMPLE:
362                 obj = new IF_ICMPLE();
363                 break;
364             case Const.IF_ACMPEQ:
365                 obj = new IF_ACMPEQ();
366                 break;
367             case Const.IF_ACMPNE:
368                 obj = new IF_ACMPNE();
369                 break;
370             case Const.GOTO:
371                 obj = new GOTO();
372                 break;
373             case Const.JSR:
374                 obj = new JSR();
375                 break;
376             case Const.RET:
377                 obj = new RET();
378                 break;
379             case Const.TABLESWITCH:
380                 obj = new TABLESWITCH();
381                 break;
382             case Const.LOOKUPSWITCH:
383                 obj = new LOOKUPSWITCH();
384                 break;
385             case Const.GETSTATIC:
386                 obj = new GETSTATIC();
387                 break;
388             case Const.PUTSTATIC:
389                 obj = new PUTSTATIC();
390                 break;
391             case Const.GETFIELD:
392                 obj = new GETFIELD();
393                 break;
394             case Const.PUTFIELD:
395                 obj = new PUTFIELD();
396                 break;
397             case Const.INVOKEVIRTUAL:
398                 obj = new INVOKEVIRTUAL();
399                 break;
400             case Const.INVOKESPECIAL:
401                 obj = new INVOKESPECIAL();
402                 break;
403             case Const.INVOKESTATIC:
404                 obj = new INVOKESTATIC();
405                 break;
406             case Const.INVOKEINTERFACE:
407                 obj = new INVOKEINTERFACE();
408                 break;
409             case Const.INVOKEDYNAMIC:
410                 obj = new INVOKEDYNAMIC();
411                 break;
412             case Const.NEW:
413                 obj = new NEW();
414                 break;
415             case Const.NEWARRAY:
416                 obj = new NEWARRAY();
417                 break;
418             case Const.ANEWARRAY:
419                 obj = new ANEWARRAY();
420                 break;
421             case Const.CHECKCAST:
422                 obj = new CHECKCAST();
423                 break;
424             case Const.INSTANCEOF:
425                 obj = new INSTANCEOF();
426                 break;
427             case Const.MULTIANEWARRAY:
428                 obj = new MULTIANEWARRAY();
429                 break;
430             case Const.IFNULL:
431                 obj = new IFNULL();
432                 break;
433             case Const.IFNONNULL:
434                 obj = new IFNONNULL();
435                 break;
436             case Const.GOTO_W:
437                 obj = new GOTO_W();
438                 break;
439             case Const.JSR_W:
440                 obj = new JSR_W();
441                 break;
442             case Const.BREAKPOINT:
443                 obj = new BREAKPOINT();
444                 break;
445             case Const.IMPDEP1:
446                 obj = new IMPDEP1();
447                 break;
448             case Const.IMPDEP2:
449                 obj = new IMPDEP2();
450                 break;
451             default:
452                 throw new ClassGenException(&quot;Illegal opcode detected: &quot; + opcode);
453 
454         }
455 
456         if (wide
457                 &amp;&amp; !((obj instanceof LocalVariableInstruction) || (obj instanceof IINC) || (obj instanceof RET))) {
458             throw new ClassGenException(&quot;Illegal opcode after wide: &quot; + opcode);
459         }
460         obj.setOpcode(opcode);
461         obj.initFromFile(bytes, wide); // Do further initializations, if any
462         return obj;
463     }
464 
465     /**
466      * This method also gives right results for instructions whose effect on the
467      * stack depends on the constant pool entry they reference.
468      *
469      * @return Number of words consumed from stack by this instruction, or
470      * Constants.UNPREDICTABLE, if this can not be computed statically
471      */
472     public int consumeStack(final ConstantPoolGen cpg) {
473         return Const.getConsumeStack(opcode);
474     }
475 
476     /**
477      * This method also gives right results for instructions whose effect on the
478      * stack depends on the constant pool entry they reference.
479      *
480      * @return Number of words produced onto stack by this instruction, or
481      * Constants.UNPREDICTABLE, if this can not be computed statically
482      */
483     public int produceStack(final ConstantPoolGen cpg) {
484         return Const.getProduceStack(opcode);
485     }
486 
487     /**
488      * @return this instructions opcode
489      */
490     public short getOpcode() {
491         return opcode;
492     }
493 
494     /**
495      * @return length (in bytes) of instruction
496      */
497     public int getLength() {
498         return length;
499     }
500 
501     /**
502      * Needed in readInstruction and subclasses in this package
503      */
504     final void setOpcode(final short opcode) {
505         this.opcode = opcode;
506     }
507 
508     /**
509      * Needed in readInstruction and subclasses in this package
510      *
511      * @since 6.0
512      */
513     final void setLength(final int length) {
514         this.length = (short) length; // TODO check range?
515     }
516 
517     /**
518      * Some instructions may be reused, so don&#39;t do anything by default.
519      */
520     void dispose() {
521     }
522 
523     /**
524      * Call corresponding visitor method(s). The order is: Call visitor methods
525      * of implemented interfaces first, then call methods according to the class
526      * hierarchy in descending order, i.e., the most specific visitXXX() call
527      * comes last.
528      *
529      * @param v Visitor object
530      */
531     public abstract void accept(Visitor v);
532 
533     /**
534      * Get Comparator object used in the equals() method to determine equality
535      * of instructions.
536      *
537      * @return currently used comparator for equals()
538      * @deprecated (6.0) use the built in comparator, or wrap this class in
539      * another object that implements these methods
540      */
541     @Deprecated
542     public static InstructionComparator getComparator() {
543         return cmp;
544     }
545 
546     /**
547      * Set comparator to be used for equals().
548      *
549      * @deprecated (6.0) use the built in comparator, or wrap this class in
550      * another object that implements these methods
551      */
552     @Deprecated
553     public static void setComparator(final InstructionComparator c) {
554         cmp = c;
555     }
556 
557     /**
558      * Check for equality, delegated to comparator
559      *
560      * @return true if that is an Instruction and has the same opcode
561      */
562     @Override
563     public boolean equals(final Object that) {
564         return (that instanceof Instruction) ? cmp.equals(this, (Instruction) that) : false;
565     }
566 
567     /**
568      * calculate the hashCode of this object
569      *
570      * @return the hashCode
571      * @since 6.0
572      */
573     @Override
574     public int hashCode() {
575         return opcode;
576     }
577 
578     /**
579      * Check if the value can fit in a byte (signed)
580      *
581      * @param value the value to check
582      * @return true if the value is in range
583      * @since 6.0
584      */
585     public static boolean isValidByte(final int value) {
586         return value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE;
587     }
588 
589     /**
590      * Check if the value can fit in a short (signed)
591      *
592      * @param value the value to check
593      * @return true if the value is in range
594      * @since 6.0
595      */
596     public static boolean isValidShort(final int value) {
597         return value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE;
598     }
599 }
    </pre>
  </body>
</html>
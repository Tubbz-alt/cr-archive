<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ClassGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>

  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.ArrayList;
 23 import java.util.List;
<a name="2" id="anc2"></a><span class="line-added"> 24 import java.util.Objects;</span>
 25 
 26 import com.sun.org.apache.bcel.internal.Const;
 27 import com.sun.org.apache.bcel.internal.classfile.AccessFlags;
 28 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
 29 import com.sun.org.apache.bcel.internal.classfile.Annotations;
 30 import com.sun.org.apache.bcel.internal.classfile.Attribute;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 32 import com.sun.org.apache.bcel.internal.classfile.Field;
 33 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
 34 import com.sun.org.apache.bcel.internal.classfile.Method;
 35 import com.sun.org.apache.bcel.internal.classfile.RuntimeInvisibleAnnotations;
 36 import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleAnnotations;
 37 import com.sun.org.apache.bcel.internal.classfile.SourceFile;
 38 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 39 
 40 /**
 41  * Template class for building up a java class. May be initialized with an
 42  * existing java class (file).
 43  *
 44  * @see JavaClass
<a name="3" id="anc3"></a><span class="line-modified"> 45  * @LastModified: Jan 2020</span>
 46  */
 47 public class ClassGen extends AccessFlags implements Cloneable {
 48 
 49     /* Corresponds to the fields found in a JavaClass object.
 50      */
 51     private String class_name;
 52     private String super_class_name;
 53     private final String file_name;
 54     private int class_name_index = -1;
 55     private int superclass_name_index = -1;
 56     private int major = Const.MAJOR;
 57     private int minor = Const.MINOR;
 58     private ConstantPoolGen cp; // Template for building up constant pool
 59     // ArrayLists instead of arrays to gather fields, methods, etc.
 60     private final List&lt;Field&gt; field_vec = new ArrayList&lt;&gt;();
 61     private final List&lt;Method&gt; method_vec = new ArrayList&lt;&gt;();
 62     private final List&lt;Attribute&gt; attribute_vec = new ArrayList&lt;&gt;();
 63     private final List&lt;String&gt; interface_vec = new ArrayList&lt;&gt;();
 64     private final List&lt;AnnotationEntryGen&gt; annotation_vec = new ArrayList&lt;&gt;();
 65 
 66     private static BCELComparator _cmp = new BCELComparator() {
 67 
 68         @Override
<a name="4" id="anc4"></a><span class="line-modified"> 69         public boolean equals( final Object o1, final Object o2 ) {</span>
 70             final ClassGen THIS = (ClassGen) o1;
 71             final ClassGen THAT = (ClassGen) o2;
<a name="5" id="anc5"></a><span class="line-modified"> 72             return Objects.equals(THIS.getClassName(), THAT.getClassName());</span>
 73         }
 74 
<a name="6" id="anc6"></a><span class="line-added"> 75 </span>
 76         @Override
<a name="7" id="anc7"></a><span class="line-modified"> 77         public int hashCode( final Object o ) {</span>
 78             final ClassGen THIS = (ClassGen) o;
 79             return THIS.getClassName().hashCode();
 80         }
 81     };
 82 
<a name="8" id="anc8"></a><span class="line-modified"> 83 </span>
<span class="line-modified"> 84     /** Convenience constructor to set up some important values initially.</span>
 85      *
 86      * @param class_name fully qualified class name
 87      * @param super_class_name fully qualified superclass name
 88      * @param file_name source file name
 89      * @param access_flags access qualifiers
 90      * @param interfaces implemented interfaces
 91      * @param cp constant pool to use
 92      */
 93     public ClassGen(final String class_name, final String super_class_name, final String file_name, final int access_flags,
 94             final String[] interfaces, final ConstantPoolGen cp) {
 95         super(access_flags);
 96         this.class_name = class_name;
 97         this.super_class_name = super_class_name;
 98         this.file_name = file_name;
 99         this.cp = cp;
100         // Put everything needed by default into the constant pool and the vectors
101         if (file_name != null) {
102             addAttribute(new SourceFile(cp.addUtf8(&quot;SourceFile&quot;), 2, cp.addUtf8(file_name), cp
103                     .getConstantPool()));
104         }
105         class_name_index = cp.addClass(class_name);
106         superclass_name_index = cp.addClass(super_class_name);
107         if (interfaces != null) {
108             for (final String interface1 : interfaces) {
109                 addInterface(interface1);
110             }
111         }
112     }
113 
<a name="9" id="anc9"></a><span class="line-modified">114 </span>
<span class="line-modified">115     /** Convenience constructor to set up some important values initially.</span>
116      *
117      * @param class_name fully qualified class name
118      * @param super_class_name fully qualified superclass name
119      * @param file_name source file name
120      * @param access_flags access qualifiers
121      * @param interfaces implemented interfaces
122      */
123     public ClassGen(final String class_name, final String super_class_name, final String file_name, final int access_flags,
124             final String[] interfaces) {
125         this(class_name, super_class_name, file_name, access_flags, interfaces,
126                 new ConstantPoolGen());
127     }
128 
<a name="10" id="anc10"></a><span class="line-added">129 </span>
130     /**
131      * Initialize with existing class.
<a name="11" id="anc11"></a>
132      * @param clazz JavaClass object (e.g. read from file)
133      */
134     public ClassGen(final JavaClass clazz) {
135         super(clazz.getAccessFlags());
136         class_name_index = clazz.getClassNameIndex();
137         superclass_name_index = clazz.getSuperclassNameIndex();
138         class_name = clazz.getClassName();
139         super_class_name = clazz.getSuperclassName();
140         file_name = clazz.getSourceFileName();
141         cp = new ConstantPoolGen(clazz.getConstantPool());
142         major = clazz.getMajor();
143         minor = clazz.getMinor();
144         final Attribute[] attributes = clazz.getAttributes();
145         // J5TODO: Could make unpacking lazy, done on first reference
146         final AnnotationEntryGen[] annotations = unpackAnnotations(attributes);
147         final Method[] methods = clazz.getMethods();
148         final Field[] fields = clazz.getFields();
149         final String[] interfaces = clazz.getInterfaceNames();
150         for (final String interface1 : interfaces) {
151             addInterface(interface1);
152         }
153         for (final Attribute attribute : attributes) {
154             if (!(attribute instanceof Annotations)) {
155                 addAttribute(attribute);
156             }
157         }
158         for (final AnnotationEntryGen annotation : annotations) {
159             addAnnotationEntry(annotation);
160         }
161         for (final Method method : methods) {
162             addMethod(method);
163         }
164         for (final Field field : fields) {
165             addField(field);
166         }
167     }
168 
169     /**
170      * Look for attributes representing annotations and unpack them.
171      */
<a name="12" id="anc12"></a><span class="line-modified">172     private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs)</span>
<span class="line-added">173     {</span>
174         final List&lt;AnnotationEntryGen&gt; annotationGenObjs = new ArrayList&lt;&gt;();
175         for (final Attribute attr : attrs) {
<a name="13" id="anc13"></a><span class="line-modified">176             if (attr instanceof RuntimeVisibleAnnotations)</span>
<span class="line-added">177             {</span>
178                 final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;
179                 final AnnotationEntry[] annos = rva.getAnnotationEntries();
180                 for (final AnnotationEntry a : annos) {
181                     annotationGenObjs.add(new AnnotationEntryGen(a,
182                             getConstantPool(), false));
183                 }
<a name="14" id="anc14"></a>






184             }
<a name="15" id="anc15"></a><span class="line-added">185             else</span>
<span class="line-added">186                 if (attr instanceof RuntimeInvisibleAnnotations)</span>
<span class="line-added">187                 {</span>
<span class="line-added">188                     final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;</span>
<span class="line-added">189                     final AnnotationEntry[] annos = ria.getAnnotationEntries();</span>
<span class="line-added">190                     for (final AnnotationEntry a : annos) {</span>
<span class="line-added">191                         annotationGenObjs.add(new AnnotationEntryGen(a,</span>
<span class="line-added">192                                 getConstantPool(), false));</span>
<span class="line-added">193                     }</span>
<span class="line-added">194                 }</span>
195         }
196         return annotationGenObjs.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);
197     }
198 
<a name="16" id="anc16"></a><span class="line-added">199 </span>
200     /**
201      * @return the (finally) built up Java class object.
202      */
203     public JavaClass getJavaClass() {
204         final int[] interfaces = getInterfaces();
205         final Field[] fields = getFields();
206         final Method[] methods = getMethods();
<a name="17" id="anc17"></a><span class="line-modified">207         Attribute[] attributes = null;</span>
208         if (annotation_vec.isEmpty()) {
209             attributes = getAttributes();
210         } else {
211             // TODO: Sometime later, trash any attributes called &#39;RuntimeVisibleAnnotations&#39; or &#39;RuntimeInvisibleAnnotations&#39;
<a name="18" id="anc18"></a><span class="line-modified">212             final Attribute[] annAttributes  = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());</span>
<span class="line-modified">213             attributes = new Attribute[attribute_vec.size()+annAttributes.length];</span>
214             attribute_vec.toArray(attributes);
<a name="19" id="anc19"></a><span class="line-modified">215             System.arraycopy(annAttributes,0,attributes,attribute_vec.size(),annAttributes.length);</span>
216         }
217         // Must be last since the above calls may still add something to it
218         final ConstantPool _cp = this.cp.getFinalConstantPool();
219         return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor,
220                 super.getAccessFlags(), _cp, interfaces, fields, methods, attributes);
221     }
222 
<a name="20" id="anc20"></a><span class="line-added">223 </span>
224     /**
225      * Add an interface to this class, i.e., this class has to implement it.
<a name="21" id="anc21"></a>
226      * @param name interface to implement (fully qualified class name)
227      */
<a name="22" id="anc22"></a><span class="line-modified">228     public void addInterface( final String name ) {</span>
229         interface_vec.add(name);
230     }
231 
<a name="23" id="anc23"></a><span class="line-added">232 </span>
233     /**
234      * Remove an interface from this class.
<a name="24" id="anc24"></a>
235      * @param name interface to remove (fully qualified name)
236      */
<a name="25" id="anc25"></a><span class="line-modified">237     public void removeInterface( final String name ) {</span>
238         interface_vec.remove(name);
239     }
240 
<a name="26" id="anc26"></a><span class="line-added">241 </span>
242     /**
243      * @return major version number of class file
244      */
245     public int getMajor() {
246         return major;
247     }
248 
<a name="27" id="anc27"></a><span class="line-modified">249 </span>
<span class="line-modified">250     /** Set major version number of class file, default value is 45 (JDK 1.1)</span>

251      * @param major major version number
252      */
<a name="28" id="anc28"></a><span class="line-modified">253     public void setMajor( final int major ) { // TODO could be package-protected - only called by test code</span>
254         this.major = major;
255     }
256 
<a name="29" id="anc29"></a><span class="line-modified">257 </span>
<span class="line-modified">258     /** Set minor version number of class file, default value is 3 (JDK 1.1)</span>

259      * @param minor minor version number
260      */
<a name="30" id="anc30"></a><span class="line-modified">261     public void setMinor( final int minor ) {  // TODO could be package-protected - only called by test code</span>
262         this.minor = minor;
263     }
264 
265     /**
266      * @return minor version number of class file
267      */
268     public int getMinor() {
269         return minor;
270     }
271 
<a name="31" id="anc31"></a><span class="line-added">272 </span>
273     /**
274      * Add an attribute to this class.
<a name="32" id="anc32"></a>
275      * @param a attribute to add
276      */
<a name="33" id="anc33"></a><span class="line-modified">277     public void addAttribute( final Attribute a ) {</span>
278         attribute_vec.add(a);
279     }
280 
<a name="34" id="anc34"></a><span class="line-modified">281     public void addAnnotationEntry(final AnnotationEntryGen a) {</span>
282         annotation_vec.add(a);
283     }
284 
<a name="35" id="anc35"></a><span class="line-added">285 </span>
286     /**
287      * Add a method to this class.
<a name="36" id="anc36"></a>
288      * @param m method to add
289      */
<a name="37" id="anc37"></a><span class="line-modified">290     public void addMethod( final Method m ) {</span>
291         method_vec.add(m);
292     }
293 
<a name="38" id="anc38"></a><span class="line-added">294 </span>
295     /**
296      * Convenience method.
297      *
<a name="39" id="anc39"></a><span class="line-modified">298      * Add an empty constructor to this class that does nothing but calling super().</span>


299      * @param access_flags rights for constructor
300      */
<a name="40" id="anc40"></a><span class="line-modified">301     public void addEmptyConstructor( final int access_flags ) {</span>
302         final InstructionList il = new InstructionList();
303         il.append(InstructionConst.THIS); // Push `this&#39;
304         il.append(new INVOKESPECIAL(cp.addMethodref(super_class_name, &quot;&lt;init&gt;&quot;, &quot;()V&quot;)));
305         il.append(InstructionConst.RETURN);
306         final MethodGen mg = new MethodGen(access_flags, Type.VOID, Type.NO_ARGS, null, &quot;&lt;init&gt;&quot;,
307                 class_name, il, cp);
308         mg.setMaxStack(1);
309         addMethod(mg.getMethod());
310     }
311 
<a name="41" id="anc41"></a><span class="line-added">312 </span>
313     /**
314      * Add a field to this class.
<a name="42" id="anc42"></a>
315      * @param f field to add
316      */
<a name="43" id="anc43"></a><span class="line-modified">317     public void addField( final Field f ) {</span>
318         field_vec.add(f);
319     }
320 
<a name="44" id="anc44"></a><span class="line-modified">321 </span>
<span class="line-added">322     public boolean containsField( final Field f ) {</span>
323         return field_vec.contains(f);
324     }
325 
<a name="45" id="anc45"></a><span class="line-modified">326 </span>
<span class="line-modified">327     /** @return field object with given name, or null</span>
328      */
<a name="46" id="anc46"></a><span class="line-modified">329     public Field containsField( final String name ) {</span>
330         for (final Field f : field_vec) {
331             if (f.getName().equals(name)) {
332                 return f;
333             }
334         }
335         return null;
336     }
337 
<a name="47" id="anc47"></a><span class="line-modified">338 </span>
<span class="line-modified">339     /** @return method object with given name and signature, or null</span>
340      */
<a name="48" id="anc48"></a><span class="line-modified">341     public Method containsMethod( final String name, final String signature ) {</span>
342         for (final Method m : method_vec) {
343             if (m.getName().equals(name) &amp;&amp; m.getSignature().equals(signature)) {
344                 return m;
345             }
346         }
347         return null;
348     }
349 
<a name="49" id="anc49"></a><span class="line-added">350 </span>
351     /**
352      * Remove an attribute from this class.
<a name="50" id="anc50"></a>
353      * @param a attribute to remove
354      */
<a name="51" id="anc51"></a><span class="line-modified">355     public void removeAttribute( final Attribute a ) {</span>
356         attribute_vec.remove(a);
357     }
358 
<a name="52" id="anc52"></a><span class="line-added">359 </span>
360     /**
361      * Remove a method from this class.
<a name="53" id="anc53"></a>
362      * @param m method to remove
363      */
<a name="54" id="anc54"></a><span class="line-modified">364     public void removeMethod( final Method m ) {</span>
365         method_vec.remove(m);
366     }
367 
<a name="55" id="anc55"></a><span class="line-modified">368 </span>
<span class="line-modified">369     /** Replace given method with new one. If the old one does not exist</span>
<span class="line-modified">370      * add the new_ method to the class anyway.</span>
371      */
<a name="56" id="anc56"></a><span class="line-modified">372     public void replaceMethod( final Method old, final Method new_ ) {</span>
373         if (new_ == null) {
374             throw new ClassGenException(&quot;Replacement method must not be null&quot;);
375         }
376         final int i = method_vec.indexOf(old);
377         if (i &lt; 0) {
378             method_vec.add(new_);
379         } else {
380             method_vec.set(i, new_);
381         }
382     }
383 
<a name="57" id="anc57"></a><span class="line-modified">384 </span>
<span class="line-modified">385     /** Replace given field with new one. If the old one does not exist</span>
<span class="line-modified">386      * add the new_ field to the class anyway.</span>
387      */
<a name="58" id="anc58"></a><span class="line-modified">388     public void replaceField( final Field old, final Field new_ ) {</span>
389         if (new_ == null) {
390             throw new ClassGenException(&quot;Replacement method must not be null&quot;);
391         }
392         final int i = field_vec.indexOf(old);
393         if (i &lt; 0) {
394             field_vec.add(new_);
395         } else {
396             field_vec.set(i, new_);
397         }
398     }
399 
<a name="59" id="anc59"></a><span class="line-added">400 </span>
401     /**
402      * Remove a field to this class.
<a name="60" id="anc60"></a>
403      * @param f field to remove
404      */
<a name="61" id="anc61"></a><span class="line-modified">405     public void removeField( final Field f ) {</span>
406         field_vec.remove(f);
407     }
408 
<a name="62" id="anc62"></a><span class="line-added">409 </span>
410     public String getClassName() {
411         return class_name;
412     }
413 
<a name="63" id="anc63"></a><span class="line-added">414 </span>
415     public String getSuperclassName() {
416         return super_class_name;
417     }
418 
<a name="64" id="anc64"></a><span class="line-added">419 </span>
420     public String getFileName() {
421         return file_name;
422     }
423 
<a name="65" id="anc65"></a><span class="line-modified">424 </span>
<span class="line-added">425     public void setClassName( final String name ) {</span>
426         class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
427         class_name_index = cp.addClass(name);
428     }
429 
<a name="66" id="anc66"></a><span class="line-modified">430 </span>
<span class="line-added">431     public void setSuperclassName( final String name ) {</span>
432         super_class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
433         superclass_name_index = cp.addClass(name);
434     }
435 
<a name="67" id="anc67"></a><span class="line-added">436 </span>
437     public Method[] getMethods() {
438         return method_vec.toArray(new Method[method_vec.size()]);
439     }
440 
<a name="68" id="anc68"></a><span class="line-modified">441 </span>
<span class="line-added">442     public void setMethods( final Method[] methods ) {</span>
443         method_vec.clear();
444         for (final Method method : methods) {
445             addMethod(method);
446         }
447     }
448 
<a name="69" id="anc69"></a><span class="line-modified">449 </span>
<span class="line-added">450     public void setMethodAt( final Method method, final int pos ) {</span>
451         method_vec.set(pos, method);
452     }
453 
<a name="70" id="anc70"></a><span class="line-modified">454 </span>
<span class="line-added">455     public Method getMethodAt( final int pos ) {</span>
456         return method_vec.get(pos);
457     }
458 
<a name="71" id="anc71"></a><span class="line-added">459 </span>
460     public String[] getInterfaceNames() {
461         final int size = interface_vec.size();
462         final String[] interfaces = new String[size];
463         interface_vec.toArray(interfaces);
464         return interfaces;
465     }
466 
<a name="72" id="anc72"></a><span class="line-added">467 </span>
468     public int[] getInterfaces() {
469         final int size = interface_vec.size();
470         final int[] interfaces = new int[size];
471         for (int i = 0; i &lt; size; i++) {
472             interfaces[i] = cp.addClass(interface_vec.get(i));
473         }
474         return interfaces;
475     }
476 
<a name="73" id="anc73"></a><span class="line-added">477 </span>
478     public Field[] getFields() {
479         return field_vec.toArray(new Field[field_vec.size()]);
480     }
481 
<a name="74" id="anc74"></a><span class="line-added">482 </span>
483     public Attribute[] getAttributes() {
484         return attribute_vec.toArray(new Attribute[attribute_vec.size()]);
485     }
486 
487     //  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?
488     public AnnotationEntryGen[] getAnnotationEntries() {
489         return annotation_vec.toArray(new AnnotationEntryGen[annotation_vec.size()]);
490     }
491 
<a name="75" id="anc75"></a><span class="line-added">492 </span>
493     public ConstantPoolGen getConstantPool() {
494         return cp;
495     }
496 
<a name="76" id="anc76"></a><span class="line-modified">497 </span>
<span class="line-added">498     public void setConstantPool( final ConstantPoolGen constant_pool ) {</span>
499         cp = constant_pool;
500     }
501 
<a name="77" id="anc77"></a><span class="line-modified">502 </span>
<span class="line-added">503     public void setClassNameIndex( final int class_name_index ) {</span>
504         this.class_name_index = class_name_index;
505         class_name = cp.getConstantPool().getConstantString(class_name_index,
506                 Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
507     }
508 
<a name="78" id="anc78"></a><span class="line-modified">509 </span>
<span class="line-added">510     public void setSuperclassNameIndex( final int superclass_name_index ) {</span>
511         this.superclass_name_index = superclass_name_index;
512         super_class_name = cp.getConstantPool().getConstantString(superclass_name_index,
513                 Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
514     }
515 
<a name="79" id="anc79"></a><span class="line-added">516 </span>
517     public int getSuperclassNameIndex() {
518         return superclass_name_index;
519     }
520 
<a name="80" id="anc80"></a><span class="line-added">521 </span>
522     public int getClassNameIndex() {
523         return class_name_index;
524     }
525 
526     private List&lt;ClassObserver&gt; observers;
527 
<a name="81" id="anc81"></a><span class="line-modified">528 </span>
<span class="line-modified">529     /** Add observer for this object.</span>
530      */
<a name="82" id="anc82"></a><span class="line-modified">531     public void addObserver( final ClassObserver o ) {</span>
532         if (observers == null) {
533             observers = new ArrayList&lt;&gt;();
534         }
535         observers.add(o);
536     }
537 
<a name="83" id="anc83"></a><span class="line-modified">538 </span>
<span class="line-modified">539     /** Remove observer for this object.</span>
540      */
<a name="84" id="anc84"></a><span class="line-modified">541     public void removeObserver( final ClassObserver o ) {</span>
542         if (observers != null) {
543             observers.remove(o);
544         }
545     }
546 
<a name="85" id="anc85"></a><span class="line-modified">547 </span>
<span class="line-modified">548     /** Call notify() method on all observers. This method is not called</span>
<span class="line-modified">549      * automatically whenever the state has changed, but has to be</span>
<span class="line-modified">550      * called by the user after he has finished editing the object.</span>
551      */
552     public void update() {
553         if (observers != null) {
554             for (final ClassObserver observer : observers) {
555                 observer.notify(this);
556             }
557         }
558     }
559 
<a name="86" id="anc86"></a><span class="line-added">560 </span>
561     @Override
562     public Object clone() {
563         try {
564             return super.clone();
565         } catch (final CloneNotSupportedException e) {
566             throw new Error(&quot;Clone Not Supported&quot;); // never happens
567         }
568     }
569 
<a name="87" id="anc87"></a><span class="line-added">570 </span>
571     /**
572      * @return Comparison strategy object
573      */
574     public static BCELComparator getComparator() {
575         return _cmp;
576     }
577 
<a name="88" id="anc88"></a><span class="line-added">578 </span>
579     /**
580      * @param comparator Comparison strategy object
581      */
<a name="89" id="anc89"></a><span class="line-modified">582     public static void setComparator( final BCELComparator comparator ) {</span>
583         _cmp = comparator;
584     }
585 
<a name="90" id="anc90"></a><span class="line-added">586 </span>
587     /**
<a name="91" id="anc91"></a><span class="line-modified">588      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">589      * By default two ClassGen objects are said to be equal when</span>
<span class="line-added">590      * their class names are equal.</span>
591      *
592      * @see java.lang.Object#equals(java.lang.Object)
593      */
594     @Override
<a name="92" id="anc92"></a><span class="line-modified">595     public boolean equals( final Object obj ) {</span>
596         return _cmp.equals(this, obj);
597     }
598 
<a name="93" id="anc93"></a><span class="line-added">599 </span>
600     /**
<a name="94" id="anc94"></a><span class="line-modified">601      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">602      * By default return the hashcode of the class name.</span>
603      *
604      * @see java.lang.Object#hashCode()
605      */
606     @Override
607     public int hashCode() {
608         return _cmp.hashCode(this);
609     }
610 }
<a name="95" id="anc95"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="95" type="hidden" />
</body>
</html>
diff a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Type.java b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Type.java
--- a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Type.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Type.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -25,14 +25,14 @@
 import com.sun.org.apache.bcel.internal.Const;
 import com.sun.org.apache.bcel.internal.classfile.ClassFormatException;
 import com.sun.org.apache.bcel.internal.classfile.Utility;
 
 /**
- * Abstract super class for all possible java types, namely basic types such as
- * int, object types like String and array types, e.g. int[]
+ * Abstract super class for all possible java types, namely basic types
+ * such as int, object types like String and array types, e.g. int[]
  *
- * @version $Id: Type.java 1749603 2016-06-21 20:50:19Z ggregory $
+ * @LastModified: Jan 2020
  */
 public abstract class Type {
 
     private final byte type;
     private String signature; // signature for the type
@@ -57,67 +57,69 @@
     public static final ReferenceType NULL = new ReferenceType() {
     };
     public static final Type UNKNOWN = new Type(Const.T_UNKNOWN, "<unknown object>") {
     };
 
+
     protected Type(final byte t, final String s) {
         type = t;
         signature = s;
     }
 
+
     /**
      * @return hashcode of Type
      */
     @Override
     public int hashCode() {
         return type ^ signature.hashCode();
     }
 
+
     /**
      * @return whether the Types are equal
      */
     @Override
     public boolean equals(final Object o) {
-        if (o instanceof Type) {
-            final Type t = (Type) o;
-            return (type == t.type) && signature.equals(t.signature);
-        }
-        return false;
+          if (o instanceof Type) {
+              final Type t = (Type)o;
+              return (type == t.type) && signature.equals(t.signature);
+          }
+          return false;
     }
 
+
     /**
      * @return signature for given type.
      */
     public String getSignature() {
         return signature;
     }
 
+
     /**
      * @return type as defined in Constants
      */
     public byte getType() {
         return type;
     }
 
     /**
-     * boolean, short and char variable are considered as int in the stack or
-     * local variable area. Returns {@link Type#INT} for
-     * {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise
+     * boolean, short and char variable are considered as int in the stack or local variable area.
+     * Returns {@link Type#INT} for {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise
      * returns the given type.
-     *
      * @since 6.0
      */
     public Type normalizeForStackOrLocal() {
         if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {
             return Type.INT;
         }
         return this;
     }
 
     /**
-     * @return stack size of this type (2 for long and double, 0 for void, 1
-     * otherwise)
+     * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)
      */
     public int getSize() {
         switch (type) {
             case Const.T_DOUBLE:
             case Const.T_LONG:
@@ -127,28 +129,30 @@
             default:
                 return 1;
         }
     }
 
+
     /**
      * @return Type string, e.g. `int[]'
      */
     @Override
     public String toString() {
         return ((this.equals(Type.NULL) || (type >= Const.T_UNKNOWN))) ? signature : Utility
                 .signatureToString(signature, false);
     }
 
+
     /**
      * Convert type to Java method signature, e.g. int[] f(java.lang.String x)
      * becomes (Ljava/lang/String;)[I
      *
      * @param return_type what the method returns
      * @param arg_types what are the argument types
      * @return method signature for given type(s).
      */
-    public static String getMethodSignature(final Type return_type, final Type[] arg_types) {
+    public static String getMethodSignature( final Type return_type, final Type[] arg_types ) {
         final StringBuilder buf = new StringBuilder("(");
         if (arg_types != null) {
             for (final Type arg_type : arg_types) {
                 buf.append(arg_type.getSignature());
             }
@@ -164,26 +168,28 @@
         protected Integer initialValue() {
             return Integer.valueOf(0);
         }
     };//int consumed_chars=0; // Remember position in string, see getArgumentTypes
 
-    private static int unwrap(final ThreadLocal<Integer> tl) {
+
+    private static int unwrap( final ThreadLocal<Integer> tl ) {
         return tl.get().intValue();
     }
 
-    private static void wrap(final ThreadLocal<Integer> tl, final int value) {
+
+    private static void wrap( final ThreadLocal<Integer> tl, final int value ) {
         tl.set(Integer.valueOf(value));
     }
 
+
     /**
      * Convert signature to a Type object.
-     *
      * @param signature signature string such as Ljava/lang/String;
      * @return type object
      */
     // @since 6.0 no longer final
-    public static Type getType(final String signature) throws StringIndexOutOfBoundsException {
+    public static Type getType( final String signature ) throws StringIndexOutOfBoundsException {
         final byte type = Utility.typeOfSignature(signature);
         if (type <= Const.T_VOID) {
             //corrected concurrent private static field acess
             wrap(consumed_chars, 1);
             return BasicType.getType(type);
@@ -198,49 +204,50 @@
             //  consumed_chars += dim; // update counter - is replaced by
             final int _temp = unwrap(consumed_chars) + dim;
             wrap(consumed_chars, _temp);
             return new ArrayType(t, dim);
         } else { // type == T_REFERENCE
-            // Utility.signatureToString understands how to parse
-            // generic types.
-            final String parsedSignature = Utility.signatureToString(signature, false);
+            // Utility.typeSignatureToString understands how to parse generic types.
+            final String parsedSignature = Utility.typeSignatureToString(signature, false);
             wrap(consumed_chars, parsedSignature.length() + 2); // "Lblabla;" `L' and `;' are removed
             return ObjectType.getInstance(parsedSignature.replace('/', '.'));
         }
     }
 
+
     /**
      * Convert return value of a method (signature) to a Type object.
      *
      * @param signature signature string such as (Ljava/lang/String;)V
      * @return return type
      */
-    public static Type getReturnType(final String signature) {
+    public static Type getReturnType( final String signature ) {
         try {
             // Read return type after `)'
             final int index = signature.lastIndexOf(')') + 1;
             return getType(signature.substring(index));
         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
             throw new ClassFormatException("Invalid method signature: " + signature, e);
         }
     }
 
+
     /**
      * Convert arguments of a method (signature) to an array of Type objects.
-     *
      * @param signature signature string such as (Ljava/lang/String;)V
      * @return array of argument types
      */
-    public static Type[] getArgumentTypes(final String signature) {
+    public static Type[] getArgumentTypes( final String signature ) {
         final List<Type> vec = new ArrayList<>();
         int index;
         Type[] types;
-        try { // Read all declarations between for `(' and `)'
-            if (signature.charAt(0) != '(') {
+        try {
+            // Skip any type arguments to read argument declarations between `(' and `)'
+            index = signature.indexOf('(') + 1;
+            if (index <= 0) {
                 throw new ClassFormatException("Invalid method signature: " + signature);
             }
-            index = 1; // current string position
             while (signature.charAt(index) != ')') {
                 vec.add(getType(signature.substring(index)));
                 //corrected concurrent private static field acess
                 index += unwrap(consumed_chars); // update position
             }
@@ -250,17 +257,16 @@
         types = new Type[vec.size()];
         vec.toArray(types);
         return types;
     }
 
-    /**
-     * Convert runtime java.lang.Class to BCEL Type object.
-     *
+
+    /** Convert runtime java.lang.Class to BCEL Type object.
      * @param cl Java class
      * @return corresponding Type object
      */
-    public static Type getType(final java.lang.Class<?> cl) {
+    public static Type getType( final java.lang.Class<?> cl ) {
         if (cl == null) {
             throw new IllegalArgumentException("Class must not be null");
         }
         /* That's an amzingly easy case, because getName() returns
          * the signature. That's what we would have liked anyway.
@@ -294,25 +300,26 @@
         } else { // "Real" class
             return ObjectType.getInstance(cl.getName());
         }
     }
 
+
     /**
      * Convert runtime java.lang.Class[] to BCEL Type objects.
-     *
      * @param classes an array of runtime class objects
      * @return array of corresponding Type objects
      */
-    public static Type[] getTypes(final java.lang.Class<?>[] classes) {
+    public static Type[] getTypes( final java.lang.Class<?>[] classes ) {
         final Type[] ret = new Type[classes.length];
         for (int i = 0; i < ret.length; i++) {
             ret[i] = getType(classes[i]);
         }
         return ret;
     }
 
-    public static String getSignature(final java.lang.reflect.Method meth) {
+
+    public static String getSignature( final java.lang.reflect.Method meth ) {
         final StringBuilder sb = new StringBuilder("(");
         final Class<?>[] params = meth.getParameterTypes(); // avoid clone
         for (final Class<?> param : params) {
             sb.append(getType(param).getSignature());
         }
@@ -331,18 +338,19 @@
 
     static int encode(final int size, final int consumed) {
         return consumed << 2 | size;
     }
 
-    static int getArgumentTypesSize(final String signature) {
+    static int getArgumentTypesSize( final String signature ) {
         int res = 0;
         int index;
-        try { // Read all declarations between for `(' and `)'
-            if (signature.charAt(0) != '(') {
+        try {
+            // Skip any type arguments to read argument declarations between `(' and `)'
+            index = signature.indexOf('(') + 1;
+            if (index <= 0) {
                 throw new ClassFormatException("Invalid method signature: " + signature);
             }
-            index = 1; // current string position
             while (signature.charAt(index) != ')') {
                 final int coded = getTypeSize(signature.substring(index));
                 res += size(coded);
                 index += consumed(coded);
             }
@@ -350,11 +358,11 @@
             throw new ClassFormatException("Invalid method signature: " + signature, e);
         }
         return res;
     }
 
-    static int getTypeSize(final String signature) throws StringIndexOutOfBoundsException {
+    static int getTypeSize( final String signature ) throws StringIndexOutOfBoundsException {
         final byte type = Utility.typeOfSignature(signature);
         if (type <= Const.T_VOID) {
             return encode(BasicType.getType(type).getSize(), 1);
         } else if (type == Const.T_ARRAY) {
             int dim = 0;
@@ -371,10 +379,11 @@
             }
             return encode(1, index + 1);
         }
     }
 
+
     static int getReturnTypeSize(final String signature) {
         final int index = signature.lastIndexOf(')') + 1;
         return Type.size(getTypeSize(signature.substring(index)));
     }
 

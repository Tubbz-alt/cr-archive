<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/ExceptionTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.bcel.internal.classfile;
 23 
 24 import java.io.DataInput;
 25 import java.io.DataOutputStream;
 26 import java.io.IOException;
 27 
 28 import com.sun.org.apache.bcel.internal.Const;
 29 
 30 /**
 31  * This class represents the table of exceptions that are thrown by a
 32  * method. This attribute may be used once per method.  The name of
 33  * this class is &lt;em&gt;ExceptionTable&lt;/em&gt; for historical reasons; The
 34  * Java Virtual Machine Specification, Second Edition defines this
 35  * attribute using the name &lt;em&gt;Exceptions&lt;/em&gt; (which is inconsistent
 36  * with the other classes).
 37  *
 38  * @version $Id: ExceptionTable.java 1749603 2016-06-21 20:50:19Z ggregory $
 39  * @see     Code
 40  */
 41 public final class ExceptionTable extends Attribute {
 42 
 43     private int[] exception_index_table; // constant pool
 44 
 45 
 46     /**
 47      * Initialize from another object. Note that both objects use the same
 48      * references (shallow copy). Use copy() for a physical copy.
 49      */
 50     public ExceptionTable(final ExceptionTable c) {
 51         this(c.getNameIndex(), c.getLength(), c.getExceptionIndexTable(), c.getConstantPool());
 52     }
 53 
 54 
 55     /**
 56      * @param name_index Index in constant pool
 57      * @param length Content length in bytes
 58      * @param exception_index_table Table of indices in constant pool
 59      * @param constant_pool Array of constants
 60      */
 61     public ExceptionTable(final int name_index, final int length, final int[] exception_index_table,
 62             final ConstantPool constant_pool) {
 63         super(Const.ATTR_EXCEPTIONS, name_index, length, constant_pool);
 64         this.exception_index_table = exception_index_table != null ? exception_index_table : new int[0];
 65     }
 66 
 67 
 68     /**
 69      * Construct object from input stream.
 70      * @param name_index Index in constant pool
 71      * @param length Content length in bytes
 72      * @param input Input stream
 73      * @param constant_pool Array of constants
 74      * @throws IOException
 75      */
 76     ExceptionTable(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {
 77         this(name_index, length, (int[]) null, constant_pool);
 78         final int number_of_exceptions = input.readUnsignedShort();
 79         exception_index_table = new int[number_of_exceptions];
 80         for (int i = 0; i &lt; number_of_exceptions; i++) {
 81             exception_index_table[i] = input.readUnsignedShort();
 82         }
 83     }
 84 
 85 
 86     /**
 87      * Called by objects that are traversing the nodes of the tree implicitely
 88      * defined by the contents of a Java class. I.e., the hierarchy of methods,
 89      * fields, attributes, etc. spawns a tree of objects.
 90      *
 91      * @param v Visitor object
 92      */
 93     @Override
 94     public void accept( final Visitor v ) {
 95         v.visitExceptionTable(this);
 96     }
 97 
 98 
 99     /**
100      * Dump exceptions attribute to file stream in binary format.
101      *
102      * @param file Output file stream
103      * @throws IOException
104      */
105     @Override
106     public final void dump( final DataOutputStream file ) throws IOException {
107         super.dump(file);
108         file.writeShort(exception_index_table.length);
109         for (final int index : exception_index_table) {
110             file.writeShort(index);
111         }
112     }
113 
114 
115     /**
116      * @return Array of indices into constant pool of thrown exceptions.
117      */
118     public final int[] getExceptionIndexTable() {
119         return exception_index_table;
120     }
121 
122 
123     /**
124      * @return Length of exception table.
125      */
126     public final int getNumberOfExceptions() {
127         return exception_index_table == null ? 0 : exception_index_table.length;
128     }
129 
130 
131     /**
132      * @return class names of thrown exceptions
133      */
134     public final String[] getExceptionNames() {
135         final String[] names = new String[exception_index_table.length];
136         for (int i = 0; i &lt; exception_index_table.length; i++) {
137             names[i] = super.getConstantPool().getConstantString(exception_index_table[i],
138                     Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
139         }
140         return names;
141     }
142 
143 
144     /**
145      * @param exception_index_table the list of exception indexes
146      * Also redefines number_of_exceptions according to table length.
147      */
148     public final void setExceptionIndexTable( final int[] exception_index_table ) {
149         this.exception_index_table = exception_index_table != null ? exception_index_table : new int[0];
150     }
151 
152 
153     /**
154      * @return String representation, i.e., a list of thrown exceptions.
155      */
156     @Override
157     public final String toString() {
158         final StringBuilder buf = new StringBuilder();
159         String str;
160         buf.append(&quot;Exceptions: &quot;);
161         for (int i = 0; i &lt; exception_index_table.length; i++) {
162             str = super.getConstantPool().getConstantString(exception_index_table[i], Const.CONSTANT_Class);
163             buf.append(Utility.compactClassName(str, false));
164             if (i &lt; exception_index_table.length - 1) {
165                 buf.append(&quot;, &quot;);
166             }
167         }
168         return buf.toString();
169     }
170 
171 
172     /**
173      * @return deep copy of this attribute
174      */
175     @Override
176     public Attribute copy( final ConstantPool _constant_pool ) {
177         final ExceptionTable c = (ExceptionTable) clone();
178         if (exception_index_table != null) {
179             c.exception_index_table = new int[exception_index_table.length];
180             System.arraycopy(exception_index_table, 0, c.exception_index_table, 0,
181                     exception_index_table.length);
182         }
183         c.setConstantPool(_constant_pool);
184         return c;
185     }
186 }
    </pre>
  </body>
</html>
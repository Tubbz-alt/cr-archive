<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/JavaClass.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InnerClasses.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LineNumber.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/JavaClass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,32 ***</span>
  import java.io.File;
  import java.io.FileOutputStream;
  import java.io.IOException;
  import java.io.OutputStream;
  import java.util.ArrayList;
  import java.util.List;
  import java.util.Set;
<span class="line-removed">- import java.util.StringTokenizer;</span>
  import java.util.TreeSet;
  
  import com.sun.org.apache.bcel.internal.Const;
  import com.sun.org.apache.bcel.internal.generic.Type;
  import com.sun.org.apache.bcel.internal.util.BCELComparator;
  import com.sun.org.apache.bcel.internal.util.ClassQueue;
  import com.sun.org.apache.bcel.internal.util.SyntheticRepository;
<span class="line-removed">- import jdk.xml.internal.SecuritySupport;</span>
  
  /**
<span class="line-modified">!  * Represents a Java class, i.e., the data structures, constant pool, fields,</span>
<span class="line-modified">!  * methods and commands contained in a Java .class file. See &lt;a</span>
<span class="line-modified">!  * href=&quot;http://docs.oracle.com/javase/specs/&quot;&gt;JVM specification&lt;/a&gt; for</span>
<span class="line-modified">!  * details. The intent of this class is to represent a parsed or otherwise</span>
<span class="line-modified">!  * existing class file. Those interested in programatically generating classes</span>
   * should see the &lt;a href=&quot;../generic/ClassGen.html&quot;&gt;ClassGen&lt;/a&gt; class.
<span class="line-modified">!  *</span>
<span class="line-removed">-  * @version $Id: JavaClass.java 1750227 2016-06-25 21:47:10Z ggregory $</span>
   * @see com.sun.org.apache.bcel.internal.generic.ClassGen
   */
  public class JavaClass extends AccessFlags implements Cloneable, Node, Comparable&lt;JavaClass&gt; {
  
      private String file_name;
      private String package_name;
<span class="line-new-header">--- 24,32 ---</span>
  import java.io.File;
  import java.io.FileOutputStream;
  import java.io.IOException;
  import java.io.OutputStream;
  import java.util.ArrayList;
<span class="line-added">+ import java.util.Objects;</span>
<span class="line-added">+ import java.util.StringTokenizer;</span>
  import java.util.List;
  import java.util.Set;
  import java.util.TreeSet;
  
  import com.sun.org.apache.bcel.internal.Const;
  import com.sun.org.apache.bcel.internal.generic.Type;
  import com.sun.org.apache.bcel.internal.util.BCELComparator;
  import com.sun.org.apache.bcel.internal.util.ClassQueue;
  import com.sun.org.apache.bcel.internal.util.SyntheticRepository;
  
  /**
<span class="line-modified">!  * Represents a Java class, i.e., the data structures, constant pool,</span>
<span class="line-modified">!  * fields, methods and commands contained in a Java .class file.</span>
<span class="line-modified">!  * See &lt;a href=&quot;http://docs.oracle.com/javase/specs/&quot;&gt;JVM specification&lt;/a&gt; for details.</span>
<span class="line-modified">!  * The intent of this class is to represent a parsed or otherwise existing</span>
<span class="line-modified">!  * class file.  Those interested in programatically generating classes</span>
   * should see the &lt;a href=&quot;../generic/ClassGen.html&quot;&gt;ClassGen&lt;/a&gt; class.
<span class="line-modified">! </span>
   * @see com.sun.org.apache.bcel.internal.generic.ClassGen
<span class="line-added">+  * @LastModified: Jan 2020</span>
   */
  public class JavaClass extends AccessFlags implements Cloneable, Node, Comparable&lt;JavaClass&gt; {
  
      private String file_name;
      private String package_name;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 72,33 ***</span>
      private boolean isNested = false;
      private boolean computedNestedTypeStatus = false;
      public static final byte HEAP = 1;
      public static final byte FILE = 2;
      public static final byte ZIP = 3;
  
      private static BCELComparator bcelComparator = new BCELComparator() {
  
          @Override
<span class="line-modified">!         public boolean equals(final Object o1, final Object o2) {</span>
              final JavaClass THIS = (JavaClass) o1;
              final JavaClass THAT = (JavaClass) o2;
<span class="line-modified">!             return THIS.getClassName().equals(THAT.getClassName());</span>
          }
  
          @Override
<span class="line-modified">!         public int hashCode(final Object o) {</span>
              final JavaClass THIS = (JavaClass) o;
              return THIS.getClassName().hashCode();
          }
      };
      /**
<span class="line-modified">!      * In cases where we go ahead and create something, use the default</span>
<span class="line-modified">!      * SyntheticRepository, because we don&#39;t know any better.</span>
       */
      private transient com.sun.org.apache.bcel.internal.util.Repository repository
              = SyntheticRepository.getInstance();
  
      /**
       * Constructor gets all contents as arguments.
       *
       * @param class_name_index Index into constant pool referencing a
       * ConstantClass that represents this class.
<span class="line-new-header">--- 72,37 ---</span>
      private boolean isNested = false;
      private boolean computedNestedTypeStatus = false;
      public static final byte HEAP = 1;
      public static final byte FILE = 2;
      public static final byte ZIP = 3;
<span class="line-added">+     private static final boolean debug = false;</span>
  
      private static BCELComparator bcelComparator = new BCELComparator() {
  
          @Override
<span class="line-modified">!         public boolean equals( final Object o1, final Object o2 ) {</span>
              final JavaClass THIS = (JavaClass) o1;
              final JavaClass THAT = (JavaClass) o2;
<span class="line-modified">!             return Objects.equals(THIS.getClassName(), THAT.getClassName());</span>
          }
  
<span class="line-added">+ </span>
          @Override
<span class="line-modified">!         public int hashCode( final Object o ) {</span>
              final JavaClass THIS = (JavaClass) o;
              return THIS.getClassName().hashCode();
          }
      };
      /**
<span class="line-modified">!      * In cases where we go ahead and create something,</span>
<span class="line-modified">!      * use the default SyntheticRepository, because we</span>
<span class="line-added">+      * don&#39;t know any better.</span>
       */
      private transient com.sun.org.apache.bcel.internal.util.Repository repository
              = SyntheticRepository.getInstance();
  
<span class="line-added">+ </span>
      /**
       * Constructor gets all contents as arguments.
       *
       * @param class_name_index Index into constant pool referencing a
       * ConstantClass that represents this class.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,10 ***</span>
<span class="line-new-header">--- 179,11 ---</span>
              final String str = constant_pool.getConstantString(interfaces[i], Const.CONSTANT_Class);
              interface_names[i] = Utility.compactClassName(str, false);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Constructor gets all contents as arguments.
       *
       * @param class_name_index Class name
       * @param superclass_name_index Superclass name
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,22 ***</span>
              final Method[] methods, final Attribute[] attributes) {
          this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,
                  constant_pool, interfaces, fields, methods, attributes, HEAP);
      }
  
      /**
<span class="line-modified">!      * Called by objects that are traversing the nodes of the tree implicitly</span>
       * defined by the contents of a Java class. I.e., the hierarchy of methods,
       * fields, attributes, etc. spawns a tree of objects.
       *
       * @param v Visitor object
       */
      @Override
<span class="line-modified">!     public void accept(final Visitor v) {</span>
          v.visitJavaClass(this);
      }
  
      /**
       * Dump class to a file.
       *
       * @param file Output file
       * @throws IOException
<span class="line-new-header">--- 203,33 ---</span>
              final Method[] methods, final Attribute[] attributes) {
          this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,
                  constant_pool, interfaces, fields, methods, attributes, HEAP);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Called by objects that are traversing the nodes of the tree implicitely</span>
       * defined by the contents of a Java class. I.e., the hierarchy of methods,
       * fields, attributes, etc. spawns a tree of objects.
       *
       * @param v Visitor object
       */
      @Override
<span class="line-modified">!     public void accept( final Visitor v ) {</span>
          v.visitJavaClass(this);
      }
  
<span class="line-added">+ </span>
<span class="line-added">+     /* Print debug information depending on `JavaClass.debug&#39;</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static void Debug( final String str ) {</span>
<span class="line-added">+         if (debug) {</span>
<span class="line-added">+             System.out.println(str);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
      /**
       * Dump class to a file.
       *
       * @param file Output file
       * @throws IOException
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,30 ***</span>
      public void dump(final File file) throws IOException {
          final String parent = file.getParent();
          if (parent != null) {
              final File dir = new File(parent);
              if (!dir.mkdirs()) { // either was not created or already existed
<span class="line-modified">!                 if (!SecuritySupport.isDirectory(dir)) {</span>
                      throw new IOException(&quot;Could not create the directory &quot; + dir);
                  }
              }
          }
          try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {
              dump(dos);
          }
      }
  
      /**
       * Dump class to a file named file_name.
       *
       * @param _file_name Output file name
       * @throws IOException
       */
<span class="line-modified">!     public void dump(final String _file_name) throws IOException {</span>
          dump(new File(_file_name));
      }
  
      /**
       * @return class in binary format
       */
      public byte[] getBytes() {
          final ByteArrayOutputStream s = new ByteArrayOutputStream();
<span class="line-new-header">--- 237,32 ---</span>
      public void dump(final File file) throws IOException {
          final String parent = file.getParent();
          if (parent != null) {
              final File dir = new File(parent);
              if (!dir.mkdirs()) { // either was not created or already existed
<span class="line-modified">!                 if (!dir.isDirectory()) {</span>
                      throw new IOException(&quot;Could not create the directory &quot; + dir);
                  }
              }
          }
          try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {
              dump(dos);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Dump class to a file named file_name.
       *
       * @param _file_name Output file name
       * @throws IOException
       */
<span class="line-modified">!     public void dump( final String _file_name ) throws IOException {</span>
          dump(new File(_file_name));
      }
  
<span class="line-added">+ </span>
      /**
       * @return class in binary format
       */
      public byte[] getBytes() {
          final ByteArrayOutputStream s = new ByteArrayOutputStream();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,27 ***</span>
              }
          }
          return s.toByteArray();
      }
  
      /**
       * Dump Java class to output stream in binary format.
       *
       * @param file Output stream
       * @throws IOException
       */
<span class="line-modified">!     public void dump(final OutputStream file) throws IOException {</span>
          dump(new DataOutputStream(file));
      }
  
      /**
       * Dump Java class to output stream in binary format.
       *
       * @param file Output stream
       * @throws IOException
       */
<span class="line-modified">!     private void dump(final DataOutputStream file) throws IOException {</span>
          file.writeInt(Const.JVM_CLASSFILE_MAGIC);
          file.writeShort(minor);
          file.writeShort(major);
          constant_pool.dump(file);
          file.writeShort(super.getAccessFlags());
<span class="line-new-header">--- 279,29 ---</span>
              }
          }
          return s.toByteArray();
      }
  
<span class="line-added">+ </span>
      /**
       * Dump Java class to output stream in binary format.
       *
       * @param file Output stream
       * @throws IOException
       */
<span class="line-modified">!     public void dump( final OutputStream file ) throws IOException {</span>
          dump(new DataOutputStream(file));
      }
  
<span class="line-added">+ </span>
      /**
       * Dump Java class to output stream in binary format.
       *
       * @param file Output stream
       * @throws IOException
       */
<span class="line-modified">!     public void dump( final DataOutputStream file ) throws IOException {</span>
          file.writeInt(Const.JVM_CLASSFILE_MAGIC);
          file.writeShort(minor);
          file.writeShort(major);
          constant_pool.dump(file);
          file.writeShort(super.getAccessFlags());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,10 ***</span>
<span class="line-new-header">--- 328,11 ---</span>
              file.writeShort(0);
          }
          file.flush();
      }
  
<span class="line-added">+ </span>
      /**
       * @return Attributes of the class.
       */
      public Attribute[] getAttributes() {
          return attributes;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,230 ***</span>
       */
      public String getClassName() {
          return class_name;
      }
  
      /**
       * @return Package name.
       */
      public String getPackageName() {
          return package_name;
      }
  
      /**
       * @return Class name index.
       */
      public int getClassNameIndex() {
          return class_name_index;
      }
  
      /**
       * @return Constant pool.
       */
      public ConstantPool getConstantPool() {
          return constant_pool;
      }
  
      /**
<span class="line-modified">!      * @return Fields, i.e., variables of the class. Like the JVM spec mandates</span>
<span class="line-modified">!      * for the classfile format, these fields are those specific to this class,</span>
<span class="line-modified">!      * and not those of the superclass or superinterfaces.</span>
       */
      public Field[] getFields() {
          return fields;
      }
  
      /**
       * @return File name of class, aka SourceFile attribute value
       */
      public String getFileName() {
          return file_name;
      }
  
      /**
       * @return Names of implemented interfaces.
       */
      public String[] getInterfaceNames() {
          return interface_names;
      }
  
      /**
       * @return Indices in constant pool of implemented interfaces.
       */
      public int[] getInterfaceIndices() {
          return interfaces;
      }
  
      /**
       * @return Major number of class file version.
       */
      public int getMajor() {
          return major;
      }
  
      /**
       * @return Methods of the class.
       */
      public Method[] getMethods() {
          return methods;
      }
  
      /**
<span class="line-modified">!      * @return A {@link Method} corresponding to java.lang.reflect.Method if any</span>
       */
<span class="line-modified">!     public Method getMethod(final java.lang.reflect.Method m) {</span>
          for (final Method method : methods) {
              if (m.getName().equals(method.getName()) &amp;&amp; (m.getModifiers() == method.getModifiers())
                      &amp;&amp; Type.getSignature(m).equals(method.getSignature())) {
                  return method;
              }
          }
          return null;
      }
  
      /**
       * @return Minor number of class file version.
       */
      public int getMinor() {
          return minor;
      }
  
      /**
       * @return sbsolute path to file where this class was read from
       */
      public String getSourceFileName() {
          return source_file_name;
      }
  
      /**
<span class="line-modified">!      * returns the super class name of this class. In the case that this class</span>
<span class="line-modified">!      * is java.lang.Object, it will return itself (java.lang.Object). This is</span>
<span class="line-modified">!      * probably incorrect but isn&#39;t fixed at this time to not break existing</span>
<span class="line-removed">-      * clients.</span>
       *
       * @return Superclass name.
       */
      public String getSuperclassName() {
          return superclass_name;
      }
  
      /**
       * @return Class name index.
       */
      public int getSuperclassNameIndex() {
          return superclass_name_index;
      }
  
      /**
       * @param attributes .
       */
<span class="line-modified">!     public void setAttributes(final Attribute[] attributes) {</span>
          this.attributes = attributes;
      }
  
      /**
       * @param class_name .
       */
<span class="line-modified">!     public void setClassName(final String class_name) {</span>
          this.class_name = class_name;
      }
  
      /**
       * @param class_name_index .
       */
<span class="line-modified">!     public void setClassNameIndex(final int class_name_index) {</span>
          this.class_name_index = class_name_index;
      }
  
      /**
       * @param constant_pool .
       */
<span class="line-modified">!     public void setConstantPool(final ConstantPool constant_pool) {</span>
          this.constant_pool = constant_pool;
      }
  
      /**
       * @param fields .
       */
<span class="line-modified">!     public void setFields(final Field[] fields) {</span>
          this.fields = fields;
      }
  
      /**
       * Set File name of class, aka SourceFile attribute value
       */
<span class="line-modified">!     public void setFileName(final String file_name) {</span>
          this.file_name = file_name;
      }
  
      /**
       * @param interface_names .
       */
<span class="line-modified">!     public void setInterfaceNames(final String[] interface_names) {</span>
          this.interface_names = interface_names;
      }
  
      /**
       * @param interfaces .
       */
<span class="line-modified">!     public void setInterfaces(final int[] interfaces) {</span>
          this.interfaces = interfaces;
      }
  
      /**
       * @param major .
       */
<span class="line-modified">!     public void setMajor(final int major) {</span>
          this.major = major;
      }
  
      /**
       * @param methods .
       */
<span class="line-modified">!     public void setMethods(final Method[] methods) {</span>
          this.methods = methods;
      }
  
      /**
       * @param minor .
       */
<span class="line-modified">!     public void setMinor(final int minor) {</span>
          this.minor = minor;
      }
  
      /**
       * Set absolute path to file this class was read from.
       */
<span class="line-modified">!     public void setSourceFileName(final String source_file_name) {</span>
          this.source_file_name = source_file_name;
      }
  
      /**
       * @param superclass_name .
       */
<span class="line-modified">!     public void setSuperclassName(final String superclass_name) {</span>
          this.superclass_name = superclass_name;
      }
  
      /**
       * @param superclass_name_index .
       */
<span class="line-modified">!     public void setSuperclassNameIndex(final int superclass_name_index) {</span>
          this.superclass_name_index = superclass_name_index;
      }
  
      /**
       * @return String representing class contents.
       */
      @Override
      public String toString() {
          String access = Utility.accessToString(super.getAccessFlags(), true);
          access = access.isEmpty() ? &quot;&quot; : (access + &quot; &quot;);
          final StringBuilder buf = new StringBuilder(128);
          buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(&quot; &quot;).append(
                  class_name).append(&quot; extends &quot;).append(
<span class="line-modified">!                         Utility.compactClassName(superclass_name, false)).append(&#39;\n&#39;);</span>
          final int size = interfaces.length;
          if (size &gt; 0) {
              buf.append(&quot;implements\t\t&quot;);
              for (int i = 0; i &lt; size; i++) {
                  buf.append(interface_names[i]);
<span class="line-new-header">--- 355,258 ---</span>
       */
      public String getClassName() {
          return class_name;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Package name.
       */
      public String getPackageName() {
          return package_name;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Class name index.
       */
      public int getClassNameIndex() {
          return class_name_index;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Constant pool.
       */
      public ConstantPool getConstantPool() {
          return constant_pool;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * @return Fields, i.e., variables of the class. Like the JVM spec</span>
<span class="line-modified">!      * mandates for the classfile format, these fields are those specific to</span>
<span class="line-modified">!      * this class, and not those of the superclass or superinterfaces.</span>
       */
      public Field[] getFields() {
          return fields;
      }
  
<span class="line-added">+ </span>
      /**
       * @return File name of class, aka SourceFile attribute value
       */
      public String getFileName() {
          return file_name;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Names of implemented interfaces.
       */
      public String[] getInterfaceNames() {
          return interface_names;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Indices in constant pool of implemented interfaces.
       */
      public int[] getInterfaceIndices() {
          return interfaces;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Major number of class file version.
       */
      public int getMajor() {
          return major;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Methods of the class.
       */
      public Method[] getMethods() {
          return methods;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * @return A {@link Method} corresponding to</span>
<span class="line-added">+      * java.lang.reflect.Method if any</span>
       */
<span class="line-modified">!     public Method getMethod( final java.lang.reflect.Method m ) {</span>
          for (final Method method : methods) {
              if (m.getName().equals(method.getName()) &amp;&amp; (m.getModifiers() == method.getModifiers())
                      &amp;&amp; Type.getSignature(m).equals(method.getSignature())) {
                  return method;
              }
          }
          return null;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Minor number of class file version.
       */
      public int getMinor() {
          return minor;
      }
  
<span class="line-added">+ </span>
      /**
       * @return sbsolute path to file where this class was read from
       */
      public String getSourceFileName() {
          return source_file_name;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * returns the super class name of this class. In the case that this class is</span>
<span class="line-modified">!      * java.lang.Object, it will return itself (java.lang.Object). This is probably incorrect</span>
<span class="line-modified">!      * but isn&#39;t fixed at this time to not break existing clients.</span>
       *
       * @return Superclass name.
       */
      public String getSuperclassName() {
          return superclass_name;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Class name index.
       */
      public int getSuperclassNameIndex() {
          return superclass_name_index;
      }
  
      /**
       * @param attributes .
       */
<span class="line-modified">!     public void setAttributes( final Attribute[] attributes ) {</span>
          this.attributes = attributes;
      }
  
<span class="line-added">+ </span>
      /**
       * @param class_name .
       */
<span class="line-modified">!     public void setClassName( final String class_name ) {</span>
          this.class_name = class_name;
      }
  
<span class="line-added">+ </span>
      /**
       * @param class_name_index .
       */
<span class="line-modified">!     public void setClassNameIndex( final int class_name_index ) {</span>
          this.class_name_index = class_name_index;
      }
  
<span class="line-added">+ </span>
      /**
       * @param constant_pool .
       */
<span class="line-modified">!     public void setConstantPool( final ConstantPool constant_pool ) {</span>
          this.constant_pool = constant_pool;
      }
  
<span class="line-added">+ </span>
      /**
       * @param fields .
       */
<span class="line-modified">!     public void setFields( final Field[] fields ) {</span>
          this.fields = fields;
      }
  
<span class="line-added">+ </span>
      /**
       * Set File name of class, aka SourceFile attribute value
       */
<span class="line-modified">!     public void setFileName( final String file_name ) {</span>
          this.file_name = file_name;
      }
  
<span class="line-added">+ </span>
      /**
       * @param interface_names .
       */
<span class="line-modified">!     public void setInterfaceNames( final String[] interface_names ) {</span>
          this.interface_names = interface_names;
      }
  
<span class="line-added">+ </span>
      /**
       * @param interfaces .
       */
<span class="line-modified">!     public void setInterfaces( final int[] interfaces ) {</span>
          this.interfaces = interfaces;
      }
  
<span class="line-added">+ </span>
      /**
       * @param major .
       */
<span class="line-modified">!     public void setMajor( final int major ) {</span>
          this.major = major;
      }
  
<span class="line-added">+ </span>
      /**
       * @param methods .
       */
<span class="line-modified">!     public void setMethods( final Method[] methods ) {</span>
          this.methods = methods;
      }
  
<span class="line-added">+ </span>
      /**
       * @param minor .
       */
<span class="line-modified">!     public void setMinor( final int minor ) {</span>
          this.minor = minor;
      }
  
<span class="line-added">+ </span>
      /**
       * Set absolute path to file this class was read from.
       */
<span class="line-modified">!     public void setSourceFileName( final String source_file_name ) {</span>
          this.source_file_name = source_file_name;
      }
  
<span class="line-added">+ </span>
      /**
       * @param superclass_name .
       */
<span class="line-modified">!     public void setSuperclassName( final String superclass_name ) {</span>
          this.superclass_name = superclass_name;
      }
  
<span class="line-added">+ </span>
      /**
       * @param superclass_name_index .
       */
<span class="line-modified">!     public void setSuperclassNameIndex( final int superclass_name_index ) {</span>
          this.superclass_name_index = superclass_name_index;
      }
  
<span class="line-added">+ </span>
      /**
       * @return String representing class contents.
       */
      @Override
      public String toString() {
          String access = Utility.accessToString(super.getAccessFlags(), true);
          access = access.isEmpty() ? &quot;&quot; : (access + &quot; &quot;);
          final StringBuilder buf = new StringBuilder(128);
          buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(&quot; &quot;).append(
                  class_name).append(&quot; extends &quot;).append(
<span class="line-modified">!                 Utility.compactClassName(superclass_name, false)).append(&#39;\n&#39;);</span>
          final int size = interfaces.length;
          if (size &gt; 0) {
              buf.append(&quot;implements\t\t&quot;);
              for (int i = 0; i &lt; size; i++) {
                  buf.append(interface_names[i]);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 565,11 ***</span>
                      buf.append(&quot;, &quot;);
                  }
              }
              buf.append(&#39;\n&#39;);
          }
<span class="line-modified">!         buf.append(&quot;filename\t\t&quot;).append(file_name).append(&#39;\n&#39;);</span>
          buf.append(&quot;compiled from\t\t&quot;).append(source_file_name).append(&#39;\n&#39;);
          buf.append(&quot;compiler version\t&quot;).append(major).append(&quot;.&quot;).append(minor).append(&#39;\n&#39;);
          buf.append(&quot;access flags\t\t&quot;).append(super.getAccessFlags()).append(&#39;\n&#39;);
          buf.append(&quot;constant pool\t\t&quot;).append(constant_pool.getLength()).append(&quot; entries\n&quot;);
          buf.append(&quot;ACC_SUPER flag\t\t&quot;).append(isSuper()).append(&quot;\n&quot;);
<span class="line-new-header">--- 614,11 ---</span>
                      buf.append(&quot;, &quot;);
                  }
              }
              buf.append(&#39;\n&#39;);
          }
<span class="line-modified">!         buf.append(&quot;file name\t\t&quot;).append(file_name).append(&#39;\n&#39;);</span>
          buf.append(&quot;compiled from\t\t&quot;).append(source_file_name).append(&#39;\n&#39;);
          buf.append(&quot;compiler version\t&quot;).append(major).append(&quot;.&quot;).append(minor).append(&#39;\n&#39;);
          buf.append(&quot;access flags\t\t&quot;).append(super.getAccessFlags()).append(&#39;\n&#39;);
          buf.append(&quot;constant pool\t\t&quot;).append(constant_pool.getLength()).append(&quot; entries\n&quot;);
          buf.append(&quot;ACC_SUPER flag\t\t&quot;).append(isSuper()).append(&quot;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 578,11 ***</span>
              for (final Attribute attribute : attributes) {
                  buf.append(indent(attribute));
              }
          }
          final AnnotationEntry[] annotations = getAnnotationEntries();
<span class="line-modified">!         if (annotations != null &amp;&amp; annotations.length &gt; 0) {</span>
              buf.append(&quot;\nAnnotation(s):\n&quot;);
              for (final AnnotationEntry annotation : annotations) {
                  buf.append(indent(annotation));
              }
          }
<span class="line-new-header">--- 627,11 ---</span>
              for (final Attribute attribute : attributes) {
                  buf.append(indent(attribute));
              }
          }
          final AnnotationEntry[] annotations = getAnnotationEntries();
<span class="line-modified">!         if (annotations!=null &amp;&amp; annotations.length&gt;0) {</span>
              buf.append(&quot;\nAnnotation(s):\n&quot;);
              for (final AnnotationEntry annotation : annotations) {
                  buf.append(indent(annotation));
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 599,19 ***</span>
              }
          }
          return buf.toString();
      }
  
<span class="line-modified">!     private static String indent(final Object obj) {</span>
          final StringTokenizer tok = new StringTokenizer(obj.toString(), &quot;\n&quot;);
          final StringBuilder buf = new StringBuilder();
          while (tok.hasMoreTokens()) {
              buf.append(&quot;\t&quot;).append(tok.nextToken()).append(&quot;\n&quot;);
          }
          return buf.toString();
      }
  
      /**
       * @return deep copy of this class
       */
      public JavaClass copy() {
          JavaClass c = null;
<span class="line-new-header">--- 648,21 ---</span>
              }
          }
          return buf.toString();
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private static String indent( final Object obj ) {</span>
          final StringTokenizer tok = new StringTokenizer(obj.toString(), &quot;\n&quot;);
          final StringBuilder buf = new StringBuilder();
          while (tok.hasMoreTokens()) {
              buf.append(&quot;\t&quot;).append(tok.nextToken()).append(&quot;\n&quot;);
          }
          return buf.toString();
      }
  
<span class="line-added">+ </span>
      /**
       * @return deep copy of this class
       */
      public JavaClass copy() {
          JavaClass c = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 636,14 ***</span>
<span class="line-new-header">--- 687,16 ---</span>
              // TODO should this throw?
          }
          return c;
      }
  
<span class="line-added">+ </span>
      public final boolean isSuper() {
          return (super.getAccessFlags() &amp; Const.ACC_SUPER) != 0;
      }
  
<span class="line-added">+ </span>
      public final boolean isClass() {
          return (super.getAccessFlags() &amp; Const.ACC_INTERFACE) == 0;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 665,66 ***</span>
      private void computeNestedTypeStatus() {
          if (computedNestedTypeStatus) {
              return;
          }
          for (final Attribute attribute : this.attributes) {
<span class="line-modified">!             if (attribute instanceof InnerClasses) {</span>
<span class="line-modified">!                 final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();</span>
<span class="line-modified">!                 for (final InnerClass innerClasse : innerClasses) {</span>
<span class="line-modified">!                     boolean innerClassAttributeRefersToMe = false;</span>
<span class="line-modified">!                     String inner_class_name = constant_pool.getConstantString(innerClasse.getInnerClassIndex(),</span>
<span class="line-modified">!                             Const.CONSTANT_Class);</span>
<span class="line-modified">!                     inner_class_name = Utility.compactClassName(inner_class_name);</span>
<span class="line-modified">!                     if (inner_class_name.equals(getClassName())) {</span>
<span class="line-modified">!                         innerClassAttributeRefersToMe = true;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     if (innerClassAttributeRefersToMe) {</span>
<span class="line-modified">!                         this.isNested = true;</span>
<span class="line-modified">!                         if (innerClasse.getInnerNameIndex() == 0) {</span>
<span class="line-modified">!                             this.isAnonymous = true;</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
          }
          this.computedNestedTypeStatus = true;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return returns either HEAP (generated), FILE, or ZIP</span>
       */
      public final byte getSource() {
          return source;
      }
  
      /**
<span class="line-modified">!      * ******************* New repository functionality ********************</span>
<span class="line-modified">!      */</span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Gets the ClassRepository which holds its definition. By default this is</span>
<span class="line-removed">-      * the same as SyntheticRepository.getInstance();</span>
       */
      public com.sun.org.apache.bcel.internal.util.Repository getRepository() {
          return repository;
      }
  
      /**
<span class="line-modified">!      * Sets the ClassRepository which loaded the JavaClass. Should be called</span>
<span class="line-modified">!      * immediately after parsing is done.</span>
       */
<span class="line-modified">!     public void setRepository(final com.sun.org.apache.bcel.internal.util.Repository repository) {</span>
          this.repository = repository;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Equivalent to runtime &quot;instanceof&quot; operator.</span>
       *
       * @return true if this JavaClass is derived from the super class
<span class="line-modified">!      * @throws ClassNotFoundException if superclasses or superinterfaces of this</span>
<span class="line-modified">!      * object can&#39;t be found</span>
       */
<span class="line-modified">!     public final boolean instanceOf(final JavaClass super_class) throws ClassNotFoundException {</span>
          if (this.equals(super_class)) {
              return true;
          }
          final JavaClass[] super_classes = getSuperClasses();
          for (final JavaClass super_classe : super_classes) {
<span class="line-new-header">--- 718,66 ---</span>
      private void computeNestedTypeStatus() {
          if (computedNestedTypeStatus) {
              return;
          }
          for (final Attribute attribute : this.attributes) {
<span class="line-modified">!               if (attribute instanceof InnerClasses) {</span>
<span class="line-modified">!                   final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();</span>
<span class="line-modified">!                   for (final InnerClass innerClasse : innerClasses) {</span>
<span class="line-modified">!                       boolean innerClassAttributeRefersToMe = false;</span>
<span class="line-modified">!                       String inner_class_name = constant_pool.getConstantString(innerClasse.getInnerClassIndex(),</span>
<span class="line-modified">!                                  Const.CONSTANT_Class);</span>
<span class="line-modified">!                       inner_class_name = Utility.compactClassName(inner_class_name, false);</span>
<span class="line-modified">!                       if (inner_class_name.equals(getClassName())) {</span>
<span class="line-modified">!                           innerClassAttributeRefersToMe = true;</span>
<span class="line-modified">!                       }</span>
<span class="line-modified">!                       if (innerClassAttributeRefersToMe) {</span>
<span class="line-modified">!                           this.isNested = true;</span>
<span class="line-modified">!                           if (innerClasse.getInnerNameIndex() == 0) {</span>
<span class="line-modified">!                               this.isAnonymous = true;</span>
<span class="line-modified">!                           }</span>
<span class="line-modified">!                       }</span>
<span class="line-modified">!                   }</span>
<span class="line-modified">!               }</span>
          }
          this.computedNestedTypeStatus = true;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return returns either HEAP (generated), FILE, or ZIP</span>
       */
      public final byte getSource() {
          return source;
      }
  
<span class="line-added">+ </span>
<span class="line-added">+     /********************* New repository functionality *********************/</span>
      /**
<span class="line-modified">!      * Gets the ClassRepository which holds its definition. By default</span>
<span class="line-modified">!      * this is the same as SyntheticRepository.getInstance();</span>
       */
      public com.sun.org.apache.bcel.internal.util.Repository getRepository() {
          return repository;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Sets the ClassRepository which loaded the JavaClass.</span>
<span class="line-modified">!      * Should be called immediately after parsing is done.</span>
       */
<span class="line-modified">!     public void setRepository( final com.sun.org.apache.bcel.internal.util.Repository repository ) { // TODO make protected?</span>
          this.repository = repository;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Equivalent to runtime &quot;instanceof&quot; operator.</span>
       *
       * @return true if this JavaClass is derived from the super class
<span class="line-modified">!      * @throws ClassNotFoundException if superclasses or superinterfaces</span>
<span class="line-modified">!      *   of this object can&#39;t be found</span>
       */
<span class="line-modified">!     public final boolean instanceOf( final JavaClass super_class ) throws ClassNotFoundException {</span>
          if (this.equals(super_class)) {
              return true;
          }
          final JavaClass[] super_classes = getSuperClasses();
          for (final JavaClass super_classe : super_classes) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 736,16 ***</span>
              return implementationOf(super_class);
          }
          return false;
      }
  
      /**
       * @return true, if this class is an implementation of interface inter
<span class="line-modified">!      * @throws ClassNotFoundException if superclasses or superinterfaces of this</span>
<span class="line-modified">!      * class can&#39;t be found</span>
       */
<span class="line-modified">!     public boolean implementationOf(final JavaClass inter) throws ClassNotFoundException {</span>
          if (!inter.isInterface()) {
              throw new IllegalArgumentException(inter.getClassName() + &quot; is no interface&quot;);
          }
          if (this.equals(inter)) {
              return true;
<span class="line-new-header">--- 789,17 ---</span>
              return implementationOf(super_class);
          }
          return false;
      }
  
<span class="line-added">+ </span>
      /**
       * @return true, if this class is an implementation of interface inter
<span class="line-modified">!      * @throws ClassNotFoundException if superclasses or superinterfaces</span>
<span class="line-modified">!      *   of this class can&#39;t be found</span>
       */
<span class="line-modified">!     public boolean implementationOf( final JavaClass inter ) throws ClassNotFoundException {</span>
          if (!inter.isInterface()) {
              throw new IllegalArgumentException(inter.getClassName() + &quot; is no interface&quot;);
          }
          if (this.equals(inter)) {
              return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 757,22 ***</span>
              }
          }
          return false;
      }
  
      /**
<span class="line-modified">!      * @return the superclass for this JavaClass object, or null if this is</span>
<span class="line-modified">!      * java.lang.Object</span>
       * @throws ClassNotFoundException if the superclass can&#39;t be found
       */
      public JavaClass getSuperClass() throws ClassNotFoundException {
          if (&quot;java.lang.Object&quot;.equals(getClassName())) {
              return null;
          }
          return repository.loadClass(getSuperclassName());
      }
  
      /**
       * @return list of super classes of this class in ascending order, i.e.,
       * java.lang.Object is always the last element
       * @throws ClassNotFoundException if any of the superclasses can&#39;t be found
       */
<span class="line-new-header">--- 811,24 ---</span>
              }
          }
          return false;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * @return the superclass for this JavaClass object, or null if this</span>
<span class="line-modified">!      * is java.lang.Object</span>
       * @throws ClassNotFoundException if the superclass can&#39;t be found
       */
      public JavaClass getSuperClass() throws ClassNotFoundException {
          if (&quot;java.lang.Object&quot;.equals(getClassName())) {
              return null;
          }
          return repository.loadClass(getSuperclassName());
      }
  
<span class="line-added">+ </span>
      /**
       * @return list of super classes of this class in ascending order, i.e.,
       * java.lang.Object is always the last element
       * @throws ClassNotFoundException if any of the superclasses can&#39;t be found
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 783,10 ***</span>
<span class="line-new-header">--- 839,11 ---</span>
              allSuperClasses.add(clazz);
          }
          return allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);
      }
  
<span class="line-added">+ </span>
      /**
       * Get interfaces directly implemented by this JavaClass.
       */
      public JavaClass[] getInterfaces() throws ClassNotFoundException {
          final String[] _interfaces = getInterfaceNames();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 795,10 ***</span>
<span class="line-new-header">--- 852,11 ---</span>
              classes[i] = repository.loadClass(_interfaces[i]);
          }
          return classes;
      }
  
<span class="line-added">+ </span>
      /**
       * Get all interfaces implemented by this JavaClass (transitively).
       */
      public JavaClass[] getAllInterfaces() throws ClassNotFoundException {
          final ClassQueue queue = new ClassQueue();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 820,49 ***</span>
              }
          }
          return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);
      }
  
      /**
       * @return Comparison strategy object
       */
      public static BCELComparator getComparator() {
          return bcelComparator;
      }
  
      /**
       * @param comparator Comparison strategy object
       */
<span class="line-modified">!     public static void setComparator(final BCELComparator comparator) {</span>
          bcelComparator = comparator;
      }
  
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">!      * JavaClass objects are said to be equal when their class names are equal.</span>
       *
       * @see java.lang.Object#equals(java.lang.Object)
       */
      @Override
<span class="line-modified">!     public boolean equals(final Object obj) {</span>
          return bcelComparator.equals(this, obj);
      }
  
      /**
<span class="line-modified">!      * Return the natural ordering of two JavaClasses. This ordering is based on</span>
<span class="line-modified">!      * the class name</span>
<span class="line-removed">-      *</span>
       * @since 6.0
       */
      @Override
<span class="line-modified">!     public int compareTo(final JavaClass obj) {</span>
          return getClassName().compareTo(obj.getClassName());
      }
  
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">!      * return the hashcode of the class name.</span>
       *
       * @see java.lang.Object#hashCode()
       */
      @Override
      public int hashCode() {
<span class="line-new-header">--- 878,54 ---</span>
              }
          }
          return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);
      }
  
<span class="line-added">+ </span>
      /**
       * @return Comparison strategy object
       */
      public static BCELComparator getComparator() {
          return bcelComparator;
      }
  
<span class="line-added">+ </span>
      /**
       * @param comparator Comparison strategy object
       */
<span class="line-modified">!     public static void setComparator( final BCELComparator comparator ) {</span>
          bcelComparator = comparator;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">!      * By default two JavaClass objects are said to be equal when</span>
<span class="line-added">+      * their class names are equal.</span>
       *
       * @see java.lang.Object#equals(java.lang.Object)
       */
      @Override
<span class="line-modified">!     public boolean equals( final Object obj ) {</span>
          return bcelComparator.equals(this, obj);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return the natural ordering of two JavaClasses.</span>
<span class="line-modified">!      * This ordering is based on the class name</span>
       * @since 6.0
       */
      @Override
<span class="line-modified">!     public int compareTo( final JavaClass obj ) {</span>
          return getClassName().compareTo(obj.getClassName());
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">!      * By default return the hashcode of the class name.</span>
       *
       * @see java.lang.Object#hashCode()
       */
      @Override
      public int hashCode() {
</pre>
<center><a href="InnerClasses.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LineNumber.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
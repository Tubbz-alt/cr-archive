diff a/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/identity/XPathMatcher.java b/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/identity/XPathMatcher.java
--- a/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/identity/XPathMatcher.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/identity/XPathMatcher.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -35,10 +35,11 @@
  * XPath matcher.
  *
  * @xerces.internal
  *
  * @author Andy Clark, IBM
+ * @LastModified: July 2019
  *
  */
 public class XPathMatcher {
 
     //
@@ -86,29 +87,29 @@
     //
     // Data
     //
 
     /** XPath location path. */
-    private XPath.LocationPath[] fLocationPaths;
+    private final XPath.LocationPath[] fLocationPaths;
 
     /** True if XPath has been matched. */
-    private int[] fMatched;
+    private final int[] fMatched;
 
     /** The matching string. */
     protected Object fMatchedString;
 
     /** Integer stack of step indexes. */
-    private IntStack[] fStepIndexes;
+    private final IntStack[] fStepIndexes;
 
     /** Current step. */
-    private int[] fCurrentStep;
+    private final int[] fCurrentStep;
 
     /**
      * No match depth. The value of this field will be zero while
      * matching is successful for the given xpath expression.
      */
-    private int [] fNoMatchDepth;
+    private final int [] fNoMatchDepth;
 
     final QName fQName = new QName();
 
 
     //
@@ -205,19 +206,19 @@
      * @param element    The name of the element.
      * @param attributes The element attributes.
      *
      * @throws SAXException Thrown by handler to signal an error.
      */
-    public void startElement(QName element, XMLAttributes attributes){
+    public void startElement(QName element, XMLAttributes attributes) {
         if (DEBUG_METHODS2) {
             System.out.println(toString()+"#startElement("+
                                "element={"+element+"},"+
                                "attributes=..."+attributes+
                                ")");
         }
 
-        for(int i = 0; i < fLocationPaths.length; i++) {
+        for (int i = 0; i < fLocationPaths.length; i++) {
             // push context
             int startStep = fCurrentStep[i];
             fStepIndexes[i].push(startStep);
 
             // try next xpath, if not matching
@@ -282,33 +283,32 @@
                 XPath.Step step = steps[fCurrentStep[i]];
                 XPath.NodeTest nodeTest = step.nodeTest;
                 if (DEBUG_MATCH) {
                     System.out.println(toString()+" [CHILD] before");
                 }
-                if (nodeTest.type == XPath.NodeTest.QNAME) {
-                    if (!nodeTest.name.equals(element)) {
-                        if(fCurrentStep[i] > descendantStep) {
-                            fCurrentStep[i] = descendantStep;
-                            continue;
-                        }
-                        fNoMatchDepth[i]++;
-                        if (DEBUG_MATCH) {
-                            System.out.println(toString()+" [CHILD] after NO MATCH");
-                        }
+                if (!matches(nodeTest, element)) {
+                    if (fCurrentStep[i] > descendantStep) {
+                        fCurrentStep[i] = descendantStep;
                         continue;
                     }
+                    fNoMatchDepth[i]++;
+                    if (DEBUG_MATCH) {
+                        System.out.println(toString()+" [CHILD] after NO MATCH");
+                    }
+                    continue;
                 }
                 fCurrentStep[i]++;
                 if (DEBUG_MATCH) {
                     System.out.println(toString()+" [CHILD] after MATCHED!");
                 }
             }
             if (fCurrentStep[i] == steps.length) {
-                if(sawDescendant) {
+                if (sawDescendant) {
                     fCurrentStep[i] = descendantStep;
                     fMatched[i] = MATCHED_DESCENDANT;
-                } else {
+                }
+                else {
                     fMatched[i] = MATCHED;
                 }
                 continue;
             }
 
@@ -322,12 +322,11 @@
                 if (attrCount > 0) {
                     XPath.NodeTest nodeTest = steps[fCurrentStep[i]].nodeTest;
 
                     for (int aIndex = 0; aIndex < attrCount; aIndex++) {
                         attributes.getName(aIndex, fQName);
-                        if (nodeTest.type != XPath.NodeTest.QNAME ||
-                            nodeTest.name.equals(fQName)) {
+                        if (matches(nodeTest, fQName)) {
                             fCurrentStep[i]++;
                             if (fCurrentStep[i] == steps.length) {
                                 fMatched[i] = MATCHED_ATTRIBUTE;
                                 int j=0;
                                 for(; j<i && ((fMatched[j] & MATCHED) != MATCHED); j++);
@@ -382,25 +381,28 @@
         if (DEBUG_METHODS2) {
             System.out.println(toString()+"#endElement("+
                                "element={"+element+"},"+
                                ")");
         }
-        for(int i = 0; i<fLocationPaths.length; i++) {
+        for (int i = 0; i < fLocationPaths.length; i++) {
             // go back a step
             fCurrentStep[i] = fStepIndexes[i].pop();
 
             // don't do anything, if not matching
             if (fNoMatchDepth[i] > 0) {
                 fNoMatchDepth[i]--;
             }
 
             // signal match, if appropriate
             else {
-                int j=0;
-                for(; j<i && ((fMatched[j] & MATCHED) != MATCHED); j++);
-                if ((j<i) || (fMatched[j] == 0) ||
-                        ((fMatched[j] & MATCHED_ATTRIBUTE) == MATCHED_ATTRIBUTE)) {
+                int j = 0;
+                for(; j < i && ((fMatched[j] & MATCHED) != MATCHED); j++);
+                if ((j < i) || (fMatched[j] == 0)) {
+                    continue;
+                }
+                if ((fMatched[j] & MATCHED_ATTRIBUTE) == MATCHED_ATTRIBUTE) {
+                    fMatched[i] = 0;
                     continue;
                 }
                 // only certain kinds of matchers actually
                 // match element content.  This permits
                 // them a way to override this to do nothing
@@ -474,10 +476,22 @@
             }
         }
         return str.toString();
     } // normalize(String):String
 
+    /** Returns true if the given QName matches the node test. **/
+    private static boolean matches(XPath.NodeTest nodeTest, QName value) {
+        if (nodeTest.type == XPath.NodeTest.QNAME) {
+            return nodeTest.name.equals(value);
+        }
+        if (nodeTest.type == XPath.NodeTest.NAMESPACE) {
+            return nodeTest.name.uri == value.uri;
+        }
+        // XPath.NodeTest.WILDCARD
+        return true;
+    } // matches(XPath.NodeTest,QName):boolean
+
     //
     // MAIN
     //
 
     // NOTE: The main of this class is here for debugging purposes.

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="XMLDocumentFragmentScannerImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="dv/xs/TypeValidator.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,10 ***</span>
<span class="line-new-header">--- 20,11 ---</span>
  
  package com.sun.org.apache.xerces.internal.impl ;
  
  import com.sun.org.apache.xerces.internal.impl.io.ASCIIReader;
  import com.sun.org.apache.xerces.internal.impl.io.UCSReader;
<span class="line-added">+ import com.sun.org.apache.xerces.internal.impl.io.UTF16Reader;</span>
  import com.sun.org.apache.xerces.internal.impl.io.UTF8Reader;
  import com.sun.org.apache.xerces.internal.impl.msg.XMLMessageFormatter;
  import com.sun.org.apache.xerces.internal.impl.validation.ValidationManager;
  import com.sun.org.apache.xerces.internal.util.*;
  import com.sun.org.apache.xerces.internal.util.URI;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,11 ***</span>
   * @author Andy Clark, IBM
   * @author Arnaud  Le Hors, IBM
   * @author K.Venugopal SUN Microsystems
   * @author Neeraj Bajaj SUN Microsystems
   * @author Sunitha Reddy SUN Microsystems
<span class="line-modified">!  * @LastModified: Nov 2018</span>
   */
  public class XMLEntityManager implements XMLComponent, XMLEntityResolver {
  
      //
      // Constants
<span class="line-new-header">--- 88,11 ---</span>
   * @author Andy Clark, IBM
   * @author Arnaud  Le Hors, IBM
   * @author K.Venugopal SUN Microsystems
   * @author Neeraj Bajaj SUN Microsystems
   * @author Sunitha Reddy SUN Microsystems
<span class="line-modified">!  * @LastModified: Apr 2019</span>
   */
  public class XMLEntityManager implements XMLComponent, XMLEntityResolver {
  
      //
      // Constants
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,13 ***</span>
      private final XMLResourceIdentifierImpl fResourceIdentifier = new XMLResourceIdentifierImpl();
  
      /** Augmentations for entities. */
      private final Augmentations fEntityAugs = new AugmentationsImpl();
  
<span class="line-removed">-     /** Pool of character buffers. */</span>
<span class="line-removed">-     private CharacterBufferPool fBufferPool = new CharacterBufferPool(fBufferSize, DEFAULT_INTERNAL_BUFFER_SIZE);</span>
<span class="line-removed">- </span>
      /** indicate whether Catalog should be used for resolving external resources */
      private boolean fUseCatalog = true;
      CatalogFeatures fCatalogFeatures;
      CatalogResolver fCatalogResolver;
  
<span class="line-new-header">--- 411,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 692,54 ***</span>
                      }
                  }
              }
  
              // wrap this stream in RewindableInputStream
<span class="line-modified">!             stream = new RewindableInputStream(stream);</span>
  
              // perform auto-detect of encoding if necessary
              if (encoding == null) {
                  // read first four bytes and determine encoding
                  final byte[] b4 = new byte[4];
                  int count = 0;
                  for (; count&lt;4; count++ ) {
<span class="line-modified">!                     b4[count] = (byte)stream.read();</span>
                  }
                  if (count == 4) {
<span class="line-modified">!                     Object [] encodingDesc = getEncodingName(b4, count);</span>
<span class="line-modified">!                     encoding = (String)(encodingDesc[0]);</span>
<span class="line-modified">!                     isBigEndian = (Boolean)(encodingDesc[1]);</span>
<span class="line-modified">! </span>
                      stream.reset();
<span class="line-modified">!                     // Special case UTF-8 files with BOM created by Microsoft</span>
<span class="line-modified">!                     // tools. It&#39;s more efficient to consume the BOM than make</span>
<span class="line-modified">!                     // the reader perform extra checks. -Ac</span>
<span class="line-modified">!                     if (count &gt; 2 &amp;&amp; encoding.equals(&quot;UTF-8&quot;)) {</span>
<span class="line-modified">!                         int b0 = b4[0] &amp; 0xFF;</span>
<span class="line-modified">!                         int b1 = b4[1] &amp; 0xFF;</span>
<span class="line-removed">-                         int b2 = b4[2] &amp; 0xFF;</span>
<span class="line-removed">-                         if (b0 == 0xEF &amp;&amp; b1 == 0xBB &amp;&amp; b2 == 0xBF) {</span>
<span class="line-removed">-                             // ignore first three bytes...</span>
                              stream.skip(3);
                          }
                      }
<span class="line-modified">!                     reader = createReader(stream, encoding, isBigEndian);</span>
                  } else {
                      reader = createReader(stream, encoding, isBigEndian);
                  }
              }
  
              // use specified encoding
              else {
                  encoding = encoding.toUpperCase(Locale.ENGLISH);
  
                  // If encoding is UTF-8, consume BOM if one is present.
<span class="line-modified">!                 if (encoding.equals(&quot;UTF-8&quot;)) {</span>
                      final int[] b3 = new int[3];
                      int count = 0;
                      for (; count &lt; 3; ++count) {
<span class="line-modified">!                         b3[count] = stream.read();</span>
                          if (b3[count] == -1)
                              break;
                      }
                      if (count == 3) {
                          if (b3[0] != 0xEF || b3[1] != 0xBB || b3[2] != 0xBF) {
<span class="line-new-header">--- 690,58 ---</span>
                      }
                  }
              }
  
              // wrap this stream in RewindableInputStream
<span class="line-modified">!             RewindableInputStream rewindableStream = new RewindableInputStream(stream);</span>
<span class="line-added">+             stream = rewindableStream;</span>
  
              // perform auto-detect of encoding if necessary
              if (encoding == null) {
                  // read first four bytes and determine encoding
                  final byte[] b4 = new byte[4];
                  int count = 0;
                  for (; count&lt;4; count++ ) {
<span class="line-modified">!                     b4[count] = (byte)rewindableStream.readAndBuffer();</span>
                  }
                  if (count == 4) {
<span class="line-modified">!                     final EncodingInfo info = getEncodingInfo(b4, count);</span>
<span class="line-modified">!                     encoding = info.autoDetectedEncoding;</span>
<span class="line-modified">!                     final String readerEncoding = info.readerEncoding;</span>
<span class="line-modified">!                     isBigEndian = info.isBigEndian;</span>
                      stream.reset();
<span class="line-modified">!                     if (info.hasBOM) {</span>
<span class="line-modified">!                         // Special case UTF-8 files with BOM created by Microsoft</span>
<span class="line-modified">!                         // tools. It&#39;s more efficient to consume the BOM than make</span>
<span class="line-modified">!                         // the reader perform extra checks. -Ac</span>
<span class="line-modified">!                         if (EncodingInfo.STR_UTF8.equals(readerEncoding)) {</span>
<span class="line-modified">!                             // UTF-8 BOM: 0xEF 0xBB 0xBF</span>
                              stream.skip(3);
                          }
<span class="line-added">+                         // It&#39;s also more efficient to consume the UTF-16 BOM.</span>
<span class="line-added">+                         else if (EncodingInfo.STR_UTF16.equals(readerEncoding)) {</span>
<span class="line-added">+                             // UTF-16 BE BOM: 0xFE 0xFF</span>
<span class="line-added">+                             // UTF-16 LE BOM: 0xFF 0xFE</span>
<span class="line-added">+                             stream.skip(2);</span>
<span class="line-added">+                         }</span>
                      }
<span class="line-modified">!                     reader = createReader(stream, readerEncoding, isBigEndian);</span>
                  } else {
                      reader = createReader(stream, encoding, isBigEndian);
                  }
              }
  
              // use specified encoding
              else {
                  encoding = encoding.toUpperCase(Locale.ENGLISH);
  
                  // If encoding is UTF-8, consume BOM if one is present.
<span class="line-modified">!                 if (EncodingInfo.STR_UTF8.equals(encoding)) {</span>
                      final int[] b3 = new int[3];
                      int count = 0;
                      for (; count &lt; 3; ++count) {
<span class="line-modified">!                         b3[count] = rewindableStream.readAndBuffer();</span>
                          if (b3[count] == -1)
                              break;
                      }
                      if (count == 3) {
                          if (b3[0] != 0xEF || b3[1] != 0xBB || b3[2] != 0xBF) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 748,60 ***</span>
                          }
                      } else {
                          stream.reset();
                      }
                  }
<span class="line-modified">!                 // If encoding is UTF-16, we still need to read the first four bytes</span>
<span class="line-modified">!                 // in order to discover the byte order.</span>
<span class="line-modified">!                 else if (encoding.equals(&quot;UTF-16&quot;)) {</span>
                      final int[] b4 = new int[4];
                      int count = 0;
                      for (; count &lt; 4; ++count) {
<span class="line-modified">!                         b4[count] = stream.read();</span>
                          if (b4[count] == -1)
                              break;
                      }
                      stream.reset();
<span class="line-removed">- </span>
<span class="line-removed">-                     String utf16Encoding = &quot;UTF-16&quot;;</span>
                      if (count &gt;= 2) {
                          final int b0 = b4[0];
                          final int b1 = b4[1];
                          if (b0 == 0xFE &amp;&amp; b1 == 0xFF) {
                              // UTF-16, big-endian
<span class="line-removed">-                             utf16Encoding = &quot;UTF-16BE&quot;;</span>
                              isBigEndian = Boolean.TRUE;
                          }
                          else if (b0 == 0xFF &amp;&amp; b1 == 0xFE) {
                              // UTF-16, little-endian
<span class="line-removed">-                             utf16Encoding = &quot;UTF-16LE&quot;;</span>
                              isBigEndian = Boolean.FALSE;
                          }
                          else if (count == 4) {
                              final int b2 = b4[2];
                              final int b3 = b4[3];
                              if (b0 == 0x00 &amp;&amp; b1 == 0x3C &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x3F) {
                                  // UTF-16, big-endian, no BOM
<span class="line-removed">-                                 utf16Encoding = &quot;UTF-16BE&quot;;</span>
                                  isBigEndian = Boolean.TRUE;
                              }
                              if (b0 == 0x3C &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x3F &amp;&amp; b3 == 0x00) {
                                  // UTF-16, little-endian, no BOM
<span class="line-removed">-                                 utf16Encoding = &quot;UTF-16LE&quot;;</span>
                                  isBigEndian = Boolean.FALSE;
                              }
                          }
                      }
<span class="line-removed">-                     reader = createReader(stream, utf16Encoding, isBigEndian);</span>
                  }
                  // If encoding is UCS-4, we still need to read the first four bytes
                  // in order to discover the byte order.
<span class="line-modified">!                 else if (encoding.equals(&quot;ISO-10646-UCS-4&quot;)) {</span>
                      final int[] b4 = new int[4];
                      int count = 0;
                      for (; count &lt; 4; ++count) {
<span class="line-modified">!                         b4[count] = stream.read();</span>
                          if (b4[count] == -1)
                              break;
                      }
                      stream.reset();
  
<span class="line-new-header">--- 750,55 ---</span>
                          }
                      } else {
                          stream.reset();
                      }
                  }
<span class="line-modified">!                 // If encoding is UTF-16, we still need to read the first</span>
<span class="line-modified">!                 // four bytes, in order to discover the byte order.</span>
<span class="line-modified">!                 else if (EncodingInfo.STR_UTF16.equals(encoding)) {</span>
                      final int[] b4 = new int[4];
                      int count = 0;
                      for (; count &lt; 4; ++count) {
<span class="line-modified">!                         b4[count] = rewindableStream.readAndBuffer();</span>
                          if (b4[count] == -1)
                              break;
                      }
                      stream.reset();
                      if (count &gt;= 2) {
                          final int b0 = b4[0];
                          final int b1 = b4[1];
                          if (b0 == 0xFE &amp;&amp; b1 == 0xFF) {
                              // UTF-16, big-endian
                              isBigEndian = Boolean.TRUE;
<span class="line-added">+                             stream.skip(2);</span>
                          }
                          else if (b0 == 0xFF &amp;&amp; b1 == 0xFE) {
                              // UTF-16, little-endian
                              isBigEndian = Boolean.FALSE;
<span class="line-added">+                             stream.skip(2);</span>
                          }
                          else if (count == 4) {
                              final int b2 = b4[2];
                              final int b3 = b4[3];
                              if (b0 == 0x00 &amp;&amp; b1 == 0x3C &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x3F) {
                                  // UTF-16, big-endian, no BOM
                                  isBigEndian = Boolean.TRUE;
                              }
                              if (b0 == 0x3C &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x3F &amp;&amp; b3 == 0x00) {
                                  // UTF-16, little-endian, no BOM
                                  isBigEndian = Boolean.FALSE;
                              }
                          }
                      }
                  }
                  // If encoding is UCS-4, we still need to read the first four bytes
                  // in order to discover the byte order.
<span class="line-modified">!                 else if (EncodingInfo.STR_UCS4.equals(encoding)) {</span>
                      final int[] b4 = new int[4];
                      int count = 0;
                      for (; count &lt; 4; ++count) {
<span class="line-modified">!                         b4[count] = rewindableStream.readAndBuffer();</span>
                          if (b4[count] == -1)
                              break;
                      }
                      stream.reset();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 817,15 ***</span>
                          }
                      }
                  }
                  // If encoding is UCS-2, we still need to read the first four bytes
                  // in order to discover the byte order.
<span class="line-modified">!                 else if (encoding.equals(&quot;ISO-10646-UCS-2&quot;)) {</span>
                      final int[] b4 = new int[4];
                      int count = 0;
                      for (; count &lt; 4; ++count) {
<span class="line-modified">!                         b4[count] = stream.read();</span>
                          if (b4[count] == -1)
                              break;
                      }
                      stream.reset();
  
<span class="line-new-header">--- 814,15 ---</span>
                          }
                      }
                  }
                  // If encoding is UCS-2, we still need to read the first four bytes
                  // in order to discover the byte order.
<span class="line-modified">!                 else if (EncodingInfo.STR_UCS2.equals(encoding)) {</span>
                      final int[] b4 = new int[4];
                      int count = 0;
                      for (; count &lt; 4; ++count) {
<span class="line-modified">!                         b4[count] = rewindableStream.readAndBuffer();</span>
                          if (b4[count] == -1)
                              break;
                      }
                      stream.reset();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1796,11 ***</span>
                  Integer bufferSize = (Integer)value;
                  if (bufferSize != null &amp;&amp;
                      bufferSize.intValue() &gt; DEFAULT_XMLDECL_BUFFER_SIZE) {
                      fBufferSize = bufferSize.intValue();
                      fEntityScanner.setBufferSize(fBufferSize);
<span class="line-removed">-                     fBufferPool.setExternalBufferSize(fBufferSize);</span>
                  }
              }
              if (suffixLength == Constants.SECURITY_MANAGER_PROPERTY.length() &amp;&amp;
                  propertyId.endsWith(Constants.SECURITY_MANAGER_PROPERTY)) {
                  fSecurityManager = (XMLSecurityManager)value;
<span class="line-new-header">--- 1793,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2423,88 ***</span>
       * Returns the IANA encoding name that is auto-detected from
       * the bytes specified, with the endian-ness of that encoding where appropriate.
       *
       * @param b4    The first four bytes of the input.
       * @param count The number of bytes actually read.
<span class="line-modified">!      * @return a 2-element array:  the first element, an IANA-encoding string,</span>
<span class="line-removed">-      *  the second element a Boolean which is true iff the document is big endian, false</span>
<span class="line-removed">-      *  if it&#39;s little-endian, and null if the distinction isn&#39;t relevant.</span>
       */
<span class="line-modified">!     protected Object[] getEncodingName(byte[] b4, int count) {</span>
  
          if (count &lt; 2) {
<span class="line-modified">!             return defaultEncoding;</span>
          }
  
          // UTF-16, with BOM
          int b0 = b4[0] &amp; 0xFF;
          int b1 = b4[1] &amp; 0xFF;
          if (b0 == 0xFE &amp;&amp; b1 == 0xFF) {
              // UTF-16, big-endian
<span class="line-modified">!             return new Object [] {&quot;UTF-16BE&quot;, true};</span>
          }
          if (b0 == 0xFF &amp;&amp; b1 == 0xFE) {
              // UTF-16, little-endian
<span class="line-modified">!             return new Object [] {&quot;UTF-16LE&quot;, false};</span>
          }
  
          // default to UTF-8 if we don&#39;t have enough bytes to make a
          // good determination of the encoding
          if (count &lt; 3) {
<span class="line-modified">!             return defaultEncoding;</span>
          }
  
          // UTF-8 with a BOM
          int b2 = b4[2] &amp; 0xFF;
          if (b0 == 0xEF &amp;&amp; b1 == 0xBB &amp;&amp; b2 == 0xBF) {
<span class="line-modified">!             return defaultEncoding;</span>
          }
  
          // default to UTF-8 if we don&#39;t have enough bytes to make a
          // good determination of the encoding
          if (count &lt; 4) {
<span class="line-modified">!             return defaultEncoding;</span>
          }
  
          // other encodings
          int b3 = b4[3] &amp; 0xFF;
          if (b0 == 0x00 &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x3C) {
              // UCS-4, big endian (1234)
<span class="line-modified">!             return new Object [] {&quot;ISO-10646-UCS-4&quot;, true};</span>
          }
          if (b0 == 0x3C &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x00) {
              // UCS-4, little endian (4321)
<span class="line-modified">!             return new Object [] {&quot;ISO-10646-UCS-4&quot;, false};</span>
          }
          if (b0 == 0x00 &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x3C &amp;&amp; b3 == 0x00) {
              // UCS-4, unusual octet order (2143)
              // REVISIT: What should this be?
<span class="line-modified">!             return new Object [] {&quot;ISO-10646-UCS-4&quot;, null};</span>
          }
          if (b0 == 0x00 &amp;&amp; b1 == 0x3C &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x00) {
              // UCS-4, unusual octect order (3412)
              // REVISIT: What should this be?
<span class="line-modified">!             return new Object [] {&quot;ISO-10646-UCS-4&quot;, null};</span>
          }
          if (b0 == 0x00 &amp;&amp; b1 == 0x3C &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x3F) {
              // UTF-16, big-endian, no BOM
              // (or could turn out to be UCS-2...
              // REVISIT: What should this be?
<span class="line-modified">!             return new Object [] {&quot;UTF-16BE&quot;, true};</span>
          }
          if (b0 == 0x3C &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x3F &amp;&amp; b3 == 0x00) {
              // UTF-16, little-endian, no BOM
              // (or could turn out to be UCS-2...
<span class="line-modified">!             return new Object [] {&quot;UTF-16LE&quot;, false};</span>
          }
          if (b0 == 0x4C &amp;&amp; b1 == 0x6F &amp;&amp; b2 == 0xA7 &amp;&amp; b3 == 0x94) {
              // EBCDIC
              // a la xerces1, return CP037 instead of EBCDIC here
<span class="line-modified">!             return new Object [] {&quot;CP037&quot;, null};</span>
          }
  
<span class="line-modified">!         return defaultEncoding;</span>
  
      } // getEncodingName(byte[],int):Object[]
  
      /**
       * Creates a reader capable of reading the given input stream in
<span class="line-new-header">--- 2419,87 ---</span>
       * Returns the IANA encoding name that is auto-detected from
       * the bytes specified, with the endian-ness of that encoding where appropriate.
       *
       * @param b4    The first four bytes of the input.
       * @param count The number of bytes actually read.
<span class="line-modified">!      * @return an instance of EncodingInfo which represents the auto-detected encoding.</span>
       */
<span class="line-modified">!     protected EncodingInfo getEncodingInfo(byte[] b4, int count) {</span>
  
          if (count &lt; 2) {
<span class="line-modified">!             return EncodingInfo.UTF_8;</span>
          }
  
          // UTF-16, with BOM
          int b0 = b4[0] &amp; 0xFF;
          int b1 = b4[1] &amp; 0xFF;
          if (b0 == 0xFE &amp;&amp; b1 == 0xFF) {
              // UTF-16, big-endian
<span class="line-modified">!             return EncodingInfo.UTF_16_BIG_ENDIAN_WITH_BOM;</span>
          }
          if (b0 == 0xFF &amp;&amp; b1 == 0xFE) {
              // UTF-16, little-endian
<span class="line-modified">!             return EncodingInfo.UTF_16_LITTLE_ENDIAN_WITH_BOM;</span>
          }
  
          // default to UTF-8 if we don&#39;t have enough bytes to make a
          // good determination of the encoding
          if (count &lt; 3) {
<span class="line-modified">!             return EncodingInfo.UTF_8;</span>
          }
  
          // UTF-8 with a BOM
          int b2 = b4[2] &amp; 0xFF;
          if (b0 == 0xEF &amp;&amp; b1 == 0xBB &amp;&amp; b2 == 0xBF) {
<span class="line-modified">!             return EncodingInfo.UTF_8_WITH_BOM;</span>
          }
  
          // default to UTF-8 if we don&#39;t have enough bytes to make a
          // good determination of the encoding
          if (count &lt; 4) {
<span class="line-modified">!             return EncodingInfo.UTF_8;</span>
          }
  
          // other encodings
          int b3 = b4[3] &amp; 0xFF;
          if (b0 == 0x00 &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x3C) {
              // UCS-4, big endian (1234)
<span class="line-modified">!             return EncodingInfo.UCS_4_BIG_ENDIAN;</span>
          }
          if (b0 == 0x3C &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x00) {
              // UCS-4, little endian (4321)
<span class="line-modified">!             return EncodingInfo.UCS_4_LITTLE_ENDIAN;</span>
          }
          if (b0 == 0x00 &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x3C &amp;&amp; b3 == 0x00) {
              // UCS-4, unusual octet order (2143)
              // REVISIT: What should this be?
<span class="line-modified">!             return EncodingInfo.UCS_4_UNUSUAL_BYTE_ORDER;</span>
          }
          if (b0 == 0x00 &amp;&amp; b1 == 0x3C &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x00) {
              // UCS-4, unusual octect order (3412)
              // REVISIT: What should this be?
<span class="line-modified">!             return EncodingInfo.UCS_4_UNUSUAL_BYTE_ORDER;</span>
          }
          if (b0 == 0x00 &amp;&amp; b1 == 0x3C &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x3F) {
              // UTF-16, big-endian, no BOM
              // (or could turn out to be UCS-2...
              // REVISIT: What should this be?
<span class="line-modified">!             return EncodingInfo.UTF_16_BIG_ENDIAN;</span>
          }
          if (b0 == 0x3C &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x3F &amp;&amp; b3 == 0x00) {
              // UTF-16, little-endian, no BOM
              // (or could turn out to be UCS-2...
<span class="line-modified">!             return EncodingInfo.UTF_16_LITTLE_ENDIAN;</span>
          }
          if (b0 == 0x4C &amp;&amp; b1 == 0x6F &amp;&amp; b2 == 0xA7 &amp;&amp; b3 == 0x94) {
              // EBCDIC
              // a la xerces1, return CP037 instead of EBCDIC here
<span class="line-modified">!             return EncodingInfo.EBCDIC;</span>
          }
  
<span class="line-modified">!         // default encoding</span>
<span class="line-added">+         return EncodingInfo.UTF_8;</span>
  
      } // getEncodingName(byte[],int):Object[]
  
      /**
       * Creates a reader capable of reading the given input stream in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2515,99 ***</span>
       *                     encoded using. If the user has specified that
       *                     Java encoding names are allowed, then the
       *                     encoding name may be a Java encoding name;
       *                     otherwise, it is an ianaEncoding name.
       * @param isBigEndian   For encodings (like uCS-4), whose names cannot
<span class="line-modified">!      *                      specify a byte order, this tells whether the order is bigEndian.  null menas</span>
<span class="line-modified">!      *                      unknown or not relevant.</span>
       *
       * @return Returns a reader.
       */
      protected Reader createReader(InputStream inputStream, String encoding, Boolean isBigEndian)
<span class="line-modified">!     throws IOException {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // normalize encoding name</span>
<span class="line-removed">-         if (encoding == null) {</span>
<span class="line-removed">-             encoding = &quot;UTF-8&quot;;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         // try to use an optimized reader</span>
<span class="line-modified">!         String ENCODING = encoding.toUpperCase(Locale.ENGLISH);</span>
<span class="line-modified">!         if (ENCODING.equals(&quot;UTF-8&quot;)) {</span>
<span class="line-modified">!             if (DEBUG_ENCODINGS) {</span>
<span class="line-modified">!                 System.out.println(&quot;$$$ creating UTF8Reader&quot;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             return new UTF8Reader(inputStream, fBufferSize, fErrorReporter.getMessageFormatter(XMLMessageFormatter.XML_DOMAIN), fErrorReporter.getLocale() );</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (ENCODING.equals(&quot;US-ASCII&quot;)) {</span>
<span class="line-modified">!             if (DEBUG_ENCODINGS) {</span>
<span class="line-modified">!                 System.out.println(&quot;$$$ creating ASCIIReader&quot;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             return new ASCIIReader(inputStream, fBufferSize, fErrorReporter.getMessageFormatter(XMLMessageFormatter.XML_DOMAIN), fErrorReporter.getLocale());</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if(ENCODING.equals(&quot;ISO-10646-UCS-4&quot;)) {</span>
<span class="line-modified">!             if(isBigEndian != null) {</span>
<span class="line-modified">!                 boolean isBE = isBigEndian.booleanValue();</span>
<span class="line-modified">!                 if(isBE) {</span>
<span class="line-modified">!                     return new UCSReader(inputStream, UCSReader.UCS4BE);</span>
                  } else {
<span class="line-modified">!                     return new UCSReader(inputStream, UCSReader.UCS4LE);</span>
                  }
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 fErrorReporter.reportError(this.getEntityScanner(),XMLMessageFormatter.XML_DOMAIN,</span>
<span class="line-modified">!                         &quot;EncodingByteOrderUnsupported&quot;,</span>
<span class="line-modified">!                         new Object[] { encoding },</span>
<span class="line-modified">!                         XMLErrorReporter.SEVERITY_FATAL_ERROR);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if(ENCODING.equals(&quot;ISO-10646-UCS-2&quot;)) {</span>
<span class="line-removed">-             if(isBigEndian != null) { // sould never happen with this encoding...</span>
<span class="line-removed">-                 boolean isBE = isBigEndian.booleanValue();</span>
<span class="line-removed">-                 if(isBE) {</span>
<span class="line-removed">-                     return new UCSReader(inputStream, UCSReader.UCS2BE);</span>
                  } else {
<span class="line-modified">!                     return new UCSReader(inputStream, UCSReader.UCS2LE);</span>
                  }
<span class="line-modified">!             } else {</span>
<span class="line-removed">-                 fErrorReporter.reportError(this.getEntityScanner(),XMLMessageFormatter.XML_DOMAIN,</span>
<span class="line-removed">-                         &quot;EncodingByteOrderUnsupported&quot;,</span>
<span class="line-removed">-                         new Object[] { encoding },</span>
<span class="line-removed">-                         XMLErrorReporter.SEVERITY_FATAL_ERROR);</span>
<span class="line-removed">-             }</span>
          }
  
          // check for valid name
          boolean validIANA = XMLChar.isValidIANAEncoding(encoding);
          boolean validJava = XMLChar.isValidJavaEncoding(encoding);
          if (!validIANA || (fAllowJavaEncodings &amp;&amp; !validJava)) {
<span class="line-modified">!             fErrorReporter.reportError(this.getEntityScanner(),XMLMessageFormatter.XML_DOMAIN,</span>
                      &quot;EncodingDeclInvalid&quot;,
                      new Object[] { encoding },
                      XMLErrorReporter.SEVERITY_FATAL_ERROR);
<span class="line-modified">!                     // NOTE: AndyH suggested that, on failure, we use ISO Latin 1</span>
<span class="line-modified">!                     //       because every byte is a valid ISO Latin 1 character.</span>
<span class="line-modified">!                     //       It may not translate correctly but if we failed on</span>
<span class="line-modified">!                     //       the encoding anyway, then we&#39;re expecting the content</span>
<span class="line-modified">!                     //       of the document to be bad. This will just prevent an</span>
<span class="line-modified">!                     //       invalid UTF-8 sequence to be detected. This is only</span>
<span class="line-modified">!                     //       important when continue-after-fatal-error is turned</span>
<span class="line-modified">!                     //       on. -Ac</span>
                      encoding = &quot;ISO-8859-1&quot;;
          }
  
          // try to use a Java reader
<span class="line-modified">!         String javaEncoding = EncodingMap.getIANA2JavaMapping(ENCODING);</span>
          if (javaEncoding == null) {
<span class="line-modified">!             if(fAllowJavaEncodings) {</span>
                  javaEncoding = encoding;
              } else {
<span class="line-modified">!                 fErrorReporter.reportError(this.getEntityScanner(),XMLMessageFormatter.XML_DOMAIN,</span>
                          &quot;EncodingDeclInvalid&quot;,
                          new Object[] { encoding },
                          XMLErrorReporter.SEVERITY_FATAL_ERROR);
<span class="line-modified">!                         // see comment above.</span>
<span class="line-modified">!                         javaEncoding = &quot;ISO8859_1&quot;;</span>
              }
          }
          if (DEBUG_ENCODINGS) {
              System.out.print(&quot;$$$ creating Java InputStreamReader: encoding=&quot;+javaEncoding);
              if (javaEncoding == encoding) {
<span class="line-new-header">--- 2510,99 ---</span>
       *                     encoded using. If the user has specified that
       *                     Java encoding names are allowed, then the
       *                     encoding name may be a Java encoding name;
       *                     otherwise, it is an ianaEncoding name.
       * @param isBigEndian   For encodings (like uCS-4), whose names cannot
<span class="line-modified">!      *                      specify a byte order, this tells whether the order</span>
<span class="line-modified">!      *                      is bigEndian.  null if unknown or irrelevant.</span>
       *
       * @return Returns a reader.
       */
      protected Reader createReader(InputStream inputStream, String encoding, Boolean isBigEndian)
<span class="line-modified">!         throws IOException {</span>
  
<span class="line-modified">!         String enc = (encoding != null) ? encoding : EncodingInfo.STR_UTF8;</span>
<span class="line-modified">!         enc = enc.toUpperCase(Locale.ENGLISH);</span>
<span class="line-modified">!         MessageFormatter f = fErrorReporter.getMessageFormatter(XMLMessageFormatter.XML_DOMAIN);</span>
<span class="line-modified">!         Locale l = fErrorReporter.getLocale();</span>
<span class="line-modified">!         switch (enc) {</span>
<span class="line-modified">!             case EncodingInfo.STR_UTF8:</span>
<span class="line-modified">!                 return new UTF8Reader(inputStream, fBufferSize, f, l);</span>
<span class="line-modified">!             case EncodingInfo.STR_UTF16:</span>
<span class="line-modified">!                 if (isBigEndian != null) {</span>
<span class="line-modified">!                     return new UTF16Reader(inputStream, fBufferSize, isBigEndian, f, l);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case EncodingInfo.STR_UTF16BE:</span>
<span class="line-modified">!                 return new UTF16Reader(inputStream, fBufferSize, true, f, l);</span>
<span class="line-modified">!             case EncodingInfo.STR_UTF16LE:</span>
<span class="line-modified">!                 return new UTF16Reader(inputStream, fBufferSize, false, f, l);</span>
<span class="line-modified">!             case EncodingInfo.STR_UCS4:</span>
<span class="line-modified">!                 if(isBigEndian != null) {</span>
<span class="line-modified">!                     if(isBigEndian) {</span>
<span class="line-added">+                         return new UCSReader(inputStream, UCSReader.UCS4BE);</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         return new UCSReader(inputStream, UCSReader.UCS4LE);</span>
<span class="line-added">+                     }</span>
                  } else {
<span class="line-modified">!                     fErrorReporter.reportError(this.getEntityScanner(),</span>
<span class="line-added">+                             XMLMessageFormatter.XML_DOMAIN,</span>
<span class="line-added">+                             &quot;EncodingByteOrderUnsupported&quot;,</span>
<span class="line-added">+                             new Object[] { encoding },</span>
<span class="line-added">+                             XMLErrorReporter.SEVERITY_FATAL_ERROR);</span>
                  }
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case EncodingInfo.STR_UCS2:</span>
<span class="line-modified">!                 if(isBigEndian != null) {</span>
<span class="line-modified">!                     if(isBigEndian) {</span>
<span class="line-modified">!                         return new UCSReader(inputStream, UCSReader.UCS2BE);</span>
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         return new UCSReader(inputStream, UCSReader.UCS2LE);</span>
<span class="line-modified">!                     }</span>
                  } else {
<span class="line-modified">!                     fErrorReporter.reportError(this.getEntityScanner(),</span>
<span class="line-added">+                             XMLMessageFormatter.XML_DOMAIN,</span>
<span class="line-added">+                             &quot;EncodingByteOrderUnsupported&quot;,</span>
<span class="line-added">+                             new Object[] { encoding },</span>
<span class="line-added">+                             XMLErrorReporter.SEVERITY_FATAL_ERROR);</span>
                  }
<span class="line-modified">!                 break;</span>
          }
  
          // check for valid name
          boolean validIANA = XMLChar.isValidIANAEncoding(encoding);
          boolean validJava = XMLChar.isValidJavaEncoding(encoding);
          if (!validIANA || (fAllowJavaEncodings &amp;&amp; !validJava)) {
<span class="line-modified">!             fErrorReporter.reportError(this.getEntityScanner(),</span>
<span class="line-added">+                     XMLMessageFormatter.XML_DOMAIN,</span>
                      &quot;EncodingDeclInvalid&quot;,
                      new Object[] { encoding },
                      XMLErrorReporter.SEVERITY_FATAL_ERROR);
<span class="line-modified">!             // NOTE: AndyH suggested that, on failure, we use ISO Latin 1</span>
<span class="line-modified">!             //       because every byte is a valid ISO Latin 1 character.</span>
<span class="line-modified">!             //       It may not translate correctly but if we failed on</span>
<span class="line-modified">!             //       the encoding anyway, then we&#39;re expecting the content</span>
<span class="line-modified">!             //       of the document to be bad. This will just prevent an</span>
<span class="line-modified">!             //       invalid UTF-8 sequence to be detected. This is only</span>
<span class="line-modified">!             //       important when continue-after-fatal-error is turned</span>
<span class="line-modified">!             //       on. -Ac</span>
                      encoding = &quot;ISO-8859-1&quot;;
          }
  
          // try to use a Java reader
<span class="line-modified">!         String javaEncoding = EncodingMap.getIANA2JavaMapping(enc);</span>
          if (javaEncoding == null) {
<span class="line-modified">!             if (fAllowJavaEncodings) {</span>
                  javaEncoding = encoding;
              } else {
<span class="line-modified">!                 fErrorReporter.reportError(this.getEntityScanner(),</span>
<span class="line-added">+                         XMLMessageFormatter.XML_DOMAIN,</span>
                          &quot;EncodingDeclInvalid&quot;,
                          new Object[] { encoding },
                          XMLErrorReporter.SEVERITY_FATAL_ERROR);
<span class="line-modified">!                 // see comment above.</span>
<span class="line-modified">!                 javaEncoding = &quot;ISO8859_1&quot;;</span>
              }
          }
          if (DEBUG_ENCODINGS) {
              System.out.print(&quot;$$$ creating Java InputStreamReader: encoding=&quot;+javaEncoding);
              if (javaEncoding == encoding) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2896,112 ***</span>
              }
          }
      } // print()
  
      /**
<span class="line-modified">!      * Buffer used in entity manager to reuse character arrays instead</span>
<span class="line-removed">-      * of creating new ones every time.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @xerces.internal</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @author Ankit Pasricha, IBM</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static class CharacterBuffer {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /** character buffer */</span>
<span class="line-removed">-         private char[] ch;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /** whether the buffer is for an external or internal scanned entity */</span>
<span class="line-removed">-         private boolean isExternal;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public CharacterBuffer(boolean isExternal, int size) {</span>
<span class="line-removed">-             this.isExternal = isExternal;</span>
<span class="line-removed">-             ch = new char[size];</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-      /**</span>
<span class="line-removed">-      * Stores a number of character buffers and provides it to the entity</span>
<span class="line-removed">-      * manager to use when an entity is seen.</span>
       *
       * @xerces.internal
       *
<span class="line-modified">!      * @author Ankit Pasricha, IBM</span>
       */
<span class="line-modified">!     private static class CharacterBufferPool {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private static final int DEFAULT_POOL_SIZE = 3;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private CharacterBuffer[] fInternalBufferPool;</span>
<span class="line-modified">!         private CharacterBuffer[] fExternalBufferPool;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private int fExternalBufferSize;</span>
<span class="line-modified">!         private int fInternalBufferSize;</span>
<span class="line-modified">!         private int poolSize;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private int fInternalTop;</span>
<span class="line-modified">!         private int fExternalTop;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         public CharacterBufferPool(int externalBufferSize, int internalBufferSize) {</span>
<span class="line-modified">!             this(DEFAULT_POOL_SIZE, externalBufferSize, internalBufferSize);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         public CharacterBufferPool(int poolSize, int externalBufferSize, int internalBufferSize) {</span>
<span class="line-modified">!             fExternalBufferSize = externalBufferSize;</span>
<span class="line-modified">!             fInternalBufferSize = internalBufferSize;</span>
<span class="line-modified">!             this.poolSize = poolSize;</span>
<span class="line-modified">!             init();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** Initializes buffer pool. **/</span>
<span class="line-modified">!         private void init() {</span>
<span class="line-modified">!             fInternalBufferPool = new CharacterBuffer[poolSize];</span>
<span class="line-modified">!             fExternalBufferPool = new CharacterBuffer[poolSize];</span>
<span class="line-modified">!             fInternalTop = -1;</span>
<span class="line-modified">!             fExternalTop = -1;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** Retrieves buffer from pool. **/</span>
<span class="line-modified">!         public CharacterBuffer getBuffer(boolean external) {</span>
<span class="line-modified">!             if (external) {</span>
<span class="line-modified">!                 if (fExternalTop &gt; -1) {</span>
<span class="line-modified">!                     return fExternalBufferPool[fExternalTop--];</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 else {</span>
<span class="line-modified">!                     return new CharacterBuffer(true, fExternalBufferSize);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             else {</span>
<span class="line-modified">!                 if (fInternalTop &gt; -1) {</span>
<span class="line-modified">!                     return fInternalBufferPool[fInternalTop--];</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 else {</span>
<span class="line-modified">!                     return new CharacterBuffer(false, fInternalBufferSize);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** Returns buffer to pool. **/</span>
<span class="line-modified">!         public void returnToPool(CharacterBuffer buffer) {</span>
<span class="line-modified">!             if (buffer.isExternal) {</span>
<span class="line-modified">!                 if (fExternalTop &lt; fExternalBufferPool.length - 1) {</span>
<span class="line-modified">!                     fExternalBufferPool[++fExternalTop] = buffer;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             else if (fInternalTop &lt; fInternalBufferPool.length - 1) {</span>
<span class="line-modified">!                 fInternalBufferPool[++fInternalTop] = buffer;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** Sets the size of external buffers and dumps the old pool. **/</span>
<span class="line-removed">-         public void setExternalBufferSize(int bufferSize) {</span>
<span class="line-removed">-             fExternalBufferSize = bufferSize;</span>
<span class="line-removed">-             fExternalBufferPool = new CharacterBuffer[poolSize];</span>
<span class="line-removed">-             fExternalTop = -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  
      /**
      * This class wraps the byte inputstreams we&#39;re presented with.
      * We need it because java.io.InputStreams don&#39;t provide
      * functionality to reread processed bytes, and they have a habit
<span class="line-new-header">--- 2891,82 ---</span>
              }
          }
      } // print()
  
      /**
<span class="line-modified">!      * Information about auto-detectable encodings.</span>
       *
       * @xerces.internal
       *
<span class="line-modified">!      * @author Michael Glavassevich, IBM</span>
       */
<span class="line-modified">!     private static class EncodingInfo {</span>
<span class="line-modified">!         public static final String STR_UTF8 = &quot;UTF-8&quot;;</span>
<span class="line-modified">!         public static final String STR_UTF16 = &quot;UTF-16&quot;;</span>
<span class="line-modified">!         public static final String STR_UTF16BE = &quot;UTF-16BE&quot;;</span>
<span class="line-modified">!         public static final String STR_UTF16LE = &quot;UTF-16LE&quot;;</span>
<span class="line-modified">!         public static final String STR_UCS4 = &quot;ISO-10646-UCS-4&quot;;</span>
<span class="line-modified">!         public static final String STR_UCS2 = &quot;ISO-10646-UCS-2&quot;;</span>
<span class="line-modified">!         public static final String STR_CP037 = &quot;CP037&quot;;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** UTF-8 **/</span>
<span class="line-modified">!         public static final EncodingInfo UTF_8 =</span>
<span class="line-modified">!                 new EncodingInfo(STR_UTF8, null, false);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** UTF-8, with BOM **/</span>
<span class="line-modified">!         public static final EncodingInfo UTF_8_WITH_BOM =</span>
<span class="line-modified">!                 new EncodingInfo(STR_UTF8, null, true);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** UTF-16, big-endian **/</span>
<span class="line-modified">!         public static final EncodingInfo UTF_16_BIG_ENDIAN =</span>
<span class="line-modified">!                 new EncodingInfo(STR_UTF16BE, STR_UTF16, Boolean.TRUE, false);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** UTF-16, big-endian with BOM **/</span>
<span class="line-modified">!         public static final EncodingInfo UTF_16_BIG_ENDIAN_WITH_BOM =</span>
<span class="line-modified">!                 new EncodingInfo(STR_UTF16BE, STR_UTF16, Boolean.TRUE, true);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** UTF-16, little-endian **/</span>
<span class="line-modified">!         public static final EncodingInfo UTF_16_LITTLE_ENDIAN =</span>
<span class="line-modified">!                 new EncodingInfo(STR_UTF16LE, STR_UTF16, Boolean.FALSE, false);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** UTF-16, little-endian with BOM **/</span>
<span class="line-modified">!         public static final EncodingInfo UTF_16_LITTLE_ENDIAN_WITH_BOM =</span>
<span class="line-modified">!                 new EncodingInfo(STR_UTF16LE, STR_UTF16, Boolean.FALSE, true);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** UCS-4, big-endian **/</span>
<span class="line-modified">!         public static final EncodingInfo UCS_4_BIG_ENDIAN =</span>
<span class="line-modified">!                 new EncodingInfo(STR_UCS4, Boolean.TRUE, false);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** UCS-4, little-endian **/</span>
<span class="line-modified">!         public static final EncodingInfo UCS_4_LITTLE_ENDIAN =</span>
<span class="line-modified">!                 new EncodingInfo(STR_UCS4, Boolean.FALSE, false);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** UCS-4, unusual byte-order (2143) or (3412) **/</span>
<span class="line-modified">!         public static final EncodingInfo UCS_4_UNUSUAL_BYTE_ORDER =</span>
<span class="line-modified">!                 new EncodingInfo(STR_UCS4, null, false);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /** EBCDIC **/</span>
<span class="line-modified">!         public static final EncodingInfo EBCDIC = new EncodingInfo(STR_CP037, null, false);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         public final String autoDetectedEncoding;</span>
<span class="line-modified">!         public final String readerEncoding;</span>
<span class="line-modified">!         public final Boolean isBigEndian;</span>
<span class="line-modified">!         public final boolean hasBOM;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private EncodingInfo(String autoDetectedEncoding, Boolean isBigEndian, boolean hasBOM) {</span>
<span class="line-modified">!             this(autoDetectedEncoding, autoDetectedEncoding, isBigEndian, hasBOM);</span>
<span class="line-modified">!         } // &lt;init&gt;(String,Boolean,boolean)</span>
<span class="line-modified">! </span>
<span class="line-modified">!         private EncodingInfo(String autoDetectedEncoding, String readerEncoding,</span>
<span class="line-modified">!                 Boolean isBigEndian, boolean hasBOM) {</span>
<span class="line-modified">!             this.autoDetectedEncoding = autoDetectedEncoding;</span>
<span class="line-modified">!             this.readerEncoding = readerEncoding;</span>
<span class="line-modified">!             this.isBigEndian = isBigEndian;</span>
<span class="line-modified">!             this.hasBOM = hasBOM;</span>
<span class="line-modified">!         } // &lt;init&gt;(String,String,Boolean,boolean)</span>
<span class="line-modified">! </span>
<span class="line-modified">!     } // class EncodingInfo</span>
  
      /**
      * This class wraps the byte inputstreams we&#39;re presented with.
      * We need it because java.io.InputStreams don&#39;t provide
      * functionality to reread processed bytes, and they have a habit
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3050,63 ***</span>
  
          public void rewind() {
              fOffset = fStartOffset;
          }
  
<span class="line-modified">!         public int read() throws IOException {</span>
<span class="line-removed">-             int b = 0;</span>
<span class="line-removed">-             if (fOffset &lt; fLength) {</span>
<span class="line-removed">-                 return fData[fOffset++] &amp; 0xff;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (fOffset == fEndOffset) {</span>
<span class="line-removed">-                 return -1;</span>
<span class="line-removed">-             }</span>
              if (fOffset == fData.length) {
                  byte[] newData = new byte[fOffset &lt;&lt; 1];
                  System.arraycopy(fData, 0, newData, 0, fOffset);
                  fData = newData;
              }
<span class="line-modified">!             b = fInputStream.read();</span>
              if (b == -1) {
                  fEndOffset = fOffset;
                  return -1;
              }
              fData[fLength++] = (byte)b;
              fOffset++;
              return b &amp; 0xff;
          }
  
          public int read(byte[] b, int off, int len) throws IOException {
<span class="line-modified">!             int bytesLeft = fLength - fOffset;</span>
              if (bytesLeft == 0) {
                  if (fOffset == fEndOffset) {
                      return -1;
                  }
  
<span class="line-modified">!                 /**</span>
<span class="line-removed">-                  * //System.out.println(&quot;fCurrentEntitty = &quot; + fCurrentEntity );</span>
<span class="line-removed">-                  * //System.out.println(&quot;fInputStream = &quot; + fInputStream );</span>
<span class="line-removed">-                  * // better get some more for the voracious reader... */</span>
<span class="line-removed">- </span>
                  if(fCurrentEntity.mayReadChunks || !fCurrentEntity.xmlDeclChunkRead) {
  
                      if (!fCurrentEntity.xmlDeclChunkRead)
                      {
                          fCurrentEntity.xmlDeclChunkRead = true;
                          len = Entity.ScannedEntity.DEFAULT_XMLDECL_BUFFER_SIZE;
                      }
                      return fInputStream.read(b, off, len);
                  }
<span class="line-modified">! </span>
<span class="line-modified">!                 int returnedVal = read();</span>
<span class="line-modified">!                 if(returnedVal == -1) {</span>
<span class="line-modified">!                   fEndOffset = fOffset;</span>
<span class="line-removed">-                   return -1;</span>
                  }
                  b[off] = (byte)returnedVal;
                  return 1;
<span class="line-removed">- </span>
              }
              if (len &lt; bytesLeft) {
                  if (len &lt;= 0) {
                      return 0;
                  }
<span class="line-new-header">--- 3015,63 ---</span>
  
          public void rewind() {
              fOffset = fStartOffset;
          }
  
<span class="line-modified">!         public int readAndBuffer() throws IOException {</span>
              if (fOffset == fData.length) {
                  byte[] newData = new byte[fOffset &lt;&lt; 1];
                  System.arraycopy(fData, 0, newData, 0, fOffset);
                  fData = newData;
              }
<span class="line-modified">!             final int b = fInputStream.read();</span>
              if (b == -1) {
                  fEndOffset = fOffset;
                  return -1;
              }
              fData[fLength++] = (byte)b;
              fOffset++;
              return b &amp; 0xff;
          }
  
<span class="line-added">+         public int read() throws IOException {</span>
<span class="line-added">+             if (fOffset &lt; fLength) {</span>
<span class="line-added">+                 return fData[fOffset++] &amp; 0xff;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (fOffset == fEndOffset) {</span>
<span class="line-added">+                 return -1;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (fCurrentEntity.mayReadChunks) {</span>
<span class="line-added">+                 return fInputStream.read();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return readAndBuffer();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          public int read(byte[] b, int off, int len) throws IOException {
<span class="line-modified">!             final int bytesLeft = fLength - fOffset;</span>
              if (bytesLeft == 0) {
                  if (fOffset == fEndOffset) {
                      return -1;
                  }
  
<span class="line-modified">!                 // read a block of data as requested</span>
                  if(fCurrentEntity.mayReadChunks || !fCurrentEntity.xmlDeclChunkRead) {
  
                      if (!fCurrentEntity.xmlDeclChunkRead)
                      {
                          fCurrentEntity.xmlDeclChunkRead = true;
                          len = Entity.ScannedEntity.DEFAULT_XMLDECL_BUFFER_SIZE;
                      }
                      return fInputStream.read(b, off, len);
                  }
<span class="line-modified">!                 int returnedVal = readAndBuffer();</span>
<span class="line-modified">!                 if (returnedVal == -1) {</span>
<span class="line-modified">!                     fEndOffset = fOffset;</span>
<span class="line-modified">!                     return -1;</span>
                  }
                  b[off] = (byte)returnedVal;
                  return 1;
              }
              if (len &lt; bytesLeft) {
                  if (len &lt;= 0) {
                      return 0;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3118,12 ***</span>
              }
              fOffset += len;
              return len;
          }
  
<span class="line-modified">!         public long skip(long n)</span>
<span class="line-removed">-         throws IOException {</span>
              int bytesLeft;
              if (n &lt;= 0) {
                  return 0;
              }
              bytesLeft = fLength - fOffset;
<span class="line-new-header">--- 3083,11 ---</span>
              }
              fOffset += len;
              return len;
          }
  
<span class="line-modified">!         public long skip(long n) throws IOException {</span>
              int bytesLeft;
              if (n &lt;= 0) {
                  return 0;
              }
              bytesLeft = fLength - fOffset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3140,11 ***</span>
              fOffset += bytesLeft;
              if (fOffset == fEndOffset) {
                  return bytesLeft;
              }
              n -= bytesLeft;
<span class="line-modified">!             /*</span>
              * In a manner of speaking, when this class isn&#39;t permitting more
              * than one byte at a time to be read, it is &quot;blocking&quot;.  The
              * available() method should indicate how much can be read without
              * blocking, so while we&#39;re in this mode, it should only indicate
              * that bytes in its buffer are available; otherwise, the result of
<span class="line-new-header">--- 3104,11 ---</span>
              fOffset += bytesLeft;
              if (fOffset == fEndOffset) {
                  return bytesLeft;
              }
              n -= bytesLeft;
<span class="line-modified">!            /*</span>
              * In a manner of speaking, when this class isn&#39;t permitting more
              * than one byte at a time to be read, it is &quot;blocking&quot;.  The
              * available() method should indicate how much can be read without
              * blocking, so while we&#39;re in this mode, it should only indicate
              * that bytes in its buffer are available; otherwise, the result of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3152,28 ***</span>
              */
              return fInputStream.skip(n) + bytesLeft;
          }
  
          public int available() throws IOException {
<span class="line-modified">!             int bytesLeft = fLength - fOffset;</span>
              if (bytesLeft == 0) {
                  if (fOffset == fEndOffset) {
                      return -1;
                  }
                  return fCurrentEntity.mayReadChunks ? fInputStream.available()
<span class="line-modified">!                 : 0;</span>
              }
              return bytesLeft;
          }
  
          public void mark(int howMuch) {
              fMark = fOffset;
          }
  
          public void reset() {
              fOffset = fMark;
<span class="line-removed">-             //test();</span>
          }
  
          public boolean markSupported() {
              return true;
          }
<span class="line-new-header">--- 3116,27 ---</span>
              */
              return fInputStream.skip(n) + bytesLeft;
          }
  
          public int available() throws IOException {
<span class="line-modified">!             final int bytesLeft = fLength - fOffset;</span>
              if (bytesLeft == 0) {
                  if (fOffset == fEndOffset) {
                      return -1;
                  }
                  return fCurrentEntity.mayReadChunks ? fInputStream.available()
<span class="line-modified">!                                                     : 0;</span>
              }
              return bytesLeft;
          }
  
          public void mark(int howMuch) {
              fMark = fOffset;
          }
  
          public void reset() {
              fOffset = fMark;
          }
  
          public boolean markSupported() {
              return true;
          }
</pre>
<center><a href="XMLDocumentFragmentScannerImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="dv/xs/TypeValidator.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
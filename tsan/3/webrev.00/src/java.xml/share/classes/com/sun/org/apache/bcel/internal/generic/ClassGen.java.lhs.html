<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ClassGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * reserved comment block</span>
<span class="line-removed">  3  * DO NOT REMOVE OR ALTER!</span>
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import java.util.ArrayList;
 24 import java.util.List;
<a name="2" id="anc2"></a>
 25 
 26 import com.sun.org.apache.bcel.internal.Const;
 27 import com.sun.org.apache.bcel.internal.classfile.AccessFlags;
 28 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
 29 import com.sun.org.apache.bcel.internal.classfile.Annotations;
 30 import com.sun.org.apache.bcel.internal.classfile.Attribute;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 32 import com.sun.org.apache.bcel.internal.classfile.Field;
 33 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
 34 import com.sun.org.apache.bcel.internal.classfile.Method;
 35 import com.sun.org.apache.bcel.internal.classfile.RuntimeInvisibleAnnotations;
 36 import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleAnnotations;
 37 import com.sun.org.apache.bcel.internal.classfile.SourceFile;
 38 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 39 
 40 /**
 41  * Template class for building up a java class. May be initialized with an
 42  * existing java class (file).
 43  *
 44  * @see JavaClass
<a name="3" id="anc3"></a><span class="line-modified"> 45  * @version $Id: ClassGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 46  */
 47 public class ClassGen extends AccessFlags implements Cloneable {
 48 
 49     /* Corresponds to the fields found in a JavaClass object.
 50      */
 51     private String class_name;
 52     private String super_class_name;
 53     private final String file_name;
 54     private int class_name_index = -1;
 55     private int superclass_name_index = -1;
 56     private int major = Const.MAJOR;
 57     private int minor = Const.MINOR;
 58     private ConstantPoolGen cp; // Template for building up constant pool
 59     // ArrayLists instead of arrays to gather fields, methods, etc.
 60     private final List&lt;Field&gt; field_vec = new ArrayList&lt;&gt;();
 61     private final List&lt;Method&gt; method_vec = new ArrayList&lt;&gt;();
 62     private final List&lt;Attribute&gt; attribute_vec = new ArrayList&lt;&gt;();
 63     private final List&lt;String&gt; interface_vec = new ArrayList&lt;&gt;();
 64     private final List&lt;AnnotationEntryGen&gt; annotation_vec = new ArrayList&lt;&gt;();
 65 
 66     private static BCELComparator _cmp = new BCELComparator() {
 67 
 68         @Override
<a name="4" id="anc4"></a><span class="line-modified"> 69         public boolean equals(final Object o1, final Object o2) {</span>
 70             final ClassGen THIS = (ClassGen) o1;
 71             final ClassGen THAT = (ClassGen) o2;
<a name="5" id="anc5"></a><span class="line-modified"> 72             return THIS.getClassName().equals(THAT.getClassName());</span>
 73         }
 74 
<a name="6" id="anc6"></a>
 75         @Override
<a name="7" id="anc7"></a><span class="line-modified"> 76         public int hashCode(final Object o) {</span>
 77             final ClassGen THIS = (ClassGen) o;
 78             return THIS.getClassName().hashCode();
 79         }
 80     };
 81 
<a name="8" id="anc8"></a><span class="line-modified"> 82     /**</span>
<span class="line-modified"> 83      * Convenience constructor to set up some important values initially.</span>
 84      *
 85      * @param class_name fully qualified class name
 86      * @param super_class_name fully qualified superclass name
 87      * @param file_name source file name
 88      * @param access_flags access qualifiers
 89      * @param interfaces implemented interfaces
 90      * @param cp constant pool to use
 91      */
 92     public ClassGen(final String class_name, final String super_class_name, final String file_name, final int access_flags,
 93             final String[] interfaces, final ConstantPoolGen cp) {
 94         super(access_flags);
 95         this.class_name = class_name;
 96         this.super_class_name = super_class_name;
 97         this.file_name = file_name;
 98         this.cp = cp;
 99         // Put everything needed by default into the constant pool and the vectors
100         if (file_name != null) {
101             addAttribute(new SourceFile(cp.addUtf8(&quot;SourceFile&quot;), 2, cp.addUtf8(file_name), cp
102                     .getConstantPool()));
103         }
104         class_name_index = cp.addClass(class_name);
105         superclass_name_index = cp.addClass(super_class_name);
106         if (interfaces != null) {
107             for (final String interface1 : interfaces) {
108                 addInterface(interface1);
109             }
110         }
111     }
112 
<a name="9" id="anc9"></a><span class="line-modified">113     /**</span>
<span class="line-modified">114      * Convenience constructor to set up some important values initially.</span>
115      *
116      * @param class_name fully qualified class name
117      * @param super_class_name fully qualified superclass name
118      * @param file_name source file name
119      * @param access_flags access qualifiers
120      * @param interfaces implemented interfaces
121      */
122     public ClassGen(final String class_name, final String super_class_name, final String file_name, final int access_flags,
123             final String[] interfaces) {
124         this(class_name, super_class_name, file_name, access_flags, interfaces,
125                 new ConstantPoolGen());
126     }
127 
<a name="10" id="anc10"></a>
128     /**
129      * Initialize with existing class.
<a name="11" id="anc11"></a><span class="line-removed">130      *</span>
131      * @param clazz JavaClass object (e.g. read from file)
132      */
133     public ClassGen(final JavaClass clazz) {
134         super(clazz.getAccessFlags());
135         class_name_index = clazz.getClassNameIndex();
136         superclass_name_index = clazz.getSuperclassNameIndex();
137         class_name = clazz.getClassName();
138         super_class_name = clazz.getSuperclassName();
139         file_name = clazz.getSourceFileName();
140         cp = new ConstantPoolGen(clazz.getConstantPool());
141         major = clazz.getMajor();
142         minor = clazz.getMinor();
143         final Attribute[] attributes = clazz.getAttributes();
144         // J5TODO: Could make unpacking lazy, done on first reference
145         final AnnotationEntryGen[] annotations = unpackAnnotations(attributes);
146         final Method[] methods = clazz.getMethods();
147         final Field[] fields = clazz.getFields();
148         final String[] interfaces = clazz.getInterfaceNames();
149         for (final String interface1 : interfaces) {
150             addInterface(interface1);
151         }
152         for (final Attribute attribute : attributes) {
153             if (!(attribute instanceof Annotations)) {
154                 addAttribute(attribute);
155             }
156         }
157         for (final AnnotationEntryGen annotation : annotations) {
158             addAnnotationEntry(annotation);
159         }
160         for (final Method method : methods) {
161             addMethod(method);
162         }
163         for (final Field field : fields) {
164             addField(field);
165         }
166     }
167 
168     /**
169      * Look for attributes representing annotations and unpack them.
170      */
<a name="12" id="anc12"></a><span class="line-modified">171     private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs) {</span>

172         final List&lt;AnnotationEntryGen&gt; annotationGenObjs = new ArrayList&lt;&gt;();
173         for (final Attribute attr : attrs) {
<a name="13" id="anc13"></a><span class="line-modified">174             if (attr instanceof RuntimeVisibleAnnotations) {</span>

175                 final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;
176                 final AnnotationEntry[] annos = rva.getAnnotationEntries();
177                 for (final AnnotationEntry a : annos) {
178                     annotationGenObjs.add(new AnnotationEntryGen(a,
179                             getConstantPool(), false));
180                 }
<a name="14" id="anc14"></a><span class="line-removed">181             } else if (attr instanceof RuntimeInvisibleAnnotations) {</span>
<span class="line-removed">182                 final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;</span>
<span class="line-removed">183                 final AnnotationEntry[] annos = ria.getAnnotationEntries();</span>
<span class="line-removed">184                 for (final AnnotationEntry a : annos) {</span>
<span class="line-removed">185                     annotationGenObjs.add(new AnnotationEntryGen(a,</span>
<span class="line-removed">186                             getConstantPool(), false));</span>
<span class="line-removed">187                 }</span>
188             }
<a name="15" id="anc15"></a>









189         }
190         return annotationGenObjs.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);
191     }
192 
<a name="16" id="anc16"></a>
193     /**
194      * @return the (finally) built up Java class object.
195      */
196     public JavaClass getJavaClass() {
197         final int[] interfaces = getInterfaces();
198         final Field[] fields = getFields();
199         final Method[] methods = getMethods();
<a name="17" id="anc17"></a><span class="line-modified">200         Attribute[] attributes;</span>
201         if (annotation_vec.isEmpty()) {
202             attributes = getAttributes();
203         } else {
204             // TODO: Sometime later, trash any attributes called &#39;RuntimeVisibleAnnotations&#39; or &#39;RuntimeInvisibleAnnotations&#39;
<a name="18" id="anc18"></a><span class="line-modified">205             final Attribute[] annAttributes = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());</span>
<span class="line-modified">206             attributes = new Attribute[attribute_vec.size() + annAttributes.length];</span>
207             attribute_vec.toArray(attributes);
<a name="19" id="anc19"></a><span class="line-modified">208             System.arraycopy(annAttributes, 0, attributes, attribute_vec.size(), annAttributes.length);</span>
209         }
210         // Must be last since the above calls may still add something to it
211         final ConstantPool _cp = this.cp.getFinalConstantPool();
212         return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor,
213                 super.getAccessFlags(), _cp, interfaces, fields, methods, attributes);
214     }
215 
<a name="20" id="anc20"></a>
216     /**
217      * Add an interface to this class, i.e., this class has to implement it.
<a name="21" id="anc21"></a><span class="line-removed">218      *</span>
219      * @param name interface to implement (fully qualified class name)
220      */
<a name="22" id="anc22"></a><span class="line-modified">221     public final void addInterface(final String name) {</span>
222         interface_vec.add(name);
223     }
224 
<a name="23" id="anc23"></a>
225     /**
226      * Remove an interface from this class.
<a name="24" id="anc24"></a><span class="line-removed">227      *</span>
228      * @param name interface to remove (fully qualified name)
229      */
<a name="25" id="anc25"></a><span class="line-modified">230     public void removeInterface(final String name) {</span>
231         interface_vec.remove(name);
232     }
233 
<a name="26" id="anc26"></a>
234     /**
235      * @return major version number of class file
236      */
237     public int getMajor() {
238         return major;
239     }
240 
<a name="27" id="anc27"></a><span class="line-modified">241     /**</span>
<span class="line-modified">242      * Set major version number of class file, default value is 45 (JDK 1.1)</span>
<span class="line-removed">243      *</span>
244      * @param major major version number
245      */
<a name="28" id="anc28"></a><span class="line-modified">246     public void setMajor(final int major) { // TODO could be package-protected - only called by test code</span>
247         this.major = major;
248     }
249 
<a name="29" id="anc29"></a><span class="line-modified">250     /**</span>
<span class="line-modified">251      * Set minor version number of class file, default value is 3 (JDK 1.1)</span>
<span class="line-removed">252      *</span>
253      * @param minor minor version number
254      */
<a name="30" id="anc30"></a><span class="line-modified">255     public void setMinor(final int minor) {  // TODO could be package-protected - only called by test code</span>
256         this.minor = minor;
257     }
258 
259     /**
260      * @return minor version number of class file
261      */
262     public int getMinor() {
263         return minor;
264     }
265 
<a name="31" id="anc31"></a>
266     /**
267      * Add an attribute to this class.
<a name="32" id="anc32"></a><span class="line-removed">268      *</span>
269      * @param a attribute to add
270      */
<a name="33" id="anc33"></a><span class="line-modified">271     public final void addAttribute(final Attribute a) {</span>
272         attribute_vec.add(a);
273     }
274 
<a name="34" id="anc34"></a><span class="line-modified">275     public final void addAnnotationEntry(final AnnotationEntryGen a) {</span>
276         annotation_vec.add(a);
277     }
278 
<a name="35" id="anc35"></a>
279     /**
280      * Add a method to this class.
<a name="36" id="anc36"></a><span class="line-removed">281      *</span>
282      * @param m method to add
283      */
<a name="37" id="anc37"></a><span class="line-modified">284     public final void addMethod(final Method m) {</span>
285         method_vec.add(m);
286     }
287 
<a name="38" id="anc38"></a>
288     /**
289      * Convenience method.
290      *
<a name="39" id="anc39"></a><span class="line-modified">291      * Add an empty constructor to this class that does nothing but calling</span>
<span class="line-removed">292      * super().</span>
<span class="line-removed">293      *</span>
294      * @param access_flags rights for constructor
295      */
<a name="40" id="anc40"></a><span class="line-modified">296     public void addEmptyConstructor(final int access_flags) {</span>
297         final InstructionList il = new InstructionList();
298         il.append(InstructionConst.THIS); // Push `this&#39;
299         il.append(new INVOKESPECIAL(cp.addMethodref(super_class_name, &quot;&lt;init&gt;&quot;, &quot;()V&quot;)));
300         il.append(InstructionConst.RETURN);
301         final MethodGen mg = new MethodGen(access_flags, Type.VOID, Type.NO_ARGS, null, &quot;&lt;init&gt;&quot;,
302                 class_name, il, cp);
303         mg.setMaxStack(1);
304         addMethod(mg.getMethod());
305     }
306 
<a name="41" id="anc41"></a>
307     /**
308      * Add a field to this class.
<a name="42" id="anc42"></a><span class="line-removed">309      *</span>
310      * @param f field to add
311      */
<a name="43" id="anc43"></a><span class="line-modified">312     public final void addField(final Field f) {</span>
313         field_vec.add(f);
314     }
315 
<a name="44" id="anc44"></a><span class="line-modified">316     public boolean containsField(final Field f) {</span>

317         return field_vec.contains(f);
318     }
319 
<a name="45" id="anc45"></a><span class="line-modified">320     /**</span>
<span class="line-modified">321      * @return field object with given name, or null</span>
322      */
<a name="46" id="anc46"></a><span class="line-modified">323     public Field containsField(final String name) {</span>
324         for (final Field f : field_vec) {
325             if (f.getName().equals(name)) {
326                 return f;
327             }
328         }
329         return null;
330     }
331 
<a name="47" id="anc47"></a><span class="line-modified">332     /**</span>
<span class="line-modified">333      * @return method object with given name and signature, or null</span>
334      */
<a name="48" id="anc48"></a><span class="line-modified">335     public Method containsMethod(final String name, final String signature) {</span>
336         for (final Method m : method_vec) {
337             if (m.getName().equals(name) &amp;&amp; m.getSignature().equals(signature)) {
338                 return m;
339             }
340         }
341         return null;
342     }
343 
<a name="49" id="anc49"></a>
344     /**
345      * Remove an attribute from this class.
<a name="50" id="anc50"></a><span class="line-removed">346      *</span>
347      * @param a attribute to remove
348      */
<a name="51" id="anc51"></a><span class="line-modified">349     public void removeAttribute(final Attribute a) {</span>
350         attribute_vec.remove(a);
351     }
352 
<a name="52" id="anc52"></a>
353     /**
354      * Remove a method from this class.
<a name="53" id="anc53"></a><span class="line-removed">355      *</span>
356      * @param m method to remove
357      */
<a name="54" id="anc54"></a><span class="line-modified">358     public void removeMethod(final Method m) {</span>
359         method_vec.remove(m);
360     }
361 
<a name="55" id="anc55"></a><span class="line-modified">362     /**</span>
<span class="line-modified">363      * Replace given method with new one. If the old one does not exist add the</span>
<span class="line-modified">364      * new_ method to the class anyway.</span>
365      */
<a name="56" id="anc56"></a><span class="line-modified">366     public void replaceMethod(final Method old, final Method new_) {</span>
367         if (new_ == null) {
368             throw new ClassGenException(&quot;Replacement method must not be null&quot;);
369         }
370         final int i = method_vec.indexOf(old);
371         if (i &lt; 0) {
372             method_vec.add(new_);
373         } else {
374             method_vec.set(i, new_);
375         }
376     }
377 
<a name="57" id="anc57"></a><span class="line-modified">378     /**</span>
<span class="line-modified">379      * Replace given field with new one. If the old one does not exist add the</span>
<span class="line-modified">380      * new_ field to the class anyway.</span>
381      */
<a name="58" id="anc58"></a><span class="line-modified">382     public void replaceField(final Field old, final Field new_) {</span>
383         if (new_ == null) {
384             throw new ClassGenException(&quot;Replacement method must not be null&quot;);
385         }
386         final int i = field_vec.indexOf(old);
387         if (i &lt; 0) {
388             field_vec.add(new_);
389         } else {
390             field_vec.set(i, new_);
391         }
392     }
393 
<a name="59" id="anc59"></a>
394     /**
395      * Remove a field to this class.
<a name="60" id="anc60"></a><span class="line-removed">396      *</span>
397      * @param f field to remove
398      */
<a name="61" id="anc61"></a><span class="line-modified">399     public void removeField(final Field f) {</span>
400         field_vec.remove(f);
401     }
402 
<a name="62" id="anc62"></a>
403     public String getClassName() {
404         return class_name;
405     }
406 
<a name="63" id="anc63"></a>
407     public String getSuperclassName() {
408         return super_class_name;
409     }
410 
<a name="64" id="anc64"></a>
411     public String getFileName() {
412         return file_name;
413     }
414 
<a name="65" id="anc65"></a><span class="line-modified">415     public void setClassName(final String name) {</span>

416         class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
417         class_name_index = cp.addClass(name);
418     }
419 
<a name="66" id="anc66"></a><span class="line-modified">420     public void setSuperclassName(final String name) {</span>

421         super_class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
422         superclass_name_index = cp.addClass(name);
423     }
424 
<a name="67" id="anc67"></a>
425     public Method[] getMethods() {
426         return method_vec.toArray(new Method[method_vec.size()]);
427     }
428 
<a name="68" id="anc68"></a><span class="line-modified">429     public void setMethods(final Method[] methods) {</span>

430         method_vec.clear();
431         for (final Method method : methods) {
432             addMethod(method);
433         }
434     }
435 
<a name="69" id="anc69"></a><span class="line-modified">436     public void setMethodAt(final Method method, final int pos) {</span>

437         method_vec.set(pos, method);
438     }
439 
<a name="70" id="anc70"></a><span class="line-modified">440     public Method getMethodAt(final int pos) {</span>

441         return method_vec.get(pos);
442     }
443 
<a name="71" id="anc71"></a>
444     public String[] getInterfaceNames() {
445         final int size = interface_vec.size();
446         final String[] interfaces = new String[size];
447         interface_vec.toArray(interfaces);
448         return interfaces;
449     }
450 
<a name="72" id="anc72"></a>
451     public int[] getInterfaces() {
452         final int size = interface_vec.size();
453         final int[] interfaces = new int[size];
454         for (int i = 0; i &lt; size; i++) {
455             interfaces[i] = cp.addClass(interface_vec.get(i));
456         }
457         return interfaces;
458     }
459 
<a name="73" id="anc73"></a>
460     public Field[] getFields() {
461         return field_vec.toArray(new Field[field_vec.size()]);
462     }
463 
<a name="74" id="anc74"></a>
464     public Attribute[] getAttributes() {
465         return attribute_vec.toArray(new Attribute[attribute_vec.size()]);
466     }
467 
468     //  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?
469     public AnnotationEntryGen[] getAnnotationEntries() {
470         return annotation_vec.toArray(new AnnotationEntryGen[annotation_vec.size()]);
471     }
472 
<a name="75" id="anc75"></a>
473     public ConstantPoolGen getConstantPool() {
474         return cp;
475     }
476 
<a name="76" id="anc76"></a><span class="line-modified">477     public void setConstantPool(final ConstantPoolGen constant_pool) {</span>

478         cp = constant_pool;
479     }
480 
<a name="77" id="anc77"></a><span class="line-modified">481     public void setClassNameIndex(final int class_name_index) {</span>

482         this.class_name_index = class_name_index;
483         class_name = cp.getConstantPool().getConstantString(class_name_index,
484                 Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
485     }
486 
<a name="78" id="anc78"></a><span class="line-modified">487     public void setSuperclassNameIndex(final int superclass_name_index) {</span>

488         this.superclass_name_index = superclass_name_index;
489         super_class_name = cp.getConstantPool().getConstantString(superclass_name_index,
490                 Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
491     }
492 
<a name="79" id="anc79"></a>
493     public int getSuperclassNameIndex() {
494         return superclass_name_index;
495     }
496 
<a name="80" id="anc80"></a>
497     public int getClassNameIndex() {
498         return class_name_index;
499     }
500 
501     private List&lt;ClassObserver&gt; observers;
502 
<a name="81" id="anc81"></a><span class="line-modified">503     /**</span>
<span class="line-modified">504      * Add observer for this object.</span>
505      */
<a name="82" id="anc82"></a><span class="line-modified">506     public void addObserver(final ClassObserver o) {</span>
507         if (observers == null) {
508             observers = new ArrayList&lt;&gt;();
509         }
510         observers.add(o);
511     }
512 
<a name="83" id="anc83"></a><span class="line-modified">513     /**</span>
<span class="line-modified">514      * Remove observer for this object.</span>
515      */
<a name="84" id="anc84"></a><span class="line-modified">516     public void removeObserver(final ClassObserver o) {</span>
517         if (observers != null) {
518             observers.remove(o);
519         }
520     }
521 
<a name="85" id="anc85"></a><span class="line-modified">522     /**</span>
<span class="line-modified">523      * Call notify() method on all observers. This method is not called</span>
<span class="line-modified">524      * automatically whenever the state has changed, but has to be called by the</span>
<span class="line-modified">525      * user after he has finished editing the object.</span>
526      */
527     public void update() {
528         if (observers != null) {
529             for (final ClassObserver observer : observers) {
530                 observer.notify(this);
531             }
532         }
533     }
534 
<a name="86" id="anc86"></a>
535     @Override
536     public Object clone() {
537         try {
538             return super.clone();
539         } catch (final CloneNotSupportedException e) {
540             throw new Error(&quot;Clone Not Supported&quot;); // never happens
541         }
542     }
543 
<a name="87" id="anc87"></a>
544     /**
545      * @return Comparison strategy object
546      */
547     public static BCELComparator getComparator() {
548         return _cmp;
549     }
550 
<a name="88" id="anc88"></a>
551     /**
552      * @param comparator Comparison strategy object
553      */
<a name="89" id="anc89"></a><span class="line-modified">554     public static void setComparator(final BCELComparator comparator) {</span>
555         _cmp = comparator;
556     }
557 
<a name="90" id="anc90"></a>
558     /**
<a name="91" id="anc91"></a><span class="line-modified">559      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">560      * ClassGen objects are said to be equal when their class names are equal.</span>

561      *
562      * @see java.lang.Object#equals(java.lang.Object)
563      */
564     @Override
<a name="92" id="anc92"></a><span class="line-modified">565     public boolean equals(final Object obj) {</span>
566         return _cmp.equals(this, obj);
567     }
568 
<a name="93" id="anc93"></a>
569     /**
<a name="94" id="anc94"></a><span class="line-modified">570      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">571      * return the hashcode of the class name.</span>
572      *
573      * @see java.lang.Object#hashCode()
574      */
575     @Override
576     public int hashCode() {
577         return _cmp.hashCode(this);
578     }
579 }
<a name="95" id="anc95"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="95" type="hidden" />
</body>
</html>
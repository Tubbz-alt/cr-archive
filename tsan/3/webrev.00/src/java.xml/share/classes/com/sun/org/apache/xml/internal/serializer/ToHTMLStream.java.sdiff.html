<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToHTMLStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SerializerBase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ToStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToHTMLStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xml.internal.serializer;
  22 
  23 import java.io.IOException;
  24 import java.util.Properties;
  25 
  26 import javax.xml.transform.Result;
  27 
  28 import org.xml.sax.Attributes;
  29 import org.xml.sax.SAXException;
  30 
  31 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
  32 import com.sun.org.apache.xml.internal.serializer.utils.Utils;

  33 
  34 /**
  35  * This serializer takes a series of SAX or
  36  * SAX-like events and writes its output
  37  * to the given stream.
  38  *
  39  * This class is not a public API, it is public
  40  * because it is used from another package.
  41  *
  42  * @xsl.usage internal
<span class="line-modified">  43  * @LastModified: Sept 2018</span>
  44  */
  45 public final class ToHTMLStream extends ToStream
  46 {
  47 
  48     /** This flag is set while receiving events from the DTD */
  49     protected boolean m_inDTD = false;
  50 
  51     /** True if the previous element is a block element. */
  52     private boolean m_isprevblock = false;
  53 
  54     /**
  55      * Map that tells which XML characters should have special treatment, and it
  56      *  provides character to entity name lookup.
  57      */
  58     private static final CharInfo m_htmlcharInfo =
  59 //        new CharInfo(CharInfo.HTML_ENTITIES_RESOURCE);
  60         CharInfo.getCharInfoInternal(CharInfo.HTML_ENTITIES_RESOURCE, Method.HTML);
  61 
  62     /** A digital search trie for fast, case insensitive lookup of ElemDesc objects. */
  63     static final Trie m_elementFlags = new Trie();
</pre>
<hr />
<pre>
 621      * method Trie.get2(name)
 622      */
 623     private Trie m_htmlInfo = new Trie(m_elementFlags);
 624     /**
 625      * Calls to this method could be replaced with calls to
 626      * getElemDesc(name), but this one should be faster.
 627      */
 628     private ElemDesc getElemDesc2(String name)
 629     {
 630         Object obj = m_htmlInfo.get2(name);
 631         if (null != obj)
 632             return (ElemDesc)obj;
 633         return m_dummy;
 634     }
 635 
 636     /**
 637      * Default constructor.
 638      */
 639     public ToHTMLStream()
 640     {


 641 
<span class="line-modified"> 642         super();</span>


 643         m_charInfo = m_htmlcharInfo;
 644         // initialize namespaces
 645         m_prefixMap = new NamespaceMappings();
<span class="line-removed"> 646 </span>
 647     }
 648 
 649     /** The name of the current element. */
 650 //    private String m_currentElementName = null;
 651 
 652     /**
 653      * Receive notification of the beginning of a document.
 654      *
 655      * @throws org.xml.sax.SAXException Any SAX exception, possibly
 656      *            wrapping another exception.
 657      *
 658      * @throws org.xml.sax.SAXException
 659      */
 660     protected void startDocumentInternal() throws org.xml.sax.SAXException
 661     {
 662         super.startDocumentInternal();
 663 
 664         m_needToCallStartDocument = false;
 665         m_needToOutputDocTypeDecl = true;
 666         m_startNewLine = false;
</pre>
<hr />
<pre>
 702                 {
 703                     throw new SAXException(e);
 704                 }
 705             }
 706         }
 707 
 708         m_needToOutputDocTypeDecl = false;
 709     }
 710 
 711     /**
 712      * Receive notification of the end of a document.
 713      *
 714      * @throws org.xml.sax.SAXException Any SAX exception, possibly
 715      *            wrapping another exception.
 716      *
 717      * @throws org.xml.sax.SAXException
 718      */
 719     public final void endDocument() throws org.xml.sax.SAXException
 720     {
 721         if (m_doIndent) {
<span class="line-modified"> 722             flushCharactersBuffer();</span>
 723         }
 724         flushPending();
 725         if (m_doIndent &amp;&amp; !m_isprevtext)
 726         {
 727             try
 728             {
 729             outputLineSep();
 730             }
 731             catch(IOException e)
 732             {
 733                 throw new SAXException(e);
 734             }
 735         }
 736 
 737         flushWriter();
 738         if (m_tracer != null)
 739             super.fireEndDoc();
 740     }
 741 
 742     /**
</pre>
<hr />
<pre>
 765      * @param localName
 766      * @param name
 767      *            The element type name.
 768      * @param atts
 769      *            The attributes attached to the element, if any.
 770      * @throws org.xml.sax.SAXException
 771      *             Any SAX exception, possibly wrapping another exception.
 772      * @see #endElement
 773      * @see org.xml.sax.AttributeList
 774      */
 775     public void startElement(
 776         String namespaceURI,
 777         String localName,
 778         String name,
 779         Attributes atts)
 780         throws SAXException
 781     {
 782         if (m_doIndent) {
 783             // will add extra one if having namespace but no matter
 784             m_childNodeNum++;
<span class="line-modified"> 785             flushCharactersBuffer();</span>
 786         }
 787         ElemContext elemContext = m_elemContext;
 788 
 789         // clean up any pending things first
 790         if (elemContext.m_startTagOpen)
 791         {
 792             closeStartTag();
 793             elemContext.m_startTagOpen = false;
 794         }
 795         else if (m_cdataTagOpen)
 796         {
 797             closeCDATA();
 798             m_cdataTagOpen = false;
 799         }
 800         else if (m_needToCallStartDocument)
 801         {
 802             startDocumentInternal();
 803             m_needToCallStartDocument = false;
 804         }
 805 
</pre>
<hr />
<pre>
 906         }
 907     }
 908 
 909     /**
 910      *  Receive notification of the end of an element.
 911      *
 912      *
 913      *  @param namespaceURI
 914      *  @param localName
 915      *  @param name The element type name
 916      *  @throws org.xml.sax.SAXException Any SAX exception, possibly
 917      *             wrapping another exception.
 918      */
 919     public final void endElement(
 920         final String namespaceURI,
 921         final String localName,
 922         final String name)
 923         throws org.xml.sax.SAXException
 924     {
 925         if (m_doIndent) {
<span class="line-modified"> 926             flushCharactersBuffer();</span>
 927         }
 928         // deal with any pending issues
 929         if (m_cdataTagOpen)
 930             closeCDATA();
 931 
 932         // if the element has a namespace, treat it like XML, not HTML
 933         if (null != namespaceURI &amp;&amp; namespaceURI.length() &gt; 0)
 934         {
 935             super.endElement(namespaceURI, localName, name);
 936 
 937             return;
 938         }
 939 
 940         try
 941         {
 942 
 943             ElemContext elemContext = m_elemContext;
 944             final ElemDesc elemDesc = elemContext.m_elementDesc;
 945             final int elemFlags = elemDesc.getFlags();
 946             final boolean elemEmpty = (elemFlags &amp; ElemDesc.EMPTY) != 0;
</pre>
<hr />
<pre>
1628             super.cdata(ch, start, length);
1629         }
1630     }
1631 
1632     /**
1633      *  Receive notification of a processing instruction.
1634      *
1635      *  @param target The processing instruction target.
1636      *  @param data The processing instruction data, or null if
1637      *         none was supplied.
1638      *  @throws org.xml.sax.SAXException Any SAX exception, possibly
1639      *             wrapping another exception.
1640      *
1641      * @throws org.xml.sax.SAXException
1642      */
1643     public void processingInstruction(String target, String data)
1644         throws org.xml.sax.SAXException
1645     {
1646         if (m_doIndent) {
1647             m_childNodeNum++;
<span class="line-modified">1648             flushCharactersBuffer();</span>
1649         }
1650         // Process any pending starDocument and startElement first.
1651         flushPending();
1652 
1653         // Use a fairly nasty hack to tell if the next node is supposed to be
1654         // unescaped text.
1655         if (target.equals(Result.PI_DISABLE_OUTPUT_ESCAPING))
1656         {
1657             startNonEscaping();
1658         }
1659         else if (target.equals(Result.PI_ENABLE_OUTPUT_ESCAPING))
1660         {
1661             endNonEscaping();
1662         }
1663         else
1664         {
1665             try
1666             {
1667             if (m_elemContext.m_startTagOpen)
1668             {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xml.internal.serializer;
  22 
  23 import java.io.IOException;
  24 import java.util.Properties;
  25 
  26 import javax.xml.transform.Result;
  27 
  28 import org.xml.sax.Attributes;
  29 import org.xml.sax.SAXException;
  30 
  31 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
  32 import com.sun.org.apache.xml.internal.serializer.utils.Utils;
<span class="line-added">  33 import javax.xml.transform.ErrorListener;</span>
  34 
  35 /**
  36  * This serializer takes a series of SAX or
  37  * SAX-like events and writes its output
  38  * to the given stream.
  39  *
  40  * This class is not a public API, it is public
  41  * because it is used from another package.
  42  *
  43  * @xsl.usage internal
<span class="line-modified">  44  * @LastModified: Aug 2019</span>
  45  */
  46 public final class ToHTMLStream extends ToStream
  47 {
  48 
  49     /** This flag is set while receiving events from the DTD */
  50     protected boolean m_inDTD = false;
  51 
  52     /** True if the previous element is a block element. */
  53     private boolean m_isprevblock = false;
  54 
  55     /**
  56      * Map that tells which XML characters should have special treatment, and it
  57      *  provides character to entity name lookup.
  58      */
  59     private static final CharInfo m_htmlcharInfo =
  60 //        new CharInfo(CharInfo.HTML_ENTITIES_RESOURCE);
  61         CharInfo.getCharInfoInternal(CharInfo.HTML_ENTITIES_RESOURCE, Method.HTML);
  62 
  63     /** A digital search trie for fast, case insensitive lookup of ElemDesc objects. */
  64     static final Trie m_elementFlags = new Trie();
</pre>
<hr />
<pre>
 622      * method Trie.get2(name)
 623      */
 624     private Trie m_htmlInfo = new Trie(m_elementFlags);
 625     /**
 626      * Calls to this method could be replaced with calls to
 627      * getElemDesc(name), but this one should be faster.
 628      */
 629     private ElemDesc getElemDesc2(String name)
 630     {
 631         Object obj = m_htmlInfo.get2(name);
 632         if (null != obj)
 633             return (ElemDesc)obj;
 634         return m_dummy;
 635     }
 636 
 637     /**
 638      * Default constructor.
 639      */
 640     public ToHTMLStream()
 641     {
<span class="line-added"> 642         this(null);</span>
<span class="line-added"> 643     }</span>
 644 
<span class="line-modified"> 645     public ToHTMLStream(ErrorListener l)</span>
<span class="line-added"> 646     {</span>
<span class="line-added"> 647         super(l);</span>
 648         m_charInfo = m_htmlcharInfo;
 649         // initialize namespaces
 650         m_prefixMap = new NamespaceMappings();

 651     }
 652 
 653     /** The name of the current element. */
 654 //    private String m_currentElementName = null;
 655 
 656     /**
 657      * Receive notification of the beginning of a document.
 658      *
 659      * @throws org.xml.sax.SAXException Any SAX exception, possibly
 660      *            wrapping another exception.
 661      *
 662      * @throws org.xml.sax.SAXException
 663      */
 664     protected void startDocumentInternal() throws org.xml.sax.SAXException
 665     {
 666         super.startDocumentInternal();
 667 
 668         m_needToCallStartDocument = false;
 669         m_needToOutputDocTypeDecl = true;
 670         m_startNewLine = false;
</pre>
<hr />
<pre>
 706                 {
 707                     throw new SAXException(e);
 708                 }
 709             }
 710         }
 711 
 712         m_needToOutputDocTypeDecl = false;
 713     }
 714 
 715     /**
 716      * Receive notification of the end of a document.
 717      *
 718      * @throws org.xml.sax.SAXException Any SAX exception, possibly
 719      *            wrapping another exception.
 720      *
 721      * @throws org.xml.sax.SAXException
 722      */
 723     public final void endDocument() throws org.xml.sax.SAXException
 724     {
 725         if (m_doIndent) {
<span class="line-modified"> 726             flushCharactersBuffer(false);</span>
 727         }
 728         flushPending();
 729         if (m_doIndent &amp;&amp; !m_isprevtext)
 730         {
 731             try
 732             {
 733             outputLineSep();
 734             }
 735             catch(IOException e)
 736             {
 737                 throw new SAXException(e);
 738             }
 739         }
 740 
 741         flushWriter();
 742         if (m_tracer != null)
 743             super.fireEndDoc();
 744     }
 745 
 746     /**
</pre>
<hr />
<pre>
 769      * @param localName
 770      * @param name
 771      *            The element type name.
 772      * @param atts
 773      *            The attributes attached to the element, if any.
 774      * @throws org.xml.sax.SAXException
 775      *             Any SAX exception, possibly wrapping another exception.
 776      * @see #endElement
 777      * @see org.xml.sax.AttributeList
 778      */
 779     public void startElement(
 780         String namespaceURI,
 781         String localName,
 782         String name,
 783         Attributes atts)
 784         throws SAXException
 785     {
 786         if (m_doIndent) {
 787             // will add extra one if having namespace but no matter
 788             m_childNodeNum++;
<span class="line-modified"> 789             flushCharactersBuffer(false);</span>
 790         }
 791         ElemContext elemContext = m_elemContext;
 792 
 793         // clean up any pending things first
 794         if (elemContext.m_startTagOpen)
 795         {
 796             closeStartTag();
 797             elemContext.m_startTagOpen = false;
 798         }
 799         else if (m_cdataTagOpen)
 800         {
 801             closeCDATA();
 802             m_cdataTagOpen = false;
 803         }
 804         else if (m_needToCallStartDocument)
 805         {
 806             startDocumentInternal();
 807             m_needToCallStartDocument = false;
 808         }
 809 
</pre>
<hr />
<pre>
 910         }
 911     }
 912 
 913     /**
 914      *  Receive notification of the end of an element.
 915      *
 916      *
 917      *  @param namespaceURI
 918      *  @param localName
 919      *  @param name The element type name
 920      *  @throws org.xml.sax.SAXException Any SAX exception, possibly
 921      *             wrapping another exception.
 922      */
 923     public final void endElement(
 924         final String namespaceURI,
 925         final String localName,
 926         final String name)
 927         throws org.xml.sax.SAXException
 928     {
 929         if (m_doIndent) {
<span class="line-modified"> 930             flushCharactersBuffer(false);</span>
 931         }
 932         // deal with any pending issues
 933         if (m_cdataTagOpen)
 934             closeCDATA();
 935 
 936         // if the element has a namespace, treat it like XML, not HTML
 937         if (null != namespaceURI &amp;&amp; namespaceURI.length() &gt; 0)
 938         {
 939             super.endElement(namespaceURI, localName, name);
 940 
 941             return;
 942         }
 943 
 944         try
 945         {
 946 
 947             ElemContext elemContext = m_elemContext;
 948             final ElemDesc elemDesc = elemContext.m_elementDesc;
 949             final int elemFlags = elemDesc.getFlags();
 950             final boolean elemEmpty = (elemFlags &amp; ElemDesc.EMPTY) != 0;
</pre>
<hr />
<pre>
1632             super.cdata(ch, start, length);
1633         }
1634     }
1635 
1636     /**
1637      *  Receive notification of a processing instruction.
1638      *
1639      *  @param target The processing instruction target.
1640      *  @param data The processing instruction data, or null if
1641      *         none was supplied.
1642      *  @throws org.xml.sax.SAXException Any SAX exception, possibly
1643      *             wrapping another exception.
1644      *
1645      * @throws org.xml.sax.SAXException
1646      */
1647     public void processingInstruction(String target, String data)
1648         throws org.xml.sax.SAXException
1649     {
1650         if (m_doIndent) {
1651             m_childNodeNum++;
<span class="line-modified">1652             flushCharactersBuffer(false);</span>
1653         }
1654         // Process any pending starDocument and startElement first.
1655         flushPending();
1656 
1657         // Use a fairly nasty hack to tell if the next node is supposed to be
1658         // unescaped text.
1659         if (target.equals(Result.PI_DISABLE_OUTPUT_ESCAPING))
1660         {
1661             startNonEscaping();
1662         }
1663         else if (target.equals(Result.PI_ENABLE_OUTPUT_ESCAPING))
1664         {
1665             endNonEscaping();
1666         }
1667         else
1668         {
1669             try
1670             {
1671             if (m_elemContext.m_startTagOpen)
1672             {
</pre>
</td>
</tr>
</table>
<center><a href="SerializerBase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ToStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
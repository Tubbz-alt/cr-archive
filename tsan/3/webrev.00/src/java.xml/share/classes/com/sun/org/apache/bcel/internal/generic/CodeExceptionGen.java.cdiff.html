<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/CodeExceptionGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassObserver.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompoundInstruction.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/CodeExceptionGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,33 ***</span>
  package com.sun.org.apache.bcel.internal.generic;
  
  import com.sun.org.apache.bcel.internal.classfile.CodeException;
  
  /**
<span class="line-modified">!  * This class represents an exception handler, i.e., specifies the region where</span>
   * a handler is active and an instruction where the actual handling is done.
   * pool as parameters. Opposed to the JVM specification the end of the handled
   * region is set to be inclusive, i.e. all instructions between start and end
   * are protected including the start and end instructions (handles) themselves.
   * The end of the region is automatically mapped to be exclusive when calling
   * getCodeException(), i.e., there is no difference semantically.
   *
<span class="line-modified">!  * @version $Id: CodeExceptionGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
<span class="line-modified">!  * @see MethodGen</span>
<span class="line-modified">!  * @see CodeException</span>
<span class="line-removed">-  * @see InstructionHandle</span>
   */
  public final class CodeExceptionGen implements InstructionTargeter, Cloneable {
  
      private InstructionHandle start_pc;
      private InstructionHandle end_pc;
      private InstructionHandle handler_pc;
      private ObjectType catch_type;
  
      /**
<span class="line-modified">!      * Add an exception handler, i.e., specify region where a handler is active</span>
<span class="line-modified">!      * and an instruction where the actual handling is done.</span>
       *
       * @param start_pc Start of handled region (inclusive)
       * @param end_pc End of handled region (inclusive)
       * @param handler_pc Where handling is done
       * @param catch_type which exception is handled, null for ANY
<span class="line-new-header">--- 21,33 ---</span>
  package com.sun.org.apache.bcel.internal.generic;
  
  import com.sun.org.apache.bcel.internal.classfile.CodeException;
  
  /**
<span class="line-modified">!  * This class represents an exception handler, i.e., specifies the  region where</span>
   * a handler is active and an instruction where the actual handling is done.
   * pool as parameters. Opposed to the JVM specification the end of the handled
   * region is set to be inclusive, i.e. all instructions between start and end
   * are protected including the start and end instructions (handles) themselves.
   * The end of the region is automatically mapped to be exclusive when calling
   * getCodeException(), i.e., there is no difference semantically.
   *
<span class="line-modified">!  * @see     MethodGen</span>
<span class="line-modified">!  * @see     CodeException</span>
<span class="line-modified">!  * @see     InstructionHandle</span>
   */
  public final class CodeExceptionGen implements InstructionTargeter, Cloneable {
  
      private InstructionHandle start_pc;
      private InstructionHandle end_pc;
      private InstructionHandle handler_pc;
      private ObjectType catch_type;
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add an exception handler, i.e., specify region where a handler is active and an</span>
<span class="line-modified">!      * instruction where the actual handling is done.</span>
       *
       * @param start_pc Start of handled region (inclusive)
       * @param end_pc End of handled region (inclusive)
       * @param handler_pc Where handling is done
       * @param catch_type which exception is handled, null for ANY
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,58 ***</span>
          setEndPC(end_pc);
          setHandlerPC(handler_pc);
          this.catch_type = catch_type;
      }
  
      /**
       * Get CodeException object.&lt;BR&gt;
       *
<span class="line-modified">!      * This relies on that the instruction list has already been dumped to byte</span>
<span class="line-modified">!      * code or or that the `setPositions&#39; methods has been called for the</span>
<span class="line-modified">!      * instruction list.</span>
       *
       * @param cp constant pool
       */
<span class="line-modified">!     public CodeException getCodeException(final ConstantPoolGen cp) {</span>
          return new CodeException(start_pc.getPosition(), end_pc.getPosition()
                  + end_pc.getInstruction().getLength(), handler_pc.getPosition(),
                  (catch_type == null) ? 0 : cp.addClass(catch_type));
      }
  
  
      /* Set start of handler
       * @param start_pc Start of handled region (inclusive)
       */
<span class="line-modified">!     public void setStartPC(final InstructionHandle start_pc) { // TODO could be package-protected?</span>
          BranchInstruction.notifyTarget(this.start_pc, start_pc, this);
          this.start_pc = start_pc;
      }
  
  
      /* Set end of handler
       * @param end_pc End of handled region (inclusive)
       */
<span class="line-modified">!     public void setEndPC(final InstructionHandle end_pc) { // TODO could be package-protected?</span>
          BranchInstruction.notifyTarget(this.end_pc, end_pc, this);
          this.end_pc = end_pc;
      }
  
  
      /* Set handler code
       * @param handler_pc Start of handler
       */
<span class="line-modified">!     public void setHandlerPC(final InstructionHandle handler_pc) { // TODO could be package-protected?</span>
          BranchInstruction.notifyTarget(this.handler_pc, handler_pc, this);
          this.handler_pc = handler_pc;
      }
  
      /**
       * @param old_ih old target, either start or end
       * @param new_ih new target
       */
      @Override
<span class="line-modified">!     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {</span>
          boolean targeted = false;
          if (start_pc == old_ih) {
              targeted = true;
              setStartPC(new_ih);
          }
<span class="line-new-header">--- 58,60 ---</span>
          setEndPC(end_pc);
          setHandlerPC(handler_pc);
          this.catch_type = catch_type;
      }
  
<span class="line-added">+ </span>
      /**
       * Get CodeException object.&lt;BR&gt;
       *
<span class="line-modified">!      * This relies on that the instruction list has already been dumped</span>
<span class="line-modified">!      * to byte code or or that the `setPositions&#39; methods has been</span>
<span class="line-modified">!      * called for the instruction list.</span>
       *
       * @param cp constant pool
       */
<span class="line-modified">!     public CodeException getCodeException( final ConstantPoolGen cp ) {</span>
          return new CodeException(start_pc.getPosition(), end_pc.getPosition()
                  + end_pc.getInstruction().getLength(), handler_pc.getPosition(),
                  (catch_type == null) ? 0 : cp.addClass(catch_type));
      }
  
  
      /* Set start of handler
       * @param start_pc Start of handled region (inclusive)
       */
<span class="line-modified">!     public void setStartPC( final InstructionHandle start_pc ) { // TODO could be package-protected?</span>
          BranchInstruction.notifyTarget(this.start_pc, start_pc, this);
          this.start_pc = start_pc;
      }
  
  
      /* Set end of handler
       * @param end_pc End of handled region (inclusive)
       */
<span class="line-modified">!     public void setEndPC( final InstructionHandle end_pc ) { // TODO could be package-protected?</span>
          BranchInstruction.notifyTarget(this.end_pc, end_pc, this);
          this.end_pc = end_pc;
      }
  
  
      /* Set handler code
       * @param handler_pc Start of handler
       */
<span class="line-modified">!     public void setHandlerPC( final InstructionHandle handler_pc ) { // TODO could be package-protected?</span>
          BranchInstruction.notifyTarget(this.handler_pc, handler_pc, this);
          this.handler_pc = handler_pc;
      }
  
<span class="line-added">+ </span>
      /**
       * @param old_ih old target, either start or end
       * @param new_ih new target
       */
      @Override
<span class="line-modified">!     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
          boolean targeted = false;
          if (start_pc == old_ih) {
              targeted = true;
              setStartPC(new_ih);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,58 ***</span>
              throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but {&quot; + start_pc + &quot;, &quot;
                      + end_pc + &quot;, &quot; + handler_pc + &quot;}&quot;);
          }
      }
  
      /**
       * @return true, if ih is target of this handler
       */
      @Override
<span class="line-modified">!     public boolean containsTarget(final InstructionHandle ih) {</span>
          return (start_pc == ih) || (end_pc == ih) || (handler_pc == ih);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Sets the type of the Exception to catch. Set &#39;null&#39; for ANY.</span>
<span class="line-modified">!      */</span>
<span class="line-removed">-     public void setCatchType(final ObjectType catch_type) {</span>
          this.catch_type = catch_type;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Gets the type of the Exception to catch, &#39;null&#39; for ANY.</span>
<span class="line-removed">-      */</span>
      public ObjectType getCatchType() {
          return catch_type;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return start of handled region (inclusive)</span>
       */
      public InstructionHandle getStartPC() {
          return start_pc;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return end of handled region (inclusive)</span>
       */
      public InstructionHandle getEndPC() {
          return end_pc;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return start of handler</span>
       */
      public InstructionHandle getHandlerPC() {
          return handler_pc;
      }
  
      @Override
      public String toString() {
          return &quot;CodeExceptionGen(&quot; + start_pc + &quot;, &quot; + end_pc + &quot;, &quot; + handler_pc + &quot;)&quot;;
      }
  
      @Override
      public Object clone() {
          try {
              return super.clone();
          } catch (final CloneNotSupportedException e) {
<span class="line-new-header">--- 127,59 ---</span>
              throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but {&quot; + start_pc + &quot;, &quot;
                      + end_pc + &quot;, &quot; + handler_pc + &quot;}&quot;);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @return true, if ih is target of this handler
       */
      @Override
<span class="line-modified">!     public boolean containsTarget( final InstructionHandle ih ) {</span>
          return (start_pc == ih) || (end_pc == ih) || (handler_pc == ih);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Sets the type of the Exception to catch. Set &#39;null&#39; for ANY. */</span>
<span class="line-modified">!     public void setCatchType( final ObjectType catch_type ) {</span>
          this.catch_type = catch_type;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Gets the type of the Exception to catch, &#39;null&#39; for ANY. */</span>
      public ObjectType getCatchType() {
          return catch_type;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return start of handled region (inclusive)</span>
       */
      public InstructionHandle getStartPC() {
          return start_pc;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return end of handled region (inclusive)</span>
       */
      public InstructionHandle getEndPC() {
          return end_pc;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return start of handler</span>
       */
      public InstructionHandle getHandlerPC() {
          return handler_pc;
      }
  
<span class="line-added">+ </span>
      @Override
      public String toString() {
          return &quot;CodeExceptionGen(&quot; + start_pc + &quot;, &quot; + end_pc + &quot;, &quot; + handler_pc + &quot;)&quot;;
      }
  
<span class="line-added">+ </span>
      @Override
      public Object clone() {
          try {
              return super.clone();
          } catch (final CloneNotSupportedException e) {
</pre>
<center><a href="ClassObserver.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompoundInstruction.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
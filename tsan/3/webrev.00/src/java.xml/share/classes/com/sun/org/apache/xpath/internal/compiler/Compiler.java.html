<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xpath/internal/compiler/Compiler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xpath.internal.compiler;
  22 
  23 import javax.xml.transform.ErrorListener;
  24 import javax.xml.transform.SourceLocator;
  25 import javax.xml.transform.TransformerException;
  26 
  27 import com.sun.org.apache.xalan.internal.res.XSLMessages;
  28 import com.sun.org.apache.xml.internal.dtm.Axis;
  29 import com.sun.org.apache.xml.internal.dtm.DTMFilter;
  30 import com.sun.org.apache.xml.internal.dtm.DTMIterator;
  31 import com.sun.org.apache.xml.internal.utils.PrefixResolver;
  32 import com.sun.org.apache.xml.internal.utils.QName;
  33 import com.sun.org.apache.xml.internal.utils.SAXSourceLocator;
  34 import com.sun.org.apache.xpath.internal.Expression;
  35 import com.sun.org.apache.xpath.internal.axes.UnionPathIterator;
  36 import com.sun.org.apache.xpath.internal.axes.WalkerFactory;
  37 import com.sun.org.apache.xpath.internal.functions.FuncExtFunction;
  38 import com.sun.org.apache.xpath.internal.functions.FuncExtFunctionAvailable;
  39 import com.sun.org.apache.xpath.internal.functions.Function;
  40 import com.sun.org.apache.xpath.internal.functions.WrongNumberArgsException;
  41 import com.sun.org.apache.xpath.internal.objects.XNumber;
  42 import com.sun.org.apache.xpath.internal.objects.XString;
  43 import com.sun.org.apache.xpath.internal.operations.And;
  44 import com.sun.org.apache.xpath.internal.operations.Div;
  45 import com.sun.org.apache.xpath.internal.operations.Equals;
  46 import com.sun.org.apache.xpath.internal.operations.Gt;
  47 import com.sun.org.apache.xpath.internal.operations.Gte;
  48 import com.sun.org.apache.xpath.internal.operations.Lt;
  49 import com.sun.org.apache.xpath.internal.operations.Lte;
  50 import com.sun.org.apache.xpath.internal.operations.Minus;
  51 import com.sun.org.apache.xpath.internal.operations.Mod;
  52 import com.sun.org.apache.xpath.internal.operations.Mult;
  53 import com.sun.org.apache.xpath.internal.operations.Neg;
  54 import com.sun.org.apache.xpath.internal.operations.NotEquals;
  55 import com.sun.org.apache.xpath.internal.operations.Operation;
  56 import com.sun.org.apache.xpath.internal.operations.Or;
  57 import com.sun.org.apache.xpath.internal.operations.Plus;
  58 import com.sun.org.apache.xpath.internal.operations.UnaryOperation;
  59 import com.sun.org.apache.xpath.internal.operations.Variable;
  60 import com.sun.org.apache.xpath.internal.patterns.FunctionPattern;
  61 import com.sun.org.apache.xpath.internal.patterns.NodeTest;
  62 import com.sun.org.apache.xpath.internal.patterns.StepPattern;
  63 import com.sun.org.apache.xpath.internal.patterns.UnionPattern;
  64 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
  65 
  66 /**
  67  * An instance of this class compiles an XPath string expression into
  68  * a Expression object.  This class compiles the string into a sequence
  69  * of operation codes (op map) and then builds from that into an Expression
  70  * tree.
  71  * @xsl.usage advanced
  72  * @LastModified: May 2019
  73  */
  74 public class Compiler extends OpMap
  75 {
  76   // count the number of operations or calls to compileOperation
  77   int countOp;
  78 
  79   /**
  80    * Construct a Compiler object with a specific ErrorListener and
  81    * SourceLocator where the expression is located.
  82    *
  83    * @param errorHandler Error listener where messages will be sent, or null
  84    *                     if messages should be sent to System err.
  85    * @param locator The location object where the expression lives, which
  86    *                may be null, but which, if not null, must be valid over
  87    *                the long haul, in other words, it will not be cloned.
  88    * @param fTable  The FunctionTable object where the xpath build-in
  89    *                functions are stored.
  90    */
  91   public Compiler(ErrorListener errorHandler, SourceLocator locator,
  92             FunctionTable fTable)
  93   {
  94     m_errorHandler = errorHandler;
  95     m_locator = locator;
  96     m_functionTable = fTable;
  97   }
  98 
  99   /**
 100    * Construct a Compiler instance that has a null error listener and a
 101    * null source locator.
 102    */
 103   public Compiler()
 104   {
 105     m_errorHandler = null;
 106     m_locator = null;
 107   }
 108 
 109   /**
 110    * Execute the XPath object from a given opcode position.
 111    *
 112    * Note that this method is added so that when StackOverflowError is caught
 113    * the address space can be freed to this point allowing further activities
 114    * such as reporting the error.
 115    *
 116    * @param opPos The current position in the xpath.m_opMap array.
 117    * @return The result of the XPath.
 118    *
 119    * @throws TransformerException if there is a syntax or other error.
 120    * @xsl.usage advanced
 121    */
 122    public Expression compileExpression(int opPos) throws TransformerException
 123    {
 124        try {
 125            countOp = 0;
 126            return compile(opPos);
 127        } catch (StackOverflowError sof) {
 128            error(XPATHErrorResources.ER_COMPILATION_TOO_MANY_OPERATION, new Object[]{countOp});
 129        }
 130        return null;
 131    }
 132 
 133   /**
 134    * This method handles the actual compilation process. It is called from the
 135    * compileExpression method as well as the subsequent processes. See the note
 136    * for compileExpression.
 137    *
 138    * @param opPos The current position in the xpath.m_opMap array.
 139    * @return The result of the XPath.
 140    *
 141    * @throws TransformerException if there is a syntax or other error.
 142    */
 143   private Expression compile(int opPos) throws TransformerException
 144   {
 145     int op = getOp(opPos);
 146 
 147     Expression expr = null;
 148     // System.out.println(getPatternString()+&quot;op: &quot;+op);
 149     switch (op)
 150     {
 151     case OpCodes.OP_XPATH :
 152       expr = compile(opPos + 2); break;
 153     case OpCodes.OP_OR :
 154       expr = or(opPos); break;
 155     case OpCodes.OP_AND :
 156       expr = and(opPos); break;
 157     case OpCodes.OP_NOTEQUALS :
 158       expr = notequals(opPos); break;
 159     case OpCodes.OP_EQUALS :
 160       expr = equals(opPos); break;
 161     case OpCodes.OP_LTE :
 162       expr = lte(opPos); break;
 163     case OpCodes.OP_LT :
 164       expr = lt(opPos); break;
 165     case OpCodes.OP_GTE :
 166       expr = gte(opPos); break;
 167     case OpCodes.OP_GT :
 168       expr = gt(opPos); break;
 169     case OpCodes.OP_PLUS :
 170       expr = plus(opPos); break;
 171     case OpCodes.OP_MINUS :
 172       expr = minus(opPos); break;
 173     case OpCodes.OP_MULT :
 174       expr = mult(opPos); break;
 175     case OpCodes.OP_DIV :
 176       expr = div(opPos); break;
 177     case OpCodes.OP_MOD :
 178       expr = mod(opPos); break;
 179 //    case OpCodes.OP_QUO :
 180 //      expr = quo(opPos); break;
 181     case OpCodes.OP_NEG :
 182       expr = neg(opPos); break;
 183     case OpCodes.OP_STRING :
 184       expr = string(opPos); break;
 185     case OpCodes.OP_BOOL :
 186       expr = bool(opPos); break;
 187     case OpCodes.OP_NUMBER :
 188       expr = number(opPos); break;
 189     case OpCodes.OP_UNION :
 190       expr = union(opPos); break;
 191     case OpCodes.OP_LITERAL :
 192       expr = literal(opPos); break;
 193     case OpCodes.OP_VARIABLE :
 194       expr = variable(opPos); break;
 195     case OpCodes.OP_GROUP :
 196       expr = group(opPos); break;
 197     case OpCodes.OP_NUMBERLIT :
 198       expr = numberlit(opPos); break;
 199     case OpCodes.OP_ARGUMENT :
 200       expr = arg(opPos); break;
 201     case OpCodes.OP_EXTFUNCTION :
 202       expr = compileExtension(opPos); break;
 203     case OpCodes.OP_FUNCTION :
 204       expr = compileFunction(opPos); break;
 205     case OpCodes.OP_LOCATIONPATH :
 206       expr = locationPath(opPos); break;
 207     case OpCodes.OP_PREDICATE :
 208       expr = null; break;  // should never hit this here.
 209     case OpCodes.OP_MATCHPATTERN :
 210       expr = matchPattern(opPos + 2); break;
 211     case OpCodes.OP_LOCATIONPATHPATTERN :
 212       expr = locationPathPattern(opPos); break;
 213     case OpCodes.OP_QUO:
 214       error(XPATHErrorResources.ER_UNKNOWN_OPCODE,
 215             new Object[]{ &quot;quo&quot; });  //&quot;ERROR! Unknown op code: &quot;+m_opMap[opPos]);
 216       break;
 217     default :
 218       error(XPATHErrorResources.ER_UNKNOWN_OPCODE,
 219             new Object[]{ Integer.toString(getOp(opPos)) });  //&quot;ERROR! Unknown op code: &quot;+m_opMap[opPos]);
 220     }
 221 //    if(null != expr)
 222 //      expr.setSourceLocator(m_locator);
 223 
 224     return expr;
 225   }
 226 
 227   /**
 228    * Bottle-neck compilation of an operation with left and right operands.
 229    *
 230    * @param operation non-null reference to parent operation.
 231    * @param opPos The op map position of the parent operation.
 232    *
 233    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Operation} instance.
 234    *
 235    * @throws TransformerException if there is a syntax or other error.
 236    */
 237   private Expression compileOperation(Operation operation, int opPos)
 238           throws TransformerException
 239   {
 240     ++countOp;
 241 
 242     int leftPos = getFirstChildPos(opPos);
 243     int rightPos = getNextOpPos(leftPos);
 244 
 245     operation.setLeftRight(compile(leftPos), compile(rightPos));
 246 
 247     return operation;
 248   }
 249 
 250   /**
 251    * Bottle-neck compilation of a unary operation.
 252    *
 253    * @param unary The parent unary operation.
 254    * @param opPos The position in the op map of the parent operation.
 255    *
 256    * @return The unary argument.
 257    *
 258    * @throws TransformerException if syntax or other error occurs.
 259    */
 260   private Expression compileUnary(UnaryOperation unary, int opPos)
 261           throws TransformerException
 262   {
 263 
 264     int rightPos = getFirstChildPos(opPos);
 265 
 266     unary.setRight(compile(rightPos));
 267 
 268     return unary;
 269   }
 270 
 271   /**
 272    * Compile an &#39;or&#39; operation.
 273    *
 274    * @param opPos The current position in the m_opMap array.
 275    *
 276    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Or} instance.
 277    *
 278    * @throws TransformerException if a error occurs creating the Expression.
 279    */
 280   protected Expression or(int opPos) throws TransformerException
 281   {
 282     return compileOperation(new Or(), opPos);
 283   }
 284 
 285   /**
 286    * Compile an &#39;and&#39; operation.
 287    *
 288    * @param opPos The current position in the m_opMap array.
 289    *
 290    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.And} instance.
 291    *
 292    * @throws TransformerException if a error occurs creating the Expression.
 293    */
 294   protected Expression and(int opPos) throws TransformerException
 295   {
 296     return compileOperation(new And(), opPos);
 297   }
 298 
 299   /**
 300    * Compile a &#39;!=&#39; operation.
 301    *
 302    * @param opPos The current position in the m_opMap array.
 303    *
 304    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.NotEquals} instance.
 305    *
 306    * @throws TransformerException if a error occurs creating the Expression.
 307    */
 308   protected Expression notequals(int opPos) throws TransformerException
 309   {
 310     return compileOperation(new NotEquals(), opPos);
 311   }
 312 
 313   /**
 314    * Compile a &#39;=&#39; operation.
 315    *
 316    * @param opPos The current position in the m_opMap array.
 317    *
 318    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Equals} instance.
 319    *
 320    * @throws TransformerException if a error occurs creating the Expression.
 321    */
 322   protected Expression equals(int opPos) throws TransformerException
 323   {
 324     return compileOperation(new Equals(), opPos);
 325   }
 326 
 327   /**
 328    * Compile a &#39;&lt;=&#39; operation.
 329    *
 330    * @param opPos The current position in the m_opMap array.
 331    *
 332    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Lte} instance.
 333    *
 334    * @throws TransformerException if a error occurs creating the Expression.
 335    */
 336   protected Expression lte(int opPos) throws TransformerException
 337   {
 338     return compileOperation(new Lte(), opPos);
 339   }
 340 
 341   /**
 342    * Compile a &#39;&lt;&#39; operation.
 343    *
 344    * @param opPos The current position in the m_opMap array.
 345    *
 346    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Lt} instance.
 347    *
 348    * @throws TransformerException if a error occurs creating the Expression.
 349    */
 350   protected Expression lt(int opPos) throws TransformerException
 351   {
 352     return compileOperation(new Lt(), opPos);
 353   }
 354 
 355   /**
 356    * Compile a &#39;&gt;=&#39; operation.
 357    *
 358    * @param opPos The current position in the m_opMap array.
 359    *
 360    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Gte} instance.
 361    *
 362    * @throws TransformerException if a error occurs creating the Expression.
 363    */
 364   protected Expression gte(int opPos) throws TransformerException
 365   {
 366     return compileOperation(new Gte(), opPos);
 367   }
 368 
 369   /**
 370    * Compile a &#39;&gt;&#39; operation.
 371    *
 372    * @param opPos The current position in the m_opMap array.
 373    *
 374    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Gt} instance.
 375    *
 376    * @throws TransformerException if a error occurs creating the Expression.
 377    */
 378   protected Expression gt(int opPos) throws TransformerException
 379   {
 380     return compileOperation(new Gt(), opPos);
 381   }
 382 
 383   /**
 384    * Compile a &#39;+&#39; operation.
 385    *
 386    * @param opPos The current position in the m_opMap array.
 387    *
 388    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Plus} instance.
 389    *
 390    * @throws TransformerException if a error occurs creating the Expression.
 391    */
 392   protected Expression plus(int opPos) throws TransformerException
 393   {
 394     return compileOperation(new Plus(), opPos);
 395   }
 396 
 397   /**
 398    * Compile a &#39;-&#39; operation.
 399    *
 400    * @param opPos The current position in the m_opMap array.
 401    *
 402    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Minus} instance.
 403    *
 404    * @throws TransformerException if a error occurs creating the Expression.
 405    */
 406   protected Expression minus(int opPos) throws TransformerException
 407   {
 408     return compileOperation(new Minus(), opPos);
 409   }
 410 
 411   /**
 412    * Compile a &#39;*&#39; operation.
 413    *
 414    * @param opPos The current position in the m_opMap array.
 415    *
 416    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Mult} instance.
 417    *
 418    * @throws TransformerException if a error occurs creating the Expression.
 419    */
 420   protected Expression mult(int opPos) throws TransformerException
 421   {
 422     return compileOperation(new Mult(), opPos);
 423   }
 424 
 425   /**
 426    * Compile a &#39;div&#39; operation.
 427    *
 428    * @param opPos The current position in the m_opMap array.
 429    *
 430    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Div} instance.
 431    *
 432    * @throws TransformerException if a error occurs creating the Expression.
 433    */
 434   protected Expression div(int opPos) throws TransformerException
 435   {
 436     return compileOperation(new Div(), opPos);
 437   }
 438 
 439   /**
 440    * Compile a &#39;mod&#39; operation.
 441    *
 442    * @param opPos The current position in the m_opMap array.
 443    *
 444    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Mod} instance.
 445    *
 446    * @throws TransformerException if a error occurs creating the Expression.
 447    */
 448   protected Expression mod(int opPos) throws TransformerException
 449   {
 450     return compileOperation(new Mod(), opPos);
 451   }
 452 
 453   /*
 454    * Compile a &#39;quo&#39; operation.
 455    *
 456    * @param opPos The current position in the m_opMap array.
 457    *
 458    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Quo} instance.
 459    *
 460    * @throws TransformerException if a error occurs creating the Expression.
 461    */
 462 //  protected Expression quo(int opPos) throws TransformerException
 463 //  {
 464 //    return compileOperation(new Quo(), opPos);
 465 //  }
 466 
 467   /**
 468    * Compile a unary &#39;-&#39; operation.
 469    *
 470    * @param opPos The current position in the m_opMap array.
 471    *
 472    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Neg} instance.
 473    *
 474    * @throws TransformerException if a error occurs creating the Expression.
 475    */
 476   protected Expression neg(int opPos) throws TransformerException
 477   {
 478     return compileUnary(new Neg(), opPos);
 479   }
 480 
 481   /**
 482    * Compile a &#39;string(...)&#39; operation.
 483    *
 484    * @param opPos The current position in the m_opMap array.
 485    *
 486    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.String} instance.
 487    *
 488    * @throws TransformerException if a error occurs creating the Expression.
 489    */
 490   protected Expression string(int opPos) throws TransformerException
 491   {
 492     return compileUnary(new com.sun.org.apache.xpath.internal.operations.String(), opPos);
 493   }
 494 
 495   /**
 496    * Compile a &#39;boolean(...)&#39; operation.
 497    *
 498    * @param opPos The current position in the m_opMap array.
 499    *
 500    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Bool} instance.
 501    *
 502    * @throws TransformerException if a error occurs creating the Expression.
 503    */
 504   protected Expression bool(int opPos) throws TransformerException
 505   {
 506     return compileUnary(new com.sun.org.apache.xpath.internal.operations.Bool(), opPos);
 507   }
 508 
 509   /**
 510    * Compile a &#39;number(...)&#39; operation.
 511    *
 512    * @param opPos The current position in the m_opMap array.
 513    *
 514    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Number} instance.
 515    *
 516    * @throws TransformerException if a error occurs creating the Expression.
 517    */
 518   protected Expression number(int opPos) throws TransformerException
 519   {
 520     return compileUnary(new com.sun.org.apache.xpath.internal.operations.Number(), opPos);
 521   }
 522 
 523   /**
 524    * Compile a literal string value.
 525    *
 526    * @param opPos The current position in the m_opMap array.
 527    *
 528    * @return reference to {@link com.sun.org.apache.xpath.internal.objects.XString} instance.
 529    *
 530    * @throws TransformerException if a error occurs creating the Expression.
 531    */
 532   protected Expression literal(int opPos)
 533   {
 534 
 535     opPos = getFirstChildPos(opPos);
 536 
 537     return (XString) getTokenQueue().elementAt(getOp(opPos));
 538   }
 539 
 540   /**
 541    * Compile a literal number value.
 542    *
 543    * @param opPos The current position in the m_opMap array.
 544    *
 545    * @return reference to {@link com.sun.org.apache.xpath.internal.objects.XNumber} instance.
 546    *
 547    * @throws TransformerException if a error occurs creating the Expression.
 548    */
 549   protected Expression numberlit(int opPos)
 550   {
 551 
 552     opPos = getFirstChildPos(opPos);
 553 
 554     return (XNumber) getTokenQueue().elementAt(getOp(opPos));
 555   }
 556 
 557   /**
 558    * Compile a variable reference.
 559    *
 560    * @param opPos The current position in the m_opMap array.
 561    *
 562    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Variable} instance.
 563    *
 564    * @throws TransformerException if a error occurs creating the Expression.
 565    */
 566   protected Expression variable(int opPos) throws TransformerException
 567   {
 568 
 569     Variable var = new Variable();
 570 
 571     opPos = getFirstChildPos(opPos);
 572 
 573     int nsPos = getOp(opPos);
 574     java.lang.String namespace
 575       = (OpCodes.EMPTY == nsPos) ? null
 576                                    : (java.lang.String) getTokenQueue().elementAt(nsPos);
 577     java.lang.String localname
 578       = (java.lang.String) getTokenQueue().elementAt(getOp(opPos+1));
 579     QName qname = new QName(namespace, localname);
 580 
 581     var.setQName(qname);
 582 
 583     return var;
 584   }
 585 
 586   /**
 587    * Compile an expression group.
 588    *
 589    * @param opPos The current position in the m_opMap array.
 590    *
 591    * @return reference to the contained expression.
 592    *
 593    * @throws TransformerException if a error occurs creating the Expression.
 594    */
 595   protected Expression group(int opPos) throws TransformerException
 596   {
 597 
 598     // no-op
 599     return compile(opPos + 2);
 600   }
 601 
 602   /**
 603    * Compile a function argument.
 604    *
 605    * @param opPos The current position in the m_opMap array.
 606    *
 607    * @return reference to the argument expression.
 608    *
 609    * @throws TransformerException if a error occurs creating the Expression.
 610    */
 611   protected Expression arg(int opPos) throws TransformerException
 612   {
 613 
 614     // no-op
 615     return compile(opPos + 2);
 616   }
 617 
 618   /**
 619    * Compile a location path union. The UnionPathIterator itself may create
 620    * {@link com.sun.org.apache.xpath.internal.axes.LocPathIterator} children.
 621    *
 622    * @param opPos The current position in the m_opMap array.
 623    *
 624    * @return reference to {@link com.sun.org.apache.xpath.internal.axes.LocPathIterator} instance.
 625    *
 626    * @throws TransformerException if a error occurs creating the Expression.
 627    */
 628   protected Expression union(int opPos) throws TransformerException
 629   {
 630     locPathDepth++;
 631     try
 632     {
 633       return UnionPathIterator.createUnionIterator(this, opPos);
 634     }
 635     finally
 636     {
 637       locPathDepth--;
 638     }
 639   }
 640 
 641   private int locPathDepth = -1;
 642 
 643   /**
 644    * Get the level of the location path or union being constructed.
 645    * @return 0 if it is a top-level path.
 646    */
 647   public int getLocationPathDepth()
 648   {
 649     return locPathDepth;
 650   }
 651 
 652   /**
 653    * Get the function table
 654    */
 655   FunctionTable getFunctionTable()
 656   {
 657     return m_functionTable;
 658   }
 659 
 660   /**
 661    * Compile a location path.  The LocPathIterator itself may create
 662    * {@link com.sun.org.apache.xpath.internal.axes.AxesWalker} children.
 663    *
 664    * @param opPos The current position in the m_opMap array.
 665    *
 666    * @return reference to {@link com.sun.org.apache.xpath.internal.axes.LocPathIterator} instance.
 667    *
 668    * @throws TransformerException if a error occurs creating the Expression.
 669    */
 670   public Expression locationPath(int opPos) throws TransformerException
 671   {
 672     locPathDepth++;
 673     try
 674     {
 675       DTMIterator iter = WalkerFactory.newDTMIterator(this, opPos, (locPathDepth == 0));
 676       return (Expression)iter; // cast OK, I guess.
 677     }
 678     finally
 679     {
 680       locPathDepth--;
 681     }
 682   }
 683 
 684   /**
 685    * Compile a location step predicate expression.
 686    *
 687    * @param opPos The current position in the m_opMap array.
 688    *
 689    * @return the contained predicate expression.
 690    *
 691    * @throws TransformerException if a error occurs creating the Expression.
 692    */
 693   public Expression predicate(int opPos) throws TransformerException
 694   {
 695     return compile(opPos + 2);
 696   }
 697 
 698   /**
 699    * Compile an entire match pattern expression.
 700    *
 701    * @param opPos The current position in the m_opMap array.
 702    *
 703    * @return reference to {@link com.sun.org.apache.xpath.internal.patterns.UnionPattern} instance.
 704    *
 705    * @throws TransformerException if a error occurs creating the Expression.
 706    */
 707   protected Expression matchPattern(int opPos) throws TransformerException
 708   {
 709     locPathDepth++;
 710     try
 711     {
 712       // First, count...
 713       int nextOpPos = opPos;
 714       int i;
 715 
 716       for (i = 0; getOp(nextOpPos) == OpCodes.OP_LOCATIONPATHPATTERN; i++)
 717       {
 718         nextOpPos = getNextOpPos(nextOpPos);
 719       }
 720 
 721       if (i == 1)
 722         return compile(opPos);
 723 
 724       UnionPattern up = new UnionPattern();
 725       StepPattern[] patterns = new StepPattern[i];
 726 
 727       for (i = 0; getOp(opPos) == OpCodes.OP_LOCATIONPATHPATTERN; i++)
 728       {
 729         nextOpPos = getNextOpPos(opPos);
 730         patterns[i] = (StepPattern) compile(opPos);
 731         opPos = nextOpPos;
 732       }
 733 
 734       up.setPatterns(patterns);
 735 
 736       return up;
 737     }
 738     finally
 739     {
 740       locPathDepth--;
 741     }
 742   }
 743 
 744   /**
 745    * Compile a location match pattern unit expression.
 746    *
 747    * @param opPos The current position in the m_opMap array.
 748    *
 749    * @return reference to {@link com.sun.org.apache.xpath.internal.patterns.StepPattern} instance.
 750    *
 751    * @throws TransformerException if a error occurs creating the Expression.
 752    */
 753   public Expression locationPathPattern(int opPos)
 754           throws TransformerException
 755   {
 756 
 757     opPos = getFirstChildPos(opPos);
 758 
 759     return stepPattern(opPos, 0, null);
 760   }
 761 
 762   /**
 763    * Get a {@link org.w3c.dom.traversal.NodeFilter} bit set that tells what
 764    * to show for a given node test.
 765    *
 766    * @param opPos the op map position for the location step.
 767    *
 768    * @return {@link org.w3c.dom.traversal.NodeFilter} bit set that tells what
 769    *         to show for a given node test.
 770    */
 771   public int getWhatToShow(int opPos)
 772   {
 773 
 774     int axesType = getOp(opPos);
 775     int testType = getOp(opPos + 3);
 776 
 777     // System.out.println(&quot;testType: &quot;+testType);
 778     switch (testType)
 779     {
 780     case OpCodes.NODETYPE_COMMENT :
 781       return DTMFilter.SHOW_COMMENT;
 782     case OpCodes.NODETYPE_TEXT :
 783 //      return DTMFilter.SHOW_TEXT | DTMFilter.SHOW_COMMENT;
 784       return DTMFilter.SHOW_TEXT | DTMFilter.SHOW_CDATA_SECTION ;
 785     case OpCodes.NODETYPE_PI :
 786       return DTMFilter.SHOW_PROCESSING_INSTRUCTION;
 787     case OpCodes.NODETYPE_NODE :
 788 //      return DTMFilter.SHOW_ALL;
 789       switch (axesType)
 790       {
 791       case OpCodes.FROM_NAMESPACE:
 792         return DTMFilter.SHOW_NAMESPACE;
 793       case OpCodes.FROM_ATTRIBUTES :
 794       case OpCodes.MATCH_ATTRIBUTE :
 795         return DTMFilter.SHOW_ATTRIBUTE;
 796       case OpCodes.FROM_SELF:
 797       case OpCodes.FROM_ANCESTORS_OR_SELF:
 798       case OpCodes.FROM_DESCENDANTS_OR_SELF:
 799         return DTMFilter.SHOW_ALL;
 800       default:
 801         if (getOp(0) == OpCodes.OP_MATCHPATTERN)
 802           return ~DTMFilter.SHOW_ATTRIBUTE
 803                   &amp; ~DTMFilter.SHOW_DOCUMENT
 804                   &amp; ~DTMFilter.SHOW_DOCUMENT_FRAGMENT;
 805         else
 806           return ~DTMFilter.SHOW_ATTRIBUTE;
 807       }
 808     case OpCodes.NODETYPE_ROOT :
 809       return DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT;
 810     case OpCodes.NODETYPE_FUNCTEST :
 811       return NodeTest.SHOW_BYFUNCTION;
 812     case OpCodes.NODENAME :
 813       switch (axesType)
 814       {
 815       case OpCodes.FROM_NAMESPACE :
 816         return DTMFilter.SHOW_NAMESPACE;
 817       case OpCodes.FROM_ATTRIBUTES :
 818       case OpCodes.MATCH_ATTRIBUTE :
 819         return DTMFilter.SHOW_ATTRIBUTE;
 820 
 821       // break;
 822       case OpCodes.MATCH_ANY_ANCESTOR :
 823       case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
 824         return DTMFilter.SHOW_ELEMENT;
 825 
 826       // break;
 827       default :
 828         return DTMFilter.SHOW_ELEMENT;
 829       }
 830     default :
 831       // System.err.println(&quot;We should never reach here.&quot;);
 832       return DTMFilter.SHOW_ALL;
 833     }
 834   }
 835 
 836 private static final boolean DEBUG = false;
 837 
 838   /**
 839    * Compile a step pattern unit expression, used for both location paths
 840    * and match patterns.
 841    *
 842    * @param opPos The current position in the m_opMap array.
 843    * @param stepCount The number of steps to expect.
 844    * @param ancestorPattern The owning StepPattern, which may be null.
 845    *
 846    * @return reference to {@link com.sun.org.apache.xpath.internal.patterns.StepPattern} instance.
 847    *
 848    * @throws TransformerException if a error occurs creating the Expression.
 849    */
 850   protected StepPattern stepPattern(
 851           int opPos, int stepCount, StepPattern ancestorPattern)
 852             throws TransformerException
 853   {
 854 
 855     int startOpPos = opPos;
 856     int stepType = getOp(opPos);
 857 
 858     if (OpCodes.ENDOP == stepType)
 859     {
 860       return null;
 861     }
 862 
 863     boolean addMagicSelf = true;
 864 
 865     int endStep = getNextOpPos(opPos);
 866 
 867     // int nextStepType = getOpMap()[endStep];
 868     StepPattern pattern;
 869 
 870     // boolean isSimple = ((OpCodes.ENDOP == nextStepType) &amp;&amp; (stepCount == 0));
 871     int argLen;
 872 
 873     switch (stepType)
 874     {
 875     case OpCodes.OP_FUNCTION :
 876       if(DEBUG)
 877         System.out.println(&quot;MATCH_FUNCTION: &quot;+m_currentPattern);
 878       addMagicSelf = false;
 879       argLen = getOp(opPos + OpMap.MAPINDEX_LENGTH);
 880       pattern = new FunctionPattern(compileFunction(opPos), Axis.PARENT, Axis.CHILD);
 881       break;
 882     case OpCodes.FROM_ROOT :
 883       if(DEBUG)
 884         System.out.println(&quot;FROM_ROOT, &quot;+m_currentPattern);
 885       addMagicSelf = false;
 886       argLen = getArgLengthOfStep(opPos);
 887       opPos = getFirstChildPosOfStep(opPos);
 888       pattern = new StepPattern(DTMFilter.SHOW_DOCUMENT |
 889                                 DTMFilter.SHOW_DOCUMENT_FRAGMENT,
 890                                 Axis.PARENT, Axis.CHILD);
 891       break;
 892     case OpCodes.MATCH_ATTRIBUTE :
 893      if(DEBUG)
 894         System.out.println(&quot;MATCH_ATTRIBUTE: &quot;+getStepLocalName(startOpPos)+&quot;, &quot;+m_currentPattern);
 895       argLen = getArgLengthOfStep(opPos);
 896       opPos = getFirstChildPosOfStep(opPos);
 897       pattern = new StepPattern(DTMFilter.SHOW_ATTRIBUTE,
 898                                 getStepNS(startOpPos),
 899                                 getStepLocalName(startOpPos),
 900                                 Axis.PARENT, Axis.ATTRIBUTE);
 901       break;
 902     case OpCodes.MATCH_ANY_ANCESTOR :
 903       if(DEBUG)
 904         System.out.println(&quot;MATCH_ANY_ANCESTOR: &quot;+getStepLocalName(startOpPos)+&quot;, &quot;+m_currentPattern);
 905       argLen = getArgLengthOfStep(opPos);
 906       opPos = getFirstChildPosOfStep(opPos);
 907       int what = getWhatToShow(startOpPos);
 908       // bit-o-hackery, but this code is due for the morgue anyway...
 909       if(0x00000500 == what)
 910         addMagicSelf = false;
 911       pattern = new StepPattern(getWhatToShow(startOpPos),
 912                                         getStepNS(startOpPos),
 913                                         getStepLocalName(startOpPos),
 914                                         Axis.ANCESTOR, Axis.CHILD);
 915       break;
 916     case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
 917       if(DEBUG)
 918         System.out.println(&quot;MATCH_IMMEDIATE_ANCESTOR: &quot;+getStepLocalName(startOpPos)+&quot;, &quot;+m_currentPattern);
 919       argLen = getArgLengthOfStep(opPos);
 920       opPos = getFirstChildPosOfStep(opPos);
 921       pattern = new StepPattern(getWhatToShow(startOpPos),
 922                                 getStepNS(startOpPos),
 923                                 getStepLocalName(startOpPos),
 924                                 Axis.PARENT, Axis.CHILD);
 925       break;
 926     default :
 927       error(XPATHErrorResources.ER_UNKNOWN_MATCH_OPERATION, null);  //&quot;unknown match operation!&quot;);
 928 
 929       return null;
 930     }
 931 
 932     pattern.setPredicates(getCompiledPredicates(opPos + argLen));
 933     if(null == ancestorPattern)
 934     {
 935       // This is the magic and invisible &quot;.&quot; at the head of every
 936       // match pattern, and corresponds to the current node in the context
 937       // list, from where predicates are counted.
 938       // So, in order to calculate &quot;foo[3]&quot;, it has to count from the
 939       // current node in the context list, so, from that current node,
 940       // the full pattern is really &quot;self::node()/child::foo[3]&quot;.  If you
 941       // translate this to a select pattern from the node being tested,
 942       // which is really how we&#39;re treating match patterns, it works out to
 943       // self::foo/parent::node[child::foo[3]]&quot;, or close enough.
 944         /*      if(addMagicSelf &amp;&amp; pattern.getPredicateCount() &gt; 0)
 945       {
 946         StepPattern selfPattern = new StepPattern(DTMFilter.SHOW_ALL,
 947                                                   Axis.PARENT, Axis.CHILD);
 948         // We need to keep the new nodetest from affecting the score...
 949         XNumber score = pattern.getStaticScore();
 950         pattern.setRelativePathPattern(selfPattern);
 951         pattern.setStaticScore(score);
 952         selfPattern.setStaticScore(score);
 953         }*/
 954     }
 955     else
 956     {
 957       // System.out.println(&quot;Setting &quot;+ancestorPattern+&quot; as relative to &quot;+pattern);
 958       pattern.setRelativePathPattern(ancestorPattern);
 959     }
 960 
 961     StepPattern relativePathPattern = stepPattern(endStep, stepCount + 1,
 962                                         pattern);
 963 
 964     return (null != relativePathPattern) ? relativePathPattern : pattern;
 965   }
 966 
 967   /**
 968    * Compile a zero or more predicates for a given match pattern.
 969    *
 970    * @param opPos The position of the first predicate the m_opMap array.
 971    *
 972    * @return reference to array of {@link com.sun.org.apache.xpath.internal.Expression} instances.
 973    *
 974    * @throws TransformerException if a error occurs creating the Expression.
 975    */
 976   public Expression[] getCompiledPredicates(int opPos)
 977           throws TransformerException
 978   {
 979 
 980     int count = countPredicates(opPos);
 981 
 982     if (count &gt; 0)
 983     {
 984       Expression[] predicates = new Expression[count];
 985 
 986       compilePredicates(opPos, predicates);
 987 
 988       return predicates;
 989     }
 990 
 991     return null;
 992   }
 993 
 994   /**
 995    * Count the number of predicates in the step.
 996    *
 997    * @param opPos The position of the first predicate the m_opMap array.
 998    *
 999    * @return The number of predicates for this step.
1000    *
1001    * @throws TransformerException if a error occurs creating the Expression.
1002    */
1003   public int countPredicates(int opPos) throws TransformerException
1004   {
1005 
1006     int count = 0;
1007 
1008     while (OpCodes.OP_PREDICATE == getOp(opPos))
1009     {
1010       count++;
1011 
1012       opPos = getNextOpPos(opPos);
1013     }
1014 
1015     return count;
1016   }
1017 
1018   /**
1019    * Compiles predicates in the step.
1020    *
1021    * @param opPos The position of the first predicate the m_opMap array.
1022    * @param predicates An empty pre-determined array of
1023    *            {@link com.sun.org.apache.xpath.internal.Expression}s, that will be filled in.
1024    *
1025    * @throws TransformerException
1026    */
1027   private void compilePredicates(int opPos, Expression[] predicates)
1028           throws TransformerException
1029   {
1030 
1031     for (int i = 0; OpCodes.OP_PREDICATE == getOp(opPos); i++)
1032     {
1033       predicates[i] = predicate(opPos);
1034       opPos = getNextOpPos(opPos);
1035     }
1036   }
1037 
1038   /**
1039    * Compile a built-in XPath function.
1040    *
1041    * @param opPos The current position in the m_opMap array.
1042    *
1043    * @return reference to {@link com.sun.org.apache.xpath.internal.functions.Function} instance.
1044    *
1045    * @throws TransformerException if a error occurs creating the Expression.
1046    */
1047   Expression compileFunction(int opPos) throws TransformerException
1048   {
1049 
1050     int endFunc = opPos + getOp(opPos + 1) - 1;
1051 
1052     opPos = getFirstChildPos(opPos);
1053 
1054     int funcID = getOp(opPos);
1055 
1056     opPos++;
1057 
1058     if (-1 != funcID)
1059     {
1060       Function func = m_functionTable.getFunction(funcID);
1061 
1062       /**
1063        * It is a trick for function-available. Since the function table is an
1064        * instance field, insert this table at compilation time for later usage
1065        */
1066 
1067       if (func instanceof FuncExtFunctionAvailable)
1068           ((FuncExtFunctionAvailable) func).setFunctionTable(m_functionTable);
1069 
1070       func.postCompileStep(this);
1071 
1072       try
1073       {
1074         int i = 0;
1075 
1076         for (int p = opPos; p &lt; endFunc; p = getNextOpPos(p), i++)
1077         {
1078 
1079           // System.out.println(&quot;argPos: &quot;+ p);
1080           // System.out.println(&quot;argCode: &quot;+ m_opMap[p]);
1081           func.setArg(compile(p), i);
1082         }
1083 
1084         func.checkNumberArgs(i);
1085       }
1086       catch (WrongNumberArgsException wnae)
1087       {
1088         java.lang.String name = m_functionTable.getFunctionName(funcID);
1089 
1090         m_errorHandler.fatalError( new TransformerException(
1091                   XSLMessages.createXPATHMessage(XPATHErrorResources.ER_ONLY_ALLOWS,
1092                       new Object[]{name, wnae.getMessage()}), m_locator));
1093               //&quot;name + &quot; only allows &quot; + wnae.getMessage() + &quot; arguments&quot;, m_locator));
1094       }
1095 
1096       return func;
1097     }
1098     else
1099     {
1100       error(XPATHErrorResources.ER_FUNCTION_TOKEN_NOT_FOUND, null);  //&quot;function token not found.&quot;);
1101 
1102       return null;
1103     }
1104   }
1105 
1106   // The current id for extension functions.
1107   private static long s_nextMethodId = 0;
1108 
1109   /**
1110    * Get the next available method id
1111    */
1112   synchronized private long getNextMethodId()
1113   {
1114     if (s_nextMethodId == Long.MAX_VALUE)
1115       s_nextMethodId = 0;
1116 
1117     return s_nextMethodId++;
1118   }
1119 
1120   /**
1121    * Compile an extension function.
1122    *
1123    * @param opPos The current position in the m_opMap array.
1124    *
1125    * @return reference to {@link com.sun.org.apache.xpath.internal.functions.FuncExtFunction} instance.
1126    *
1127    * @throws TransformerException if a error occurs creating the Expression.
1128    */
1129   private Expression compileExtension(int opPos)
1130           throws TransformerException
1131   {
1132 
1133     int endExtFunc = opPos + getOp(opPos + 1) - 1;
1134 
1135     opPos = getFirstChildPos(opPos);
1136 
1137     java.lang.String ns = (java.lang.String) getTokenQueue().elementAt(getOp(opPos));
1138 
1139     opPos++;
1140 
1141     java.lang.String funcName =
1142       (java.lang.String) getTokenQueue().elementAt(getOp(opPos));
1143 
1144     opPos++;
1145 
1146     // We create a method key to uniquely identify this function so that we
1147     // can cache the object needed to invoke it.  This way, we only pay the
1148     // reflection overhead on the first call.
1149 
1150     Function extension = new FuncExtFunction(ns, funcName, String.valueOf(getNextMethodId()));
1151 
1152     try
1153     {
1154       int i = 0;
1155 
1156       while (opPos &lt; endExtFunc)
1157       {
1158         int nextOpPos = getNextOpPos(opPos);
1159 
1160         extension.setArg(this.compile(opPos), i);
1161 
1162         opPos = nextOpPos;
1163 
1164         i++;
1165       }
1166     }
1167     catch (WrongNumberArgsException wnae)
1168     {
1169       ;  // should never happen
1170     }
1171 
1172     return extension;
1173   }
1174 
1175   /**
1176    * Warn the user of an problem.
1177    *
1178    * @param msg An error msgkey that corresponds to one of the constants found
1179    *            in {@link com.sun.org.apache.xpath.internal.res.XPATHErrorResources}, which is
1180    *            a key for a format string.
1181    * @param args An array of arguments represented in the format string, which
1182    *             may be null.
1183    *
1184    * @throws TransformerException if the current ErrorListoner determines to
1185    *                              throw an exception.
1186    */
1187   public void warn(String msg, Object[] args) throws TransformerException
1188   {
1189 
1190     java.lang.String fmsg = XSLMessages.createXPATHWarning(msg, args);
1191 
1192     if (null != m_errorHandler)
1193     {
1194       m_errorHandler.warning(new TransformerException(fmsg, m_locator));
1195     }
1196     else
1197     {
1198       System.out.println(fmsg
1199                           +&quot;; file &quot;+m_locator.getSystemId()
1200                           +&quot;; line &quot;+m_locator.getLineNumber()
1201                           +&quot;; column &quot;+m_locator.getColumnNumber());
1202     }
1203   }
1204 
1205   /**
1206    * Tell the user of an assertion error, and probably throw an
1207    * exception.
1208    *
1209    * @param b  If false, a runtime exception will be thrown.
1210    * @param msg The assertion message, which should be informative.
1211    *
1212    * @throws RuntimeException if the b argument is false.
1213    */
1214   public void assertion(boolean b, java.lang.String msg)
1215   {
1216 
1217     if (!b)
1218     {
1219       java.lang.String fMsg = XSLMessages.createXPATHMessage(
1220         XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
1221         new Object[]{ msg });
1222 
1223       throw new RuntimeException(fMsg);
1224     }
1225   }
1226 
1227   /**
1228    * Tell the user of an error, and probably throw an
1229    * exception.
1230    *
1231    * @param msg An error msgkey that corresponds to one of the constants found
1232    *            in {@link com.sun.org.apache.xpath.internal.res.XPATHErrorResources}, which is
1233    *            a key for a format string.
1234    * @param args An array of arguments represented in the format string, which
1235    *             may be null.
1236    *
1237    * @throws TransformerException if the current ErrorListoner determines to
1238    *                              throw an exception.
1239    */
1240   public void error(String msg, Object[] args) throws TransformerException
1241   {
1242 
1243     java.lang.String fmsg = XSLMessages.createXPATHMessage(msg, args);
1244 
1245 
1246     if (null != m_errorHandler)
1247     {
1248       m_errorHandler.fatalError(new TransformerException(fmsg, m_locator));
1249     }
1250     else
1251     {
1252 
1253       // System.out.println(te.getMessage()
1254       //                    +&quot;; file &quot;+te.getSystemId()
1255       //                    +&quot;; line &quot;+te.getLineNumber()
1256       //                    +&quot;; column &quot;+te.getColumnNumber());
1257       throw new TransformerException(fmsg, (SAXSourceLocator)m_locator);
1258     }
1259   }
1260 
1261   /**
1262    * The current prefixResolver for the execution context.
1263    */
1264   private PrefixResolver m_currentPrefixResolver = null;
1265 
1266   /**
1267    * Get the current namespace context for the xpath.
1268    *
1269    * @return The current prefix resolver, *may* be null, though hopefully not.
1270    */
1271   public PrefixResolver getNamespaceContext()
1272   {
1273     return m_currentPrefixResolver;
1274   }
1275 
1276   /**
1277    * Set the current namespace context for the xpath.
1278    *
1279    * @param pr The resolver for prefixes in the XPath expression.
1280    */
1281   public void setNamespaceContext(PrefixResolver pr)
1282   {
1283     m_currentPrefixResolver = pr;
1284   }
1285 
1286   /** The error listener where errors will be sent.  If this is null, errors
1287    *  and warnings will be sent to System.err.  May be null.    */
1288   ErrorListener m_errorHandler;
1289 
1290   /** The source locator for the expression being compiled.  May be null. */
1291   SourceLocator m_locator;
1292 
1293   /**
1294    * The FunctionTable for all xpath build-in functions
1295    */
1296   private FunctionTable m_functionTable;
1297 }
    </pre>
  </body>
</html>
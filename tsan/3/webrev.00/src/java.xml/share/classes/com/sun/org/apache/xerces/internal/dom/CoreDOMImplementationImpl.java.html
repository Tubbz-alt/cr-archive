<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/CoreDOMImplementationImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.xerces.internal.dom;
 21 
 22 import com.sun.org.apache.xerces.internal.impl.RevalidationHandler;
 23 import com.sun.org.apache.xerces.internal.impl.dtd.XML11DTDProcessor;
 24 import com.sun.org.apache.xerces.internal.impl.dtd.XML11DTDValidator;
 25 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDLoader;
 26 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator;
 27 import com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator;
 28 import com.sun.org.apache.xerces.internal.parsers.DOMParserImpl;
 29 import com.sun.org.apache.xerces.internal.parsers.DTDConfiguration;
 30 import com.sun.org.apache.xerces.internal.parsers.XIncludeAwareParserConfiguration;
 31 import com.sun.org.apache.xerces.internal.parsers.XML11DTDConfiguration;
 32 import com.sun.org.apache.xerces.internal.util.XMLChar;
 33 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarDescription;
 34 import java.lang.ref.SoftReference;
 35 import org.w3c.dom.DOMException;
 36 import org.w3c.dom.DOMImplementation;
 37 import org.w3c.dom.Document;
 38 import org.w3c.dom.DocumentType;
 39 import org.w3c.dom.Element;
 40 import org.w3c.dom.ls.LSParser;
 41 import org.w3c.dom.ls.DOMImplementationLS;
 42 import org.w3c.dom.ls.LSInput;
 43 import org.w3c.dom.ls.LSOutput;
 44 import org.w3c.dom.ls.LSSerializer;
 45 /**
 46  * The DOMImplementation class is description of a particular
 47  * implementation of the Document Object Model. As such its data is
 48  * static, shared by all instances of this implementation.
 49  * &lt;P&gt;
 50  * The DOM API requires that it be a real object rather than static
 51  * methods. However, there&#39;s nothing that says it can&#39;t be a singleton,
 52  * so that&#39;s how I&#39;ve implemented it.
 53  * &lt;P&gt;
 54  * This particular class, along with CoreDocumentImpl, supports the DOM
 55  * Core and Load/Save (Experimental). Optional modules are supported by
 56  * the more complete DOMImplementation class along with DocumentImpl.
 57  *
 58  * @xerces.internal
 59  *
 60  * @since PR-DOM-Level-1-19980818.
 61  * @LastModified: Apr 2019
 62  */
 63 @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;}) //SoftReference array
 64 public class CoreDOMImplementationImpl
 65         implements DOMImplementation, DOMImplementationLS {
 66 
 67     //
 68     // Data
 69     //
 70 
 71     // validator pools
 72     private static final int SIZE = 2;
 73 
 74     private SoftReference schemaValidators[] = new SoftReference[SIZE];
 75     private SoftReference xml10DTDValidators[] = new SoftReference[SIZE];
 76     private SoftReference xml11DTDValidators[] = new SoftReference[SIZE];
 77 
 78     private int freeSchemaValidatorIndex = -1;
 79     private int freeXML10DTDValidatorIndex = -1;
 80     private int freeXML11DTDValidatorIndex = -1;
 81 
 82     private int schemaValidatorsCurrentSize = SIZE;
 83     private int xml10DTDValidatorsCurrentSize = SIZE;
 84     private int xml11DTDValidatorsCurrentSize = SIZE;
 85 
 86     private SoftReference xml10DTDLoaders[] = new SoftReference[SIZE];
 87     private SoftReference xml11DTDLoaders[] = new SoftReference[SIZE];
 88 
 89     private int freeXML10DTDLoaderIndex = -1;
 90     private int freeXML11DTDLoaderIndex = -1;
 91 
 92     private int xml10DTDLoaderCurrentSize = SIZE;
 93     private int xml11DTDLoaderCurrentSize = SIZE;
 94 
 95     // Document and doctype counter.  Used to assign order to documents and
 96     // doctypes without owners, on an demand basis.   Used for
 97     // compareDocumentPosition
 98     private int docAndDoctypeCounter = 0;
 99 
100         // static
101         /** Dom implementation singleton. */
102         static final CoreDOMImplementationImpl singleton = new CoreDOMImplementationImpl();
103 
104         //
105         // Public methods
106         //
107         /** NON-DOM: Obtain and return the single shared object */
108         public static DOMImplementation getDOMImplementation() {
109                 return singleton;
110         }
111         //
112         // DOMImplementation methods
113         //
114         /**
115          * Test if the DOM implementation supports a specific &quot;feature&quot; --
116          * currently meaning language and level thereof.
117          *
118          * @param feature The package name of the feature to test.
119          * In Level 1, supported values are &quot;HTML&quot; and &quot;XML&quot; (case-insensitive).
120          * At this writing, com.sun.org.apache.xerces.internal.dom supports only XML.
121          *
122          * @param version The version number of the feature being tested.
123          * This is interpreted as &quot;Version of the DOM API supported for the
124          * specified Feature&quot;, and in Level 1 should be &quot;1.0&quot;
125          *
126          * @return true if this implementation is compatible with the specified
127          * feature and version.
128          */
129         public boolean hasFeature(String feature, String version) {
130 
131             boolean anyVersion = version == null || version.length() == 0;
132 
133             if (feature.startsWith(&quot;+&quot;)) {
134                 feature = feature.substring(1);
135             }
136             return (feature.equalsIgnoreCase(&quot;Core&quot;)
137                     &amp;&amp; (anyVersion
138                         || version.equals(&quot;1.0&quot;)
139                         || version.equals(&quot;2.0&quot;)
140                         || version.equals(&quot;3.0&quot;)))
141                         || (feature.equalsIgnoreCase(&quot;XML&quot;)
142                     &amp;&amp; (anyVersion
143                         || version.equals(&quot;1.0&quot;)
144                         || version.equals(&quot;2.0&quot;)
145                         || version.equals(&quot;3.0&quot;)))
146                         || (feature.equalsIgnoreCase(&quot;XMLVersion&quot;)
147                     &amp;&amp; (anyVersion
148                         || version.equals(&quot;1.0&quot;)
149                         || version.equals(&quot;1.1&quot;)))
150                         || (feature.equalsIgnoreCase(&quot;LS&quot;)
151                     &amp;&amp; (anyVersion
152                         || version.equals(&quot;3.0&quot;)))
153                         || (feature.equalsIgnoreCase(&quot;ElementTraversal&quot;)
154                     &amp;&amp; (anyVersion
155                         || version.equals(&quot;1.0&quot;)));
156         } // hasFeature(String,String):boolean
157 
158 
159         /**
160          * Introduced in DOM Level 2. &lt;p&gt;
161          *
162          * Creates an empty DocumentType node.
163          *
164          * @param qualifiedName The qualified name of the document type to be created.
165          * @param publicID The document type public identifier.
166          * @param systemID The document type system identifier.
167          * @since WD-DOM-Level-2-19990923
168          */
169         public DocumentType createDocumentType( String qualifiedName,
170                                     String publicID, String systemID) {
171                 // REVISIT: this might allow creation of invalid name for DOCTYPE
172                 //          xmlns prefix.
173                 //          also there is no way for a user to turn off error checking.
174                 checkQName(qualifiedName);
175                 return new DocumentTypeImpl(null, qualifiedName, publicID, systemID);
176         }
177 
178     final void checkQName(String qname){
179         int index = qname.indexOf(&#39;:&#39;);
180         int lastIndex = qname.lastIndexOf(&#39;:&#39;);
181         int length = qname.length();
182 
183         // it is an error for NCName to have more than one &#39;:&#39;
184         // check if it is valid QName [Namespace in XML production 6]
185         if (index == 0 || index == length - 1 || lastIndex != index) {
186             String msg =
187                 DOMMessageFormatter.formatMessage(
188                     DOMMessageFormatter.DOM_DOMAIN,
189                     &quot;NAMESPACE_ERR&quot;,
190                     null);
191             throw new DOMException(DOMException.NAMESPACE_ERR, msg);
192         }
193         int start = 0;
194         // Namespace in XML production [6]
195         if (index &gt; 0) {
196             // check that prefix is NCName
197             if (!XMLChar.isNCNameStart(qname.charAt(start))) {
198                 String msg =
199                     DOMMessageFormatter.formatMessage(
200                         DOMMessageFormatter.DOM_DOMAIN,
201                         &quot;INVALID_CHARACTER_ERR&quot;,
202                         null);
203                 throw new DOMException(DOMException.INVALID_CHARACTER_ERR, msg);
204             }
205             for (int i = 1; i &lt; index; i++) {
206                 if (!XMLChar.isNCName(qname.charAt(i))) {
207                     String msg =
208                         DOMMessageFormatter.formatMessage(
209                             DOMMessageFormatter.DOM_DOMAIN,
210                             &quot;INVALID_CHARACTER_ERR&quot;,
211                             null);
212                     throw new DOMException(
213                         DOMException.INVALID_CHARACTER_ERR,
214                         msg);
215                 }
216             }
217             start = index + 1;
218         }
219 
220         // check local part
221         if (!XMLChar.isNCNameStart(qname.charAt(start))) {
222             // REVISIT: add qname parameter to the message
223             String msg =
224                 DOMMessageFormatter.formatMessage(
225                     DOMMessageFormatter.DOM_DOMAIN,
226                     &quot;INVALID_CHARACTER_ERR&quot;,
227                     null);
228             throw new DOMException(DOMException.INVALID_CHARACTER_ERR, msg);
229         }
230         for (int i = start + 1; i &lt; length; i++) {
231             if (!XMLChar.isNCName(qname.charAt(i))) {
232                 String msg =
233                     DOMMessageFormatter.formatMessage(
234                         DOMMessageFormatter.DOM_DOMAIN,
235                         &quot;INVALID_CHARACTER_ERR&quot;,
236                         null);
237                 throw new DOMException(DOMException.INVALID_CHARACTER_ERR, msg);
238             }
239         }
240     }
241 
242 
243         /**
244          * Introduced in DOM Level 2. &lt;p&gt;
245          *
246          * Creates an XML Document object of the specified type with its document
247          * element.
248          *
249          * @param namespaceURI     The namespace URI of the document
250          *                         element to create, or null.
251          * @param qualifiedName    The qualified name of the document
252          *                         element to create.
253          * @param doctype          The type of document to be created or null.&lt;p&gt;
254          *
255          *                         When doctype is not null, its
256          *                         Node.ownerDocument attribute is set to
257          *                         the document being created.
258          * @return Document        A new Document object.
259          * @throws DOMException    WRONG_DOCUMENT_ERR: Raised if doctype has
260          *                         already been used with a different document.
261          * @since WD-DOM-Level-2-19990923
262          */
263         public Document createDocument(
264                 String namespaceURI,
265                 String qualifiedName,
266                 DocumentType doctype)
267                 throws DOMException {
268                 if (doctype != null &amp;&amp; doctype.getOwnerDocument() != null) {
269                         String msg =
270                                 DOMMessageFormatter.formatMessage(
271                                         DOMMessageFormatter.DOM_DOMAIN,
272                                         &quot;WRONG_DOCUMENT_ERR&quot;,
273                                         null);
274                         throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);
275                 }
276                 CoreDocumentImpl doc = createDocument(doctype);
277                 // If namespaceURI and qualifiedName are null return a Document with no document element.
278                 if (qualifiedName != null || namespaceURI != null) {
279                     Element e = doc.createElementNS(namespaceURI, qualifiedName);
280                     doc.appendChild(e);
281                 }
282                 return doc;
283         }
284 
285         protected CoreDocumentImpl createDocument(DocumentType doctype) {
286             return new CoreDocumentImpl(doctype);
287         }
288 
289         /**
290          * DOM Level 3 WD - Experimental.
291          */
292         public Object getFeature(String feature, String version) {
293             if (singleton.hasFeature(feature, version)) {
294                     return singleton;
295                 }
296             return null;
297         }
298 
299         // DOM L3 LS
300 
301         /**
302          * DOM Level 3 LS CR - Experimental.
303      * Create a new &lt;code&gt;LSParser&lt;/code&gt;. The newly constructed parser may
304      * then be configured by means of its &lt;code&gt;DOMConfiguration&lt;/code&gt;
305      * object, and used to parse documents by means of its &lt;code&gt;parse&lt;/code&gt;
306      *  method.
307      * @param mode  The &lt;code&gt;mode&lt;/code&gt; argument is either
308      *   &lt;code&gt;MODE_SYNCHRONOUS&lt;/code&gt; or &lt;code&gt;MODE_ASYNCHRONOUS&lt;/code&gt;, if
309      *   &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;MODE_SYNCHRONOUS&lt;/code&gt; then the
310      *   &lt;code&gt;LSParser&lt;/code&gt; that is created will operate in synchronous
311      *   mode, if it&#39;s &lt;code&gt;MODE_ASYNCHRONOUS&lt;/code&gt; then the
312      *   &lt;code&gt;LSParser&lt;/code&gt; that is created will operate in asynchronous
313      *   mode.
314      * @param schemaType  An absolute URI representing the type of the schema
315      *   language used during the load of a &lt;code&gt;Document&lt;/code&gt; using the
316      *   newly created &lt;code&gt;LSParser&lt;/code&gt;. Note that no lexical checking
317      *   is done on the absolute URI. In order to create a
318      *   &lt;code&gt;LSParser&lt;/code&gt; for any kind of schema types (i.e. the
319      *   LSParser will be free to use any schema found), use the value
320      *   &lt;code&gt;null&lt;/code&gt;.
321      * &lt;p &gt;&lt;b&gt;Note:&lt;/b&gt;    For W3C XML Schema [&lt;a href=&#39;http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/&#39;&gt;XML Schema Part 1&lt;/a&gt;]
322      *   , applications must use the value
323      *   &lt;code&gt;&quot;http://www.w3.org/2001/XMLSchema&quot;&lt;/code&gt;. For XML DTD [&lt;a href=&#39;http://www.w3.org/TR/2000/REC-xml-20001006&#39;&gt;XML 1.0&lt;/a&gt;],
324      *   applications must use the value
325      *   &lt;code&gt;&quot;http://www.w3.org/TR/REC-xml&quot;&lt;/code&gt;. Other Schema languages
326      *   are outside the scope of the W3C and therefore should recommend an
327      *   absolute URI in order to use this method.
328      * @return  The newly created &lt;code&gt;LSParser&lt;/code&gt; object. This
329      *   &lt;code&gt;LSParser&lt;/code&gt; is either synchronous or asynchronous
330      *   depending on the value of the &lt;code&gt;mode&lt;/code&gt; argument.
331      * &lt;p &gt;&lt;b&gt;Note:&lt;/b&gt;    By default, the newly created &lt;code&gt;LSParser&lt;/code&gt;
332      *    does not contain a &lt;code&gt;DOMErrorHandler&lt;/code&gt;, i.e. the value of
333      *   the &quot;&lt;a href=&#39;http://www.w3.org/TR/2003/WD-DOM-Level-3-Core-20030609/core.html#parameter-error-handler&#39;&gt;
334      *   error-handler&lt;/a&gt;&quot; configuration parameter is &lt;code&gt;null&lt;/code&gt;. However, implementations
335      *   may provide a default error handler at creation time. In that case,
336      *   the initial value of the &lt;code&gt;&quot;error-handler&quot;&lt;/code&gt; configuration
337      *   parameter on the new created &lt;code&gt;LSParser&lt;/code&gt; contains a
338      *   reference to the default error handler.
339      * @exception DOMException
340      *    NOT_SUPPORTED_ERR: Raised if the requested mode or schema type is
341      *   not supported.
342          */
343     public LSParser createLSParser(short mode, String schemaType)
344                 throws DOMException {
345                 if (mode != DOMImplementationLS.MODE_SYNCHRONOUS || (schemaType !=null &amp;&amp;
346                    !&quot;http://www.w3.org/2001/XMLSchema&quot;.equals(schemaType) &amp;&amp;
347                         !&quot;http://www.w3.org/TR/REC-xml&quot;.equals(schemaType))) {
348                         String msg =
349                                 DOMMessageFormatter.formatMessage(
350                                         DOMMessageFormatter.DOM_DOMAIN,
351                                         &quot;NOT_SUPPORTED_ERR&quot;,
352                                         null);
353                         throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
354                 }
355                 if (schemaType != null
356                         &amp;&amp; schemaType.equals(&quot;http://www.w3.org/TR/REC-xml&quot;)) {
357                         return new DOMParserImpl(new XML11DTDConfiguration(),
358                                 schemaType);
359                 }
360                 else {
361                         // create default parser configuration validating against XMLSchemas
362                         return new DOMParserImpl(new XIncludeAwareParserConfiguration(),
363                                 schemaType);
364                 }
365         }
366 
367     /**
368      * DOM Level 3 LS CR - Experimental.
369      * Create a new &lt;code&gt;LSSerializer&lt;/code&gt; object.
370      * @return The newly created &lt;code&gt;LSSerializer&lt;/code&gt; object.
371      * &lt;p &gt;&lt;b&gt;Note:&lt;/b&gt;    By default, the newly created
372      * &lt;code&gt;LSSerializer&lt;/code&gt; has no &lt;code&gt;DOMErrorHandler&lt;/code&gt;,
373      * i.e. the value of the &lt;code&gt;&quot;error-handler&quot;&lt;/code&gt; configuration
374      * parameter is &lt;code&gt;null&lt;/code&gt;. However, implementations may
375      * provide a default error handler at creation time. In that case, the
376      * initial value of the &lt;code&gt;&quot;error-handler&quot;&lt;/code&gt; configuration
377      * parameter on the new created &lt;code&gt;LSSerializer&lt;/code&gt; contains a
378      * reference to the default error handler.
379      */
380     public LSSerializer createLSSerializer() {
381             return new com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl();
382         }
383 
384         /**
385          * DOM Level 3 LS CR - Experimental.
386          * Create a new empty input source.
387          * @return  The newly created input object.
388          */
389         public LSInput createLSInput() {
390                 return new DOMInputImpl();
391         }
392 
393         //
394         // Protected methods
395         //
396         /** NON-DOM: retrieve validator. */
397         synchronized RevalidationHandler getValidator(String schemaType, String xmlVersion) {
398         if (schemaType == XMLGrammarDescription.XML_SCHEMA) {
399             // create new validator - we should not attempt
400             // to restrict the number of validation handlers being
401             // requested
402             while (freeSchemaValidatorIndex &gt;= 0) {
403                 // return first available validator
404                 SoftReference ref = schemaValidators[freeSchemaValidatorIndex];
405                 RevalidationHandlerHolder holder = (RevalidationHandlerHolder) ref.get();
406                 if (holder != null &amp;&amp; holder.handler != null) {
407                     RevalidationHandler val = holder.handler;
408                     holder.handler = null;
409                     --freeSchemaValidatorIndex;
410                     return val;
411                 }
412                 schemaValidators[freeSchemaValidatorIndex--] = null;
413             }
414             return new XMLSchemaValidator();
415         }
416         else if(schemaType == XMLGrammarDescription.XML_DTD) {
417             // return an instance of XML11DTDValidator
418             if (&quot;1.1&quot;.equals(xmlVersion)) {
419                 while (freeXML11DTDValidatorIndex &gt;= 0) {
420                     // return first available validator
421                     SoftReference ref = xml11DTDValidators[freeXML11DTDValidatorIndex];
422                     RevalidationHandlerHolder holder = (RevalidationHandlerHolder) ref.get();
423                     if (holder != null &amp;&amp; holder.handler != null) {
424                         RevalidationHandler val = holder.handler;
425                         holder.handler = null;
426                         --freeXML11DTDValidatorIndex;
427                         return val;
428                     }
429                     xml11DTDValidators[freeXML11DTDValidatorIndex--] = null;
430                 }
431                 return new XML11DTDValidator();
432             }
433             // return an instance of XMLDTDValidator
434             else {
435                 while (freeXML10DTDValidatorIndex &gt;= 0) {
436                     // return first available validator
437                     SoftReference ref = xml10DTDValidators[freeXML10DTDValidatorIndex];
438                     RevalidationHandlerHolder holder = (RevalidationHandlerHolder) ref.get();
439                     if (holder != null &amp;&amp; holder.handler != null) {
440                         RevalidationHandler val = holder.handler;
441                         holder.handler = null;
442                         --freeXML10DTDValidatorIndex;
443                         return val;
444                     }
445                     xml10DTDValidators[freeXML10DTDValidatorIndex--] = null;
446                 }
447                 return new XMLDTDValidator();
448             }
449         }
450         return null;
451         }
452 
453         /** NON-DOM: release validator */
454         synchronized void releaseValidator(String schemaType, String xmlVersion,
455                 RevalidationHandler validator) {
456             if (schemaType == XMLGrammarDescription.XML_SCHEMA) {
457                 ++freeSchemaValidatorIndex;
458                 if (schemaValidators.length == freeSchemaValidatorIndex) {
459                     // resize size of the validators
460                     schemaValidatorsCurrentSize += SIZE;
461                     SoftReference newarray[] =  new SoftReference[schemaValidatorsCurrentSize];
462                     System.arraycopy(schemaValidators, 0, newarray, 0, schemaValidators.length);
463                     schemaValidators = newarray;
464                 }
465                 SoftReference ref = schemaValidators[freeSchemaValidatorIndex];
466                 if (ref != null) {
467                     RevalidationHandlerHolder holder = (RevalidationHandlerHolder) ref.get();
468                     if (holder != null) {
469                         holder.handler = validator;
470                         return;
471                     }
472                 }
473                 schemaValidators[freeSchemaValidatorIndex] = new SoftReference(new RevalidationHandlerHolder(validator));
474             }
475             else if (schemaType == XMLGrammarDescription.XML_DTD) {
476                 // release an instance of XML11DTDValidator
477                 if (&quot;1.1&quot;.equals(xmlVersion)) {
478                     ++freeXML11DTDValidatorIndex;
479                     if (xml11DTDValidators.length == freeXML11DTDValidatorIndex) {
480                         // resize size of the validators
481                         xml11DTDValidatorsCurrentSize += SIZE;
482                         SoftReference [] newarray = new SoftReference[xml11DTDValidatorsCurrentSize];
483                         System.arraycopy(xml11DTDValidators, 0, newarray, 0, xml11DTDValidators.length);
484                         xml11DTDValidators = newarray;
485                     }
486                     SoftReference ref = xml11DTDValidators[freeXML11DTDValidatorIndex];
487                     if (ref != null) {
488                         RevalidationHandlerHolder holder = (RevalidationHandlerHolder) ref.get();
489                         if (holder != null) {
490                             holder.handler = validator;
491                             return;
492                         }
493                     }
494                     xml11DTDValidators[freeXML11DTDValidatorIndex] = new SoftReference(new RevalidationHandlerHolder(validator));
495                 }
496                 // release an instance of XMLDTDValidator
497                 else {
498                     ++freeXML10DTDValidatorIndex;
499                     if (xml10DTDValidators.length == freeXML10DTDValidatorIndex) {
500                         // resize size of the validators
501                         xml10DTDValidatorsCurrentSize += SIZE;
502                         SoftReference [] newarray = new SoftReference[xml10DTDValidatorsCurrentSize];
503                         System.arraycopy(xml10DTDValidators, 0, newarray, 0, xml10DTDValidators.length);
504                         xml10DTDValidators = newarray;
505                     }
506                     SoftReference ref = xml10DTDValidators[freeXML10DTDValidatorIndex];
507                     if (ref != null) {
508                         RevalidationHandlerHolder holder = (RevalidationHandlerHolder) ref.get();
509                         if (holder != null) {
510                             holder.handler = validator;
511                             return;
512                         }
513                     }
514                     xml10DTDValidators[freeXML10DTDValidatorIndex] = new SoftReference(new RevalidationHandlerHolder(validator));
515                 }
516             }
517         }
518 
519     /** NON-DOM: retrieve DTD loader */
520     synchronized final XMLDTDLoader getDTDLoader(String xmlVersion) {
521         // return an instance of XML11DTDProcessor
522         if (&quot;1.1&quot;.equals(xmlVersion)) {
523             while (freeXML11DTDLoaderIndex &gt;= 0) {
524                 // return first available DTD loader
525                 SoftReference ref = xml11DTDLoaders[freeXML11DTDLoaderIndex];
526                 XMLDTDLoaderHolder holder = (XMLDTDLoaderHolder) ref.get();
527                 if (holder != null &amp;&amp; holder.loader != null) {
528                     XMLDTDLoader val = holder.loader;
529                     holder.loader = null;
530                     --freeXML11DTDLoaderIndex;
531                     return val;
532                 }
533                 xml11DTDLoaders[freeXML11DTDLoaderIndex--] = null;
534             }
535             return new XML11DTDProcessor();
536         }
537         // return an instance of XMLDTDLoader
538         else {
539             while (freeXML10DTDLoaderIndex &gt;= 0) {
540                 // return first available DTD loader
541                 SoftReference ref = xml10DTDLoaders[freeXML10DTDLoaderIndex];
542                 XMLDTDLoaderHolder holder = (XMLDTDLoaderHolder) ref.get();
543                 if (holder != null &amp;&amp; holder.loader != null) {
544                     XMLDTDLoader val = holder.loader;
545                     holder.loader = null;
546                     --freeXML10DTDLoaderIndex;
547                     return val;
548                 }
549                 xml10DTDLoaders[freeXML10DTDLoaderIndex--] = null;
550             }
551             return new XMLDTDLoader();
552         }
553     }
554 
555     /** NON-DOM: release DTD loader */
556     synchronized final void releaseDTDLoader(String xmlVersion, XMLDTDLoader loader) {
557         // release an instance of XMLDTDLoader
558         if (&quot;1.1&quot;.equals(xmlVersion)) {
559             ++freeXML11DTDLoaderIndex;
560             if (xml11DTDLoaders.length == freeXML11DTDLoaderIndex) {
561                 // resize size of the DTD loaders
562                 xml11DTDLoaderCurrentSize += SIZE;
563                 SoftReference [] newarray = new SoftReference[xml11DTDLoaderCurrentSize];
564                 System.arraycopy(xml11DTDLoaders, 0, newarray, 0, xml11DTDLoaders.length);
565                 xml11DTDLoaders = newarray;
566             }
567             SoftReference ref = xml11DTDLoaders[freeXML11DTDLoaderIndex];
568             if (ref != null) {
569                 XMLDTDLoaderHolder holder = (XMLDTDLoaderHolder) ref.get();
570                 if (holder != null) {
571                     holder.loader = loader;
572                     return;
573                 }
574             }
575             xml11DTDLoaders[freeXML11DTDLoaderIndex] = new SoftReference(new XMLDTDLoaderHolder(loader));
576         }
577         // release an instance of XMLDTDLoader
578         else {
579             ++freeXML10DTDLoaderIndex;
580             if (xml10DTDLoaders.length == freeXML10DTDLoaderIndex) {
581                 // resize size of the DTD loaders
582                 xml10DTDLoaderCurrentSize += SIZE;
583                 SoftReference [] newarray = new SoftReference[xml10DTDLoaderCurrentSize];
584                 System.arraycopy(xml10DTDLoaders, 0, newarray, 0, xml10DTDLoaders.length);
585                 xml10DTDLoaders = newarray;
586             }
587             SoftReference ref = xml10DTDLoaders[freeXML10DTDLoaderIndex];
588             if (ref != null) {
589                 XMLDTDLoaderHolder holder = (XMLDTDLoaderHolder) ref.get();
590                 if (holder != null) {
591                     holder.loader = loader;
592                     return;
593                 }
594             }
595             xml10DTDLoaders[freeXML10DTDLoaderIndex] = new SoftReference(new XMLDTDLoaderHolder(loader));
596         }
597     }
598 
599     /** NON-DOM:  increment document/doctype counter */
600     protected synchronized int assignDocumentNumber() {
601         return ++docAndDoctypeCounter;
602     }
603 
604     /** NON-DOM:  increment document/doctype counter */
605     protected synchronized int assignDocTypeNumber() {
606         return ++docAndDoctypeCounter;
607     }
608 
609     /* DOM Level 3 LS CR - Experimental.
610      *
611      * Create a new empty output destination object where
612      * &lt;code&gt;LSOutput.characterStream&lt;/code&gt;,
613      * &lt;code&gt;LSOutput.byteStream&lt;/code&gt;, &lt;code&gt;LSOutput.systemId&lt;/code&gt;,
614      * &lt;code&gt;LSOutput.encoding&lt;/code&gt; are null.
615      * @return  The newly created output object.
616     */
617     public LSOutput createLSOutput() {
618         return new DOMOutputImpl();
619     }
620 
621     /**
622      * A holder for RevalidationHandlers. This allows us to reuse
623      * SoftReferences which haven&#39;t yet been cleared by the garbage
624      * collector.
625      */
626     static final class RevalidationHandlerHolder {
627         RevalidationHandlerHolder(RevalidationHandler handler) {
628             this.handler = handler;
629         }
630         RevalidationHandler handler;
631     }
632 
633     /**
634      * A holder for XMLDTDLoaders. This allows us to reuse SoftReferences
635      * which haven&#39;t yet been cleared by the garbage collector.
636      */
637     static final class XMLDTDLoaderHolder {
638         XMLDTDLoaderHolder(XMLDTDLoader loader) {
639             this.loader = loader;
640         }
641         XMLDTDLoader loader;
642     }
643 
644 } // class DOMImplementationImpl
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/identity/XPathMatcher.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xerces.internal.impl.xs.identity;
 22 
 23 import com.sun.org.apache.xerces.internal.impl.Constants;
 24 import com.sun.org.apache.xerces.internal.impl.xpath.XPath;
 25 import com.sun.org.apache.xerces.internal.util.IntStack;
 26 import com.sun.org.apache.xerces.internal.xni.QName;
 27 import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
 28 import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
 29 import com.sun.org.apache.xerces.internal.xs.ShortList;
 30 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
 31 import org.xml.sax.SAXException;
 32 
 33 
 34 /**
 35  * XPath matcher.
 36  *
 37  * @xerces.internal
 38  *
 39  * @author Andy Clark, IBM
<a name="2" id="anc2"></a><span class="line-added"> 40  * @LastModified: July 2019</span>
 41  *
 42  */
 43 public class XPathMatcher {
 44 
 45     //
 46     // Constants
 47     //
 48 
 49     // debugging
 50 
 51     /** Compile to true to debug everything. */
 52     protected static final boolean DEBUG_ALL = false;
 53 
 54     /** Compile to true to debug method callbacks. */
 55     protected static final boolean DEBUG_METHODS = false || DEBUG_ALL;
 56 
 57     /** Compile to true to debug important method callbacks. */
 58     protected static final boolean DEBUG_METHODS2 = false || DEBUG_METHODS || DEBUG_ALL;
 59 
 60     /** Compile to true to debug the &lt;em&gt;really&lt;/em&gt; important methods. */
 61     protected static final boolean DEBUG_METHODS3 = false || DEBUG_METHODS || DEBUG_ALL;
 62 
 63     /** Compile to true to debug match. */
 64     protected static final boolean DEBUG_MATCH = false || DEBUG_ALL;
 65 
 66     /** Compile to true to debug step index stack. */
 67     protected static final boolean DEBUG_STACK = false || DEBUG_ALL;
 68 
 69     /** Don&#39;t touch this value unless you add more debug constants. */
 70     protected static final boolean DEBUG_ANY = DEBUG_METHODS ||
 71                                                DEBUG_METHODS2 ||
 72                                                DEBUG_METHODS3 ||
 73                                                DEBUG_MATCH ||
 74                                                DEBUG_STACK;
 75 
 76     // constants describing whether a match was made,
 77     // and if so how.
 78     // matched any way
 79     protected static final int MATCHED = 1;
 80     // matched on the attribute axis
 81     protected static final int MATCHED_ATTRIBUTE = 3;
 82     // matched on the descendant-or-self axixs
 83     protected static final int MATCHED_DESCENDANT = 5;
 84     // matched some previous (ancestor) node on the descendant-or-self-axis, but not this node
 85     protected static final int MATCHED_DESCENDANT_PREVIOUS = 13;
 86 
 87     //
 88     // Data
 89     //
 90 
 91     /** XPath location path. */
<a name="3" id="anc3"></a><span class="line-modified"> 92     private final XPath.LocationPath[] fLocationPaths;</span>
 93 
 94     /** True if XPath has been matched. */
<a name="4" id="anc4"></a><span class="line-modified"> 95     private final int[] fMatched;</span>
 96 
 97     /** The matching string. */
 98     protected Object fMatchedString;
 99 
100     /** Integer stack of step indexes. */
<a name="5" id="anc5"></a><span class="line-modified">101     private final IntStack[] fStepIndexes;</span>
102 
103     /** Current step. */
<a name="6" id="anc6"></a><span class="line-modified">104     private final int[] fCurrentStep;</span>
105 
106     /**
107      * No match depth. The value of this field will be zero while
108      * matching is successful for the given xpath expression.
109      */
<a name="7" id="anc7"></a><span class="line-modified">110     private final int [] fNoMatchDepth;</span>
111 
112     final QName fQName = new QName();
113 
114 
115     //
116     // Constructors
117     //
118 
119     /**
120      * Constructs an XPath matcher that implements a document fragment
121      * handler.
122      *
123      * @param xpath   The xpath.
124      */
125     public XPathMatcher(XPath xpath) {
126         fLocationPaths = xpath.getLocationPaths();
127         fStepIndexes = new IntStack[fLocationPaths.length];
128         for(int i=0; i&lt;fStepIndexes.length; i++) fStepIndexes[i] = new IntStack();
129         fCurrentStep = new int[fLocationPaths.length];
130         fNoMatchDepth = new int[fLocationPaths.length];
131         fMatched = new int[fLocationPaths.length];
132     } // &lt;init&gt;(XPath)
133 
134     //
135     // Public methods
136     //
137 
138     /**
139      * Returns value of first member of fMatched that
140      * is nonzero.
141      */
142     public boolean isMatched() {
143         // xpath has been matched if any one of the members of the union have matched.
144         for (int i=0; i &lt; fLocationPaths.length; i++)
145             if (((fMatched[i] &amp; MATCHED) == MATCHED)
146                     &amp;&amp; ((fMatched[i] &amp; MATCHED_DESCENDANT_PREVIOUS) != MATCHED_DESCENDANT_PREVIOUS)
147                     &amp;&amp; ((fNoMatchDepth[i] == 0)
148                     || ((fMatched[i] &amp; MATCHED_DESCENDANT) == MATCHED_DESCENDANT)))
149                 return true;
150 
151         return false;
152     } // isMatched():int
153 
154     //
155     // Protected methods
156     //
157 
158     // a place-holder method; to be overridden by subclasses
159     // that care about matching element content.
160     protected void handleContent(XSTypeDefinition type, boolean nillable,
161             Object value, short valueType, ShortList itemValueType) {
162     }
163 
164     /**
165      * This method is called when the XPath handler matches the
166      * XPath expression. Subclasses can override this method to
167      * provide default handling upon a match.
168      */
169     protected void matched(Object actualValue, short valueType,
170             ShortList itemValueType, boolean isNil) {
171         if (DEBUG_METHODS3) {
172             System.out.println(toString()+&quot;#matched(\&quot;&quot;+actualValue+&quot;\&quot;)&quot;);
173         }
174     } // matched(String content, XSSimpleType val)
175 
176     //
177     // ~XMLDocumentFragmentHandler methods
178     //
179 
180     /**
181      * The start of the document fragment.
182      */
183     public void startDocumentFragment(){
184         if (DEBUG_METHODS) {
185             System.out.println(toString()+&quot;#startDocumentFragment(&quot;+
186                                &quot;)&quot;);
187         }
188 
189         // reset state
190         fMatchedString = null;
191         for(int i = 0; i &lt; fLocationPaths.length; i++) {
192             fStepIndexes[i].clear();
193             fCurrentStep[i] = 0;
194             fNoMatchDepth[i] = 0;
195             fMatched[i] = 0;
196         }
197 
198 
199     } // startDocumentFragment()
200 
201     /**
202      * The start of an element. If the document specifies the start element
203      * by using an empty tag, then the startElement method will immediately
204      * be followed by the endElement method, with no intervening methods.
205      *
206      * @param element    The name of the element.
207      * @param attributes The element attributes.
208      *
209      * @throws SAXException Thrown by handler to signal an error.
210      */
<a name="8" id="anc8"></a><span class="line-modified">211     public void startElement(QName element, XMLAttributes attributes) {</span>
212         if (DEBUG_METHODS2) {
213             System.out.println(toString()+&quot;#startElement(&quot;+
214                                &quot;element={&quot;+element+&quot;},&quot;+
215                                &quot;attributes=...&quot;+attributes+
216                                &quot;)&quot;);
217         }
218 
<a name="9" id="anc9"></a><span class="line-modified">219         for (int i = 0; i &lt; fLocationPaths.length; i++) {</span>
220             // push context
221             int startStep = fCurrentStep[i];
222             fStepIndexes[i].push(startStep);
223 
224             // try next xpath, if not matching
225             if ((fMatched[i] &amp; MATCHED_DESCENDANT) == MATCHED || fNoMatchDepth[i] &gt; 0) {
226                 fNoMatchDepth[i]++;
227                 continue;
228             }
229             if((fMatched[i] &amp; MATCHED_DESCENDANT) == MATCHED_DESCENDANT) {
230                 fMatched[i] = MATCHED_DESCENDANT_PREVIOUS;
231             }
232 
233             if (DEBUG_STACK) {
234                 System.out.println(toString()+&quot;: &quot;+fStepIndexes[i]);
235             }
236 
237             // consume self::node() steps
238             XPath.Step[] steps = fLocationPaths[i].steps;
239             while (fCurrentStep[i] &lt; steps.length &amp;&amp;
240                     steps[fCurrentStep[i]].axis.type == XPath.Axis.SELF) {
241                 if (DEBUG_MATCH) {
242                     XPath.Step step = steps[fCurrentStep[i]];
243                     System.out.println(toString()+&quot; [SELF] MATCHED!&quot;);
244                 }
245                 fCurrentStep[i]++;
246             }
247             if (fCurrentStep[i] == steps.length) {
248                 if (DEBUG_MATCH) {
249                     System.out.println(toString()+&quot; XPath MATCHED!&quot;);
250                 }
251                 fMatched[i] = MATCHED;
252                 continue;
253             }
254 
255             // now if the current step is a descendant step, we let the next
256             // step do its thing; if it fails, we reset ourselves
257             // to look at this step for next time we&#39;re called.
258             // so first consume all descendants:
259             int descendantStep = fCurrentStep[i];
260             while(fCurrentStep[i] &lt; steps.length &amp;&amp;
261                     steps[fCurrentStep[i]].axis.type == XPath.Axis.DESCENDANT) {
262                 if (DEBUG_MATCH) {
263                     XPath.Step step = steps[fCurrentStep[i]];
264                     System.out.println(toString()+&quot; [DESCENDANT] MATCHED!&quot;);
265                 }
266                 fCurrentStep[i]++;
267             }
268             boolean sawDescendant = fCurrentStep[i] &gt; descendantStep;
269             if (fCurrentStep[i] == steps.length) {
270                 if (DEBUG_MATCH) {
271                     System.out.println(toString()+&quot; XPath DIDN&#39;T MATCH!&quot;);
272                 }
273                 fNoMatchDepth[i]++;
274                 if (DEBUG_MATCH) {
275                     System.out.println(toString()+&quot; [CHILD] after NO MATCH&quot;);
276                 }
277                 continue;
278             }
279 
280             // match child::... step, if haven&#39;t consumed any self::node()
281             if ((fCurrentStep[i] == startStep || fCurrentStep[i] &gt; descendantStep) &amp;&amp;
282                 steps[fCurrentStep[i]].axis.type == XPath.Axis.CHILD) {
283                 XPath.Step step = steps[fCurrentStep[i]];
284                 XPath.NodeTest nodeTest = step.nodeTest;
285                 if (DEBUG_MATCH) {
286                     System.out.println(toString()+&quot; [CHILD] before&quot;);
287                 }
<a name="10" id="anc10"></a><span class="line-modified">288                 if (!matches(nodeTest, element)) {</span>
<span class="line-modified">289                     if (fCurrentStep[i] &gt; descendantStep) {</span>
<span class="line-modified">290                         fCurrentStep[i] = descendantStep;</span>







291                         continue;
292                     }
<a name="11" id="anc11"></a><span class="line-added">293                     fNoMatchDepth[i]++;</span>
<span class="line-added">294                     if (DEBUG_MATCH) {</span>
<span class="line-added">295                         System.out.println(toString()+&quot; [CHILD] after NO MATCH&quot;);</span>
<span class="line-added">296                     }</span>
<span class="line-added">297                     continue;</span>
298                 }
299                 fCurrentStep[i]++;
300                 if (DEBUG_MATCH) {
301                     System.out.println(toString()+&quot; [CHILD] after MATCHED!&quot;);
302                 }
303             }
304             if (fCurrentStep[i] == steps.length) {
<a name="12" id="anc12"></a><span class="line-modified">305                 if (sawDescendant) {</span>
306                     fCurrentStep[i] = descendantStep;
307                     fMatched[i] = MATCHED_DESCENDANT;
<a name="13" id="anc13"></a><span class="line-modified">308                 }</span>
<span class="line-added">309                 else {</span>
310                     fMatched[i] = MATCHED;
311                 }
312                 continue;
313             }
314 
315             // match attribute::... step
316             if (fCurrentStep[i] &lt; steps.length &amp;&amp;
317                 steps[fCurrentStep[i]].axis.type == XPath.Axis.ATTRIBUTE) {
318                 if (DEBUG_MATCH) {
319                     System.out.println(toString()+&quot; [ATTRIBUTE] before&quot;);
320                 }
321                 int attrCount = attributes.getLength();
322                 if (attrCount &gt; 0) {
323                     XPath.NodeTest nodeTest = steps[fCurrentStep[i]].nodeTest;
324 
325                     for (int aIndex = 0; aIndex &lt; attrCount; aIndex++) {
326                         attributes.getName(aIndex, fQName);
<a name="14" id="anc14"></a><span class="line-modified">327                         if (matches(nodeTest, fQName)) {</span>

328                             fCurrentStep[i]++;
329                             if (fCurrentStep[i] == steps.length) {
330                                 fMatched[i] = MATCHED_ATTRIBUTE;
331                                 int j=0;
332                                 for(; j&lt;i &amp;&amp; ((fMatched[j] &amp; MATCHED) != MATCHED); j++);
333                                 if(j==i) {
334                                     AttributePSVI attrPSVI = (AttributePSVI)attributes.
335                                             getAugmentations(aIndex).getItem(Constants.ATTRIBUTE_PSVI);
336                                     fMatchedString = attrPSVI.getSchemaValue().getActualValue();
337                                     matched(fMatchedString, attrPSVI.getSchemaValue().getActualValueType(),
338                                             attrPSVI.getSchemaValue().getListValueTypes(), false);
339                                 }
340                             }
341                             break;
342                         }
343                     }
344                 }
345                 if ((fMatched[i] &amp; MATCHED) != MATCHED) {
346                     if(fCurrentStep[i] &gt; descendantStep) {
347                         fCurrentStep[i] = descendantStep;
348                         continue;
349                     }
350                     fNoMatchDepth[i]++;
351                     if (DEBUG_MATCH) {
352                         System.out.println(toString()+&quot; [ATTRIBUTE] after&quot;);
353                     }
354                     continue;
355                 }
356                 if (DEBUG_MATCH) {
357                     System.out.println(toString()+&quot; [ATTRIBUTE] after MATCHED!&quot;);
358                 }
359             }
360         }
361 
362     }
363     // startElement(QName,XMLAttrList,int)
364 
365     /**
366        * @param element
367        *        name of the element.
368        * @param type
369        *        content type of this element. IOW, the XML schema type
370        *        of the &lt;tt&gt;value&lt;/tt&gt;. Note that this may not be the type declared
371        *        in the element declaration, but it is &quot;the actual type&quot;. For example,
372        *        if the XML is &amp;lt;foo xsi:type=&quot;xs:string&quot;&gt;aaa&amp;lt;/foo&gt;, this
373        *        parameter will be &quot;xs:string&quot;.
374        * @param nillable - nillable
375        *        true if the element declaration is nillable.
376        * @param value - actual value
377        *        the typed value of the content of this element.
378        */
379     public void endElement(QName element, XSTypeDefinition type, boolean nillable,
380             Object value, short valueType, ShortList itemValueType) {
381         if (DEBUG_METHODS2) {
382             System.out.println(toString()+&quot;#endElement(&quot;+
383                                &quot;element={&quot;+element+&quot;},&quot;+
384                                &quot;)&quot;);
385         }
<a name="15" id="anc15"></a><span class="line-modified">386         for (int i = 0; i &lt; fLocationPaths.length; i++) {</span>
387             // go back a step
388             fCurrentStep[i] = fStepIndexes[i].pop();
389 
390             // don&#39;t do anything, if not matching
391             if (fNoMatchDepth[i] &gt; 0) {
392                 fNoMatchDepth[i]--;
393             }
394 
395             // signal match, if appropriate
396             else {
<a name="16" id="anc16"></a><span class="line-modified">397                 int j = 0;</span>
<span class="line-modified">398                 for(; j &lt; i &amp;&amp; ((fMatched[j] &amp; MATCHED) != MATCHED); j++);</span>
<span class="line-modified">399                 if ((j &lt; i) || (fMatched[j] == 0)) {</span>
<span class="line-modified">400                     continue;</span>
<span class="line-added">401                 }</span>
<span class="line-added">402                 if ((fMatched[j] &amp; MATCHED_ATTRIBUTE) == MATCHED_ATTRIBUTE) {</span>
<span class="line-added">403                     fMatched[i] = 0;</span>
404                     continue;
405                 }
406                 // only certain kinds of matchers actually
407                 // match element content.  This permits
408                 // them a way to override this to do nothing
409                 // and hopefully save a few operations.
410                 handleContent(type, nillable, value, valueType, itemValueType);
411                 fMatched[i] = 0;
412             }
413 
414             if (DEBUG_STACK) {
415                 System.out.println(toString()+&quot;: &quot;+fStepIndexes[i]);
416             }
417         }
418 
419     } // endElement(QName)
420 
421     //
422     // Object methods
423     //
424 
425     /** Returns a string representation of this object. */
426     public String toString() {
427         /***
428         return fLocationPath.toString();
429         /***/
430         StringBuffer str = new StringBuffer();
431         String s = super.toString();
432         int index2 = s.lastIndexOf(&#39;.&#39;);
433         if (index2 != -1) {
434             s = s.substring(index2 + 1);
435         }
436         str.append(s);
437         for(int i =0;i&lt;fLocationPaths.length; i++) {
438             str.append(&#39;[&#39;);
439             XPath.Step[] steps = fLocationPaths[i].steps;
440             for (int j = 0; j &lt; steps.length; j++) {
441                 if (j == fCurrentStep[i]) {
442                     str.append(&#39;^&#39;);
443                 }
444                 str.append(steps[j].toString());
445                 if (j &lt; steps.length - 1) {
446                     str.append(&#39;/&#39;);
447                 }
448             }
449             if (fCurrentStep[i] == steps.length) {
450                 str.append(&#39;^&#39;);
451             }
452             str.append(&#39;]&#39;);
453             str.append(&#39;,&#39;);
454         }
455         return str.toString();
456     } // toString():String
457 
458     //
459     // Private methods
460     //
461 
462     /** Normalizes text. */
463     private String normalize(String s) {
464         StringBuffer str = new StringBuffer();
465         int length = s.length();
466         for (int i = 0; i &lt; length; i++) {
467             char c = s.charAt(i);
468             switch (c) {
469                 case &#39;\n&#39;: {
470                     str.append(&quot;\\n&quot;);
471                     break;
472                 }
473                 default: {
474                     str.append(c);
475                 }
476             }
477         }
478         return str.toString();
479     } // normalize(String):String
480 
<a name="17" id="anc17"></a><span class="line-added">481     /** Returns true if the given QName matches the node test. **/</span>
<span class="line-added">482     private static boolean matches(XPath.NodeTest nodeTest, QName value) {</span>
<span class="line-added">483         if (nodeTest.type == XPath.NodeTest.QNAME) {</span>
<span class="line-added">484             return nodeTest.name.equals(value);</span>
<span class="line-added">485         }</span>
<span class="line-added">486         if (nodeTest.type == XPath.NodeTest.NAMESPACE) {</span>
<span class="line-added">487             return nodeTest.name.uri == value.uri;</span>
<span class="line-added">488         }</span>
<span class="line-added">489         // XPath.NodeTest.WILDCARD</span>
<span class="line-added">490         return true;</span>
<span class="line-added">491     } // matches(XPath.NodeTest,QName):boolean</span>
<span class="line-added">492 </span>
493     //
494     // MAIN
495     //
496 
497     // NOTE: The main of this class is here for debugging purposes.
498     //       However, javac (JDK 1.1.8) has an internal compiler
499     //       error when compiling. Jikes has no problem, though.
500     //
501     //       If you want to use this main, use Jikes to compile but
502     //       *never* check in this code to CVS without commenting it
503     //       out. -Ac
504 
505     /** Main program. */
506     /***
507     public static void main(String[] argv) throws XNIException {
508 
509         if (DEBUG_ANY) {
510             for (int i = 0; i &lt; argv.length; i++) {
511                 final String expr = argv[i];
512                 final XPath xpath = new XPath(expr, symbols, null);
513                 final XPathMatcher matcher = new XPathMatcher(xpath, true);
514                 com.sun.org.apache.xerces.internal.parsers.SAXParser parser =
515                     new com.sun.org.apache.xerces.internal.parsers.SAXParser(symbols) {
516                     public void startDocument() throws XNIException {
517                         matcher.startDocumentFragment(symbols, null);
518                     }
519                     public void startElement(QName element, XMLAttrList attributes, int handle) throws XNIException {
520                         matcher.startElement(element, attributes, handle);
521                     }
522                     public void characters(char[] ch, int offset, int length) throws XNIException {
523                         matcher.characters(ch, offset, length);
524                     }
525                     public void endElement(QName element) throws XNIException {
526                         matcher.endElement(element);
527                     }
528                     public void endDocument() throws XNIException {
529                         matcher.endDocumentFragment();
530                     }
531                 };
532                 System.out.println(&quot;#### argv[&quot;+i+&quot;]: \&quot;&quot;+expr+&quot;\&quot; -&gt; \&quot;&quot;+xpath.toString()+&#39;&quot;&#39;);
533                 final String uri = argv[++i];
534                 System.out.println(&quot;#### argv[&quot;+i+&quot;]: &quot;+uri);
535                 parser.parse(uri);
536             }
537         }
538 
539     } // main(String[])
540     /***/
541 
542 } // class XPathMatcher
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
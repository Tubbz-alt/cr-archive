<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/bcel/internal/util/InstructionFinder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.bcel.internal.util;
 22 
 23 import com.sun.org.apache.bcel.internal.Const;
 24 import com.sun.org.apache.bcel.internal.generic.ClassGenException;
 25 import com.sun.org.apache.bcel.internal.generic.InstructionHandle;
 26 import com.sun.org.apache.bcel.internal.generic.InstructionList;
 27 import java.util.ArrayList;
 28 import java.util.HashMap;
 29 import java.util.Iterator;
 30 import java.util.List;
 31 import java.util.Locale;
 32 import java.util.Map;
 33 import java.util.regex.Matcher;
 34 import java.util.regex.Pattern;
 35 
 36 /**
 37  * InstructionFinder is a tool to search for given instructions patterns, i.e.,
 38  * match sequences of instructions in an instruction list via regular
 39  * expressions. This can be used, e.g., in order to implement a peep hole
 40  * optimizer that looks for code patterns and replaces them with faster
 41  * equivalents.
 42  *
 43  * &lt;p&gt;
 44  * This class internally uses the java.util.regex
 45  * package to search for regular expressions.
 46  *
 47  * A typical application would look like this:
 48  *
 49  * &lt;pre&gt;
 50  *
 51  *
 52  *   InstructionFinder f   = new InstructionFinder(il);
 53  *   String            pat = &amp;quot;IfInstruction ICONST_0 GOTO ICONST_1 NOP (IFEQ|IFNE)&amp;quot;;
 54  *
 55  *   for (Iterator i = f.search(pat, constraint); i.hasNext(); ) {
 56  *   InstructionHandle[] match = (InstructionHandle[])i.next();
 57  *   ...
 58  *   il.delete(match[1], match[5]);
 59  *   ...
 60  *   }
 61  *
 62  *
 63  * &lt;/pre&gt;
 64  *
 65  * @see com.sun.org.apache.bcel.internal.generic.Instruction
 66  * @see InstructionList
 67  * @LastModified: Jan 2020
 68  */
 69 public class InstructionFinder {
 70 
 71     private static final int OFFSET = 32767; // char + OFFSET is outside of LATIN-1
 72     private static final int NO_OPCODES = 256; // Potential number, some are not used
 73     private static final Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
 74     private final InstructionList il;
 75     private String il_string; // instruction list as string
 76     private InstructionHandle[] handles; // map instruction
 77 
 78 
 79     // list to array
 80     /**
 81      * @param il
 82      *          instruction list to search for given patterns
 83      */
 84     public InstructionFinder(final InstructionList il) {
 85         this.il = il;
 86         reread();
 87     }
 88 
 89 
 90     /**
 91      * Reread the instruction list, e.g., after you&#39;ve altered the list upon a
 92      * match.
 93      */
 94     public final void reread() {
 95         final int size = il.getLength();
 96         final char[] buf = new char[size]; // Create a string with length equal to il length
 97         handles = il.getInstructionHandles();
 98         // Map opcodes to characters
 99         for (int i = 0; i &lt; size; i++) {
100             buf[i] = makeChar(handles[i].getInstruction().getOpcode());
101         }
102         il_string = new String(buf);
103     }
104 
105 
106     /**
107      * Map symbolic instruction names like &quot;getfield&quot; to a single character.
108      *
109      * @param pattern
110      *          instruction pattern in lower case
111      * @return encoded string for a pattern such as &quot;BranchInstruction&quot;.
112      */
113     private static String mapName( final String pattern ) {
114         final String result = map.get(pattern);
115         if (result != null) {
116             return result;
117         }
118         for (short i = 0; i &lt; NO_OPCODES; i++) {
119             if (pattern.equals(Const.getOpcodeName(i))) {
120                 return &quot;&quot; + makeChar(i);
121             }
122         }
123         throw new RuntimeException(&quot;Instruction unknown: &quot; + pattern);
124     }
125 
126 
127     /**
128      * Replace symbolic names of instructions with the appropiate character and
129      * remove all white space from string. Meta characters such as +, * are
130      * ignored.
131      *
132      * @param pattern
133      *          The pattern to compile
134      * @return translated regular expression string
135      */
136     private static String compilePattern( final String pattern ) {
137         //Bug: BCEL-77 - Instructions are assumed to be english, to avoid odd Locale issues
138         final String lower = pattern.toLowerCase(Locale.ENGLISH);
139         final StringBuilder buf = new StringBuilder();
140         final int size = pattern.length();
141         for (int i = 0; i &lt; size; i++) {
142             char ch = lower.charAt(i);
143             if (Character.isLetterOrDigit(ch)) {
144                 final StringBuilder name = new StringBuilder();
145                 while ((Character.isLetterOrDigit(ch) || ch == &#39;_&#39;) &amp;&amp; i &lt; size) {
146                     name.append(ch);
147                     if (++i &lt; size) {
148                         ch = lower.charAt(i);
149                     } else {
150                         break;
151                     }
152                 }
153                 i--;
154                 buf.append(mapName(name.toString()));
155             } else if (!Character.isWhitespace(ch)) {
156                 buf.append(ch);
157             }
158         }
159         return buf.toString();
160     }
161 
162 
163     /**
164      * @return the matched piece of code as an array of instruction (handles)
165      */
166     private InstructionHandle[] getMatch( final int matched_from, final int match_length ) {
167         final InstructionHandle[] match = new InstructionHandle[match_length];
168         System.arraycopy(handles, matched_from, match, 0, match_length);
169         return match;
170     }
171 
172 
173     /**
174      * Search for the given pattern in the instruction list. You can search for
175      * any valid opcode via its symbolic name, e.g. &quot;istore&quot;. You can also use a
176      * super class or an interface name to match a whole set of instructions, e.g.
177      * &quot;BranchInstruction&quot; or &quot;LoadInstruction&quot;. &quot;istore&quot; is also an alias for all
178      * &quot;istore_x&quot; instructions. Additional aliases are &quot;if&quot; for &quot;ifxx&quot;, &quot;if_icmp&quot;
179      * for &quot;if_icmpxx&quot;, &quot;if_acmp&quot; for &quot;if_acmpxx&quot;.
180      *
181      * Consecutive instruction names must be separated by white space which will
182      * be removed during the compilation of the pattern.
183      *
184      * For the rest the usual pattern matching rules for regular expressions
185      * apply.
186      * &lt;P&gt;
187      * Example pattern:
188      *
189      * &lt;pre&gt;
190      * search(&amp;quot;BranchInstruction NOP ((IfInstruction|GOTO)+ ISTORE Instruction)*&amp;quot;);
191      * &lt;/pre&gt;
192      *
193      * &lt;p&gt;
194      * If you alter the instruction list upon a match such that other matching
195      * areas are affected, you should call reread() to update the finder and call
196      * search() again, because the matches are cached.
197      *
198      * @param pattern
199      *          the instruction pattern to search for, where case is ignored
200      * @param from
201      *          where to start the search in the instruction list
202      * @param constraint
203      *          optional CodeConstraint to check the found code pattern for
204      *          user-defined constraints
205      * @return iterator of matches where e.nextElement() returns an array of
206      *         instruction handles describing the matched area
207      */
208     public final Iterator&lt;InstructionHandle[]&gt; search( final String pattern,
209             final InstructionHandle from, final CodeConstraint constraint ) {
210         final String search = compilePattern(pattern);
211         int start = -1;
212         for (int i = 0; i &lt; handles.length; i++) {
213             if (handles[i] == from) {
214                 start = i; // Where to start search from (index)
215                 break;
216             }
217         }
218         if (start == -1) {
219             throw new ClassGenException(&quot;Instruction handle &quot; + from
220                     + &quot; not found in instruction list.&quot;);
221         }
222         final Pattern regex = Pattern.compile(search);
223         final List&lt;InstructionHandle[]&gt; matches = new ArrayList&lt;&gt;();
224         final Matcher matcher = regex.matcher(il_string);
225         while (start &lt; il_string.length() &amp;&amp; matcher.find(start)) {
226             final int startExpr = matcher.start();
227             final int endExpr = matcher.end();
228             final int lenExpr = endExpr - startExpr;
229             final InstructionHandle[] match = getMatch(startExpr, lenExpr);
230             if ((constraint == null) || constraint.checkCode(match)) {
231                 matches.add(match);
232             }
233             start = endExpr;
234         }
235         return matches.iterator();
236     }
237 
238 
239     /**
240      * Start search beginning from the start of the given instruction list.
241      *
242      * @param pattern
243      *          the instruction pattern to search for, where case is ignored
244      * @return iterator of matches where e.nextElement() returns an array of
245      *         instruction handles describing the matched area
246      */
247     public final Iterator&lt;InstructionHandle[]&gt; search( final String pattern ) {
248         return search(pattern, il.getStart(), null);
249     }
250 
251 
252     /**
253      * Start search beginning from `from&#39;.
254      *
255      * @param pattern
256      *          the instruction pattern to search for, where case is ignored
257      * @param from
258      *          where to start the search in the instruction list
259      * @return iterator of matches where e.nextElement() returns an array of
260      *         instruction handles describing the matched area
261      */
262     public final Iterator&lt;InstructionHandle[]&gt; search( final String pattern,
263             final InstructionHandle from ) {
264         return search(pattern, from, null);
265     }
266 
267 
268     /**
269      * Start search beginning from the start of the given instruction list. Check
270      * found matches with the constraint object.
271      *
272      * @param pattern
273      *          the instruction pattern to search for, case is ignored
274      * @param constraint
275      *          constraints to be checked on matching code
276      * @return instruction handle or `null&#39; if the match failed
277      */
278     public final Iterator&lt;InstructionHandle[]&gt; search( final String pattern,
279             final CodeConstraint constraint ) {
280         return search(pattern, il.getStart(), constraint);
281     }
282 
283 
284     /**
285      * Convert opcode number to char.
286      */
287     private static char makeChar( final short opcode ) {
288         return (char) (opcode + OFFSET);
289     }
290 
291 
292     /**
293      * @return the inquired instruction list
294      */
295     public final InstructionList getInstructionList() {
296         return il;
297     }
298 
299     /**
300      * Code patterns found may be checked using an additional user-defined
301      * constraint object whether they really match the needed criterion. I.e.,
302      * check constraints that can not expressed with regular expressions.
303      *
304      */
305     public interface CodeConstraint {
306 
307         /**
308          * @param match
309          *          array of instructions matching the requested pattern
310          * @return true if the matched area is really useful
311          */
312         boolean checkCode( InstructionHandle[] match );
313     }
314 
315     // Initialize pattern map
316     static {
317         map.put(&quot;arithmeticinstruction&quot;,&quot;(irem|lrem|iand|ior|ineg|isub|lneg|fneg|fmul|ldiv|fadd|lxor|frem|idiv|land|ixor|ishr|fsub|lshl|fdiv|iadd|lor|dmul|lsub|ishl|imul|lmul|lushr|dneg|iushr|lshr|ddiv|drem|dadd|ladd|dsub)&quot;);
318         map.put(&quot;invokeinstruction&quot;, &quot;(invokevirtual|invokeinterface|invokestatic|invokespecial|invokedynamic)&quot;);
319         map.put(&quot;arrayinstruction&quot;, &quot;(baload|aastore|saload|caload|fastore|lastore|iaload|castore|iastore|aaload|bastore|sastore|faload|laload|daload|dastore)&quot;);
320         map.put(&quot;gotoinstruction&quot;, &quot;(goto|goto_w)&quot;);
321         map.put(&quot;conversioninstruction&quot;, &quot;(d2l|l2d|i2s|d2i|l2i|i2b|l2f|d2f|f2i|i2d|i2l|f2d|i2c|f2l|i2f)&quot;);
322         map.put(&quot;localvariableinstruction&quot;,&quot;(fstore|iinc|lload|dstore|dload|iload|aload|astore|istore|fload|lstore)&quot;);
323         map.put(&quot;loadinstruction&quot;, &quot;(fload|dload|lload|iload|aload)&quot;);
324         map.put(&quot;fieldinstruction&quot;, &quot;(getfield|putstatic|getstatic|putfield)&quot;);
325         map.put(&quot;cpinstruction&quot;, &quot;(ldc2_w|invokeinterface|invokedynamic|multianewarray|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|ldc_w|invokestatic|invokevirtual|putfield|ldc|new|anewarray)&quot;);
326         map.put(&quot;stackinstruction&quot;, &quot;(dup2|swap|dup2_x2|pop|pop2|dup|dup2_x1|dup_x2|dup_x1)&quot;);
327         map.put(&quot;branchinstruction&quot;, &quot;(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)&quot;);
328         map.put(&quot;returninstruction&quot;, &quot;(lreturn|ireturn|freturn|dreturn|areturn|return)&quot;);
329         map.put(&quot;storeinstruction&quot;, &quot;(istore|fstore|dstore|astore|lstore)&quot;);
330         map.put(&quot;select&quot;, &quot;(tableswitch|lookupswitch)&quot;);
331         map.put(&quot;ifinstruction&quot;, &quot;(ifeq|ifgt|if_icmpne|if_icmpeq|ifge|ifnull|ifne|if_icmple|if_icmpge|if_acmpeq|if_icmplt|if_acmpne|ifnonnull|iflt|if_icmpgt|ifle)&quot;);
332         map.put(&quot;jsrinstruction&quot;, &quot;(jsr|jsr_w)&quot;);
333         map.put(&quot;variablelengthinstruction&quot;, &quot;(tableswitch|jsr|goto|lookupswitch)&quot;);
334         map.put(&quot;unconditionalbranch&quot;, &quot;(goto|jsr|jsr_w|athrow|goto_w)&quot;);
335         map.put(&quot;constantpushinstruction&quot;, &quot;(dconst|bipush|sipush|fconst|iconst|lconst)&quot;);
336         map.put(&quot;typedinstruction&quot;, &quot;(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dastore|ret|f2d|f2i|drem|iinc|i2c|checkcast|frem|lreturn|astore|lushr|daload|dneg|fastore|istore|lshl|ldiv|lstore|areturn|ishr|ldc_w|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|faload|sipush|iushr|caload|instanceof|invokespecial|putfield|fmul|ireturn|laload|d2f|lneg|ixor|i2l|fdiv|lastore|multianewarray|i2b|getstatic|i2d|putstatic|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|freturn|ldc|aconst_null|castore|lmul|ldc2_w|dadd|iconst|f2l|ddiv|dstore|land|jsr|anewarray|dmul|bipush|dsub|sastore|d2i|i2s|lshr|iadd|l2i|lload|bastore|fstore|fneg|iload|fadd|baload|fconst|ior|ineg|dreturn|l2f|lconst|getfield|invokevirtual|invokestatic|iastore)&quot;);
337         map.put(&quot;popinstruction&quot;, &quot;(fstore|dstore|pop|pop2|astore|putstatic|istore|lstore)&quot;);
338         map.put(&quot;allocationinstruction&quot;, &quot;(multianewarray|new|anewarray|newarray)&quot;);
339         map.put(&quot;indexedinstruction&quot;, &quot;(lload|lstore|fload|ldc2_w|invokeinterface|invokedynamic|multianewarray|astore|dload|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|dstore|istore|iinc|ldc_w|ret|fstore|invokestatic|iload|putfield|invokevirtual|ldc|new|aload|anewarray)&quot;);
340         map.put(&quot;pushinstruction&quot;, &quot;(dup|lload|dup2|bipush|fload|ldc2_w|sipush|lconst|fconst|dload|getstatic|ldc_w|aconst_null|dconst|iload|ldc|iconst|aload)&quot;);
341         map.put(&quot;stackproducer&quot;, &quot;(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dup|f2d|f2i|drem|i2c|checkcast|frem|lushr|daload|dneg|lshl|ldiv|ishr|ldc_w|invokeinterface|invokedynamic|lxor|ishl|l2d|i2f|faload|sipush|iushr|caload|instanceof|invokespecial|fmul|laload|d2f|lneg|ixor|i2l|fdiv|getstatic|i2b|swap|i2d|dup2|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|ldc|arraylength|aconst_null|tableswitch|lmul|ldc2_w|iconst|dadd|f2l|ddiv|land|jsr|anewarray|dmul|bipush|dsub|d2i|newarray|i2s|lshr|iadd|lload|l2i|fneg|iload|fadd|baload|fconst|lookupswitch|ior|ineg|lconst|l2f|getfield|invokevirtual|invokestatic)&quot;);
342         map.put(&quot;stackconsumer&quot;, &quot;(imul|lsub|lor|iflt|fcmpg|if_icmpgt|iand|ifeq|if_icmplt|lrem|ifnonnull|idiv|d2l|isub|dcmpg|dastore|if_icmpeq|f2d|f2i|drem|i2c|checkcast|frem|lreturn|astore|lushr|pop2|monitorexit|dneg|fastore|istore|lshl|ldiv|lstore|areturn|if_icmpge|ishr|monitorenter|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|iushr|instanceof|invokespecial|fmul|ireturn|d2f|lneg|ixor|pop|i2l|ifnull|fdiv|lastore|i2b|if_acmpeq|ifge|swap|i2d|putstatic|fcmpl|ladd|irem|dcmpl|fsub|freturn|ifgt|castore|lmul|dadd|f2l|ddiv|dstore|land|if_icmpne|if_acmpne|dmul|dsub|sastore|ifle|d2i|i2s|lshr|iadd|l2i|bastore|fstore|fneg|fadd|ior|ineg|ifne|dreturn|l2f|if_icmple|getfield|invokevirtual|invokestatic|iastore)&quot;);
343         map.put(&quot;exceptionthrower&quot;,&quot;(irem|lrem|laload|putstatic|baload|dastore|areturn|getstatic|ldiv|anewarray|iastore|castore|idiv|saload|lastore|fastore|putfield|lreturn|caload|getfield|return|aastore|freturn|newarray|instanceof|multianewarray|athrow|faload|iaload|aaload|dreturn|monitorenter|checkcast|bastore|arraylength|new|invokevirtual|sastore|ldc_w|ireturn|invokespecial|monitorexit|invokeinterface|invokedynamic|ldc|invokestatic|daload)&quot;);
344         map.put(&quot;loadclass&quot;, &quot;(multianewarray|invokeinterface|invokedynamic|instanceof|invokespecial|putfield|checkcast|putstatic|invokevirtual|new|getstatic|invokestatic|getfield|anewarray)&quot;);
345         map.put(&quot;instructiontargeter&quot;, &quot;(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)&quot;);
346         // Some aliases
347         map.put(&quot;if_icmp&quot;, &quot;(if_icmpne|if_icmpeq|if_icmple|if_icmpge|if_icmplt|if_icmpgt)&quot;);
348         map.put(&quot;if_acmp&quot;, &quot;(if_acmpeq|if_acmpne)&quot;);
349         map.put(&quot;if&quot;, &quot;(ifeq|ifne|iflt|ifge|ifgt|ifle)&quot;);
350         // Precompile some aliases first
351         map.put(&quot;iconst&quot;, precompile(Const.ICONST_0, Const.ICONST_5, Const.ICONST_M1));
352         map.put(&quot;lconst&quot;, new String(new char[] { &#39;(&#39;, makeChar(Const.LCONST_0), &#39;|&#39;, makeChar(Const.LCONST_1), &#39;)&#39; }));
353         map.put(&quot;dconst&quot;, new String(new char[] { &#39;(&#39;, makeChar(Const.DCONST_0), &#39;|&#39;, makeChar(Const.DCONST_1), &#39;)&#39; }));
354         map.put(&quot;fconst&quot;, new String(new char[] { &#39;(&#39;, makeChar(Const.FCONST_0), &#39;|&#39;, makeChar(Const.FCONST_1), &#39;|&#39;, makeChar(Const.FCONST_2), &#39;)&#39; }));
355         map.put(&quot;lload&quot;, precompile(Const.LLOAD_0, Const.LLOAD_3, Const.LLOAD));
356         map.put(&quot;iload&quot;, precompile(Const.ILOAD_0, Const.ILOAD_3, Const.ILOAD));
357         map.put(&quot;dload&quot;, precompile(Const.DLOAD_0, Const.DLOAD_3, Const.DLOAD));
358         map.put(&quot;fload&quot;, precompile(Const.FLOAD_0, Const.FLOAD_3, Const.FLOAD));
359         map.put(&quot;aload&quot;, precompile(Const.ALOAD_0, Const.ALOAD_3, Const.ALOAD));
360         map.put(&quot;lstore&quot;, precompile(Const.LSTORE_0, Const.LSTORE_3, Const.LSTORE));
361         map.put(&quot;istore&quot;, precompile(Const.ISTORE_0, Const.ISTORE_3, Const.ISTORE));
362         map.put(&quot;dstore&quot;, precompile(Const.DSTORE_0, Const.DSTORE_3, Const.DSTORE));
363         map.put(&quot;fstore&quot;, precompile(Const.FSTORE_0, Const.FSTORE_3, Const.FSTORE));
364         map.put(&quot;astore&quot;, precompile(Const.ASTORE_0, Const.ASTORE_3, Const.ASTORE));
365         // Compile strings
366         for (final Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
367             final String key = entry.getKey();
368             final String value = entry.getValue();
369             final char ch = value.charAt(1); // Omit already precompiled patterns
370             if (ch &lt; OFFSET) {
371                 map.put(key, compilePattern(value)); // precompile all patterns
372             }
373         }
374         // Add instruction alias to match anything
375         final StringBuilder buf = new StringBuilder(&quot;(&quot;);
376         for (short i = 0; i &lt; NO_OPCODES; i++) {
377             if (Const.getNoOfOperands(i) != Const.UNDEFINED) { // Not an invalid opcode
378                 buf.append(makeChar(i));
379                 if (i &lt; NO_OPCODES - 1) {
380                     buf.append(&#39;|&#39;);
381                 }
382             }
383         }
384         buf.append(&#39;)&#39;);
385         map.put(&quot;instruction&quot;, buf.toString());
386     }
387 
388 
389     private static String precompile( final short from, final short to, final short extra ) {
390         final StringBuilder buf = new StringBuilder(&quot;(&quot;);
391         for (short i = from; i &lt;= to; i++) {
392             buf.append(makeChar(i));
393             buf.append(&#39;|&#39;);
394         }
395         buf.append(makeChar(extra));
396         buf.append(&quot;)&quot;);
397         return buf.toString();
398     }
399 
400 
401     /*
402      * Internal debugging routines.
403      */
404 //    private static final String pattern2string( String pattern ) {
405 //        return pattern2string(pattern, true);
406 //    }
407 
408 
409 //    private static final String pattern2string( String pattern, boolean make_string ) {
410 //        StringBuffer buf = new StringBuffer();
411 //        for (int i = 0; i &lt; pattern.length(); i++) {
412 //            char ch = pattern.charAt(i);
413 //            if (ch &gt;= OFFSET) {
414 //                if (make_string) {
415 //                    buf.append(Constants.getOpcodeName(ch - OFFSET));
416 //                } else {
417 //                    buf.append((ch - OFFSET));
418 //                }
419 //            } else {
420 //                buf.append(ch);
421 //            }
422 //        }
423 //        return buf.toString();
424 //    }
425 }
    </pre>
  </body>
</html>
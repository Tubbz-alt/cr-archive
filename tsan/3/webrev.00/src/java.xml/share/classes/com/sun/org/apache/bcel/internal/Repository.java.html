<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/bcel/internal/Repository.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal;
 21 
 22 
 23 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
 24 import com.sun.org.apache.bcel.internal.util.SyntheticRepository;
 25 
 26 /**
 27  * The repository maintains informations about class interdependencies, e.g.,
 28  * whether a class is a sub-class of another. Delegates actual class loading
 29  * to SyntheticRepository with current class path by default.
 30  *
 31  * @see com.sun.org.apache.bcel.internal.util.Repository
 32  * @see SyntheticRepository
 33  *
 34  * @LastModified: Jan 2020
 35  */
 36 public abstract class Repository {
 37 
 38     private static com.sun.org.apache.bcel.internal.util.Repository repository
 39             = SyntheticRepository.getInstance();
 40 
 41 
 42     /**
 43      * @return currently used repository instance
 44      */
 45     public static com.sun.org.apache.bcel.internal.util.Repository getRepository() {
 46         return repository;
 47     }
 48 
 49 
 50     /**
 51      * Sets repository instance to be used for class loading
 52      */
 53     public static void setRepository( final com.sun.org.apache.bcel.internal.util.Repository rep ) {
 54         repository = rep;
 55     }
 56 
 57 
 58     /**
 59      * Lookups class somewhere found on your CLASSPATH, or whereever the
 60      * repository instance looks for it.
 61      *
 62      * @return class object for given fully qualified class name
 63      * @throws ClassNotFoundException if the class could not be found or
 64      * parsed correctly
 65      */
 66     public static JavaClass lookupClass( final String class_name ) throws ClassNotFoundException {
 67         return repository.loadClass(class_name);
 68     }
 69 
 70 
 71     /**
 72      * Tries to find class source using the internal repository instance.
 73      *
 74      * @see Class
 75      * @return JavaClass object for given runtime class
 76      * @throws ClassNotFoundException if the class could not be found or
 77      * parsed correctly
 78      */
 79     public static JavaClass lookupClass( final Class&lt;?&gt; clazz ) throws ClassNotFoundException {
 80         return repository.loadClass(clazz);
 81     }
 82 
 83 
 84     /**
 85      * Clear the repository.
 86      */
 87     public static void clearCache() {
 88         repository.clear();
 89     }
 90 
 91 
 92     /**
 93      * Adds clazz to repository if there isn&#39;t an equally named class already in there.
 94      *
 95      * @return old entry in repository
 96      */
 97     public static JavaClass addClass( final JavaClass clazz ) {
 98         final JavaClass old = repository.findClass(clazz.getClassName());
 99         repository.storeClass(clazz);
100         return old;
101     }
102 
103 
104     /**
105      * Removes class with given (fully qualified) name from repository.
106      */
107     public static void removeClass( final String clazz ) {
108         repository.removeClass(repository.findClass(clazz));
109     }
110 
111 
112     /**
113      * Removes given class from repository.
114      */
115     public static void removeClass( final JavaClass clazz ) {
116         repository.removeClass(clazz);
117     }
118 
119 
120     /**
121      * @return list of super classes of clazz in ascending order, i.e.,
122      * Object is always the last element
123      * @throws ClassNotFoundException if any of the superclasses can&#39;t be found
124      */
125     public static JavaClass[] getSuperClasses( final JavaClass clazz ) throws ClassNotFoundException {
126         return clazz.getSuperClasses();
127     }
128 
129 
130     /**
131      * @return list of super classes of clazz in ascending order, i.e.,
132      * Object is always the last element.
133      * @throws ClassNotFoundException if the named class or any of its
134      *  superclasses can&#39;t be found
135      */
136     public static JavaClass[] getSuperClasses( final String class_name ) throws ClassNotFoundException {
137         final JavaClass jc = lookupClass(class_name);
138         return getSuperClasses(jc);
139     }
140 
141 
142     /**
143      * @return all interfaces implemented by class and its super
144      * classes and the interfaces that those interfaces extend, and so on.
145      * (Some people call this a transitive hull).
146      * @throws ClassNotFoundException if any of the class&#39;s
147      *  superclasses or superinterfaces can&#39;t be found
148      */
149     public static JavaClass[] getInterfaces( final JavaClass clazz ) throws ClassNotFoundException {
150         return clazz.getAllInterfaces();
151     }
152 
153 
154     /**
155      * @return all interfaces implemented by class and its super
156      * classes and the interfaces that extend those interfaces, and so on
157      * @throws ClassNotFoundException if the named class can&#39;t be found,
158      *   or if any of its superclasses or superinterfaces can&#39;t be found
159      */
160     public static JavaClass[] getInterfaces( final String class_name ) throws ClassNotFoundException {
161         return getInterfaces(lookupClass(class_name));
162     }
163 
164 
165     /**
166      * Equivalent to runtime &quot;instanceof&quot; operator.
167      * @return true, if clazz is an instance of super_class
168      * @throws ClassNotFoundException if any superclasses or superinterfaces
169      *   of clazz can&#39;t be found
170      */
171     public static boolean instanceOf( final JavaClass clazz, final JavaClass super_class )
172             throws ClassNotFoundException {
173         return clazz.instanceOf(super_class);
174     }
175 
176 
177     /**
178      * @return true, if clazz is an instance of super_class
179      * @throws ClassNotFoundException if either clazz or super_class
180      *   can&#39;t be found
181      */
182     public static boolean instanceOf( final String clazz, final String super_class )
183             throws ClassNotFoundException {
184         return instanceOf(lookupClass(clazz), lookupClass(super_class));
185     }
186 
187 
188     /**
189      * @return true, if clazz is an instance of super_class
190      * @throws ClassNotFoundException if super_class can&#39;t be found
191      */
192     public static boolean instanceOf( final JavaClass clazz, final String super_class )
193             throws ClassNotFoundException {
194         return instanceOf(clazz, lookupClass(super_class));
195     }
196 
197 
198     /**
199      * @return true, if clazz is an instance of super_class
200      * @throws ClassNotFoundException if clazz can&#39;t be found
201      */
202     public static boolean instanceOf( final String clazz, final JavaClass super_class )
203             throws ClassNotFoundException {
204         return instanceOf(lookupClass(clazz), super_class);
205     }
206 
207 
208     /**
209      * @return true, if clazz is an implementation of interface inter
210      * @throws ClassNotFoundException if any superclasses or superinterfaces
211      *   of clazz can&#39;t be found
212      */
213     public static boolean implementationOf( final JavaClass clazz, final JavaClass inter )
214             throws ClassNotFoundException {
215         return clazz.implementationOf(inter);
216     }
217 
218 
219     /**
220      * @return true, if clazz is an implementation of interface inter
221      * @throws ClassNotFoundException if clazz, inter, or any superclasses
222      *   or superinterfaces of clazz can&#39;t be found
223      */
224     public static boolean implementationOf( final String clazz, final String inter )
225             throws ClassNotFoundException {
226         return implementationOf(lookupClass(clazz), lookupClass(inter));
227     }
228 
229 
230     /**
231      * @return true, if clazz is an implementation of interface inter
232      * @throws ClassNotFoundException if inter or any superclasses
233      *   or superinterfaces of clazz can&#39;t be found
234      */
235     public static boolean implementationOf( final JavaClass clazz, final String inter )
236             throws ClassNotFoundException {
237         return implementationOf(clazz, lookupClass(inter));
238     }
239 
240 
241     /**
242      * @return true, if clazz is an implementation of interface inter
243      * @throws ClassNotFoundException if clazz or any superclasses or
244      *   superinterfaces of clazz can&#39;t be found
245      */
246     public static boolean implementationOf( final String clazz, final JavaClass inter )
247             throws ClassNotFoundException {
248         return implementationOf(lookupClass(clazz), inter);
249     }
250 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ElementImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentTypeImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ElementNSImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ElementImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * reserved comment block</span>
<span class="line-removed">   3  * DO NOT REMOVE OR ALTER!</span>
   4  */
   5 /*
   6  * Licensed to the Apache Software Foundation (ASF) under one or more
   7  * contributor license agreements.  See the NOTICE file distributed with
   8  * this work for additional information regarding copyright ownership.
   9  * The ASF licenses this file to You under the Apache License, Version 2.0
  10  * (the &quot;License&quot;); you may not use this file except in compliance with
  11  * the License.  You may obtain a copy of the License at
  12  *
  13  *      http://www.apache.org/licenses/LICENSE-2.0
  14  *
  15  * Unless required by applicable law or agreed to in writing, software
  16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  18  * See the License for the specific language governing permissions and
  19  * limitations under the License.
  20  */
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 import org.w3c.dom.Attr;
</pre>
<hr />
<pre>
  38  * &lt;P&gt;
  39  * Elements may have Attributes associated with them; the API for this is
  40  * defined in Node, but the function is implemented here. In general, XML
  41  * applications should retrive Attributes as Nodes, since they may contain
  42  * entity references and hence be a fairly complex sub-tree. HTML users will be
  43  * dealing with simple string values, and convenience methods are provided to
  44  * work in terms of Strings.
  45  * &lt;P&gt;
  46  * ElementImpl does not support Namespaces. ElementNSImpl, which inherits from
  47  * it, does.
  48  *
  49  * @see ElementNSImpl
  50  *
  51  * @xerces.internal
  52  *
  53  * @author Arnaud Le Hors, IBM
  54  * @author Joe Kesselman, IBM
  55  * @author Andy Clark, IBM
  56  * @author Ralf Pfeiffer, IBM
  57  * @since PR-DOM-Level-1-19980818.

  58  */
  59 public class ElementImpl
<span class="line-modified">  60         extends ParentNode</span>
<span class="line-modified">  61         implements Element, ElementTraversal, TypeInfo {</span>
  62 
  63     //
  64     // Constants
  65     //
<span class="line-modified">  66     /**</span>
<span class="line-modified">  67      * Serialization version.</span>
<span class="line-removed">  68      */</span>
  69     static final long serialVersionUID = 3717253516652722278L;
  70     //
  71     // Data
  72     //
  73 
<span class="line-modified">  74     /**</span>
<span class="line-removed">  75      * Element name.</span>
<span class="line-removed">  76      */</span>
  77     protected String name;
  78 
<span class="line-modified">  79     /**</span>
<span class="line-removed">  80      * Attributes.</span>
<span class="line-removed">  81      */</span>
  82     protected AttributeMap attributes;
  83 
  84     //
  85     // Constructors
  86     //
<span class="line-modified">  87     /**</span>
<span class="line-modified">  88      * Factory constructor.</span>
<span class="line-removed">  89      */</span>
  90     public ElementImpl(CoreDocumentImpl ownerDoc, String name) {
  91         super(ownerDoc);
  92         this.name = name;
  93         needsSyncData(true);    // synchronizeData will initialize attributes
  94     }
  95 
  96     // for ElementNSImpl
<span class="line-modified">  97     protected ElementImpl() {</span>
<span class="line-removed">  98     }</span>
  99 
 100     // Support for DOM Level 3 renameNode method.
 101     // Note: This only deals with part of the pb. CoreDocumentImpl
 102     // does all the work.
 103     void rename(String name) {
 104         if (needsSyncData()) {
 105             synchronizeData();
 106         }
 107         if (ownerDocument.errorChecking) {
 108             int colon1 = name.indexOf(&#39;:&#39;);
 109             if (colon1 != -1) {
 110                 String msg
 111                         = DOMMessageFormatter.formatMessage(
<span class="line-modified"> 112                                 DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-modified"> 113                                 &quot;NAMESPACE_ERR&quot;,</span>
<span class="line-modified"> 114                                 null);</span>
 115                 throw new DOMException(DOMException.NAMESPACE_ERR, msg);
 116             }
 117             if (!CoreDocumentImpl.isXMLName(name, ownerDocument.isXML11Version())) {
 118                 String msg = DOMMessageFormatter.formatMessage(
 119                         DOMMessageFormatter.DOM_DOMAIN,
 120                         &quot;INVALID_CHARACTER_ERR&quot;, null);
 121                 throw new DOMException(DOMException.INVALID_CHARACTER_ERR,
 122                         msg);
 123             }
 124         }
 125         this.name = name;
 126         reconcileDefaultAttributes();
 127     }
 128 
 129     //
 130     // Node methods
 131     //
 132     /**
 133      * A short integer indicating what type of node this is. The named constants
 134      * for this value are defined in the org.w3c.dom.Node interface.
</pre>
<hr />
<pre>
 270     //
 271     // Element methods
 272     //
 273     /**
 274      * Look up a single Attribute by name. Returns the Attribute&#39;s string value,
 275      * or an empty string (NOT null!) to indicate that the name did not map to a
 276      * currently defined attribute.
 277      * &lt;p&gt;
 278      * Note: Attributes may contain complex node trees. This method returns the
 279      * &quot;flattened&quot; string obtained from Attribute.getValue(). If you need the
 280      * structure information, see getAttributeNode().
 281      */
 282     public String getAttribute(String name) {
 283 
 284         if (needsSyncData()) {
 285             synchronizeData();
 286         }
 287         if (attributes == null) {
 288             return &quot;&quot;;
 289         }
<span class="line-modified"> 290         Attr attr = (Attr) (attributes.getNamedItem(name));</span>
 291         return (attr == null) ? &quot;&quot; : attr.getValue();
 292 
 293     } // getAttribute(String):String
 294 
 295     /**
 296      * Look up a single Attribute by name. Returns the Attribute Node, so its
 297      * complete child tree is available. This could be important in XML, where
 298      * the string rendering may not be sufficient information.
 299      * &lt;p&gt;
 300      * If no matching attribute is available, returns null.
 301      */
 302     public Attr getAttributeNode(String name) {
 303 
 304         if (needsSyncData()) {
 305             synchronizeData();
 306         }
 307         if (attributes == null) {
 308             return null;
 309         }
<span class="line-modified"> 310         return (Attr) attributes.getNamedItem(name);</span>
 311 
 312     } // getAttributeNode(String):Attr
 313 
 314     /**
 315      * Returns a NodeList of all descendent nodes (children, grandchildren, and
 316      * so on) which are Elements and which have the specified tag name.
 317      * &lt;p&gt;
 318      * Note: NodeList is a &quot;live&quot; view of the DOM. Its contents will change as
 319      * the DOM changes, and alterations made to the NodeList will be reflected
 320      * in the DOM.
 321      *
 322      * @param tagname The type of element to gather. To obtain a list of all
 323      * elements no matter what their names, use the wild-card tag name &quot;*&quot;.
 324      *
 325      * @see DeepNodeListImpl
 326      */
 327     public NodeList getElementsByTagName(String tagname) {
 328         return new DeepNodeListImpl(this, tagname);
 329     }
 330 
</pre>
<hr />
<pre>
 436         attributes.safeRemoveNamedItem(name);
 437 
 438     } // removeAttribute(String)
 439 
 440     /**
 441      * Remove the specified attribute/value pair. If the removed Attribute has a
 442      * default value, it is immediately replaced.
 443      * &lt;p&gt;
 444      * NOTE: Specifically removes THIS NODE -- not the node with this name, nor
 445      * the node with these contents. If the specific Attribute object passed in
 446      * is not stored in this Element, we throw a DOMException. If you really
 447      * want to remove an attribute by name, use removeAttribute().
 448      *
 449      * @return the Attribute object that was removed.
 450      * @throws DOMException(NOT_FOUND_ERR) if oldattr is not an attribute of
 451      * this Element.
 452      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is
 453      * readonly.
 454      */
 455     public Attr removeAttributeNode(Attr oldAttr)
<span class="line-modified"> 456             throws DOMException {</span>
 457 
 458         if (ownerDocument.errorChecking &amp;&amp; isReadOnly()) {
 459             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
 460             throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);
 461         }
 462 
 463         if (needsSyncData()) {
 464             synchronizeData();
 465         }
 466 
 467         if (attributes == null) {
 468             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);
 469             throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 470         }
 471         return (Attr) attributes.removeItem(oldAttr, true);
 472 
 473     } // removeAttributeNode(Attr):Attr
 474 
 475     /**
 476      * Add a new name/value pair, or replace the value of the existing attribute
 477      * having that name.
 478      *
 479      * Note: this method supports only the simplest kind of Attribute, one whose
 480      * value is a string contained in a single Text node. If you want to assert
 481      * a more complex value (which XML permits, though HTML doesn&#39;t), see
 482      * setAttributeNode().
 483      *
 484      * The attribute is created with specified=true, meaning it&#39;s an explicit
 485      * value rather than inherited from the DTD as a default. Again,
 486      * setAttributeNode can be used to achieve other results.
 487      *
 488      * @throws DOMException(INVALID_NAME_ERR) if the name is not acceptable.
 489      * (Attribute factory will do that test for us.)
 490      *
 491      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is
 492      * readonly.
 493      */
<span class="line-modified"> 494     public void setAttribute(String name, String value) {</span>
<span class="line-modified"> 495 </span>
<span class="line-modified"> 496         if (ownerDocument.errorChecking &amp;&amp; isReadOnly()) {</span>
<span class="line-modified"> 497             String msg</span>
<span class="line-modified"> 498                     = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified"> 499                             DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-modified"> 500                             &quot;NO_MODIFICATION_ALLOWED_ERR&quot;,</span>
<span class="line-modified"> 501                             null);</span>
<span class="line-modified"> 502             throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);</span>
<span class="line-removed"> 503         }</span>
 504 
<span class="line-modified"> 505         if (needsSyncData()) {</span>
<span class="line-modified"> 506             synchronizeData();</span>
<span class="line-modified"> 507         }</span>
 508 
<span class="line-modified"> 509         Attr newAttr = getAttributeNode(name);</span>
<span class="line-modified"> 510         if (newAttr == null) {</span>
<span class="line-modified"> 511             newAttr = getOwnerDocument().createAttribute(name);</span>
 512 
<span class="line-modified"> 513             if (attributes == null) {</span>
<span class="line-modified"> 514                 attributes = new AttributeMap(this, null);</span>
<span class="line-modified"> 515             }</span>
 516 
<span class="line-modified"> 517             newAttr.setNodeValue(value);</span>
<span class="line-modified"> 518             attributes.setNamedItem(newAttr);</span>
<span class="line-modified"> 519         } else {</span>
<span class="line-modified"> 520             newAttr.setNodeValue(value);</span>
<span class="line-modified"> 521         }</span>
 522 
<span class="line-modified"> 523     } // setAttribute(String,String)</span>
 524 
 525     /**
 526      * Add a new attribute/value pair, or replace the value of the existing
 527      * attribute with that name.
 528      * &lt;P&gt;
 529      * This method allows you to add an Attribute that has already been
 530      * constructed, and hence avoids the limitations of the simple
 531      * setAttribute() call. It can handle attribute values that have arbitrarily
 532      * complex tree structure -- in particular, those which had entity
 533      * references mixed into their text.
 534      *
 535      * @throws DOMException(INUSE_ATTRIBUTE_ERR) if the Attribute object has
 536      * already been assigned to another Element.
 537      */
 538     public Attr setAttributeNode(Attr newAttr)
 539             throws DOMException {
 540 
 541         if (needsSyncData()) {
 542             synchronizeData();
 543         }
 544 
 545         if (ownerDocument.errorChecking) {
 546             if (isReadOnly()) {
 547                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
 548                 throw new DOMException(
<span class="line-modified"> 549                         DOMException.NO_MODIFICATION_ALLOWED_ERR,</span>
<span class="line-modified"> 550                         msg);</span>
 551             }
 552 
 553             if (newAttr.getOwnerDocument() != ownerDocument) {
 554                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;WRONG_DOCUMENT_ERR&quot;, null);
<span class="line-modified"> 555                 throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);</span>
 556             }
 557         }
 558 
 559         if (attributes == null) {
 560             attributes = new AttributeMap(this, null);
 561         }
 562         // This will throw INUSE if necessary
 563         return (Attr) attributes.setNamedItem(newAttr);
 564 
 565     } // setAttributeNode(Attr):Attr
 566 
 567     //
 568     // DOM2: Namespace methods
 569     //
 570     /**
 571      * Introduced in DOM Level 2.
 572      * &lt;p&gt;
 573      *
 574      * Retrieves an attribute value by local name and namespace URI.
 575      *
 576      * @param namespaceURI The namespace URI of the attribute to retrieve.
 577      * @param localName The local name of the attribute to retrieve.
 578      * @return String The Attr value as a string, or empty string if that
 579      * attribute does not have a specified or default value.
 580      * @since WD-DOM-Level-2-19990923
 581      */
 582     public String getAttributeNS(String namespaceURI, String localName) {
 583 
 584         if (needsSyncData()) {
 585             synchronizeData();
 586         }
 587 
 588         if (attributes == null) {
 589             return &quot;&quot;;
 590         }
 591 
<span class="line-modified"> 592         Attr attr = (Attr) (attributes.getNamedItemNS(namespaceURI, localName));</span>
 593         return (attr == null) ? &quot;&quot; : attr.getValue();
 594 
 595     } // getAttributeNS(String,String):String
 596 
 597     /**
 598      * Introduced in DOM Level 2.
 599      * &lt;p&gt;
 600      *
 601      * Adds a new attribute. If the given namespaceURI is null or an empty
 602      * string and the qualifiedName has a prefix that is &quot;xml&quot;, the new
 603      * attribute is bound to the predefined namespace
 604      * &quot;http://www.w3.org/XML/1998/namespace&quot; [Namespaces]. If an attribute with
 605      * the same local name and namespace URI is already present on the element,
 606      * its prefix is changed to be the prefix part of the qualifiedName, and its
 607      * value is changed to be the value parameter. This value is a simple
 608      * string, it is not parsed as it is being set. So any markup (such as
 609      * syntax to be recognized as an entity reference) is treated as literal
 610      * text, and needs to be appropriately escaped by the implementation when it
 611      * is written out. In order to assign an attribute value that contains
 612      * entity references, the user must create an Attr node plus any Text and
</pre>
<hr />
<pre>
 616      *
 617      * @param namespaceURI The namespace URI of the attribute to create or
 618      * alter.
 619      * @param qualifiedName The qualified name of the attribute to create or
 620      * alter.
 621      * @param value The value to set in string form.
 622      * @throws INVALID_CHARACTER_ERR: Raised if the specified name contains an
 623      * invalid character.
 624      *
 625      * @throws NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
 626      *
 627      * @throws NAMESPACE_ERR: Raised if the qualifiedName has a prefix that is
 628      * &quot;xml&quot; and the namespaceURI is neither null nor an empty string nor
 629      * &quot;http://www.w3.org/XML/1998/namespace&quot;, or if the qualifiedName has a
 630      * prefix that is &quot;xmlns&quot; but the namespaceURI is neither null nor an empty
 631      * string, or if if the qualifiedName has a prefix different from &quot;xml&quot; and
 632      * &quot;xmlns&quot; and the namespaceURI is null or an empty string.
 633      * @since WD-DOM-Level-2-19990923
 634      */
 635     public void setAttributeNS(String namespaceURI, String qualifiedName,
<span class="line-modified"> 636             String value) {</span>
<span class="line-modified"> 637         if (ownerDocument.errorChecking &amp;&amp; isReadOnly()) {</span>
<span class="line-modified"> 638             String msg</span>
<span class="line-modified"> 639                     = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified"> 640                             DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-modified"> 641                             &quot;NO_MODIFICATION_ALLOWED_ERR&quot;,</span>
<span class="line-modified"> 642                             null);</span>
<span class="line-modified"> 643             throw new DOMException(</span>
<span class="line-modified"> 644                     DOMException.NO_MODIFICATION_ALLOWED_ERR,</span>
<span class="line-modified"> 645                     msg);</span>
<span class="line-modified"> 646         }</span>
<span class="line-modified"> 647         if (needsSyncData()) {</span>
<span class="line-modified"> 648             synchronizeData();</span>
<span class="line-modified"> 649         }</span>
<span class="line-modified"> 650         int index = qualifiedName.indexOf(&#39;:&#39;);</span>
<span class="line-modified"> 651         String prefix, localName;</span>
<span class="line-modified"> 652         if (index &lt; 0) {</span>
<span class="line-modified"> 653             prefix = null;</span>
<span class="line-modified"> 654             localName = qualifiedName;</span>
<span class="line-modified"> 655         } else {</span>
<span class="line-modified"> 656             prefix = qualifiedName.substring(0, index);</span>
<span class="line-modified"> 657             localName = qualifiedName.substring(index + 1);</span>
<span class="line-removed"> 658         }</span>
<span class="line-removed"> 659         Attr newAttr = getAttributeNodeNS(namespaceURI, localName);</span>
<span class="line-removed"> 660         if (newAttr == null) {</span>
 661             // REVISIT: this is not efficient, we are creating twice the same
 662             //          strings for prefix and localName.
<span class="line-modified"> 663             newAttr = getOwnerDocument().createAttributeNS(</span>
<span class="line-modified"> 664                     namespaceURI,</span>
<span class="line-modified"> 665                     qualifiedName);</span>
<span class="line-modified"> 666             if (attributes == null) {</span>
<span class="line-modified"> 667                 attributes = new AttributeMap(this, null);</span>
<span class="line-modified"> 668             }</span>
<span class="line-modified"> 669             newAttr.setNodeValue(value);</span>
<span class="line-modified"> 670             attributes.setNamedItemNS(newAttr);</span>
 671                 }
 672                 else {
 673             if (newAttr instanceof AttrNSImpl){
 674                 String origNodeName = ((AttrNSImpl) newAttr).name;
 675                 String newName = (prefix!=null) ? (prefix+&quot;:&quot;+localName) : localName;
 676 
 677                 ((AttrNSImpl) newAttr).name = newName;
 678 
 679                 if (!newName.equals(origNodeName)) {
 680                     // Note: we can&#39;t just change the name of the attribute. Names have to be in sorted
 681                     // order in the attributes vector because a binary search is used to locate them.
 682                     // If the new name has a different prefix, the list may become unsorted.
 683                     // Maybe it would be better to resort the list, but the simplest
 684                     // fix seems to be to remove the old attribute and re-insert it.
 685                     newAttr = (Attr) attributes.removeItem(newAttr, false);
 686                     attributes.addItem(newAttr);
 687                 }
 688             }
 689             else {
 690                 // This case may happen if user calls:
 691                 //      elem.setAttribute(&quot;name&quot;, &quot;value&quot;);
 692                 //      elem.setAttributeNS(null, &quot;name&quot;, &quot;value&quot;);
 693                 // This case is not defined by the DOM spec, we choose
 694                 // to create a new attribute in this case and remove an old one from the tree
 695                 // note this might cause events to be propagated or user data to be lost
<span class="line-modified"> 696                 newAttr = new AttrNSImpl((CoreDocumentImpl)getOwnerDocument(), namespaceURI, qualifiedName, localName);</span>
 697                 attributes.setNamedItemNS(newAttr);
 698             }
 699 
<span class="line-modified"> 700             newAttr.setNodeValue(value);</span>
<span class="line-modified"> 701         }</span>
 702 
 703     } // setAttributeNS(String,String,String)
 704 
 705     /**
 706      * Introduced in DOM Level 2.
 707      * &lt;p&gt;
 708      *
 709      * Removes an attribute by local name and namespace URI. If the removed
 710      * attribute has a default value it is immediately replaced. The replacing
 711      * attribute has the same namespace URI and local name, as well as the
 712      * original prefix.&lt;p&gt;
 713      *
 714      * @param namespaceURI The namespace URI of the attribute to remove.
 715      *
 716      * @param localName The local name of the attribute to remove.
 717      * @throws NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
 718      * @since WD-DOM-Level-2-19990923
 719      */
 720     public void removeAttributeNS(String namespaceURI, String localName) {
 721 
</pre>
<hr />
<pre>
 736 
 737     } // removeAttributeNS(String,String)
 738 
 739     /**
 740      * Retrieves an Attr node by local name and namespace URI.
 741      *
 742      * @param namespaceURI The namespace URI of the attribute to retrieve.
 743      * @param localName The local name of the attribute to retrieve.
 744      * @return Attr The Attr node with the specified attribute local name and
 745      * namespace URI or null if there is no such attribute.
 746      * @since WD-DOM-Level-2-19990923
 747      */
 748     public Attr getAttributeNodeNS(String namespaceURI, String localName) {
 749 
 750         if (needsSyncData()) {
 751             synchronizeData();
 752         }
 753         if (attributes == null) {
 754             return null;
 755         }
<span class="line-modified"> 756         return (Attr) attributes.getNamedItemNS(namespaceURI, localName);</span>
 757 
 758     } // getAttributeNodeNS(String,String):Attr
 759 
 760     /**
 761      * Introduced in DOM Level 2.
 762      * &lt;p&gt;
 763      *
 764      * Adds a new attribute. If an attribute with that local name and namespace
 765      * URI is already present in the element, it is replaced by the new one.
 766      *
 767      * @param newAttr The Attr node to add to the attribute list. When the Node
 768      * has no namespaceURI, this method behaves like setAttributeNode.
 769      * @return Attr If the newAttr attribute replaces an existing attribute with
 770      * the same local name and namespace URI, the * previously existing Attr
 771      * node is returned, otherwise null is returned.
 772      * @throws WRONG_DOCUMENT_ERR: Raised if newAttr was created from a
 773      * different document than the one that created the element.
 774      *
 775      * @throws NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
 776      *
 777      * @throws INUSE_ATTRIBUTE_ERR: Raised if newAttr is already an attribute of
 778      * another Element object. The DOM user must explicitly clone Attr nodes to
 779      * re-use them in other elements.
 780      * @since WD-DOM-Level-2-19990923
 781      */
 782     public Attr setAttributeNodeNS(Attr newAttr)
 783             throws DOMException {
 784 
 785         if (needsSyncData()) {
 786             synchronizeData();
 787         }
 788         if (ownerDocument.errorChecking) {
 789             if (isReadOnly()) {
 790                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
<span class="line-modified"> 791                 throw new DOMException(</span>
<span class="line-modified"> 792                         DOMException.NO_MODIFICATION_ALLOWED_ERR,</span>
<span class="line-modified"> 793                         msg);</span>
 794             }
 795             if (newAttr.getOwnerDocument() != ownerDocument) {
 796                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;WRONG_DOCUMENT_ERR&quot;, null);
 797                 throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);
 798             }
 799         }
 800 
 801         if (attributes == null) {
 802             attributes = new AttributeMap(this, null);
 803         }
 804         // This will throw INUSE if necessary
 805         return (Attr) attributes.setNamedItemNS(newAttr);
 806 
 807     } // setAttributeNodeNS(Attr):Attr
 808 
 809     /**
<span class="line-modified"> 810      * NON-DOM: sets attribute node for this element</span>
<span class="line-modified"> 811      */</span>
 812     protected int setXercesAttributeNode(Attr attr) {
 813 
 814         if (needsSyncData()) {
 815             synchronizeData();
 816         }
 817 
 818         if (attributes == null) {
 819             attributes = new AttributeMap(this, null);
 820         }
 821         return attributes.addItem(attr);
 822 
 823     }
 824 
 825     /**
<span class="line-modified"> 826      * NON-DOM: get inded of an attribute</span>
<span class="line-modified"> 827      */</span>
 828     protected int getXercesAttribute(String namespaceURI, String localName) {
 829 
 830         if (needsSyncData()) {
 831             synchronizeData();
 832         }
 833         if (attributes == null) {
 834             return -1;
 835         }
 836         return attributes.getNamedItemIndex(namespaceURI, localName);
 837 
 838     }
 839 
 840     /**
 841      * Introduced in DOM Level 2.
 842      */
 843     public boolean hasAttributes() {
 844         if (needsSyncData()) {
 845             synchronizeData();
 846         }
 847         return (attributes != null &amp;&amp; attributes.getLength() != 0);
</pre>
<hr />
<pre>
 862     }
 863 
 864     /**
 865      * Introduced in DOM Level 2.
 866      * &lt;p&gt;
 867      *
 868      * Returns a NodeList of all the Elements with a given local name and
 869      * namespace URI in the order in which they would be encountered in a
 870      * preorder traversal of the Document tree, starting from this node.
 871      *
 872      * @param namespaceURI The namespace URI of the elements to match on. The
 873      * special value &quot;*&quot; matches all namespaces. When it is null or an empty
 874      * string, this method behaves like getElementsByTagName.
 875      * @param localName The local name of the elements to match on. The special
 876      * value &quot;*&quot; matches all local names.
 877      * @return NodeList A new NodeList object containing all the matched
 878      * Elements.
 879      * @since WD-DOM-Level-2-19990923
 880      */
 881     public NodeList getElementsByTagNameNS(String namespaceURI,
<span class="line-modified"> 882             String localName) {</span>
 883         return new DeepNodeListImpl(this, namespaceURI, localName);
 884     }
 885 
 886     /**
 887      * DOM Level 3 WD- Experimental. Override inherited behavior from NodeImpl
 888      * and ParentNode to check on attributes
 889      */
 890     public boolean isEqualNode(Node arg) {
 891         if (!super.isEqualNode(arg)) {
 892             return false;
 893         }
 894         boolean hasAttrs = hasAttributes();
 895         if (hasAttrs != ((Element) arg).hasAttributes()) {
 896             return false;
 897         }
 898         if (hasAttrs) {
 899             NamedNodeMap map1 = getAttributes();
 900             NamedNodeMap map2 = ((Element) arg).getAttributes();
 901             int len = map1.getLength();
 902             if (len != map2.getLength()) {
 903                 return false;
 904             }
 905             for (int i = 0; i &lt; len; i++) {
 906                 Node n1 = map1.item(i);
 907                 if (n1.getLocalName() == null) { // DOM Level 1 Node
 908                     Node n2 = map2.getNamedItem(n1.getNodeName());
 909                     if (n2 == null || !((NodeImpl) n1).isEqualNode(n2)) {
 910                         return false;
 911                     }
 912                 } else {
 913                     Node n2 = map2.getNamedItemNS(n1.getNamespaceURI(),
<span class="line-modified"> 914                             n1.getLocalName());</span>
 915                     if (n2 == null || !((NodeImpl) n1).isEqualNode(n2)) {
 916                         return false;
 917                     }
 918                 }
 919             }
 920         }
 921         return true;
 922     }
 923 
 924     /**
 925      * DOM Level 3: register the given attribute node as an ID attribute
 926      */
 927     public void setIdAttributeNode(Attr at, boolean makeId) {
 928         if (needsSyncData()) {
 929             synchronizeData();
 930         }
 931         if (ownerDocument.errorChecking) {
 932             if (isReadOnly()) {
<span class="line-modified"> 933                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);</span>

 934                 throw new DOMException(
<span class="line-modified"> 935                         DOMException.NO_MODIFICATION_ALLOWED_ERR,</span>
<span class="line-removed"> 936                         msg);</span>
 937             }
 938 
 939             if (at.getOwnerElement() != this) {
<span class="line-modified"> 940                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);</span>

 941                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 942             }
 943         }
 944         ((AttrImpl) at).isIdAttribute(makeId);
 945         if (!makeId) {
 946             ownerDocument.removeIdentifier(at.getValue());
 947         } else {
 948             ownerDocument.putIdentifier(at.getValue(), this);
 949         }
 950     }
 951 
 952     /**
 953      * DOM Level 3: register the given attribute node as an ID attribute
 954      */
 955     public void setIdAttribute(String name, boolean makeId) {
 956         if (needsSyncData()) {
 957             synchronizeData();
 958         }
 959         Attr at = getAttributeNode(name);
 960 
 961         if (at == null) {
<span class="line-modified"> 962             String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified"> 963                     DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-removed"> 964                     &quot;NOT_FOUND_ERR&quot;, null);</span>
 965             throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
<span class="line-modified"> 966         }</span>
 967 
 968         if (ownerDocument.errorChecking) {
 969             if (isReadOnly()) {
<span class="line-modified"> 970                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);</span>
<span class="line-modified"> 971                 throw new DOMException(</span>
<span class="line-modified"> 972                         DOMException.NO_MODIFICATION_ALLOWED_ERR,</span>
<span class="line-removed"> 973                         msg);</span>
 974             }
 975 
 976             if (at.getOwnerElement() != this) {
<span class="line-modified"> 977                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);</span>

 978                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 979             }
 980         }
 981 
 982         ((AttrImpl) at).isIdAttribute(makeId);
 983         if (!makeId) {
 984             ownerDocument.removeIdentifier(at.getValue());
 985         } else {
 986             ownerDocument.putIdentifier(at.getValue(), this);
 987         }
 988     }
 989 
 990     /**
 991      * DOM Level 3: register the given attribute node as an ID attribute
 992      */
 993     public void setIdAttributeNS(String namespaceURI, String localName,
<span class="line-modified"> 994             boolean makeId) {</span>
 995         if (needsSyncData()) {
 996             synchronizeData();
 997         }
 998         //if namespace uri is empty string, set it to &#39;null&#39;
 999         if (namespaceURI != null) {
1000             namespaceURI = (namespaceURI.length() == 0) ? null : namespaceURI;
1001         }
1002         Attr at = getAttributeNodeNS(namespaceURI, localName);
1003 
1004         if (at == null) {
<span class="line-modified">1005             String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified">1006                     DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-removed">1007                     &quot;NOT_FOUND_ERR&quot;, null);</span>
1008             throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
<span class="line-modified">1009         }</span>
1010 
<span class="line-modified">1011         if (ownerDocument.errorChecking) {</span>
1012             if (isReadOnly()) {
1013                 String msg = DOMMessageFormatter.formatMessage(
1014                         DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
1015                 throw new DOMException(
<span class="line-modified">1016                         DOMException.NO_MODIFICATION_ALLOWED_ERR,</span>
<span class="line-modified">1017                         msg);</span>
1018             }
1019 
1020             if (at.getOwnerElement() != this) {
1021                 String msg = DOMMessageFormatter.formatMessage(
1022                         DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);
1023                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
1024             }
1025         }
1026         ((AttrImpl) at).isIdAttribute(makeId);
1027         if (!makeId) {
1028             ownerDocument.removeIdentifier(at.getValue());
1029         } else {
1030             ownerDocument.putIdentifier(at.getValue(), this);
1031         }
<span class="line-modified">1032     }</span>
1033 
1034     /**
1035      * @see org.w3c.dom.TypeInfo#getTypeName()
1036      */
<span class="line-modified">1037     public String getTypeName() {</span>
1038         return null;
<span class="line-modified">1039     }</span>
1040 
1041     /**
1042      * @see org.w3c.dom.TypeInfo#getTypeNamespace()
1043      */
1044     public String getTypeNamespace() {
1045         return null;
1046     }
1047 
1048     /**
1049      * Introduced in DOM Level 3.
1050      * &lt;p&gt;
1051      * Checks if a type is derived from another by restriction. See:
1052      * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom
1053      *
1054      * @param typeNamespaceArg The namspace of the ancestor type declaration
1055      * @param typeNameArg The name of the ancestor type declaration
1056      * @param derivationMethod The derivation method
1057      *
1058      * @return boolean True if the type is derived by restriction for the
1059      * reference type
1060      */
1061     public boolean isDerivedFrom(String typeNamespaceArg,
<span class="line-modified">1062             String typeNameArg,</span>
<span class="line-modified">1063             int derivationMethod) {</span>
1064 
1065         return false;
1066     }
1067 
<span class="line-modified">1068     /**</span>
<span class="line-modified">1069      * Method getSchemaTypeInfo.</span>
<span class="line-modified">1070      *</span>
<span class="line-modified">1071      * @return TypeInfo</span>
<span class="line-removed">1072      */</span>
1073     public TypeInfo getSchemaTypeInfo() {
1074         if (needsSyncData()) {
1075             synchronizeData();
1076         }
1077         return this;
1078     }
1079 
1080     //
1081     // Public methods
1082     //
1083     /**
1084      * NON-DOM: Subclassed to flip the attributes&#39; readonly switch as well.
1085      *
1086      * @see NodeImpl#setReadOnly
1087      */
1088     public void setReadOnly(boolean readOnly, boolean deep) {
1089         super.setReadOnly(readOnly, deep);
1090         if (attributes != null) {
1091             attributes.setReadOnly(readOnly, true);
1092         }
</pre>
<hr />
<pre>
1142     /**
1143      * Reconcile default attributes.
1144      */
1145     protected void reconcileDefaultAttributes() {
1146         if (attributes != null) {
1147             NamedNodeMapImpl defaults = getDefaultAttributes();
1148             attributes.reconcileDefaults(defaults);
1149         }
1150     }
1151 
1152     /**
1153      * Get the default attributes.
1154      */
1155     protected NamedNodeMapImpl getDefaultAttributes() {
1156 
1157         DocumentTypeImpl doctype
1158                 = (DocumentTypeImpl) ownerDocument.getDoctype();
1159         if (doctype == null) {
1160             return null;
1161         }
<span class="line-modified">1162         ElementDefinitionImpl eldef</span>
<span class="line-removed">1163                 = (ElementDefinitionImpl) doctype.getElements()</span>
1164                 .getNamedItem(getNodeName());
1165         if (eldef == null) {
1166             return null;
1167         }
1168         return (NamedNodeMapImpl) eldef.getAttributes();
1169 
1170     } // getDefaultAttributes()
1171 
1172     //
1173     // ElementTraversal methods
1174     //
1175     /**
1176      * @see &lt;a
1177      * href=&quot;http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-childElementCount&quot;&gt;
1178      * Element Traversal Specification&lt;/a&gt;
1179      */
1180     @Override
1181     public final int getChildElementCount() {
1182         int count = 0;
1183         Element child = getFirstElementChild();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>

   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 package com.sun.org.apache.xerces.internal.dom;
  21 
  22 import org.w3c.dom.Attr;
</pre>
<hr />
<pre>
  37  * &lt;P&gt;
  38  * Elements may have Attributes associated with them; the API for this is
  39  * defined in Node, but the function is implemented here. In general, XML
  40  * applications should retrive Attributes as Nodes, since they may contain
  41  * entity references and hence be a fairly complex sub-tree. HTML users will be
  42  * dealing with simple string values, and convenience methods are provided to
  43  * work in terms of Strings.
  44  * &lt;P&gt;
  45  * ElementImpl does not support Namespaces. ElementNSImpl, which inherits from
  46  * it, does.
  47  *
  48  * @see ElementNSImpl
  49  *
  50  * @xerces.internal
  51  *
  52  * @author Arnaud Le Hors, IBM
  53  * @author Joe Kesselman, IBM
  54  * @author Andy Clark, IBM
  55  * @author Ralf Pfeiffer, IBM
  56  * @since PR-DOM-Level-1-19980818.
<span class="line-added">  57  * @LastModified: Apr 2019</span>
  58  */
  59 public class ElementImpl
<span class="line-modified">  60     extends ParentNode</span>
<span class="line-modified">  61     implements Element, ElementTraversal, TypeInfo {</span>
  62 
  63     //
  64     // Constants
  65     //
<span class="line-modified">  66 </span>
<span class="line-modified">  67     /** Serialization version. */</span>

  68     static final long serialVersionUID = 3717253516652722278L;
  69     //
  70     // Data
  71     //
  72 
<span class="line-modified">  73     /** Element name. */</span>


  74     protected String name;
  75 
<span class="line-modified">  76     /** Attributes. */</span>


  77     protected AttributeMap attributes;
  78 
  79     //
  80     // Constructors
  81     //
<span class="line-modified">  82 </span>
<span class="line-modified">  83     /** Factory constructor. */</span>

  84     public ElementImpl(CoreDocumentImpl ownerDoc, String name) {
  85         super(ownerDoc);
  86         this.name = name;
  87         needsSyncData(true);    // synchronizeData will initialize attributes
  88     }
  89 
  90     // for ElementNSImpl
<span class="line-modified">  91     protected ElementImpl() {}</span>

  92 
  93     // Support for DOM Level 3 renameNode method.
  94     // Note: This only deals with part of the pb. CoreDocumentImpl
  95     // does all the work.
  96     void rename(String name) {
  97         if (needsSyncData()) {
  98             synchronizeData();
  99         }
 100         if (ownerDocument.errorChecking) {
 101             int colon1 = name.indexOf(&#39;:&#39;);
 102             if (colon1 != -1) {
 103                 String msg
 104                         = DOMMessageFormatter.formatMessage(
<span class="line-modified"> 105                             DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-modified"> 106                             &quot;NAMESPACE_ERR&quot;,</span>
<span class="line-modified"> 107                             null);</span>
 108                 throw new DOMException(DOMException.NAMESPACE_ERR, msg);
 109             }
 110             if (!CoreDocumentImpl.isXMLName(name, ownerDocument.isXML11Version())) {
 111                 String msg = DOMMessageFormatter.formatMessage(
 112                         DOMMessageFormatter.DOM_DOMAIN,
 113                         &quot;INVALID_CHARACTER_ERR&quot;, null);
 114                 throw new DOMException(DOMException.INVALID_CHARACTER_ERR,
 115                         msg);
 116             }
 117         }
 118         this.name = name;
 119         reconcileDefaultAttributes();
 120     }
 121 
 122     //
 123     // Node methods
 124     //
 125     /**
 126      * A short integer indicating what type of node this is. The named constants
 127      * for this value are defined in the org.w3c.dom.Node interface.
</pre>
<hr />
<pre>
 263     //
 264     // Element methods
 265     //
 266     /**
 267      * Look up a single Attribute by name. Returns the Attribute&#39;s string value,
 268      * or an empty string (NOT null!) to indicate that the name did not map to a
 269      * currently defined attribute.
 270      * &lt;p&gt;
 271      * Note: Attributes may contain complex node trees. This method returns the
 272      * &quot;flattened&quot; string obtained from Attribute.getValue(). If you need the
 273      * structure information, see getAttributeNode().
 274      */
 275     public String getAttribute(String name) {
 276 
 277         if (needsSyncData()) {
 278             synchronizeData();
 279         }
 280         if (attributes == null) {
 281             return &quot;&quot;;
 282         }
<span class="line-modified"> 283         Attr attr = (Attr)(attributes.getNamedItem(name));</span>
 284         return (attr == null) ? &quot;&quot; : attr.getValue();
 285 
 286     } // getAttribute(String):String
 287 
 288     /**
 289      * Look up a single Attribute by name. Returns the Attribute Node, so its
 290      * complete child tree is available. This could be important in XML, where
 291      * the string rendering may not be sufficient information.
 292      * &lt;p&gt;
 293      * If no matching attribute is available, returns null.
 294      */
 295     public Attr getAttributeNode(String name) {
 296 
 297         if (needsSyncData()) {
 298             synchronizeData();
 299         }
 300         if (attributes == null) {
 301             return null;
 302         }
<span class="line-modified"> 303         return (Attr)attributes.getNamedItem(name);</span>
 304 
 305     } // getAttributeNode(String):Attr
 306 
 307     /**
 308      * Returns a NodeList of all descendent nodes (children, grandchildren, and
 309      * so on) which are Elements and which have the specified tag name.
 310      * &lt;p&gt;
 311      * Note: NodeList is a &quot;live&quot; view of the DOM. Its contents will change as
 312      * the DOM changes, and alterations made to the NodeList will be reflected
 313      * in the DOM.
 314      *
 315      * @param tagname The type of element to gather. To obtain a list of all
 316      * elements no matter what their names, use the wild-card tag name &quot;*&quot;.
 317      *
 318      * @see DeepNodeListImpl
 319      */
 320     public NodeList getElementsByTagName(String tagname) {
 321         return new DeepNodeListImpl(this, tagname);
 322     }
 323 
</pre>
<hr />
<pre>
 429         attributes.safeRemoveNamedItem(name);
 430 
 431     } // removeAttribute(String)
 432 
 433     /**
 434      * Remove the specified attribute/value pair. If the removed Attribute has a
 435      * default value, it is immediately replaced.
 436      * &lt;p&gt;
 437      * NOTE: Specifically removes THIS NODE -- not the node with this name, nor
 438      * the node with these contents. If the specific Attribute object passed in
 439      * is not stored in this Element, we throw a DOMException. If you really
 440      * want to remove an attribute by name, use removeAttribute().
 441      *
 442      * @return the Attribute object that was removed.
 443      * @throws DOMException(NOT_FOUND_ERR) if oldattr is not an attribute of
 444      * this Element.
 445      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is
 446      * readonly.
 447      */
 448     public Attr removeAttributeNode(Attr oldAttr)
<span class="line-modified"> 449         throws DOMException {</span>
 450 
 451         if (ownerDocument.errorChecking &amp;&amp; isReadOnly()) {
 452             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
 453             throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);
 454         }
 455 
 456         if (needsSyncData()) {
 457             synchronizeData();
 458         }
 459 
 460         if (attributes == null) {
 461             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);
 462             throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 463         }
 464         return (Attr) attributes.removeItem(oldAttr, true);
 465 
 466     } // removeAttributeNode(Attr):Attr
 467 
 468     /**
 469      * Add a new name/value pair, or replace the value of the existing attribute
 470      * having that name.
 471      *
 472      * Note: this method supports only the simplest kind of Attribute, one whose
 473      * value is a string contained in a single Text node. If you want to assert
 474      * a more complex value (which XML permits, though HTML doesn&#39;t), see
 475      * setAttributeNode().
 476      *
 477      * The attribute is created with specified=true, meaning it&#39;s an explicit
 478      * value rather than inherited from the DTD as a default. Again,
 479      * setAttributeNode can be used to achieve other results.
 480      *
 481      * @throws DOMException(INVALID_NAME_ERR) if the name is not acceptable.
 482      * (Attribute factory will do that test for us.)
 483      *
 484      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is
 485      * readonly.
 486      */
<span class="line-modified"> 487         public void setAttribute(String name, String value) {</span>
<span class="line-modified"> 488 </span>
<span class="line-modified"> 489                 if (ownerDocument.errorChecking &amp;&amp; isReadOnly()) {</span>
<span class="line-modified"> 490                     String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified"> 491                                         DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-modified"> 492                                         &quot;NO_MODIFICATION_ALLOWED_ERR&quot;,</span>
<span class="line-modified"> 493                                         null);</span>
<span class="line-modified"> 494                     throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);</span>
<span class="line-modified"> 495                 }</span>

 496 
<span class="line-modified"> 497                 if (needsSyncData()) {</span>
<span class="line-modified"> 498                         synchronizeData();</span>
<span class="line-modified"> 499                 }</span>
 500 
<span class="line-modified"> 501                 Attr newAttr = getAttributeNode(name);</span>
<span class="line-modified"> 502                 if (newAttr == null) {</span>
<span class="line-modified"> 503                         newAttr = getOwnerDocument().createAttribute(name);</span>
 504 
<span class="line-modified"> 505                         if (attributes == null) {</span>
<span class="line-modified"> 506                                 attributes = new AttributeMap(this, null);</span>
<span class="line-modified"> 507                         }</span>
 508 
<span class="line-modified"> 509                         newAttr.setNodeValue(value);</span>
<span class="line-modified"> 510                         attributes.setNamedItem(newAttr);</span>
<span class="line-modified"> 511                 } else {</span>
<span class="line-modified"> 512                         newAttr.setNodeValue(value);</span>
<span class="line-modified"> 513                 }</span>
 514 
<span class="line-modified"> 515         } // setAttribute(String,String)</span>
 516 
 517     /**
 518      * Add a new attribute/value pair, or replace the value of the existing
 519      * attribute with that name.
 520      * &lt;P&gt;
 521      * This method allows you to add an Attribute that has already been
 522      * constructed, and hence avoids the limitations of the simple
 523      * setAttribute() call. It can handle attribute values that have arbitrarily
 524      * complex tree structure -- in particular, those which had entity
 525      * references mixed into their text.
 526      *
 527      * @throws DOMException(INUSE_ATTRIBUTE_ERR) if the Attribute object has
 528      * already been assigned to another Element.
 529      */
 530     public Attr setAttributeNode(Attr newAttr)
 531             throws DOMException {
 532 
 533         if (needsSyncData()) {
 534             synchronizeData();
 535         }
 536 
 537         if (ownerDocument.errorChecking) {
 538             if (isReadOnly()) {
 539                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
 540                 throw new DOMException(
<span class="line-modified"> 541                                      DOMException.NO_MODIFICATION_ALLOWED_ERR,</span>
<span class="line-modified"> 542                                      msg);</span>
 543             }
 544 
 545             if (newAttr.getOwnerDocument() != ownerDocument) {
 546                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;WRONG_DOCUMENT_ERR&quot;, null);
<span class="line-modified"> 547                     throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);</span>
 548             }
 549         }
 550 
 551         if (attributes == null) {
 552             attributes = new AttributeMap(this, null);
 553         }
 554         // This will throw INUSE if necessary
 555         return (Attr) attributes.setNamedItem(newAttr);
 556 
 557     } // setAttributeNode(Attr):Attr
 558 
 559     //
 560     // DOM2: Namespace methods
 561     //
 562     /**
 563      * Introduced in DOM Level 2.
 564      * &lt;p&gt;
 565      *
 566      * Retrieves an attribute value by local name and namespace URI.
 567      *
 568      * @param namespaceURI The namespace URI of the attribute to retrieve.
 569      * @param localName The local name of the attribute to retrieve.
 570      * @return String The Attr value as a string, or empty string if that
 571      * attribute does not have a specified or default value.
 572      * @since WD-DOM-Level-2-19990923
 573      */
 574     public String getAttributeNS(String namespaceURI, String localName) {
 575 
 576         if (needsSyncData()) {
 577             synchronizeData();
 578         }
 579 
 580         if (attributes == null) {
 581             return &quot;&quot;;
 582         }
 583 
<span class="line-modified"> 584         Attr attr = (Attr)(attributes.getNamedItemNS(namespaceURI, localName));</span>
 585         return (attr == null) ? &quot;&quot; : attr.getValue();
 586 
 587     } // getAttributeNS(String,String):String
 588 
 589     /**
 590      * Introduced in DOM Level 2.
 591      * &lt;p&gt;
 592      *
 593      * Adds a new attribute. If the given namespaceURI is null or an empty
 594      * string and the qualifiedName has a prefix that is &quot;xml&quot;, the new
 595      * attribute is bound to the predefined namespace
 596      * &quot;http://www.w3.org/XML/1998/namespace&quot; [Namespaces]. If an attribute with
 597      * the same local name and namespace URI is already present on the element,
 598      * its prefix is changed to be the prefix part of the qualifiedName, and its
 599      * value is changed to be the value parameter. This value is a simple
 600      * string, it is not parsed as it is being set. So any markup (such as
 601      * syntax to be recognized as an entity reference) is treated as literal
 602      * text, and needs to be appropriately escaped by the implementation when it
 603      * is written out. In order to assign an attribute value that contains
 604      * entity references, the user must create an Attr node plus any Text and
</pre>
<hr />
<pre>
 608      *
 609      * @param namespaceURI The namespace URI of the attribute to create or
 610      * alter.
 611      * @param qualifiedName The qualified name of the attribute to create or
 612      * alter.
 613      * @param value The value to set in string form.
 614      * @throws INVALID_CHARACTER_ERR: Raised if the specified name contains an
 615      * invalid character.
 616      *
 617      * @throws NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
 618      *
 619      * @throws NAMESPACE_ERR: Raised if the qualifiedName has a prefix that is
 620      * &quot;xml&quot; and the namespaceURI is neither null nor an empty string nor
 621      * &quot;http://www.w3.org/XML/1998/namespace&quot;, or if the qualifiedName has a
 622      * prefix that is &quot;xmlns&quot; but the namespaceURI is neither null nor an empty
 623      * string, or if if the qualifiedName has a prefix different from &quot;xml&quot; and
 624      * &quot;xmlns&quot; and the namespaceURI is null or an empty string.
 625      * @since WD-DOM-Level-2-19990923
 626      */
 627     public void setAttributeNS(String namespaceURI, String qualifiedName,
<span class="line-modified"> 628                                           String value) {</span>
<span class="line-modified"> 629                 if (ownerDocument.errorChecking &amp;&amp; isReadOnly()) {</span>
<span class="line-modified"> 630                     String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified"> 631                                         DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-modified"> 632                                         &quot;NO_MODIFICATION_ALLOWED_ERR&quot;,</span>
<span class="line-modified"> 633                                         null);</span>
<span class="line-modified"> 634                     throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);</span>
<span class="line-modified"> 635                 }</span>
<span class="line-modified"> 636                 if (needsSyncData()) {</span>
<span class="line-modified"> 637                         synchronizeData();</span>
<span class="line-modified"> 638                 }</span>
<span class="line-modified"> 639                 int index = qualifiedName.indexOf(&#39;:&#39;);</span>
<span class="line-modified"> 640                 String prefix, localName;</span>
<span class="line-modified"> 641                 if (index &lt; 0) {</span>
<span class="line-modified"> 642                         prefix = null;</span>
<span class="line-modified"> 643                         localName = qualifiedName;</span>
<span class="line-modified"> 644                 } else {</span>
<span class="line-modified"> 645                         prefix = qualifiedName.substring(0, index);</span>
<span class="line-modified"> 646                         localName = qualifiedName.substring(index + 1);</span>
<span class="line-modified"> 647                 }</span>
<span class="line-modified"> 648                 Attr newAttr = getAttributeNodeNS(namespaceURI, localName);</span>
<span class="line-modified"> 649                 if (newAttr == null) {</span>



 650             // REVISIT: this is not efficient, we are creating twice the same
 651             //          strings for prefix and localName.
<span class="line-modified"> 652                         newAttr = getOwnerDocument().createAttributeNS(</span>
<span class="line-modified"> 653                                         namespaceURI,</span>
<span class="line-modified"> 654                                         qualifiedName);</span>
<span class="line-modified"> 655                         if (attributes == null) {</span>
<span class="line-modified"> 656                                 attributes = new AttributeMap(this, null);</span>
<span class="line-modified"> 657                         }</span>
<span class="line-modified"> 658                         newAttr.setNodeValue(value);</span>
<span class="line-modified"> 659                         attributes.setNamedItemNS(newAttr);</span>
 660                 }
 661                 else {
 662             if (newAttr instanceof AttrNSImpl){
 663                 String origNodeName = ((AttrNSImpl) newAttr).name;
 664                 String newName = (prefix!=null) ? (prefix+&quot;:&quot;+localName) : localName;
 665 
 666                 ((AttrNSImpl) newAttr).name = newName;
 667 
 668                 if (!newName.equals(origNodeName)) {
 669                     // Note: we can&#39;t just change the name of the attribute. Names have to be in sorted
 670                     // order in the attributes vector because a binary search is used to locate them.
 671                     // If the new name has a different prefix, the list may become unsorted.
 672                     // Maybe it would be better to resort the list, but the simplest
 673                     // fix seems to be to remove the old attribute and re-insert it.
 674                     newAttr = (Attr) attributes.removeItem(newAttr, false);
 675                     attributes.addItem(newAttr);
 676                 }
 677             }
 678             else {
 679                 // This case may happen if user calls:
 680                 //      elem.setAttribute(&quot;name&quot;, &quot;value&quot;);
 681                 //      elem.setAttributeNS(null, &quot;name&quot;, &quot;value&quot;);
 682                 // This case is not defined by the DOM spec, we choose
 683                 // to create a new attribute in this case and remove an old one from the tree
 684                 // note this might cause events to be propagated or user data to be lost
<span class="line-modified"> 685                 newAttr = ((CoreDocumentImpl)getOwnerDocument()).createAttributeNS(namespaceURI, qualifiedName, localName);</span>
 686                 attributes.setNamedItemNS(newAttr);
 687             }
 688 
<span class="line-modified"> 689                         newAttr.setNodeValue(value);</span>
<span class="line-modified"> 690                 }</span>
 691 
 692     } // setAttributeNS(String,String,String)
 693 
 694     /**
 695      * Introduced in DOM Level 2.
 696      * &lt;p&gt;
 697      *
 698      * Removes an attribute by local name and namespace URI. If the removed
 699      * attribute has a default value it is immediately replaced. The replacing
 700      * attribute has the same namespace URI and local name, as well as the
 701      * original prefix.&lt;p&gt;
 702      *
 703      * @param namespaceURI The namespace URI of the attribute to remove.
 704      *
 705      * @param localName The local name of the attribute to remove.
 706      * @throws NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
 707      * @since WD-DOM-Level-2-19990923
 708      */
 709     public void removeAttributeNS(String namespaceURI, String localName) {
 710 
</pre>
<hr />
<pre>
 725 
 726     } // removeAttributeNS(String,String)
 727 
 728     /**
 729      * Retrieves an Attr node by local name and namespace URI.
 730      *
 731      * @param namespaceURI The namespace URI of the attribute to retrieve.
 732      * @param localName The local name of the attribute to retrieve.
 733      * @return Attr The Attr node with the specified attribute local name and
 734      * namespace URI or null if there is no such attribute.
 735      * @since WD-DOM-Level-2-19990923
 736      */
 737     public Attr getAttributeNodeNS(String namespaceURI, String localName) {
 738 
 739         if (needsSyncData()) {
 740             synchronizeData();
 741         }
 742         if (attributes == null) {
 743             return null;
 744         }
<span class="line-modified"> 745         return (Attr)attributes.getNamedItemNS(namespaceURI, localName);</span>
 746 
 747     } // getAttributeNodeNS(String,String):Attr
 748 
 749     /**
 750      * Introduced in DOM Level 2.
 751      * &lt;p&gt;
 752      *
 753      * Adds a new attribute. If an attribute with that local name and namespace
 754      * URI is already present in the element, it is replaced by the new one.
 755      *
 756      * @param newAttr The Attr node to add to the attribute list. When the Node
 757      * has no namespaceURI, this method behaves like setAttributeNode.
 758      * @return Attr If the newAttr attribute replaces an existing attribute with
 759      * the same local name and namespace URI, the * previously existing Attr
 760      * node is returned, otherwise null is returned.
 761      * @throws WRONG_DOCUMENT_ERR: Raised if newAttr was created from a
 762      * different document than the one that created the element.
 763      *
 764      * @throws NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
 765      *
 766      * @throws INUSE_ATTRIBUTE_ERR: Raised if newAttr is already an attribute of
 767      * another Element object. The DOM user must explicitly clone Attr nodes to
 768      * re-use them in other elements.
 769      * @since WD-DOM-Level-2-19990923
 770      */
 771     public Attr setAttributeNodeNS(Attr newAttr)
 772             throws DOMException {
 773 
 774         if (needsSyncData()) {
 775             synchronizeData();
 776         }
 777         if (ownerDocument.errorChecking) {
 778             if (isReadOnly()) {
 779                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
<span class="line-modified"> 780                     throw new DOMException(</span>
<span class="line-modified"> 781                                      DOMException.NO_MODIFICATION_ALLOWED_ERR,</span>
<span class="line-modified"> 782                                      msg);</span>
 783             }
 784             if (newAttr.getOwnerDocument() != ownerDocument) {
 785                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;WRONG_DOCUMENT_ERR&quot;, null);
 786                 throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);
 787             }
 788         }
 789 
 790         if (attributes == null) {
 791             attributes = new AttributeMap(this, null);
 792         }
 793         // This will throw INUSE if necessary
 794         return (Attr) attributes.setNamedItemNS(newAttr);
 795 
 796     } // setAttributeNodeNS(Attr):Attr
 797 
 798     /**
<span class="line-modified"> 799       * NON-DOM: sets attribute node for this element</span>
<span class="line-modified"> 800       */</span>
 801     protected int setXercesAttributeNode(Attr attr) {
 802 
 803         if (needsSyncData()) {
 804             synchronizeData();
 805         }
 806 
 807         if (attributes == null) {
 808             attributes = new AttributeMap(this, null);
 809         }
 810         return attributes.addItem(attr);
 811 
 812     }
 813 
 814     /**
<span class="line-modified"> 815       * NON-DOM: get inded of an attribute</span>
<span class="line-modified"> 816       */</span>
 817     protected int getXercesAttribute(String namespaceURI, String localName) {
 818 
 819         if (needsSyncData()) {
 820             synchronizeData();
 821         }
 822         if (attributes == null) {
 823             return -1;
 824         }
 825         return attributes.getNamedItemIndex(namespaceURI, localName);
 826 
 827     }
 828 
 829     /**
 830      * Introduced in DOM Level 2.
 831      */
 832     public boolean hasAttributes() {
 833         if (needsSyncData()) {
 834             synchronizeData();
 835         }
 836         return (attributes != null &amp;&amp; attributes.getLength() != 0);
</pre>
<hr />
<pre>
 851     }
 852 
 853     /**
 854      * Introduced in DOM Level 2.
 855      * &lt;p&gt;
 856      *
 857      * Returns a NodeList of all the Elements with a given local name and
 858      * namespace URI in the order in which they would be encountered in a
 859      * preorder traversal of the Document tree, starting from this node.
 860      *
 861      * @param namespaceURI The namespace URI of the elements to match on. The
 862      * special value &quot;*&quot; matches all namespaces. When it is null or an empty
 863      * string, this method behaves like getElementsByTagName.
 864      * @param localName The local name of the elements to match on. The special
 865      * value &quot;*&quot; matches all local names.
 866      * @return NodeList A new NodeList object containing all the matched
 867      * Elements.
 868      * @since WD-DOM-Level-2-19990923
 869      */
 870     public NodeList getElementsByTagNameNS(String namespaceURI,
<span class="line-modified"> 871                                            String localName) {</span>
 872         return new DeepNodeListImpl(this, namespaceURI, localName);
 873     }
 874 
 875     /**
 876      * DOM Level 3 WD- Experimental. Override inherited behavior from NodeImpl
 877      * and ParentNode to check on attributes
 878      */
 879     public boolean isEqualNode(Node arg) {
 880         if (!super.isEqualNode(arg)) {
 881             return false;
 882         }
 883         boolean hasAttrs = hasAttributes();
 884         if (hasAttrs != ((Element) arg).hasAttributes()) {
 885             return false;
 886         }
 887         if (hasAttrs) {
 888             NamedNodeMap map1 = getAttributes();
 889             NamedNodeMap map2 = ((Element) arg).getAttributes();
 890             int len = map1.getLength();
 891             if (len != map2.getLength()) {
 892                 return false;
 893             }
 894             for (int i = 0; i &lt; len; i++) {
 895                 Node n1 = map1.item(i);
 896                 if (n1.getLocalName() == null) { // DOM Level 1 Node
 897                     Node n2 = map2.getNamedItem(n1.getNodeName());
 898                     if (n2 == null || !((NodeImpl) n1).isEqualNode(n2)) {
 899                         return false;
 900                     }
 901                 } else {
 902                     Node n2 = map2.getNamedItemNS(n1.getNamespaceURI(),
<span class="line-modified"> 903                                                   n1.getLocalName());</span>
 904                     if (n2 == null || !((NodeImpl) n1).isEqualNode(n2)) {
 905                         return false;
 906                     }
 907                 }
 908             }
 909         }
 910         return true;
 911     }
 912 
 913     /**
 914      * DOM Level 3: register the given attribute node as an ID attribute
 915      */
 916     public void setIdAttributeNode(Attr at, boolean makeId) {
 917         if (needsSyncData()) {
 918             synchronizeData();
 919         }
 920         if (ownerDocument.errorChecking) {
 921             if (isReadOnly()) {
<span class="line-modified"> 922                 String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-added"> 923                         DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);</span>
 924                 throw new DOMException(
<span class="line-modified"> 925                         DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);</span>

 926             }
 927 
 928             if (at.getOwnerElement() != this) {
<span class="line-modified"> 929                 String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-added"> 930                         DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);</span>
 931                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 932             }
 933         }
 934         ((AttrImpl) at).isIdAttribute(makeId);
 935         if (!makeId) {
 936             ownerDocument.removeIdentifier(at.getValue());
 937         } else {
 938             ownerDocument.putIdentifier(at.getValue(), this);
 939         }
 940     }
 941 
 942     /**
 943      * DOM Level 3: register the given attribute node as an ID attribute
 944      */
 945     public void setIdAttribute(String name, boolean makeId) {
 946         if (needsSyncData()) {
 947             synchronizeData();
 948         }
 949         Attr at = getAttributeNode(name);
 950 
 951         if (at == null) {
<span class="line-modified"> 952                 String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified"> 953                         DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);</span>

 954             throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
<span class="line-modified"> 955                 }</span>
 956 
 957         if (ownerDocument.errorChecking) {
 958             if (isReadOnly()) {
<span class="line-modified"> 959                 String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified"> 960                         DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);</span>
<span class="line-modified"> 961                 throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);</span>

 962             }
 963 
 964             if (at.getOwnerElement() != this) {
<span class="line-modified"> 965                 String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-added"> 966                         DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);</span>
 967                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 968             }
 969         }
 970 
 971         ((AttrImpl) at).isIdAttribute(makeId);
 972         if (!makeId) {
 973             ownerDocument.removeIdentifier(at.getValue());
 974         } else {
 975             ownerDocument.putIdentifier(at.getValue(), this);
 976         }
 977     }
 978 
 979     /**
 980      * DOM Level 3: register the given attribute node as an ID attribute
 981      */
 982     public void setIdAttributeNS(String namespaceURI, String localName,
<span class="line-modified"> 983                                     boolean makeId) {</span>
 984         if (needsSyncData()) {
 985             synchronizeData();
 986         }
 987         //if namespace uri is empty string, set it to &#39;null&#39;
 988         if (namespaceURI != null) {
 989             namespaceURI = (namespaceURI.length() == 0) ? null : namespaceURI;
 990         }
 991         Attr at = getAttributeNodeNS(namespaceURI, localName);
 992 
 993         if (at == null) {
<span class="line-modified"> 994                 String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified"> 995                         DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);</span>

 996             throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
<span class="line-modified"> 997                 }</span>
 998 
<span class="line-modified"> 999                 if (ownerDocument.errorChecking) {</span>
1000             if (isReadOnly()) {
1001                 String msg = DOMMessageFormatter.formatMessage(
1002                         DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
1003                 throw new DOMException(
<span class="line-modified">1004                                      DOMException.NO_MODIFICATION_ALLOWED_ERR,</span>
<span class="line-modified">1005                                      msg);</span>
1006             }
1007 
1008             if (at.getOwnerElement() != this) {
1009                 String msg = DOMMessageFormatter.formatMessage(
1010                         DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);
1011                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
1012             }
1013         }
1014         ((AttrImpl) at).isIdAttribute(makeId);
1015         if (!makeId) {
1016             ownerDocument.removeIdentifier(at.getValue());
1017         } else {
1018             ownerDocument.putIdentifier(at.getValue(), this);
1019         }
<span class="line-modified">1020    }</span>
1021 
1022     /**
1023      * @see org.w3c.dom.TypeInfo#getTypeName()
1024      */
<span class="line-modified">1025      public String getTypeName() {</span>
1026         return null;
<span class="line-modified">1027      }</span>
1028 
1029     /**
1030      * @see org.w3c.dom.TypeInfo#getTypeNamespace()
1031      */
1032     public String getTypeNamespace() {
1033         return null;
1034     }
1035 
1036     /**
1037      * Introduced in DOM Level 3.
1038      * &lt;p&gt;
1039      * Checks if a type is derived from another by restriction. See:
1040      * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom
1041      *
1042      * @param typeNamespaceArg The namspace of the ancestor type declaration
1043      * @param typeNameArg The name of the ancestor type declaration
1044      * @param derivationMethod The derivation method
1045      *
1046      * @return boolean True if the type is derived by restriction for the
1047      * reference type
1048      */
1049     public boolean isDerivedFrom(String typeNamespaceArg,
<span class="line-modified">1050                                  String typeNameArg,</span>
<span class="line-modified">1051                                  int derivationMethod) {</span>
1052 
1053         return false;
1054     }
1055 
<span class="line-modified">1056         /**</span>
<span class="line-modified">1057          * Method getSchemaTypeInfo.</span>
<span class="line-modified">1058          * @return TypeInfo</span>
<span class="line-modified">1059          */</span>

1060     public TypeInfo getSchemaTypeInfo() {
1061         if (needsSyncData()) {
1062             synchronizeData();
1063         }
1064         return this;
1065     }
1066 
1067     //
1068     // Public methods
1069     //
1070     /**
1071      * NON-DOM: Subclassed to flip the attributes&#39; readonly switch as well.
1072      *
1073      * @see NodeImpl#setReadOnly
1074      */
1075     public void setReadOnly(boolean readOnly, boolean deep) {
1076         super.setReadOnly(readOnly, deep);
1077         if (attributes != null) {
1078             attributes.setReadOnly(readOnly, true);
1079         }
</pre>
<hr />
<pre>
1129     /**
1130      * Reconcile default attributes.
1131      */
1132     protected void reconcileDefaultAttributes() {
1133         if (attributes != null) {
1134             NamedNodeMapImpl defaults = getDefaultAttributes();
1135             attributes.reconcileDefaults(defaults);
1136         }
1137     }
1138 
1139     /**
1140      * Get the default attributes.
1141      */
1142     protected NamedNodeMapImpl getDefaultAttributes() {
1143 
1144         DocumentTypeImpl doctype
1145                 = (DocumentTypeImpl) ownerDocument.getDoctype();
1146         if (doctype == null) {
1147             return null;
1148         }
<span class="line-modified">1149         ElementDefinitionImpl eldef = (ElementDefinitionImpl)doctype.getElements()</span>

1150                 .getNamedItem(getNodeName());
1151         if (eldef == null) {
1152             return null;
1153         }
1154         return (NamedNodeMapImpl) eldef.getAttributes();
1155 
1156     } // getDefaultAttributes()
1157 
1158     //
1159     // ElementTraversal methods
1160     //
1161     /**
1162      * @see &lt;a
1163      * href=&quot;http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-childElementCount&quot;&gt;
1164      * Element Traversal Specification&lt;/a&gt;
1165      */
1166     @Override
1167     public final int getChildElementCount() {
1168         int count = 0;
1169         Element child = getFirstElementChild();
</pre>
</td>
</tr>
</table>
<center><a href="DocumentTypeImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ElementNSImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
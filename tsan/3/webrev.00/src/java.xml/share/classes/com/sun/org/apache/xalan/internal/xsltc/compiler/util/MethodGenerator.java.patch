diff a/src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java b/src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java
--- a/src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -73,11 +73,11 @@
 import java.util.Stack;
 
 /**
  * @author Jacek Ambroziak
  * @author Santiago Pericas-Geertsen
- * @LastModified: Nov 2017
+ * @LastModified: July 2019
  */
 public class MethodGenerator extends MethodGen
     implements com.sun.org.apache.xalan.internal.xsltc.compiler.Constants {
     protected static final int INVALID_INDEX   = -1;
 
@@ -205,11 +205,11 @@
 
         index = cpg.addInterfaceMethodref(NODE_ITERATOR, NEXT, NEXT_SIG);
         _nextNode = new INVOKEINTERFACE(index, 1);
 
         _slotAllocator = new SlotAllocator();
-        _slotAllocator.initialize(getLocalVariableRegistry().getLocals(false));
+        _slotAllocator.initialize(getLocalVariableRegistry().getLocals());
         _allocatorInit = true;
     }
 
     /**
      * Allocates a local variable. If the slot allocator has already been
@@ -443,11 +443,11 @@
                         sameNameList.remove(i);
                         break;
                     }
                 }
             } else {
-                _nameToLVGMap.remove(lvg);
+                _nameToLVGMap.remove(lvg.getName());
             }
         }
 
         /**
          * <p>Given the name of a variable, finds a {@link LocalVariableGen}
@@ -478,59 +478,35 @@
 
             return lvg;
         }
 
         /**
-         * <p>Gets all {@link LocalVariableGen} objects for this method.</p>
-         * <p>When the <code>includeRemoved</code> argument has the value
-         * <code>false</code>, this method replaces uses of
-         * {@link MethodGen#getLocalVariables()} which has
+         * Gets all {@link LocalVariableGen} objects.
+         * This method replaces {@link MethodGen#getLocalVariables()} which has
          * a side-effect of setting the start and end range for any
-         * <code>LocalVariableGen</code> if either was <code>null</code>.  That
+         * {@code LocalVariableGen} if either was {@code null}.  That
          * side-effect causes problems for outlining of code in XSLTC.
-         * @param includeRemoved Specifies whether all local variables ever
-         * declared should be returned (<code>true</code>) or only those not
-         * removed (<code>false</code>)
-         * @return an array of <code>LocalVariableGen</code> containing all the
+         *
+         * @return an array of {@code LocalVariableGen} containing all the
          * local variables
          */
         @SuppressWarnings("unchecked")
-        protected LocalVariableGen[] getLocals(boolean includeRemoved) {
+        private LocalVariableGen[] getLocals() {
             LocalVariableGen[] locals = null;
             List<LocalVariableGen> allVarsEverDeclared = new ArrayList<>();
 
-            if (includeRemoved) {
-                int slotCount = allVarsEverDeclared.size();
-
-                for (int i = 0; i < slotCount; i++) {
-                    Object slotEntries = _variables.get(i);
-                    if (slotEntries != null) {
-                        if (slotEntries instanceof ArrayList) {
-                            List<LocalVariableGen> slotList =
-                                    (List<LocalVariableGen>)slotEntries;
-
-                            for (int j = 0; j < slotList.size(); j++) {
-                                allVarsEverDeclared.add(slotList.get(i));
-                            }
-                        } else {
-                            allVarsEverDeclared.add((LocalVariableGen)slotEntries);
-                        }
-                    }
-                }
-            } else {
-                for (Map.Entry<String, Object> nameVarsPair : _nameToLVGMap.entrySet()) {
-                    Object vars = nameVarsPair.getValue();
-                    if (vars != null) {
-                        if (vars instanceof ArrayList) {
-                            List<LocalVariableGen> varsList =
-                                    (List<LocalVariableGen>) vars;
-                            for (int i = 0; i < varsList.size(); i++) {
-                                allVarsEverDeclared.add(varsList.get(i));
-                            }
-                        } else {
-                            allVarsEverDeclared.add((LocalVariableGen)vars);
+            for (Map.Entry<String, Object> nameVarsPair : _nameToLVGMap.entrySet()) {
+                Object vars = nameVarsPair.getValue();
+                if (vars != null) {
+                    if (vars instanceof ArrayList) {
+                        List<LocalVariableGen> varsList =
+                                (List<LocalVariableGen>) vars;
+                        for (int i = 0; i < varsList.size(); i++) {
+                            allVarsEverDeclared.add(varsList.get(i));
                         }
+                    } else {
+                        allVarsEverDeclared.add((LocalVariableGen)vars);
                     }
                 }
             }
 
             locals = new LocalVariableGen[allVarsEverDeclared.size()];

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/FieldOrMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.bcel.internal.generic;
 23 
 24 import com.sun.org.apache.bcel.internal.Const;
 25 import com.sun.org.apache.bcel.internal.classfile.ConstantCP;
 26 import com.sun.org.apache.bcel.internal.classfile.ConstantNameAndType;
 27 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 28 import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;
 29 
 30 /**
 31  * Super class for InvokeInstruction and FieldInstruction, since they have
 32  * some methods in common!
 33  *
 34  */
 35 public abstract class FieldOrMethod extends CPInstruction implements LoadClass {
 36 
 37     /**
 38      * Empty constructor needed for Instruction.readInstruction.
 39      * Not to be used otherwise.
 40      */
 41     FieldOrMethod() {
 42         // no init
 43     }
 44 
 45 
 46     /**
 47      * @param index to constant pool
 48      */
 49     protected FieldOrMethod(final short opcode, final int index) {
 50         super(opcode, index);
 51     }
 52 
 53 
 54     /** @return signature of referenced method/field.
 55      */
 56     public String getSignature(final ConstantPoolGen cpg) {
 57         final ConstantPool cp = cpg.getConstantPool();
 58         final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());
 59         final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());
 60         return ((ConstantUtf8) cp.getConstant(cnat.getSignatureIndex())).getBytes();
 61     }
 62 
 63 
 64     /** @return name of referenced method/field.
 65      */
 66     public String getName(final ConstantPoolGen cpg) {
 67         final ConstantPool cp = cpg.getConstantPool();
 68         final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());
 69         final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());
 70         return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();
 71     }
 72 
 73 
 74     /**
 75      * @return name of the referenced class/interface
 76      * @deprecated If the instruction references an array class,
 77      *    this method will return &quot;java.lang.Object&quot;.
 78      *    For code generated by Java 1.5, this answer is
 79      *    sometimes wrong (e.g., if the &quot;clone()&quot; method is
 80      *    called on an array).  A better idea is to use
 81      *    the {@link #getReferenceType(ConstantPoolGen)} method, which correctly distinguishes
 82      *    between class types and array types.
 83      *
 84      */
 85     @Deprecated
 86     public String getClassName(final ConstantPoolGen cpg) {
 87         final ConstantPool cp = cpg.getConstantPool();
 88         final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());
 89         final String className = cp.getConstantString(cmr.getClassIndex(), Const.CONSTANT_Class);
 90         if (className.startsWith(&quot;[&quot;)) {
 91             // Turn array classes into java.lang.Object.
 92             return &quot;java.lang.Object&quot;;
 93         }
 94         return className.replace(&#39;/&#39;, &#39;.&#39;);
 95     }
 96 
 97 
 98     /** @return type of the referenced class/interface
 99      * @deprecated If the instruction references an array class,
100      *    the ObjectType returned will be invalid.  Use
101      *    getReferenceType() instead.
102      */
103     @Deprecated
104     public ObjectType getClassType(final ConstantPoolGen cpg) {
105         return ObjectType.getInstance(getClassName(cpg));
106     }
107 
108 
109     /**
110      * Gets the reference type representing the class, interface,
111      * or array class referenced by the instruction.
112      * @param cpg the ConstantPoolGen used to create the instruction
113      * @return an ObjectType (if the referenced class type is a class
114      *   or interface), or an ArrayType (if the referenced class
115      *   type is an array class)
116      */
117     public ReferenceType getReferenceType(final ConstantPoolGen cpg) {
118         final ConstantPool cp = cpg.getConstantPool();
119         final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());
120         String className = cp.getConstantString(cmr.getClassIndex(), Const.CONSTANT_Class);
121         if (className.startsWith(&quot;[&quot;)) {
122             return (ArrayType) Type.getType(className);
123         }
124         className = className.replace(&#39;/&#39;, &#39;.&#39;);
125         return ObjectType.getInstance(className);
126     }
127 
128 
129     /**
130      * Gets the ObjectType of the method return or field.
131      *
132      * @return type of the referenced class/interface
133      * @throws ClassGenException when the field is (or method returns) an array,
134      */
135     @Override
136     public ObjectType getLoadClassType(final ConstantPoolGen cpg) {
137         final ReferenceType rt = getReferenceType(cpg);
138         if (rt instanceof ObjectType) {
139             return (ObjectType) rt;
140         }
141         throw new ClassGenException(rt.getClass().getCanonicalName() + &quot; &quot; +
142                 rt.getSignature() + &quot; does not represent an ObjectType&quot;);
143     }
144 }
    </pre>
  </body>
</html>
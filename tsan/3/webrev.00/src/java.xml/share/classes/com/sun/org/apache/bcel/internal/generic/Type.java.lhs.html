<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.ArrayList;
 23 import java.util.List;
 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.ClassFormatException;
 27 import com.sun.org.apache.bcel.internal.classfile.Utility;
 28 
 29 /**
<a name="2" id="anc2"></a><span class="line-modified"> 30  * Abstract super class for all possible java types, namely basic types such as</span>
<span class="line-modified"> 31  * int, object types like String and array types, e.g. int[]</span>
 32  *
<a name="3" id="anc3"></a><span class="line-modified"> 33  * @version $Id: Type.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 34  */
 35 public abstract class Type {
 36 
 37     private final byte type;
 38     private String signature; // signature for the type
 39     /**
 40      * Predefined constants
 41      */
 42     public static final BasicType VOID = new BasicType(Const.T_VOID);
 43     public static final BasicType BOOLEAN = new BasicType(Const.T_BOOLEAN);
 44     public static final BasicType INT = new BasicType(Const.T_INT);
 45     public static final BasicType SHORT = new BasicType(Const.T_SHORT);
 46     public static final BasicType BYTE = new BasicType(Const.T_BYTE);
 47     public static final BasicType LONG = new BasicType(Const.T_LONG);
 48     public static final BasicType DOUBLE = new BasicType(Const.T_DOUBLE);
 49     public static final BasicType FLOAT = new BasicType(Const.T_FLOAT);
 50     public static final BasicType CHAR = new BasicType(Const.T_CHAR);
 51     public static final ObjectType OBJECT = new ObjectType(&quot;java.lang.Object&quot;);
 52     public static final ObjectType CLASS = new ObjectType(&quot;java.lang.Class&quot;);
 53     public static final ObjectType STRING = new ObjectType(&quot;java.lang.String&quot;);
 54     public static final ObjectType STRINGBUFFER = new ObjectType(&quot;java.lang.StringBuffer&quot;);
 55     public static final ObjectType THROWABLE = new ObjectType(&quot;java.lang.Throwable&quot;);
 56     public static final Type[] NO_ARGS = new Type[0]; // EMPTY, so immutable
 57     public static final ReferenceType NULL = new ReferenceType() {
 58     };
 59     public static final Type UNKNOWN = new Type(Const.T_UNKNOWN, &quot;&lt;unknown object&gt;&quot;) {
 60     };
 61 
<a name="4" id="anc4"></a>
 62     protected Type(final byte t, final String s) {
 63         type = t;
 64         signature = s;
 65     }
 66 
<a name="5" id="anc5"></a>
 67     /**
 68      * @return hashcode of Type
 69      */
 70     @Override
 71     public int hashCode() {
 72         return type ^ signature.hashCode();
 73     }
 74 
<a name="6" id="anc6"></a>
 75     /**
 76      * @return whether the Types are equal
 77      */
 78     @Override
 79     public boolean equals(final Object o) {
<a name="7" id="anc7"></a><span class="line-modified"> 80         if (o instanceof Type) {</span>
<span class="line-modified"> 81             final Type t = (Type) o;</span>
<span class="line-modified"> 82             return (type == t.type) &amp;&amp; signature.equals(t.signature);</span>
<span class="line-modified"> 83         }</span>
<span class="line-modified"> 84         return false;</span>
 85     }
 86 
<a name="8" id="anc8"></a>
 87     /**
 88      * @return signature for given type.
 89      */
 90     public String getSignature() {
 91         return signature;
 92     }
 93 
<a name="9" id="anc9"></a>
 94     /**
 95      * @return type as defined in Constants
 96      */
 97     public byte getType() {
 98         return type;
 99     }
100 
101     /**
<a name="10" id="anc10"></a><span class="line-modified">102      * boolean, short and char variable are considered as int in the stack or</span>
<span class="line-modified">103      * local variable area. Returns {@link Type#INT} for</span>
<span class="line-removed">104      * {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise</span>
105      * returns the given type.
<a name="11" id="anc11"></a><span class="line-removed">106      *</span>
107      * @since 6.0
108      */
109     public Type normalizeForStackOrLocal() {
110         if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {
111             return Type.INT;
112         }
113         return this;
114     }
115 
116     /**
<a name="12" id="anc12"></a><span class="line-modified">117      * @return stack size of this type (2 for long and double, 0 for void, 1</span>
<span class="line-removed">118      * otherwise)</span>
119      */
120     public int getSize() {
121         switch (type) {
122             case Const.T_DOUBLE:
123             case Const.T_LONG:
124                 return 2;
125             case Const.T_VOID:
126                 return 0;
127             default:
128                 return 1;
129         }
130     }
131 
<a name="13" id="anc13"></a>
132     /**
133      * @return Type string, e.g. `int[]&#39;
134      */
135     @Override
136     public String toString() {
137         return ((this.equals(Type.NULL) || (type &gt;= Const.T_UNKNOWN))) ? signature : Utility
138                 .signatureToString(signature, false);
139     }
140 
<a name="14" id="anc14"></a>
141     /**
142      * Convert type to Java method signature, e.g. int[] f(java.lang.String x)
143      * becomes (Ljava/lang/String;)[I
144      *
145      * @param return_type what the method returns
146      * @param arg_types what are the argument types
147      * @return method signature for given type(s).
148      */
<a name="15" id="anc15"></a><span class="line-modified">149     public static String getMethodSignature(final Type return_type, final Type[] arg_types) {</span>
150         final StringBuilder buf = new StringBuilder(&quot;(&quot;);
151         if (arg_types != null) {
152             for (final Type arg_type : arg_types) {
153                 buf.append(arg_type.getSignature());
154             }
155         }
156         buf.append(&#39;)&#39;);
157         buf.append(return_type.getSignature());
158         return buf.toString();
159     }
160 
161     private static final ThreadLocal&lt;Integer&gt; consumed_chars = new ThreadLocal&lt;Integer&gt;() {
162 
163         @Override
164         protected Integer initialValue() {
165             return Integer.valueOf(0);
166         }
167     };//int consumed_chars=0; // Remember position in string, see getArgumentTypes
168 
<a name="16" id="anc16"></a><span class="line-modified">169     private static int unwrap(final ThreadLocal&lt;Integer&gt; tl) {</span>

170         return tl.get().intValue();
171     }
172 
<a name="17" id="anc17"></a><span class="line-modified">173     private static void wrap(final ThreadLocal&lt;Integer&gt; tl, final int value) {</span>

174         tl.set(Integer.valueOf(value));
175     }
176 
<a name="18" id="anc18"></a>
177     /**
178      * Convert signature to a Type object.
<a name="19" id="anc19"></a><span class="line-removed">179      *</span>
180      * @param signature signature string such as Ljava/lang/String;
181      * @return type object
182      */
183     // @since 6.0 no longer final
<a name="20" id="anc20"></a><span class="line-modified">184     public static Type getType(final String signature) throws StringIndexOutOfBoundsException {</span>
185         final byte type = Utility.typeOfSignature(signature);
186         if (type &lt;= Const.T_VOID) {
187             //corrected concurrent private static field acess
188             wrap(consumed_chars, 1);
189             return BasicType.getType(type);
190         } else if (type == Const.T_ARRAY) {
191             int dim = 0;
192             do { // Count dimensions
193                 dim++;
194             } while (signature.charAt(dim) == &#39;[&#39;);
195             // Recurse, but just once, if the signature is ok
196             final Type t = getType(signature.substring(dim));
197             //corrected concurrent private static field acess
198             //  consumed_chars += dim; // update counter - is replaced by
199             final int _temp = unwrap(consumed_chars) + dim;
200             wrap(consumed_chars, _temp);
201             return new ArrayType(t, dim);
202         } else { // type == T_REFERENCE
<a name="21" id="anc21"></a><span class="line-modified">203             // Utility.signatureToString understands how to parse</span>
<span class="line-modified">204             // generic types.</span>
<span class="line-removed">205             final String parsedSignature = Utility.signatureToString(signature, false);</span>
206             wrap(consumed_chars, parsedSignature.length() + 2); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed
207             return ObjectType.getInstance(parsedSignature.replace(&#39;/&#39;, &#39;.&#39;));
208         }
209     }
210 
<a name="22" id="anc22"></a>
211     /**
212      * Convert return value of a method (signature) to a Type object.
213      *
214      * @param signature signature string such as (Ljava/lang/String;)V
215      * @return return type
216      */
<a name="23" id="anc23"></a><span class="line-modified">217     public static Type getReturnType(final String signature) {</span>
218         try {
219             // Read return type after `)&#39;
220             final int index = signature.lastIndexOf(&#39;)&#39;) + 1;
221             return getType(signature.substring(index));
222         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
223             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
224         }
225     }
226 
<a name="24" id="anc24"></a>
227     /**
228      * Convert arguments of a method (signature) to an array of Type objects.
<a name="25" id="anc25"></a><span class="line-removed">229      *</span>
230      * @param signature signature string such as (Ljava/lang/String;)V
231      * @return array of argument types
232      */
<a name="26" id="anc26"></a><span class="line-modified">233     public static Type[] getArgumentTypes(final String signature) {</span>
234         final List&lt;Type&gt; vec = new ArrayList&lt;&gt;();
235         int index;
236         Type[] types;
<a name="27" id="anc27"></a><span class="line-modified">237         try { // Read all declarations between for `(&#39; and `)&#39;</span>
<span class="line-modified">238             if (signature.charAt(0) != &#39;(&#39;) {</span>


239                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
240             }
<a name="28" id="anc28"></a><span class="line-removed">241             index = 1; // current string position</span>
242             while (signature.charAt(index) != &#39;)&#39;) {
243                 vec.add(getType(signature.substring(index)));
244                 //corrected concurrent private static field acess
245                 index += unwrap(consumed_chars); // update position
246             }
247         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
248             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
249         }
250         types = new Type[vec.size()];
251         vec.toArray(types);
252         return types;
253     }
254 
<a name="29" id="anc29"></a><span class="line-modified">255     /**</span>
<span class="line-modified">256      * Convert runtime java.lang.Class to BCEL Type object.</span>
<span class="line-removed">257      *</span>
258      * @param cl Java class
259      * @return corresponding Type object
260      */
<a name="30" id="anc30"></a><span class="line-modified">261     public static Type getType(final java.lang.Class&lt;?&gt; cl) {</span>
262         if (cl == null) {
263             throw new IllegalArgumentException(&quot;Class must not be null&quot;);
264         }
265         /* That&#39;s an amzingly easy case, because getName() returns
266          * the signature. That&#39;s what we would have liked anyway.
267          */
268         if (cl.isArray()) {
269             return getType(cl.getName());
270         } else if (cl.isPrimitive()) {
271             if (cl == Integer.TYPE) {
272                 return INT;
273             } else if (cl == Void.TYPE) {
274                 return VOID;
275             } else if (cl == Double.TYPE) {
276                 return DOUBLE;
277             } else if (cl == Float.TYPE) {
278                 return FLOAT;
279             } else if (cl == Boolean.TYPE) {
280                 return BOOLEAN;
281             } else if (cl == Byte.TYPE) {
282                 return BYTE;
283             } else if (cl == Short.TYPE) {
284                 return SHORT;
285             } else if (cl == Byte.TYPE) {
286                 return BYTE;
287             } else if (cl == Long.TYPE) {
288                 return LONG;
289             } else if (cl == Character.TYPE) {
290                 return CHAR;
291             } else {
292                 throw new IllegalStateException(&quot;Ooops, what primitive type is &quot; + cl);
293             }
294         } else { // &quot;Real&quot; class
295             return ObjectType.getInstance(cl.getName());
296         }
297     }
298 
<a name="31" id="anc31"></a>
299     /**
300      * Convert runtime java.lang.Class[] to BCEL Type objects.
<a name="32" id="anc32"></a><span class="line-removed">301      *</span>
302      * @param classes an array of runtime class objects
303      * @return array of corresponding Type objects
304      */
<a name="33" id="anc33"></a><span class="line-modified">305     public static Type[] getTypes(final java.lang.Class&lt;?&gt;[] classes) {</span>
306         final Type[] ret = new Type[classes.length];
307         for (int i = 0; i &lt; ret.length; i++) {
308             ret[i] = getType(classes[i]);
309         }
310         return ret;
311     }
312 
<a name="34" id="anc34"></a><span class="line-modified">313     public static String getSignature(final java.lang.reflect.Method meth) {</span>

314         final StringBuilder sb = new StringBuilder(&quot;(&quot;);
315         final Class&lt;?&gt;[] params = meth.getParameterTypes(); // avoid clone
316         for (final Class&lt;?&gt; param : params) {
317             sb.append(getType(param).getSignature());
318         }
319         sb.append(&quot;)&quot;);
320         sb.append(getType(meth.getReturnType()).getSignature());
321         return sb.toString();
322     }
323 
324     static int size(final int coded) {
325         return coded &amp; 3;
326     }
327 
328     static int consumed(final int coded) {
329         return coded &gt;&gt; 2;
330     }
331 
332     static int encode(final int size, final int consumed) {
333         return consumed &lt;&lt; 2 | size;
334     }
335 
<a name="35" id="anc35"></a><span class="line-modified">336     static int getArgumentTypesSize(final String signature) {</span>
337         int res = 0;
338         int index;
<a name="36" id="anc36"></a><span class="line-modified">339         try { // Read all declarations between for `(&#39; and `)&#39;</span>
<span class="line-modified">340             if (signature.charAt(0) != &#39;(&#39;) {</span>


341                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
342             }
<a name="37" id="anc37"></a><span class="line-removed">343             index = 1; // current string position</span>
344             while (signature.charAt(index) != &#39;)&#39;) {
345                 final int coded = getTypeSize(signature.substring(index));
346                 res += size(coded);
347                 index += consumed(coded);
348             }
349         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
350             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
351         }
352         return res;
353     }
354 
<a name="38" id="anc38"></a><span class="line-modified">355     static int getTypeSize(final String signature) throws StringIndexOutOfBoundsException {</span>
356         final byte type = Utility.typeOfSignature(signature);
357         if (type &lt;= Const.T_VOID) {
358             return encode(BasicType.getType(type).getSize(), 1);
359         } else if (type == Const.T_ARRAY) {
360             int dim = 0;
361             do { // Count dimensions
362                 dim++;
363             } while (signature.charAt(dim) == &#39;[&#39;);
364             // Recurse, but just once, if the signature is ok
365             final int consumed = consumed(getTypeSize(signature.substring(dim)));
366             return encode(1, dim + consumed);
367         } else { // type == T_REFERENCE
368             final int index = signature.indexOf(&#39;;&#39;); // Look for closing `;&#39;
369             if (index &lt; 0) {
370                 throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
371             }
372             return encode(1, index + 1);
373         }
374     }
375 
<a name="39" id="anc39"></a>
376     static int getReturnTypeSize(final String signature) {
377         final int index = signature.lastIndexOf(&#39;)&#39;) + 1;
378         return Type.size(getTypeSize(signature.substring(index)));
379     }
380 
381 
382     /*
383      * Currently only used by the ArrayType constructor.
384      * The signature has a complicated dependency on other parameter
385      * so it&#39;s tricky to do it in a call to the super ctor.
386      */
387     void setSignature(final String signature) {
388         this.signature = signature;
389     }
390 }
<a name="40" id="anc40"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="40" type="hidden" />
</body>
</html>
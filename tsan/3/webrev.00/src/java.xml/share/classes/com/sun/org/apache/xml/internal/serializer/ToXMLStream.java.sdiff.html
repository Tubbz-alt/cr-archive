<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToXMLStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ToUnknownStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="dom3/LSSerializerImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToXMLStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21  package com.sun.org.apache.xml.internal.serializer;
 22 
 23 import java.io.IOException;
 24 
 25 import javax.xml.transform.ErrorListener;
 26 import javax.xml.transform.Result;
 27 import javax.xml.transform.Transformer;
 28 import javax.xml.transform.TransformerException;
 29 
 30 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
 31 import com.sun.org.apache.xml.internal.serializer.utils.Utils;
 32 import org.xml.sax.SAXException;
 33 
 34 /**
 35  * This class converts SAX or SAX-like calls to a
 36  * serialized xml document.  The xsl:output method is &quot;xml&quot;.
 37  *
 38  * This class is used explicitly in code generated by XSLTC,
 39  * so it is &quot;public&quot;, but it should
 40  * be viewed as internal or package private, this is not an API.
 41  *
 42  * @xsl.usage internal

 43  */
 44 public final class ToXMLStream extends ToStream
 45 {
 46 
 47     /**
 48      * remembers if we need to write out &quot;]]&gt;&quot; to close the CDATA
 49      */
 50     boolean m_cdataTagOpen = false;
 51 
 52 
 53     /**
 54      * Map that tells which XML characters should have special treatment, and it
 55      *  provides character to entity name lookup.
 56      */
 57     private static CharInfo m_xmlcharInfo =
 58 //      new CharInfo(CharInfo.XML_ENTITIES_RESOURCE);
 59         CharInfo.getCharInfoInternal(CharInfo.XML_ENTITIES_RESOURCE, Method.XML);
 60 
 61     /**
 62      * Default constructor.
 63      */
 64     public ToXMLStream()
 65     {









 66         m_charInfo = m_xmlcharInfo;
 67 
 68         initCDATA();
 69         // initialize namespaces
 70         m_prefixMap = new NamespaceMappings();
<span class="line-removed"> 71 </span>
 72     }
 73 
 74     /**
 75      * Copy properties from another SerializerToXML.
 76      *
 77      * @param xmlListener non-null reference to a SerializerToXML object.
 78      */
 79     public void CopyFrom(ToXMLStream xmlListener)
 80     {
 81 
 82         m_writer = xmlListener.m_writer;
 83 
 84 
 85         // m_outputStream = xmlListener.m_outputStream;
 86         String encoding = xmlListener.getEncoding();
 87         setEncoding(encoding);
 88 
 89         setOmitXMLDeclaration(xmlListener.getOmitXMLDeclaration());
 90 
 91         m_ispreserveSpace = xmlListener.m_ispreserveSpace;
</pre>
<hr />
<pre>
183                 catch(IOException e)
184                 {
185                     throw new SAXException(e);
186                 }
187 
188             }
189         }
190     }
191 
192     /**
193      * Receive notification of the end of a document.
194      *
195      * @throws org.xml.sax.SAXException Any SAX exception, possibly
196      *            wrapping another exception.
197      *
198      * @throws org.xml.sax.SAXException
199      */
200     public void endDocument() throws org.xml.sax.SAXException
201     {
202         if (m_doIndent) {
<span class="line-modified">203             flushCharactersBuffer();</span>
204         }
205         flushPending();
206         if (m_doIndent &amp;&amp; !m_isprevtext)
207         {
208             try
209             {
210             outputLineSep();
211             }
212             catch(IOException e)
213             {
214                 throw new SAXException(e);
215             }
216         }
217 
218         flushWriter();
219 
220         if (m_tracer != null)
221             super.fireEndDoc();
222     }
223 
</pre>
<hr />
<pre>
250 
251     /**
252      * Receive notification of a processing instruction.
253      *
254      * @param target The processing instruction target.
255      * @param data The processing instruction data, or null if
256      *        none was supplied.
257      * @throws org.xml.sax.SAXException Any SAX exception, possibly
258      *            wrapping another exception.
259      *
260      * @throws org.xml.sax.SAXException
261      */
262     public void processingInstruction(String target, String data)
263         throws org.xml.sax.SAXException
264     {
265         if (isInEntityRef())
266             return;
267 
268         if (m_doIndent) {
269             m_childNodeNum++;
<span class="line-modified">270             flushCharactersBuffer();</span>
271         }
272         flushPending();
273 
274         if (target.equals(Result.PI_DISABLE_OUTPUT_ESCAPING))
275         {
276             startNonEscaping();
277         }
278         else if (target.equals(Result.PI_ENABLE_OUTPUT_ESCAPING))
279         {
280             endNonEscaping();
281         }
282         else
283         {
284             try
285             {
286                 if (m_elemContext.m_startTagOpen)
287                 {
288                     closeStartTag();
289                     m_elemContext.m_startTagOpen = false;
290                 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21  package com.sun.org.apache.xml.internal.serializer;
 22 
 23 import java.io.IOException;
 24 
 25 import javax.xml.transform.ErrorListener;
 26 import javax.xml.transform.Result;
 27 import javax.xml.transform.Transformer;
 28 import javax.xml.transform.TransformerException;
 29 
 30 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
 31 import com.sun.org.apache.xml.internal.serializer.utils.Utils;
 32 import org.xml.sax.SAXException;
 33 
 34 /**
 35  * This class converts SAX or SAX-like calls to a
 36  * serialized xml document.  The xsl:output method is &quot;xml&quot;.
 37  *
 38  * This class is used explicitly in code generated by XSLTC,
 39  * so it is &quot;public&quot;, but it should
 40  * be viewed as internal or package private, this is not an API.
 41  *
 42  * @xsl.usage internal
<span class="line-added"> 43  * @LastModified: Aug 2019</span>
 44  */
 45 public final class ToXMLStream extends ToStream
 46 {
 47 
 48     /**
 49      * remembers if we need to write out &quot;]]&gt;&quot; to close the CDATA
 50      */
 51     boolean m_cdataTagOpen = false;
 52 
 53 
 54     /**
 55      * Map that tells which XML characters should have special treatment, and it
 56      *  provides character to entity name lookup.
 57      */
 58     private static CharInfo m_xmlcharInfo =
 59 //      new CharInfo(CharInfo.XML_ENTITIES_RESOURCE);
 60         CharInfo.getCharInfoInternal(CharInfo.XML_ENTITIES_RESOURCE, Method.XML);
 61 
 62     /**
 63      * Default constructor.
 64      */
 65     public ToXMLStream()
 66     {
<span class="line-added"> 67         this(null);</span>
<span class="line-added"> 68     }</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     /**</span>
<span class="line-added"> 71      * Default constructor.</span>
<span class="line-added"> 72      */</span>
<span class="line-added"> 73     public ToXMLStream(ErrorListener l)</span>
<span class="line-added"> 74     {</span>
<span class="line-added"> 75         super(l);</span>
 76         m_charInfo = m_xmlcharInfo;
 77 
 78         initCDATA();
 79         // initialize namespaces
 80         m_prefixMap = new NamespaceMappings();

 81     }
 82 
 83     /**
 84      * Copy properties from another SerializerToXML.
 85      *
 86      * @param xmlListener non-null reference to a SerializerToXML object.
 87      */
 88     public void CopyFrom(ToXMLStream xmlListener)
 89     {
 90 
 91         m_writer = xmlListener.m_writer;
 92 
 93 
 94         // m_outputStream = xmlListener.m_outputStream;
 95         String encoding = xmlListener.getEncoding();
 96         setEncoding(encoding);
 97 
 98         setOmitXMLDeclaration(xmlListener.getOmitXMLDeclaration());
 99 
100         m_ispreserveSpace = xmlListener.m_ispreserveSpace;
</pre>
<hr />
<pre>
192                 catch(IOException e)
193                 {
194                     throw new SAXException(e);
195                 }
196 
197             }
198         }
199     }
200 
201     /**
202      * Receive notification of the end of a document.
203      *
204      * @throws org.xml.sax.SAXException Any SAX exception, possibly
205      *            wrapping another exception.
206      *
207      * @throws org.xml.sax.SAXException
208      */
209     public void endDocument() throws org.xml.sax.SAXException
210     {
211         if (m_doIndent) {
<span class="line-modified">212             flushCharactersBuffer(false);</span>
213         }
214         flushPending();
215         if (m_doIndent &amp;&amp; !m_isprevtext)
216         {
217             try
218             {
219             outputLineSep();
220             }
221             catch(IOException e)
222             {
223                 throw new SAXException(e);
224             }
225         }
226 
227         flushWriter();
228 
229         if (m_tracer != null)
230             super.fireEndDoc();
231     }
232 
</pre>
<hr />
<pre>
259 
260     /**
261      * Receive notification of a processing instruction.
262      *
263      * @param target The processing instruction target.
264      * @param data The processing instruction data, or null if
265      *        none was supplied.
266      * @throws org.xml.sax.SAXException Any SAX exception, possibly
267      *            wrapping another exception.
268      *
269      * @throws org.xml.sax.SAXException
270      */
271     public void processingInstruction(String target, String data)
272         throws org.xml.sax.SAXException
273     {
274         if (isInEntityRef())
275             return;
276 
277         if (m_doIndent) {
278             m_childNodeNum++;
<span class="line-modified">279             flushCharactersBuffer(false);</span>
280         }
281         flushPending();
282 
283         if (target.equals(Result.PI_DISABLE_OUTPUT_ESCAPING))
284         {
285             startNonEscaping();
286         }
287         else if (target.equals(Result.PI_ENABLE_OUTPUT_ESCAPING))
288         {
289             endNonEscaping();
290         }
291         else
292         {
293             try
294             {
295                 if (m_elemContext.m_startTagOpen)
296                 {
297                     closeStartTag();
298                     m_elemContext.m_startTagOpen = false;
299                 }
</pre>
</td>
</tr>
</table>
<center><a href="ToUnknownStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="dom3/LSSerializerImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *     http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xalan.internal.xsltc.trax;
  22 
  23 import com.sun.org.apache.xalan.internal.XalanConstants;
  24 import com.sun.org.apache.xalan.internal.utils.XMLSecurityManager;
  25 import com.sun.org.apache.xalan.internal.xsltc.DOM;
  26 import com.sun.org.apache.xalan.internal.xsltc.DOMCache;
  27 import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
  28 import com.sun.org.apache.xalan.internal.xsltc.Translet;
  29 import com.sun.org.apache.xalan.internal.xsltc.TransletException;
  30 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
  31 import com.sun.org.apache.xalan.internal.xsltc.dom.DOMWSFilter;
  32 import com.sun.org.apache.xalan.internal.xsltc.dom.SAXImpl;
  33 import com.sun.org.apache.xalan.internal.xsltc.dom.XSLTCDTMManager;
  34 import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
  35 import com.sun.org.apache.xalan.internal.xsltc.runtime.output.TransletOutputHandlerFactory;
  36 import com.sun.org.apache.xml.internal.dtm.DTMWSFilter;
  37 import com.sun.org.apache.xml.internal.serializer.OutputPropertiesFactory;
  38 import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
  39 import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
  40 import com.sun.org.apache.xml.internal.utils.XMLReaderManager;
  41 import java.io.File;
  42 import java.io.FileOutputStream;
  43 import java.io.IOException;
  44 import java.io.InputStream;
  45 import java.io.OutputStream;
  46 import java.io.Reader;
  47 import java.io.Writer;
  48 import java.net.URI;
  49 import java.net.URL;
  50 import java.net.URLConnection;
  51 import java.net.UnknownServiceException;
  52 import java.util.ArrayList;
  53 import java.util.Enumeration;
  54 import java.util.HashMap;
  55 import java.util.List;
  56 import java.util.Map;
  57 import java.util.Properties;
  58 import java.util.StringTokenizer;
  59 import javax.xml.XMLConstants;
  60 import javax.xml.catalog.CatalogException;
  61 import javax.xml.catalog.CatalogFeatures;
  62 import javax.xml.catalog.CatalogManager;
  63 import javax.xml.catalog.CatalogResolver;
  64 import javax.xml.parsers.DocumentBuilder;
  65 import javax.xml.parsers.DocumentBuilderFactory;
  66 import javax.xml.parsers.ParserConfigurationException;
  67 import javax.xml.stream.XMLEventReader;
  68 import javax.xml.stream.XMLStreamReader;
  69 import javax.xml.transform.ErrorListener;
  70 import javax.xml.transform.OutputKeys;
  71 import javax.xml.transform.Result;
  72 import javax.xml.transform.Source;
  73 import javax.xml.transform.Transformer;
  74 import javax.xml.transform.TransformerException;
  75 import javax.xml.transform.URIResolver;
  76 import javax.xml.transform.dom.DOMResult;
  77 import javax.xml.transform.dom.DOMSource;
  78 import javax.xml.transform.sax.SAXResult;
  79 import javax.xml.transform.sax.SAXSource;
  80 import javax.xml.transform.stax.StAXResult;
  81 import javax.xml.transform.stax.StAXSource;
  82 import javax.xml.transform.stream.StreamResult;
  83 import javax.xml.transform.stream.StreamSource;
  84 import jdk.xml.internal.JdkXmlFeatures;
  85 import jdk.xml.internal.JdkXmlUtils;
<a name="1" id="anc1"></a>
  86 import org.xml.sax.ContentHandler;
  87 import org.xml.sax.InputSource;
  88 import org.xml.sax.SAXException;
  89 import org.xml.sax.XMLReader;
  90 import org.xml.sax.ext.LexicalHandler;
  91 
  92 /**
  93  * @author Morten Jorgensen
  94  * @author G. Todd Miller
  95  * @author Santiago Pericas-Geertsen
<a name="2" id="anc2"></a><span class="line-modified">  96  * @LastModified: Feb 2019</span>
  97  */
  98 public final class TransformerImpl extends Transformer
<a name="3" id="anc3"></a><span class="line-modified">  99     implements DOMCache, ErrorListener</span>
 100 {
 101 
 102     private final static String LEXICAL_HANDLER_PROPERTY =
 103         &quot;http://xml.org/sax/properties/lexical-handler&quot;;
 104 
 105     /**
 106      * Namespace prefixes feature for {@link XMLReader}.
 107      */
 108     private static final String NAMESPACE_PREFIXES_FEATURE =
 109         &quot;http://xml.org/sax/features/namespace-prefixes&quot;;
 110 
 111     /**
 112      * A reference to the translet or null if the identity transform.
 113      */
 114     private AbstractTranslet _translet = null;
 115 
 116     /**
 117      * The output method of this transformation.
 118      */
 119     private String _method = null;
 120 
 121     /**
 122      * The output encoding of this transformation.
 123      */
 124     private String _encoding = null;
 125 
 126     /**
 127      * The systemId set in input source.
 128      */
 129     private String _sourceSystemId = null;
 130 
<a name="4" id="anc4"></a>




 131     /**
 132      * An error listener for runtime errors.
 133      */
<a name="5" id="anc5"></a><span class="line-modified"> 134     private ErrorListener _errorListener = this;</span>
 135 
 136     /**
 137      * A reference to a URI resolver for calls to document().
 138      */
 139     private URIResolver _uriResolver = null;
 140 
 141     /**
 142      * Output properties of this transformer instance.
 143      */
 144     private Properties _properties, _propertiesClone;
 145 
 146     /**
 147      * A reference to an output handler factory.
 148      */
 149     private TransletOutputHandlerFactory _tohFactory = null;
 150 
 151     /**
 152      * A reference to a internal DOM representation of the input.
 153      */
 154     private DOM _dom = null;
 155 
 156     /**
 157      * Number of indent spaces to add when indentation is on.
 158      */
 159     private int _indentNumber = -1;
 160 
 161     /**
 162      * A reference to the transformer factory that this templates
 163      * object belongs to.
 164      */
 165     private TransformerFactoryImpl _tfactory = null;
 166 
 167     /**
 168      * A reference to the output stream, if we create one in our code.
 169      */
 170     private OutputStream _ostream = null;
 171 
 172     /**
 173      * A reference to the XSLTCDTMManager which is used to build the DOM/DTM
 174      * for this transformer.
 175      */
 176     private XSLTCDTMManager _dtmManager = null;
 177 
 178     /**
 179      * A reference to an object that creates and caches XMLReader objects.
 180      */
 181     private XMLReaderManager _readerManager;
 182 
 183     /**
 184      * A flag indicating whether we use incremental building of the DTM.
 185      */
 186     //private boolean _isIncremental = false;
 187 
 188     /**
 189      * A flag indicating whether this transformer implements the identity
 190      * transform.
 191      */
 192     private boolean _isIdentity = false;
 193 
 194     /**
 195      * State of the secure processing feature.
 196      */
 197     private boolean _isSecureProcessing = false;
 198 
 199     /**
 200      * Indicates whether 3rd party parser may be used to override the system-default
 201      */
 202     private boolean _overrideDefaultParser;
 203 
 204      /**
 205      * protocols allowed for external DTD references in source file and/or stylesheet.
 206      */
 207     private String _accessExternalDTD = XalanConstants.EXTERNAL_ACCESS_DEFAULT;
 208 
 209     private XMLSecurityManager _securityManager;
 210     /**
 211      * A map to store parameters for the identity transform. These
 212      * are not needed during the transformation, but we must keep track of
 213      * them to be fully complaint with the JAXP API.
 214      */
 215     private Map&lt;String, Object&gt; _parameters = null;
 216 
 217     // Catalog features
 218     CatalogFeatures _catalogFeatures;
 219     CatalogResolver _catalogUriResolver;
 220 
 221     // Catalog is enabled by default
 222     boolean _useCatalog = true;
 223 
 224     int _cdataChunkSize = JdkXmlUtils.CDATA_CHUNK_SIZE_DEFAULT;
 225 
 226     /**
 227      * This class wraps an ErrorListener into a MessageHandler in order to
 228      * capture messages reported via xsl:message.
 229      */
 230     static class MessageHandler
 231            extends com.sun.org.apache.xalan.internal.xsltc.runtime.MessageHandler
 232     {
 233         private ErrorListener _errorListener;
 234 
 235         public MessageHandler(ErrorListener errorListener) {
 236             _errorListener = errorListener;
 237         }
 238 
 239         @Override
 240         public void displayMessage(String msg) {
 241             if(_errorListener == null) {
 242                 System.err.println(msg);
 243             }
 244             else {
 245                 try {
 246                     _errorListener.warning(new TransformerException(msg));
 247                 }
 248                 catch (TransformerException e) {
 249                     // ignored
 250                 }
 251             }
 252         }
<a name="6" id="anc6"></a>



 253     }
 254 
 255     protected TransformerImpl(Properties outputProperties, int indentNumber,
 256         TransformerFactoryImpl tfactory)
 257     {
 258         this(null, outputProperties, indentNumber, tfactory);
 259         _isIdentity = true;
 260         // _properties.put(OutputKeys.METHOD, &quot;xml&quot;);
 261     }
 262 
 263     protected TransformerImpl(Translet translet, Properties outputProperties,
 264         int indentNumber, TransformerFactoryImpl tfactory)
 265     {
 266         _translet = (AbstractTranslet) translet;
<a name="7" id="anc7"></a>


 267         _properties = createOutputProperties(outputProperties);
 268         _propertiesClone = (Properties) _properties.clone();
 269         _indentNumber = indentNumber;
 270         _tfactory = tfactory;
 271         _overrideDefaultParser = _tfactory.overrideDefaultParser();
 272         _accessExternalDTD = (String)_tfactory.getAttribute(XMLConstants.ACCESS_EXTERNAL_DTD);
 273         _securityManager = (XMLSecurityManager)_tfactory.getAttribute(XalanConstants.SECURITY_MANAGER);
 274         _readerManager = XMLReaderManager.getInstance(_overrideDefaultParser);
 275         _readerManager.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, _accessExternalDTD);
 276         _readerManager.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, _isSecureProcessing);
 277         _readerManager.setProperty(XalanConstants.SECURITY_MANAGER, _securityManager);
 278         _cdataChunkSize = JdkXmlUtils.getValue(_tfactory.getAttribute(JdkXmlUtils.CDATA_CHUNK_SIZE),
 279                 JdkXmlUtils.CDATA_CHUNK_SIZE_DEFAULT);
 280         _readerManager.setProperty(JdkXmlUtils.CDATA_CHUNK_SIZE, _cdataChunkSize);
 281 
 282         _useCatalog = _tfactory.getFeature(XMLConstants.USE_CATALOG);
 283         if (_useCatalog) {
 284             _catalogFeatures = (CatalogFeatures)_tfactory.getAttribute(JdkXmlFeatures.CATALOG_FEATURES);
 285             String catalogFiles = _catalogFeatures.get(CatalogFeatures.Feature.DEFER);
 286             if (catalogFiles != null) {
 287                 _readerManager.setFeature(XMLConstants.USE_CATALOG, _useCatalog);
 288                 _readerManager.setProperty(JdkXmlFeatures.CATALOG_FEATURES, _catalogFeatures);
 289             }
 290         }
 291         //_isIncremental = tfactory._incremental;
 292     }
 293 
 294     /**
 295      * Return the state of the secure processing feature.
 296      */
 297     public boolean isSecureProcessing() {
 298         return _isSecureProcessing;
 299     }
 300 
 301     /**
 302      * Set the state of the secure processing feature.
 303      */
 304     public void setSecureProcessing(boolean flag) {
 305         _isSecureProcessing = flag;
 306         _readerManager.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, _isSecureProcessing);
 307     }
 308     /**
 309      * Return the state of the services mechanism feature.
 310      */
 311     public boolean overrideDefaultParser() {
 312         return _overrideDefaultParser;
 313     }
 314 
 315     /**
 316      * Set the state of the services mechanism feature.
 317      */
 318     public void setOverrideDefaultParser(boolean flag) {
 319         _overrideDefaultParser = flag;
 320     }
 321 
 322     /**
 323      * Returns the translet wrapped inside this Transformer or
 324      * null if this is the identity transform.
 325      */
 326     protected AbstractTranslet getTranslet() {
 327         return _translet;
 328     }
 329 
 330     public boolean isIdentity() {
 331         return _isIdentity;
 332     }
 333 
 334     /**
 335      * Implements JAXP&#39;s Transformer.transform()
 336      *
 337      * @param source Contains the input XML document
 338      * @param result Will contain the output from the transformation
 339      * @throws TransformerException
 340      */
 341     @Override
 342     public void transform(Source source, Result result)
 343         throws TransformerException
 344     {
 345         if (!_isIdentity) {
 346             if (_translet == null) {
 347                 ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_TRANSLET_ERR);
 348                 throw new TransformerException(err.toString());
 349             }
 350             // Pass output properties to the translet
 351             transferOutputProperties(_translet);
 352         }
 353 
 354         final SerializationHandler toHandler = getOutputHandler(result);
 355         if (toHandler == null) {
 356             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_HANDLER_ERR);
 357             throw new TransformerException(err.toString());
 358         }
 359 
 360         if (!_isIdentity &amp;&amp; (_uriResolver != null || (_tfactory.getFeature(XMLConstants.USE_CATALOG)
 361                     &amp;&amp; _tfactory.getAttribute(JdkXmlUtils.CATALOG_FILES) != null))) {
 362             _translet.setDOMCache(this);
 363         }
 364 
 365         // Pass output properties to handler if identity
 366         if (_isIdentity) {
 367             transferOutputProperties(toHandler);
 368         }
 369 
 370         transform(source, toHandler, _encoding);
 371         try{
 372             if (result instanceof DOMResult) {
 373                 ((DOMResult)result).setNode(_tohFactory.getNode());
 374             } else if (result instanceof StAXResult) {
 375                   if (((StAXResult) result).getXMLEventWriter() != null)
 376                 {
 377                     (_tohFactory.getXMLEventWriter()).flush();
 378                 }
 379                 else if (((StAXResult) result).getXMLStreamWriter() != null) {
 380                     (_tohFactory.getXMLStreamWriter()).flush();
 381                     //result = new StAXResult(_tohFactory.getXMLStreamWriter());
 382                 }
 383             }
 384         } catch (Exception e) {
 385             System.out.println(&quot;Result writing error&quot;);
 386         }
 387     }
 388 
 389     /**
 390      * Create an output handler for the transformation output based on
 391      * the type and contents of the TrAX Result object passed to the
 392      * transform() method.
 393      */
 394     public SerializationHandler getOutputHandler(Result result)
 395         throws TransformerException
 396     {
 397         // Get output method using get() to ignore defaults
 398         _method = (String) _properties.get(OutputKeys.METHOD);
 399 
 400         // Get encoding using getProperty() to use defaults
 401         _encoding = _properties.getProperty(OutputKeys.ENCODING);
 402 
<a name="8" id="anc8"></a><span class="line-modified"> 403         _tohFactory = TransletOutputHandlerFactory.newInstance(_overrideDefaultParser);</span>

 404         _tohFactory.setEncoding(_encoding);
 405         if (_method != null) {
 406             _tohFactory.setOutputMethod(_method);
 407         }
 408 
 409         // Set indentation number in the factory
 410         if (_indentNumber &gt;= 0) {
 411             _tohFactory.setIndentNumber(_indentNumber);
 412         }
 413 
 414         // Return the content handler for this Result object
 415         try {
 416             // Result object could be SAXResult, DOMResult, or StreamResult
 417             if (result instanceof SAXResult) {
 418                 final SAXResult target = (SAXResult)result;
 419                 final ContentHandler handler = target.getHandler();
 420 
 421                 _tohFactory.setHandler(handler);
 422 
 423                 /**
 424                  * Fix for bug 24414
 425                  * If the lexicalHandler is set then we need to get that
 426                  * for obtaining the lexical information
 427                  */
 428                 LexicalHandler lexicalHandler = target.getLexicalHandler();
 429 
 430                 if (lexicalHandler != null ) {
 431                     _tohFactory.setLexicalHandler(lexicalHandler);
 432                 }
 433 
 434                 _tohFactory.setOutputType(TransletOutputHandlerFactory.SAX);
 435                 return _tohFactory.getSerializationHandler();
 436             }
 437             else if (result instanceof StAXResult) {
 438                 if (((StAXResult) result).getXMLEventWriter() != null)
 439                     _tohFactory.setXMLEventWriter(((StAXResult) result).getXMLEventWriter());
 440                 else if (((StAXResult) result).getXMLStreamWriter() != null)
 441                     _tohFactory.setXMLStreamWriter(((StAXResult) result).getXMLStreamWriter());
 442                 _tohFactory.setOutputType(TransletOutputHandlerFactory.STAX);
 443                 return _tohFactory.getSerializationHandler();
 444             }
 445             else if (result instanceof DOMResult) {
 446                 _tohFactory.setNode(((DOMResult) result).getNode());
 447                 _tohFactory.setNextSibling(((DOMResult) result).getNextSibling());
 448                 _tohFactory.setOutputType(TransletOutputHandlerFactory.DOM);
 449                 return _tohFactory.getSerializationHandler();
 450             }
 451             else if (result instanceof StreamResult) {
 452                 // Get StreamResult
 453                 final StreamResult target = (StreamResult) result;
 454 
 455                 // StreamResult may have been created with a java.io.File,
 456                 // java.io.Writer, java.io.OutputStream or just a String
 457                 // systemId.
 458 
 459                 _tohFactory.setOutputType(TransletOutputHandlerFactory.STREAM);
 460 
 461                 // try to get a Writer from Result object
 462                 final Writer writer = target.getWriter();
 463                 if (writer != null) {
 464                     _tohFactory.setWriter(writer);
 465                     return _tohFactory.getSerializationHandler();
 466                 }
 467 
 468                 // or try to get an OutputStream from Result object
 469                 final OutputStream ostream = target.getOutputStream();
 470                 if (ostream != null) {
 471                     _tohFactory.setOutputStream(ostream);
 472                     return _tohFactory.getSerializationHandler();
 473                 }
 474 
 475                 // or try to get just a systemId string from Result object
 476                 String systemId = result.getSystemId();
 477                 if (systemId == null) {
 478                     ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_RESULT_ERR);
 479                     throw new TransformerException(err.toString());
 480                 }
 481 
 482                 // System Id may be in one of several forms, (1) a uri
 483                 // that starts with &#39;file:&#39;, (2) uri that starts with &#39;http:&#39;
 484                 // or (3) just a filename on the local system.
 485                 URL url;
 486                 if (systemId.startsWith(&quot;file:&quot;)) {
 487                     // if StreamResult(File) or setSystemID(File) was used,
 488                     // the systemId will be URI encoded as a result of File.toURI(),
 489                     // it must be decoded for use by URL
 490                     try{
 491                         URI uri = new URI(systemId) ;
 492                         systemId = &quot;file:&quot;;
 493 
 494                         String host = uri.getHost(); // decoded String
 495                         String path = uri.getPath(); //decoded String
 496                         if (path == null) {
 497                          path = &quot;&quot;;
 498                         }
 499 
 500                         // if host (URI authority) then file:// + host + path
 501                         // else just path (may be absolute or relative)
 502                         if (host != null) {
 503                          systemId += &quot;//&quot; + host + path;
 504                         } else {
 505                          systemId += &quot;//&quot; + path;
 506                         }
 507                     }
 508                     catch (Exception  exception) {
 509                         // URI exception which means nothing can be done so OK to ignore
 510                     }
 511 
 512                     url = new URL(systemId);
 513                     _ostream = new FileOutputStream(url.getFile());
 514                     _tohFactory.setOutputStream(_ostream);
 515                     return _tohFactory.getSerializationHandler();
 516                 }
 517                 else if (systemId.startsWith(&quot;http:&quot;)) {
 518                     url = new URL(systemId);
 519                     final URLConnection connection = url.openConnection();
 520                     _tohFactory.setOutputStream(_ostream = connection.getOutputStream());
 521                     return _tohFactory.getSerializationHandler();
 522                 }
 523                 else {
 524                     // system id is just a filename
 525                     _tohFactory.setOutputStream(
 526                         _ostream = new FileOutputStream(new File(systemId)));
 527                     return _tohFactory.getSerializationHandler();
 528                 }
 529             }
 530         }
 531         // If we cannot write to the location specified by the SystemId
 532         catch (UnknownServiceException e) {
 533             throw new TransformerException(e);
 534         }
 535         catch (ParserConfigurationException e) {
 536             throw new TransformerException(e);
 537         }
 538         // If we cannot create the file specified by the SystemId
 539         catch (IOException e) {
 540             throw new TransformerException(e);
 541         }
 542         return null;
 543     }
 544 
 545     /**
 546      * Set the internal DOM that will be used for the next transformation
 547      */
 548     protected void setDOM(DOM dom) {
 549         _dom = dom;
 550     }
 551 
 552     /**
 553      * Builds an internal DOM from a TrAX Source object
 554      */
 555     private DOM getDOM(Source source) throws TransformerException {
 556         try {
 557             DOM dom;
 558 
 559             if (source != null) {
 560                 DTMWSFilter wsfilter;
 561                 if (_translet != null &amp;&amp; _translet instanceof StripFilter) {
 562                     wsfilter = new DOMWSFilter(_translet);
 563                  } else {
 564                     wsfilter = null;
 565                  }
 566 
 567                  boolean hasIdCall = (_translet != null) ? _translet.hasIdCall()
 568                                                          : false;
 569 
 570                  if (_dtmManager == null) {
 571                      _dtmManager =
 572                          _tfactory.createNewDTMManagerInstance();
 573                      _dtmManager.setOverrideDefaultParser(_overrideDefaultParser);
 574                  }
 575                  dom = (DOM)_dtmManager.getDTM(source, false, wsfilter, true,
 576                                               false, false, 0, hasIdCall);
 577             } else if (_dom != null) {
 578                  dom = _dom;
 579                  _dom = null;  // use only once, so reset to &#39;null&#39;
 580             } else {
 581                  return null;
 582             }
 583 
 584             if (!_isIdentity) {
 585                 // Give the translet the opportunity to make a prepass of
 586                 // the document, in case it can extract useful information early
 587                 _translet.prepassDocument(dom);
 588             }
 589 
 590             return dom;
 591 
 592         }
 593         catch (Exception e) {
 594             if (_errorListener != null) {
 595                 postErrorToListener(e.getMessage());
 596             }
 597             throw new TransformerException(e);
 598         }
 599     }
 600 
 601     /**
 602      * Returns the {@link com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl}
 603      * object that create this &lt;code&gt;Transformer&lt;/code&gt;.
 604      */
 605     protected TransformerFactoryImpl getTransformerFactory() {
 606         return _tfactory;
 607     }
 608 
 609     /**
 610      * Returns the {@link com.sun.org.apache.xalan.internal.xsltc.runtime.output.TransletOutputHandlerFactory}
 611      * object that create the &lt;code&gt;TransletOutputHandler&lt;/code&gt;.
 612      */
 613     protected TransletOutputHandlerFactory getTransletOutputHandlerFactory() {
 614         return _tohFactory;
 615     }
 616 
 617     private void transformIdentity(Source source, SerializationHandler handler)
 618         throws Exception
 619     {
 620         // Get systemId from source
 621         if (source != null) {
 622             _sourceSystemId = source.getSystemId();
 623         }
 624 
 625         if (source instanceof StreamSource) {
 626             final StreamSource stream = (StreamSource) source;
 627             final InputStream streamInput = stream.getInputStream();
 628             final Reader streamReader = stream.getReader();
 629             final XMLReader reader = _readerManager.getXMLReader();
 630 
 631             try {
 632                 // Hook up reader and output handler
 633                 try {
 634                     reader.setProperty(LEXICAL_HANDLER_PROPERTY, handler);
 635                     reader.setFeature(NAMESPACE_PREFIXES_FEATURE, true);
 636                 } catch (SAXException e) {
 637                     // Falls through
 638                 }
 639                 reader.setContentHandler(handler);
 640 
 641                 // Create input source from source
 642                 InputSource input;
 643                 if (streamInput != null) {
 644                     input = new InputSource(streamInput);
 645                     input.setSystemId(_sourceSystemId);
 646                 }
 647                 else if (streamReader != null) {
 648                     input = new InputSource(streamReader);
 649                     input.setSystemId(_sourceSystemId);
 650                 }
 651                 else if (_sourceSystemId != null) {
 652                     input = new InputSource(_sourceSystemId);
 653                 }
 654                 else {
 655                     ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);
 656                     throw new TransformerException(err.toString());
 657                 }
 658 
 659                 // Start pushing SAX events
 660                 reader.parse(input);
 661             } finally {
 662                 _readerManager.releaseXMLReader(reader);
 663             }
 664         } else if (source instanceof SAXSource) {
 665             final SAXSource sax = (SAXSource) source;
 666             XMLReader reader = sax.getXMLReader();
 667             final InputSource input = sax.getInputSource();
 668             boolean userReader = true;
 669 
 670             try {
 671                 // Create a reader if not set by user
 672                 if (reader == null) {
 673                     reader = _readerManager.getXMLReader();
 674                     userReader = false;
 675                 }
 676 
 677                 // Hook up reader and output handler
 678                 try {
 679                     reader.setProperty(LEXICAL_HANDLER_PROPERTY, handler);
 680                     reader.setFeature(NAMESPACE_PREFIXES_FEATURE, true);
 681                 } catch (SAXException e) {
 682                     // Falls through
 683                 }
 684                 reader.setContentHandler(handler);
 685 
 686                 // Start pushing SAX events
 687                 reader.parse(input);
 688             } finally {
 689                 if (!userReader) {
 690                     _readerManager.releaseXMLReader(reader);
 691                 }
 692             }
 693         } else if (source instanceof StAXSource) {
 694             final StAXSource staxSource = (StAXSource)source;
 695             StAXEvent2SAX staxevent2sax;
 696             StAXStream2SAX staxStream2SAX;
 697             if (staxSource.getXMLEventReader() != null) {
 698                 final XMLEventReader xmlEventReader = staxSource.getXMLEventReader();
 699                 staxevent2sax = new StAXEvent2SAX(xmlEventReader);
 700                 staxevent2sax.setContentHandler(handler);
 701                 staxevent2sax.parse();
 702                 handler.flushPending();
 703             } else if (staxSource.getXMLStreamReader() != null) {
 704                 final XMLStreamReader xmlStreamReader = staxSource.getXMLStreamReader();
 705                 staxStream2SAX = new StAXStream2SAX(xmlStreamReader);
 706                 staxStream2SAX.setContentHandler(handler);
 707                 staxStream2SAX.parse();
 708                 handler.flushPending();
 709             }
 710         } else if (source instanceof DOMSource) {
 711             final DOMSource domsrc = (DOMSource) source;
 712             new DOM2TO(domsrc.getNode(), handler).parse();
 713         } else if (source instanceof XSLTCSource) {
 714             final DOM dom = ((XSLTCSource) source).getDOM(null, _translet);
 715             ((SAXImpl)dom).copy(handler);
 716         } else {
 717             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);
 718             throw new TransformerException(err.toString());
 719         }
 720     }
 721 
 722     /**
 723      * Internal transformation method - uses the internal APIs of XSLTC
 724      */
 725     private void transform(Source source, SerializationHandler handler,
 726         String encoding) throws TransformerException
 727     {
 728         try {
 729             /*
 730              * According to JAXP1.2, new SAXSource()/StreamSource()
 731              * should create an empty input tree, with a default root node.
 732              * new DOMSource()creates an empty document using DocumentBuilder.
 733              * newDocument(); Use DocumentBuilder.newDocument() for all 3
 734              * situations, since there is no clear spec. how to create
 735              * an empty tree when both SAXSource() and StreamSource() are used.
 736              */
 737             if ((source instanceof StreamSource &amp;&amp; source.getSystemId()==null
 738                 &amp;&amp; ((StreamSource)source).getInputStream()==null &amp;&amp;
 739                 ((StreamSource)source).getReader()==null)||
 740                 (source instanceof SAXSource &amp;&amp;
 741                 ((SAXSource)source).getInputSource()==null &amp;&amp;
 742                 ((SAXSource)source).getXMLReader()==null )||
 743                 (source instanceof DOMSource &amp;&amp;
 744                 ((DOMSource)source).getNode()==null)){
 745 
 746                 boolean supportCatalog = true;
 747 
 748                 DocumentBuilderFactory builderF = JdkXmlUtils.getDOMFactory(_overrideDefaultParser);
 749                 try {
 750                     builderF.setFeature(XMLConstants.USE_CATALOG, _useCatalog);
 751                 } catch (ParserConfigurationException e) {
 752                     supportCatalog = false;
 753                 }
 754 
 755                 if (supportCatalog &amp;&amp; _useCatalog) {
 756                     CatalogFeatures cf = (CatalogFeatures)_tfactory.getAttribute(JdkXmlFeatures.CATALOG_FEATURES);
 757                     if (cf != null) {
 758                         for (CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {
 759                             builderF.setAttribute(f.getPropertyName(), cf.get(f));
 760                         }
 761                     }
 762                 }
 763 
 764                 DocumentBuilder builder = builderF.newDocumentBuilder();
 765                 String systemID = source.getSystemId();
 766                 source = new DOMSource(builder.newDocument());
 767 
 768                 // Copy system ID from original, empty Source to new
 769                 if (systemID != null) {
 770                   source.setSystemId(systemID);
 771                 }
 772             }
 773             if (_isIdentity) {
 774                 transformIdentity(source, handler);
 775             } else {
 776                 _translet.transform(getDOM(source), handler);
 777             }
 778         } catch (TransletException e) {
 779             if (_errorListener != null) postErrorToListener(e.getMessage());
 780             throw new TransformerException(e);
 781         } catch (RuntimeException e) {
 782             if (_errorListener != null) postErrorToListener(e.getMessage());
 783             throw new TransformerException(e);
 784         } catch (Exception e) {
 785             if (_errorListener != null) postErrorToListener(e.getMessage());
 786             throw new TransformerException(e);
 787         } finally {
 788             _dtmManager = null;
 789         }
 790 
 791         // If we create an output stream for the Result, we need to close it after the transformation.
 792         if (_ostream != null) {
 793             try {
 794                 _ostream.close();
 795             }
 796             catch (IOException e) {}
 797             _ostream = null;
 798         }
 799     }
 800 
 801     /**
 802      * Implements JAXP&#39;s Transformer.getErrorListener()
 803      * Get the error event handler in effect for the transformation.
 804      *
 805      * @return The error event handler currently in effect
 806      */
 807     @Override
 808     public ErrorListener getErrorListener() {
 809         return _errorListener;
 810     }
 811 
 812     /**
 813      * Implements JAXP&#39;s Transformer.setErrorListener()
 814      * Set the error event listener in effect for the transformation.
 815      * Register a message handler in the translet in order to forward
 816      * xsl:messages to error listener.
 817      *
 818      * @param listener The error event listener to use
 819      * @throws IllegalArgumentException
 820      */
 821     @Override
 822     public void setErrorListener(ErrorListener listener)
 823         throws IllegalArgumentException {
 824         if (listener == null) {
 825             ErrorMsg err = new ErrorMsg(ErrorMsg.ERROR_LISTENER_NULL_ERR,
 826                                         &quot;Transformer&quot;);
 827             throw new IllegalArgumentException(err.toString());
 828         }
 829         _errorListener = listener;
 830 
 831         // Register a message handler to report xsl:messages
<a name="9" id="anc9"></a><span class="line-modified"> 832     if (_translet != null)</span>
<span class="line-modified"> 833         _translet.setMessageHandler(new MessageHandler(_errorListener));</span>
 834     }
 835 
 836     /**
 837      * Inform TrAX error listener of an error
 838      */
 839     private void postErrorToListener(String message) {
 840         try {
 841             _errorListener.error(new TransformerException(message));
 842         }
 843         catch (TransformerException e) {
 844             // ignored - transformation cannot be continued
 845         }
 846     }
 847 
 848     /**
 849      * Inform TrAX error listener of a warning
 850      */
 851     private void postWarningToListener(String message) {
 852         try {
 853             _errorListener.warning(new TransformerException(message));
 854         }
 855         catch (TransformerException e) {
 856             // ignored - transformation cannot be continued
 857         }
 858     }
 859 
 860     /**
 861      * Implements JAXP&#39;s Transformer.getOutputProperties().
 862      * Returns a copy of the output properties for the transformation. This is
 863      * a set of layered properties. The first layer contains properties set by
 864      * calls to setOutputProperty() and setOutputProperties() on this class,
 865      * and the output settings defined in the stylesheet&#39;s &lt;xsl:output&gt;
 866      * element makes up the second level, while the default XSLT output
 867      * settings are returned on the third level.
 868      *
 869      * @return Properties in effect for this Transformer
 870      */
 871     @Override
 872     public Properties getOutputProperties() {
 873         return (Properties) _properties.clone();
 874     }
 875 
 876     /**
 877      * Implements JAXP&#39;s Transformer.getOutputProperty().
 878      * Get an output property that is in effect for the transformation. The
 879      * property specified may be a property that was set with setOutputProperty,
 880      * or it may be a property specified in the stylesheet.
 881      *
 882      * @param name A non-null string that contains the name of the property
 883      * @throws IllegalArgumentException if the property name is not known
 884      */
 885     @Override
 886     public String getOutputProperty(String name)
 887         throws IllegalArgumentException
 888     {
 889         if (!validOutputProperty(name)) {
 890             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
 891             throw new IllegalArgumentException(err.toString());
 892         }
 893         return _properties.getProperty(name);
 894     }
 895 
 896     /**
 897      * Implements JAXP&#39;s Transformer.setOutputProperties().
 898      * Set the output properties for the transformation. These properties
 899      * will override properties set in the Templates with xsl:output.
 900      * Unrecognised properties will be quitely ignored.
 901      *
 902      * @param properties The properties to use for the Transformer
 903      * @throws IllegalArgumentException Never, errors are ignored
 904      */
 905     @Override
 906     public void setOutputProperties(Properties properties)
 907         throws IllegalArgumentException
 908     {
 909         if (properties != null) {
 910             final Enumeration&lt;?&gt; names = properties.propertyNames();
 911 
 912             while (names.hasMoreElements()) {
 913                 final String name = (String) names.nextElement();
 914 
 915                 // Ignore lower layer properties
 916                 if (isDefaultProperty(name, properties)) continue;
 917 
 918                 if (validOutputProperty(name)) {
 919                     _properties.setProperty(name, properties.getProperty(name));
 920                 }
 921                 else {
 922                     ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
 923                     throw new IllegalArgumentException(err.toString());
 924                 }
 925             }
 926         }
 927         else {
 928             _properties = (Properties)_propertiesClone.clone();
 929         }
 930     }
 931 
 932     /**
 933      * Implements JAXP&#39;s Transformer.setOutputProperty().
 934      * Get an output property that is in effect for the transformation. The
 935      * property specified may be a property that was set with
 936      * setOutputProperty(), or it may be a property specified in the stylesheet.
 937      *
 938      * @param name The name of the property to set
 939      * @param value The value to assign to the property
 940      * @throws IllegalArgumentException Never, errors are ignored
 941      */
 942     @Override
 943     public void setOutputProperty(String name, String value)
 944         throws IllegalArgumentException
 945     {
 946         if (!validOutputProperty(name)) {
 947             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
 948             throw new IllegalArgumentException(err.toString());
 949         }
 950         _properties.setProperty(name, value);
 951     }
 952 
 953     /**
 954      * Internal method to pass any properties to the translet prior to
 955      * initiating the transformation
 956      */
 957     private void transferOutputProperties(AbstractTranslet translet)
 958     {
 959         // Return right now if no properties are set
 960         if (_properties == null) return;
 961 
 962         // Get a list of all the defined properties
 963         Enumeration&lt;?&gt; names = _properties.propertyNames();
 964         while (names.hasMoreElements()) {
 965             // Note the use of get() instead of getProperty()
 966             String name  = (String) names.nextElement();
 967             String value = (String) _properties.get(name);
 968 
 969             // Ignore default properties
 970             if (value == null) continue;
 971 
 972             // Pass property value to translet - override previous setting
 973             if (name.equals(OutputKeys.ENCODING)) {
 974                 translet._encoding = value;
 975             }
 976             else if (name.equals(OutputKeys.METHOD)) {
 977                 translet._method = value;
 978             }
 979             else if (name.equals(OutputKeys.DOCTYPE_PUBLIC)) {
 980                 translet._doctypePublic = value;
 981             }
 982             else if (name.equals(OutputKeys.DOCTYPE_SYSTEM)) {
 983                 translet._doctypeSystem = value;
 984             }
 985             else if (name.equals(OutputKeys.MEDIA_TYPE)) {
 986                 translet._mediaType = value;
 987             }
 988             else if (name.equals(OutputKeys.STANDALONE)) {
 989                 translet._standalone = value;
 990             }
 991             else if (name.equals(OutputKeys.VERSION)) {
 992                 translet._version = value;
 993             }
 994             else if (name.equals(OutputKeys.OMIT_XML_DECLARATION)) {
 995                 translet._omitHeader =
 996                     (value != null &amp;&amp; value.toLowerCase().equals(&quot;yes&quot;));
 997             }
 998             else if (name.equals(OutputKeys.INDENT)) {
 999                 translet._indent =
1000                     (value != null &amp;&amp; value.toLowerCase().equals(&quot;yes&quot;));
1001             }
1002             else if (name.equals(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL +&quot;indent-amount&quot;)) {
1003                  if (value != null) {
1004                      translet._indentamount = Integer.parseInt(value);
1005                  }
1006             }
1007             else if (name.equals(OutputPropertiesFactory.S_BUILTIN_EXTENSIONS_UNIVERSAL +&quot;indent-amount&quot;)) {
1008                  if (value != null) {
1009                      translet._indentamount = Integer.parseInt(value);
1010                  }
1011             }
1012             else if (name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)) {
1013                 if (value != null) {
1014                     translet._cdata = null; // clear previous setting
1015                     StringTokenizer e = new StringTokenizer(value);
1016                     while (e.hasMoreTokens()) {
1017                         translet.addCdataElement(e.nextToken());
1018                     }
1019                 }
1020             }
1021             else if (name.equals(OutputPropertiesFactory.ORACLE_IS_STANDALONE)) {
1022                  if (value != null &amp;&amp; value.equals(&quot;yes&quot;)) {
1023                      translet._isStandalone = true;
1024                  }
1025             }
1026         }
1027     }
1028 
1029     /**
1030      * This method is used to pass any properties to the output handler
1031      * when running the identity transform.
1032      */
1033     public void transferOutputProperties(SerializationHandler handler)
1034     {
1035         // Return right now if no properties are set
1036         if (_properties == null) return;
1037 
1038         String doctypePublic = null;
1039         String doctypeSystem = null;
1040 
1041         // Get a list of all the defined properties
1042         Enumeration&lt;?&gt; names = _properties.propertyNames();
1043         while (names.hasMoreElements()) {
1044             // Note the use of get() instead of getProperty()
1045             String name  = (String) names.nextElement();
1046             String value = (String) _properties.get(name);
1047 
1048             // Ignore default properties
1049             if (value == null) continue;
1050 
1051             // Pass property value to translet - override previous setting
1052             if (name.equals(OutputKeys.DOCTYPE_PUBLIC)) {
1053                 doctypePublic = value;
1054             }
1055             else if (name.equals(OutputKeys.DOCTYPE_SYSTEM)) {
1056                 doctypeSystem = value;
1057             }
1058             else if (name.equals(OutputKeys.MEDIA_TYPE)) {
1059                 handler.setMediaType(value);
1060             }
1061             else if (name.equals(OutputKeys.STANDALONE)) {
1062                 handler.setStandalone(value);
1063             }
1064             else if (name.equals(OutputKeys.VERSION)) {
1065                 handler.setVersion(value);
1066             }
1067             else if (name.equals(OutputKeys.OMIT_XML_DECLARATION)) {
1068                 handler.setOmitXMLDeclaration(
1069                     value != null &amp;&amp; value.toLowerCase().equals(&quot;yes&quot;));
1070             }
1071             else if (name.equals(OutputKeys.INDENT)) {
1072                 handler.setIndent(
1073                     value != null &amp;&amp; value.toLowerCase().equals(&quot;yes&quot;));
1074             }
1075             else if (name.equals(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL +&quot;indent-amount&quot;)) {
1076                 if (value != null) {
1077                     handler.setIndentAmount(Integer.parseInt(value));
1078                 }
1079             }
1080             else if (name.equals(OutputPropertiesFactory.S_BUILTIN_EXTENSIONS_UNIVERSAL +&quot;indent-amount&quot;)) {
1081                 if (value != null) {
1082                     handler.setIndentAmount(Integer.parseInt(value));
1083                 }
1084             }
1085             else if (name.equals(OutputPropertiesFactory.ORACLE_IS_STANDALONE)) {
1086                 if (value != null &amp;&amp; value.equals(&quot;yes&quot;)) {
1087                     handler.setIsStandalone(true);
1088                 }
1089             }
1090             else if (name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)) {
1091                 if (value != null) {
1092                     StringTokenizer e = new StringTokenizer(value);
1093                     List&lt;String&gt; uriAndLocalNames = null;
1094                     while (e.hasMoreTokens()) {
1095                         final String token = e.nextToken();
1096 
1097                         // look for the last colon, as the String may be
1098                         // something like &quot;http://abc.com:local&quot;
1099                         int lastcolon = token.lastIndexOf(&#39;:&#39;);
1100                         String uri;
1101                         String localName;
1102                         if (lastcolon &gt; 0) {
1103                             uri = token.substring(0, lastcolon);
1104                             localName = token.substring(lastcolon+1);
1105                         } else {
1106                             // no colon at all, lets hope this is the
1107                             // local name itself then
1108                             uri = null;
1109                             localName = token;
1110                         }
1111 
1112                         if (uriAndLocalNames == null) {
1113                             uriAndLocalNames = new ArrayList&lt;&gt;();
1114                         }
1115                         // add the uri/localName as a pair, in that order
1116                         uriAndLocalNames.add(uri);
1117                         uriAndLocalNames.add(localName);
1118                     }
1119                     handler.setCdataSectionElements(uriAndLocalNames);
1120                 }
1121             }
1122         }
1123 
1124         // Call setDoctype() if needed
1125         if (doctypePublic != null || doctypeSystem != null) {
1126             handler.setDoctype(doctypeSystem, doctypePublic);
1127         }
1128     }
1129 
1130     /**
1131      * Internal method to create the initial set of properties. There
1132      * are two layers of properties: the default layer and the base layer.
1133      * The latter contains properties defined in the stylesheet or by
1134      * the user using this API.
1135      */
1136     private Properties createOutputProperties(Properties outputProperties) {
1137         final Properties defaults = new Properties();
1138         setDefaults(defaults, &quot;xml&quot;);
1139 
1140         // Copy propeties set in stylesheet to base
1141         final Properties base = new Properties(defaults);
1142         if (outputProperties != null) {
1143             final Enumeration&lt;?&gt; names = outputProperties.propertyNames();
1144             while (names.hasMoreElements()) {
1145                 final String name = (String) names.nextElement();
1146                 base.setProperty(name, outputProperties.getProperty(name));
1147             }
1148         }
1149         else {
1150             base.setProperty(OutputKeys.ENCODING, _translet._encoding);
1151             if (_translet._method != null)
1152                 base.setProperty(OutputKeys.METHOD, _translet._method);
1153         }
1154 
1155         // Update defaults based on output method
1156         final String method = base.getProperty(OutputKeys.METHOD);
1157         if (method != null) {
1158             if (method.equals(&quot;html&quot;)) {
1159                 setDefaults(defaults,&quot;html&quot;);
1160             }
1161             else if (method.equals(&quot;text&quot;)) {
1162                 setDefaults(defaults,&quot;text&quot;);
1163             }
1164         }
1165 
1166         return base;
1167     }
1168 
1169         /**
1170          * Internal method to get the default properties from the
1171          * serializer factory and set them on the property object.
1172          * @param props a java.util.Property object on which the properties are set.
1173          * @param method The output method type, one of &quot;xml&quot;, &quot;text&quot;, &quot;html&quot; ...
1174          */
1175         private void setDefaults(Properties props, String method)
1176         {
1177                 final Properties method_props =
1178                         OutputPropertiesFactory.getDefaultMethodProperties(method);
1179                 {
1180                     final Enumeration&lt;?&gt; names = method_props.propertyNames();
1181                     while (names.hasMoreElements())
1182                     {
1183                         final String name = (String)names.nextElement();
1184                         props.setProperty(name, method_props.getProperty(name));
1185                     }
1186                 }
1187         }
1188     /**
1189      * Verifies if a given output property name is a property defined in
1190      * the JAXP 1.1 / TrAX spec
1191      */
1192     private boolean validOutputProperty(String name) {
1193         return (name.equals(OutputKeys.ENCODING) ||
1194                 name.equals(OutputKeys.METHOD) ||
1195                 name.equals(OutputKeys.INDENT) ||
1196                 name.equals(OutputKeys.DOCTYPE_PUBLIC) ||
1197                 name.equals(OutputKeys.DOCTYPE_SYSTEM) ||
1198                 name.equals(OutputKeys.CDATA_SECTION_ELEMENTS) ||
1199                 name.equals(OutputKeys.MEDIA_TYPE) ||
1200                 name.equals(OutputKeys.OMIT_XML_DECLARATION)   ||
1201                 name.equals(OutputKeys.STANDALONE) ||
1202                 name.equals(OutputKeys.VERSION) ||
1203                 name.equals(OutputPropertiesFactory.ORACLE_IS_STANDALONE) ||
1204                 name.charAt(0) == &#39;{&#39;);
1205     }
1206 
1207     /**
1208      * Checks if a given output property is default (2nd layer only)
1209      */
1210     private boolean isDefaultProperty(String name, Properties properties) {
1211         return (properties.get(name) == null);
1212     }
1213 
1214     /**
1215      * Implements JAXP&#39;s Transformer.setParameter()
1216      * Add a parameter for the transformation. The parameter is simply passed
1217      * on to the translet - no validation is performed - so any unused
1218      * parameters are quitely ignored by the translet.
1219      *
1220      * @param name The name of the parameter
1221      * @param value The value to assign to the parameter
1222      */
1223     @Override
1224     public void setParameter(String name, Object value) {
1225 
1226         if (value == null) {
1227             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_INVALID_SET_PARAM_VALUE, name);
1228             throw new IllegalArgumentException(err.toString());
1229         }
1230 
1231         if (_isIdentity) {
1232             if (_parameters == null) {
1233                 _parameters = new HashMap&lt;&gt;();
1234             }
1235             _parameters.put(name, value);
1236         }
1237         else {
1238             _translet.addParameter(name, value);
1239         }
1240     }
1241 
1242     /**
1243      * Implements JAXP&#39;s Transformer.clearParameters()
1244      * Clear all parameters set with setParameter. Clears the translet&#39;s
1245      * parameter stack.
1246      */
1247     @Override
1248     public void clearParameters() {
1249         if (_isIdentity &amp;&amp; _parameters != null) {
1250             _parameters.clear();
1251         }
1252         else {
1253             _translet.clearParameters();
1254         }
1255     }
1256 
1257     /**
1258      * Implements JAXP&#39;s Transformer.getParameter()
1259      * Returns the value of a given parameter. Note that the translet will not
1260      * keep values for parameters that were not defined in the stylesheet.
1261      *
1262      * @param name The name of the parameter
1263      * @return An object that contains the value assigned to the parameter
1264      */
1265     @Override
1266     public final Object getParameter(String name) {
1267         if (_isIdentity) {
1268             return (_parameters != null) ? _parameters.get(name) : null;
1269         }
1270         else {
1271             return _translet.getParameter(name);
1272         }
1273     }
1274 
1275     /**
1276      * Implements JAXP&#39;s Transformer.getURIResolver()
1277      * Set the object currently used to resolve URIs used in document().
1278      *
1279      * @return  The URLResolver object currently in use
1280      */
1281     @Override
1282     public URIResolver getURIResolver() {
1283         return _uriResolver;
1284     }
1285 
1286     /**
1287      * Implements JAXP&#39;s Transformer.setURIResolver()
1288      * Set an object that will be used to resolve URIs used in document().
1289      *
1290      * @param resolver The URIResolver to use in document()
1291      */
1292     @Override
1293     public void setURIResolver(URIResolver resolver) {
1294         _uriResolver = resolver;
1295     }
1296 
1297     /**
1298      * This class should only be used as a DOMCache for the translet if the
1299      * URIResolver has been set.
1300      *
1301      * The method implements XSLTC&#39;s DOMCache interface, which is used to
1302      * plug in an external document loader into a translet. This method acts
1303      * as an adapter between TrAX&#39;s URIResolver interface and XSLTC&#39;s
1304      * DOMCache interface. This approach is simple, but removes the
1305      * possibility of using external document caches with XSLTC.
1306      *
1307      * @param baseURI The base URI used by the document call.
1308      * @param href The href argument passed to the document function.
1309      * @param translet A reference to the translet requesting the document
1310      */
1311     @Override
1312     public DOM retrieveDocument(String baseURI, String href, Translet translet) {
1313         try {
1314             // Argument to document function was: document(&#39;&#39;);
1315             if (href.length() == 0) {
1316                 href = baseURI;
1317             }
1318 
1319             /*
1320              *  Fix for bug 24188
1321              *  Incase the _uriResolver.resolve(href,base) is null
1322              *  try to still  retrieve the document before returning null
1323              *  and throwing the FileNotFoundException in
1324              *  com.sun.org.apache.xalan.internal.xsltc.dom.LoadDocument
1325              *
1326              */
1327             Source resolvedSource = null;
1328             if (_uriResolver != null) {
1329                 resolvedSource = _uriResolver.resolve(href, baseURI);
1330             }
1331 
1332             if (resolvedSource == null &amp;&amp; _useCatalog &amp;&amp;
1333                     _catalogFeatures.get(CatalogFeatures.Feature.FILES) != null)  {
1334                 if (_catalogUriResolver == null) {
1335                     _catalogUriResolver = CatalogManager.catalogResolver(_catalogFeatures);
1336                 }
1337                 resolvedSource = _catalogUriResolver.resolve(href, baseURI);
1338             }
1339 
1340             if (resolvedSource == null)  {
1341                 StreamSource streamSource = new StreamSource(
1342                      SystemIDResolver.getAbsoluteURI(href, baseURI));
1343                 return getDOM(streamSource) ;
1344             }
1345 
1346             return getDOM(resolvedSource);
1347         }
1348         catch (TransformerException | CatalogException e) {
1349             if (_errorListener != null)
1350                 postErrorToListener(&quot;File not found: &quot; + e.getMessage());
1351             return(null);
1352         }
1353     }
1354 
<a name="10" id="anc10"></a><span class="line-removed">1355     /**</span>
<span class="line-removed">1356      * Receive notification of a recoverable error.</span>
<span class="line-removed">1357      * The transformer must continue to provide normal parsing events after</span>
<span class="line-removed">1358      * invoking this method. It should still be possible for the application</span>
<span class="line-removed">1359      * to process the document through to the end.</span>
<span class="line-removed">1360      *</span>
<span class="line-removed">1361      * @param e The warning information encapsulated in a transformer</span>
<span class="line-removed">1362      * exception.</span>
<span class="line-removed">1363      * @throws TransformerException if the application chooses to discontinue</span>
<span class="line-removed">1364      * the transformation (always does in our case).</span>
<span class="line-removed">1365      */</span>
<span class="line-removed">1366     @Override</span>
<span class="line-removed">1367     public void error(TransformerException e)</span>
<span class="line-removed">1368         throws TransformerException</span>
<span class="line-removed">1369     {</span>
<span class="line-removed">1370         Throwable wrapped = e.getException();</span>
<span class="line-removed">1371         if (wrapped != null) {</span>
<span class="line-removed">1372             System.err.println(new ErrorMsg(ErrorMsg.ERROR_PLUS_WRAPPED_MSG,</span>
<span class="line-removed">1373                                             e.getMessageAndLocation(),</span>
<span class="line-removed">1374                                             wrapped.getMessage()));</span>
<span class="line-removed">1375         } else {</span>
<span class="line-removed">1376             System.err.println(new ErrorMsg(ErrorMsg.ERROR_MSG,</span>
<span class="line-removed">1377                                             e.getMessageAndLocation()));</span>
<span class="line-removed">1378         }</span>
<span class="line-removed">1379         throw e;</span>
<span class="line-removed">1380     }</span>
<span class="line-removed">1381 </span>
<span class="line-removed">1382     /**</span>
<span class="line-removed">1383      * Receive notification of a non-recoverable error.</span>
<span class="line-removed">1384      * The application must assume that the transformation cannot continue</span>
<span class="line-removed">1385      * after the Transformer has invoked this method, and should continue</span>
<span class="line-removed">1386      * (if at all) only to collect addition error messages. In fact,</span>
<span class="line-removed">1387      * Transformers are free to stop reporting events once this method has</span>
<span class="line-removed">1388      * been invoked.</span>
<span class="line-removed">1389      *</span>
<span class="line-removed">1390      * @param e The warning information encapsulated in a transformer</span>
<span class="line-removed">1391      * exception.</span>
<span class="line-removed">1392      * @throws TransformerException if the application chooses to discontinue</span>
<span class="line-removed">1393      * the transformation (always does in our case).</span>
<span class="line-removed">1394      */</span>
<span class="line-removed">1395     @Override</span>
<span class="line-removed">1396     public void fatalError(TransformerException e)</span>
<span class="line-removed">1397         throws TransformerException</span>
<span class="line-removed">1398     {</span>
<span class="line-removed">1399         Throwable wrapped = e.getException();</span>
<span class="line-removed">1400         if (wrapped != null) {</span>
<span class="line-removed">1401             System.err.println(new ErrorMsg(ErrorMsg.FATAL_ERR_PLUS_WRAPPED_MSG,</span>
<span class="line-removed">1402                                             e.getMessageAndLocation(),</span>
<span class="line-removed">1403                                             wrapped.getMessage()));</span>
<span class="line-removed">1404         } else {</span>
<span class="line-removed">1405             System.err.println(new ErrorMsg(ErrorMsg.FATAL_ERR_MSG,</span>
<span class="line-removed">1406                                             e.getMessageAndLocation()));</span>
<span class="line-removed">1407         }</span>
<span class="line-removed">1408         throw e;</span>
<span class="line-removed">1409     }</span>
<span class="line-removed">1410 </span>
<span class="line-removed">1411     /**</span>
<span class="line-removed">1412      * Receive notification of a warning.</span>
<span class="line-removed">1413      * Transformers can use this method to report conditions that are not</span>
<span class="line-removed">1414      * errors or fatal errors. The default behaviour is to take no action.</span>
<span class="line-removed">1415      * After invoking this method, the Transformer must continue with the</span>
<span class="line-removed">1416      * transformation. It should still be possible for the application to</span>
<span class="line-removed">1417      * process the document through to the end.</span>
<span class="line-removed">1418      *</span>
<span class="line-removed">1419      * @param e The warning information encapsulated in a transformer</span>
<span class="line-removed">1420      * exception.</span>
<span class="line-removed">1421      * @throws TransformerException if the application chooses to discontinue</span>
<span class="line-removed">1422      * the transformation (never does in our case).</span>
<span class="line-removed">1423      */</span>
<span class="line-removed">1424     @Override</span>
<span class="line-removed">1425     public void warning(TransformerException e)</span>
<span class="line-removed">1426         throws TransformerException</span>
<span class="line-removed">1427     {</span>
<span class="line-removed">1428         Throwable wrapped = e.getException();</span>
<span class="line-removed">1429         if (wrapped != null) {</span>
<span class="line-removed">1430             System.err.println(new ErrorMsg(ErrorMsg.WARNING_PLUS_WRAPPED_MSG,</span>
<span class="line-removed">1431                                             e.getMessageAndLocation(),</span>
<span class="line-removed">1432                                             wrapped.getMessage()));</span>
<span class="line-removed">1433         } else {</span>
<span class="line-removed">1434             System.err.println(new ErrorMsg(ErrorMsg.WARNING_MSG,</span>
<span class="line-removed">1435                                             e.getMessageAndLocation()));</span>
<span class="line-removed">1436         }</span>
<span class="line-removed">1437     }</span>
<span class="line-removed">1438 </span>
1439     /**
1440      * This method resets  the Transformer to its original configuration
1441      * Transformer code is reset to the same state it was when it was
1442      * created
1443      * @since 1.5
1444      */
1445     @Override
1446     public void reset() {
1447 
1448         _method = null;
1449         _encoding = null;
1450         _sourceSystemId = null;
<a name="11" id="anc11"></a><span class="line-modified">1451         _errorListener = this;</span>
1452         _uriResolver = null;
1453         _dom = null;
1454         _parameters = null;
1455         _indentNumber = -1;
1456         setOutputProperties (null);
1457         _tohFactory = null;
1458         _ostream = null;
1459 
1460     }
1461 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
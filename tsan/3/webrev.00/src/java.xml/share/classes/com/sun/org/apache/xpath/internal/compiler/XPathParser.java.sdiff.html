<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xpath/internal/compiler/XPathParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Compiler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../res/XPATHErrorResources.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xpath/internal/compiler/XPathParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xpath.internal.compiler;
  22 
  23 import javax.xml.transform.ErrorListener;
  24 import javax.xml.transform.TransformerException;
  25 
  26 import com.sun.org.apache.xalan.internal.res.XSLMessages;
  27 import com.sun.org.apache.xml.internal.utils.PrefixResolver;
  28 import com.sun.org.apache.xpath.internal.XPathProcessorException;
  29 import com.sun.org.apache.xpath.internal.objects.XNumber;
  30 import com.sun.org.apache.xpath.internal.objects.XString;
  31 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
  32 
  33 /**
  34  * Tokenizes and parses XPath expressions. This should really be named
  35  * XPathParserImpl, and may be renamed in the future.
  36  * @xsl.usage general

  37  */
  38 public class XPathParser
  39 {
  40         // %REVIEW% Is there a better way of doing this?
  41         // Upside is minimum object churn. Downside is that we don&#39;t have a useful
  42         // backtrace in the exception itself -- but we don&#39;t expect to need one.
  43         static public final String CONTINUE_AFTER_FATAL_ERROR=&quot;CONTINUE_AFTER_FATAL_ERROR&quot;;
  44 
  45   /**
  46    * The XPath to be processed.
  47    */
  48   private OpMap m_ops;
  49 
  50   /**
  51    * The next token in the pattern.
  52    */
  53   transient String m_token;
  54 
  55   /**
  56    * The first char in m_token, the theory being that this
  57    * is an optimization because we won&#39;t have to do charAt(0) as
  58    * often.
  59    */
  60   transient char m_tokenChar = 0;
  61 
  62   /**
  63    * The position in the token queue is tracked by m_queueMark.
  64    */
  65   int m_queueMark = 0;
  66 
  67   /**
  68    * Results from checking FilterExpr syntax
  69    */
  70   protected final static int FILTER_MATCH_FAILED     = 0;
  71   protected final static int FILTER_MATCH_PRIMARY    = 1;
  72   protected final static int FILTER_MATCH_PREDICATES = 2;
  73 



  74   /**
  75    * The parser constructor.
  76    */
  77   public XPathParser(ErrorListener errorListener, javax.xml.transform.SourceLocator sourceLocator)
  78   {
  79     m_errorListener = errorListener;
  80     m_sourceLocator = sourceLocator;
  81   }
  82 
  83   /**
  84    * The prefix resolver to map prefixes to namespaces in the OpMap.
  85    */
  86   PrefixResolver m_namespaceContext;
  87 
  88   /**
  89    * Given an string, init an XPath object for selections,
  90    * in order that a parse doesn&#39;t
  91    * have to be done each time the expression is evaluated.
  92    *
  93    * @param compiler The compiler object.
</pre>
<hr />
<pre>
 140           if (null != m_token)
 141             extraTokens += &quot;, &quot;;
 142         }
 143 
 144         error(XPATHErrorResources.ER_EXTRA_ILLEGAL_TOKENS,
 145               new Object[]{ extraTokens });  //&quot;Extra illegal tokens: &quot;+extraTokens);
 146       }
 147 
 148     }
 149     catch (com.sun.org.apache.xpath.internal.XPathProcessorException e)
 150     {
 151           if(CONTINUE_AFTER_FATAL_ERROR.equals(e.getMessage()))
 152           {
 153                 // What I _want_ to do is null out this XPath.
 154                 // I doubt this has the desired effect, but I&#39;m not sure what else to do.
 155                 // %REVIEW%!!!
 156                 initXPath(compiler, &quot;/..&quot;,  namespaceContext);
 157           }
 158           else
 159                 throw e;



 160     }
 161 
 162     compiler.shrink();
 163   }
 164 
 165   /**
 166    * Given an string, init an XPath object for pattern matches,
 167    * in order that a parse doesn&#39;t
 168    * have to be done each time the expression is evaluated.
 169    * @param compiler The XPath object to be initialized.
 170    * @param expression A String representing the XPath.
 171    * @param namespaceContext An object that is able to resolve prefixes in
 172    * the XPath to namespaces.
 173    *
 174    * @throws javax.xml.transform.TransformerException
 175    */
 176   public void initMatchPattern(
 177           Compiler compiler, String expression, PrefixResolver namespaceContext)
 178             throws javax.xml.transform.TransformerException
 179   {
 180 
 181     m_ops = compiler;
 182     m_namespaceContext = namespaceContext;
 183     m_functionTable = compiler.getFunctionTable();
 184 
 185     Lexer lexer = new Lexer(compiler, namespaceContext, this);
 186 
 187     lexer.tokenize(expression);
 188 
 189     m_ops.setOp(0, OpCodes.OP_MATCHPATTERN);
 190     m_ops.setOp(OpMap.MAPINDEX_LENGTH, 2);
 191 
 192     nextToken();
<span class="line-modified"> 193     Pattern();</span>





 194 
 195     if (null != m_token)
 196     {
 197       String extraTokens = &quot;&quot;;
 198 
 199       while (null != m_token)
 200       {
 201         extraTokens += &quot;&#39;&quot; + m_token + &quot;&#39;&quot;;
 202 
 203         nextToken();
 204 
 205         if (null != m_token)
 206           extraTokens += &quot;, &quot;;
 207       }
 208 
 209       error(XPATHErrorResources.ER_EXTRA_ILLEGAL_TOKENS,
 210             new Object[]{ extraTokens });  //&quot;Extra illegal tokens: &quot;+extraTokens);
 211     }
 212 
 213     // Terminate for safety.
</pre>
<hr />
<pre>
 724 
 725     int totalLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 726 
 727     m_ops.setOp(totalLen, op);
 728     m_ops.setOp(totalLen + OpMap.MAPINDEX_LENGTH, length);
 729     m_ops.setOp(OpMap.MAPINDEX_LENGTH, totalLen + length);
 730   }
 731 
 732   // ============= EXPRESSIONS FUNCTIONS =================
 733 
 734   /**
 735    *
 736    *
 737    * Expr  ::=  OrExpr
 738    *
 739    *
 740    * @throws javax.xml.transform.TransformerException
 741    */
 742   protected void Expr() throws javax.xml.transform.TransformerException
 743   {
<span class="line-modified"> 744     OrExpr();</span>
 745   }
 746 
 747   /**
 748    *
 749    *
 750    * OrExpr  ::=  AndExpr
 751    * | OrExpr &#39;or&#39; AndExpr
 752    *
 753    *
 754    * @throws javax.xml.transform.TransformerException
 755    */
 756   protected void OrExpr() throws javax.xml.transform.TransformerException
 757   {
 758 
 759     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 760 
 761     AndExpr();
 762 
 763     if ((null != m_token) &amp;&amp; tokenIs(&quot;or&quot;))
 764     {
</pre>
<hr />
<pre>
1866           // &quot;Node test that matches either NCName:* or QName was expected.&quot;
1867           error(XPATHErrorResources.ER_EXPECTED_NODE_TEST, null);
1868         }
1869       }
1870 
1871       m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1872 
1873       nextToken();
1874     }
1875   }
1876 
1877   /**
1878    *
1879    * Predicate ::= &#39;[&#39; PredicateExpr &#39;]&#39;
1880    *
1881    *
1882    * @throws javax.xml.transform.TransformerException
1883    */
1884   protected void Predicate() throws javax.xml.transform.TransformerException
1885   {
<span class="line-removed">1886 </span>
1887     if (tokenIs(&#39;[&#39;))
1888     {

1889       nextToken();
1890       PredicateExpr();

1891       consumeExpected(&#39;]&#39;);
1892     }
1893   }
1894 
1895   /**
1896    *
1897    * PredicateExpr ::= Expr
1898    *
1899    *
1900    * @throws javax.xml.transform.TransformerException
1901    */
1902   protected void PredicateExpr() throws javax.xml.transform.TransformerException
1903   {
1904 
1905     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1906 
1907     appendOp(2, OpCodes.OP_PREDICATE);
1908     Expr();
1909 
1910     // Terminate for safety.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xpath.internal.compiler;
  22 
  23 import javax.xml.transform.ErrorListener;
  24 import javax.xml.transform.TransformerException;
  25 
  26 import com.sun.org.apache.xalan.internal.res.XSLMessages;
  27 import com.sun.org.apache.xml.internal.utils.PrefixResolver;
  28 import com.sun.org.apache.xpath.internal.XPathProcessorException;
  29 import com.sun.org.apache.xpath.internal.objects.XNumber;
  30 import com.sun.org.apache.xpath.internal.objects.XString;
  31 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
  32 
  33 /**
  34  * Tokenizes and parses XPath expressions. This should really be named
  35  * XPathParserImpl, and may be renamed in the future.
  36  * @xsl.usage general
<span class="line-added">  37  * @LastModified: May 2019</span>
  38  */
  39 public class XPathParser
  40 {
  41         // %REVIEW% Is there a better way of doing this?
  42         // Upside is minimum object churn. Downside is that we don&#39;t have a useful
  43         // backtrace in the exception itself -- but we don&#39;t expect to need one.
  44         static public final String CONTINUE_AFTER_FATAL_ERROR=&quot;CONTINUE_AFTER_FATAL_ERROR&quot;;
  45 
  46   /**
  47    * The XPath to be processed.
  48    */
  49   private OpMap m_ops;
  50 
  51   /**
  52    * The next token in the pattern.
  53    */
  54   transient String m_token;
  55 
  56   /**
  57    * The first char in m_token, the theory being that this
  58    * is an optimization because we won&#39;t have to do charAt(0) as
  59    * often.
  60    */
  61   transient char m_tokenChar = 0;
  62 
  63   /**
  64    * The position in the token queue is tracked by m_queueMark.
  65    */
  66   int m_queueMark = 0;
  67 
  68   /**
  69    * Results from checking FilterExpr syntax
  70    */
  71   protected final static int FILTER_MATCH_FAILED     = 0;
  72   protected final static int FILTER_MATCH_PRIMARY    = 1;
  73   protected final static int FILTER_MATCH_PREDICATES = 2;
  74 
<span class="line-added">  75   // counts open predicates</span>
<span class="line-added">  76   private int countPredicate;</span>
<span class="line-added">  77 </span>
  78   /**
  79    * The parser constructor.
  80    */
  81   public XPathParser(ErrorListener errorListener, javax.xml.transform.SourceLocator sourceLocator)
  82   {
  83     m_errorListener = errorListener;
  84     m_sourceLocator = sourceLocator;
  85   }
  86 
  87   /**
  88    * The prefix resolver to map prefixes to namespaces in the OpMap.
  89    */
  90   PrefixResolver m_namespaceContext;
  91 
  92   /**
  93    * Given an string, init an XPath object for selections,
  94    * in order that a parse doesn&#39;t
  95    * have to be done each time the expression is evaluated.
  96    *
  97    * @param compiler The compiler object.
</pre>
<hr />
<pre>
 144           if (null != m_token)
 145             extraTokens += &quot;, &quot;;
 146         }
 147 
 148         error(XPATHErrorResources.ER_EXTRA_ILLEGAL_TOKENS,
 149               new Object[]{ extraTokens });  //&quot;Extra illegal tokens: &quot;+extraTokens);
 150       }
 151 
 152     }
 153     catch (com.sun.org.apache.xpath.internal.XPathProcessorException e)
 154     {
 155           if(CONTINUE_AFTER_FATAL_ERROR.equals(e.getMessage()))
 156           {
 157                 // What I _want_ to do is null out this XPath.
 158                 // I doubt this has the desired effect, but I&#39;m not sure what else to do.
 159                 // %REVIEW%!!!
 160                 initXPath(compiler, &quot;/..&quot;,  namespaceContext);
 161           }
 162           else
 163                 throw e;
<span class="line-added"> 164     } catch (StackOverflowError sof) {</span>
<span class="line-added"> 165         error(XPATHErrorResources.ER_PREDICATE_TOO_MANY_OPEN,</span>
<span class="line-added"> 166               new Object[]{m_token, m_queueMark, countPredicate});</span>
 167     }
 168 
 169     compiler.shrink();
 170   }
 171 
 172   /**
 173    * Given an string, init an XPath object for pattern matches,
 174    * in order that a parse doesn&#39;t
 175    * have to be done each time the expression is evaluated.
 176    * @param compiler The XPath object to be initialized.
 177    * @param expression A String representing the XPath.
 178    * @param namespaceContext An object that is able to resolve prefixes in
 179    * the XPath to namespaces.
 180    *
 181    * @throws javax.xml.transform.TransformerException
 182    */
 183   public void initMatchPattern(
 184           Compiler compiler, String expression, PrefixResolver namespaceContext)
 185             throws javax.xml.transform.TransformerException
 186   {
 187 
 188     m_ops = compiler;
 189     m_namespaceContext = namespaceContext;
 190     m_functionTable = compiler.getFunctionTable();
 191 
 192     Lexer lexer = new Lexer(compiler, namespaceContext, this);
 193 
 194     lexer.tokenize(expression);
 195 
 196     m_ops.setOp(0, OpCodes.OP_MATCHPATTERN);
 197     m_ops.setOp(OpMap.MAPINDEX_LENGTH, 2);
 198 
 199     nextToken();
<span class="line-modified"> 200     try {</span>
<span class="line-added"> 201         Pattern();</span>
<span class="line-added"> 202     } catch (StackOverflowError sof) {</span>
<span class="line-added"> 203         error(XPATHErrorResources.ER_PREDICATE_TOO_MANY_OPEN,</span>
<span class="line-added"> 204               new Object[]{m_token, m_queueMark, countPredicate});</span>
<span class="line-added"> 205     }</span>
 206 
 207     if (null != m_token)
 208     {
 209       String extraTokens = &quot;&quot;;
 210 
 211       while (null != m_token)
 212       {
 213         extraTokens += &quot;&#39;&quot; + m_token + &quot;&#39;&quot;;
 214 
 215         nextToken();
 216 
 217         if (null != m_token)
 218           extraTokens += &quot;, &quot;;
 219       }
 220 
 221       error(XPATHErrorResources.ER_EXTRA_ILLEGAL_TOKENS,
 222             new Object[]{ extraTokens });  //&quot;Extra illegal tokens: &quot;+extraTokens);
 223     }
 224 
 225     // Terminate for safety.
</pre>
<hr />
<pre>
 736 
 737     int totalLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 738 
 739     m_ops.setOp(totalLen, op);
 740     m_ops.setOp(totalLen + OpMap.MAPINDEX_LENGTH, length);
 741     m_ops.setOp(OpMap.MAPINDEX_LENGTH, totalLen + length);
 742   }
 743 
 744   // ============= EXPRESSIONS FUNCTIONS =================
 745 
 746   /**
 747    *
 748    *
 749    * Expr  ::=  OrExpr
 750    *
 751    *
 752    * @throws javax.xml.transform.TransformerException
 753    */
 754   protected void Expr() throws javax.xml.transform.TransformerException
 755   {
<span class="line-modified"> 756        OrExpr();</span>
 757   }
 758 
 759   /**
 760    *
 761    *
 762    * OrExpr  ::=  AndExpr
 763    * | OrExpr &#39;or&#39; AndExpr
 764    *
 765    *
 766    * @throws javax.xml.transform.TransformerException
 767    */
 768   protected void OrExpr() throws javax.xml.transform.TransformerException
 769   {
 770 
 771     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 772 
 773     AndExpr();
 774 
 775     if ((null != m_token) &amp;&amp; tokenIs(&quot;or&quot;))
 776     {
</pre>
<hr />
<pre>
1878           // &quot;Node test that matches either NCName:* or QName was expected.&quot;
1879           error(XPATHErrorResources.ER_EXPECTED_NODE_TEST, null);
1880         }
1881       }
1882 
1883       m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1884 
1885       nextToken();
1886     }
1887   }
1888 
1889   /**
1890    *
1891    * Predicate ::= &#39;[&#39; PredicateExpr &#39;]&#39;
1892    *
1893    *
1894    * @throws javax.xml.transform.TransformerException
1895    */
1896   protected void Predicate() throws javax.xml.transform.TransformerException
1897   {

1898     if (tokenIs(&#39;[&#39;))
1899     {
<span class="line-added">1900       countPredicate++;</span>
1901       nextToken();
1902       PredicateExpr();
<span class="line-added">1903       countPredicate--;</span>
1904       consumeExpected(&#39;]&#39;);
1905     }
1906   }
1907 
1908   /**
1909    *
1910    * PredicateExpr ::= Expr
1911    *
1912    *
1913    * @throws javax.xml.transform.TransformerException
1914    */
1915   protected void PredicateExpr() throws javax.xml.transform.TransformerException
1916   {
1917 
1918     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1919 
1920     appendOp(2, OpCodes.OP_PREDICATE);
1921     Expr();
1922 
1923     // Terminate for safety.
</pre>
</td>
</tr>
</table>
<center><a href="Compiler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../res/XPATHErrorResources.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/AttrImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../xalan/internal/xsltc/trax/TransformerImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AttrNSImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/AttrImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
</pre>
<hr />
<pre>
  93  * simplicity, this doesn&#39;t make much of a difference in memory usage because
  94  * there are only very few objects that are only a Parent. This is only true
  95  * now because AttrImpl now inherits directly from NodeImpl and has its own
  96  * implementation of the ParentNode&#39;s node behavior. So there is still some
  97  * duplicated code there.
  98  * &lt;p&gt;
  99  * This class doesn&#39;t directly support mutation events, however, it notifies
 100  * the document when mutations are performed so that the document class do so.
 101  *
 102  * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: Some of the code here is partially duplicated in
 103  * ParentNode, be careful to keep these two classes in sync!
 104  *
 105  * @xerces.internal
 106  *
 107  * @see AttrNSImpl
 108  *
 109  * @author Arnaud  Le Hors, IBM
 110  * @author Joe Kesselman, IBM
 111  * @author Andy Clark, IBM
 112  * @since PR-DOM-Level-1-19980818.

 113  *
 114  */
 115 public class AttrImpl
 116     extends NodeImpl
 117     implements Attr, TypeInfo{
 118 
 119     //
 120     // Constants
 121     //
 122 
 123     /** Serialization version. */
 124     static final long serialVersionUID = 7277707688218972102L;
 125 
 126     /** DTD namespace. **/
 127     static final String DTD_URI = &quot;http://www.w3.org/TR/REC-xml&quot;;
 128 
 129     //
 130     // Data
 131     //
 132 
 133     /** This can either be a String or the first child node. */
 134     protected Object value = null;
 135 
 136     /** Attribute name. */
 137     protected String name;
 138 
 139     /** Type information */
 140     // REVISIT: we are losing the type information in DOM during serialization
 141     transient Object type;
 142 
<span class="line-removed"> 143     protected TextImpl textNode = null;</span>
<span class="line-removed"> 144 </span>
 145     //
 146     // Constructors
 147     //
 148 
 149     /**
 150      * Attribute has no public constructor. Please use the factory
 151      * method in the Document class.
 152      */
 153     protected AttrImpl(CoreDocumentImpl ownerDocument, String name) {
 154         super(ownerDocument);
 155         this.name = name;
 156         /** False for default attributes. */
 157         isSpecified(true);
 158         hasStringValue(true);
 159     }
 160 
 161     // for AttrNSImpl
 162     protected AttrImpl() {}
 163 
 164     // Support for DOM Level 3 renameNode method.
</pre>
<hr />
<pre>
 175     // create a real text node as child if we don&#39;t have one yet
 176     protected void makeChildNode() {
 177         if (hasStringValue()) {
 178             if (value != null) {
 179                 TextImpl text =
 180                     (TextImpl) ownerDocument().createTextNode((String) value);
 181                 value = text;
 182                 text.isFirstChild(true);
 183                 text.previousSibling = text;
 184                 text.ownerNode = this;
 185                 text.isOwned(true);
 186             }
 187             hasStringValue(false);
 188         }
 189     }
 190 
 191     /**
 192      * NON-DOM
 193      * set the ownerDocument of this node and its children
 194      */
<span class="line-modified"> 195     void setOwnerDocument(CoreDocumentImpl doc) {</span>
 196         if (needsSyncChildren()) {
 197             synchronizeChildren();
 198         }
 199         super.setOwnerDocument(doc);
 200         if (!hasStringValue()) {
 201             for (ChildNode child = (ChildNode) value;
<span class="line-modified"> 202                  child != null; child = child.nextSibling) {</span>
 203                 child.setOwnerDocument(doc);
 204             }
 205         }
 206     }
 207 
 208     /**
 209      * NON-DOM: set the type of this attribute to be ID type.
 210      *
 211      * @param id
 212      */
 213     public void setIdAttribute(boolean id){
 214         if (needsSyncData()) {
 215             synchronizeData();
 216         }
 217         isIdAttribute(id);
 218     }
 219     /** DOM Level 3: isId*/
 220     public boolean isId(){
 221         // REVISIT: should an attribute that is not in the tree return
 222         // isID true?
</pre>
<hr />
<pre>
 332         return name;
 333 
 334     } // getName():String
 335 
 336     /**
 337      * The DOM doesn&#39;t clearly define what setValue(null) means. I&#39;ve taken it
 338      * as &quot;remove all children&quot;, which from outside should appear
 339      * similar to setting it to the empty string.
 340      */
 341     public void setValue(String newvalue) {
 342 
 343         CoreDocumentImpl ownerDocument = ownerDocument();
 344 
 345         if (ownerDocument.errorChecking &amp;&amp; isReadOnly()) {
 346             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
 347             throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);
 348         }
 349 
 350         Element ownerElement = getOwnerElement();
 351         String oldvalue = &quot;&quot;;


 352         if (needsSyncData()) {
 353             synchronizeData();
 354         }
 355         if (needsSyncChildren()) {
 356             synchronizeChildren();
 357         }
 358         if (value != null) {
 359             if (ownerDocument.getMutationEvents()) {
 360                 // Can no longer just discard the kids; they may have
 361                 // event listeners waiting for them to disconnect.
 362                 if (hasStringValue()) {
 363                     oldvalue = (String) value;
 364                     // create an actual text node as our child so
 365                     // that we can use it in the event
<span class="line-modified"> 366                     if (textNode == null) {</span>
<span class="line-removed"> 367                         textNode = (TextImpl)</span>
<span class="line-removed"> 368                             ownerDocument.createTextNode((String) value);</span>
<span class="line-removed"> 369                     }</span>
<span class="line-removed"> 370                     else {</span>
<span class="line-removed"> 371                         textNode.data = (String) value;</span>
<span class="line-removed"> 372                     }</span>
 373                     value = textNode;
 374                     textNode.isFirstChild(true);
 375                     textNode.previousSibling = textNode;
 376                     textNode.ownerNode = this;
 377                     textNode.isOwned(true);
 378                     hasStringValue(false);
 379                     internalRemoveChild(textNode, true);
 380                 }
 381                 else {
 382                     oldvalue = getValue();
 383                     while (value != null) {
 384                         internalRemoveChild((Node) value, true);
 385                     }
 386                 }
 387             }
 388             else {
 389                 if (hasStringValue()) {
 390                     oldvalue = (String) value;
 391                 }
 392                 else {
</pre>
<hr />
<pre>
 397                     firstChild.previousSibling = null;
 398                     firstChild.isFirstChild(false);
 399                     firstChild.ownerNode = ownerDocument;
 400                 }
 401                 // then remove ref to current value
 402                 value = null;
 403                 needsSyncChildren(false);
 404             }
 405             if (isIdAttribute() &amp;&amp; ownerElement != null) {
 406                 ownerDocument.removeIdentifier(oldvalue);
 407             }
 408         }
 409 
 410         // Create and add the new one, generating only non-aggregate events
 411         // (There are no listeners on the new Text, but there may be
 412         // capture/bubble listeners on the Attr.
 413         // Note that aggregate events are NOT dispatched here,
 414         // since we need to combine the remove and insert.
 415         isSpecified(true);
 416         if (ownerDocument.getMutationEvents()) {
<span class="line-modified"> 417             // if there are any event handlers create a real node</span>
<span class="line-modified"> 418             internalInsertBefore(ownerDocument.createTextNode(newvalue),</span>
<span class="line-modified"> 419                                  null, true);</span>







 420             hasStringValue(false);
 421             // notify document
 422             ownerDocument.modifiedAttrValue(this, oldvalue);
 423         } else {
 424             // directly store the string
 425             value = newvalue;
 426             hasStringValue(true);
 427             changed();
 428         }
 429         if (isIdAttribute() &amp;&amp; ownerElement != null) {
 430             ownerDocument.putIdentifier(newvalue, ownerElement);
 431         }
 432 
 433     } // setValue(String)
 434 
 435     /**
 436      * The &quot;string value&quot; of an Attribute is its text representation,
 437      * which in turn is a concatenation of the string values of its children.
 438      */
 439     public String getValue() {
</pre>
<hr />
<pre>
1017      * @return int
1018      */
1019     public int getLength() {
1020 
1021         if (hasStringValue()) {
1022             return 1;
1023         }
1024         ChildNode node = (ChildNode) value;
1025         int length = 0;
1026         for (; node != null; node = node.nextSibling) {
1027             length++;
1028         }
1029         return length;
1030 
1031     } // getLength():int
1032 
1033     /**
1034      * NodeList method: Return the Nth immediate child of this node, or
1035      * null if the index is out of bounds.
1036      * @return org.w3c.dom.Node
<span class="line-modified">1037      * @param Index int</span>
1038      */
1039     public Node item(int index) {
1040 
1041         if (hasStringValue()) {
1042             if (index != 0 || value == null) {
1043                 return null;
1044             }
1045             else {
1046                 makeChildNode();
1047                 return (Node) value;
1048             }
1049         }
1050         if (index &lt; 0) {
1051             return null;
1052         }
1053         ChildNode node = (ChildNode) value;
1054         for (int i = 0; i &lt; index &amp;&amp; node != null; i++) {
1055             node = node.nextSibling;
1056         }
1057         return node;
</pre>
<hr />
<pre>
1059     } // item(int):Node
1060 
1061     //
1062     // DOM3
1063     //
1064 
1065     /**
1066      * DOM Level 3 WD- Experimental.
1067      * Override inherited behavior from ParentNode to support deep equal.
1068      * isEqualNode is always deep on Attr nodes.
1069      */
1070     public boolean isEqualNode(Node arg) {
1071         return super.isEqualNode(arg);
1072     }
1073 
1074     /**
1075      * Introduced in DOM Level 3. &lt;p&gt;
1076      * Checks if a type is derived from another by restriction. See:
1077      * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom
1078      *
<span class="line-modified">1079      * @param ancestorNS</span>
1080      *        The namspace of the ancestor type declaration
<span class="line-modified">1081      * @param ancestorName</span>
1082      *        The name of the ancestor type declaration
<span class="line-modified">1083      * @param type</span>
<span class="line-modified">1084      *        The reference type definition</span>
1085      *
1086      * @return boolean True if the type is derived by restriciton for the
1087      *         reference type
1088      */
1089     public boolean isDerivedFrom(String typeNamespaceArg,
1090                                  String typeNameArg,
1091                                  int derivationMethod) {
1092 
1093         return false;
1094     }
1095 
1096 
1097     //
1098     // Public methods
1099     //
1100 
1101     /**
1102      * Override default behavior so that if deep is true, children are also
1103      * toggled.
1104      * @see Node
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
</pre>
<hr />
<pre>
  93  * simplicity, this doesn&#39;t make much of a difference in memory usage because
  94  * there are only very few objects that are only a Parent. This is only true
  95  * now because AttrImpl now inherits directly from NodeImpl and has its own
  96  * implementation of the ParentNode&#39;s node behavior. So there is still some
  97  * duplicated code there.
  98  * &lt;p&gt;
  99  * This class doesn&#39;t directly support mutation events, however, it notifies
 100  * the document when mutations are performed so that the document class do so.
 101  *
 102  * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: Some of the code here is partially duplicated in
 103  * ParentNode, be careful to keep these two classes in sync!
 104  *
 105  * @xerces.internal
 106  *
 107  * @see AttrNSImpl
 108  *
 109  * @author Arnaud  Le Hors, IBM
 110  * @author Joe Kesselman, IBM
 111  * @author Andy Clark, IBM
 112  * @since PR-DOM-Level-1-19980818.
<span class="line-added"> 113  * @LastModified: Apr 2019</span>
 114  *
 115  */
 116 public class AttrImpl
 117     extends NodeImpl
 118     implements Attr, TypeInfo{
 119 
 120     //
 121     // Constants
 122     //
 123 
 124     /** Serialization version. */
 125     static final long serialVersionUID = 7277707688218972102L;
 126 
 127     /** DTD namespace. **/
 128     static final String DTD_URI = &quot;http://www.w3.org/TR/REC-xml&quot;;
 129 
 130     //
 131     // Data
 132     //
 133 
 134     /** This can either be a String or the first child node. */
 135     protected Object value = null;
 136 
 137     /** Attribute name. */
 138     protected String name;
 139 
 140     /** Type information */
 141     // REVISIT: we are losing the type information in DOM during serialization
 142     transient Object type;
 143 


 144     //
 145     // Constructors
 146     //
 147 
 148     /**
 149      * Attribute has no public constructor. Please use the factory
 150      * method in the Document class.
 151      */
 152     protected AttrImpl(CoreDocumentImpl ownerDocument, String name) {
 153         super(ownerDocument);
 154         this.name = name;
 155         /** False for default attributes. */
 156         isSpecified(true);
 157         hasStringValue(true);
 158     }
 159 
 160     // for AttrNSImpl
 161     protected AttrImpl() {}
 162 
 163     // Support for DOM Level 3 renameNode method.
</pre>
<hr />
<pre>
 174     // create a real text node as child if we don&#39;t have one yet
 175     protected void makeChildNode() {
 176         if (hasStringValue()) {
 177             if (value != null) {
 178                 TextImpl text =
 179                     (TextImpl) ownerDocument().createTextNode((String) value);
 180                 value = text;
 181                 text.isFirstChild(true);
 182                 text.previousSibling = text;
 183                 text.ownerNode = this;
 184                 text.isOwned(true);
 185             }
 186             hasStringValue(false);
 187         }
 188     }
 189 
 190     /**
 191      * NON-DOM
 192      * set the ownerDocument of this node and its children
 193      */
<span class="line-modified"> 194     protected void setOwnerDocument(CoreDocumentImpl doc) {</span>
 195         if (needsSyncChildren()) {
 196             synchronizeChildren();
 197         }
 198         super.setOwnerDocument(doc);
 199         if (!hasStringValue()) {
 200             for (ChildNode child = (ChildNode) value;
<span class="line-modified"> 201                 child != null; child = child.nextSibling) {</span>
 202                 child.setOwnerDocument(doc);
 203             }
 204         }
 205     }
 206 
 207     /**
 208      * NON-DOM: set the type of this attribute to be ID type.
 209      *
 210      * @param id
 211      */
 212     public void setIdAttribute(boolean id){
 213         if (needsSyncData()) {
 214             synchronizeData();
 215         }
 216         isIdAttribute(id);
 217     }
 218     /** DOM Level 3: isId*/
 219     public boolean isId(){
 220         // REVISIT: should an attribute that is not in the tree return
 221         // isID true?
</pre>
<hr />
<pre>
 331         return name;
 332 
 333     } // getName():String
 334 
 335     /**
 336      * The DOM doesn&#39;t clearly define what setValue(null) means. I&#39;ve taken it
 337      * as &quot;remove all children&quot;, which from outside should appear
 338      * similar to setting it to the empty string.
 339      */
 340     public void setValue(String newvalue) {
 341 
 342         CoreDocumentImpl ownerDocument = ownerDocument();
 343 
 344         if (ownerDocument.errorChecking &amp;&amp; isReadOnly()) {
 345             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
 346             throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);
 347         }
 348 
 349         Element ownerElement = getOwnerElement();
 350         String oldvalue = &quot;&quot;;
<span class="line-added"> 351         TextImpl textNode = null;</span>
<span class="line-added"> 352 </span>
 353         if (needsSyncData()) {
 354             synchronizeData();
 355         }
 356         if (needsSyncChildren()) {
 357             synchronizeChildren();
 358         }
 359         if (value != null) {
 360             if (ownerDocument.getMutationEvents()) {
 361                 // Can no longer just discard the kids; they may have
 362                 // event listeners waiting for them to disconnect.
 363                 if (hasStringValue()) {
 364                     oldvalue = (String) value;
 365                     // create an actual text node as our child so
 366                     // that we can use it in the event
<span class="line-modified"> 367                     textNode = (TextImpl) ownerDocument.createTextNode((String) value);</span>






 368                     value = textNode;
 369                     textNode.isFirstChild(true);
 370                     textNode.previousSibling = textNode;
 371                     textNode.ownerNode = this;
 372                     textNode.isOwned(true);
 373                     hasStringValue(false);
 374                     internalRemoveChild(textNode, true);
 375                 }
 376                 else {
 377                     oldvalue = getValue();
 378                     while (value != null) {
 379                         internalRemoveChild((Node) value, true);
 380                     }
 381                 }
 382             }
 383             else {
 384                 if (hasStringValue()) {
 385                     oldvalue = (String) value;
 386                 }
 387                 else {
</pre>
<hr />
<pre>
 392                     firstChild.previousSibling = null;
 393                     firstChild.isFirstChild(false);
 394                     firstChild.ownerNode = ownerDocument;
 395                 }
 396                 // then remove ref to current value
 397                 value = null;
 398                 needsSyncChildren(false);
 399             }
 400             if (isIdAttribute() &amp;&amp; ownerElement != null) {
 401                 ownerDocument.removeIdentifier(oldvalue);
 402             }
 403         }
 404 
 405         // Create and add the new one, generating only non-aggregate events
 406         // (There are no listeners on the new Text, but there may be
 407         // capture/bubble listeners on the Attr.
 408         // Note that aggregate events are NOT dispatched here,
 409         // since we need to combine the remove and insert.
 410         isSpecified(true);
 411         if (ownerDocument.getMutationEvents()) {
<span class="line-modified"> 412             // if there are any event handlers create a real node or</span>
<span class="line-modified"> 413             // reuse the one we synthesized for the remove notifications</span>
<span class="line-modified"> 414             // if it exists.</span>
<span class="line-added"> 415             if (textNode == null) {</span>
<span class="line-added"> 416                 textNode = (TextImpl) ownerDocument.createTextNode(newvalue);</span>
<span class="line-added"> 417             }</span>
<span class="line-added"> 418             else {</span>
<span class="line-added"> 419                 textNode.data = newvalue;</span>
<span class="line-added"> 420             }</span>
<span class="line-added"> 421             internalInsertBefore(textNode, null, true);</span>
 422             hasStringValue(false);
 423             // notify document
 424             ownerDocument.modifiedAttrValue(this, oldvalue);
 425         } else {
 426             // directly store the string
 427             value = newvalue;
 428             hasStringValue(true);
 429             changed();
 430         }
 431         if (isIdAttribute() &amp;&amp; ownerElement != null) {
 432             ownerDocument.putIdentifier(newvalue, ownerElement);
 433         }
 434 
 435     } // setValue(String)
 436 
 437     /**
 438      * The &quot;string value&quot; of an Attribute is its text representation,
 439      * which in turn is a concatenation of the string values of its children.
 440      */
 441     public String getValue() {
</pre>
<hr />
<pre>
1019      * @return int
1020      */
1021     public int getLength() {
1022 
1023         if (hasStringValue()) {
1024             return 1;
1025         }
1026         ChildNode node = (ChildNode) value;
1027         int length = 0;
1028         for (; node != null; node = node.nextSibling) {
1029             length++;
1030         }
1031         return length;
1032 
1033     } // getLength():int
1034 
1035     /**
1036      * NodeList method: Return the Nth immediate child of this node, or
1037      * null if the index is out of bounds.
1038      * @return org.w3c.dom.Node
<span class="line-modified">1039      * @param index int</span>
1040      */
1041     public Node item(int index) {
1042 
1043         if (hasStringValue()) {
1044             if (index != 0 || value == null) {
1045                 return null;
1046             }
1047             else {
1048                 makeChildNode();
1049                 return (Node) value;
1050             }
1051         }
1052         if (index &lt; 0) {
1053             return null;
1054         }
1055         ChildNode node = (ChildNode) value;
1056         for (int i = 0; i &lt; index &amp;&amp; node != null; i++) {
1057             node = node.nextSibling;
1058         }
1059         return node;
</pre>
<hr />
<pre>
1061     } // item(int):Node
1062 
1063     //
1064     // DOM3
1065     //
1066 
1067     /**
1068      * DOM Level 3 WD- Experimental.
1069      * Override inherited behavior from ParentNode to support deep equal.
1070      * isEqualNode is always deep on Attr nodes.
1071      */
1072     public boolean isEqualNode(Node arg) {
1073         return super.isEqualNode(arg);
1074     }
1075 
1076     /**
1077      * Introduced in DOM Level 3. &lt;p&gt;
1078      * Checks if a type is derived from another by restriction. See:
1079      * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom
1080      *
<span class="line-modified">1081      * @param typeNamespaceArg</span>
1082      *        The namspace of the ancestor type declaration
<span class="line-modified">1083      * @param typeNameArg</span>
1084      *        The name of the ancestor type declaration
<span class="line-modified">1085      * @param derivationMethod</span>
<span class="line-modified">1086      *        The derivation method</span>
1087      *
1088      * @return boolean True if the type is derived by restriciton for the
1089      *         reference type
1090      */
1091     public boolean isDerivedFrom(String typeNamespaceArg,
1092                                  String typeNameArg,
1093                                  int derivationMethod) {
1094 
1095         return false;
1096     }
1097 
1098 
1099     //
1100     // Public methods
1101     //
1102 
1103     /**
1104      * Override default behavior so that if deep is true, children are also
1105      * toggled.
1106      * @see Node
</pre>
</td>
</tr>
</table>
<center><a href="../../../xalan/internal/xsltc/trax/TransformerImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AttrNSImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/JavaClass.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.classfile;
 21 
 22 import java.io.ByteArrayOutputStream;
 23 import java.io.DataOutputStream;
 24 import java.io.File;
 25 import java.io.FileOutputStream;
 26 import java.io.IOException;
 27 import java.io.OutputStream;
 28 import java.util.ArrayList;
<a name="2" id="anc2"></a>

 29 import java.util.List;
 30 import java.util.Set;
<a name="3" id="anc3"></a><span class="line-removed"> 31 import java.util.StringTokenizer;</span>
 32 import java.util.TreeSet;
 33 
 34 import com.sun.org.apache.bcel.internal.Const;
 35 import com.sun.org.apache.bcel.internal.generic.Type;
 36 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 37 import com.sun.org.apache.bcel.internal.util.ClassQueue;
 38 import com.sun.org.apache.bcel.internal.util.SyntheticRepository;
<a name="4" id="anc4"></a><span class="line-removed"> 39 import jdk.xml.internal.SecuritySupport;</span>
 40 
 41 /**
<a name="5" id="anc5"></a><span class="line-modified"> 42  * Represents a Java class, i.e., the data structures, constant pool, fields,</span>
<span class="line-modified"> 43  * methods and commands contained in a Java .class file. See &lt;a</span>
<span class="line-modified"> 44  * href=&quot;http://docs.oracle.com/javase/specs/&quot;&gt;JVM specification&lt;/a&gt; for</span>
<span class="line-modified"> 45  * details. The intent of this class is to represent a parsed or otherwise</span>
<span class="line-modified"> 46  * existing class file. Those interested in programatically generating classes</span>
 47  * should see the &lt;a href=&quot;../generic/ClassGen.html&quot;&gt;ClassGen&lt;/a&gt; class.
<a name="6" id="anc6"></a><span class="line-modified"> 48  *</span>
<span class="line-removed"> 49  * @version $Id: JavaClass.java 1750227 2016-06-25 21:47:10Z ggregory $</span>
 50  * @see com.sun.org.apache.bcel.internal.generic.ClassGen
<a name="7" id="anc7"></a>
 51  */
 52 public class JavaClass extends AccessFlags implements Cloneable, Node, Comparable&lt;JavaClass&gt; {
 53 
 54     private String file_name;
 55     private String package_name;
 56     private String source_file_name = &quot;&lt;Unknown&gt;&quot;;
 57     private int class_name_index;
 58     private int superclass_name_index;
 59     private String class_name;
 60     private String superclass_name;
 61     private int major;
 62     private int minor; // Compiler version
 63     private ConstantPool constant_pool; // Constant pool
 64     private int[] interfaces; // implemented interfaces
 65     private String[] interface_names;
 66     private Field[] fields; // Fields, i.e., variables of class
 67     private Method[] methods; // methods defined in the class
 68     private Attribute[] attributes; // attributes defined in the class
 69     private AnnotationEntry[] annotations;   // annotations defined on the class
 70     private byte source = HEAP; // Generated in memory
 71     private boolean isAnonymous = false;
 72     private boolean isNested = false;
 73     private boolean computedNestedTypeStatus = false;
 74     public static final byte HEAP = 1;
 75     public static final byte FILE = 2;
 76     public static final byte ZIP = 3;
<a name="8" id="anc8"></a>
 77 
 78     private static BCELComparator bcelComparator = new BCELComparator() {
 79 
 80         @Override
<a name="9" id="anc9"></a><span class="line-modified"> 81         public boolean equals(final Object o1, final Object o2) {</span>
 82             final JavaClass THIS = (JavaClass) o1;
 83             final JavaClass THAT = (JavaClass) o2;
<a name="10" id="anc10"></a><span class="line-modified"> 84             return THIS.getClassName().equals(THAT.getClassName());</span>
 85         }
 86 
<a name="11" id="anc11"></a>
 87         @Override
<a name="12" id="anc12"></a><span class="line-modified"> 88         public int hashCode(final Object o) {</span>
 89             final JavaClass THIS = (JavaClass) o;
 90             return THIS.getClassName().hashCode();
 91         }
 92     };
 93     /**
<a name="13" id="anc13"></a><span class="line-modified"> 94      * In cases where we go ahead and create something, use the default</span>
<span class="line-modified"> 95      * SyntheticRepository, because we don&#39;t know any better.</span>

 96      */
 97     private transient com.sun.org.apache.bcel.internal.util.Repository repository
 98             = SyntheticRepository.getInstance();
 99 
<a name="14" id="anc14"></a>
100     /**
101      * Constructor gets all contents as arguments.
102      *
103      * @param class_name_index Index into constant pool referencing a
104      * ConstantClass that represents this class.
105      * @param superclass_name_index Index into constant pool referencing a
106      * ConstantClass that represents this class&#39;s superclass.
107      * @param file_name File name
108      * @param major Major compiler version
109      * @param minor Minor compiler version
110      * @param access_flags Access rights defined by bit flags
111      * @param constant_pool Array of constants
112      * @param interfaces Implemented interfaces
113      * @param fields Class fields
114      * @param methods Class methods
115      * @param attributes Class attributes
116      * @param source Read from file or generated in memory?
117      */
118     public JavaClass(final int class_name_index, final int superclass_name_index,
119             final String file_name, final int major, final int minor, final int access_flags,
120             final ConstantPool constant_pool, int[] interfaces, Field[] fields,
121             Method[] methods, Attribute[] attributes, final byte source) {
122         super(access_flags);
123         if (interfaces == null) {
124             interfaces = new int[0];
125         }
126         if (attributes == null) {
127             attributes = new Attribute[0];
128         }
129         if (fields == null) {
130             fields = new Field[0];
131         }
132         if (methods == null) {
133             methods = new Method[0];
134         }
135         this.class_name_index = class_name_index;
136         this.superclass_name_index = superclass_name_index;
137         this.file_name = file_name;
138         this.major = major;
139         this.minor = minor;
140         this.constant_pool = constant_pool;
141         this.interfaces = interfaces;
142         this.fields = fields;
143         this.methods = methods;
144         this.attributes = attributes;
145         this.source = source;
146         // Get source file name if available
147         for (final Attribute attribute : attributes) {
148             if (attribute instanceof SourceFile) {
149                 source_file_name = ((SourceFile) attribute).getSourceFileName();
150                 break;
151             }
152         }
153         /* According to the specification the following entries must be of type
154          * `ConstantClass&#39; but we check that anyway via the
155          * `ConstPool.getConstant&#39; method.
156          */
157         class_name = constant_pool.getConstantString(class_name_index, Const.CONSTANT_Class);
158         class_name = Utility.compactClassName(class_name, false);
159         final int index = class_name.lastIndexOf(&#39;.&#39;);
160         if (index &lt; 0) {
161             package_name = &quot;&quot;;
162         } else {
163             package_name = class_name.substring(0, index);
164         }
165         if (superclass_name_index &gt; 0) {
166             // May be zero -&gt; class is java.lang.Object
167             superclass_name = constant_pool.getConstantString(superclass_name_index,
168                     Const.CONSTANT_Class);
169             superclass_name = Utility.compactClassName(superclass_name, false);
170         } else {
171             superclass_name = &quot;java.lang.Object&quot;;
172         }
173         interface_names = new String[interfaces.length];
174         for (int i = 0; i &lt; interfaces.length; i++) {
175             final String str = constant_pool.getConstantString(interfaces[i], Const.CONSTANT_Class);
176             interface_names[i] = Utility.compactClassName(str, false);
177         }
178     }
179 
<a name="15" id="anc15"></a>
180     /**
181      * Constructor gets all contents as arguments.
182      *
183      * @param class_name_index Class name
184      * @param superclass_name_index Superclass name
185      * @param file_name File name
186      * @param major Major compiler version
187      * @param minor Minor compiler version
188      * @param access_flags Access rights defined by bit flags
189      * @param constant_pool Array of constants
190      * @param interfaces Implemented interfaces
191      * @param fields Class fields
192      * @param methods Class methods
193      * @param attributes Class attributes
194      */
195     public JavaClass(final int class_name_index, final int superclass_name_index,
196             final String file_name, final int major, final int minor, final int access_flags,
197             final ConstantPool constant_pool, final int[] interfaces, final Field[] fields,
198             final Method[] methods, final Attribute[] attributes) {
199         this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,
200                 constant_pool, interfaces, fields, methods, attributes, HEAP);
201     }
202 
<a name="16" id="anc16"></a>
203     /**
<a name="17" id="anc17"></a><span class="line-modified">204      * Called by objects that are traversing the nodes of the tree implicitly</span>
205      * defined by the contents of a Java class. I.e., the hierarchy of methods,
206      * fields, attributes, etc. spawns a tree of objects.
207      *
208      * @param v Visitor object
209      */
210     @Override
<a name="18" id="anc18"></a><span class="line-modified">211     public void accept(final Visitor v) {</span>
212         v.visitJavaClass(this);
213     }
214 
<a name="19" id="anc19"></a>









215     /**
216      * Dump class to a file.
217      *
218      * @param file Output file
219      * @throws IOException
220      */
221     public void dump(final File file) throws IOException {
222         final String parent = file.getParent();
223         if (parent != null) {
224             final File dir = new File(parent);
225             if (!dir.mkdirs()) { // either was not created or already existed
<a name="20" id="anc20"></a><span class="line-modified">226                 if (!SecuritySupport.isDirectory(dir)) {</span>
227                     throw new IOException(&quot;Could not create the directory &quot; + dir);
228                 }
229             }
230         }
231         try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {
232             dump(dos);
233         }
234     }
235 
<a name="21" id="anc21"></a>
236     /**
237      * Dump class to a file named file_name.
238      *
239      * @param _file_name Output file name
240      * @throws IOException
241      */
<a name="22" id="anc22"></a><span class="line-modified">242     public void dump(final String _file_name) throws IOException {</span>
243         dump(new File(_file_name));
244     }
245 
<a name="23" id="anc23"></a>
246     /**
247      * @return class in binary format
248      */
249     public byte[] getBytes() {
250         final ByteArrayOutputStream s = new ByteArrayOutputStream();
251         final DataOutputStream ds = new DataOutputStream(s);
252         try {
253             dump(ds);
254         } catch (final IOException e) {
255             System.err.println(&quot;Error dumping class: &quot; + e.getMessage());
256         } finally {
257             try {
258                 ds.close();
259             } catch (final IOException e2) {
260                 System.err.println(&quot;Error dumping class: &quot; + e2.getMessage());
261             }
262         }
263         return s.toByteArray();
264     }
265 
<a name="24" id="anc24"></a>
266     /**
267      * Dump Java class to output stream in binary format.
268      *
269      * @param file Output stream
270      * @throws IOException
271      */
<a name="25" id="anc25"></a><span class="line-modified">272     public void dump(final OutputStream file) throws IOException {</span>
273         dump(new DataOutputStream(file));
274     }
275 
<a name="26" id="anc26"></a>
276     /**
277      * Dump Java class to output stream in binary format.
278      *
279      * @param file Output stream
280      * @throws IOException
281      */
<a name="27" id="anc27"></a><span class="line-modified">282     private void dump(final DataOutputStream file) throws IOException {</span>
283         file.writeInt(Const.JVM_CLASSFILE_MAGIC);
284         file.writeShort(minor);
285         file.writeShort(major);
286         constant_pool.dump(file);
287         file.writeShort(super.getAccessFlags());
288         file.writeShort(class_name_index);
289         file.writeShort(superclass_name_index);
290         file.writeShort(interfaces.length);
291         for (final int interface1 : interfaces) {
292             file.writeShort(interface1);
293         }
294         file.writeShort(fields.length);
295         for (final Field field : fields) {
296             field.dump(file);
297         }
298         file.writeShort(methods.length);
299         for (final Method method : methods) {
300             method.dump(file);
301         }
302         if (attributes != null) {
303             file.writeShort(attributes.length);
304             for (final Attribute attribute : attributes) {
305                 attribute.dump(file);
306             }
307         } else {
308             file.writeShort(0);
309         }
310         file.flush();
311     }
312 
<a name="28" id="anc28"></a>
313     /**
314      * @return Attributes of the class.
315      */
316     public Attribute[] getAttributes() {
317         return attributes;
318     }
319 
320     /**
321      * @return Annotations on the class
322      * @since 6.0
323      */
324     public AnnotationEntry[] getAnnotationEntries() {
325         if (annotations == null) {
326             annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
327         }
328 
329         return annotations;
330     }
331 
332     /**
333      * @return Class name.
334      */
335     public String getClassName() {
336         return class_name;
337     }
338 
<a name="29" id="anc29"></a>
339     /**
340      * @return Package name.
341      */
342     public String getPackageName() {
343         return package_name;
344     }
345 
<a name="30" id="anc30"></a>
346     /**
347      * @return Class name index.
348      */
349     public int getClassNameIndex() {
350         return class_name_index;
351     }
352 
<a name="31" id="anc31"></a>
353     /**
354      * @return Constant pool.
355      */
356     public ConstantPool getConstantPool() {
357         return constant_pool;
358     }
359 
<a name="32" id="anc32"></a>
360     /**
<a name="33" id="anc33"></a><span class="line-modified">361      * @return Fields, i.e., variables of the class. Like the JVM spec mandates</span>
<span class="line-modified">362      * for the classfile format, these fields are those specific to this class,</span>
<span class="line-modified">363      * and not those of the superclass or superinterfaces.</span>
364      */
365     public Field[] getFields() {
366         return fields;
367     }
368 
<a name="34" id="anc34"></a>
369     /**
370      * @return File name of class, aka SourceFile attribute value
371      */
372     public String getFileName() {
373         return file_name;
374     }
375 
<a name="35" id="anc35"></a>
376     /**
377      * @return Names of implemented interfaces.
378      */
379     public String[] getInterfaceNames() {
380         return interface_names;
381     }
382 
<a name="36" id="anc36"></a>
383     /**
384      * @return Indices in constant pool of implemented interfaces.
385      */
386     public int[] getInterfaceIndices() {
387         return interfaces;
388     }
389 
<a name="37" id="anc37"></a>
390     /**
391      * @return Major number of class file version.
392      */
393     public int getMajor() {
394         return major;
395     }
396 
<a name="38" id="anc38"></a>
397     /**
398      * @return Methods of the class.
399      */
400     public Method[] getMethods() {
401         return methods;
402     }
403 
<a name="39" id="anc39"></a>
404     /**
<a name="40" id="anc40"></a><span class="line-modified">405      * @return A {@link Method} corresponding to java.lang.reflect.Method if any</span>

406      */
<a name="41" id="anc41"></a><span class="line-modified">407     public Method getMethod(final java.lang.reflect.Method m) {</span>
408         for (final Method method : methods) {
409             if (m.getName().equals(method.getName()) &amp;&amp; (m.getModifiers() == method.getModifiers())
410                     &amp;&amp; Type.getSignature(m).equals(method.getSignature())) {
411                 return method;
412             }
413         }
414         return null;
415     }
416 
<a name="42" id="anc42"></a>
417     /**
418      * @return Minor number of class file version.
419      */
420     public int getMinor() {
421         return minor;
422     }
423 
<a name="43" id="anc43"></a>
424     /**
425      * @return sbsolute path to file where this class was read from
426      */
427     public String getSourceFileName() {
428         return source_file_name;
429     }
430 
<a name="44" id="anc44"></a>
431     /**
<a name="45" id="anc45"></a><span class="line-modified">432      * returns the super class name of this class. In the case that this class</span>
<span class="line-modified">433      * is java.lang.Object, it will return itself (java.lang.Object). This is</span>
<span class="line-modified">434      * probably incorrect but isn&#39;t fixed at this time to not break existing</span>
<span class="line-removed">435      * clients.</span>
436      *
437      * @return Superclass name.
438      */
439     public String getSuperclassName() {
440         return superclass_name;
441     }
442 
<a name="46" id="anc46"></a>
443     /**
444      * @return Class name index.
445      */
446     public int getSuperclassNameIndex() {
447         return superclass_name_index;
448     }
449 
450     /**
451      * @param attributes .
452      */
<a name="47" id="anc47"></a><span class="line-modified">453     public void setAttributes(final Attribute[] attributes) {</span>
454         this.attributes = attributes;
455     }
456 
<a name="48" id="anc48"></a>
457     /**
458      * @param class_name .
459      */
<a name="49" id="anc49"></a><span class="line-modified">460     public void setClassName(final String class_name) {</span>
461         this.class_name = class_name;
462     }
463 
<a name="50" id="anc50"></a>
464     /**
465      * @param class_name_index .
466      */
<a name="51" id="anc51"></a><span class="line-modified">467     public void setClassNameIndex(final int class_name_index) {</span>
468         this.class_name_index = class_name_index;
469     }
470 
<a name="52" id="anc52"></a>
471     /**
472      * @param constant_pool .
473      */
<a name="53" id="anc53"></a><span class="line-modified">474     public void setConstantPool(final ConstantPool constant_pool) {</span>
475         this.constant_pool = constant_pool;
476     }
477 
<a name="54" id="anc54"></a>
478     /**
479      * @param fields .
480      */
<a name="55" id="anc55"></a><span class="line-modified">481     public void setFields(final Field[] fields) {</span>
482         this.fields = fields;
483     }
484 
<a name="56" id="anc56"></a>
485     /**
486      * Set File name of class, aka SourceFile attribute value
487      */
<a name="57" id="anc57"></a><span class="line-modified">488     public void setFileName(final String file_name) {</span>
489         this.file_name = file_name;
490     }
491 
<a name="58" id="anc58"></a>
492     /**
493      * @param interface_names .
494      */
<a name="59" id="anc59"></a><span class="line-modified">495     public void setInterfaceNames(final String[] interface_names) {</span>
496         this.interface_names = interface_names;
497     }
498 
<a name="60" id="anc60"></a>
499     /**
500      * @param interfaces .
501      */
<a name="61" id="anc61"></a><span class="line-modified">502     public void setInterfaces(final int[] interfaces) {</span>
503         this.interfaces = interfaces;
504     }
505 
<a name="62" id="anc62"></a>
506     /**
507      * @param major .
508      */
<a name="63" id="anc63"></a><span class="line-modified">509     public void setMajor(final int major) {</span>
510         this.major = major;
511     }
512 
<a name="64" id="anc64"></a>
513     /**
514      * @param methods .
515      */
<a name="65" id="anc65"></a><span class="line-modified">516     public void setMethods(final Method[] methods) {</span>
517         this.methods = methods;
518     }
519 
<a name="66" id="anc66"></a>
520     /**
521      * @param minor .
522      */
<a name="67" id="anc67"></a><span class="line-modified">523     public void setMinor(final int minor) {</span>
524         this.minor = minor;
525     }
526 
<a name="68" id="anc68"></a>
527     /**
528      * Set absolute path to file this class was read from.
529      */
<a name="69" id="anc69"></a><span class="line-modified">530     public void setSourceFileName(final String source_file_name) {</span>
531         this.source_file_name = source_file_name;
532     }
533 
<a name="70" id="anc70"></a>
534     /**
535      * @param superclass_name .
536      */
<a name="71" id="anc71"></a><span class="line-modified">537     public void setSuperclassName(final String superclass_name) {</span>
538         this.superclass_name = superclass_name;
539     }
540 
<a name="72" id="anc72"></a>
541     /**
542      * @param superclass_name_index .
543      */
<a name="73" id="anc73"></a><span class="line-modified">544     public void setSuperclassNameIndex(final int superclass_name_index) {</span>
545         this.superclass_name_index = superclass_name_index;
546     }
547 
<a name="74" id="anc74"></a>
548     /**
549      * @return String representing class contents.
550      */
551     @Override
552     public String toString() {
553         String access = Utility.accessToString(super.getAccessFlags(), true);
554         access = access.isEmpty() ? &quot;&quot; : (access + &quot; &quot;);
555         final StringBuilder buf = new StringBuilder(128);
556         buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(&quot; &quot;).append(
557                 class_name).append(&quot; extends &quot;).append(
<a name="75" id="anc75"></a><span class="line-modified">558                         Utility.compactClassName(superclass_name, false)).append(&#39;\n&#39;);</span>
559         final int size = interfaces.length;
560         if (size &gt; 0) {
561             buf.append(&quot;implements\t\t&quot;);
562             for (int i = 0; i &lt; size; i++) {
563                 buf.append(interface_names[i]);
564                 if (i &lt; size - 1) {
565                     buf.append(&quot;, &quot;);
566                 }
567             }
568             buf.append(&#39;\n&#39;);
569         }
<a name="76" id="anc76"></a><span class="line-modified">570         buf.append(&quot;filename\t\t&quot;).append(file_name).append(&#39;\n&#39;);</span>
571         buf.append(&quot;compiled from\t\t&quot;).append(source_file_name).append(&#39;\n&#39;);
572         buf.append(&quot;compiler version\t&quot;).append(major).append(&quot;.&quot;).append(minor).append(&#39;\n&#39;);
573         buf.append(&quot;access flags\t\t&quot;).append(super.getAccessFlags()).append(&#39;\n&#39;);
574         buf.append(&quot;constant pool\t\t&quot;).append(constant_pool.getLength()).append(&quot; entries\n&quot;);
575         buf.append(&quot;ACC_SUPER flag\t\t&quot;).append(isSuper()).append(&quot;\n&quot;);
576         if (attributes.length &gt; 0) {
577             buf.append(&quot;\nAttribute(s):\n&quot;);
578             for (final Attribute attribute : attributes) {
579                 buf.append(indent(attribute));
580             }
581         }
582         final AnnotationEntry[] annotations = getAnnotationEntries();
<a name="77" id="anc77"></a><span class="line-modified">583         if (annotations != null &amp;&amp; annotations.length &gt; 0) {</span>
584             buf.append(&quot;\nAnnotation(s):\n&quot;);
585             for (final AnnotationEntry annotation : annotations) {
586                 buf.append(indent(annotation));
587             }
588         }
589         if (fields.length &gt; 0) {
590             buf.append(&quot;\n&quot;).append(fields.length).append(&quot; fields:\n&quot;);
591             for (final Field field : fields) {
592                 buf.append(&quot;\t&quot;).append(field).append(&#39;\n&#39;);
593             }
594         }
595         if (methods.length &gt; 0) {
596             buf.append(&quot;\n&quot;).append(methods.length).append(&quot; methods:\n&quot;);
597             for (final Method method : methods) {
598                 buf.append(&quot;\t&quot;).append(method).append(&#39;\n&#39;);
599             }
600         }
601         return buf.toString();
602     }
603 
<a name="78" id="anc78"></a><span class="line-modified">604     private static String indent(final Object obj) {</span>

605         final StringTokenizer tok = new StringTokenizer(obj.toString(), &quot;\n&quot;);
606         final StringBuilder buf = new StringBuilder();
607         while (tok.hasMoreTokens()) {
608             buf.append(&quot;\t&quot;).append(tok.nextToken()).append(&quot;\n&quot;);
609         }
610         return buf.toString();
611     }
612 
<a name="79" id="anc79"></a>
613     /**
614      * @return deep copy of this class
615      */
616     public JavaClass copy() {
617         JavaClass c = null;
618         try {
619             c = (JavaClass) clone();
620             c.constant_pool = constant_pool.copy();
621             c.interfaces = interfaces.clone();
622             c.interface_names = interface_names.clone();
623             c.fields = new Field[fields.length];
624             for (int i = 0; i &lt; fields.length; i++) {
625                 c.fields[i] = fields[i].copy(c.constant_pool);
626             }
627             c.methods = new Method[methods.length];
628             for (int i = 0; i &lt; methods.length; i++) {
629                 c.methods[i] = methods[i].copy(c.constant_pool);
630             }
631             c.attributes = new Attribute[attributes.length];
632             for (int i = 0; i &lt; attributes.length; i++) {
633                 c.attributes[i] = attributes[i].copy(c.constant_pool);
634             }
635         } catch (final CloneNotSupportedException e) {
636             // TODO should this throw?
637         }
638         return c;
639     }
640 
<a name="80" id="anc80"></a>
641     public final boolean isSuper() {
642         return (super.getAccessFlags() &amp; Const.ACC_SUPER) != 0;
643     }
644 
<a name="81" id="anc81"></a>
645     public final boolean isClass() {
646         return (super.getAccessFlags() &amp; Const.ACC_INTERFACE) == 0;
647     }
648 
649     /**
650      * @since 6.0
651      */
652     public final boolean isAnonymous() {
653         computeNestedTypeStatus();
654         return this.isAnonymous;
655     }
656 
657     /**
658      * @since 6.0
659      */
660     public final boolean isNested() {
661         computeNestedTypeStatus();
662         return this.isNested;
663     }
664 
665     private void computeNestedTypeStatus() {
666         if (computedNestedTypeStatus) {
667             return;
668         }
669         for (final Attribute attribute : this.attributes) {
<a name="82" id="anc82"></a><span class="line-modified">670             if (attribute instanceof InnerClasses) {</span>
<span class="line-modified">671                 final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();</span>
<span class="line-modified">672                 for (final InnerClass innerClasse : innerClasses) {</span>
<span class="line-modified">673                     boolean innerClassAttributeRefersToMe = false;</span>
<span class="line-modified">674                     String inner_class_name = constant_pool.getConstantString(innerClasse.getInnerClassIndex(),</span>
<span class="line-modified">675                             Const.CONSTANT_Class);</span>
<span class="line-modified">676                     inner_class_name = Utility.compactClassName(inner_class_name);</span>
<span class="line-modified">677                     if (inner_class_name.equals(getClassName())) {</span>
<span class="line-modified">678                         innerClassAttributeRefersToMe = true;</span>
<span class="line-modified">679                     }</span>
<span class="line-modified">680                     if (innerClassAttributeRefersToMe) {</span>
<span class="line-modified">681                         this.isNested = true;</span>
<span class="line-modified">682                         if (innerClasse.getInnerNameIndex() == 0) {</span>
<span class="line-modified">683                             this.isAnonymous = true;</span>
<span class="line-modified">684                         }</span>
<span class="line-modified">685                     }</span>
<span class="line-modified">686                 }</span>
<span class="line-modified">687             }</span>
688         }
689         this.computedNestedTypeStatus = true;
690     }
691 
<a name="83" id="anc83"></a><span class="line-modified">692     /**</span>
<span class="line-modified">693      * @return returns either HEAP (generated), FILE, or ZIP</span>
694      */
695     public final byte getSource() {
696         return source;
697     }
698 
<a name="84" id="anc84"></a>

699     /**
<a name="85" id="anc85"></a><span class="line-modified">700      * ******************* New repository functionality ********************</span>
<span class="line-modified">701      */</span>
<span class="line-removed">702     /**</span>
<span class="line-removed">703      * Gets the ClassRepository which holds its definition. By default this is</span>
<span class="line-removed">704      * the same as SyntheticRepository.getInstance();</span>
705      */
706     public com.sun.org.apache.bcel.internal.util.Repository getRepository() {
707         return repository;
708     }
709 
<a name="86" id="anc86"></a>
710     /**
<a name="87" id="anc87"></a><span class="line-modified">711      * Sets the ClassRepository which loaded the JavaClass. Should be called</span>
<span class="line-modified">712      * immediately after parsing is done.</span>
713      */
<a name="88" id="anc88"></a><span class="line-modified">714     public void setRepository(final com.sun.org.apache.bcel.internal.util.Repository repository) {</span>
715         this.repository = repository;
716     }
717 
<a name="89" id="anc89"></a><span class="line-modified">718     /**</span>
<span class="line-modified">719      * Equivalent to runtime &quot;instanceof&quot; operator.</span>
720      *
721      * @return true if this JavaClass is derived from the super class
<a name="90" id="anc90"></a><span class="line-modified">722      * @throws ClassNotFoundException if superclasses or superinterfaces of this</span>
<span class="line-modified">723      * object can&#39;t be found</span>
724      */
<a name="91" id="anc91"></a><span class="line-modified">725     public final boolean instanceOf(final JavaClass super_class) throws ClassNotFoundException {</span>
726         if (this.equals(super_class)) {
727             return true;
728         }
729         final JavaClass[] super_classes = getSuperClasses();
730         for (final JavaClass super_classe : super_classes) {
731             if (super_classe.equals(super_class)) {
732                 return true;
733             }
734         }
735         if (super_class.isInterface()) {
736             return implementationOf(super_class);
737         }
738         return false;
739     }
740 
<a name="92" id="anc92"></a>
741     /**
742      * @return true, if this class is an implementation of interface inter
<a name="93" id="anc93"></a><span class="line-modified">743      * @throws ClassNotFoundException if superclasses or superinterfaces of this</span>
<span class="line-modified">744      * class can&#39;t be found</span>
745      */
<a name="94" id="anc94"></a><span class="line-modified">746     public boolean implementationOf(final JavaClass inter) throws ClassNotFoundException {</span>
747         if (!inter.isInterface()) {
748             throw new IllegalArgumentException(inter.getClassName() + &quot; is no interface&quot;);
749         }
750         if (this.equals(inter)) {
751             return true;
752         }
753         final JavaClass[] super_interfaces = getAllInterfaces();
754         for (final JavaClass super_interface : super_interfaces) {
755             if (super_interface.equals(inter)) {
756                 return true;
757             }
758         }
759         return false;
760     }
761 
<a name="95" id="anc95"></a>
762     /**
<a name="96" id="anc96"></a><span class="line-modified">763      * @return the superclass for this JavaClass object, or null if this is</span>
<span class="line-modified">764      * java.lang.Object</span>
765      * @throws ClassNotFoundException if the superclass can&#39;t be found
766      */
767     public JavaClass getSuperClass() throws ClassNotFoundException {
768         if (&quot;java.lang.Object&quot;.equals(getClassName())) {
769             return null;
770         }
771         return repository.loadClass(getSuperclassName());
772     }
773 
<a name="97" id="anc97"></a>
774     /**
775      * @return list of super classes of this class in ascending order, i.e.,
776      * java.lang.Object is always the last element
777      * @throws ClassNotFoundException if any of the superclasses can&#39;t be found
778      */
779     public JavaClass[] getSuperClasses() throws ClassNotFoundException {
780         JavaClass clazz = this;
781         final List&lt;JavaClass&gt; allSuperClasses = new ArrayList&lt;&gt;();
782         for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {
783             allSuperClasses.add(clazz);
784         }
785         return allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);
786     }
787 
<a name="98" id="anc98"></a>
788     /**
789      * Get interfaces directly implemented by this JavaClass.
790      */
791     public JavaClass[] getInterfaces() throws ClassNotFoundException {
792         final String[] _interfaces = getInterfaceNames();
793         final JavaClass[] classes = new JavaClass[_interfaces.length];
794         for (int i = 0; i &lt; _interfaces.length; i++) {
795             classes[i] = repository.loadClass(_interfaces[i]);
796         }
797         return classes;
798     }
799 
<a name="99" id="anc99"></a>
800     /**
801      * Get all interfaces implemented by this JavaClass (transitively).
802      */
803     public JavaClass[] getAllInterfaces() throws ClassNotFoundException {
804         final ClassQueue queue = new ClassQueue();
805         final Set&lt;JavaClass&gt; allInterfaces = new TreeSet&lt;&gt;();
806         queue.enqueue(this);
807         while (!queue.empty()) {
808             final JavaClass clazz = queue.dequeue();
809             final JavaClass souper = clazz.getSuperClass();
810             final JavaClass[] _interfaces = clazz.getInterfaces();
811             if (clazz.isInterface()) {
812                 allInterfaces.add(clazz);
813             } else {
814                 if (souper != null) {
815                     queue.enqueue(souper);
816                 }
817             }
818             for (final JavaClass _interface : _interfaces) {
819                 queue.enqueue(_interface);
820             }
821         }
822         return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);
823     }
824 
<a name="100" id="anc100"></a>
825     /**
826      * @return Comparison strategy object
827      */
828     public static BCELComparator getComparator() {
829         return bcelComparator;
830     }
831 
<a name="101" id="anc101"></a>
832     /**
833      * @param comparator Comparison strategy object
834      */
<a name="102" id="anc102"></a><span class="line-modified">835     public static void setComparator(final BCELComparator comparator) {</span>
836         bcelComparator = comparator;
837     }
838 
<a name="103" id="anc103"></a>
839     /**
<a name="104" id="anc104"></a><span class="line-modified">840      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">841      * JavaClass objects are said to be equal when their class names are equal.</span>

842      *
843      * @see java.lang.Object#equals(java.lang.Object)
844      */
845     @Override
<a name="105" id="anc105"></a><span class="line-modified">846     public boolean equals(final Object obj) {</span>
847         return bcelComparator.equals(this, obj);
848     }
849 
<a name="106" id="anc106"></a>
850     /**
<a name="107" id="anc107"></a><span class="line-modified">851      * Return the natural ordering of two JavaClasses. This ordering is based on</span>
<span class="line-modified">852      * the class name</span>
<span class="line-removed">853      *</span>
854      * @since 6.0
855      */
856     @Override
<a name="108" id="anc108"></a><span class="line-modified">857     public int compareTo(final JavaClass obj) {</span>
858         return getClassName().compareTo(obj.getClassName());
859     }
860 
<a name="109" id="anc109"></a>
861     /**
<a name="110" id="anc110"></a><span class="line-modified">862      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">863      * return the hashcode of the class name.</span>
864      *
865      * @see java.lang.Object#hashCode()
866      */
867     @Override
868     public int hashCode() {
869         return bcelComparator.hashCode(this);
870     }
871 }
<a name="111" id="anc111"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="111" type="hidden" />
</body>
</html>
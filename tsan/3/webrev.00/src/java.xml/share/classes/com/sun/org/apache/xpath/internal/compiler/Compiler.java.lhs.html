<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xpath/internal/compiler/Compiler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * reserved comment block</span>
<span class="line-removed">   3  * DO NOT REMOVE OR ALTER!</span>
   4  */
   5 /*
   6  * Licensed to the Apache Software Foundation (ASF) under one or more
   7  * contributor license agreements.  See the NOTICE file distributed with
   8  * this work for additional information regarding copyright ownership.
   9  * The ASF licenses this file to You under the Apache License, Version 2.0
  10  * (the &quot;License&quot;); you may not use this file except in compliance with
  11  * the License.  You may obtain a copy of the License at
  12  *
  13  *      http://www.apache.org/licenses/LICENSE-2.0
  14  *
  15  * Unless required by applicable law or agreed to in writing, software
  16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  18  * See the License for the specific language governing permissions and
  19  * limitations under the License.
  20  */
  21 
  22 package com.sun.org.apache.xpath.internal.compiler;
  23 
  24 import javax.xml.transform.ErrorListener;
  25 import javax.xml.transform.SourceLocator;
  26 import javax.xml.transform.TransformerException;
  27 
  28 import com.sun.org.apache.xalan.internal.res.XSLMessages;
  29 import com.sun.org.apache.xml.internal.dtm.Axis;
  30 import com.sun.org.apache.xml.internal.dtm.DTMFilter;
  31 import com.sun.org.apache.xml.internal.dtm.DTMIterator;
  32 import com.sun.org.apache.xml.internal.utils.PrefixResolver;
  33 import com.sun.org.apache.xml.internal.utils.QName;
  34 import com.sun.org.apache.xml.internal.utils.SAXSourceLocator;
  35 import com.sun.org.apache.xpath.internal.Expression;
  36 import com.sun.org.apache.xpath.internal.axes.UnionPathIterator;
  37 import com.sun.org.apache.xpath.internal.axes.WalkerFactory;
  38 import com.sun.org.apache.xpath.internal.functions.FuncExtFunction;
  39 import com.sun.org.apache.xpath.internal.functions.FuncExtFunctionAvailable;
  40 import com.sun.org.apache.xpath.internal.functions.Function;
  41 import com.sun.org.apache.xpath.internal.functions.WrongNumberArgsException;
  42 import com.sun.org.apache.xpath.internal.objects.XNumber;
  43 import com.sun.org.apache.xpath.internal.objects.XString;
  44 import com.sun.org.apache.xpath.internal.operations.And;
  45 import com.sun.org.apache.xpath.internal.operations.Div;
  46 import com.sun.org.apache.xpath.internal.operations.Equals;
  47 import com.sun.org.apache.xpath.internal.operations.Gt;
  48 import com.sun.org.apache.xpath.internal.operations.Gte;
  49 import com.sun.org.apache.xpath.internal.operations.Lt;
  50 import com.sun.org.apache.xpath.internal.operations.Lte;
  51 import com.sun.org.apache.xpath.internal.operations.Minus;
  52 import com.sun.org.apache.xpath.internal.operations.Mod;
  53 import com.sun.org.apache.xpath.internal.operations.Mult;
  54 import com.sun.org.apache.xpath.internal.operations.Neg;
  55 import com.sun.org.apache.xpath.internal.operations.NotEquals;
  56 import com.sun.org.apache.xpath.internal.operations.Operation;
  57 import com.sun.org.apache.xpath.internal.operations.Or;
  58 import com.sun.org.apache.xpath.internal.operations.Plus;
  59 import com.sun.org.apache.xpath.internal.operations.UnaryOperation;
  60 import com.sun.org.apache.xpath.internal.operations.Variable;
  61 import com.sun.org.apache.xpath.internal.patterns.FunctionPattern;
  62 import com.sun.org.apache.xpath.internal.patterns.NodeTest;
  63 import com.sun.org.apache.xpath.internal.patterns.StepPattern;
  64 import com.sun.org.apache.xpath.internal.patterns.UnionPattern;
  65 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
  66 
  67 /**
  68  * An instance of this class compiles an XPath string expression into
  69  * a Expression object.  This class compiles the string into a sequence
  70  * of operation codes (op map) and then builds from that into an Expression
  71  * tree.
  72  * @xsl.usage advanced
<a name="2" id="anc2"></a>
  73  */
  74 public class Compiler extends OpMap
  75 {
<a name="3" id="anc3"></a>

  76 
  77   /**
  78    * Construct a Compiler object with a specific ErrorListener and
  79    * SourceLocator where the expression is located.
  80    *
  81    * @param errorHandler Error listener where messages will be sent, or null
  82    *                     if messages should be sent to System err.
  83    * @param locator The location object where the expression lives, which
  84    *                may be null, but which, if not null, must be valid over
  85    *                the long haul, in other words, it will not be cloned.
  86    * @param fTable  The FunctionTable object where the xpath build-in
  87    *                functions are stored.
  88    */
  89   public Compiler(ErrorListener errorHandler, SourceLocator locator,
  90             FunctionTable fTable)
  91   {
  92     m_errorHandler = errorHandler;
  93     m_locator = locator;
  94     m_functionTable = fTable;
  95   }
  96 
  97   /**
  98    * Construct a Compiler instance that has a null error listener and a
  99    * null source locator.
 100    */
 101   public Compiler()
 102   {
 103     m_errorHandler = null;
 104     m_locator = null;
 105   }
 106 
 107   /**
 108    * Execute the XPath object from a given opcode position.
<a name="4" id="anc4"></a>




 109    * @param opPos The current position in the xpath.m_opMap array.
 110    * @return The result of the XPath.
 111    *
 112    * @throws TransformerException if there is a syntax or other error.
 113    * @xsl.usage advanced
 114    */
<a name="5" id="anc5"></a><span class="line-modified"> 115   public Expression compile(int opPos) throws TransformerException</span>
<span class="line-modified"> 116   {</span>








 117 
<a name="6" id="anc6"></a>











 118     int op = getOp(opPos);
 119 
 120     Expression expr = null;
 121     // System.out.println(getPatternString()+&quot;op: &quot;+op);
 122     switch (op)
 123     {
 124     case OpCodes.OP_XPATH :
 125       expr = compile(opPos + 2); break;
 126     case OpCodes.OP_OR :
 127       expr = or(opPos); break;
 128     case OpCodes.OP_AND :
 129       expr = and(opPos); break;
 130     case OpCodes.OP_NOTEQUALS :
 131       expr = notequals(opPos); break;
 132     case OpCodes.OP_EQUALS :
 133       expr = equals(opPos); break;
 134     case OpCodes.OP_LTE :
 135       expr = lte(opPos); break;
 136     case OpCodes.OP_LT :
 137       expr = lt(opPos); break;
 138     case OpCodes.OP_GTE :
 139       expr = gte(opPos); break;
 140     case OpCodes.OP_GT :
 141       expr = gt(opPos); break;
 142     case OpCodes.OP_PLUS :
 143       expr = plus(opPos); break;
 144     case OpCodes.OP_MINUS :
 145       expr = minus(opPos); break;
 146     case OpCodes.OP_MULT :
 147       expr = mult(opPos); break;
 148     case OpCodes.OP_DIV :
 149       expr = div(opPos); break;
 150     case OpCodes.OP_MOD :
 151       expr = mod(opPos); break;
 152 //    case OpCodes.OP_QUO :
 153 //      expr = quo(opPos); break;
 154     case OpCodes.OP_NEG :
 155       expr = neg(opPos); break;
 156     case OpCodes.OP_STRING :
 157       expr = string(opPos); break;
 158     case OpCodes.OP_BOOL :
 159       expr = bool(opPos); break;
 160     case OpCodes.OP_NUMBER :
 161       expr = number(opPos); break;
 162     case OpCodes.OP_UNION :
 163       expr = union(opPos); break;
 164     case OpCodes.OP_LITERAL :
 165       expr = literal(opPos); break;
 166     case OpCodes.OP_VARIABLE :
 167       expr = variable(opPos); break;
 168     case OpCodes.OP_GROUP :
 169       expr = group(opPos); break;
 170     case OpCodes.OP_NUMBERLIT :
 171       expr = numberlit(opPos); break;
 172     case OpCodes.OP_ARGUMENT :
 173       expr = arg(opPos); break;
 174     case OpCodes.OP_EXTFUNCTION :
 175       expr = compileExtension(opPos); break;
 176     case OpCodes.OP_FUNCTION :
 177       expr = compileFunction(opPos); break;
 178     case OpCodes.OP_LOCATIONPATH :
 179       expr = locationPath(opPos); break;
 180     case OpCodes.OP_PREDICATE :
 181       expr = null; break;  // should never hit this here.
 182     case OpCodes.OP_MATCHPATTERN :
 183       expr = matchPattern(opPos + 2); break;
 184     case OpCodes.OP_LOCATIONPATHPATTERN :
 185       expr = locationPathPattern(opPos); break;
 186     case OpCodes.OP_QUO:
 187       error(XPATHErrorResources.ER_UNKNOWN_OPCODE,
 188             new Object[]{ &quot;quo&quot; });  //&quot;ERROR! Unknown op code: &quot;+m_opMap[opPos]);
 189       break;
 190     default :
 191       error(XPATHErrorResources.ER_UNKNOWN_OPCODE,
 192             new Object[]{ Integer.toString(getOp(opPos)) });  //&quot;ERROR! Unknown op code: &quot;+m_opMap[opPos]);
 193     }
 194 //    if(null != expr)
 195 //      expr.setSourceLocator(m_locator);
 196 
 197     return expr;
 198   }
 199 
 200   /**
 201    * Bottle-neck compilation of an operation with left and right operands.
 202    *
 203    * @param operation non-null reference to parent operation.
 204    * @param opPos The op map position of the parent operation.
 205    *
 206    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Operation} instance.
 207    *
 208    * @throws TransformerException if there is a syntax or other error.
 209    */
 210   private Expression compileOperation(Operation operation, int opPos)
 211           throws TransformerException
 212   {
<a name="7" id="anc7"></a>
 213 
 214     int leftPos = getFirstChildPos(opPos);
 215     int rightPos = getNextOpPos(leftPos);
 216 
 217     operation.setLeftRight(compile(leftPos), compile(rightPos));
 218 
 219     return operation;
 220   }
 221 
 222   /**
 223    * Bottle-neck compilation of a unary operation.
 224    *
 225    * @param unary The parent unary operation.
 226    * @param opPos The position in the op map of the parent operation.
 227    *
 228    * @return The unary argument.
 229    *
 230    * @throws TransformerException if syntax or other error occurs.
 231    */
 232   private Expression compileUnary(UnaryOperation unary, int opPos)
 233           throws TransformerException
 234   {
 235 
 236     int rightPos = getFirstChildPos(opPos);
 237 
 238     unary.setRight(compile(rightPos));
 239 
 240     return unary;
 241   }
 242 
 243   /**
 244    * Compile an &#39;or&#39; operation.
 245    *
 246    * @param opPos The current position in the m_opMap array.
 247    *
 248    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Or} instance.
 249    *
 250    * @throws TransformerException if a error occurs creating the Expression.
 251    */
 252   protected Expression or(int opPos) throws TransformerException
 253   {
 254     return compileOperation(new Or(), opPos);
 255   }
 256 
 257   /**
 258    * Compile an &#39;and&#39; operation.
 259    *
 260    * @param opPos The current position in the m_opMap array.
 261    *
 262    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.And} instance.
 263    *
 264    * @throws TransformerException if a error occurs creating the Expression.
 265    */
 266   protected Expression and(int opPos) throws TransformerException
 267   {
 268     return compileOperation(new And(), opPos);
 269   }
 270 
 271   /**
 272    * Compile a &#39;!=&#39; operation.
 273    *
 274    * @param opPos The current position in the m_opMap array.
 275    *
 276    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.NotEquals} instance.
 277    *
 278    * @throws TransformerException if a error occurs creating the Expression.
 279    */
 280   protected Expression notequals(int opPos) throws TransformerException
 281   {
 282     return compileOperation(new NotEquals(), opPos);
 283   }
 284 
 285   /**
 286    * Compile a &#39;=&#39; operation.
 287    *
 288    * @param opPos The current position in the m_opMap array.
 289    *
 290    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Equals} instance.
 291    *
 292    * @throws TransformerException if a error occurs creating the Expression.
 293    */
 294   protected Expression equals(int opPos) throws TransformerException
 295   {
 296     return compileOperation(new Equals(), opPos);
 297   }
 298 
 299   /**
 300    * Compile a &#39;&lt;=&#39; operation.
 301    *
 302    * @param opPos The current position in the m_opMap array.
 303    *
 304    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Lte} instance.
 305    *
 306    * @throws TransformerException if a error occurs creating the Expression.
 307    */
 308   protected Expression lte(int opPos) throws TransformerException
 309   {
 310     return compileOperation(new Lte(), opPos);
 311   }
 312 
 313   /**
 314    * Compile a &#39;&lt;&#39; operation.
 315    *
 316    * @param opPos The current position in the m_opMap array.
 317    *
 318    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Lt} instance.
 319    *
 320    * @throws TransformerException if a error occurs creating the Expression.
 321    */
 322   protected Expression lt(int opPos) throws TransformerException
 323   {
 324     return compileOperation(new Lt(), opPos);
 325   }
 326 
 327   /**
 328    * Compile a &#39;&gt;=&#39; operation.
 329    *
 330    * @param opPos The current position in the m_opMap array.
 331    *
 332    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Gte} instance.
 333    *
 334    * @throws TransformerException if a error occurs creating the Expression.
 335    */
 336   protected Expression gte(int opPos) throws TransformerException
 337   {
 338     return compileOperation(new Gte(), opPos);
 339   }
 340 
 341   /**
 342    * Compile a &#39;&gt;&#39; operation.
 343    *
 344    * @param opPos The current position in the m_opMap array.
 345    *
 346    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Gt} instance.
 347    *
 348    * @throws TransformerException if a error occurs creating the Expression.
 349    */
 350   protected Expression gt(int opPos) throws TransformerException
 351   {
 352     return compileOperation(new Gt(), opPos);
 353   }
 354 
 355   /**
 356    * Compile a &#39;+&#39; operation.
 357    *
 358    * @param opPos The current position in the m_opMap array.
 359    *
 360    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Plus} instance.
 361    *
 362    * @throws TransformerException if a error occurs creating the Expression.
 363    */
 364   protected Expression plus(int opPos) throws TransformerException
 365   {
 366     return compileOperation(new Plus(), opPos);
 367   }
 368 
 369   /**
 370    * Compile a &#39;-&#39; operation.
 371    *
 372    * @param opPos The current position in the m_opMap array.
 373    *
 374    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Minus} instance.
 375    *
 376    * @throws TransformerException if a error occurs creating the Expression.
 377    */
 378   protected Expression minus(int opPos) throws TransformerException
 379   {
 380     return compileOperation(new Minus(), opPos);
 381   }
 382 
 383   /**
 384    * Compile a &#39;*&#39; operation.
 385    *
 386    * @param opPos The current position in the m_opMap array.
 387    *
 388    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Mult} instance.
 389    *
 390    * @throws TransformerException if a error occurs creating the Expression.
 391    */
 392   protected Expression mult(int opPos) throws TransformerException
 393   {
 394     return compileOperation(new Mult(), opPos);
 395   }
 396 
 397   /**
 398    * Compile a &#39;div&#39; operation.
 399    *
 400    * @param opPos The current position in the m_opMap array.
 401    *
 402    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Div} instance.
 403    *
 404    * @throws TransformerException if a error occurs creating the Expression.
 405    */
 406   protected Expression div(int opPos) throws TransformerException
 407   {
 408     return compileOperation(new Div(), opPos);
 409   }
 410 
 411   /**
 412    * Compile a &#39;mod&#39; operation.
 413    *
 414    * @param opPos The current position in the m_opMap array.
 415    *
 416    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Mod} instance.
 417    *
 418    * @throws TransformerException if a error occurs creating the Expression.
 419    */
 420   protected Expression mod(int opPos) throws TransformerException
 421   {
 422     return compileOperation(new Mod(), opPos);
 423   }
 424 
 425   /*
 426    * Compile a &#39;quo&#39; operation.
 427    *
 428    * @param opPos The current position in the m_opMap array.
 429    *
 430    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Quo} instance.
 431    *
 432    * @throws TransformerException if a error occurs creating the Expression.
 433    */
 434 //  protected Expression quo(int opPos) throws TransformerException
 435 //  {
 436 //    return compileOperation(new Quo(), opPos);
 437 //  }
 438 
 439   /**
 440    * Compile a unary &#39;-&#39; operation.
 441    *
 442    * @param opPos The current position in the m_opMap array.
 443    *
 444    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Neg} instance.
 445    *
 446    * @throws TransformerException if a error occurs creating the Expression.
 447    */
 448   protected Expression neg(int opPos) throws TransformerException
 449   {
 450     return compileUnary(new Neg(), opPos);
 451   }
 452 
 453   /**
 454    * Compile a &#39;string(...)&#39; operation.
 455    *
 456    * @param opPos The current position in the m_opMap array.
 457    *
 458    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.String} instance.
 459    *
 460    * @throws TransformerException if a error occurs creating the Expression.
 461    */
 462   protected Expression string(int opPos) throws TransformerException
 463   {
 464     return compileUnary(new com.sun.org.apache.xpath.internal.operations.String(), opPos);
 465   }
 466 
 467   /**
 468    * Compile a &#39;boolean(...)&#39; operation.
 469    *
 470    * @param opPos The current position in the m_opMap array.
 471    *
 472    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Bool} instance.
 473    *
 474    * @throws TransformerException if a error occurs creating the Expression.
 475    */
 476   protected Expression bool(int opPos) throws TransformerException
 477   {
 478     return compileUnary(new com.sun.org.apache.xpath.internal.operations.Bool(), opPos);
 479   }
 480 
 481   /**
 482    * Compile a &#39;number(...)&#39; operation.
 483    *
 484    * @param opPos The current position in the m_opMap array.
 485    *
 486    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Number} instance.
 487    *
 488    * @throws TransformerException if a error occurs creating the Expression.
 489    */
 490   protected Expression number(int opPos) throws TransformerException
 491   {
 492     return compileUnary(new com.sun.org.apache.xpath.internal.operations.Number(), opPos);
 493   }
 494 
 495   /**
 496    * Compile a literal string value.
 497    *
 498    * @param opPos The current position in the m_opMap array.
 499    *
 500    * @return reference to {@link com.sun.org.apache.xpath.internal.objects.XString} instance.
 501    *
 502    * @throws TransformerException if a error occurs creating the Expression.
 503    */
 504   protected Expression literal(int opPos)
 505   {
 506 
 507     opPos = getFirstChildPos(opPos);
 508 
 509     return (XString) getTokenQueue().elementAt(getOp(opPos));
 510   }
 511 
 512   /**
 513    * Compile a literal number value.
 514    *
 515    * @param opPos The current position in the m_opMap array.
 516    *
 517    * @return reference to {@link com.sun.org.apache.xpath.internal.objects.XNumber} instance.
 518    *
 519    * @throws TransformerException if a error occurs creating the Expression.
 520    */
 521   protected Expression numberlit(int opPos)
 522   {
 523 
 524     opPos = getFirstChildPos(opPos);
 525 
 526     return (XNumber) getTokenQueue().elementAt(getOp(opPos));
 527   }
 528 
 529   /**
 530    * Compile a variable reference.
 531    *
 532    * @param opPos The current position in the m_opMap array.
 533    *
 534    * @return reference to {@link com.sun.org.apache.xpath.internal.operations.Variable} instance.
 535    *
 536    * @throws TransformerException if a error occurs creating the Expression.
 537    */
 538   protected Expression variable(int opPos) throws TransformerException
 539   {
 540 
 541     Variable var = new Variable();
 542 
 543     opPos = getFirstChildPos(opPos);
 544 
 545     int nsPos = getOp(opPos);
 546     java.lang.String namespace
 547       = (OpCodes.EMPTY == nsPos) ? null
 548                                    : (java.lang.String) getTokenQueue().elementAt(nsPos);
 549     java.lang.String localname
 550       = (java.lang.String) getTokenQueue().elementAt(getOp(opPos+1));
 551     QName qname = new QName(namespace, localname);
 552 
 553     var.setQName(qname);
 554 
 555     return var;
 556   }
 557 
 558   /**
 559    * Compile an expression group.
 560    *
 561    * @param opPos The current position in the m_opMap array.
 562    *
 563    * @return reference to the contained expression.
 564    *
 565    * @throws TransformerException if a error occurs creating the Expression.
 566    */
 567   protected Expression group(int opPos) throws TransformerException
 568   {
 569 
 570     // no-op
 571     return compile(opPos + 2);
 572   }
 573 
 574   /**
 575    * Compile a function argument.
 576    *
 577    * @param opPos The current position in the m_opMap array.
 578    *
 579    * @return reference to the argument expression.
 580    *
 581    * @throws TransformerException if a error occurs creating the Expression.
 582    */
 583   protected Expression arg(int opPos) throws TransformerException
 584   {
 585 
 586     // no-op
 587     return compile(opPos + 2);
 588   }
 589 
 590   /**
 591    * Compile a location path union. The UnionPathIterator itself may create
 592    * {@link com.sun.org.apache.xpath.internal.axes.LocPathIterator} children.
 593    *
 594    * @param opPos The current position in the m_opMap array.
 595    *
 596    * @return reference to {@link com.sun.org.apache.xpath.internal.axes.LocPathIterator} instance.
 597    *
 598    * @throws TransformerException if a error occurs creating the Expression.
 599    */
 600   protected Expression union(int opPos) throws TransformerException
 601   {
 602     locPathDepth++;
 603     try
 604     {
 605       return UnionPathIterator.createUnionIterator(this, opPos);
 606     }
 607     finally
 608     {
 609       locPathDepth--;
 610     }
 611   }
 612 
 613   private int locPathDepth = -1;
 614 
 615   /**
 616    * Get the level of the location path or union being constructed.
 617    * @return 0 if it is a top-level path.
 618    */
 619   public int getLocationPathDepth()
 620   {
 621     return locPathDepth;
 622   }
 623 
 624   /**
 625    * Get the function table
 626    */
 627   FunctionTable getFunctionTable()
 628   {
 629     return m_functionTable;
 630   }
 631 
 632   /**
 633    * Compile a location path.  The LocPathIterator itself may create
 634    * {@link com.sun.org.apache.xpath.internal.axes.AxesWalker} children.
 635    *
 636    * @param opPos The current position in the m_opMap array.
 637    *
 638    * @return reference to {@link com.sun.org.apache.xpath.internal.axes.LocPathIterator} instance.
 639    *
 640    * @throws TransformerException if a error occurs creating the Expression.
 641    */
 642   public Expression locationPath(int opPos) throws TransformerException
 643   {
 644     locPathDepth++;
 645     try
 646     {
 647       DTMIterator iter = WalkerFactory.newDTMIterator(this, opPos, (locPathDepth == 0));
 648       return (Expression)iter; // cast OK, I guess.
 649     }
 650     finally
 651     {
 652       locPathDepth--;
 653     }
 654   }
 655 
 656   /**
 657    * Compile a location step predicate expression.
 658    *
 659    * @param opPos The current position in the m_opMap array.
 660    *
 661    * @return the contained predicate expression.
 662    *
 663    * @throws TransformerException if a error occurs creating the Expression.
 664    */
 665   public Expression predicate(int opPos) throws TransformerException
 666   {
 667     return compile(opPos + 2);
 668   }
 669 
 670   /**
 671    * Compile an entire match pattern expression.
 672    *
 673    * @param opPos The current position in the m_opMap array.
 674    *
 675    * @return reference to {@link com.sun.org.apache.xpath.internal.patterns.UnionPattern} instance.
 676    *
 677    * @throws TransformerException if a error occurs creating the Expression.
 678    */
 679   protected Expression matchPattern(int opPos) throws TransformerException
 680   {
 681     locPathDepth++;
 682     try
 683     {
 684       // First, count...
 685       int nextOpPos = opPos;
 686       int i;
 687 
 688       for (i = 0; getOp(nextOpPos) == OpCodes.OP_LOCATIONPATHPATTERN; i++)
 689       {
 690         nextOpPos = getNextOpPos(nextOpPos);
 691       }
 692 
 693       if (i == 1)
 694         return compile(opPos);
 695 
 696       UnionPattern up = new UnionPattern();
 697       StepPattern[] patterns = new StepPattern[i];
 698 
 699       for (i = 0; getOp(opPos) == OpCodes.OP_LOCATIONPATHPATTERN; i++)
 700       {
 701         nextOpPos = getNextOpPos(opPos);
 702         patterns[i] = (StepPattern) compile(opPos);
 703         opPos = nextOpPos;
 704       }
 705 
 706       up.setPatterns(patterns);
 707 
 708       return up;
 709     }
 710     finally
 711     {
 712       locPathDepth--;
 713     }
 714   }
 715 
 716   /**
 717    * Compile a location match pattern unit expression.
 718    *
 719    * @param opPos The current position in the m_opMap array.
 720    *
 721    * @return reference to {@link com.sun.org.apache.xpath.internal.patterns.StepPattern} instance.
 722    *
 723    * @throws TransformerException if a error occurs creating the Expression.
 724    */
 725   public Expression locationPathPattern(int opPos)
 726           throws TransformerException
 727   {
 728 
 729     opPos = getFirstChildPos(opPos);
 730 
 731     return stepPattern(opPos, 0, null);
 732   }
 733 
 734   /**
 735    * Get a {@link org.w3c.dom.traversal.NodeFilter} bit set that tells what
 736    * to show for a given node test.
 737    *
 738    * @param opPos the op map position for the location step.
 739    *
 740    * @return {@link org.w3c.dom.traversal.NodeFilter} bit set that tells what
 741    *         to show for a given node test.
 742    */
 743   public int getWhatToShow(int opPos)
 744   {
 745 
 746     int axesType = getOp(opPos);
 747     int testType = getOp(opPos + 3);
 748 
 749     // System.out.println(&quot;testType: &quot;+testType);
 750     switch (testType)
 751     {
 752     case OpCodes.NODETYPE_COMMENT :
 753       return DTMFilter.SHOW_COMMENT;
 754     case OpCodes.NODETYPE_TEXT :
 755 //      return DTMFilter.SHOW_TEXT | DTMFilter.SHOW_COMMENT;
 756       return DTMFilter.SHOW_TEXT | DTMFilter.SHOW_CDATA_SECTION ;
 757     case OpCodes.NODETYPE_PI :
 758       return DTMFilter.SHOW_PROCESSING_INSTRUCTION;
 759     case OpCodes.NODETYPE_NODE :
 760 //      return DTMFilter.SHOW_ALL;
 761       switch (axesType)
 762       {
 763       case OpCodes.FROM_NAMESPACE:
 764         return DTMFilter.SHOW_NAMESPACE;
 765       case OpCodes.FROM_ATTRIBUTES :
 766       case OpCodes.MATCH_ATTRIBUTE :
 767         return DTMFilter.SHOW_ATTRIBUTE;
 768       case OpCodes.FROM_SELF:
 769       case OpCodes.FROM_ANCESTORS_OR_SELF:
 770       case OpCodes.FROM_DESCENDANTS_OR_SELF:
 771         return DTMFilter.SHOW_ALL;
 772       default:
 773         if (getOp(0) == OpCodes.OP_MATCHPATTERN)
 774           return ~DTMFilter.SHOW_ATTRIBUTE
 775                   &amp; ~DTMFilter.SHOW_DOCUMENT
 776                   &amp; ~DTMFilter.SHOW_DOCUMENT_FRAGMENT;
 777         else
 778           return ~DTMFilter.SHOW_ATTRIBUTE;
 779       }
 780     case OpCodes.NODETYPE_ROOT :
 781       return DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT;
 782     case OpCodes.NODETYPE_FUNCTEST :
 783       return NodeTest.SHOW_BYFUNCTION;
 784     case OpCodes.NODENAME :
 785       switch (axesType)
 786       {
 787       case OpCodes.FROM_NAMESPACE :
 788         return DTMFilter.SHOW_NAMESPACE;
 789       case OpCodes.FROM_ATTRIBUTES :
 790       case OpCodes.MATCH_ATTRIBUTE :
 791         return DTMFilter.SHOW_ATTRIBUTE;
 792 
 793       // break;
 794       case OpCodes.MATCH_ANY_ANCESTOR :
 795       case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
 796         return DTMFilter.SHOW_ELEMENT;
 797 
 798       // break;
 799       default :
 800         return DTMFilter.SHOW_ELEMENT;
 801       }
 802     default :
 803       // System.err.println(&quot;We should never reach here.&quot;);
 804       return DTMFilter.SHOW_ALL;
 805     }
 806   }
 807 
 808 private static final boolean DEBUG = false;
 809 
 810   /**
 811    * Compile a step pattern unit expression, used for both location paths
 812    * and match patterns.
 813    *
 814    * @param opPos The current position in the m_opMap array.
 815    * @param stepCount The number of steps to expect.
 816    * @param ancestorPattern The owning StepPattern, which may be null.
 817    *
 818    * @return reference to {@link com.sun.org.apache.xpath.internal.patterns.StepPattern} instance.
 819    *
 820    * @throws TransformerException if a error occurs creating the Expression.
 821    */
 822   protected StepPattern stepPattern(
 823           int opPos, int stepCount, StepPattern ancestorPattern)
 824             throws TransformerException
 825   {
 826 
 827     int startOpPos = opPos;
 828     int stepType = getOp(opPos);
 829 
 830     if (OpCodes.ENDOP == stepType)
 831     {
 832       return null;
 833     }
 834 
 835     boolean addMagicSelf = true;
 836 
 837     int endStep = getNextOpPos(opPos);
 838 
 839     // int nextStepType = getOpMap()[endStep];
 840     StepPattern pattern;
 841 
 842     // boolean isSimple = ((OpCodes.ENDOP == nextStepType) &amp;&amp; (stepCount == 0));
 843     int argLen;
 844 
 845     switch (stepType)
 846     {
 847     case OpCodes.OP_FUNCTION :
 848       if(DEBUG)
 849         System.out.println(&quot;MATCH_FUNCTION: &quot;+m_currentPattern);
 850       addMagicSelf = false;
 851       argLen = getOp(opPos + OpMap.MAPINDEX_LENGTH);
 852       pattern = new FunctionPattern(compileFunction(opPos), Axis.PARENT, Axis.CHILD);
 853       break;
 854     case OpCodes.FROM_ROOT :
 855       if(DEBUG)
 856         System.out.println(&quot;FROM_ROOT, &quot;+m_currentPattern);
 857       addMagicSelf = false;
 858       argLen = getArgLengthOfStep(opPos);
 859       opPos = getFirstChildPosOfStep(opPos);
 860       pattern = new StepPattern(DTMFilter.SHOW_DOCUMENT |
 861                                 DTMFilter.SHOW_DOCUMENT_FRAGMENT,
 862                                 Axis.PARENT, Axis.CHILD);
 863       break;
 864     case OpCodes.MATCH_ATTRIBUTE :
 865      if(DEBUG)
 866         System.out.println(&quot;MATCH_ATTRIBUTE: &quot;+getStepLocalName(startOpPos)+&quot;, &quot;+m_currentPattern);
 867       argLen = getArgLengthOfStep(opPos);
 868       opPos = getFirstChildPosOfStep(opPos);
 869       pattern = new StepPattern(DTMFilter.SHOW_ATTRIBUTE,
 870                                 getStepNS(startOpPos),
 871                                 getStepLocalName(startOpPos),
 872                                 Axis.PARENT, Axis.ATTRIBUTE);
 873       break;
 874     case OpCodes.MATCH_ANY_ANCESTOR :
 875       if(DEBUG)
 876         System.out.println(&quot;MATCH_ANY_ANCESTOR: &quot;+getStepLocalName(startOpPos)+&quot;, &quot;+m_currentPattern);
 877       argLen = getArgLengthOfStep(opPos);
 878       opPos = getFirstChildPosOfStep(opPos);
 879       int what = getWhatToShow(startOpPos);
 880       // bit-o-hackery, but this code is due for the morgue anyway...
 881       if(0x00000500 == what)
 882         addMagicSelf = false;
 883       pattern = new StepPattern(getWhatToShow(startOpPos),
 884                                         getStepNS(startOpPos),
 885                                         getStepLocalName(startOpPos),
 886                                         Axis.ANCESTOR, Axis.CHILD);
 887       break;
 888     case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
 889       if(DEBUG)
 890         System.out.println(&quot;MATCH_IMMEDIATE_ANCESTOR: &quot;+getStepLocalName(startOpPos)+&quot;, &quot;+m_currentPattern);
 891       argLen = getArgLengthOfStep(opPos);
 892       opPos = getFirstChildPosOfStep(opPos);
 893       pattern = new StepPattern(getWhatToShow(startOpPos),
 894                                 getStepNS(startOpPos),
 895                                 getStepLocalName(startOpPos),
 896                                 Axis.PARENT, Axis.CHILD);
 897       break;
 898     default :
 899       error(XPATHErrorResources.ER_UNKNOWN_MATCH_OPERATION, null);  //&quot;unknown match operation!&quot;);
 900 
 901       return null;
 902     }
 903 
 904     pattern.setPredicates(getCompiledPredicates(opPos + argLen));
 905     if(null == ancestorPattern)
 906     {
 907       // This is the magic and invisible &quot;.&quot; at the head of every
 908       // match pattern, and corresponds to the current node in the context
 909       // list, from where predicates are counted.
 910       // So, in order to calculate &quot;foo[3]&quot;, it has to count from the
 911       // current node in the context list, so, from that current node,
 912       // the full pattern is really &quot;self::node()/child::foo[3]&quot;.  If you
 913       // translate this to a select pattern from the node being tested,
 914       // which is really how we&#39;re treating match patterns, it works out to
 915       // self::foo/parent::node[child::foo[3]]&quot;, or close enough.
 916         /*      if(addMagicSelf &amp;&amp; pattern.getPredicateCount() &gt; 0)
 917       {
 918         StepPattern selfPattern = new StepPattern(DTMFilter.SHOW_ALL,
 919                                                   Axis.PARENT, Axis.CHILD);
 920         // We need to keep the new nodetest from affecting the score...
 921         XNumber score = pattern.getStaticScore();
 922         pattern.setRelativePathPattern(selfPattern);
 923         pattern.setStaticScore(score);
 924         selfPattern.setStaticScore(score);
 925         }*/
 926     }
 927     else
 928     {
 929       // System.out.println(&quot;Setting &quot;+ancestorPattern+&quot; as relative to &quot;+pattern);
 930       pattern.setRelativePathPattern(ancestorPattern);
 931     }
 932 
 933     StepPattern relativePathPattern = stepPattern(endStep, stepCount + 1,
 934                                         pattern);
 935 
 936     return (null != relativePathPattern) ? relativePathPattern : pattern;
 937   }
 938 
 939   /**
 940    * Compile a zero or more predicates for a given match pattern.
 941    *
 942    * @param opPos The position of the first predicate the m_opMap array.
 943    *
 944    * @return reference to array of {@link com.sun.org.apache.xpath.internal.Expression} instances.
 945    *
 946    * @throws TransformerException if a error occurs creating the Expression.
 947    */
 948   public Expression[] getCompiledPredicates(int opPos)
 949           throws TransformerException
 950   {
 951 
 952     int count = countPredicates(opPos);
 953 
 954     if (count &gt; 0)
 955     {
 956       Expression[] predicates = new Expression[count];
 957 
 958       compilePredicates(opPos, predicates);
 959 
 960       return predicates;
 961     }
 962 
 963     return null;
 964   }
 965 
 966   /**
 967    * Count the number of predicates in the step.
 968    *
 969    * @param opPos The position of the first predicate the m_opMap array.
 970    *
 971    * @return The number of predicates for this step.
 972    *
 973    * @throws TransformerException if a error occurs creating the Expression.
 974    */
 975   public int countPredicates(int opPos) throws TransformerException
 976   {
 977 
 978     int count = 0;
 979 
 980     while (OpCodes.OP_PREDICATE == getOp(opPos))
 981     {
 982       count++;
 983 
 984       opPos = getNextOpPos(opPos);
 985     }
 986 
 987     return count;
 988   }
 989 
 990   /**
 991    * Compiles predicates in the step.
 992    *
 993    * @param opPos The position of the first predicate the m_opMap array.
 994    * @param predicates An empty pre-determined array of
 995    *            {@link com.sun.org.apache.xpath.internal.Expression}s, that will be filled in.
 996    *
 997    * @throws TransformerException
 998    */
 999   private void compilePredicates(int opPos, Expression[] predicates)
1000           throws TransformerException
1001   {
1002 
1003     for (int i = 0; OpCodes.OP_PREDICATE == getOp(opPos); i++)
1004     {
1005       predicates[i] = predicate(opPos);
1006       opPos = getNextOpPos(opPos);
1007     }
1008   }
1009 
1010   /**
1011    * Compile a built-in XPath function.
1012    *
1013    * @param opPos The current position in the m_opMap array.
1014    *
1015    * @return reference to {@link com.sun.org.apache.xpath.internal.functions.Function} instance.
1016    *
1017    * @throws TransformerException if a error occurs creating the Expression.
1018    */
1019   Expression compileFunction(int opPos) throws TransformerException
1020   {
1021 
1022     int endFunc = opPos + getOp(opPos + 1) - 1;
1023 
1024     opPos = getFirstChildPos(opPos);
1025 
1026     int funcID = getOp(opPos);
1027 
1028     opPos++;
1029 
1030     if (-1 != funcID)
1031     {
1032       Function func = m_functionTable.getFunction(funcID);
1033 
1034       /**
1035        * It is a trick for function-available. Since the function table is an
1036        * instance field, insert this table at compilation time for later usage
1037        */
1038 
1039       if (func instanceof FuncExtFunctionAvailable)
1040           ((FuncExtFunctionAvailable) func).setFunctionTable(m_functionTable);
1041 
1042       func.postCompileStep(this);
1043 
1044       try
1045       {
1046         int i = 0;
1047 
1048         for (int p = opPos; p &lt; endFunc; p = getNextOpPos(p), i++)
1049         {
1050 
1051           // System.out.println(&quot;argPos: &quot;+ p);
1052           // System.out.println(&quot;argCode: &quot;+ m_opMap[p]);
1053           func.setArg(compile(p), i);
1054         }
1055 
1056         func.checkNumberArgs(i);
1057       }
1058       catch (WrongNumberArgsException wnae)
1059       {
1060         java.lang.String name = m_functionTable.getFunctionName(funcID);
1061 
1062         m_errorHandler.fatalError( new TransformerException(
1063                   XSLMessages.createXPATHMessage(XPATHErrorResources.ER_ONLY_ALLOWS,
1064                       new Object[]{name, wnae.getMessage()}), m_locator));
1065               //&quot;name + &quot; only allows &quot; + wnae.getMessage() + &quot; arguments&quot;, m_locator));
1066       }
1067 
1068       return func;
1069     }
1070     else
1071     {
1072       error(XPATHErrorResources.ER_FUNCTION_TOKEN_NOT_FOUND, null);  //&quot;function token not found.&quot;);
1073 
1074       return null;
1075     }
1076   }
1077 
1078   // The current id for extension functions.
1079   private static long s_nextMethodId = 0;
1080 
1081   /**
1082    * Get the next available method id
1083    */
1084   synchronized private long getNextMethodId()
1085   {
1086     if (s_nextMethodId == Long.MAX_VALUE)
1087       s_nextMethodId = 0;
1088 
1089     return s_nextMethodId++;
1090   }
1091 
1092   /**
1093    * Compile an extension function.
1094    *
1095    * @param opPos The current position in the m_opMap array.
1096    *
1097    * @return reference to {@link com.sun.org.apache.xpath.internal.functions.FuncExtFunction} instance.
1098    *
1099    * @throws TransformerException if a error occurs creating the Expression.
1100    */
1101   private Expression compileExtension(int opPos)
1102           throws TransformerException
1103   {
1104 
1105     int endExtFunc = opPos + getOp(opPos + 1) - 1;
1106 
1107     opPos = getFirstChildPos(opPos);
1108 
1109     java.lang.String ns = (java.lang.String) getTokenQueue().elementAt(getOp(opPos));
1110 
1111     opPos++;
1112 
1113     java.lang.String funcName =
1114       (java.lang.String) getTokenQueue().elementAt(getOp(opPos));
1115 
1116     opPos++;
1117 
1118     // We create a method key to uniquely identify this function so that we
1119     // can cache the object needed to invoke it.  This way, we only pay the
1120     // reflection overhead on the first call.
1121 
1122     Function extension = new FuncExtFunction(ns, funcName, String.valueOf(getNextMethodId()));
1123 
1124     try
1125     {
1126       int i = 0;
1127 
1128       while (opPos &lt; endExtFunc)
1129       {
1130         int nextOpPos = getNextOpPos(opPos);
1131 
1132         extension.setArg(this.compile(opPos), i);
1133 
1134         opPos = nextOpPos;
1135 
1136         i++;
1137       }
1138     }
1139     catch (WrongNumberArgsException wnae)
1140     {
1141       ;  // should never happen
1142     }
1143 
1144     return extension;
1145   }
1146 
1147   /**
1148    * Warn the user of an problem.
1149    *
1150    * @param msg An error msgkey that corresponds to one of the constants found
1151    *            in {@link com.sun.org.apache.xpath.internal.res.XPATHErrorResources}, which is
1152    *            a key for a format string.
1153    * @param args An array of arguments represented in the format string, which
1154    *             may be null.
1155    *
1156    * @throws TransformerException if the current ErrorListoner determines to
1157    *                              throw an exception.
1158    */
1159   public void warn(String msg, Object[] args) throws TransformerException
1160   {
1161 
1162     java.lang.String fmsg = XSLMessages.createXPATHWarning(msg, args);
1163 
1164     if (null != m_errorHandler)
1165     {
1166       m_errorHandler.warning(new TransformerException(fmsg, m_locator));
1167     }
1168     else
1169     {
1170       System.out.println(fmsg
1171                           +&quot;; file &quot;+m_locator.getSystemId()
1172                           +&quot;; line &quot;+m_locator.getLineNumber()
1173                           +&quot;; column &quot;+m_locator.getColumnNumber());
1174     }
1175   }
1176 
1177   /**
1178    * Tell the user of an assertion error, and probably throw an
1179    * exception.
1180    *
1181    * @param b  If false, a runtime exception will be thrown.
1182    * @param msg The assertion message, which should be informative.
1183    *
1184    * @throws RuntimeException if the b argument is false.
1185    */
1186   public void assertion(boolean b, java.lang.String msg)
1187   {
1188 
1189     if (!b)
1190     {
1191       java.lang.String fMsg = XSLMessages.createXPATHMessage(
1192         XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
1193         new Object[]{ msg });
1194 
1195       throw new RuntimeException(fMsg);
1196     }
1197   }
1198 
1199   /**
1200    * Tell the user of an error, and probably throw an
1201    * exception.
1202    *
1203    * @param msg An error msgkey that corresponds to one of the constants found
1204    *            in {@link com.sun.org.apache.xpath.internal.res.XPATHErrorResources}, which is
1205    *            a key for a format string.
1206    * @param args An array of arguments represented in the format string, which
1207    *             may be null.
1208    *
1209    * @throws TransformerException if the current ErrorListoner determines to
1210    *                              throw an exception.
1211    */
1212   public void error(String msg, Object[] args) throws TransformerException
1213   {
1214 
1215     java.lang.String fmsg = XSLMessages.createXPATHMessage(msg, args);
1216 
1217 
1218     if (null != m_errorHandler)
1219     {
1220       m_errorHandler.fatalError(new TransformerException(fmsg, m_locator));
1221     }
1222     else
1223     {
1224 
1225       // System.out.println(te.getMessage()
1226       //                    +&quot;; file &quot;+te.getSystemId()
1227       //                    +&quot;; line &quot;+te.getLineNumber()
1228       //                    +&quot;; column &quot;+te.getColumnNumber());
1229       throw new TransformerException(fmsg, (SAXSourceLocator)m_locator);
1230     }
1231   }
1232 
1233   /**
1234    * The current prefixResolver for the execution context.
1235    */
1236   private PrefixResolver m_currentPrefixResolver = null;
1237 
1238   /**
1239    * Get the current namespace context for the xpath.
1240    *
1241    * @return The current prefix resolver, *may* be null, though hopefully not.
1242    */
1243   public PrefixResolver getNamespaceContext()
1244   {
1245     return m_currentPrefixResolver;
1246   }
1247 
1248   /**
1249    * Set the current namespace context for the xpath.
1250    *
1251    * @param pr The resolver for prefixes in the XPath expression.
1252    */
1253   public void setNamespaceContext(PrefixResolver pr)
1254   {
1255     m_currentPrefixResolver = pr;
1256   }
1257 
1258   /** The error listener where errors will be sent.  If this is null, errors
1259    *  and warnings will be sent to System.err.  May be null.    */
1260   ErrorListener m_errorHandler;
1261 
1262   /** The source locator for the expression being compiled.  May be null. */
1263   SourceLocator m_locator;
1264 
1265   /**
1266    * The FunctionTable for all xpath build-in functions
1267    */
1268   private FunctionTable m_functionTable;
1269 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
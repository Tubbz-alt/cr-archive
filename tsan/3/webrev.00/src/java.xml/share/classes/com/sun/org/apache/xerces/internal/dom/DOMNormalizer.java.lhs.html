<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/DOMNormalizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 
  24 
<a name="2" id="anc2"></a><span class="line-removed">  25 import com.sun.org.apache.xerces.internal.dom.AbortException;</span>
  26 import com.sun.org.apache.xerces.internal.impl.Constants;
  27 import com.sun.org.apache.xerces.internal.impl.RevalidationHandler;
<a name="3" id="anc3"></a><span class="line-modified">  28 import com.sun.org.apache.xerces.internal.impl.dtd.DTDGrammar;</span>
<span class="line-removed">  29 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDDescription;</span>
  30 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator;
  31 import com.sun.org.apache.xerces.internal.impl.dv.XSSimpleType;
  32 import com.sun.org.apache.xerces.internal.impl.xs.util.SimpleLocator;
<a name="4" id="anc4"></a><span class="line-removed">  33 import com.sun.org.apache.xerces.internal.parsers.XMLGrammarPreparser;</span>
  34 import com.sun.org.apache.xerces.internal.util.AugmentationsImpl;
  35 import com.sun.org.apache.xerces.internal.util.NamespaceSupport;
  36 import com.sun.org.apache.xerces.internal.util.SymbolTable;
  37 import com.sun.org.apache.xerces.internal.util.XML11Char;
  38 import com.sun.org.apache.xerces.internal.util.XMLChar;
<a name="5" id="anc5"></a><span class="line-removed">  39 import com.sun.org.apache.xerces.internal.util.XMLGrammarPoolImpl;</span>
  40 import com.sun.org.apache.xerces.internal.util.XMLSymbols;
  41 import com.sun.org.apache.xerces.internal.xni.Augmentations;
  42 import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
  43 import com.sun.org.apache.xerces.internal.xni.QName;
  44 import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
  45 import com.sun.org.apache.xerces.internal.xni.XMLDocumentHandler;
  46 import com.sun.org.apache.xerces.internal.xni.XMLLocator;
  47 import com.sun.org.apache.xerces.internal.xni.XMLResourceIdentifier;
  48 import com.sun.org.apache.xerces.internal.xni.XMLString;
  49 import com.sun.org.apache.xerces.internal.xni.XNIException;
  50 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarDescription;
<a name="6" id="anc6"></a><span class="line-removed">  51 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarPool;</span>
  52 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponent;
  53 import com.sun.org.apache.xerces.internal.xni.parser.XMLDocumentSource;
<a name="7" id="anc7"></a><span class="line-removed">  54 import com.sun.org.apache.xerces.internal.xni.parser.XMLInputSource;</span>
  55 import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
  56 import com.sun.org.apache.xerces.internal.xs.ElementPSVI;
  57 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
  58 import java.io.IOException;
<a name="8" id="anc8"></a><span class="line-removed">  59 import java.io.StringReader;</span>
  60 import java.util.ArrayList;
  61 import java.util.List;
  62 import java.util.Vector;
  63 import org.w3c.dom.Attr;
  64 import org.w3c.dom.Comment;
  65 import org.w3c.dom.DOMError;
  66 import org.w3c.dom.DOMErrorHandler;
  67 import org.w3c.dom.Document;
  68 import org.w3c.dom.DocumentType;
  69 import org.w3c.dom.Element;
  70 import org.w3c.dom.Entity;
  71 import org.w3c.dom.NamedNodeMap;
  72 import org.w3c.dom.Node;
  73 import org.w3c.dom.NodeList;
  74 import org.w3c.dom.ProcessingInstruction;
  75 import org.w3c.dom.Text;
  76 /**
  77  * This class adds implementation for normalizeDocument method.
  78  * It acts as if the document was going through a save and load cycle, putting
  79  * the document in a &quot;normal&quot; form. The actual result depends on the features being set
  80  * and governing what operations actually take place. See setNormalizationFeature for details.
  81  * Noticeably this method normalizes Text nodes, makes the document &quot;namespace wellformed&quot;,
  82  * according to the algorithm described below in pseudo code, by adding missing namespace
  83  * declaration attributes and adding or changing namespace prefixes, updates the replacement
  84  * tree of EntityReference nodes, normalizes attribute values, etc.
  85  * Mutation events, when supported, are generated to reflect the changes occuring on the
  86  * document.
  87  * See Namespace normalization for details on how namespace declaration attributes and prefixes
  88  * are normalized.
  89  *
  90  * NOTE: There is an initial support for DOM revalidation with XML Schema as a grammar.
  91  * The tree might not be validated correctly if entityReferences, CDATA sections are
  92  * present in the tree. The PSVI information is not exposed, normalized data (including element
  93  * default content is not available).
  94  *
  95  * @xerces.experimental
  96  *
  97  * @author Elena Litani, IBM
  98  * @author Neeraj Bajaj, Sun Microsystems, inc.
<a name="9" id="anc9"></a><span class="line-modified">  99  * @LastModified: Nov 2017</span>
 100  */
 101 public class DOMNormalizer implements XMLDocumentHandler {
 102 
 103     //
 104     // constants
 105     //
 106     /** Debug normalize document*/
 107     protected final static boolean DEBUG_ND = false;
 108     /** Debug namespace fix up algorithm*/
 109     protected final static boolean DEBUG = false;
 110     /** Debug document handler events */
 111     protected final static boolean DEBUG_EVENTS = false;
 112 
 113     /** prefix added by namespace fixup algorithm should follow a pattern &quot;NS&quot; + index*/
 114     protected final static String PREFIX = &quot;NS&quot;;
 115 
 116     //
 117     // Data
 118     //
 119     protected DOMConfigurationImpl fConfiguration = null;
 120     protected CoreDocumentImpl fDocument = null;
 121     protected final XMLAttributesProxy fAttrProxy = new XMLAttributesProxy();
 122     protected final QName fQName = new QName();
 123 
 124     /** Validation handler represents validator instance. */
 125     protected RevalidationHandler fValidationHandler;
 126 
 127     /** symbol table */
 128     protected SymbolTable fSymbolTable;
 129     /** error handler. may be null. */
 130     protected DOMErrorHandler fErrorHandler;
 131 
 132     /**
 133      * Cached {@link DOMError} impl.
 134      * The same object is re-used to report multiple errors.
 135      */
 136     private final DOMErrorImpl fError = new DOMErrorImpl();
 137 
 138     // Validation against namespace aware grammar
 139     protected boolean fNamespaceValidation = false;
 140 
 141     // Update PSVI information in the tree
 142     protected boolean fPSVI = false;
 143 
 144     /** The namespace context of this document: stores namespaces in scope */
 145     protected final NamespaceContext fNamespaceContext = new NamespaceSupport();
 146 
 147     /** Stores all namespace bindings on the current element */
 148     protected final NamespaceContext fLocalNSBinder = new NamespaceSupport();
 149 
 150     /** list of attributes */
 151     protected final List&lt;Node&gt; fAttributeList = new ArrayList&lt;&gt;(5);
 152 
 153     /** DOM Locator -  for namespace fixup algorithm */
 154     protected final DOMLocatorImpl fLocator = new DOMLocatorImpl();
 155 
 156     /** for setting the PSVI */
 157     protected Node fCurrentNode = null;
<a name="10" id="anc10"></a><span class="line-modified"> 158     private QName fAttrQName = new QName();</span>
 159 
 160     // attribute value normalization
 161     final XMLString fNormalizedValue = new XMLString(new char[16], 0, 0);
 162 
 163     //DTD validator
 164     private XMLDTDValidator fDTDValidator;
 165 
<a name="11" id="anc11"></a><span class="line-modified"> 166     //Check if element content is all &quot;ignorable whitespace&quot;</span>
<span class="line-modified"> 167     private boolean allWhitespace = false;</span>



 168 
 169     // Constructor
 170     //
 171 
 172     public DOMNormalizer(){}
 173 
 174 
 175 
 176     /**
 177      * Normalizes document.
 178      * Note: reset() must be called before this method.
 179      */
<a name="12" id="anc12"></a><span class="line-modified"> 180         protected void normalizeDocument(CoreDocumentImpl document, DOMConfigurationImpl config) {</span>





 181 
<a name="13" id="anc13"></a><span class="line-modified"> 182                 fDocument = document;</span>
<span class="line-modified"> 183                 fConfiguration = config;</span>

 184 
<a name="14" id="anc14"></a><span class="line-modified"> 185                 // intialize and reset DOMNormalizer component</span>
<span class="line-modified"> 186                 //</span>
<span class="line-modified"> 187                 fSymbolTable = (SymbolTable) fConfiguration.getProperty(DOMConfigurationImpl.SYMBOL_TABLE);</span>
<span class="line-modified"> 188                 // reset namespace context</span>
<span class="line-modified"> 189                 fNamespaceContext.reset();</span>
<span class="line-modified"> 190                 fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING);</span>
 191 
<a name="15" id="anc15"></a><span class="line-modified"> 192                 if ((fConfiguration.features &amp; DOMConfigurationImpl.VALIDATE) != 0) {</span>
 193             String schemaLang = (String)fConfiguration.getProperty(DOMConfigurationImpl.JAXP_SCHEMA_LANGUAGE);
 194 
<a name="16" id="anc16"></a><span class="line-modified"> 195             if(schemaLang != null &amp;&amp; schemaLang.equals(Constants.NS_XMLSCHEMA)) {</span>
<span class="line-modified"> 196                         fValidationHandler =</span>
<span class="line-modified"> 197                                 CoreDOMImplementationImpl.singleton.getValidator(XMLGrammarDescription.XML_SCHEMA);</span>
 198                 fConfiguration.setFeature(DOMConfigurationImpl.SCHEMA, true);
 199                 fConfiguration.setFeature(DOMConfigurationImpl.SCHEMA_FULL_CHECKING, true);
 200                 // report fatal error on DOM Level 1 nodes
 201                 fNamespaceValidation = true;
 202 
 203                 // check if we need to fill in PSVI
 204                 fPSVI = ((fConfiguration.features &amp; DOMConfigurationImpl.PSVI) !=0)?true:false;
 205             }
<a name="17" id="anc17"></a>








 206 
<a name="18" id="anc18"></a><span class="line-modified"> 207                         fConfiguration.setFeature(DOMConfigurationImpl.XERCES_VALIDATION, true);</span>
 208 
 209             // reset ID table
 210             fDocument.clearIdentifiers();
 211 
<a name="19" id="anc19"></a><span class="line-modified"> 212             if(fValidationHandler != null)</span>
<span class="line-modified"> 213             // reset schema validator</span>
 214                 ((XMLComponent) fValidationHandler).reset(fConfiguration);
<a name="20" id="anc20"></a>




 215 
<a name="21" id="anc21"></a><span class="line-modified"> 216                 }</span>
<span class="line-modified"> 217 </span>
<span class="line-modified"> 218                 fErrorHandler = (DOMErrorHandler) fConfiguration.getParameter(Constants.DOM_ERROR_HANDLER);</span>
<span class="line-modified"> 219                 if (fValidationHandler != null) {</span>
<span class="line-removed"> 220                         fValidationHandler.setDocumentHandler(this);</span>
<span class="line-removed"> 221                         fValidationHandler.startDocument(</span>
 222                     new SimpleLocator(fDocument.fDocumentURI, fDocument.fDocumentURI,
<a name="22" id="anc22"></a><span class="line-modified"> 223                                                 -1, -1 ), fDocument.encoding, fNamespaceContext, null);</span>
<span class="line-modified"> 224 </span>
<span class="line-modified"> 225                 }</span>
<span class="line-modified"> 226                 try {</span>
<span class="line-modified"> 227                         Node kid, next;</span>
<span class="line-modified"> 228                         for (kid = fDocument.getFirstChild(); kid != null; kid = next) {</span>
<span class="line-modified"> 229                                 next = kid.getNextSibling();</span>
<span class="line-modified"> 230                                 kid = normalizeNode(kid);</span>
<span class="line-removed"> 231                                 if (kid != null) { // don&#39;t advance</span>
<span class="line-removed"> 232                                         next = kid;</span>
<span class="line-removed"> 233                                 }</span>
<span class="line-removed"> 234                         }</span>
 235 
<a name="23" id="anc23"></a><span class="line-modified"> 236                         // release resources</span>
<span class="line-modified"> 237                         if (fValidationHandler != null) {</span>
<span class="line-modified"> 238                                 fValidationHandler.endDocument(null);</span>
<span class="line-modified"> 239                                 CoreDOMImplementationImpl.singleton.releaseValidator(</span>
<span class="line-modified"> 240                                         XMLGrammarDescription.XML_SCHEMA, fValidationHandler);</span>
<span class="line-modified"> 241                                 fValidationHandler = null;</span>
<span class="line-removed"> 242                         }</span>
<span class="line-removed"> 243                 } catch (AbortException e) {</span>
<span class="line-removed"> 244                     return;</span>
 245                 }
<a name="24" id="anc24"></a>
 246 
<a name="25" id="anc25"></a>






 247         }
<a name="26" id="anc26"></a><span class="line-modified"> 248 </span>












 249 
 250     /**
 251      *
 252      * This method acts as if the document was going through a save
 253      * and load cycle, putting the document in a &quot;normal&quot; form. The actual result
 254      * depends on the features being set and governing what operations actually
 255      * take place. See setNormalizationFeature for details. Noticeably this method
 256      * normalizes Text nodes, makes the document &quot;namespace wellformed&quot;,
 257      * according to the algorithm described below in pseudo code, by adding missing
 258      * namespace declaration attributes and adding or changing namespace prefixes, updates
 259      * the replacement tree of EntityReference nodes,normalizes attribute values, etc.
 260      *
 261      * @param node   Modified node or null. If node is returned, we need
 262      *               to normalize again starting on the node returned.
 263      * @return  the normalized Node
 264      */
 265     protected Node normalizeNode (Node node){
 266 
 267         int type = node.getNodeType();
 268         boolean wellformed;
 269         fLocator.fRelatedNode=node;
 270 
 271         switch (type) {
 272         case Node.DOCUMENT_TYPE_NODE: {
 273                 if (DEBUG_ND) {
 274                     System.out.println(&quot;==&gt;normalizeNode:{doctype}&quot;);
 275                 }
<a name="27" id="anc27"></a><span class="line-modified"> 276                 DocumentTypeImpl docType = (DocumentTypeImpl)node;</span>
<span class="line-removed"> 277                 fDTDValidator = (XMLDTDValidator)CoreDOMImplementationImpl.singleton.getValidator(XMLGrammarDescription.XML_DTD);</span>
<span class="line-removed"> 278                 fDTDValidator.setDocumentHandler(this);</span>
<span class="line-removed"> 279                 fConfiguration.setProperty(Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY, createGrammarPool(docType));</span>
<span class="line-removed"> 280                 fDTDValidator.reset(fConfiguration);</span>
<span class="line-removed"> 281                 fDTDValidator.startDocument(</span>
<span class="line-removed"> 282                         new SimpleLocator(fDocument.fDocumentURI, fDocument.fDocumentURI,</span>
<span class="line-removed"> 283                             -1, -1 ), fDocument.encoding, fNamespaceContext, null);</span>
<span class="line-removed"> 284                 fDTDValidator.doctypeDecl(docType.getName(), docType.getPublicId(), docType.getSystemId(), null);</span>
<span class="line-removed"> 285                 //REVISIT: well-formness encoding info</span>
 286                 break;
 287             }
 288 
 289         case Node.ELEMENT_NODE: {
 290                 if (DEBUG_ND) {
 291                     System.out.println(&quot;==&gt;normalizeNode:{element} &quot;+node.getNodeName());
 292                 }
 293 
 294                 //do the name check only when version of the document was changed &amp;
 295                 //application has set the value of well-formed features to true
 296                 if (fDocument.errorChecking) {
 297                     if ( ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) &amp;&amp;
 298                             fDocument.isXMLVersionChanged()){
 299                         if (fNamespaceValidation){
<a name="28" id="anc28"></a><span class="line-modified"> 300                             wellformed = CoreDocumentImpl.isValidQName(node.getPrefix() , node.getLocalName(), fDocument.isXML11Version()) ;</span>
 301                         }
 302                         else {
 303                             wellformed = CoreDocumentImpl.isXMLName(node.getNodeName() , fDocument.isXML11Version());
 304                         }
 305                         if (!wellformed){
 306                             String msg = DOMMessageFormatter.formatMessage(
 307                                     DOMMessageFormatter.DOM_DOMAIN,
 308                                     &quot;wf-invalid-character-in-node-name&quot;,
 309                                     new Object[]{&quot;Element&quot;, node.getNodeName()});
 310                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 311                             &quot;wf-invalid-character-in-node-name&quot;);
 312                         }
 313                     }
 314                 }
 315                 // push namespace context
 316                 fNamespaceContext.pushContext();
 317                 fLocalNSBinder.reset();
 318 
 319                 ElementImpl elem = (ElementImpl)node;
 320                 if (elem.needsSyncChildren()) {
 321                     elem.synchronizeChildren();
 322                 }
 323                 AttributeMap attributes = (elem.hasAttributes()) ? (AttributeMap) elem.getAttributes() : null;
 324 
 325                 // fix namespaces and remove default attributes
 326                 if ((fConfiguration.features &amp; DOMConfigurationImpl.NAMESPACES) !=0) {
 327                     // fix namespaces
 328                     // normalize attribute values
 329                     // remove default attributes
 330                     namespaceFixUp(elem, attributes);
 331 
<a name="29" id="anc29"></a><span class="line-modified"> 332                     if ((fConfiguration.features &amp; DOMConfigurationImpl.NSDECL) == 0 &amp;&amp; attributes != null ) {</span>
<span class="line-modified"> 333                         for (int i = 0; i &lt; attributes.getLength(); ++i) {</span>
<span class="line-modified"> 334                             Attr att = (Attr)attributes.getItem(i);</span>
<span class="line-modified"> 335                             if (XMLSymbols.PREFIX_XMLNS.equals(att.getPrefix()) ||</span>
<span class="line-modified"> 336                                 XMLSymbols.PREFIX_XMLNS.equals(att.getName())) {</span>
<span class="line-modified"> 337                                 elem.removeAttributeNode(att);</span>
<span class="line-modified"> 338                                 --i;</span>








 339                             }
 340                         }
 341                     }
 342 
 343                 } else {
 344                     if ( attributes!=null ) {
 345                         for ( int i=0; i&lt;attributes.getLength(); ++i ) {
 346                             Attr attr = (Attr)attributes.item(i);
 347                             //removeDefault(attr, attributes);
 348                             attr.normalize();
 349                             if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)){
<a name="30" id="anc30"></a><span class="line-modified"> 350                                     isAttrValueWF(fErrorHandler, fError, fLocator, attributes, (AttrImpl)attr, attr.getValue(), fDocument.isXML11Version());</span>
<span class="line-modified"> 351                                 if (fDocument.isXMLVersionChanged()){</span>
<span class="line-modified"> 352                                     wellformed=CoreDocumentImpl.isXMLName(node.getNodeName() , fDocument.isXML11Version());</span>
<span class="line-modified"> 353                                     if (!wellformed){</span>
<span class="line-modified"> 354                                                             String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified"> 355                                                               DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-modified"> 356                                                               &quot;wf-invalid-character-in-node-name&quot;,</span>
<span class="line-modified"> 357                                                                new Object[]{&quot;Attr&quot;,node.getNodeName()});</span>
<span class="line-modified"> 358                                                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,</span>
<span class="line-modified"> 359                                                                 &quot;wf-invalid-character-in-node-name&quot;);</span>





 360                                     }
 361                                 }
 362                             }
 363                         }
 364                     }
 365                 }
 366 
 367 
 368                 if (fValidationHandler != null) {
 369                     // REVISIT: possible solutions to discard default content are:
 370                     //         either we pass some flag to XML Schema validator
 371                     //         or rely on the PSVI information.
 372                     fAttrProxy.setAttributes(attributes, fDocument, elem);
 373                     updateQName(elem, fQName); // updates global qname
 374                     // set error node in the dom error wrapper
 375                     // so if error occurs we can report an error node
 376                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 377                     fCurrentNode = node;
 378                     // call re-validation handler
 379                     fValidationHandler.startElement(fQName, fAttrProxy, null);
 380                 }
 381 
<a name="31" id="anc31"></a><span class="line-removed"> 382                 if (fDTDValidator != null) {</span>
<span class="line-removed"> 383                     // REVISIT: possible solutions to discard default content are:</span>
<span class="line-removed"> 384                     //         either we pass some flag to XML Schema validator</span>
<span class="line-removed"> 385                     //         or rely on the PSVI information.</span>
<span class="line-removed"> 386                     fAttrProxy.setAttributes(attributes, fDocument, elem);</span>
<span class="line-removed"> 387                     updateQName(elem, fQName); // updates global qname</span>
<span class="line-removed"> 388                     // set error node in the dom error wrapper</span>
<span class="line-removed"> 389                     // so if error occurs we can report an error node</span>
<span class="line-removed"> 390                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-removed"> 391                     fCurrentNode = node;</span>
<span class="line-removed"> 392                     // call re-validation handler</span>
<span class="line-removed"> 393                     fDTDValidator.startElement(fQName, fAttrProxy, null);</span>
<span class="line-removed"> 394                 }</span>
<span class="line-removed"> 395 </span>
 396                 // normalize children
 397                 Node kid, next;
 398                 for (kid = elem.getFirstChild(); kid != null; kid = next) {
 399                     next = kid.getNextSibling();
 400                     kid = normalizeNode(kid);
<a name="32" id="anc32"></a><span class="line-modified"> 401                     if (kid !=null) {</span>
 402                         next = kid;  // don&#39;t advance
 403                     }
 404                 }
 405                 if (DEBUG_ND) {
 406                     // normalized subtree
 407                     System.out.println(&quot;***The children of {&quot;+node.getNodeName()+&quot;} are normalized&quot;);
 408                     for (kid = elem.getFirstChild(); kid != null; kid = next) {
 409                         next = kid.getNextSibling();
 410                         System.out.println(kid.getNodeName() +&quot;[&quot;+kid.getNodeValue()+&quot;]&quot;);
 411                     }
 412 
 413                 }
 414 
<a name="33" id="anc33"></a><span class="line-removed"> 415 </span>
 416                 if (fValidationHandler != null) {
 417                     updateQName(elem, fQName); // updates global qname
 418                     //
 419                     // set error node in the dom error wrapper
 420                     // so if error occurs we can report an error node
 421                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 422                     fCurrentNode = node;
 423                     fValidationHandler.endElement(fQName, null);
 424                 }
 425 
<a name="34" id="anc34"></a><span class="line-removed"> 426                 if (fDTDValidator != null) {</span>
<span class="line-removed"> 427                     updateQName(elem, fQName); // updates global qname</span>
<span class="line-removed"> 428                     //</span>
<span class="line-removed"> 429                     // set error node in the dom error wrapper</span>
<span class="line-removed"> 430                     // so if error occurs we can report an error node</span>
<span class="line-removed"> 431                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-removed"> 432                     fCurrentNode = node;</span>
<span class="line-removed"> 433                     fDTDValidator.endElement(fQName, null);</span>
<span class="line-removed"> 434                 }</span>
<span class="line-removed"> 435 </span>
 436                 // pop namespace context
 437                 fNamespaceContext.popContext();
 438 
 439                 break;
 440             }
 441 
 442         case Node.COMMENT_NODE: {
 443                 if (DEBUG_ND) {
 444                     System.out.println(&quot;==&gt;normalizeNode:{comments}&quot;);
 445                 }
 446 
 447                 if ((fConfiguration.features &amp; DOMConfigurationImpl.COMMENTS) == 0) {
 448                     Node prevSibling = node.getPreviousSibling();
 449                     Node parent = node.getParentNode();
 450                     // remove the comment node
 451                     parent.removeChild(node);
 452                     if (prevSibling != null &amp;&amp; prevSibling.getNodeType() == Node.TEXT_NODE) {
 453                         Node nextSibling = prevSibling.getNextSibling();
 454                         if (nextSibling != null &amp;&amp; nextSibling.getNodeType() == Node.TEXT_NODE) {
 455                             ((TextImpl)nextSibling).insertData(0, prevSibling.getNodeValue());
 456                             parent.removeChild(prevSibling);
 457                             return nextSibling;
 458                         }
 459                     }
 460                 }//if comment node need not be removed
 461                 else {
 462                     if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)){
 463                         String commentdata = ((Comment)node).getData();
 464                         // check comments for invalid xml chracter as per the version
 465                         // of the document
 466                         isCommentWF(fErrorHandler, fError, fLocator, commentdata, fDocument.isXML11Version());
 467                     }
<a name="35" id="anc35"></a>






 468                 }//end-else if comment node is not to be removed.
 469                                 break;
 470             }
 471         case Node.ENTITY_REFERENCE_NODE: {
 472                 if (DEBUG_ND) {
 473                     System.out.println(&quot;==&gt;normalizeNode:{entityRef} &quot;+node.getNodeName());
 474                 }
 475 
 476                 if ((fConfiguration.features &amp; DOMConfigurationImpl.ENTITIES) == 0) {
 477                     Node prevSibling = node.getPreviousSibling();
 478                     Node parent = node.getParentNode();
 479                     ((EntityReferenceImpl)node).setReadOnly(false, true);
 480                     expandEntityRef (parent, node);
 481                     parent.removeChild(node);
 482                     Node next = (prevSibling != null)?prevSibling.getNextSibling():parent.getFirstChild();
 483                     // The list of children #text -&gt; &amp;ent;
 484                     // and entity has a first child as a text
 485                     // we should not advance
 486                     if (prevSibling != null &amp;&amp; next != null &amp;&amp; prevSibling.getNodeType() == Node.TEXT_NODE &amp;&amp;
 487                         next.getNodeType() == Node.TEXT_NODE) {
 488                         return prevSibling;  // Don&#39;t advance
 489                     }
 490                     return next;
 491                 } else {
 492                     if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) &amp;&amp;
 493                         fDocument.isXMLVersionChanged()){
 494                             CoreDocumentImpl.isXMLName(node.getNodeName() , fDocument.isXML11Version());
 495                     }
 496                     // REVISIT: traverse entity reference and send appropriate calls to the validator
 497                     // (no normalization should be performed for the children).
 498                 }
 499                 break;
 500             }
 501 
 502         case Node.CDATA_SECTION_NODE: {
 503                 if (DEBUG_ND) {
 504                     System.out.println(&quot;==&gt;normalizeNode:{cdata}&quot;);
 505                 }
 506 
 507                 if ((fConfiguration.features &amp; DOMConfigurationImpl.CDATA) == 0) {
 508                     // convert CDATA to TEXT nodes
 509                     Node prevSibling = node.getPreviousSibling();
 510                     if (prevSibling != null &amp;&amp; prevSibling.getNodeType() == Node.TEXT_NODE){
 511                         ((Text)prevSibling).appendData(node.getNodeValue());
 512                         node.getParentNode().removeChild(node);
 513                         return prevSibling; //don&#39;t advance
 514                     }
 515                     else {
 516                         Text text = fDocument.createTextNode(node.getNodeValue());
 517                         Node parent = node.getParentNode();
 518                         node = parent.replaceChild(text, node);
 519                         return text;  //don&#39;t advance
 520 
 521                     }
 522                 }
 523 
 524                 // send characters call for CDATA
 525                 if (fValidationHandler != null) {
 526                     // set error node in the dom error wrapper
 527                     // so if error occurs we can report an error node
 528                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 529                     fCurrentNode = node;
 530                     fValidationHandler.startCDATA(null);
 531                     fValidationHandler.characterData(node.getNodeValue(), null);
 532                     fValidationHandler.endCDATA(null);
 533                 }
<a name="36" id="anc36"></a><span class="line-removed"> 534 </span>
<span class="line-removed"> 535                 if (fDTDValidator != null) {</span>
<span class="line-removed"> 536                     // set error node in the dom error wrapper</span>
<span class="line-removed"> 537                     // so if error occurs we can report an error node</span>
<span class="line-removed"> 538                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-removed"> 539                     fCurrentNode = node;</span>
<span class="line-removed"> 540                     fDTDValidator.startCDATA(null);</span>
<span class="line-removed"> 541                     fDTDValidator.characterData(node.getNodeValue(), null);</span>
<span class="line-removed"> 542                     fDTDValidator.endCDATA(null);</span>
<span class="line-removed"> 543                 }</span>
 544                 String value = node.getNodeValue();
 545 
 546                 if ((fConfiguration.features &amp; DOMConfigurationImpl.SPLITCDATA) != 0) {
 547                     int index;
 548                     Node parent = node.getParentNode();
 549                     if (fDocument.errorChecking) {
 550                         isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), fDocument.isXML11Version());
 551                     }
 552                     while ( (index=value.indexOf(&quot;]]&gt;&quot;)) &gt;= 0 ) {
 553                         node.setNodeValue(value.substring(0, index+2));
 554                         value = value.substring(index +2);
 555 
 556                         Node firstSplitNode = node;
 557                         Node newChild = fDocument.createCDATASection(value);
 558                         parent.insertBefore(newChild, node.getNextSibling());
 559                         node = newChild;
 560                         // issue warning
 561                         fLocator.fRelatedNode = firstSplitNode;
 562                         String msg = DOMMessageFormatter.formatMessage(
 563                             DOMMessageFormatter.DOM_DOMAIN,
 564                             &quot;cdata-sections-splitted&quot;,
 565                              null);
 566                         reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_WARNING,
 567                             &quot;cdata-sections-splitted&quot;);
 568                     }
 569 
 570                 }
 571                 else if (fDocument.errorChecking) {
 572                     // check well-formedness
 573                     isCDataWF(fErrorHandler, fError, fLocator, value, fDocument.isXML11Version());
 574                 }
 575                 break;
 576             }
 577 
 578         case Node.TEXT_NODE: {
 579                 if (DEBUG_ND) {
 580                     System.out.println(&quot;==&gt;normalizeNode(text):{&quot;+node.getNodeValue()+&quot;}&quot;);
 581                 }
 582                 // If node is a text node, we need to check for one of two
 583                 // conditions:
 584                 //   1) There is an adjacent text node
 585                 //   2) There is no adjacent text node, but node is
 586                 //      an empty text node.
 587                 Node next = node.getNextSibling();
 588                 // If an adjacent text node, merge it with this node
 589                 if ( next!=null &amp;&amp; next.getNodeType() == Node.TEXT_NODE ) {
 590                     ((Text)node).appendData(next.getNodeValue());
 591                     node.getParentNode().removeChild( next );
 592                     // We don&#39;t need to check well-formness here since we are not yet
 593                     // done with this node.
 594 
 595                     return node; // Don&#39;t advance;
 596                 } else if (node.getNodeValue().length()==0) {
 597                     // If kid is empty, remove it
 598                     node.getParentNode().removeChild( node );
 599                 } else {
 600                     // validator.characters() call and well-formness
 601                     // Don&#39;t send characters or check well-formness in the following cases:
 602                     // 1. entities is false, next child is entity reference: expand tree first
 603                     // 2. comments is false, and next child is comment
 604                     // 3. cdata is false, and next child is cdata
 605 
 606                     short nextType = (next != null)?next.getNodeType():-1;
 607                     if (nextType == -1 || !(((fConfiguration.features &amp; DOMConfigurationImpl.ENTITIES) == 0 &amp;&amp;
<a name="37" id="anc37"></a><span class="line-modified"> 608                            nextType == Node.ENTITY_NODE) ||</span>
<span class="line-modified"> 609                           ((fConfiguration.features &amp; DOMConfigurationImpl.COMMENTS) == 0 &amp;&amp;</span>
<span class="line-modified"> 610                            nextType == Node.COMMENT_NODE) ||</span>
<span class="line-modified"> 611                           ((fConfiguration.features &amp; DOMConfigurationImpl.CDATA) == 0) &amp;&amp;</span>
<span class="line-modified"> 612                           nextType == Node.CDATA_SECTION_NODE)) {</span>
<span class="line-modified"> 613                               if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) ){</span>
<span class="line-modified"> 614                                   isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), fDocument.isXML11Version());</span>
<span class="line-modified"> 615                               }</span>
<span class="line-modified"> 616                               if (fValidationHandler != null) {</span>
<span class="line-modified"> 617                                      fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-modified"> 618                                      fCurrentNode = node;</span>
<span class="line-modified"> 619                                      fValidationHandler.characterData(node.getNodeValue(), null);</span>
<span class="line-modified"> 620                                      if (DEBUG_ND) {</span>
<span class="line-modified"> 621                                          System.out.println(&quot;=====&gt;characterData(),&quot;+nextType);</span>
<span class="line-modified"> 622 </span>
<span class="line-modified"> 623                                      }</span>
<span class="line-modified"> 624                               }</span>
<span class="line-modified"> 625                               if (fDTDValidator != null) {</span>
<span class="line-modified"> 626                                   fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-modified"> 627                                   fCurrentNode = node;</span>
<span class="line-modified"> 628                                   fDTDValidator.characterData(node.getNodeValue(), null);</span>
<span class="line-modified"> 629                                   if (DEBUG_ND) {</span>
<span class="line-modified"> 630                                       System.out.println(&quot;=====&gt;characterData(),&quot;+nextType);</span>
<span class="line-modified"> 631 </span>
<span class="line-modified"> 632                                   }</span>
<span class="line-removed"> 633                                   if(allWhitespace) {</span>
<span class="line-removed"> 634                                       allWhitespace = false;</span>
<span class="line-removed"> 635                                       ((TextImpl)node).setIgnorableWhitespace(true);</span>
<span class="line-removed"> 636                                   }</span>
<span class="line-removed"> 637                               }</span>
 638                     }
 639                     else {
<a name="38" id="anc38"></a><span class="line-modified"> 640                             if (DEBUG_ND) {</span>
<span class="line-modified"> 641                                 System.out.println(&quot;=====&gt;don&#39;t send characters(),&quot;+nextType);</span>
 642 
<a name="39" id="anc39"></a><span class="line-modified"> 643                             }</span>
 644                     }
 645                 }
 646                 break;
 647             }
 648         case Node.PROCESSING_INSTRUCTION_NODE: {
 649 
 650             //do the well-formed valid PI target name , data check when application has set the value of well-formed feature to true
 651             if (fDocument.errorChecking &amp;&amp; (fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0 ) {
 652                 ProcessingInstruction pinode = (ProcessingInstruction)node ;
 653 
 654                 String target = pinode.getTarget();
 655                 //1.check PI target name
 656                 if(fDocument.isXML11Version()){
 657                     wellformed = XML11Char.isXML11ValidName(target);
 658                 }
 659                 else{
 660                     wellformed = XMLChar.isValidName(target);
 661                 }
 662 
 663                                 if (!wellformed) {
 664                                     String msg = DOMMessageFormatter.formatMessage(
 665                                         DOMMessageFormatter.DOM_DOMAIN,
 666                                         &quot;wf-invalid-character-in-node-name&quot;,
 667                                         new Object[]{&quot;Element&quot;, node.getNodeName()});
 668                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 669                         &quot;wf-invalid-character-in-node-name&quot;);
 670                 }
 671 
 672                 //2. check PI data
 673                 //processing isntruction data may have certain characters
 674                 //which may not be valid XML character
 675                 isXMLCharWF(fErrorHandler, fError, fLocator, pinode.getData(), fDocument.isXML11Version());
 676             }
<a name="40" id="anc40"></a>








 677         }//end case Node.PROCESSING_INSTRUCTION_NODE
 678 
 679         }//end of switch
 680         return null;
 681     }//normalizeNode
 682 
<a name="41" id="anc41"></a><span class="line-modified"> 683     private XMLGrammarPool createGrammarPool(DocumentTypeImpl docType) {</span>
<span class="line-removed"> 684 </span>
<span class="line-removed"> 685         XMLGrammarPoolImpl pool = new XMLGrammarPoolImpl();</span>
 686 
<a name="42" id="anc42"></a><span class="line-modified"> 687         XMLGrammarPreparser preParser = new XMLGrammarPreparser(fSymbolTable);</span>
<span class="line-modified"> 688         preParser.registerPreparser(XMLGrammarDescription.XML_DTD, null);</span>
<span class="line-modified"> 689         preParser.setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE, true);</span>
<span class="line-modified"> 690         preParser.setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.VALIDATION_FEATURE, true);</span>
<span class="line-modified"> 691         preParser.setProperty(Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY, pool);</span>
 692 
<a name="43" id="anc43"></a><span class="line-modified"> 693         String internalSubset = docType.getInternalSubset();</span>
<span class="line-modified"> 694         XMLInputSource is = new XMLInputSource(docType.getPublicId(), docType.getSystemId(), null, false);</span>















 695 
<a name="44" id="anc44"></a><span class="line-modified"> 696         if(internalSubset != null)</span>
<span class="line-removed"> 697             is.setCharacterStream(new StringReader(internalSubset));</span>
 698         try {
<a name="45" id="anc45"></a><span class="line-modified"> 699             DTDGrammar g = (DTDGrammar)preParser.preparseGrammar(XMLGrammarDescription.XML_DTD, is);</span>
<span class="line-modified"> 700             ((XMLDTDDescription)g.getGrammarDescription()).setRootName(docType.getName());</span>
<span class="line-modified"> 701             is.setCharacterStream(null);</span>
<span class="line-modified"> 702             g = (DTDGrammar)preParser.preparseGrammar(XMLGrammarDescription.XML_DTD, is);</span>
<span class="line-modified"> 703             ((XMLDTDDescription)g.getGrammarDescription()).setRootName(docType.getName());</span>
<span class="line-modified"> 704 </span>
<span class="line-modified"> 705         } catch (XNIException e) {</span>
<span class="line-removed"> 706         } catch (IOException e) {</span>
 707         }
<a name="46" id="anc46"></a><span class="line-modified"> 708 </span>
<span class="line-modified"> 709         return pool;</span>
<span class="line-modified"> 710     }</span>
<span class="line-modified"> 711 </span>
<span class="line-modified"> 712 </span>




 713 
 714     protected final void expandEntityRef (Node parent, Node reference){
 715         Node kid, next;
 716         for (kid = reference.getFirstChild(); kid != null; kid = next) {
 717             next = kid.getNextSibling();
 718             parent.insertBefore(kid, reference);
 719         }
 720     }
 721 
 722     // fix namespaces
 723     // normalize attribute values
 724     // remove default attributes
 725     // check attribute names if the version of the document changed.
 726 
 727     protected final void namespaceFixUp (ElementImpl element, AttributeMap attributes){
 728         if (DEBUG) {
 729             System.out.println(&quot;[ns-fixup] element:&quot; +element.getNodeName()+
 730                                &quot; uri: &quot;+element.getNamespaceURI());
 731         }
 732 
 733         // ------------------------------------
 734         // pick up local namespace declarations
 735         // &lt;xsl:stylesheet xmlns:xsl=&quot;http://xslt&quot;&gt;
 736         //   &lt;!-- add the following via DOM
 737         //          body is bound to http://xslt
 738         //    --&gt;
 739         //   &lt;xsl:body xmlns:xsl=&quot;http://bound&quot;/&gt;
 740         //
 741         // ------------------------------------
 742 
<a name="47" id="anc47"></a><span class="line-modified"> 743         String value, name, uri, prefix;</span>
 744         if (attributes != null) {
 745 
 746             // Record all valid local declarations
 747             for (int k = 0; k &lt; attributes.getLength(); ++k) {
 748                 Attr attr = (Attr)attributes.getItem(k);
<a name="48" id="anc48"></a><span class="line-removed"> 749 </span>
<span class="line-removed"> 750                 //do the name check only when version of the document was changed &amp;</span>
<span class="line-removed"> 751                 //application has set the value of well-formed features to true</span>
<span class="line-removed"> 752                 if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) &amp;&amp;</span>
<span class="line-removed"> 753                     fDocument.isXMLVersionChanged()) {</span>
<span class="line-removed"> 754                     //checkQName does checking based on the version of the document</span>
<span class="line-removed"> 755                     fDocument.checkQName(attr.getPrefix() , attr.getLocalName()) ;</span>
<span class="line-removed"> 756                 }</span>
<span class="line-removed"> 757 </span>
 758                 uri = attr.getNamespaceURI();
 759                 if (uri != null &amp;&amp; uri.equals(NamespaceContext.XMLNS_URI)) {
 760                     // namespace attribute
<a name="49" id="anc49"></a><span class="line-removed"> 761 </span>
<span class="line-removed"> 762                     // &quot;namespace-declarations&quot; == false; Discard all namespace declaration attributes</span>
<span class="line-removed"> 763                     if ((fConfiguration.features &amp; DOMConfigurationImpl.NSDECL) == 0) {</span>
<span class="line-removed"> 764                         continue;</span>
<span class="line-removed"> 765                     }</span>
<span class="line-removed"> 766 </span>
 767                     value = attr.getNodeValue();
 768                     if (value == null) {
 769                         value=XMLSymbols.EMPTY_STRING;
 770                     }
 771 
 772                     // Check for invalid namespace declaration:
 773                     if (fDocument.errorChecking &amp;&amp; value.equals(NamespaceContext.XMLNS_URI)) {
 774                         //A null value for locale is passed to formatMessage,
 775                         //which means that the default locale will be used
 776                         fLocator.fRelatedNode = attr;
 777                         String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,&quot;CantBindXMLNS&quot;,null );
 778                         reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR, &quot;CantBindXMLNS&quot;);
 779                     } else {
 780                         // XML 1.0 Attribute value normalization
 781                         // value = normalizeAttributeValue(value, attr);
 782                         prefix = attr.getPrefix();
 783                         prefix = (prefix == null ||
 784                                   prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 785                         String localpart = fSymbolTable.addSymbol( attr.getLocalName());
 786                         if (prefix == XMLSymbols.PREFIX_XMLNS) { //xmlns:prefix
 787 
 788                             value = fSymbolTable.addSymbol(value);
 789                             if (value.length() != 0) {
 790                                 fNamespaceContext.declarePrefix(localpart, value);
 791                             } else {
 792                                 // REVISIT: issue error on invalid declarations
 793                                 //          xmlns:foo = &quot;&quot;
 794 
 795                             }
 796                             //removeDefault (attr, attributes);
 797                             continue;
 798                         } else { // (localpart == fXmlnsSymbol &amp;&amp; prefix == fEmptySymbol)  -- xmlns
 799                             // empty prefix is always bound (&quot;&quot; or some string)
 800                             value = fSymbolTable.addSymbol(value);
<a name="50" id="anc50"></a><span class="line-modified"> 801                             fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, value);</span>
 802                             //removeDefault (attr, attributes);
 803                             continue;
 804                         }
 805                     }  // end-else: valid declaration
 806                 } // end-if: namespace attribute
 807             }
 808         }
 809 
 810 
 811 
 812         // ---------------------------------------------------------
 813         // Fix up namespaces for element: per DOM L3
 814         // Need to consider the following cases:
 815         //
 816         // case 1: &lt;xsl:stylesheet xmlns:xsl=&quot;http://xsl&quot;&gt;
 817         // We create another element body bound to the &quot;http://xsl&quot; namespace
 818         // as well as namespace attribute rebounding xsl to another namespace.
 819         // &lt;xsl:body xmlns:xsl=&quot;http://another&quot;&gt;
 820         // Need to make sure that the new namespace decl value is changed to
 821         // &quot;http://xsl&quot;
 822         //
 823         // ---------------------------------------------------------
 824         // check if prefix/namespace is correct for current element
 825         // ---------------------------------------------------------
 826 
 827         uri = element.getNamespaceURI();
 828         prefix = element.getPrefix();
<a name="51" id="anc51"></a><span class="line-modified"> 829 </span>
<span class="line-removed"> 830         // &quot;namespace-declarations&quot; == false? Discard all namespace declaration attributes</span>
<span class="line-removed"> 831         if ((fConfiguration.features &amp; DOMConfigurationImpl.NSDECL) == 0) {</span>
<span class="line-removed"> 832             // no namespace declaration == no namespace URI, semantics are to keep prefix</span>
<span class="line-removed"> 833             uri = null;</span>
<span class="line-removed"> 834         } else if (uri != null) {  // Element has a namespace</span>
 835             uri = fSymbolTable.addSymbol(uri);
 836             prefix = (prefix == null ||
 837                       prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 838             if (fNamespaceContext.getURI(prefix) == uri) {
 839                 // The xmlns:prefix=namespace or xmlns=&quot;default&quot; was declared at parent.
 840                 // The binder always stores mapping of empty prefix to &quot;&quot;.
 841             } else {
 842                 // the prefix is either undeclared
 843                 // or
 844                 // conflict: the prefix is bound to another URI
 845                 addNamespaceDecl(prefix, uri, element);
 846                 fLocalNSBinder.declarePrefix(prefix, uri);
 847                 fNamespaceContext.declarePrefix(prefix, uri);
 848             }
 849         } else { // Element has no namespace
 850             if (element.getLocalName() == null) {
 851 
 852                 //  Error: DOM Level 1 node!
 853                 if (fNamespaceValidation) {
 854                     String msg = DOMMessageFormatter.formatMessage(
 855                             DOMMessageFormatter.DOM_DOMAIN, &quot;NullLocalElementName&quot;,
 856                             new Object[]{element.getNodeName()});
 857                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_FATAL_ERROR,
 858                     &quot;NullLocalElementName&quot;);
 859                 } else {
 860                     String msg = DOMMessageFormatter.formatMessage(
 861                             DOMMessageFormatter.DOM_DOMAIN, &quot;NullLocalElementName&quot;,
 862                             new Object[]{element.getNodeName()});
 863                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 864                     &quot;NullLocalElementName&quot;);
 865                 }
 866 
 867             } else { // uri=null and no colon (DOM L2 node)
 868                 uri = fNamespaceContext.getURI(XMLSymbols.EMPTY_STRING);
 869                 if (uri !=null &amp;&amp; uri.length() &gt; 0) {
 870                     // undeclare default namespace declaration (before that element
 871                     // bound to non-zero length uir), but adding xmlns=&quot;&quot; decl
 872                     addNamespaceDecl (XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING, element);
<a name="52" id="anc52"></a><span class="line-modified"> 873                     fLocalNSBinder.declarePrefix(XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING);</span>
<span class="line-modified"> 874                     fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING);</span>
 875                 }
 876             }
 877         }
 878 
 879         // -----------------------------------------
 880         // Fix up namespaces for attributes: per DOM L3
 881         // check if prefix/namespace is correct the attributes
 882         // -----------------------------------------
 883         if (attributes != null) {
 884 
 885             // clone content of the attributes
 886             attributes.cloneMap(fAttributeList);
 887             for (int i = 0; i &lt; fAttributeList.size(); i++) {
 888                 Attr attr = (Attr) fAttributeList.get(i);
 889                 fLocator.fRelatedNode = attr;
 890 
 891                 if (DEBUG) {
 892                     System.out.println(&quot;==&gt;[ns-fixup] process attribute: &quot;+attr.getNodeName());
 893                 }
 894                 // normalize attribute value
 895                 attr.normalize();
 896                 value = attr.getValue();
<a name="53" id="anc53"></a><span class="line-removed"> 897                 name = attr.getNodeName();</span>
 898                 uri = attr.getNamespaceURI();
 899 
 900                 // make sure that value is never null.
 901                 if (value == null) {
<a name="54" id="anc54"></a><span class="line-modified"> 902                     value=XMLSymbols.EMPTY_STRING;</span>
























 903                 }
 904 
 905                 if (uri != null) {  // attribute has namespace !=null
 906                     prefix = attr.getPrefix();
 907                     prefix = (prefix == null ||
 908                               prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 909                     /*String localpart =*/ fSymbolTable.addSymbol( attr.getLocalName());
 910 
 911                     // ---------------------------------------
 912                     // skip namespace declarations
 913                     // ---------------------------------------
 914                     // REVISIT: can we assume that &quot;uri&quot; is from some symbol
 915                     // table, and compare by reference? -SG
 916                     if (uri != null &amp;&amp; uri.equals(NamespaceContext.XMLNS_URI)) {
 917                         continue;
 918                     }
<a name="55" id="anc55"></a><span class="line-removed"> 919                     //---------------------------------------</span>
<span class="line-removed"> 920                     // check if value of the attribute is namespace well-formed</span>
<span class="line-removed"> 921                     //---------------------------------------</span>
<span class="line-removed"> 922                     if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)) {</span>
<span class="line-removed"> 923                             isAttrValueWF(fErrorHandler, fError, fLocator, attributes, (AttrImpl)attr, attr.getValue(), fDocument.isXML11Version());</span>
<span class="line-removed"> 924                             if (fDocument.isXMLVersionChanged()){</span>
<span class="line-removed"> 925                                 boolean wellformed=CoreDocumentImpl.isXMLName(attr.getNodeName() , fDocument.isXML11Version());</span>
<span class="line-removed"> 926                                 if (!wellformed){</span>
<span class="line-removed"> 927                                                         String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-removed"> 928                                                             DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-removed"> 929                                                             &quot;wf-invalid-character-in-node-name&quot;,</span>
<span class="line-removed"> 930                                                             new Object[]{&quot;Attribute&quot;, attr.getNodeName()});</span>
<span class="line-removed"> 931                                         reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,</span>
<span class="line-removed"> 932                                             &quot;wf-invalid-character-in-node-name&quot;);</span>
<span class="line-removed"> 933                                 }</span>
<span class="line-removed"> 934                         }</span>
<span class="line-removed"> 935                     }</span>
 936 
 937                     // ---------------------------------------
 938                     // remove default attributes
 939                     // ---------------------------------------
 940                     /*
 941                     if (removeDefault(attr, attributes)) {
 942                         continue;
 943                     }
 944                     */
 945                     // XML 1.0 Attribute value normalization
 946                     //value = normalizeAttributeValue(value, attr);
 947 
 948                     // reset id-attributes
 949                     ((AttrImpl)attr).setIdAttribute(false);
 950 
<a name="56" id="anc56"></a><span class="line-removed"> 951 </span>
 952                     uri = fSymbolTable.addSymbol(uri);
 953 
 954                     // find if for this prefix a URI was already declared
 955                     String declaredURI =  fNamespaceContext.getURI(prefix);
 956 
 957                     if (prefix == XMLSymbols.EMPTY_STRING || declaredURI != uri) {
 958                         // attribute has no prefix (default namespace decl does not apply to attributes)
 959                         // OR
 960                         // attribute prefix is not declared
 961                         // OR
 962                         // conflict: attribute has a prefix that conficlicts with a binding
 963                         //           already active in scope
 964 
<a name="57" id="anc57"></a><span class="line-removed"> 965                         name  = attr.getNodeName();</span>
 966                         // Find if any prefix for attributes namespace URI is available
 967                         // in the scope
 968                         String declaredPrefix = fNamespaceContext.getPrefix(uri);
 969                         if (declaredPrefix !=null &amp;&amp; declaredPrefix !=XMLSymbols.EMPTY_STRING) {
 970 
 971                             // use the prefix that was found (declared previously for this URI
 972                             prefix = declaredPrefix;
 973                         } else {
 974                             if (prefix != XMLSymbols.EMPTY_STRING &amp;&amp; fLocalNSBinder.getURI(prefix) == null) {
 975                                 // the current prefix is not null and it has no in scope declaration
 976 
 977                                 // use this prefix
 978                             } else {
 979 
 980                                 // find a prefix following the pattern &quot;NS&quot; +index (starting at 1)
 981                                 // make sure this prefix is not declared in the current scope.
 982                                 int counter = 1;
 983                                 prefix = fSymbolTable.addSymbol(PREFIX +counter++);
 984                                 while (fLocalNSBinder.getURI(prefix)!=null) {
 985                                     prefix = fSymbolTable.addSymbol(PREFIX +counter++);
 986                                 }
 987 
 988                             }
 989                             // add declaration for the new prefix
 990                             addNamespaceDecl(prefix, uri, element);
 991                             value = fSymbolTable.addSymbol(value);
 992                             fLocalNSBinder.declarePrefix(prefix, value);
 993                             fNamespaceContext.declarePrefix(prefix, uri);
 994                         }
 995 
 996                         // change prefix for this attribute
 997                         attr.setPrefix(prefix);
 998                     }
 999                 } else { // attribute uri == null
1000 
1001                     // XML 1.0 Attribute value normalization
1002                     //value = normalizeAttributeValue(value, attr);
1003 
1004                     // reset id-attributes
1005                     ((AttrImpl)attr).setIdAttribute(false);
1006 
1007                     if (attr.getLocalName() == null) {
1008                         // It is an error if document has DOM L1 nodes.
1009                         if (fNamespaceValidation) {
1010                             String msg = DOMMessageFormatter.formatMessage(
1011                                 DOMMessageFormatter.DOM_DOMAIN,
1012                                 &quot;NullLocalAttrName&quot;, new Object[]{attr.getNodeName()});
1013                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_FATAL_ERROR,
1014                                 &quot;NullLocalAttrName&quot;);
1015                         } else {
1016                             String msg = DOMMessageFormatter.formatMessage(
1017                                 DOMMessageFormatter.DOM_DOMAIN,
1018                                 &quot;NullLocalAttrName&quot;, new Object[]{attr.getNodeName()});
1019                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
1020                                 &quot;NullLocalAttrName&quot;);
1021                         }
1022                     } else {
1023                         // uri=null and no colon
1024                         // no fix up is needed: default namespace decl does not
1025 
1026                         // ---------------------------------------
1027                         // remove default attributes
1028                         // ---------------------------------------
1029                         // removeDefault(attr, attributes);
1030                     }
1031                 }
1032             }
1033         } // end loop for attributes
1034     }
1035 
1036     /**
1037      * Adds a namespace attribute or replaces the value of existing namespace
1038      * attribute with the given prefix and value for URI.
1039      * In case prefix is empty will add/update default namespace declaration.
1040      *
1041      * @param prefix
1042      * @param uri
1043      * @exception IOException
1044      */
1045 
1046     protected final void addNamespaceDecl(String prefix, String uri, ElementImpl element){
1047         if (DEBUG) {
1048             System.out.println(&quot;[ns-fixup] addNamespaceDecl [&quot;+prefix+&quot;]&quot;);
1049         }
1050         if (prefix == XMLSymbols.EMPTY_STRING) {
1051             if (DEBUG) {
1052                 System.out.println(&quot;=&gt;add xmlns=\&quot;&quot;+uri+&quot;\&quot; declaration&quot;);
1053             }
1054             element.setAttributeNS(NamespaceContext.XMLNS_URI, XMLSymbols.PREFIX_XMLNS, uri);
1055         } else {
1056             if (DEBUG) {
1057                 System.out.println(&quot;=&gt;add xmlns:&quot;+prefix+&quot;=\&quot;&quot;+uri+&quot;\&quot; declaration&quot;);
1058             }
1059             element.setAttributeNS(NamespaceContext.XMLNS_URI, &quot;xmlns:&quot;+prefix, uri);
1060         }
1061     }
1062 
1063 
1064     //
1065     // Methods for well-formness checking
1066     //
1067 
1068 
1069     /**
1070      * Check if CDATA section is well-formed
1071      * @param datavalue
1072      * @param isXML11Version = true if XML 1.1
1073      */
1074     public static final void isCDataWF(DOMErrorHandler errorHandler, DOMErrorImpl error, DOMLocatorImpl locator,
1075         String datavalue, boolean isXML11Version)
1076     {
1077         if (datavalue == null || (datavalue.length() == 0) ) {
1078             return;
1079         }
1080 
1081         char [] dataarray = datavalue.toCharArray();
1082         int datalength = dataarray.length;
1083 
1084         // version of the document is XML 1.1
1085         if (isXML11Version) {
1086             // we need to check all chracters as per production rules of XML11
1087             int i = 0;
1088             while(i &lt; datalength){
1089                 char c = dataarray[i++];
1090                 if ( XML11Char.isXML11Invalid(c) ) {
1091                     // check if this is a supplemental character
1092                     if (XMLChar.isHighSurrogate(c) &amp;&amp; i &lt; datalength) {
1093                         char c2 = dataarray[i++];
1094                         if (XMLChar.isLowSurrogate(c2) &amp;&amp;
1095                             XMLChar.isSupplemental(XMLChar.supplemental(c, c2))) {
1096                             continue;
1097                         }
1098                     }
1099                     String msg = DOMMessageFormatter.formatMessage(
1100                         DOMMessageFormatter.XML_DOMAIN,
1101                         &quot;InvalidCharInCDSect&quot;,
1102                         new Object[] { Integer.toString(c, 16)});
1103                     reportDOMError(
1104                         errorHandler,
1105                         error,
1106                         locator,
1107                         msg,
1108                         DOMError.SEVERITY_ERROR,
1109                         &quot;wf-invalid-character&quot;);
1110                 }
1111                 else if (c == &#39;]&#39;) {
1112                     int count = i;
1113                     if (count &lt; datalength &amp;&amp; dataarray[count] == &#39;]&#39;) {
1114                         while (++count &lt; datalength &amp;&amp; dataarray[count] == &#39;]&#39;) {
1115                             // do nothing
1116                         }
1117                         if (count &lt; datalength &amp;&amp; dataarray[count] == &#39;&gt;&#39;) {
1118                             // CDEndInContent
1119                             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN, &quot;CDEndInContent&quot;, null);
1120                             reportDOMError(errorHandler, error, locator,msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1121                         }
1122                     }
1123 
1124                 }
1125             }
1126         } // version of the document is XML 1.0
1127         else {
1128             // we need to check all chracters as per production rules of XML 1.0
1129             int i = 0;
1130             while (i &lt; datalength) {
1131                 char c = dataarray[i++];
1132                 if( XMLChar.isInvalid(c) ) {
1133                     // check if this is a supplemental character
1134                     if (XMLChar.isHighSurrogate(c) &amp;&amp; i &lt; datalength) {
1135                         char c2 = dataarray[i++];
1136                         if (XMLChar.isLowSurrogate(c2) &amp;&amp;
1137                             XMLChar.isSupplemental(XMLChar.supplemental(c, c2))) {
1138                             continue;
1139                         }
1140                     }
1141                     // Note:  The key InvalidCharInCDSect from XMLMessages.properties
1142                     // is being used to obtain the message and DOM error type
1143                     // &quot;wf-invalid-character&quot; is used.  Also per DOM it is error but
1144                     // as per XML spec. it is fatal error
1145                     String msg = DOMMessageFormatter.formatMessage(
1146                         DOMMessageFormatter.XML_DOMAIN,
1147                         &quot;InvalidCharInCDSect&quot;,
1148                         new Object[]{Integer.toString(c, 16)});
1149                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1150                 }
1151                 else if (c==&#39;]&#39;) {
1152                     int count = i;
1153                     if ( count&lt; datalength &amp;&amp; dataarray[count]==&#39;]&#39; ) {
1154                         while (++count &lt; datalength &amp;&amp; dataarray[count]==&#39;]&#39; ) {
1155                             // do nothing
1156                         }
1157                         if ( count &lt; datalength &amp;&amp; dataarray[count]==&#39;&gt;&#39; ) {
1158                             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN, &quot;CDEndInContent&quot;, null);
1159                             reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1160                         }
1161                     }
1162 
1163                 }
1164             }
1165         } // end-else fDocument.isXMLVersion()
1166 
1167     } // isCDataWF
1168 
1169     /**
1170      * NON-DOM: check for valid XML characters as per the XML version
1171      * @param datavalue
1172      * @param isXML11Version = true if XML 1.1
1173      */
1174     public static final void isXMLCharWF(DOMErrorHandler errorHandler, DOMErrorImpl error, DOMLocatorImpl locator,
1175         String datavalue, boolean isXML11Version)
1176     {
1177         if ( datavalue == null || (datavalue.length() == 0) ) {
1178             return;
1179         }
1180 
1181         char [] dataarray = datavalue.toCharArray();
1182         int datalength = dataarray.length;
1183 
1184         // version of the document is XML 1.1
1185         if(isXML11Version){
1186             //we need to check all characters as per production rules of XML11
1187             int i = 0 ;
1188             while (i &lt; datalength) {
1189                 if(XML11Char.isXML11Invalid(dataarray[i++])){
1190                     // check if this is a supplemental character
1191                     char ch = dataarray[i-1];
1192                     if (XMLChar.isHighSurrogate(ch) &amp;&amp; i &lt; datalength) {
1193                         char ch2 = dataarray[i++];
1194                         if (XMLChar.isLowSurrogate(ch2) &amp;&amp;
1195                             XMLChar.isSupplemental(XMLChar.supplemental(ch, ch2))) {
1196                             continue;
1197                         }
1198                     }
1199                     String msg = DOMMessageFormatter.formatMessage(
1200                         DOMMessageFormatter.DOM_DOMAIN, &quot;InvalidXMLCharInDOM&quot;,
1201                         new Object[]{Integer.toString(dataarray[i-1], 16)});
1202                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR,
1203                     &quot;wf-invalid-character&quot;);
1204                 }
1205             }
1206         } // version of the document is XML 1.0
1207         else{
1208             // we need to check all characters as per production rules of XML 1.0
1209             int i = 0 ;
1210             while (i &lt; datalength) {
1211                 if( XMLChar.isInvalid(dataarray[i++]) ) {
1212                     // check if this is a supplemental character
1213                     char ch = dataarray[i-1];
1214                     if (XMLChar.isHighSurrogate(ch) &amp;&amp; i &lt; datalength) {
1215                         char ch2 = dataarray[i++];
1216                         if (XMLChar.isLowSurrogate(ch2) &amp;&amp;
1217                             XMLChar.isSupplemental(XMLChar.supplemental(ch, ch2))) {
1218                             continue;
1219                         }
1220                     }
1221                     String msg = DOMMessageFormatter.formatMessage(
1222                         DOMMessageFormatter.DOM_DOMAIN, &quot;InvalidXMLCharInDOM&quot;,
1223                         new Object[]{Integer.toString(dataarray[i-1], 16)});
1224                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR,
1225                     &quot;wf-invalid-character&quot;);
1226                 }
1227             }
1228         } // end-else fDocument.isXMLVersion()
1229 
1230     } // isXMLCharWF
1231 
1232     /**
1233      * NON-DOM: check if value of the comment is well-formed
1234      * @param datavalue
1235      * @param isXML11Version = true if XML 1.1
1236      */
1237     public static final void isCommentWF(DOMErrorHandler errorHandler, DOMErrorImpl error, DOMLocatorImpl locator,
1238         String datavalue, boolean isXML11Version)
1239     {
1240         if ( datavalue == null || (datavalue.length() == 0) ) {
1241             return;
1242         }
1243 
1244         char [] dataarray = datavalue.toCharArray();
1245         int datalength = dataarray.length ;
1246 
1247         // version of the document is XML 1.1
1248         if (isXML11Version) {
1249             // we need to check all chracters as per production rules of XML11
1250             int i = 0 ;
1251             while (i &lt; datalength){
1252                 char c = dataarray[i++];
1253                 if ( XML11Char.isXML11Invalid(c) ) {
1254                     // check if this is a supplemental character
1255                     if (XMLChar.isHighSurrogate(c) &amp;&amp; i &lt; datalength) {
1256                         char c2 = dataarray[i++];
1257                         if (XMLChar.isLowSurrogate(c2) &amp;&amp;
1258                             XMLChar.isSupplemental(XMLChar.supplemental(c, c2))) {
1259                             continue;
1260                         }
1261                     }
1262                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,
1263                         &quot;InvalidCharInComment&quot;,
1264                         new Object [] {Integer.toString(dataarray[i-1], 16)});
1265                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1266                 }
1267                 else if (c == &#39;-&#39; &amp;&amp; i &lt; datalength &amp;&amp; dataarray[i] == &#39;-&#39;) {
1268                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,
1269                         &quot;DashDashInComment&quot;, null);
1270                     // invalid: &#39;--&#39; in comment
1271                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1272                 }
1273             }
1274         } // version of the document is XML 1.0
1275         else {
1276             // we need to check all chracters as per production rules of XML 1.0
1277             int i = 0;
1278             while (i &lt; datalength){
1279                 char c = dataarray[i++];
1280                 if( XMLChar.isInvalid(c) ){
1281                     // check if this is a supplemental character
1282                     if (XMLChar.isHighSurrogate(c) &amp;&amp; i &lt; datalength) {
1283                         char c2 = dataarray[i++];
1284                         if (XMLChar.isLowSurrogate(c2) &amp;&amp;
1285                             XMLChar.isSupplemental(XMLChar.supplemental(c, c2))) {
1286                             continue;
1287                         }
1288                     }
1289                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,
1290                         &quot;InvalidCharInComment&quot;, new Object [] {Integer.toString(dataarray[i-1], 16)});
1291                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1292                 }
1293                 else if (c == &#39;-&#39; &amp;&amp; i&lt;datalength &amp;&amp; dataarray[i]==&#39;-&#39;){
1294                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,
1295                         &quot;DashDashInComment&quot;, null);
1296                     // invalid: &#39;--&#39; in comment
1297                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1298                 }
1299             }
1300 
1301         } // end-else fDocument.isXMLVersion()
1302 
1303     } // isCommentWF
1304 
1305     /** NON-DOM: check if attribute value is well-formed
1306      * @param attributes
1307      * @param a
1308      * @param value
1309      */
1310     public static final void isAttrValueWF(DOMErrorHandler errorHandler, DOMErrorImpl error,
1311             DOMLocatorImpl locator, NamedNodeMap attributes, Attr a, String value, boolean xml11Version) {
1312         if (a instanceof AttrImpl &amp;&amp; ((AttrImpl)a).hasStringValue()) {
1313             isXMLCharWF(errorHandler, error, locator, value, xml11Version);
1314         } else {
1315                 NodeList children = a.getChildNodes();
1316             //check each child node of the attribute&#39;s value
1317             for (int j = 0; j &lt; children.getLength(); j++) {
1318                 Node child = children.item(j);
1319                 //If the attribute&#39;s child is an entity refernce
1320                 if (child.getNodeType() == Node.ENTITY_REFERENCE_NODE) {
1321                     Document owner = a.getOwnerDocument();
1322                     Entity ent = null;
1323                     //search for the entity in the docType
1324                     //of the attribute&#39;s ownerDocument
1325                     if (owner != null) {
1326                         DocumentType docType = owner.getDoctype();
1327                         if (docType != null) {
1328                             NamedNodeMap entities = docType.getEntities();
1329                             ent = (Entity) entities.getNamedItemNS(
1330                                     &quot;*&quot;,
1331                                     child.getNodeName());
1332                         }
1333                     }
1334                     //If the entity was not found issue a fatal error
1335                     if (ent == null) {
1336                         String msg = DOMMessageFormatter.formatMessage(
1337                             DOMMessageFormatter.DOM_DOMAIN, &quot;UndeclaredEntRefInAttrValue&quot;,
1338                             new Object[]{a.getNodeName()});
1339                         reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR,
1340                             &quot;UndeclaredEntRefInAttrValue&quot;);
1341                     }
1342                 }
1343                 else {
1344                     // Text node
1345                     isXMLCharWF(errorHandler, error, locator, child.getNodeValue(), xml11Version);
1346                 }
1347             }
1348         }
1349     }
1350 
1351 
1352 
1353     /**
1354      * Reports a DOM error to the user handler.
1355      *
1356      * If the error is fatal, the processing will be always aborted.
1357      */
1358     public static final void reportDOMError(DOMErrorHandler errorHandler, DOMErrorImpl error, DOMLocatorImpl locator,
1359                         String message, short severity, String type ) {
1360         if( errorHandler!=null ) {
1361             error.reset();
1362             error.fMessage = message;
1363             error.fSeverity = severity;
1364             error.fLocator = locator;
1365             error.fType = type;
1366             error.fRelatedData = locator.fRelatedNode;
1367 
1368             if(!errorHandler.handleError(error))
1369                 throw new AbortException();
1370         }
1371         if( severity==DOMError.SEVERITY_FATAL_ERROR )
1372             throw new AbortException();
1373     }
1374 
1375     protected final void updateQName (Node node, QName qname){
1376 
1377         String prefix    = node.getPrefix();
1378         String namespace = node.getNamespaceURI();
1379         String localName = node.getLocalName();
1380         // REVISIT: the symbols are added too often: start/endElement
1381         //          and in the namespaceFixup. Should reduce number of calls to symbol table.
1382         qname.prefix = (prefix!=null &amp;&amp; prefix.length()!=0)?fSymbolTable.addSymbol(prefix):null;
1383         qname.localpart = (localName != null)?fSymbolTable.addSymbol(localName):null;
1384         qname.rawname = fSymbolTable.addSymbol(node.getNodeName());
1385         qname.uri =  (namespace != null)?fSymbolTable.addSymbol(namespace):null;
1386     }
1387 
1388 
1389 
1390         /* REVISIT: remove this method if DOM does not change spec.
1391          * Performs partial XML 1.0 attribute value normalization and replaces
1392      * attribute value if the value is changed after the normalization.
1393      * DOM defines that normalizeDocument acts as if the document was going
1394      * through a save and load cycle, given that serializer will not escape
1395      * any &#39;\n&#39; or &#39;\r&#39; characters on load those will be normalized.
1396      * Thus during normalize document we need to do the following:
1397      * - perform &quot;2.11 End-of-Line Handling&quot;
1398      * - replace #xD, #xA, #x9 with #x20 (white space).
1399      * Note: This alg. won&#39;t attempt to resolve entity references or character entity
1400      * references, since &#39;&amp;&#39; will be escaped during serialization and during loading
1401      * this won&#39;t be recognized as entity reference, i.e. attribute value &quot;&amp;foo;&quot; will
1402      * be serialized as &quot;&amp;amp;foo;&quot; and thus after loading will be &quot;&amp;foo;&quot; again.
1403          * @param value current attribute value
1404          * @param attr current attribute
1405          * @return String the value (could be original if normalization did not change
1406      * the string)
1407          */
1408     final String normalizeAttributeValue(String value, Attr attr) {
1409         if (!attr.getSpecified()){
1410             // specified attributes should already have a normalized form
1411             // since those were added by validator
1412             return value;
1413         }
1414         int end = value.length();
1415         // ensure capacity
1416         if (fNormalizedValue.ch.length &lt; end) {
1417             fNormalizedValue.ch = new char[end];
1418         }
1419         fNormalizedValue.length = 0;
1420         boolean normalized = false;
1421         for (int i = 0; i &lt; end; i++) {
1422             char c = value.charAt(i);
1423             if (c==0x0009 || c==0x000A) {
1424                fNormalizedValue.ch[fNormalizedValue.length++] = &#39; &#39;;
1425                normalized = true;
1426             }
1427             else if(c==0x000D){
1428                normalized = true;
1429                fNormalizedValue.ch[fNormalizedValue.length++] = &#39; &#39;;
1430                int next = i+1;
1431                if (next &lt; end &amp;&amp; value.charAt(next)==0x000A) i=next; // skip following xA
1432             }
1433             else {
1434                 fNormalizedValue.ch[fNormalizedValue.length++] = c;
1435             }
1436         }
1437         if (normalized){
1438            value = fNormalizedValue.toString();
1439            attr.setValue(value);
1440         }
1441         return value;
1442     }
1443 
1444     protected final class XMLAttributesProxy
1445     implements XMLAttributes {
1446         protected AttributeMap fAttributes;
1447         protected CoreDocumentImpl fDocument;
1448         protected ElementImpl fElement;
1449 
<a name="58" id="anc58"></a><span class="line-modified">1450         protected final Vector&lt;Augmentations&gt; fAugmentations = new Vector&lt;&gt;(5);</span>
<span class="line-modified">1451 </span>
1452 
1453         public void setAttributes(AttributeMap attributes, CoreDocumentImpl doc, ElementImpl elem) {
1454             fDocument = doc;
1455             fAttributes = attributes;
1456             fElement = elem;
1457             if (attributes != null) {
1458                 int length = attributes.getLength();
<a name="59" id="anc59"></a><span class="line-modified">1459 </span>
1460                 fAugmentations.setSize(length);
1461                 // REVISIT: this implementation does not store any value in augmentations
1462                 //          and basically not keeping augs in parallel to attributes map
1463                 //          untill all attributes are added (default attributes)
1464                 for (int i = 0; i &lt; length; i++) {
1465                     fAugmentations.setElementAt(new AugmentationsImpl(), i);
1466                 }
<a name="60" id="anc60"></a><span class="line-modified">1467             } else {</span>


1468                 fAugmentations.setSize(0);
1469             }
1470         }
1471 
1472 
<a name="61" id="anc61"></a><span class="line-modified">1473                 /**</span>
1474          * This method adds default declarations
1475                  * @see com.sun.org.apache.xerces.internal.xni.XMLAttributes#addAttribute(QName, String, String)
<a name="62" id="anc62"></a><span class="line-modified">1476                  */</span>
<span class="line-modified">1477                 public int addAttribute(QName qname, String attrType, String attrValue) {</span>
<span class="line-modified">1478                         int index = fElement.getXercesAttribute(qname.uri, qname.localpart);</span>
<span class="line-modified">1479                         // add defaults to the tree</span>
<span class="line-modified">1480                         if (index &lt; 0) {</span>
1481                 // the default attribute was removed by a user and needed to
1482                 // be added back
<a name="63" id="anc63"></a><span class="line-modified">1483                                 AttrImpl attr = (AttrImpl)</span>
<span class="line-modified">1484                                         ((CoreDocumentImpl) fElement.getOwnerDocument()).createAttributeNS(</span>
<span class="line-modified">1485                                                 qname.uri,</span>
<span class="line-modified">1486                                                 qname.rawname,</span>
<span class="line-modified">1487                                                 qname.localpart);</span>
1488                 // REVISIT: the following should also update ID table
1489                 attr.setNodeValue(attrValue);
1490                 index = fElement.setXercesAttributeNode(attr);
<a name="64" id="anc64"></a>
1491                 fAugmentations.insertElementAt(new AugmentationsImpl(), index);
1492                 attr.setSpecified(false);
<a name="65" id="anc65"></a><span class="line-modified">1493                         }</span>
<span class="line-modified">1494                         else {</span>
1495                 // default attribute is in the tree
1496                 // we don&#39;t need to do anything since prefix was already fixed
1497                 // at the namespace fixup time and value must be same value, otherwise
1498                 // attribute will be treated as specified and we will never reach
1499                 // this method.
1500 
1501             }
1502             return index;
<a name="66" id="anc66"></a><span class="line-modified">1503                 }</span>
1504 
1505 
1506         public void removeAllAttributes(){
1507             // REVISIT: implement
1508         }
1509 
1510 
1511         public void removeAttributeAt(int attrIndex){
1512             // REVISIT: implement
1513         }
1514 
1515 
1516         public int getLength(){
1517             return(fAttributes != null)?fAttributes.getLength():0;
1518         }
1519 
1520 
1521         public int getIndex(String qName){
1522             // REVISIT: implement
1523             return -1;
1524         }
1525 
<a name="67" id="anc67"></a><span class="line-modified">1526         public int getIndex(String uri, String localPart){</span>
1527             // REVISIT: implement
1528             return -1;
1529         }
1530 
<a name="68" id="anc68"></a><span class="line-modified">1531         public void setName(int attrIndex, QName attrName){</span>
1532             // REVISIT: implement
1533         }
1534 
<a name="69" id="anc69"></a><span class="line-modified">1535         public void getName(int attrIndex, QName attrName){</span>
<span class="line-modified">1536             if (fAttributes !=null) {</span>
1537                 updateQName((Node)fAttributes.getItem(attrIndex), attrName);
1538             }
1539         }
1540 
<a name="70" id="anc70"></a><span class="line-modified">1541         public String getPrefix(int index){</span>
<span class="line-modified">1542             // REVISIT: implement</span>





1543             return null;
1544         }
1545 
<a name="71" id="anc71"></a><span class="line-modified">1546 </span>
<span class="line-modified">1547         public String getURI(int index){</span>
<span class="line-modified">1548             // REVISIT: implement</span>




1549             return null;
1550         }
1551 
1552 
<a name="72" id="anc72"></a><span class="line-modified">1553         public String getLocalName(int index){</span>
<span class="line-modified">1554             // REVISIT: implement</span>





1555             return null;
1556         }
1557 
<a name="73" id="anc73"></a><span class="line-modified">1558 </span>
<span class="line-modified">1559         public String getQName(int index){</span>
<span class="line-modified">1560             // REVISIT: implement</span>



1561             return null;
1562         }
1563 
1564          public QName getQualifiedName(int index){
1565             //return fAttributes.item(index).ge);
1566             return null;
1567         }
1568 
<a name="74" id="anc74"></a><span class="line-modified">1569         public void setType(int attrIndex, String attrType){</span>
<span class="line-modified">1570             // REVISIT: implement</span>
1571         }
1572 
<a name="75" id="anc75"></a><span class="line-modified">1573 </span>
<span class="line-modified">1574         public String getType(int index){</span>
<span class="line-modified">1575             return &quot;CDATA&quot;;</span>
1576         }
1577 
<a name="76" id="anc76"></a><span class="line-modified">1578 </span>
<span class="line-removed">1579         public String getType(String qName){</span>
1580             return &quot;CDATA&quot;;
1581         }
1582 
<a name="77" id="anc77"></a><span class="line-modified">1583 </span>
<span class="line-removed">1584         public String getType(String uri, String localName){</span>
1585             return &quot;CDATA&quot;;
1586         }
1587 
<a name="78" id="anc78"></a>





1588 
<a name="79" id="anc79"></a><span class="line-modified">1589         public void setValue(int attrIndex, String attrValue){</span>
1590             // REVISIT: is this desired behaviour?
1591             // The values are updated in the case datatype-normalization is turned on
1592             // in this case we need to make sure that specified attributes stay specified
1593 
1594             if (fAttributes != null){
1595                 AttrImpl attr = (AttrImpl)fAttributes.getItem(attrIndex);
1596                 boolean specified = attr.getSpecified();
1597                 attr.setValue(attrValue);
1598                 attr.setSpecified(specified);
1599 
1600             }
1601         }
1602 
1603         public  void setValue(int attrIndex, String attrValue, XMLString value){
1604             setValue(attrIndex, value.toString());
1605         }
1606 
1607         public String getValue(int index){
1608             return (fAttributes !=null)?fAttributes.item(index).getNodeValue():&quot;&quot;;
1609 
1610         }
1611 
<a name="80" id="anc80"></a><span class="line-removed">1612 </span>
1613         public String getValue(String qName){
1614             // REVISIT: implement
1615             return null;
1616         }
1617 
<a name="81" id="anc81"></a><span class="line-removed">1618 </span>
1619         public String getValue(String uri, String localName){
1620             if (fAttributes != null) {
1621                 Node node =  fAttributes.getNamedItemNS(uri, localName);
1622                 return(node != null)? node.getNodeValue():null;
1623             }
1624             return null;
1625         }
1626 
<a name="82" id="anc82"></a><span class="line-removed">1627 </span>
1628         public void setNonNormalizedValue(int attrIndex, String attrValue){
1629             // REVISIT: implement
1630 
1631         }
1632 
<a name="83" id="anc83"></a><span class="line-removed">1633 </span>
1634         public String getNonNormalizedValue(int attrIndex){
1635             // REVISIT: implement
1636             return null;
1637         }
1638 
<a name="84" id="anc84"></a><span class="line-removed">1639 </span>
1640         public void setSpecified(int attrIndex, boolean specified){
1641             AttrImpl attr = (AttrImpl)fAttributes.getItem(attrIndex);
1642             attr.setSpecified(specified);
1643         }
1644 
1645         public boolean isSpecified(int attrIndex){
1646             return((Attr)fAttributes.getItem(attrIndex)).getSpecified();
1647         }
1648 
1649         public Augmentations getAugmentations (int attributeIndex){
1650             return fAugmentations.elementAt(attributeIndex);
1651         }
1652 
1653         public Augmentations getAugmentations (String uri, String localPart){
1654             // REVISIT: implement
1655             return null;
1656         }
1657 
1658         public Augmentations getAugmentations(String qName){
1659             // REVISIT: implement
1660             return null;
1661         }
1662 
1663         /**
1664          * Sets the augmentations of the attribute at the specified index.
1665          *
1666          * @param attrIndex The attribute index.
1667          * @param augs      The augmentations.
1668          */
1669         public void setAugmentations(int attrIndex, Augmentations augs) {
1670             fAugmentations.setElementAt(augs, attrIndex);
1671         }
1672     }
1673 
1674     //
1675     // XMLDocumentHandler methods
1676     //
1677 
1678     /**
1679      * The start of the document.
1680      *
1681      * @param locator  The document locator, or null if the document
1682      *                 location cannot be reported during the parsing
1683      *                 of this document. However, it is &lt;em&gt;strongly&lt;/em&gt;
1684      *                 recommended that a locator be supplied that can
1685      *                 at least report the system identifier of the
1686      *                 document.
1687      * @param encoding The auto-detected IANA encoding name of the entity
1688      *                 stream. This value will be null in those situations
1689      *                 where the entity encoding is not auto-detected (e.g.
1690      *                 internal entities or a document entity that is
1691      *                 parsed from a java.io.Reader).
1692      * @param namespaceContext
1693      *                 The namespace context in effect at the
1694      *                 start of this document.
1695      *                 This object represents the current context.
1696      *                 Implementors of this class are responsible
1697      *                 for copying the namespace bindings from the
1698      *                 the current context (and its parent contexts)
1699      *                 if that information is important.
1700      *
1701      * @param augs     Additional information that may include infoset augmentations
1702      * @exception XNIException
1703      *                   Thrown by handler to signal an error.
1704      */
1705     public void startDocument(XMLLocator locator, String encoding,
1706                               NamespaceContext namespaceContext,
1707                               Augmentations augs)
1708         throws XNIException{
1709     }
1710 
1711     /**
1712      * Notifies of the presence of an XMLDecl line in the document. If
1713      * present, this method will be called immediately following the
1714      * startDocument call.
1715      *
1716      * @param version    The XML version.
1717      * @param encoding   The IANA encoding name of the document, or null if
1718      *                   not specified.
1719      * @param standalone The standalone value, or null if not specified.
1720      * @param augs       Additional information that may include infoset augmentations
1721      *
1722      * @exception XNIException
1723      *                   Thrown by handler to signal an error.
1724      */
1725     public void xmlDecl(String version, String encoding, String standalone, Augmentations augs)
1726         throws XNIException{
1727     }
1728 
1729     /**
1730      * Notifies of the presence of the DOCTYPE line in the document.
1731      *
1732      * @param rootElement
1733      *                 The name of the root element.
1734      * @param publicId The public identifier if an external DTD or null
1735      *                 if the external DTD is specified using SYSTEM.
1736      * @param systemId The system identifier if an external DTD, null
1737      *                 otherwise.
1738      * @param augs     Additional information that may include infoset augmentations
1739      *
1740      * @exception XNIException
1741      *                   Thrown by handler to signal an error.
1742      */
1743     public void doctypeDecl(String rootElement, String publicId, String systemId, Augmentations augs)
1744         throws XNIException{
1745     }
1746 
1747     /**
1748      * A comment.
1749      *
1750      * @param text   The text in the comment.
1751      * @param augs   Additional information that may include infoset augmentations
1752      *
1753      * @exception XNIException
1754      *                   Thrown by application to signal an error.
1755      */
1756     public void comment(XMLString text, Augmentations augs) throws XNIException{
1757     }
1758 
1759     /**
1760      * A processing instruction. Processing instructions consist of a
1761      * target name and, optionally, text data. The data is only meaningful
1762      * to the application.
1763      * &lt;p&gt;
1764      * Typically, a processing instruction&#39;s data will contain a series
1765      * of pseudo-attributes. These pseudo-attributes follow the form of
1766      * element attributes but are &lt;strong&gt;not&lt;/strong&gt; parsed or presented
1767      * to the application as anything other than text. The application is
1768      * responsible for parsing the data.
1769      *
1770      * @param target The target.
1771      * @param data   The data or null if none specified.
1772      * @param augs   Additional information that may include infoset augmentations
1773      *
1774      * @exception XNIException
1775      *                   Thrown by handler to signal an error.
1776      */
1777     public void processingInstruction(String target, XMLString data, Augmentations augs)
1778         throws XNIException{
1779     }
1780 
1781     /**
1782      * The start of an element.
1783      *
1784      * @param element    The name of the element.
1785      * @param attributes The element attributes.
1786      * @param augs       Additional information that may include infoset augmentations
1787      *
1788      * @exception XNIException
1789      *                   Thrown by handler to signal an error.
1790      */
<a name="85" id="anc85"></a><span class="line-modified">1791         public void startElement(QName element, XMLAttributes attributes, Augmentations augs)</span>
<span class="line-modified">1792                 throws XNIException {</span>
<span class="line-modified">1793                 Element currentElement = (Element) fCurrentNode;</span>
<span class="line-modified">1794                 int attrCount = attributes.getLength();</span>
1795         if (DEBUG_EVENTS) {
1796             System.out.println(&quot;==&gt;startElement: &quot; +element+
<a name="86" id="anc86"></a><span class="line-modified">1797             &quot; attrs.length=&quot;+attrCount);</span>
1798         }
1799 
<a name="87" id="anc87"></a><span class="line-modified">1800                 for (int i = 0; i &lt; attrCount; i++) {</span>
<span class="line-modified">1801                         attributes.getName(i, fAttrQName);</span>
<span class="line-modified">1802                         Attr attr = null;</span>
1803 
<a name="88" id="anc88"></a><span class="line-modified">1804                         attr = currentElement.getAttributeNodeNS(fAttrQName.uri, fAttrQName.localpart);</span>




1805             AttributePSVI attrPSVI =
<a name="89" id="anc89"></a><span class="line-modified">1806                                 (AttributePSVI) attributes.getAugmentations(i).getItem(Constants.ATTRIBUTE_PSVI);</span>
1807 
<a name="90" id="anc90"></a><span class="line-modified">1808                         if (attrPSVI != null) {</span>
1809                 //REVISIT: instead we should be using augmentations:
1810                 // to set/retrieve Id attributes
1811                 XSTypeDefinition decl = attrPSVI.getMemberTypeDefinition();
1812                 boolean id = false;
<a name="91" id="anc91"></a><span class="line-modified">1813                 if (decl != null){</span>
1814                     id = ((XSSimpleType)decl).isIDType();
<a name="92" id="anc92"></a><span class="line-modified">1815                 } else{</span>

1816                     decl = attrPSVI.getTypeDefinition();
<a name="93" id="anc93"></a><span class="line-modified">1817                     if (decl !=null){</span>
<span class="line-modified">1818                        id = ((XSSimpleType)decl).isIDType();</span>
1819                     }
1820                 }
<a name="94" id="anc94"></a><span class="line-modified">1821                 if (id){</span>
1822                     ((ElementImpl)currentElement).setIdAttributeNode(attr, true);
1823                 }
1824 
<a name="95" id="anc95"></a><span class="line-modified">1825                                 if (fPSVI) {</span>
<span class="line-modified">1826                                         ((PSVIAttrNSImpl) attr).setPSVI(attrPSVI);</span>
<span class="line-modified">1827                                 }</span>
<span class="line-modified">1828                                 if ((fConfiguration.features &amp; DOMConfigurationImpl.DTNORMALIZATION) != 0) {</span>
<span class="line-modified">1829                                         // datatype-normalization</span>
<span class="line-modified">1830                                         // NOTE: The specified value MUST be set after we set</span>
<span class="line-modified">1831                                         //       the node value because that turns the &quot;specified&quot;</span>
<span class="line-modified">1832                                         //       flag to &quot;true&quot; which may overwrite a &quot;false&quot;</span>
<span class="line-modified">1833                                         //       value from the attribute list.</span>
<span class="line-modified">1834                                         boolean specified = attr.getSpecified();</span>
<span class="line-modified">1835                                         attr.setValue(attrPSVI.getSchemaValue().getNormalizedValue());</span>
<span class="line-modified">1836                                         if (!specified) {</span>
<span class="line-modified">1837                                                 ((AttrImpl) attr).setSpecified(specified);</span>
<span class="line-modified">1838                                         }</span>
<span class="line-modified">1839                                 }</span>




1840                         }
<a name="96" id="anc96"></a>













1841                 }
<a name="97" id="anc97"></a>


1842         }
<a name="98" id="anc98"></a>
1843 
1844 
1845     /**
1846      * An empty element.
1847      *
1848      * @param element    The name of the element.
1849      * @param attributes The element attributes.
1850      * @param augs       Additional information that may include infoset augmentations
1851      *
1852      * @exception XNIException
1853      *                   Thrown by handler to signal an error.
1854      */
1855         public void emptyElement(QName element, XMLAttributes attributes, Augmentations augs)
1856                 throws XNIException {
1857         if (DEBUG_EVENTS) {
1858             System.out.println(&quot;==&gt;emptyElement: &quot; +element);
1859         }
1860 
1861                 startElement(element, attributes, augs);
1862         endElement(element, augs);
1863         }
1864 
1865     /**
1866      * This method notifies the start of a general entity.
1867      * &lt;p&gt;
1868      * &lt;strong&gt;Note:&lt;/strong&gt; This method is not called for entity references
1869      * appearing as part of attribute values.
1870      *
1871      * @param name     The name of the general entity.
1872      * @param identifier The resource identifier.
1873      * @param encoding The auto-detected IANA encoding name of the entity
1874      *                 stream. This value will be null in those situations
1875      *                 where the entity encoding is not auto-detected (e.g.
1876      *                 internal entities or a document entity that is
1877      *                 parsed from a java.io.Reader).
1878      * @param augs     Additional information that may include infoset augmentations
1879      *
1880      * @exception XNIException Thrown by handler to signal an error.
1881      */
1882     public void startGeneralEntity(String name,
1883                                    XMLResourceIdentifier identifier,
1884                                    String encoding,
1885                                    Augmentations augs) throws XNIException{
1886     }
1887 
1888     /**
1889      * Notifies of the presence of a TextDecl line in an entity. If present,
1890      * this method will be called immediately following the startEntity call.
1891      * &lt;p&gt;
1892      * &lt;strong&gt;Note:&lt;/strong&gt; This method will never be called for the
1893      * document entity; it is only called for external general entities
1894      * referenced in document content.
1895      * &lt;p&gt;
1896      * &lt;strong&gt;Note:&lt;/strong&gt; This method is not called for entity references
1897      * appearing as part of attribute values.
1898      *
1899      * @param version  The XML version, or null if not specified.
1900      * @param encoding The IANA encoding name of the entity.
1901      * @param augs     Additional information that may include infoset augmentations
1902      *
1903      * @exception XNIException
1904      *                   Thrown by handler to signal an error.
1905      */
1906     public void textDecl(String version, String encoding, Augmentations augs) throws XNIException{
1907     }
1908 
1909     /**
1910      * This method notifies the end of a general entity.
1911      * &lt;p&gt;
1912      * &lt;strong&gt;Note:&lt;/strong&gt; This method is not called for entity references
1913      * appearing as part of attribute values.
1914      *
1915      * @param name   The name of the entity.
1916      * @param augs   Additional information that may include infoset augmentations
1917      *
1918      * @exception XNIException
1919      *                   Thrown by handler to signal an error.
1920      */
1921     public void endGeneralEntity(String name, Augmentations augs) throws XNIException{
1922     }
1923 
1924     /**
1925      * Character content.
1926      *
1927      * @param text   The content.
1928      * @param augs   Additional information that may include infoset augmentations
1929      *
1930      * @exception XNIException
1931      *                   Thrown by handler to signal an error.
1932      */
1933     public void characters(XMLString text, Augmentations augs) throws XNIException{
1934     }
1935 
1936     /**
1937      * Ignorable whitespace. For this method to be called, the document
1938      * source must have some way of determining that the text containing
1939      * only whitespace characters should be considered ignorable. For
1940      * example, the validator can determine if a length of whitespace
1941      * characters in the document are ignorable based on the element
1942      * content model.
1943      *
1944      * @param text   The ignorable whitespace.
1945      * @param augs   Additional information that may include infoset augmentations
1946      *
1947      * @exception XNIException
1948      *                   Thrown by handler to signal an error.
1949      */
1950     public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException{
<a name="99" id="anc99"></a><span class="line-modified">1951         allWhitespace = true;</span>
1952     }
1953 
1954     /**
1955      * The end of an element.
1956      *
1957      * @param element The name of the element.
1958      * @param augs    Additional information that may include infoset augmentations
1959      *
1960      * @exception XNIException
1961      *                   Thrown by handler to signal an error.
1962      */
<a name="100" id="anc100"></a><span class="line-modified">1963         public void endElement(QName element, Augmentations augs) throws XNIException {</span>
<span class="line-modified">1964                 if (DEBUG_EVENTS) {</span>
<span class="line-modified">1965                         System.out.println(&quot;==&gt;endElement: &quot; + element);</span>
<span class="line-modified">1966                 }</span>
1967 
<a name="101" id="anc101"></a><span class="line-modified">1968         if(augs != null) {</span>
<span class="line-modified">1969                 ElementPSVI elementPSVI = (ElementPSVI) augs.getItem(Constants.ELEMENT_PSVI);</span>
<span class="line-modified">1970                 if (elementPSVI != null) {</span>
<span class="line-modified">1971                         ElementImpl elementNode = (ElementImpl) fCurrentNode;</span>
<span class="line-modified">1972                         if (fPSVI) {</span>
<span class="line-modified">1973                                 ((PSVIElementNSImpl) fCurrentNode).setPSVI(elementPSVI);</span>
<span class="line-modified">1974                         }</span>
<span class="line-modified">1975                         // include element default content (if one is available)</span>
<span class="line-modified">1976                         String normalizedValue = elementPSVI.getSchemaValue().getNormalizedValue();</span>
<span class="line-modified">1977                         if ((fConfiguration.features &amp; DOMConfigurationImpl.DTNORMALIZATION) != 0) {</span>








1978                     if (normalizedValue !=null)
<a name="102" id="anc102"></a><span class="line-modified">1979                                     elementNode.setTextContent(normalizedValue);</span>
<span class="line-modified">1980                         }</span>
<span class="line-modified">1981                         else {</span>
<span class="line-modified">1982                                 // NOTE: this is a hack: it is possible that DOM had an empty element</span>
<span class="line-modified">1983                                 // and validator sent default value using characters(), which we don&#39;t</span>
<span class="line-modified">1984                                 // implement. Thus, here we attempt to add the default value.</span>
<span class="line-modified">1985                                 String text = elementNode.getTextContent();</span>
<span class="line-modified">1986                                 if (text.length() == 0) {</span>
<span class="line-modified">1987                                         // default content could be provided</span>
1988                         if (normalizedValue !=null)
1989                             elementNode.setTextContent(normalizedValue);
<a name="103" id="anc103"></a><span class="line-modified">1990                                 }</span>
<span class="line-removed">1991                         }</span>
1992                 }
<a name="104" id="anc104"></a>

1993         }
<a name="105" id="anc105"></a>


1994         }
<a name="106" id="anc106"></a>
1995 
1996 
1997     /**
1998      * The start of a CDATA section.
1999      *
2000      * @param augs   Additional information that may include infoset augmentations
2001      *
2002      * @exception XNIException
2003      *                   Thrown by handler to signal an error.
2004      */
2005     public void startCDATA(Augmentations augs) throws XNIException{
2006     }
2007 
2008     /**
2009      * The end of a CDATA section.
2010      *
2011      * @param augs   Additional information that may include infoset augmentations
2012      *
2013      * @exception XNIException
2014      *                   Thrown by handler to signal an error.
2015      */
2016     public void endCDATA(Augmentations augs) throws XNIException{
2017     }
2018 
2019     /**
2020      * The end of the document.
2021      *
2022      * @param augs   Additional information that may include infoset augmentations
2023      *
2024      * @exception XNIException
2025      *                   Thrown by handler to signal an error.
2026      */
2027     public void endDocument(Augmentations augs) throws XNIException{
2028     }
2029 
2030 
2031     /** Sets the document source. */
2032     public void setDocumentSource(XMLDocumentSource source){
2033     }
2034 
2035 
2036     /** Returns the document source. */
2037     public XMLDocumentSource getDocumentSource(){
2038         return null;
2039     }
2040 
2041 }  // DOMNormalizer class
<a name="107" id="anc107"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="107" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableInstruction.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LocalVariableGen.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MONITORENTER.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableInstruction.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,42 ***</span>
  import com.sun.org.apache.bcel.internal.util.ByteSequence;
  
  /**
   * Abstract super class for instructions dealing with local variables.
   *
<span class="line-modified">!  * @version $Id: LocalVariableInstruction.java 1747278 2016-06-07 17:28:43Z</span>
<span class="line-removed">-  * britter $</span>
   */
  public abstract class LocalVariableInstruction extends Instruction implements TypedInstruction,
          IndexedInstruction {
  
      private int n = -1; // index of referenced variable
      private short c_tag = -1; // compact version, such as ILOAD_0
      private short canon_tag = -1; // canonical tag such as ILOAD
  
      private boolean wide() {
          return n &gt; Const.MAX_BYTE;
      }
  
      /**
<span class="line-modified">!      * Empty constructor needed for the Class.newInstance() statement in</span>
<span class="line-modified">!      * Instruction.readInstruction(). Not to be used otherwise. tag and length</span>
<span class="line-modified">!      * are defined in readInstruction and initFromFile, respectively.</span>
       */
      LocalVariableInstruction(final short canon_tag, final short c_tag) {
          super();
          this.canon_tag = canon_tag;
          this.c_tag = c_tag;
      }
  
      /**
<span class="line-modified">!      * Empty constructor needed for the Class.newInstance() statement in</span>
<span class="line-modified">!      * Instruction.readInstruction(). Also used by IINC()!</span>
       */
      LocalVariableInstruction() {
      }
  
      /**
       * @param opcode Instruction opcode
       * @param c_tag Instruction number for compact version, ALOAD_0, e.g.
       * @param n local variable index (unsigned short)
       */
<span class="line-new-header">--- 26,45 ---</span>
  import com.sun.org.apache.bcel.internal.util.ByteSequence;
  
  /**
   * Abstract super class for instructions dealing with local variables.
   *
<span class="line-modified">!  * @LastModified: Jan 2020</span>
   */
  public abstract class LocalVariableInstruction extends Instruction implements TypedInstruction,
          IndexedInstruction {
  
      private int n = -1; // index of referenced variable
      private short c_tag = -1; // compact version, such as ILOAD_0
      private short canon_tag = -1; // canonical tag such as ILOAD
  
<span class="line-added">+ </span>
      private boolean wide() {
          return n &gt; Const.MAX_BYTE;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Empty constructor needed for Instruction.readInstruction.</span>
<span class="line-modified">!      * Not to be used otherwise.</span>
<span class="line-modified">!      * tag and length are defined in readInstruction and initFromFile, respectively.</span>
       */
      LocalVariableInstruction(final short canon_tag, final short c_tag) {
          super();
          this.canon_tag = canon_tag;
          this.c_tag = c_tag;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Empty constructor needed for Instruction.readInstruction.</span>
<span class="line-modified">!      * Also used by IINC()!</span>
       */
      LocalVariableInstruction() {
      }
  
<span class="line-added">+ </span>
      /**
       * @param opcode Instruction opcode
       * @param c_tag Instruction number for compact version, ALOAD_0, e.g.
       * @param n local variable index (unsigned short)
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,17 ***</span>
          this.c_tag = c_tag;
          canon_tag = opcode;
          setIndex(n);
      }
  
      /**
       * Dump instruction as byte code to stream out.
<span class="line-removed">-      *</span>
       * @param out Output stream
       */
      @Override
<span class="line-modified">!     public void dump(final DataOutputStream out) throws IOException {</span>
          if (wide()) {
              out.writeByte(Const.WIDE);
          }
          out.writeByte(super.getOpcode());
          if (super.getLength() &gt; 1) { // Otherwise ILOAD_n, instruction, e.g.
<span class="line-new-header">--- 73,17 ---</span>
          this.c_tag = c_tag;
          canon_tag = opcode;
          setIndex(n);
      }
  
<span class="line-added">+ </span>
      /**
       * Dump instruction as byte code to stream out.
       * @param out Output stream
       */
      @Override
<span class="line-modified">!     public void dump( final DataOutputStream out ) throws IOException {</span>
          if (wide()) {
              out.writeByte(Const.WIDE);
          }
          out.writeByte(super.getOpcode());
          if (super.getLength() &gt; 1) { // Otherwise ILOAD_n, instruction, e.g.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,44 ***</span>
                  out.writeByte(n);
              }
          }
      }
  
      /**
       * Long output format:
       *
<span class="line-modified">!      * &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode number&amp;gt;&quot;]&quot; &quot;(&quot;&amp;lt;length of</span>
<span class="line-modified">!      * instruction&amp;gt;&quot;)&quot; &quot;&amp;lt;&quot;&amp;lt; local variable index&amp;gt;&quot;&amp;gt;&quot;</span>
       *
       * @param verbose long/short format switch
       * @return mnemonic for instruction
       */
      @Override
<span class="line-modified">!     public String toString(final boolean verbose) {</span>
          final short _opcode = super.getOpcode();
          if (((_opcode &gt;= Const.ILOAD_0) &amp;&amp; (_opcode &lt;= Const.ALOAD_3))
<span class="line-modified">!                 || ((_opcode &gt;= Const.ISTORE_0) &amp;&amp; (_opcode &lt;= Const.ASTORE_3))) {</span>
              return super.toString(verbose);
          }
          return super.toString(verbose) + &quot; &quot; + n;
      }
  
      /**
       * Read needed data (e.g. index) from file.
       * &lt;pre&gt;
       * (ILOAD &amp;lt;= tag &amp;lt;= ALOAD_3) || (ISTORE &amp;lt;= tag &amp;lt;= ASTORE_3)
       * &lt;/pre&gt;
       */
      @Override
<span class="line-modified">!     protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {</span>
          if (wide) {
              n = bytes.readUnsignedShort();
              super.setLength(4);
          } else {
              final short _opcode = super.getOpcode();
              if (((_opcode &gt;= Const.ILOAD) &amp;&amp; (_opcode &lt;= Const.ALOAD))
<span class="line-modified">!                     || ((_opcode &gt;= Const.ISTORE) &amp;&amp; (_opcode &lt;= Const.ASTORE))) {</span>
                  n = bytes.readUnsignedByte();
                  super.setLength(2);
              } else if (_opcode &lt;= Const.ALOAD_3) { // compact load instruction such as ILOAD_2
                  n = (_opcode - Const.ILOAD_0) % 4;
                  super.setLength(1);
<span class="line-new-header">--- 93,46 ---</span>
                  out.writeByte(n);
              }
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Long output format:
       *
<span class="line-modified">!      * &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode number&amp;gt;&quot;]&quot;</span>
<span class="line-modified">!      * &quot;(&quot;&amp;lt;length of instruction&amp;gt;&quot;)&quot; &quot;&amp;lt;&quot;&amp;lt; local variable index&amp;gt;&quot;&amp;gt;&quot;</span>
       *
       * @param verbose long/short format switch
       * @return mnemonic for instruction
       */
      @Override
<span class="line-modified">!     public String toString( final boolean verbose ) {</span>
          final short _opcode = super.getOpcode();
          if (((_opcode &gt;= Const.ILOAD_0) &amp;&amp; (_opcode &lt;= Const.ALOAD_3))
<span class="line-modified">!          || ((_opcode &gt;= Const.ISTORE_0) &amp;&amp; (_opcode &lt;= Const.ASTORE_3))) {</span>
              return super.toString(verbose);
          }
          return super.toString(verbose) + &quot; &quot; + n;
      }
  
<span class="line-added">+ </span>
      /**
       * Read needed data (e.g. index) from file.
       * &lt;pre&gt;
       * (ILOAD &amp;lt;= tag &amp;lt;= ALOAD_3) || (ISTORE &amp;lt;= tag &amp;lt;= ASTORE_3)
       * &lt;/pre&gt;
       */
      @Override
<span class="line-modified">!     protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {</span>
          if (wide) {
              n = bytes.readUnsignedShort();
              super.setLength(4);
          } else {
              final short _opcode = super.getOpcode();
              if (((_opcode &gt;= Const.ILOAD) &amp;&amp; (_opcode &lt;= Const.ALOAD))
<span class="line-modified">!              || ((_opcode &gt;= Const.ISTORE) &amp;&amp; (_opcode &lt;= Const.ASTORE))) {</span>
                  n = bytes.readUnsignedByte();
                  super.setLength(2);
              } else if (_opcode &lt;= Const.ALOAD_3) { // compact load instruction such as ILOAD_2
                  n = (_opcode - Const.ILOAD_0) % 4;
                  super.setLength(1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,25 ***</span>
                  super.setLength(1);
              }
          }
      }
  
      /**
       * @return local variable index (n) referred by this instruction.
       */
      @Override
      public final int getIndex() {
          return n;
      }
  
      /**
<span class="line-modified">!      * Set the local variable index. also updates opcode and length TODO Why?</span>
<span class="line-modified">!      *</span>
       * @see #setIndexOnly(int)
       */
      @Override
<span class="line-modified">!     public void setIndex(final int n) { // TODO could be package-protected?</span>
          if ((n &lt; 0) || (n &gt; Const.MAX_SHORT)) {
              throw new ClassGenException(&quot;Illegal value: &quot; + n);
          }
          this.n = n;
          // Cannot be &lt; 0 as this is checked above
<span class="line-new-header">--- 141,28 ---</span>
                  super.setLength(1);
              }
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @return local variable index (n) referred by this instruction.
       */
      @Override
      public final int getIndex() {
          return n;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Set the local variable index.</span>
<span class="line-modified">!      * also updates opcode and length</span>
<span class="line-added">+      * TODO Why?</span>
       * @see #setIndexOnly(int)
       */
      @Override
<span class="line-modified">!     public void setIndex( final int n ) { // TODO could be package-protected?</span>
          if ((n &lt; 0) || (n &gt; Const.MAX_SHORT)) {
              throw new ClassGenException(&quot;Illegal value: &quot; + n);
          }
          this.n = n;
          // Cannot be &lt; 0 as this is checked above
</pre>
<hr />
<pre>
<span class="line-old-header">*** 169,27 ***</span>
                  super.setLength(2);
              }
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return canonical tag for instruction, e.g., ALOAD for ALOAD_0</span>
       */
      public short getCanonicalTag() {
          return canon_tag;
      }
  
      /**
<span class="line-modified">!      * Returns the type associated with the instruction - in case of ALOAD or</span>
<span class="line-modified">!      * ASTORE Type.OBJECT is returned. This is just a bit incorrect, because</span>
<span class="line-modified">!      * ALOAD and ASTORE may work on every ReferenceType (including Type.NULL)</span>
<span class="line-modified">!      * and ASTORE may even work on a ReturnaddressType .</span>
<span class="line-modified">!      *</span>
       * @return type associated with the instruction
       */
      @Override
<span class="line-modified">!     public Type getType(final ConstantPoolGen cp) {</span>
          switch (canon_tag) {
              case Const.ILOAD:
              case Const.ISTORE:
                  return Type.INT;
              case Const.LLOAD:
<span class="line-new-header">--- 177,28 ---</span>
                  super.setLength(2);
              }
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return canonical tag for instruction, e.g., ALOAD for ALOAD_0</span>
       */
      public short getCanonicalTag() {
          return canon_tag;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Returns the type associated with the instruction -</span>
<span class="line-modified">!      * in case of ALOAD or ASTORE Type.OBJECT is returned.</span>
<span class="line-modified">!      * This is just a bit incorrect, because ALOAD and ASTORE</span>
<span class="line-modified">!      * may work on every ReferenceType (including Type.NULL) and</span>
<span class="line-modified">!      * ASTORE may even work on a ReturnaddressType .</span>
       * @return type associated with the instruction
       */
      @Override
<span class="line-modified">!     public Type getType( final ConstantPoolGen cp ) {</span>
          switch (canon_tag) {
              case Const.ILOAD:
              case Const.ISTORE:
                  return Type.INT;
              case Const.LLOAD:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,11 ***</span>
          }
      }
  
      /**
       * Sets the index of the referenced variable (n) only
<span class="line-removed">-      *</span>
       * @since 6.0
       * @see #setIndex(int)
       */
      final void setIndexOnly(final int n) {
          this.n = n;
<span class="line-new-header">--- 218,10 ---</span>
</pre>
<center><a href="LocalVariableGen.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MONITORENTER.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
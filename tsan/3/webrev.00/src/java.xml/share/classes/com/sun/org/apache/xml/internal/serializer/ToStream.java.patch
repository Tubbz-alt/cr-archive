diff a/src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToStream.java b/src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToStream.java
--- a/src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToStream.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -49,11 +49,11 @@
 /**
  * This abstract class is a base class for other stream
  * serializers (xml, html, text ...) that write output to a stream.
  *
  * @xsl.usage internal
- * @LastModified: Sept 2018
+ * @LastModified: Aug 2019
  */
 abstract public class ToStream extends SerializerBase {
 
     private static final String COMMENT_BEGIN = "<!--";
     private static final String COMMENT_END = "-->";
@@ -196,11 +196,17 @@
     private char m_highSurrogate = 0;
 
     /**
      * Default constructor
      */
-    public ToStream() { }
+    public ToStream() {
+        this(null);
+    }
+
+    public ToStream(ErrorListener l) {
+        m_errListener = l;
+    }
 
     /**
      * This helper method to writes out "]]>" when closing a CDATA section.
      *
      * @throws org.xml.sax.SAXException
@@ -420,49 +426,34 @@
                             || ( !defaultVal && (oldExplicitEncoding == null || !oldExplicitEncoding.equalsIgnoreCase(newEncoding) ))) {
                        // We are trying to change the default or the non-default setting of the encoding to a different value
                        // from what it was
 
                        EncodingInfo encodingInfo = Encodings.getEncodingInfo(newEncoding);
-                       if (newEncoding != null && encodingInfo.name == null) {
-                        // We tried to get an EncodingInfo for Object for the given
-                        // encoding, but it came back with an internall null name
-                        // so the encoding is not supported by the JDK, issue a message.
-                        final String msg = Utils.messages.createMessage(
-                                MsgKey.ER_ENCODING_NOT_SUPPORTED,new Object[]{ newEncoding });
-
-                        final String msg2 =
-                            "Warning: encoding \"" + newEncoding + "\" not supported, using "
-                                   + Encodings.DEFAULT_MIME_ENCODING;
-                        try {
-                                // Prepare to issue the warning message
-                                final Transformer tran = super.getTransformer();
-                                if (tran != null) {
-                                    final ErrorListener errHandler = tran
-                                            .getErrorListener();
-                                    // Issue the warning message
-                                    if (null != errHandler
-                                            && m_sourceLocator != null) {
-                                        errHandler
-                                                .warning(new TransformerException(
-                                                        msg, m_sourceLocator));
-                                        errHandler
-                                                .warning(new TransformerException(
-                                                        msg2, m_sourceLocator));
-                                    } else {
-                                        System.out.println(msg);
-                                        System.out.println(msg2);
-                                    }
-                                } else {
-                                    System.out.println(msg);
-                                    System.out.println(msg2);
+                       if (encodingInfo.name == null) {
+                            // We tried to get an EncodingInfo for Object for the given
+                            // encoding, but it came back with an internall null name
+                            // so the encoding is not supported by the JDK, issue a message.
+                            final String msg = Utils.messages.createMessage(
+                                    MsgKey.ER_ENCODING_NOT_SUPPORTED,new Object[]{ newEncoding });
+
+                            final String msg2 =
+                                "Warning: encoding \"" + newEncoding + "\" not supported, using "
+                                       + Encodings.DEFAULT_MIME_ENCODING;
+                            try {
+                                // refer to JDK-8229005, should throw Exception instead of warning and
+                                // then falling back to the default encoding. Keep it for now.
+                                if (m_errListener != null) {
+                                    m_errListener.warning(new TransformerException(msg, m_sourceLocator));
+                                    m_errListener.warning(new TransformerException(msg2, m_sourceLocator));
                                 }
                             } catch (Exception e) {
                             }
 
                             // We said we are using UTF-8, so use it
                             newEncoding = Encodings.DEFAULT_MIME_ENCODING;
-                            val = Encodings.DEFAULT_MIME_ENCODING; // to store the modified value into the properties a little later
+                            // to store the modified value into the properties a little later
+                            val = Encodings.DEFAULT_MIME_ENCODING;
                             encodingInfo = Encodings.getEncodingInfo(newEncoding);
                         }
                        // The encoding was good, or was forced to UTF-8 above
 
 
@@ -1229,11 +1220,11 @@
             {
                 closeStartTag();
                 m_elemContext.m_startTagOpen = false;
             }
 
-            if (!m_cdataTagOpen && shouldIndent())
+            if (!m_cdataTagOpen && shouldIndentForText())
                 indent();
 
             boolean writeCDataBrackets =
                 (((length >= 1) && escapingNotNeeded(ch[start])));
 
@@ -1268,10 +1259,11 @@
                  */
                 if (ch[start + length - 1] == ']')
                     closeCDATA();
             }
 
+            m_isprevtext = true;
             // time to fire off CDATA event
             if (m_tracer != null)
                 super.fireCDATAEvent(ch, old_start, length);
         }
         catch (IOException ioe)
@@ -1534,15 +1526,17 @@
             throw new SAXException(e);
         }
     }
 
     /**
-     * Used to flush the buffered characters when indentation is on, this method
-     * will be called when the next node is traversed.
+     * Flushes the buffered characters when indentation is on. This method
+     * is called before the next node is traversed.
      *
+     * @param isText indicates whether the node to be traversed is text
+     * @throws org.xml.sax.SAXException
      */
-    final protected void flushCharactersBuffer() throws SAXException {
+    final protected void flushCharactersBuffer(boolean isText) throws SAXException {
         try {
             if (shouldFormatOutput() && m_charactersBuffer.isAnyCharactersBuffered()) {
                 if (m_elemContext.m_isCdataSection) {
                     /*
                      * due to cdata-section-elements atribute, we need this as
@@ -1551,11 +1545,13 @@
                     char[] chars = m_charactersBuffer.toChars();
                     cdata(chars, 0, chars.length);
                     return;
                 }
 
-                m_childNodeNum++;
+                if (!isText) {
+                    m_childNodeNum++;
+                }
                 boolean skipBeginningNewlines = false;
                 if (shouldIndentForText()) {
                     indent();
                     m_startNewLine = true;
                     // newline has always been added here because if this is the
@@ -1844,11 +1840,11 @@
         if (isInEntityRef())
             return;
 
         if (m_doIndent) {
             m_childNodeNum++;
-            flushCharactersBuffer();
+            flushCharactersBuffer(false);
         }
 
         if (m_needToCallStartDocument)
         {
             startDocumentInternal();
@@ -2115,11 +2111,11 @@
 
         if (isInEntityRef())
             return;
 
         if (m_doIndent) {
-            flushCharactersBuffer();
+            flushCharactersBuffer(false);
         }
         // namespaces declared at the current depth are no longer valid
         // so get rid of them
         m_prefixMap.popNamespaces(m_elemContext.m_currentElemDepth, null);
 
@@ -2307,11 +2303,11 @@
         int start_old = start;
         if (isInEntityRef())
             return;
         if (m_doIndent) {
             m_childNodeNum++;
-            flushCharactersBuffer();
+            flushCharactersBuffer(false);
         }
         if (m_elemContext.m_startTagOpen)
         {
             closeStartTag();
             m_elemContext.m_startTagOpen = false;
@@ -2489,12 +2485,11 @@
      * @see #endCDATA
      */
     public void startCDATA() throws org.xml.sax.SAXException
     {
         if (m_doIndent) {
-            m_childNodeNum++;
-            flushCharactersBuffer();
+            flushCharactersBuffer(true);
         }
 
         m_cdataStartCalled = true;
     }
 

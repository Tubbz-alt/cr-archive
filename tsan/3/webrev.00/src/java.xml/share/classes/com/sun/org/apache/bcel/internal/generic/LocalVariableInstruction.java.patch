diff a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableInstruction.java b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableInstruction.java
--- a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableInstruction.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableInstruction.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -26,42 +26,45 @@
 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 
 /**
  * Abstract super class for instructions dealing with local variables.
  *
- * @version $Id: LocalVariableInstruction.java 1747278 2016-06-07 17:28:43Z
- * britter $
+ * @LastModified: Jan 2020
  */
 public abstract class LocalVariableInstruction extends Instruction implements TypedInstruction,
         IndexedInstruction {
 
     private int n = -1; // index of referenced variable
     private short c_tag = -1; // compact version, such as ILOAD_0
     private short canon_tag = -1; // canonical tag such as ILOAD
 
+
     private boolean wide() {
         return n > Const.MAX_BYTE;
     }
 
+
     /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Not to be used otherwise. tag and length
-     * are defined in readInstruction and initFromFile, respectively.
+     * Empty constructor needed for Instruction.readInstruction.
+     * Not to be used otherwise.
+     * tag and length are defined in readInstruction and initFromFile, respectively.
      */
     LocalVariableInstruction(final short canon_tag, final short c_tag) {
         super();
         this.canon_tag = canon_tag;
         this.c_tag = c_tag;
     }
 
+
     /**
-     * Empty constructor needed for the Class.newInstance() statement in
-     * Instruction.readInstruction(). Also used by IINC()!
+     * Empty constructor needed for Instruction.readInstruction.
+     * Also used by IINC()!
      */
     LocalVariableInstruction() {
     }
 
+
     /**
      * @param opcode Instruction opcode
      * @param c_tag Instruction number for compact version, ALOAD_0, e.g.
      * @param n local variable index (unsigned short)
      */
@@ -70,17 +73,17 @@
         this.c_tag = c_tag;
         canon_tag = opcode;
         setIndex(n);
     }
 
+
     /**
      * Dump instruction as byte code to stream out.
-     *
      * @param out Output stream
      */
     @Override
-    public void dump(final DataOutputStream out) throws IOException {
+    public void dump( final DataOutputStream out ) throws IOException {
         if (wide()) {
             out.writeByte(Const.WIDE);
         }
         out.writeByte(super.getOpcode());
         if (super.getLength() > 1) { // Otherwise ILOAD_n, instruction, e.g.
@@ -90,44 +93,46 @@
                 out.writeByte(n);
             }
         }
     }
 
+
     /**
      * Long output format:
      *
-     * &lt;name of opcode&gt; "["&lt;opcode number&gt;"]" "("&lt;length of
-     * instruction&gt;")" "&lt;"&lt; local variable index&gt;"&gt;"
+     * &lt;name of opcode&gt; "["&lt;opcode number&gt;"]"
+     * "("&lt;length of instruction&gt;")" "&lt;"&lt; local variable index&gt;"&gt;"
      *
      * @param verbose long/short format switch
      * @return mnemonic for instruction
      */
     @Override
-    public String toString(final boolean verbose) {
+    public String toString( final boolean verbose ) {
         final short _opcode = super.getOpcode();
         if (((_opcode >= Const.ILOAD_0) && (_opcode <= Const.ALOAD_3))
-                || ((_opcode >= Const.ISTORE_0) && (_opcode <= Const.ASTORE_3))) {
+         || ((_opcode >= Const.ISTORE_0) && (_opcode <= Const.ASTORE_3))) {
             return super.toString(verbose);
         }
         return super.toString(verbose) + " " + n;
     }
 
+
     /**
      * Read needed data (e.g. index) from file.
      * <pre>
      * (ILOAD &lt;= tag &lt;= ALOAD_3) || (ISTORE &lt;= tag &lt;= ASTORE_3)
      * </pre>
      */
     @Override
-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {
+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {
         if (wide) {
             n = bytes.readUnsignedShort();
             super.setLength(4);
         } else {
             final short _opcode = super.getOpcode();
             if (((_opcode >= Const.ILOAD) && (_opcode <= Const.ALOAD))
-                    || ((_opcode >= Const.ISTORE) && (_opcode <= Const.ASTORE))) {
+             || ((_opcode >= Const.ISTORE) && (_opcode <= Const.ASTORE))) {
                 n = bytes.readUnsignedByte();
                 super.setLength(2);
             } else if (_opcode <= Const.ALOAD_3) { // compact load instruction such as ILOAD_2
                 n = (_opcode - Const.ILOAD_0) % 4;
                 super.setLength(1);
@@ -136,25 +141,28 @@
                 super.setLength(1);
             }
         }
     }
 
+
     /**
      * @return local variable index (n) referred by this instruction.
      */
     @Override
     public final int getIndex() {
         return n;
     }
 
+
     /**
-     * Set the local variable index. also updates opcode and length TODO Why?
-     *
+     * Set the local variable index.
+     * also updates opcode and length
+     * TODO Why?
      * @see #setIndexOnly(int)
      */
     @Override
-    public void setIndex(final int n) { // TODO could be package-protected?
+    public void setIndex( final int n ) { // TODO could be package-protected?
         if ((n < 0) || (n > Const.MAX_SHORT)) {
             throw new ClassGenException("Illegal value: " + n);
         }
         this.n = n;
         // Cannot be < 0 as this is checked above
@@ -169,27 +177,28 @@
                 super.setLength(2);
             }
         }
     }
 
-    /**
-     * @return canonical tag for instruction, e.g., ALOAD for ALOAD_0
+
+    /** @return canonical tag for instruction, e.g., ALOAD for ALOAD_0
      */
     public short getCanonicalTag() {
         return canon_tag;
     }
 
+
     /**
-     * Returns the type associated with the instruction - in case of ALOAD or
-     * ASTORE Type.OBJECT is returned. This is just a bit incorrect, because
-     * ALOAD and ASTORE may work on every ReferenceType (including Type.NULL)
-     * and ASTORE may even work on a ReturnaddressType .
-     *
+     * Returns the type associated with the instruction -
+     * in case of ALOAD or ASTORE Type.OBJECT is returned.
+     * This is just a bit incorrect, because ALOAD and ASTORE
+     * may work on every ReferenceType (including Type.NULL) and
+     * ASTORE may even work on a ReturnaddressType .
      * @return type associated with the instruction
      */
     @Override
-    public Type getType(final ConstantPoolGen cp) {
+    public Type getType( final ConstantPoolGen cp ) {
         switch (canon_tag) {
             case Const.ILOAD:
             case Const.ISTORE:
                 return Type.INT;
             case Const.LLOAD:
@@ -209,11 +218,10 @@
         }
     }
 
     /**
      * Sets the index of the referenced variable (n) only
-     *
      * @since 6.0
      * @see #setIndex(int)
      */
     final void setIndexOnly(final int n) {
         this.n = n;

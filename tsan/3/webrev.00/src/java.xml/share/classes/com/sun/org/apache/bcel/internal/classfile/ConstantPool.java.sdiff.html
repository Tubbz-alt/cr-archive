<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/ConstantPool.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConstantObject.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantString.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/ConstantPool.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.bcel.internal.classfile;
 23 
 24 import java.io.DataInput;
 25 import java.io.DataOutputStream;
 26 import java.io.IOException;
 27 
 28 import com.sun.org.apache.bcel.internal.Const;
 29 
 30 /**
 31  * This class represents the constant pool, i.e., a table of constants, of
 32  * a parsed classfile. It may contain null references, due to the JVM
 33  * specification that skips an entry after an 8-byte constant (double,
 34  * long) entry.  Those interested in generating constant pools
 35  * programatically should see &lt;a href=&quot;../generic/ConstantPoolGen.html&quot;&gt;
 36  * ConstantPoolGen&lt;/a&gt;.
 37 
<span class="line-removed"> 38  * @version $Id: ConstantPool.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 39  * @see     Constant
 40  * @see     com.sun.org.apache.bcel.internal.generic.ConstantPoolGen
 41  */
 42 public class ConstantPool implements Cloneable, Node {
 43 
 44     private Constant[] constant_pool;
 45 
<span class="line-removed"> 46 </span>
 47     /**
 48      * @param constant_pool Array of constants
 49      */
 50     public ConstantPool(final Constant[] constant_pool) {
 51         this.constant_pool = constant_pool;
 52     }
 53 
<span class="line-removed"> 54 </span>
 55     /**
<span class="line-modified"> 56      * Read constants from given input stream.</span>
 57      *
 58      * @param input Input stream
 59      * @throws IOException
 60      * @throws ClassFormatException
 61      */
 62     public ConstantPool(final DataInput input) throws IOException, ClassFormatException {
 63         byte tag;
 64         final int constant_pool_count = input.readUnsignedShort();
 65         constant_pool = new Constant[constant_pool_count];
 66         /* constant_pool[0] is unused by the compiler and may be used freely
 67          * by the implementation.
 68          */
 69         for (int i = 1; i &lt; constant_pool_count; i++) {
 70             constant_pool[i] = Constant.readConstant(input);
 71             /* Quote from the JVM specification:
 72              * &quot;All eight byte constants take up two spots in the constant pool.
 73              * If this is the n&#39;th byte in the constant pool, then the next item
 74              * will be numbered n+2&quot;
 75              *
 76              * Thus we have to increment the index counter.
 77              */
 78             tag = constant_pool[i].getTag();
 79             if ((tag == Const.CONSTANT_Double) || (tag == Const.CONSTANT_Long)) {
 80                 i++;
 81             }
 82         }
 83     }
 84 
<span class="line-removed"> 85 </span>
 86     /**
 87      * Called by objects that are traversing the nodes of the tree implicitely
 88      * defined by the contents of a Java class. I.e., the hierarchy of methods,
 89      * fields, attributes, etc. spawns a tree of objects.
 90      *
 91      * @param v Visitor object
 92      */
 93     @Override
 94     public void accept( final Visitor v ) {
 95         v.visitConstantPool(this);
 96     }
 97 
<span class="line-removed"> 98 </span>
 99     /**
<span class="line-modified">100      * Resolve constant to a string representation.</span>
101      *
102      * @param  c Constant to be printed
103      * @return String representation
104      */
105     public String constantToString( Constant c ) throws ClassFormatException {
106         String str;
107         int i;
108         final byte tag = c.getTag();
109         switch (tag) {
110             case Const.CONSTANT_Class:
111                 i = ((ConstantClass) c).getNameIndex();
112                 c = getConstant(i, Const.CONSTANT_Utf8);
113                 str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
114                 break;
115             case Const.CONSTANT_String:
116                 i = ((ConstantString) c).getStringIndex();
117                 c = getConstant(i, Const.CONSTANT_Utf8);
118                 str = &quot;\&quot;&quot; + escape(((ConstantUtf8) c).getBytes()) + &quot;\&quot;&quot;;
119                 break;
120             case Const.CONSTANT_Utf8:
121                 str = ((ConstantUtf8) c).getBytes();
122                 break;
123             case Const.CONSTANT_Double:
124                 str = String.valueOf(((ConstantDouble) c).getBytes());
125                 break;
126             case Const.CONSTANT_Float:
127                 str = String.valueOf(((ConstantFloat) c).getBytes());
128                 break;
129             case Const.CONSTANT_Long:
130                 str = String.valueOf(((ConstantLong) c).getBytes());
131                 break;
132             case Const.CONSTANT_Integer:
133                 str = String.valueOf(((ConstantInteger) c).getBytes());
134                 break;
135             case Const.CONSTANT_NameAndType:
136                 str = constantToString(((ConstantNameAndType) c).getNameIndex(),
137                         Const.CONSTANT_Utf8)
<span class="line-modified">138                         + &quot;:&quot; + constantToString(((ConstantNameAndType) c).getSignatureIndex(),</span>
139                         Const.CONSTANT_Utf8);
140                 break;
141             case Const.CONSTANT_InterfaceMethodref:
142             case Const.CONSTANT_Methodref:
143             case Const.CONSTANT_Fieldref:
144                 str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class)
145                         + &quot;.&quot; + constantToString(((ConstantCP) c).getNameAndTypeIndex(),
146                         Const.CONSTANT_NameAndType);
147                 break;
148             case Const.CONSTANT_MethodHandle:
149                 // Note that the ReferenceIndex may point to a Fieldref, Methodref or
150                 // InterfaceMethodref - so we need to peek ahead to get the actual type.
151                 final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
152                 str = Const.getMethodHandleName(cmh.getReferenceKind())
153                         + &quot; &quot; + constantToString(cmh.getReferenceIndex(),
154                         getConstant(cmh.getReferenceIndex()).getTag());
155                 break;
156             case Const.CONSTANT_MethodType:
157                 final ConstantMethodType cmt = (ConstantMethodType) c;
158                 str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
159                 break;
160             case Const.CONSTANT_InvokeDynamic:
161                 final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
162                 str = cid.getBootstrapMethodAttrIndex()
163                         + &quot;:&quot; + constantToString(cid.getNameAndTypeIndex(),
164                         Const.CONSTANT_NameAndType);
165                 break;










166             default: // Never reached
167                 throw new RuntimeException(&quot;Unknown constant type &quot; + tag);
168         }
169         return str;
170     }
171 
<span class="line-removed">172 </span>
173     private static String escape( final String str ) {
174         final int len = str.length();
175         final StringBuilder buf = new StringBuilder(len + 5);
176         final char[] ch = str.toCharArray();
177         for (int i = 0; i &lt; len; i++) {
178             switch (ch[i]) {
179                 case &#39;\n&#39;:
180                     buf.append(&quot;\\n&quot;);
181                     break;
182                 case &#39;\r&#39;:
183                     buf.append(&quot;\\r&quot;);
184                     break;
185                 case &#39;\t&#39;:
186                     buf.append(&quot;\\t&quot;);
187                     break;
188                 case &#39;\b&#39;:
189                     buf.append(&quot;\\b&quot;);
190                     break;
191                 case &#39;&quot;&#39;:
192                     buf.append(&quot;\\\&quot;&quot;);
193                     break;
194                 default:
195                     buf.append(ch[i]);
196             }
197         }
198         return buf.toString();
199     }
200 
<span class="line-removed">201 </span>
202     /**
<span class="line-modified">203      * Retrieve constant at `index&#39; from constant pool and resolve it to</span>
204      * a string representation.
205      *
206      * @param  index of constant in constant pool
207      * @param  tag expected type
208      * @return String representation
209      */
210     public String constantToString( final int index, final byte tag ) throws ClassFormatException {
211         final Constant c = getConstant(index, tag);
212         return constantToString(c);
213     }
214 
<span class="line-removed">215 </span>
216     /**
217      * Dump constant pool to file stream in binary format.
218      *
219      * @param file Output file stream
220      * @throws IOException
221      */
222     public void dump( final DataOutputStream file ) throws IOException {
223         file.writeShort(constant_pool.length);
224         for (int i = 1; i &lt; constant_pool.length; i++) {
225             if (constant_pool[i] != null) {
226                 constant_pool[i].dump(file);
227             }
228         }
229     }
230 
<span class="line-removed">231 </span>
232     /**
<span class="line-modified">233      * Get constant from constant pool.</span>
234      *
235      * @param  index Index in constant pool
236      * @return Constant value
237      * @see    Constant
238      */
239     public Constant getConstant( final int index ) {
240         if (index &gt;= constant_pool.length || index &lt; 0) {
241             throw new ClassFormatException(&quot;Invalid constant pool reference: &quot; + index
242                     + &quot;. Constant pool size is: &quot; + constant_pool.length);
243         }
244         return constant_pool[index];
245     }
246 
<span class="line-removed">247 </span>
248     /**
<span class="line-modified">249      * Get constant from constant pool and check whether it has the</span>
250      * expected type.
251      *
252      * @param  index Index in constant pool
253      * @param  tag Tag of expected constant, i.e., its type
254      * @return Constant value
255      * @see    Constant
256      * @throws  ClassFormatException
257      */
258     public Constant getConstant( final int index, final byte tag ) throws ClassFormatException {
259         Constant c;
260         c = getConstant(index);
261         if (c == null) {
262             throw new ClassFormatException(&quot;Constant pool at index &quot; + index + &quot; is null.&quot;);
263         }
264         if (c.getTag() != tag) {
265             throw new ClassFormatException(&quot;Expected class `&quot; + Const.getConstantName(tag)
266                     + &quot;&#39; at index &quot; + index + &quot; and got &quot; + c);
267         }
268         return c;
269     }
270 
<span class="line-removed">271 </span>
272     /**
273      * @return Array of constants.
274      * @see    Constant
275      */
276     public Constant[] getConstantPool() {
277         return constant_pool;
278     }
279 
<span class="line-removed">280 </span>
281     /**
<span class="line-modified">282      * Get string from constant pool and bypass the indirection of</span>
283      * `ConstantClass&#39; and `ConstantString&#39; objects. I.e. these classes have
284      * an index field that points to another entry of the constant pool of
285      * type `ConstantUtf8&#39; which contains the real data.
286      *
287      * @param  index Index in constant pool
288      * @param  tag Tag of expected constant, either ConstantClass or ConstantString
289      * @return Contents of string reference
290      * @see    ConstantClass
291      * @see    ConstantString
292      * @throws  ClassFormatException
293      */
294     public String getConstantString( final int index, final byte tag ) throws ClassFormatException {
295         Constant c;
296         int i;
297         c = getConstant(index, tag);
<span class="line-modified">298         /* This switch() is not that elegant, since the two classes have the</span>
299          * same contents, they just differ in the name of the index
300          * field variable.
301          * But we want to stick to the JVM naming conventions closely though
302          * we could have solved these more elegantly by using the same
303          * variable name or by subclassing.
304          */
305         switch (tag) {
306             case Const.CONSTANT_Class:
307                 i = ((ConstantClass) c).getNameIndex();
308                 break;
309             case Const.CONSTANT_String:
310                 i = ((ConstantString) c).getStringIndex();
311                 break;






312             default:
313                 throw new RuntimeException(&quot;getConstantString called with illegal tag &quot; + tag);
314         }
315         // Finally get the string from the constant pool
316         c = getConstant(i, Const.CONSTANT_Utf8);
317         return ((ConstantUtf8) c).getBytes();
318     }
319 
320 
321     /**
322      * @return Length of constant pool.
323      */
324     public int getLength() {
325         return constant_pool == null ? 0 : constant_pool.length;
326     }
327 
328 
329     /**
330      * @param constant Constant to set
331      */
</pre>
</td>
<td>
<hr />
<pre>
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.bcel.internal.classfile;
 23 
 24 import java.io.DataInput;
 25 import java.io.DataOutputStream;
 26 import java.io.IOException;
 27 
 28 import com.sun.org.apache.bcel.internal.Const;
 29 
 30 /**
 31  * This class represents the constant pool, i.e., a table of constants, of
 32  * a parsed classfile. It may contain null references, due to the JVM
 33  * specification that skips an entry after an 8-byte constant (double,
 34  * long) entry.  Those interested in generating constant pools
 35  * programatically should see &lt;a href=&quot;../generic/ConstantPoolGen.html&quot;&gt;
 36  * ConstantPoolGen&lt;/a&gt;.
 37 

 38  * @see     Constant
 39  * @see     com.sun.org.apache.bcel.internal.generic.ConstantPoolGen
 40  */
 41 public class ConstantPool implements Cloneable, Node {
 42 
 43     private Constant[] constant_pool;
 44 

 45     /**
 46      * @param constant_pool Array of constants
 47      */
 48     public ConstantPool(final Constant[] constant_pool) {
 49         this.constant_pool = constant_pool;
 50     }
 51 

 52     /**
<span class="line-modified"> 53      * Reads constants from given input stream.</span>
 54      *
 55      * @param input Input stream
 56      * @throws IOException
 57      * @throws ClassFormatException
 58      */
 59     public ConstantPool(final DataInput input) throws IOException, ClassFormatException {
 60         byte tag;
 61         final int constant_pool_count = input.readUnsignedShort();
 62         constant_pool = new Constant[constant_pool_count];
 63         /* constant_pool[0] is unused by the compiler and may be used freely
 64          * by the implementation.
 65          */
 66         for (int i = 1; i &lt; constant_pool_count; i++) {
 67             constant_pool[i] = Constant.readConstant(input);
 68             /* Quote from the JVM specification:
 69              * &quot;All eight byte constants take up two spots in the constant pool.
 70              * If this is the n&#39;th byte in the constant pool, then the next item
 71              * will be numbered n+2&quot;
 72              *
 73              * Thus we have to increment the index counter.
 74              */
 75             tag = constant_pool[i].getTag();
 76             if ((tag == Const.CONSTANT_Double) || (tag == Const.CONSTANT_Long)) {
 77                 i++;
 78             }
 79         }
 80     }
 81 

 82     /**
 83      * Called by objects that are traversing the nodes of the tree implicitely
 84      * defined by the contents of a Java class. I.e., the hierarchy of methods,
 85      * fields, attributes, etc. spawns a tree of objects.
 86      *
 87      * @param v Visitor object
 88      */
 89     @Override
 90     public void accept( final Visitor v ) {
 91         v.visitConstantPool(this);
 92     }
 93 

 94     /**
<span class="line-modified"> 95      * Resolves constant to a string representation.</span>
 96      *
 97      * @param  c Constant to be printed
 98      * @return String representation
 99      */
100     public String constantToString( Constant c ) throws ClassFormatException {
101         String str;
102         int i;
103         final byte tag = c.getTag();
104         switch (tag) {
105             case Const.CONSTANT_Class:
106                 i = ((ConstantClass) c).getNameIndex();
107                 c = getConstant(i, Const.CONSTANT_Utf8);
108                 str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
109                 break;
110             case Const.CONSTANT_String:
111                 i = ((ConstantString) c).getStringIndex();
112                 c = getConstant(i, Const.CONSTANT_Utf8);
113                 str = &quot;\&quot;&quot; + escape(((ConstantUtf8) c).getBytes()) + &quot;\&quot;&quot;;
114                 break;
115             case Const.CONSTANT_Utf8:
116                 str = ((ConstantUtf8) c).getBytes();
117                 break;
118             case Const.CONSTANT_Double:
119                 str = String.valueOf(((ConstantDouble) c).getBytes());
120                 break;
121             case Const.CONSTANT_Float:
122                 str = String.valueOf(((ConstantFloat) c).getBytes());
123                 break;
124             case Const.CONSTANT_Long:
125                 str = String.valueOf(((ConstantLong) c).getBytes());
126                 break;
127             case Const.CONSTANT_Integer:
128                 str = String.valueOf(((ConstantInteger) c).getBytes());
129                 break;
130             case Const.CONSTANT_NameAndType:
131                 str = constantToString(((ConstantNameAndType) c).getNameIndex(),
132                         Const.CONSTANT_Utf8)
<span class="line-modified">133                         + &quot; &quot; + constantToString(((ConstantNameAndType) c).getSignatureIndex(),</span>
134                         Const.CONSTANT_Utf8);
135                 break;
136             case Const.CONSTANT_InterfaceMethodref:
137             case Const.CONSTANT_Methodref:
138             case Const.CONSTANT_Fieldref:
139                 str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class)
140                         + &quot;.&quot; + constantToString(((ConstantCP) c).getNameAndTypeIndex(),
141                         Const.CONSTANT_NameAndType);
142                 break;
143             case Const.CONSTANT_MethodHandle:
144                 // Note that the ReferenceIndex may point to a Fieldref, Methodref or
145                 // InterfaceMethodref - so we need to peek ahead to get the actual type.
146                 final ConstantMethodHandle cmh = (ConstantMethodHandle) c;
147                 str = Const.getMethodHandleName(cmh.getReferenceKind())
148                         + &quot; &quot; + constantToString(cmh.getReferenceIndex(),
149                         getConstant(cmh.getReferenceIndex()).getTag());
150                 break;
151             case Const.CONSTANT_MethodType:
152                 final ConstantMethodType cmt = (ConstantMethodType) c;
153                 str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);
154                 break;
155             case Const.CONSTANT_InvokeDynamic:
156                 final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
157                 str = cid.getBootstrapMethodAttrIndex()
158                         + &quot;:&quot; + constantToString(cid.getNameAndTypeIndex(),
159                         Const.CONSTANT_NameAndType);
160                 break;
<span class="line-added">161             case Const.CONSTANT_Module:</span>
<span class="line-added">162                 i = ((ConstantModule) c).getNameIndex();</span>
<span class="line-added">163                 c = getConstant(i, Const.CONSTANT_Utf8);</span>
<span class="line-added">164                 str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);</span>
<span class="line-added">165                 break;</span>
<span class="line-added">166             case Const.CONSTANT_Package:</span>
<span class="line-added">167                 i = ((ConstantPackage) c).getNameIndex();</span>
<span class="line-added">168                 c = getConstant(i, Const.CONSTANT_Utf8);</span>
<span class="line-added">169                 str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);</span>
<span class="line-added">170                 break;</span>
171             default: // Never reached
172                 throw new RuntimeException(&quot;Unknown constant type &quot; + tag);
173         }
174         return str;
175     }
176 

177     private static String escape( final String str ) {
178         final int len = str.length();
179         final StringBuilder buf = new StringBuilder(len + 5);
180         final char[] ch = str.toCharArray();
181         for (int i = 0; i &lt; len; i++) {
182             switch (ch[i]) {
183                 case &#39;\n&#39;:
184                     buf.append(&quot;\\n&quot;);
185                     break;
186                 case &#39;\r&#39;:
187                     buf.append(&quot;\\r&quot;);
188                     break;
189                 case &#39;\t&#39;:
190                     buf.append(&quot;\\t&quot;);
191                     break;
192                 case &#39;\b&#39;:
193                     buf.append(&quot;\\b&quot;);
194                     break;
195                 case &#39;&quot;&#39;:
196                     buf.append(&quot;\\\&quot;&quot;);
197                     break;
198                 default:
199                     buf.append(ch[i]);
200             }
201         }
202         return buf.toString();
203     }
204 

205     /**
<span class="line-modified">206      * Retrieves constant at `index&#39; from constant pool and resolve it to</span>
207      * a string representation.
208      *
209      * @param  index of constant in constant pool
210      * @param  tag expected type
211      * @return String representation
212      */
213     public String constantToString( final int index, final byte tag ) throws ClassFormatException {
214         final Constant c = getConstant(index, tag);
215         return constantToString(c);
216     }
217 

218     /**
219      * Dump constant pool to file stream in binary format.
220      *
221      * @param file Output file stream
222      * @throws IOException
223      */
224     public void dump( final DataOutputStream file ) throws IOException {
225         file.writeShort(constant_pool.length);
226         for (int i = 1; i &lt; constant_pool.length; i++) {
227             if (constant_pool[i] != null) {
228                 constant_pool[i].dump(file);
229             }
230         }
231     }
232 

233     /**
<span class="line-modified">234      * Gets constant from constant pool.</span>
235      *
236      * @param  index Index in constant pool
237      * @return Constant value
238      * @see    Constant
239      */
240     public Constant getConstant( final int index ) {
241         if (index &gt;= constant_pool.length || index &lt; 0) {
242             throw new ClassFormatException(&quot;Invalid constant pool reference: &quot; + index
243                     + &quot;. Constant pool size is: &quot; + constant_pool.length);
244         }
245         return constant_pool[index];
246     }
247 

248     /**
<span class="line-modified">249      * Gets constant from constant pool and check whether it has the</span>
250      * expected type.
251      *
252      * @param  index Index in constant pool
253      * @param  tag Tag of expected constant, i.e., its type
254      * @return Constant value
255      * @see    Constant
256      * @throws  ClassFormatException
257      */
258     public Constant getConstant( final int index, final byte tag ) throws ClassFormatException {
259         Constant c;
260         c = getConstant(index);
261         if (c == null) {
262             throw new ClassFormatException(&quot;Constant pool at index &quot; + index + &quot; is null.&quot;);
263         }
264         if (c.getTag() != tag) {
265             throw new ClassFormatException(&quot;Expected class `&quot; + Const.getConstantName(tag)
266                     + &quot;&#39; at index &quot; + index + &quot; and got &quot; + c);
267         }
268         return c;
269     }
270 

271     /**
272      * @return Array of constants.
273      * @see    Constant
274      */
275     public Constant[] getConstantPool() {
276         return constant_pool;
277     }
278 

279     /**
<span class="line-modified">280      * Gets string from constant pool and bypass the indirection of</span>
281      * `ConstantClass&#39; and `ConstantString&#39; objects. I.e. these classes have
282      * an index field that points to another entry of the constant pool of
283      * type `ConstantUtf8&#39; which contains the real data.
284      *
285      * @param  index Index in constant pool
286      * @param  tag Tag of expected constant, either ConstantClass or ConstantString
287      * @return Contents of string reference
288      * @see    ConstantClass
289      * @see    ConstantString
290      * @throws  ClassFormatException
291      */
292     public String getConstantString( final int index, final byte tag ) throws ClassFormatException {
293         Constant c;
294         int i;
295         c = getConstant(index, tag);
<span class="line-modified">296         /* This switch() is not that elegant, since the four classes have the</span>
297          * same contents, they just differ in the name of the index
298          * field variable.
299          * But we want to stick to the JVM naming conventions closely though
300          * we could have solved these more elegantly by using the same
301          * variable name or by subclassing.
302          */
303         switch (tag) {
304             case Const.CONSTANT_Class:
305                 i = ((ConstantClass) c).getNameIndex();
306                 break;
307             case Const.CONSTANT_String:
308                 i = ((ConstantString) c).getStringIndex();
309                 break;
<span class="line-added">310             case Const.CONSTANT_Module:</span>
<span class="line-added">311                 i = ((ConstantModule) c).getNameIndex();</span>
<span class="line-added">312                 break;</span>
<span class="line-added">313             case Const.CONSTANT_Package:</span>
<span class="line-added">314                 i = ((ConstantPackage) c).getNameIndex();</span>
<span class="line-added">315                 break;</span>
316             default:
317                 throw new RuntimeException(&quot;getConstantString called with illegal tag &quot; + tag);
318         }
319         // Finally get the string from the constant pool
320         c = getConstant(i, Const.CONSTANT_Utf8);
321         return ((ConstantUtf8) c).getBytes();
322     }
323 
324 
325     /**
326      * @return Length of constant pool.
327      */
328     public int getLength() {
329         return constant_pool == null ? 0 : constant_pool.length;
330     }
331 
332 
333     /**
334      * @param constant Constant to set
335      */
</pre>
</td>
</tr>
</table>
<center><a href="ConstantObject.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantString.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
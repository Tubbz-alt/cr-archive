<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Select.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.io.DataOutputStream;
 23 import java.io.IOException;
 24 
 25 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 26 
 27 /**
 28  * Select - Abstract super class for LOOKUPSWITCH and TABLESWITCH instructions.
 29  *
<a name="2" id="anc2"></a><span class="line-modified"> 30  * &lt;p&gt;We use our super&#39;s &lt;code&gt;target&lt;/code&gt; property as the default target.</span>

 31  *
<a name="3" id="anc3"></a>
 32  * @see LOOKUPSWITCH
 33  * @see TABLESWITCH
 34  * @see InstructionList
<a name="4" id="anc4"></a><span class="line-added"> 35  * @LastModified: Jan 2020</span>
 36  */
 37 public abstract class Select extends BranchInstruction implements VariableLengthInstruction,
 38         StackConsumer /* @since 6.0 */, StackProducer {
 39 
 40     private int[] match; // matches, i.e., case 1: ... TODO could be package-protected?
 41     private int[] indices; // target offsets TODO could be package-protected?
 42     private InstructionHandle[] targets; // target objects in instruction list TODO could be package-protected?
 43     private int fixed_length; // fixed length defined by subclasses TODO could be package-protected?
 44     private int match_length; // number of cases TODO could be package-protected?
 45     private int padding = 0; // number of pad bytes for alignment TODO could be package-protected?
 46 
 47     /**
<a name="5" id="anc5"></a><span class="line-modified"> 48      * Empty constructor needed for Instruction.readInstruction.</span>
<span class="line-modified"> 49      * Not to be used otherwise.</span>
 50      */
 51     Select() {
 52     }
 53 
<a name="6" id="anc6"></a><span class="line-added"> 54 </span>
 55     /**
<a name="7" id="anc7"></a><span class="line-modified"> 56      * (Match, target) pairs for switch.</span>
<span class="line-modified"> 57      * `Match&#39; and `targets&#39; must have the same length of course.</span>
 58      *
 59      * @param match array of matching values
 60      * @param targets instruction targets
 61      * @param defaultTarget default instruction target
 62      */
 63     Select(final short opcode, final int[] match, final InstructionHandle[] targets, final InstructionHandle defaultTarget) {
 64         // don&#39;t set default target before instuction is built
 65         super(opcode, null);
 66         this.match = match;
 67         this.targets = targets;
 68         // now it&#39;s safe to set default target
 69         setTarget(defaultTarget);
 70         for (final InstructionHandle target2 : targets) {
 71             notifyTarget(null, target2, this);
 72         }
 73         if ((match_length = match.length) != targets.length) {
<a name="8" id="anc8"></a><span class="line-modified"> 74             throw new ClassGenException(&quot;Match and target array have not the same length: Match length: &quot; +</span>
<span class="line-modified"> 75                 match.length + &quot; Target length: &quot; + targets.length);</span>
 76         }
 77         indices = new int[match_length];
 78     }
 79 
<a name="9" id="anc9"></a><span class="line-added"> 80 </span>
 81     /**
 82      * Since this is a variable length instruction, it may shift the following
 83      * instructions which then need to update their position.
 84      *
<a name="10" id="anc10"></a><span class="line-modified"> 85      * Called by InstructionList.setPositions when setting the position for every</span>
<span class="line-modified"> 86      * instruction. In the presence of variable length instructions `setPositions&#39;</span>
<span class="line-modified"> 87      * performs multiple passes over the instruction list to calculate the</span>
<span class="line-modified"> 88      * correct (byte) positions and offsets by calling this function.</span>

 89      *
<a name="11" id="anc11"></a><span class="line-modified"> 90      * @param offset additional offset caused by preceding (variable length) instructions</span>
<span class="line-modified"> 91      * @param max_offset the maximum offset that may be caused by these instructions</span>
<span class="line-modified"> 92      * @return additional offset caused by possible change of this instruction&#39;s length</span>



 93      */
 94     @Override
<a name="12" id="anc12"></a><span class="line-modified"> 95     protected int updatePosition( final int offset, final int max_offset ) {</span>
 96         setPosition(getPosition() + offset); // Additional offset caused by preceding SWITCHs, GOTOs, etc.
 97         final short old_length = (short) super.getLength();
 98         /* Alignment on 4-byte-boundary, + 1, because of tag byte.
 99          */
100         padding = (4 - ((getPosition() + 1) % 4)) % 4;
101         super.setLength((short) (fixed_length + padding)); // Update length
102         return super.getLength() - old_length;
103     }
104 
<a name="13" id="anc13"></a><span class="line-added">105 </span>
106     /**
107      * Dump instruction as byte code to stream out.
<a name="14" id="anc14"></a>
108      * @param out Output stream
109      */
110     @Override
<a name="15" id="anc15"></a><span class="line-modified">111     public void dump( final DataOutputStream out ) throws IOException {</span>
112         out.writeByte(super.getOpcode());
113         for (int i = 0; i &lt; padding; i++) {
114             out.writeByte(0);
115         }
116         super.setIndex(getTargetOffset()); // Write default target offset
117         out.writeInt(super.getIndex());
118     }
119 
<a name="16" id="anc16"></a><span class="line-added">120 </span>
121     /**
122      * Read needed data (e.g. index) from file.
123      */
124     @Override
<a name="17" id="anc17"></a><span class="line-modified">125     protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {</span>
126         padding = (4 - (bytes.getIndex() % 4)) % 4; // Compute number of pad bytes
127         for (int i = 0; i &lt; padding; i++) {
128             bytes.readByte();
129         }
130         // Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)
131         super.setIndex(bytes.readInt());
132     }
133 
<a name="18" id="anc18"></a><span class="line-added">134 </span>
135     /**
136      * @return mnemonic for instruction
137      */
138     @Override
<a name="19" id="anc19"></a><span class="line-modified">139     public String toString( final boolean verbose ) {</span>
140         final StringBuilder buf = new StringBuilder(super.toString(verbose));
141         if (verbose) {
142             for (int i = 0; i &lt; match_length; i++) {
143                 String s = &quot;null&quot;;
144                 if (targets[i] != null) {
145                     s = targets[i].getInstruction().toString();
146                 }
147                 buf.append(&quot;(&quot;).append(match[i]).append(&quot;, &quot;).append(s).append(&quot; = {&quot;).append(
148                         indices[i]).append(&quot;})&quot;);
149             }
150         } else {
151             buf.append(&quot; ...&quot;);
152         }
153         return buf.toString();
154     }
155 
<a name="20" id="anc20"></a><span class="line-added">156 </span>
157     /**
158      * Set branch target for `i&#39;th case
159      */
<a name="21" id="anc21"></a><span class="line-modified">160     public void setTarget( final int i, final InstructionHandle target ) { // TODO could be package-protected?</span>
161         notifyTarget(targets[i], target, this);
162         targets[i] = target;
163     }
164 
<a name="22" id="anc22"></a><span class="line-added">165 </span>
166     /**
167      * @param old_ih old target
168      * @param new_ih new target
169      */
170     @Override
<a name="23" id="anc23"></a><span class="line-modified">171     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
172         boolean targeted = false;
173         if (super.getTarget() == old_ih) {
174             targeted = true;
175             setTarget(new_ih);
176         }
177         for (int i = 0; i &lt; targets.length; i++) {
178             if (targets[i] == old_ih) {
179                 targeted = true;
180                 setTarget(i, new_ih);
181             }
182         }
183         if (!targeted) {
184             throw new ClassGenException(&quot;Not targeting &quot; + old_ih);
185         }
186     }
187 
<a name="24" id="anc24"></a><span class="line-added">188 </span>
189     /**
190      * @return true, if ih is target of this instruction
191      */
192     @Override
<a name="25" id="anc25"></a><span class="line-modified">193     public boolean containsTarget( final InstructionHandle ih ) {</span>
194         if (super.getTarget() == ih) {
195             return true;
196         }
197         for (final InstructionHandle target2 : targets) {
198             if (target2 == ih) {
199                 return true;
200             }
201         }
202         return false;
203     }
204 
<a name="26" id="anc26"></a><span class="line-added">205 </span>
206     @Override
207     protected Object clone() throws CloneNotSupportedException {
208         final Select copy = (Select) super.clone();
209         copy.match = match.clone();
210         copy.indices = indices.clone();
211         copy.targets = targets.clone();
212         return copy;
213     }
214 
<a name="27" id="anc27"></a><span class="line-added">215 </span>
216     /**
217      * Inform targets that they&#39;re not targeted anymore.
218      */
219     @Override
220     void dispose() {
221         super.dispose();
222         for (final InstructionHandle target2 : targets) {
223             target2.removeTargeter(this);
224         }
225     }
226 
<a name="28" id="anc28"></a><span class="line-added">227 </span>
228     /**
229      * @return array of match indices
230      */
231     public int[] getMatchs() {
232         return match;
233     }
234 
<a name="29" id="anc29"></a><span class="line-added">235 </span>
236     /**
237      * @return array of match target offsets
238      */
239     public int[] getIndices() {
240         return indices;
241     }
242 
<a name="30" id="anc30"></a><span class="line-added">243 </span>
244     /**
245      * @return array of match targets
246      */
247     public InstructionHandle[] getTargets() {
248         return targets;
249     }
250 
251     /**
252      * @return match entry
253      * @since 6.0
254      */
255     final int getMatch(final int index) {
256         return match[index];
257     }
258 
<a name="31" id="anc31"></a><span class="line-added">259 </span>
260     /**
261      * @return index entry from indices
262      * @since 6.0
263      */
264     final int getIndices(final int index) {
265         return indices[index];
266     }
267 
268     /**
269      * @return target entry
270      * @since 6.0
271      */
272     final InstructionHandle getTarget(final int index) {
273         return targets[index];
274     }
275 
<a name="32" id="anc32"></a><span class="line-added">276 </span>
277     /**
278      * @return the fixed_length
279      * @since 6.0
280      */
281     final int getFixed_length() {
282         return fixed_length;
283     }
284 
<a name="33" id="anc33"></a><span class="line-added">285 </span>
286     /**
287      * @param fixed_length the fixed_length to set
288      * @since 6.0
289      */
290     final void setFixed_length(final int fixed_length) {
291         this.fixed_length = fixed_length;
292     }
293 
<a name="34" id="anc34"></a><span class="line-added">294 </span>
295     /**
296      * @return the match_length
297      * @since 6.0
298      */
299     final int getMatch_length() {
300         return match_length;
301     }
302 
<a name="35" id="anc35"></a><span class="line-added">303 </span>
304     /**
305      * @param match_length the match_length to set
306      * @since 6.0
307      */
308     final int setMatch_length(final int match_length) {
309         this.match_length = match_length;
310         return match_length;
311     }
312 
313     /**
314      *
315      * @param index
316      * @param value
317      * @since 6.0
318      */
319     final void setMatch(final int index, final int value) {
320         match[index] = value;
321     }
322 
323     /**
324      *
325      * @param array
326      * @since 6.0
327      */
328     final void setIndices(final int[] array) {
329         indices = array;
330     }
331 
332     /**
333      *
334      * @param array
335      * @since 6.0
336      */
337     final void setMatches(final int[] array) {
338         match = array;
339     }
340 
341     /**
342      *
343      * @param array
344      * @since 6.0
345      */
346     final void setTargets(final InstructionHandle[] array) {
347         targets = array;
348     }
349 
350     /**
351      *
352      * @return the padding
353      * @since 6.0
354      */
355     final int getPadding() {
356         return padding;
357     }
358 
<a name="36" id="anc36"></a><span class="line-modified">359 </span>
<span class="line-modified">360     /** @since 6.0 */</span>

361     final int setIndices(final int i, final int value) {
362         indices[i] = value;
363         return value;  // Allow use in nested calls
364     }
365 }
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>
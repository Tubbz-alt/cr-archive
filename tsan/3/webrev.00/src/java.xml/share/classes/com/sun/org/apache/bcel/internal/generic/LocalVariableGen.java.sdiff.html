<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoadInstruction.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LocalVariableInstruction.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import com.sun.org.apache.bcel.internal.Const;
 24 import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
 25 
 26 /**
<span class="line-modified"> 27  * This class represents a local variable within a method. It contains its</span>
<span class="line-modified"> 28  * scope, name and type. The generated LocalVariable object can be obtained with</span>
<span class="line-modified"> 29  * getLocalVariable which needs the instruction list and the constant pool as</span>
<span class="line-modified"> 30  * parameters.</span>
 31  *
<span class="line-modified"> 32  * @version $Id: LocalVariableGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
<span class="line-modified"> 33  * @see LocalVariable</span>
<span class="line-removed"> 34  * @see MethodGen</span>
 35  */
 36 public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Cloneable {
 37 
 38     private int index;
 39     private String name;
 40     private Type type;
 41     private InstructionHandle start;
 42     private InstructionHandle end;



 43 
 44     /**
<span class="line-modified"> 45      * Generate a local variable that with index `index&#39;. Note that double and</span>
<span class="line-modified"> 46      * long variables need two indexs. Index indices have to be provided by the</span>
<span class="line-removed"> 47      * user.</span>
 48      *
 49      * @param index index of local variable
 50      * @param name its name
 51      * @param type its type
<span class="line-modified"> 52      * @param start from where the instruction is valid (null means from the</span>
<span class="line-removed"> 53      * start)</span>
 54      * @param end until where the instruction is valid (null means to the end)
 55      */
<span class="line-modified"> 56     public LocalVariableGen(final int index, final String name, final Type type,</span>
<span class="line-modified"> 57             final InstructionHandle start, final InstructionHandle end) {</span>
 58         if ((index &lt; 0) || (index &gt; Const.MAX_SHORT)) {
 59             throw new ClassGenException(&quot;Invalid index index: &quot; + index);
 60         }
 61         this.name = name;
 62         this.type = type;
 63         this.index = index;
 64         setStart(start);
 65         setEnd(end);




















 66     }
 67 

 68     /**
<span class="line-modified"> 69      * Get LocalVariable object.</span>
 70      *
<span class="line-modified"> 71      * This relies on that the instruction list has already been dumped to byte</span>
<span class="line-modified"> 72      * code or or that the `setPositions&#39; methods has been called for the</span>
<span class="line-removed"> 73      * instruction list.</span>
 74      *
<span class="line-modified"> 75      * Note that for local variables whose scope end at the last instruction of</span>
<span class="line-modified"> 76      * the method&#39;s code, the JVM specification is ambiguous: both a</span>
<span class="line-modified"> 77      * start_pc+length ending at the last instruction and start_pc+length ending</span>
<span class="line-modified"> 78      * at first index beyond the end of the code are valid.</span>

 79      *
 80      * @param cp constant pool
 81      */
<span class="line-modified"> 82     public LocalVariable getLocalVariable(final ConstantPoolGen cp) {</span>
 83         int start_pc = 0;
 84         int length = 0;
 85         if ((start != null) &amp;&amp; (end != null)) {
 86             start_pc = start.getPosition();
 87             length = end.getPosition() - start_pc;
<span class="line-modified"> 88             if (end.getNext() == null) {</span>
 89                 length += end.getInstruction().getLength();
 90             }
 91         }
 92         final int name_index = cp.addUtf8(name);
 93         final int signature_index = cp.addUtf8(type.getSignature());
 94         return new LocalVariable(start_pc, length, name_index, signature_index, index, cp
<span class="line-modified"> 95                 .getConstantPool());</span>
 96     }
 97 
<span class="line-modified"> 98     public void setIndex(final int index) {</span>

 99         this.index = index;
100     }
101 

102     public int getIndex() {
103         return index;
104     }
105 
















106     @Override
<span class="line-modified">107     public void setName(final String name) {</span>
108         this.name = name;
109     }
110 

111     @Override
112     public String getName() {
113         return name;
114     }
115 

116     @Override
<span class="line-modified">117     public void setType(final Type type) {</span>
118         this.type = type;
119     }
120 

121     @Override
122     public Type getType() {
123         return type;
124     }
125 

126     public InstructionHandle getStart() {
127         return start;
128     }
129 

130     public InstructionHandle getEnd() {
131         return end;
132     }
133 
<span class="line-modified">134     public void setStart(final InstructionHandle start) { // TODO could be package-protected?</span>

135         BranchInstruction.notifyTarget(this.start, start, this);
136         this.start = start;
137     }
138 
<span class="line-modified">139     public void setEnd(final InstructionHandle end) { // TODO could be package-protected?</span>

140         BranchInstruction.notifyTarget(this.end, end, this);
141         this.end = end;
142     }
143 

144     /**
145      * @param old_ih old target, either start or end
146      * @param new_ih new target
147      */
148     @Override
<span class="line-modified">149     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {</span>
150         boolean targeted = false;
151         if (start == old_ih) {
152             targeted = true;
153             setStart(new_ih);
154         }
155         if (end == old_ih) {
156             targeted = true;
157             setEnd(new_ih);
158         }
159         if (!targeted) {
160             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but {&quot; + start + &quot;, &quot; + end
161                     + &quot;}&quot;);
162         }
163     }
164 
165     /**
166      * Clear the references from and to this variable when it&#39;s removed.
167      */
168     void dispose() {
169         setStart(null);
170         setEnd(null);
171     }
172 
173     /**
174      * @return true, if ih is target of this variable
175      */
176     @Override
<span class="line-modified">177     public boolean containsTarget(final InstructionHandle ih) {</span>
178         return (start == ih) || (end == ih);
179     }
180 

181     @Override
182     public int hashCode() {
183         // If the user changes the name or type, problems with the targeter hashmap will occur.
184         // Note: index cannot be part of hash as it may be changed by the user.
185         return name.hashCode() ^ type.hashCode();
186     }
187 

188     /**
189      * We consider to local variables to be equal, if the use the same index and
190      * are valid in the same range.
191      */
192     @Override
<span class="line-modified">193     public boolean equals(final Object o) {</span>
194         if (!(o instanceof LocalVariableGen)) {
195             return false;
196         }
197         final LocalVariableGen l = (LocalVariableGen) o;
198         return (l.index == index) &amp;&amp; (l.start == start) &amp;&amp; (l.end == end);
199     }
200 

201     @Override
202     public String toString() {
203         return &quot;LocalVariableGen(&quot; + name + &quot;, &quot; + type + &quot;, &quot; + start + &quot;, &quot; + end + &quot;)&quot;;
204     }
205 

206     @Override
207     public Object clone() {
208         try {
209             return super.clone();
210         } catch (final CloneNotSupportedException e) {
211             throw new Error(&quot;Clone Not Supported&quot;); // never happens
212         }
213     }
214 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import com.sun.org.apache.bcel.internal.Const;
 24 import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
 25 
 26 /**
<span class="line-modified"> 27  * Represents a local variable within a method. It contains its</span>
<span class="line-modified"> 28  * scope, name and type. The generated LocalVariable object can be obtained</span>
<span class="line-modified"> 29  * with getLocalVariable which needs the instruction list and the constant</span>
<span class="line-modified"> 30  * pool as parameters.</span>
 31  *
<span class="line-modified"> 32  * @see     LocalVariable</span>
<span class="line-modified"> 33  * @see     MethodGen</span>

 34  */
 35 public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Cloneable {
 36 
 37     private int index;
 38     private String name;
 39     private Type type;
 40     private InstructionHandle start;
 41     private InstructionHandle end;
<span class="line-added"> 42     private int orig_index; // never changes; used to match up with LocalVariableTypeTable entries</span>
<span class="line-added"> 43     private boolean live_to_end;</span>
<span class="line-added"> 44 </span>
 45 
 46     /**
<span class="line-modified"> 47      * Generate a local variable that with index `index&#39;. Note that double and long</span>
<span class="line-modified"> 48      * variables need two indexs. Index indices have to be provided by the user.</span>

 49      *
 50      * @param index index of local variable
 51      * @param name its name
 52      * @param type its type
<span class="line-modified"> 53      * @param start from where the instruction is valid (null means from the start)</span>

 54      * @param end until where the instruction is valid (null means to the end)
 55      */
<span class="line-modified"> 56     public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,</span>
<span class="line-modified"> 57             final InstructionHandle end) {</span>
 58         if ((index &lt; 0) || (index &gt; Const.MAX_SHORT)) {
 59             throw new ClassGenException(&quot;Invalid index index: &quot; + index);
 60         }
 61         this.name = name;
 62         this.type = type;
 63         this.index = index;
 64         setStart(start);
 65         setEnd(end);
<span class="line-added"> 66         this.orig_index = index;</span>
<span class="line-added"> 67         this.live_to_end = end == null;</span>
<span class="line-added"> 68     }</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71     /**</span>
<span class="line-added"> 72      * Generates a local variable that with index `index&#39;. Note that double and long</span>
<span class="line-added"> 73      * variables need two indexs. Index indices have to be provided by the user.</span>
<span class="line-added"> 74      *</span>
<span class="line-added"> 75      * @param index index of local variable</span>
<span class="line-added"> 76      * @param name its name</span>
<span class="line-added"> 77      * @param type its type</span>
<span class="line-added"> 78      * @param start from where the instruction is valid (null means from the start)</span>
<span class="line-added"> 79      * @param end until where the instruction is valid (null means to the end)</span>
<span class="line-added"> 80      * @param orig_index index of local variable prior to any changes to index</span>
<span class="line-added"> 81      */</span>
<span class="line-added"> 82     public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,</span>
<span class="line-added"> 83             final InstructionHandle end, final int orig_index) {</span>
<span class="line-added"> 84         this(index, name, type, start, end);</span>
<span class="line-added"> 85         this.orig_index = orig_index;</span>
 86     }
 87 
<span class="line-added"> 88 </span>
 89     /**
<span class="line-modified"> 90      * Gets LocalVariable object.</span>
 91      *
<span class="line-modified"> 92      * This relies on that the instruction list has already been dumped to byte code or</span>
<span class="line-modified"> 93      * or that the `setPositions&#39; methods has been called for the instruction list.</span>

 94      *
<span class="line-modified"> 95      * Note that due to the conversion from byte code offset to InstructionHandle,</span>
<span class="line-modified"> 96      * it is impossible to tell the difference between a live range that ends BEFORE</span>
<span class="line-modified"> 97      * the last insturction of the method or a live range that ends AFTER the last</span>
<span class="line-modified"> 98      * instruction of the method.  Hence the live_to_end flag to differentiate</span>
<span class="line-added"> 99      * between these two cases.</span>
100      *
101      * @param cp constant pool
102      */
<span class="line-modified">103     public LocalVariable getLocalVariable( final ConstantPoolGen cp ) {</span>
104         int start_pc = 0;
105         int length = 0;
106         if ((start != null) &amp;&amp; (end != null)) {
107             start_pc = start.getPosition();
108             length = end.getPosition() - start_pc;
<span class="line-modified">109             if ((end.getNext() == null) &amp;&amp; live_to_end) {</span>
110                 length += end.getInstruction().getLength();
111             }
112         }
113         final int name_index = cp.addUtf8(name);
114         final int signature_index = cp.addUtf8(type.getSignature());
115         return new LocalVariable(start_pc, length, name_index, signature_index, index, cp
<span class="line-modified">116                 .getConstantPool(), orig_index);</span>
117     }
118 
<span class="line-modified">119 </span>
<span class="line-added">120     public void setIndex( final int index ) {</span>
121         this.index = index;
122     }
123 
<span class="line-added">124 </span>
125     public int getIndex() {
126         return index;
127     }
128 
<span class="line-added">129 </span>
<span class="line-added">130     public int getOrigIndex() {</span>
<span class="line-added">131         return orig_index;</span>
<span class="line-added">132     }</span>
<span class="line-added">133 </span>
<span class="line-added">134 </span>
<span class="line-added">135     public void setLiveToEnd( final boolean live_to_end) {</span>
<span class="line-added">136         this.live_to_end = live_to_end;</span>
<span class="line-added">137     }</span>
<span class="line-added">138 </span>
<span class="line-added">139 </span>
<span class="line-added">140     public boolean getLiveToEnd() {</span>
<span class="line-added">141         return live_to_end;</span>
<span class="line-added">142     }</span>
<span class="line-added">143 </span>
<span class="line-added">144 </span>
145     @Override
<span class="line-modified">146     public void setName( final String name ) {</span>
147         this.name = name;
148     }
149 
<span class="line-added">150 </span>
151     @Override
152     public String getName() {
153         return name;
154     }
155 
<span class="line-added">156 </span>
157     @Override
<span class="line-modified">158     public void setType( final Type type ) {</span>
159         this.type = type;
160     }
161 
<span class="line-added">162 </span>
163     @Override
164     public Type getType() {
165         return type;
166     }
167 
<span class="line-added">168 </span>
169     public InstructionHandle getStart() {
170         return start;
171     }
172 
<span class="line-added">173 </span>
174     public InstructionHandle getEnd() {
175         return end;
176     }
177 
<span class="line-modified">178 </span>
<span class="line-added">179     public void setStart( final InstructionHandle start ) { // TODO could be package-protected?</span>
180         BranchInstruction.notifyTarget(this.start, start, this);
181         this.start = start;
182     }
183 
<span class="line-modified">184 </span>
<span class="line-added">185     public void setEnd( final InstructionHandle end ) { // TODO could be package-protected?</span>
186         BranchInstruction.notifyTarget(this.end, end, this);
187         this.end = end;
188     }
189 
<span class="line-added">190 </span>
191     /**
192      * @param old_ih old target, either start or end
193      * @param new_ih new target
194      */
195     @Override
<span class="line-modified">196     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
197         boolean targeted = false;
198         if (start == old_ih) {
199             targeted = true;
200             setStart(new_ih);
201         }
202         if (end == old_ih) {
203             targeted = true;
204             setEnd(new_ih);
205         }
206         if (!targeted) {
207             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but {&quot; + start + &quot;, &quot; + end
208                     + &quot;}&quot;);
209         }
210     }
211 
212     /**
213      * Clear the references from and to this variable when it&#39;s removed.
214      */
215     void dispose() {
216         setStart(null);
217         setEnd(null);
218     }
219 
220     /**
221      * @return true, if ih is target of this variable
222      */
223     @Override
<span class="line-modified">224     public boolean containsTarget( final InstructionHandle ih ) {</span>
225         return (start == ih) || (end == ih);
226     }
227 
<span class="line-added">228 </span>
229     @Override
230     public int hashCode() {
231         // If the user changes the name or type, problems with the targeter hashmap will occur.
232         // Note: index cannot be part of hash as it may be changed by the user.
233         return name.hashCode() ^ type.hashCode();
234     }
235 
<span class="line-added">236 </span>
237     /**
238      * We consider to local variables to be equal, if the use the same index and
239      * are valid in the same range.
240      */
241     @Override
<span class="line-modified">242     public boolean equals( final Object o ) {</span>
243         if (!(o instanceof LocalVariableGen)) {
244             return false;
245         }
246         final LocalVariableGen l = (LocalVariableGen) o;
247         return (l.index == index) &amp;&amp; (l.start == start) &amp;&amp; (l.end == end);
248     }
249 
<span class="line-added">250 </span>
251     @Override
252     public String toString() {
253         return &quot;LocalVariableGen(&quot; + name + &quot;, &quot; + type + &quot;, &quot; + start + &quot;, &quot; + end + &quot;)&quot;;
254     }
255 
<span class="line-added">256 </span>
257     @Override
258     public Object clone() {
259         try {
260             return super.clone();
261         } catch (final CloneNotSupportedException e) {
262             throw new Error(&quot;Clone Not Supported&quot;); // never happens
263         }
264     }
265 }
</pre>
</td>
</tr>
</table>
<center><a href="LoadInstruction.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LocalVariableInstruction.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
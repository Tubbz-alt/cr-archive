<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ParentNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 import java.io.Serializable;
  24 import java.io.IOException;
  25 import java.io.ObjectInputStream;
  26 import java.io.ObjectOutputStream;
  27 
  28 import org.w3c.dom.DOMException;
  29 import org.w3c.dom.Document;
  30 import org.w3c.dom.Node;
  31 import org.w3c.dom.NodeList;
  32 import org.w3c.dom.UserDataHandler;
  33 
  34 /**
  35  * ParentNode inherits from ChildNode and adds the capability of having child
  36  * nodes. Not every node in the DOM can have children, so only nodes that can
  37  * should inherit from this class and pay the price for it.
  38  * &lt;P&gt;
  39  * ParentNode, just like NodeImpl, also implements NodeList, so it can
  40  * return itself in response to the getChildNodes() query. This eliminiates
  41  * the need for a separate ChildNodeList object. Note that this is an
  42  * IMPLEMENTATION DETAIL; applications should _never_ assume that
  43  * this identity exists. On the other hand, subclasses may need to override
  44  * this, in case of conflicting names. This is the case for the classes
  45  * HTMLSelectElementImpl and HTMLFormElementImpl of the HTML DOM.
  46  * &lt;P&gt;
  47  * While we have a direct reference to the first child, the last child is
  48  * stored as the previous sibling of the first child. First child nodes are
  49  * marked as being so, and getNextSibling hides this fact.
  50  * &lt;P&gt;Note: Not all parent nodes actually need to also be a child. At some
  51  * point we used to have ParentNode inheriting from NodeImpl and another class
  52  * called ChildAndParentNode that inherited from ChildNode. But due to the lack
  53  * of multiple inheritance a lot of code had to be duplicated which led to a
  54  * maintenance nightmare. At the same time only a few nodes (Document,
  55  * DocumentFragment, Entity, and Attribute) cannot be a child so the gain in
  56  * memory wasn&#39;t really worth it. The only type for which this would be the
  57  * case is Attribute, but we deal with there in another special way, so this is
  58  * not applicable.
  59  * &lt;p&gt;
  60  * This class doesn&#39;t directly support mutation events, however, it notifies
  61  * the document when mutations are performed so that the document class do so.
  62  *
  63  * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: Some of the code here is partially duplicated in
  64  * AttrImpl, be careful to keep these two classes in sync!
  65  *
  66  * @xerces.internal
  67  *
  68  * @author Arnaud  Le Hors, IBM
  69  * @author Joe Kesselman, IBM
  70  * @author Andy Clark, IBM
<a name="2" id="anc2"></a><span class="line-added">  71  * @LastModified: Apr 2019</span>
  72  */
  73 public abstract class ParentNode
  74     extends ChildNode {
  75 
  76     /** Serialization version. */
  77     static final long serialVersionUID = 2815829867152120872L;
  78 
  79     /** Owner document. */
  80     protected CoreDocumentImpl ownerDocument;
  81 
  82     /** First child. */
  83     protected ChildNode firstChild = null;
  84 
  85     // transients
  86 
  87     /** NodeList cache */
  88     protected transient NodeListCache fNodeListCache = null;
  89 
  90     //
  91     // Constructors
  92     //
  93 
  94     /**
  95      * No public constructor; only subclasses of ParentNode should be
  96      * instantiated, and those normally via a Document&#39;s factory methods
  97      */
  98     protected ParentNode(CoreDocumentImpl ownerDocument) {
  99         super(ownerDocument);
 100         this.ownerDocument = ownerDocument;
 101     }
 102 
 103     /** Constructor for serialization. */
 104     public ParentNode() {}
 105 
 106     //
 107     // NodeList methods
 108     //
 109 
 110     /**
 111      * Returns a duplicate of a given node. You can consider this a
 112      * generic &quot;copy constructor&quot; for nodes. The newly returned object should
 113      * be completely independent of the source object&#39;s subtree, so changes
 114      * in one after the clone has been made will not affect the other.
 115      * &lt;p&gt;
 116      * Example: Cloning a Text node will copy both the node and the text it
 117      * contains.
 118      * &lt;p&gt;
 119      * Example: Cloning something that has children -- Element or Attr, for
 120      * example -- will _not_ clone those children unless a &quot;deep clone&quot;
 121      * has been requested. A shallow clone of an Attr node will yield an
 122      * empty Attr of the same name.
 123      * &lt;p&gt;
 124      * NOTE: Clones will always be read/write, even if the node being cloned
 125      * is read-only, to permit applications using only the DOM API to obtain
 126      * editable copies of locked portions of the tree.
 127      */
 128     public Node cloneNode(boolean deep) {
 129 
 130         if (needsSyncChildren()) {
 131             synchronizeChildren();
 132         }
 133         ParentNode newnode = (ParentNode) super.cloneNode(deep);
 134 
 135         // set owner document
 136         newnode.ownerDocument = ownerDocument;
 137 
 138         // Need to break the association w/ original kids
 139         newnode.firstChild      = null;
 140 
 141         // invalidate cache for children NodeList
 142         newnode.fNodeListCache = null;
 143 
 144         // Then, if deep, clone the kids too.
 145         if (deep) {
 146             for (ChildNode child = firstChild;
 147                  child != null;
 148                  child = child.nextSibling) {
 149                 newnode.appendChild(child.cloneNode(true));
 150             }
 151         }
 152 
 153         return newnode;
 154 
 155     } // cloneNode(boolean):Node
 156 
 157     /**
 158      * Find the Document that this Node belongs to (the document in
 159      * whose context the Node was created). The Node may or may not
 160      * currently be part of that Document&#39;s actual contents.
 161      */
 162     public Document getOwnerDocument() {
 163         return ownerDocument;
 164     }
 165 
 166     /**
 167      * same as above but returns internal type and this one is not overridden
 168      * by CoreDocumentImpl to return null
 169      */
 170     CoreDocumentImpl ownerDocument() {
 171         return ownerDocument;
 172     }
 173 
 174     /**
 175      * NON-DOM
 176      * set the ownerDocument of this node and its children
 177      */
<a name="3" id="anc3"></a><span class="line-modified"> 178     protected void setOwnerDocument(CoreDocumentImpl doc) {</span>
 179         if (needsSyncChildren()) {
 180             synchronizeChildren();
 181         }
<a name="4" id="anc4"></a>





 182         super.setOwnerDocument(doc);
 183         ownerDocument = doc;
<a name="5" id="anc5"></a><span class="line-added"> 184         for (ChildNode child = firstChild;</span>
<span class="line-added"> 185         child != null; child = child.nextSibling) {</span>
<span class="line-added"> 186             child.setOwnerDocument(doc);</span>
<span class="line-added"> 187         }</span>
 188     }
 189 
 190     /**
 191      * Test whether this node has any children. Convenience shorthand
 192      * for (Node.getFirstChild()!=null)
 193      */
 194     public boolean hasChildNodes() {
 195         if (needsSyncChildren()) {
 196             synchronizeChildren();
 197         }
 198         return firstChild != null;
 199     }
 200 
 201     /**
 202      * Obtain a NodeList enumerating all children of this node. If there
 203      * are none, an (initially) empty NodeList is returned.
 204      * &lt;p&gt;
 205      * NodeLists are &quot;live&quot;; as children are added/removed the NodeList
 206      * will immediately reflect those changes. Also, the NodeList refers
 207      * to the actual nodes, so changes to those nodes made via the DOM tree
 208      * will be reflected in the NodeList and vice versa.
 209      * &lt;p&gt;
 210      * In this implementation, Nodes implement the NodeList interface and
 211      * provide their own getChildNodes() support. Other DOMs may solve this
 212      * differently.
 213      */
 214     public NodeList getChildNodes() {
 215 
 216         if (needsSyncChildren()) {
 217             synchronizeChildren();
 218         }
 219         return this;
 220 
 221     } // getChildNodes():NodeList
 222 
 223     /** The first child of this Node, or null if none. */
 224     public Node getFirstChild() {
 225 
 226         if (needsSyncChildren()) {
 227             synchronizeChildren();
 228         }
 229         return firstChild;
 230 
 231     }   // getFirstChild():Node
 232 
 233     /** The last child of this Node, or null if none. */
 234     public Node getLastChild() {
 235 
 236         if (needsSyncChildren()) {
 237             synchronizeChildren();
 238         }
 239         return lastChild();
 240 
 241     } // getLastChild():Node
 242 
 243     final ChildNode lastChild() {
 244         // last child is stored as the previous sibling of first child
 245         return firstChild != null ? firstChild.previousSibling : null;
 246     }
 247 
 248     final void lastChild(ChildNode node) {
 249         // store lastChild as previous sibling of first child
 250         if (firstChild != null) {
 251             firstChild.previousSibling = node;
 252         }
 253     }
 254 
 255     /**
 256      * Move one or more node(s) to our list of children. Note that this
 257      * implicitly removes them from their previous parent.
 258      *
 259      * @param newChild The Node to be moved to our subtree. As a
 260      * convenience feature, inserting a DocumentNode will instead insert
 261      * all its children.
 262      *
 263      * @param refChild Current child which newChild should be placed
 264      * immediately before. If refChild is null, the insertion occurs
 265      * after all existing Nodes, like appendChild().
 266      *
 267      * @return newChild, in its new state (relocated, or emptied in the case of
 268      * DocumentNode.)
 269      *
 270      * @throws DOMException(HIERARCHY_REQUEST_ERR) if newChild is of a
 271      * type that shouldn&#39;t be a child of this node, or if newChild is an
 272      * ancestor of this node.
 273      *
 274      * @throws DOMException(WRONG_DOCUMENT_ERR) if newChild has a
 275      * different owner document than we do.
 276      *
 277      * @throws DOMException(NOT_FOUND_ERR) if refChild is not a child of
 278      * this node.
 279      *
 280      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if this node is
 281      * read-only.
 282      */
 283     public Node insertBefore(Node newChild, Node refChild)
 284         throws DOMException {
 285         // Tail-call; optimizer should be able to do good things with.
 286         return internalInsertBefore(newChild, refChild, false);
 287     } // insertBefore(Node,Node):Node
 288 
 289     /** NON-DOM INTERNAL: Within DOM actions,we sometimes need to be able
 290      * to control which mutation events are spawned. This version of the
 291      * insertBefore operation allows us to do so. It is not intended
 292      * for use by application programs.
 293      */
 294     Node internalInsertBefore(Node newChild, Node refChild, boolean replace)
 295         throws DOMException {
 296 
 297         boolean errorChecking = ownerDocument.errorChecking;
 298 
 299         if (newChild.getNodeType() == Node.DOCUMENT_FRAGMENT_NODE) {
 300             // SLOW BUT SAFE: We could insert the whole subtree without
 301             // juggling so many next/previous pointers. (Wipe out the
 302             // parent&#39;s child-list, patch the parent pointers, set the
 303             // ends of the list.) But we know some subclasses have special-
 304             // case behavior they add to insertBefore(), so we don&#39;t risk it.
 305             // This approch also takes fewer bytecodes.
 306 
 307             // NOTE: If one of the children is not a legal child of this
 308             // node, throw HIERARCHY_REQUEST_ERR before _any_ of the children
 309             // have been transferred. (Alternative behaviors would be to
 310             // reparent up to the first failure point or reparent all those
 311             // which are acceptable to the target node, neither of which is
 312             // as robust. PR-DOM-0818 isn&#39;t entirely clear on which it
 313             // recommends?????
 314 
 315             // No need to check kids for right-document; if they weren&#39;t,
 316             // they wouldn&#39;t be kids of that DocFrag.
 317             if (errorChecking) {
 318                 for (Node kid = newChild.getFirstChild(); // Prescan
 319                      kid != null; kid = kid.getNextSibling()) {
 320 
 321                     if (!ownerDocument.isKidOK(this, kid)) {
 322                         throw new DOMException(
 323                               DOMException.HIERARCHY_REQUEST_ERR,
 324                               DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null));
 325                     }
 326                 }
 327             }
 328 
 329             while (newChild.hasChildNodes()) {
 330                 insertBefore(newChild.getFirstChild(), refChild);
 331             }
 332             return newChild;
 333         }
 334 
 335         if (newChild == refChild) {
 336             // stupid case that must be handled as a no-op triggering events...
 337             refChild = refChild.getNextSibling();
 338             removeChild(newChild);
 339             insertBefore(newChild, refChild);
 340             return newChild;
 341         }
 342 
 343         if (needsSyncChildren()) {
 344             synchronizeChildren();
 345         }
 346 
 347         if (errorChecking) {
 348             if (isReadOnly()) {
 349                 throw new DOMException(
 350                               DOMException.NO_MODIFICATION_ALLOWED_ERR,
 351                               DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null));
 352             }
 353             if (newChild.getOwnerDocument() != ownerDocument &amp;&amp; newChild != ownerDocument) {
 354                 throw new DOMException(DOMException.WRONG_DOCUMENT_ERR,
 355                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;WRONG_DOCUMENT_ERR&quot;, null));
 356             }
 357             if (!ownerDocument.isKidOK(this, newChild)) {
 358                 throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,
 359                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null));
 360             }
 361             // refChild must be a child of this node (or null)
 362             if (refChild != null &amp;&amp; refChild.getParentNode() != this) {
 363                 throw new DOMException(DOMException.NOT_FOUND_ERR,
 364                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null));
 365             }
 366 
 367             // Prevent cycles in the tree
 368             // newChild cannot be ancestor of this Node,
 369             // and actually cannot be this
<a name="6" id="anc6"></a><span class="line-modified"> 370             boolean treeSafe = true;</span>
<span class="line-modified"> 371             for (NodeImpl a = this; treeSafe &amp;&amp; a != null; a = a.parentNode())</span>
<span class="line-modified"> 372             {</span>
<span class="line-modified"> 373                 treeSafe = newChild != a;</span>
<span class="line-modified"> 374             }</span>
<span class="line-modified"> 375             if(!treeSafe) {</span>
<span class="line-modified"> 376                 throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,</span>
<span class="line-modified"> 377                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null));</span>


 378             }
 379         }
 380 
 381         // notify document
 382         ownerDocument.insertingNode(this, replace);
 383 
 384         // Convert to internal type, to avoid repeated casting
 385         ChildNode newInternal = (ChildNode)newChild;
 386 
 387         Node oldparent = newInternal.parentNode();
 388         if (oldparent != null) {
 389             oldparent.removeChild(newInternal);
 390         }
 391 
 392         // Convert to internal type, to avoid repeated casting
 393         ChildNode refInternal = (ChildNode)refChild;
 394 
 395         // Attach up
 396         newInternal.ownerNode = this;
 397         newInternal.isOwned(true);
 398 
 399         // Attach before and after
 400         // Note: firstChild.previousSibling == lastChild!!
 401         if (firstChild == null) {
 402             // this our first and only child
 403             firstChild = newInternal;
 404             newInternal.isFirstChild(true);
 405             newInternal.previousSibling = newInternal;
 406         }
 407         else {
 408             if (refInternal == null) {
 409                 // this is an append
 410                 ChildNode lastChild = firstChild.previousSibling;
 411                 lastChild.nextSibling = newInternal;
 412                 newInternal.previousSibling = lastChild;
 413                 firstChild.previousSibling = newInternal;
 414             }
 415             else {
 416                 // this is an insert
 417                 if (refChild == firstChild) {
 418                     // at the head of the list
 419                     firstChild.isFirstChild(false);
 420                     newInternal.nextSibling = firstChild;
 421                     newInternal.previousSibling = firstChild.previousSibling;
 422                     firstChild.previousSibling = newInternal;
 423                     firstChild = newInternal;
 424                     newInternal.isFirstChild(true);
 425                 }
 426                 else {
 427                     // somewhere in the middle
 428                     ChildNode prev = refInternal.previousSibling;
 429                     newInternal.nextSibling = refInternal;
 430                     prev.nextSibling = newInternal;
 431                     refInternal.previousSibling = newInternal;
 432                     newInternal.previousSibling = prev;
 433                 }
 434             }
 435         }
 436 
 437         changed();
 438 
 439         // update cached length if we have any
 440         if (fNodeListCache != null) {
 441             if (fNodeListCache.fLength != -1) {
 442                 fNodeListCache.fLength++;
 443             }
 444             if (fNodeListCache.fChildIndex != -1) {
 445                 // if we happen to insert just before the cached node, update
 446                 // the cache to the new node to match the cached index
 447                 if (fNodeListCache.fChild == refInternal) {
 448                     fNodeListCache.fChild = newInternal;
 449                 } else {
 450                     // otherwise just invalidate the cache
 451                     fNodeListCache.fChildIndex = -1;
 452                 }
 453             }
 454         }
 455 
 456         // notify document
 457         ownerDocument.insertedNode(this, newInternal, replace);
 458 
 459         checkNormalizationAfterInsert(newInternal);
 460 
 461         return newChild;
 462 
 463     } // internalInsertBefore(Node,Node,boolean):Node
 464 
 465     /**
 466      * Remove a child from this Node. The removed child&#39;s subtree
 467      * remains intact so it may be re-inserted elsewhere.
 468      *
 469      * @return oldChild, in its new state (removed).
 470      *
 471      * @throws DOMException(NOT_FOUND_ERR) if oldChild is not a child of
 472      * this node.
 473      *
 474      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if this node is
 475      * read-only.
 476      */
 477     public Node removeChild(Node oldChild)
 478         throws DOMException {
 479         // Tail-call, should be optimizable
 480         return internalRemoveChild(oldChild, false);
 481     } // removeChild(Node) :Node
 482 
 483     /** NON-DOM INTERNAL: Within DOM actions,we sometimes need to be able
 484      * to control which mutation events are spawned. This version of the
 485      * removeChild operation allows us to do so. It is not intended
 486      * for use by application programs.
 487      */
 488     Node internalRemoveChild(Node oldChild, boolean replace)
 489         throws DOMException {
 490 
 491         CoreDocumentImpl ownerDocument = ownerDocument();
 492         if (ownerDocument.errorChecking) {
 493             if (isReadOnly()) {
 494                 throw new DOMException(
 495                             DOMException.NO_MODIFICATION_ALLOWED_ERR,
 496                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null));
 497             }
 498             if (oldChild != null &amp;&amp; oldChild.getParentNode() != this) {
 499                 throw new DOMException(DOMException.NOT_FOUND_ERR,
 500                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null));
 501             }
 502         }
 503 
 504         ChildNode oldInternal = (ChildNode) oldChild;
 505 
 506         // notify document
 507         ownerDocument.removingNode(this, oldInternal, replace);
 508 
<a name="7" id="anc7"></a><span class="line-added"> 509         // Save previous sibling for normalization checking.</span>
<span class="line-added"> 510         final ChildNode oldPreviousSibling = oldInternal.previousSibling();</span>
<span class="line-added"> 511 </span>
 512         // update cached length if we have any
 513         if (fNodeListCache != null) {
 514             if (fNodeListCache.fLength != -1) {
 515                 fNodeListCache.fLength--;
 516             }
 517             if (fNodeListCache.fChildIndex != -1) {
 518                 // if the removed node is the cached node
 519                 // move the cache to its (soon former) previous sibling
 520                 if (fNodeListCache.fChild == oldInternal) {
 521                     fNodeListCache.fChildIndex--;
<a name="8" id="anc8"></a><span class="line-modified"> 522                     fNodeListCache.fChild = oldPreviousSibling;</span>
 523                 } else {
 524                     // otherwise just invalidate the cache
 525                     fNodeListCache.fChildIndex = -1;
 526                 }
 527             }
 528         }
 529 
 530         // Patch linked list around oldChild
 531         // Note: lastChild == firstChild.previousSibling
 532         if (oldInternal == firstChild) {
 533             // removing first child
 534             oldInternal.isFirstChild(false);
 535             firstChild = oldInternal.nextSibling;
 536             if (firstChild != null) {
 537                 firstChild.isFirstChild(true);
 538                 firstChild.previousSibling = oldInternal.previousSibling;
 539             }
 540         } else {
 541             ChildNode prev = oldInternal.previousSibling;
 542             ChildNode next = oldInternal.nextSibling;
 543             prev.nextSibling = next;
 544             if (next == null) {
 545                 // removing last child
 546                 firstChild.previousSibling = prev;
 547             } else {
 548                 // removing some other child in the middle
 549                 next.previousSibling = prev;
 550             }
 551         }
 552 
<a name="9" id="anc9"></a>


 553         // Remove oldInternal&#39;s references to tree
 554         oldInternal.ownerNode       = ownerDocument;
 555         oldInternal.isOwned(false);
 556         oldInternal.nextSibling     = null;
 557         oldInternal.previousSibling = null;
 558 
 559         changed();
 560 
 561         // notify document
 562         ownerDocument.removedNode(this, replace);
 563 
 564         checkNormalizationAfterRemove(oldPreviousSibling);
 565 
 566         return oldInternal;
 567 
 568     } // internalRemoveChild(Node,boolean):Node
 569 
 570     /**
 571      * Make newChild occupy the location that oldChild used to
 572      * have. Note that newChild will first be removed from its previous
 573      * parent, if any. Equivalent to inserting newChild before oldChild,
 574      * then removing oldChild.
 575      *
 576      * @return oldChild, in its new state (removed).
 577      *
 578      * @throws DOMException(HIERARCHY_REQUEST_ERR) if newChild is of a
 579      * type that shouldn&#39;t be a child of this node, or if newChild is
 580      * one of our ancestors.
 581      *
 582      * @throws DOMException(WRONG_DOCUMENT_ERR) if newChild has a
 583      * different owner document than we do.
 584      *
 585      * @throws DOMException(NOT_FOUND_ERR) if oldChild is not a child of
 586      * this node.
 587      *
 588      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if this node is
 589      * read-only.
 590      */
 591     public Node replaceChild(Node newChild, Node oldChild)
 592         throws DOMException {
 593         // If Mutation Events are being generated, this operation might
 594         // throw aggregate events twice when modifying an Attr -- once
 595         // on insertion and once on removal. DOM Level 2 does not specify
 596         // this as either desirable or undesirable, but hints that
 597         // aggregations should be issued only once per user request.
 598 
 599         // notify document
 600         ownerDocument.replacingNode(this);
 601 
 602         internalInsertBefore(newChild, oldChild, true);
 603         if (newChild != oldChild) {
 604             internalRemoveChild(oldChild, true);
 605         }
 606 
 607         // notify document
 608         ownerDocument.replacedNode(this);
 609 
 610         return oldChild;
 611     }
 612 
 613     /*
 614      * Get Node text content
 615      * @since DOM Level 3
 616      */
 617     public String getTextContent() throws DOMException {
 618         Node child = getFirstChild();
 619         if (child != null) {
 620             Node next = child.getNextSibling();
 621             if (next == null) {
 622                 return hasTextContent(child) ? ((NodeImpl) child).getTextContent() : &quot;&quot;;
 623             }
<a name="10" id="anc10"></a><span class="line-modified"> 624             StringBuilder buf = new StringBuilder();</span>
<span class="line-modified"> 625             getTextContent(buf);</span>
<span class="line-modified"> 626             return buf.toString();</span>





 627         }
 628         return &quot;&quot;;
 629     }
 630 
<a name="11" id="anc11"></a><span class="line-modified"> 631     // internal method taking a StringBuilder in parameter</span>
<span class="line-modified"> 632     void getTextContent(StringBuilder buf) throws DOMException {</span>
 633         Node child = getFirstChild();
 634         while (child != null) {
 635             if (hasTextContent(child)) {
 636                 ((NodeImpl) child).getTextContent(buf);
 637             }
 638             child = child.getNextSibling();
 639         }
 640     }
 641 
 642     // internal method returning whether to take the given node&#39;s text content
 643     final boolean hasTextContent(Node child) {
 644         return child.getNodeType() != Node.COMMENT_NODE &amp;&amp;
 645             child.getNodeType() != Node.PROCESSING_INSTRUCTION_NODE &amp;&amp;
 646             (child.getNodeType() != Node.TEXT_NODE ||
 647              ((TextImpl) child).isIgnorableWhitespace() == false);
 648     }
 649 
 650     /*
 651      * Set Node text content
 652      * @since DOM Level 3
 653      */
 654     public void setTextContent(String textContent)
 655         throws DOMException {
 656         // get rid of any existing children
 657         Node child;
 658         while ((child = getFirstChild()) != null) {
 659             removeChild(child);
 660         }
 661         // create a Text node to hold the given content
 662         if (textContent != null &amp;&amp; textContent.length() != 0){
 663             appendChild(ownerDocument().createTextNode(textContent));
 664         }
 665     }
 666 
 667     //
 668     // NodeList methods
 669     //
 670 
 671     /**
 672      * Count the immediate children of this node.  Use to implement
 673      * NodeList.getLength().
 674      * @return int
 675      */
 676     private int nodeListGetLength() {
 677 
 678         if (fNodeListCache == null) {
<a name="12" id="anc12"></a><span class="line-added"> 679             if (needsSyncChildren()) {</span>
<span class="line-added"> 680                 synchronizeChildren();</span>
<span class="line-added"> 681             }</span>
 682             // get rid of trivial cases
 683             if (firstChild == null) {
 684                 return 0;
 685             }
 686             if (firstChild == lastChild()) {
 687                 return 1;
 688             }
 689             // otherwise request a cache object
 690             fNodeListCache = ownerDocument.getNodeListCache(this);
 691         }
 692         if (fNodeListCache.fLength == -1) { // is the cached length invalid ?
 693             int l;
 694             ChildNode n;
 695             // start from the cached node if we have one
 696             if (fNodeListCache.fChildIndex != -1 &amp;&amp;
 697                 fNodeListCache.fChild != null) {
 698                 l = fNodeListCache.fChildIndex;
 699                 n = fNodeListCache.fChild;
 700             } else {
 701                 n = firstChild;
 702                 l = 0;
 703             }
 704             while (n != null) {
 705                 l++;
 706                 n = n.nextSibling;
 707             }
 708             fNodeListCache.fLength = l;
 709         }
 710 
 711         return fNodeListCache.fLength;
 712 
 713     } // nodeListGetLength():int
 714 
 715     /**
 716      * NodeList method: Count the immediate children of this node
 717      * @return int
 718      */
 719     public int getLength() {
 720         return nodeListGetLength();
 721     }
 722 
 723     /**
 724      * Return the Nth immediate child of this node, or null if the index is
 725      * out of bounds.  Use to implement NodeList.item().
 726      * @param index int
 727      */
 728     private Node nodeListItem(int index) {
 729 
 730         if (fNodeListCache == null) {
<a name="13" id="anc13"></a><span class="line-added"> 731             if (needsSyncChildren()) {</span>
<span class="line-added"> 732                 synchronizeChildren();</span>
<span class="line-added"> 733             }</span>
 734             // get rid of trivial case
 735             if (firstChild == lastChild()) {
 736                 return index == 0 ? firstChild : null;
 737             }
 738             // otherwise request a cache object
 739             fNodeListCache = ownerDocument.getNodeListCache(this);
 740         }
 741         int i = fNodeListCache.fChildIndex;
 742         ChildNode n = fNodeListCache.fChild;
 743         boolean firstAccess = true;
 744         // short way
 745         if (i != -1 &amp;&amp; n != null) {
 746             firstAccess = false;
 747             if (i &lt; index) {
 748                 while (i &lt; index &amp;&amp; n != null) {
 749                     i++;
 750                     n = n.nextSibling;
 751                 }
 752             }
 753             else if (i &gt; index) {
 754                 while (i &gt; index &amp;&amp; n != null) {
 755                     i--;
 756                     n = n.previousSibling();
 757                 }
 758             }
 759         }
 760         else {
 761             // long way
 762             if (index &lt; 0) {
 763                 return null;
 764             }
 765             n = firstChild;
 766             for (i = 0; i &lt; index &amp;&amp; n != null; i++) {
 767                 n = n.nextSibling;
 768             }
 769         }
 770 
 771         // release cache if reaching last child or first child
 772         if (!firstAccess &amp;&amp; (n == firstChild || n == lastChild())) {
 773             fNodeListCache.fChildIndex = -1;
 774             fNodeListCache.fChild = null;
 775             ownerDocument.freeNodeListCache(fNodeListCache);
 776             // we can keep using the cache until it is actually reused
 777             // fNodeListCache will be nulled by the pool (document) if that
 778             // happens.
 779             // fNodeListCache = null;
 780         }
 781         else {
 782             // otherwise update it
 783             fNodeListCache.fChildIndex = i;
 784             fNodeListCache.fChild = n;
 785         }
 786         return n;
 787 
 788     } // nodeListItem(int):Node
 789 
 790     /**
 791      * NodeList method: Return the Nth immediate child of this node, or
 792      * null if the index is out of bounds.
 793      * @return org.w3c.dom.Node
 794      * @param index int
 795      */
 796     public Node item(int index) {
 797         return nodeListItem(index);
 798     } // item(int):Node
 799 
 800     /**
 801      * Create a NodeList to access children that is use by subclass elements
 802      * that have methods named getLength() or item(int).  ChildAndParentNode
 803      * optimizes getChildNodes() by implementing NodeList itself.  However if
 804      * a subclass Element implements methods with the same name as the NodeList
 805      * methods, they will override the actually methods in this class.
 806      * &lt;p&gt;
 807      * To use this method, the subclass should implement getChildNodes() and
 808      * have it call this method.  The resulting NodeList instance maybe
 809      * shared and cached in a transient field, but the cached value must be
 810      * cleared if the node is cloned.
 811      */
 812     protected final NodeList getChildNodesUnoptimized() {
 813         if (needsSyncChildren()) {
 814             synchronizeChildren();
 815         }
 816         return new NodeList() {
 817                 /**
 818                  * @see NodeList.getLength()
 819                  */
 820                 public int getLength() {
 821                     return nodeListGetLength();
 822                 } // getLength():int
 823 
 824                 /**
 825                  * @see NodeList.item(int)
 826                  */
 827                 public Node item(int index) {
 828                     return nodeListItem(index);
 829                 } // item(int):Node
 830             };
 831     } // getChildNodesUnoptimized():NodeList
 832 
 833     //
 834     // DOM2: methods, getters, setters
 835     //
 836 
 837     /**
 838      * Override default behavior to call normalize() on this Node&#39;s
 839      * children. It is up to implementors or Node to override normalize()
 840      * to take action.
 841      */
 842     public void normalize() {
 843         // No need to normalize if already normalized.
 844         if (isNormalized()) {
 845             return;
 846         }
 847         if (needsSyncChildren()) {
 848             synchronizeChildren();
 849         }
 850         ChildNode kid;
 851         for (kid = firstChild; kid != null; kid = kid.nextSibling) {
 852             kid.normalize();
 853         }
 854         isNormalized(true);
 855     }
 856 
 857     /**
 858      * DOM Level 3 WD- Experimental.
 859      * Override inherited behavior from NodeImpl to support deep equal.
 860      */
 861     public boolean isEqualNode(Node arg) {
 862         if (!super.isEqualNode(arg)) {
 863             return false;
 864         }
 865         // there are many ways to do this test, and there isn&#39;t any way
 866         // better than another. Performance may vary greatly depending on
 867         // the implementations involved. This one should work fine for us.
 868         Node child1 = getFirstChild();
 869         Node child2 = arg.getFirstChild();
 870         while (child1 != null &amp;&amp; child2 != null) {
<a name="14" id="anc14"></a><span class="line-modified"> 871             if (!child1.isEqualNode(child2)) {</span>
 872                 return false;
 873             }
 874             child1 = child1.getNextSibling();
 875             child2 = child2.getNextSibling();
 876         }
 877         if (child1 != child2) {
 878             return false;
 879         }
 880         return true;
 881     }
 882 
 883     //
 884     // Public methods
 885     //
 886 
 887     /**
 888      * Override default behavior so that if deep is true, children are also
 889      * toggled.
 890      * @see Node
 891      * &lt;P&gt;
 892      * Note: this will not change the state of an EntityReference or its
 893      * children, which are always read-only.
 894      */
 895     public void setReadOnly(boolean readOnly, boolean deep) {
 896 
 897         super.setReadOnly(readOnly, deep);
 898 
 899         if (deep) {
 900 
 901             if (needsSyncChildren()) {
 902                 synchronizeChildren();
 903             }
 904 
 905             // Recursively set kids
 906             for (ChildNode mykid = firstChild;
 907                  mykid != null;
 908                  mykid = mykid.nextSibling) {
 909                 if (mykid.getNodeType() != Node.ENTITY_REFERENCE_NODE) {
 910                     mykid.setReadOnly(readOnly,true);
 911                 }
 912             }
 913         }
 914     } // setReadOnly(boolean,boolean)
 915 
 916     //
 917     // Protected methods
 918     //
 919 
 920     /**
 921      * Override this method in subclass to hook in efficient
 922      * internal data structure.
 923      */
 924     protected void synchronizeChildren() {
 925         // By default just change the flag to avoid calling this method again
 926         needsSyncChildren(false);
 927     }
 928 
 929     /**
 930      * Checks the normalized state of this node after inserting a child.
 931      * If the inserted child causes this node to be unnormalized, then this
 932      * node is flagged accordingly.
 933      * The conditions for changing the normalized state are:
 934      * &lt;ul&gt;
 935      * &lt;li&gt;The inserted child is a text node and one of its adjacent siblings
 936      * is also a text node.
 937      * &lt;li&gt;The inserted child is is itself unnormalized.
 938      * &lt;/ul&gt;
 939      *
 940      * @param insertedChild the child node that was inserted into this node
 941      *
 942      * @throws NullPointerException if the inserted child is &lt;code&gt;null&lt;/code&gt;
 943      */
 944     void checkNormalizationAfterInsert(ChildNode insertedChild) {
 945         // See if insertion caused this node to be unnormalized.
 946         if (insertedChild.getNodeType() == Node.TEXT_NODE) {
 947             ChildNode prev = insertedChild.previousSibling();
 948             ChildNode next = insertedChild.nextSibling;
 949             // If an adjacent sibling of the new child is a text node,
 950             // flag this node as unnormalized.
 951             if ((prev != null &amp;&amp; prev.getNodeType() == Node.TEXT_NODE) ||
 952                 (next != null &amp;&amp; next.getNodeType() == Node.TEXT_NODE)) {
 953                 isNormalized(false);
 954             }
 955         }
 956         else {
 957             // If the new child is not normalized,
 958             // then this node is inherently not normalized.
 959             if (!insertedChild.isNormalized()) {
 960                 isNormalized(false);
 961             }
 962         }
 963     } // checkNormalizationAfterInsert(ChildNode)
 964 
 965     /**
 966      * Checks the normalized of this node after removing a child.
 967      * If the removed child causes this node to be unnormalized, then this
 968      * node is flagged accordingly.
 969      * The conditions for changing the normalized state are:
 970      * &lt;ul&gt;
 971      * &lt;li&gt;The removed child had two adjacent siblings that were text nodes.
 972      * &lt;/ul&gt;
 973      *
 974      * @param previousSibling the previous sibling of the removed child, or
 975      * &lt;code&gt;null&lt;/code&gt;
 976      */
 977     void checkNormalizationAfterRemove(ChildNode previousSibling) {
 978         // See if removal caused this node to be unnormalized.
 979         // If the adjacent siblings of the removed child were both text nodes,
 980         // flag this node as unnormalized.
 981         if (previousSibling != null &amp;&amp;
 982             previousSibling.getNodeType() == Node.TEXT_NODE) {
 983 
 984             ChildNode next = previousSibling.nextSibling;
 985             if (next != null &amp;&amp; next.getNodeType() == Node.TEXT_NODE) {
 986                 isNormalized(false);
 987             }
 988         }
 989     } // checkNormalizationAfterRemove(Node)
 990 
 991     //
 992     // Serialization methods
 993     //
 994 
 995     /** Serialize object. */
 996     private void writeObject(ObjectOutputStream out) throws IOException {
 997 
<a name="15" id="anc15"></a><span class="line-modified"> 998         // synchronize children</span>
 999         if (needsSyncChildren()) {
1000             synchronizeChildren();
1001         }
1002         // write object
1003         out.defaultWriteObject();
1004 
1005     } // writeObject(ObjectOutputStream)
1006 
1007     /** Deserialize object. */
1008     private void readObject(ObjectInputStream ois)
1009         throws ClassNotFoundException, IOException {
1010 
1011         // perform default deseralization
1012         ois.defaultReadObject();
1013 
1014         // hardset synchildren - so we don&#39;t try to sync - it does not make any
1015         // sense to try to synchildren when we just deserialize object.
1016         needsSyncChildren(false);
1017 
1018     } // readObject(ObjectInputStream)
1019 
1020     /*
1021      * a class to store some user data along with its handler
1022      */
<a name="16" id="anc16"></a><span class="line-modified">1023     class UserDataRecord implements Serializable {</span>
1024         /** Serialization version. */
1025         private static final long serialVersionUID = 3258126977134310455L;
1026 
1027         Object fData;
1028         UserDataHandler fHandler;
1029         UserDataRecord(Object data, UserDataHandler handler) {
1030             fData = data;
1031             fHandler = handler;
1032         }
1033     }
1034 } // class ParentNode
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
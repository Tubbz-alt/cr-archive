<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import com.sun.org.apache.bcel.internal.Const;
 23 
 24 /**
<a name="2" id="anc2"></a><span class="line-modified"> 25  * Instances of this class may be used, e.g., to generate typed</span>
<span class="line-modified"> 26  * versions of instructions. Its main purpose is to be used as the</span>
<span class="line-modified"> 27  * byte code generating backend of a compiler. You can subclass it to</span>
<span class="line-added"> 28  * add your own create methods.</span>
 29  * &lt;p&gt;
<a name="3" id="anc3"></a><span class="line-modified"> 30  * Note: The static createXXX methods return singleton instances</span>
<span class="line-modified"> 31  * from the {@link InstructionConst} class.</span>
 32  *
<a name="4" id="anc4"></a>
 33  * @see Const
 34  * @see InstructionConst
<a name="5" id="anc5"></a><span class="line-modified"> 35  * @LastModified: Jan 2020</span>
 36  */
 37 public class InstructionFactory {
 38 
 39     // N.N. These must agree with the order of Constants.T_CHAR through T_LONG
 40     private static final String[] short_names = {
<a name="6" id="anc6"></a><span class="line-modified"> 41             &quot;C&quot;, &quot;F&quot;, &quot;D&quot;, &quot;B&quot;, &quot;S&quot;, &quot;I&quot;, &quot;L&quot;</span>
 42     };
 43 
 44     private ClassGen cg;
 45     private ConstantPoolGen cp;
 46 
 47     public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {
 48         this.cg = cg;
 49         this.cp = cp;
 50     }
 51 
<a name="7" id="anc7"></a><span class="line-modified"> 52 </span>
<span class="line-modified"> 53     /** Initialize with ClassGen object</span>
 54      */
 55     public InstructionFactory(final ClassGen cg) {
 56         this(cg, cg.getConstantPool());
 57     }
 58 
<a name="8" id="anc8"></a><span class="line-modified"> 59 </span>
<span class="line-modified"> 60     /** Initialize just with ConstantPoolGen object</span>
 61      */
 62     public InstructionFactory(final ConstantPoolGen cp) {
 63         this(null, cp);
 64     }
 65 
<a name="9" id="anc9"></a><span class="line-modified"> 66 </span>
<span class="line-modified"> 67     /** Create an invoke instruction. (Except for invokedynamic.)</span>
 68      *
 69      * @param class_name name of the called class
 70      * @param name name of the called method
 71      * @param ret_type return type of method
 72      * @param arg_types argument types of method
<a name="10" id="anc10"></a><span class="line-modified"> 73      * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL,</span>
<span class="line-modified"> 74      * or INVOKESPECIAL</span>
 75      * @see Const
 76      */
<a name="11" id="anc11"></a><span class="line-modified"> 77     public InvokeInstruction createInvoke( final String class_name, final String name,</span>
<span class="line-modified"> 78             final Type ret_type, final Type[] arg_types, final short kind ) {</span>
 79         int index;
 80         int nargs = 0;
 81         final String signature = Type.getMethodSignature(ret_type, arg_types);
 82         for (final Type arg_type : arg_types) {
 83             nargs += arg_type.getSize();
 84         }
 85         if (kind == Const.INVOKEINTERFACE) {
 86             index = cp.addInterfaceMethodref(class_name, name, signature);
 87         } else {
 88             index = cp.addMethodref(class_name, name, signature);
 89         }
 90         switch (kind) {
 91             case Const.INVOKESPECIAL:
 92                 return new INVOKESPECIAL(index);
 93             case Const.INVOKEVIRTUAL:
 94                 return new INVOKEVIRTUAL(index);
 95             case Const.INVOKESTATIC:
 96                 return new INVOKESTATIC(index);
 97             case Const.INVOKEINTERFACE:
 98                 return new INVOKEINTERFACE(index, nargs + 1);
 99             case Const.INVOKEDYNAMIC:
100                 return new INVOKEDYNAMIC(index);
101             default:
102                 throw new RuntimeException(&quot;Oops: Unknown invoke kind: &quot; + kind);
103         }
104     }
105 
<a name="12" id="anc12"></a><span class="line-modified">106     /** Create an invokedynamic instruction.</span>

107      *
108      * @param bootstrap_index index into the bootstrap_methods array
109      * @param name name of the called method
110      * @param ret_type return type of method
111      * @param arg_types argument types of method
112      * @see Constants
113      */
<a name="13" id="anc13"></a><span class="line-modified">114 /*</span>
<span class="line-modified">115  * createInvokeDynamic only needed if instrumention code wants to generate</span>
<span class="line-modified">116  * a new invokedynamic instruction.  I don&#39;t think we need.  (markro)</span>
<span class="line-modified">117  *</span>
<span class="line-modified">118     public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type,</span>
<span class="line-modified">119             Type[] arg_types) {</span>
<span class="line-modified">120         int index;</span>
<span class="line-modified">121         int nargs = 0;</span>
<span class="line-modified">122         String signature = Type.getMethodSignature(ret_type, arg_types);</span>
<span class="line-modified">123         for (int i = 0; i &lt; arg_types.length; i++) {</span>
<span class="line-modified">124             nargs += arg_types[i].getSize();</span>
<span class="line-modified">125         }</span>
<span class="line-modified">126         // UNDONE - needs to be added to ConstantPoolGen</span>
<span class="line-modified">127         //index = cp.addInvokeDynamic(bootstrap_index, name, signature);</span>
<span class="line-modified">128         index = 0;</span>
<span class="line-modified">129         return new INVOKEDYNAMIC(index);</span>
<span class="line-modified">130     }</span>
<span class="line-modified">131  */</span>
<span class="line-modified">132 </span>
<span class="line-modified">133     /** Create a call to the most popular System.out.println() method.</span>
134      *
135      * @param s the string to print
136      */
<a name="14" id="anc14"></a><span class="line-modified">137     public InstructionList createPrintln( final String s ) {</span>
138         final InstructionList il = new InstructionList();
139         final int out = cp.addFieldref(&quot;java.lang.System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
140         final int println = cp.addMethodref(&quot;java.io.PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;);
141         il.append(new GETSTATIC(out));
142         il.append(new PUSH(cp, s));
143         il.append(new INVOKEVIRTUAL(println));
144         return il;
145     }
146 
<a name="15" id="anc15"></a><span class="line-modified">147 </span>
<span class="line-modified">148     /** Uses PUSH to push a constant value onto the stack.</span>

149      * @param value must be of type Number, Boolean, Character or String
150      */
<a name="16" id="anc16"></a><span class="line-modified">151     public Instruction createConstant( final Object value ) {</span>
152         PUSH push;
153         if (value instanceof Number) {
154             push = new PUSH(cp, (Number) value);
155         } else if (value instanceof String) {
156             push = new PUSH(cp, (String) value);
157         } else if (value instanceof Boolean) {
158             push = new PUSH(cp, (Boolean) value);
159         } else if (value instanceof Character) {
160             push = new PUSH(cp, (Character) value);
161         } else {
162             throw new ClassGenException(&quot;Illegal type: &quot; + value.getClass());
163         }
164         return push.getInstruction();
165     }
166 
167     private static class MethodObject {
168 
169         final Type[] arg_types;
170         final Type result_type;
171         final String class_name;
172         final String name;
173 
<a name="17" id="anc17"></a><span class="line-added">174 </span>
175         MethodObject(final String c, final String n, final Type r, final Type[] a) {
176             class_name = c;
177             name = n;
178             result_type = r;
179             arg_types = a;
180         }
181     }
182 
<a name="18" id="anc18"></a><span class="line-modified">183 </span>
<span class="line-added">184     private InvokeInstruction createInvoke( final MethodObject m, final short kind ) {</span>
185         return createInvoke(m.class_name, m.name, m.result_type, m.arg_types, kind);
186     }
187 
188     private static final MethodObject[] append_mos = {
<a name="19" id="anc19"></a><span class="line-modified">189             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">190                 Type.STRING</span>
<span class="line-modified">191             }),</span>
<span class="line-modified">192             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">193                 Type.OBJECT</span>
<span class="line-modified">194             }),</span>
<span class="line-modified">195             null,</span>
<span class="line-modified">196             null, // indices 2, 3</span>
<span class="line-modified">197             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">198                 Type.BOOLEAN</span>
<span class="line-modified">199             }),</span>
<span class="line-modified">200             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">201                 Type.CHAR</span>
<span class="line-modified">202             }),</span>
<span class="line-modified">203             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">204                 Type.FLOAT</span>
<span class="line-modified">205             }),</span>
<span class="line-modified">206             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">207                 Type.DOUBLE</span>
<span class="line-modified">208             }),</span>
<span class="line-modified">209             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">210                 Type.INT</span>
<span class="line-modified">211             }),</span>
<span class="line-modified">212             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, // No append(byte)</span>
<span class="line-modified">213                     new Type[] {</span>
<span class="line-modified">214                         Type.INT</span>
<span class="line-modified">215                     }),</span>
<span class="line-modified">216             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, // No append(short)</span>
<span class="line-modified">217                     new Type[] {</span>
<span class="line-modified">218                         Type.INT</span>
<span class="line-modified">219                     }),</span>
<span class="line-modified">220             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">221                 Type.LONG</span>
<span class="line-modified">222             })</span>
223     };
224 
<a name="20" id="anc20"></a><span class="line-modified">225 </span>
<span class="line-modified">226     private static boolean isString( final Type type ) {</span>
<span class="line-modified">227         return (type instanceof ObjectType) &amp;&amp;</span>
<span class="line-added">228               ((ObjectType) type).getClassName().equals(&quot;java.lang.String&quot;);</span>
229     }
230 
<a name="21" id="anc21"></a><span class="line-modified">231 </span>
<span class="line-added">232     public Instruction createAppend( final Type type ) {</span>
233         final byte t = type.getType();
234         if (isString(type)) {
235             return createInvoke(append_mos[0], Const.INVOKEVIRTUAL);
236         }
237         switch (t) {
238             case Const.T_BOOLEAN:
239             case Const.T_CHAR:
240             case Const.T_FLOAT:
241             case Const.T_DOUBLE:
242             case Const.T_BYTE:
243             case Const.T_SHORT:
244             case Const.T_INT:
245             case Const.T_LONG:
246                 return createInvoke(append_mos[t], Const.INVOKEVIRTUAL);
247             case Const.T_ARRAY:
248             case Const.T_OBJECT:
249                 return createInvoke(append_mos[1], Const.INVOKEVIRTUAL);
250             default:
251                 throw new RuntimeException(&quot;Oops: No append for this type? &quot; + type);
252         }
253     }
254 
<a name="22" id="anc22"></a><span class="line-modified">255 </span>
<span class="line-modified">256     /** Create a field instruction.</span>
257      *
258      * @param class_name name of the accessed class
259      * @param name name of the referenced field
<a name="23" id="anc23"></a><span class="line-modified">260      * @param type  type of field</span>
261      * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC
262      * @see Const
263      */
<a name="24" id="anc24"></a><span class="line-modified">264     public FieldInstruction createFieldAccess( final String class_name,</span>
<span class="line-added">265             final String name, final Type type, final short kind ) {</span>
266         int index;
267         final String signature = type.getSignature();
268         index = cp.addFieldref(class_name, name, signature);
269         switch (kind) {
270             case Const.GETFIELD:
271                 return new GETFIELD(index);
272             case Const.PUTFIELD:
273                 return new PUTFIELD(index);
274             case Const.GETSTATIC:
275                 return new GETSTATIC(index);
276             case Const.PUTSTATIC:
277                 return new PUTSTATIC(index);
278             default:
279                 throw new RuntimeException(&quot;Oops: Unknown getfield kind:&quot; + kind);
280         }
281     }
282 
<a name="25" id="anc25"></a><span class="line-modified">283 </span>
<span class="line-modified">284     /** Create reference to `this&#39;</span>
285      */
286     public static Instruction createThis() {
287         return new ALOAD(0);
288     }
289 
<a name="26" id="anc26"></a><span class="line-modified">290 </span>
<span class="line-modified">291     /** Create typed return</span>
292      */
<a name="27" id="anc27"></a><span class="line-modified">293     public static ReturnInstruction createReturn( final Type type ) {</span>
294         switch (type.getType()) {
295             case Const.T_ARRAY:
296             case Const.T_OBJECT:
297                 return InstructionConst.ARETURN;
298             case Const.T_INT:
299             case Const.T_SHORT:
300             case Const.T_BOOLEAN:
301             case Const.T_CHAR:
302             case Const.T_BYTE:
303                 return InstructionConst.IRETURN;
304             case Const.T_FLOAT:
305                 return InstructionConst.FRETURN;
306             case Const.T_DOUBLE:
307                 return InstructionConst.DRETURN;
308             case Const.T_LONG:
309                 return InstructionConst.LRETURN;
310             case Const.T_VOID:
311                 return InstructionConst.RETURN;
312             default:
313                 throw new RuntimeException(&quot;Invalid type: &quot; + type);
314         }
315     }
316 
<a name="28" id="anc28"></a><span class="line-modified">317 </span>
<span class="line-added">318     private static ArithmeticInstruction createBinaryIntOp( final char first, final String op ) {</span>
319         switch (first) {
320             case &#39;-&#39;:
321                 return InstructionConst.ISUB;
322             case &#39;+&#39;:
323                 return InstructionConst.IADD;
324             case &#39;%&#39;:
325                 return InstructionConst.IREM;
326             case &#39;*&#39;:
327                 return InstructionConst.IMUL;
328             case &#39;/&#39;:
329                 return InstructionConst.IDIV;
330             case &#39;&amp;&#39;:
331                 return InstructionConst.IAND;
332             case &#39;|&#39;:
333                 return InstructionConst.IOR;
334             case &#39;^&#39;:
335                 return InstructionConst.IXOR;
336             case &#39;&lt;&#39;:
337                 return InstructionConst.ISHL;
338             case &#39;&gt;&#39;:
339                 return op.equals(&quot;&gt;&gt;&gt;&quot;) ? InstructionConst.IUSHR : InstructionConst.ISHR;
340             default:
341                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
342         }
343     }
344 
<a name="29" id="anc29"></a><span class="line-modified">345 </span>
<span class="line-added">346     private static ArithmeticInstruction createBinaryLongOp( final char first, final String op ) {</span>
347         switch (first) {
348             case &#39;-&#39;:
349                 return InstructionConst.LSUB;
350             case &#39;+&#39;:
351                 return InstructionConst.LADD;
352             case &#39;%&#39;:
353                 return InstructionConst.LREM;
354             case &#39;*&#39;:
355                 return InstructionConst.LMUL;
356             case &#39;/&#39;:
357                 return InstructionConst.LDIV;
358             case &#39;&amp;&#39;:
359                 return InstructionConst.LAND;
360             case &#39;|&#39;:
361                 return InstructionConst.LOR;
362             case &#39;^&#39;:
363                 return InstructionConst.LXOR;
364             case &#39;&lt;&#39;:
365                 return InstructionConst.LSHL;
366             case &#39;&gt;&#39;:
367                 return op.equals(&quot;&gt;&gt;&gt;&quot;) ? InstructionConst.LUSHR : InstructionConst.LSHR;
368             default:
369                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
370         }
371     }
372 
<a name="30" id="anc30"></a><span class="line-modified">373 </span>
<span class="line-added">374     private static ArithmeticInstruction createBinaryFloatOp( final char op ) {</span>
375         switch (op) {
376             case &#39;-&#39;:
377                 return InstructionConst.FSUB;
378             case &#39;+&#39;:
379                 return InstructionConst.FADD;
380             case &#39;*&#39;:
381                 return InstructionConst.FMUL;
382             case &#39;/&#39;:
383                 return InstructionConst.FDIV;
384             case &#39;%&#39;:
385                 return InstructionConst.FREM;
386             default:
387                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
388         }
389     }
390 
<a name="31" id="anc31"></a><span class="line-modified">391 </span>
<span class="line-added">392     private static ArithmeticInstruction createBinaryDoubleOp( final char op ) {</span>
393         switch (op) {
394             case &#39;-&#39;:
395                 return InstructionConst.DSUB;
396             case &#39;+&#39;:
397                 return InstructionConst.DADD;
398             case &#39;*&#39;:
399                 return InstructionConst.DMUL;
400             case &#39;/&#39;:
401                 return InstructionConst.DDIV;
402             case &#39;%&#39;:
403                 return InstructionConst.DREM;
404             default:
405                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
406         }
407     }
408 
<a name="32" id="anc32"></a><span class="line-added">409 </span>
410     /**
411      * Create binary operation for simple basic types, such as int and float.
412      *
413      * @param op operation, such as &quot;+&quot;, &quot;*&quot;, &quot;&amp;lt;&amp;lt;&quot;, etc.
414      */
<a name="33" id="anc33"></a><span class="line-modified">415     public static ArithmeticInstruction createBinaryOperation( final String op, final Type type ) {</span>
416         final char first = op.charAt(0);
417         switch (type.getType()) {
418             case Const.T_BYTE:
419             case Const.T_SHORT:
420             case Const.T_INT:
421             case Const.T_CHAR:
422                 return createBinaryIntOp(first, op);
423             case Const.T_LONG:
424                 return createBinaryLongOp(first, op);
425             case Const.T_FLOAT:
426                 return createBinaryFloatOp(first);
427             case Const.T_DOUBLE:
428                 return createBinaryDoubleOp(first);
429             default:
430                 throw new RuntimeException(&quot;Invalid type &quot; + type);
431         }
432     }
433 
<a name="34" id="anc34"></a><span class="line-added">434 </span>
435     /**
436      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
437      */
<a name="35" id="anc35"></a><span class="line-modified">438     public static StackInstruction createPop( final int size ) {</span>
439         return (size == 2) ? InstructionConst.POP2 : InstructionConst.POP;
440     }
441 
<a name="36" id="anc36"></a><span class="line-added">442 </span>
443     /**
444      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
445      */
<a name="37" id="anc37"></a><span class="line-modified">446     public static StackInstruction createDup( final int size ) {</span>
447         return (size == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;
448     }
449 
<a name="38" id="anc38"></a><span class="line-added">450 </span>
451     /**
452      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
453      */
<a name="39" id="anc39"></a><span class="line-modified">454     public static StackInstruction createDup_2( final int size ) {</span>
455         return (size == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;
456     }
457 
<a name="40" id="anc40"></a><span class="line-added">458 </span>
459     /**
460      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
461      */
<a name="41" id="anc41"></a><span class="line-modified">462     public static StackInstruction createDup_1( final int size ) {</span>
463         return (size == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;
464     }
465 
<a name="42" id="anc42"></a><span class="line-added">466 </span>
467     /**
468      * @param index index of local variable
469      */
<a name="43" id="anc43"></a><span class="line-modified">470     public static LocalVariableInstruction createStore( final Type type, final int index ) {</span>
471         switch (type.getType()) {
472             case Const.T_BOOLEAN:
473             case Const.T_CHAR:
474             case Const.T_BYTE:
475             case Const.T_SHORT:
476             case Const.T_INT:
477                 return new ISTORE(index);
478             case Const.T_FLOAT:
479                 return new FSTORE(index);
480             case Const.T_DOUBLE:
481                 return new DSTORE(index);
482             case Const.T_LONG:
483                 return new LSTORE(index);
484             case Const.T_ARRAY:
485             case Const.T_OBJECT:
486                 return new ASTORE(index);
487             default:
488                 throw new RuntimeException(&quot;Invalid type &quot; + type);
489         }
490     }
491 
<a name="44" id="anc44"></a><span class="line-added">492 </span>
493     /**
494      * @param index index of local variable
495      */
<a name="45" id="anc45"></a><span class="line-modified">496     public static LocalVariableInstruction createLoad( final Type type, final int index ) {</span>
497         switch (type.getType()) {
498             case Const.T_BOOLEAN:
499             case Const.T_CHAR:
500             case Const.T_BYTE:
501             case Const.T_SHORT:
502             case Const.T_INT:
503                 return new ILOAD(index);
504             case Const.T_FLOAT:
505                 return new FLOAD(index);
506             case Const.T_DOUBLE:
507                 return new DLOAD(index);
508             case Const.T_LONG:
509                 return new LLOAD(index);
510             case Const.T_ARRAY:
511             case Const.T_OBJECT:
512                 return new ALOAD(index);
513             default:
514                 throw new RuntimeException(&quot;Invalid type &quot; + type);
515         }
516     }
517 
<a name="46" id="anc46"></a><span class="line-added">518 </span>
519     /**
520      * @param type type of elements of array, i.e., array.getElementType()
521      */
<a name="47" id="anc47"></a><span class="line-modified">522     public static ArrayInstruction createArrayLoad( final Type type ) {</span>
523         switch (type.getType()) {
524             case Const.T_BOOLEAN:
525             case Const.T_BYTE:
526                 return InstructionConst.BALOAD;
527             case Const.T_CHAR:
528                 return InstructionConst.CALOAD;
529             case Const.T_SHORT:
530                 return InstructionConst.SALOAD;
531             case Const.T_INT:
532                 return InstructionConst.IALOAD;
533             case Const.T_FLOAT:
534                 return InstructionConst.FALOAD;
535             case Const.T_DOUBLE:
536                 return InstructionConst.DALOAD;
537             case Const.T_LONG:
538                 return InstructionConst.LALOAD;
539             case Const.T_ARRAY:
540             case Const.T_OBJECT:
541                 return InstructionConst.AALOAD;
542             default:
543                 throw new RuntimeException(&quot;Invalid type &quot; + type);
544         }
545     }
546 
<a name="48" id="anc48"></a><span class="line-added">547 </span>
548     /**
549      * @param type type of elements of array, i.e., array.getElementType()
550      */
<a name="49" id="anc49"></a><span class="line-modified">551     public static ArrayInstruction createArrayStore( final Type type ) {</span>
552         switch (type.getType()) {
553             case Const.T_BOOLEAN:
554             case Const.T_BYTE:
555                 return InstructionConst.BASTORE;
556             case Const.T_CHAR:
557                 return InstructionConst.CASTORE;
558             case Const.T_SHORT:
559                 return InstructionConst.SASTORE;
560             case Const.T_INT:
561                 return InstructionConst.IASTORE;
562             case Const.T_FLOAT:
563                 return InstructionConst.FASTORE;
564             case Const.T_DOUBLE:
565                 return InstructionConst.DASTORE;
566             case Const.T_LONG:
567                 return InstructionConst.LASTORE;
568             case Const.T_ARRAY:
569             case Const.T_OBJECT:
570                 return InstructionConst.AASTORE;
571             default:
572                 throw new RuntimeException(&quot;Invalid type &quot; + type);
573         }
574     }
575 
576     /**
577      * Create conversion operation for two stack operands, this may be an I2C,
578      * instruction, e.g., if the operands are basic types and CHECKCAST if they
579      * are reference types.
580      */
<a name="50" id="anc50"></a><span class="line-modified">581     public Instruction createCast( final Type src_type, final Type dest_type ) {</span>
582         if ((src_type instanceof BasicType) &amp;&amp; (dest_type instanceof BasicType)) {
583             final byte dest = dest_type.getType();
584             byte src = src_type.getType();
585             if (dest == Const.T_LONG
586                     &amp;&amp; (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
587                 src = Const.T_INT;
588             }
589             final String name = &quot;com.sun.org.apache.bcel.internal.generic.&quot; + short_names[src - Const.T_CHAR] + &quot;2&quot;
590                     + short_names[dest - Const.T_CHAR];
591             Instruction i = null;
592             try {
593                 i = (Instruction) java.lang.Class.forName(name).getDeclaredConstructor().newInstance();
594             } catch (final Exception e) {
595                 throw new RuntimeException(&quot;Could not find instruction: &quot; + name, e);
596             }
597             return i;
598         } else if ((src_type instanceof ReferenceType) &amp;&amp; (dest_type instanceof ReferenceType)) {
599             if (dest_type instanceof ArrayType) {
600                 return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));
601             }
602             return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
603         } else {
604             throw new RuntimeException(&quot;Can not cast &quot; + src_type + &quot; to &quot; + dest_type);
605         }
606     }
607 
<a name="51" id="anc51"></a><span class="line-modified">608 </span>
<span class="line-added">609     public GETFIELD createGetField( final String class_name, final String name, final Type t ) {</span>
610         return new GETFIELD(cp.addFieldref(class_name, name, t.getSignature()));
611     }
612 
<a name="52" id="anc52"></a><span class="line-modified">613 </span>
<span class="line-added">614     public GETSTATIC createGetStatic( final String class_name, final String name, final Type t ) {</span>
615         return new GETSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
616     }
617 
<a name="53" id="anc53"></a><span class="line-modified">618 </span>
<span class="line-added">619     public PUTFIELD createPutField( final String class_name, final String name, final Type t ) {</span>
620         return new PUTFIELD(cp.addFieldref(class_name, name, t.getSignature()));
621     }
622 
<a name="54" id="anc54"></a><span class="line-modified">623 </span>
<span class="line-added">624     public PUTSTATIC createPutStatic( final String class_name, final String name, final Type t ) {</span>
625         return new PUTSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
626     }
627 
<a name="55" id="anc55"></a><span class="line-modified">628 </span>
<span class="line-added">629     public CHECKCAST createCheckCast( final ReferenceType t ) {</span>
630         if (t instanceof ArrayType) {
631             return new CHECKCAST(cp.addArrayClass((ArrayType) t));
632         }
633         return new CHECKCAST(cp.addClass((ObjectType) t));
634     }
635 
<a name="56" id="anc56"></a><span class="line-modified">636 </span>
<span class="line-added">637     public INSTANCEOF createInstanceOf( final ReferenceType t ) {</span>
638         if (t instanceof ArrayType) {
639             return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
640         }
641         return new INSTANCEOF(cp.addClass((ObjectType) t));
642     }
643 
<a name="57" id="anc57"></a><span class="line-modified">644 </span>
<span class="line-added">645     public NEW createNew( final ObjectType t ) {</span>
646         return new NEW(cp.addClass(t));
647     }
648 
<a name="58" id="anc58"></a><span class="line-modified">649 </span>
<span class="line-added">650     public NEW createNew( final String s ) {</span>
651         return createNew(ObjectType.getInstance(s));
652     }
653 
654     /**
655      * Create new array of given size and type.
656      *
657      * @return an instruction that creates the corresponding array at runtime,
658      * i.e. is an AllocationInstruction
659      */
<a name="59" id="anc59"></a><span class="line-modified">660     public Instruction createNewArray( final Type t, final short dim ) {</span>
661         if (dim == 1) {
662             if (t instanceof ObjectType) {
663                 return new ANEWARRAY(cp.addClass((ObjectType) t));
664             } else if (t instanceof ArrayType) {
665                 return new ANEWARRAY(cp.addArrayClass((ArrayType) t));
666             } else {
667                 return new NEWARRAY(t.getType());
668             }
669         }
670         ArrayType at;
671         if (t instanceof ArrayType) {
672             at = (ArrayType) t;
673         } else {
674             at = new ArrayType(t, dim);
675         }
676         return new MULTIANEWARRAY(cp.addArrayClass(at), dim);
677     }
678 
679     /**
680      * Create &quot;null&quot; value for reference types, 0 for basic types like int
681      */
<a name="60" id="anc60"></a><span class="line-modified">682     public static Instruction createNull( final Type type ) {</span>
683         switch (type.getType()) {
684             case Const.T_ARRAY:
685             case Const.T_OBJECT:
686                 return InstructionConst.ACONST_NULL;
687             case Const.T_INT:
688             case Const.T_SHORT:
689             case Const.T_BOOLEAN:
690             case Const.T_CHAR:
691             case Const.T_BYTE:
692                 return InstructionConst.ICONST_0;
693             case Const.T_FLOAT:
694                 return InstructionConst.FCONST_0;
695             case Const.T_DOUBLE:
696                 return InstructionConst.DCONST_0;
697             case Const.T_LONG:
698                 return InstructionConst.LCONST_0;
699             case Const.T_VOID:
700                 return InstructionConst.NOP;
701             default:
702                 throw new RuntimeException(&quot;Invalid type: &quot; + type);
703         }
704     }
705 
706     /**
707      * Create branch instruction by given opcode, except LOOKUPSWITCH and
708      * TABLESWITCH. For those you should use the SWITCH compound instruction.
709      */
<a name="61" id="anc61"></a><span class="line-modified">710     public static BranchInstruction createBranchInstruction( final short opcode,</span>
<span class="line-added">711             final InstructionHandle target ) {</span>
712         switch (opcode) {
713             case Const.IFEQ:
714                 return new IFEQ(target);
715             case Const.IFNE:
716                 return new IFNE(target);
717             case Const.IFLT:
718                 return new IFLT(target);
719             case Const.IFGE:
720                 return new IFGE(target);
721             case Const.IFGT:
722                 return new IFGT(target);
723             case Const.IFLE:
724                 return new IFLE(target);
725             case Const.IF_ICMPEQ:
726                 return new IF_ICMPEQ(target);
727             case Const.IF_ICMPNE:
728                 return new IF_ICMPNE(target);
729             case Const.IF_ICMPLT:
730                 return new IF_ICMPLT(target);
731             case Const.IF_ICMPGE:
732                 return new IF_ICMPGE(target);
733             case Const.IF_ICMPGT:
734                 return new IF_ICMPGT(target);
735             case Const.IF_ICMPLE:
736                 return new IF_ICMPLE(target);
737             case Const.IF_ACMPEQ:
738                 return new IF_ACMPEQ(target);
739             case Const.IF_ACMPNE:
740                 return new IF_ACMPNE(target);
741             case Const.GOTO:
742                 return new GOTO(target);
743             case Const.JSR:
744                 return new JSR(target);
745             case Const.IFNULL:
746                 return new IFNULL(target);
747             case Const.IFNONNULL:
748                 return new IFNONNULL(target);
749             case Const.GOTO_W:
750                 return new GOTO_W(target);
751             case Const.JSR_W:
752                 return new JSR_W(target);
753             default:
754                 throw new RuntimeException(&quot;Invalid opcode: &quot; + opcode);
755         }
756     }
757 
<a name="62" id="anc62"></a><span class="line-modified">758 </span>
<span class="line-added">759     public void setClassGen( final ClassGen c ) {</span>
760         cg = c;
761     }
762 
<a name="63" id="anc63"></a><span class="line-added">763 </span>
764     public ClassGen getClassGen() {
765         return cg;
766     }
767 
<a name="64" id="anc64"></a><span class="line-modified">768 </span>
<span class="line-added">769     public void setConstantPool( final ConstantPoolGen c ) {</span>
770         cp = c;
771     }
772 
<a name="65" id="anc65"></a><span class="line-added">773 </span>
774     public ConstantPoolGen getConstantPool() {
775         return cp;
776     }
777 }
<a name="66" id="anc66"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="66" type="hidden" />
</body>
</html>
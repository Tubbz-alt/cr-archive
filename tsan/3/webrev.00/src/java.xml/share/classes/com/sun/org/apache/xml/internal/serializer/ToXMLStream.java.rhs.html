<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToXMLStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21  package com.sun.org.apache.xml.internal.serializer;
 22 
 23 import java.io.IOException;
 24 
 25 import javax.xml.transform.ErrorListener;
 26 import javax.xml.transform.Result;
 27 import javax.xml.transform.Transformer;
 28 import javax.xml.transform.TransformerException;
 29 
 30 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
 31 import com.sun.org.apache.xml.internal.serializer.utils.Utils;
 32 import org.xml.sax.SAXException;
 33 
 34 /**
 35  * This class converts SAX or SAX-like calls to a
 36  * serialized xml document.  The xsl:output method is &quot;xml&quot;.
 37  *
 38  * This class is used explicitly in code generated by XSLTC,
 39  * so it is &quot;public&quot;, but it should
 40  * be viewed as internal or package private, this is not an API.
 41  *
 42  * @xsl.usage internal
<a name="2" id="anc2"></a><span class="line-added"> 43  * @LastModified: Aug 2019</span>
 44  */
 45 public final class ToXMLStream extends ToStream
 46 {
 47 
 48     /**
 49      * remembers if we need to write out &quot;]]&gt;&quot; to close the CDATA
 50      */
 51     boolean m_cdataTagOpen = false;
 52 
 53 
 54     /**
 55      * Map that tells which XML characters should have special treatment, and it
 56      *  provides character to entity name lookup.
 57      */
 58     private static CharInfo m_xmlcharInfo =
 59 //      new CharInfo(CharInfo.XML_ENTITIES_RESOURCE);
 60         CharInfo.getCharInfoInternal(CharInfo.XML_ENTITIES_RESOURCE, Method.XML);
 61 
 62     /**
 63      * Default constructor.
 64      */
 65     public ToXMLStream()
 66     {
<a name="3" id="anc3"></a><span class="line-added"> 67         this(null);</span>
<span class="line-added"> 68     }</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     /**</span>
<span class="line-added"> 71      * Default constructor.</span>
<span class="line-added"> 72      */</span>
<span class="line-added"> 73     public ToXMLStream(ErrorListener l)</span>
<span class="line-added"> 74     {</span>
<span class="line-added"> 75         super(l);</span>
 76         m_charInfo = m_xmlcharInfo;
 77 
 78         initCDATA();
 79         // initialize namespaces
 80         m_prefixMap = new NamespaceMappings();
<a name="4" id="anc4"></a>
 81     }
 82 
 83     /**
 84      * Copy properties from another SerializerToXML.
 85      *
 86      * @param xmlListener non-null reference to a SerializerToXML object.
 87      */
 88     public void CopyFrom(ToXMLStream xmlListener)
 89     {
 90 
 91         m_writer = xmlListener.m_writer;
 92 
 93 
 94         // m_outputStream = xmlListener.m_outputStream;
 95         String encoding = xmlListener.getEncoding();
 96         setEncoding(encoding);
 97 
 98         setOmitXMLDeclaration(xmlListener.getOmitXMLDeclaration());
 99 
100         m_ispreserveSpace = xmlListener.m_ispreserveSpace;
101         m_preserveSpaces = xmlListener.m_preserveSpaces;
102         m_childNodeNum = xmlListener.m_childNodeNum;
103         m_childNodeNumStack = xmlListener.m_childNodeNumStack;
104         m_charactersBuffer = xmlListener.m_charactersBuffer;
105         m_inEntityRef = xmlListener.m_inEntityRef;
106         m_isprevtext = xmlListener.m_isprevtext;
107         m_doIndent = xmlListener.m_doIndent;
108         setIndentAmount(xmlListener.getIndentAmount());
109         m_startNewLine = xmlListener.m_startNewLine;
110         m_needToOutputDocTypeDecl = xmlListener.m_needToOutputDocTypeDecl;
111         setDoctypeSystem(xmlListener.getDoctypeSystem());
112         setDoctypePublic(xmlListener.getDoctypePublic());
113         setStandalone(xmlListener.getStandalone());
114         setMediaType(xmlListener.getMediaType());
115         m_maxCharacter = xmlListener.m_maxCharacter;
116         m_encodingInfo = xmlListener.m_encodingInfo;
117         m_spaceBeforeClose = xmlListener.m_spaceBeforeClose;
118         m_cdataStartCalled = xmlListener.m_cdataStartCalled;
119 
120     }
121 
122     /**
123      * Receive notification of the beginning of a document.
124      *
125      * @throws org.xml.sax.SAXException Any SAX exception, possibly
126      *            wrapping another exception.
127      *
128      * @throws org.xml.sax.SAXException
129      */
130     public void startDocumentInternal() throws org.xml.sax.SAXException
131     {
132 
133         if (m_needToCallStartDocument)
134         {
135             super.startDocumentInternal();
136             m_needToCallStartDocument = false;
137 
138             if (isInEntityRef())
139                 return;
140 
141             m_needToOutputDocTypeDecl = true;
142             m_startNewLine = false;
143             /* The call to getXMLVersion() might emit an error message
144              * and we should emit this message regardless of if we are
145              * writing out an XML header or not.
146              */
147             if (getOmitXMLDeclaration() == false)
148             {
149                 String encoding = Encodings.getMimeEncoding(getEncoding());
150                 String version = getVersion();
151                 if (version == null)
152                     version = &quot;1.0&quot;;
153                 String standalone;
154 
155                 if (m_standaloneWasSpecified)
156                 {
157                     standalone = &quot; standalone=\&quot;&quot; + getStandalone() + &quot;\&quot;&quot;;
158                 }
159                 else
160                 {
161                     standalone = &quot;&quot;;
162                 }
163 
164                 try
165                 {
166                     final java.io.Writer writer = m_writer;
167                     writer.write(&quot;&lt;?xml version=\&quot;&quot;);
168                     writer.write(version);
169                     writer.write(&quot;\&quot; encoding=\&quot;&quot;);
170                     writer.write(encoding);
171                     writer.write(&#39;\&quot;&#39;);
172                     writer.write(standalone);
173                     writer.write(&quot;?&gt;&quot;);
174                     if (m_doIndent) {
175                         if (m_standaloneWasSpecified
176                                 || getDoctypePublic() != null
177                                 || getDoctypeSystem() != null
178                                 || m_isStandalone) {
179                             // We almost never put a newline after the XML
180                             // header because this XML could be used as
181                             // an extenal general parsed entity
182                             // and we don&#39;t know the context into which it
183                             // will be used in the future.  Only when
184                             // standalone, or a doctype system or public is
185                             // specified are we free to insert a new line
186                             // after the header.  Is it even worth bothering
187                             // in these rare cases?
188                             writer.write(m_lineSep, 0, m_lineSepLen);
189                         }
190                     }
191                 }
192                 catch(IOException e)
193                 {
194                     throw new SAXException(e);
195                 }
196 
197             }
198         }
199     }
200 
201     /**
202      * Receive notification of the end of a document.
203      *
204      * @throws org.xml.sax.SAXException Any SAX exception, possibly
205      *            wrapping another exception.
206      *
207      * @throws org.xml.sax.SAXException
208      */
209     public void endDocument() throws org.xml.sax.SAXException
210     {
211         if (m_doIndent) {
<a name="5" id="anc5"></a><span class="line-modified">212             flushCharactersBuffer(false);</span>
213         }
214         flushPending();
215         if (m_doIndent &amp;&amp; !m_isprevtext)
216         {
217             try
218             {
219             outputLineSep();
220             }
221             catch(IOException e)
222             {
223                 throw new SAXException(e);
224             }
225         }
226 
227         flushWriter();
228 
229         if (m_tracer != null)
230             super.fireEndDoc();
231     }
232 
233     /**
234      * Starts a whitespace preserving section. All characters printed
235      * within a preserving section are printed without indentation and
236      * without consolidating multiple spaces. This is equivalent to
237      * the &lt;tt&gt;xml:space=&amp;quot;preserve&amp;quot;&lt;/tt&gt; attribute. Only XML
238      * and HTML serializers need to support this method.
239      * &lt;p&gt;
240      * The contents of the whitespace preserving section will be delivered
241      * through the regular &lt;tt&gt;characters&lt;/tt&gt; event.
242      *
243      * @throws org.xml.sax.SAXException
244      */
245     public void startPreserving() throws org.xml.sax.SAXException
246     {
247     }
248 
249     /**
250      * Ends a whitespace preserving section.
251      *
252      * @see #startPreserving
253      *
254      * @throws org.xml.sax.SAXException
255      */
256     public void endPreserving() throws org.xml.sax.SAXException
257     {
258     }
259 
260     /**
261      * Receive notification of a processing instruction.
262      *
263      * @param target The processing instruction target.
264      * @param data The processing instruction data, or null if
265      *        none was supplied.
266      * @throws org.xml.sax.SAXException Any SAX exception, possibly
267      *            wrapping another exception.
268      *
269      * @throws org.xml.sax.SAXException
270      */
271     public void processingInstruction(String target, String data)
272         throws org.xml.sax.SAXException
273     {
274         if (isInEntityRef())
275             return;
276 
277         if (m_doIndent) {
278             m_childNodeNum++;
<a name="6" id="anc6"></a><span class="line-modified">279             flushCharactersBuffer(false);</span>
280         }
281         flushPending();
282 
283         if (target.equals(Result.PI_DISABLE_OUTPUT_ESCAPING))
284         {
285             startNonEscaping();
286         }
287         else if (target.equals(Result.PI_ENABLE_OUTPUT_ESCAPING))
288         {
289             endNonEscaping();
290         }
291         else
292         {
293             try
294             {
295                 if (m_elemContext.m_startTagOpen)
296                 {
297                     closeStartTag();
298                     m_elemContext.m_startTagOpen = false;
299                 }
300                 else if (m_needToCallStartDocument)
301                     startDocumentInternal();
302 
303                 if (shouldIndent())
304                     indent();
305 
306                 final java.io.Writer writer = m_writer;
307                 writer.write(&quot;&lt;?&quot;);
308                 writer.write(target);
309 
310                 if (data.length() &gt; 0
311                     &amp;&amp; !Character.isSpaceChar(data.charAt(0)))
312                     writer.write(&#39; &#39;);
313 
314                 int indexOfQLT = data.indexOf(&quot;?&gt;&quot;);
315 
316                 if (indexOfQLT &gt;= 0)
317                 {
318 
319                     // See XSLT spec on error recovery of &quot;?&gt;&quot; in PIs.
320                     if (indexOfQLT &gt; 0)
321                     {
322                         writer.write(data.substring(0, indexOfQLT));
323                     }
324 
325                     writer.write(&quot;? &gt;&quot;); // add space between.
326 
327                     if ((indexOfQLT + 2) &lt; data.length())
328                     {
329                         writer.write(data.substring(indexOfQLT + 2));
330                     }
331                 }
332                 else
333                 {
334                     writer.write(data);
335                 }
336 
337                 writer.write(&#39;?&#39;);
338                 writer.write(&#39;&gt;&#39;);
339 
340                 /**
341                  * Before Xalan 1497, a newline char was printed out if not inside of an
342                  * element. The whitespace is not significant is the output is standalone
343                 */
344                 if (m_elemContext.m_currentElemDepth &lt;= 0 &amp;&amp; m_isStandalone)
345                     writer.write(m_lineSep, 0, m_lineSepLen);
346 
347 
348                 /*
349                  * Don&#39;t write out any indentation whitespace now,
350                  * because there may be non-whitespace text after this.
351                  *
352                  * Simply mark that at this point if we do decide
353                  * to indent that we should
354                  * add a newline on the end of the current line before
355                  * the indentation at the start of the next line.
356                  */
357                 m_startNewLine = true;
358             }
359             catch(IOException e)
360             {
361                 throw new SAXException(e);
362             }
363         }
364 
365         if (m_tracer != null)
366             super.fireEscapingEvent(target, data);
367     }
368 
369     /**
370      * Receive notivication of a entityReference.
371      *
372      * @param name The name of the entity.
373      *
374      * @throws org.xml.sax.SAXException
375      */
376     public void entityReference(String name) throws org.xml.sax.SAXException
377     {
378         if (m_elemContext.m_startTagOpen)
379         {
380             closeStartTag();
381             m_elemContext.m_startTagOpen = false;
382         }
383 
384         try
385         {
386             if (shouldIndent())
387                 indent();
388 
389             final java.io.Writer writer = m_writer;
390             writer.write(&#39;&amp;&#39;);
391             writer.write(name);
392             writer.write(&#39;;&#39;);
393         }
394         catch(IOException e)
395         {
396             throw new SAXException(e);
397         }
398 
399         if (m_tracer != null)
400             super.fireEntityReference(name);
401     }
402 
403     /**
404      * This method is used to add an attribute to the currently open element.
405      * The caller has guaranted that this attribute is unique, which means that it
406      * not been seen before and will not be seen again.
407      *
408      * @param name the qualified name of the attribute
409      * @param value the value of the attribute which can contain only
410      * ASCII printable characters characters in the range 32 to 127 inclusive.
411      * @param flags the bit values of this integer give optimization information.
412      */
413     public void addUniqueAttribute(String name, String value, int flags)
414         throws SAXException
415     {
416         if (m_elemContext.m_startTagOpen)
417         {
418 
419             try
420             {
421                 final String patchedName = patchName(name);
422                 final java.io.Writer writer = m_writer;
423                 if ((flags &amp; NO_BAD_CHARS) &gt; 0 &amp;&amp; m_xmlcharInfo.onlyQuotAmpLtGt)
424                 {
425                     // &quot;flags&quot; has indicated that the characters
426                     // &#39;&gt;&#39;  &#39;&lt;&#39;   &#39;&amp;&#39;  and &#39;&quot;&#39; are not in the value and
427                     // m_htmlcharInfo has recorded that there are no other
428                     // entities in the range 32 to 127 so we write out the
429                     // value directly
430 
431                     writer.write(&#39; &#39;);
432                     writer.write(patchedName);
433                     writer.write(&quot;=\&quot;&quot;);
434                     writer.write(value);
435                     writer.write(&#39;&quot;&#39;);
436                 }
437                 else
438                 {
439                     writer.write(&#39; &#39;);
440                     writer.write(patchedName);
441                     writer.write(&quot;=\&quot;&quot;);
442                     writeAttrString(writer, value, this.getEncoding());
443                     writer.write(&#39;&quot;&#39;);
444                 }
445             } catch (IOException e) {
446                 throw new SAXException(e);
447             }
448         }
449     }
450 
451     /**
452      * Add an attribute to the current element.
453      * @param uri the URI associated with the element name
454      * @param localName local part of the attribute name
455      * @param rawName   prefix:localName
456      * @param type
457      * @param value the value of the attribute
458      * @param xslAttribute true if this attribute is from an xsl:attribute,
459      * false if declared within the elements opening tag.
460      * @throws SAXException
461      */
462     public void addAttribute(
463         String uri,
464         String localName,
465         String rawName,
466         String type,
467         String value,
468         boolean xslAttribute)
469         throws SAXException
470     {
471         if (m_elemContext.m_startTagOpen)
472         {
473             boolean was_added = addAttributeAlways(uri, localName, rawName, type, value, xslAttribute);
474 
475 
476             /*
477              * We don&#39;t run this block of code if:
478              * 1. The attribute value was only replaced (was_added is false).
479              * 2. The attribute is from an xsl:attribute element (that is handled
480              *    in the addAttributeAlways() call just above.
481              * 3. The name starts with &quot;xmlns&quot;, i.e. it is a namespace declaration.
482              */
483             if (was_added &amp;&amp; !xslAttribute &amp;&amp; !rawName.startsWith(&quot;xmlns&quot;))
484             {
485                 String prefixUsed =
486                     ensureAttributesNamespaceIsDeclared(
487                         uri,
488                         localName,
489                         rawName);
490                 if (prefixUsed != null
491                     &amp;&amp; rawName != null
492                     &amp;&amp; !rawName.startsWith(prefixUsed))
493                 {
494                     // use a different raw name, with the prefix used in the
495                     // generated namespace declaration
496                     rawName = prefixUsed + &quot;:&quot; + localName;
497 
498                 }
499             }
500             addAttributeAlways(uri, localName, rawName, type, value, xslAttribute);
501         }
502         else
503         {
504             /*
505              * The startTag is closed, yet we are adding an attribute?
506              *
507              * Section: 7.1.3 Creating Attributes Adding an attribute to an
508              * element after a PI (for example) has been added to it is an
509              * error. The attributes can be ignored. The spec doesn&#39;t explicitly
510              * say this is disallowed, as it does for child elements, but it
511              * makes sense to have the same treatment.
512              *
513              * We choose to ignore the attribute which is added too late.
514              */
515             // Generate a warning of the ignored attributes
516 
517             // Create the warning message
518             String msg = Utils.messages.createMessage(
519                     MsgKey.ER_ILLEGAL_ATTRIBUTE_POSITION,new Object[]{ localName });
520 
521             try {
522                 // Prepare to issue the warning message
523                 Transformer tran = super.getTransformer();
524                 ErrorListener errHandler = tran.getErrorListener();
525 
526 
527                 // Issue the warning message
528                 if (null != errHandler &amp;&amp; m_sourceLocator != null)
529                   errHandler.warning(new TransformerException(msg, m_sourceLocator));
530                 else
531                   System.out.println(msg);
532                 }
533             catch (Exception e){}
534         }
535     }
536 
537     /**
538      * @see ExtendedContentHandler#endElement(String)
539      */
540     public void endElement(String elemName) throws SAXException
541     {
542         endElement(null, null, elemName);
543     }
544 
545     /**
546      * This method is used to notify the serializer of a namespace mapping (or node)
547      * that applies to the current element whose startElement() call has already been seen.
548      * The official SAX startPrefixMapping(prefix,uri) is to define a mapping for a child
549      * element that is soon to be seen with a startElement() call. The official SAX call
550      * does not apply to the current element, hence the reason for this method.
551      */
552     public void namespaceAfterStartElement(
553         final String prefix,
554         final String uri)
555         throws SAXException
556     {
557 
558         // hack for XSLTC with finding URI for default namespace
559         if (m_elemContext.m_elementURI == null)
560         {
561             String prefix1 = getPrefixPart(m_elemContext.m_elementName);
562             if (prefix1 == null &amp;&amp; EMPTYSTRING.equals(prefix))
563             {
564                 // the elements URI is not known yet, and it
565                 // doesn&#39;t have a prefix, and we are currently
566                 // setting the uri for prefix &quot;&quot;, so we have
567                 // the uri for the element... lets remember it
568                 m_elemContext.m_elementURI = uri;
569             }
570         }
571         startPrefixMapping(prefix,uri,false);
572         return;
573 
574     }
575 
576     /**
577      * From XSLTC
578      * Declare a prefix to point to a namespace URI. Inform SAX handler
579      * if this is a new prefix mapping.
580      */
581     protected boolean pushNamespace(String prefix, String uri)
582     {
583         try
584         {
585             if (m_prefixMap.pushNamespace(
586                 prefix, uri, m_elemContext.m_currentElemDepth))
587             {
588                 startPrefixMapping(prefix, uri);
589                 return true;
590             }
591         }
592         catch (SAXException e)
593         {
594             // falls through
595         }
596         return false;
597     }
598     /**
599      * Try&#39;s to reset the super class and reset this class for
600      * re-use, so that you don&#39;t need to create a new serializer
601      * (mostly for performance reasons).
602      *
603      * @return true if the class was successfuly reset.
604      */
605     public boolean reset()
606     {
607         boolean wasReset = false;
608         if (super.reset())
609         {
610             resetToXMLStream();
611             wasReset = true;
612         }
613         return wasReset;
614     }
615 
616     /**
617      * Reset all of the fields owned by ToStream class
618      *
619      */
620     private void resetToXMLStream()
621     {
622         this.m_cdataTagOpen = false;
623 
624     }
625 
626     /**
627      * This method checks for the XML version of output document.
628      * If XML version of output document is not specified, then output
629      * document is of version XML 1.0.
630      * If XML version of output doucment is specified, but it is not either
631      * XML 1.0 or XML 1.1, a warning message is generated, the XML Version of
632      * output document is set to XML 1.0 and processing continues.
633      * @return string (XML version)
634      */
635     private String getXMLVersion()
636     {
637         String xmlVersion = getVersion();
638         if(xmlVersion == null || xmlVersion.equals(XMLVERSION10))
639         {
640             xmlVersion = XMLVERSION10;
641         }
642         else if(xmlVersion.equals(XMLVERSION11))
643         {
644             xmlVersion = XMLVERSION11;
645         }
646         else
647         {
648             String msg = Utils.messages.createMessage(
649                                MsgKey.ER_XML_VERSION_NOT_SUPPORTED,new Object[]{ xmlVersion });
650             try
651             {
652                 // Prepare to issue the warning message
653                 Transformer tran = super.getTransformer();
654                 ErrorListener errHandler = tran.getErrorListener();
655                 // Issue the warning message
656                 if (null != errHandler &amp;&amp; m_sourceLocator != null)
657                     errHandler.warning(new TransformerException(msg, m_sourceLocator));
658                 else
659                     System.out.println(msg);
660             }
661             catch (Exception e){}
662             xmlVersion = XMLVERSION10;
663         }
664         return xmlVersion;
665     }
666 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
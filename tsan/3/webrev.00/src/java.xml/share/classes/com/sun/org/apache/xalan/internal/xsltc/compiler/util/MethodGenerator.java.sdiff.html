<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../XSLTC.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../dom/NodeSortRecord.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 /*
  21  * $Id: MethodGenerator.java,v 1.2.4.1 2005/09/05 11:16:47 pvedula Exp $
  22  */
</pre>
<hr />
<pre>
  58 import com.sun.org.apache.bcel.internal.generic.MethodGen;
  59 import com.sun.org.apache.bcel.internal.generic.NEW;
  60 import com.sun.org.apache.bcel.internal.generic.PUTFIELD;
  61 import com.sun.org.apache.bcel.internal.generic.RET;
  62 import com.sun.org.apache.bcel.internal.generic.Select;
  63 import com.sun.org.apache.bcel.internal.generic.TargetLostException;
  64 import com.sun.org.apache.bcel.internal.generic.Type;
  65 import com.sun.org.apache.xalan.internal.xsltc.compiler.Pattern;
  66 import com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC;
  67 import java.util.ArrayList;
  68 import java.util.Collections;
  69 import java.util.HashMap;
  70 import java.util.Iterator;
  71 import java.util.List;
  72 import java.util.Map;
  73 import java.util.Stack;
  74 
  75 /**
  76  * @author Jacek Ambroziak
  77  * @author Santiago Pericas-Geertsen
<span class="line-modified">  78  * @LastModified: Nov 2017</span>
  79  */
  80 public class MethodGenerator extends MethodGen
  81     implements com.sun.org.apache.xalan.internal.xsltc.compiler.Constants {
  82     protected static final int INVALID_INDEX   = -1;
  83 
  84     private static final String START_ELEMENT_SIG
  85         = &quot;(&quot; + STRING_SIG + &quot;)V&quot;;
  86     private static final String END_ELEMENT_SIG
  87         = START_ELEMENT_SIG;
  88 
  89     private static final int DOM_INDEX       = 1;
  90     private static final int ITERATOR_INDEX  = 2;
  91     private static final int HANDLER_INDEX   = 3;
  92 
  93     private static final int MAX_METHOD_SIZE = 65535;
  94     private static final int MAX_BRANCH_TARGET_OFFSET = 32767;
  95     private static final int MIN_BRANCH_TARGET_OFFSET = -32768;
  96 
  97     private static final int TARGET_METHOD_SIZE = 60000;
  98     private static final int MINIMUM_OUTLINEABLE_CHUNK_SIZE = 1000;
</pre>
<hr />
<pre>
 190 
 191         index = cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
 192                                           &quot;endDocument&quot;,
 193                                           &quot;()V&quot;);
 194         _endDocument = new INVOKEINTERFACE(index, 1);
 195 
 196 
 197         index = cpg.addInterfaceMethodref(NODE_ITERATOR,
 198                                           SET_START_NODE,
 199                                           SET_START_NODE_SIG);
 200         _setStartNode = new INVOKEINTERFACE(index, 2);
 201 
 202         index = cpg.addInterfaceMethodref(NODE_ITERATOR,
 203                                           &quot;reset&quot;, &quot;()&quot;+NODE_ITERATOR_SIG);
 204         _reset = new INVOKEINTERFACE(index, 1);
 205 
 206         index = cpg.addInterfaceMethodref(NODE_ITERATOR, NEXT, NEXT_SIG);
 207         _nextNode = new INVOKEINTERFACE(index, 1);
 208 
 209         _slotAllocator = new SlotAllocator();
<span class="line-modified"> 210         _slotAllocator.initialize(getLocalVariableRegistry().getLocals(false));</span>
 211         _allocatorInit = true;
 212     }
 213 
 214     /**
 215      * Allocates a local variable. If the slot allocator has already been
 216      * initialized, then call addLocalVariable2() so that the new variable
 217      * is known to the allocator. Failing to do this may cause the allocator
 218      * to return a slot that is already in use.
 219      */
 220     public LocalVariableGen addLocalVariable(String name, Type type,
 221                                              InstructionHandle start,
 222                                              InstructionHandle end)
 223     {
 224         LocalVariableGen lvg;
 225 
 226         if (_allocatorInit) {
 227             lvg = addLocalVariable2(name, type, start);
 228         } else {
 229             lvg = super.addLocalVariable(name, type, start, end);
 230             getLocalVariableRegistry().registerLocalVariable(lvg);
</pre>
<hr />
<pre>
 428          * Remove the mapping from the name of the specified
 429          * {@link LocalVariableGen} to itself.
 430          * See also {@link #registerByName(LocalVariableGen)} and
 431          * {@link #lookUpByName(String)}
 432          * @param lvg a &lt;code&gt;LocalVariableGen&lt;/code&gt;
 433          */
 434         @SuppressWarnings(&quot;unchecked&quot;)
 435         protected void removeByNameTracking(LocalVariableGen lvg) {
 436             Object duplicateNameEntry = _nameToLVGMap.get(lvg.getName());
 437 
 438             if (duplicateNameEntry instanceof ArrayList) {
 439                 List&lt;LocalVariableGen&gt; sameNameList =
 440                         (List&lt;LocalVariableGen&gt;)duplicateNameEntry;
 441                 for (int i = 0; i &lt; sameNameList.size(); i++) {
 442                     if (sameNameList.get(i) == lvg) {
 443                         sameNameList.remove(i);
 444                         break;
 445                     }
 446                 }
 447             } else {
<span class="line-modified"> 448                 _nameToLVGMap.remove(lvg);</span>
 449             }
 450         }
 451 
 452         /**
 453          * &lt;p&gt;Given the name of a variable, finds a {@link LocalVariableGen}
 454          * corresponding to it.&lt;/p&gt;
 455          * &lt;p&gt;See also {@link #registerByName(LocalVariableGen)} and
 456          * {@link #removeByNameTracking(LocalVariableGen)}&lt;/p&gt;
 457          * @param name
 458          * @return
 459          */
 460         @SuppressWarnings(&quot;unchecked&quot;)
 461         protected LocalVariableGen lookUpByName(String name) {
 462             LocalVariableGen lvg = null;
 463             Object duplicateNameEntry = _nameToLVGMap.get(name);
 464 
 465             if (duplicateNameEntry instanceof ArrayList) {
 466                 List&lt;LocalVariableGen&gt; sameNameList =
 467                         (List&lt;LocalVariableGen&gt;)duplicateNameEntry;
 468 
 469                 for (int i = 0; i &lt; sameNameList.size(); i++) {
 470                     lvg = sameNameList.get(i);
 471                     if (lvg.getName() == null ? name == null : lvg.getName().equals(name)) {
 472                         break;
 473                     }
 474                 }
 475             } else {
 476                 lvg = (LocalVariableGen) duplicateNameEntry;
 477             }
 478 
 479             return lvg;
 480         }
 481 
 482         /**
<span class="line-modified"> 483          * &lt;p&gt;Gets all {@link LocalVariableGen} objects for this method.&lt;/p&gt;</span>
<span class="line-modified"> 484          * &lt;p&gt;When the &lt;code&gt;includeRemoved&lt;/code&gt; argument has the value</span>
<span class="line-removed"> 485          * &lt;code&gt;false&lt;/code&gt;, this method replaces uses of</span>
<span class="line-removed"> 486          * {@link MethodGen#getLocalVariables()} which has</span>
 487          * a side-effect of setting the start and end range for any
<span class="line-modified"> 488          * &lt;code&gt;LocalVariableGen&lt;/code&gt; if either was &lt;code&gt;null&lt;/code&gt;.  That</span>
 489          * side-effect causes problems for outlining of code in XSLTC.
<span class="line-modified"> 490          * @param includeRemoved Specifies whether all local variables ever</span>
<span class="line-modified"> 491          * declared should be returned (&lt;code&gt;true&lt;/code&gt;) or only those not</span>
<span class="line-removed"> 492          * removed (&lt;code&gt;false&lt;/code&gt;)</span>
<span class="line-removed"> 493          * @return an array of &lt;code&gt;LocalVariableGen&lt;/code&gt; containing all the</span>
 494          * local variables
 495          */
 496         @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified"> 497         protected LocalVariableGen[] getLocals(boolean includeRemoved) {</span>
 498             LocalVariableGen[] locals = null;
 499             List&lt;LocalVariableGen&gt; allVarsEverDeclared = new ArrayList&lt;&gt;();
 500 
<span class="line-modified"> 501             if (includeRemoved) {</span>
<span class="line-modified"> 502                 int slotCount = allVarsEverDeclared.size();</span>
<span class="line-modified"> 503 </span>
<span class="line-modified"> 504                 for (int i = 0; i &lt; slotCount; i++) {</span>
<span class="line-modified"> 505                     Object slotEntries = _variables.get(i);</span>
<span class="line-modified"> 506                     if (slotEntries != null) {</span>
<span class="line-modified"> 507                         if (slotEntries instanceof ArrayList) {</span>
<span class="line-modified"> 508                             List&lt;LocalVariableGen&gt; slotList =</span>
<span class="line-removed"> 509                                     (List&lt;LocalVariableGen&gt;)slotEntries;</span>
<span class="line-removed"> 510 </span>
<span class="line-removed"> 511                             for (int j = 0; j &lt; slotList.size(); j++) {</span>
<span class="line-removed"> 512                                 allVarsEverDeclared.add(slotList.get(i));</span>
<span class="line-removed"> 513                             }</span>
<span class="line-removed"> 514                         } else {</span>
<span class="line-removed"> 515                             allVarsEverDeclared.add((LocalVariableGen)slotEntries);</span>
<span class="line-removed"> 516                         }</span>
<span class="line-removed"> 517                     }</span>
<span class="line-removed"> 518                 }</span>
<span class="line-removed"> 519             } else {</span>
<span class="line-removed"> 520                 for (Map.Entry&lt;String, Object&gt; nameVarsPair : _nameToLVGMap.entrySet()) {</span>
<span class="line-removed"> 521                     Object vars = nameVarsPair.getValue();</span>
<span class="line-removed"> 522                     if (vars != null) {</span>
<span class="line-removed"> 523                         if (vars instanceof ArrayList) {</span>
<span class="line-removed"> 524                             List&lt;LocalVariableGen&gt; varsList =</span>
<span class="line-removed"> 525                                     (List&lt;LocalVariableGen&gt;) vars;</span>
<span class="line-removed"> 526                             for (int i = 0; i &lt; varsList.size(); i++) {</span>
<span class="line-removed"> 527                                 allVarsEverDeclared.add(varsList.get(i));</span>
<span class="line-removed"> 528                             }</span>
<span class="line-removed"> 529                         } else {</span>
<span class="line-removed"> 530                             allVarsEverDeclared.add((LocalVariableGen)vars);</span>
 531                         }


 532                     }
 533                 }
 534             }
 535 
 536             locals = new LocalVariableGen[allVarsEverDeclared.size()];
 537             allVarsEverDeclared.toArray(locals);
 538 
 539             return locals;
 540         }
 541     }
 542 
 543     /**
 544      * Determines whether a particular variable is in use at a particular offset
 545      * in the byte code for this method.
 546      * &lt;p&gt;&lt;b&gt;Preconditions:&lt;/b&gt;
 547      * &lt;ul&gt;
 548      * &lt;li&gt;The {@link InstructionList#setPositions()} has been called for the
 549      * {@link InstructionList} associated with this {@link MethodGenerator}.
 550      * &lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
 551      * @param lvg the {@link LocalVariableGen} for the variable
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 /*
  21  * $Id: MethodGenerator.java,v 1.2.4.1 2005/09/05 11:16:47 pvedula Exp $
  22  */
</pre>
<hr />
<pre>
  58 import com.sun.org.apache.bcel.internal.generic.MethodGen;
  59 import com.sun.org.apache.bcel.internal.generic.NEW;
  60 import com.sun.org.apache.bcel.internal.generic.PUTFIELD;
  61 import com.sun.org.apache.bcel.internal.generic.RET;
  62 import com.sun.org.apache.bcel.internal.generic.Select;
  63 import com.sun.org.apache.bcel.internal.generic.TargetLostException;
  64 import com.sun.org.apache.bcel.internal.generic.Type;
  65 import com.sun.org.apache.xalan.internal.xsltc.compiler.Pattern;
  66 import com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC;
  67 import java.util.ArrayList;
  68 import java.util.Collections;
  69 import java.util.HashMap;
  70 import java.util.Iterator;
  71 import java.util.List;
  72 import java.util.Map;
  73 import java.util.Stack;
  74 
  75 /**
  76  * @author Jacek Ambroziak
  77  * @author Santiago Pericas-Geertsen
<span class="line-modified">  78  * @LastModified: July 2019</span>
  79  */
  80 public class MethodGenerator extends MethodGen
  81     implements com.sun.org.apache.xalan.internal.xsltc.compiler.Constants {
  82     protected static final int INVALID_INDEX   = -1;
  83 
  84     private static final String START_ELEMENT_SIG
  85         = &quot;(&quot; + STRING_SIG + &quot;)V&quot;;
  86     private static final String END_ELEMENT_SIG
  87         = START_ELEMENT_SIG;
  88 
  89     private static final int DOM_INDEX       = 1;
  90     private static final int ITERATOR_INDEX  = 2;
  91     private static final int HANDLER_INDEX   = 3;
  92 
  93     private static final int MAX_METHOD_SIZE = 65535;
  94     private static final int MAX_BRANCH_TARGET_OFFSET = 32767;
  95     private static final int MIN_BRANCH_TARGET_OFFSET = -32768;
  96 
  97     private static final int TARGET_METHOD_SIZE = 60000;
  98     private static final int MINIMUM_OUTLINEABLE_CHUNK_SIZE = 1000;
</pre>
<hr />
<pre>
 190 
 191         index = cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
 192                                           &quot;endDocument&quot;,
 193                                           &quot;()V&quot;);
 194         _endDocument = new INVOKEINTERFACE(index, 1);
 195 
 196 
 197         index = cpg.addInterfaceMethodref(NODE_ITERATOR,
 198                                           SET_START_NODE,
 199                                           SET_START_NODE_SIG);
 200         _setStartNode = new INVOKEINTERFACE(index, 2);
 201 
 202         index = cpg.addInterfaceMethodref(NODE_ITERATOR,
 203                                           &quot;reset&quot;, &quot;()&quot;+NODE_ITERATOR_SIG);
 204         _reset = new INVOKEINTERFACE(index, 1);
 205 
 206         index = cpg.addInterfaceMethodref(NODE_ITERATOR, NEXT, NEXT_SIG);
 207         _nextNode = new INVOKEINTERFACE(index, 1);
 208 
 209         _slotAllocator = new SlotAllocator();
<span class="line-modified"> 210         _slotAllocator.initialize(getLocalVariableRegistry().getLocals());</span>
 211         _allocatorInit = true;
 212     }
 213 
 214     /**
 215      * Allocates a local variable. If the slot allocator has already been
 216      * initialized, then call addLocalVariable2() so that the new variable
 217      * is known to the allocator. Failing to do this may cause the allocator
 218      * to return a slot that is already in use.
 219      */
 220     public LocalVariableGen addLocalVariable(String name, Type type,
 221                                              InstructionHandle start,
 222                                              InstructionHandle end)
 223     {
 224         LocalVariableGen lvg;
 225 
 226         if (_allocatorInit) {
 227             lvg = addLocalVariable2(name, type, start);
 228         } else {
 229             lvg = super.addLocalVariable(name, type, start, end);
 230             getLocalVariableRegistry().registerLocalVariable(lvg);
</pre>
<hr />
<pre>
 428          * Remove the mapping from the name of the specified
 429          * {@link LocalVariableGen} to itself.
 430          * See also {@link #registerByName(LocalVariableGen)} and
 431          * {@link #lookUpByName(String)}
 432          * @param lvg a &lt;code&gt;LocalVariableGen&lt;/code&gt;
 433          */
 434         @SuppressWarnings(&quot;unchecked&quot;)
 435         protected void removeByNameTracking(LocalVariableGen lvg) {
 436             Object duplicateNameEntry = _nameToLVGMap.get(lvg.getName());
 437 
 438             if (duplicateNameEntry instanceof ArrayList) {
 439                 List&lt;LocalVariableGen&gt; sameNameList =
 440                         (List&lt;LocalVariableGen&gt;)duplicateNameEntry;
 441                 for (int i = 0; i &lt; sameNameList.size(); i++) {
 442                     if (sameNameList.get(i) == lvg) {
 443                         sameNameList.remove(i);
 444                         break;
 445                     }
 446                 }
 447             } else {
<span class="line-modified"> 448                 _nameToLVGMap.remove(lvg.getName());</span>
 449             }
 450         }
 451 
 452         /**
 453          * &lt;p&gt;Given the name of a variable, finds a {@link LocalVariableGen}
 454          * corresponding to it.&lt;/p&gt;
 455          * &lt;p&gt;See also {@link #registerByName(LocalVariableGen)} and
 456          * {@link #removeByNameTracking(LocalVariableGen)}&lt;/p&gt;
 457          * @param name
 458          * @return
 459          */
 460         @SuppressWarnings(&quot;unchecked&quot;)
 461         protected LocalVariableGen lookUpByName(String name) {
 462             LocalVariableGen lvg = null;
 463             Object duplicateNameEntry = _nameToLVGMap.get(name);
 464 
 465             if (duplicateNameEntry instanceof ArrayList) {
 466                 List&lt;LocalVariableGen&gt; sameNameList =
 467                         (List&lt;LocalVariableGen&gt;)duplicateNameEntry;
 468 
 469                 for (int i = 0; i &lt; sameNameList.size(); i++) {
 470                     lvg = sameNameList.get(i);
 471                     if (lvg.getName() == null ? name == null : lvg.getName().equals(name)) {
 472                         break;
 473                     }
 474                 }
 475             } else {
 476                 lvg = (LocalVariableGen) duplicateNameEntry;
 477             }
 478 
 479             return lvg;
 480         }
 481 
 482         /**
<span class="line-modified"> 483          * Gets all {@link LocalVariableGen} objects.</span>
<span class="line-modified"> 484          * This method replaces {@link MethodGen#getLocalVariables()} which has</span>


 485          * a side-effect of setting the start and end range for any
<span class="line-modified"> 486          * {@code LocalVariableGen} if either was {@code null}.  That</span>
 487          * side-effect causes problems for outlining of code in XSLTC.
<span class="line-modified"> 488          *</span>
<span class="line-modified"> 489          * @return an array of {@code LocalVariableGen} containing all the</span>


 490          * local variables
 491          */
 492         @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified"> 493         private LocalVariableGen[] getLocals() {</span>
 494             LocalVariableGen[] locals = null;
 495             List&lt;LocalVariableGen&gt; allVarsEverDeclared = new ArrayList&lt;&gt;();
 496 
<span class="line-modified"> 497             for (Map.Entry&lt;String, Object&gt; nameVarsPair : _nameToLVGMap.entrySet()) {</span>
<span class="line-modified"> 498                 Object vars = nameVarsPair.getValue();</span>
<span class="line-modified"> 499                 if (vars != null) {</span>
<span class="line-modified"> 500                     if (vars instanceof ArrayList) {</span>
<span class="line-modified"> 501                         List&lt;LocalVariableGen&gt; varsList =</span>
<span class="line-modified"> 502                                 (List&lt;LocalVariableGen&gt;) vars;</span>
<span class="line-modified"> 503                         for (int i = 0; i &lt; varsList.size(); i++) {</span>
<span class="line-modified"> 504                             allVarsEverDeclared.add(varsList.get(i));</span>






















 505                         }
<span class="line-added"> 506                     } else {</span>
<span class="line-added"> 507                         allVarsEverDeclared.add((LocalVariableGen)vars);</span>
 508                     }
 509                 }
 510             }
 511 
 512             locals = new LocalVariableGen[allVarsEverDeclared.size()];
 513             allVarsEverDeclared.toArray(locals);
 514 
 515             return locals;
 516         }
 517     }
 518 
 519     /**
 520      * Determines whether a particular variable is in use at a particular offset
 521      * in the byte code for this method.
 522      * &lt;p&gt;&lt;b&gt;Preconditions:&lt;/b&gt;
 523      * &lt;ul&gt;
 524      * &lt;li&gt;The {@link InstructionList#setPositions()} has been called for the
 525      * {@link InstructionList} associated with this {@link MethodGenerator}.
 526      * &lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
 527      * @param lvg the {@link LocalVariableGen} for the variable
</pre>
</td>
</tr>
</table>
<center><a href="../XSLTC.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../dom/NodeSortRecord.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java b/src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java
--- a/src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java
@@ -81,24 +81,25 @@
 import javax.xml.transform.stax.StAXSource;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
 import jdk.xml.internal.JdkXmlFeatures;
 import jdk.xml.internal.JdkXmlUtils;
+import jdk.xml.internal.TransformErrorListener;
 import org.xml.sax.ContentHandler;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import org.xml.sax.XMLReader;
 import org.xml.sax.ext.LexicalHandler;
 
 /**
  * @author Morten Jorgensen
  * @author G. Todd Miller
  * @author Santiago Pericas-Geertsen
- * @LastModified: Feb 2019
+ * @LastModified: Aug 2019
  */
 public final class TransformerImpl extends Transformer
-    implements DOMCache, ErrorListener
+    implements DOMCache
 {
 
     private final static String LEXICAL_HANDLER_PROPERTY =
         "http://xml.org/sax/properties/lexical-handler";
 
@@ -126,14 +127,19 @@
     /**
      * The systemId set in input source.
      */
     private String _sourceSystemId = null;
 
+    /**
+     * Default error listener
+     */
+    private final ErrorListener _defaultListener = new TransformErrorListener();
+
     /**
      * An error listener for runtime errors.
      */
-    private ErrorListener _errorListener = this;
+    private ErrorListener _errorListener = _defaultListener;
 
     /**
      * A reference to a URI resolver for calls to document().
      */
     private URIResolver _uriResolver = null;
@@ -248,10 +254,14 @@
                 catch (TransformerException e) {
                     // ignored
                 }
             }
         }
+
+        public ErrorListener getErrorListener() {
+            return _errorListener;
+        }
     }
 
     protected TransformerImpl(Properties outputProperties, int indentNumber,
         TransformerFactoryImpl tfactory)
     {
@@ -262,10 +272,13 @@
 
     protected TransformerImpl(Translet translet, Properties outputProperties,
         int indentNumber, TransformerFactoryImpl tfactory)
     {
         _translet = (AbstractTranslet) translet;
+        if (_translet != null) {
+            _translet.setMessageHandler(new MessageHandler(_errorListener));
+        }
         _properties = createOutputProperties(outputProperties);
         _propertiesClone = (Properties) _properties.clone();
         _indentNumber = indentNumber;
         _tfactory = tfactory;
         _overrideDefaultParser = _tfactory.overrideDefaultParser();
@@ -398,11 +411,12 @@
         _method = (String) _properties.get(OutputKeys.METHOD);
 
         // Get encoding using getProperty() to use defaults
         _encoding = _properties.getProperty(OutputKeys.ENCODING);
 
-        _tohFactory = TransletOutputHandlerFactory.newInstance(_overrideDefaultParser);
+        _tohFactory = TransletOutputHandlerFactory
+                .newInstance(_overrideDefaultParser, _errorListener);
         _tohFactory.setEncoding(_encoding);
         if (_method != null) {
             _tohFactory.setOutputMethod(_method);
         }
 
@@ -827,12 +841,12 @@
             throw new IllegalArgumentException(err.toString());
         }
         _errorListener = listener;
 
         // Register a message handler to report xsl:messages
-    if (_translet != null)
-        _translet.setMessageHandler(new MessageHandler(_errorListener));
+        if (_translet != null)
+            _translet.setMessageHandler(new MessageHandler(_errorListener));
     }
 
     /**
      * Inform TrAX error listener of an error
      */
@@ -1350,94 +1364,10 @@
                 postErrorToListener("File not found: " + e.getMessage());
             return(null);
         }
     }
 
-    /**
-     * Receive notification of a recoverable error.
-     * The transformer must continue to provide normal parsing events after
-     * invoking this method. It should still be possible for the application
-     * to process the document through to the end.
-     *
-     * @param e The warning information encapsulated in a transformer
-     * exception.
-     * @throws TransformerException if the application chooses to discontinue
-     * the transformation (always does in our case).
-     */
-    @Override
-    public void error(TransformerException e)
-        throws TransformerException
-    {
-        Throwable wrapped = e.getException();
-        if (wrapped != null) {
-            System.err.println(new ErrorMsg(ErrorMsg.ERROR_PLUS_WRAPPED_MSG,
-                                            e.getMessageAndLocation(),
-                                            wrapped.getMessage()));
-        } else {
-            System.err.println(new ErrorMsg(ErrorMsg.ERROR_MSG,
-                                            e.getMessageAndLocation()));
-        }
-        throw e;
-    }
-
-    /**
-     * Receive notification of a non-recoverable error.
-     * The application must assume that the transformation cannot continue
-     * after the Transformer has invoked this method, and should continue
-     * (if at all) only to collect addition error messages. In fact,
-     * Transformers are free to stop reporting events once this method has
-     * been invoked.
-     *
-     * @param e The warning information encapsulated in a transformer
-     * exception.
-     * @throws TransformerException if the application chooses to discontinue
-     * the transformation (always does in our case).
-     */
-    @Override
-    public void fatalError(TransformerException e)
-        throws TransformerException
-    {
-        Throwable wrapped = e.getException();
-        if (wrapped != null) {
-            System.err.println(new ErrorMsg(ErrorMsg.FATAL_ERR_PLUS_WRAPPED_MSG,
-                                            e.getMessageAndLocation(),
-                                            wrapped.getMessage()));
-        } else {
-            System.err.println(new ErrorMsg(ErrorMsg.FATAL_ERR_MSG,
-                                            e.getMessageAndLocation()));
-        }
-        throw e;
-    }
-
-    /**
-     * Receive notification of a warning.
-     * Transformers can use this method to report conditions that are not
-     * errors or fatal errors. The default behaviour is to take no action.
-     * After invoking this method, the Transformer must continue with the
-     * transformation. It should still be possible for the application to
-     * process the document through to the end.
-     *
-     * @param e The warning information encapsulated in a transformer
-     * exception.
-     * @throws TransformerException if the application chooses to discontinue
-     * the transformation (never does in our case).
-     */
-    @Override
-    public void warning(TransformerException e)
-        throws TransformerException
-    {
-        Throwable wrapped = e.getException();
-        if (wrapped != null) {
-            System.err.println(new ErrorMsg(ErrorMsg.WARNING_PLUS_WRAPPED_MSG,
-                                            e.getMessageAndLocation(),
-                                            wrapped.getMessage()));
-        } else {
-            System.err.println(new ErrorMsg(ErrorMsg.WARNING_MSG,
-                                            e.getMessageAndLocation()));
-        }
-    }
-
     /**
      * This method resets  the Transformer to its original configuration
      * Transformer code is reset to the same state it was when it was
      * created
      * @since 1.5
@@ -1446,11 +1376,11 @@
     public void reset() {
 
         _method = null;
         _encoding = null;
         _sourceSystemId = null;
-        _errorListener = this;
+        _errorListener = _defaultListener;
         _uriResolver = null;
         _dom = null;
         _parameters = null;
         _indentNumber = -1;
         setOutputProperties (null);

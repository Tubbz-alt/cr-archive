<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToTextStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xml.internal.serializer;
 22 
 23 import java.io.IOException;
 24 
 25 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
 26 import com.sun.org.apache.xml.internal.serializer.utils.Utils;
<a name="2" id="anc2"></a><span class="line-added"> 27 import javax.xml.transform.ErrorListener;</span>
 28 import org.xml.sax.Attributes;
 29 import org.xml.sax.SAXException;
 30 
 31 /**
 32  * This class is not a public API.
 33  * It is only public because it is used in other packages.
 34  * This class converts SAX or SAX-like calls to a
 35  * serialized document for xsl:output method of &quot;text&quot;.
 36  * @xsl.usage internal
<a name="3" id="anc3"></a><span class="line-modified"> 37  * @LastModified: Aug 2019</span>
 38  */
 39 public final class ToTextStream extends ToStream
 40 {
 41 
 42 
 43   /**
 44    * Default constructor.
 45    */
 46   public ToTextStream()
 47   {
<a name="4" id="anc4"></a><span class="line-modified"> 48     this(null);</span>
<span class="line-added"> 49   }</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51   public ToTextStream(ErrorListener l)</span>
<span class="line-added"> 52   {</span>
<span class="line-added"> 53     super(l);</span>
 54   }
 55 
 56 
 57 
 58   /**
 59    * Receive notification of the beginning of a document.
 60    *
 61    * &lt;p&gt;The SAX parser will invoke this method only once, before any
 62    * other methods in this interface or in DTDHandler (except for
 63    * setDocumentLocator).&lt;/p&gt;
 64    *
 65    * @throws org.xml.sax.SAXException Any SAX exception, possibly
 66    *            wrapping another exception.
 67    *
 68    * @throws org.xml.sax.SAXException
 69    */
 70   protected void startDocumentInternal() throws org.xml.sax.SAXException
 71   {
 72     super.startDocumentInternal();
 73 
 74     m_needToCallStartDocument = false;
 75 
 76     // No action for the moment.
 77   }
 78 
 79   /**
 80    * Receive notification of the end of a document.
 81    *
 82    * &lt;p&gt;The SAX parser will invoke this method only once, and it will
 83    * be the last method invoked during the parse.  The parser shall
 84    * not invoke this method until it has either abandoned parsing
 85    * (because of an unrecoverable error) or reached the end of
 86    * input.&lt;/p&gt;
 87    *
 88    * @throws org.xml.sax.SAXException Any SAX exception, possibly
 89    *            wrapping another exception.
 90    *
 91    * @throws org.xml.sax.SAXException
 92    */
 93   public void endDocument() throws org.xml.sax.SAXException
 94   {
 95     flushPending();
 96     flushWriter();
 97     if (m_tracer != null)
 98         super.fireEndDoc();
 99   }
100 
101   /**
102    * Receive notification of the beginning of an element.
103    *
104    * &lt;p&gt;The Parser will invoke this method at the beginning of every
105    * element in the XML document; there will be a corresponding
106    * endElement() event for every startElement() event (even when the
107    * element is empty). All of the element&#39;s content will be
108    * reported, in order, before the corresponding endElement()
109    * event.&lt;/p&gt;
110    *
111    * &lt;p&gt;If the element name has a namespace prefix, the prefix will
112    * still be attached.  Note that the attribute list provided will
113    * contain only attributes with explicit values (specified or
114    * defaulted): #IMPLIED attributes will be omitted.&lt;/p&gt;
115    *
116    *
117    * @param namespaceURI The Namespace URI, or the empty string if the
118    *        element has no Namespace URI or if Namespace
119    *        processing is not being performed.
120    * @param localName The local name (without prefix), or the
121    *        empty string if Namespace processing is not being
122    *        performed.
123    * @param name The qualified name (with prefix), or the
124    *        empty string if qualified names are not available.
125    * @param atts The attributes attached to the element, if any.
126    * @throws org.xml.sax.SAXException Any SAX exception, possibly
127    *            wrapping another exception.
128    * @see #endElement
129    * @see org.xml.sax.AttributeList
130    *
131    * @throws org.xml.sax.SAXException
132    */
133   public void startElement(
134           String namespaceURI, String localName, String name, Attributes atts)
135             throws org.xml.sax.SAXException
136   {
137     // time to fire off startElement event
138     if (m_tracer != null) {
139         super.fireStartElem(name);
140         this.firePseudoAttributes();
141     }
142     return;
143   }
144 
145   /**
146    * Receive notification of the end of an element.
147    *
148    * &lt;p&gt;The SAX parser will invoke this method at the end of every
149    * element in the XML document; there will be a corresponding
150    * startElement() event for every endElement() event (even when the
151    * element is empty).&lt;/p&gt;
152    *
153    * &lt;p&gt;If the element name has a namespace prefix, the prefix will
154    * still be attached to the name.&lt;/p&gt;
155    *
156    *
157    * @param namespaceURI The Namespace URI, or the empty string if the
158    *        element has no Namespace URI or if Namespace
159    *        processing is not being performed.
160    * @param localName The local name (without prefix), or the
161    *        empty string if Namespace processing is not being
162    *        performed.
163    * @param name The qualified name (with prefix), or the
164    *        empty string if qualified names are not available.
165    * @throws org.xml.sax.SAXException Any SAX exception, possibly
166    *            wrapping another exception.
167    *
168    * @throws org.xml.sax.SAXException
169    */
170   public void endElement(String namespaceURI, String localName, String name)
171           throws org.xml.sax.SAXException
172   {
173         if (m_tracer != null)
174             super.fireEndElem(name);
175   }
176 
177   /**
178    * Receive notification of character data.
179    *
180    * &lt;p&gt;The Parser will call this method to report each chunk of
181    * character data.  SAX parsers may return all contiguous character
182    * data in a single chunk, or they may split it into several
183    * chunks; however, all of the characters in any single event
184    * must come from the same external entity, so that the Locator
185    * provides useful information.&lt;/p&gt;
186    *
187    * &lt;p&gt;The application must not attempt to read from the array
188    * outside of the specified range.&lt;/p&gt;
189    *
190    * &lt;p&gt;Note that some parsers will report whitespace using the
191    * ignorableWhitespace() method rather than this one (validating
192    * parsers must do so).&lt;/p&gt;
193    *
194    * @param ch The characters from the XML document.
195    * @param start The start position in the array.
196    * @param length The number of characters to read from the array.
197    * @throws org.xml.sax.SAXException Any SAX exception, possibly
198    *            wrapping another exception.
199    * @see #ignorableWhitespace
200    * @see org.xml.sax.Locator
201    */
202   public void characters(char ch[], int start, int length)
203           throws org.xml.sax.SAXException
204   {
205 
206     flushPending();
207 
208     try
209     {
210         if (inTemporaryOutputState()) {
211             /* leave characters un-processed as we are
212              * creating temporary output, the output generated by
213              * this serializer will be input to a final serializer
214              * later on and it will do the processing in final
215              * output state (not temporary output state).
216              *
217              * A &quot;temporary&quot; ToTextStream serializer is used to
218              * evaluate attribute value templates (for example),
219              * and the result of evaluating such a thing
220              * is fed into a final serializer later on.
221              */
222             m_writer.write(ch, start, length);
223         }
224         else {
225             // In final output state we do process the characters!
226             writeNormalizedChars(ch, start, length, m_lineSepUse);
227         }
228 
229         if (m_tracer != null)
230             super.fireCharEvent(ch, start, length);
231     }
232     catch(IOException ioe)
233     {
234       throw new SAXException(ioe);
235     }
236   }
237 
238   /**
239    * If available, when the disable-output-escaping attribute is used,
240    * output raw text without escaping.
241    *
242    * @param ch The characters from the XML document.
243    * @param start The start position in the array.
244    * @param length The number of characters to read from the array.
245    *
246    * @throws org.xml.sax.SAXException Any SAX exception, possibly
247    *            wrapping another exception.
248    */
249   public void charactersRaw(char ch[], int start, int length)
250           throws org.xml.sax.SAXException
251   {
252 
253     try
254     {
255       writeNormalizedChars(ch, start, length, m_lineSepUse);
256     }
257     catch(IOException ioe)
258     {
259       throw new SAXException(ioe);
260     }
261   }
262 
263     /**
264      * Normalize the characters, but don&#39;t escape.  Different from
265      * SerializerToXML#writeNormalizedChars because it does not attempt to do
266      * XML escaping at all.
267      *
268      * @param ch The characters from the XML document.
269      * @param start The start position in the array.
270      * @param length The number of characters to read from the array.
271      * @param useLineSep true if the operating systems
272      * end-of-line separator should be output rather than a new-line character.
273      *
274      * @throws IOException
275      * @throws org.xml.sax.SAXException
276      */
277     void writeNormalizedChars(
278         final char ch[],
279             final int start,
280             final int length,
281             final boolean useLineSep)
282             throws IOException, org.xml.sax.SAXException
283     {
284         final String encoding = getEncoding();
285         final java.io.Writer writer = m_writer;
286         final int end = start + length;
287 
288         /* copy a few &quot;constants&quot; before the loop for performance */
289         final char S_LINEFEED = CharInfo.S_LINEFEED;
290 
291         // This for() loop always increments i by one at the end
292         // of the loop.  Additional increments of i adjust for when
293         // two input characters (a high/low UTF16 surrogate pair)
294         // are processed.
295         for (int i = start; i &lt; end; i++) {
296             final char c = ch[i];
297 
298             if (S_LINEFEED == c &amp;&amp; useLineSep) {
299                 writer.write(m_lineSep, 0, m_lineSepLen);
300                 // one input char processed
301             } else if (m_encodingInfo.isInEncoding(c)) {
302                 writer.write(c);
303                 // one input char processed
304             } else if (Encodings.isHighUTF16Surrogate(c) ||
305                        Encodings.isLowUTF16Surrogate(c)) {
306                 final int codePoint = writeUTF16Surrogate(c, ch, i, end);
307                 if (codePoint &gt;= 0) {
308                     // move the index if the low surrogate is consumed
309                     // as writeUTF16Surrogate has written the pair
310                     if (Encodings.isHighUTF16Surrogate(c)) {
311                         i++;
312                     }
313 
314                     // printing to the console is not appropriate, but will leave
315                     // it as is for compatibility.
316                     if (codePoint &gt;0) {
317                         // I think we can just emit the message,
318                         // not crash and burn.
319                         final String integralValue = Integer.toString(codePoint);
320                         final String msg = Utils.messages.createMessage(
321                             MsgKey.ER_ILLEGAL_CHARACTER,
322                             new Object[] { integralValue, encoding });
323 
324                         //Older behavior was to throw the message,
325                         //but newer gentler behavior is to write a message to System.err
326                         //throw new SAXException(msg);
327                         System.err.println(msg);
328                     }
329                 }
330             } else {
331                 // Don&#39;t know what to do with this char, it is
332                 // not in the encoding and not a high char in
333                 // a surrogate pair, so write out as an entity ref
334                 if (encoding != null) {
335                     /* The output encoding is known,
336                      * so somthing is wrong.
337                      */
338 
339                     // not in the encoding, so write out a character reference
340                     writer.write(&#39;&amp;&#39;);
341                     writer.write(&#39;#&#39;);
342                     writer.write(Integer.toString(c));
343                     writer.write(&#39;;&#39;);
344 
345                     // I think we can just emit the message,
346                     // not crash and burn.
347                     final String integralValue = Integer.toString(c);
348                     final String msg = Utils.messages.createMessage(
349                         MsgKey.ER_ILLEGAL_CHARACTER,
350                         new Object[] { integralValue, encoding });
351 
352                     //Older behavior was to throw the message,
353                     //but newer gentler behavior is to write a message to System.err
354                     //throw new SAXException(msg);
355                     System.err.println(msg);
356                 } else {
357                     /* The output encoding is not known,
358                      * so just write it out as-is.
359                      */
360                     writer.write(c);
361                 }
362 
363                 // one input char was processed
364             }
365         }
366     }
367 
368   /**
369    * Receive notification of cdata.
370    *
371    * &lt;p&gt;The Parser will call this method to report each chunk of
372    * character data.  SAX parsers may return all contiguous character
373    * data in a single chunk, or they may split it into several
374    * chunks; however, all of the characters in any single event
375    * must come from the same external entity, so that the Locator
376    * provides useful information.&lt;/p&gt;
377    *
378    * &lt;p&gt;The application must not attempt to read from the array
379    * outside of the specified range.&lt;/p&gt;
380    *
381    * &lt;p&gt;Note that some parsers will report whitespace using the
382    * ignorableWhitespace() method rather than this one (validating
383    * parsers must do so).&lt;/p&gt;
384    *
385    * @param ch The characters from the XML document.
386    * @param start The start position in the array.
387    * @param length The number of characters to read from the array.
388    * @throws org.xml.sax.SAXException Any SAX exception, possibly
389    *            wrapping another exception.
390    * @see #ignorableWhitespace
391    * @see org.xml.sax.Locator
392    */
393   public void cdata(char ch[], int start, int length)
394           throws org.xml.sax.SAXException
395   {
396     try
397     {
398         writeNormalizedChars(ch, start, length, m_lineSepUse);
399         if (m_tracer != null)
400             super.fireCDATAEvent(ch, start, length);
401     }
402     catch(IOException ioe)
403     {
404       throw new SAXException(ioe);
405     }
406   }
407 
408   /**
409    * Receive notification of ignorable whitespace in element content.
410    *
411    * &lt;p&gt;Validating Parsers must use this method to report each chunk
412    * of ignorable whitespace (see the W3C XML 1.0 recommendation,
413    * section 2.10): non-validating parsers may also use this method
414    * if they are capable of parsing and using content models.&lt;/p&gt;
415    *
416    * &lt;p&gt;SAX parsers may return all contiguous whitespace in a single
417    * chunk, or they may split it into several chunks; however, all of
418    * the characters in any single event must come from the same
419    * external entity, so that the Locator provides useful
420    * information.&lt;/p&gt;
421    *
422    * &lt;p&gt;The application must not attempt to read from the array
423    * outside of the specified range.&lt;/p&gt;
424    *
425    * @param ch The characters from the XML document.
426    * @param start The start position in the array.
427    * @param length The number of characters to read from the array.
428    * @throws org.xml.sax.SAXException Any SAX exception, possibly
429    *            wrapping another exception.
430    * @see #characters
431    *
432    * @throws org.xml.sax.SAXException
433    */
434   public void ignorableWhitespace(char ch[], int start, int length)
435           throws org.xml.sax.SAXException
436   {
437 
438     try
439     {
440       writeNormalizedChars(ch, start, length, m_lineSepUse);
441     }
442     catch(IOException ioe)
443     {
444       throw new SAXException(ioe);
445     }
446   }
447 
448   /**
449    * Receive notification of a processing instruction.
450    *
451    * &lt;p&gt;The Parser will invoke this method once for each processing
452    * instruction found: note that processing instructions may occur
453    * before or after the main document element.&lt;/p&gt;
454    *
455    * &lt;p&gt;A SAX parser should never report an XML declaration (XML 1.0,
456    * section 2.8) or a text declaration (XML 1.0, section 4.3.1)
457    * using this method.&lt;/p&gt;
458    *
459    * @param target The processing instruction target.
460    * @param data The processing instruction data, or null if
461    *        none was supplied.
462    * @throws org.xml.sax.SAXException Any SAX exception, possibly
463    *            wrapping another exception.
464    *
465    * @throws org.xml.sax.SAXException
466    */
467   public void processingInstruction(String target, String data)
468           throws org.xml.sax.SAXException
469   {
470     // flush anything pending first
471     flushPending();
472 
473     if (m_tracer != null)
474         super.fireEscapingEvent(target, data);
475   }
476 
477   /**
478    * Called when a Comment is to be constructed.
479    * Note that Xalan will normally invoke the other version of this method.
480    * %REVIEW% In fact, is this one ever needed, or was it a mistake?
481    *
482    * @param   data  The comment data.
483    * @throws org.xml.sax.SAXException Any SAX exception, possibly
484    *            wrapping another exception.
485    */
486   public void comment(String data) throws org.xml.sax.SAXException
487   {
488       final int length = data.length();
489       if (length &gt; m_charsBuff.length)
490       {
491           m_charsBuff = new char[length*2 + 1];
492       }
493       data.getChars(0, length, m_charsBuff, 0);
494       comment(m_charsBuff, 0, length);
495   }
496 
497   /**
498    * Report an XML comment anywhere in the document.
499    *
500    * This callback will be used for comments inside or outside the
501    * document element, including comments in the external DTD
502    * subset (if read).
503    *
504    * @param ch An array holding the characters in the comment.
505    * @param start The starting position in the array.
506    * @param length The number of characters to use from the array.
507    * @throws org.xml.sax.SAXException The application may raise an exception.
508    */
509   public void comment(char ch[], int start, int length)
510           throws org.xml.sax.SAXException
511   {
512 
513     flushPending();
514     if (m_tracer != null)
515         super.fireCommentEvent(ch, start, length);
516   }
517 
518   /**
519    * Receive notivication of a entityReference.
520    *
521    * @param name non-null reference to the name of the entity.
522    *
523    * @throws org.xml.sax.SAXException
524    */
525   public void entityReference(String name) throws org.xml.sax.SAXException
526   {
527         if (m_tracer != null)
528             super.fireEntityReference(name);
529   }
530 
531     /**
532      * @see ExtendedContentHandler#addAttribute(String, String, String, String, String)
533      */
534     public void addAttribute(
535         String uri,
536         String localName,
537         String rawName,
538         String type,
539         String value,
540         boolean XSLAttribute)
541     {
542         // do nothing, just forget all about the attribute
543     }
544 
545     /**
546      * @see org.xml.sax.ext.LexicalHandler#endCDATA()
547      */
548     public void endCDATA() throws SAXException
549     {
550         // do nothing
551     }
552 
553     /**
554      * @see ExtendedContentHandler#endElement(String)
555      */
556     public void endElement(String elemName) throws SAXException
557     {
558         if (m_tracer != null)
559             super.fireEndElem(elemName);
560     }
561 
562     /**
563      * From XSLTC
564      */
565     public void startElement(
566     String elementNamespaceURI,
567     String elementLocalName,
568     String elementName)
569     throws SAXException
570     {
571         if (m_needToCallStartDocument)
572             startDocumentInternal();
573         // time to fire off startlement event.
574         if (m_tracer != null) {
575             super.fireStartElem(elementName);
576             this.firePseudoAttributes();
577         }
578 
579         return;
580     }
581 
582 
583     /**
584      * From XSLTC
585      */
586     public void characters(String characters)
587     throws SAXException
588     {
589         final int length = characters.length();
590         if (length &gt; m_charsBuff.length)
591         {
592             m_charsBuff = new char[length*2 + 1];
593         }
594         characters.getChars(0, length, m_charsBuff, 0);
595         characters(m_charsBuff, 0, length);
596     }
597 
598 
599     /**
600      * From XSLTC
601      */
602     public void addAttribute(String name, String value)
603     {
604         // do nothing, forget about the attribute
605     }
606 
607     /**
608      * Add a unique attribute
609      */
610     public void addUniqueAttribute(String qName, String value, int flags)
611         throws SAXException
612     {
613         // do nothing, forget about the attribute
614     }
615 
616     public boolean startPrefixMapping(
617         String prefix,
618         String uri,
619         boolean shouldFlush)
620         throws SAXException
621     {
622         // no namespace support for HTML
623         return false;
624     }
625 
626 
627     public void startPrefixMapping(String prefix, String uri)
628         throws org.xml.sax.SAXException
629     {
630         // no namespace support for HTML
631     }
632 
633 
634     public void namespaceAfterStartElement(
635         final String prefix,
636         final String uri)
637         throws SAXException
638     {
639         // no namespace support for HTML
640     }
641 
642     public void flushPending() throws org.xml.sax.SAXException
643     {
644             if (m_needToCallStartDocument)
645             {
646                 startDocumentInternal();
647                 m_needToCallStartDocument = false;
648             }
649     }
650 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
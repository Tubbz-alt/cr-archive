<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/FieldGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.ArrayList;
 23 import java.util.List;
<a name="2" id="anc2"></a>
 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
 27 import com.sun.org.apache.bcel.internal.classfile.Annotations;
 28 import com.sun.org.apache.bcel.internal.classfile.Attribute;
 29 import com.sun.org.apache.bcel.internal.classfile.Constant;
 30 import com.sun.org.apache.bcel.internal.classfile.ConstantObject;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 32 import com.sun.org.apache.bcel.internal.classfile.ConstantValue;
 33 import com.sun.org.apache.bcel.internal.classfile.Field;
 34 import com.sun.org.apache.bcel.internal.classfile.Utility;
 35 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 36 
 37 /**
<a name="3" id="anc3"></a><span class="line-modified"> 38  * Template class for building up a field. The only extraordinary thing one can</span>
<span class="line-modified"> 39  * do is to add a constant value attribute to a field (which must of course be</span>
<span class="line-modified"> 40  * compatible with to the declared type).</span>
 41  *
<a name="4" id="anc4"></a><span class="line-removed"> 42  * @version $Id: FieldGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 43  * @see Field
<a name="5" id="anc5"></a>
 44  */
 45 public class FieldGen extends FieldGenOrMethodGen {
 46 
 47     private Object value = null;
 48     private static BCELComparator bcelComparator = new BCELComparator() {
 49 
 50         @Override
<a name="6" id="anc6"></a><span class="line-modified"> 51         public boolean equals(final Object o1, final Object o2) {</span>
 52             final FieldGen THIS = (FieldGen) o1;
 53             final FieldGen THAT = (FieldGen) o2;
<a name="7" id="anc7"></a><span class="line-modified"> 54             return THIS.getName().equals(THAT.getName())</span>
<span class="line-modified"> 55                     &amp;&amp; THIS.getSignature().equals(THAT.getSignature());</span>
 56         }
 57 
<a name="8" id="anc8"></a>
 58         @Override
<a name="9" id="anc9"></a><span class="line-modified"> 59         public int hashCode(final Object o) {</span>
 60             final FieldGen THIS = (FieldGen) o;
 61             return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
 62         }
 63     };
 64 
<a name="10" id="anc10"></a>
 65     /**
<a name="11" id="anc11"></a><span class="line-modified"> 66      * Declare a field. If it is static (isStatic() == true) and has a basic</span>
<span class="line-modified"> 67      * type like int or String it may have an initial value associated with it</span>
<span class="line-modified"> 68      * as defined by setInitValue().</span>
 69      *
 70      * @param access_flags access qualifiers
<a name="12" id="anc12"></a><span class="line-modified"> 71      * @param type field type</span>
 72      * @param name field name
 73      * @param cp constant pool
 74      */
 75     public FieldGen(final int access_flags, final Type type, final String name, final ConstantPoolGen cp) {
 76         super(access_flags);
 77         setType(type);
 78         setName(name);
 79         setConstantPool(cp);
 80     }
 81 
<a name="13" id="anc13"></a>
 82     /**
 83      * Instantiate from existing field.
 84      *
 85      * @param field Field object
<a name="14" id="anc14"></a><span class="line-modified"> 86      * @param cp constant pool (must contain the same entries as the field&#39;s</span>
<span class="line-removed"> 87      * constant pool)</span>
 88      */
 89     public FieldGen(final Field field, final ConstantPoolGen cp) {
 90         this(field.getAccessFlags(), Type.getType(field.getSignature()), field.getName(), cp);
 91         final Attribute[] attrs = field.getAttributes();
 92         for (final Attribute attr : attrs) {
 93             if (attr instanceof ConstantValue) {
 94                 setValue(((ConstantValue) attr).getConstantValueIndex());
 95             } else if (attr instanceof Annotations) {
<a name="15" id="anc15"></a><span class="line-modified"> 96                 final Annotations runtimeAnnotations = (Annotations) attr;</span>
 97                 final AnnotationEntry[] annotationEntries = runtimeAnnotations.getAnnotationEntries();
 98                 for (final AnnotationEntry element : annotationEntries) {
<a name="16" id="anc16"></a><span class="line-modified"> 99                     addAnnotationEntry(new AnnotationEntryGen(element, cp, false));</span>
100                 }
101             } else {
102                 addAttribute(attr);
103             }
104         }
105     }
106 
<a name="17" id="anc17"></a><span class="line-modified">107     private void setValue(final int index) {</span>

108         final ConstantPool cp = super.getConstantPool().getConstantPool();
109         final Constant c = cp.getConstant(index);
110         value = ((ConstantObject) c).getConstantValue(cp);
111     }
112 
<a name="18" id="anc18"></a>
113     /**
<a name="19" id="anc19"></a><span class="line-modified">114      * Set (optional) initial value of field, otherwise it will be set to</span>
<span class="line-modified">115      * null/0/false by the JVM automatically.</span>
116      */
<a name="20" id="anc20"></a><span class="line-modified">117     public void setInitValue(final String str) {</span>
<span class="line-modified">118         checkType(ObjectType.getInstance(&quot;java.lang.String&quot;));</span>
119         if (str != null) {
120             value = str;
121         }
122     }
123 
<a name="21" id="anc21"></a><span class="line-modified">124     public void setInitValue(final long l) {</span>

125         checkType(Type.LONG);
126         if (l != 0L) {
<a name="22" id="anc22"></a><span class="line-modified">127             value = l;</span>
128         }
129     }
130 
<a name="23" id="anc23"></a><span class="line-modified">131     public void setInitValue(final int i) {</span>

132         checkType(Type.INT);
133         if (i != 0) {
<a name="24" id="anc24"></a><span class="line-modified">134             value = i;</span>
135         }
136     }
137 
<a name="25" id="anc25"></a><span class="line-modified">138     public void setInitValue(final short s) {</span>

139         checkType(Type.SHORT);
140         if (s != 0) {
<a name="26" id="anc26"></a><span class="line-modified">141             value = (int) s;</span>
142         }
143     }
144 
<a name="27" id="anc27"></a><span class="line-modified">145     public void setInitValue(final char c) {</span>

146         checkType(Type.CHAR);
147         if (c != 0) {
<a name="28" id="anc28"></a><span class="line-modified">148             value = (int) c;</span>
149         }
150     }
151 
<a name="29" id="anc29"></a><span class="line-modified">152     public void setInitValue(final byte b) {</span>

153         checkType(Type.BYTE);
154         if (b != 0) {
<a name="30" id="anc30"></a><span class="line-modified">155             value = (int) b;</span>
156         }
157     }
158 
<a name="31" id="anc31"></a><span class="line-modified">159     public void setInitValue(final boolean b) {</span>

160         checkType(Type.BOOLEAN);
161         if (b) {
<a name="32" id="anc32"></a><span class="line-modified">162             value = 1;</span>
163         }
164     }
165 
<a name="33" id="anc33"></a><span class="line-modified">166     public void setInitValue(final float f) {</span>

167         checkType(Type.FLOAT);
168         if (f != 0.0) {
169             value = f;
170         }
171     }
172 
<a name="34" id="anc34"></a><span class="line-modified">173     public void setInitValue(final double d) {</span>

174         checkType(Type.DOUBLE);
175         if (d != 0.0) {
176             value = d;
177         }
178     }
179 
<a name="35" id="anc35"></a><span class="line-modified">180     /**</span>
<span class="line-modified">181      * Remove any initial value.</span>
182      */
183     public void cancelInitValue() {
184         value = null;
185     }
186 
<a name="36" id="anc36"></a><span class="line-modified">187     private void checkType(final Type atype) {</span>

188         final Type superType = super.getType();
189         if (superType == null) {
190             throw new ClassGenException(&quot;You haven&#39;t defined the type of the field yet&quot;);
191         }
192         if (!isFinal()) {
193             throw new ClassGenException(&quot;Only final fields may have an initial value!&quot;);
194         }
195         if (!superType.equals(atype)) {
196             throw new ClassGenException(&quot;Types are not compatible: &quot; + superType + &quot; vs. &quot; + atype);
197         }
198     }
199 
<a name="37" id="anc37"></a>
200     /**
201      * Get field object after having set up all necessary values.
202      */
203     public Field getField() {
204         final String signature = getSignature();
205         final int name_index = super.getConstantPool().addUtf8(super.getName());
206         final int signature_index = super.getConstantPool().addUtf8(signature);
207         if (value != null) {
208             checkType(super.getType());
209             final int index = addConstant();
210             addAttribute(new ConstantValue(super.getConstantPool().addUtf8(&quot;ConstantValue&quot;), 2, index,
211                     super.getConstantPool().getConstantPool())); // sic
212         }
213         addAnnotationsAsAttribute(super.getConstantPool());
214         return new Field(super.getAccessFlags(), name_index, signature_index, getAttributes(),
215                 super.getConstantPool().getConstantPool()); // sic
216     }
217 
218     private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<a name="38" id="anc38"></a><span class="line-modified">219         final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
220         for (final Attribute attr : attrs) {
221             addAttribute(attr);
222         }
<a name="39" id="anc39"></a><span class="line-modified">223     }</span>

224 
225     private int addConstant() {
226         switch (super.getType().getType()) { // sic
227             case Const.T_INT:
228             case Const.T_CHAR:
229             case Const.T_BYTE:
230             case Const.T_BOOLEAN:
231             case Const.T_SHORT:
232                 return super.getConstantPool().addInteger(((Integer) value));
233             case Const.T_FLOAT:
234                 return super.getConstantPool().addFloat(((Float) value));
235             case Const.T_DOUBLE:
236                 return super.getConstantPool().addDouble(((Double) value));
237             case Const.T_LONG:
238                 return super.getConstantPool().addLong(((Long) value));
239             case Const.T_REFERENCE:
240                 return super.getConstantPool().addString((String) value);
241             default:
242                 throw new RuntimeException(&quot;Oops: Unhandled : &quot; + super.getType().getType()); // sic
243         }
244     }
245 
<a name="40" id="anc40"></a>
246     @Override
247     public String getSignature() {
248         return super.getType().getSignature();
249     }
250 
251     private List&lt;FieldObserver&gt; observers;
252 
<a name="41" id="anc41"></a><span class="line-modified">253     /**</span>
<span class="line-modified">254      * Add observer for this object.</span>
255      */
<a name="42" id="anc42"></a><span class="line-modified">256     public void addObserver(final FieldObserver o) {</span>
257         if (observers == null) {
258             observers = new ArrayList&lt;&gt;();
259         }
260         observers.add(o);
261     }
262 
<a name="43" id="anc43"></a><span class="line-modified">263     /**</span>
<span class="line-modified">264      * Remove observer for this object.</span>
265      */
<a name="44" id="anc44"></a><span class="line-modified">266     public void removeObserver(final FieldObserver o) {</span>
267         if (observers != null) {
268             observers.remove(o);
269         }
270     }
271 
<a name="45" id="anc45"></a><span class="line-modified">272     /**</span>
<span class="line-modified">273      * Call notify() method on all observers. This method is not called</span>
<span class="line-modified">274      * automatically whenever the state has changed, but has to be called by the</span>
<span class="line-modified">275      * user after he has finished editing the object.</span>
276      */
277     public void update() {
278         if (observers != null) {
<a name="46" id="anc46"></a><span class="line-modified">279             for (final FieldObserver observer : observers) {</span>
280                 observer.notify(this);
281             }
282         }
283     }
284 
<a name="47" id="anc47"></a>
285     public String getInitValue() {
286         if (value != null) {
287             return value.toString();
288         }
289         return null;
290     }
291 
<a name="48" id="anc48"></a>
292     /**
<a name="49" id="anc49"></a><span class="line-modified">293      * Return string representation close to declaration format, `public static</span>
<span class="line-modified">294      * final short MAX = 100&#39;, e.g..</span>
295      *
296      * @return String representation of field
297      */
298     @Override
299     public final String toString() {
300         String name;
301         String signature;
302         String access; // Short cuts to constant pool
303         access = Utility.accessToString(super.getAccessFlags());
304         access = access.isEmpty() ? &quot;&quot; : (access + &quot; &quot;);
305         signature = super.getType().toString();
306         name = getName();
307         final StringBuilder buf = new StringBuilder(32); // CHECKSTYLE IGNORE MagicNumber
308         buf.append(access).append(signature).append(&quot; &quot;).append(name);
309         final String value = getInitValue();
310         if (value != null) {
311             buf.append(&quot; = &quot;).append(value);
312         }
313         return buf.toString();
314     }
315 
<a name="50" id="anc50"></a><span class="line-modified">316     /**</span>
<span class="line-modified">317      * @return deep copy of this field</span>
318      */
<a name="51" id="anc51"></a><span class="line-modified">319     public FieldGen copy(final ConstantPoolGen cp) {</span>
320         final FieldGen fg = (FieldGen) clone();
321         fg.setConstantPool(cp);
322         return fg;
323     }
324 
<a name="52" id="anc52"></a>
325     /**
326      * @return Comparison strategy object
327      */
328     public static BCELComparator getComparator() {
329         return bcelComparator;
330     }
331 
<a name="53" id="anc53"></a>
332     /**
333      * @param comparator Comparison strategy object
334      */
<a name="54" id="anc54"></a><span class="line-modified">335     public static void setComparator(final BCELComparator comparator) {</span>
336         bcelComparator = comparator;
337     }
338 
<a name="55" id="anc55"></a>
339     /**
<a name="56" id="anc56"></a><span class="line-modified">340      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">341      * FieldGen objects are said to be equal when their names and signatures are</span>
<span class="line-modified">342      * equal.</span>
343      *
344      * @see java.lang.Object#equals(java.lang.Object)
345      */
346     @Override
<a name="57" id="anc57"></a><span class="line-modified">347     public boolean equals(final Object obj) {</span>
348         return bcelComparator.equals(this, obj);
349     }
350 
<a name="58" id="anc58"></a>
351     /**
<a name="59" id="anc59"></a><span class="line-modified">352      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">353      * return the hashcode of the field&#39;s name XOR signature.</span>
354      *
355      * @see java.lang.Object#hashCode()
356      */
357     @Override
358     public int hashCode() {
359         return bcelComparator.hashCode(this);
360     }
361 }
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
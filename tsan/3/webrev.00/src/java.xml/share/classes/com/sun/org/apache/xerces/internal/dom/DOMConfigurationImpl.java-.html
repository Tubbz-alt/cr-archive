<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/DOMConfigurationImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 import com.sun.org.apache.xerces.internal.impl.Constants;
  24 import com.sun.org.apache.xerces.internal.impl.XMLEntityManager;
  25 import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;
  26 import com.sun.org.apache.xerces.internal.impl.dv.DTDDVFactory;
  27 import com.sun.org.apache.xerces.internal.impl.msg.XMLMessageFormatter;
  28 import com.sun.org.apache.xerces.internal.impl.validation.ValidationManager;
  29 import com.sun.org.apache.xerces.internal.util.DOMEntityResolverWrapper;
  30 import com.sun.org.apache.xerces.internal.util.DOMErrorHandlerWrapper;
  31 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
  32 import com.sun.org.apache.xerces.internal.util.ParserConfigurationSettings;
  33 import com.sun.org.apache.xerces.internal.util.PropertyState;
  34 import com.sun.org.apache.xerces.internal.util.SymbolTable;
  35 import com.sun.org.apache.xerces.internal.utils.ObjectFactory;
  36 import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;
  37 import com.sun.org.apache.xerces.internal.utils.XMLSecurityPropertyManager;
  38 import com.sun.org.apache.xerces.internal.xni.XMLDTDContentModelHandler;
  39 import com.sun.org.apache.xerces.internal.xni.XMLDTDHandler;
  40 import com.sun.org.apache.xerces.internal.xni.XMLDocumentHandler;
  41 import com.sun.org.apache.xerces.internal.xni.XNIException;
  42 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarPool;
  43 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponent;
  44 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponentManager;
  45 import com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException;
  46 import com.sun.org.apache.xerces.internal.xni.parser.XMLEntityResolver;
  47 import com.sun.org.apache.xerces.internal.xni.parser.XMLErrorHandler;
  48 import com.sun.org.apache.xerces.internal.xni.parser.XMLInputSource;
  49 import com.sun.org.apache.xerces.internal.xni.parser.XMLParserConfiguration;
  50 import java.io.IOException;
  51 import java.util.ArrayList;
  52 import java.util.HashMap;
  53 import java.util.List;
  54 import java.util.Locale;
  55 import javax.xml.XMLConstants;
  56 import javax.xml.catalog.CatalogFeatures;
  57 import jdk.xml.internal.JdkXmlUtils;
  58 import org.w3c.dom.DOMConfiguration;
  59 import org.w3c.dom.DOMErrorHandler;
  60 import org.w3c.dom.DOMException;
  61 import org.w3c.dom.DOMStringList;
  62 import org.w3c.dom.ls.LSResourceResolver;
  63 
  64 
  65 
  66 /**
  67  * Xerces implementation of DOMConfiguration that maintains a table of recognized parameters.
  68  *
  69  * @xerces.internal
  70  *
  71  * @author Elena Litani, IBM
  72  * @author Neeraj Bajaj, Sun Microsystems.
  73  * @LastModified: Oct 2017
  74  */
  75 public class DOMConfigurationImpl extends ParserConfigurationSettings
  76     implements XMLParserConfiguration, DOMConfiguration {
  77 
  78     //
  79     // Constants
  80     //
  81 
  82     // feature identifiers
  83 
  84     /** Feature identifier: validation. */
  85     protected static final String XERCES_VALIDATION =
  86         Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
  87 
  88     /** Feature identifier: namespaces. */
  89     protected static final String XERCES_NAMESPACES =
  90         Constants.SAX_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE;
  91 
  92     protected static final String SCHEMA =
  93         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_VALIDATION_FEATURE;
  94 
  95     protected static final String SCHEMA_FULL_CHECKING =
  96         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_FULL_CHECKING;
  97 
  98     protected static final String DYNAMIC_VALIDATION =
  99         Constants.XERCES_FEATURE_PREFIX + Constants.DYNAMIC_VALIDATION_FEATURE;
 100 
 101     protected static final String NORMALIZE_DATA =
 102         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_NORMALIZED_VALUE;
 103 
 104     /** sending psvi in the pipeline */
 105     protected static final String SEND_PSVI =
 106         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_AUGMENT_PSVI;
 107 
 108     protected final static String DTD_VALIDATOR_FACTORY_PROPERTY =
 109         Constants.XERCES_PROPERTY_PREFIX + Constants.DATATYPE_VALIDATOR_FACTORY_PROPERTY;
 110 
 111     /** Feature identifier: namespace growth */
 112     protected static final String NAMESPACE_GROWTH =
 113         Constants.XERCES_FEATURE_PREFIX + Constants.NAMESPACE_GROWTH_FEATURE;
 114 
 115     protected static final String TOLERATE_DUPLICATES =
 116         Constants.XERCES_FEATURE_PREFIX + Constants.TOLERATE_DUPLICATES_FEATURE;
 117 
 118     // property identifiers
 119 
 120     /** Property identifier: entity manager. */
 121     protected static final String ENTITY_MANAGER =
 122         Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_MANAGER_PROPERTY;
 123 
 124     /** Property identifier: error reporter. */
 125     protected static final String ERROR_REPORTER =
 126         Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY;
 127 
 128     /** Property identifier: xml string. */
 129     protected static final String XML_STRING =
 130         Constants.SAX_PROPERTY_PREFIX + Constants.XML_STRING_PROPERTY;
 131 
 132     /** Property identifier: symbol table. */
 133     protected static final String SYMBOL_TABLE =
 134         Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY;
 135 
 136     /** Property id: Grammar pool*/
 137     protected static final String GRAMMAR_POOL =
 138     Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY;
 139 
 140     /** Property identifier: error handler. */
 141     protected static final String ERROR_HANDLER =
 142         Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_HANDLER_PROPERTY;
 143 
 144     /** Property identifier: entity resolver. */
 145     protected static final String ENTITY_RESOLVER =
 146         Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_RESOLVER_PROPERTY;
 147 
 148     /** Property identifier: JAXP schema language / DOM schema-type. */
 149     protected static final String JAXP_SCHEMA_LANGUAGE =
 150     Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE;
 151 
 152     /** Property identifier: JAXP schema source/ DOM schema-location. */
 153     protected static final String JAXP_SCHEMA_SOURCE =
 154     Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_SOURCE;
 155 
 156     protected static final String VALIDATION_MANAGER =
 157         Constants.XERCES_PROPERTY_PREFIX + Constants.VALIDATION_MANAGER_PROPERTY;
 158 
 159     /** Property identifier: Schema DV Factory */
 160     protected static final String SCHEMA_DV_FACTORY =
 161         Constants.XERCES_PROPERTY_PREFIX + Constants.SCHEMA_DV_FACTORY_PROPERTY;
 162 
 163     /** Property identifier: Security manager. */
 164     private static final String SECURITY_MANAGER = Constants.SECURITY_MANAGER;
 165 
 166     /** Property identifier: Security property manager. */
 167     private static final String XML_SECURITY_PROPERTY_MANAGER =
 168             Constants.XML_SECURITY_PROPERTY_MANAGER;
 169 
 170     //
 171     // Data
 172     //
 173     XMLDocumentHandler fDocumentHandler;
 174 
 175     /** Normalization features*/
 176     protected short features = 0;
 177 
 178     protected final static short NAMESPACES          = 0x1&lt;&lt;0;
 179     protected final static short DTNORMALIZATION     = 0x1&lt;&lt;1;
 180     protected final static short ENTITIES            = 0x1&lt;&lt;2;
 181     protected final static short CDATA               = 0x1&lt;&lt;3;
 182     protected final static short SPLITCDATA          = 0x1&lt;&lt;4;
 183     protected final static short COMMENTS            = 0x1&lt;&lt;5;
 184     protected final static short VALIDATE            = 0x1&lt;&lt;6;
 185     protected final static short PSVI                = 0x1&lt;&lt;7;
 186     protected final static short WELLFORMED          = 0x1&lt;&lt;8;
 187     protected final static short NSDECL              = 0x1&lt;&lt;9;
 188 
 189     protected final static short INFOSET_TRUE_PARAMS = NAMESPACES | COMMENTS | WELLFORMED | NSDECL;
 190     protected final static short INFOSET_FALSE_PARAMS = ENTITIES | DTNORMALIZATION | CDATA;
 191     protected final static short INFOSET_MASK = INFOSET_TRUE_PARAMS | INFOSET_FALSE_PARAMS;
 192 
 193     // components
 194 
 195     /** Symbol table. */
 196     protected SymbolTable fSymbolTable;
 197 
 198     /** Components. */
 199     protected List&lt;XMLComponent&gt; fComponents;
 200 
 201     protected ValidationManager fValidationManager;
 202 
 203     /** Locale. */
 204     protected Locale fLocale;
 205 
 206     /** Error reporter */
 207     protected XMLErrorReporter fErrorReporter;
 208 
 209     protected final DOMErrorHandlerWrapper fErrorHandlerWrapper =
 210                 new DOMErrorHandlerWrapper();
 211 
 212     // private data
 213 
 214     private DOMStringList fRecognizedParameters;
 215 
 216 
 217     //
 218     // Constructors
 219     //
 220 
 221     /** Default Constructor. */
 222     protected DOMConfigurationImpl() {
 223         this(null, null);
 224     } // &lt;init&gt;()
 225 
 226     /**
 227      * Constructs a parser configuration using the specified symbol table.
 228      *
 229      * @param symbolTable The symbol table to use.
 230      */
 231     protected DOMConfigurationImpl(SymbolTable symbolTable) {
 232         this(symbolTable, null);
 233     } // &lt;init&gt;(SymbolTable)
 234 
 235     /**
 236      * Constructs a parser configuration using the specified symbol table
 237      * and parent settings.
 238      *
 239      * @param symbolTable    The symbol table to use.
 240      * @param parentSettings The parent settings.
 241      */
 242     protected DOMConfigurationImpl(SymbolTable symbolTable,
 243                                     XMLComponentManager parentSettings) {
 244         super(parentSettings);
 245 
 246 
 247         // create table for features and properties
 248         fFeatures = new HashMap&lt;&gt;();
 249         fProperties = new HashMap&lt;&gt;();
 250 
 251         // add default recognized features
 252         final String[] recognizedFeatures = {
 253             XERCES_VALIDATION,
 254             XERCES_NAMESPACES,
 255             SCHEMA,
 256             SCHEMA_FULL_CHECKING,
 257             DYNAMIC_VALIDATION,
 258             NORMALIZE_DATA,
 259             SEND_PSVI,
 260             NAMESPACE_GROWTH,
 261             TOLERATE_DUPLICATES,
 262             XMLConstants.USE_CATALOG,
 263             JdkXmlUtils.OVERRIDE_PARSER
 264         };
 265         addRecognizedFeatures(recognizedFeatures);
 266 
 267         // set state for default features
 268         setFeature(XERCES_VALIDATION, false);
 269         setFeature(SCHEMA, false);
 270         setFeature(SCHEMA_FULL_CHECKING, false);
 271         setFeature(DYNAMIC_VALIDATION, false);
 272         setFeature(NORMALIZE_DATA, false);
 273         setFeature(XERCES_NAMESPACES, true);
 274         setFeature(SEND_PSVI, true);
 275         setFeature(NAMESPACE_GROWTH, false);
 276         setFeature(XMLConstants.USE_CATALOG, JdkXmlUtils.USE_CATALOG_DEFAULT);
 277         setFeature(JdkXmlUtils.OVERRIDE_PARSER, JdkXmlUtils.OVERRIDE_PARSER_DEFAULT);
 278 
 279         // add default recognized properties
 280         final String[] recognizedProperties = {
 281             XML_STRING,
 282             SYMBOL_TABLE,
 283             ERROR_HANDLER,
 284             ENTITY_RESOLVER,
 285             ERROR_REPORTER,
 286             ENTITY_MANAGER,
 287             VALIDATION_MANAGER,
 288             GRAMMAR_POOL,
 289             JAXP_SCHEMA_SOURCE,
 290             JAXP_SCHEMA_LANGUAGE,
 291             DTD_VALIDATOR_FACTORY_PROPERTY,
 292             SCHEMA_DV_FACTORY,
 293             SECURITY_MANAGER,
 294             XML_SECURITY_PROPERTY_MANAGER,
 295             JdkXmlUtils.CATALOG_DEFER,
 296             JdkXmlUtils.CATALOG_FILES,
 297             JdkXmlUtils.CATALOG_PREFER,
 298             JdkXmlUtils.CATALOG_RESOLVE,
 299             JdkXmlUtils.CDATA_CHUNK_SIZE
 300         };
 301         addRecognizedProperties(recognizedProperties);
 302 
 303         // set default values for normalization features
 304         features |= NAMESPACES;
 305         features |= ENTITIES;
 306         features |= COMMENTS;
 307         features |= CDATA;
 308         features |= SPLITCDATA;
 309         features |= WELLFORMED;
 310         features |= NSDECL;
 311 
 312         if (symbolTable == null) {
 313             symbolTable = new SymbolTable();
 314         }
 315         fSymbolTable = symbolTable;
 316 
 317         fComponents = new ArrayList&lt;&gt;();
 318 
 319         setProperty(SYMBOL_TABLE, fSymbolTable);
 320         fErrorReporter = new XMLErrorReporter();
 321         setProperty(ERROR_REPORTER, fErrorReporter);
 322         addComponent(fErrorReporter);
 323 
 324         setProperty(DTD_VALIDATOR_FACTORY_PROPERTY, DTDDVFactory.getInstance());
 325 
 326         XMLEntityManager manager =  new XMLEntityManager();
 327         setProperty(ENTITY_MANAGER, manager);
 328         addComponent(manager);
 329 
 330         fValidationManager = createValidationManager();
 331         setProperty(VALIDATION_MANAGER, fValidationManager);
 332 
 333         setProperty(SECURITY_MANAGER, new XMLSecurityManager(true));
 334 
 335         setProperty(Constants.XML_SECURITY_PROPERTY_MANAGER,
 336                 new XMLSecurityPropertyManager());
 337 
 338         // add message formatters
 339         if (fErrorReporter.getMessageFormatter(XMLMessageFormatter.XML_DOMAIN) == null) {
 340             XMLMessageFormatter xmft = new XMLMessageFormatter();
 341             fErrorReporter.putMessageFormatter(XMLMessageFormatter.XML_DOMAIN, xmft);
 342             fErrorReporter.putMessageFormatter(XMLMessageFormatter.XMLNS_DOMAIN, xmft);
 343         }
 344 
 345         // REVISIT: try to include XML Schema formatter.
 346         //          This is a hack to allow DTD configuration to be build.
 347         //
 348         if (fErrorReporter.getMessageFormatter(&quot;http://www.w3.org/TR/xml-schema-1&quot;) == null) {
 349             MessageFormatter xmft = null;
 350             try {
 351                xmft = (MessageFormatter)(
 352                     ObjectFactory.newInstance(&quot;com.sun.org.apache.xerces.internal.impl.xs.XSMessageFormatter&quot;, true));
 353             } catch (Exception exception){
 354             }
 355 
 356              if (xmft !=  null) {
 357                  fErrorReporter.putMessageFormatter(&quot;http://www.w3.org/TR/xml-schema-1&quot;, xmft);
 358              }
 359         }
 360 
 361 
 362         // set locale
 363         try {
 364             setLocale(Locale.getDefault());
 365         }
 366         catch (XNIException e) {
 367             // do nothing
 368             // REVISIT: What is the right thing to do? -Ac
 369         }
 370 
 371         // Initialize Catalog features
 372         for( CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {
 373             setProperty(f.getPropertyName(), null);
 374         }
 375 
 376         setProperty(JdkXmlUtils.CDATA_CHUNK_SIZE, JdkXmlUtils.CDATA_CHUNK_SIZE_DEFAULT);
 377     } // &lt;init&gt;(SymbolTable)
 378 
 379 
 380     //
 381     // XMLParserConfiguration methods
 382     //
 383 
 384     /**
 385      * Parse an XML document.
 386      * &lt;p&gt;
 387      * The parser can use this method to instruct this configuration
 388      * to begin parsing an XML document from any valid input source
 389      * (a character stream, a byte stream, or a URI).
 390      * &lt;p&gt;
 391      * Parsers may not invoke this method while a parse is in progress.
 392      * Once a parse is complete, the parser may then parse another XML
 393      * document.
 394      * &lt;p&gt;
 395      * This method is synchronous: it will not return until parsing
 396      * has ended.  If a client application wants to terminate
 397      * parsing early, it should throw an exception.
 398      *
 399      * @param source The input source for the top-level of the
 400      *               XML document.
 401      *
 402      * @exception XNIException Any XNI exception, possibly wrapping
 403      *                         another exception.
 404      * @exception IOException  An IO exception from the parser, possibly
 405      *                         from a byte stream or character stream
 406      *                         supplied by the parser.
 407      */
 408     public void parse(XMLInputSource inputSource)
 409         throws XNIException, IOException{
 410         // no-op
 411     }
 412 
 413     /**
 414      * Sets the document handler on the last component in the pipeline
 415      * to receive information about the document.
 416      *
 417      * @param documentHandler   The document handler.
 418      */
 419     public void setDocumentHandler(XMLDocumentHandler documentHandler) {
 420         fDocumentHandler = documentHandler;
 421     } // setDocumentHandler(XMLDocumentHandler)
 422 
 423     /** Returns the registered document handler. */
 424     public XMLDocumentHandler getDocumentHandler() {
 425         return fDocumentHandler;
 426     } // getDocumentHandler():XMLDocumentHandler
 427 
 428     /**
 429      * Sets the DTD handler.
 430      *
 431      * @param dtdHandler The DTD handler.
 432      */
 433     public void setDTDHandler(XMLDTDHandler dtdHandler) {
 434         //no-op
 435     } // setDTDHandler(XMLDTDHandler)
 436 
 437     /** Returns the registered DTD handler. */
 438     public XMLDTDHandler getDTDHandler() {
 439         return null;
 440     } // getDTDHandler():XMLDTDHandler
 441 
 442     /**
 443      * Sets the DTD content model handler.
 444      *
 445      * @param handler The DTD content model handler.
 446      */
 447     public void setDTDContentModelHandler(XMLDTDContentModelHandler handler) {
 448         //no-op
 449 
 450     } // setDTDContentModelHandler(XMLDTDContentModelHandler)
 451 
 452     /** Returns the registered DTD content model handler. */
 453     public XMLDTDContentModelHandler getDTDContentModelHandler() {
 454         return null;
 455     } // getDTDContentModelHandler():XMLDTDContentModelHandler
 456 
 457     /**
 458      * Sets the resolver used to resolve external entities. The EntityResolver
 459      * interface supports resolution of public and system identifiers.
 460      *
 461      * @param resolver The new entity resolver. Passing a null value will
 462      *                 uninstall the currently installed resolver.
 463      */
 464     public void setEntityResolver(XMLEntityResolver resolver) {
 465         if (resolver !=null) {
 466             fProperties.put(ENTITY_RESOLVER, resolver);
 467         }
 468     } // setEntityResolver(XMLEntityResolver)
 469 
 470     /**
 471      * Return the current entity resolver.
 472      *
 473      * @return The current entity resolver, or null if none
 474      *         has been registered.
 475      * @see #setEntityResolver
 476      */
 477     public XMLEntityResolver getEntityResolver() {
 478         return (XMLEntityResolver)fProperties.get(ENTITY_RESOLVER);
 479     } // getEntityResolver():XMLEntityResolver
 480 
 481     /**
 482      * Allow an application to register an error event handler.
 483      *
 484      * &lt;p&gt;If the application does not register an error handler, all
 485      * error events reported by the SAX parser will be silently
 486      * ignored; however, normal processing may not continue.  It is
 487      * highly recommended that all SAX applications implement an
 488      * error handler to avoid unexpected bugs.&lt;/p&gt;
 489      *
 490      * &lt;p&gt;Applications may register a new or different handler in the
 491      * middle of a parse, and the SAX parser must begin using the new
 492      * handler immediately.&lt;/p&gt;
 493      *
 494      * @param errorHandler The error handler.
 495      * @exception java.lang.NullPointerException If the handler
 496      *            argument is null.
 497      * @see #getErrorHandler
 498      */
 499     public void setErrorHandler(XMLErrorHandler errorHandler) {
 500         if (errorHandler != null) {
 501             fProperties.put(ERROR_HANDLER, errorHandler);
 502         }
 503     } // setErrorHandler(XMLErrorHandler)
 504 
 505     /**
 506      * Return the current error handler.
 507      *
 508      * @return The current error handler, or null if none
 509      *         has been registered.
 510      * @see #setErrorHandler
 511      */
 512     public XMLErrorHandler getErrorHandler() {
 513         return (XMLErrorHandler)fProperties.get(ERROR_HANDLER);
 514     } // getErrorHandler():XMLErrorHandler
 515 
 516     /**
 517      * Set the state of a feature.
 518      *
 519      * Set the state of any feature in a SAX2 parser.  The parser
 520      * might not recognize the feature, and if it does recognize
 521      * it, it might not be able to fulfill the request.
 522      *
 523      * @param featureId The unique identifier (URI) of the feature.
 524      * @param state The requested state of the feature (true or false).
 525      *
 526      * @exception com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException If the
 527      *            requested feature is not known.
 528      */
 529     public void setFeature(String featureId, boolean state)
 530         throws XMLConfigurationException {
 531 
 532         // save state if noone &quot;objects&quot;
 533         super.setFeature(featureId, state);
 534 
 535     } // setFeature(String,boolean)
 536 
 537     /**
 538      * setProperty
 539      *
 540      * @param propertyId
 541      * @param value
 542      */
 543     public void setProperty(String propertyId, Object value)
 544         throws XMLConfigurationException {
 545 
 546         // store value if noone &quot;objects&quot;
 547         super.setProperty(propertyId, value);
 548 
 549     } // setProperty(String,Object)
 550 
 551     /**
 552      * Set the locale to use for messages.
 553      *
 554      * @param locale The locale object to use for localization of messages.
 555      *
 556      * @exception XNIException Thrown if the parser does not support the
 557      *                         specified locale.
 558      */
 559     public void setLocale(Locale locale) throws XNIException {
 560         fLocale = locale;
 561         fErrorReporter.setLocale(locale);
 562 
 563     } // setLocale(Locale)
 564 
 565     /** Returns the locale. */
 566     public Locale getLocale() {
 567         return fLocale;
 568     } // getLocale():Locale
 569 
 570     /**
 571      * DOM Level 3 WD - Experimental.
 572      * setParameter
 573      */
 574     public void setParameter(String name, Object value) throws DOMException {
 575         boolean found = true;
 576 
 577         // REVISIT: Recognizes DOM L3 default features only.
 578         //          Does not yet recognize Xerces features.
 579                 if(value instanceof Boolean){
 580                         boolean state = ((Boolean)value).booleanValue();
 581 
 582             if (name.equalsIgnoreCase(Constants.DOM_COMMENTS)) {
 583                 features = (short) (state ? features | COMMENTS : features &amp; ~COMMENTS);
 584             }
 585             else if (name.equalsIgnoreCase(Constants.DOM_DATATYPE_NORMALIZATION)) {
 586                 setFeature(NORMALIZE_DATA, state);
 587                 features =
 588                     (short) (state ? features | DTNORMALIZATION : features &amp; ~DTNORMALIZATION);
 589                 if (state) {
 590                     features = (short) (features | VALIDATE);
 591                 }
 592             }
 593             else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACES)) {
 594                 features = (short) (state ? features | NAMESPACES : features &amp; ~NAMESPACES);
 595             }
 596             else if (name.equalsIgnoreCase(Constants.DOM_CDATA_SECTIONS)) {
 597                 features = (short) (state ? features | CDATA : features &amp; ~CDATA);
 598             }
 599             else if (name.equalsIgnoreCase(Constants.DOM_ENTITIES)) {
 600                 features = (short) (state ? features | ENTITIES : features &amp; ~ENTITIES);
 601             }
 602             else if (name.equalsIgnoreCase(Constants.DOM_SPLIT_CDATA)) {
 603                 features = (short) (state ? features | SPLITCDATA : features &amp; ~SPLITCDATA);
 604             }
 605             else if (name.equalsIgnoreCase(Constants.DOM_VALIDATE)) {
 606                 features = (short) (state ? features | VALIDATE : features &amp; ~VALIDATE);
 607             }
 608             else if (name.equalsIgnoreCase(Constants.DOM_WELLFORMED)) {
 609                 features = (short) (state ? features | WELLFORMED : features &amp; ~WELLFORMED );
 610             }
 611             else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACE_DECLARATIONS)) {
 612                 features = (short) (state ? features | NSDECL : features &amp; ~NSDECL);
 613             }
 614             else if (name.equalsIgnoreCase(Constants.DOM_INFOSET)) {
 615                 // Setting to false has no effect.
 616                 if (state) {
 617                     features = (short) (features | INFOSET_TRUE_PARAMS);
 618                     features = (short) (features &amp; ~INFOSET_FALSE_PARAMS);
 619                     setFeature(NORMALIZE_DATA, false);
 620                 }
 621             }
 622             else if (name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)
 623                     || name.equalsIgnoreCase(Constants.DOM_CANONICAL_FORM)
 624                     || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA)
 625                     || name.equalsIgnoreCase(Constants.DOM_CHECK_CHAR_NORMALIZATION)
 626                     ) {
 627                 if (state) { // true is not supported
 628                     String msg =
 629                         DOMMessageFormatter.formatMessage(
 630                             DOMMessageFormatter.DOM_DOMAIN,
 631                             &quot;FEATURE_NOT_SUPPORTED&quot;,
 632                             new Object[] { name });
 633                     throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
 634                 }
 635             }
 636                         else if ( name.equalsIgnoreCase(Constants.DOM_ELEMENT_CONTENT_WHITESPACE)) {
 637                 if (!state) { // false is not supported
 638                     String msg =
 639                         DOMMessageFormatter.formatMessage(
 640                             DOMMessageFormatter.DOM_DOMAIN,
 641                             &quot;FEATURE_NOT_SUPPORTED&quot;,
 642                             new Object[] { name });
 643                    throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
 644                 }
 645             }
 646             else if (name.equalsIgnoreCase(SEND_PSVI) ){
 647                 // REVISIT: turning augmentation of PSVI is not support,
 648                 // because in this case we won&#39;t be able to retrieve element
 649                 // default value.
 650                 if (!state) { // false is not supported
 651                     String msg =
 652                         DOMMessageFormatter.formatMessage(
 653                             DOMMessageFormatter.DOM_DOMAIN,
 654                             &quot;FEATURE_NOT_SUPPORTED&quot;,
 655                             new Object[] { name });
 656                     throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
 657                 }
 658             }
 659             else if (name.equalsIgnoreCase(Constants.DOM_PSVI)){
 660                   features = (short) (state ? features | PSVI : features &amp; ~PSVI);
 661             }
 662             else {
 663                 found = false;
 664                 /*
 665                 String msg =
 666                     DOMMessageFormatter.formatMessage(
 667                         DOMMessageFormatter.DOM_DOMAIN,
 668                         &quot;FEATURE_NOT_FOUND&quot;,
 669                         new Object[] { name });
 670                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 671                 */
 672             }
 673 
 674         }
 675 
 676                 if (!found || !(value instanceof Boolean))  { // set properties
 677                         found = true;
 678 
 679             if (name.equalsIgnoreCase(Constants.DOM_ERROR_HANDLER)) {
 680                 if (value instanceof DOMErrorHandler || value == null) {
 681                     fErrorHandlerWrapper.setErrorHandler((DOMErrorHandler)value);
 682                     setErrorHandler(fErrorHandlerWrapper);
 683                 }
 684 
 685                 else {
 686                     // REVISIT: type mismatch
 687                     String msg =
 688                         DOMMessageFormatter.formatMessage(
 689                             DOMMessageFormatter.DOM_DOMAIN,
 690                             &quot;TYPE_MISMATCH_ERR&quot;,
 691                             new Object[] { name });
 692                     throw new DOMException(DOMException.TYPE_MISMATCH_ERR, msg);
 693                 }
 694             }
 695             else if (name.equalsIgnoreCase(Constants.DOM_RESOURCE_RESOLVER)) {
 696                 if (value instanceof LSResourceResolver || value == null) {
 697                     try {
 698                         setEntityResolver(new DOMEntityResolverWrapper((LSResourceResolver) value));
 699                     }
 700                     catch (XMLConfigurationException e) {}
 701                 }
 702                 else {
 703                     // REVISIT: type mismatch
 704                     String msg =
 705                         DOMMessageFormatter.formatMessage(
 706                             DOMMessageFormatter.DOM_DOMAIN,
 707                             &quot;TYPE_MISMATCH_ERR&quot;,
 708                             new Object[] { name });
 709                     throw new DOMException(DOMException.TYPE_MISMATCH_ERR, msg);
 710                 }
 711 
 712             }
 713             else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_LOCATION)) {
 714                 if (value instanceof String || value == null) {
 715                     try {
 716                         // map DOM schema-location to JAXP schemaSource property
 717                         setProperty(
 718                             Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_SOURCE,
 719                             value);
 720                     }
 721                     catch (XMLConfigurationException e) {}
 722                 }
 723                 else {
 724                     // REVISIT: type mismatch
 725                     String msg =
 726                         DOMMessageFormatter.formatMessage(
 727                             DOMMessageFormatter.DOM_DOMAIN,
 728                             &quot;TYPE_MISMATCH_ERR&quot;,
 729                             new Object[] { name });
 730                     throw new DOMException(DOMException.TYPE_MISMATCH_ERR, msg);
 731                 }
 732 
 733             }
 734             else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_TYPE)) {
 735                 if (value instanceof String || value == null) {
 736                     try {
 737                         if (value == null) {
 738                             setProperty(
 739                                 Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE,
 740                                 null);
 741                         }
 742                         else if (value.equals(Constants.NS_XMLSCHEMA)) {
 743                             // REVISIT: when add support to DTD validation
 744                             setProperty(
 745                                 Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE,
 746                                 Constants.NS_XMLSCHEMA);
 747                         }
 748                         else if (value.equals(Constants.NS_DTD)) {
 749                             // Added support for revalidation against DTDs
 750                                 setProperty(Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE,
 751                                                 Constants.NS_DTD);
 752                         }
 753                     }
 754                     catch (XMLConfigurationException e) {}
 755                 }
 756                 else {
 757                     String msg =
 758                         DOMMessageFormatter.formatMessage(
 759                             DOMMessageFormatter.DOM_DOMAIN,
 760                             &quot;TYPE_MISMATCH_ERR&quot;,
 761                             new Object[] { name });
 762                     throw new DOMException(DOMException.TYPE_MISMATCH_ERR, msg);
 763                 }
 764 
 765             }
 766             else if (name.equalsIgnoreCase(SYMBOL_TABLE)){
 767                 // Xerces Symbol Table
 768                 if (value instanceof SymbolTable){
 769                     setProperty(SYMBOL_TABLE, value);
 770                 }
 771                 else {
 772                     // REVISIT: type mismatch
 773                     String msg =
 774                         DOMMessageFormatter.formatMessage(
 775                             DOMMessageFormatter.DOM_DOMAIN,
 776                             &quot;TYPE_MISMATCH_ERR&quot;,
 777                             new Object[] { name });
 778                     throw new DOMException(DOMException.TYPE_MISMATCH_ERR, msg);
 779                 }
 780             }
 781             else if (name.equalsIgnoreCase (GRAMMAR_POOL)){
 782                 if (value instanceof XMLGrammarPool){
 783                     setProperty(GRAMMAR_POOL, value);
 784                 }
 785                 else {
 786                     // REVISIT: type mismatch
 787                     String msg =
 788                         DOMMessageFormatter.formatMessage(
 789                             DOMMessageFormatter.DOM_DOMAIN,
 790                             &quot;TYPE_MISMATCH_ERR&quot;,
 791                             new Object[] { name });
 792                     throw new DOMException(DOMException.TYPE_MISMATCH_ERR, msg);
 793                 }
 794 
 795             }
 796             else {
 797                 // REVISIT: check if this is a boolean parameter -- type mismatch should be thrown.
 798                 //parameter is not recognized
 799                 String msg =
 800                     DOMMessageFormatter.formatMessage(
 801                         DOMMessageFormatter.DOM_DOMAIN,
 802                         &quot;FEATURE_NOT_FOUND&quot;,
 803                         new Object[] { name });
 804                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 805             }
 806         }
 807 
 808     }
 809 
 810 
 811     /**
 812      * DOM Level 3 WD - Experimental.
 813      * getParameter
 814      */
 815         public Object getParameter(String name) throws DOMException {
 816 
 817                 // REVISIT: Recognizes DOM L3 default features only.
 818                 //          Does not yet recognize Xerces features.
 819 
 820                 if (name.equalsIgnoreCase(Constants.DOM_COMMENTS)) {
 821                         return ((features &amp; COMMENTS) != 0) ? Boolean.TRUE : Boolean.FALSE;
 822                 }
 823                 else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACES)) {
 824                         return (features &amp; NAMESPACES) != 0 ? Boolean.TRUE : Boolean.FALSE;
 825                 }
 826                 else if (name.equalsIgnoreCase(Constants.DOM_DATATYPE_NORMALIZATION)) {
 827                         // REVISIT: datatype-normalization only takes effect if validation is on
 828                         return (features &amp; DTNORMALIZATION) != 0 ? Boolean.TRUE : Boolean.FALSE;
 829                 }
 830                 else if (name.equalsIgnoreCase(Constants.DOM_CDATA_SECTIONS)) {
 831                         return (features &amp; CDATA) != 0 ? Boolean.TRUE : Boolean.FALSE;
 832                 }
 833                 else if (name.equalsIgnoreCase(Constants.DOM_ENTITIES)) {
 834                         return (features &amp; ENTITIES) != 0 ? Boolean.TRUE : Boolean.FALSE;
 835                 }
 836                 else if (name.equalsIgnoreCase(Constants.DOM_SPLIT_CDATA)) {
 837                         return (features &amp; SPLITCDATA) != 0 ? Boolean.TRUE : Boolean.FALSE;
 838                 }
 839                 else if (name.equalsIgnoreCase(Constants.DOM_VALIDATE)) {
 840                         return (features &amp; VALIDATE) != 0 ? Boolean.TRUE : Boolean.FALSE;
 841                 }
 842                 else if (name.equalsIgnoreCase(Constants.DOM_WELLFORMED)) {
 843                         return (features &amp; WELLFORMED) != 0 ? Boolean.TRUE : Boolean.FALSE;
 844                 }
 845                 else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACE_DECLARATIONS)) {
 846                     return (features &amp; NSDECL) != 0 ? Boolean.TRUE : Boolean.FALSE;
 847                 }
 848                 else if (name.equalsIgnoreCase(Constants.DOM_INFOSET)) {
 849                         return (features &amp; INFOSET_MASK) == INFOSET_TRUE_PARAMS ? Boolean.TRUE : Boolean.FALSE;
 850                 }
 851                 else if (name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)
 852                                 || name.equalsIgnoreCase(Constants.DOM_CANONICAL_FORM)
 853                                 || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA)
 854                                 || name.equalsIgnoreCase(Constants.DOM_CHECK_CHAR_NORMALIZATION)
 855                 ) {
 856                         return Boolean.FALSE;
 857                 }
 858         else if (name.equalsIgnoreCase(SEND_PSVI)) {
 859             return Boolean.TRUE;
 860         }
 861         else if (name.equalsIgnoreCase(Constants.DOM_PSVI)) {
 862             return (features &amp; PSVI) != 0 ? Boolean.TRUE : Boolean.FALSE;
 863         }
 864         else if (name.equalsIgnoreCase(Constants.DOM_ELEMENT_CONTENT_WHITESPACE)) {
 865                         return Boolean.TRUE;
 866                 }
 867                 else if (name.equalsIgnoreCase(Constants.DOM_ERROR_HANDLER)) {
 868             return fErrorHandlerWrapper.getErrorHandler();
 869                 }
 870                 else if (name.equalsIgnoreCase(Constants.DOM_RESOURCE_RESOLVER)) {
 871                         XMLEntityResolver entityResolver = getEntityResolver();
 872                         if (entityResolver != null &amp;&amp; entityResolver instanceof DOMEntityResolverWrapper) {
 873                                 return ((DOMEntityResolverWrapper) entityResolver).getEntityResolver();
 874                         }
 875                         return null;
 876                 }
 877                 else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_TYPE)) {
 878                         return getProperty(Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE);
 879                 }
 880                 else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_LOCATION)) {
 881                         return getProperty(Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_SOURCE);
 882                 }
 883         else if (name.equalsIgnoreCase(SYMBOL_TABLE)){
 884             return getProperty(SYMBOL_TABLE);
 885         }
 886         else if (name.equalsIgnoreCase(GRAMMAR_POOL)){
 887             return getProperty(GRAMMAR_POOL);
 888         }
 889                 else {
 890                         String msg =
 891                                 DOMMessageFormatter.formatMessage(
 892                                         DOMMessageFormatter.DOM_DOMAIN,
 893                                         &quot;FEATURE_NOT_FOUND&quot;,
 894                                         new Object[] { name });
 895                         throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 896                 }
 897 
 898         }
 899 
 900     /**
 901      * DOM Level 3 WD - Experimental.
 902      * Check if setting a parameter to a specific value is supported.
 903      *
 904      * @param name The name of the parameter to check.
 905      *
 906      * @param value An object. if null, the returned value is true.
 907      *
 908      * @return true if the parameter could be successfully set to the
 909      * specified value, or false if the parameter is not recognized or
 910      * the requested value is not supported. This does not change the
 911      * current value of the parameter itself.
 912      */
 913         public boolean canSetParameter(String name, Object value) {
 914 
 915         if (value == null){
 916             //if null, the returned value is true.
 917             //REVISIT: I dont like this --- even for unrecognized parameter it would
 918             //return &#39;true&#39;. I think it should return false in that case.
 919             // Application will be surprised to find that setParameter throws not
 920             //recognized exception when canSetParameter returns &#39;true&#39; Then what is the use
 921             //of having canSetParameter ??? - nb.
 922             return true ;
 923         }
 924         if( value instanceof Boolean ){
 925             //features whose parameter value can be set either &#39;true&#39; or &#39;false&#39;
 926             // or they accept any boolean value -- so we just need to check that
 927             // its a boolean value..
 928             if (name.equalsIgnoreCase(Constants.DOM_COMMENTS)
 929                 || name.equalsIgnoreCase(Constants.DOM_DATATYPE_NORMALIZATION)
 930                 || name.equalsIgnoreCase(Constants.DOM_CDATA_SECTIONS)
 931                 || name.equalsIgnoreCase(Constants.DOM_ENTITIES)
 932                 || name.equalsIgnoreCase(Constants.DOM_SPLIT_CDATA)
 933                 || name.equalsIgnoreCase(Constants.DOM_NAMESPACES)
 934                 || name.equalsIgnoreCase(Constants.DOM_VALIDATE)
 935                 || name.equalsIgnoreCase(Constants.DOM_WELLFORMED)
 936                 || name.equalsIgnoreCase(Constants.DOM_INFOSET)
 937                 || name.equalsIgnoreCase(Constants.DOM_NAMESPACE_DECLARATIONS)
 938                 ) {
 939                 return true;
 940             }//features whose parameter value can not be set to &#39;true&#39;
 941             else if (
 942                 name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)
 943                     || name.equalsIgnoreCase(Constants.DOM_CANONICAL_FORM)
 944                     || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA)
 945                     || name.equalsIgnoreCase(Constants.DOM_CHECK_CHAR_NORMALIZATION)
 946                     ) {
 947                     return (value.equals(Boolean.TRUE)) ? false : true;
 948             }//features whose parameter value can not be set to &#39;false&#39;
 949             else if( name.equalsIgnoreCase(Constants.DOM_ELEMENT_CONTENT_WHITESPACE)
 950                     || name.equalsIgnoreCase(SEND_PSVI)
 951                     ) {
 952                     return (value.equals(Boolean.TRUE)) ? true : false;
 953             }// if name is not among the above listed above -- its not recognized. return false
 954             else {
 955                 return false ;
 956             }
 957         }
 958                 else if (name.equalsIgnoreCase(Constants.DOM_ERROR_HANDLER)) {
 959             return (value instanceof DOMErrorHandler) ? true : false ;
 960         }
 961         else if (name.equalsIgnoreCase(Constants.DOM_RESOURCE_RESOLVER)) {
 962             return (value instanceof LSResourceResolver) ? true : false ;
 963         }
 964         else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_LOCATION)) {
 965             return (value instanceof String) ? true : false ;
 966         }
 967         else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_TYPE)) {
 968             // REVISIT: should null value be supported?
 969             //as of now we are only supporting W3C XML Schema
 970             return ( (value instanceof String) &amp;&amp; value.equals(Constants.NS_XMLSCHEMA) ) ? true : false ;
 971         }
 972         else if (name.equalsIgnoreCase(SYMBOL_TABLE)){
 973             // Xerces Symbol Table
 974             return (value instanceof SymbolTable) ? true : false ;
 975         }
 976         else if (name.equalsIgnoreCase (GRAMMAR_POOL)){
 977             return (value instanceof XMLGrammarPool) ? true : false ;
 978         }
 979         else {
 980             //false if the parameter is not recognized or the requested value is not supported.
 981             return false ;
 982         }
 983 
 984         } //canSetParameter
 985 
 986     /**
 987      *  DOM Level 3 CR - Experimental.
 988      *
 989      *  The list of the parameters supported by this
 990      * &lt;code&gt;DOMConfiguration&lt;/code&gt; object and for which at least one value
 991      * can be set by the application. Note that this list can also contain
 992      * parameter names defined outside this specification.
 993      */
 994     public DOMStringList getParameterNames() {
 995         if (fRecognizedParameters == null){
 996             List&lt;String&gt; parameters = new ArrayList&lt;&gt;();
 997 
 998             //Add DOM recognized parameters
 999             //REVISIT: Would have been nice to have a list of
1000             //recognized paramters.
1001             parameters.add(Constants.DOM_COMMENTS);
1002             parameters.add(Constants.DOM_DATATYPE_NORMALIZATION);
1003             parameters.add(Constants.DOM_CDATA_SECTIONS);
1004             parameters.add(Constants.DOM_ENTITIES);
1005             parameters.add(Constants.DOM_SPLIT_CDATA);
1006             parameters.add(Constants.DOM_NAMESPACES);
1007             parameters.add(Constants.DOM_VALIDATE);
1008 
1009             parameters.add(Constants.DOM_INFOSET);
1010             parameters.add(Constants.DOM_NORMALIZE_CHARACTERS);
1011             parameters.add(Constants.DOM_CANONICAL_FORM);
1012             parameters.add(Constants.DOM_VALIDATE_IF_SCHEMA);
1013             parameters.add(Constants.DOM_CHECK_CHAR_NORMALIZATION);
1014             parameters.add(Constants.DOM_WELLFORMED);
1015 
1016             parameters.add(Constants.DOM_NAMESPACE_DECLARATIONS);
1017             parameters.add(Constants.DOM_ELEMENT_CONTENT_WHITESPACE);
1018 
1019             parameters.add(Constants.DOM_ERROR_HANDLER);
1020             parameters.add(Constants.DOM_SCHEMA_TYPE);
1021             parameters.add(Constants.DOM_SCHEMA_LOCATION);
1022             parameters.add(Constants.DOM_RESOURCE_RESOLVER);
1023 
1024             //Add recognized xerces features and properties
1025             parameters.add(GRAMMAR_POOL);
1026             parameters.add(SYMBOL_TABLE);
1027             parameters.add(SEND_PSVI);
1028 
1029             fRecognizedParameters = new DOMStringListImpl(parameters);
1030         }
1031 
1032         return fRecognizedParameters;
1033     }//getParameterNames
1034 
1035     //
1036     // Protected methods
1037     //
1038 
1039     /**
1040      * reset all components before parsing
1041      */
1042     protected void reset() throws XNIException {
1043 
1044         if (fValidationManager != null)
1045             fValidationManager.reset();
1046 
1047         int count = fComponents.size();
1048         for (int i = 0; i &lt; count; i++) {
1049             XMLComponent c = fComponents.get(i);
1050             c.reset(this);
1051         }
1052 
1053     } // reset()
1054 
1055     /**
1056      * Check a property. If the property is known and supported, this method
1057      * simply returns. Otherwise, the appropriate exception is thrown.
1058      *
1059      * @param propertyId The unique identifier (URI) of the property
1060      *                   being set.
1061      * @exception com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException If the
1062      *            requested feature is not known or supported.
1063      */
1064     protected PropertyState checkProperty(String propertyId)
1065         throws XMLConfigurationException {
1066 
1067         // special cases
1068         if (propertyId.startsWith(Constants.SAX_PROPERTY_PREFIX)) {
1069             final int suffixLength = propertyId.length() - Constants.SAX_PROPERTY_PREFIX.length();
1070 
1071             //
1072             // http://xml.org/sax/properties/xml-string
1073             // Value type: String
1074             // Access: read-only
1075             //   Get the literal string of characters associated with the
1076             //   current event.  If the parser recognises and supports this
1077             //   property but is not currently parsing text, it should return
1078             //   null (this is a good way to check for availability before the
1079             //   parse begins).
1080             //
1081             if (suffixLength == Constants.XML_STRING_PROPERTY.length() &amp;&amp;
1082                 propertyId.endsWith(Constants.XML_STRING_PROPERTY)) {
1083                 // REVISIT - we should probably ask xml-dev for a precise
1084                 // definition of what this is actually supposed to return, and
1085                 // in exactly which circumstances.
1086                 return PropertyState.NOT_SUPPORTED;
1087             }
1088         }
1089 
1090         // check property
1091         return super.checkProperty(propertyId);
1092 
1093     } // checkProperty(String)
1094 
1095 
1096     protected void addComponent(XMLComponent component) {
1097 
1098         // don&#39;t add a component more than once
1099         if (fComponents.contains(component)) {
1100             return;
1101         }
1102         fComponents.add(component);
1103 
1104         // register component&#39;s recognized features
1105         String[] recognizedFeatures = component.getRecognizedFeatures();
1106         addRecognizedFeatures(recognizedFeatures);
1107 
1108         // register component&#39;s recognized properties
1109         String[] recognizedProperties = component.getRecognizedProperties();
1110         addRecognizedProperties(recognizedProperties);
1111 
1112     } // addComponent(XMLComponent)
1113 
1114     protected ValidationManager createValidationManager(){
1115         return new ValidationManager();
1116     }
1117 
1118 } // class XMLParser
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Select.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.io.DataOutputStream;
 23 import java.io.IOException;
 24 
 25 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 26 
 27 /**
 28  * Select - Abstract super class for LOOKUPSWITCH and TABLESWITCH instructions.
 29  *
 30  * &lt;p&gt;
 31  * We use our super&#39;s &lt;code&gt;target&lt;/code&gt; property as the default target.
 32  *
 33  * @version $Id: Select.java 1749603 2016-06-21 20:50:19Z ggregory $
 34  * @see LOOKUPSWITCH
 35  * @see TABLESWITCH
 36  * @see InstructionList
 37  */
 38 public abstract class Select extends BranchInstruction implements VariableLengthInstruction,
 39         StackConsumer /* @since 6.0 */, StackProducer {
 40 
 41     private int[] match; // matches, i.e., case 1: ... TODO could be package-protected?
 42     private int[] indices; // target offsets TODO could be package-protected?
 43     private InstructionHandle[] targets; // target objects in instruction list TODO could be package-protected?
 44     private int fixed_length; // fixed length defined by subclasses TODO could be package-protected?
 45     private int match_length; // number of cases TODO could be package-protected?
 46     private int padding = 0; // number of pad bytes for alignment TODO could be package-protected?
 47 
 48     /**
 49      * Empty constructor needed for the Class.newInstance() statement in
 50      * Instruction.readInstruction(). Not to be used otherwise.
 51      */
 52     Select() {
 53     }
 54 
 55     /**
 56      * (Match, target) pairs for switch. `Match&#39; and `targets&#39; must have the
 57      * same length of course.
 58      *
 59      * @param match array of matching values
 60      * @param targets instruction targets
 61      * @param defaultTarget default instruction target
 62      */
 63     Select(final short opcode, final int[] match, final InstructionHandle[] targets, final InstructionHandle defaultTarget) {
 64         // don&#39;t set default target before instuction is built
 65         super(opcode, null);
 66         this.match = match;
 67         this.targets = targets;
 68         // now it&#39;s safe to set default target
 69         setTarget(defaultTarget);
 70         for (final InstructionHandle target2 : targets) {
 71             notifyTarget(null, target2, this);
 72         }
 73         if ((match_length = match.length) != targets.length) {
 74             throw new ClassGenException(&quot;Match and target array have not the same length: Match length: &quot;
 75                     + match.length + &quot; Target length: &quot; + targets.length);
 76         }
 77         indices = new int[match_length];
 78     }
 79 
 80     /**
 81      * Since this is a variable length instruction, it may shift the following
 82      * instructions which then need to update their position.
 83      *
 84      * Called by InstructionList.setPositions when setting the position for
 85      * every instruction. In the presence of variable length instructions
 86      * `setPositions&#39; performs multiple passes over the instruction list to
 87      * calculate the correct (byte) positions and offsets by calling this
 88      * function.
 89      *
 90      * @param offset additional offset caused by preceding (variable length)
 91      * instructions
 92      * @param max_offset the maximum offset that may be caused by these
 93      * instructions
 94      * @return additional offset caused by possible change of this instruction&#39;s
 95      * length
 96      */
 97     @Override
 98     protected int updatePosition(final int offset, final int max_offset) {
 99         setPosition(getPosition() + offset); // Additional offset caused by preceding SWITCHs, GOTOs, etc.
100         final short old_length = (short) super.getLength();
101         /* Alignment on 4-byte-boundary, + 1, because of tag byte.
102          */
103         padding = (4 - ((getPosition() + 1) % 4)) % 4;
104         super.setLength((short) (fixed_length + padding)); // Update length
105         return super.getLength() - old_length;
106     }
107 
108     /**
109      * Dump instruction as byte code to stream out.
110      *
111      * @param out Output stream
112      */
113     @Override
114     public void dump(final DataOutputStream out) throws IOException {
115         out.writeByte(super.getOpcode());
116         for (int i = 0; i &lt; padding; i++) {
117             out.writeByte(0);
118         }
119         super.setIndex(getTargetOffset()); // Write default target offset
120         out.writeInt(super.getIndex());
121     }
122 
123     /**
124      * Read needed data (e.g. index) from file.
125      */
126     @Override
127     protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {
128         padding = (4 - (bytes.getIndex() % 4)) % 4; // Compute number of pad bytes
129         for (int i = 0; i &lt; padding; i++) {
130             bytes.readByte();
131         }
132         // Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)
133         super.setIndex(bytes.readInt());
134     }
135 
136     /**
137      * @return mnemonic for instruction
138      */
139     @Override
140     public String toString(final boolean verbose) {
141         final StringBuilder buf = new StringBuilder(super.toString(verbose));
142         if (verbose) {
143             for (int i = 0; i &lt; match_length; i++) {
144                 String s = &quot;null&quot;;
145                 if (targets[i] != null) {
146                     s = targets[i].getInstruction().toString();
147                 }
148                 buf.append(&quot;(&quot;).append(match[i]).append(&quot;, &quot;).append(s).append(&quot; = {&quot;).append(
149                         indices[i]).append(&quot;})&quot;);
150             }
151         } else {
152             buf.append(&quot; ...&quot;);
153         }
154         return buf.toString();
155     }
156 
157     /**
158      * Set branch target for `i&#39;th case
159      */
160     public void setTarget(final int i, final InstructionHandle target) { // TODO could be package-protected?
161         notifyTarget(targets[i], target, this);
162         targets[i] = target;
163     }
164 
165     /**
166      * @param old_ih old target
167      * @param new_ih new target
168      */
169     @Override
170     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {
171         boolean targeted = false;
172         if (super.getTarget() == old_ih) {
173             targeted = true;
174             setTarget(new_ih);
175         }
176         for (int i = 0; i &lt; targets.length; i++) {
177             if (targets[i] == old_ih) {
178                 targeted = true;
179                 setTarget(i, new_ih);
180             }
181         }
182         if (!targeted) {
183             throw new ClassGenException(&quot;Not targeting &quot; + old_ih);
184         }
185     }
186 
187     /**
188      * @return true, if ih is target of this instruction
189      */
190     @Override
191     public boolean containsTarget(final InstructionHandle ih) {
192         if (super.getTarget() == ih) {
193             return true;
194         }
195         for (final InstructionHandle target2 : targets) {
196             if (target2 == ih) {
197                 return true;
198             }
199         }
200         return false;
201     }
202 
203     @Override
204     protected Object clone() throws CloneNotSupportedException {
205         final Select copy = (Select) super.clone();
206         copy.match = match.clone();
207         copy.indices = indices.clone();
208         copy.targets = targets.clone();
209         return copy;
210     }
211 
212     /**
213      * Inform targets that they&#39;re not targeted anymore.
214      */
215     @Override
216     void dispose() {
217         super.dispose();
218         for (final InstructionHandle target2 : targets) {
219             target2.removeTargeter(this);
220         }
221     }
222 
223     /**
224      * @return array of match indices
225      */
226     public int[] getMatchs() {
227         return match;
228     }
229 
230     /**
231      * @return array of match target offsets
232      */
233     public int[] getIndices() {
234         return indices;
235     }
236 
237     /**
238      * @return array of match targets
239      */
240     public InstructionHandle[] getTargets() {
241         return targets;
242     }
243 
244     /**
245      * @return match entry
246      * @since 6.0
247      */
248     final int getMatch(final int index) {
249         return match[index];
250     }
251 
252     /**
253      * @return index entry from indices
254      * @since 6.0
255      */
256     final int getIndices(final int index) {
257         return indices[index];
258     }
259 
260     /**
261      * @return target entry
262      * @since 6.0
263      */
264     final InstructionHandle getTarget(final int index) {
265         return targets[index];
266     }
267 
268     /**
269      * @return the fixed_length
270      * @since 6.0
271      */
272     final int getFixed_length() {
273         return fixed_length;
274     }
275 
276     /**
277      * @param fixed_length the fixed_length to set
278      * @since 6.0
279      */
280     final void setFixed_length(final int fixed_length) {
281         this.fixed_length = fixed_length;
282     }
283 
284     /**
285      * @return the match_length
286      * @since 6.0
287      */
288     final int getMatch_length() {
289         return match_length;
290     }
291 
292     /**
293      * @param match_length the match_length to set
294      * @since 6.0
295      */
296     final int setMatch_length(final int match_length) {
297         this.match_length = match_length;
298         return match_length;
299     }
300 
301     /**
302      *
303      * @param index
304      * @param value
305      * @since 6.0
306      */
307     final void setMatch(final int index, final int value) {
308         match[index] = value;
309     }
310 
311     /**
312      *
313      * @param array
314      * @since 6.0
315      */
316     final void setIndices(final int[] array) {
317         indices = array;
318     }
319 
320     /**
321      *
322      * @param array
323      * @since 6.0
324      */
325     final void setMatches(final int[] array) {
326         match = array;
327     }
328 
329     /**
330      *
331      * @param array
332      * @since 6.0
333      */
334     final void setTargets(final InstructionHandle[] array) {
335         targets = array;
336     }
337 
338     /**
339      *
340      * @return the padding
341      * @since 6.0
342      */
343     final int getPadding() {
344         return padding;
345     }
346 
347     /**
348      * @since 6.0
349      */
350     final int setIndices(final int i, final int value) {
351         indices[i] = value;
352         return value;  // Allow use in nested calls
353     }
354 }
    </pre>
  </body>
</html>
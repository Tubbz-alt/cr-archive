<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/Utility.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 package com.sun.org.apache.bcel.internal.classfile;
  21 
  22 import java.io.ByteArrayInputStream;
  23 import java.io.ByteArrayOutputStream;
  24 import java.io.CharArrayReader;
  25 import java.io.CharArrayWriter;
  26 import java.io.FilterReader;
  27 import java.io.FilterWriter;
  28 import java.io.IOException;
  29 import java.io.PrintStream;
  30 import java.io.PrintWriter;
  31 import java.io.Reader;
  32 import java.io.Writer;
  33 import java.util.ArrayList;
  34 import java.util.List;
  35 import java.util.Locale;
  36 import java.util.zip.GZIPInputStream;
  37 import java.util.zip.GZIPOutputStream;
  38 
  39 import com.sun.org.apache.bcel.internal.Const;
  40 import com.sun.org.apache.bcel.internal.util.ByteSequence;
  41 
  42 /**
  43  * Utility functions that do not really belong to any class in particular.
  44  *
<a name="2" id="anc2"></a><span class="line-modified">  45  * @version $Id: Utility.java 1751107 2016-07-03 02:41:18Z dbrosius $</span>
<span class="line-removed">  46  * @LastModified: Oct 2017</span>
  47  */
  48 // @since 6.0 methods are no longer final
  49 public abstract class Utility {
  50 
<a name="3" id="anc3"></a><span class="line-modified">  51     private static int unwrap(final ThreadLocal&lt;Integer&gt; tl) {</span>
<span class="line-modified">  52         return tl.get().intValue();</span>
  53     }
  54 
<a name="4" id="anc4"></a><span class="line-modified">  55     private static void wrap(final ThreadLocal&lt;Integer&gt; tl, final int value) {</span>
<span class="line-modified">  56         tl.set(Integer.valueOf(value));</span>
  57     }
  58 
<a name="5" id="anc5"></a>




  59     private static ThreadLocal&lt;Integer&gt; consumed_chars = new ThreadLocal&lt;Integer&gt;() {
<a name="6" id="anc6"></a><span class="line-removed">  60 </span>
  61         @Override
  62         protected Integer initialValue() {
<a name="7" id="anc7"></a><span class="line-modified">  63             return Integer.valueOf(0);</span>
  64         }
<a name="8" id="anc8"></a><span class="line-modified">  65     };/* How many chars have been consumed</span>
<span class="line-removed">  66      * during parsing in signatureToString().</span>
<span class="line-removed">  67      * Read by methodSignatureToString().</span>
<span class="line-removed">  68      * Set by side effect,but only internally.</span>
<span class="line-removed">  69      */</span>
  70 
<a name="9" id="anc9"></a><span class="line-modified">  71     private static boolean wide = false; /* The `WIDE&#39; instruction is used in the</span>
  72      * byte code to allow 16-bit wide indices
  73      * for local variables. This opcode
  74      * precedes an `ILOAD&#39;, e.g.. The opcode
  75      * immediately following takes an extra
  76      * byte which is combined with the
  77      * following byte to form a
  78      * 16-bit value.
  79      */
<a name="10" id="anc10"></a>
  80 
  81 
  82     /**
  83      * Convert bit field of flags into string such as `static final&#39;.
  84      *
<a name="11" id="anc11"></a><span class="line-modified">  85      * @param access_flags Access flags</span>
  86      * @return String representation of flags
  87      */
<a name="12" id="anc12"></a><span class="line-modified">  88     public static String accessToString(final int access_flags) {</span>
  89         return accessToString(access_flags, false);
  90     }
  91 
<a name="13" id="anc13"></a>
  92     /**
  93      * Convert bit field of flags into string such as `static final&#39;.
  94      *
  95      * Special case: Classes compiled with new compilers and with the
<a name="14" id="anc14"></a><span class="line-modified">  96      * `ACC_SUPER&#39; flag would be said to be &quot;synchronized&quot;. This is because SUN</span>
<span class="line-modified">  97      * used the same value for the flags `ACC_SUPER&#39; and `ACC_SYNCHRONIZED&#39;.</span>

  98      *
<a name="15" id="anc15"></a><span class="line-modified">  99      * @param access_flags Access flags</span>
<span class="line-modified"> 100      * @param for_class access flags are for class qualifiers ?</span>
 101      * @return String representation of flags
 102      */
<a name="16" id="anc16"></a><span class="line-modified"> 103     public static String accessToString(final int access_flags, final boolean for_class) {</span>
 104         final StringBuilder buf = new StringBuilder();
 105         int p = 0;
<a name="17" id="anc17"></a><span class="line-modified"> 106         for (int i = 0; p &lt; Const.MAX_ACC_FLAG; i++) { // Loop through known flags</span>
 107             p = pow2(i);
 108             if ((access_flags &amp; p) != 0) {
 109                 /* Special case: Classes compiled with new compilers and with the
 110                  * `ACC_SUPER&#39; flag would be said to be &quot;synchronized&quot;. This is
 111                  * because SUN used the same value for the flags `ACC_SUPER&#39; and
 112                  * `ACC_SYNCHRONIZED&#39;.
 113                  */
 114                 if (for_class &amp;&amp; ((p == Const.ACC_SUPER) || (p == Const.ACC_INTERFACE))) {
 115                     continue;
 116                 }
 117                 buf.append(Const.getAccessName(i)).append(&quot; &quot;);
 118             }
 119         }
 120         return buf.toString().trim();
 121     }
 122 
<a name="18" id="anc18"></a>
 123     /**
 124      * @param access_flags the class flags
 125      *
 126      * @return &quot;class&quot; or &quot;interface&quot;, depending on the ACC_INTERFACE flag
 127      */
<a name="19" id="anc19"></a><span class="line-modified"> 128     public static String classOrInterface(final int access_flags) {</span>
 129         return ((access_flags &amp; Const.ACC_INTERFACE) != 0) ? &quot;interface&quot; : &quot;class&quot;;
 130     }
 131 
<a name="20" id="anc20"></a>
 132     /**
 133      * Disassemble a byte array of JVM byte codes starting from code line
 134      * `index&#39; and return the disassembled string representation. Decode only
<a name="21" id="anc21"></a><span class="line-modified"> 135      * `num&#39; opcodes (including their operands), use -1 if you want to decompile</span>
<span class="line-modified"> 136      * everything.</span>
 137      *
<a name="22" id="anc22"></a><span class="line-modified"> 138      * @param code byte code array</span>
<span class="line-modified"> 139      * @param constant_pool Array of constants</span>
<span class="line-modified"> 140      * @param index offset in `code&#39; array</span>
 141      * &lt;EM&gt;(number of opcodes, not bytes!)&lt;/EM&gt;
<a name="23" id="anc23"></a><span class="line-modified"> 142      * @param length number of opcodes to decompile, -1 for all</span>
<span class="line-modified"> 143      * @param verbose be verbose, e.g. print constant pool index</span>
 144      * @return String representation of byte codes
 145      */
<a name="24" id="anc24"></a><span class="line-modified"> 146     public static String codeToString(final byte[] code, final ConstantPool constant_pool,</span>
<span class="line-modified"> 147             final int index, final int length, final boolean verbose) {</span>
<span class="line-modified"> 148         // Should be sufficient // CHECKSTYLE IGNORE MagicNumber</span>
<span class="line-removed"> 149         final StringBuilder buf = new StringBuilder(code.length * 20);</span>
 150         try (ByteSequence stream = new ByteSequence(code)) {
 151             for (int i = 0; i &lt; index; i++) {
 152                 codeToString(stream, constant_pool, verbose);
 153             }
 154             for (int i = 0; stream.available() &gt; 0; i++) {
 155                 if ((length &lt; 0) || (i &lt; length)) {
 156                     final String indices = fillup(stream.getIndex() + &quot;:&quot;, 6, true, &#39; &#39;);
<a name="25" id="anc25"></a><span class="line-modified"> 157                     buf.append(indices)</span>
<span class="line-removed"> 158                             .append(codeToString(stream, constant_pool, verbose))</span>
<span class="line-removed"> 159                             .append(&#39;\n&#39;);</span>
 160                 }
 161             }
 162         } catch (final IOException e) {
 163             throw new ClassFormatException(&quot;Byte code error: &quot; + buf.toString(), e);
 164         }
 165         return buf.toString();
 166     }
 167 
<a name="26" id="anc26"></a><span class="line-modified"> 168     public static String codeToString(final byte[] code, final ConstantPool constant_pool,</span>
<span class="line-modified"> 169             final int index, final int length) {</span>
 170         return codeToString(code, constant_pool, index, length, true);
 171     }
 172 
<a name="27" id="anc27"></a>
 173     /**
<a name="28" id="anc28"></a><span class="line-modified"> 174      * Disassemble a stream of byte codes and return the string representation.</span>

 175      *
<a name="29" id="anc29"></a><span class="line-modified"> 176      * @param bytes stream of bytes</span>
<span class="line-modified"> 177      * @param constant_pool Array of constants</span>
<span class="line-modified"> 178      * @param verbose be verbose, e.g. print constant pool index</span>
 179      * @return String representation of byte code
 180      *
<a name="30" id="anc30"></a><span class="line-modified"> 181      * @throws IOException if a failure from reading from the bytes argument</span>
<span class="line-removed"> 182      * occurs</span>
 183      */
 184     @SuppressWarnings(&quot;fallthrough&quot;) // by design for case Const.INSTANCEOF
 185     public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool,
 186             final boolean verbose) throws IOException {
 187         final short opcode = (short) bytes.readUnsignedByte();
 188         int default_offset = 0;
 189         int low;
 190         int high;
 191         int npairs;
 192         int index;
 193         int vindex;
 194         int constant;
 195         int[] match;
 196         int[] jump_table;
 197         int no_pad_bytes = 0;
 198         int offset;
 199         final StringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));
 200         /* Special case: Skip (0-3) padding bytes, i.e., the
 201          * following bytes are 4-byte-aligned
 202          */
 203         if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {
 204             final int remainder = bytes.getIndex() % 4;
 205             no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;
 206             for (int i = 0; i &lt; no_pad_bytes; i++) {
 207                 byte b;
 208                 if ((b = bytes.readByte()) != 0) {
 209                     System.err.println(&quot;Warning: Padding byte != 0 in &quot;
 210                             + Const.getOpcodeName(opcode) + &quot;:&quot; + b);
 211                 }
 212             }
 213             // Both cases have a field default_offset in common
 214             default_offset = bytes.readInt();
 215         }
 216         switch (opcode) {
 217             /* Table switch has variable length arguments.
 218              */
 219             case Const.TABLESWITCH:
 220                 low = bytes.readInt();
 221                 high = bytes.readInt();
 222                 offset = bytes.getIndex() - 12 - no_pad_bytes - 1;
 223                 default_offset += offset;
 224                 buf.append(&quot;\tdefault = &quot;).append(default_offset).append(&quot;, low = &quot;).append(low)
 225                         .append(&quot;, high = &quot;).append(high).append(&quot;(&quot;);
 226                 jump_table = new int[high - low + 1];
 227                 for (int i = 0; i &lt; jump_table.length; i++) {
 228                     jump_table[i] = offset + bytes.readInt();
 229                     buf.append(jump_table[i]);
 230                     if (i &lt; jump_table.length - 1) {
 231                         buf.append(&quot;, &quot;);
 232                     }
 233                 }
 234                 buf.append(&quot;)&quot;);
 235                 break;
 236             /* Lookup switch has variable length arguments.
 237              */
 238             case Const.LOOKUPSWITCH: {
 239                 npairs = bytes.readInt();
 240                 offset = bytes.getIndex() - 8 - no_pad_bytes - 1;
 241                 match = new int[npairs];
 242                 jump_table = new int[npairs];
 243                 default_offset += offset;
 244                 buf.append(&quot;\tdefault = &quot;).append(default_offset).append(&quot;, npairs = &quot;).append(
 245                         npairs).append(&quot; (&quot;);
 246                 for (int i = 0; i &lt; npairs; i++) {
 247                     match[i] = bytes.readInt();
 248                     jump_table[i] = offset + bytes.readInt();
 249                     buf.append(&quot;(&quot;).append(match[i]).append(&quot;, &quot;).append(jump_table[i]).append(&quot;)&quot;);
 250                     if (i &lt; npairs - 1) {
 251                         buf.append(&quot;, &quot;);
 252                     }
 253                 }
 254                 buf.append(&quot;)&quot;);
 255             }
<a name="31" id="anc31"></a><span class="line-modified"> 256             break;</span>
 257             /* Two address bytes + offset from start of byte stream form the
 258              * jump target
 259              */
 260             case Const.GOTO:
 261             case Const.IFEQ:
 262             case Const.IFGE:
 263             case Const.IFGT:
 264             case Const.IFLE:
 265             case Const.IFLT:
 266             case Const.JSR:
 267             case Const.IFNE:
 268             case Const.IFNONNULL:
 269             case Const.IFNULL:
 270             case Const.IF_ACMPEQ:
 271             case Const.IF_ACMPNE:
 272             case Const.IF_ICMPEQ:
 273             case Const.IF_ICMPGE:
 274             case Const.IF_ICMPGT:
 275             case Const.IF_ICMPLE:
 276             case Const.IF_ICMPLT:
 277             case Const.IF_ICMPNE:
 278                 buf.append(&quot;\t\t#&quot;).append((bytes.getIndex() - 1) + bytes.readShort());
 279                 break;
 280             /* 32-bit wide jumps
 281              */
 282             case Const.GOTO_W:
 283             case Const.JSR_W:
 284                 buf.append(&quot;\t\t#&quot;).append((bytes.getIndex() - 1) + bytes.readInt());
 285                 break;
 286             /* Index byte references local variable (register)
 287              */
 288             case Const.ALOAD:
 289             case Const.ASTORE:
 290             case Const.DLOAD:
 291             case Const.DSTORE:
 292             case Const.FLOAD:
 293             case Const.FSTORE:
 294             case Const.ILOAD:
 295             case Const.ISTORE:
 296             case Const.LLOAD:
 297             case Const.LSTORE:
 298             case Const.RET:
 299                 if (wide) {
 300                     vindex = bytes.readUnsignedShort();
 301                     wide = false; // Clear flag
 302                 } else {
 303                     vindex = bytes.readUnsignedByte();
 304                 }
 305                 buf.append(&quot;\t\t%&quot;).append(vindex);
 306                 break;
 307             /*
 308              * Remember wide byte which is used to form a 16-bit address in the
 309              * following instruction. Relies on that the method is called again with
 310              * the following opcode.
 311              */
 312             case Const.WIDE:
 313                 wide = true;
 314                 buf.append(&quot;\t(wide)&quot;);
 315                 break;
 316             /* Array of basic type.
 317              */
 318             case Const.NEWARRAY:
 319                 buf.append(&quot;\t\t&lt;&quot;).append(Const.getTypeName(bytes.readByte())).append(&quot;&gt;&quot;);
 320                 break;
 321             /* Access object/class fields.
 322              */
 323             case Const.GETFIELD:
 324             case Const.GETSTATIC:
 325             case Const.PUTFIELD:
 326             case Const.PUTSTATIC:
 327                 index = bytes.readUnsignedShort();
 328                 buf.append(&quot;\t\t&quot;).append(
 329                         constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(
<a name="32" id="anc32"></a><span class="line-modified"> 330                                 verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);</span>
 331                 break;
 332             /* Operands are references to classes in constant pool
 333              */
 334             case Const.NEW:
 335             case Const.CHECKCAST:
 336                 buf.append(&quot;\t&quot;);
<a name="33" id="anc33"></a><span class="line-modified"> 337             //$FALL-THROUGH$</span>
 338             case Const.INSTANCEOF:
 339                 index = bytes.readUnsignedShort();
 340                 buf.append(&quot;\t&lt;&quot;).append(
 341                         constant_pool.constantToString(index, Const.CONSTANT_Class))
 342                         .append(&quot;&gt;&quot;).append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 343                 break;
 344             /* Operands are references to methods in constant pool
 345              */
 346             case Const.INVOKESPECIAL:
 347             case Const.INVOKESTATIC:
 348                 index = bytes.readUnsignedShort();
 349                 final Constant c = constant_pool.getConstant(index);
 350                 // With Java8 operand may be either a CONSTANT_Methodref
 351                 // or a CONSTANT_InterfaceMethodref.   (markro)
 352                 buf.append(&quot;\t&quot;).append(
 353                         constant_pool.constantToString(index, c.getTag()))
 354                         .append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 355                 break;
 356             case Const.INVOKEVIRTUAL:
 357                 index = bytes.readUnsignedShort();
 358                 buf.append(&quot;\t&quot;).append(
 359                         constant_pool.constantToString(index, Const.CONSTANT_Methodref))
 360                         .append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 361                 break;
 362             case Const.INVOKEINTERFACE:
 363                 index = bytes.readUnsignedShort();
 364                 final int nargs = bytes.readUnsignedByte(); // historical, redundant
 365                 buf.append(&quot;\t&quot;).append(
 366                         constant_pool
<a name="34" id="anc34"></a><span class="line-modified"> 367                         .constantToString(index, Const.CONSTANT_InterfaceMethodref))</span>
 368                         .append(verbose ? &quot; (&quot; + index + &quot;)\t&quot; : &quot;&quot;).append(nargs).append(&quot;\t&quot;)
 369                         .append(bytes.readUnsignedByte()); // Last byte is a reserved space
 370                 break;
 371             case Const.INVOKEDYNAMIC:
 372                 index = bytes.readUnsignedShort();
 373                 buf.append(&quot;\t&quot;).append(
 374                         constant_pool
<a name="35" id="anc35"></a><span class="line-modified"> 375                         .constantToString(index, Const.CONSTANT_InvokeDynamic))</span>
 376                         .append(verbose ? &quot; (&quot; + index + &quot;)\t&quot; : &quot;&quot;)
<a name="36" id="anc36"></a><span class="line-modified"> 377                         .append(bytes.readUnsignedByte()) // Thrid byte is a reserved space</span>
 378                         .append(bytes.readUnsignedByte()); // Last byte is a reserved space
 379                 break;
 380             /* Operands are references to items in constant pool
 381              */
 382             case Const.LDC_W:
 383             case Const.LDC2_W:
 384                 index = bytes.readUnsignedShort();
 385                 buf.append(&quot;\t\t&quot;).append(
 386                         constant_pool.constantToString(index, constant_pool.getConstant(index)
 387                                 .getTag())).append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 388                 break;
 389             case Const.LDC:
 390                 index = bytes.readUnsignedByte();
 391                 buf.append(&quot;\t\t&quot;).append(
 392                         constant_pool.constantToString(index, constant_pool.getConstant(index)
 393                                 .getTag())).append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 394                 break;
 395             /* Array of references.
 396              */
 397             case Const.ANEWARRAY:
 398                 index = bytes.readUnsignedShort();
 399                 buf.append(&quot;\t\t&lt;&quot;).append(
 400                         compactClassName(constant_pool.getConstantString(index,
<a name="37" id="anc37"></a><span class="line-modified"> 401                                         Const.CONSTANT_Class), false)).append(&quot;&gt;&quot;).append(</span>
<span class="line-modified"> 402                                 verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);</span>
 403                 break;
 404             /* Multidimensional array of references.
 405              */
 406             case Const.MULTIANEWARRAY: {
 407                 index = bytes.readUnsignedShort();
 408                 final int dimensions = bytes.readUnsignedByte();
 409                 buf.append(&quot;\t&lt;&quot;).append(
 410                         compactClassName(constant_pool.getConstantString(index,
<a name="38" id="anc38"></a><span class="line-modified"> 411                                         Const.CONSTANT_Class), false)).append(&quot;&gt;\t&quot;).append(dimensions)</span>
 412                         .append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
 413             }
<a name="39" id="anc39"></a><span class="line-modified"> 414             break;</span>
 415             /* Increment local variable.
 416              */
 417             case Const.IINC:
 418                 if (wide) {
 419                     vindex = bytes.readUnsignedShort();
 420                     constant = bytes.readShort();
 421                     wide = false;
 422                 } else {
 423                     vindex = bytes.readUnsignedByte();
 424                     constant = bytes.readByte();
 425                 }
 426                 buf.append(&quot;\t\t%&quot;).append(vindex).append(&quot;\t&quot;).append(constant);
 427                 break;
 428             default:
 429                 if (Const.getNoOfOperands(opcode) &gt; 0) {
 430                     for (int i = 0; i &lt; Const.getOperandTypeCount(opcode); i++) {
 431                         buf.append(&quot;\t\t&quot;);
 432                         switch (Const.getOperandType(opcode, i)) {
 433                             case Const.T_BYTE:
 434                                 buf.append(bytes.readByte());
 435                                 break;
 436                             case Const.T_SHORT:
 437                                 buf.append(bytes.readShort());
 438                                 break;
 439                             case Const.T_INT:
 440                                 buf.append(bytes.readInt());
 441                                 break;
 442                             default: // Never reached
 443                                 throw new IllegalStateException(&quot;Unreachable default case reached!&quot;);
 444                         }
 445                     }
 446                 }
 447         }
 448         return buf.toString();
 449     }
 450 
<a name="40" id="anc40"></a><span class="line-modified"> 451     public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool)</span>

 452             throws IOException {
 453         return codeToString(bytes, constant_pool, true);
 454     }
 455 
<a name="41" id="anc41"></a>
 456     /**
 457      * Shorten long class names, &lt;em&gt;java/lang/String&lt;/em&gt; becomes
 458      * &lt;em&gt;String&lt;/em&gt;.
 459      *
 460      * @param str The long class name
 461      * @return Compacted class name
 462      */
<a name="42" id="anc42"></a><span class="line-modified"> 463     public static String compactClassName(final String str) {</span>
 464         return compactClassName(str, true);
 465     }
 466 
<a name="43" id="anc43"></a>















 467     /**
 468      * Shorten long class name &lt;em&gt;str&lt;/em&gt;, i.e., chop off the &lt;em&gt;prefix&lt;/em&gt;,
<a name="44" id="anc44"></a><span class="line-modified"> 469      * if the class name starts with this string and the flag &lt;em&gt;chopit&lt;/em&gt; is</span>
<span class="line-modified"> 470      * true. Slashes &lt;em&gt;/&lt;/em&gt; are converted to dots &lt;em&gt;.&lt;/em&gt;.</span>

 471      *
 472      * @param str The long class name
 473      * @param prefix The prefix the get rid off
<a name="45" id="anc45"></a><span class="line-modified"> 474      * @param chopit Flag that determines whether chopping is executed or not</span>
 475      * @return Compacted class name
 476      */
<a name="46" id="anc46"></a><span class="line-modified"> 477     public static String compactClassName(String str, final String prefix, final boolean chopit) {</span>
 478         final int len = prefix.length();
 479         str = str.replace(&#39;/&#39;, &#39;.&#39;); // Is `/&#39; on all systems, even DOS
 480         if (chopit) {
 481             // If string starts with `prefix&#39; and contains no further dots
 482             if (str.startsWith(prefix) &amp;&amp; (str.substring(len).indexOf(&#39;.&#39;) == -1)) {
 483                 str = str.substring(len);
 484             }
 485         }
 486         return str;
 487     }
 488 
<a name="47" id="anc47"></a><span class="line-removed"> 489     /**</span>
<span class="line-removed"> 490      * Shorten long class names, &lt;em&gt;java/lang/String&lt;/em&gt; becomes</span>
<span class="line-removed"> 491      * &lt;em&gt;java.lang.String&lt;/em&gt;, e.g.. If &lt;em&gt;chopit&lt;/em&gt; is &lt;em&gt;true&lt;/em&gt; the</span>
<span class="line-removed"> 492      * prefix &lt;em&gt;java.lang&lt;/em&gt;</span>
<span class="line-removed"> 493      * is also removed.</span>
<span class="line-removed"> 494      *</span>
<span class="line-removed"> 495      * @param str The long class name</span>
<span class="line-removed"> 496      * @param chopit Flag that determines whether chopping is executed or not</span>
<span class="line-removed"> 497      * @return Compacted class name</span>
<span class="line-removed"> 498      */</span>
<span class="line-removed"> 499     public static String compactClassName(final String str, final boolean chopit) {</span>
<span class="line-removed"> 500         return compactClassName(str, &quot;java.lang.&quot;, chopit);</span>
<span class="line-removed"> 501     }</span>
 502 
 503     /**
 504      * @return `flag&#39; with bit `i&#39; set to 1
 505      */
<a name="48" id="anc48"></a><span class="line-modified"> 506     public static int setBit(final int flag, final int i) {</span>
 507         return flag | pow2(i);
 508     }
 509 
<a name="49" id="anc49"></a>
 510     /**
 511      * @return `flag&#39; with bit `i&#39; set to 0
 512      */
<a name="50" id="anc50"></a><span class="line-modified"> 513     public static int clearBit(final int flag, final int i) {</span>
 514         final int bit = pow2(i);
 515         return (flag &amp; bit) == 0 ? flag : flag ^ bit;
 516     }
 517 
<a name="51" id="anc51"></a>
 518     /**
 519      * @return true, if bit `i&#39; in `flag&#39; is set
 520      */
<a name="52" id="anc52"></a><span class="line-modified"> 521     public static boolean isSet(final int flag, final int i) {</span>
 522         return (flag &amp; pow2(i)) != 0;
 523     }
 524 
<a name="53" id="anc53"></a>
 525     /**
<a name="54" id="anc54"></a><span class="line-modified"> 526      * Converts string containing the method return and argument types to a byte</span>
<span class="line-modified"> 527      * code method signature.</span>
 528      *
<a name="55" id="anc55"></a><span class="line-modified"> 529      * @param ret Return type of method</span>
<span class="line-modified"> 530      * @param argv Types of method arguments</span>
 531      * @return Byte code representation of method signature
 532      *
 533      * @throws ClassFormatException if the signature is for Void
 534      */
<a name="56" id="anc56"></a><span class="line-modified"> 535     public static String methodTypeToSignature(final String ret, final String[] argv)</span>
 536             throws ClassFormatException {
 537         final StringBuilder buf = new StringBuilder(&quot;(&quot;);
 538         String str;
 539         if (argv != null) {
 540             for (final String element : argv) {
 541                 str = getSignature(element);
 542                 if (str.endsWith(&quot;V&quot;)) {
 543                     throw new ClassFormatException(&quot;Invalid type: &quot; + element);
 544                 }
 545                 buf.append(str);
 546             }
 547         }
 548         str = getSignature(ret);
 549         buf.append(&quot;)&quot;).append(str);
 550         return buf.toString();
 551     }
 552 
<a name="57" id="anc57"></a>
 553     /**
<a name="58" id="anc58"></a><span class="line-modified"> 554      * @param signature Method signature</span>
<span class="line-modified"> 555      * @return Array of argument types</span>


 556      * @throws ClassFormatException
 557      */
<a name="59" id="anc59"></a><span class="line-modified"> 558     public static String[] methodSignatureArgumentTypes(final String signature)</span>
 559             throws ClassFormatException {
 560         return methodSignatureArgumentTypes(signature, true);
 561     }
 562 
<a name="60" id="anc60"></a>
 563     /**
<a name="61" id="anc61"></a><span class="line-modified"> 564      * @param signature Method signature</span>
<span class="line-modified"> 565      * @param chopit Shorten class names ?</span>
<span class="line-modified"> 566      * @return Array of argument types</span>


 567      * @throws ClassFormatException
 568      */
<a name="62" id="anc62"></a><span class="line-modified"> 569     public static String[] methodSignatureArgumentTypes(final String signature, final boolean chopit)</span>
 570             throws ClassFormatException {
 571         final List&lt;String&gt; vec = new ArrayList&lt;&gt;();
 572         int index;
<a name="63" id="anc63"></a><span class="line-modified"> 573         try { // Read all declarations between for `(&#39; and `)&#39;</span>
<span class="line-modified"> 574             if (signature.charAt(0) != &#39;(&#39;) {</span>


 575                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
 576             }
<a name="64" id="anc64"></a><span class="line-removed"> 577             index = 1; // current string position</span>
 578             while (signature.charAt(index) != &#39;)&#39;) {
<a name="65" id="anc65"></a><span class="line-modified"> 579                 vec.add(signatureToString(signature.substring(index), chopit));</span>
 580                 //corrected concurrent private static field acess
 581                 index += unwrap(consumed_chars); // update position
 582             }
 583         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
 584             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
 585         }
 586         return vec.toArray(new String[vec.size()]);
 587     }
 588 
<a name="66" id="anc66"></a>
 589     /**
<a name="67" id="anc67"></a><span class="line-modified"> 590      * @param signature Method signature</span>
<span class="line-modified"> 591      * @return return type of method</span>


 592      * @throws ClassFormatException
 593      */
<a name="68" id="anc68"></a><span class="line-modified"> 594     public static String methodSignatureReturnType(final String signature)</span>
<span class="line-removed"> 595             throws ClassFormatException {</span>
 596         return methodSignatureReturnType(signature, true);
 597     }
 598 
<a name="69" id="anc69"></a>
 599     /**
<a name="70" id="anc70"></a><span class="line-modified"> 600      * @param signature Method signature</span>
<span class="line-modified"> 601      * @param chopit Shorten class names ?</span>
<span class="line-modified"> 602      * @return return type of method</span>


 603      * @throws ClassFormatException
 604      */
<a name="71" id="anc71"></a><span class="line-modified"> 605     public static String methodSignatureReturnType(final String signature,</span>
<span class="line-removed"> 606             final boolean chopit) throws ClassFormatException {</span>
 607         int index;
 608         String type;
 609         try {
 610             // Read return type after `)&#39;
 611             index = signature.lastIndexOf(&#39;)&#39;) + 1;
<a name="72" id="anc72"></a><span class="line-modified"> 612             type = signatureToString(signature.substring(index), chopit);</span>



 613         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
 614             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
 615         }
 616         return type;
 617     }
 618 
<a name="73" id="anc73"></a>
 619     /**
 620      * Converts method signature to string with all class names compacted.
 621      *
<a name="74" id="anc74"></a><span class="line-modified"> 622      * @param signature to convert</span>
<span class="line-modified"> 623      * @param name of method</span>
<span class="line-modified"> 624      * @param access flags of method</span>
 625      * @return Human readable signature
 626      */
<a name="75" id="anc75"></a><span class="line-modified"> 627     public static String methodSignatureToString(final String signature,</span>
<span class="line-removed"> 628             final String name, final String access) {</span>
 629         return methodSignatureToString(signature, name, access, true);
 630     }
 631 
<a name="76" id="anc76"></a><span class="line-modified"> 632     public static String methodSignatureToString(final String signature,</span>
<span class="line-modified"> 633             final String name, final String access, final boolean chopit) {</span>









 634         return methodSignatureToString(signature, name, access, chopit, null);
 635     }
 636 
<a name="77" id="anc77"></a>
 637     /**
<a name="78" id="anc78"></a><span class="line-modified"> 638      * A returntype signature represents the return value from a method. It is a</span>
<span class="line-removed"> 639      * series of bytes in the following grammar:</span>
<span class="line-removed"> 640      *</span>
<span class="line-removed"> 641      * &lt;pre&gt;</span>
<span class="line-removed"> 642      * &amp;lt;return_signature&amp;gt; ::= &amp;lt;field_type&amp;gt; | V</span>
<span class="line-removed"> 643      * &lt;/pre&gt;</span>
<span class="line-removed"> 644      *</span>
<span class="line-removed"> 645      * The character V indicates that the method returns no value. Otherwise,</span>
<span class="line-removed"> 646      * the signature indicates the type of the return value. An argument</span>
<span class="line-removed"> 647      * signature represents an argument passed to a method:</span>
<span class="line-removed"> 648      *</span>
<span class="line-removed"> 649      * &lt;pre&gt;</span>
<span class="line-removed"> 650      * &amp;lt;argument_signature&amp;gt; ::= &amp;lt;field_type&amp;gt;</span>
<span class="line-removed"> 651      * &lt;/pre&gt;</span>
<span class="line-removed"> 652      *</span>
<span class="line-removed"> 653      * A method signature represents the arguments that the method expects, and</span>
<span class="line-removed"> 654      * the value that it returns.</span>
<span class="line-removed"> 655      * &lt;pre&gt;</span>
<span class="line-removed"> 656      * &amp;lt;method_signature&amp;gt; ::= (&amp;lt;arguments_signature&amp;gt;) &amp;lt;return_signature&amp;gt;</span>
<span class="line-removed"> 657      * &amp;lt;arguments_signature&amp;gt;::= &amp;lt;argument_signature&amp;gt;*</span>
<span class="line-removed"> 658      * &lt;/pre&gt;</span>
<span class="line-removed"> 659      *</span>
<span class="line-removed"> 660      * This method converts such a string into a Java type declaration like</span>
 661      * `void main(String[])&#39; and throws a `ClassFormatException&#39; when the parsed
 662      * type is invalid.
 663      *
<a name="79" id="anc79"></a><span class="line-modified"> 664      * @param signature Method signature</span>
<span class="line-modified"> 665      * @param name Method name</span>
<span class="line-modified"> 666      * @param access Method access rights</span>
<span class="line-modified"> 667      * @param chopit</span>
<span class="line-modified"> 668      * @param vars</span>
 669      * @return Java type declaration
 670      * @throws ClassFormatException
 671      */
<a name="80" id="anc80"></a><span class="line-modified"> 672     public static String methodSignatureToString(final String signature, final String name,</span>
<span class="line-modified"> 673             final String access, final boolean chopit, final LocalVariableTable vars)</span>
<span class="line-removed"> 674             throws ClassFormatException {</span>
 675         final StringBuilder buf = new StringBuilder(&quot;(&quot;);
 676         String type;
 677         int index;
 678         int var_index = access.contains(&quot;static&quot;) ? 0 : 1;
<a name="81" id="anc81"></a><span class="line-modified"> 679         try { // Read all declarations between for `(&#39; and `)&#39;</span>
<span class="line-modified"> 680             if (signature.charAt(0) != &#39;(&#39;) {</span>


 681                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
 682             }
<a name="82" id="anc82"></a><span class="line-removed"> 683             index = 1; // current string position</span>
 684             while (signature.charAt(index) != &#39;)&#39;) {
<a name="83" id="anc83"></a><span class="line-modified"> 685                 final String param_type = signatureToString(signature.substring(index), chopit);</span>
 686                 buf.append(param_type);
 687                 if (vars != null) {
 688                     final LocalVariable l = vars.getLocalVariable(var_index, 0);
 689                     if (l != null) {
 690                         buf.append(&quot; &quot;).append(l.getName());
 691                     }
 692                 } else {
 693                     buf.append(&quot; arg&quot;).append(var_index);
 694                 }
 695                 if (&quot;double&quot;.equals(param_type) || &quot;long&quot;.equals(param_type)) {
 696                     var_index += 2;
 697                 } else {
 698                     var_index++;
 699                 }
 700                 buf.append(&quot;, &quot;);
 701                 //corrected concurrent private static field acess
 702                 index += unwrap(consumed_chars); // update position
 703             }
 704             index++; // update position
 705             // Read return type after `)&#39;
<a name="84" id="anc84"></a><span class="line-modified"> 706             type = signatureToString(signature.substring(index), chopit);</span>
 707         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
 708             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
 709         }
<a name="85" id="anc85"></a>
 710         if (buf.length() &gt; 1) {
 711             buf.setLength(buf.length() - 2);
 712         }
 713         buf.append(&quot;)&quot;);
 714         return access + ((access.length() &gt; 0) ? &quot; &quot; : &quot;&quot;) + // May be an empty string
 715                 type + &quot; &quot; + name + buf.toString();
 716     }
 717 
<a name="86" id="anc86"></a><span class="line-modified"> 718     // Guess what this does</span>
<span class="line-modified"> 719     private static int pow2(final int n) {</span>
 720         return 1 &lt;&lt; n;
 721     }
 722 
<a name="87" id="anc87"></a>
 723     /**
<a name="88" id="anc88"></a><span class="line-modified"> 724      * Replace all occurrences of &lt;em&gt;old&lt;/em&gt; in &lt;em&gt;str&lt;/em&gt; with</span>
<span class="line-removed"> 725      * &lt;em&gt;new&lt;/em&gt;.</span>
 726      *
 727      * @param str String to permute
 728      * @param old String to be replaced
 729      * @param new_ Replacement string
 730      * @return new String object
 731      */
<a name="89" id="anc89"></a><span class="line-modified"> 732     public static String replace(String str, final String old, final String new_) {</span>
 733         int index;
 734         int old_index;
 735         try {
 736             if (str.contains(old)) { // `old&#39; found in str
 737                 final StringBuilder buf = new StringBuilder();
 738                 old_index = 0; // String start offset
 739                 // While we have something to replace
 740                 while ((index = str.indexOf(old, old_index)) != -1) {
 741                     buf.append(str.substring(old_index, index)); // append prefix
 742                     buf.append(new_); // append replacement
 743                     old_index = index + old.length(); // Skip `old&#39;.length chars
 744                 }
 745                 buf.append(str.substring(old_index)); // append rest of string
 746                 str = buf.toString();
 747             }
 748         } catch (final StringIndexOutOfBoundsException e) { // Should not occur
 749             System.err.println(e);
 750         }
 751         return str;
 752     }
 753 
<a name="90" id="anc90"></a>
 754     /**
<a name="91" id="anc91"></a><span class="line-modified"> 755      * Converts signature to string with all class names compacted.</span>
 756      *
<a name="92" id="anc92"></a><span class="line-modified"> 757      * @param signature to convert</span>
<span class="line-modified"> 758      * @return Human readable signature</span>




















 759      */
<a name="93" id="anc93"></a><span class="line-modified"> 760     public static String signatureToString(final String signature) {</span>










 761         return signatureToString(signature, true);
 762     }
 763 
<a name="94" id="anc94"></a>
 764     /**
<a name="95" id="anc95"></a><span class="line-modified"> 765      * The field signature represents the value of an argument to a function or</span>
<span class="line-modified"> 766      * the value of a variable. It is a series of bytes generated by the</span>
<span class="line-modified"> 767      * following grammar:</span>
 768      *
<a name="96" id="anc96"></a><span class="line-modified"> 769      * &lt;PRE&gt;</span>
<span class="line-modified"> 770      * &amp;lt;field_signature&amp;gt; ::= &amp;lt;field_type&amp;gt;</span>
<span class="line-modified"> 771      * &amp;lt;field_type&amp;gt;      ::= &amp;lt;base_type&amp;gt;|&amp;lt;object_type&amp;gt;|&amp;lt;array_type&amp;gt;</span>
<span class="line-modified"> 772      * &amp;lt;base_type&amp;gt;       ::= B|C|D|F|I|J|S|Z</span>
<span class="line-modified"> 773      * &amp;lt;object_type&amp;gt;     ::= L&amp;lt;fullclassname&amp;gt;;</span>
<span class="line-modified"> 774      * &amp;lt;array_type&amp;gt;      ::= [&amp;lt;field_type&amp;gt;</span>








































































































 775      *
<a name="97" id="anc97"></a><span class="line-modified"> 776      * The meaning of the base types is as follows:</span>
<span class="line-modified"> 777      * B byte signed byte</span>
<span class="line-modified"> 778      * C char character</span>
<span class="line-modified"> 779      * D double double precision IEEE float</span>
<span class="line-modified"> 780      * F float single precision IEEE float</span>
<span class="line-modified"> 781      * I int integer</span>
<span class="line-modified"> 782      * J long long integer</span>
<span class="line-modified"> 783      * L&amp;lt;fullclassname&amp;gt;; ... an object of the given class</span>
<span class="line-modified"> 784      * S short signed short</span>
<span class="line-modified"> 785      * Z boolean true or false</span>
<span class="line-modified"> 786      * [&amp;lt;field sig&amp;gt; ... array</span>
<span class="line-modified"> 787      * &lt;/PRE&gt;</span>














 788      *
<a name="98" id="anc98"></a><span class="line-modified"> 789      * This method converts this string into a Java type declaration such as</span>
<span class="line-modified"> 790      * `String[]&#39; and throws a `ClassFormatException&#39; when the parsed type is</span>
<span class="line-removed"> 791      * invalid.</span>
 792      *
<a name="99" id="anc99"></a><span class="line-modified"> 793      * @param signature Class signature</span>
<span class="line-modified"> 794      * @param chopit Flag that determines whether chopping is executed or not</span>
<span class="line-modified"> 795      * @return Java type declaration</span>
 796      * @throws ClassFormatException
<a name="100" id="anc100"></a>
 797      */
<a name="101" id="anc101"></a><span class="line-modified"> 798     public static String signatureToString(final String signature, final boolean chopit) {</span>
 799         //corrected concurrent private static field acess
 800         wrap(consumed_chars, 1); // This is the default, read just one char like `B&#39;
 801         try {
 802             switch (signature.charAt(0)) {
 803                 case &#39;B&#39;:
 804                     return &quot;byte&quot;;
 805                 case &#39;C&#39;:
 806                     return &quot;char&quot;;
 807                 case &#39;D&#39;:
 808                     return &quot;double&quot;;
 809                 case &#39;F&#39;:
 810                     return &quot;float&quot;;
 811                 case &#39;I&#39;:
 812                     return &quot;int&quot;;
 813                 case &#39;J&#39;:
 814                     return &quot;long&quot;;
 815                 case &#39;T&#39;: { // TypeVariableSignature
 816                     final int index = signature.indexOf(&#39;;&#39;); // Look for closing `;&#39;
 817                     if (index &lt; 0) {
<a name="102" id="anc102"></a><span class="line-modified"> 818                         throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);</span>
 819                     }
 820                     //corrected concurrent private static field acess
 821                     wrap(consumed_chars, index + 1); // &quot;Tblabla;&quot; `T&#39; and `;&#39; are removed
 822                     return compactClassName(signature.substring(1, index), chopit);
 823                 }
 824                 case &#39;L&#39;: { // Full class name
 825                     // should this be a while loop? can there be more than
 826                     // one generic clause?  (markro)
 827                     int fromIndex = signature.indexOf(&#39;&lt;&#39;); // generic type?
 828                     if (fromIndex &lt; 0) {
 829                         fromIndex = 0;
 830                     } else {
 831                         fromIndex = signature.indexOf(&#39;&gt;&#39;, fromIndex);
 832                         if (fromIndex &lt; 0) {
 833                             throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
 834                         }
 835                     }
 836                     final int index = signature.indexOf(&#39;;&#39;, fromIndex); // Look for closing `;&#39;
 837                     if (index &lt; 0) {
 838                         throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
 839                     }
<a name="103" id="anc103"></a>
 840                     // check to see if there are any TypeArguments
 841                     final int bracketIndex = signature.substring(0, index).indexOf(&#39;&lt;&#39;);
 842                     if (bracketIndex &lt; 0) {
 843                         // just a class identifier
 844                         wrap(consumed_chars, index + 1); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed
 845                         return compactClassName(signature.substring(1, index), chopit);
 846                     }
<a name="104" id="anc104"></a>









 847 
 848                     // we have TypeArguments; build up partial result
 849                     // as we recurse for each TypeArgument
<a name="105" id="anc105"></a><span class="line-modified"> 850                     final StringBuilder type = new StringBuilder(</span>
<span class="line-removed"> 851                             compactClassName(signature.substring(1, bracketIndex), chopit))</span>
<span class="line-removed"> 852                             .append(&quot;&lt;&quot;);</span>
 853                     int consumed_chars = bracketIndex + 1; // Shadows global var
 854 
 855                     // check for wildcards
 856                     if (signature.charAt(consumed_chars) == &#39;+&#39;) {
 857                         type.append(&quot;? extends &quot;);
 858                         consumed_chars++;
 859                     } else if (signature.charAt(consumed_chars) == &#39;-&#39;) {
 860                         type.append(&quot;? super &quot;);
 861                         consumed_chars++;
<a name="106" id="anc106"></a><span class="line-removed"> 862                     } else if (signature.charAt(consumed_chars) == &#39;*&#39;) {</span>
<span class="line-removed"> 863                         // must be at end of signature</span>
<span class="line-removed"> 864                         if (signature.charAt(consumed_chars + 1) != &#39;&gt;&#39;) {</span>
<span class="line-removed"> 865                             throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);</span>
<span class="line-removed"> 866                         }</span>
<span class="line-removed"> 867                         if (signature.charAt(consumed_chars + 2) != &#39;;&#39;) {</span>
<span class="line-removed"> 868                             throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);</span>
<span class="line-removed"> 869                         }</span>
<span class="line-removed"> 870                         wrap(Utility.consumed_chars, consumed_chars + 3); // remove final &quot;*&gt;;&quot;</span>
<span class="line-removed"> 871                         return type + &quot;?&gt;...&quot;;</span>
 872                     }
 873 
 874                     // get the first TypeArgument
<a name="107" id="anc107"></a><span class="line-modified"> 875                     type.append(signatureToString(signature.substring(consumed_chars), chopit));</span>
<span class="line-modified"> 876                     // update our consumed count by the number of characters the for type argument</span>
<span class="line-modified"> 877                     consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;</span>
<span class="line-modified"> 878                     wrap(Utility.consumed_chars, consumed_chars);</span>





 879 
 880                     // are there more TypeArguments?
 881                     while (signature.charAt(consumed_chars) != &#39;&gt;&#39;) {
<a name="108" id="anc108"></a><span class="line-modified"> 882                         type.append(&quot;, &quot;).append(signatureToString(signature.substring(consumed_chars), chopit));</span>





























 883                         // update our consumed count by the number of characters the for type argument
<a name="109" id="anc109"></a>

 884                         consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;
 885                         wrap(Utility.consumed_chars, consumed_chars);
<a name="110" id="anc110"></a>
 886                     }
<a name="111" id="anc111"></a><span class="line-modified"> 887 </span>
<span class="line-removed"> 888                     if (signature.charAt(consumed_chars + 1) != &#39;;&#39;) {</span>
 889                         throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
 890                     }
<a name="112" id="anc112"></a><span class="line-modified"> 891                     wrap(Utility.consumed_chars, consumed_chars + 2); // remove final &quot;&gt;;&quot;</span>
<span class="line-modified"> 892                     return type.append(&quot;&gt;&quot;).toString();</span>
 893                 }
 894                 case &#39;S&#39;:
 895                     return &quot;short&quot;;
 896                 case &#39;Z&#39;:
 897                     return &quot;boolean&quot;;
 898                 case &#39;[&#39;: { // Array declaration
 899                     int n;
 900                     StringBuilder brackets;
 901                     String type;
 902                     int consumed_chars; // Shadows global var
 903                     brackets = new StringBuilder(); // Accumulate []&#39;s
 904                     // Count opening brackets and look for optional size argument
 905                     for (n = 0; signature.charAt(n) == &#39;[&#39;; n++) {
 906                         brackets.append(&quot;[]&quot;);
 907                     }
 908                     consumed_chars = n; // Remember value
 909                     // The rest of the string denotes a `&lt;field_type&gt;&#39;
<a name="113" id="anc113"></a><span class="line-modified"> 910                     type = signatureToString(signature.substring(n), chopit);</span>
 911                     //corrected concurrent private static field acess
 912                     //Utility.consumed_chars += consumed_chars; is replaced by:
 913                     final int _temp = unwrap(Utility.consumed_chars) + consumed_chars;
 914                     wrap(Utility.consumed_chars, _temp);
 915                     return type + brackets.toString();
 916                 }
 917                 case &#39;V&#39;:
 918                     return &quot;void&quot;;
 919                 default:
 920                     throw new ClassFormatException(&quot;Invalid signature: `&quot; + signature + &quot;&#39;&quot;);
 921             }
 922         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
 923             throw new ClassFormatException(&quot;Invalid signature: &quot; + signature, e);
 924         }
 925     }
 926 
<a name="114" id="anc114"></a><span class="line-modified"> 927     /**</span>
<span class="line-modified"> 928      * Parse Java type such as &quot;char&quot;, or &quot;java.lang.String[]&quot; and return the</span>
<span class="line-modified"> 929      * signature in byte code format, e.g. &quot;C&quot; or &quot;[Ljava/lang/String;&quot;</span>
<span class="line-removed"> 930      * respectively.</span>
 931      *
<a name="115" id="anc115"></a><span class="line-modified"> 932      * @param type Java type</span>
 933      * @return byte code signature
 934      */
<a name="116" id="anc116"></a><span class="line-modified"> 935     public static String getSignature(String type) {</span>
 936         final StringBuilder buf = new StringBuilder();
 937         final char[] chars = type.toCharArray();
 938         boolean char_found = false;
 939         boolean delim = false;
 940         int index = -1;
<a name="117" id="anc117"></a><span class="line-modified"> 941         loop:</span>
<span class="line-removed"> 942         for (int i = 0; i &lt; chars.length; i++) {</span>
 943             switch (chars[i]) {
 944                 case &#39; &#39;:
 945                 case &#39;\t&#39;:
 946                 case &#39;\n&#39;:
 947                 case &#39;\r&#39;:
 948                 case &#39;\f&#39;:
 949                     if (char_found) {
 950                         delim = true;
 951                     }
 952                     break;
 953                 case &#39;[&#39;:
 954                     if (!char_found) {
 955                         throw new RuntimeException(&quot;Illegal type: &quot; + type);
 956                     }
 957                     index = i;
 958                     break loop;
 959                 default:
 960                     char_found = true;
 961                     if (!delim) {
 962                         buf.append(chars[i]);
 963                     }
 964             }
 965         }
 966         int brackets = 0;
 967         if (index &gt; 0) {
 968             brackets = countBrackets(type.substring(index));
 969         }
 970         type = buf.toString();
 971         buf.setLength(0);
 972         for (int i = 0; i &lt; brackets; i++) {
 973             buf.append(&#39;[&#39;);
 974         }
 975         boolean found = false;
 976         for (int i = Const.T_BOOLEAN; (i &lt;= Const.T_VOID) &amp;&amp; !found; i++) {
 977             if (Const.getTypeName(i).equals(type)) {
 978                 found = true;
 979                 buf.append(Const.getShortTypeName(i));
 980             }
 981         }
 982         if (!found) {
 983             buf.append(&#39;L&#39;).append(type.replace(&#39;.&#39;, &#39;/&#39;)).append(&#39;;&#39;);
 984         }
 985         return buf.toString();
 986     }
 987 
<a name="118" id="anc118"></a><span class="line-modified"> 988     private static int countBrackets(final String brackets) {</span>

 989         final char[] chars = brackets.toCharArray();
 990         int count = 0;
 991         boolean open = false;
 992         for (final char c : chars) {
 993             switch (c) {
 994                 case &#39;[&#39;:
 995                     if (open) {
 996                         throw new RuntimeException(&quot;Illegally nested brackets:&quot; + brackets);
 997                     }
 998                     open = true;
 999                     break;
1000                 case &#39;]&#39;:
1001                     if (!open) {
1002                         throw new RuntimeException(&quot;Illegally nested brackets:&quot; + brackets);
1003                     }
1004                     open = false;
1005                     count++;
1006                     break;
1007                 default:
1008                     // Don&#39;t care
1009                     break;
1010             }
1011         }
1012         if (open) {
1013             throw new RuntimeException(&quot;Illegally nested brackets:&quot; + brackets);
1014         }
1015         return count;
1016     }
1017 
<a name="119" id="anc119"></a>
1018     /**
<a name="120" id="anc120"></a><span class="line-modified">1019      * Return type of method signature as a byte value as defined in</span>
<span class="line-removed">1020      * &lt;em&gt;Constants&lt;/em&gt;</span>
1021      *
<a name="121" id="anc121"></a><span class="line-modified">1022      * @param signature in format described above</span>
1023      * @return type of method signature
<a name="122" id="anc122"></a><span class="line-modified">1024      * @see Const</span>
1025      *
1026      * @throws ClassFormatException if signature is not a method signature
1027      */
<a name="123" id="anc123"></a><span class="line-modified">1028     public static byte typeOfMethodSignature(final String signature) throws ClassFormatException {</span>
1029         int index;
1030         try {
1031             if (signature.charAt(0) != &#39;(&#39;) {
1032                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
1033             }
1034             index = signature.lastIndexOf(&#39;)&#39;) + 1;
1035             return typeOfSignature(signature.substring(index));
1036         } catch (final StringIndexOutOfBoundsException e) {
1037             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
1038         }
1039     }
1040 
<a name="124" id="anc124"></a>
1041     /**
1042      * Return type of signature as a byte value as defined in &lt;em&gt;Constants&lt;/em&gt;
1043      *
<a name="125" id="anc125"></a><span class="line-modified">1044      * @param signature in format described above</span>
1045      * @return type of signature
<a name="126" id="anc126"></a><span class="line-modified">1046      * @see Const</span>
1047      *
1048      * @throws ClassFormatException if signature isn&#39;t a known type
1049      */
<a name="127" id="anc127"></a><span class="line-modified">1050     public static byte typeOfSignature(final String signature) throws ClassFormatException {</span>
1051         try {
1052             switch (signature.charAt(0)) {
1053                 case &#39;B&#39;:
1054                     return Const.T_BYTE;
1055                 case &#39;C&#39;:
1056                     return Const.T_CHAR;
1057                 case &#39;D&#39;:
1058                     return Const.T_DOUBLE;
1059                 case &#39;F&#39;:
1060                     return Const.T_FLOAT;
1061                 case &#39;I&#39;:
1062                     return Const.T_INT;
1063                 case &#39;J&#39;:
1064                     return Const.T_LONG;
1065                 case &#39;L&#39;:
1066                 case &#39;T&#39;:
1067                     return Const.T_REFERENCE;
1068                 case &#39;[&#39;:
1069                     return Const.T_ARRAY;
1070                 case &#39;V&#39;:
1071                     return Const.T_VOID;
1072                 case &#39;Z&#39;:
1073                     return Const.T_BOOLEAN;
1074                 case &#39;S&#39;:
1075                     return Const.T_SHORT;
1076                 case &#39;!&#39;:
1077                 case &#39;+&#39;:
1078                 case &#39;*&#39;:
1079                     return typeOfSignature(signature.substring(1));
1080                 default:
1081                     throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
1082             }
1083         } catch (final StringIndexOutOfBoundsException e) {
1084             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
1085         }
1086     }
1087 
<a name="128" id="anc128"></a><span class="line-modified">1088     /**</span>
<span class="line-modified">1089      * Map opcode names to opcode numbers. E.g., return Constants.ALOAD for</span>
<span class="line-removed">1090      * &quot;aload&quot;</span>
1091      */
<a name="129" id="anc129"></a><span class="line-modified">1092     public static short searchOpcode(String name) {</span>
1093         name = name.toLowerCase(Locale.ENGLISH);
1094         for (short i = 0; i &lt; Const.OPCODE_NAMES_LENGTH; i++) {
1095             if (Const.getOpcodeName(i).equals(name)) {
1096                 return i;
1097             }
1098         }
1099         return -1;
1100     }
1101 
<a name="130" id="anc130"></a>
1102     /**
1103      * Convert (signed) byte to (unsigned) short value, i.e., all negative
1104      * values become positive.
1105      */
<a name="131" id="anc131"></a><span class="line-modified">1106     private static short byteToShort(final byte b) {</span>
1107         return (b &lt; 0) ? (short) (256 + b) : (short) b;
1108     }
1109 
<a name="132" id="anc132"></a><span class="line-modified">1110     /**</span>
<span class="line-modified">1111      * Convert bytes into hexadecimal string</span>
1112      *
1113      * @param bytes an array of bytes to convert to hexadecimal
1114      *
1115      * @return bytes as hexadecimal string, e.g. 00 fa 12 ...
1116      */
<a name="133" id="anc133"></a><span class="line-modified">1117     public static String toHexString(final byte[] bytes) {</span>
1118         final StringBuilder buf = new StringBuilder();
1119         for (int i = 0; i &lt; bytes.length; i++) {
1120             final short b = byteToShort(bytes[i]);
1121             final String hex = Integer.toHexString(b);
1122             if (b &lt; 0x10) {
1123                 buf.append(&#39;0&#39;);
1124             }
1125             buf.append(hex);
1126             if (i &lt; bytes.length - 1) {
1127                 buf.append(&#39; &#39;);
1128             }
1129         }
1130         return buf.toString();
1131     }
1132 
<a name="134" id="anc134"></a>
1133     /**
1134      * Return a string for an integer justified left or right and filled up with
1135      * `fill&#39; characters if necessary.
1136      *
1137      * @param i integer to format
1138      * @param length length of desired string
1139      * @param left_justify format left or right
1140      * @param fill fill character
1141      * @return formatted int
1142      */
<a name="135" id="anc135"></a><span class="line-modified">1143     public static String format(final int i, final int length,</span>
<span class="line-removed">1144             final boolean left_justify, final char fill) {</span>
1145         return fillup(Integer.toString(i), length, left_justify, fill);
1146     }
1147 
<a name="136" id="anc136"></a>
1148     /**
<a name="137" id="anc137"></a><span class="line-modified">1149      * Fillup char with up to length characters with char `fill&#39; and justify it</span>
<span class="line-removed">1150      * left or right.</span>
1151      *
1152      * @param str string to format
1153      * @param length length of desired string
1154      * @param left_justify format left or right
1155      * @param fill fill character
1156      * @return formatted string
1157      */
<a name="138" id="anc138"></a><span class="line-modified">1158     public static String fillup(final String str, final int length,</span>
<span class="line-removed">1159             final boolean left_justify, final char fill) {</span>
1160         final int len = length - str.length();
1161         final char[] buf = new char[(len &lt; 0) ? 0 : len];
1162         for (int j = 0; j &lt; buf.length; j++) {
1163             buf[j] = fill;
1164         }
1165         if (left_justify) {
1166             return str + new String(buf);
1167         }
1168         return new String(buf) + str;
1169     }
1170 
<a name="139" id="anc139"></a><span class="line-modified">1171     static boolean equals(final byte[] a, final byte[] b) {</span>

1172         int size;
1173         if ((size = a.length) != b.length) {
1174             return false;
1175         }
1176         for (int i = 0; i &lt; size; i++) {
1177             if (a[i] != b[i]) {
1178                 return false;
1179             }
1180         }
1181         return true;
1182     }
1183 
<a name="140" id="anc140"></a><span class="line-modified">1184     public static void printArray(final PrintStream out, final Object[] obj) {</span>

1185         out.println(printArray(obj, true));
1186     }
1187 
<a name="141" id="anc141"></a><span class="line-modified">1188     public static void printArray(final PrintWriter out, final Object[] obj) {</span>

1189         out.println(printArray(obj, true));
1190     }
1191 
<a name="142" id="anc142"></a><span class="line-modified">1192     public static String printArray(final Object[] obj) {</span>

1193         return printArray(obj, true);
1194     }
1195 
<a name="143" id="anc143"></a><span class="line-modified">1196     public static String printArray(final Object[] obj, final boolean braces) {</span>

1197         return printArray(obj, braces, false);
1198     }
1199 
<a name="144" id="anc144"></a><span class="line-modified">1200     public static String printArray(final Object[] obj, final boolean braces, final boolean quote) {</span>

1201         if (obj == null) {
1202             return null;
1203         }
1204         final StringBuilder buf = new StringBuilder();
1205         if (braces) {
1206             buf.append(&#39;{&#39;);
1207         }
1208         for (int i = 0; i &lt; obj.length; i++) {
1209             if (obj[i] != null) {
1210                 buf.append(quote ? &quot;\&quot;&quot; : &quot;&quot;).append(obj[i]).append(quote ? &quot;\&quot;&quot; : &quot;&quot;);
1211             } else {
1212                 buf.append(&quot;null&quot;);
1213             }
1214             if (i &lt; obj.length - 1) {
1215                 buf.append(&quot;, &quot;);
1216             }
1217         }
1218         if (braces) {
1219             buf.append(&#39;}&#39;);
1220         }
1221         return buf.toString();
1222     }
1223 
<a name="145" id="anc145"></a>
1224     /**
1225      * @param ch the character to test if it&#39;s part of an identifier
1226      *
1227      * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)
1228      */
<a name="146" id="anc146"></a><span class="line-modified">1229     public static boolean isJavaIdentifierPart(final char ch) {</span>
1230         return ((ch &gt;= &#39;a&#39;) &amp;&amp; (ch &lt;= &#39;z&#39;)) || ((ch &gt;= &#39;A&#39;) &amp;&amp; (ch &lt;= &#39;Z&#39;))
1231                 || ((ch &gt;= &#39;0&#39;) &amp;&amp; (ch &lt;= &#39;9&#39;)) || (ch == &#39;_&#39;);
1232     }
1233 
<a name="147" id="anc147"></a>
1234     /**
<a name="148" id="anc148"></a><span class="line-modified">1235      * Encode byte array it into Java identifier string, i.e., a string that</span>
<span class="line-modified">1236      * only contains the following characters: (a, ... z, A, ... Z, 0, ... 9, _,</span>
<span class="line-modified">1237      * $). The encoding algorithm itself is not too clever: if the current</span>
<span class="line-modified">1238      * byte&#39;s ASCII value already is a valid Java identifier part, leave it as</span>
<span class="line-modified">1239      * it is. Otherwise it writes the escape character($) followed by:</span>

1240      *
1241      * &lt;ul&gt;
<a name="149" id="anc149"></a><span class="line-modified">1242      * &lt;li&gt; the ASCII value as a hexadecimal string, if the value is not in the</span>
<span class="line-modified">1243      * range 200..247&lt;/li&gt;</span>
<span class="line-removed">1244      * &lt;li&gt;a Java identifier char not used in a lowercase hexadecimal string, if</span>
<span class="line-removed">1245      * the value is in the range 200..247&lt;/li&gt;</span>
1246      * &lt;/ul&gt;
1247      *
<a name="150" id="anc150"></a><span class="line-modified">1248      * &lt;p&gt;</span>
<span class="line-removed">1249      * This operation inflates the original byte array by roughly 40-50%&lt;/p&gt;</span>
1250      *
1251      * @param bytes the byte array to convert
1252      * @param compress use gzip to minimize string
1253      *
1254      * @throws IOException if there&#39;s a gzip exception
1255      */
1256     public static String encode(byte[] bytes, final boolean compress) throws IOException {
1257         if (compress) {
1258             try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
1259                     GZIPOutputStream gos = new GZIPOutputStream(baos)) {
1260                 gos.write(bytes, 0, bytes.length);
1261                 bytes = baos.toByteArray();
1262             }
1263         }
1264         final CharArrayWriter caw = new CharArrayWriter();
1265         try (JavaWriter jw = new JavaWriter(caw)) {
1266             for (final byte b : bytes) {
1267                 final int in = b &amp; 0x000000ff; // Normalize to unsigned
1268                 jw.write(in);
1269             }
1270         }
1271         return caw.toString();
1272     }
1273 
<a name="151" id="anc151"></a>
1274     /**
1275      * Decode a string back to a byte array.
1276      *
1277      * @param s the string to convert
1278      * @param uncompress use gzip to uncompress the stream of bytes
1279      *
1280      * @throws IOException if there&#39;s a gzip exception
1281      */
1282     public static byte[] decode(final String s, final boolean uncompress) throws IOException {
1283         byte[] bytes;
1284         try (JavaReader jr = new JavaReader(new CharArrayReader(s.toCharArray()));
1285                 ByteArrayOutputStream bos = new ByteArrayOutputStream()) {
1286             int ch;
1287             while ((ch = jr.read()) &gt;= 0) {
1288                 bos.write(ch);
1289             }
1290             bytes = bos.toByteArray();
1291         }
1292         if (uncompress) {
1293             final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));
1294             final byte[] tmp = new byte[bytes.length * 3]; // Rough estimate
1295             int count = 0;
1296             int b;
1297             while ((b = gis.read()) &gt;= 0) {
1298                 tmp[count++] = (byte) b;
1299             }
1300             bytes = new byte[count];
1301             System.arraycopy(tmp, 0, bytes, 0, count);
1302         }
1303         return bytes;
1304     }
1305 
1306     // A-Z, g-z, _, $
1307     private static final int FREE_CHARS = 48;
1308     private static int[] CHAR_MAP = new int[FREE_CHARS];
1309     private static int[] MAP_CHAR = new int[256]; // Reverse map
1310     private static final char ESCAPE_CHAR = &#39;$&#39;;
<a name="152" id="anc152"></a><span class="line-removed">1311 </span>
1312     static {
1313         int j = 0;
1314         for (int i = &#39;A&#39;; i &lt;= &#39;Z&#39;; i++) {
1315             CHAR_MAP[j] = i;
1316             MAP_CHAR[i] = j;
1317             j++;
1318         }
1319         for (int i = &#39;g&#39;; i &lt;= &#39;z&#39;; i++) {
1320             CHAR_MAP[j] = i;
1321             MAP_CHAR[i] = j;
1322             j++;
1323         }
1324         CHAR_MAP[j] = &#39;$&#39;;
1325         MAP_CHAR[&#39;$&#39;] = j;
1326         j++;
1327         CHAR_MAP[j] = &#39;_&#39;;
1328         MAP_CHAR[&#39;_&#39;] = j;
1329     }
1330 
1331     /**
<a name="153" id="anc153"></a><span class="line-modified">1332      * Decode characters into bytes. Used by &lt;a</span>
<span class="line-modified">1333      * href=&quot;Utility.html#decode(java.lang.String, boolean)&quot;&gt;decode()&lt;/a&gt;</span>
1334      */
1335     private static class JavaReader extends FilterReader {
1336 
1337         public JavaReader(final Reader in) {
1338             super(in);
1339         }
1340 
<a name="154" id="anc154"></a>
1341         @Override
1342         public int read() throws IOException {
1343             final int b = in.read();
1344             if (b != ESCAPE_CHAR) {
1345                 return b;
1346             }
1347             final int i = in.read();
1348             if (i &lt; 0) {
1349                 return -1;
1350             }
1351             if (((i &gt;= &#39;0&#39;) &amp;&amp; (i &lt;= &#39;9&#39;)) || ((i &gt;= &#39;a&#39;) &amp;&amp; (i &lt;= &#39;f&#39;))) { // Normal escape
1352                 final int j = in.read();
1353                 if (j &lt; 0) {
1354                     return -1;
1355                 }
1356                 final char[] tmp = {
<a name="155" id="anc155"></a><span class="line-modified">1357                     (char) i, (char) j</span>
1358                 };
1359                 final int s = Integer.parseInt(new String(tmp), 16);
1360                 return s;
1361             }
1362             return MAP_CHAR[i];
1363         }
1364 
<a name="156" id="anc156"></a>
1365         @Override
<a name="157" id="anc157"></a><span class="line-modified">1366         public int read(final char[] cbuf, final int off, final int len) throws IOException {</span>
1367             for (int i = 0; i &lt; len; i++) {
1368                 cbuf[off + i] = (char) read();
1369             }
1370             return len;
1371         }
1372     }
1373 
1374     /**
<a name="158" id="anc158"></a><span class="line-modified">1375      * Encode bytes into valid java identifier characters. Used by &lt;a</span>
<span class="line-modified">1376      * href=&quot;Utility.html#encode(byte[], boolean)&quot;&gt;encode()&lt;/a&gt;</span>
1377      */
1378     private static class JavaWriter extends FilterWriter {
1379 
1380         public JavaWriter(final Writer out) {
1381             super(out);
1382         }
1383 
<a name="159" id="anc159"></a>
1384         @Override
<a name="160" id="anc160"></a><span class="line-modified">1385         public void write(final int b) throws IOException {</span>
1386             if (isJavaIdentifierPart((char) b) &amp;&amp; (b != ESCAPE_CHAR)) {
1387                 out.write(b);
1388             } else {
1389                 out.write(ESCAPE_CHAR); // Escape character
1390                 // Special escape
1391                 if (b &gt;= 0 &amp;&amp; b &lt; FREE_CHARS) {
1392                     out.write(CHAR_MAP[b]);
1393                 } else { // Normal escape
1394                     final char[] tmp = Integer.toHexString(b).toCharArray();
1395                     if (tmp.length == 1) {
1396                         out.write(&#39;0&#39;);
1397                         out.write(tmp[0]);
1398                     } else {
1399                         out.write(tmp[0]);
1400                         out.write(tmp[1]);
1401                     }
1402                 }
1403             }
1404         }
1405 
<a name="161" id="anc161"></a>
1406         @Override
<a name="162" id="anc162"></a><span class="line-modified">1407         public void write(final char[] cbuf, final int off, final int len) throws IOException {</span>
1408             for (int i = 0; i &lt; len; i++) {
1409                 write(cbuf[off + i]);
1410             }
1411         }
1412 
<a name="163" id="anc163"></a>
1413         @Override
<a name="164" id="anc164"></a><span class="line-modified">1414         public void write(final String str, final int off, final int len) throws IOException {</span>
1415             write(str.toCharArray(), off, len);
1416         }
1417     }
1418 
<a name="165" id="anc165"></a>
1419     /**
1420      * Escape all occurences of newline chars &#39;\n&#39;, quotes \&quot;, etc.
1421      */
<a name="166" id="anc166"></a><span class="line-modified">1422     public static String convertString(final String label) {</span>
1423         final char[] ch = label.toCharArray();
1424         final StringBuilder buf = new StringBuilder();
1425         for (final char element : ch) {
1426             switch (element) {
1427                 case &#39;\n&#39;:
1428                     buf.append(&quot;\\n&quot;);
1429                     break;
1430                 case &#39;\r&#39;:
1431                     buf.append(&quot;\\r&quot;);
1432                     break;
1433                 case &#39;\&quot;&#39;:
1434                     buf.append(&quot;\\\&quot;&quot;);
1435                     break;
1436                 case &#39;\&#39;&#39;:
1437                     buf.append(&quot;\\&#39;&quot;);
1438                     break;
1439                 case &#39;\\&#39;:
1440                     buf.append(&quot;\\\\&quot;);
1441                     break;
1442                 default:
1443                     buf.append(element);
1444                     break;
1445             }
1446         }
1447         return buf.toString();
1448     }
<a name="167" id="anc167"></a>
1449 }
<a name="168" id="anc168"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="168" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *     http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xalan.internal.xsltc.trax;
  22 
  23 import com.sun.org.apache.xalan.internal.XalanConstants;
  24 import com.sun.org.apache.xalan.internal.utils.XMLSecurityManager;
  25 import com.sun.org.apache.xalan.internal.xsltc.DOM;
  26 import com.sun.org.apache.xalan.internal.xsltc.DOMCache;
  27 import com.sun.org.apache.xalan.internal.xsltc.StripFilter;
  28 import com.sun.org.apache.xalan.internal.xsltc.Translet;
  29 import com.sun.org.apache.xalan.internal.xsltc.TransletException;
  30 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
  31 import com.sun.org.apache.xalan.internal.xsltc.dom.DOMWSFilter;
  32 import com.sun.org.apache.xalan.internal.xsltc.dom.SAXImpl;
  33 import com.sun.org.apache.xalan.internal.xsltc.dom.XSLTCDTMManager;
  34 import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
  35 import com.sun.org.apache.xalan.internal.xsltc.runtime.output.TransletOutputHandlerFactory;
  36 import com.sun.org.apache.xml.internal.dtm.DTMWSFilter;
  37 import com.sun.org.apache.xml.internal.serializer.OutputPropertiesFactory;
  38 import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
  39 import com.sun.org.apache.xml.internal.utils.SystemIDResolver;
  40 import com.sun.org.apache.xml.internal.utils.XMLReaderManager;
  41 import java.io.File;
  42 import java.io.FileOutputStream;
  43 import java.io.IOException;
  44 import java.io.InputStream;
  45 import java.io.OutputStream;
  46 import java.io.Reader;
  47 import java.io.Writer;
  48 import java.net.URI;
  49 import java.net.URL;
  50 import java.net.URLConnection;
  51 import java.net.UnknownServiceException;
  52 import java.util.ArrayList;
  53 import java.util.Enumeration;
  54 import java.util.HashMap;
  55 import java.util.List;
  56 import java.util.Map;
  57 import java.util.Properties;
  58 import java.util.StringTokenizer;
  59 import javax.xml.XMLConstants;
  60 import javax.xml.catalog.CatalogException;
  61 import javax.xml.catalog.CatalogFeatures;
  62 import javax.xml.catalog.CatalogManager;
  63 import javax.xml.catalog.CatalogResolver;
  64 import javax.xml.parsers.DocumentBuilder;
  65 import javax.xml.parsers.DocumentBuilderFactory;
  66 import javax.xml.parsers.ParserConfigurationException;
  67 import javax.xml.stream.XMLEventReader;
  68 import javax.xml.stream.XMLStreamReader;
  69 import javax.xml.transform.ErrorListener;
  70 import javax.xml.transform.OutputKeys;
  71 import javax.xml.transform.Result;
  72 import javax.xml.transform.Source;
  73 import javax.xml.transform.Transformer;
  74 import javax.xml.transform.TransformerException;
  75 import javax.xml.transform.URIResolver;
  76 import javax.xml.transform.dom.DOMResult;
  77 import javax.xml.transform.dom.DOMSource;
  78 import javax.xml.transform.sax.SAXResult;
  79 import javax.xml.transform.sax.SAXSource;
  80 import javax.xml.transform.stax.StAXResult;
  81 import javax.xml.transform.stax.StAXSource;
  82 import javax.xml.transform.stream.StreamResult;
  83 import javax.xml.transform.stream.StreamSource;
  84 import jdk.xml.internal.JdkXmlFeatures;
  85 import jdk.xml.internal.JdkXmlUtils;
<a name="1" id="anc1"></a><span class="line-added">  86 import jdk.xml.internal.TransformErrorListener;</span>
  87 import org.xml.sax.ContentHandler;
  88 import org.xml.sax.InputSource;
  89 import org.xml.sax.SAXException;
  90 import org.xml.sax.XMLReader;
  91 import org.xml.sax.ext.LexicalHandler;
  92 
  93 /**
  94  * @author Morten Jorgensen
  95  * @author G. Todd Miller
  96  * @author Santiago Pericas-Geertsen
<a name="2" id="anc2"></a><span class="line-modified">  97  * @LastModified: Aug 2019</span>
  98  */
  99 public final class TransformerImpl extends Transformer
<a name="3" id="anc3"></a><span class="line-modified"> 100     implements DOMCache</span>
 101 {
 102 
 103     private final static String LEXICAL_HANDLER_PROPERTY =
 104         &quot;http://xml.org/sax/properties/lexical-handler&quot;;
 105 
 106     /**
 107      * Namespace prefixes feature for {@link XMLReader}.
 108      */
 109     private static final String NAMESPACE_PREFIXES_FEATURE =
 110         &quot;http://xml.org/sax/features/namespace-prefixes&quot;;
 111 
 112     /**
 113      * A reference to the translet or null if the identity transform.
 114      */
 115     private AbstractTranslet _translet = null;
 116 
 117     /**
 118      * The output method of this transformation.
 119      */
 120     private String _method = null;
 121 
 122     /**
 123      * The output encoding of this transformation.
 124      */
 125     private String _encoding = null;
 126 
 127     /**
 128      * The systemId set in input source.
 129      */
 130     private String _sourceSystemId = null;
 131 
<a name="4" id="anc4"></a><span class="line-added"> 132     /**</span>
<span class="line-added"> 133      * Default error listener</span>
<span class="line-added"> 134      */</span>
<span class="line-added"> 135     private final ErrorListener _defaultListener = new TransformErrorListener();</span>
<span class="line-added"> 136 </span>
 137     /**
 138      * An error listener for runtime errors.
 139      */
<a name="5" id="anc5"></a><span class="line-modified"> 140     private ErrorListener _errorListener = _defaultListener;</span>
 141 
 142     /**
 143      * A reference to a URI resolver for calls to document().
 144      */
 145     private URIResolver _uriResolver = null;
 146 
 147     /**
 148      * Output properties of this transformer instance.
 149      */
 150     private Properties _properties, _propertiesClone;
 151 
 152     /**
 153      * A reference to an output handler factory.
 154      */
 155     private TransletOutputHandlerFactory _tohFactory = null;
 156 
 157     /**
 158      * A reference to a internal DOM representation of the input.
 159      */
 160     private DOM _dom = null;
 161 
 162     /**
 163      * Number of indent spaces to add when indentation is on.
 164      */
 165     private int _indentNumber = -1;
 166 
 167     /**
 168      * A reference to the transformer factory that this templates
 169      * object belongs to.
 170      */
 171     private TransformerFactoryImpl _tfactory = null;
 172 
 173     /**
 174      * A reference to the output stream, if we create one in our code.
 175      */
 176     private OutputStream _ostream = null;
 177 
 178     /**
 179      * A reference to the XSLTCDTMManager which is used to build the DOM/DTM
 180      * for this transformer.
 181      */
 182     private XSLTCDTMManager _dtmManager = null;
 183 
 184     /**
 185      * A reference to an object that creates and caches XMLReader objects.
 186      */
 187     private XMLReaderManager _readerManager;
 188 
 189     /**
 190      * A flag indicating whether we use incremental building of the DTM.
 191      */
 192     //private boolean _isIncremental = false;
 193 
 194     /**
 195      * A flag indicating whether this transformer implements the identity
 196      * transform.
 197      */
 198     private boolean _isIdentity = false;
 199 
 200     /**
 201      * State of the secure processing feature.
 202      */
 203     private boolean _isSecureProcessing = false;
 204 
 205     /**
 206      * Indicates whether 3rd party parser may be used to override the system-default
 207      */
 208     private boolean _overrideDefaultParser;
 209 
 210      /**
 211      * protocols allowed for external DTD references in source file and/or stylesheet.
 212      */
 213     private String _accessExternalDTD = XalanConstants.EXTERNAL_ACCESS_DEFAULT;
 214 
 215     private XMLSecurityManager _securityManager;
 216     /**
 217      * A map to store parameters for the identity transform. These
 218      * are not needed during the transformation, but we must keep track of
 219      * them to be fully complaint with the JAXP API.
 220      */
 221     private Map&lt;String, Object&gt; _parameters = null;
 222 
 223     // Catalog features
 224     CatalogFeatures _catalogFeatures;
 225     CatalogResolver _catalogUriResolver;
 226 
 227     // Catalog is enabled by default
 228     boolean _useCatalog = true;
 229 
 230     int _cdataChunkSize = JdkXmlUtils.CDATA_CHUNK_SIZE_DEFAULT;
 231 
 232     /**
 233      * This class wraps an ErrorListener into a MessageHandler in order to
 234      * capture messages reported via xsl:message.
 235      */
 236     static class MessageHandler
 237            extends com.sun.org.apache.xalan.internal.xsltc.runtime.MessageHandler
 238     {
 239         private ErrorListener _errorListener;
 240 
 241         public MessageHandler(ErrorListener errorListener) {
 242             _errorListener = errorListener;
 243         }
 244 
 245         @Override
 246         public void displayMessage(String msg) {
 247             if(_errorListener == null) {
 248                 System.err.println(msg);
 249             }
 250             else {
 251                 try {
 252                     _errorListener.warning(new TransformerException(msg));
 253                 }
 254                 catch (TransformerException e) {
 255                     // ignored
 256                 }
 257             }
 258         }
<a name="6" id="anc6"></a><span class="line-added"> 259 </span>
<span class="line-added"> 260         public ErrorListener getErrorListener() {</span>
<span class="line-added"> 261             return _errorListener;</span>
<span class="line-added"> 262         }</span>
 263     }
 264 
 265     protected TransformerImpl(Properties outputProperties, int indentNumber,
 266         TransformerFactoryImpl tfactory)
 267     {
 268         this(null, outputProperties, indentNumber, tfactory);
 269         _isIdentity = true;
 270         // _properties.put(OutputKeys.METHOD, &quot;xml&quot;);
 271     }
 272 
 273     protected TransformerImpl(Translet translet, Properties outputProperties,
 274         int indentNumber, TransformerFactoryImpl tfactory)
 275     {
 276         _translet = (AbstractTranslet) translet;
<a name="7" id="anc7"></a><span class="line-added"> 277         if (_translet != null) {</span>
<span class="line-added"> 278             _translet.setMessageHandler(new MessageHandler(_errorListener));</span>
<span class="line-added"> 279         }</span>
 280         _properties = createOutputProperties(outputProperties);
 281         _propertiesClone = (Properties) _properties.clone();
 282         _indentNumber = indentNumber;
 283         _tfactory = tfactory;
 284         _overrideDefaultParser = _tfactory.overrideDefaultParser();
 285         _accessExternalDTD = (String)_tfactory.getAttribute(XMLConstants.ACCESS_EXTERNAL_DTD);
 286         _securityManager = (XMLSecurityManager)_tfactory.getAttribute(XalanConstants.SECURITY_MANAGER);
 287         _readerManager = XMLReaderManager.getInstance(_overrideDefaultParser);
 288         _readerManager.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, _accessExternalDTD);
 289         _readerManager.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, _isSecureProcessing);
 290         _readerManager.setProperty(XalanConstants.SECURITY_MANAGER, _securityManager);
 291         _cdataChunkSize = JdkXmlUtils.getValue(_tfactory.getAttribute(JdkXmlUtils.CDATA_CHUNK_SIZE),
 292                 JdkXmlUtils.CDATA_CHUNK_SIZE_DEFAULT);
 293         _readerManager.setProperty(JdkXmlUtils.CDATA_CHUNK_SIZE, _cdataChunkSize);
 294 
 295         _useCatalog = _tfactory.getFeature(XMLConstants.USE_CATALOG);
 296         if (_useCatalog) {
 297             _catalogFeatures = (CatalogFeatures)_tfactory.getAttribute(JdkXmlFeatures.CATALOG_FEATURES);
 298             String catalogFiles = _catalogFeatures.get(CatalogFeatures.Feature.DEFER);
 299             if (catalogFiles != null) {
 300                 _readerManager.setFeature(XMLConstants.USE_CATALOG, _useCatalog);
 301                 _readerManager.setProperty(JdkXmlFeatures.CATALOG_FEATURES, _catalogFeatures);
 302             }
 303         }
 304         //_isIncremental = tfactory._incremental;
 305     }
 306 
 307     /**
 308      * Return the state of the secure processing feature.
 309      */
 310     public boolean isSecureProcessing() {
 311         return _isSecureProcessing;
 312     }
 313 
 314     /**
 315      * Set the state of the secure processing feature.
 316      */
 317     public void setSecureProcessing(boolean flag) {
 318         _isSecureProcessing = flag;
 319         _readerManager.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, _isSecureProcessing);
 320     }
 321     /**
 322      * Return the state of the services mechanism feature.
 323      */
 324     public boolean overrideDefaultParser() {
 325         return _overrideDefaultParser;
 326     }
 327 
 328     /**
 329      * Set the state of the services mechanism feature.
 330      */
 331     public void setOverrideDefaultParser(boolean flag) {
 332         _overrideDefaultParser = flag;
 333     }
 334 
 335     /**
 336      * Returns the translet wrapped inside this Transformer or
 337      * null if this is the identity transform.
 338      */
 339     protected AbstractTranslet getTranslet() {
 340         return _translet;
 341     }
 342 
 343     public boolean isIdentity() {
 344         return _isIdentity;
 345     }
 346 
 347     /**
 348      * Implements JAXP&#39;s Transformer.transform()
 349      *
 350      * @param source Contains the input XML document
 351      * @param result Will contain the output from the transformation
 352      * @throws TransformerException
 353      */
 354     @Override
 355     public void transform(Source source, Result result)
 356         throws TransformerException
 357     {
 358         if (!_isIdentity) {
 359             if (_translet == null) {
 360                 ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_TRANSLET_ERR);
 361                 throw new TransformerException(err.toString());
 362             }
 363             // Pass output properties to the translet
 364             transferOutputProperties(_translet);
 365         }
 366 
 367         final SerializationHandler toHandler = getOutputHandler(result);
 368         if (toHandler == null) {
 369             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_HANDLER_ERR);
 370             throw new TransformerException(err.toString());
 371         }
 372 
 373         if (!_isIdentity &amp;&amp; (_uriResolver != null || (_tfactory.getFeature(XMLConstants.USE_CATALOG)
 374                     &amp;&amp; _tfactory.getAttribute(JdkXmlUtils.CATALOG_FILES) != null))) {
 375             _translet.setDOMCache(this);
 376         }
 377 
 378         // Pass output properties to handler if identity
 379         if (_isIdentity) {
 380             transferOutputProperties(toHandler);
 381         }
 382 
 383         transform(source, toHandler, _encoding);
 384         try{
 385             if (result instanceof DOMResult) {
 386                 ((DOMResult)result).setNode(_tohFactory.getNode());
 387             } else if (result instanceof StAXResult) {
 388                   if (((StAXResult) result).getXMLEventWriter() != null)
 389                 {
 390                     (_tohFactory.getXMLEventWriter()).flush();
 391                 }
 392                 else if (((StAXResult) result).getXMLStreamWriter() != null) {
 393                     (_tohFactory.getXMLStreamWriter()).flush();
 394                     //result = new StAXResult(_tohFactory.getXMLStreamWriter());
 395                 }
 396             }
 397         } catch (Exception e) {
 398             System.out.println(&quot;Result writing error&quot;);
 399         }
 400     }
 401 
 402     /**
 403      * Create an output handler for the transformation output based on
 404      * the type and contents of the TrAX Result object passed to the
 405      * transform() method.
 406      */
 407     public SerializationHandler getOutputHandler(Result result)
 408         throws TransformerException
 409     {
 410         // Get output method using get() to ignore defaults
 411         _method = (String) _properties.get(OutputKeys.METHOD);
 412 
 413         // Get encoding using getProperty() to use defaults
 414         _encoding = _properties.getProperty(OutputKeys.ENCODING);
 415 
<a name="8" id="anc8"></a><span class="line-modified"> 416         _tohFactory = TransletOutputHandlerFactory</span>
<span class="line-added"> 417                 .newInstance(_overrideDefaultParser, _errorListener);</span>
 418         _tohFactory.setEncoding(_encoding);
 419         if (_method != null) {
 420             _tohFactory.setOutputMethod(_method);
 421         }
 422 
 423         // Set indentation number in the factory
 424         if (_indentNumber &gt;= 0) {
 425             _tohFactory.setIndentNumber(_indentNumber);
 426         }
 427 
 428         // Return the content handler for this Result object
 429         try {
 430             // Result object could be SAXResult, DOMResult, or StreamResult
 431             if (result instanceof SAXResult) {
 432                 final SAXResult target = (SAXResult)result;
 433                 final ContentHandler handler = target.getHandler();
 434 
 435                 _tohFactory.setHandler(handler);
 436 
 437                 /**
 438                  * Fix for bug 24414
 439                  * If the lexicalHandler is set then we need to get that
 440                  * for obtaining the lexical information
 441                  */
 442                 LexicalHandler lexicalHandler = target.getLexicalHandler();
 443 
 444                 if (lexicalHandler != null ) {
 445                     _tohFactory.setLexicalHandler(lexicalHandler);
 446                 }
 447 
 448                 _tohFactory.setOutputType(TransletOutputHandlerFactory.SAX);
 449                 return _tohFactory.getSerializationHandler();
 450             }
 451             else if (result instanceof StAXResult) {
 452                 if (((StAXResult) result).getXMLEventWriter() != null)
 453                     _tohFactory.setXMLEventWriter(((StAXResult) result).getXMLEventWriter());
 454                 else if (((StAXResult) result).getXMLStreamWriter() != null)
 455                     _tohFactory.setXMLStreamWriter(((StAXResult) result).getXMLStreamWriter());
 456                 _tohFactory.setOutputType(TransletOutputHandlerFactory.STAX);
 457                 return _tohFactory.getSerializationHandler();
 458             }
 459             else if (result instanceof DOMResult) {
 460                 _tohFactory.setNode(((DOMResult) result).getNode());
 461                 _tohFactory.setNextSibling(((DOMResult) result).getNextSibling());
 462                 _tohFactory.setOutputType(TransletOutputHandlerFactory.DOM);
 463                 return _tohFactory.getSerializationHandler();
 464             }
 465             else if (result instanceof StreamResult) {
 466                 // Get StreamResult
 467                 final StreamResult target = (StreamResult) result;
 468 
 469                 // StreamResult may have been created with a java.io.File,
 470                 // java.io.Writer, java.io.OutputStream or just a String
 471                 // systemId.
 472 
 473                 _tohFactory.setOutputType(TransletOutputHandlerFactory.STREAM);
 474 
 475                 // try to get a Writer from Result object
 476                 final Writer writer = target.getWriter();
 477                 if (writer != null) {
 478                     _tohFactory.setWriter(writer);
 479                     return _tohFactory.getSerializationHandler();
 480                 }
 481 
 482                 // or try to get an OutputStream from Result object
 483                 final OutputStream ostream = target.getOutputStream();
 484                 if (ostream != null) {
 485                     _tohFactory.setOutputStream(ostream);
 486                     return _tohFactory.getSerializationHandler();
 487                 }
 488 
 489                 // or try to get just a systemId string from Result object
 490                 String systemId = result.getSystemId();
 491                 if (systemId == null) {
 492                     ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_RESULT_ERR);
 493                     throw new TransformerException(err.toString());
 494                 }
 495 
 496                 // System Id may be in one of several forms, (1) a uri
 497                 // that starts with &#39;file:&#39;, (2) uri that starts with &#39;http:&#39;
 498                 // or (3) just a filename on the local system.
 499                 URL url;
 500                 if (systemId.startsWith(&quot;file:&quot;)) {
 501                     // if StreamResult(File) or setSystemID(File) was used,
 502                     // the systemId will be URI encoded as a result of File.toURI(),
 503                     // it must be decoded for use by URL
 504                     try{
 505                         URI uri = new URI(systemId) ;
 506                         systemId = &quot;file:&quot;;
 507 
 508                         String host = uri.getHost(); // decoded String
 509                         String path = uri.getPath(); //decoded String
 510                         if (path == null) {
 511                          path = &quot;&quot;;
 512                         }
 513 
 514                         // if host (URI authority) then file:// + host + path
 515                         // else just path (may be absolute or relative)
 516                         if (host != null) {
 517                          systemId += &quot;//&quot; + host + path;
 518                         } else {
 519                          systemId += &quot;//&quot; + path;
 520                         }
 521                     }
 522                     catch (Exception  exception) {
 523                         // URI exception which means nothing can be done so OK to ignore
 524                     }
 525 
 526                     url = new URL(systemId);
 527                     _ostream = new FileOutputStream(url.getFile());
 528                     _tohFactory.setOutputStream(_ostream);
 529                     return _tohFactory.getSerializationHandler();
 530                 }
 531                 else if (systemId.startsWith(&quot;http:&quot;)) {
 532                     url = new URL(systemId);
 533                     final URLConnection connection = url.openConnection();
 534                     _tohFactory.setOutputStream(_ostream = connection.getOutputStream());
 535                     return _tohFactory.getSerializationHandler();
 536                 }
 537                 else {
 538                     // system id is just a filename
 539                     _tohFactory.setOutputStream(
 540                         _ostream = new FileOutputStream(new File(systemId)));
 541                     return _tohFactory.getSerializationHandler();
 542                 }
 543             }
 544         }
 545         // If we cannot write to the location specified by the SystemId
 546         catch (UnknownServiceException e) {
 547             throw new TransformerException(e);
 548         }
 549         catch (ParserConfigurationException e) {
 550             throw new TransformerException(e);
 551         }
 552         // If we cannot create the file specified by the SystemId
 553         catch (IOException e) {
 554             throw new TransformerException(e);
 555         }
 556         return null;
 557     }
 558 
 559     /**
 560      * Set the internal DOM that will be used for the next transformation
 561      */
 562     protected void setDOM(DOM dom) {
 563         _dom = dom;
 564     }
 565 
 566     /**
 567      * Builds an internal DOM from a TrAX Source object
 568      */
 569     private DOM getDOM(Source source) throws TransformerException {
 570         try {
 571             DOM dom;
 572 
 573             if (source != null) {
 574                 DTMWSFilter wsfilter;
 575                 if (_translet != null &amp;&amp; _translet instanceof StripFilter) {
 576                     wsfilter = new DOMWSFilter(_translet);
 577                  } else {
 578                     wsfilter = null;
 579                  }
 580 
 581                  boolean hasIdCall = (_translet != null) ? _translet.hasIdCall()
 582                                                          : false;
 583 
 584                  if (_dtmManager == null) {
 585                      _dtmManager =
 586                          _tfactory.createNewDTMManagerInstance();
 587                      _dtmManager.setOverrideDefaultParser(_overrideDefaultParser);
 588                  }
 589                  dom = (DOM)_dtmManager.getDTM(source, false, wsfilter, true,
 590                                               false, false, 0, hasIdCall);
 591             } else if (_dom != null) {
 592                  dom = _dom;
 593                  _dom = null;  // use only once, so reset to &#39;null&#39;
 594             } else {
 595                  return null;
 596             }
 597 
 598             if (!_isIdentity) {
 599                 // Give the translet the opportunity to make a prepass of
 600                 // the document, in case it can extract useful information early
 601                 _translet.prepassDocument(dom);
 602             }
 603 
 604             return dom;
 605 
 606         }
 607         catch (Exception e) {
 608             if (_errorListener != null) {
 609                 postErrorToListener(e.getMessage());
 610             }
 611             throw new TransformerException(e);
 612         }
 613     }
 614 
 615     /**
 616      * Returns the {@link com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl}
 617      * object that create this &lt;code&gt;Transformer&lt;/code&gt;.
 618      */
 619     protected TransformerFactoryImpl getTransformerFactory() {
 620         return _tfactory;
 621     }
 622 
 623     /**
 624      * Returns the {@link com.sun.org.apache.xalan.internal.xsltc.runtime.output.TransletOutputHandlerFactory}
 625      * object that create the &lt;code&gt;TransletOutputHandler&lt;/code&gt;.
 626      */
 627     protected TransletOutputHandlerFactory getTransletOutputHandlerFactory() {
 628         return _tohFactory;
 629     }
 630 
 631     private void transformIdentity(Source source, SerializationHandler handler)
 632         throws Exception
 633     {
 634         // Get systemId from source
 635         if (source != null) {
 636             _sourceSystemId = source.getSystemId();
 637         }
 638 
 639         if (source instanceof StreamSource) {
 640             final StreamSource stream = (StreamSource) source;
 641             final InputStream streamInput = stream.getInputStream();
 642             final Reader streamReader = stream.getReader();
 643             final XMLReader reader = _readerManager.getXMLReader();
 644 
 645             try {
 646                 // Hook up reader and output handler
 647                 try {
 648                     reader.setProperty(LEXICAL_HANDLER_PROPERTY, handler);
 649                     reader.setFeature(NAMESPACE_PREFIXES_FEATURE, true);
 650                 } catch (SAXException e) {
 651                     // Falls through
 652                 }
 653                 reader.setContentHandler(handler);
 654 
 655                 // Create input source from source
 656                 InputSource input;
 657                 if (streamInput != null) {
 658                     input = new InputSource(streamInput);
 659                     input.setSystemId(_sourceSystemId);
 660                 }
 661                 else if (streamReader != null) {
 662                     input = new InputSource(streamReader);
 663                     input.setSystemId(_sourceSystemId);
 664                 }
 665                 else if (_sourceSystemId != null) {
 666                     input = new InputSource(_sourceSystemId);
 667                 }
 668                 else {
 669                     ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);
 670                     throw new TransformerException(err.toString());
 671                 }
 672 
 673                 // Start pushing SAX events
 674                 reader.parse(input);
 675             } finally {
 676                 _readerManager.releaseXMLReader(reader);
 677             }
 678         } else if (source instanceof SAXSource) {
 679             final SAXSource sax = (SAXSource) source;
 680             XMLReader reader = sax.getXMLReader();
 681             final InputSource input = sax.getInputSource();
 682             boolean userReader = true;
 683 
 684             try {
 685                 // Create a reader if not set by user
 686                 if (reader == null) {
 687                     reader = _readerManager.getXMLReader();
 688                     userReader = false;
 689                 }
 690 
 691                 // Hook up reader and output handler
 692                 try {
 693                     reader.setProperty(LEXICAL_HANDLER_PROPERTY, handler);
 694                     reader.setFeature(NAMESPACE_PREFIXES_FEATURE, true);
 695                 } catch (SAXException e) {
 696                     // Falls through
 697                 }
 698                 reader.setContentHandler(handler);
 699 
 700                 // Start pushing SAX events
 701                 reader.parse(input);
 702             } finally {
 703                 if (!userReader) {
 704                     _readerManager.releaseXMLReader(reader);
 705                 }
 706             }
 707         } else if (source instanceof StAXSource) {
 708             final StAXSource staxSource = (StAXSource)source;
 709             StAXEvent2SAX staxevent2sax;
 710             StAXStream2SAX staxStream2SAX;
 711             if (staxSource.getXMLEventReader() != null) {
 712                 final XMLEventReader xmlEventReader = staxSource.getXMLEventReader();
 713                 staxevent2sax = new StAXEvent2SAX(xmlEventReader);
 714                 staxevent2sax.setContentHandler(handler);
 715                 staxevent2sax.parse();
 716                 handler.flushPending();
 717             } else if (staxSource.getXMLStreamReader() != null) {
 718                 final XMLStreamReader xmlStreamReader = staxSource.getXMLStreamReader();
 719                 staxStream2SAX = new StAXStream2SAX(xmlStreamReader);
 720                 staxStream2SAX.setContentHandler(handler);
 721                 staxStream2SAX.parse();
 722                 handler.flushPending();
 723             }
 724         } else if (source instanceof DOMSource) {
 725             final DOMSource domsrc = (DOMSource) source;
 726             new DOM2TO(domsrc.getNode(), handler).parse();
 727         } else if (source instanceof XSLTCSource) {
 728             final DOM dom = ((XSLTCSource) source).getDOM(null, _translet);
 729             ((SAXImpl)dom).copy(handler);
 730         } else {
 731             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);
 732             throw new TransformerException(err.toString());
 733         }
 734     }
 735 
 736     /**
 737      * Internal transformation method - uses the internal APIs of XSLTC
 738      */
 739     private void transform(Source source, SerializationHandler handler,
 740         String encoding) throws TransformerException
 741     {
 742         try {
 743             /*
 744              * According to JAXP1.2, new SAXSource()/StreamSource()
 745              * should create an empty input tree, with a default root node.
 746              * new DOMSource()creates an empty document using DocumentBuilder.
 747              * newDocument(); Use DocumentBuilder.newDocument() for all 3
 748              * situations, since there is no clear spec. how to create
 749              * an empty tree when both SAXSource() and StreamSource() are used.
 750              */
 751             if ((source instanceof StreamSource &amp;&amp; source.getSystemId()==null
 752                 &amp;&amp; ((StreamSource)source).getInputStream()==null &amp;&amp;
 753                 ((StreamSource)source).getReader()==null)||
 754                 (source instanceof SAXSource &amp;&amp;
 755                 ((SAXSource)source).getInputSource()==null &amp;&amp;
 756                 ((SAXSource)source).getXMLReader()==null )||
 757                 (source instanceof DOMSource &amp;&amp;
 758                 ((DOMSource)source).getNode()==null)){
 759 
 760                 boolean supportCatalog = true;
 761 
 762                 DocumentBuilderFactory builderF = JdkXmlUtils.getDOMFactory(_overrideDefaultParser);
 763                 try {
 764                     builderF.setFeature(XMLConstants.USE_CATALOG, _useCatalog);
 765                 } catch (ParserConfigurationException e) {
 766                     supportCatalog = false;
 767                 }
 768 
 769                 if (supportCatalog &amp;&amp; _useCatalog) {
 770                     CatalogFeatures cf = (CatalogFeatures)_tfactory.getAttribute(JdkXmlFeatures.CATALOG_FEATURES);
 771                     if (cf != null) {
 772                         for (CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {
 773                             builderF.setAttribute(f.getPropertyName(), cf.get(f));
 774                         }
 775                     }
 776                 }
 777 
 778                 DocumentBuilder builder = builderF.newDocumentBuilder();
 779                 String systemID = source.getSystemId();
 780                 source = new DOMSource(builder.newDocument());
 781 
 782                 // Copy system ID from original, empty Source to new
 783                 if (systemID != null) {
 784                   source.setSystemId(systemID);
 785                 }
 786             }
 787             if (_isIdentity) {
 788                 transformIdentity(source, handler);
 789             } else {
 790                 _translet.transform(getDOM(source), handler);
 791             }
 792         } catch (TransletException e) {
 793             if (_errorListener != null) postErrorToListener(e.getMessage());
 794             throw new TransformerException(e);
 795         } catch (RuntimeException e) {
 796             if (_errorListener != null) postErrorToListener(e.getMessage());
 797             throw new TransformerException(e);
 798         } catch (Exception e) {
 799             if (_errorListener != null) postErrorToListener(e.getMessage());
 800             throw new TransformerException(e);
 801         } finally {
 802             _dtmManager = null;
 803         }
 804 
 805         // If we create an output stream for the Result, we need to close it after the transformation.
 806         if (_ostream != null) {
 807             try {
 808                 _ostream.close();
 809             }
 810             catch (IOException e) {}
 811             _ostream = null;
 812         }
 813     }
 814 
 815     /**
 816      * Implements JAXP&#39;s Transformer.getErrorListener()
 817      * Get the error event handler in effect for the transformation.
 818      *
 819      * @return The error event handler currently in effect
 820      */
 821     @Override
 822     public ErrorListener getErrorListener() {
 823         return _errorListener;
 824     }
 825 
 826     /**
 827      * Implements JAXP&#39;s Transformer.setErrorListener()
 828      * Set the error event listener in effect for the transformation.
 829      * Register a message handler in the translet in order to forward
 830      * xsl:messages to error listener.
 831      *
 832      * @param listener The error event listener to use
 833      * @throws IllegalArgumentException
 834      */
 835     @Override
 836     public void setErrorListener(ErrorListener listener)
 837         throws IllegalArgumentException {
 838         if (listener == null) {
 839             ErrorMsg err = new ErrorMsg(ErrorMsg.ERROR_LISTENER_NULL_ERR,
 840                                         &quot;Transformer&quot;);
 841             throw new IllegalArgumentException(err.toString());
 842         }
 843         _errorListener = listener;
 844 
 845         // Register a message handler to report xsl:messages
<a name="9" id="anc9"></a><span class="line-modified"> 846         if (_translet != null)</span>
<span class="line-modified"> 847             _translet.setMessageHandler(new MessageHandler(_errorListener));</span>
 848     }
 849 
 850     /**
 851      * Inform TrAX error listener of an error
 852      */
 853     private void postErrorToListener(String message) {
 854         try {
 855             _errorListener.error(new TransformerException(message));
 856         }
 857         catch (TransformerException e) {
 858             // ignored - transformation cannot be continued
 859         }
 860     }
 861 
 862     /**
 863      * Inform TrAX error listener of a warning
 864      */
 865     private void postWarningToListener(String message) {
 866         try {
 867             _errorListener.warning(new TransformerException(message));
 868         }
 869         catch (TransformerException e) {
 870             // ignored - transformation cannot be continued
 871         }
 872     }
 873 
 874     /**
 875      * Implements JAXP&#39;s Transformer.getOutputProperties().
 876      * Returns a copy of the output properties for the transformation. This is
 877      * a set of layered properties. The first layer contains properties set by
 878      * calls to setOutputProperty() and setOutputProperties() on this class,
 879      * and the output settings defined in the stylesheet&#39;s &lt;xsl:output&gt;
 880      * element makes up the second level, while the default XSLT output
 881      * settings are returned on the third level.
 882      *
 883      * @return Properties in effect for this Transformer
 884      */
 885     @Override
 886     public Properties getOutputProperties() {
 887         return (Properties) _properties.clone();
 888     }
 889 
 890     /**
 891      * Implements JAXP&#39;s Transformer.getOutputProperty().
 892      * Get an output property that is in effect for the transformation. The
 893      * property specified may be a property that was set with setOutputProperty,
 894      * or it may be a property specified in the stylesheet.
 895      *
 896      * @param name A non-null string that contains the name of the property
 897      * @throws IllegalArgumentException if the property name is not known
 898      */
 899     @Override
 900     public String getOutputProperty(String name)
 901         throws IllegalArgumentException
 902     {
 903         if (!validOutputProperty(name)) {
 904             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
 905             throw new IllegalArgumentException(err.toString());
 906         }
 907         return _properties.getProperty(name);
 908     }
 909 
 910     /**
 911      * Implements JAXP&#39;s Transformer.setOutputProperties().
 912      * Set the output properties for the transformation. These properties
 913      * will override properties set in the Templates with xsl:output.
 914      * Unrecognised properties will be quitely ignored.
 915      *
 916      * @param properties The properties to use for the Transformer
 917      * @throws IllegalArgumentException Never, errors are ignored
 918      */
 919     @Override
 920     public void setOutputProperties(Properties properties)
 921         throws IllegalArgumentException
 922     {
 923         if (properties != null) {
 924             final Enumeration&lt;?&gt; names = properties.propertyNames();
 925 
 926             while (names.hasMoreElements()) {
 927                 final String name = (String) names.nextElement();
 928 
 929                 // Ignore lower layer properties
 930                 if (isDefaultProperty(name, properties)) continue;
 931 
 932                 if (validOutputProperty(name)) {
 933                     _properties.setProperty(name, properties.getProperty(name));
 934                 }
 935                 else {
 936                     ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
 937                     throw new IllegalArgumentException(err.toString());
 938                 }
 939             }
 940         }
 941         else {
 942             _properties = (Properties)_propertiesClone.clone();
 943         }
 944     }
 945 
 946     /**
 947      * Implements JAXP&#39;s Transformer.setOutputProperty().
 948      * Get an output property that is in effect for the transformation. The
 949      * property specified may be a property that was set with
 950      * setOutputProperty(), or it may be a property specified in the stylesheet.
 951      *
 952      * @param name The name of the property to set
 953      * @param value The value to assign to the property
 954      * @throws IllegalArgumentException Never, errors are ignored
 955      */
 956     @Override
 957     public void setOutputProperty(String name, String value)
 958         throws IllegalArgumentException
 959     {
 960         if (!validOutputProperty(name)) {
 961             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
 962             throw new IllegalArgumentException(err.toString());
 963         }
 964         _properties.setProperty(name, value);
 965     }
 966 
 967     /**
 968      * Internal method to pass any properties to the translet prior to
 969      * initiating the transformation
 970      */
 971     private void transferOutputProperties(AbstractTranslet translet)
 972     {
 973         // Return right now if no properties are set
 974         if (_properties == null) return;
 975 
 976         // Get a list of all the defined properties
 977         Enumeration&lt;?&gt; names = _properties.propertyNames();
 978         while (names.hasMoreElements()) {
 979             // Note the use of get() instead of getProperty()
 980             String name  = (String) names.nextElement();
 981             String value = (String) _properties.get(name);
 982 
 983             // Ignore default properties
 984             if (value == null) continue;
 985 
 986             // Pass property value to translet - override previous setting
 987             if (name.equals(OutputKeys.ENCODING)) {
 988                 translet._encoding = value;
 989             }
 990             else if (name.equals(OutputKeys.METHOD)) {
 991                 translet._method = value;
 992             }
 993             else if (name.equals(OutputKeys.DOCTYPE_PUBLIC)) {
 994                 translet._doctypePublic = value;
 995             }
 996             else if (name.equals(OutputKeys.DOCTYPE_SYSTEM)) {
 997                 translet._doctypeSystem = value;
 998             }
 999             else if (name.equals(OutputKeys.MEDIA_TYPE)) {
1000                 translet._mediaType = value;
1001             }
1002             else if (name.equals(OutputKeys.STANDALONE)) {
1003                 translet._standalone = value;
1004             }
1005             else if (name.equals(OutputKeys.VERSION)) {
1006                 translet._version = value;
1007             }
1008             else if (name.equals(OutputKeys.OMIT_XML_DECLARATION)) {
1009                 translet._omitHeader =
1010                     (value != null &amp;&amp; value.toLowerCase().equals(&quot;yes&quot;));
1011             }
1012             else if (name.equals(OutputKeys.INDENT)) {
1013                 translet._indent =
1014                     (value != null &amp;&amp; value.toLowerCase().equals(&quot;yes&quot;));
1015             }
1016             else if (name.equals(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL +&quot;indent-amount&quot;)) {
1017                  if (value != null) {
1018                      translet._indentamount = Integer.parseInt(value);
1019                  }
1020             }
1021             else if (name.equals(OutputPropertiesFactory.S_BUILTIN_EXTENSIONS_UNIVERSAL +&quot;indent-amount&quot;)) {
1022                  if (value != null) {
1023                      translet._indentamount = Integer.parseInt(value);
1024                  }
1025             }
1026             else if (name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)) {
1027                 if (value != null) {
1028                     translet._cdata = null; // clear previous setting
1029                     StringTokenizer e = new StringTokenizer(value);
1030                     while (e.hasMoreTokens()) {
1031                         translet.addCdataElement(e.nextToken());
1032                     }
1033                 }
1034             }
1035             else if (name.equals(OutputPropertiesFactory.ORACLE_IS_STANDALONE)) {
1036                  if (value != null &amp;&amp; value.equals(&quot;yes&quot;)) {
1037                      translet._isStandalone = true;
1038                  }
1039             }
1040         }
1041     }
1042 
1043     /**
1044      * This method is used to pass any properties to the output handler
1045      * when running the identity transform.
1046      */
1047     public void transferOutputProperties(SerializationHandler handler)
1048     {
1049         // Return right now if no properties are set
1050         if (_properties == null) return;
1051 
1052         String doctypePublic = null;
1053         String doctypeSystem = null;
1054 
1055         // Get a list of all the defined properties
1056         Enumeration&lt;?&gt; names = _properties.propertyNames();
1057         while (names.hasMoreElements()) {
1058             // Note the use of get() instead of getProperty()
1059             String name  = (String) names.nextElement();
1060             String value = (String) _properties.get(name);
1061 
1062             // Ignore default properties
1063             if (value == null) continue;
1064 
1065             // Pass property value to translet - override previous setting
1066             if (name.equals(OutputKeys.DOCTYPE_PUBLIC)) {
1067                 doctypePublic = value;
1068             }
1069             else if (name.equals(OutputKeys.DOCTYPE_SYSTEM)) {
1070                 doctypeSystem = value;
1071             }
1072             else if (name.equals(OutputKeys.MEDIA_TYPE)) {
1073                 handler.setMediaType(value);
1074             }
1075             else if (name.equals(OutputKeys.STANDALONE)) {
1076                 handler.setStandalone(value);
1077             }
1078             else if (name.equals(OutputKeys.VERSION)) {
1079                 handler.setVersion(value);
1080             }
1081             else if (name.equals(OutputKeys.OMIT_XML_DECLARATION)) {
1082                 handler.setOmitXMLDeclaration(
1083                     value != null &amp;&amp; value.toLowerCase().equals(&quot;yes&quot;));
1084             }
1085             else if (name.equals(OutputKeys.INDENT)) {
1086                 handler.setIndent(
1087                     value != null &amp;&amp; value.toLowerCase().equals(&quot;yes&quot;));
1088             }
1089             else if (name.equals(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL +&quot;indent-amount&quot;)) {
1090                 if (value != null) {
1091                     handler.setIndentAmount(Integer.parseInt(value));
1092                 }
1093             }
1094             else if (name.equals(OutputPropertiesFactory.S_BUILTIN_EXTENSIONS_UNIVERSAL +&quot;indent-amount&quot;)) {
1095                 if (value != null) {
1096                     handler.setIndentAmount(Integer.parseInt(value));
1097                 }
1098             }
1099             else if (name.equals(OutputPropertiesFactory.ORACLE_IS_STANDALONE)) {
1100                 if (value != null &amp;&amp; value.equals(&quot;yes&quot;)) {
1101                     handler.setIsStandalone(true);
1102                 }
1103             }
1104             else if (name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)) {
1105                 if (value != null) {
1106                     StringTokenizer e = new StringTokenizer(value);
1107                     List&lt;String&gt; uriAndLocalNames = null;
1108                     while (e.hasMoreTokens()) {
1109                         final String token = e.nextToken();
1110 
1111                         // look for the last colon, as the String may be
1112                         // something like &quot;http://abc.com:local&quot;
1113                         int lastcolon = token.lastIndexOf(&#39;:&#39;);
1114                         String uri;
1115                         String localName;
1116                         if (lastcolon &gt; 0) {
1117                             uri = token.substring(0, lastcolon);
1118                             localName = token.substring(lastcolon+1);
1119                         } else {
1120                             // no colon at all, lets hope this is the
1121                             // local name itself then
1122                             uri = null;
1123                             localName = token;
1124                         }
1125 
1126                         if (uriAndLocalNames == null) {
1127                             uriAndLocalNames = new ArrayList&lt;&gt;();
1128                         }
1129                         // add the uri/localName as a pair, in that order
1130                         uriAndLocalNames.add(uri);
1131                         uriAndLocalNames.add(localName);
1132                     }
1133                     handler.setCdataSectionElements(uriAndLocalNames);
1134                 }
1135             }
1136         }
1137 
1138         // Call setDoctype() if needed
1139         if (doctypePublic != null || doctypeSystem != null) {
1140             handler.setDoctype(doctypeSystem, doctypePublic);
1141         }
1142     }
1143 
1144     /**
1145      * Internal method to create the initial set of properties. There
1146      * are two layers of properties: the default layer and the base layer.
1147      * The latter contains properties defined in the stylesheet or by
1148      * the user using this API.
1149      */
1150     private Properties createOutputProperties(Properties outputProperties) {
1151         final Properties defaults = new Properties();
1152         setDefaults(defaults, &quot;xml&quot;);
1153 
1154         // Copy propeties set in stylesheet to base
1155         final Properties base = new Properties(defaults);
1156         if (outputProperties != null) {
1157             final Enumeration&lt;?&gt; names = outputProperties.propertyNames();
1158             while (names.hasMoreElements()) {
1159                 final String name = (String) names.nextElement();
1160                 base.setProperty(name, outputProperties.getProperty(name));
1161             }
1162         }
1163         else {
1164             base.setProperty(OutputKeys.ENCODING, _translet._encoding);
1165             if (_translet._method != null)
1166                 base.setProperty(OutputKeys.METHOD, _translet._method);
1167         }
1168 
1169         // Update defaults based on output method
1170         final String method = base.getProperty(OutputKeys.METHOD);
1171         if (method != null) {
1172             if (method.equals(&quot;html&quot;)) {
1173                 setDefaults(defaults,&quot;html&quot;);
1174             }
1175             else if (method.equals(&quot;text&quot;)) {
1176                 setDefaults(defaults,&quot;text&quot;);
1177             }
1178         }
1179 
1180         return base;
1181     }
1182 
1183         /**
1184          * Internal method to get the default properties from the
1185          * serializer factory and set them on the property object.
1186          * @param props a java.util.Property object on which the properties are set.
1187          * @param method The output method type, one of &quot;xml&quot;, &quot;text&quot;, &quot;html&quot; ...
1188          */
1189         private void setDefaults(Properties props, String method)
1190         {
1191                 final Properties method_props =
1192                         OutputPropertiesFactory.getDefaultMethodProperties(method);
1193                 {
1194                     final Enumeration&lt;?&gt; names = method_props.propertyNames();
1195                     while (names.hasMoreElements())
1196                     {
1197                         final String name = (String)names.nextElement();
1198                         props.setProperty(name, method_props.getProperty(name));
1199                     }
1200                 }
1201         }
1202     /**
1203      * Verifies if a given output property name is a property defined in
1204      * the JAXP 1.1 / TrAX spec
1205      */
1206     private boolean validOutputProperty(String name) {
1207         return (name.equals(OutputKeys.ENCODING) ||
1208                 name.equals(OutputKeys.METHOD) ||
1209                 name.equals(OutputKeys.INDENT) ||
1210                 name.equals(OutputKeys.DOCTYPE_PUBLIC) ||
1211                 name.equals(OutputKeys.DOCTYPE_SYSTEM) ||
1212                 name.equals(OutputKeys.CDATA_SECTION_ELEMENTS) ||
1213                 name.equals(OutputKeys.MEDIA_TYPE) ||
1214                 name.equals(OutputKeys.OMIT_XML_DECLARATION)   ||
1215                 name.equals(OutputKeys.STANDALONE) ||
1216                 name.equals(OutputKeys.VERSION) ||
1217                 name.equals(OutputPropertiesFactory.ORACLE_IS_STANDALONE) ||
1218                 name.charAt(0) == &#39;{&#39;);
1219     }
1220 
1221     /**
1222      * Checks if a given output property is default (2nd layer only)
1223      */
1224     private boolean isDefaultProperty(String name, Properties properties) {
1225         return (properties.get(name) == null);
1226     }
1227 
1228     /**
1229      * Implements JAXP&#39;s Transformer.setParameter()
1230      * Add a parameter for the transformation. The parameter is simply passed
1231      * on to the translet - no validation is performed - so any unused
1232      * parameters are quitely ignored by the translet.
1233      *
1234      * @param name The name of the parameter
1235      * @param value The value to assign to the parameter
1236      */
1237     @Override
1238     public void setParameter(String name, Object value) {
1239 
1240         if (value == null) {
1241             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_INVALID_SET_PARAM_VALUE, name);
1242             throw new IllegalArgumentException(err.toString());
1243         }
1244 
1245         if (_isIdentity) {
1246             if (_parameters == null) {
1247                 _parameters = new HashMap&lt;&gt;();
1248             }
1249             _parameters.put(name, value);
1250         }
1251         else {
1252             _translet.addParameter(name, value);
1253         }
1254     }
1255 
1256     /**
1257      * Implements JAXP&#39;s Transformer.clearParameters()
1258      * Clear all parameters set with setParameter. Clears the translet&#39;s
1259      * parameter stack.
1260      */
1261     @Override
1262     public void clearParameters() {
1263         if (_isIdentity &amp;&amp; _parameters != null) {
1264             _parameters.clear();
1265         }
1266         else {
1267             _translet.clearParameters();
1268         }
1269     }
1270 
1271     /**
1272      * Implements JAXP&#39;s Transformer.getParameter()
1273      * Returns the value of a given parameter. Note that the translet will not
1274      * keep values for parameters that were not defined in the stylesheet.
1275      *
1276      * @param name The name of the parameter
1277      * @return An object that contains the value assigned to the parameter
1278      */
1279     @Override
1280     public final Object getParameter(String name) {
1281         if (_isIdentity) {
1282             return (_parameters != null) ? _parameters.get(name) : null;
1283         }
1284         else {
1285             return _translet.getParameter(name);
1286         }
1287     }
1288 
1289     /**
1290      * Implements JAXP&#39;s Transformer.getURIResolver()
1291      * Set the object currently used to resolve URIs used in document().
1292      *
1293      * @return  The URLResolver object currently in use
1294      */
1295     @Override
1296     public URIResolver getURIResolver() {
1297         return _uriResolver;
1298     }
1299 
1300     /**
1301      * Implements JAXP&#39;s Transformer.setURIResolver()
1302      * Set an object that will be used to resolve URIs used in document().
1303      *
1304      * @param resolver The URIResolver to use in document()
1305      */
1306     @Override
1307     public void setURIResolver(URIResolver resolver) {
1308         _uriResolver = resolver;
1309     }
1310 
1311     /**
1312      * This class should only be used as a DOMCache for the translet if the
1313      * URIResolver has been set.
1314      *
1315      * The method implements XSLTC&#39;s DOMCache interface, which is used to
1316      * plug in an external document loader into a translet. This method acts
1317      * as an adapter between TrAX&#39;s URIResolver interface and XSLTC&#39;s
1318      * DOMCache interface. This approach is simple, but removes the
1319      * possibility of using external document caches with XSLTC.
1320      *
1321      * @param baseURI The base URI used by the document call.
1322      * @param href The href argument passed to the document function.
1323      * @param translet A reference to the translet requesting the document
1324      */
1325     @Override
1326     public DOM retrieveDocument(String baseURI, String href, Translet translet) {
1327         try {
1328             // Argument to document function was: document(&#39;&#39;);
1329             if (href.length() == 0) {
1330                 href = baseURI;
1331             }
1332 
1333             /*
1334              *  Fix for bug 24188
1335              *  Incase the _uriResolver.resolve(href,base) is null
1336              *  try to still  retrieve the document before returning null
1337              *  and throwing the FileNotFoundException in
1338              *  com.sun.org.apache.xalan.internal.xsltc.dom.LoadDocument
1339              *
1340              */
1341             Source resolvedSource = null;
1342             if (_uriResolver != null) {
1343                 resolvedSource = _uriResolver.resolve(href, baseURI);
1344             }
1345 
1346             if (resolvedSource == null &amp;&amp; _useCatalog &amp;&amp;
1347                     _catalogFeatures.get(CatalogFeatures.Feature.FILES) != null)  {
1348                 if (_catalogUriResolver == null) {
1349                     _catalogUriResolver = CatalogManager.catalogResolver(_catalogFeatures);
1350                 }
1351                 resolvedSource = _catalogUriResolver.resolve(href, baseURI);
1352             }
1353 
1354             if (resolvedSource == null)  {
1355                 StreamSource streamSource = new StreamSource(
1356                      SystemIDResolver.getAbsoluteURI(href, baseURI));
1357                 return getDOM(streamSource) ;
1358             }
1359 
1360             return getDOM(resolvedSource);
1361         }
1362         catch (TransformerException | CatalogException e) {
1363             if (_errorListener != null)
1364                 postErrorToListener(&quot;File not found: &quot; + e.getMessage());
1365             return(null);
1366         }
1367     }
1368 
<a name="10" id="anc10"></a>



















































































1369     /**
1370      * This method resets  the Transformer to its original configuration
1371      * Transformer code is reset to the same state it was when it was
1372      * created
1373      * @since 1.5
1374      */
1375     @Override
1376     public void reset() {
1377 
1378         _method = null;
1379         _encoding = null;
1380         _sourceSystemId = null;
<a name="11" id="anc11"></a><span class="line-modified">1381         _errorListener = _defaultListener;</span>
1382         _uriResolver = null;
1383         _dom = null;
1384         _parameters = null;
1385         _indentNumber = -1;
1386         setOutputProperties (null);
1387         _tohFactory = null;
1388         _ostream = null;
1389 
1390     }
1391 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
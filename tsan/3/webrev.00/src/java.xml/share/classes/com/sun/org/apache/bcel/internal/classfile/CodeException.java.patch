diff a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/CodeException.java b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/CodeException.java
--- a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/CodeException.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/CodeException.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -29,12 +29,12 @@
 /**
  * This class represents an entry in the exception table of the <em>Code</em>
  * attribute and is used only there. It contains a range in which a
  * particular exception handler is active.
  *
- * @version $Id: CodeException.java 1749603 2016-06-21 20:50:19Z ggregory $
  * @see     Code
+ * @LastModified: Jan 2020
  */
 public final class CodeException implements Cloneable, Node {
 
     private int start_pc; // Range in the code the exception handler is
     private int end_pc; // active. start_pc is inclusive, end_pc exclusive
@@ -101,11 +101,11 @@
      * Dump code exception to file stream in binary format.
      *
      * @param file Output file stream
      * @throws IOException
      */
-    public final void dump( final DataOutputStream file ) throws IOException {
+    public void dump( final DataOutputStream file ) throws IOException {
         file.writeShort(start_pc);
         file.writeShort(end_pc);
         file.writeShort(handler_pc);
         file.writeShort(catch_type);
     }
@@ -113,85 +113,85 @@
 
     /**
      * @return 0, if the handler catches any exception, otherwise it points to
      * the exception class which is to be caught.
      */
-    public final int getCatchType() {
+    public int getCatchType() {
         return catch_type;
     }
 
 
     /**
      * @return Exclusive end index of the region where the handler is active.
      */
-    public final int getEndPC() {
+    public int getEndPC() {
         return end_pc;
     }
 
 
     /**
      * @return Starting address of exception handler, relative to the code.
      */
-    public final int getHandlerPC() {
+    public int getHandlerPC() {
         return handler_pc;
     }
 
 
     /**
      * @return Inclusive start index of the region where the handler is active.
      */
-    public final int getStartPC() {
+    public int getStartPC() {
         return start_pc;
     }
 
 
     /**
      * @param catch_type the type of exception that is caught
      */
-    public final void setCatchType( final int catch_type ) {
+    public void setCatchType( final int catch_type ) {
         this.catch_type = catch_type;
     }
 
 
     /**
      * @param end_pc end of handled block
      */
-    public final void setEndPC( final int end_pc ) {
+    public void setEndPC( final int end_pc ) {
         this.end_pc = end_pc;
     }
 
 
     /**
      * @param handler_pc where the actual code is
      */
-    public final void setHandlerPC( final int handler_pc ) { // TODO unused
+    public void setHandlerPC( final int handler_pc ) { // TODO unused
         this.handler_pc = handler_pc;
     }
 
 
     /**
      * @param start_pc start of handled block
      */
-    public final void setStartPC( final int start_pc ) { // TODO unused
+    public void setStartPC( final int start_pc ) { // TODO unused
         this.start_pc = start_pc;
     }
 
 
     /**
      * @return String representation.
      */
     @Override
-    public final String toString() {
+    public String toString() {
         return "CodeException(start_pc = " + start_pc + ", end_pc = " + end_pc + ", handler_pc = "
                 + handler_pc + ", catch_type = " + catch_type + ")";
     }
 
 
     /**
      * @return String representation.
      */
-    public final String toString( final ConstantPool cp, final boolean verbose ) {
+    public String toString( final ConstantPool cp, final boolean verbose ) {
         String str;
         if (catch_type == 0) {
             str = "<Any exception>(0)";
         } else {
             str = Utility.compactClassName(cp.getConstantString(catch_type, Const.CONSTANT_Class), false)
@@ -199,11 +199,11 @@
         }
         return start_pc + "\t" + end_pc + "\t" + handler_pc + "\t" + str;
     }
 
 
-    public final String toString( final ConstantPool cp ) {
+    public String toString( final ConstantPool cp ) {
         return toString(cp, true);
     }
 
 
     /**

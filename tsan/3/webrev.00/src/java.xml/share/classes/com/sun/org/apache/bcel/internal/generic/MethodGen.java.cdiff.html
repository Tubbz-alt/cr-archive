<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/MethodGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MULTIANEWARRAY.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MethodObserver.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/MethodGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,42 ***</span>
  import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleParameterAnnotations;
  import com.sun.org.apache.bcel.internal.classfile.Utility;
  import com.sun.org.apache.bcel.internal.util.BCELComparator;
  import java.util.ArrayList;
  import java.util.Arrays;
<span class="line-removed">- import java.util.Comparator;</span>
  import java.util.HashMap;
  import java.util.List;
  import java.util.Map;
  import java.util.Stack;
  
  /**
   * Template class for building up a method. This is done by defining exception
   * handlers, adding thrown exceptions, local variables and attributes, whereas
   * the `LocalVariableTable&#39; and `LineNumberTable&#39; attributes will be set
   * automatically for the code. Use stripAttributes() if you don&#39;t like this.
   *
   * While generating code it may be necessary to insert NOP operations. You can
<span class="line-modified">!  * use the `removeNOPs&#39; method to get rid off them. The resulting method object</span>
<span class="line-modified">!  * can be obtained via the `getMethod()&#39; method.</span>
   *
<span class="line-modified">!  * @version $Id: MethodGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
<span class="line-modified">!  * @see InstructionList</span>
<span class="line-modified">!  * @see Method</span>
<span class="line-removed">-  * @LastModified: Oct 2017</span>
   */
  public class MethodGen extends FieldGenOrMethodGen {
  
      private String class_name;
      private Type[] arg_types;
      private String[] arg_names;
      private int max_locals;
      private int max_stack;
      private InstructionList il;
      private boolean strip_attributes;
      private final List&lt;LocalVariableGen&gt; variable_vec = new ArrayList&lt;&gt;();
<span class="line-removed">-     private final List&lt;LocalVariableGen&gt; type_vec = new ArrayList&lt;&gt;();</span>
      private final List&lt;LineNumberGen&gt; line_number_vec = new ArrayList&lt;&gt;();
      private final List&lt;CodeExceptionGen&gt; exception_vec = new ArrayList&lt;&gt;();
      private final List&lt;String&gt; throws_vec = new ArrayList&lt;&gt;();
      private final List&lt;Attribute&gt; code_attrs_vec = new ArrayList&lt;&gt;();
  
<span class="line-new-header">--- 37,41 ---</span>
  import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleParameterAnnotations;
  import com.sun.org.apache.bcel.internal.classfile.Utility;
  import com.sun.org.apache.bcel.internal.util.BCELComparator;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.HashMap;
  import java.util.List;
  import java.util.Map;
<span class="line-added">+ import java.util.Objects;</span>
  import java.util.Stack;
  
  /**
   * Template class for building up a method. This is done by defining exception
   * handlers, adding thrown exceptions, local variables and attributes, whereas
   * the `LocalVariableTable&#39; and `LineNumberTable&#39; attributes will be set
   * automatically for the code. Use stripAttributes() if you don&#39;t like this.
   *
   * While generating code it may be necessary to insert NOP operations. You can
<span class="line-modified">!  * use the `removeNOPs&#39; method to get rid off them.</span>
<span class="line-modified">!  * The resulting method object can be obtained via the `getMethod()&#39; method.</span>
   *
<span class="line-modified">!  * @see     InstructionList</span>
<span class="line-modified">!  * @see     Method</span>
<span class="line-modified">!  * @LastModified: Jan 2020</span>
   */
  public class MethodGen extends FieldGenOrMethodGen {
  
      private String class_name;
      private Type[] arg_types;
      private String[] arg_names;
      private int max_locals;
      private int max_stack;
      private InstructionList il;
      private boolean strip_attributes;
<span class="line-added">+     private LocalVariableTypeTable local_variable_type_table = null;</span>
      private final List&lt;LocalVariableGen&gt; variable_vec = new ArrayList&lt;&gt;();
      private final List&lt;LineNumberGen&gt; line_number_vec = new ArrayList&lt;&gt;();
      private final List&lt;CodeExceptionGen&gt; exception_vec = new ArrayList&lt;&gt;();
      private final List&lt;String&gt; throws_vec = new ArrayList&lt;&gt;();
      private final List&lt;Attribute&gt; code_attrs_vec = new ArrayList&lt;&gt;();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,45 ***</span>
      private boolean haveUnpackedParameterAnnotations = false;
  
      private static BCELComparator bcelComparator = new BCELComparator() {
  
          @Override
<span class="line-modified">!         public boolean equals(final Object o1, final Object o2) {</span>
              final MethodGen THIS = (MethodGen) o1;
              final MethodGen THAT = (MethodGen) o2;
<span class="line-modified">!             return THIS.getName().equals(THAT.getName())</span>
<span class="line-modified">!                     &amp;&amp; THIS.getSignature().equals(THAT.getSignature());</span>
          }
  
          @Override
<span class="line-modified">!         public int hashCode(final Object o) {</span>
              final MethodGen THIS = (MethodGen) o;
              return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
          }
      };
  
      /**
<span class="line-modified">!      * Declare method. If the method is non-static the constructor automatically</span>
<span class="line-modified">!      * declares a local variable `$this&#39; in slot 0. The actual code is contained</span>
<span class="line-modified">!      * in the `il&#39; parameter, which may further manipulated by the user. But he</span>
<span class="line-modified">!      * must take care not to remove any instruction (handles) that are still</span>
<span class="line-modified">!      * referenced from this object.</span>
       *
       * For example one may not add a local variable and later remove the
<span class="line-modified">!      * instructions it refers to without causing havoc. It is safe however if</span>
<span class="line-modified">!      * you remove that local variable, too.</span>
       *
       * @param access_flags access qualifiers
<span class="line-modified">!      * @param return_type method type</span>
       * @param arg_types argument types
<span class="line-modified">!      * @param arg_names argument names (if this is null, default names will be</span>
<span class="line-modified">!      * provided for them)</span>
       * @param method_name name of method
<span class="line-modified">!      * @param class_name class name containing this method (may be null, if you</span>
<span class="line-modified">!      * don&#39;t care)</span>
<span class="line-modified">!      * @param il instruction list associated with this method, may be null only</span>
<span class="line-removed">-      * for abstract or native methods</span>
       * @param cp constant pool
       */
      public MethodGen(final int access_flags, final Type return_type, final Type[] arg_types, String[] arg_names,
              final String method_name, final String class_name, final InstructionList il, final ConstantPoolGen cp) {
          super(access_flags);
<span class="line-new-header">--- 80,46 ---</span>
      private boolean haveUnpackedParameterAnnotations = false;
  
      private static BCELComparator bcelComparator = new BCELComparator() {
  
          @Override
<span class="line-modified">!         public boolean equals( final Object o1, final Object o2 ) {</span>
              final MethodGen THIS = (MethodGen) o1;
              final MethodGen THAT = (MethodGen) o2;
<span class="line-modified">!             return Objects.equals(THIS.getName(), THAT.getName())</span>
<span class="line-modified">!                     &amp;&amp; Objects.equals(THIS.getSignature(), THAT.getSignature());</span>
          }
  
<span class="line-added">+ </span>
          @Override
<span class="line-modified">!         public int hashCode( final Object o ) {</span>
              final MethodGen THIS = (MethodGen) o;
              return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
          }
      };
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Declare method. If the method is non-static the constructor</span>
<span class="line-modified">!      * automatically declares a local variable `$this&#39; in slot 0. The</span>
<span class="line-modified">!      * actual code is contained in the `il&#39; parameter, which may further</span>
<span class="line-modified">!      * manipulated by the user. But he must take care not to remove any</span>
<span class="line-modified">!      * instruction (handles) that are still referenced from this object.</span>
       *
       * For example one may not add a local variable and later remove the
<span class="line-modified">!      * instructions it refers to without causing havoc. It is safe</span>
<span class="line-modified">!      * however if you remove that local variable, too.</span>
       *
       * @param access_flags access qualifiers
<span class="line-modified">!      * @param return_type  method type</span>
       * @param arg_types argument types
<span class="line-modified">!      * @param arg_names argument names (if this is null, default names will be provided</span>
<span class="line-modified">!      * for them)</span>
       * @param method_name name of method
<span class="line-modified">!      * @param class_name class name containing this method (may be null, if you don&#39;t care)</span>
<span class="line-modified">!      * @param il instruction list associated with this method, may be null only for</span>
<span class="line-modified">!      * abstract or native methods</span>
       * @param cp constant pool
       */
      public MethodGen(final int access_flags, final Type return_type, final Type[] arg_types, String[] arg_names,
              final String method_name, final String class_name, final InstructionList il, final ConstantPoolGen cp) {
          super(access_flags);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,18 ***</span>
          setClassName(class_name);
          setInstructionList(il);
          setConstantPool(cp);
          final boolean abstract_ = isAbstract() || isNative();
          InstructionHandle start = null;
<span class="line-modified">!         InstructionHandle end = null;</span>
          if (!abstract_) {
              start = il.getStart();
<span class="line-modified">!             end = il.getEnd();</span>
              /* Add local variables, namely the implicit `this&#39; and the arguments
               */
              if (!isStatic() &amp;&amp; (class_name != null)) { // Instance method -&gt; `this&#39; is local var 0
<span class="line-modified">!                 addLocalVariable(&quot;this&quot;, ObjectType.getInstance(class_name), start, end);</span>
              }
          }
          if (arg_types != null) {
              final int size = arg_types.length;
              for (final Type arg_type : arg_types) {
<span class="line-new-header">--- 130,18 ---</span>
          setClassName(class_name);
          setInstructionList(il);
          setConstantPool(cp);
          final boolean abstract_ = isAbstract() || isNative();
          InstructionHandle start = null;
<span class="line-modified">!         final InstructionHandle end = null;</span>
          if (!abstract_) {
              start = il.getStart();
<span class="line-modified">!             // end == null =&gt; live to end of method</span>
              /* Add local variables, namely the implicit `this&#39; and the arguments
               */
              if (!isStatic() &amp;&amp; (class_name != null)) { // Instance method -&gt; `this&#39; is local var 0
<span class="line-modified">!                 addLocalVariable(&quot;this&quot;,  ObjectType.getInstance(class_name), start, end);</span>
              }
          }
          if (arg_types != null) {
              final int size = arg_types.length;
              for (final Type arg_type : arg_types) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,23 ***</span>
                  }
              }
          }
      }
  
      /**
       * Instantiate from existing method.
       *
       * @param m method
       * @param class_name class name containing this method
       * @param cp constant pool
       */
      public MethodGen(final Method m, final String class_name, final ConstantPoolGen cp) {
          this(m.getAccessFlags(), Type.getReturnType(m.getSignature()), Type.getArgumentTypes(m
<span class="line-modified">!                 .getSignature()), null /* may be overridden anyway */, m.getName(), class_name,</span>
                  ((m.getAccessFlags() &amp; (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0)
<span class="line-modified">!                 ? new InstructionList(m.getCode().getCode())</span>
<span class="line-modified">!                 : null, cp);</span>
          final Attribute[] attributes = m.getAttributes();
          for (final Attribute attribute : attributes) {
              Attribute a = attribute;
              if (a instanceof Code) {
                  final Code c = (Code) a;
<span class="line-new-header">--- 167,25 ---</span>
                  }
              }
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Instantiate from existing method.
       *
       * @param m method
       * @param class_name class name containing this method
       * @param cp constant pool
       */
      public MethodGen(final Method m, final String class_name, final ConstantPoolGen cp) {
          this(m.getAccessFlags(), Type.getReturnType(m.getSignature()), Type.getArgumentTypes(m
<span class="line-modified">!                 .getSignature()), null /* may be overridden anyway */</span>
<span class="line-added">+         , m.getName(), class_name,</span>
                  ((m.getAccessFlags() &amp; (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0)
<span class="line-modified">!                         ? new InstructionList(m.getCode().getCode())</span>
<span class="line-modified">!                         : null, cp);</span>
          final Attribute[] attributes = m.getAttributes();
          for (final Attribute attribute : attributes) {
              Attribute a = attribute;
              if (a instanceof Code) {
                  final Code c = (Code) a;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,11 ***</span>
                          final int type = ce.getCatchType();
                          ObjectType c_type = null;
                          if (type &gt; 0) {
                              final String cen = m.getConstantPool().getConstantString(type,
                                      Const.CONSTANT_Class);
<span class="line-modified">!                             c_type = ObjectType.getInstance(cen);</span>
                          }
                          final int end_pc = ce.getEndPC();
                          final int length = m.getCode().getCode().length;
                          InstructionHandle end;
                          if (length == end_pc) { // May happen, because end_pc is exclusive
<span class="line-new-header">--- 197,11 ---</span>
                          final int type = ce.getCatchType();
                          ObjectType c_type = null;
                          if (type &gt; 0) {
                              final String cen = m.getConstantPool().getConstantString(type,
                                      Const.CONSTANT_Class);
<span class="line-modified">!                             c_type =  ObjectType.getInstance(cen);</span>
                          }
                          final int end_pc = ce.getEndPC();
                          final int length = m.getCode().getCode().length;
                          InstructionHandle end;
                          if (length == end_pc) { // May happen, because end_pc is exclusive
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,17 ***</span>
                              if (ih != null) {
                                  addLineNumber(ih, l.getLineNumber());
                              }
                          }
                      } else if (a instanceof LocalVariableTable) {
<span class="line-modified">!                         final LocalVariable[] lv = ((LocalVariableTable) a).getLocalVariableTable();</span>
<span class="line-removed">-                         removeLocalVariables();</span>
<span class="line-removed">-                         repairHandles(lv, false);</span>
                      } else if (a instanceof LocalVariableTypeTable) {
<span class="line-modified">!                         LocalVariable[] lv = ((LocalVariableTypeTable) a).getLocalVariableTypeTable();</span>
<span class="line-removed">-                         removeLocalVariableTypes();</span>
<span class="line-removed">-                         repairHandles(lv, true);</span>
                      } else {
                          addCodeAttribute(a);
                      }
                  }
              } else if (a instanceof ExceptionTable) {
<span class="line-new-header">--- 224,13 ---</span>
                              if (ih != null) {
                                  addLineNumber(ih, l.getLineNumber());
                              }
                          }
                      } else if (a instanceof LocalVariableTable) {
<span class="line-modified">!                         updateLocalVariableTable((LocalVariableTable) a);</span>
                      } else if (a instanceof LocalVariableTypeTable) {
<span class="line-modified">!                         this.local_variable_type_table = (LocalVariableTypeTable) a.copy(cp.getConstantPool());</span>
                      } else {
                          addCodeAttribute(a);
                      }
                  }
              } else if (a instanceof ExceptionTable) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 250,54 ***</span>
                  addAttribute(a);
              }
          }
      }
  
<span class="line-removed">-     private void repairHandles(final LocalVariable[] lv, boolean isLVT) {</span>
<span class="line-removed">-         for (int k = 0; k &lt; lv.length; k++) {</span>
<span class="line-removed">-             LocalVariable l = lv[k];</span>
<span class="line-removed">-             InstructionHandle start = il.findHandle(l.getStartPC());</span>
<span class="line-removed">-             InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());</span>
<span class="line-removed">-             // Repair malformed handles</span>
<span class="line-removed">-             if (null == start) {</span>
<span class="line-removed">-                 start = il.getStart();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (null == end) {</span>
<span class="line-removed">-                 end = il.getEnd();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (isLVT) {</span>
<span class="line-removed">-                 addLocalVariableType(l.getName(), Type.getType(l.getSignature()),</span>
<span class="line-removed">-                         l.getIndex(), start, end);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 addLocalVariable(l.getName(), Type.getType(l.getSignature()),</span>
<span class="line-removed">-                         l.getIndex(), start, end);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Adds a local variable to this method.
       *
       * @param name variable name
       * @param type variable type
<span class="line-modified">!      * @param slot the index of the local variable, if type is long or double,</span>
<span class="line-modified">!      * the next available index is slot+2</span>
       * @param start from where the variable is valid
       * @param end until where the variable is valid
       * @return new local variable object
       * @see LocalVariable
       */
<span class="line-modified">!     public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot,</span>
<span class="line-modified">!             final InstructionHandle start, final InstructionHandle end) {</span>
<span class="line-removed">- </span>
          final byte t = type.getType();
          if (t != Const.T_ADDRESS) {
              final int add = type.getSize();
              if (slot + add &gt; max_locals) {
                  max_locals = slot + add;
              }
<span class="line-modified">!             final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end);</span>
              int i;
              if ((i = variable_vec.indexOf(l)) &gt;= 0) {
                  variable_vec.set(i, l);
              } else {
                  variable_vec.add(l);
<span class="line-new-header">--- 248,32 ---</span>
                  addAttribute(a);
              }
          }
      }
  
      /**
       * Adds a local variable to this method.
       *
       * @param name variable name
       * @param type variable type
<span class="line-modified">!      * @param slot the index of the local variable, if type is long or double, the next available</span>
<span class="line-modified">!      * index is slot+2</span>
       * @param start from where the variable is valid
       * @param end until where the variable is valid
<span class="line-added">+      * @param orig_index the index of the local variable prior to any modifications</span>
       * @return new local variable object
       * @see LocalVariable
       */
<span class="line-modified">!     public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,</span>
<span class="line-modified">!             final InstructionHandle start, final InstructionHandle end, final int orig_index ) {</span>
          final byte t = type.getType();
          if (t != Const.T_ADDRESS) {
              final int add = type.getSize();
              if (slot + add &gt; max_locals) {
                  max_locals = slot + add;
              }
<span class="line-modified">!             final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, orig_index);</span>
              int i;
              if ((i = variable_vec.indexOf(l)) &gt;= 0) {
                  variable_vec.set(i, l);
              } else {
                  variable_vec.add(l);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 306,104 ***</span>
          }
          throw new IllegalArgumentException(&quot;Can not use &quot; + type
                  + &quot; as type for local variable&quot;);
      }
  
      /**
       * Adds a local variable to this method and assigns an index automatically.
       *
       * @param name variable name
       * @param type variable type
<span class="line-modified">!      * @param start from where the variable is valid, if this is null, it is</span>
<span class="line-modified">!      * valid from the start</span>
<span class="line-modified">!      * @param end until where the variable is valid, if this is null, it is</span>
<span class="line-modified">!      * valid to the end</span>
       * @return new local variable object
       * @see LocalVariable
       */
<span class="line-modified">!     public LocalVariableGen addLocalVariable(final String name, final Type type,</span>
<span class="line-modified">!             final InstructionHandle start, final InstructionHandle end) {</span>
          return addLocalVariable(name, type, max_locals, start, end);
      }
  
      /**
       * Remove a local variable, its slot will not be reused, if you do not use
       * addLocalVariable with an explicit index argument.
       */
      public void removeLocalVariable(final LocalVariableGen l) {
          variable_vec.remove(l);
      }
  
      /**
       * Remove all local variables.
       */
      public void removeLocalVariables() {
          variable_vec.clear();
      }
  
      /*
       * If the range of the variable has not been set yet, it will be set to be valid from
       * the start to the end of the instruction list.
       *
       * @return array of declared local variables sorted by index
       */
      public LocalVariableGen[] getLocalVariables() {
<span class="line-modified">!         return getLocalVariableOrTypes(false);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * If the range of the variable has not been set yet, it will be set to be</span>
<span class="line-removed">-      * valid from the start to the end of the instruction list.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return array of declared local variable types sorted by index</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private LocalVariableGen[] getLocalVariableTypes() {</span>
<span class="line-removed">-         return getLocalVariableOrTypes(true);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * If the range of the variable or type has not been set yet, it will be set</span>
<span class="line-removed">-      * to be valid from the start to the end of the instruction list.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return array of declared local variables or types sorted by index</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private LocalVariableGen[] getLocalVariableOrTypes(boolean isLVT) {</span>
<span class="line-removed">-         int size = (isLVT) ? type_vec.size() : variable_vec.size();</span>
<span class="line-removed">-         LocalVariableGen[] lg = new LocalVariableGen[size];</span>
<span class="line-removed">-         if (isLVT) {</span>
<span class="line-removed">-             type_vec.toArray(lg);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             variable_vec.toArray(lg);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          for (int i = 0; i &lt; size; i++) {
<span class="line-modified">!             if (lg[i].getStart() == null) {</span>
                  lg[i].setStart(il.getStart());
              }
<span class="line-modified">! </span>
<span class="line-removed">-             if (lg[i].getEnd() == null) {</span>
                  lg[i].setEnd(il.getEnd());
              }
          }
<span class="line-removed">- </span>
          if (size &gt; 1) {
<span class="line-modified">!             Arrays.sort(lg, new Comparator&lt;LocalVariableGen&gt;() {</span>
<span class="line-removed">-                 @Override</span>
<span class="line-removed">-                 public int compare(final LocalVariableGen o1, final LocalVariableGen o2) {</span>
<span class="line-removed">-                     return o1.getIndex() - o2.getIndex();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             });</span>
          }
<span class="line-removed">- </span>
          return lg;
      }
  
      /**
<span class="line-modified">!      * @return `LocalVariableTable&#39; attribute of all the local variables of this</span>
<span class="line-removed">-      * method.</span>
       */
<span class="line-modified">!     public LocalVariableTable getLocalVariableTable(final ConstantPoolGen cp) {</span>
          final LocalVariableGen[] lg = getLocalVariables();
          final int size = lg.length;
          final LocalVariable[] lv = new LocalVariable[size];
          for (int i = 0; i &lt; size; i++) {
              lv[i] = lg[i].getLocalVariable(cp);
<span class="line-new-header">--- 282,92 ---</span>
          }
          throw new IllegalArgumentException(&quot;Can not use &quot; + type
                  + &quot; as type for local variable&quot;);
      }
  
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Adds a local variable to this method.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param name variable name</span>
<span class="line-added">+      * @param type variable type</span>
<span class="line-added">+      * @param slot the index of the local variable, if type is long or double, the next available</span>
<span class="line-added">+      * index is slot+2</span>
<span class="line-added">+      * @param start from where the variable is valid</span>
<span class="line-added">+      * @param end until where the variable is valid</span>
<span class="line-added">+      * @return new local variable object</span>
<span class="line-added">+      * @see LocalVariable</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,</span>
<span class="line-added">+             final InstructionHandle start, final InstructionHandle end ) {</span>
<span class="line-added">+         return addLocalVariable(name, type, slot, start, end, slot);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Adds a local variable to this method and assigns an index automatically.
       *
       * @param name variable name
       * @param type variable type
<span class="line-modified">!      * @param start from where the variable is valid, if this is null,</span>
<span class="line-modified">!      * it is valid from the start</span>
<span class="line-modified">!      * @param end until where the variable is valid, if this is null,</span>
<span class="line-modified">!      * it is valid to the end</span>
       * @return new local variable object
       * @see LocalVariable
       */
<span class="line-modified">!     public LocalVariableGen addLocalVariable( final String name, final Type type, final InstructionHandle start,</span>
<span class="line-modified">!             final InstructionHandle end ) {</span>
          return addLocalVariable(name, type, max_locals, start, end);
      }
  
<span class="line-added">+ </span>
      /**
       * Remove a local variable, its slot will not be reused, if you do not use
       * addLocalVariable with an explicit index argument.
       */
      public void removeLocalVariable(final LocalVariableGen l) {
          variable_vec.remove(l);
      }
  
<span class="line-added">+ </span>
      /**
       * Remove all local variables.
       */
      public void removeLocalVariables() {
          variable_vec.clear();
      }
  
<span class="line-added">+ </span>
      /*
       * If the range of the variable has not been set yet, it will be set to be valid from
       * the start to the end of the instruction list.
       *
       * @return array of declared local variables sorted by index
       */
      public LocalVariableGen[] getLocalVariables() {
<span class="line-modified">!         final int size = variable_vec.size();</span>
<span class="line-modified">!         final LocalVariableGen[] lg = new LocalVariableGen[size];</span>
<span class="line-modified">!         variable_vec.toArray(lg);</span>
          for (int i = 0; i &lt; size; i++) {
<span class="line-modified">!             if ((lg[i].getStart() == null) &amp;&amp; (il != null)) {</span>
                  lg[i].setStart(il.getStart());
              }
<span class="line-modified">!             if ((lg[i].getEnd() == null) &amp;&amp; (il != null)) {</span>
                  lg[i].setEnd(il.getEnd());
              }
          }
          if (size &gt; 1) {
<span class="line-modified">!             Arrays.sort(lg, (o1, o2) -&gt; o1.getIndex() - o2.getIndex());</span>
          }
          return lg;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * @return `LocalVariableTable&#39; attribute of all the local variables of this method.</span>
       */
<span class="line-modified">!     public LocalVariableTable getLocalVariableTable( final ConstantPoolGen cp ) {</span>
          final LocalVariableGen[] lg = getLocalVariables();
          final int size = lg.length;
          final LocalVariable[] lv = new LocalVariable[size];
          for (int i = 0; i &lt; size; i++) {
              lv[i] = lg[i].getLocalVariable(cp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,252 ***</span>
          return new LocalVariableTable(cp.addUtf8(&quot;LocalVariableTable&quot;), 2 + lv.length * 10, lv, cp
                  .getConstantPool());
      }
  
      /**
<span class="line-modified">!      * @return `LocalVariableTypeTable&#39; attribute of all the local variable</span>
<span class="line-removed">-      * types of this method.</span>
       */
<span class="line-modified">!     public LocalVariableTypeTable getLocalVariableTypeTable(ConstantPoolGen cp) {</span>
<span class="line-modified">!         LocalVariableGen[] lg = getLocalVariableTypes();</span>
<span class="line-removed">-         int size = lg.length;</span>
<span class="line-removed">-         LocalVariable[] lv = new LocalVariable[size];</span>
<span class="line-removed">- </span>
<span class="line-removed">-         for (int i = 0; i &lt; size; i++) {</span>
<span class="line-removed">-             lv[i] = lg[i].getLocalVariable(cp);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return new LocalVariableTypeTable(cp.addUtf8(&quot;LocalVariableTypeTable&quot;),</span>
<span class="line-removed">-                 2 + lv.length * 10, lv, cp.getConstantPool());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Adds a local variable type to this method.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param name variable name</span>
<span class="line-removed">-      * @param type variable type</span>
<span class="line-removed">-      * @param slot the index of the local variable, if type is long or double,</span>
<span class="line-removed">-      * the next available index is slot+2</span>
<span class="line-removed">-      * @param start from where the variable is valid</span>
<span class="line-removed">-      * @param end until where the variable is valid</span>
<span class="line-removed">-      * @return new local variable object</span>
<span class="line-removed">-      * @see LocalVariable</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private LocalVariableGen addLocalVariableType(String name, Type type, int slot,</span>
<span class="line-removed">-             InstructionHandle start,</span>
<span class="line-removed">-             InstructionHandle end) {</span>
<span class="line-removed">-         byte t = type.getType();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (t != Const.T_ADDRESS) {</span>
<span class="line-removed">-             int add = type.getSize();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (slot + add &gt; max_locals) {</span>
<span class="line-removed">-                 max_locals = slot + add;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end);</span>
<span class="line-removed">-             int i;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if ((i = type_vec.indexOf(l)) &gt;= 0) // Overwrite if necessary</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 type_vec.set(i, l);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 type_vec.add(l);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             return l;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;Can not use &quot; + type</span>
<span class="line-removed">-                     + &quot; as type for local variable&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Remove all local variable types.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private void removeLocalVariableTypes() {</span>
<span class="line-removed">-         type_vec.clear();</span>
      }
  
      /**
       * Give an instruction a line number corresponding to the source code line.
       *
       * @param ih instruction to tag
       * @return new line number object
       * @see LineNumber
       */
<span class="line-modified">!     public LineNumberGen addLineNumber(final InstructionHandle ih, final int src_line) {</span>
          final LineNumberGen l = new LineNumberGen(ih, src_line);
          line_number_vec.add(l);
          return l;
      }
  
      /**
       * Remove a line number.
       */
<span class="line-modified">!     public void removeLineNumber(final LineNumberGen l) {</span>
          line_number_vec.remove(l);
      }
  
      /**
       * Remove all line numbers.
       */
      public void removeLineNumbers() {
          line_number_vec.clear();
      }
  
      /*
       * @return array of line numbers
       */
      public LineNumberGen[] getLineNumbers() {
          final LineNumberGen[] lg = new LineNumberGen[line_number_vec.size()];
          line_number_vec.toArray(lg);
          return lg;
      }
  
      /**
<span class="line-modified">!      * @return `LineNumberTable&#39; attribute of all the local variables of this</span>
<span class="line-removed">-      * method.</span>
       */
<span class="line-modified">!     public LineNumberTable getLineNumberTable(final ConstantPoolGen cp) {</span>
          final int size = line_number_vec.size();
          final LineNumber[] ln = new LineNumber[size];
          for (int i = 0; i &lt; size; i++) {
              ln[i] = line_number_vec.get(i).getLineNumber();
          }
          return new LineNumberTable(cp.addUtf8(&quot;LineNumberTable&quot;), 2 + ln.length * 4, ln, cp
                  .getConstantPool());
      }
  
      /**
<span class="line-modified">!      * Add an exception handler, i.e., specify region where a handler is active</span>
<span class="line-modified">!      * and an instruction where the actual handling is done.</span>
       *
       * @param start_pc Start of region (inclusive)
       * @param end_pc End of region (inclusive)
       * @param handler_pc Where handling is done
       * @param catch_type class type of handled exception or null if any
       * exception is handled
       * @return new exception handler object
       */
<span class="line-modified">!     public CodeExceptionGen addExceptionHandler(final InstructionHandle start_pc,</span>
<span class="line-modified">!             final InstructionHandle end_pc, final InstructionHandle handler_pc, final ObjectType catch_type) {</span>
          if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {
              throw new ClassGenException(&quot;Exception handler target is null instruction&quot;);
          }
          final CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);
          exception_vec.add(c);
          return c;
      }
  
      /**
       * Remove an exception handler.
       */
<span class="line-modified">!     public void removeExceptionHandler(final CodeExceptionGen c) {</span>
          exception_vec.remove(c);
      }
  
      /**
       * Remove all line numbers.
       */
      public void removeExceptionHandlers() {
          exception_vec.clear();
      }
  
      /*
       * @return array of declared exception handlers
       */
      public CodeExceptionGen[] getExceptionHandlers() {
          final CodeExceptionGen[] cg = new CodeExceptionGen[exception_vec.size()];
          exception_vec.toArray(cg);
          return cg;
      }
  
      /**
       * @return code exceptions for `Code&#39; attribute
       */
      private CodeException[] getCodeExceptions() {
          final int size = exception_vec.size();
          final CodeException[] c_exc = new CodeException[size];
          for (int i = 0; i &lt; size; i++) {
<span class="line-modified">!             final CodeExceptionGen c = exception_vec.get(i);</span>
              c_exc[i] = c.getCodeException(super.getConstantPool());
          }
          return c_exc;
      }
  
      /**
       * Add an exception possibly thrown by this method.
       *
       * @param class_name (fully qualified) name of exception
       */
<span class="line-modified">!     public void addException(final String class_name) {</span>
          throws_vec.add(class_name);
      }
  
      /**
       * Remove an exception.
       */
<span class="line-modified">!     public void removeException(final String c) {</span>
          throws_vec.remove(c);
      }
  
      /**
       * Remove all exceptions.
       */
      public void removeExceptions() {
          throws_vec.clear();
      }
  
      /*
       * @return array of thrown exceptions
       */
      public String[] getExceptions() {
          final String[] e = new String[throws_vec.size()];
          throws_vec.toArray(e);
          return e;
      }
  
      /**
<span class="line-modified">!      * @return `Exceptions&#39; attribute of all the exceptions thrown by this</span>
<span class="line-removed">-      * method.</span>
       */
<span class="line-modified">!     private ExceptionTable getExceptionTable(final ConstantPoolGen cp) {</span>
          final int size = throws_vec.size();
          final int[] ex = new int[size];
          for (int i = 0; i &lt; size; i++) {
              ex[i] = cp.addClass(throws_vec.get(i));
          }
          return new ExceptionTable(cp.addUtf8(&quot;Exceptions&quot;), 2 + 2 * size, ex, cp.getConstantPool());
      }
  
      /**
       * Add an attribute to the code. Currently, the JVM knows about the
<span class="line-modified">!      * LineNumberTable, LocalVariableTable and StackMap attributes, where the</span>
<span class="line-modified">!      * former two will be generated automatically and the latter is used for the</span>
<span class="line-modified">!      * MIDP only. Other attributes will be ignored by the JVM but do no harm.</span>
       *
       * @param a attribute to be added
       */
<span class="line-modified">!     public void addCodeAttribute(final Attribute a) {</span>
          code_attrs_vec.add(a);
      }
  
      /**
       * Remove a code attribute.
       */
<span class="line-modified">!     public void removeCodeAttribute(final Attribute a) {</span>
          code_attrs_vec.remove(a);
      }
  
      /**
       * Remove all code attributes.
       */
      public void removeCodeAttributes() {
          code_attrs_vec.clear();
      }
  
      /**
       * @return all attributes of this method.
       */
      public Attribute[] getCodeAttributes() {
          final Attribute[] attributes = new Attribute[code_attrs_vec.size()];
<span class="line-new-header">--- 375,219 ---</span>
          return new LocalVariableTable(cp.addUtf8(&quot;LocalVariableTable&quot;), 2 + lv.length * 10, lv, cp
                  .getConstantPool());
      }
  
      /**
<span class="line-modified">!      * @return `LocalVariableTypeTable&#39; attribute of this method.</span>
       */
<span class="line-modified">!     public LocalVariableTypeTable getLocalVariableTypeTable() {</span>
<span class="line-modified">!         return local_variable_type_table;</span>
      }
  
      /**
       * Give an instruction a line number corresponding to the source code line.
       *
       * @param ih instruction to tag
       * @return new line number object
       * @see LineNumber
       */
<span class="line-modified">!     public LineNumberGen addLineNumber( final InstructionHandle ih, final int src_line ) {</span>
          final LineNumberGen l = new LineNumberGen(ih, src_line);
          line_number_vec.add(l);
          return l;
      }
  
<span class="line-added">+ </span>
      /**
       * Remove a line number.
       */
<span class="line-modified">!     public void removeLineNumber( final LineNumberGen l ) {</span>
          line_number_vec.remove(l);
      }
  
<span class="line-added">+ </span>
      /**
       * Remove all line numbers.
       */
      public void removeLineNumbers() {
          line_number_vec.clear();
      }
  
<span class="line-added">+ </span>
      /*
       * @return array of line numbers
       */
      public LineNumberGen[] getLineNumbers() {
          final LineNumberGen[] lg = new LineNumberGen[line_number_vec.size()];
          line_number_vec.toArray(lg);
          return lg;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * @return `LineNumberTable&#39; attribute of all the local variables of this method.</span>
       */
<span class="line-modified">!     public LineNumberTable getLineNumberTable( final ConstantPoolGen cp ) {</span>
          final int size = line_number_vec.size();
          final LineNumber[] ln = new LineNumber[size];
          for (int i = 0; i &lt; size; i++) {
              ln[i] = line_number_vec.get(i).getLineNumber();
          }
          return new LineNumberTable(cp.addUtf8(&quot;LineNumberTable&quot;), 2 + ln.length * 4, ln, cp
                  .getConstantPool());
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add an exception handler, i.e., specify region where a handler is active and an</span>
<span class="line-modified">!      * instruction where the actual handling is done.</span>
       *
       * @param start_pc Start of region (inclusive)
       * @param end_pc End of region (inclusive)
       * @param handler_pc Where handling is done
       * @param catch_type class type of handled exception or null if any
       * exception is handled
       * @return new exception handler object
       */
<span class="line-modified">!     public CodeExceptionGen addExceptionHandler( final InstructionHandle start_pc,</span>
<span class="line-modified">!             final InstructionHandle end_pc, final InstructionHandle handler_pc, final ObjectType catch_type ) {</span>
          if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {
              throw new ClassGenException(&quot;Exception handler target is null instruction&quot;);
          }
          final CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);
          exception_vec.add(c);
          return c;
      }
  
<span class="line-added">+ </span>
      /**
       * Remove an exception handler.
       */
<span class="line-modified">!     public void removeExceptionHandler( final CodeExceptionGen c ) {</span>
          exception_vec.remove(c);
      }
  
<span class="line-added">+ </span>
      /**
       * Remove all line numbers.
       */
      public void removeExceptionHandlers() {
          exception_vec.clear();
      }
  
<span class="line-added">+ </span>
      /*
       * @return array of declared exception handlers
       */
      public CodeExceptionGen[] getExceptionHandlers() {
          final CodeExceptionGen[] cg = new CodeExceptionGen[exception_vec.size()];
          exception_vec.toArray(cg);
          return cg;
      }
  
<span class="line-added">+ </span>
      /**
       * @return code exceptions for `Code&#39; attribute
       */
      private CodeException[] getCodeExceptions() {
          final int size = exception_vec.size();
          final CodeException[] c_exc = new CodeException[size];
          for (int i = 0; i &lt; size; i++) {
<span class="line-modified">!             final CodeExceptionGen c =  exception_vec.get(i);</span>
              c_exc[i] = c.getCodeException(super.getConstantPool());
          }
          return c_exc;
      }
  
<span class="line-added">+ </span>
      /**
       * Add an exception possibly thrown by this method.
       *
       * @param class_name (fully qualified) name of exception
       */
<span class="line-modified">!     public void addException( final String class_name ) {</span>
          throws_vec.add(class_name);
      }
  
<span class="line-added">+ </span>
      /**
       * Remove an exception.
       */
<span class="line-modified">!     public void removeException( final String c ) {</span>
          throws_vec.remove(c);
      }
  
<span class="line-added">+ </span>
      /**
       * Remove all exceptions.
       */
      public void removeExceptions() {
          throws_vec.clear();
      }
  
<span class="line-added">+ </span>
      /*
       * @return array of thrown exceptions
       */
      public String[] getExceptions() {
          final String[] e = new String[throws_vec.size()];
          throws_vec.toArray(e);
          return e;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * @return `Exceptions&#39; attribute of all the exceptions thrown by this method.</span>
       */
<span class="line-modified">!     private ExceptionTable getExceptionTable( final ConstantPoolGen cp ) {</span>
          final int size = throws_vec.size();
          final int[] ex = new int[size];
          for (int i = 0; i &lt; size; i++) {
              ex[i] = cp.addClass(throws_vec.get(i));
          }
          return new ExceptionTable(cp.addUtf8(&quot;Exceptions&quot;), 2 + 2 * size, ex, cp.getConstantPool());
      }
  
<span class="line-added">+ </span>
      /**
       * Add an attribute to the code. Currently, the JVM knows about the
<span class="line-modified">!      * LineNumberTable, LocalVariableTable and StackMap attributes,</span>
<span class="line-modified">!      * where the former two will be generated automatically and the</span>
<span class="line-modified">!      * latter is used for the MIDP only. Other attributes will be</span>
<span class="line-added">+      * ignored by the JVM but do no harm.</span>
       *
       * @param a attribute to be added
       */
<span class="line-modified">!     public void addCodeAttribute( final Attribute a ) {</span>
          code_attrs_vec.add(a);
      }
  
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Remove the LocalVariableTypeTable</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void removeLocalVariableTypeTable( ) {</span>
<span class="line-added">+         local_variable_type_table = null;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Remove a code attribute.
       */
<span class="line-modified">!     public void removeCodeAttribute( final Attribute a ) {</span>
          code_attrs_vec.remove(a);
      }
  
<span class="line-added">+ </span>
      /**
       * Remove all code attributes.
       */
      public void removeCodeAttributes() {
<span class="line-added">+         local_variable_type_table = null;</span>
          code_attrs_vec.clear();
      }
  
<span class="line-added">+ </span>
      /**
       * @return all attributes of this method.
       */
      public Attribute[] getCodeAttributes() {
          final Attribute[] attributes = new Attribute[code_attrs_vec.size()];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 666,35 ***</span>
  
      /**
       * @since 6.0
       */
      public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<span class="line-modified">!         final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
          for (final Attribute attr : attrs) {
              addAttribute(attr);
          }
<span class="line-modified">!     }</span>
  
      /**
       * @since 6.0
       */
<span class="line-modified">!     public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {</span>
<span class="line-modified">!         if (!hasParameterAnnotations) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, param_annotations);</span>
<span class="line-modified">!         if (attrs != null) {</span>
<span class="line-modified">!             for (final Attribute attr : attrs) {</span>
<span class="line-modified">!                 addAttribute(attr);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
  
      /**
<span class="line-modified">!      * Get method object. Never forget to call setMaxStack() or</span>
<span class="line-modified">!      * setMaxStack(max), respectively, before calling this method (the same</span>
<span class="line-removed">-      * applies for max locals).</span>
       *
       * @return method object
       */
      public Method getMethod() {
          final String signature = getSignature();
<span class="line-new-header">--- 597,35 ---</span>
  
      /**
       * @since 6.0
       */
      public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<span class="line-modified">!           final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
          for (final Attribute attr : attrs) {
              addAttribute(attr);
          }
<span class="line-modified">!       }</span>
  
      /**
       * @since 6.0
       */
<span class="line-modified">!       public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {</span>
<span class="line-modified">!           if (!hasParameterAnnotations) {</span>
<span class="line-modified">!               return;</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp,param_annotations);</span>
<span class="line-modified">!           if (attrs != null) {</span>
<span class="line-modified">!               for (final Attribute attr : attrs) {</span>
<span class="line-modified">!                   addAttribute(attr);</span>
<span class="line-modified">!               }</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!       }</span>
<span class="line-added">+ </span>
  
      /**
<span class="line-modified">!      * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively,</span>
<span class="line-modified">!      * before calling this method (the same applies for max locals).</span>
       *
       * @return method object
       */
      public Method getMethod() {
          final String signature = getSignature();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,23 ***</span>
          if (il != null) {
              byte_code = il.getByteCode();
          }
          LineNumberTable lnt = null;
          LocalVariableTable lvt = null;
<span class="line-modified">!         LocalVariableTypeTable lvtt = null;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /* Create LocalVariableTable, LocalvariableTypeTable, and LineNumberTable</span>
<span class="line-removed">-          * attributes (for debuggers, e.g.)</span>
           */
          if ((variable_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
              addCodeAttribute(lvt = getLocalVariableTable(_cp));
          }
<span class="line-modified">! </span>
<span class="line-modified">!         if ((type_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {</span>
<span class="line-modified">!             addCodeAttribute(lvtt = getLocalVariableTypeTable(_cp));</span>
          }
<span class="line-removed">- </span>
          if ((line_number_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
              addCodeAttribute(lnt = getLineNumberTable(_cp));
          }
          final Attribute[] code_attrs = getCodeAttributes();
          /* Each attribute causes 6 additional header bytes
<span class="line-new-header">--- 638,23 ---</span>
          if (il != null) {
              byte_code = il.getByteCode();
          }
          LineNumberTable lnt = null;
          LocalVariableTable lvt = null;
<span class="line-modified">!         /* Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)</span>
           */
          if ((variable_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
<span class="line-added">+             updateLocalVariableTable(getLocalVariableTable(_cp));</span>
              addCodeAttribute(lvt = getLocalVariableTable(_cp));
          }
<span class="line-modified">!         if (local_variable_type_table != null) {</span>
<span class="line-modified">!             // LocalVariable length in LocalVariableTypeTable is not updated automatically. It&#39;s a difference with LocalVariableTable.</span>
<span class="line-modified">!             if (lvt != null) {</span>
<span class="line-added">+                 adjustLocalVariableTypeTable(lvt);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             addCodeAttribute(local_variable_type_table);</span>
          }
          if ((line_number_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
              addCodeAttribute(lnt = getLineNumberTable(_cp));
          }
          final Attribute[] code_attrs = getCodeAttributes();
          /* Each attribute causes 6 additional header bytes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 760,12 ***</span>
                  .getConstantPool());
          // Undo effects of adding attributes
          if (lvt != null) {
              removeCodeAttribute(lvt);
          }
<span class="line-modified">!         if (lvtt != null) {</span>
<span class="line-modified">!             removeCodeAttribute(lvtt);</span>
          }
          if (lnt != null) {
              removeCodeAttribute(lnt);
          }
          if (code != null) {
<span class="line-new-header">--- 691,12 ---</span>
                  .getConstantPool());
          // Undo effects of adding attributes
          if (lvt != null) {
              removeCodeAttribute(lvt);
          }
<span class="line-modified">!         if (local_variable_type_table != null) {</span>
<span class="line-modified">!             removeCodeAttribute(local_variable_type_table);</span>
          }
          if (lnt != null) {
              removeCodeAttribute(lnt);
          }
          if (code != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 775,10 ***</span>
<span class="line-new-header">--- 706,45 ---</span>
              removeAttribute(et);
          }
          return m;
      }
  
<span class="line-added">+     private void updateLocalVariableTable(final LocalVariableTable a) {</span>
<span class="line-added">+         final LocalVariable[] lv = a.getLocalVariableTable();</span>
<span class="line-added">+         removeLocalVariables();</span>
<span class="line-added">+         for (final LocalVariable l : lv) {</span>
<span class="line-added">+             InstructionHandle start = il.findHandle(l.getStartPC());</span>
<span class="line-added">+             final InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());</span>
<span class="line-added">+             // Repair malformed handles</span>
<span class="line-added">+             if (null == start) {</span>
<span class="line-added">+                 start = il.getStart();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // end == null =&gt; live to end of method</span>
<span class="line-added">+             // Since we are recreating the LocalVaraible, we must</span>
<span class="line-added">+             // propagate the orig_index to new copy.</span>
<span class="line-added">+             addLocalVariable(l.getName(), Type.getType(l.getSignature()), l</span>
<span class="line-added">+                     .getIndex(), start, end, l.getOrigIndex());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {</span>
<span class="line-added">+         final LocalVariable[] lv = lvt.getLocalVariableTable();</span>
<span class="line-added">+         final LocalVariable[] lvg = local_variable_type_table.getLocalVariableTypeTable();</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (final LocalVariable element : lvg) {</span>
<span class="line-added">+             for (final LocalVariable l : lv) {</span>
<span class="line-added">+                 if (element.getName().equals(l.getName()) &amp;&amp; element.getIndex() == l.getOrigIndex()) {</span>
<span class="line-added">+                     element.setLength(l.getLength());</span>
<span class="line-added">+                     element.setStartPC(l.getStartPC());</span>
<span class="line-added">+                     element.setIndex(l.getIndex());</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
      /**
       * Remove all NOPs from the instruction list (if possible) and update every
       * object referring to them, i.e., branch instructions, local variables and
       * exception handlers.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 802,96 ***</span>
                  }
              }
          }
      }
  
      /**
       * Set maximum number of local variables.
       */
<span class="line-modified">!     public void setMaxLocals(final int m) {</span>
          max_locals = m;
      }
  
      public int getMaxLocals() {
          return max_locals;
      }
  
      /**
       * Set maximum stack size for this method.
       */
<span class="line-modified">!     public void setMaxStack(final int m) { // TODO could be package-protected?</span>
          max_stack = m;
      }
  
      public int getMaxStack() {
          return max_stack;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return class that contains this method</span>
       */
      public String getClassName() {
          return class_name;
      }
  
<span class="line-modified">!     public void setClassName(final String class_name) { // TODO could be package-protected?</span>
          this.class_name = class_name;
      }
  
<span class="line-modified">!     public void setReturnType(final Type return_type) {</span>
          setType(return_type);
      }
  
      public Type getReturnType() {
          return getType();
      }
  
<span class="line-modified">!     public void setArgumentTypes(final Type[] arg_types) {</span>
          this.arg_types = arg_types;
      }
  
      public Type[] getArgumentTypes() {
          return arg_types.clone();
      }
  
<span class="line-modified">!     public void setArgumentType(final int i, final Type type) {</span>
          arg_types[i] = type;
      }
  
<span class="line-modified">!     public Type getArgumentType(final int i) {</span>
          return arg_types[i];
      }
  
<span class="line-modified">!     public void setArgumentNames(final String[] arg_names) {</span>
          this.arg_names = arg_names;
      }
  
      public String[] getArgumentNames() {
          return arg_names.clone();
      }
  
<span class="line-modified">!     public void setArgumentName(final int i, final String name) {</span>
          arg_names[i] = name;
      }
  
<span class="line-modified">!     public String getArgumentName(final int i) {</span>
          return arg_names[i];
      }
  
      public InstructionList getInstructionList() {
          return il;
      }
  
<span class="line-modified">!     public void setInstructionList(final InstructionList il) { // TODO could be package-protected?</span>
          this.il = il;
      }
  
      @Override
      public String getSignature() {
          return Type.getMethodSignature(super.getType(), arg_types);
      }
  
      /**
       * Computes max. stack size by performing control flow analysis.
       */
      public void setMaxStack() { // TODO could be package-protected? (some tests would need repackaging)
          if (il != null) {
<span class="line-new-header">--- 768,115 ---</span>
                  }
              }
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Set maximum number of local variables.
       */
<span class="line-modified">!     public void setMaxLocals( final int m ) {</span>
          max_locals = m;
      }
  
<span class="line-added">+ </span>
      public int getMaxLocals() {
          return max_locals;
      }
  
<span class="line-added">+ </span>
      /**
       * Set maximum stack size for this method.
       */
<span class="line-modified">!     public void setMaxStack( final int m ) { // TODO could be package-protected?</span>
          max_stack = m;
      }
  
<span class="line-added">+ </span>
      public int getMaxStack() {
          return max_stack;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return class that contains this method</span>
       */
      public String getClassName() {
          return class_name;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setClassName( final String class_name ) { // TODO could be package-protected?</span>
          this.class_name = class_name;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setReturnType( final Type return_type ) {</span>
          setType(return_type);
      }
  
<span class="line-added">+ </span>
      public Type getReturnType() {
          return getType();
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setArgumentTypes( final Type[] arg_types ) {</span>
          this.arg_types = arg_types;
      }
  
<span class="line-added">+ </span>
      public Type[] getArgumentTypes() {
          return arg_types.clone();
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setArgumentType( final int i, final Type type ) {</span>
          arg_types[i] = type;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public Type getArgumentType( final int i ) {</span>
          return arg_types[i];
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setArgumentNames( final String[] arg_names ) {</span>
          this.arg_names = arg_names;
      }
  
<span class="line-added">+ </span>
      public String[] getArgumentNames() {
          return arg_names.clone();
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setArgumentName( final int i, final String name ) {</span>
          arg_names[i] = name;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public String getArgumentName( final int i ) {</span>
          return arg_names[i];
      }
  
<span class="line-added">+ </span>
      public InstructionList getInstructionList() {
          return il;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setInstructionList( final InstructionList il ) { // TODO could be package-protected?</span>
          this.il = il;
      }
  
<span class="line-added">+ </span>
      @Override
      public String getSignature() {
          return Type.getMethodSignature(super.getType(), arg_types);
      }
  
<span class="line-added">+ </span>
      /**
       * Computes max. stack size by performing control flow analysis.
       */
      public void setMaxStack() { // TODO could be package-protected? (some tests would need repackaging)
          if (il != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 899,10 ***</span>
<span class="line-new-header">--- 884,11 ---</span>
          } else {
              max_stack = 0;
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Compute maximum number of local variables.
       */
      public void setMaxLocals() { // TODO could be package-protected? (some tests would need repackaging)
          if (il != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 927,23 ***</span>
          } else {
              max_locals = 0;
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Do not/Do produce attributes code attributesLineNumberTable and</span>
       * LocalVariableTable, like javac -O
       */
<span class="line-modified">!     public void stripAttributes(final boolean flag) {</span>
          strip_attributes = flag;
      }
  
      static final class BranchTarget {
  
          final InstructionHandle target;
          final int stackDepth;
  
          BranchTarget(final InstructionHandle target, final int stackDepth) {
              this.target = target;
              this.stackDepth = stackDepth;
          }
      }
<span class="line-new-header">--- 913,24 ---</span>
          } else {
              max_locals = 0;
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Do not/Do produce attributes code attributesLineNumberTable and</span>
       * LocalVariableTable, like javac -O
       */
<span class="line-modified">!     public void stripAttributes( final boolean flag ) {</span>
          strip_attributes = flag;
      }
  
      static final class BranchTarget {
  
          final InstructionHandle target;
          final int stackDepth;
  
<span class="line-added">+ </span>
          BranchTarget(final InstructionHandle target, final int stackDepth) {
              this.target = target;
              this.stackDepth = stackDepth;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 951,44 ***</span>
      static final class BranchStack {
  
          private final Stack&lt;BranchTarget&gt; branchTargets = new Stack&lt;&gt;();
          private final Map&lt;InstructionHandle, BranchTarget&gt; visitedTargets = new HashMap&lt;&gt;();
  
<span class="line-modified">!         public void push(final InstructionHandle target, final int stackDepth) {</span>
              if (visited(target)) {
                  return;
              }
              branchTargets.push(visit(target, stackDepth));
          }
  
          public BranchTarget pop() {
              if (!branchTargets.empty()) {
                  final BranchTarget bt = branchTargets.pop();
                  return bt;
              }
              return null;
          }
  
<span class="line-modified">!         private BranchTarget visit(final InstructionHandle target, final int stackDepth) {</span>
              final BranchTarget bt = new BranchTarget(target, stackDepth);
              visitedTargets.put(target, bt);
              return bt;
          }
  
<span class="line-modified">!         private boolean visited(final InstructionHandle target) {</span>
              return visitedTargets.get(target) != null;
          }
      }
  
      /**
<span class="line-modified">!      * Computes stack usage of an instruction list by performing control flow</span>
<span class="line-removed">-      * analysis.</span>
       *
       * @return maximum stack depth used by method
       */
<span class="line-modified">!     public static int getMaxStack(final ConstantPoolGen cp, final InstructionList il,</span>
<span class="line-removed">-             final CodeExceptionGen[] et) {</span>
          final BranchStack branchTargets = new BranchStack();
          /* Initially, populate the branch stack with the exception
           * handlers, because these aren&#39;t (necessarily) branched to
           * explicitly. in each case, the stack will have depth 1,
           * containing the exception object.
<span class="line-new-header">--- 938,47 ---</span>
      static final class BranchStack {
  
          private final Stack&lt;BranchTarget&gt; branchTargets = new Stack&lt;&gt;();
          private final Map&lt;InstructionHandle, BranchTarget&gt; visitedTargets = new HashMap&lt;&gt;();
  
<span class="line-modified">! </span>
<span class="line-added">+         public void push( final InstructionHandle target, final int stackDepth ) {</span>
              if (visited(target)) {
                  return;
              }
              branchTargets.push(visit(target, stackDepth));
          }
  
<span class="line-added">+ </span>
          public BranchTarget pop() {
              if (!branchTargets.empty()) {
                  final BranchTarget bt = branchTargets.pop();
                  return bt;
              }
              return null;
          }
  
<span class="line-modified">! </span>
<span class="line-added">+         private BranchTarget visit( final InstructionHandle target, final int stackDepth ) {</span>
              final BranchTarget bt = new BranchTarget(target, stackDepth);
              visitedTargets.put(target, bt);
              return bt;
          }
  
<span class="line-modified">! </span>
<span class="line-added">+         private boolean visited( final InstructionHandle target ) {</span>
              return visitedTargets.get(target) != null;
          }
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Computes stack usage of an instruction list by performing control flow analysis.</span>
       *
       * @return maximum stack depth used by method
       */
<span class="line-modified">!     public static int getMaxStack( final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et ) {</span>
          final BranchStack branchTargets = new BranchStack();
          /* Initially, populate the branch stack with the exception
           * handlers, because these aren&#39;t (necessarily) branched to
           * explicitly. in each case, the stack will have depth 1,
           * containing the exception object.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1057,45 ***</span>
          return maxStackDepth;
      }
  
      private List&lt;MethodObserver&gt; observers;
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Add observer for this object.</span>
       */
<span class="line-modified">!     public void addObserver(final MethodObserver o) {</span>
          if (observers == null) {
              observers = new ArrayList&lt;&gt;();
          }
          observers.add(o);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Remove observer for this object.</span>
       */
<span class="line-modified">!     public void removeObserver(final MethodObserver o) {</span>
          if (observers != null) {
              observers.remove(o);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Call notify() method on all observers. This method is not called</span>
<span class="line-modified">!      * automatically whenever the state has changed, but has to be called by the</span>
<span class="line-modified">!      * user after he has finished editing the object.</span>
       */
      public void update() {
          if (observers != null) {
              for (final MethodObserver observer : observers) {
                  observer.notify(this);
              }
          }
      }
  
      /**
<span class="line-modified">!      * Return string representation close to declaration format, e.g. public</span>
<span class="line-modified">!      * static void main(String[]) throws IOException&#39;</span>
       *
       * @return String representation of the method.
       */
      @Override
      public final String toString() {
<span class="line-new-header">--- 1047,46 ---</span>
          return maxStackDepth;
      }
  
      private List&lt;MethodObserver&gt; observers;
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Add observer for this object.</span>
       */
<span class="line-modified">!     public void addObserver( final MethodObserver o ) {</span>
          if (observers == null) {
              observers = new ArrayList&lt;&gt;();
          }
          observers.add(o);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Remove observer for this object.</span>
       */
<span class="line-modified">!     public void removeObserver( final MethodObserver o ) {</span>
          if (observers != null) {
              observers.remove(o);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Call notify() method on all observers. This method is not called</span>
<span class="line-modified">!      * automatically whenever the state has changed, but has to be</span>
<span class="line-modified">!      * called by the user after he has finished editing the object.</span>
       */
      public void update() {
          if (observers != null) {
              for (final MethodObserver observer : observers) {
                  observer.notify(this);
              }
          }
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return string representation close to declaration format,</span>
<span class="line-modified">!      * `public static void main(String[]) throws IOException&#39;, e.g.</span>
       *
       * @return String representation of the method.
       */
      @Override
      public final String toString() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1116,14 ***</span>
              }
          }
          return buf.toString();
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return deep copy of this method</span>
       */
<span class="line-modified">!     public MethodGen copy(final String class_name, final ConstantPoolGen cp) {</span>
          final Method m = ((MethodGen) clone()).getMethod();
          final MethodGen mg = new MethodGen(m, class_name, super.getConstantPool());
          if (super.getConstantPool() != cp) {
              mg.setConstantPool(cp);
              mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);
<span class="line-new-header">--- 1107,14 ---</span>
              }
          }
          return buf.toString();
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return deep copy of this method</span>
       */
<span class="line-modified">!     public MethodGen copy( final String class_name, final ConstantPoolGen cp ) {</span>
          final Method m = ((MethodGen) clone()).getMethod();
          final MethodGen mg = new MethodGen(m, class_name, super.getConstantPool());
          if (super.getConstantPool() != cp) {
              mg.setConstantPool(cp);
              mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1133,11 ***</span>
  
      //J5TODO: Should param_annotations be an array of arrays? Rather than an array of lists, this
      // is more likely to suggest to the caller it is readonly (which a List does not).
      /**
       * Return a list of AnnotationGen objects representing parameter annotations
<span class="line-removed">-      *</span>
       * @since 6.0
       */
      public List&lt;AnnotationEntryGen&gt; getAnnotationsOnParameter(final int i) {
          ensureExistingParameterAnnotationsUnpacked();
          if (!hasParameterAnnotations || i &gt; arg_types.length) {
<span class="line-new-header">--- 1124,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1152,22 ***</span>
       * as parameter annotations. There are two kinds of parameter annotation -
       * visible and invisible. Once they have been unpacked, these attributes are
       * deleted. (The annotations will be rebuilt as attributes when someone
       * builds a Method object out of this MethodGen object).
       */
<span class="line-modified">!     private void ensureExistingParameterAnnotationsUnpacked() {</span>
          if (haveUnpackedParameterAnnotations) {
              return;
          }
          // Find attributes that contain parameter annotation data
          final Attribute[] attrs = getAttributes();
          ParameterAnnotations paramAnnVisAttr = null;
          ParameterAnnotations paramAnnInvisAttr = null;
          for (final Attribute attribute : attrs) {
<span class="line-modified">!             if (attribute instanceof ParameterAnnotations) {</span>
                  // Initialize param_annotations
<span class="line-modified">!                 if (!hasParameterAnnotations) {</span>
                      @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
                      final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
                      param_annotations = parmList;
                      for (int j = 0; j &lt; arg_types.length; j++) {
                          param_annotations[j] = new ArrayList&lt;&gt;();
<span class="line-new-header">--- 1142,25 ---</span>
       * as parameter annotations. There are two kinds of parameter annotation -
       * visible and invisible. Once they have been unpacked, these attributes are
       * deleted. (The annotations will be rebuilt as attributes when someone
       * builds a Method object out of this MethodGen object).
       */
<span class="line-modified">!     private void ensureExistingParameterAnnotationsUnpacked()</span>
<span class="line-added">+     {</span>
          if (haveUnpackedParameterAnnotations) {
              return;
          }
          // Find attributes that contain parameter annotation data
          final Attribute[] attrs = getAttributes();
          ParameterAnnotations paramAnnVisAttr = null;
          ParameterAnnotations paramAnnInvisAttr = null;
          for (final Attribute attribute : attrs) {
<span class="line-modified">!             if (attribute instanceof ParameterAnnotations)</span>
<span class="line-added">+             {</span>
                  // Initialize param_annotations
<span class="line-modified">!                 if (!hasParameterAnnotations)</span>
<span class="line-added">+                 {</span>
                      @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
                      final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
                      param_annotations = parmList;
                      for (int j = 0; j &lt; arg_types.length; j++) {
                          param_annotations[j] = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1178,17 ***</span>
                  if (rpa instanceof RuntimeVisibleParameterAnnotations) {
                      paramAnnVisAttr = rpa;
                  } else {
                      paramAnnInvisAttr = rpa;
                  }
<span class="line-modified">!                 for (int j = 0; j &lt; arg_types.length; j++) {</span>
                      // This returns Annotation[] ...
<span class="line-modified">!                     final ParameterAnnotationEntry immutableArray = rpa</span>
<span class="line-removed">-                             .getParameterAnnotationEntries()[j];</span>
                      // ... which needs transforming into an AnnotationGen[] ...
<span class="line-modified">!                     final List&lt;AnnotationEntryGen&gt; mutable</span>
<span class="line-removed">-                             = makeMutableVersion(immutableArray.getAnnotationEntries());</span>
                      // ... then add these to any we already know about
                      param_annotations[j].addAll(mutable);
                  }
              }
          }
<span class="line-new-header">--- 1171,17 ---</span>
                  if (rpa instanceof RuntimeVisibleParameterAnnotations) {
                      paramAnnVisAttr = rpa;
                  } else {
                      paramAnnInvisAttr = rpa;
                  }
<span class="line-modified">!                 final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();</span>
<span class="line-added">+                 for (int j = 0; j &lt; parameterAnnotationEntries.length; j++)</span>
<span class="line-added">+                 {</span>
                      // This returns Annotation[] ...
<span class="line-modified">!                     final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];</span>
                      // ... which needs transforming into an AnnotationGen[] ...
<span class="line-modified">!                     final List&lt;AnnotationEntryGen&gt; mutable = makeMutableVersion(immutableArray.getAnnotationEntries());</span>
                      // ... then add these to any we already know about
                      param_annotations[j].addAll(mutable);
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1199,32 ***</span>
              removeAttribute(paramAnnInvisAttr);
          }
          haveUnpackedParameterAnnotations = true;
      }
  
<span class="line-modified">!     private List&lt;AnnotationEntryGen&gt; makeMutableVersion(final AnnotationEntry[] mutableArray) {</span>
          final List&lt;AnnotationEntryGen&gt; result = new ArrayList&lt;&gt;();
          for (final AnnotationEntry element : mutableArray) {
              result.add(new AnnotationEntryGen(element, getConstantPool(),
                      false));
          }
          return result;
      }
  
      public void addParameterAnnotation(final int parameterIndex,
<span class="line-modified">!             final AnnotationEntryGen annotation) {</span>
          ensureExistingParameterAnnotationsUnpacked();
<span class="line-modified">!         if (!hasParameterAnnotations) {</span>
              @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
              final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
              param_annotations = parmList;
              hasParameterAnnotations = true;
          }
          final List&lt;AnnotationEntryGen&gt; existingAnnotations = param_annotations[parameterIndex];
<span class="line-modified">!         if (existingAnnotations != null) {</span>
              existingAnnotations.add(annotation);
<span class="line-modified">!         } else {</span>
              final List&lt;AnnotationEntryGen&gt; l = new ArrayList&lt;&gt;();
              l.add(annotation);
              param_annotations[parameterIndex] = l;
          }
      }
<span class="line-new-header">--- 1192,38 ---</span>
              removeAttribute(paramAnnInvisAttr);
          }
          haveUnpackedParameterAnnotations = true;
      }
  
<span class="line-modified">!     private List&lt;AnnotationEntryGen&gt; makeMutableVersion(final AnnotationEntry[] mutableArray)</span>
<span class="line-added">+     {</span>
          final List&lt;AnnotationEntryGen&gt; result = new ArrayList&lt;&gt;();
          for (final AnnotationEntry element : mutableArray) {
              result.add(new AnnotationEntryGen(element, getConstantPool(),
                      false));
          }
          return result;
      }
  
      public void addParameterAnnotation(final int parameterIndex,
<span class="line-modified">!             final AnnotationEntryGen annotation)</span>
<span class="line-added">+     {</span>
          ensureExistingParameterAnnotationsUnpacked();
<span class="line-modified">!         if (!hasParameterAnnotations)</span>
<span class="line-added">+         {</span>
              @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
              final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
              param_annotations = parmList;
              hasParameterAnnotations = true;
          }
          final List&lt;AnnotationEntryGen&gt; existingAnnotations = param_annotations[parameterIndex];
<span class="line-modified">!         if (existingAnnotations != null)</span>
<span class="line-added">+         {</span>
              existingAnnotations.add(annotation);
<span class="line-modified">!         }</span>
<span class="line-added">+         else</span>
<span class="line-added">+         {</span>
              final List&lt;AnnotationEntryGen&gt; l = new ArrayList&lt;&gt;();
              l.add(annotation);
              param_annotations[parameterIndex] = l;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1234,32 ***</span>
       */
      public static BCELComparator getComparator() {
          return bcelComparator;
      }
  
      /**
       * @param comparator Comparison strategy object
       */
<span class="line-modified">!     public static void setComparator(final BCELComparator comparator) {</span>
          bcelComparator = comparator;
      }
  
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">!      * MethodGen objects are said to be equal when their names and signatures</span>
<span class="line-modified">!      * are equal.</span>
       *
       * @see java.lang.Object#equals(java.lang.Object)
       */
      @Override
<span class="line-modified">!     public boolean equals(final Object obj) {</span>
          return bcelComparator.equals(this, obj);
      }
  
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">!      * return the hashcode of the method&#39;s name XOR signature.</span>
       *
       * @see java.lang.Object#hashCode()
       */
      @Override
      public int hashCode() {
<span class="line-new-header">--- 1233,35 ---</span>
       */
      public static BCELComparator getComparator() {
          return bcelComparator;
      }
  
<span class="line-added">+ </span>
      /**
       * @param comparator Comparison strategy object
       */
<span class="line-modified">!     public static void setComparator( final BCELComparator comparator ) {</span>
          bcelComparator = comparator;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">!      * By default two MethodGen objects are said to be equal when</span>
<span class="line-modified">!      * their names and signatures are equal.</span>
       *
       * @see java.lang.Object#equals(java.lang.Object)
       */
      @Override
<span class="line-modified">!     public boolean equals( final Object obj ) {</span>
          return bcelComparator.equals(this, obj);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">!      * By default return the hashcode of the method&#39;s name XOR signature.</span>
       *
       * @see java.lang.Object#hashCode()
       */
      @Override
      public int hashCode() {
</pre>
<center><a href="MULTIANEWARRAY.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="MethodObserver.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ElementNSImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ElementImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ElementNSImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69     // REVISIT: we are losing the type information in DOM during serialization
 70     transient XSTypeDefinition type;
 71 
 72     protected ElementNSImpl() {
 73         super();
 74     }
 75     /**
 76      * DOM2: Constructor for Namespace implementation.
 77      */
 78     protected ElementNSImpl(CoreDocumentImpl ownerDocument,
 79                             String namespaceURI,
 80                             String qualifiedName)
 81         throws DOMException
 82     {
 83         super(ownerDocument, qualifiedName);
 84         setName(namespaceURI, qualifiedName);
 85     }
 86 
 87         private void setName(String namespaceURI, String qname) {
 88 
<span class="line-modified"> 89                 String prefix;</span>
<span class="line-modified"> 90                 // DOM Level 3: namespace URI is never empty string.</span>
<span class="line-modified"> 91                 this.namespaceURI = namespaceURI;</span>
<span class="line-modified"> 92                 if (namespaceURI != null) {</span>
 93             //convert the empty string to &#39;null&#39;
<span class="line-modified"> 94                         this.namespaceURI =     (namespaceURI.length() == 0) ? null : namespaceURI;</span>
<span class="line-modified"> 95                 }</span>
 96 
 97         int colon1, colon2 ;
 98 
 99         //NAMESPACE_ERR:
100         //1. if the qualified name is &#39;null&#39; it is malformed.
101         //2. or if the qualifiedName is null and the namespaceURI is different from null,
102         // We dont need to check for namespaceURI != null, if qualified name is null throw DOMException.
103         if(qname == null){
104                                 String msg =
105                                         DOMMessageFormatter.formatMessage(
106                                                 DOMMessageFormatter.DOM_DOMAIN,
107                                                 &quot;NAMESPACE_ERR&quot;,
108                                                 null);
109                                 throw new DOMException(DOMException.NAMESPACE_ERR, msg);
110         }
111         else{
112                     colon1 = qname.indexOf(&#39;:&#39;);
113                     colon2 = qname.lastIndexOf(&#39;:&#39;);
114         }
115 
</pre>
<hr />
<pre>
173 
174     // for DeferredElementImpl
175     protected ElementNSImpl(CoreDocumentImpl ownerDocument,
176                             String value) {
177         super(ownerDocument, value);
178     }
179 
180     // Support for DOM Level 3 renameNode method.
181     // Note: This only deals with part of the pb. CoreDocumentImpl
182     // does all the work.
183     void rename(String namespaceURI, String qualifiedName)
184     {
185         if (needsSyncData()) {
186             synchronizeData();
187         }
188                 this.name = qualifiedName;
189         setName(namespaceURI, qualifiedName);
190         reconcileDefaultAttributes();
191     }
192 
<span class="line-removed">193     /**</span>
<span class="line-removed">194      * NON-DOM: resets this node and sets specified values for the node</span>
<span class="line-removed">195      *</span>
<span class="line-removed">196      * @param ownerDocument</span>
<span class="line-removed">197      * @param namespaceURI</span>
<span class="line-removed">198      * @param qualifiedName</span>
<span class="line-removed">199      * @param localName</span>
<span class="line-removed">200      */</span>
<span class="line-removed">201     protected void setValues (CoreDocumentImpl ownerDocument,</span>
<span class="line-removed">202                             String namespaceURI, String qualifiedName,</span>
<span class="line-removed">203                             String localName){</span>
<span class="line-removed">204 </span>
<span class="line-removed">205         // remove children first</span>
<span class="line-removed">206         firstChild = null;</span>
<span class="line-removed">207         previousSibling = null;</span>
<span class="line-removed">208         nextSibling = null;</span>
<span class="line-removed">209         fNodeListCache = null;</span>
<span class="line-removed">210 </span>
<span class="line-removed">211         // set owner document</span>
<span class="line-removed">212         attributes = null;</span>
<span class="line-removed">213         super.flags = 0;</span>
<span class="line-removed">214         setOwnerDocument(ownerDocument);</span>
<span class="line-removed">215 </span>
<span class="line-removed">216         // synchronizeData will initialize attributes</span>
<span class="line-removed">217         needsSyncData(true);</span>
<span class="line-removed">218         super.name = qualifiedName;</span>
<span class="line-removed">219         this.localName = localName;</span>
<span class="line-removed">220         this.namespaceURI = namespaceURI;</span>
<span class="line-removed">221 </span>
<span class="line-removed">222     }</span>
<span class="line-removed">223 </span>
224     //
225     // Node methods
226     //
227 
228 
229 
230     //
231     //DOM2: Namespace methods.
232     //
233 
234     /**
235      * Introduced in DOM Level 2. &lt;p&gt;
236      *
237      * The namespace URI of this node, or null if it is unspecified.&lt;p&gt;
238      *
239      * This is not a computed value that is the result of a namespace lookup based on
240      * an examination of the namespace declarations in scope. It is merely the
241      * namespace URI given at creation time.&lt;p&gt;
242      *
243      * For nodes created with a DOM Level 1 method, such as createElement
</pre>
<hr />
<pre>
323         }
324         else {
325             name = localName;
326         }
327     }
328 
329     /**
330      * Introduced in DOM Level 2. &lt;p&gt;
331      *
332      * Returns the local part of the qualified name of this node.
333      * @since WD-DOM-Level-2-19990923
334      */
335     public String getLocalName()
336     {
337         if (needsSyncData()) {
338             synchronizeData();
339         }
340         return localName;
341     }
342 
<span class="line-modified">343 </span>
<span class="line-modified">344    /**</span>
<span class="line-modified">345      * DOM Level 3 WD - Experimental.</span>
<span class="line-removed">346      * Retrieve baseURI</span>
347      */
<span class="line-modified">348     public String getBaseURI() {</span>
<span class="line-modified">349 </span>
<span class="line-modified">350         if (needsSyncData()) {</span>
<span class="line-removed">351             synchronizeData();</span>
<span class="line-removed">352         }</span>
<span class="line-removed">353         // Absolute base URI is computed according to XML Base (http://www.w3.org/TR/xmlbase/#granularity)</span>
<span class="line-removed">354 </span>
<span class="line-removed">355         // 1.  the base URI specified by an xml:base attribute on the element, if one exists</span>
<span class="line-removed">356 </span>
<span class="line-removed">357         if (attributes != null) {</span>
<span class="line-removed">358             Attr attrNode = (Attr)attributes.getNamedItemNS(&quot;http://www.w3.org/XML/1998/namespace&quot;, &quot;base&quot;);</span>
<span class="line-removed">359             if (attrNode != null) {</span>
<span class="line-removed">360                 String uri =  attrNode.getNodeValue();</span>
<span class="line-removed">361                 if (uri.length() != 0 ) {// attribute value is always empty string</span>
<span class="line-removed">362                     try {</span>
<span class="line-removed">363                         uri = new URI(uri).toString();</span>
<span class="line-removed">364                     }</span>
<span class="line-removed">365                     catch (com.sun.org.apache.xerces.internal.util.URI.MalformedURIException e) {</span>
<span class="line-removed">366                         // This may be a relative URI.</span>
<span class="line-removed">367 </span>
<span class="line-removed">368                         // Start from the base URI of the parent, or if this node has no parent, the owner node.</span>
<span class="line-removed">369                         NodeImpl parentOrOwner = (parentNode() != null) ? parentNode() : ownerNode;</span>
<span class="line-removed">370 </span>
<span class="line-removed">371                         // Make any parentURI into a URI object to use with the URI(URI, String) constructor.</span>
<span class="line-removed">372                         String parentBaseURI = (parentOrOwner != null) ? parentOrOwner.getBaseURI() : null;</span>
<span class="line-removed">373 </span>
<span class="line-removed">374                         if (parentBaseURI != null) {</span>
<span class="line-removed">375                             try {</span>
<span class="line-removed">376                                 uri = new URI(new URI(parentBaseURI), uri).toString();</span>
<span class="line-removed">377                             }</span>
<span class="line-removed">378                             catch (com.sun.org.apache.xerces.internal.util.URI.MalformedURIException ex){</span>
<span class="line-removed">379                                 // This should never happen: parent should have checked the URI and returned null if invalid.</span>
<span class="line-removed">380                                 return null;</span>
<span class="line-removed">381                             }</span>
<span class="line-removed">382                             return uri;</span>
<span class="line-removed">383                         }</span>
<span class="line-removed">384                         // REVISIT: what should happen in this case?</span>
<span class="line-removed">385                         return null;</span>
<span class="line-removed">386                     }</span>
<span class="line-removed">387                     return uri;</span>
<span class="line-removed">388                 }</span>
<span class="line-removed">389             }</span>
<span class="line-removed">390         }</span>
<span class="line-removed">391 </span>
<span class="line-removed">392         //2.the base URI of the element&#39;s parent element within the document or external entity,</span>
<span class="line-removed">393         //if one exists</span>
<span class="line-removed">394         String parentElementBaseURI = (this.parentNode() != null) ? this.parentNode().getBaseURI() : null ;</span>
<span class="line-removed">395         //base URI of parent element is not null</span>
<span class="line-removed">396         if(parentElementBaseURI != null){</span>
<span class="line-removed">397             try {</span>
<span class="line-removed">398                 //return valid absolute base URI</span>
<span class="line-removed">399                return new URI(parentElementBaseURI).toString();</span>
<span class="line-removed">400             }</span>
<span class="line-removed">401             catch (com.sun.org.apache.xerces.internal.util.URI.MalformedURIException e){</span>
<span class="line-removed">402                 // REVISIT: what should happen in this case?</span>
<span class="line-removed">403                 return null;</span>
<span class="line-removed">404             }</span>
<span class="line-removed">405         }</span>
<span class="line-removed">406         //3. the base URI of the document entity or external entity containing the element</span>
<span class="line-removed">407 </span>
<span class="line-removed">408         String baseURI = (this.ownerNode != null) ? this.ownerNode.getBaseURI() : null ;</span>
<span class="line-removed">409 </span>
<span class="line-removed">410         if(baseURI != null){</span>
<span class="line-removed">411             try {</span>
<span class="line-removed">412                 //return valid absolute base URI</span>
<span class="line-removed">413                return new URI(baseURI).toString();</span>
<span class="line-removed">414             }</span>
<span class="line-removed">415             catch (com.sun.org.apache.xerces.internal.util.URI.MalformedURIException e){</span>
<span class="line-removed">416                 // REVISIT: what should happen in this case?</span>
<span class="line-removed">417                 return null;</span>
<span class="line-removed">418             }</span>
<span class="line-removed">419         }</span>
<span class="line-removed">420 </span>
<span class="line-removed">421         return null;</span>
<span class="line-removed">422 </span>
<span class="line-removed">423     }</span>
<span class="line-removed">424 </span>
425 
426     /**
427      * @see org.w3c.dom.TypeInfo#getTypeName()
428      */
429     public String getTypeName() {
430         if (type !=null){
431             if (type instanceof XSSimpleTypeDecl) {
432                 return ((XSSimpleTypeDecl) type).getTypeName();
433             } else if (type instanceof XSComplexTypeDecl) {
434                 return ((XSComplexTypeDecl) type).getTypeName();
435             }
436         }
437         return null;
438     }
439 
440     /**
441      * @see org.w3c.dom.TypeInfo#getTypeNamespace()
442      */
443     public String getTypeNamespace() {
444         if (type !=null){
445             return type.getNamespace();
446         }
447         return null;
448     }
449 
450     /**
451      * Introduced in DOM Level 2. &lt;p&gt;
452      * Checks if a type is derived from another by restriction. See:
453      * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom
454      *
<span class="line-modified">455      * @param ancestorNS</span>
456      *        The namspace of the ancestor type declaration
<span class="line-modified">457      * @param ancestorName</span>
458      *        The name of the ancestor type declaration
<span class="line-modified">459      * @param type</span>
<span class="line-modified">460      *        The reference type definition</span>
461      *
462      * @return boolean True if the type is derived by restriciton for the
463      *         reference type
464      */
465     public boolean isDerivedFrom(String typeNamespaceArg, String typeNameArg,
466             int derivationMethod) {
467         if(needsSyncData()) {
468             synchronizeData();
469         }
470         if (type != null) {
471             if (type instanceof XSSimpleTypeDecl) {
472                 return ((XSSimpleTypeDecl) type).isDOMDerivedFrom(
473                         typeNamespaceArg, typeNameArg, derivationMethod);
474             } else if (type instanceof XSComplexTypeDecl) {
475                 return ((XSComplexTypeDecl) type).isDOMDerivedFrom(
476                         typeNamespaceArg, typeNameArg, derivationMethod);
477             }
478         }
479         return false;
480     }
</pre>
</td>
<td>
<hr />
<pre>
 69     // REVISIT: we are losing the type information in DOM during serialization
 70     transient XSTypeDefinition type;
 71 
 72     protected ElementNSImpl() {
 73         super();
 74     }
 75     /**
 76      * DOM2: Constructor for Namespace implementation.
 77      */
 78     protected ElementNSImpl(CoreDocumentImpl ownerDocument,
 79                             String namespaceURI,
 80                             String qualifiedName)
 81         throws DOMException
 82     {
 83         super(ownerDocument, qualifiedName);
 84         setName(namespaceURI, qualifiedName);
 85     }
 86 
 87         private void setName(String namespaceURI, String qname) {
 88 
<span class="line-modified"> 89             String prefix;</span>
<span class="line-modified"> 90             // DOM Level 3: namespace URI is never empty string.</span>
<span class="line-modified"> 91             this.namespaceURI = namespaceURI;</span>
<span class="line-modified"> 92             if (namespaceURI != null) {</span>
 93             //convert the empty string to &#39;null&#39;
<span class="line-modified"> 94             this.namespaceURI = (namespaceURI.length() == 0) ? null : namespaceURI;</span>
<span class="line-modified"> 95             }</span>
 96 
 97         int colon1, colon2 ;
 98 
 99         //NAMESPACE_ERR:
100         //1. if the qualified name is &#39;null&#39; it is malformed.
101         //2. or if the qualifiedName is null and the namespaceURI is different from null,
102         // We dont need to check for namespaceURI != null, if qualified name is null throw DOMException.
103         if(qname == null){
104                                 String msg =
105                                         DOMMessageFormatter.formatMessage(
106                                                 DOMMessageFormatter.DOM_DOMAIN,
107                                                 &quot;NAMESPACE_ERR&quot;,
108                                                 null);
109                                 throw new DOMException(DOMException.NAMESPACE_ERR, msg);
110         }
111         else{
112                     colon1 = qname.indexOf(&#39;:&#39;);
113                     colon2 = qname.lastIndexOf(&#39;:&#39;);
114         }
115 
</pre>
<hr />
<pre>
173 
174     // for DeferredElementImpl
175     protected ElementNSImpl(CoreDocumentImpl ownerDocument,
176                             String value) {
177         super(ownerDocument, value);
178     }
179 
180     // Support for DOM Level 3 renameNode method.
181     // Note: This only deals with part of the pb. CoreDocumentImpl
182     // does all the work.
183     void rename(String namespaceURI, String qualifiedName)
184     {
185         if (needsSyncData()) {
186             synchronizeData();
187         }
188                 this.name = qualifiedName;
189         setName(namespaceURI, qualifiedName);
190         reconcileDefaultAttributes();
191     }
192 































193     //
194     // Node methods
195     //
196 
197 
198 
199     //
200     //DOM2: Namespace methods.
201     //
202 
203     /**
204      * Introduced in DOM Level 2. &lt;p&gt;
205      *
206      * The namespace URI of this node, or null if it is unspecified.&lt;p&gt;
207      *
208      * This is not a computed value that is the result of a namespace lookup based on
209      * an examination of the namespace declarations in scope. It is merely the
210      * namespace URI given at creation time.&lt;p&gt;
211      *
212      * For nodes created with a DOM Level 1 method, such as createElement
</pre>
<hr />
<pre>
292         }
293         else {
294             name = localName;
295         }
296     }
297 
298     /**
299      * Introduced in DOM Level 2. &lt;p&gt;
300      *
301      * Returns the local part of the qualified name of this node.
302      * @since WD-DOM-Level-2-19990923
303      */
304     public String getLocalName()
305     {
306         if (needsSyncData()) {
307             synchronizeData();
308         }
309         return localName;
310     }
311 
<span class="line-modified">312     /**</span>
<span class="line-modified">313      * NON-DOM</span>
<span class="line-modified">314      * Returns the xml:base attribute.</span>

315      */
<span class="line-modified">316     protected Attr getXMLBaseAttribute() {</span>
<span class="line-modified">317         return (Attr) attributes.getNamedItemNS(&quot;http://www.w3.org/XML/1998/namespace&quot;, &quot;base&quot;);</span>
<span class="line-modified">318     } // getXMLBaseAttribute():Attr</span>










































































319 
320     /**
321      * @see org.w3c.dom.TypeInfo#getTypeName()
322      */
323     public String getTypeName() {
324         if (type !=null){
325             if (type instanceof XSSimpleTypeDecl) {
326                 return ((XSSimpleTypeDecl) type).getTypeName();
327             } else if (type instanceof XSComplexTypeDecl) {
328                 return ((XSComplexTypeDecl) type).getTypeName();
329             }
330         }
331         return null;
332     }
333 
334     /**
335      * @see org.w3c.dom.TypeInfo#getTypeNamespace()
336      */
337     public String getTypeNamespace() {
338         if (type !=null){
339             return type.getNamespace();
340         }
341         return null;
342     }
343 
344     /**
345      * Introduced in DOM Level 2. &lt;p&gt;
346      * Checks if a type is derived from another by restriction. See:
347      * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom
348      *
<span class="line-modified">349      * @param typeNamespaceArg</span>
350      *        The namspace of the ancestor type declaration
<span class="line-modified">351      * @param typeNameArg</span>
352      *        The name of the ancestor type declaration
<span class="line-modified">353      * @param derivationMethod</span>
<span class="line-modified">354      *        The derivation method</span>
355      *
356      * @return boolean True if the type is derived by restriciton for the
357      *         reference type
358      */
359     public boolean isDerivedFrom(String typeNamespaceArg, String typeNameArg,
360             int derivationMethod) {
361         if(needsSyncData()) {
362             synchronizeData();
363         }
364         if (type != null) {
365             if (type instanceof XSSimpleTypeDecl) {
366                 return ((XSSimpleTypeDecl) type).isDOMDerivedFrom(
367                         typeNamespaceArg, typeNameArg, derivationMethod);
368             } else if (type instanceof XSComplexTypeDecl) {
369                 return ((XSComplexTypeDecl) type).isDOMDerivedFrom(
370                         typeNamespaceArg, typeNameArg, derivationMethod);
371             }
372         }
373         return false;
374     }
</pre>
</td>
</tr>
</table>
<center><a href="ElementImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
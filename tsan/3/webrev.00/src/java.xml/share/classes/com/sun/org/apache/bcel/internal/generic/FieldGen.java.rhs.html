<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/FieldGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.ArrayList;
 23 import java.util.List;
<a name="2" id="anc2"></a><span class="line-added"> 24 import java.util.Objects;</span>
 25 
 26 import com.sun.org.apache.bcel.internal.Const;
 27 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
 28 import com.sun.org.apache.bcel.internal.classfile.Annotations;
 29 import com.sun.org.apache.bcel.internal.classfile.Attribute;
 30 import com.sun.org.apache.bcel.internal.classfile.Constant;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantObject;
 32 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 33 import com.sun.org.apache.bcel.internal.classfile.ConstantValue;
 34 import com.sun.org.apache.bcel.internal.classfile.Field;
 35 import com.sun.org.apache.bcel.internal.classfile.Utility;
 36 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 37 
 38 /**
<a name="3" id="anc3"></a><span class="line-modified"> 39  * Template class for building up a field.  The only extraordinary thing</span>
<span class="line-modified"> 40  * one can do is to add a constant value attribute to a field (which must of</span>
<span class="line-modified"> 41  * course be compatible with to the declared type).</span>
 42  *
<a name="4" id="anc4"></a>
 43  * @see Field
<a name="5" id="anc5"></a><span class="line-added"> 44  * @LastModified: Jan 2020</span>
 45  */
 46 public class FieldGen extends FieldGenOrMethodGen {
 47 
 48     private Object value = null;
 49     private static BCELComparator bcelComparator = new BCELComparator() {
 50 
 51         @Override
<a name="6" id="anc6"></a><span class="line-modified"> 52         public boolean equals( final Object o1, final Object o2 ) {</span>
 53             final FieldGen THIS = (FieldGen) o1;
 54             final FieldGen THAT = (FieldGen) o2;
<a name="7" id="anc7"></a><span class="line-modified"> 55             return Objects.equals(THIS.getName(), THAT.getName())</span>
<span class="line-modified"> 56                     &amp;&amp; Objects.equals(THIS.getSignature(), THAT.getSignature());</span>
 57         }
 58 
<a name="8" id="anc8"></a><span class="line-added"> 59 </span>
 60         @Override
<a name="9" id="anc9"></a><span class="line-modified"> 61         public int hashCode( final Object o ) {</span>
 62             final FieldGen THIS = (FieldGen) o;
 63             return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
 64         }
 65     };
 66 
<a name="10" id="anc10"></a><span class="line-added"> 67 </span>
 68     /**
<a name="11" id="anc11"></a><span class="line-modified"> 69      * Declare a field. If it is static (isStatic() == true) and has a</span>
<span class="line-modified"> 70      * basic type like int or String it may have an initial value</span>
<span class="line-modified"> 71      * associated with it as defined by setInitValue().</span>
 72      *
 73      * @param access_flags access qualifiers
<a name="12" id="anc12"></a><span class="line-modified"> 74      * @param type  field type</span>
 75      * @param name field name
 76      * @param cp constant pool
 77      */
 78     public FieldGen(final int access_flags, final Type type, final String name, final ConstantPoolGen cp) {
 79         super(access_flags);
 80         setType(type);
 81         setName(name);
 82         setConstantPool(cp);
 83     }
 84 
<a name="13" id="anc13"></a><span class="line-added"> 85 </span>
 86     /**
 87      * Instantiate from existing field.
 88      *
 89      * @param field Field object
<a name="14" id="anc14"></a><span class="line-modified"> 90      * @param cp constant pool (must contain the same entries as the field&#39;s constant pool)</span>

 91      */
 92     public FieldGen(final Field field, final ConstantPoolGen cp) {
 93         this(field.getAccessFlags(), Type.getType(field.getSignature()), field.getName(), cp);
 94         final Attribute[] attrs = field.getAttributes();
 95         for (final Attribute attr : attrs) {
 96             if (attr instanceof ConstantValue) {
 97                 setValue(((ConstantValue) attr).getConstantValueIndex());
 98             } else if (attr instanceof Annotations) {
<a name="15" id="anc15"></a><span class="line-modified"> 99                 final Annotations runtimeAnnotations = (Annotations)attr;</span>
100                 final AnnotationEntry[] annotationEntries = runtimeAnnotations.getAnnotationEntries();
101                 for (final AnnotationEntry element : annotationEntries) {
<a name="16" id="anc16"></a><span class="line-modified">102                     addAnnotationEntry(new AnnotationEntryGen(element,cp,false));</span>
103                 }
104             } else {
105                 addAttribute(attr);
106             }
107         }
108     }
109 
<a name="17" id="anc17"></a><span class="line-modified">110 </span>
<span class="line-added">111     private void setValue( final int index ) {</span>
112         final ConstantPool cp = super.getConstantPool().getConstantPool();
113         final Constant c = cp.getConstant(index);
114         value = ((ConstantObject) c).getConstantValue(cp);
115     }
116 
<a name="18" id="anc18"></a><span class="line-added">117 </span>
118     /**
<a name="19" id="anc19"></a><span class="line-modified">119      * Set (optional) initial value of field, otherwise it will be set to null/0/false</span>
<span class="line-modified">120      * by the JVM automatically.</span>
121      */
<a name="20" id="anc20"></a><span class="line-modified">122     public void setInitValue( final String str ) {</span>
<span class="line-modified">123         checkType(  ObjectType.getInstance(&quot;java.lang.String&quot;));</span>
124         if (str != null) {
125             value = str;
126         }
127     }
128 
<a name="21" id="anc21"></a><span class="line-modified">129 </span>
<span class="line-added">130     public void setInitValue( final long l ) {</span>
131         checkType(Type.LONG);
132         if (l != 0L) {
<a name="22" id="anc22"></a><span class="line-modified">133             value = Long.valueOf(l);</span>
134         }
135     }
136 
<a name="23" id="anc23"></a><span class="line-modified">137 </span>
<span class="line-added">138     public void setInitValue( final int i ) {</span>
139         checkType(Type.INT);
140         if (i != 0) {
<a name="24" id="anc24"></a><span class="line-modified">141             value = Integer.valueOf(i);</span>
142         }
143     }
144 
<a name="25" id="anc25"></a><span class="line-modified">145 </span>
<span class="line-added">146     public void setInitValue( final short s ) {</span>
147         checkType(Type.SHORT);
148         if (s != 0) {
<a name="26" id="anc26"></a><span class="line-modified">149             value = Integer.valueOf(s);</span>
150         }
151     }
152 
<a name="27" id="anc27"></a><span class="line-modified">153 </span>
<span class="line-added">154     public void setInitValue( final char c ) {</span>
155         checkType(Type.CHAR);
156         if (c != 0) {
<a name="28" id="anc28"></a><span class="line-modified">157             value = Integer.valueOf(c);</span>
158         }
159     }
160 
<a name="29" id="anc29"></a><span class="line-modified">161 </span>
<span class="line-added">162     public void setInitValue( final byte b ) {</span>
163         checkType(Type.BYTE);
164         if (b != 0) {
<a name="30" id="anc30"></a><span class="line-modified">165             value = Integer.valueOf(b);</span>
166         }
167     }
168 
<a name="31" id="anc31"></a><span class="line-modified">169 </span>
<span class="line-added">170     public void setInitValue( final boolean b ) {</span>
171         checkType(Type.BOOLEAN);
172         if (b) {
<a name="32" id="anc32"></a><span class="line-modified">173             value = Integer.valueOf(1);</span>
174         }
175     }
176 
<a name="33" id="anc33"></a><span class="line-modified">177 </span>
<span class="line-added">178     public void setInitValue( final float f ) {</span>
179         checkType(Type.FLOAT);
180         if (f != 0.0) {
181             value = f;
182         }
183     }
184 
<a name="34" id="anc34"></a><span class="line-modified">185 </span>
<span class="line-added">186     public void setInitValue( final double d ) {</span>
187         checkType(Type.DOUBLE);
188         if (d != 0.0) {
189             value = d;
190         }
191     }
192 
<a name="35" id="anc35"></a><span class="line-modified">193 </span>
<span class="line-modified">194     /** Remove any initial value.</span>
195      */
196     public void cancelInitValue() {
197         value = null;
198     }
199 
<a name="36" id="anc36"></a><span class="line-modified">200 </span>
<span class="line-added">201     private void checkType( final Type atype ) {</span>
202         final Type superType = super.getType();
203         if (superType == null) {
204             throw new ClassGenException(&quot;You haven&#39;t defined the type of the field yet&quot;);
205         }
206         if (!isFinal()) {
207             throw new ClassGenException(&quot;Only final fields may have an initial value!&quot;);
208         }
209         if (!superType.equals(atype)) {
210             throw new ClassGenException(&quot;Types are not compatible: &quot; + superType + &quot; vs. &quot; + atype);
211         }
212     }
213 
<a name="37" id="anc37"></a><span class="line-added">214 </span>
215     /**
216      * Get field object after having set up all necessary values.
217      */
218     public Field getField() {
219         final String signature = getSignature();
220         final int name_index = super.getConstantPool().addUtf8(super.getName());
221         final int signature_index = super.getConstantPool().addUtf8(signature);
222         if (value != null) {
223             checkType(super.getType());
224             final int index = addConstant();
225             addAttribute(new ConstantValue(super.getConstantPool().addUtf8(&quot;ConstantValue&quot;), 2, index,
226                     super.getConstantPool().getConstantPool())); // sic
227         }
228         addAnnotationsAsAttribute(super.getConstantPool());
229         return new Field(super.getAccessFlags(), name_index, signature_index, getAttributes(),
230                 super.getConstantPool().getConstantPool()); // sic
231     }
232 
233     private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<a name="38" id="anc38"></a><span class="line-modified">234           final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
235         for (final Attribute attr : attrs) {
236             addAttribute(attr);
237         }
<a name="39" id="anc39"></a><span class="line-modified">238       }</span>
<span class="line-added">239 </span>
240 
241     private int addConstant() {
242         switch (super.getType().getType()) { // sic
243             case Const.T_INT:
244             case Const.T_CHAR:
245             case Const.T_BYTE:
246             case Const.T_BOOLEAN:
247             case Const.T_SHORT:
248                 return super.getConstantPool().addInteger(((Integer) value));
249             case Const.T_FLOAT:
250                 return super.getConstantPool().addFloat(((Float) value));
251             case Const.T_DOUBLE:
252                 return super.getConstantPool().addDouble(((Double) value));
253             case Const.T_LONG:
254                 return super.getConstantPool().addLong(((Long) value));
255             case Const.T_REFERENCE:
256                 return super.getConstantPool().addString((String) value);
257             default:
258                 throw new RuntimeException(&quot;Oops: Unhandled : &quot; + super.getType().getType()); // sic
259         }
260     }
261 
<a name="40" id="anc40"></a><span class="line-added">262 </span>
263     @Override
264     public String getSignature() {
265         return super.getType().getSignature();
266     }
267 
268     private List&lt;FieldObserver&gt; observers;
269 
<a name="41" id="anc41"></a><span class="line-modified">270 </span>
<span class="line-modified">271     /** Add observer for this object.</span>
272      */
<a name="42" id="anc42"></a><span class="line-modified">273     public void addObserver( final FieldObserver o ) {</span>
274         if (observers == null) {
275             observers = new ArrayList&lt;&gt;();
276         }
277         observers.add(o);
278     }
279 
<a name="43" id="anc43"></a><span class="line-modified">280 </span>
<span class="line-modified">281     /** Remove observer for this object.</span>
282      */
<a name="44" id="anc44"></a><span class="line-modified">283     public void removeObserver( final FieldObserver o ) {</span>
284         if (observers != null) {
285             observers.remove(o);
286         }
287     }
288 
<a name="45" id="anc45"></a><span class="line-modified">289 </span>
<span class="line-modified">290     /** Call notify() method on all observers. This method is not called</span>
<span class="line-modified">291      * automatically whenever the state has changed, but has to be</span>
<span class="line-modified">292      * called by the user after he has finished editing the object.</span>
293      */
294     public void update() {
295         if (observers != null) {
<a name="46" id="anc46"></a><span class="line-modified">296             for (final FieldObserver observer : observers ) {</span>
297                 observer.notify(this);
298             }
299         }
300     }
301 
<a name="47" id="anc47"></a><span class="line-added">302 </span>
303     public String getInitValue() {
304         if (value != null) {
305             return value.toString();
306         }
307         return null;
308     }
309 
<a name="48" id="anc48"></a><span class="line-added">310 </span>
311     /**
<a name="49" id="anc49"></a><span class="line-modified">312      * Return string representation close to declaration format,</span>
<span class="line-modified">313      * `public static final short MAX = 100&#39;, e.g..</span>
314      *
315      * @return String representation of field
316      */
317     @Override
318     public final String toString() {
319         String name;
320         String signature;
321         String access; // Short cuts to constant pool
322         access = Utility.accessToString(super.getAccessFlags());
323         access = access.isEmpty() ? &quot;&quot; : (access + &quot; &quot;);
324         signature = super.getType().toString();
325         name = getName();
326         final StringBuilder buf = new StringBuilder(32); // CHECKSTYLE IGNORE MagicNumber
327         buf.append(access).append(signature).append(&quot; &quot;).append(name);
328         final String value = getInitValue();
329         if (value != null) {
330             buf.append(&quot; = &quot;).append(value);
331         }
332         return buf.toString();
333     }
334 
<a name="50" id="anc50"></a><span class="line-modified">335 </span>
<span class="line-modified">336     /** @return deep copy of this field</span>
337      */
<a name="51" id="anc51"></a><span class="line-modified">338     public FieldGen copy( final ConstantPoolGen cp ) {</span>
339         final FieldGen fg = (FieldGen) clone();
340         fg.setConstantPool(cp);
341         return fg;
342     }
343 
<a name="52" id="anc52"></a><span class="line-added">344 </span>
345     /**
346      * @return Comparison strategy object
347      */
348     public static BCELComparator getComparator() {
349         return bcelComparator;
350     }
351 
<a name="53" id="anc53"></a><span class="line-added">352 </span>
353     /**
354      * @param comparator Comparison strategy object
355      */
<a name="54" id="anc54"></a><span class="line-modified">356     public static void setComparator( final BCELComparator comparator ) {</span>
357         bcelComparator = comparator;
358     }
359 
<a name="55" id="anc55"></a><span class="line-added">360 </span>
361     /**
<a name="56" id="anc56"></a><span class="line-modified">362      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">363      * By default two FieldGen objects are said to be equal when</span>
<span class="line-modified">364      * their names and signatures are equal.</span>
365      *
366      * @see java.lang.Object#equals(java.lang.Object)
367      */
368     @Override
<a name="57" id="anc57"></a><span class="line-modified">369     public boolean equals( final Object obj ) {</span>
370         return bcelComparator.equals(this, obj);
371     }
372 
<a name="58" id="anc58"></a><span class="line-added">373 </span>
374     /**
<a name="59" id="anc59"></a><span class="line-modified">375      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">376      * By default return the hashcode of the field&#39;s name XOR signature.</span>
377      *
378      * @see java.lang.Object#hashCode()
379      */
380     @Override
381     public int hashCode() {
382         return bcelComparator.hashCode(this);
383     }
384 }
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
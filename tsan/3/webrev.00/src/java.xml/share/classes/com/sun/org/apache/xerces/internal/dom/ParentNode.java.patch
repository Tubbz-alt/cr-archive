diff a/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ParentNode.java b/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ParentNode.java
--- a/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ParentNode.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ParentNode.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -66,10 +66,11 @@
  * @xerces.internal
  *
  * @author Arnaud  Le Hors, IBM
  * @author Joe Kesselman, IBM
  * @author Andy Clark, IBM
+ * @LastModified: Apr 2019
  */
 public abstract class ParentNode
     extends ChildNode {
 
     /** Serialization version. */
@@ -172,22 +173,20 @@
 
     /**
      * NON-DOM
      * set the ownerDocument of this node and its children
      */
-    void setOwnerDocument(CoreDocumentImpl doc) {
+    protected void setOwnerDocument(CoreDocumentImpl doc) {
         if (needsSyncChildren()) {
             synchronizeChildren();
         }
-       for (ChildNode child = firstChild;
-             child != null; child = child.nextSibling) {
-             child.setOwnerDocument(doc);
-        }
-        /* setting the owner document of self, after it's children makes the
-           data of children available to the new document. */
         super.setOwnerDocument(doc);
         ownerDocument = doc;
+        for (ChildNode child = firstChild;
+        child != null; child = child.nextSibling) {
+            child.setOwnerDocument(doc);
+        }
     }
 
     /**
      * Test whether this node has any children. Convenience shorthand
      * for (Node.getFirstChild()!=null)
@@ -366,20 +365,18 @@
             }
 
             // Prevent cycles in the tree
             // newChild cannot be ancestor of this Node,
             // and actually cannot be this
-            if (ownerDocument.ancestorChecking) {
-                boolean treeSafe = true;
-                for (NodeImpl a = this; treeSafe && a != null; a = a.parentNode())
-                {
-                    treeSafe = newChild != a;
-                }
-                if(!treeSafe) {
-                    throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,
-                                DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "HIERARCHY_REQUEST_ERR", null));
-                }
+            boolean treeSafe = true;
+            for (NodeImpl a = this; treeSafe && a != null; a = a.parentNode())
+            {
+                treeSafe = newChild != a;
+            }
+            if(!treeSafe) {
+                throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,
+                            DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, "HIERARCHY_REQUEST_ERR", null));
             }
         }
 
         // notify document
         ownerDocument.insertingNode(this, replace);
@@ -507,21 +504,24 @@
         ChildNode oldInternal = (ChildNode) oldChild;
 
         // notify document
         ownerDocument.removingNode(this, oldInternal, replace);
 
+        // Save previous sibling for normalization checking.
+        final ChildNode oldPreviousSibling = oldInternal.previousSibling();
+
         // update cached length if we have any
         if (fNodeListCache != null) {
             if (fNodeListCache.fLength != -1) {
                 fNodeListCache.fLength--;
             }
             if (fNodeListCache.fChildIndex != -1) {
                 // if the removed node is the cached node
                 // move the cache to its (soon former) previous sibling
                 if (fNodeListCache.fChild == oldInternal) {
                     fNodeListCache.fChildIndex--;
-                    fNodeListCache.fChild = oldInternal.previousSibling();
+                    fNodeListCache.fChild = oldPreviousSibling;
                 } else {
                     // otherwise just invalidate the cache
                     fNodeListCache.fChildIndex = -1;
                 }
             }
@@ -548,13 +548,10 @@
                 // removing some other child in the middle
                 next.previousSibling = prev;
             }
         }
 
-        // Save previous sibling for normalization checking.
-        ChildNode oldPreviousSibling = oldInternal.previousSibling();
-
         // Remove oldInternal's references to tree
         oldInternal.ownerNode       = ownerDocument;
         oldInternal.isOwned(false);
         oldInternal.nextSibling     = null;
         oldInternal.previousSibling = null;
@@ -622,24 +619,19 @@
         if (child != null) {
             Node next = child.getNextSibling();
             if (next == null) {
                 return hasTextContent(child) ? ((NodeImpl) child).getTextContent() : "";
             }
-            if (fBufferStr == null){
-                fBufferStr = new StringBuffer();
-            }
-            else {
-                fBufferStr.setLength(0);
-            }
-            getTextContent(fBufferStr);
-            return fBufferStr.toString();
+            StringBuilder buf = new StringBuilder();
+            getTextContent(buf);
+            return buf.toString();
         }
         return "";
     }
 
-    // internal method taking a StringBuffer in parameter
-    void getTextContent(StringBuffer buf) throws DOMException {
+    // internal method taking a StringBuilder in parameter
+    void getTextContent(StringBuilder buf) throws DOMException {
         Node child = getFirstChild();
         while (child != null) {
             if (hasTextContent(child)) {
                 ((NodeImpl) child).getTextContent(buf);
             }
@@ -682,10 +674,13 @@
      * @return int
      */
     private int nodeListGetLength() {
 
         if (fNodeListCache == null) {
+            if (needsSyncChildren()) {
+                synchronizeChildren();
+            }
             // get rid of trivial cases
             if (firstChild == null) {
                 return 0;
             }
             if (firstChild == lastChild()) {
@@ -731,10 +726,13 @@
      * @param index int
      */
     private Node nodeListItem(int index) {
 
         if (fNodeListCache == null) {
+            if (needsSyncChildren()) {
+                synchronizeChildren();
+            }
             // get rid of trivial case
             if (firstChild == lastChild()) {
                 return index == 0 ? firstChild : null;
             }
             // otherwise request a cache object
@@ -868,11 +866,11 @@
         // better than another. Performance may vary greatly depending on
         // the implementations involved. This one should work fine for us.
         Node child1 = getFirstChild();
         Node child2 = arg.getFirstChild();
         while (child1 != null && child2 != null) {
-            if (!((NodeImpl) child1).isEqualNode(child2)) {
+            if (!child1.isEqualNode(child2)) {
                 return false;
             }
             child1 = child1.getNextSibling();
             child2 = child2.getNextSibling();
         }
@@ -995,11 +993,11 @@
     //
 
     /** Serialize object. */
     private void writeObject(ObjectOutputStream out) throws IOException {
 
-        // synchronize chilren
+        // synchronize children
         if (needsSyncChildren()) {
             synchronizeChildren();
         }
         // write object
         out.defaultWriteObject();
@@ -1020,11 +1018,11 @@
     } // readObject(ObjectInputStream)
 
     /*
      * a class to store some user data along with its handler
      */
-    protected class UserDataRecord implements Serializable {
+    class UserDataRecord implements Serializable {
         /** Serialization version. */
         private static final long serialVersionUID = 3258126977134310455L;
 
         Object fData;
         UserDataHandler fHandler;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InstructionFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionList.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.Collection;
 23 import java.util.HashMap;
 24 import java.util.HashSet;
 25 import java.util.Map;
 26 import java.util.Set;
 27 
 28 import com.sun.org.apache.bcel.internal.classfile.Utility;
 29 
 30 /**
 31  * Instances of this class give users a handle to the instructions contained in
 32  * an InstructionList. Instruction objects may be used more than once within a
 33  * list, this is useful because it saves memory and may be much faster.
 34  *
<span class="line-modified"> 35  * Within an InstructionList an InstructionHandle object is wrapped around all</span>
<span class="line-modified"> 36  * instructions, i.e., it implements a cell in a doubly-linked list. From the</span>
<span class="line-modified"> 37  * outside only the next and the previous instruction (handle) are accessible.</span>
<span class="line-modified"> 38  * One can traverse the list via an Enumeration returned by</span>

 39  * InstructionList.elements().
 40  *
<span class="line-removed"> 41  * @version $Id: InstructionHandle.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 42  * @see Instruction
 43  * @see BranchHandle
 44  * @see InstructionList

 45  */
 46 public class InstructionHandle {
 47 
 48     private InstructionHandle next;
 49     private InstructionHandle prev;
 50     private Instruction instruction;
 51 
 52     private int i_position = -1; // byte code offset of instruction
 53 
 54     private Set&lt;InstructionTargeter&gt; targeters;
 55     private Map&lt;Object, Object&gt; attributes;
 56 











 57     public final InstructionHandle getNext() {
 58         return next;
 59     }
 60 

 61     public final InstructionHandle getPrev() {
 62         return prev;
 63     }
 64 

 65     public final Instruction getInstruction() {
 66         return instruction;
 67     }
 68 

 69     /**
<span class="line-modified"> 70      * Replace current instruction contained in this handle. Old instruction is</span>
<span class="line-modified"> 71      * disposed using Instruction.dispose().</span>
 72      */
<span class="line-modified"> 73     public void setInstruction(final Instruction i) { // Overridden in BranchHandle TODO could be package-protected?</span>
 74         if (i == null) {
 75             throw new ClassGenException(&quot;Assigning null to handle&quot;);
 76         }
 77         if ((this.getClass() != BranchHandle.class) &amp;&amp; (i instanceof BranchInstruction)) {
 78             throw new ClassGenException(&quot;Assigning branch instruction &quot; + i + &quot; to plain handle&quot;);
 79         }
 80         if (instruction != null) {
 81             instruction.dispose();
 82         }
 83         instruction = i;
 84     }
 85 

 86     /**
<span class="line-modified"> 87      * Temporarily swap the current instruction, without disturbing anything.</span>
<span class="line-modified"> 88      * Meant to be used by a debugger, implementing breakpoints. Current</span>
<span class="line-modified"> 89      * instruction is returned.</span>
 90      * &lt;p&gt;
 91      * Warning: if this is used on a BranchHandle then some methods such as
<span class="line-modified"> 92      * getPosition() will still refer to the original cached instruction,</span>
<span class="line-modified"> 93      * whereas other BH methods may affect the cache and the replacement</span>
<span class="line-removed"> 94      * instruction.</span>
 95      */
 96     // See BCEL-273
 97     // TODO remove this method in any redesign of BCEL
<span class="line-modified"> 98     public Instruction swapInstruction(final Instruction i) {</span>
 99         final Instruction oldInstruction = instruction;
100         instruction = i;
101         return oldInstruction;
102     }
103 
104 
<span class="line-modified">105     /*private*/</span>
<span class="line-removed">106     protected InstructionHandle(final Instruction i) {</span>
107         setInstruction(i);
108     }
109 
<span class="line-modified">110     private static InstructionHandle ih_list = null; // List of reusable handles</span>
<span class="line-removed">111 </span>
<span class="line-removed">112     /**</span>
<span class="line-removed">113      * Factory method.</span>
114      */
<span class="line-modified">115     static InstructionHandle getInstructionHandle(final Instruction i) {</span>
<span class="line-modified">116         if (ih_list == null) {</span>
<span class="line-removed">117             return new InstructionHandle(i);</span>
<span class="line-removed">118         }</span>
<span class="line-removed">119         final InstructionHandle ih = ih_list;</span>
<span class="line-removed">120         ih_list = ih.next;</span>
<span class="line-removed">121         ih.setInstruction(i);</span>
<span class="line-removed">122         return ih;</span>
123     }
124 

125     /**
<span class="line-modified">126      * Called by InstructionList.setPositions when setting the position for</span>
<span class="line-modified">127      * every instruction. In the presence of variable length instructions</span>
<span class="line-modified">128      * `setPositions()&#39; performs multiple passes over the instruction list to</span>
<span class="line-modified">129      * calculate the correct (byte) positions and offsets by calling this</span>
<span class="line-removed">130      * function.</span>
131      *
<span class="line-modified">132      * @param offset additional offset caused by preceding (variable length)</span>
<span class="line-modified">133      * instructions</span>
<span class="line-modified">134      * @param max_offset the maximum offset that may be caused by these</span>
<span class="line-removed">135      * instructions</span>
<span class="line-removed">136      * @return additional offset caused by possible change of this instruction&#39;s</span>
<span class="line-removed">137      * length</span>
138      */
<span class="line-modified">139     protected int updatePosition(final int offset, final int max_offset) {</span>
140         i_position += offset;
141         return 0;
142     }
143 
<span class="line-modified">144     /**</span>
<span class="line-modified">145      * @return the position, i.e., the byte code offset of the contained</span>
<span class="line-modified">146      * instruction. This is accurate only after InstructionList.setPositions()</span>
<span class="line-modified">147      * has been called.</span>
148      */
149     public int getPosition() {
150         return i_position;
151     }
152 
<span class="line-modified">153     /**</span>
<span class="line-modified">154      * Set the position, i.e., the byte code offset of the contained</span>
155      * instruction.
156      */
<span class="line-modified">157     void setPosition(final int pos) {</span>
158         i_position = pos;
159     }
160 
<span class="line-removed">161     /**</span>
<span class="line-removed">162      * Overridden in BranchHandle</span>
<span class="line-removed">163      */</span>
<span class="line-removed">164     protected void addHandle() {</span>
<span class="line-removed">165         next = ih_list;</span>
<span class="line-removed">166         ih_list = this;</span>
<span class="line-removed">167     }</span>
168 
169     /**
<span class="line-modified">170      * Delete contents, i.e., remove user access and make handle reusable.</span>
171      */
172     void dispose() {
173         next = prev = null;
174         instruction.dispose();
175         instruction = null;
176         i_position = -1;
177         attributes = null;
178         removeAllTargeters();
<span class="line-removed">179         addHandle();</span>
180     }
181 
<span class="line-modified">182     /**</span>
<span class="line-modified">183      * Remove all targeters, if any.</span>
184      */
185     public void removeAllTargeters() {
186         if (targeters != null) {
187             targeters.clear();
188         }
189     }
190 

191     /**
192      * Denote this handle isn&#39;t referenced anymore by t.
193      */
<span class="line-modified">194     public void removeTargeter(final InstructionTargeter t) {</span>
195         if (targeters != null) {
196             targeters.remove(t);
197         }
198     }
199 

200     /**
201      * Denote this handle is being referenced by t.
202      */
<span class="line-modified">203     public void addTargeter(final InstructionTargeter t) {</span>
204         if (targeters == null) {
205             targeters = new HashSet&lt;&gt;();
206         }
207         //if(!targeters.contains(t))
208         targeters.add(t);
209     }
210 

211     public boolean hasTargeters() {
212         return (targeters != null) &amp;&amp; (targeters.size() &gt; 0);
213     }
214 

215     /**
216      * @return null, if there are no targeters
217      */
218     public InstructionTargeter[] getTargeters() {
219         if (!hasTargeters()) {
220             return new InstructionTargeter[0];
221         }
222         final InstructionTargeter[] t = new InstructionTargeter[targeters.size()];
223         targeters.toArray(t);
224         return t;
225     }
226 
<span class="line-modified">227     /**</span>
<span class="line-modified">228      * @return a (verbose) string representation of the contained instruction.</span>
229      */
<span class="line-modified">230     public String toString(final boolean verbose) {</span>
231         return Utility.format(i_position, 4, false, &#39; &#39;) + &quot;: &quot; + instruction.toString(verbose);
232     }
233 
<span class="line-modified">234     /**</span>
<span class="line-modified">235      * @return a string representation of the contained instruction.</span>
236      */
237     @Override
238     public String toString() {
239         return toString(true);
240     }
241 
<span class="line-modified">242     /**</span>
<span class="line-modified">243      * Add an attribute to an instruction handle.</span>
244      *
245      * @param key the key object to store/retrieve the attribute
246      * @param attr the attribute to associate with this handle
247      */
<span class="line-modified">248     public void addAttribute(final Object key, final Object attr) {</span>
249         if (attributes == null) {
250             attributes = new HashMap&lt;&gt;(3);
251         }
252         attributes.put(key, attr);
253     }
254 
<span class="line-modified">255     /**</span>
<span class="line-modified">256      * Delete an attribute of an instruction handle.</span>
257      *
258      * @param key the key object to retrieve the attribute
259      */
<span class="line-modified">260     public void removeAttribute(final Object key) {</span>
261         if (attributes != null) {
262             attributes.remove(key);
263         }
264     }
265 
<span class="line-modified">266     /**</span>
<span class="line-modified">267      * Get attribute of an instruction handle.</span>
268      *
269      * @param key the key object to store/retrieve the attribute
270      */
<span class="line-modified">271     public Object getAttribute(final Object key) {</span>
272         if (attributes != null) {
273             return attributes.get(key);
274         }
275         return null;
276     }
277 
<span class="line-modified">278     /**</span>
<span class="line-modified">279      * @return all attributes associated with this handle</span>
280      */
281     public Collection&lt;Object&gt; getAttributes() {
282         if (attributes == null) {
283             attributes = new HashMap&lt;&gt;(3);
284         }
285         return attributes.values();
286     }
287 
<span class="line-modified">288     /**</span>
<span class="line-modified">289      * Convenience method, simply calls accept() on the contained instruction.</span>
290      *
291      * @param v Visitor object
292      */
<span class="line-modified">293     public void accept(final Visitor v) {</span>
294         instruction.accept(v);
295     }
296 

297     /**
298      * @param next the next to set
299      * @ since 6.0
300      */
301     final InstructionHandle setNext(final InstructionHandle next) {
302         this.next = next;
303         return next;
304     }
305 

306     /**
307      * @param prev the prev to set
308      * @ since 6.0
309      */
310     final InstructionHandle setPrev(final InstructionHandle prev) {
311         this.prev = prev;
312         return prev;
313     }
314 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.Collection;
 23 import java.util.HashMap;
 24 import java.util.HashSet;
 25 import java.util.Map;
 26 import java.util.Set;
 27 
 28 import com.sun.org.apache.bcel.internal.classfile.Utility;
 29 
 30 /**
 31  * Instances of this class give users a handle to the instructions contained in
 32  * an InstructionList. Instruction objects may be used more than once within a
 33  * list, this is useful because it saves memory and may be much faster.
 34  *
<span class="line-modified"> 35  * Within an InstructionList an InstructionHandle object is wrapped</span>
<span class="line-modified"> 36  * around all instructions, i.e., it implements a cell in a</span>
<span class="line-modified"> 37  * doubly-linked list. From the outside only the next and the</span>
<span class="line-modified"> 38  * previous instruction (handle) are accessible. One</span>
<span class="line-added"> 39  * can traverse the list via an Enumeration returned by</span>
 40  * InstructionList.elements().
 41  *

 42  * @see Instruction
 43  * @see BranchHandle
 44  * @see InstructionList
<span class="line-added"> 45  * @LastModified: Jan 2020</span>
 46  */
 47 public class InstructionHandle {
 48 
 49     private InstructionHandle next;
 50     private InstructionHandle prev;
 51     private Instruction instruction;
 52 
 53     private int i_position = -1; // byte code offset of instruction
 54 
 55     private Set&lt;InstructionTargeter&gt; targeters;
 56     private Map&lt;Object, Object&gt; attributes;
 57 
<span class="line-added"> 58 </span>
<span class="line-added"> 59     /**</span>
<span class="line-added"> 60      * Does nothing.</span>
<span class="line-added"> 61      *</span>
<span class="line-added"> 62      * @deprecated Does nothing as of 6.3.1.</span>
<span class="line-added"> 63      */</span>
<span class="line-added"> 64     @Deprecated</span>
<span class="line-added"> 65     protected void addHandle() {</span>
<span class="line-added"> 66         // noop</span>
<span class="line-added"> 67     }</span>
<span class="line-added"> 68 </span>
 69     public final InstructionHandle getNext() {
 70         return next;
 71     }
 72 
<span class="line-added"> 73 </span>
 74     public final InstructionHandle getPrev() {
 75         return prev;
 76     }
 77 
<span class="line-added"> 78 </span>
 79     public final Instruction getInstruction() {
 80         return instruction;
 81     }
 82 
<span class="line-added"> 83 </span>
 84     /**
<span class="line-modified"> 85      * Replace current instruction contained in this handle.</span>
<span class="line-modified"> 86      * Old instruction is disposed using Instruction.dispose().</span>
 87      */
<span class="line-modified"> 88     public void setInstruction( final Instruction i ) { // Overridden in BranchHandle TODO could be package-protected?</span>
 89         if (i == null) {
 90             throw new ClassGenException(&quot;Assigning null to handle&quot;);
 91         }
 92         if ((this.getClass() != BranchHandle.class) &amp;&amp; (i instanceof BranchInstruction)) {
 93             throw new ClassGenException(&quot;Assigning branch instruction &quot; + i + &quot; to plain handle&quot;);
 94         }
 95         if (instruction != null) {
 96             instruction.dispose();
 97         }
 98         instruction = i;
 99     }
100 
<span class="line-added">101 </span>
102     /**
<span class="line-modified">103      * Temporarily swap the current instruction, without disturbing</span>
<span class="line-modified">104      * anything. Meant to be used by a debugger, implementing</span>
<span class="line-modified">105      * breakpoints. Current instruction is returned.</span>
106      * &lt;p&gt;
107      * Warning: if this is used on a BranchHandle then some methods such as
<span class="line-modified">108      * getPosition() will still refer to the original cached instruction, whereas</span>
<span class="line-modified">109      * other BH methods may affect the cache and the replacement instruction.</span>

110      */
111     // See BCEL-273
112     // TODO remove this method in any redesign of BCEL
<span class="line-modified">113     public Instruction swapInstruction( final Instruction i ) {</span>
114         final Instruction oldInstruction = instruction;
115         instruction = i;
116         return oldInstruction;
117     }
118 
119 
<span class="line-modified">120     /*private*/protected InstructionHandle(final Instruction i) {</span>

121         setInstruction(i);
122     }
123 
<span class="line-modified">124     /** Factory method.</span>



125      */
<span class="line-modified">126     static InstructionHandle getInstructionHandle( final Instruction i ) {</span>
<span class="line-modified">127         return new InstructionHandle(i);</span>






128     }
129 
<span class="line-added">130 </span>
131     /**
<span class="line-modified">132      * Called by InstructionList.setPositions when setting the position for every</span>
<span class="line-modified">133      * instruction. In the presence of variable length instructions `setPositions()&#39;</span>
<span class="line-modified">134      * performs multiple passes over the instruction list to calculate the</span>
<span class="line-modified">135      * correct (byte) positions and offsets by calling this function.</span>

136      *
<span class="line-modified">137      * @param offset additional offset caused by preceding (variable length) instructions</span>
<span class="line-modified">138      * @param max_offset the maximum offset that may be caused by these instructions</span>
<span class="line-modified">139      * @return additional offset caused by possible change of this instruction&#39;s length</span>



140      */
<span class="line-modified">141     protected int updatePosition( final int offset, final int max_offset ) {</span>
142         i_position += offset;
143         return 0;
144     }
145 
<span class="line-modified">146 </span>
<span class="line-modified">147     /** @return the position, i.e., the byte code offset of the contained</span>
<span class="line-modified">148      * instruction. This is accurate only after</span>
<span class="line-modified">149      * InstructionList.setPositions() has been called.</span>
150      */
151     public int getPosition() {
152         return i_position;
153     }
154 
<span class="line-modified">155 </span>
<span class="line-modified">156     /** Set the position, i.e., the byte code offset of the contained</span>
157      * instruction.
158      */
<span class="line-modified">159     void setPosition( final int pos ) {</span>
160         i_position = pos;
161     }
162 







163 
164     /**
<span class="line-modified">165      * Delete contents, i.e., remove user access.</span>
166      */
167     void dispose() {
168         next = prev = null;
169         instruction.dispose();
170         instruction = null;
171         i_position = -1;
172         attributes = null;
173         removeAllTargeters();

174     }
175 
<span class="line-modified">176 </span>
<span class="line-modified">177     /** Remove all targeters, if any.</span>
178      */
179     public void removeAllTargeters() {
180         if (targeters != null) {
181             targeters.clear();
182         }
183     }
184 
<span class="line-added">185 </span>
186     /**
187      * Denote this handle isn&#39;t referenced anymore by t.
188      */
<span class="line-modified">189     public void removeTargeter( final InstructionTargeter t ) {</span>
190         if (targeters != null) {
191             targeters.remove(t);
192         }
193     }
194 
<span class="line-added">195 </span>
196     /**
197      * Denote this handle is being referenced by t.
198      */
<span class="line-modified">199     public void addTargeter( final InstructionTargeter t ) {</span>
200         if (targeters == null) {
201             targeters = new HashSet&lt;&gt;();
202         }
203         //if(!targeters.contains(t))
204         targeters.add(t);
205     }
206 
<span class="line-added">207 </span>
208     public boolean hasTargeters() {
209         return (targeters != null) &amp;&amp; (targeters.size() &gt; 0);
210     }
211 
<span class="line-added">212 </span>
213     /**
214      * @return null, if there are no targeters
215      */
216     public InstructionTargeter[] getTargeters() {
217         if (!hasTargeters()) {
218             return new InstructionTargeter[0];
219         }
220         final InstructionTargeter[] t = new InstructionTargeter[targeters.size()];
221         targeters.toArray(t);
222         return t;
223     }
224 
<span class="line-modified">225 </span>
<span class="line-modified">226     /** @return a (verbose) string representation of the contained instruction.</span>
227      */
<span class="line-modified">228     public String toString( final boolean verbose ) {</span>
229         return Utility.format(i_position, 4, false, &#39; &#39;) + &quot;: &quot; + instruction.toString(verbose);
230     }
231 
<span class="line-modified">232 </span>
<span class="line-modified">233     /** @return a string representation of the contained instruction.</span>
234      */
235     @Override
236     public String toString() {
237         return toString(true);
238     }
239 
<span class="line-modified">240 </span>
<span class="line-modified">241     /** Add an attribute to an instruction handle.</span>
242      *
243      * @param key the key object to store/retrieve the attribute
244      * @param attr the attribute to associate with this handle
245      */
<span class="line-modified">246     public void addAttribute( final Object key, final Object attr ) {</span>
247         if (attributes == null) {
248             attributes = new HashMap&lt;&gt;(3);
249         }
250         attributes.put(key, attr);
251     }
252 
<span class="line-modified">253 </span>
<span class="line-modified">254     /** Delete an attribute of an instruction handle.</span>
255      *
256      * @param key the key object to retrieve the attribute
257      */
<span class="line-modified">258     public void removeAttribute( final Object key ) {</span>
259         if (attributes != null) {
260             attributes.remove(key);
261         }
262     }
263 
<span class="line-modified">264 </span>
<span class="line-modified">265     /** Get attribute of an instruction handle.</span>
266      *
267      * @param key the key object to store/retrieve the attribute
268      */
<span class="line-modified">269     public Object getAttribute( final Object key ) {</span>
270         if (attributes != null) {
271             return attributes.get(key);
272         }
273         return null;
274     }
275 
<span class="line-modified">276 </span>
<span class="line-modified">277     /** @return all attributes associated with this handle</span>
278      */
279     public Collection&lt;Object&gt; getAttributes() {
280         if (attributes == null) {
281             attributes = new HashMap&lt;&gt;(3);
282         }
283         return attributes.values();
284     }
285 
<span class="line-modified">286 </span>
<span class="line-modified">287     /** Convenience method, simply calls accept() on the contained instruction.</span>
288      *
289      * @param v Visitor object
290      */
<span class="line-modified">291     public void accept( final Visitor v ) {</span>
292         instruction.accept(v);
293     }
294 
<span class="line-added">295 </span>
296     /**
297      * @param next the next to set
298      * @ since 6.0
299      */
300     final InstructionHandle setNext(final InstructionHandle next) {
301         this.next = next;
302         return next;
303     }
304 
<span class="line-added">305 </span>
306     /**
307      * @param prev the prev to set
308      * @ since 6.0
309      */
310     final InstructionHandle setPrev(final InstructionHandle prev) {
311         this.prev = prev;
312         return prev;
313     }
314 }
</pre>
</td>
</tr>
</table>
<center><a href="InstructionFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionList.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDAbstractTraverser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../identity/XPathMatcher.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="XSDComplexTypeTraverser.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDAbstractTraverser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,10 ***</span>
<span class="line-new-header">--- 21,12 ---</span>
  package com.sun.org.apache.xerces.internal.impl.xs.traversers;
  
  import com.sun.org.apache.xerces.internal.impl.dv.InvalidDatatypeValueException;
  import com.sun.org.apache.xerces.internal.impl.dv.XSFacets;
  import com.sun.org.apache.xerces.internal.impl.dv.XSSimpleType;
<span class="line-added">+ import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;</span>
<span class="line-added">+ import com.sun.org.apache.xerces.internal.impl.dv.xs.XSSimpleTypeDecl;</span>
  import com.sun.org.apache.xerces.internal.impl.validation.ValidationState;
  import com.sun.org.apache.xerces.internal.impl.xs.SchemaGrammar;
  import com.sun.org.apache.xerces.internal.impl.xs.SchemaSymbols;
  import com.sun.org.apache.xerces.internal.impl.xs.XSAnnotationImpl;
  import com.sun.org.apache.xerces.internal.impl.xs.XSAttributeGroupDecl;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,10 ***</span>
<span class="line-new-header">--- 42,11 ---</span>
  import com.sun.org.apache.xerces.internal.util.SymbolTable;
  import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
  import com.sun.org.apache.xerces.internal.xni.QName;
  import com.sun.org.apache.xerces.internal.xs.XSAttributeUse;
  import com.sun.org.apache.xerces.internal.xs.XSObjectList;
<span class="line-added">+ import com.sun.org.apache.xerces.internal.xs.XSSimpleTypeDefinition;</span>
  import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
  import java.util.ArrayList;
  import java.util.List;
  import java.util.Locale;
  import org.w3c.dom.Element;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 278,10 ***</span>
<span class="line-new-header">--- 281,11 ---</span>
              fFixedFacets = fixedFacets;
          }
      }
  
      FacetInfo traverseFacets(Element content,
<span class="line-added">+             XSTypeDefinition typeDef,</span>
              XSSimpleType baseValidator,
              XSDocumentInfo schemaDoc) {
  
          short facetsPresent = 0 ;
          short facetsFixed = 0; // facets that have fixed=&quot;true&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,10 ***</span>
<span class="line-new-header">--- 295,13 ---</span>
          XSObjectListImpl enumAnnotations = null;
          XSObjectListImpl patternAnnotations = null;
          List&lt;NamespaceContext&gt; enumNSDecls = hasQName ? new ArrayList&lt;&gt;() : null;
          int currentFacet = 0;
          xsFacets.reset();
<span class="line-added">+         boolean seenPattern = false;</span>
<span class="line-added">+         Element contextNode = (Element)content.getParentNode();</span>
<span class="line-added">+         boolean hasLengthFacet = false, hasMinLengthFacet = false, hasMaxLengthFacet = false;</span>
          while (content != null) {
              // General Attribute Checking
              Object[] attrs = null;
              facet = DOMUtil.getLocalName(content);
              if (facet.equals(SchemaSymbols.ELT_ENUMERATION)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 362,11 ***</span>
                  if (child !=null) {
                      reportSchemaError(&quot;s4s-elt-must-match.1&quot;, new Object[]{&quot;enumeration&quot;, &quot;(annotation?)&quot;, DOMUtil.getLocalName(child)}, child);
                  }
              }
              else if (facet.equals(SchemaSymbols.ELT_PATTERN)) {
<span class="line-removed">-                 facetsPresent |= XSSimpleType.FACET_PATTERN;</span>
                  attrs = fAttrChecker.checkAttributes(content, false, schemaDoc);
                  String patternVal = (String)attrs[XSAttributeChecker.ATTIDX_VALUE];
                  // The facet can&#39;t be used if the value is missing. Ignore
                  // this facet element.
                  if (patternVal == null) {
<span class="line-new-header">--- 369,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 374,10 ***</span>
<span class="line-new-header">--- 380,11 ---</span>
                      fAttrChecker.returnAttrArray (attrs, schemaDoc);
                      content = DOMUtil.getNextSiblingElement(content);
                      continue;
                  }
  
<span class="line-added">+                 seenPattern = true;</span>
                  if (fPattern.length() == 0) {
                      fPattern.append(patternVal);
                  } else {
                      // ---------------------------------------------
                      //datatypes: 5.2.4 pattern: src-multiple-pattern
</pre>
<hr />
<pre>
<span class="line-old-header">*** 475,13 ***</span>
<span class="line-new-header">--- 482,15 ---</span>
                      facetsFixed |= currentFacet;
                  }
                  switch (currentFacet) {
                  case XSSimpleType.FACET_MINLENGTH:
                      xsFacets.minLength = ((XInt)attrs[XSAttributeChecker.ATTIDX_VALUE]).intValue();
<span class="line-added">+                     hasMinLengthFacet = true;</span>
                      break;
                  case XSSimpleType.FACET_MAXLENGTH:
                      xsFacets.maxLength = ((XInt)attrs[XSAttributeChecker.ATTIDX_VALUE]).intValue();
<span class="line-added">+                     hasMaxLengthFacet = true;</span>
                      break;
                  case XSSimpleType.FACET_MAXEXCLUSIVE:
                      xsFacets.maxExclusive = (String)attrs[XSAttributeChecker.ATTIDX_VALUE];
                      break;
                  case XSSimpleType.FACET_MAXINCLUSIVE:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 502,10 ***</span>
<span class="line-new-header">--- 511,11 ---</span>
                  case XSSimpleType.FACET_WHITESPACE:
                      xsFacets.whiteSpace = ((XInt)attrs[XSAttributeChecker.ATTIDX_VALUE]).shortValue();
                      break;
                  case XSSimpleType.FACET_LENGTH:
                      xsFacets.length = ((XInt)attrs[XSAttributeChecker.ATTIDX_VALUE]).intValue();
<span class="line-added">+                     hasLengthFacet = true;</span>
                      break;
                  }
  
                  Element child = DOMUtil.getFirstChildElement( content );
                  XSAnnotationImpl annotation = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 564,20 ***</span>
              facetsPresent |= XSSimpleType.FACET_ENUMERATION;
              xsFacets.enumeration = enumData;
              xsFacets.enumNSDecls = enumNSDecls;
              xsFacets.enumAnnotations = enumAnnotations;
          }
<span class="line-modified">!         if ((facetsPresent &amp; XSSimpleType.FACET_PATTERN) != 0) {</span>
              xsFacets.pattern = fPattern.toString();
              xsFacets.patternAnnotations = patternAnnotations;
          }
  
          fPattern.setLength(0);
  
          return new FacetInfo(xsFacets, content, facetsPresent, facetsFixed);
      }
  
  
      // return whether QName/NOTATION is part of the given type
      private boolean containsQName(XSSimpleType type) {
          if (type.getVariety() == XSSimpleType.VARIETY_ATOMIC) {
              short primitive = type.getPrimitiveKind();
<span class="line-new-header">--- 574,152 ---</span>
              facetsPresent |= XSSimpleType.FACET_ENUMERATION;
              xsFacets.enumeration = enumData;
              xsFacets.enumNSDecls = enumNSDecls;
              xsFacets.enumAnnotations = enumAnnotations;
          }
<span class="line-modified">!         if (seenPattern) {</span>
<span class="line-added">+             facetsPresent |= XSSimpleType.FACET_PATTERN;</span>
              xsFacets.pattern = fPattern.toString();
              xsFacets.patternAnnotations = patternAnnotations;
          }
  
          fPattern.setLength(0);
  
<span class="line-added">+         // check if length, minLength and maxLength facets contradict with enumeration facets.</span>
<span class="line-added">+         // currently considers the case when the baseValidator is a built-in type.</span>
<span class="line-added">+         if (enumData != null) {</span>
<span class="line-added">+            if (hasLengthFacet) {</span>
<span class="line-added">+               checkEnumerationAndLengthInconsistency(baseValidator, enumData, contextNode, getSchemaTypeName(typeDef));</span>
<span class="line-added">+            }</span>
<span class="line-added">+            if (hasMinLengthFacet) {</span>
<span class="line-added">+               checkEnumerationAndMinLengthInconsistency(baseValidator, enumData, contextNode, getSchemaTypeName(typeDef));</span>
<span class="line-added">+            }</span>
<span class="line-added">+            if (hasMaxLengthFacet) {</span>
<span class="line-added">+               checkEnumerationAndMaxLengthInconsistency(baseValidator, enumData, contextNode, getSchemaTypeName(typeDef));</span>
<span class="line-added">+            }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          return new FacetInfo(xsFacets, content, facetsPresent, facetsFixed);
      }
  
<span class="line-added">+     /*</span>
<span class="line-added">+      * Get name of an XSD type definition as a string value (which will typically be the value of &quot;name&quot; attribute of a</span>
<span class="line-added">+      * type definition, or an internal name determined by the validator for anonymous types).</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static String getSchemaTypeName(XSTypeDefinition typeDefn) {</span>
<span class="line-added">+ </span>
<span class="line-added">+         String typeNameStr = &quot;&quot;;</span>
<span class="line-added">+         if (typeDefn instanceof XSSimpleTypeDefinition) {</span>
<span class="line-added">+             typeNameStr = ((XSSimpleTypeDecl) typeDefn).getTypeName();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             typeNameStr = ((XSComplexTypeDecl) typeDefn).getTypeName();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return typeNameStr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     } // getSchemaTypeName</span>
<span class="line-added">+ </span>
<span class="line-added">+     /*</span>
<span class="line-added">+      * Check whether values of xs:maxLength and xs:enumeration are consistent. Report a warning message if they are not.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void checkEnumerationAndMaxLengthInconsistency(XSSimpleType baseValidator, List&lt;String&gt; enumData, Element contextNode, String typeName) {</span>
<span class="line-added">+         if (SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(baseValidator.getNamespace()) &amp;&amp;</span>
<span class="line-added">+             SchemaSymbols.ATTVAL_HEXBINARY.equals(baseValidator.getName())) {</span>
<span class="line-added">+             for (int enumIdx = 0; enumIdx &lt; enumData.size(); enumIdx++) {</span>
<span class="line-added">+                 String enumVal = (enumData.get(enumIdx));</span>
<span class="line-added">+                 if (enumVal.length() / 2 &gt; xsFacets.maxLength) {</span>
<span class="line-added">+                     reportSchemaWarning(&quot;FacetsContradict&quot;, new Object[]{enumVal, SchemaSymbols.ELT_MAXLENGTH, typeName}, contextNode);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         else if (SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(baseValidator.getNamespace()) &amp;&amp;</span>
<span class="line-added">+                  SchemaSymbols.ATTVAL_BASE64BINARY.equals(baseValidator.getName())) {</span>
<span class="line-added">+             for (int enumIdx = 0; enumIdx &lt; enumData.size(); enumIdx++) {</span>
<span class="line-added">+                 String enumVal = (enumData.get(enumIdx));</span>
<span class="line-added">+                 byte[] decodedVal = Base64.decode(enumVal);</span>
<span class="line-added">+                 if (decodedVal != null &amp;&amp; (new String(decodedVal)).length() &gt; xsFacets.maxLength) {</span>
<span class="line-added">+                    reportSchemaWarning(&quot;FacetsContradict&quot;, new Object[]{enumVal, SchemaSymbols.ELT_MAXLENGTH, typeName}, contextNode);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             for (int enumIdx = 0; enumIdx &lt; enumData.size(); enumIdx++) {</span>
<span class="line-added">+                 String enumVal = (enumData.get(enumIdx));</span>
<span class="line-added">+                 if (enumVal.length() &gt; xsFacets.maxLength) {</span>
<span class="line-added">+                     reportSchemaWarning(&quot;FacetsContradict&quot;, new Object[]{enumVal, SchemaSymbols.ELT_MAXLENGTH, typeName}, contextNode);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } // checkEnumerationAndMaxLengthInconsistency</span>
<span class="line-added">+ </span>
<span class="line-added">+     /*</span>
<span class="line-added">+      * Check whether values of xs:minLength and xs:enumeration are consistent. Report a warning message if they are not.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void checkEnumerationAndMinLengthInconsistency(XSSimpleType baseValidator, List&lt;String&gt; enumData, Element contextNode, String typeName) {</span>
<span class="line-added">+         if (SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(baseValidator.getNamespace()) &amp;&amp;</span>
<span class="line-added">+             SchemaSymbols.ATTVAL_HEXBINARY.equals(baseValidator.getName())) {</span>
<span class="line-added">+             for (int enumIdx = 0; enumIdx &lt; enumData.size(); enumIdx++) {</span>
<span class="line-added">+                 String enumVal = (enumData.get(enumIdx));</span>
<span class="line-added">+                 if (enumVal.length() / 2 &lt; xsFacets.minLength) {</span>
<span class="line-added">+                     reportSchemaWarning(&quot;FacetsContradict&quot;, new Object[]{enumVal, SchemaSymbols.ELT_MINLENGTH, typeName}, contextNode);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         else if (SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(baseValidator.getNamespace()) &amp;&amp;</span>
<span class="line-added">+                  SchemaSymbols.ATTVAL_BASE64BINARY.equals(baseValidator.getName())) {</span>
<span class="line-added">+             for (int enumIdx = 0; enumIdx &lt; enumData.size(); enumIdx++) {</span>
<span class="line-added">+                 String enumVal = (enumData.get(enumIdx));</span>
<span class="line-added">+                 byte[] decodedVal = Base64.decode(enumVal);</span>
<span class="line-added">+                 if (decodedVal != null &amp;&amp; (new String(decodedVal)).length() &lt; xsFacets.minLength) {</span>
<span class="line-added">+                    reportSchemaWarning(&quot;FacetsContradict&quot;, new Object[]{enumVal, SchemaSymbols.ELT_MINLENGTH, typeName}, contextNode);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             for (int enumIdx = 0; enumIdx &lt; enumData.size(); enumIdx++) {</span>
<span class="line-added">+                 String enumVal = (enumData.get(enumIdx));</span>
<span class="line-added">+                 if (enumVal.length() &lt; xsFacets.minLength) {</span>
<span class="line-added">+                     reportSchemaWarning(&quot;FacetsContradict&quot;, new Object[]{enumVal, SchemaSymbols.ELT_MINLENGTH, typeName}, contextNode);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } // checkEnumerationAndMinLengthInconsistency</span>
<span class="line-added">+ </span>
<span class="line-added">+     /*</span>
<span class="line-added">+      * Check whether values of xs:length and xs:enumeration are consistent. Report a warning message if they are not.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void checkEnumerationAndLengthInconsistency(XSSimpleType baseValidator, List&lt;String&gt; enumData, Element contextNode, String typeName) {</span>
<span class="line-added">+         if (SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(baseValidator.getNamespace()) &amp;&amp;</span>
<span class="line-added">+             SchemaSymbols.ATTVAL_HEXBINARY.equals(baseValidator.getName())) {</span>
<span class="line-added">+             for (int enumIdx = 0; enumIdx &lt; enumData.size(); enumIdx++) {</span>
<span class="line-added">+                 String enumVal = (enumData.get(enumIdx));</span>
<span class="line-added">+                 if (enumVal.length() / 2 != xsFacets.length) {</span>
<span class="line-added">+                     reportSchemaWarning(&quot;FacetsContradict&quot;, new Object[]{enumVal, SchemaSymbols.ELT_LENGTH, typeName}, contextNode);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         else if (SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(baseValidator.getNamespace()) &amp;&amp;</span>
<span class="line-added">+                  SchemaSymbols.ATTVAL_BASE64BINARY.equals(baseValidator.getName())) {</span>
<span class="line-added">+             for (int enumIdx = 0; enumIdx &lt; enumData.size(); enumIdx++) {</span>
<span class="line-added">+                 String enumVal = (enumData.get(enumIdx));</span>
<span class="line-added">+                 byte[] decodedVal = Base64.decode(enumVal);</span>
<span class="line-added">+                 if (decodedVal != null &amp;&amp; (new String(decodedVal)).length() != xsFacets.length) {</span>
<span class="line-added">+                    reportSchemaWarning(&quot;FacetsContradict&quot;, new Object[]{enumVal, SchemaSymbols.ELT_LENGTH, typeName}, contextNode);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             for (int enumIdx = 0; enumIdx &lt; enumData.size(); enumIdx++) {</span>
<span class="line-added">+                 String enumVal = (enumData.get(enumIdx));</span>
<span class="line-added">+                 if (enumVal.length() != xsFacets.length) {</span>
<span class="line-added">+                     reportSchemaWarning(&quot;FacetsContradict&quot;, new Object[]{enumVal, SchemaSymbols.ELT_LENGTH, typeName}, contextNode);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } // checkEnumerationAndLengthInconsistency</span>
<span class="line-added">+ </span>
  
      // return whether QName/NOTATION is part of the given type
      private boolean containsQName(XSSimpleType type) {
          if (type.getVariety() == XSSimpleType.VARIETY_ATOMIC) {
              short primitive = type.getPrimitiveKind();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 722,10 ***</span>
<span class="line-new-header">--- 864,14 ---</span>
  
      void reportSchemaError (String key, Object[] args, Element ele) {
          fSchemaHandler.reportSchemaError(key, args, ele);
      }
  
<span class="line-added">+     void reportSchemaWarning (String key, Object[] args, Element ele) {</span>
<span class="line-added">+         fSchemaHandler.reportSchemaWarning(key, args, ele);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Element/Attribute traversers call this method to check whether
       * the type is NOTATION without enumeration facet
       */
      void checkNotationType(String refName, XSTypeDefinition typeDecl, Element elem) {
</pre>
<center><a href="../identity/XPathMatcher.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="XSDComplexTypeTraverser.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>